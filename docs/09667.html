<html>
<head>
<title>PyPy: compliant, flexible and fast implementation of Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyPy:Python的遵从性、灵活性和快速实现</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/pypy-compliant-flexible-and-fast-implementation-of-python-4fc1377e6375?source=collection_archive---------14-----------------------#2021-08-31">https://levelup.gitconnected.com/pypy-compliant-flexible-and-fast-implementation-of-python-4fc1377e6375?source=collection_archive---------14-----------------------#2021-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ff35" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">运行相同的Python脚本甚至要快数百倍，无需付出任何努力。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e322f9b7a5d060118ecc53de6898e2c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZOsz1oZM4Fysavxh"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@kellisa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里萨·伯纳德</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2641" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为软件开发人员，痴迷于代码性能和效率是典型的。假设您有一个Python脚本来完成某项工作，但您确信它太慢了，您可以做得更好。您使用了正确的数据结构，算法是最佳的，并且您已经应用了所有关于Python性能调优的技巧。不过，这太慢了。</p><p id="edb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">突然之间，你发现了一个名为<a class="ae kv" href="https://www.pypy.org/" rel="noopener ugc nofollow" target="_blank"> PyPy </a>的工具，它的目标是让你的Python代码运行速度快上百倍。你没有什么可失去的，所以你为什么不试一试呢？</p><p id="37fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将向您展示什么是PyPy，以及它的主要特性。</p><blockquote class="ls"><p id="fb01" class="lt lu iq bd lv lw lx ly lz ma mb lr dk translated">如果希望代码运行得更快，可能只需要使用PyPy。</p><p id="70b9" class="lt lu iq bd lv lw lx ly lz ma mb lr dk translated">吉多·范·罗苏姆(Python的创造者)</p></blockquote><h1 id="12b7" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">默认Python实现的工作原理</h1><p id="2880" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">在讨论什么是PyPy以及它如何设法加快Python代码的执行速度之前，我们先来讨论一下“默认Python”是如何工作的。</p><p id="9491" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大家可能已经知道，Python是一个接口。与每个接口一样，存在不同的实现。Python实现的几个例子是<a class="ae kv" href="https://en.wikipedia.org/wiki/CPython" rel="noopener ugc nofollow" target="_blank"> CPython </a>(用C语言编写)<a class="ae kv" href="https://www.jython.org/" rel="noopener ugc nofollow" target="_blank"> Jython </a>(用Java编写)和<a class="ae kv" href="https://ironpython.net/" rel="noopener ugc nofollow" target="_blank"> IronPython </a>(用C#编写)。Python的缺省实现(也是最广泛使用的实现)是<strong class="ky ir"> CPython </strong>。</p><p id="b196" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，当您使用CPython运行Python脚本时会发生什么呢？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/c5a273748f4eecfd374c6f8c3d3f6e86.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*wu1xEFrtP7ZWD15Kye5veA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">作者形象</figcaption></figure><p id="d26c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，Python文件被编译为字节码文件。pyc扩展。然后，使用CPython解释器，在虚拟机中执行字节码。虚拟环境是Python跨平台的部分原因。可以将在Windows计算机上编译的. pyc文件运行到Mac环境中，因为。pyc文件与体系结构无关。不过，一定要使用相同的Python版本。</p><h1 id="96d2" class="mc md iq bd me mf mg mh mi mj mk ml mm jw na jx mo jz nb ka mq kc nc kd ms mt bi translated">PyPy价值主张</h1><p id="8ff5" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">我们希望确保PyPy确实值得安装，因为我们的时间非常宝贵。那么，PyPy的主要特点是什么呢？我们为什么要使用它？</p><p id="6146" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不会在这里列出在官方网站上发布的使用PyPy的好处，我会写下我最看重的东西。</p><p id="171e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，有三个好处:</p><ul class=""><li id="54f0" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">速度</li><li id="e68e" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">无堆栈</li><li id="ab7c" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">易用性</li></ul><p id="71a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们快速回顾一下它们。</p><h2 id="596e" class="nr md iq bd me ns nt dn mi nu nv dp mm lf nw nx mo lj ny nz mq ln oa ob ms oc bi translated">特点1:速度</h2><p id="216f" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">PyPy比CPython更快的原因很简单:PyPy有一个不同的设计，一个更好的实现，并带有一个<strong class="ky ir"> JIT </strong>(实时)编译器。</p><p id="5416" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不涉及太多细节，PyPy有两个部分:</p><ol class=""><li id="deb4" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr od nj nk nl bi translated"><strong class="ky ir">解释器</strong>，用Python的子集RPython编写</li><li id="f75e" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr od nj nk nl bi translated"><strong class="ky ir">翻译工具链</strong>，它将RPython代码编译成C</li></ol><p id="d35f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解释器是一个普通的Python解释器。使用翻译工具链将它翻译成C，在这个过程中，会自动添加垃圾收集器(GC)和JIT编译器。JIT编译器通常允许Python程序运行得更快，因为它不是在执行之前翻译和优化字节码，而是在运行时翻译和优化代码。值得注意的是，PyPy在处理运行纯Python代码的长时间运行的程序时表现出色，因为对于短进程，JIT编译器甚至没有时间正确启动。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/1eb1af516cc9c79cb9362b20f1894cd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QfJ1CjN79eTrkjgKGlvXlw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://speed.pypy.org/" rel="noopener ugc nofollow" target="_blank">https://speed.pypy.org/</a></figcaption></figure><p id="877e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如PyPy的速度中心所述，速度的提高很大程度上取决于正在执行的任务类型。所有基准的几何平均值比CPython快0.22或<strong class="ky ir"> 4.5 </strong>倍<em class="of">。</em></p><h2 id="9ac9" class="nr md iq bd me ns nt dn mi nu nv dp mm lf nw nx mo lj ny nz mq ln oa ob ms oc bi translated">功能2:无堆叠</h2><blockquote class="og oh oi"><p id="9987" class="kw kx of ky b kz la jr lb lc ld ju le oj lg lh li ok lk ll lm ol lo lp lq lr ij bi translated">递归错误:超过了最大递归深度</p></blockquote><p id="da88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您在生活中使用过递归算法，您几乎肯定会遇到上述递归错误。发生此错误的原因是您的函数被调用了太多次，并且由于函数调用被安排在堆栈上，如果堆栈已满，它将无法再处理函数调用。换句话说，标准Python中的递归受到C堆栈大小的限制。通过使用<a class="ae kv" href="https://wiki.python.org/moin/StacklessPython" rel="noopener ugc nofollow" target="_blank">stacklespython</a>，函数调用被存储在堆中，通常堆的大小要大得多。</p><p id="eb5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这不是重点。StacklessPython实现了<strong class="ky ir">小线程</strong>。</p><p id="af49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">小任务是在单个Python线程中运行的微小任务。它们重量轻，便于携带。您可以运行数以千计的线程，而不用担心使用单独的线程或进程带来的开销。</p><h2 id="e3a7" class="nr md iq bd me ns nt dn mi nu nv dp mm lf nw nx mo lj ny nz mq ln oa ob ms oc bi translated">特点3:简单，非常好用！</h2><p id="a96b" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">你下载PyPy，你就可以开始了。没有特殊的配置或手动工作要做。</p><p id="63d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想在不接触源代码的情况下优化Python代码，PyPy是一个不错的选择。为了给你带来一个具有相同目标的不同工具的例子，Cython是编译成c的Python的超集，它的目的是以c的速度运行Python代码，例如，你拿一个在标准Python中很慢的函数来编译它。然后，像普通的Python代码片段一样导入它。但是，要使用Cython，您必须手动检查您的代码并相应地修改它(例如，通过添加类型)。不完全是一个无痛的解决方案。</p><h1 id="56fc" class="mc md iq bd me mf mg mh mi mj mk ml mm jw na jx mo jz nb ka mq kc nc kd ms mt bi translated">结论</h1><p id="6979" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">我最近发现了PyPy，它给Python代码带来的巨大性能优势让我非常惊讶。</p><p id="5463" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">PyPy是优化Python代码的一种便捷方式，但是请记住，它也有一些限制。它不是一个神奇的工具，可以加速一切，所以一定要检查它的用法是否符合你的需要。</p><p id="a270" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢这篇文章，如果你发现有什么不对的地方，请在评论中补充。</p><p id="4d88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">谢谢😉</p></div><div class="ab cl om on hu oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ij ik il im in"><h1 id="cb5b" class="mc md iq bd me mf ot mh mi mj ou ml mm jw ov jx mo jz ow ka mq kc ox kd ms mt bi translated">参考</h1><p id="86af" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">[1]: PyPy文档、目标和架构概述。<a class="ae kv" href="https://doc.pypy.org/en/latest/architecture.html" rel="noopener ugc nofollow" target="_blank">https://doc.pypy.org/en/latest/architecture.html</a></p><p id="348e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2]: PyPy官网。https://www.pypy.org/index.html<a class="ae kv" href="https://www.pypy.org/index.html" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>