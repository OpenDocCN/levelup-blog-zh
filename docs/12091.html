<html>
<head>
<title>Reusable code with React hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有React挂钩的可重用代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-hooks-fed5502ca894?source=collection_archive---------4-----------------------#2022-05-14">https://levelup.gitconnected.com/react-hooks-fed5502ca894?source=collection_archive---------4-----------------------#2022-05-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0f9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用正确的钩子提高可重用性</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/891cfcd7b621aa38bbb775041acd6b3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M0NZIWptkM-JOh2k"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@bamagal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"/>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的“我的镜头人生”</figcaption></figure><p id="569f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你还记得在React 16.8.0之前，组件生命周期在<code class="fe lc ld le lf b">componentDidMount</code>、<code class="fe lc ld le lf b">componentDidUpdate</code>和<code class="fe lc ld le lf b">componentWillUnmount</code>中是如何处理的。每个生命周期方法通常包含不相关的逻辑，而相互关联的逻辑被分离。这通常会导致复杂的组件难以重用，并且容易出现错误和不一致。</p><p id="c89a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在React 16.8.0中发布了hooks来改善许多React开发者面临的这些日常问题。</p><blockquote class="lg lh li"><p id="6af7" class="jn jo lj jp b jq jr js jt ju jv jw jx lk jz ka kb ll kd ke kf lm kh ki kj kk ij bi translated"><strong class="jp ir">钩子允许你根据相关的部分将一个组件分割成更小的功能(比如设置订阅或者获取数据)</strong>，而不是根据生命周期方法强制分割。</p></blockquote></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="d05e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这对于保持关注点的良好分离是非常好的，而且对于保持代码干燥也是非常好的。钩子允许你提取有状态的逻辑，这样它就可以被独立地测试并在其他组件中重用。这使得有状态逻辑不容易出错，并提供了更好的关注点分离。视图变得更加整洁，不再充斥着复杂的逻辑。</p><blockquote class="lg lh li"><p id="8c8f" class="jn jo lj jp b jq jr js jt ju jv jw jx lk jz ka kb ll kd ke kf lm kh ki kj kk ij bi translated">钩子不仅仅意味着通过使用useEffect来代替生命周期方法。</p></blockquote></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="c75b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑下面的例子，我们正在制作一个<code class="fe lc ld le lf b">ArticlePreview</code>组件，就像这样:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lu"><img src="../Images/62b813742c073bb3b25bd79fa1ab0ad4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cLzgB3COWFaNR7MAgYRNwQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">反应组件—文章预览</figcaption></figure><p id="2884" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能会想写类似这样的东西:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="a994" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法的问题是，您的组件中混合了许多有状态逻辑。这使得有状态逻辑很难独立测试，也不可能在其他组件中重用，比如下面的<code class="fe lc ld le lf b">ArticleFull</code>组件:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lx"><img src="../Images/2e4f84b0ce68cd2cf36d151d0296b016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s2GoUa9wid8AJeZ8RJx0ug.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">反应成分—物品全部</figcaption></figure><p id="ffff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以说，更好的方法是创建一个定制钩子<code class="fe lc ld le lf b">useArticle</code>，为<code class="fe lc ld le lf b">ArticlePreview</code>和<code class="fe lc ld le lf b">ArticleFull</code>组件处理可重用的有状态逻辑。一个<code class="fe lc ld le lf b">useArticle</code>钩子可能看起来像这样:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="e693" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并且将有状态逻辑提取到它自己的定制钩子中，视图/组件看起来会像这样:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="a004" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这是一个简单的例子，但是关注点的分离要好得多，因为有状态逻辑被移动到一个可重用的<em class="lj">定制钩子</em>，并且组件更加干净，易于阅读和维护。</p><p id="2093" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，定制钩子是一个干净和可重用代码的好机制！</p></div></div>    
</body>
</html>