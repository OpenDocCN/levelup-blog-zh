<html>
<head>
<title>Reminder: Java For loops can iterate over almost anything</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提醒:Java For loops几乎可以迭代任何东西</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/reminder-java-for-loops-can-iterate-over-almost-anything-17f66f24b371?source=collection_archive---------21-----------------------#2020-12-02">https://levelup.gitconnected.com/reminder-java-for-loops-can-iterate-over-almost-anything-17f66f24b371?source=collection_archive---------21-----------------------#2020-12-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6f711b41120fff48a27d19cdcd5ead3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DSh-PTm7DTtNQgV-"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@maxwbender?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Max Bender </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="0a7d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有一次我居然忘了怎么用Java写For循环。我得去查一下。幸运的是，现在这样的东西很容易找到。典型的例子是这样的:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="6c69" class="ln lo it lj b gy lp lq l lr ls">for (<strong class="lj iu">int i = 1; i &lt; 11; i++</strong>) {<br/>    System.out.println(i);<br/>}</span></pre><p id="57fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这会将数字1到10分别写入控制台的不同行中。</p><p id="09fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然迭代器<code class="fe lt lu lv lj b">i</code>通常会从0而不是1开始，但是它可以从任何其他的<code class="fe lt lu lv lj b">int</code>开始；有些人喜欢使用小于或等于而不是严格小于作为布尔条件，但是你可以在整数上使用任何布尔条件；而且增量不一定是1，可以是任何正整数，也可以是减量，变化甚至不一定是加法，可以是任何<code class="fe lt lu lv lj b">int</code>运算。</p><p id="7f6c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Java语言规范中没有要求迭代器是一个<code class="fe lt lu lv lj b">int</code>。它可以很容易地是任何其他数字基本类型。比如，你可以用<code class="fe lt lu lv lj b">double</code>:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="75a4" class="ln lo it lj b gy lp lq l lr ls">double phi = (1.0 + Math.sqrt(5.0)) / 2;<br/>for (<strong class="lj iu">double phiPower = 1.0;<br/>     phiPower &lt; Double.POSITIVE_INFINITY;<br/>     phiPower *= phi</strong>) {<br/>    System.out.println(phiPower);<br/>}</span></pre><p id="7d09" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">多亏了备受争议的分号，我们可以在多行中整齐地格式化For循环声明。</p><p id="a07e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">初始化在1.0时开始<code class="fe lt lu lv lj b">phiPower</code>；布尔条件是<code class="fe lt lu lv lj b">phiPower</code>小于<code class="fe lt lu lv lj b">Double.POSITIVE_INFINITY</code>(不是实际的无穷大，而是非常特殊的浮点值)；而变化就是<code class="fe lt lu lv lj b">phiPower</code>乘以<code class="fe lt lu lv lj b">phi</code>。</p><p id="cf2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将计算黄金比例的幂(大约1.618)，从1.0开始，然后是黄金比例本身，接着是黄金比例的平方(大约2.618)，立方(大约4.236)，等等，直到大约1.1163 × 10 ⁰⁸.为止</p><p id="7b9a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除此之外，黄金分割比的幂对于64位浮点数来说太大了，以至于无法以任何精度来表示，所以它们会作为“正无穷大”而丢失。</p><p id="457b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Java For循环甚至比我目前描述的更加灵活。迭代器不一定是一个原语，它也可以是一个对象。例如，<code class="fe lt lu lv lj b">java.time</code>包中的日期时间对象。</p><p id="7d4f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">for循环声明的重要之处在于它具有:初始化(典型示例中的<code class="fe lt lu lv lj b">int i = 1</code>)；最初为真但最终将变为假的布尔条件(<code class="fe lt lu lv lj b">i &lt; 11</code>)；以及最终使布尔条件为假的增量或减量(<code class="fe lt lu lv lj b">i++</code>)。</p><p id="050e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实际上，初始化的时候。条件；和更改，这些元素中的任何一个或全部都可能被省略，很可能导致无限循环。</p><p id="a0a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设出于某种原因，我们想知道从2020年2月29日到2096年2月29日的每个闰日是星期几(注意2100年2月28日，不是29日)。</p><p id="8606" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">至于你是想从<code class="fe lt lu lv lj b">java.time</code>和<code class="fe lt lu lv lj b">java.time.format</code>进行一揽子进口还是更有针对性的进口，我由你决定。我们这样设置我们的各种时间对象:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="c656" class="ln lo it lj b gy lp lq l lr ls">DateTimeFormatter formatter = DateTimeFormatter.RFC_1123_DATE_TIME;<br/>LocalDate leapDay2020 = LocalDate.of(2020, 2, 29);<br/>LocalDateTime leapDay2020AtNoon =<br/>        LocalDateTime.of(leapDay2020, LocalTime.NOON);<br/>OffsetDateTime leapDay2020UTC =<br/>        OffsetDateTime.of(leapDay2020AtNoon, ZoneOffset.UTC);<br/>OffsetDateTime notLeapDay2100 = leapDay2020UTC.plusYears(80);</span></pre><p id="5de7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在是For循环:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="3f23" class="ln lo it lj b gy lp lq l lr ls">for (<strong class="lj iu">OffsetDateTime leapDay = leapDay2020UTC;<br/>     leapDay.isBefore(notLeapDay2100);<br/>     leapDay = leapDay.plusYears(4)</strong>) {<br/>       System.out.println(formatter.format(leapDay));<br/>}</span></pre><p id="f660" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个For循环有:将日期时间对象初始化为2020年2月29日，UTC中午；指定日期早于2100年2月28日的布尔条件；以及日期时间对象的四年增量。</p><p id="d688" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们做的一切都正确，我们应该得到以下输出:</p><blockquote class="lw lx ly"><p id="38e9" class="kg kh lz ki b kj kk kl km kn ko kp kq ma ks kt ku mb kw kx ky mc la lb lc ld im bi translated">2020年2月29日星期六12:00:00 GMT<br/>2024年2月29日星期四12:00:00 GMT<br/>2028年2月29日星期二12:00:00 GMT</p><p id="8bf0" class="kg kh lz ki b kj kk kl km kn ko kp kq ma ks kt ku mb kw kx ky mc la lb lc ld im bi translated">…以此类推，直到…</p><p id="d7ca" class="kg kh lz ki b kj kk kl km kn ko kp kq ma ks kt ku mb kw kx ky mc la lb lc ld im bi translated">2096年2月29日星期三12:00:00 GMT</p></blockquote><p id="bd51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我对For循环之前的设置并不完全满意——我会考虑重构建议。也许用lambda更优雅，但这不是这次演示的重点。</p><p id="10c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我相信这也可以用被弃用的<code class="fe lt lu lv lj b">java.util.Date</code>类来实现，但是我不在乎测试这个理论。</p><p id="094b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于循环迭代器来说，日期-时间对象的一个更实际的应用是在工资处理程序的测试套件中。</p><p id="306f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以让测试类构造器设置一个虚构的员工考勤卡，从周一开始，让他们在两周内的每个工作日打卡上下班，领取固定工资，也许还可以在这里或那里添加一些随机的加班时间。</p><p id="f303" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，测试程序检查程序是否正确计算了员工的工作时间和税前工资。</p><p id="1436" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果这些日期-时间对象没有<code class="fe lt lu lv lj b">isBefore()</code>函数，我们可以使用<code class="fe lt lu lv lj b">compareTo()</code>函数，尽管它有点笨拙。我们仍然可以使用没有实现<code class="fe lt lu lv lj b">Comparable&lt;T&gt;</code>接口的类<code class="fe lt lu lv lj b">T</code>的For循环迭代器对象，比如<code class="fe lt lu lv lj b">java.awt.Color</code>。例如，鉴于</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="066c" class="ln lo it lj b gy lp lq l lr ls">Color veryDarkBlue = new Color(16);<br/>System.out.println("&lt;table style=\"color: white\"&gt;");<br/>for (<strong class="lj iu">Color color = veryDarkBlue;<br/>     !color.equals(Color.BLUE);<br/>     color = color.brighter()</strong>) {<br/>     System.out.println("&lt;tr&gt;&lt;td style=\"background-color: #0000"<br/>             + Integer.toString(color.getBlue(), 16) + "\"&gt;"<br/>             + color.toString() + "&lt;/td&gt;&lt;/tr&gt;");<br/>}<br/>System.out.println("&lt;/table&gt;");</span></pre><p id="5298" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将输出放入一个HTML文档中，可能会应用一些CSS填充，您应该会在Web浏览器中看到类似这样的内容:</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi md"><img src="../Images/201df9f75542d77097c032ebb7d3e5fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*a2IXhG_JOYlITWRu_dJvZA.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">从Microsoft Edge 87.0中看到的Java程序生成的HTML文档。表格的第一行显示“java.awt.Color[r=0，g=0，b=16]”，背景看起来基本上是黑色的。表格的最后一行在浅蓝色bckground上显示“java.awt.Color[r=0，g=0，b=254]”。</figcaption></figure><p id="42aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管在这里使用<code class="fe lt lu lv lj b">int</code>迭代器可能更有意义，因为我们只改变了蓝色通道…</p><p id="35d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在许多其他情况下，通常最好将对象放入数组或集合中，然后使用“For Each”循环依次处理对象。这是更现代的Java虚拟机编程语言所采用的方法，比如Scala或Kotlin。</p><p id="00ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很容易将Java中的循环标准视为第一代或第二代编程语言的遗迹。但是它们仍然非常有用，不管是以整数迭代器的典型形式还是以不同的迭代器的形式。</p></div></div>    
</body>
</html>