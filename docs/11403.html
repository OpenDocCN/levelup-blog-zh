<html>
<head>
<title>3 Best Practices for Using Named Arguments in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kotlin中使用命名参数的3个最佳实践</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/3-best-practices-for-using-named-arguments-in-kotlin-e6cd08336bd3?source=collection_archive---------13-----------------------#2022-03-14">https://levelup.gitconnected.com/3-best-practices-for-using-named-arguments-in-kotlin-e6cd08336bd3?source=collection_archive---------13-----------------------#2022-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="a9d1" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">一系列固执己见的科特林编码实践</h2><div class=""/><div class=""><h2 id="9330" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">为什么以及何时使用命名参数</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/6a2aad97efdfb61c11a3ae14c81209c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cV7HqtRQN2slmqdvSdjJzA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</figcaption></figure><p id="cc07" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">命名参数可以提高代码的可读性和安全性。但这是为什么呢？什么时候应该使用命名参数？</p><p id="114e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">本文回答了这些问题以及更多问题。第一部分描述了位置参数的问题，以及命名参数如何解决这些问题。第二部分包含三个关于何时使用命名参数的自以为是的最佳实践。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="e89c" class="mh mi iq bd mj mk ml mm mn mo mp mq mr kf ms kg mt ki mu kj mv kl mw km mx my bi translated">位置论证问题</h1><p id="126f" class="pw-post-body-paragraph le lf iq lg b lh mz ka lj lk na kd lm ln nb lp lq lr nc lt lu lv nd lx ly lz ij bi translated">为了理解什么时候使用命名参数是有帮助的，让我们看一下位置参数的三个问题以及命名参数是如何有帮助的。</p><h2 id="7410" class="ne mi iq bd mj nf ng dn mn nh ni dp mr ln nj nk mt lr nl nm mv lv nn no mx iw bi translated">争论的意思并不总是很清楚</h2><p id="5a91" class="pw-post-body-paragraph le lf iq lg b lh mz ka lj lk na kd lm ln nb lp lq lr nc lt lu lv nd lx ly lz ij bi translated">当看一个函数时，并不总是清楚一个参数是什么意思。让我们以Kotlin标准库的<code class="fe np nq nr ns b"><a class="ae nt" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/windowed.html" rel="noopener ugc nofollow" target="_blank">windowed</a></code>为例。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="89ed" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这两个整数参数是模糊的。除非你以前用过这个功能，否则你不会知道它们是什么意思，即使那样也很难读懂。</p><p id="ff67" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">命名参数通过明确每个参数的含义来提高可读性。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="302d" class="ne mi iq bd mj nf ng dn mn nh ni dp mr ln nj nk mt lr nl nm mv lv nn no mx iw bi translated">很容易混淆相同类型的参数</h2><p id="cb24" class="pw-post-body-paragraph le lf iq lg b lh mz ka lj lk na kd lm ln nb lp lq lr nc lt lu lv nd lx ly lz ij bi translated">前面的例子使用了命名参数来清楚地说明每个参数代表什么。我们可以通过使用命名变量来获得相同的结果:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="a27d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">与命名参数相比，这种方法最大的缺点是很容易意外地交换<code class="fe np nq nr ns b">size</code>和<code class="fe np nq nr ns b">step</code>参数。这正是我在上面的例子中所做的。你注意到了吗？</p><p id="3286" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">由于这些参数属于同一类型，编译器不会抱怨，但是可以肯定这会导致意外的运行时行为。</p><p id="1fc4" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">使用命名参数，您不太可能意外地交换相同类型的参数。</p><h2 id="4e58" class="ne mi iq bd mj nf ng dn mn nh ni dp mr ln nj nk mt lr nl nm mv lv nn no mx iw bi translated">如果参数顺序改变，事情就会变糟</h2><p id="edf1" class="pw-post-body-paragraph le lf iq lg b lh mz ka lj lk na kd lm ln nb lp lq lr nc lt lu lv nd lx ly lz ij bi translated">假设您的代码库中有下面的<code class="fe np nq nr ns b">data class</code>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="727b" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在整个代码库中，有很多不使用命名参数实例化<code class="fe np nq nr ns b">Show</code>对象的地方。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="402b" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如果有人改变了<code class="fe np nq nr ns b">Show</code>参数的顺序，我们必须重构实例化这些对象的所有位置。如果我们使用命名参数来实例化对象，这种重构就没有必要了。</p><p id="666b" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">公平地说，这个例子中的风险很低。由于参数的类型不同，编译时会出现错误。然而，如果我们交换相同类型的参数，就很难确定什么需要重构，这就使得使用命名参数的情况更加明显。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="966b" class="mh mi iq bd mj mk ml mm mn mo mp mq mr kf ms kg mt ki mu kj mv kl mw km mx my bi translated">使用命名参数的最佳实践</h1><p id="a4c2" class="pw-post-body-paragraph le lf iq lg b lh mz ka lj lk na kd lm ln nb lp lq lr nc lt lu lv nd lx ly lz ij bi translated">考虑到上一节中的问题，我们可以定义三种最佳实践:</p><ul class=""><li id="cbb6" class="nw nx iq lg b lh li lk ll ln ny lr nz lv oa lz ob oc od oe bi translated">当不清楚参数的含义时，使用命名参数</li><li id="e0c9" class="nw nx iq lg b lh of lk og ln oh lr oi lv oj lz ob oc od oe bi translated">在构造函数调用中总是使用命名参数</li><li id="f769" class="nw nx iq lg b lh of lk og ln oh lr oi lv oj lz ob oc od oe bi translated">不要混合命名参数和位置参数</li></ul><blockquote class="ok ol om"><p id="d342" class="le lf on lg b lh li ka lj lk ll kd lm oo lo lp lq op ls lt lu oq lw lx ly lz ij bi translated">这些做法只是我坚持己见的建议，绝不应被视为绝对真理。如果你不同意他们的观点，请随时回复。</p></blockquote><h2 id="9238" class="ne mi iq bd mj nf ng dn mn nh ni dp mr ln nj nk mt lr nl nm mv lv nn no mx iw bi translated">当不清楚参数的含义时，使用命名参数</h2><p id="bba7" class="pw-post-body-paragraph le lf iq lg b lh mz ka lj lk na kd lm ln nb lp lq lr nc lt lu lv nd lx ly lz ij bi translated">上一节中的示例展示了当不清楚参数的含义时，命名参数如何提高可读性。这就是为什么我建议使用命名参数，如果参数是模糊的。</p><p id="ec57" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">为像<code class="fe np nq nr ns b">findById</code>这样的方法使用一个命名的参数，它只接受一个<code class="fe np nq nr ns b">Long</code>作为参数，没有任何好处。从方法的名称可以清楚地看出参数的含义。</p><p id="20b0" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">当处理一个从同一类型中取出多个参数的函数时，参数根据定义是模糊的。在这种情况下，请始终使用命名参数。</p><p id="9872" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这些例子是两个极端。确定论点是否足够清楚并不总是容易的。对你来说可能很清楚的东西对你的同事来说可能很模糊，反之亦然。它还取决于对某些功能的体验以及该功能的使用范围。</p><p id="1f07" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">作为一个经验法则:如果您不确定是否应该使用命名参数，您可能应该这样做。</p><h2 id="5129" class="ne mi iq bd mj nf ng dn mn nh ni dp mr ln nj nk mt lr nl nm mv lv nn no mx iw bi translated">在构造函数调用中总是使用命名参数</h2><p id="4f2b" class="pw-post-body-paragraph le lf iq lg b lh mz ka lj lk na kd lm ln nb lp lq lr nc lt lu lv nd lx ly lz ij bi translated">构造函数的参数通常不清楚。可能有很多参数，相同类型的多个参数，默认参数或所有参数的组合。在大多数情况下，在构造函数调用中使用命名参数可以提高可读性。</p><p id="0e16" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">由于大多数构造函数调用受益于命名参数，我的建议是保持一致性，在构造函数调用中总是使用命名参数。</p><h2 id="9b27" class="ne mi iq bd mj nf ng dn mn nh ni dp mr ln nj nk mt lr nl nm mv lv nn no mx iw bi translated">不要混合命名参数和位置参数</h2><p id="caca" class="pw-post-body-paragraph le lf iq lg b lh mz ka lj lk na kd lm ln nb lp lq lr nc lt lu lv nd lx ly lz ij bi translated">Kotlin允许您混合命名参数和位置参数:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="1fe6" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">此示例对第一个和最后一个参数使用命名参数，对中间的参数使用位置参数。</p><p id="019f" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我喜欢一致性。对我来说，混合命名参数和可选参数会降低可读性。这就是为什么我建议不要在一个函数调用中混合命名参数和位置参数。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="a630" class="mh mi iq bd mj mk ml mm mn mo mp mq mr kf ms kg mt ki mu kj mv kl mw km mx my bi translated">天下没有免费的午餐</h1><p id="11c7" class="pw-post-body-paragraph le lf iq lg b lh mz ka lj lk na kd lm ln nb lp lq lr nc lt lu lv nd lx ly lz ij bi translated">没有免费的好东西。命名参数也不例外，因为可读性和安全性的提高是有代价的。</p><h2 id="0977" class="ne mi iq bd mj nf ng dn mn nh ni dp mr ln nj nk mt lr nl nm mv lv nn no mx iw bi translated">命名参数使代码更加冗长</h2><p id="8ccc" class="pw-post-body-paragraph le lf iq lg b lh mz ka lj lk na kd lm ln nb lp lq lr nc lt lu lv nd lx ly lz ij bi translated">不可否认，命名参数会使您的代码更加冗长。这就是为什么只有当命名参数可以提高代码的可读性或安全性时，才应该使用它们。一直使用命名参数会降低代码的信噪比。</p><p id="1fae" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">函数需要的参数越多，命名参数就越多。具有讽刺意味的是，需要大量参数的函数从使用命名参数中获益最多。</p><h2 id="0c4a" class="ne mi iq bd mj nf ng dn mn nh ni dp mr ln nj nk mt lr nl nm mv lv nn no mx iw bi translated">改变参数名成为一个突破性的改变</h2><p id="7cf5" class="pw-post-body-paragraph le lf iq lg b lh mz ka lj lk na kd lm ln nb lp lq lr nc lt lu lv nd lx ly lz ij bi translated">假设您的代码调用了第三方库中的一些函数，并且是通过命名参数来调用的。如果库的作者决定在未来的版本中更改参数名，这意味着您的代码将不再编译。有了位置论点，你就不会有这个问题了。</p><p id="7851" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">因为这些错误总是在编译时出现，所以风险很低，但是因为参数名的改变而不得不重构可能会很烦人。这是你为额外的可读性和安全性付出的代价。对我来说，这是非常值得付出的代价。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><p id="f6d1" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">感谢您的阅读。我希望这有所帮助。如果您有任何问题或反馈，请随时回复。</p></div></div>    
</body>
</html>