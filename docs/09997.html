<html>
<head>
<title>Running Puppeteer with Jest on Github actions for automated testing with coverage.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Github actions上运行带有Jest的Puppeteer进行自动化测试。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/running-puppeteer-with-jest-on-github-actions-for-automated-testing-with-coverage-6cd15bc843b0?source=collection_archive---------2-----------------------#2021-10-12">https://levelup.gitconnected.com/running-puppeteer-with-jest-on-github-actions-for-automated-testing-with-coverage-6cd15bc843b0?source=collection_archive---------2-----------------------#2021-10-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c734" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/puppeteer/puppeteer" rel="noopener ugc nofollow" target="_blank">puppeter</a>是一个为chrome和chrome公开API的库。我将带您了解创建<a class="ae kl" href="https://docs.github.com/en/actions" rel="noopener ugc nofollow" target="_blank"> Github actions </a> (Github的CI/CD管道解决方案)的过程，它可以使用jest运行集成测试，在容器中运行它，并生成覆盖报告。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/3e7cce9b9a9168716a0b6f54cf91e175.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Lfw0k-JQMrFH498wT9q0g.jpeg"/></div></div></figure><p id="93a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里访问Github上的完整项目:<a class="ae kl" href="https://github.com/liron-navon/puppeteer-jest-github-actions-example" rel="noopener ugc nofollow" target="_blank">https://Github . com/liron-navon/puppet eer-jest-Github-actions-example</a>。在这篇文章中，我将回顾它并解释它是如何工作的。</p><h2 id="b71f" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">用jest和木偶师编写一个简单的测试</h2><p id="b845" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">一个测试需要一个测试用例，在这种情况下，我将使用一个简单的HTML文件，其中有一个按钮(id="btn ")和一个计数器(id="counter ")，还有一个JS文件，它只计算按钮被点击的次数并更新计数器。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="ebfd" class="ky kz iq lx b gy mb mc l md me">&lt;body&gt;<br/>  &lt;p&gt;button was clicked: &lt;span id="counter"&gt;0&lt;/span&gt; times&lt;/p&gt;<br/>  &lt;button id="btn"&gt;click me&lt;/button&gt;<br/>  &lt;script src="./index.js" type="text/javascript"&gt;&lt;/script&gt;<br/>&lt;/body&gt;</span></pre><p id="a6b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和index.js文件:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="518f" class="ky kz iq lx b gy mb mc l md me">const btn = document.querySelector('#btn');<br/>const counter = document.querySelector('#counter');</span><span id="5132" class="ky kz iq lx b gy mf mc l md me">btn.addEventListener('click', () =&gt; {<br/>  counter.innerHTML = +counter.textContent + 1;<br/>});</span></pre><p id="169b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试这一点，我创建了一个小的测试文件，我们用jest-puppeter打开一个浏览器，在每次测试之前进入我们的页面，通过选择按钮、单击它并检查计数器来测试文件。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="5352" class="ky kz iq lx b gy mb mc l md me">describe('my first test with jest-puppeteer', () =&gt; {</span><span id="d015" class="ky kz iq lx b gy mf mc l md me">  beforeEach(async () =&gt; {<br/>    await page.goto('http://localhost:9999');<br/>  });</span><span id="b93e" class="ky kz iq lx b gy mf mc l md me">  it('can count', async () =&gt; {<br/>    // refer to the elements we need<br/>    const counter = await page.$('#counter');<br/>    const btn = await page.$('#btn');</span><span id="6cc8" class="ky kz iq lx b gy mf mc l md me">    // before any click we expect 0<br/>    let counterText = await page.evaluate(<br/>          el =&gt; el.textContent, counter<br/>    )<br/>    expect(+counterText).toEqual(0);</span><span id="c85c" class="ky kz iq lx b gy mf mc l md me">    // cick the button<br/>    await btn.click();</span><span id="5008" class="ky kz iq lx b gy mf mc l md me">    // expect counter to increament<br/>    counterText = await page.evaluate(el =&gt; el.textContent, counter)<br/>    expect(+counterText).toEqual(1);<br/>  });<br/>})</span></pre><h2 id="628c" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">配置Jest和木偶师在本地运行</h2><p id="7229" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">现在我们需要运行jest-puppeter，所以我们需要一些开发依赖项，完整的列表在package.json的存储库中，但是主要的是:<br/><a class="ae kl" href="https://github.com/smooth-code/jest-puppeteer" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">jest-puppeter</strong></a><strong class="jp ir"/>——用于在puppeter环境中运行测试。<br/><a class="ae kl" href="https://github.com/ocavue/jest-puppeteer-istanbul" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">jest-puppet er-伊斯坦布尔</strong> </a> —这允许我们创建一个覆盖报告。<br/><a class="ae kl" href="https://github.com/istanbuljs/babel-plugin-istanbul" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">babel-plugin-伊斯坦布尔</strong> </a> —在伊斯坦布尔包装我们的代码，这样我们可以收集覆盖率。<br/><a class="ae kl" href="https://parceljs.org/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">package</strong></a>—将使用babel为我们构建项目，因此我们可以使用伊斯坦布尔，并且还将充当我们的开发服务器，它类似于Webpack，但没有令人厌烦的配置。<br/><a class="ae kl" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">jest</strong></a>——试跑者。</p><p id="4971" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了在浏览器中运行我们的HTML文件，我们可以使用parcel:</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="940a" class="ky kz iq lx b gy mb mc l md me">parcel src/index.html --port 9999</span></pre><p id="bac0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了运行我们的测试和服务器，我在package.json中创建了脚本“npm test”和“npm start”。</p><p id="c5aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们需要添加一个jest.config.js文件，在这里我们定义如何运行测试和产生覆盖率。这里的主要内容是使用jest-puppeteer作为预置来运行使用puppeteer的测试，以及我们从jest-puppet eer-伊斯坦布尔获取的设置/报告器——我们还将生成不同的报告文件，稍后将在管道中使用。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="a5fe" class="ky kz iq lx b gy mb mc l md me">const config = {<br/>  "preset": "jest-puppeteer",<br/>  "collectCoverage": true,<br/>  "collectCoverageFrom": [<br/>    "src/**/*"<br/>  ],<br/>  "coverageReporters": [<br/>    "text",<br/>    "lcov",<br/>    "cobertura"<br/>  ],<br/>  "setupFilesAfterEnv": [<br/>  "jest-puppeteer-istanbul/lib/setup"<br/>  ],<br/>  "reporters": [<br/>    "default",<br/>    "jest-puppeteer-istanbul/lib/reporter"<br/>  ],<br/>  "coverageDirectory": "coverage"<br/>}<br/>module.exports = config;</span></pre><p id="780d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要一个小的。babelrc文件，在这里我们定义了在编译过程中伊斯坦布尔插件的使用。当然，我们不希望这个部分出现在产品中，因为它会产生很多额外的代码，所以我们寻找环境变量，并且只在测试/开发/ci中应用伊斯坦布尔插件。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="c78c" class="ky kz iq lx b gy mb mc l md me">const plugins = [];</span><span id="a463" class="ky kz iq lx b gy mf mc l md me">// when run in the CI enviroonment<br/>const isCI = Boolean(process.env.CI || false);</span><span id="c1a1" class="ky kz iq lx b gy mf mc l md me">// when run locally directly (calling npm start)<br/>const isDevelopment = process.env.NODE_ENV === "development";</span><span id="443f" class="ky kz iq lx b gy mf mc l md me">// when run in test environment by jest (npm test)<br/>const isTest = process.env.NODE_ENV === "test";</span><span id="0bf9" class="ky kz iq lx b gy mf mc l md me">if (isTest || isDevelopment || isCI) {<br/>  plugins.push("istanbul");<br/>}</span><span id="cdd2" class="ky kz iq lx b gy mf mc l md me">module.exports = {<br/>  plugins: plugins<br/>}</span></pre><p id="7143" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们所需要的，您可以在一个终端中运行start，在另一个终端中进行测试，但是在CI环境中这样做并不方便。幸运的是jest-puppeteer允许我们在项目的根目录下设置一个名为jest-puppeteer.config.js的配置文件，它将被库自动获取。</p><p id="00ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们可以定义如何运行我们的服务器，以及jest-puppet er应该寻找哪个端口。如果服务器已经在运行，它就不会运行start命令，这对开发来说非常方便。</p><p id="b237" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ciPipelineOptions将在CI环境中使用，因为我们需要禁用一些chrome优化以使其在Linux的docker环境中运行，并且因为我们的环境有一个稳定的chrome版本，我们可以使用它来代替chrome，当然，我们将以无头模式运行它，因为CI没有屏幕。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="7a71" class="ky kz iq lx b gy mb mc l md me">const ci = Boolean(process.env.CI || false);<br/>const baseOptions = {<br/>  server: {<br/>  command: 'npm run start',<br/>  port: 9999<br/>  }<br/>}<br/>const ciPipelineOptions = {<br/>  launch: {<br/>    executablePath: '/usr/bin/google-chrome-stable',<br/>    headless: true,<br/>    args: [<br/>      '--ignore-certificate-errors',<br/>      '--no-sandbox',<br/>      '--disable-setuid-sandbox',<br/>      '--disable-accelerated-2d-canvas',<br/>      '--disable-gpu'<br/>    ]<br/>  },<br/>server: baseOptions.server<br/>}</span><span id="94fc" class="ky kz iq lx b gy mf mc l md me">module.exports = ci ? ciPipelineOptions : baseOptions;</span></pre><p id="8c0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以运行“npm test”来运行我们的服务器并在本地进行测试，我们将会看到类似这样的消息。这意味着我们所有的文件都被测试和覆盖，如果我们错过了任何测试，jest会让我们知道哪些行没有被覆盖，所以我们可以增加我们的覆盖率。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mh"><img src="../Images/571ffc7e0de609c7fcbd371ee67a1d0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eLz3XclHiriqypDPVe89Fw.png"/></div></div></figure><h2 id="851a" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">准备运行操作</h2><p id="9eaf" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">现在我们已经准备好了，一切都测试过了，让我们谈谈CI管道，GitHub操作要求我们在目录中有管道文件。github/workflows”所以我在工作流中创建了一个tests.yml文件，我们将在其中定义管道，完整的文件在git存储库中，所以我将一部分一部分地讨论它。</p><p id="6215" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们定义了一个名为Tests的工作流，当我们推送到master时，以及当我们从任何分支到master创建一个pull请求时，它就会运行。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="f7ca" class="ky kz iq lx b gy mb mc l md me">name: Tests<br/>on:<br/>  push:<br/>    branches: [ master ]<br/>  pull_request:<br/>    branches: [ master ]</span></pre><p id="0783" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们定义作业，我们需要一个名为CI的作业，我们将在Linux (Ubuntu-20.04)虚拟机(VM)上运行它，但在VM上，我们将运行一个容器，其中包含运行puppeteer所需的所有系统依赖项和一个稳定的chrome浏览器。然后我们将定义CI环境变量，它一直存在于GitHub actions中，但不在容器内部。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="5ff4" class="ky kz iq lx b gy mb mc l md me">jobs:<br/>  ci:<br/>    runs-on: ubuntu-20.04<br/>    container: lironavon/docker-puppeteer-container:14.16.0<br/>    env:<br/>      CI: true<br/>    steps:</span></pre><p id="ae45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前两个步骤不是必需的，但我总是将它们包含在我的构建中，第一个步骤将在容器中设置git——这将允许我们在容器中使用git操作，第二个步骤是缓存步骤，它将缓存我们所有的节点模块以实现更快的管道。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="66f3" class="ky kz iq lx b gy mb mc l md me"># add git to the container and set it up with the token<br/>- name: setup git in container<br/>  uses: actions/checkout@v2<br/>    with:<br/>    token: ${{ secrets.GITHUB_TOKEN }}</span><span id="173c" class="ky kz iq lx b gy mf mc l md me"># cache the dependencies from any node_modules directory<br/>- name: cache dependencies<br/>  uses: actions/cache@v2<br/>  with:<br/>    path: '**/node_modules'<br/>    key: node_modules-${{ hashFiles('**/package-lock.json')}}</span></pre><p id="aede" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来的两步非常简单，我们将在CI模式下安装依赖项，并忽略脚本，还记得我们在jest-puppet er的配置文件中定义的“executablePath”吗？如果我们没有定义它，我们将需要让puppeteer运行一个脚本来下载它自己的chromium浏览器，所以这里我们阻止它这样做，下一步只是运行我们的测试。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="dcc8" class="ky kz iq lx b gy mb mc l md me"># install the dependencies<br/>- name: install dependencies<br/>  run: npm ci --ignore-scripts</span><span id="37d1" class="ky kz iq lx b gy mf mc l md me"># run the tests<br/>- name: test<br/>  run: npm test</span></pre><p id="e6d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在此之前，我们可以简单地推GitHub，GitHub操作应该运行并导致通过管道，如果任何测试失败，管道将失败。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mi"><img src="../Images/61e08295fbc241e95108c41f55014f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ngbLfJlILRG2KXbmrycSpQ.png"/></div></div></figure><p id="b3bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们甚至可以为我们的项目制作一个徽章，通过添加到README文件中来表明测试已经通过</p><p id="ef71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">！[工作流标记](https://github . com/USER _ NAME/REPOSITORY _ NAME/actions/workflows/FILE _ NAME . yml/badge . SVG)</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/b50ed5f4adfa8c743dbf0ee185b5786e.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*idQL9Y1noPTebOi_Ngk2Yg.png"/></div></figure><h2 id="7b20" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">分支保护</h2><p id="17db" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">当然，测试的主要原因是为了确保没有人在推送可能损害我们项目的代码，在Github中，我们可以通过进入设置&gt;分支(1)，设置分支名称模式(2)设置状态检查(3)并选择我们的管道作业(4)来实施分支保护——还记得我们在tests.yml文件中设置了“jobs:ci…”吗？原来如此。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mk"><img src="../Images/be9ae44a5827de7436ed69241ecd35e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tnA6uvZxlW5XZwKBMBcGKg.png"/></div></div></figure><p id="3b9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，当我们创建“拉”请求时，我们将看到一条消息，告诉我们在合并分支之前，CI状态必须通过。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ml"><img src="../Images/d892f3a04fb5ae069649a409bdc57fde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QmwBros0Ss0J7iqRk7-wsQ.png"/></div></div></figure><p id="4573" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将保护我们的分支，所以所有的测试必须在合并前通过，但我们也想测试覆盖率。</p><p id="d395" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">工作流程中的下一步将为我们验证覆盖结果，我们使用<a class="ae kl" href="https://github.com/devmasx/coverage-check-action" rel="noopener ugc nofollow" target="_blank">覆盖率-检查-操作</a>来完成。通过我们从伊斯坦布尔得到的lcov文件，并说在90%的覆盖率下，我们将失败的管道。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="446f" class="ky kz iq lx b gy mb mc l md me"># check coverage<br/>- name: validate coverage<br/>  uses: devmasx/coverage-check-action@v1.2.0<br/>  with:<br/>    type: lcov<br/>    result_path: coverage/lcov.info<br/>    min_coverage: 90<br/>    token: ${{ github.token }}</span></pre><p id="40de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它还会生成一个覆盖率消息，以便我们检查覆盖率。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mm"><img src="../Images/f48f20898722852170eb7ed2bd35df91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KtWfU-JNRuk7oCKN9M_tLg.png"/></div></div></figure><h2 id="f07c" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">添加覆盖徽章</h2><p id="909c" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">最后一步纯粹是添加另一个徽章，这对开源项目来说非常好:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/230a722b6dee127118e656e6d3482934.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*zyFUBma56JobzfvjJmidAQ.png"/></div></figure><p id="739f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们可以使用<a class="ae kl" href="https://github.com/ewjoachim/coverage-comment-action" rel="noopener ugc nofollow" target="_blank"> coverage-comment-action </a>，这需要我们启用<a class="ae kl" href="https://docs.github.com/en/communities/documenting-your-project-with-wikis/about-wikis" rel="noopener ugc nofollow" target="_blank"> GitHub wiki </a>特性，它将存储我们的徽章信息。然后，我们可以根据覆盖率来决定给它什么颜色，因此，在90%以下它将是红色，在90%和100%之间它将是橙色，它必须是100%绿色，当然，您可以根据您的个人使用情形来更改它。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="83f8" class="ky kz iq lx b gy mb mc l md me"># create a badge and make a report of the coverage<br/>- name: display coverage<br/>  uses: ewjoachim/coverage-comment-action@v1<br/>  with:<br/>    GITHUB_TOKEN: ${{ github.token }}<br/>    COVERAGE_FILE: cobertura-coverage.xml<br/>    BADGE_ENABLED: true<br/>    BADGE_FILENAME: coverage-comment-badge.json<br/>    MINIMUM_GREEN: 100<br/>    MINIMUM_ORANGE: 90</span></pre><h2 id="e9c0" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">结论</h2><p id="ed51" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">Jest是一个很棒的测试运行程序，当我们需要自动化浏览器交互时，puppeteer非常棒。一旦你理解了如何使用GitHub动作，它们就非常简单，如果可能的话，你应该在运行测试时检查覆盖率。</p><p id="c5e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请鼓掌并关注，因为我将每隔几周发布一次内容，我真心感谢每一位关注者、拍板者和评论者🙂。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure></div></div>    
</body>
</html>