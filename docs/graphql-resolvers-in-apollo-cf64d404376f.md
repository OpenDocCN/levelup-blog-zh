# Apollo 中的 GraphQL 解析器

> 原文：<https://levelup.gitconnected.com/graphql-resolvers-in-apollo-cf64d404376f>

## 了解 Apollo 服务器中的上下文对象

![](img/50444819889b1443f1def8a8d382c0df.png)

*本文中介绍的所有模式和思想都在*[*https://github.com/TheMagoo73/Apollo-Example*](https://github.com/TheMagoo73/Apollo-Example)*的演示代码中显示。*

esolvers 是创建基于 GraphQL 的服务的关键元素；在解析器中，您将获取和形成您的数据，无论是在简单的情况下直接从数据库获取，还是更有可能从基于微服务的系统中的其他后端服务和 API 获取。在本文中，我们将着眼于创建与 [Apollo framework](https://www.apollographql.com/) 一起使用的解析器，然后特别是它提供的经常被忽略的“上下文”对象，以及我们如何在代码中使用它来提高可测试性，并存储“预调用”状态。

> 在本文中，我们特别关注 Apollo，并使用 apollo-server-express 包。然而，我们在这里看到的对于绝大多数 GraphQL 服务器框架都是有效的。

## 构建解析器

让我们看看一个非常简单的旋变器，了解一下发生了什么。

这里我们定义了一个非常简单的 GraphQL 模式——给定用户名，只需一个查询就可以得到个性化的问候。记住，模式定义了契约，但是我们需要一个解析器通过创建问候并经由 Apollo 框架返回来实际实现查询。

我们可以在`resolvers.Query`文字对象中看到这个解析器。注意，Apollo 为解析器提供了几个参数，`root, args`和`context`。让我们更详细地分析一下。

`root`参数，也称为`parent`，主要用于主从式查询，其中 Apollo 构建了一个解析器链，以构建更复杂的响应。此参数用于将“父级”解析器的结果传递给其子级。在这篇文章中，我们不会触及它的用法。

根据这个例子,`args`参数非常简单明了，它是一个对象，包含模式中为每个解析器定义的参数。

是《阿波罗》中最有趣和最有用的解析器元素之一。默认情况下，在上面的例子中，它将是一个空对象，因为我们还没有定义我们想要它包含什么，Apollo 本身不会添加任何东西。为了创建更好的解析器，我们可以使用该参数向每个解析器传递我们定义的对象，该对象注入解析器可以使用的数据和功能，例如数据访问器。在本文的剩余部分，我们将更详细地研究这个特性。

## 在上下文中注入功能

上下文的一个常见用途是将功能注入解析器，下面是一个简单的例子。在这种情况下，我们创建一个“随机报价”查询；我们需要调用一个 API 并获得一个报价列表，然后从列表中随机抽取一个报价。我们还希望解析器能够记录它在做什么。这个功能是在解析器之外创建的，所以可以很容易地进行单元测试和修改，然后使用上下文将其“注入”到解析器中。

您可以看到注入发生在我们创建 Apollo 服务器的地方；我们创建一个包含数据访问函数的静态上下文对象，以及我们希望解析器使用的记录器。

## 使用上下文和注入进行测试

我们已经看到了使用 context 对象如何允许我们为数据访问之类的事情注入容易测试的单元。但是这种注入也允许我们以一种更加端到端的方式非常容易地测试我们的 GraphQL 模式和解析器。让我们看看如何使用 Mocha 和 Chia 以及上下文来实现这一点。

这个例子测试了我们上面定义的 API，假设我们已经将 resolvers 和 typedefs 重构到单独的文件中(这是一个好的实践)。通过这样做，并将记录器和报价服务的模拟注入到上下文中，我们可以使用`graphql()`方法来执行查询并验证响应，从而测试我们的模式和解析器是否正确绑定。

## 动态语境

到目前为止，我们已经把上下文看作是一个简单的对象，它是我们在创建服务器时设置的。在简单的情况下，这可能是所有需要的。然而，我们可以使用第二个选项来执行更复杂的用例，那就是在我们创建服务器时提供一个功能。然后，Apollo 将为每个请求执行该函数，将返回的对象作为上下文参数传递给每个解析器。

让我们来看看实际情况。一个常见的用例是，我们希望在解析器的请求中使用“authentication”头，例如，确保用户可以访问所请求的资源。这个例子使用了流行的 Express 服务器上的`apollo-server-express`,但是这个原则也适用于其他服务器。

我们可以稍微分解一下这个例子，看看到底发生了什么。

首先，我们构建一个简单的模式，通过一个简单的查询就可以得到个性化的问候。然后，我们为查询设置解析器，该查询返回一个问候，并使用来自上下文对象的用户名完成。但是上下文如何知道每个请求的正确名称呢？

实现这一点的关键是 Apollo 将为每个请求调用的`createConext`方法。该方法从 Apollo 接收一个对象，该对象包含通常会传递给 Express 中间件的`request`和`response`对象。在我们的例子中，我们检查了一个`authorization`头，如果找到了，就调用一个函数(为了简单起见省略了)从令牌中获取用户详细信息并返回一个用户名。我们将它构建到一个返回的对象中——这个对象将作为上下文传递给每个解析器。

最后，当我们创建 Apollo 服务器时，我们将 createContext 方法作为选项中的`context`进行传递。Apollo 将把它看作一个函数而不是一个简单的对象，并将确保它为每个请求执行。

总之，上下文是 GraphQL 服务器框架的一个关键特性，这一点经常被忽略。然而，它为我们提供了许多非常有用的功能，因此在构建 GraphQL API 服务器时，花一些时间来考虑是非常值得的。