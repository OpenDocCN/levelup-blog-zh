<html>
<head>
<title>6 Things To Know When Dockerizing Microsoft .NET Apps in Production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对微软进行分类时要知道的6件事。生产中的网络应用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/6-things-to-know-when-dockerizing-microsoft-net-apps-in-production-45b8c27a41b0?source=collection_archive---------2-----------------------#2021-06-21">https://levelup.gitconnected.com/6-things-to-know-when-dockerizing-microsoft-net-apps-in-production-45b8c27a41b0?source=collection_archive---------2-----------------------#2021-06-21</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="e451" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">运行微软的清单。生产环境中Docker容器中的. NET应用程序</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/3664c00a3264431047f44a78f845ef2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KefUpgflMMiOGSjcNHI12g.jpeg"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">照片由来自<a class="ae kz" href="https://www.pexels.com/photo/black-and-gray-mining-rig-1148820/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的panumas nikhomkhai拍摄</figcaption></figure><p id="9fd0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">许多人喜欢我关于在Docker的生产环境中运行<a class="ae kz" href="https://betterprogramming.pub/docker-for-node-js-in-production-b9dc0e9e48e0" rel="noopener ugc nofollow" target="_blank"> Node.js </a>或<a class="ae kz" href="https://betterprogramming.pub/6-things-to-know-when-dockerizing-python-apps-in-production-f4701b50ca46" rel="noopener ugc nofollow" target="_blank"> Python </a>应用程序的文章。</p><p id="224b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">除了Node.js和Python，我还和Microsoft.NET一起工作。现在，我为Python和Node.js写的大部分东西对. NET也是有效的，但是还是有区别的。本文描述了跑步时的关键事项。Docker容器中的. NET应用程序。</p><p id="1343" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可以在GitHub库中找到所有的例子。</p><h1 id="2cb6" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">1.选择正确的基础图像</h1><p id="652f" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">使用最佳映像来运行您的应用程序至关重要。您应该选择具有应用程序所需的所有功能的最小图像。一个小图像通过网络从Docker注册表快速传输到您的Docker主机。所以你的容器启动更快。</p><p id="6dd0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">与其发展形象，不如一直用<a class="ae kz" href="https://hub.docker.com/_/microsoft-dotnet/" rel="noopener ugc nofollow" target="_blank">官方。NET Docker图片</a>。这些都是微软设计优化的。有两种类型，一种用于开发，另一种用于运行您的应用程序。我们需要后者。</p><p id="dd4c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你看Docker hub，还有很多可能的图像。选择归结为Windows还是Linux？如果可能的话，选择Linux，因为这些图像往往较小。</p><p id="df78" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我真的很喜欢阿尔卑斯山的图像。Alpine是一个带有强化内核的最小Linux发行版。下面，我拉了一些Linux的图片。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj mt"><img src="../Images/c616a8d2a8c63e24171b9f9f39a1529b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U6F_graYsmsE9CCDqjFTIw.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">不同的官员。微软提供的. NET Docker图片</figcaption></figure><p id="e744" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">5.0标签是默认图像，与基于Debian 10的5.0-buster-slim-amd64相同。5.0焦点标签基于Ubuntu 20.04，5.0 Alpine-amd64图像基于Alpine 3.13。</p><p id="2d1b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你看阿尔卑斯版本是最小的。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h1 id="45ac" class="lw lx iu bd ly lz nb mb mc md nc mf mg ka nd kb mi kd ne ke mk kg nf kh mm mn bi translated">2.使用非根容器映像</h1><p id="50d5" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">默认情况下，您的应用程序在容器中以root用户身份运行。容器中的根与主机上的根不同。Docker限制容器中的用户。但是为了减少安全攻击面，您可能希望以非特权用户的身份运行容器。</p><p id="febc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">非根容器增加了一层额外的安全性，推荐用于生产环境。但是，因为他们作为非根用户运行，所以不可能执行特权任务。</p><p id="9bd9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一些官方图片已经创建了一个非root用户，但大多数时候你必须添加它。在docker文件中创建一个具有已知UID和GID的用户，并以这个用户的身份运行您的流程。请参见下面的示例。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">用于在非根容器中运行. NET应用程序的Dockerfile</figcaption></figure><p id="6319" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在第一行，我使用<code class="fe ni nj nk nl b">mcr.microsoft.com/dotnet/runtime:5.0-alpine-amd64</code>作为基本图像。接下来，第5行的语句添加了应用程序用户和组。它将组和用户id设置为1000。</p><p id="930d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第8行的指令为应用程序创建了目录。我将目录的新所有者设置为用户<strong class="lc iv"> app </strong>。</p><p id="eea8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通常情况下，<code class="fe ni nj nk nl b">WORKDIR</code>指令设置工作目录并创建文件夹。但是，没有办法设置目录所有者。所以我手动创建文件夹并设置所有者。</p><p id="341c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我在第12行将用户设置为app用户。<code class="fe ni nj nk nl b">USER</code>指令设置运行映像时的用户名(或UID)。在下一行，我将应用程序的二进制文件复制到工作文件夹。</p><p id="8148" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在最后一行，应用程序开始使用<code class="fe ni nj nk nl b">CMD</code>指令。这提供了执行容器的缺省值。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h1 id="f540" class="lw lx iu bd ly lz nb mb mc md nc mf mg ka nd kb mi kd ne ke mk kg nf kh mm mn bi translated">3.开始和停止您的。网络应用</h1><p id="1660" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">开始和停止你的。NET应用程序中的Docker容器。在之前显示的Dockerfile文件中，我使用<code class="fe ni nj nk nl b">CMD</code>指令启动应用程序。</p><p id="e1f7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当你开始你的。NET app使用exec形式的<code class="fe ni nj nk nl b">CMD</code>指令，确保可以从应用程序内部的操作系统(例如<code class="fe ni nj nk nl b">SIGINT</code>和<code class="fe ni nj nk nl b">SIGTERM</code>)接收信号，并处理它们以优雅地关闭应用程序。</p><p id="86b5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在不同于节点进程，默认情况下. NET应用程序监听这些信号。它使用默认连接的ConsoleLifetime类。</p><p id="1379" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你希望你的应用程序优雅地关闭，你可以处理<code class="fe ni nj nk nl b">SIGINT</code>和<code class="fe ni nj nk nl b">SIGTERM</code>。使用<code class="fe ni nj nk nl b">Console.CancelKeyPress</code>抓住<code class="fe ni nj nk nl b">SIGINT</code>，使用<code class="fe ni nj nk nl b"><em class="nm">AppDomain.CurrentDomain.ProcessExit</em></code>抓住<code class="fe ni nj nk nl b">SIGTERM</code>。下面是一个例子。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">处理来自操作系统的SIGINT和SIGTERM信号</figcaption></figure></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h1 id="ea25" class="lw lx iu bd ly lz nb mb mc md nc mf mg ka nd kb mi kd ne ke mk kg nf kh mm mn bi translated">4.健康检查</h1><p id="170e" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">运行状况检查是一个用于确定正在运行的容器的运行状况的命令。使用Docker文件中的<code class="fe ni nj nk nl b">HEALTH CHECK</code>命令，您可以告诉Docker如何测试容器，看它是否工作。</p><p id="1c64" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">值得注意的是，<code class="fe ni nj nk nl b">HEALTH CHECK</code>命令在Kubernetes集群中不能<strong class="lc iv">而不能</strong>工作，因为它不能处理<code class="fe ni nj nk nl b">HEALTH CHECK</code>命令。</p><p id="0628" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Kubernetes使用探针来检测您的容器是否运行正常。它支持以下三种探测。</p><ul class=""><li id="7595" class="nn no iu lc b ld le lg lh lj np ln nq lr nr lv ns nt nu nv bi translated"><em class="nm">活性探针</em>。这是为了检测应用程序进程是否崩溃。</li><li id="4644" class="nn no iu lc b ld nw lg nx lj ny ln nz lr oa lv ns nt nu nv bi translated"><em class="nm">准备就绪探测器</em>。这是为了检测应用程序是否准备好处理请求。</li><li id="eb48" class="nn no iu lc b ld nw lg nx lj ny ln nz lr oa lv ns nt nu nv bi translated"><em class="nm">启动探针</em>。这在容器启动时使用，表示它准备好了。</li></ul><p id="5b53" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">无论您是创建Docker <code class="fe ni nj nk nl b">HEALTH CHECK</code>还是Kubernetes探测器，都使用HTTP端点来实现它们。如果端点返回成功状态代码，则<code class="fe ni nj nk nl b">HEALTH CHECK</code>或探测成功。</p><p id="bfa5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我将向你展示如何实现Docker <code class="fe ni nj nk nl b">HEALTH CHECK</code>。将其更改为Kubernetes探头应该相对容易。</p><p id="047f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我创建了一个标准的WEB API项目来演示健康检查。这里可以找到<a class="ae kz" href="https://github.com/PatrickKalkman/docker-net/blob/main/health-check/Controllers/HealthCheckController.cs" rel="noopener ugc nofollow" target="_blank">。我添加了一个新的控制器，专门用于接收健康检查请求。</a></p><p id="c32a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在第13行，您可以看到当应用程序在<code class="fe ni nj nk nl b"><a class="ae kz" href="http://localhost/healthcheck." rel="noopener ugc nofollow" target="_blank">http://localhost/healthcheck</a></code> <a class="ae kz" href="http://localhost/healthcheck." rel="noopener ugc nofollow" target="_blank">收到GET请求时执行的动作。您需要实现对您的应用程序健康状况的实际检查。这取决于应用程序的类型。例如，您可以对数据库执行查询并映射结果。</a></p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">添加可以接收HTTP健康检查的独立控制器</figcaption></figure><p id="ea2d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有了这个控制器，我们可以将<code class="fe ni nj nk nl b">HEALTH CHECK</code>命令添加到docker文件中。我们指定，为了执行健康检查，Docker运行时必须执行<code class="fe ni nj nk nl b">curl --fail <a class="ae kz" href="http://localhost/healthcheck." rel="noopener ugc nofollow" target="_blank">http://localhost/healthcheck</a></code> <a class="ae kz" href="http://localhost/healthcheck." rel="noopener ugc nofollow" target="_blank">。</a>如果该命令返回0以外的退出代码，则容器不健康。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">在Dockerfile文件中指定健康检查</figcaption></figure><p id="a028" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">相同的控制器动作可以用作在Kubernetes准备就绪探测中调用的url。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h1 id="fd38" class="lw lx iu bd ly lz nb mb mc md nc mf mg ka nd kb mi kd ne ke mk kg nf kh mm mn bi translated">5.从您的登录。网络应用</h1><p id="ea3f" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">在Docker容器中运行时，从. NET应用程序进行日志记录是很简单的。根据具体情况，记录到stdout或stderr。</p><p id="9f7b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这背后的基本原理是让其他东西来处理日志记录。这是有意义的，因为我们在微服务架构中使用Docker容器，在许多服务之间分配职责。</p><p id="dfd9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我不会推荐用<code class="fe ni nj nk nl b">Console.WriteLine</code>或者<code class="fe ni nj nk nl b">Console.Error.WriteLine</code>。相反，使用内置日志提供程序的标准日志API。请参见下面示例中的第15行。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">使用标准日志api将日志添加到健康控制器</figcaption></figure></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h1 id="2a61" class="lw lx iu bd ly lz nb mb mc md nc mf mg ka nd kb mi kd ne ke mk kg nf kh mm mn bi translated">6.使用环境变量的配置</h1><p id="01ae" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">当你的应用程序在Docker容器中运行时，Docker希望你使用环境变量来配置你的应用程序。</p><p id="2e59" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">谢天谢地。NET 5.0有一些很棒的默认配置选项。当你用<a class="ae kz" href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-new" rel="noopener ugc nofollow" target="_blank"> dotnet new </a>或Visual Studio生成一个新的ASP.NET核心web应用时，它会生成以下代码。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">配置ASP.NET核心应用程序的标准生成代码</figcaption></figure><p id="b4da" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第九行的CreateDefaultBuilder方法按以下顺序提供默认配置。</p><ul class=""><li id="7de8" class="nn no iu lc b ld le lg lh lj np ln nq lr nr lv ns nt nu nv bi translated">使用来自<code class="fe ni nj nk nl b"><a class="ae kz" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-5.0#appsettingsjson" rel="noopener ugc nofollow" target="_blank">appsettings.json</a></code>文件的配置</li><li id="1ed8" class="nn no iu lc b ld nw lg nx lj ny ln nz lr oa lv ns nt nu nv bi translated">使用来自<code class="fe ni nj nk nl b">appsettings.[Environment.json]</code>文件<em class="nm">的配置。</em></li><li id="2fa7" class="nn no iu lc b ld nw lg nx lj ny ln nz lr oa lv ns nt nu nv bi translated">使用环境变量</li><li id="a4bb" class="nn no iu lc b ld nw lg nx lj ny ln nz lr oa lv ns nt nu nv bi translated">使用命令行参数</li></ul><p id="aa6a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在每一步中，您都可以覆盖上一步的设置。这意味着您可以通过环境否决任何设置。例如通过改变记录级别。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ob"><img src="../Images/f9b5310f8d13deaea7938f53945468dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iNGvX_A4EEfJOysXcauimg.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">设置环境变量以覆盖日志记录级别</figcaption></figure><p id="ec22" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请注意，您使用级别之间的双下划线从<code class="fe ni nj nk nl b">appsettings.json</code>指定层次结构。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h1 id="f067" class="lw lx iu bd ly lz nb mb mc md nc mf mg ka nd kb mi kd ne ke mk kg nf kh mm mn bi translated">结论</h1><p id="51d0" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">在这篇文章中，我描述了以下6点来改善运行。生产环境中Docker容器中的. NET应用程序。</p><ul class=""><li id="307d" class="nn no iu lc b ld le lg lh lj np ln nq lr nr lv ns nt nu nv bi translated">为您的容器选择正确的基础映像至关重要。您的映像越小，部署和启动的速度就越快</li><li id="a79b" class="nn no iu lc b ld nw lg nx lj ny ln nz lr oa lv ns nt nu nv bi translated">总是使用非根容器。非根容器增加了一层额外的安全性，推荐用于生产环境。</li><li id="2a73" class="nn no iu lc b ld nw lg nx lj ny ln nz lr oa lv ns nt nu nv bi translated">在应用程序中处理SIGINT和SIGTERM，这样就可以优雅地关闭应用程序。</li><li id="a735" class="nn no iu lc b ld nw lg nx lj ny ln nz lr oa lv ns nt nu nv bi translated">使用健康检查告诉Docker或集群管理器正在运行的容器的状态。</li><li id="8d2b" class="nn no iu lc b ld nw lg nx lj ny ln nz lr oa lv ns nt nu nv bi translated">不要记录到文件或数据库。总是使用stdout和stderr。使用内置日志提供程序的默认日志API。</li><li id="e4e0" class="nn no iu lc b ld nw lg nx lj ny ln nz lr oa lv ns nt nu nv bi translated">默认情况下，一个. NET 5.0应用程序提供了很多功能来配置您的应用程序。您可以通过环境变量覆盖所有设置。</li></ul><p id="d004" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可以在这个Github库中找到所有的例子。</p><p id="4976" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>