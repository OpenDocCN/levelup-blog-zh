<html>
<head>
<title>Why it’s Time to Stop Using JavaScript IIFEs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么是时候停止使用JavaScript了</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-its-time-to-stop-using-javascript-iifes-b62602f25bfc?source=collection_archive---------0-----------------------#2020-03-20">https://levelup.gitconnected.com/why-its-time-to-stop-using-javascript-iifes-b62602f25bfc?source=collection_archive---------0-----------------------#2020-03-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/864800332620e1f6f265b75c32de7ed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UIaNo-0_iSA9ASNT"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@agebarros?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿格巴洛斯</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="4e9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript语言中，IIFE代表立即调用的函数表达式。</p><p id="96cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个被定义然后立即执行的函数。</p><p id="a77f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们将看看为什么是时候停止在我们的代码中写生命了。</p><h1 id="2528" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">我们可以在JavaScript中定义块范围的变量</h1><p id="6188" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">因为ES6是作为标准发布的，所以我们可以用<code class="fe mh mi mj mk b">let</code>和<code class="fe mh mi mj mk b">const</code>声明块范围的变量和常量。它还引入了独立的块，将变量和常量隔离到它们自己的块中，外部无法访问。</p><p id="f842" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ff77" class="mt lf it mk b gy mu mv l mw mx">{<br/>  let x = 1;<br/>}</span></pre><p id="557b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么<code class="fe mh mi mj mk b">x</code>就不会对外公开。</p><p id="6e2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它比:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1006" class="mt lf it mk b gy mu mv l mw mx">(()=&gt;{<br/>  let x = 1;<br/>})();</span></pre><p id="17de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在几乎所有现代浏览器都支持ES6，我们应该停止使用IIFEs来分离变量与外界。</p><p id="2667" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">隔离变量的另一种方法是模块，它也得到广泛的支持。只要我们不导出它们，其他模块就无法使用它们。</p><h1 id="0d8f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">我们不再那么需要闭包了</h1><p id="91f0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">闭包是返回另一个函数的函数。返回的函数可能运行在其外部但在封闭函数内部的代码。</p><p id="0083" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，它可能会产生如下副作用:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="dc70" class="mt lf it mk b gy mu mv l mw mx">const id = (() =&gt; {<br/>  let count = 0;<br/>  return () =&gt; {<br/>    ++count;<br/>    return `id_${count}`;<br/>  };<br/>})();</span></pre><p id="4e51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，现在我们有块和模块来隔离数据，这变得更加复杂和不必要。</p><p id="fa74" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将所有这些放在他们自己的模块中，这样我们就不必担心暴露数据。</p><p id="27b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还会产生副作用，这并不好，因为我们应该尽可能避免产生副作用。这是因为它们使得函数难以测试，因为它们不纯。</p><p id="ebb3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们可以避免嵌套时，返回函数的函数也会引入嵌套，所以它比不返回函数的函数更容易混淆。</p><p id="94d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更好的选择是用一个模块代替它。</p><p id="046c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用模块，我们可以编写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ccbe" class="mt lf it mk b gy mu mv l mw mx">let count = 0;</span><span id="03a0" class="mt lf it mk b gy my mv l mw mx">export const id = () =&gt; {<br/>  ++this.count;<br/>  return `id_${count}`<br/>}</span></pre><p id="fdb7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有相同的<code class="fe mh mi mj mk b">count</code>声明，并且我们导出了<code class="fe mh mi mj mk b">id</code>函数，这样其他模块也可以使用它。</p><p id="9661" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这隐藏了<code class="fe mh mi mj mk b">count</code>并暴露了我们想要的函数，就像生命一样，但是嵌套更少了，我们不必定义另一个函数并运行它。</p><h1 id="42c8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">别名变量</h1><p id="7027" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">同样，我们曾经写过这样的东西:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="dce3" class="mt lf it mk b gy mu mv l mw mx">window.$ = function foo() {<br/>  // ...<br/>};</span><span id="2bf9" class="mt lf it mk b gy my mv l mw mx">(function($) {<br/>  // ...<br/>})(jQuery);</span></pre><p id="ec3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们绝对不应该仅仅为了给变量创建别名而编写生命，因为我们可以使用模块来做到这一点。</p><p id="7033" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了模块，我们可以导入不同名字的东西。</p><p id="99e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天的方法是这样写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6926" class="mt lf it mk b gy mu mv l mw mx">import { $ as jQuery } from "jquery";</span><span id="6412" class="mt lf it mk b gy my mv l mw mx">const $ = () =&gt; {};</span></pre><p id="98d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们不应该给<code class="fe mh mi mj mk b">window</code>对象附加新的属性，因为这会污染全局范围。</p><h1 id="5c1b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">捕获全局对象</h1><p id="bec5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有了<code class="fe mh mi mj mk b">globalThis</code>，我们不必担心不同环境中全局对象的名字，因为它正在成为一种标准。</p><p id="8d80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们不需要通过在顶层编写以下代码来捕获全局对象:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f5ef" class="mt lf it mk b gy mu mv l mw mx">(function(global) {<br/>  // ...<br/>})(this);</span></pre><p id="1216" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">甚至在<code class="fe mh mi mj mk b">globalThis</code>之前，通过编写以下代码来设置全局对象并不太难:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="417b" class="mt lf it mk b gy mu mv l mw mx">const globalObj = self || window || global;</span></pre><p id="5c75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者如果我们想更精确些，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="db44" class="mt lf it mk b gy mu mv l mw mx">const getGlobal = () =&gt; { <br/>  if (typeof self !== 'undefined') { return self; } <br/>  if (typeof window !== 'undefined') { return window; } <br/>  if (typeof global !== 'undefined') { return global; } <br/>  throw new Error('unable to locate global object'); <br/>};</span></pre><p id="1986" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们就不需要添加额外的函数调用和嵌套。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/c5cee6682e02c3aa93e25f691ab03489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eDuuXtQKVoYqCMh3"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@kaylahotto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯拉·奥托</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="8cbd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">缩小优化</h1><p id="7a94" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有了JavaScript模块，我们不再需要将代码与文件分开，这样我们的文件就可以适当地缩小。</p><p id="93f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">网络包、浏览器、包裹、汇总等。，都可以正确地处理模块，所以我们应该使用它们来创建更干净的代码。</p><h1 id="2e77" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="3fa2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">是时候停止在我们的代码中写生命了。它增加了额外的函数定义和嵌套。</p><p id="d53b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，在JavaScript模块被引入和广泛使用之前，这是一个时代错误。2020年，我们应该使用模块和块来分离代码。</p><p id="b4a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">块范围的变量用于防止从模块外部访问变量。</p></div></div>    
</body>
</html>