<html>
<head>
<title>Building a Stack Class in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Java构建堆栈类</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/selfmade-stack-class-in-java-d401dc7d68f0?source=collection_archive---------0-----------------------#2020-02-06">https://levelup.gitconnected.com/selfmade-stack-class-in-java-d401dc7d68f0?source=collection_archive---------0-----------------------#2020-02-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/2f47928faf4847232ee6035e6e891bab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CrarQlCsBB8esRxy1kqxvg.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://www.pexels.com/de-de/foto/backen-backerei-behandeln-bunt-1407346/" rel="noopener ugc nofollow" target="_blank">https://www . pexels . com/de-de/foto/backen-backerei-behandeln-bunt-1407346/</a></figcaption></figure><div class=""/><p id="25a9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">堆栈是编程中的基本数据结构。它的行为就像一个数据容器，新的条目被添加到栈顶，而你只能访问最后添加的条目(最顶端的条目)。</p><p id="b194" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">甲骨文的定义(<a class="ae jd" href="https://docs.oracle.com/javase/7/docs/api/java/util/Stack.html" rel="noopener ugc nofollow" target="_blank">来源</a>)</p><blockquote class="lb lc ld"><p id="3c61" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">Stack类表示对象的后进先出(LIFO)堆栈。提供了常见的push和pop操作，以及一个查看堆栈顶部项目的方法、一个测试堆栈是否为空的方法和一个在堆栈中搜索项目并发现它离顶部有多远的方法。</p></blockquote><p id="60c6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天，我们试图用自己的通用类和接口在Java中重新创建这种数据结构。为了存储不同的数据类型，该类是泛型的。它应该提供以下六种方法:</p><ul class=""><li id="861c" class="li lj jg kf b kg kh kk kl ko lk ks ll kw lm la ln lo lp lq bi translated"><strong class="kf jh">按</strong>(在顶部添加新项目)</li><li id="26cb" class="li lj jg kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated"><strong class="kf jh">弹出</strong>(移除最上面的项目)</li><li id="432d" class="li lj jg kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated"><strong class="kf jh">窥视</strong>(获得最顶端的物品)</li><li id="edcb" class="li lj jg kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated"><strong class="kf jh"> isEmpty </strong>(检查堆栈是否为空)</li><li id="3057" class="li lj jg kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated"><strong class="kf jh">大小</strong>(获取堆栈的大小)</li><li id="36f8" class="li lj jg kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated"><strong class="kf jh">搜索</strong>(搜索对象)</li></ul><h2 id="493e" class="lw lx jg bd ly lz ma dn mb mc md dp me ko mf mg mh ks mi mj mk kw ml mm mn mo bi translated">接口:Stackable.java</h2><p id="baef" class="pw-post-body-paragraph kd ke jg kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">让我们从堆栈的接口开始。该接口指定哪些方法必须在stack类中实现。我们声明我刚才提到的六个方法。</p><p id="0f16" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mu mv mw mx b">&lt;T&gt;</code>构造将接口标记为泛型。在这种情况下,<code class="fe mu mv mw mx b">T</code>可以是任何数据类型。比如<code class="fe mu mv mw mx b">Integer</code>或者<code class="fe mu mv mw mx b">String</code>。</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi my"><img src="../Images/474cf7acf4d7a6db8c75e993a05cf335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UHOQ47THP9iZJKUHZ9hhBg.png"/></div></div></figure></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h2 id="a00c" class="lw lx jg bd ly lz ma dn mb mc md dp me ko mf mg mh ks mi mj mk kw ml mm mn mo bi translated">班级:Stack.java</h2><p id="b245" class="pw-post-body-paragraph kd ke jg kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">接下来，我们创建stack类。这里我们需要两个私有属性:<code class="fe mu mv mw mx b">previous</code>和<code class="fe mu mv mw mx b">value</code>。</p><p id="1f47" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mu mv mw mx b">previous</code>是对在堆栈顺序中位于当前实例之下的项目(底层项目)的引用。这导致了递归实现。</p><p id="1071" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mu mv mw mx b">value</code>属性包含当前堆栈实例存储的值。它可以是任何数据类型。</p><p id="13de" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们稍后还需要多个构造函数。因为这个类是通用的，所以我们在这里也需要<code class="fe mu mv mw mx b">&lt;T&gt;</code>构造。</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi my"><img src="../Images/771985749289b604edba827e38bad852.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uV-ptt6-ZtgQg68VycACAg.png"/></div></div></figure><p id="6e3c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">方法:推</strong></p><p id="cc3e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此方法将一个项推到堆栈的顶部。因此，我们将stack的当前实例设置为前一个实例，并存储新值。</p><p id="df2f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在引用我们的旧堆栈实例。</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi my"><img src="../Images/ca4b0c0fff9ac9d4f44159861a4a98ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q6cJAt_eZKlolRb2Dni0iQ.png"/></div></div></figure><p id="50cb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">方法:弹出</strong></p><p id="8c26" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此方法移除堆栈顶部的项并返回其值。</p><p id="47ee" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们将当前值存储在一个临时变量中，因为它会被覆盖，以后我们需要返回它。</p><p id="a70d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之后，我们将当前的<code class="fe mu mv mw mx b">value</code>设置为来自我们的<code class="fe mu mv mw mx b">previous</code>堆栈项目的值。此外，我们将当前的<code class="fe mu mv mw mx b">previous</code>属性引用到底层项目的<code class="fe mu mv mw mx b">previous</code>项目。</p><p id="25a6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们返回移除的值。</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi my"><img src="../Images/407c8c6645424c7b86ec83713dc4590f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PTQlw5jDduFUHnhzez2buA.png"/></div></div></figure><p id="dd04" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">方法:窥视</strong></p><p id="a4ae" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此方法查看堆栈顶部项目的值并返回它。这里我们只需要返回<code class="fe mu mv mw mx b">this.value</code>。</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi my"><img src="../Images/420a68f6767753bb5defe65f63b2b6e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WcNTRj-S7QU1UvjQPENEpQ.png"/></div></div></figure><p id="f29b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">方法:isEmpty </strong></p><p id="3714" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此方法测试堆栈是否为空。由于最后一个堆栈项目没有引用另一个(底层)项目，我们只需要检查<code class="fe mu mv mw mx b">previous</code>项目是否是<code class="fe mu mv mw mx b">null</code>。</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi my"><img src="../Images/c201fa74e3639097e1b47bae22c2e6a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J4vfJnn6ulr0GXGxPe7oKw.png"/></div></div></figure><p id="6d2b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">方法:尺寸</strong></p><p id="8952" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个方法返回堆栈中的项目数。这里，我们递归地计数，直到到达最后一项。</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi my"><img src="../Images/a5e257980affed59edf6fc29ae762978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jZGtHujTHCaDv3ecxrCh4g.png"/></div></div></figure><p id="b318" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">方法:搜索</strong></p><p id="bca0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此方法返回项在堆栈上从1开始的位置。因此，我们循环遍历所有的堆栈项，并增加一个计数器，直到达到等于目标项的值。最后但同样重要的是，我们返回计数器。</p><p id="fc75" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果不匹配，则返回<code class="fe mu mv mw mx b">-1</code>。</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi my"><img src="../Images/ff415225f1c9507414b034f837607163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WliGeCcqWzFz2btXaH7y7w.png"/></div></div></figure></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h2 id="6d0f" class="lw lx jg bd ly lz ma dn mb mc md dp me ko mf mg mh ks mi mj mk kw ml mm mn mo bi translated">试试吧！</h2><p id="0c34" class="pw-post-body-paragraph kd ke jg kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">让我们创建一个新的stack类实例，并进行测试。</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi my"><img src="../Images/201c1ff399bd5ba431cc03da1df2638a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*72h2oEb_DohpMzXzFxD5cw.png"/></div></div></figure></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="dccf" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！<a class="ae jd" href="https://gist.github.com/larswaechter/5ee39c4b4d874f0280951b6ac5a40ace" rel="noopener ugc nofollow" target="_blank">在这里</a>你可以找到包含完整代码的GitHub Gist。</p></div></div>    
</body>
</html>