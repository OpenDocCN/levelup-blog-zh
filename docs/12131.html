<html>
<head>
<title>Start Testing Your JavaScript Code with Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jest开始测试您的JavaScript代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/start-testing-your-javascript-code-with-jest-81e04f546a3e?source=collection_archive---------6-----------------------#2022-05-17">https://levelup.gitconnected.com/start-testing-your-javascript-code-with-jest-81e04f546a3e?source=collection_archive---------6-----------------------#2022-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/351312138844f63c0f65d20968a46461.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_pUW3r2UaEJkDpzzUF7KDw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">布莱克·康纳利在<a class="ae kc" href="https://unsplash.com/s/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="286a" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">为什么我们要为我们的代码编写测试？</h1><p id="64f9" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当不止一个开发人员积极地对代码库进行修改时，问题和错误就会出现。也很难诊断出是谁提交了错误代码，或者错误的根本原因是什么。因此，在将这些内容引入代码库之前，最好采取预防措施。这可以通过编写测试来完成，可以由单个开发人员在他们的机器上进行本地测试，或者也可以在CI/CD管道中建立自动测试套件，当代码提交发生时就会触发这些测试套件。编写测试的另一个好处是，当我们为应用程序开发功能时，我们倾向于编写更好、更纯粹的功能，因为我们意识到最终必须为它们编写测试。</p><h2 id="7c5e" class="lz ke iq bd kf ma mb dn kj mc md dp kn lm me mf kr lq mg mh kv lu mi mj kz mk bi translated"><strong class="ak"> <em class="ml">不同类型的测试</em> </strong></h2><p id="d1a0" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">有不同类型的测试，这些是最常见的:</p><p id="9e44" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated"><strong class="ld ir">单元测试</strong> <br/>单元测试用于测试源代码的最小单元(比如函数或者方法)。这是最容易实现的，也是各种类型中最常见的测试。</p><p id="3174" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated"><strong class="ld ir">集成测试</strong> <br/>这是为了测试代码库中不同组件或单元之间的交叉通信，例如涉及应用架构不同部分的认证功能。集成测试是在完成单个单元测试的前提下建立的。</p><p id="a7c6" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated"><strong class="ld ir">端到端测试<br/> </strong>端到端测试，顾名思义就是从头到尾测试软件的工作流程。当应用程序变得更大时，这真的很复杂，因此许多公司仍然进行手动测试。这个过程可以从启动浏览器开始，在地址栏中输入web应用程序的URL，这是UI驱动的。然而，也有像Selenium、Cypress和量角器这样的工具来帮助自动化这种端到端的测试，尽管设置起来可能需要相当长的时间。</p><p id="af65" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">有相当多的测试库，为不同的目的和不同的编程语言服务。在本文中，我们将重点测试我们的JavaScript代码。更确切地说，<strong class="ld ir"> Jest </strong>是这篇文章的主角。</p><h1 id="caf9" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">杰斯特:什么，为什么？</h1><p id="8656" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Jest是一个流行的(尤其是对于React库)JavaScript测试库。它提供了各种各样的方法和功能，涵盖了测试过程中的许多部分，包括断言、模拟和间谍、代码覆盖等。当你使用create-react-app框架时，Jest已经内置了。在今天的文章中，我们将为您的JavaScript代码进行Jest的简单设置，以及如何开始本地测试我们的应用程序功能。</p><h1 id="df77" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">快速设置</h1><p id="0008" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">首先，我们用npm初始化工作目录。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="d34c" class="lz ke iq mw b gy na nb l nc nd">npm init -y</span></pre><p id="9c45" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">y标志基本上意味着从npm init自动接受提示(而不是对每个提示都按enter)。</p><p id="cdf9" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">接下来，我们从npm安装Jest。我们只需要安装Jest作为开发依赖项，因为它只在开发阶段需要。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="2aec" class="lz ke iq mw b gy na nb l nc nd">npm install jest — save-dev</span></pre><p id="ee21" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">安装后，您应该看到Jest包包含在package.json的devDependencies中。</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="8098" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">现在，让我们从第一个例子开始:</p><p id="8b59" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated"><strong class="ld ir"> script1.js </strong></p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="aeee" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">脚本1只是将两个数字相加并返回总和。</p><p id="f207" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">为了测试script1.js，我们创建了另一个名为“script1.test.js”的文件(最好遵循为脚本命名测试文件的惯例)。在这个测试脚本中，我们可以添加以下JavaScript代码:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7c31" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">这是我们从script1.js导入addNums函数，并在这个脚本中执行测试。您可以从Jest中编写“test”或它的别名“it”(我们在脚本中使用的)来测试addNums函数。第一个参数是这个测试的名字，第二个参数是要测试的期望。该方法非常简单明了:期望函数将数字4和5相加，结果是9。测试的第二行是测试通过4和5应该不会产生10的结果。简单。</p><p id="474a" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">为了运行这个测试，我们需要在package.json中配置“test”脚本来运行。您可以按如下方式配置它:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="30df" class="lz ke iq mw b gy na nb l nc nd">"scripts": {<br/>    "test": "jest ./*test.js"<br/>  }</span></pre><p id="2d1a" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">这是告诉节点运行测试，并捕捉文件名的正则表达式。完成更改后，运行:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="a772" class="lz ke iq mw b gy na nb l nc nd">npm test</span></pre><p id="e531" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">您应该会收到如下输出:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="07f9" class="lz ke iq mw b gy na nb l nc nd">PASS  ./script1.test.js<br/><br/>Test Suites: 1 passed, 1 total<br/>Tests:       1 passed, 1 total<br/>Snapshots:   0 total<br/>Time:        1.125 s<br/>Ran all test suites matching /.\\*test.js/i.</span></pre><p id="5784" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">这意味着您现在有一个测试套件(script1.test.js)和一个测试(一个“它”就是一个测试)。</p><p id="79f0" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">如果不希望每次都键入*npm test*来运行测试，可以在package.json中配置测试脚本，如下所示:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="02a5" class="lz ke iq mw b gy na nb l nc nd">"scripts": {<br/>    "test": "jest --watch ./*test.js"<br/>  }</span></pre><p id="887f" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">每次在进行更改后保存文件时，npm测试将会观察并自动触发以运行测试。</p><p id="a1fb" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">让我们看看第二个例子:</p><p id="7f5e" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated"><strong class="ld ir">剧本2.js </strong></p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="dac8" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">给定一个db(一个JS数组)和一个搜索词，返回与该词匹配的名字(只有前3个匹配)。我们将db作为这个函数的依赖项注入的原因是，这个函数更容易重用，并且更容易用模拟数据库进行测试。<br/>函数“functionNotTested”没有任何用途，只是向您显示测试覆盖范围。我们不打算为这个函数编写一个测试。</p><p id="8743" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">这个函数里要测试的东西似乎更多。首先，我们可以测试该函数是否返回带有所提供的搜索词的预期搜索结果。其次，我们希望该函数只返回搜索词的前3个匹配项。我们还可以检查是否将null或undefined作为参数传递给搜索项的函数，该函数可以正确地处理它并返回一个空数组。最后，我们还可以确保这个搜索函数区分大小写。我们不需要执行真正的数据库连接，因为这是一个单元测试。在测试与真实数据库的集成之前，我们应该确保这个函数能够像预期的那样与注入的数据库数组和搜索词一起工作。因此，我们可以简单地创建一个模拟db数组，并将其传递给函数(这就是编写可重用代码的好处)。这是我们可能构建的测试脚本:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ddc0" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">这对你来说应该很有意义。如果函数遇到不存在的搜索项，或者接收null或undefined作为搜索项，那么函数应该返回一个空数组(JavaScript“filter”函数处理这个问题)。在最后一个测试中，我们希望搜索函数区分大小写，因此像“Lily …”和“… Li”这样的名字不应该出现在结果中。最后，函数“describe”用于将多个测试组合成一个整体。因此，当结果被打印出来时，这些测试将有一个名为“查找与数据库中的搜索词相匹配的名称的函数”的组名。“toEqual”可以用来测试JavaScript对象。</p><p id="7afa" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">让我们看一下最后一个例子:</p><p id="914a" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated"><strong class="ld ir"> script3.js </strong></p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d190" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">我们将需要在第三个脚本中调用API，因为我们正在使用Node.js(并且浏览器获取API不可用)，您可以为Node.js安装同构获取:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="4d8b" class="lz ke iq mw b gy na nb l nc nd">npm install isomorphic-fetch</span></pre><p id="9334" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">我们在这个例子中使用的API是PokéAPI。通过将您想要查找的口袋妖怪传入API路径，可以方便地检索口袋妖怪信息。这个函数返回找到的口袋妖怪的名字、体重和身高。</p><p id="1a31" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">到目前为止，我想介绍Jest的另一个功能:为您的代码提供测试覆盖的整体视图。</p><p id="effb" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">创建“script3.js”后，运行以下命令:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="eeec" class="lz ke iq mw b gy na nb l nc nd">npm test — — coverage</span></pre><p id="de08" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">您应该看到这个:</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/e330095174a2acb5b783b89c20b558cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*RxRLPz7BTM-tRL6_Dq5T4Q.png"/></div></figure><p id="3eb6" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">这显示了有多少百分比的测试覆盖了每个JavaScript文件，以及哪一行没有被覆盖。请记住，在我们的script2.js中有一个函数，我们没有为它编写任何测试，这就是script2.js没有得到100%的原因。我们没有为script3.js编写任何测试用例，因此，它的测试覆盖率为0%。</p><p id="6ec2" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">好了，我们可以开始编写script3.js的测试了，让我们先试试这个测试脚本:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ce04" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">因此，这个脚本试图调用API，并检索要与预期值进行比较的数据。让我们尝试运行*npm测试*:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="55b8" class="lz ke iq mw b gy na nb l nc nd">&gt; jest-testing@1.0.0 test C:\Users\Dylan Oh\source\repos\jest-testing<br/>&gt; jest ./*test.js<br/><br/> PASS  ./script2.test.js<br/> PASS  ./script3.test.js<br/> PASS  ./script1.test.js<br/><br/>Test Suites: 3 passed, 3 total                                                                                                                                                                                                   <br/>Tests:       6 passed, 6 total<br/>Snapshots:   0 total<br/>Time:        0.801 s, estimated 1 s<br/>Ran all test suites matching /.\\*test.js/i.</span></pre><p id="7654" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">耶！通过了！或者……真的是吗？</p><p id="0136" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">嗯，有一种方法可以知道这一点。我们可以添加一个函数来检查测试中通过了多少断言:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="3b9e" class="lz ke iq mw b gy na nb l nc nd"><br/>expect.assertions(numberOfAssertionsExpected);<br/></span></pre><p id="9276" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">让我们将它添加到script3.test.js中:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="241f" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">我们期望在这里完成3个断言，分别针对姓名、体重和身高。运行<em class="nh"> npm测试</em>:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="0aa1" class="lz ke iq mw b gy na nb l nc nd">FAIL  ./script3.test.js<br/>  ● Find the Pokemon from PokeAPI and return its name, weight and height<br/><br/>    expect.assertions(3);<br/><br/>    Expected three assertions to be called but received zero assertion calls.<br/><br/>      3 |<br/>      4 | it("Find the Pokemon from PokeAPI and return its name, weight and height", () =&gt; {<br/>    &gt; 5 |     expect.assertions(3);<br/>        |            ^<br/>      6 |     fetchPokemon("bulbasaur", fetch).then(data =&gt; {<br/>      7 |         expect(data.name).toBe("bulbasaur");<br/>      8 |         expect(data.height).toBe(7);<br/><br/>      at Object.&lt;anonymous&gt; (script3.test.js:5:12)<br/><br/> PASS  ./script2.test.js<br/> PASS  ./script1.test.js<br/><br/>Test Suites: 1 failed, 2 passed, 3 total                                                                                                                                                                                         <br/>Tests:       1 failed, 5 passed, 6 total<br/>Snapshots:   0 total<br/>Time:        0.842 s, estimated 1 s<br/>Ran all test suites matching /.\\*test.js/i.<br/>npm ERR! Test failed.  See above for more details.</span></pre><p id="6014" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">Opps…零断言调用。这里发生了什么？原因是，断言对异步调用一无所知，并且在检索数据之前，测试已经通过。因此，我们需要一种方法来告诉这些断言等待数据返回。</p><p id="d7ba" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">解决这个问题的一个方法是向测试方法的回调函数传递一个“done”函数，并把它放在断言之后。</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c35e" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">并且，它通过并确保进行了三次断言调用。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="abf4" class="lz ke iq mw b gy na nb l nc nd">PASS  ./script3.test.js<br/> PASS  ./script2.test.js<br/> PASS  ./script1.test.js<br/><br/>Test Suites: 3 passed, 3 total                                                                                                                                                                                                   <br/>Tests:       6 passed, 6 total<br/>Snapshots:   0 total<br/>Time:        0.868 s, estimated 1 s<br/>Ran all test suites matching /.\\*test.js/i.</span></pre><p id="baab" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">更简单的方法是，我们可以只使用<strong class="ld ir"> <em class="nh">返回</em> </strong>这个异步函数，Jest足够聪明，可以等到结果返回。</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9d67" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">这也将通过断言测试的预期。我个人建议使用return语句来返回承诺，并始终记得包括测试异步函数所需的断言调用次数，以确保断言真正被贯穿。</p><p id="85c8" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">我们可以删除script2.js中不必要的函数，然后运行</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="2fb0" class="lz ke iq mw b gy na nb l nc nd">npm test -- --coverage</span></pre><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/f2c4acc38d18bac07e9510fd30b4ea44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*UJGFkxktRz9kS2uGVbEPBA.png"/></div></figure><p id="e4bb" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">在那里，我们有100%的测试覆盖率。</p><p id="e6af" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">无论是在本地测试还是在CI/CD管道上测试，为您的代码编写测试总是一个好的实践。这将有助于我们更早地发现潜在的错误，并迫使我们自己在某种程度上写出更好的代码。T9】</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="e469" class="pw-post-body-paragraph lb lc iq ld b le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly ij bi translated">请在Medium、Twitter或Linkedin上关注我，获取更多关于web开发、Web3等主题的文章！</p><div class="nq nr gp gr ns nt"><a href="https://www.linkedin.com/in/dylan-oh-dick-loon/" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">Dylan Oh -软件工程师-信息员| LinkedIn</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">精通ReactJs的全栈开发。使用NodeJs、C # ASP.NET Blazor、Typescript、NextJs的经验</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">www.linkedin.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh jw nt"/></div></div></a></div></div></div>    
</body>
</html>