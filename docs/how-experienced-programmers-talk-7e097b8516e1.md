# 有经验的程序员如何说话

> 原文：<https://levelup.gitconnected.com/how-experienced-programmers-talk-7e097b8516e1>

![](img/bf056837c37dc5dbd2d2d84fdd40cee1.png)

[KOBU 机构](https://unsplash.com/@kobuagency?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

昨天，我写了一篇关于[程序员应该如何交流的高层次概述。](/how-programmers-should-communicate-4738fcec5ab8)

在这方面，我设计了一个简单的 1-2-3 计划，关于如何做技术和面试演示。

今天，我将详细介绍，并定义编程通信的最基本构件。

因为细节是魔鬼所在。

# 为什么这是必要的？

我通过艰难的方式认识到这一点。

在我职业生涯的早期，我的演讲充满了技术术语。如果我想描述一个简单的阶级关系，我会这样继续下去:

> 类 A 有两个方法:getConfiguration()和 postMessage()。使用 getConfiguration()，类 B 首先获得配置。然后它调用 postMessage()，后者接受一个配置对象作为参数。

这是在我们两周一次的状态会议期间！

每个人都打哈欠。我老板以为我是实习生。实际上，我已经相当资深了，但是很少和真正的程序员一起参与协作设计。

我的任务主要包括从客户那里获取规格、设计功能和交付，没有中间阶段的协作、问答或白板。

我很少交换任何重要的反馈。即使我这么做了，也是以电子邮件的形式，没有人在场对我怒目而视或纠正我的咆哮。

但是当我开始看到我的沟通中的差距时，我决定改进。下面是我学到的要点，你也可以从中受益。

# #1:创造:

如果 A 类用除自身以外的部分/全部参数创建 B 类，你可以说 A 创建/定义并使用 B。

在现实世界中，它可能是以下内容的某种变体:

*   API 客户端**在打开 HTTP 会话之前创建一个配置对象**
*   支付对象**在发起支付网关 api 调用之前创建支付方法(例如 PayPal/visa)对象**
*   类工厂在将环境对象注入视图-模型层次结构之前创建它

这内在地暗示了造物主 A 类也要对 B 类的毁灭负责。

最流行的用法是使用名称 **Factory (** 上面的第三个例子 **)** ，但是你也可以使用其他的名称，这取决于你的项目。

# #2:转换器/串行器/解串器:

这些术语一般用于描述负责在业务对象和普通数据之间进行转换的实用程序类。它们大多是一些开源转换库的一部分。

> 抽象减少了讨论中的技术术语密度，从而使团队的其他成员能够忍受

在这种情况下，你也可以用他们的真名来称呼他们。然而，当涉及到非程序员时，这样做可能会增加团队沟通的复杂性。

## 示例:

您可以拥有一个带有格式参数(JSON/XML)的转换器类。它将字节数组数据转换成所需的业务对象，反之亦然。

你如何描述它的工作？类似于:

*   转换器**解析**JSON/XML 数据(以产生业务对象)。
*   转换器**产生一个流/序列化**(转换成 XML/JSON)

为什么我们将转换器类称为**转换器**，而不是实际的类名(JSONConvertor)？因为这种抽象减少了讨论中的技术术语密度，从而使团队的其他成员，尤其是业务人员能够忍受。

# #3:授权:

当一个 A 类的对象被传递给 B 类供 B 类代码使用时，你可以说 B 委托给了 A。

在现实世界中，它可能是以下内容的某种变体:

*   视图/屏幕**将 UI 事件委托给控制器对象。**
*   每次收到订单时，主业务对象**将委托给子业务对象**
*   每次检测到更改时，后台进程都会委托给数据库读取器和写入器

如果委托是异步的，你想描述一个回调，你也可以说 B 在特定的点唤醒 A。例如，当 API 调用返回错误时，URL 加载器会唤醒视图模型类。

# #4:缓存:

在我描述的所有案例中，这是最不常见的一类。

> 大多数缓存器被错误地标识为实用程序类。

在大多数不负责任地进行类设计的代码库中，有一个症状非常普遍:它们都缓存(通常是不必要的)数据。

因此，大多数这样的类除了在屏幕、模块或用户会话之间缓存数据之外没有其他任务。

在我过去的大部分代码库中，我都是以一种非常随意的方式来描述它们，比如:

```
PaymentScreen gives data to the **PaymentModule** class, which stores the reference to the payment, and later hands it over to the OrderScreen class.
```

结果呢？每次提到 **PaymentModule** 时，我的团队都觉得碰壁了。它需要一个更好的替代品。类似于:

```
Payment screen data is cached until user goes the Order screen.
```

这就是为什么我们需要真实的类名来使讨论复杂化？

大多数编码人员将这样的类称为实用类，以淡化它们的重要性。

但是，最好尽早识别它们，并将它们标记为**缓存器**。更好的方法是，重构并将它们重命名为缓存器。

这种方法有两个优点:

*   它宣布了他们的目的和在类设计中的位置(对团队中的新人非常有用)
*   这迫使人们重新思考软件内存布局。我们将所有数据存储在哪里，为什么要这样做？我们这样做是多余的吗？反过来说，我们是否过早地使缓存失效，迫使 API 进行早期重取？

# 结论:

> 足够抽象的交流是走向技术领先的第一步。

我刚才描述的大致类型只是一个开始。有了设计模式的经验和实践，您也可以提出自己的交流模式。

要记住的关键是在你想要的/真实的代码设计之上添加抽象。

程序员抽象技术细节的能力反映了他/她的经验。

通过不断验证和排练你与团队的理想语言交流，你不仅可以展示你的专业知识，还可以让其他人利用你的工作。

足够抽象的交流是走向技术领导的第一步。