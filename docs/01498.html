<html>
<head>
<title>A Guide to Next.js API Routes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Next.js API路线指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-guide-to-next-js-api-routes-a287eda1f784?source=collection_archive---------2-----------------------#2020-01-08">https://levelup.gitconnected.com/a-guide-to-next-js-api-routes-a287eda1f784?source=collection_archive---------2-----------------------#2020-01-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4755" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用API构建全栈React应用程序—无需配置</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7617fd4c8bf4726b56e6d9467dca19b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nkrEbtxp6Zl0UT1BLL93bw.jpeg"/></div></div></figure><p id="e5d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Next.js v9中，引入了API路由，允许您创建RESTful端点作为下一个文件夹结构的一部分。我们能够向我们的应用添加业务逻辑，而无需编写任何额外的定制服务器代码，这为我们提供了编写全栈React +节点应用所需的一切。</p><p id="cd6f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过在我们的下一个应用中封装前端和后端，我们可以快速构建和部署新的应用，并在生产中毫不费力地扩展它们。</p><p id="14e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我将向您展示如何创建API路由，并通过一个示例进行工作，然后深入研究API路由是如何工作的。</p><p id="1f55" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">源代码:<a class="ae lq" href="https://github.com/treyhuffine/next-api-routes-demo" rel="noopener ugc nofollow" target="_blank">https://github.com/treyhuffine/next-api-routes-demo</a></p><h2 id="a4a3" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">创建API路线</h2><p id="6630" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">可以在<code class="fe mp mq mr ms b">pages/api</code>目录下声明API。类似于<code class="fe mp mq mr ms b">pages</code>目录下的文件和文件夹如何直接映射到页面URL，同样的情况也发生在<code class="fe mp mq mr ms b">pages/api</code>上。</p><p id="0c96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您在<code class="fe mp mq mr ms b">pages/api</code>中声明一个文件或文件夹时，它将生成一个匹配<code class="fe mp mq mr ms b">/api/&lt;folder&gt;/&lt;file&gt;</code>的URL端点。例如，如果我们创建<code class="fe mp mq mr ms b">pages/api/users.js</code>，我们的应用程序将公开一个<code class="fe mp mq mr ms b">/api/users</code>端点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure><p id="c0da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建和维护一份简历并不有趣。相反，让我们为你生成一份令人敬畏的简历:)<a class="ae lq" href="https://gitconnected.com/resume-builder" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">简历生成器&gt; </strong> </a></p><div class="mu mv gp gr mw mx"><a href="https://gitconnected.com/resume-builder" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">软件工程师简历生成器和示例| gitconnected</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">一份有价值的简历模板，使用您个人资料中的详细信息构建。从你的投资组合网站链接到你的简历或…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">gitconnected.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl ks mx"/></div></div></a></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure><h2 id="1c59" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">下一个API路线示例</h2><p id="7423" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">首先，我们将初始化下一个项目:</p><pre class="kj kk kl km gt nm ms nn no aw np bi"><span id="d0d1" class="lr ls it ms b gy nq nr l ns nt">npx create-next-app api-routes-demo</span><span id="589f" class="lr ls it ms b gy nu nr l ns nt">cd api-routes-demo</span></pre><p id="553d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在创建一个<code class="fe mp mq mr ms b">pages/api</code>文件夹和一个<code class="fe mp mq mr ms b">page/api/hello.js</code>文件。在该文件中，添加以下代码:</p><pre class="kj kk kl km gt nm ms nn no aw np bi"><span id="be1e" class="lr ls it ms b gy nq nr l ns nt">const handler = (req, res) =&gt; {<br/>  return res.json({ hello: 'world!' });<br/>};</span><span id="3e14" class="lr ls it ms b gy nu nr l ns nt">export default handler;</span></pre><p id="2c51" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就这么简单！只需要一个文件/函数来创建一个API。现在访问<code class="fe mp mq mr ms b">localhost:3000/api/hello</code>，会得到如下回应:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/4369b6526cc5a5e833065143fed06dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*8p-_qFHGLc2yibEatgVRLA.png"/></div></figure><h2 id="7703" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">API路线如何工作</h2><p id="bafa" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">Next.js将从<code class="fe mp mq mr ms b">api</code>文件夹中的所有文件中寻找默认导出，并将它们视为该路径的处理程序。默认导出必须是将请求和响应作为函数参数的函数。</p><pre class="kj kk kl km gt nm ms nn no aw np bi"><span id="8d90" class="lr ls it ms b gy nq nr l ns nt">export default (req, res) =&gt; {/* Handle an API request*/}</span></pre><p id="0333" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Next.js为我们创建了一个节点服务器(或者一个无服务器的lambda，如果您将无服务器设置为您的构建目标),并从节点传递请求和响应对象。它还会自动解析请求的主体、查询和cookies，因为这些在大多数请求处理程序中经常使用。</p><pre class="kj kk kl km gt nm ms nn no aw np bi"><span id="37de" class="lr ls it ms b gy nq nr l ns nt">export default function handler(req, res) {<br/>  console.log(req.body) // The request body<br/>  console.log(req.query) // The url query string<br/>  console.log(req.cookies) // The passed cookies</span><span id="c8ee" class="lr ls it ms b gy nu nr l ns nt">  res.end('Hello World')<br/>}</span></pre><p id="2d61" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同样值得注意的是，如果需要在内部进行异步请求，比如查询数据库，处理程序可以使用<code class="fe mp mq mr ms b">async</code> / <code class="fe mp mq mr ms b">await</code>。</p><h2 id="9e7a" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">创建动态路由</h2><p id="14c0" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">API路由还允许我们以与页面相同的方式定义动态路径参数。例如，我们可以使用结构<code class="fe mp mq mr ms b">pages/api/users/[id].js</code>创建一个通过用户ID获取用户的路由。这将创建一条<code class="fe mp mq mr ms b">/api/user/:id</code>路线，并且可以在查询参数中访问<code class="fe mp mq mr ms b">id</code>。让我们现在创建这个文件，并添加以下处理程序:</p><pre class="kj kk kl km gt nm ms nn no aw np bi"><span id="43d3" class="lr ls it ms b gy nq nr l ns nt">export default (req, res) =&gt; {<br/>  const { query: { id } } = req<br/><br/>  res.json({ user: { id, name: 'Test User' } })<br/>}</span></pre><p id="ab12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">访问<code class="fe mp mq mr ms b">localhost:3000/api/users/123</code>，你会得到如下回应:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/bbe7afed62081dbe0fab196f242d0e8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n-Tjftv5yACMHQh7HS32NA.png"/></div></div></figure><h2 id="e3d4" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">路线中的错误</h2><p id="f619" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">如果您想从API返回一个错误，您可以简单地使用<code class="fe mp mq mr ms b">res.status()</code>方法，该方法将为响应设置状态代码。</p><pre class="kj kk kl km gt nm ms nn no aw np bi"><span id="5e4e" class="lr ls it ms b gy nq nr l ns nt">export default async (req, res) =&gt; {<br/>  const { query: { id } } = req</span><span id="9f11" class="lr ls it ms b gy nu nr l ns nt">  const user = await getUserById(id)</span><span id="36ad" class="lr ls it ms b gy nu nr l ns nt">  if (!user) {<br/>    return res.status(404).json({<br/>      status: 404,<br/>      message: 'Not Found'<br/>    })<br/>  }</span><span id="568b" class="lr ls it ms b gy nu nr l ns nt">  return res.json({ user })<br/>}</span></pre><h2 id="27bf" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">处理不同的HTTP方法(GET、POST、PUT、PATCH、DELETE)</h2><p id="9459" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">与我们通常在Node中构建服务器不同的一个概念是，我们需要在一个请求处理程序中处理所有的HTTP请求方法。我们可以检查<code class="fe mp mq mr ms b">req.method</code>变量来获取正在使用的HTTP方法。最常见的处理模式是使用一个<code class="fe mp mq mr ms b">switch</code>语句。</p><pre class="kj kk kl km gt nm ms nn no aw np bi"><span id="5521" class="lr ls it ms b gy nq nr l ns nt">export default (req, res) =&gt; {<br/>  const { method } = req</span><span id="9260" class="lr ls it ms b gy nu nr l ns nt">  switch (method) {<br/>    case 'GET':<br/>      // handleGet()<br/>      break<br/>    case 'POST':<br/>      // handlePost()<br/>      break<br/>    default:<br/>      <!-- -->res.setHeader('Allow', ['GET', 'POST'])<br/>      res.status(405).end(`Method ${method} Not Allowed`)<br/>}</span></pre><h2 id="e95d" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">TypeScript集成:开箱即用！</h2><p id="bcd2" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">要使用TypeScript，只需安装TypeScript以及React和Node的类型。</p><pre class="kj kk kl km gt nm ms nn no aw np bi"><span id="831e" class="lr ls it ms b gy nq nr l ns nt">yarn add -D typescript <a class="ae lq" href="http://twitter.com/types/react" rel="noopener ugc nofollow" target="_blank">@types/react</a> <a class="ae lq" href="http://twitter.com/types/node" rel="noopener ugc nofollow" target="_blank">@types/node</a></span></pre><p id="fa2b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你甚至不需要创建你的<code class="fe mp mq mr ms b">tsconfig.json</code>文件。如果Next检测到TypeScript，它会在您运行服务器时为您生成一个。</p><p id="8df2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们重温前面的简单API请求，我们可以将名称改为<code class="fe mp mq mr ms b">pages/api/hello.ts</code>并为路由添加类型。</p><pre class="kj kk kl km gt nm ms nn no aw np bi"><span id="3ebc" class="lr ls it ms b gy nq nr l ns nt">import { NextApiRequest, NextApiResponse } from 'next';</span><span id="e4b7" class="lr ls it ms b gy nu nr l ns nt">const handler = (_req: NextApiRequest, res: NextApiResponse) =&gt; {<br/>  return res.json({ hello: 'world!' });<br/>};</span><span id="e4e7" class="lr ls it ms b gy nu nr l ns nt">export default handler;</span></pre><p id="566b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将类型<code class="fe mp mq mr ms b">NextApiRequest</code>和<code class="fe mp mq mr ms b">NextApiResponse</code>添加到我们的请求和响应中。我们可以看到我们的<code class="fe mp mq mr ms b">.json</code>方法在<code class="fe mp mq mr ms b">res</code>上被识别。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/95fd31eddaffafea39afc36b2e6a6d48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*La6uRbvh9kmk_OQJrpM22Q.png"/></div></div></figure><h2 id="c310" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">API路由部署</h2><p id="a8ba" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">下一个应用程序的部署方式不会改变。如果您在next.config.js文件中使用<code class="fe mp mq mr ms b">target: 'server'</code>,它将在服务器的<code class="fe mp mq mr ms b">/api</code>路径下公开API路由。如果你<code class="fe mp mq mr ms b">target: 'serverless'</code>，API路由将被视为Lambda函数，可以使用Now无缝部署。无论您选择哪个，到<code class="fe mp mq mr ms b">/api/&lt;handler-file&gt;</code>的路径都是相同的。</p><h2 id="31f9" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">端点特定的配置</h2><p id="f820" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">Next.js提供了一个escape hatch，因此您可以单独配置每个处理程序并更改默认行为。例如，如果您需要我们需要原始请求体，您可以选择退出自动解析。</p><p id="127f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要配置一个端点，导出一个名为<code class="fe mp mq mr ms b">config</code>的对象，它将被下一次构建自动选取。</p><pre class="kj kk kl km gt nm ms nn no aw np bi"><span id="bd0d" class="lr ls it ms b gy nq nr l ns nt"><strong class="ms iu">export</strong> <strong class="ms iu">const</strong> config = {<br/>  api: {<br/>    bodyParser: false, // Disallow body parsing, consume as stream</span><span id="7b7c" class="lr ls it ms b gy nu nr l ns nt">    // OR</span><span id="7fa8" class="lr ls it ms b gy nu nr l ns nt">    bodyParser: {<br/>      sizeLimit: '1mb', // Set max body size<br/>    },<br/>  },<br/>}</span></pre><h2 id="f3ca" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">包裹</h2><p id="5fcb" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">Next是一个强大的工具，应该是任何开发人员工具箱的一部分。它允许我们快速创建web应用程序，而无需担心配置或构建—一切都为我们处理和优化。</p><p id="489b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">下一条API路线的优势:</strong></p><ul class=""><li id="99f0" class="ny nz it kw b kx ky la lb ld oa lh ob ll oc lp od oe of og bi translated">没有配置</li><li id="c254" class="ny nz it kw b kx oh la oi ld oj lh ok ll ol lp od oe of og bi translated">每个处理程序都是独立的函数</li><li id="28e3" class="ny nz it kw b kx oh la oi ld oj lh ok ll ol lp od oe of og bi translated">使用参数轻松创建动态路径</li><li id="575c" class="ny nz it kw b kx oh la oi ld oj lh ok ll ol lp od oe of og bi translated">可以使用微型中间件</li><li id="7291" class="ny nz it kw b kx oh la oi ld oj lh ok ll ol lp od oe of og bi translated">可以用自己的函数来修饰处理程序</li><li id="0009" class="ny nz it kw b kx oh la oi ld oj lh ok ll ol lp od oe of og bi translated">可以单独配置每个处理程序</li><li id="ac8c" class="ny nz it kw b kx oh la oi ld oj lh ok ll ol lp od oe of og bi translated">构建为lambda函数或在节点服务器中使用微</li><li id="18a8" class="ny nz it kw b kx oh la oi ld oj lh ok ll ol lp od oe of og bi translated">现成的打字稿</li></ul></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><p id="eb81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">—<a class="ae lq" href="https://twitter.com/treyhuffine" rel="noopener ugc nofollow" target="_blank">@ trey huffine</a>|<a class="ae lq" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">@ git connected</a></p></div></div>    
</body>
</html>