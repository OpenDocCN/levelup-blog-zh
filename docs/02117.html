<html>
<head>
<title>JShell, the Java REPL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JShell，Java REPL</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/jshell-the-java-repl-21ba403c2dc5?source=collection_archive---------9-----------------------#2020-02-19">https://levelup.gitconnected.com/jshell-the-java-repl-21ba403c2dc5?source=collection_archive---------9-----------------------#2020-02-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2492" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">简单的命令行原型和更多</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/28f44105ec98912757637b49c38cebe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QQn2VbwlEZDxtMYm53VdCQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@so_obarey?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Ahmed Sobah </a>在<a class="ae ky" href="https://unsplash.com/s/photos/shell?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="78e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">快速运行一些代码而不启动一个成熟的IDE或者创建一个<em class="lv">临时</em>项目会非常有帮助。它可以用于构建代码原型，尝试一些新功能，或者运行一个更大项目的一小部分。</p><p id="2303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多语言都包含一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop" rel="noopener ugc nofollow" target="_blank"> REPL </a>，一个读取-评估-打印循环，它评估输入的声明、语句和表达式，并立即显示结果。有了Java 9，我们终于也有了一个。</p><h2 id="0415" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">例子</h2><p id="7a56" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">为了更好地形象化这些例子，我避免使用Gists。相反，我对所有用户输入都使用<strong class="lb iu">粗体</strong>，不强调JShell输出。以<code class="fe mu mv mw mx b">#</code>开头的行是出于解释的目的添加的，并不是JShell输出的一部分。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="c659" class="nf lx it bd ly ng nh ni mb nj nk nl me jz nm ka mh kc nn kd mk kf no kg mn np bi translated">基本用法</h1><p id="ca8a" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">要启动一个新的JShell会话，只需在您喜欢的终端/命令行中键入<code class="fe mu mv mw mx b">jshell</code>:</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="0fa5" class="lw lx it mx b gy nu nv l nw nx"><strong class="mx iu">jshell [options] [load-files]</strong></span></pre><h2 id="dbed" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">片段</h2><p id="51e4" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">JShell评估你扔给它的所有东西:表达式、语句、导入或定义。这些Java代码块被称为“片段”。</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="aed0" class="lw lx it mx b gy nu nv l nw nx"># Expressions<br/>jshell&gt; <strong class="mx iu">2 + 3</strong><br/>$1 ==&gt; 5</span><span id="9cf3" class="lw lx it mx b gy ny nv l nw nx"># Statements<br/>jshell&gt; <strong class="mx iu">var a = 2 + 3</strong><br/>a ==&gt; 5</span><span id="f967" class="lw lx it mx b gy ny nv l nw nx"># Imports<br/>jshell&gt; <strong class="mx iu">import java.time.*</strong></span><span id="82ab" class="lw lx it mx b gy ny nv l nw nx"># Definitions<br/>jshell&gt; <strong class="mx iu">boolean greaterZero(int i) {</strong><br/>   ...&gt; <strong class="mx iu">return i &gt; 0;</strong><br/>   ...&gt; <strong class="mx iu">}</strong><br/>|  created method greaterZero(int)</span></pre><p id="5e62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单行代码片段不需要分号。如果我们定义一个方法或类，我们仍然需要分号来表示花括号中的内容。</p><h2 id="01e2" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">临时变量</h2><p id="02c7" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">代码片段返回的任何值都会自动保存到一个名为<code class="fe mu mv mw mx b">$&lt;number&gt;</code>的“临时变量”中。现在表达式的结果可供以后使用。</p><p id="5ace" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要列出活动会话的所有变量，键入<code class="fe mu mv mw mx b">/vars</code>，这将打印所有临时和非临时变量:</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="b085" class="lw lx it mx b gy nu nv l nw nx">jshell&gt; <strong class="mx iu">2 + 3</strong><br/>$1 ==&gt; 5</span><span id="4d4e" class="lw lx it mx b gy ny nv l nw nx">jshell&gt; <strong class="mx iu">String.valueOf($1)</strong><br/>$2 ==&gt; "5"</span><span id="7804" class="lw lx it mx b gy ny nv l nw nx">jshell&gt; <strong class="mx iu">String nonScratch = "value"</strong><br/>nonScratch ==&gt; "value"</span><span id="75e4" class="lw lx it mx b gy ny nv l nw nx">jshell&gt; <strong class="mx iu">/vars</strong><br/>|    int $1 = 5<br/>|    String $2 = "5"<br/>|    String nonScratch = "value"</span></pre><h2 id="edce" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">进口</h2><p id="e351" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">默认情况下，只有一小部分JDK会自动导入。键入<code class="fe mu mv mw mx b">/imports</code>列出当前JShell会话的所有导入的包和类:</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="b8c0" class="lw lx it mx b gy nu nv l nw nx">jshell&gt; <strong class="mx iu">/imports</strong><br/>|    import java.io.*<br/>|    import java.math.*<br/>|    import java.net.*<br/>|    import java.nio.file.*<br/>|    import java.util.*<br/>|    import java.util.concurrent.*<br/>|    import java.util.function.*<br/>|    import java.util.prefs.*<br/>|    import java.util.regex.*<br/>|    import java.util.stream.*</span></pre><p id="399a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以导入其他包和类，就像在“普通”Java代码中一样:</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="1403" class="lw lx it mx b gy nu nv l nw nx">jshell&gt; <strong class="mx iu">import java.time.*</strong></span><span id="1f89" class="lw lx it mx b gy ny nv l nw nx">jshell&gt; <strong class="mx iu">import static java.util.stream.Collectors.*</strong></span></pre><p id="7e02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，我们可以指示JShell在启动时使用预定义的加载文件<code class="fe mu mv mw mx b">jshell JAVASE</code>加载一组不同的包</p><p id="c7de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将从JDK装载大约170个不同的包，而不仅仅是最少的。</p><h2 id="68d9" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">基于上下文的自动导入</h2><p id="b9aa" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">没有人想把处理Java代码所需的所有导入都打出来。JShell为您提供了保护，这是一件好事！</p><p id="132c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要导入一个类型，我们可以在任何类型的末尾按下<code class="fe mu mv mw mx b">shift-tab i</code>, JShell会尝试根据上下文找到正确的类型:</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="686d" class="lw lx it mx b gy nu nv l nw nx">#                    cursor position<br/>#                          ▼<br/>jshell&gt; <strong class="mx iu">var now = LocalDate.now() &lt;shift-tab i&gt;</strong><br/>0: Do nothing<br/>1: import: java.time.LocalDate<br/>Choice: <strong class="mx iu">1</strong></span></pre><p id="6895" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并不总是会找到导入候选项。但是大多数时候，它会让使用JShell变得更容易。</p><h2 id="ed65" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">变量表达式</h2><p id="44b3" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">另一个方便的快捷方式是<code class="fe mu mv mw mx b">shift-tab v</code>，它将一个表达式转换成一个变量创建语句:</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="db55" class="lw lx it mx b gy nu nv l nw nx">jshell&gt; <strong class="mx iu">3 + 3 &lt;shift-tab v&gt;</strong><br/># New cursor position<br/>#           ▼<br/>jshell&gt; int  = 3 + 3</span></pre><p id="f581" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变量类型会被自动推断和插入，只要给它一个名字，按<code class="fe mu mv mw mx b">enter</code>，你就把你的表达式转换成一个有名字的变量了。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="5408" class="nf lx it bd ly ng nh ni mb nj nk nl me jz nm ka mh kc nn kd mk kf no kg mn np bi translated">标签的力量</h1><p id="5b94" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">标签完成功能非常强大，可以用来完成代码片段和命令。多次按下<code class="fe mu mv mw mx b">tab</code>可增加提供的信息量。</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="1dd4" class="lw lx it mx b gy nu nv l nw nx">jshell&gt; <strong class="mx iu">System.out.print &lt;tab&gt;</strong><br/>print(     printf(    println(  </span><span id="1547" class="lw lx it mx b gy ny nv l nw nx">jshell&gt; System.out.print</span></pre><p id="5399" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们找到了正确的方法，我们可以通过在括号后再次按下<code class="fe mu mv mw mx b">tab</code>来查看所有可用的签名:</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="f3e5" class="lw lx it mx b gy nu nv l nw nx">jshell&gt; <strong class="mx iu">System.out.println(</strong><br/>Signatures:<br/>void PrintStream.println()<br/>void PrintStream.println(boolean x)<br/>void PrintStream.println(char x)<br/>void PrintStream.println(int x)<br/>void PrintStream.println(long x)<br/>void PrintStream.println(float x)<br/>void PrintStream.println(double x)<br/>void PrintStream.println(char[] x)<br/>void PrintStream.println(String x)<br/>void PrintStream.println(Object x)</span><span id="c528" class="lw lx it mx b gy ny nv l nw nx">&lt;press tab again to see documentation&gt;</span><span id="3d0e" class="lw lx it mx b gy ny nv l nw nx">jshell&gt; System.out.println(</span></pre><p id="8fad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如输出所示，再次按下<code class="fe mu mv mw mx b">tab</code>(一次又一次)将循环浏览每个签名的文档。</p><h2 id="0667" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">方法和类</h2><p id="93c4" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">方法和类可以“照常”声明:</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="29fb" class="lw lx it mx b gy nu nv l nw nx">jshell&gt; <strong class="mx iu">String concat(String a, String b) {</strong><br/>   ...&gt; <strong class="mx iu">return a + b;</strong><br/>   ...&gt; <strong class="mx iu">}</strong><br/>|  created method concat(String,String)</span><span id="022b" class="lw lx it mx b gy ny nv l nw nx">jshell&gt; <strong class="mx iu">class SimplePojo {</strong><br/>   ...&gt; <strong class="mx iu">private String value;</strong><br/>   ...&gt; <strong class="mx iu">String getValue() {</strong><br/>   ...&gt; <strong class="mx iu">return this.value;</strong><br/>   ...&gt; <strong class="mx iu">}</strong><br/>   ...&gt; <strong class="mx iu">void setValue(String newValue) {</strong><br/>   ...&gt; <strong class="mx iu">this.value = newValue;</strong><br/>   ...&gt; <strong class="mx iu">}</strong><br/>   ...&gt; <strong class="mx iu">}</strong><br/>|  created class SimplePojo</span><span id="1f7c" class="lw lx it mx b gy ny nv l nw nx">jshell&gt; <strong class="mx iu">var pojo = new SimplePojo()</strong><br/>pojo ==&gt; SimplePojo@67424e82</span><span id="4111" class="lw lx it mx b gy ny nv l nw nx">jshell&gt; <strong class="mx iu">pojo.setValue("a value")</strong></span><span id="c11c" class="lw lx it mx b gy ny nv l nw nx">jshell&gt; <strong class="mx iu">pojo.getValue()</strong><br/>$7 ==&gt; "a value"</span></pre><h2 id="17a0" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">向前引用</h2><p id="d4cc" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">由于<em class="lv">前向引用</em>，我们的方法和类可以使用变量和其他尚未声明的构造。不过，JShell警告我们:</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="09c1" class="lw lx it mx b gy nu nv l nw nx">jshell&gt; <strong class="mx iu">void forwardReference() {</strong><br/>   ...&gt; <strong class="mx iu">System.out.println(notYetDeclared);</strong><br/>   ...&gt; <strong class="mx iu">}</strong><br/>|  created method forwardReference(), however, it cannot be invoked until variable notYetDeclared is declared</span><span id="995e" class="lw lx it mx b gy ny nv l nw nx">jshell&gt; <strong class="mx iu">forwardReference()</strong><br/>|  attempted to call method forwardReference() which cannot be invoked until variable notYetDeclared is declared</span><span id="065d" class="lw lx it mx b gy ny nv l nw nx">jshell&gt; <strong class="mx iu">var notYet = "variable is declared"</strong><br/>notYetDeclared ==&gt; "variable is declared"</span><span id="a51b" class="lw lx it mx b gy ny nv l nw nx">jshell&gt; <strong class="mx iu">forwardReference()</strong><br/>variable is declared</span></pre><p id="6553" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使我们能够更容易地设置我们的环境，而不是在创建方法之前确保一切就绪。</p><h2 id="380f" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">控制流</h2><p id="9145" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">支持Java控制流语句:</p><ul class=""><li id="1004" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><code class="fe mu mv mw mx b">if</code> - <code class="fe mu mv mw mx b">else</code></li><li id="143f" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe mu mv mw mx b">? :</code>三元运算符</li><li id="254b" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe mu mv mw mx b">for</code>和<code class="fe mu mv mw mx b">while</code>-循环</li><li id="0071" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe mu mv mw mx b">switch</code>报表</li></ul></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="c08a" class="nf lx it bd ly ng nh ni mb nj nk nl me jz nm ka mh kc nn kd mk kf no kg mn np bi translated">历史</h1><p id="8f1e" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">有多种方法可以处理以前的代码片段。</p><h2 id="c617" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">列表</h2><p id="35bd" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">命令<code class="fe mu mv mw mx b">/history</code>将以纯文本显示当前活动会话的所有片段和命令。</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="f867" class="lw lx it mx b gy nu nv l nw nx">jshell&gt; <strong class="mx iu">2 + 4</strong><br/>$1 ==&gt; 6</span><span id="8ed2" class="lw lx it mx b gy ny nv l nw nx">jshell&gt; <strong class="mx iu">String test = "42"</strong><br/>test ==&gt; "42"</span><span id="6f6c" class="lw lx it mx b gy ny nv l nw nx">jshell&gt; <strong class="mx iu">/history</strong></span><span id="31c4" class="lw lx it mx b gy ny nv l nw nx">2 + 4<br/>String test = "42"<br/>/history</span></pre><p id="87ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，使用<code class="fe mu mv mw mx b">/list</code>,我们得到一个代码片段列表，而不是命令，以及它们对应的ID。</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="5e25" class="lw lx it mx b gy nu nv l nw nx">jshell&gt; <strong class="mx iu">2 + 4</strong><br/>$1 ==&gt; 6</span><span id="03f8" class="lw lx it mx b gy ny nv l nw nx">jshell&gt; <strong class="mx iu">String test = "42"</strong><br/>test ==&gt; "42"</span><span id="22bd" class="lw lx it mx b gy ny nv l nw nx">jshell&gt; <strong class="mx iu">/list</strong></span><span id="4536" class="lw lx it mx b gy ny nv l nw nx">   1 : 2 + 4<br/>   2 : String test = "42";</span></pre><p id="f56a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该ID可以在其他命令中使用。</p><h2 id="7747" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">搜索</h2><p id="9f1c" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">JShell支持向后和向前搜索:</p><ul class=""><li id="2ba5" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><code class="fe mu mv mw mx b">ctrl-r</code> -向后</li><li id="2d98" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe mu mv mw mx b">ctrl-s</code> -向后</li></ul></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="9e0a" class="nf lx it bd ly ng nh ni mb nj nk nl me jz nm ka mh kc nn kd mk kf no kg mn np bi translated">命令</h1><p id="5573" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们已经了解了一些可用的命令，比如<code class="fe mu mv mw mx b">/vars</code>和<code class="fe mu mv mw mx b">/list</code>。</p><p id="fa86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多命令都有不同的选项。我们可以通过键入<code class="fe mu mv mw mx b">/?</code>或<code class="fe mu mv mw mx b">/help</code>来查看它们，以获得简短的概述。有关命令的详细解释，请使用<code class="fe mu mv mw mx b">/? &lt;command&gt;</code>或<code class="fe mu mv mw mx b">/help &lt;command&gt;</code>。</p><h2 id="3d54" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">命令列表</h2><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="5650" class="lw lx it mx b gy nu nv l nw nx"> Command            | Description<br/>--------------------|------------------------------------<br/> /!                 | Rerun last snippet<br/> /-&lt;n&gt;              | Rerun the last &lt;n&gt;-th snippet<br/> /&lt;id&gt;              | Rerun specific snippet<br/>                    |<br/> /list              | List source of session<br/> /vars              | List variables<br/> /types             | List types<br/> /methods           | List methods<br/> /imports           | List imports<br/>                    |<br/> /history           | Plain text history<br/> /drop &lt;name or id&gt; | Delete source entry<br/> /edit              | Open all source in editor<br/> /edit &lt;id&gt;         | Open specific source in editor<br/> /open &lt;file&gt;       | Open file as source input<br/> /save &lt;file&gt;       | Save snippets to &lt;file&gt;<br/>                    |<br/> /reload            | Reset and replay each snippet<br/> /reset             | Reset JShell<br/> /env               | View or change the evaluation context<br/> /set &lt;key&gt; &lt;value&gt; | Configure JShell<br/> /exit              | Quit JShell</span></pre><h2 id="7c93" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">命令缩写</h2><p id="a8ed" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们不需要输入完整的命令，只需让它具有唯一性即可:</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="9756" class="lw lx it mx b gy nu nv l nw nx">jshell&gt; <strong class="mx iu">/set feedback verbose</strong></span></pre><p id="7992" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和...相对</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="c0e4" class="lw lx it mx b gy nu nv l nw nx">jshell&gt; <strong class="mx iu">/se fe v</strong></span></pre><p id="e492" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mu mv mw mx b">/s</code>对<code class="fe mu mv mw mx b">/set</code>来说还不够，感谢<code class="fe mu mv mw mx b">/save</code>。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="a3f0" class="nf lx it bd ly ng nh ni mb nj nk nl me jz nm ka mh kc nn kd mk kf no kg mn np bi translated">外部代码</h1><p id="5804" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">Java提供了很多功能，但是能够在JShell中使用任何JAR文件使它成为一个强大的原型工具。</p><h2 id="1db1" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">类路径</h2><p id="3565" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们可以在启动时指定类路径:</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="e33d" class="lw lx it mx b gy nu nv l nw nx"><strong class="mx iu">jshell --class-path [directory or JAR files]</strong></span></pre><p id="f9db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者我们可以在活动会话期间设置它:</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="56b6" class="lw lx it mx b gy nu nv l nw nx">jshell&gt; <strong class="mx iu">/env --class-path [directory or JAR files]</strong></span></pre><p id="3ad8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，会话将被重置，所有不在启动脚本中的内容都将消失。</p><h2 id="b853" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">Java 9模块</h2><p id="2cb7" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated"><a class="ae ky" href="https://www.oracle.com/corporate/features/understanding-java-9-modules.html" rel="noopener ugc nofollow" target="_blank">模块</a>的用法类似于使用类路径:</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="3942" class="lw lx it mx b gy nu nv l nw nx"><strong class="mx iu">jshell --module-path [module path] --add-modules [module]</strong></span></pre><p id="8c42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也可以在活动会话中设置:</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="bb11" class="lw lx it mx b gy nu nv l nw nx">jshell&gt; <strong class="mx iu">/env --module-path [module-path] --add-modules [module]</strong></span></pre></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="58bd" class="nf lx it bd ly ng nh ni mb nj nk nl me jz nm ka mh kc nn kd mk kf no kg mn np bi translated">配置</h1><p id="4dce" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">在<code class="fe mu mv mw mx b">/set</code>的帮助下，我们可以按照自己的喜好配置JShell。</p><h2 id="84b6" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">基本配置</h2><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="65b3" class="lw lx it mx b gy nu nv l nw nx"> Config key /values | Description<br/>--------------------|--------------------------------------<br/> editor &lt;command&gt;   | Specify editor for "/edit"<br/> start &lt;file&gt;       | Contents of file will become default<br/>                    | snippets/commands at startup<br/> feedback &lt;mode&gt;    | Verbosity of feedback<br/> &lt;none&gt;             | Display editor, start and feedback</span></pre><p id="6d4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像其他命令一样，<code class="fe mu mv mw mx b">editor</code>有额外的选项，你可以用<code class="fe mu mv mw mx b">/help /set editor</code>查看。</p><h2 id="084b" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">坚持</h2><p id="2c91" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">默认情况下，所有<code class="fe mu mv mw mx b">/set</code>命令仅在当前会话期间设置。要永久设置配置选项，我们需要在末尾添加参数<code class="fe mu mv mw mx b">-retain</code>。</p><p id="86e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是要注意，并不是每个保留的选项都可以像编辑器选项一样用<code class="fe mu mv mw mx b">-delete</code>删除。我试图找出JShell保存其配置的位置，但找不到，即使在检查了<a class="ae ky" href="https://github.com/openjdk/jdk/blob/master/src/jdk.jshell/share/classes/jdk/jshell/tool/package-info.java" rel="noopener ugc nofollow" target="_blank">源代码</a>之后也找不到。</p><h2 id="118a" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">高级配置</h2><p id="5b4d" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们可以非常详细地配置JShell提供的输出。但是这会使这篇文章的长度增加两倍或三倍。如果您对配置输出感兴趣，您应该查看一下<code class="fe mu mv mw mx b">/set mode</code>和<code class="fe mu mv mw mx b">/set format</code>选项。</p><p id="e0a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/9/jshell/feedback-modes.htm#JSHEL-GUID-906D1D0B-76AD-4AFD-9229-96C6FD823B4A" rel="noopener ugc nofollow" target="_blank"> JShell反馈模式文档</a>(甲骨文)</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="a468" class="nf lx it bd ly ng nh ni mb nj nk nl me jz nm ka mh kc nn kd mk kf no kg mn np bi translated">使用脚本</h1><h2 id="5eb1" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">启动脚本</h2><p id="1698" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">如前所述，JShell加载了一个默认的<em class="lv">启动脚本</em>，为会话准备有用的导入。</p><p id="29ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在启动时使用我们自己的脚本，按照我们喜欢的方式准备它:</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="e8a2" class="lw lx it mx b gy nu nv l nw nx"><strong class="mx iu">jshell --startup [script]</strong></span></pre><p id="a86f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用多个启动脚本，我们需要使用参数<code class="fe mu mv mw mx b">--start</code>来代替:</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="b852" class="lw lx it mx b gy nu nv l nw nx"><strong class="mx iu">jshell --start [script] --start [script]</strong></span></pre><p id="91f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者我们可以用<code class="fe mu mv mw mx b">/set start -retain [scripts]</code>来代替。</p><p id="86d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有3个内置的启动脚本可用:</p><ul class=""><li id="e107" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><code class="fe mu mv mw mx b">DEFAULT</code> <br/>加载最小导入量，在没有指定加载文件时使用。</li><li id="3bf0" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">装载大约175个不同的JDK包。</li><li id="01fd" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe mu mv mw mx b">PRINTING</code>加载与<code class="fe mu mv mw mx b">DEFAULT</code>相同的导入，但也添加了多个<code class="fe mu mv mw mx b">print</code>便利方法。</li></ul><p id="9aad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当会话重置时，启动脚本始终运行:</p><ul class=""><li id="194d" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">初次起动</li><li id="578a" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe mu mv mw mx b">/reset</code></li><li id="71a2" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe mu mv mw mx b">/reload</code></li><li id="1627" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe mu mv mw mx b">/env</code></li></ul><h2 id="5ad6" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">加载脚本</h2><p id="0f48" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">也可以将脚本加载到会话中:</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="0177" class="lw lx it mx b gy nu nv l nw nx"><strong class="mx iu">jshell [load-file]</strong></span></pre><p id="0de3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者在会话中使用<code class="fe mu mv mw mx b">/open [load-file]</code>。</p><p id="5b05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与启动脚本不同，它不会在会话重置时重新加载。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="0b32" class="nf lx it bd ly ng nh ni mb nj nk nl me jz nm ka mh kc nn kd mk kf no kg mn np bi translated">资源</h1><ul class=""><li id="d716" class="nz oa it lb b lc mp lf mq li on lm oo lq op lu oe of og oh bi translated">JShell用户指南(甲骨文)</li><li id="384b" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="http://cr.openjdk.java.net/~rfield/tutorial/JShellTutorial.html" rel="noopener ugc nofollow" target="_blank"> JShell教程</a> (OpenJDK)</li><li id="1e01" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">JEP 222  (OpenJDK)</li><li id="1145" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="https://www.baeldung.com/java-9-repl" rel="noopener ugc nofollow" target="_blank"> Java 9 —探索REPL </a> (Baeldung)</li><li id="cab0" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="https://www.jetbrains.com/help/idea/jshell-console.html" rel="noopener ugc nofollow" target="_blank">IntelliJ IDEA中的JShell控制台</a></li></ul></div></div>    
</body>
</html>