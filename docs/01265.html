<html>
<head>
<title>Creating Custom Kubernetes Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建自定义Kubernetes运算符</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-custom-kubernetes-operators-f15ec1dadff2?source=collection_archive---------5-----------------------#2019-12-09">https://levelup.gitconnected.com/creating-custom-kubernetes-operators-f15ec1dadff2?source=collection_archive---------5-----------------------#2019-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3c7a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">本文原载于</em><a class="ae kp" href="https://www.magalix.com/blog/creating-custom-kubernetes-operators" rel="noopener ugc nofollow" target="_blank">https://www . magalix . com/blog/creating-custom-kubernetes-operators</a></p><h1 id="b9a2" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">操作员还是自定义控制器？</h1><p id="0429" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">当我第一次接触这个话题时，我对一个对象有些困惑，即<a class="ae kp" href="https://www.magalix.com/blog/extending-the-kubernetes-controller" rel="noopener ugc nofollow" target="_blank">扩展了Kubernetes </a>的功能应该被称为操作符还是自定义控制器。深入挖掘这个主题，我了解到这两个术语广义上指的是同一个概念；使用<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-101-concepts-and-why-it-matters" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>的模块化和原子性来创建一个控制器，该控制器响应特定事件并执行定制动作。在另一篇文章中，我们创建了一个我们自己的控制器，它响应配置图中的变化，并重启任何正在使用这个<a class="ae kp" href="https://www.magalix.com/blog/the-configmap-pattern" rel="noopener ugc nofollow" target="_blank">配置图</a>的pod。</p><p id="2c5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">自定义控制器通过检查包含Pod标签的配置图的注释部分来确定重新启动哪些Pod。在更高级的情况下，我们需要控制器响应非Kubernetes本地的定制资源。因此，当定制控制器在本地<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-resource-requests-and-limits-101" rel="noopener ugc nofollow" target="_blank"> Kubernetes资源</a>和事件上操作和监听时，操作员使用定制资源定义(CRD)，用户创建的资源来解决复杂的业务问题。操作员可以被认为是人类操作员的替代品。知道应用程序的技术细节，也知道业务需求并据此行动的人。</p><h1 id="07bf" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">一个经营者能带来什么？</h1><p id="d21f" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">操作员是一个运行在<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-pods-101-the-cluster-sailors" rel="noopener ugc nofollow" target="_blank"> Pod </a>上的程序，并保持与API服务器的持续连接。如前所述，运营商处理CRDs。那么，一个典型的操作员是如何工作的，什么时候应该使用他来代替<a class="ae kp" href="https://www.magalix.com/blog/extending-the-kubernetes-controller" rel="noopener ugc nofollow" target="_blank">定制控制器</a>？让我们举个简单的例子。</p><p id="4fad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设您作为Kubernetes管理员的工作需要创建多个MySQL数据库集群。自然，一个集群和另一个集群之间存在细微的差异，比如节点数量、<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-storage-101" rel="noopener ugc nofollow" target="_blank">存储</a>容量，甚至是MySQL镜像版本。但是最终，你仍然需要创建像<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-statefulsets-101-state-of-the-pods" rel="noopener ugc nofollow" target="_blank"> StatefulSets </a>和服务这样的本地资源，并且仍然以“大致”相同的方式配置它们。</p><p id="2e33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，如果您有一个名为MySQLCluster的资源会怎么样呢？它使用自己的定义文件，可能如下所示:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="c4cf" class="mc kr it ly b gy md me l mf mg">apiVersion: cr.mysqloperator.grtl.github.com/v1<br/>kind: MySQLCluster<br/>metadata:<br/>  name: "my-cluster"<br/>spec:<br/>  secret: "my-secret"<br/>  fromBackup: "my-backup-2017-12-14-01-22"<br/>  port: 3306<br/>  replicas: 2<br/>  storage: "1Gi"<br/>  image: "mysql:latest"</span></pre><p id="c9d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，Kubernetes如何知道如何处理MySQLCluster？它不是像部署、服务或Pod那样的本地资源。为了指导Kubernetes如何解释和使用这个资源，我们需要部署一个扩展API的操作符。继续上面的示例，可以使用以下命令部署操作员:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="571b" class="mc kr it ly b gy md me l mf mg">kubectl run mysql-operator --image=grtl/mysql-operator:latest</span></pre><p id="5992" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">。是的，它只是一个在吊舱中运行的程序。但是，当它运行时，它会自动向API服务器注册一个自定义资源定义(CRD)。这就是Kubernetes识别和知道如何处理MySQLCluster资源的方式。</p><p id="8bda" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您应用上面的定义时，尽管没有名为MySQLCluster的本地Kubernetes资源，它仍然有效。但是，资源将被创建，因为有一个定制控制器(Operator)正在监视MySQLCluster类型对象的API。一旦它接收到感兴趣的事件，它就触发适当的动作作为响应。值得注意的是，上面的例子取自GRTL mysql-operator。读完这篇文章后，我强烈推荐你看看这个操作符是如何在https://github.com/grtl/mysql-operator<a class="ae kp" href="https://github.com/grtl/mysql-operator" rel="noopener ugc nofollow" target="_blank">上构建的。</a></p><p id="7355" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，在我们的例子中，一旦应用了这个定义，操作者就创建了几个本地Kubernetes资源，比如StatefulSet、服务、sidecar容器、健康和就绪探测器等等。也许现在，你会问:</p><h1 id="c2c1" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">舵轮图不就是这样吗？</h1><p id="4a63" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">另一个混淆的来源是什么时候使用<a class="ae kp" href="https://www.magalix.com/blog/the-best-kubernetes-tutorials" rel="noopener ugc nofollow" target="_blank"> Helm </a>图表，什么时候使用操作符，因为它们都是自动创建Kubernetes对象的。事实上，操作符和掌舵图并不是相互替代的。它们是相辅相成的。回到我们的MySQL集群示例，组成集群的定制控制器和CRD可以作为Helm图表的一部分进行部署。</p><p id="ee6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个操作者不仅仅构建本地的Kubernetes资源，他还拥有必要的特定领域的知识来以一种使应用程序正常工作的方式操作这些资源。因此，如果我们要通过舵图(不涉及操作员)部署我们的MySQL集群，我们将部署一个<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-statefulsets-101-state-of-the-pods" rel="noopener ugc nofollow" target="_blank">statefullset</a>、一个<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-storage-101" rel="noopener ugc nofollow" target="_blank">持久卷</a>、一个<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-secrets-101" rel="noopener ugc nofollow" target="_blank"> Secret </a>、一个<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-services-101-the-pods-interfaces" rel="noopener ugc nofollow" target="_blank"> Service </a>等等。仅此而已。</p><p id="b2d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Helm不知道(也无法处理)这些组件如何相互交互以形成一个正常运行的数据库集群。运算符用于有状态的应用程序。有状态应用程序(如数据库、消息队列系统、缓存系统等。)需要一种特定的方式来处理它们如何启动、如何扩展以及如何关闭。操作员取代了手动执行这些任务的人类操作员，而舵轮图更容易将操作员部署为其他组件的一部分。让我们来看看下图:</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mh"><img src="../Images/45ece1df4f6591606d0b18696e51da62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hyFYBPoocylFhcMc.png"/></div></div></figure><p id="588f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，使用了一个舵图来部署环境。它利用了Kubernetes的本地资源，如部署、工作、Docker图像和秘密。假设这是应用程序的前端部分，后端需要一个具有紧密耦合资源的数据库集群，这些资源作为一个单元一起工作。操作员负责创建和管理这个自定义资源。它还可以创建这个定制资源的多个实例(想想彼此交互的多个数据库集群)。这里的运营商是整个基础设施的一部分，它是通过舵图部署的。</p><h1 id="6adc" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">实验:构建自定义Kubernetes操作符</h1><p id="71b2" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">在本实验中，我们将构建一种特殊类型的ConfigMap，其中包含在其定义中使用它的pod的标签。因此，我们正在创建一个自定义资源定义(CRD)。值得注意的是，我们在本文中创建了一个使用定制控制器的类似示例，扩展了Kubernetes控制器。然而，在我们使用定制控制器实现这一功能和我们当前使用操作符实现这一功能之间有一些微妙的区别。让我们暂停一下，解释一下这两种方法有什么不同。</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mp"><img src="../Images/9978b06c97ae2da10dd2a6d262675065.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*N4JHYwKbQlDHxy3X.png"/></div></div></figure><p id="c00a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从上图中可以看出，定制控制器持续监视API服务器，查看特定配置图中的变化。一旦检测到一个，它就从配置图的注释部分提取窗格选择器，并使用它来重新启动与选择相匹配的窗格，以反映更改。</p><p id="8d9a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，当使用操作符时，您可以创建一个自定义资源定义(CRD ),该定义引用一个配置映射以及受影响的Pod的Pod选择器。通过这种方式，您可以将配置图与其窗格分离，因为您不再需要将标签添加到其注释中。因此，您可以对不同的应用程序使用不同的配置图。这可以用下面的例子来说明:</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mh"><img src="../Images/5a018b458458c9d8fb3021b99519ea53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gRkKqm7QNzc7zr2e.png"/></div></div></figure><p id="8f7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为这是一个相当长的实验，所以让我们把它分成几个阶段，从架构开始。</p><h1 id="0501" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">建筑</h1><p id="b02b" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">我们的操作员需要连接到API服务器来观察CRD的变化，从而决定应该采取哪种行动。有两种主要的方法可以连接到Kubernetes API服务器；通过客户端库和Kubectl代理。许多现代编程语言都提供了用于连接和处理Kubernetes的SDK。其中一些是Kubernetes官方支持的(不用说，Golang拥有最丰富的库)，还有许多是T2社区支持的。</p><p id="40c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您的需求不复杂，那么使用<a class="ae kp" href="https://kubernetes.io/docs/tasks/access-kubernetes-api/http-proxy-access-api/" rel="noopener ugc nofollow" target="_blank"> kubectl代理</a>方法可能会更好。使用一个简单的kubectl命令，您可以打开一个反向代理，监听您选择的端口。任何到达该端口的HTTP请求都会被自动转发到API服务器。虽然您使用kubectl的控制力较弱，但是您可以节省自己编写连接到API的代码的时间。</p><p id="d151" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本实验中，我们将使用kubectl代理方法。因为我们通过常规部署来部署操作符(最终，操作符只是一个程序)，所以我们将有一个包含两个容器的Pod:</p><ul class=""><li id="3245" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated">操作者容器:它包含监视API和检测感兴趣的变化的程序。</li><li id="ec7c" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">大使容器:它只是运行kubectl代理。操作员容器使用它来连接API服务器。有关大使模式的更多信息，请参考我们的文章，大使模式。</li></ul><p id="3524" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下图描述了这种架构:</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mp"><img src="../Images/613876126ebb62f346082ea32e0be9cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Zg_O_mFbDO2wj3Dp.png"/></div></div></figure><h1 id="5084" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">自定义资源定义(CRD)</h1><p id="be88" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">CRD是使用自己的定义文件创建的，就像任何其他Kubernetes资源一样。现实世界中的运营商可能会在运营商的代码中捆绑创建和注册CRD。例如，前面描述的<a class="ae kp" href="https://github.com/grtl/mysql-operator" rel="noopener ugc nofollow" target="_blank"> mysql-operator </a>在启动时注册它的CRD。让操作员来处理CRD创建，可以节省时间并抽象流程，以便您可以专注于业务需求。在本实验中，我们将手动创建CRD，以了解其工作原理。我们的CRD的定义文件可能如下所示:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="26c8" class="mc kr it ly b gy md me l mf mg">---<br/>apiVersion: apiextensions.k8s.io/v1beta1<br/>kind: CustomResourceDefinition<br/>metadata:<br/>  name: configmonitors.magalix.com<br/>spec:<br/>  scope: Namespaced<br/>  group: magalix.com<br/>  version: v1<br/>  names:<br/>    kind: ConfigMonitor<br/>    singular: configmonitor<br/>    plural: configmonitors<br/>  validation:<br/>    openAPIV3Schema:<br/>      properties:<br/>        spec:<br/>          properties:<br/>            configMap:<br/>              type: string<br/>              description: "Name of the ConfigMap to watch for changes"<br/>            podSelector:<br/>              type: object<br/>              description: "Label selector used for selecting Pods"<br/>              additionalProperties:<br/>                type: string<br/>---<br/>apiVersion: rbac.authorization.k8s.io/v1<br/>kind: Role<br/>metadata:<br/>  name: config-monitor-crd<br/>rules:<br/>- apiGroups:<br/>  - magalix.com<br/>  resources:<br/>  - configmonitor<br/>  - configmonitor/finalizers<br/>  verbs: [ get, list, create, update, delete, deletecollection, watch ]</span></pre><p id="ab69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，上面的代码片段包含两个定义:CRD和RBAC角色，它需要能够扩展API服务器。让我们强调一下CRD定义的重要方面:</p><p id="2516" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第2行和第3行:</strong>允许您添加CRD的API版本。CRD通过自己的资源添加到集群中。资源类型为CustomResourceDefinitinon。</p><p id="a7df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第7行:</strong>范围定义了这个资源是对整个集群可用还是对它所在的名称空间可用。如果一个名称空间被删除，与之相关的所有CRD也会被删除。</p><p id="c28d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第8行和第9行:</strong>组和版本定义了如何调用REST端点。在我们的示例中，这是/apis/magalix.com/v1。</p><p id="d368" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第10到13行:</strong>指定我们将如何调用我们的新资源。资源在三个地方被调用:</p><ul class=""><li id="3872" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated">API端点中使用了复数名称。在我们的示例中，应该是/APIs/magalix . com/v1/config minotors。</li><li id="083e" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">单数名称是在CLI上使用的名称，例如在使用kubectl子命令时。它也用于显示结果。</li></ul><p id="a1a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第14行到第26行:</strong>文件中剩余的行用于验证将使用这个CRD创建的资源。它使用<a class="ae kp" href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#schemaObject" rel="noopener ugc nofollow" target="_blank"> OpenAPI规范</a>版本3。验证用于确保使用正确的字段类型和值。例如，Pod定义的容器参数需要一个容器对象数组。添加单个字符串值会造成问题，因此验证可以确保如果输入了不正确的值，API会拒绝定义，并且不会创建资源。在我们的例子中，我们期望:</p><ul class=""><li id="d0ec" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated"><strong class="js iu">配置映射参数</strong>:指定配置映射资源名称的字符串。</li><li id="6230" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><strong class="js iu">pod selector参数:</strong>这是用于选择pod的标签的占位符。标签本身是一个字符串，因此通过指定additionalProperties参数，允许对象具有一个或多个字符串值。</li></ul><p id="084f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">文件的第二部分包含我们在CRD中使用的角色的定义。该角色允许CRD访问定义资源的API组以及终结器部分上的谓词。当您需要在删除资源之前执行一个或多个操作时，可以使用终结器。在我们的例子中，我们没有为资源指定任何终结器逻辑。</p><p id="98fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们使用kubectl应用上面的定义:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="b0ed" class="mc kr it ly b gy md me l mf mg">$ kubectl apply -f crd.yml<br/>customresourcedefinition.apiextensions.k8s.io/configmonitors.magalix.com created<br/>role.rbac.authorization.k8s.io/config-monitor-crd created</span></pre><h1 id="8281" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">配置监视器资源</h1><p id="6106" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">现在，我们的集群识别ConfigMonitor类型的资源，让我们创建一个。该资源的定义文件如下所示:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="b7e7" class="mc kr it ly b gy md me l mf mg">apiVersion: magalix.com/v1<br/>kind: ConfigMonitor<br/>metadata:<br/>  name: flakapp-config-monitor<br/>spec:<br/>  configmap: flaskapp-config<br/>  podSelector:<br/>    app: frontend</span></pre><p id="66ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，该定义使用了我们在CRD中指定的字段。我们有configmap名称和标签，我们将使用它们来选择podSelector部分中的pod。</p><h1 id="f1bc" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">演示应用程序</h1><p id="cf2e" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">我们的演示应用程序只是一个Python flask API，它用一条消息来响应HTTP请求。该消息来自稍后将存储在configmap中的配置文件。应用程序代码如下所示:</p><p id="beda" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">app/main.py:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="ff8e" class="mc kr it ly b gy md me l mf mg">from flask import Flask<br/>app = Flask(__name__)<br/><a class="ae kp" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/")<br/>def hello():<br/>    app.config.from_pyfile('/config/config.cfg')<br/>    return app.config['MSG']</span><span id="7c85" class="mc kr it ly b gy ne me l mf mg">if __name__ == "__main__":<br/>    # Only for debugging while developing<br/>    app.run(host='0.0.0.0', debug=True, port=80)</span></pre><p id="1f32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们构建并推送应用程序，以便以后使用:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="c090" class="mc kr it ly b gy md me l mf mg">docker build -t magalixcorp/flask:cusop<br/>docker push magalixcorp/flask:cusop</span></pre><h1 id="61b7" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">配置图</h1><p id="e093" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">我们的应用程序是一个简单的Python Flask API应用程序，当其端点被点击时显示一条消息。该消息是从我们存储在ConfigMap中的配置文件中读取的。配置映射定义如下所示:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="8e59" class="mc kr it ly b gy md me l mf mg">apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  name: flaskapp-config<br/>data:<br/>  config.cfg: <br/>    MSG="Welcome to Kubernetes!"</span></pre><p id="58cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用kubectl apply命令将上述定义应用到集群中。</p><p id="cb37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">kubectl apply -f configmap.yml</p><p id="82e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，我们已经准备好了所有的组件。让我们创建一个将它们联系在一起的操作符。</p><h1 id="b635" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">接线员</h1><p id="1de7" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">操作符只是一个程序(如前所述)。它可以用你选择的任何编程语言编写。Python，Ruby，Go，JavaScript，Java，甚至bash都可以。Go之所以在编写操作符时被广泛使用，是因为它为Kubernetes提供了丰富的客户端库，而不是因为它是构建操作符的唯一方式。在我们的实验室中，我们将使用Python。应用程序打开与API服务器的持续连接，并观察配置图的变化。一旦检测到更改，它将在configmonitors类型的资源中搜索匹配的ConfigMap名称。找到后，configmonitor会提供必要的标签，操作员可以通过这些标签通过podSelector参数搜索pod。我们的运算符的代码文件如下所示:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="3793" class="mc kr it ly b gy md me l mf mg">import requests<br/>import os<br/>import json<br/>import logging<br/>import sys</span><span id="be30" class="mc kr it ly b gy ne me l mf mg">log = logging.getLogger(__name__)<br/>out_hdlr = logging.StreamHandler(sys.stdout)<br/>out_hdlr.setFormatter(logging.Formatter('%(asctime)s %(message)s'))<br/>out_hdlr.setLevel(logging.INFO)<br/>log.addHandler(out_hdlr)<br/>log.setLevel(logging.INFO)</span><span id="ce19" class="mc kr it ly b gy ne me l mf mg">base_url = "<a class="ae kp" href="http://127.0.0.1:8001" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8001</a>"</span><span id="7169" class="mc kr it ly b gy ne me l mf mg">namespace = os.getenv("res_namespace", "default")</span><span id="5858" class="mc kr it ly b gy ne me l mf mg"># This is the function that searches for and kills Pods by searching for them by label</span><span id="2a23" class="mc kr it ly b gy ne me l mf mg">def kill_pods(labels):<br/>    # We receive labels in the form of a list<br/>    for label in labels:<br/>        url = "{}/api/v1/namespaces/{}/pods?labelSelector={}".format(<br/>            base_url, namespace, label)<br/>        r = requests.get(url)<br/>        # Make the request to the endpoint to retreive the Pods<br/>        response = r.json()<br/>        # Extract the Pod name from the list<br/>        pods = [p['metadata']['name'] for p in response['items']]<br/>        # For each Pod, issue an HTTP DELETE request<br/>        for p in pods:<br/>            url = "{}/api/v1/namespaces/{}/pods/{}".format(<br/>                base_url, namespace, p)<br/>            r = requests.delete(url)<br/>            if r.status_code == 200:<br/>                log.info("{} was deleted successfully".format(p))<br/>            else:<br/>                log.error("Could not delete {}".format(p))</span><span id="0dc3" class="mc kr it ly b gy ne me l mf mg"># This function is used to extract the Pod labels from the configmonitor resource.<br/># It takes the configmap name as the argument and uses it to search for configmonitors<br/># that have the configmap name in its spec<br/>def getPodLabels(configmap):<br/>    url = "{}/apis/magalix.com/v1/namespaces/{}/configmonitors".format(<br/>        base_url, namespace)<br/>    r = requests.get(url)<br/>    # Issue the HTTP request to the appropriate endpoint<br/>    response = r.json()<br/>    # Extract the podSelector part from each object in the response<br/>    pod_labels_json = [i['spec']['podSelector']<br/>                       for i in response['items'] if i['spec']['configmap'] == "flaskapp-config"]<br/>    result = [list(l.keys())[0] + "=" + l[list(l.keys())[0]]<br/>              for l in pod_labels_json]<br/>    # The result is a list of labels<br/>    return result</span><span id="841a" class="mc kr it ly b gy ne me l mf mg"># This is the main function that watches the API for changes</span><span id="2d9f" class="mc kr it ly b gy ne me l mf mg">def event_loop():<br/>    log.info("Starting the service")<br/>    url = '{}/api/v1/namespaces/{}/configmaps?watch=true"'.format(<br/>        base_url, namespace)<br/>    r = requests.get(url, stream=True)<br/>    # We issue the request to the API endpoint and keep the conenction open<br/>    for line in r.iter_lines():<br/>        obj = json.loads(line)<br/>        # We examine the type part of the object to see if it is MODIFIED<br/>        event_type = obj['type']<br/>        # and we extract the configmap name because we'll need it later<br/>        configmap_name = obj["object"]["metadata"]["name"]<br/>        if event_type == "MODIFIED":<br/>            log.info("Modification detected")<br/>            # If the type is MODIFIED then we extract the pod labels by using the getPodLabels function<br/>            # passing the configmap name as a parameter<br/>            labels = getPodLabels(configmap_name)<br/>            # Once we have the labels, we can use them to find and kill the Pods by calling the<br/>            # kill_pods function<br/>            kill_pods(labels)</span><span id="1670" class="mc kr it ly b gy ne me l mf mg">event_loop()</span></pre><h1 id="71c6" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">操作员部署</h1><p id="9a91" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">正如您在代码文件中看到的，我们的操作符只是一个Python程序。我们将通过将它添加到Docker容器并将其推送到注册表来将其部署到集群。我们还需要另一个容器作为<a class="ae kp" href="https://www.magalix.com/blog/tag/ambassador" rel="noopener ugc nofollow" target="_blank">大使容器</a>。</p><h1 id="efd4" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">操作员应用程序容器</h1><p id="20ef" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">应用程序容器的docker文件如下所示:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="480b" class="mc kr it ly b gy md me l mf mg">FROM python:latest<br/>RUN pip install requests<br/>COPY main.py /main.py<br/>ENTRYPOINT [ "python", "/main.py" ]</span></pre><p id="7dfc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要建立并推广这个Dockerfile文件:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="b0b7" class="mc kr it ly b gy md me l mf mg">docker build -t magalixcorp/operator .<br/>docker push magalixcorp/operator</span></pre><h1 id="a0ee" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">部署文件</h1><p id="7a26" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">sidecar或大使容器只是一个包含kubectl的图像。我们将使用它来运行kubectl代理命令。将两个容器组合在一个<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-deployments-101" rel="noopener ugc nofollow" target="_blank">部署</a>中，如下所示:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="7c20" class="mc kr it ly b gy md me l mf mg">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: operator<br/>  labels:<br/>    app: operator<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: operator<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: operator<br/>    spec:<br/>      containers:<br/>      - name: proxycontainer<br/>        image: lachlanevenson/k8s-kubectl<br/>        command: ["kubectl","proxy","--port=8001"]<br/>      - name: app<br/>        image: magalixcorp/operator<br/>        env:<br/>          - name: res_namespace<br/>            valueFrom:<br/>              fieldRef:<br/>                fieldPath: metadata.namespace</span></pre><p id="49a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，我们将名称空间作为环境变量注入到操作应用程序中。名称空间本身来自向下API，这是Kubernetes的一个特性，允许您获取关于当前对象设置的信息。关于这个模式以及如何使用它的更多信息，请参考我们的文章‘反射模式’。</p><p id="63be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，我们已经构建并部署了许多组件。在继续测试我们的实验室之前，让我们快速回顾一下我们所做的工作:</p><ul class=""><li id="917f" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated">应用程序映像:应用程序部署窗格使用它来启动应用程序容器。</li><li id="6ab6" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">ConfigMap:它包含应用程序容器使用的配置文件。</li><li id="ea3d" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">自定义资源定义:这是扩展API的资源，使Kubernetes能够接受和使用configmonitors。ConfigMonitor是一种自定义资源，它具有配置映射的名称以及使用此配置映射的pod的标签。</li><li id="5148" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">ConfigMonitor:基于CRD，我们创建一个具有configmap名称和pod标签的configmonitor对象。</li><li id="3384" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">操作符应用程序图像:这是一个包含操作符逻辑的Python应用程序。</li><li id="8292" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">操作员部署:这是运行操作员映像的部署资源。这个部署运行的Pod有两个容器:操作员容器和大使(边车)容器。第二个运行kubectl代理命令，该命令将命令从操作符容器中继到集群的API服务器。</li></ul><h1 id="8736" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">启动实验室并测试结果</h1><p id="5c10" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">让我们为我们的演示应用程序创建一个部署。该部署确保当我们的操作员由于配置图更改而删除应用程序窗格时，该应用程序窗格将重新启动。我们的演示应用程序的部署定义如下所示:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="2fea" class="mc kr it ly b gy md me l mf mg">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: frontend<br/>  labels:<br/>    app: frontend<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: frontend<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: frontend<br/>    spec:<br/>      containers:<br/>      - name: app<br/>        image: magalixcorp/flask:operator<br/>        volumeMounts:<br/>        - name: config-vol<br/>          mountPath: /config<br/>      volumes:<br/>      - name: config-vol<br/>        configMap:<br/>          name: flaskapp-config</span></pre><p id="2d1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们应用这个部署:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="fcd1" class="mc kr it ly b gy md me l mf mg">kubectl apply -f deployment.yml                                                                                                                                              <br/>deployment.apps/frontend created</span></pre><p id="1ab6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在开始实验之前，我们需要确保应用程序运行正常。在真实的场景中，您将创建一个服务，并可能创建一个入口来允许您的应用程序接收流量。在我们的例子中，由于我们已经有了很多组件，让我们登录到应用程序容器并对localhost发出curl命令:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="4a1e" class="mc kr it ly b gy md me l mf mg">kubectl get pods                                                                                                                                                             <br/>NAME                        READY   STATUS    RESTARTS   AGE<br/>frontend-7f8d89fb68-77qv4   1/1     Running   0          25s<br/>operator-6d8464b567-v7sh4   2/2     Running   0          34m<br/>$ kubectl exec -it frontend-7f8d89fb68-77qv4 -- bash                                                                                                                           <br/>root@frontend-7f8d89fb68-77qv4:/app# curl localhost &amp;&amp; echo<br/>Welcome to Kubernetes!</span></pre><p id="9310" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，我们的应用程序用配置图中定义的消息进行响应。让我们更改消息，看看我们的操作员是否会接受更改并做出相应的响应:</p><p id="19e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们更改配置图，使其如下所示:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="decc" class="mc kr it ly b gy md me l mf mg">apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  name: flaskapp-config<br/>data:<br/>  config.cfg: <br/>    MSG="Welcome to Operators!"</span></pre><p id="0493" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们应用配置图，看看我们的应用程序窗格会发生什么:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="a03e" class="mc kr it ly b gy md me l mf mg">$ kubectl apply -f configmap.yml                                                                                                                                               <br/>configmap/flaskapp-config configured<br/>$ kubectl get pods    </span></pre><p id="adfc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很明显，前端pod(演示应用程序)已经重新启动。它只有4秒钟。但是让我们通过点击API查看消息来仔细检查一下:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="bd4b" class="mc kr it ly b gy md me l mf mg">kubectl exec -it frontend-7f8d89fb68-jgzbz -- bash                                                                                                                          <br/>root@frontend-7f8d89fb68-jgzbz:/app# curl localhost &amp;&amp; echo<br/>Welcome to Operators!</span></pre><p id="60bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，会显示正确的消息。最后，让我们看看我们的操作员生成的日志消息:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="eef8" class="mc kr it ly b gy md me l mf mg">$ kubectl logs operator-6d8464b567-v7sh4 -c app                                                                                                                                <br/>2019-09-27 19:44:08,958 Starting the service<br/>2019-09-27 20:22:02,610 Modification detected<br/>2019-09-27 20:22:02,648 frontend-7f8d89fb68-77qv4 was deleted successfully</span></pre><h1 id="82da" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="8fa8" class="mq mr it js b jt lo jx lp kb nf kf ng kj nh kn mv mw mx my bi translated">尽管Kubernetes带来了开箱即用的强大功能，但它的设计方式使其具有高度的模块化和可扩展性。</li><li id="9c03" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">如果您需要与本地Kubernetes资源进行交互，比如pod、服务、配置图等。那么使用定制控制器就没问题了。</li><li id="1d7b" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">自定义控制器只不过是一个订阅和监听API服务器的程序。当它检测到感兴趣的事件时，它会采取相应的措施，可能会使用事件数据中的信息。</li><li id="061c" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">如果您的需求更加复杂，您可以决定创建多个本地Kubernetes资源的组合。这种组合被称为自定义资源定义(CRD)。</li><li id="09d4" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">使用CRD，您可以创建一个全功能的MySQL集群，它接受节点数量、监听端口等配置参数。您可以像处理其他本地资源一样处理这个集群。</li><li id="923b" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">CRD需要一个自己的定制控制器才能正常工作。只是这一次，它被称为一个操作员。操作员是使用CRDs的自定义控制器。</li><li id="26cb" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">操作员可以作为掌舵图的一部分进行部署。</li><li id="25e8" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">运算符可以用任何现代编程语言编写。然而，你会发现大多数操作符都是用Go编写的，因为它有丰富的客户端库。</li></ul></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="7a3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">原载于</em><a class="ae kp" href="https://www.magalix.com/blog/creating-custom-kubernetes-operators" rel="noopener ugc nofollow" target="_blank">https://www . magalix . com/blog/creating-custom-kubernetes-operators</a><em class="ko">2019年12月9日。</em></p></div></div>    
</body>
</html>