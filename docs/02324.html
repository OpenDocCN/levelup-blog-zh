<html>
<head>
<title>BEM CSS in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应中的边界元CSS</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/bem-css-in-react-e0d4a4721872?source=collection_archive---------1-----------------------#2020-03-06">https://levelup.gitconnected.com/bem-css-in-react-e0d4a4721872?source=collection_archive---------1-----------------------#2020-03-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/4c9f7f8dcbb3a1663a4195decc14d707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*JUOm5i5XVGQ03mBAwimFvA.png"/></div></figure><p id="23e0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这篇文章中，我打算回答两个问题:</p><ol class=""><li id="e684" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">BEM是什么？</li><li id="7811" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">BEM应该如何应用于React组件的设计？</li></ol><p id="3f47" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">BEM是Block Element Modifier的缩写。它不是一个框架或库。这只是一个更大的CSS架构难题的一小部分。具体来说，BEM是一个严格的CSS选择器命名约定，为组件组合提供了一个有价值的心智模型。请允许我解释…</p><blockquote class="lj lk ll"><p id="d39b" class="jx jy lm jz b ka kb kc kd ke kf kg kh ln kj kk kl lo kn ko kp lp kr ks kt ku im bi translated"><em class="it">BEM中的术语</em>元素<em class="it">不应与</em> HTML元素<em class="it">混淆。HTML元素是HTML标签在HTML文档中的实际应用。比如一个表示为HTML元素的</em> <code class="fe lq lr ls lt b"><em class="it">input</em></code> <em class="it">标签就是</em> <code class="fe lq lr ls lt b"><em class="it">&lt;input /&gt;</em></code> <em class="it">。HTML元素支持属性，例如</em> <code class="fe lq lr ls lt b"><em class="it">class</em></code> <em class="it">属性(例如</em> <code class="fe lq lr ls lt b"><em class="it">&lt;input class="fancy-input" /&gt;</em></code> <em class="it">)，我们将在BEM的研究中大量使用这些属性。</em></p></blockquote><p id="e87b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">今天构建用户界面时，我们经常使用基于组件的JavaScript库，如React、Vue、Svelte等。不同的库和框架对样式有不同的看法。无论好坏，React基本上没有意见。在我知道React是什么之前，我用BEM创建了组件库。几年过去了，我已经深入React世界，仍然发现BEM是我构建可伸缩、可预测CSS的首选。</p><h1 id="b71f" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">边界元块</h1><p id="1fbe" class="pw-post-body-paragraph jx jy it jz b ka ms kc kd ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku im bi translated">b代表街区。块是独立的组件，可能会也可能不会在整个场地中重复使用。在React上下文中，BEM <em class="lm">块</em>通常映射到单个React表示组件。它们可以是很大的实体组件，比如充满醒目图片、标题、行动号召和导航菜单的页面英雄。块也采用简单组件的形式，如按钮、链接或标题元素。边界元块可以并且通常<em class="lm">应该</em>包含其他边界元块。如果我们已经定义了块组件<code class="fe lq lr ls lt b">Button</code>、<code class="fe lq lr ls lt b">Navigation</code>和<code class="fe lq lr ls lt b">Heading</code>，那么我们的<code class="fe lq lr ls lt b">Hero</code>块很可能包含这样的组件。</p><p id="2d6e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">设置块样式时，块应该包含该组件所需的所有基本样式。一个块的变体，称为修饰符，将拥有修改基本块样式的CSS规则(我们将在后面更多地讨论)。</p><p id="b2ce" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们的<code class="fe lq lr ls lt b">Button</code>组件可能看起来像这样:</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="eed5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我更喜欢将块选择器命名为与组件相同的名称。在这种情况下，<code class="fe lq lr ls lt b">Button</code>映射到<code class="fe lq lr ls lt b">.button</code>类名。有些人喜欢大写这个街区的名字(<code class="fe lq lr ls lt b">.Button</code>)。就我个人而言，我使用kebab case作为我的CSS类名，但是你可以随意使用😁。</p><h1 id="0845" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">边界元修改器</h1><p id="0e3a" class="pw-post-body-paragraph jx jy it jz b ka ms kc kd ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku im bi translated">暂时跳过BEM元素，我想解释一下BEM修改器。修饰符正是那个——<em class="lm">修饰符</em>。它们旨在修改基类(通常是块)。修饰符应该只包含修改基类所必需的样式。修饰符使用双破折号<code class="fe lq lr ls lt b">--</code>来分隔修饰符名称和它们所修改的基类名称:</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">带修改器的BEM按钮</figcaption></figure><p id="ae26" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在上面的代码片段中，我们引入了3个新的修饰符:outline、primary和outline-primary。这些修饰符是为了说明的目的，但是它们强调了我想提出的关于修饰符的两个要点:</p><ol class=""><li id="50fe" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">修饰符应该在它们所修饰的东西之后声明。这是必要的，因为<code class="fe lq lr ls lt b">.button</code>及其所有修饰符的CSS特异性是相同的。但是，因为修饰符出现在基类之后，所以修饰符的规则优先于基类中定义的冲突规则。</li><li id="7c03" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">修改者必须只包括他们需要修改的特定规则。例如，大纲修改器只有3条规则:<code class="fe lq lr ls lt b">background-color</code>、<code class="fe lq lr ls lt b">border-color</code>和<code class="fe lq lr ls lt b">color</code>。不包括任何关于<code class="fe lq lr ls lt b">font-size</code>、<code class="fe lq lr ls lt b">font-weight</code>等的内容。这些留给基类<code class="fe lq lr ls lt b">.button</code>来定义。这意味着当对HTML元素应用修饰符时，也必须包括基类。</li></ol><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">如何以及如何不应用边界元修改器</figcaption></figure><h1 id="7c3d" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">另一种不明智的方法</h1><p id="7b6f" class="pw-post-body-paragraph jx jy it jz b ka ms kc kd ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku im bi translated">看了上面的例子，你可能会发现多余的BEM块命名空间很笨拙，并想知道为什么你不这样做:</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="13c4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当应用于HTML时，它将更改为以下内容:</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="7317" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">从好的方面来说，这种方法意味着编写更少的代码，并且我们通过耦合选择器有效地命名了基类的修饰符(例如<code class="fe lq lr ls lt b">.button.outline</code>)。我不推荐这种方法的原因在于我对CSS架构的一个更大但相关的信念:<strong class="jz iu"> CSS选择器应该尽可能不具体。</strong></p><p id="82cd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe lq lr ls lt b">.button.outline {...}</code>例子的问题是我们将选择器的特异性加倍了。如果我后来想进一步修改特定用例的<code class="fe lq lr ls lt b">color</code>、<code class="fe lq lr ls lt b">background-color</code>或<code class="fe lq lr ls lt b">border-color</code>，这会产生问题。为了让我的新风格发挥作用，我的新选择器必须至少和<code class="fe lq lr ls lt b">.button.outline</code>一样具体。</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="e4c5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这种情况下，<code class="fe lq lr ls lt b">.flashy-button</code>边框颜色将立即被更具体的<code class="fe lq lr ls lt b">.button.outline</code>选择器取代。为了解决这个问题，我们需要引入任意数量的技巧，比如将类名(<code class="fe lq lr ls lt b">.flashy-button.flashy-button {...}</code>)对折，或者在类名上添加一个<code class="fe lq lr ls lt b">!important</code>。我们可以通过对修饰符使用单个类名来保持CSS特异性图相对平坦，从而避免这个问题。</p><h1 id="0ede" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">应用修改器进行反应</h1><p id="72a0" class="pw-post-body-paragraph jx jy it jz b ka ms kc kd ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku im bi translated">我是<code class="fe lq lr ls lt b">classnames</code>图书馆的忠实粉丝。这是一种有条件地将类名应用于React元素的有用方法。让我们为我们的<code class="fe lq lr ls lt b">Button</code>组件添加对3个修饰符的支持:</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="a47f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe lq lr ls lt b">classnames</code>库可以接受任意数量的字符串或对象作为参数。字符串参数连接到<code class="fe lq lr ls lt b">classNames</code>函数返回的结果字符串。对象用于有条件地应用类名。对象的键代表你可能想要添加的类名。对应的值是计算结果为true或false的表达式。如果表达式评估为真，存储在对象的键中的类名将应用于<code class="fe lq lr ls lt b">classNames</code>返回的结果字符串。如果我们要用以下道具来呈现我们的<code class="fe lq lr ls lt b">Button</code>组件:</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="bf5d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe lq lr ls lt b">classNames</code>函数将返回<code class="fe lq lr ls lt b">'button button--outline-primary'</code>。</p><h1 id="41bb" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">边界元</h1><p id="0f34" class="pw-post-body-paragraph jx jy it jz b ka ms kc kd ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku im bi translated">根据我的经验，边界元是边界元方程中最容易被误解的部分。BEM元素用一个<code class="fe lq lr ls lt b">__</code>(双下划线)表示。结构如下。<code class="fe lq lr ls lt b">.&lt;block-name&gt;__&lt;child-name&gt;</code>。BEM元素由其父块命名。边界元块和边界元单元之间的紧密关系是很重要的。然而，只有在包装BEM块的上下文中样式化HTML元素<em class="lm">才有意义时，才应该使用BEM元素。为了说明这一点，我将使用一个更复杂的BEM块示例:一个英雄。我们的React组件可能如下所示:</em></p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="6267" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这种情况下，BEM块是<em class="lm"> hero </em>并且恰当命名的<code class="fe lq lr ls lt b">hero</code>类名被正确地应用于顶层元素:T1。但是我应该如何设计子元素的样式呢:<code class="fe lq lr ls lt b">h1</code>、<code class="fe lq lr ls lt b">p</code>和<code class="fe lq lr ls lt b">Button</code>？我是否应该立即创建一个<code class="fe lq lr ls lt b">.hero__title</code>、<code class="fe lq lr ls lt b">.hero__message</code>和<code class="fe lq lr ls lt b">.hero__button</code>？也许吧。但不一定。</p><p id="6093" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们从<code class="fe lq lr ls lt b">h1</code>和<code class="fe lq lr ls lt b">p</code>开始。不管这些BEM讨论，明智的做法是为标题、段落等常见元素提供一些基线元素样式。作为一个例子，我会把这个<em class="lm">放在我的任何组件样式的</em>之前。</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="2436" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在hero块的上下文中，如果应用于这些元素的基线样式是好的，那么您可以让它们保持原样。对于我们的定制<code class="fe lq lr ls lt b">Button</code>组件也是如此。如果它看起来像你想要的那样，那么它将被赋予自己的BEM块类名<code class="fe lq lr ls lt b">.button</code>，我们就可以收工了。</p><p id="0618" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，我经常看到开发人员做的是立即跳转到将所有块祖先元素样式化为BEM元素。所以他们会这样做:</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="ffe3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在最坏的情况下，开发人员可能会完全忽略我们可重用的<code class="fe lq lr ls lt b">Button</code>并为<code class="fe lq lr ls lt b">.hero__button</code>创建一组全新的样式，这些样式复制了块<code class="fe lq lr ls lt b">.button</code>中的许多样式。这挫败了可重用组件的意义，所以<em class="lm">不要这样做。</em></p><p id="6869" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，如果一切看起来都很好，不需要进一步的样式，我们可以不创建任何BEM元素样式，让我们的英雄块保持原样。然而，如果我们需要调整一些特定于我们的hero用例的东西，那么是时候引入BEM元素了:</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="2725" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">有趣的是，<code class="fe lq lr ls lt b">Button</code>同时作为边界元<em class="lm">模块</em> ( <code class="fe lq lr ls lt b">.button</code>)和边界元<em class="lm">元素</em> ( <code class="fe lq lr ls lt b">.hero__cta</code>)。那完全没问题！就我而言，这是CSS的最佳组合🤓</p><p id="6e66" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们的<code class="fe lq lr ls lt b">Button</code>组件有一个小问题。组件<code class="fe lq lr ls lt b">Hero</code>正试图将一个定制的<code class="fe lq lr ls lt b">className</code>道具传递给我们的<code class="fe lq lr ls lt b">Button</code>。如果我们使用<code class="fe lq lr ls lt b">Button</code>的现有实现，<code class="fe lq lr ls lt b">Button</code>将忽略这个道具。让我们来解决这个问题:</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="2d47" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们必须从<code class="fe lq lr ls lt b">props</code>对象中析构<code class="fe lq lr ls lt b">className</code>属性，然后将它添加到<code class="fe lq lr ls lt b">classNames()</code>的参数中。如果一个值被传递给<code class="fe lq lr ls lt b">className</code>属性，它将被适当地应用到产生的<code class="fe lq lr ls lt b">classes</code>变量。如果省略，<code class="fe lq lr ls lt b">classNames</code>函数将从结果中省略<code class="fe lq lr ls lt b">undefined</code>值。</p><h1 id="cd60" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">关于CSS特异性的一个注记</h1><p id="2434" class="pw-post-body-paragraph jx jy it jz b ka ms kc kd ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku im bi translated">如果你回头看看我们引入了一些BEM元素样式的hero示例，你会注意到BEM元素<code class="fe lq lr ls lt b">hero__cta</code>被应用到了<code class="fe lq lr ls lt b">Button</code>元素。我们知道，在幕后，<code class="fe lq lr ls lt b">Button</code>会将<code class="fe lq lr ls lt b">button</code>和<code class="fe lq lr ls lt b">hero__cta</code>类名应用于呈现的<code class="fe lq lr ls lt b">&lt;button /&gt;</code>。<code class="fe lq lr ls lt b">.button</code>和<code class="fe lq lr ls lt b">.hero__cta</code>具有相同水平的特异性。我们的意图是应用于<code class="fe lq lr ls lt b">Button</code>的边框颜色是<code class="fe lq lr ls lt b">.hero__cta</code>中指定的颜色，而不是<code class="fe lq lr ls lt b">.button</code>中定义的基线值。我们如何确保这一切发生？</p><p id="7488" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这就是你的捆扎机发挥作用的地方。请注意我们在Hero.js模块中加载<code class="fe lq lr ls lt b">./Button</code>和<code class="fe lq lr ls lt b">./Hero.css</code>依赖项的顺序:</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="d4f0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe lq lr ls lt b">./Hero.css</code>是继之后进口<em class="lm">的T21。这很重要。当您的bundler(例如Webpack)构建最终的包(JavaScript和CSS)时，它会密切关注依赖项的创作顺序。因为<code class="fe lq lr ls lt b">./Button</code>是在<code class="fe lq lr ls lt b">./Hero.css</code>之前导入的，所以Webpack(大概还有其他捆绑器)会先进入Button.js <em class="lm">再进入</em>，甚至不会对<code class="fe lq lr ls lt b">./Hero.css</code>有任何影响。由于Button.js导入了<code class="fe lq lr ls lt b">./Button.css</code>，Button.css将包含在生成的css包<em class="lm">中，在</em>hero . CSS的内容之前。这就是为什么我总是建议你<strong class="jz iu">在你的模块</strong>中加载你的组件的CSS依赖作为最终的依赖。</em></p><h1 id="b20b" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">最后</h1><p id="68ca" class="pw-post-body-paragraph jx jy it jz b ka ms kc kd ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku im bi translated">现在有很多方法来创作CSS。有许多CSS-in-JS选项、CSS模块，还有更多“传统的”选项，就像我在本文中提到的。在我看来，CSS-in-JS在基于数据(道具)的样式高度动态的情况下大放异彩。但是在你需要一些简单的变化和一个合理的方法来建模和扩展你的站点/应用的CSS的情况下，BEM已经被证明是一个极好的可扩展模型。</p><p id="9f19" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最后说明:我也是CSS模块的忠实粉丝。在以后的文章中，我将讨论如何将BEM方法应用于CSS模块。</p></div></div>    
</body>
</html>