<html>
<head>
<title>Don’t use Lambda to move data! API Gateway can help</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要用Lambda移动数据！API网关可以提供帮助</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dont-use-lambda-to-move-data-api-gateway-can-help-fe899df239e6?source=collection_archive---------1-----------------------#2020-04-29">https://levelup.gitconnected.com/dont-use-lambda-to-move-data-api-gateway-can-help-fe899df239e6?source=collection_archive---------1-----------------------#2020-04-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b684" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">API Gateway是Lambda的最佳伴侣，很多人都是用API Gateway尝试自己的第一个Lambda函数。但很多人不知道的是，API Gateway不仅仅是一个触发器，它能做的比你想象的更多。</p><p id="4bb6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文将带您了解如何使用API Gateway来:</p><ol class=""><li id="c819" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">验证用户输入</li><li id="85f1" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">转换数据格式</li><li id="64f0" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">与其他AWS服务集成</li></ol></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="8eaa" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">1.输入验证</h1><p id="f237" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">最重要的安全原则之一是永远不要相信用户的输入。所以你可能在Lambda函数的开头有一些验证用户输入的代码。</p><p id="e018" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以首先使用API Gateway验证输入，避免不必要的Lambda调用，而不是调用Lambda函数来验证用户输入并返回错误。我们可以这样做:</p><h2 id="b66b" class="mm lk it bd ll mn mo dn lp mp mq dp lt kb mr ms lx kf mt mu mb kj mv mw mf mx bi translated">步骤1:创建数据模型</h2><p id="8131" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">首先，我们需要定义我们想要的用户输入的模型，以便API Gateway可以使用它来进行验证。</p><p id="8c5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在AWS控制台中，创建REST API后，您可以看到一个名为<strong class="js iu">模型的页面。</strong></p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi my"><img src="../Images/d7e370fc39fcb25b166d2e159304eb43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Moykd5gpl049RpTa4o6umw.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">在<strong class="bd ll">模型</strong>页面中，我们可以使用JSON模式创建数据模型</figcaption></figure><p id="7b72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Model </strong>是一个<a class="ae no" href="https://json-schema.org/learn/getting-started-step-by-step.html" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> JSON schema </strong> </a>，可以定义请求内容的预期结构。例如，我可以定义我的API端点来摄取包含字符串<code class="fe np nq nr ns b">name</code>的JSON一个整数<code class="fe np nq nr ns b">id</code>；并且没有额外的价值，通过下面的模式:</p><pre class="mz na nb nc gt nt ns nu nv aw nw bi"><span id="6f11" class="mm lk it ns b gy nx ny l nz oa">{<br/>    "$schema":"<a class="ae no" href="http://json-schema.org/draft-04/schema#" rel="noopener ugc nofollow" target="_blank">http://json-schema.org/draft-04/schema#</a>",<br/>    "properties":{<br/>        "name":{<br/>            "type":"string"<br/>        },<br/>        "id":{<br/>            "type":"integer"<br/>        }<br/>    },<br/>    "required":[<br/>        "id",<br/>        "name"<br/>    ],<br/>    "additionalProperties":false<br/>}</span></pre><p id="5dd5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这只是一个简单的例子。使用JSON Schema，您可以定义更复杂的验证规则，比如最小值/最大值、枚举、模式匹配、嵌套对象。</p></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h2 id="ed38" class="mm lk it bd ll mn mo dn lp mp mq dp lt kb mr ms lx kf mt mu mb kj mv mw mf mx bi translated">步骤2:用API端点绑定模型</h2><p id="91b8" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">接下来，我们需要将模型绑定到我们想要进行验证的端点。在<strong class="js iu">resources</strong>页面，点击进入端点，选择<strong class="js iu">方法请求</strong>。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ob"><img src="../Images/0eeb12edb1d4f9c507a3b97916cb8b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IjT1LQPzCGdEodpeBtL0vA.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">在<strong class="bd ll">方法请求</strong>页面中，我们可以将模型绑定到一个端点</figcaption></figure><p id="6d6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们为<strong class="js iu">请求验证器</strong>选择<strong class="js iu">“验证主体、查询字符串参数和头”</strong>，以便API网关验证来自用户的请求主体。</p><p id="a9c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu">请求体</strong>选项卡下，我们添加一行，其中<strong class="js iu">内容类型</strong>设置为<strong class="js iu">应用程序/json </strong>(当然，如果您的API接收不同的内容类型，您可以使用其他内容类型)。在<strong class="js iu">模型名称</strong>列中，我们选择我们在步骤1中创建的模型。</p><p id="f1c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们可以测试我们的API。返回<strong class="js iu">方法执行</strong>页面，点击<strong class="js iu">测试</strong>。在此页面上，我们可以预览API的行为，而无需部署它。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi oc"><img src="../Images/ce42b17dd29c19663ffc0cc012cd6ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lUsnC_rpolv9GTKh5iBuFA.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">如果输入无效，API将返回HTTP 400错误</figcaption></figure><p id="e8be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我尝试使用一个空对象作为输入。因为模型声明<code class="fe np nq nr ns b">name</code>和<code class="fe np nq nr ns b">id</code>是必需的，API会立即返回一个HTTP 400错误，而不会调用下游流程。</p></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h2 id="dd29" class="mm lk it bd ll mn mo dn lp mp mq dp lt kb mr ms lx kf mt mu mb kj mv mw mf mx bi translated">步骤3:修改错误响应</h2><p id="4b74" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">正如我们所看到的，API返回了一个错误消息<strong class="js iu">“无效的请求体”</strong>。例如，如果我们输入一个带有<code class="fe np nq nr ns b">name</code>和<code class="fe np nq nr ns b">id</code>的JSON，但是数据类型错误:</p><pre class="mz na nb nc gt nt ns nu nv aw nw bi"><span id="eb41" class="mm lk it ns b gy nx ny l nz oa">{<br/>    "name": "Richard",<br/>    "id": "This is a string"<br/>}</span></pre><p id="f835" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它仍然返回相同的消息。它不是很有用，因为它没有告诉用户请求的哪一部分是无效的。</p><p id="1725" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu">网关响应</strong>页面中，我们可以为每种响应类型定制响应。对于我们的用例，我们将定制<strong class="js iu">错误的请求体</strong>。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div class="gh gi od"><img src="../Images/549943027b9830a26f5d94239622c2d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*X9XvMeHde-VTqncaybnRow.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">我们可以定制来自API网关的响应</figcaption></figure><p id="3b2f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">点击<code class="fe np nq nr ns b">application/json</code>下的<strong class="js iu">响应模板</strong>，我们可以看到默认的模板是:</p><pre class="mz na nb nc gt nt ns nu nv aw nw bi"><span id="5049" class="mm lk it ns b gy nx ny l nz oa">{"message":$context.error.messageString}</span></pre><p id="354e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要把它改成更有意义的信息。我们可以使用许多<a class="ae no" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#context-variable-reference" rel="noopener ugc nofollow" target="_blank">变量</a>来构造响应体。在我们的例子中，我们将使用<code class="fe np nq nr ns b">$context.error.validationErrorString</code>，我们将模板改为:</p><pre class="mz na nb nc gt nt ns nu nv aw nw bi"><span id="4b68" class="mm lk it ns b gy nx ny l nz oa">{"message":"$context.error.validationErrorString"}</span></pre><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi oe"><img src="../Images/7003cb3627b71d5063b74776df5fe9be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2wlc9LvbwcICCtcy2BfJIQ.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">使用$context变量收缩响应体</figcaption></figure><p id="7150" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">保存模板后，我们可以返回到<strong class="js iu">方法执行</strong>页面，再次进行测试。</p><p id="4902" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，如果我们输入一个空对象作为输入，API Gateway会用消息响应一个HTTP 400错误</p><pre class="mz na nb nc gt nt ns nu nv aw nw bi"><span id="53d1" class="mm lk it ns b gy nx ny l nz oa">[object has missing required properties (["id","name"])]</span></pre><p id="2882" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们将一个字符串放入<strong class="js iu"> id </strong>字段，它会以消息作为响应</p><pre class="mz na nb nc gt nt ns nu nv aw nw bi"><span id="c77f" class="mm lk it ns b gy nx ny l nz oa">[instance type (string) does not match any allowed primitive type (allowed: ["integer"])]</span></pre><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi of"><img src="../Images/f55d4639b4df9dd7a1a0b3bd5a7215ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5IlTmwnOjaVRssx1JxIMHw.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">响应现在包含验证错误</figcaption></figure></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="a39d" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">2.数据转换和服务集成</h1><p id="d90b" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">很多时候，当人们想要向客户提供AWS服务时，他们不会直接公开服务API，因为他们想要控制请求和响应格式。首先必须考虑使用Lambda来转换数据格式，并对AWS服务进行API调用。</p></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h2 id="8a47" class="mm lk it bd ll mn mo dn lp mp mq dp lt kb mr ms lx kf mt mu mb kj mv mw mf mx bi translated">示例:从DynamoDB获取记录</h2><p id="ba5c" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">从DynamoDB查询记录应该是最常见的API用例之一。API Gateway可以帮助我们将用户输入的查询字符串翻译成DynamoDB查询。并且把结果翻译成我们想要的格式给用户。</p><p id="06bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本例中，我将创建一个GET端点，从查询字符串中获取<code class="fe np nq nr ns b">id</code>，然后从DynamoDB返回相关记录。</p></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h2 id="d50e" class="mm lk it bd ll mn mo dn lp mp mq dp lt kb mr ms lx kf mt mu mb kj mv mw mf mx bi translated">步骤1:创建IAM角色</h2><p id="1c90" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">我们需要为API网关创建一个IAM角色来访问AWS服务。在本例中，我们将创建一个授予DynamoDB查询权限的角色。</p><p id="d8dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu"> IAM角色</strong>页面中，我们创建了一个新角色。对于<strong class="js iu">【可信实体】</strong>，我们选择<strong class="js iu"> API网关</strong>。然后，我们将所有配置保留为默认设置，直到最后一步。给角色起一个名字，例如<strong class="js iu">DynamoDBQueryForAPIGateway</strong>。</p><div class="mz na nb nc gt ab cb"><figure class="og nd oh oi oj ok ol paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><img src="../Images/d104272429369f0c1391741359c16012.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*BLSTdpTgh1mVzkTtrTVmsA.png"/></div></figure><figure class="og nd om oi oj ok ol paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><img src="../Images/ebd6c5e2a68fb39fed9b8a62f98b07ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*CfN4dmIxTVjzkm39dDOKYA.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk on di oo op translated">为API网关创建新角色</figcaption></figure></div><p id="263a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们需要分离默认的<strong class="js iu">AmazonAPIGatewayPushToCloudWatchLogs</strong>策略，并添加我们的内联策略。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi oq"><img src="../Images/222bcb38c6262edcc7798e4d7a129618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BGDWjzGeje2aRQ7e6jFTlA.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">删除默认策略并添加我们的内联策略</figcaption></figure><p id="5364" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在内联策略中，我们在表上授予<strong class="js iu"> DynamoDB Query </strong>权限。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi or"><img src="../Images/62a455148603615d267f21cf874b516b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3XdAXKsuLIwA1l09_fkjfg.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">添加内联策略以授予对DynamoDB表的查询访问权限</figcaption></figure></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h2 id="532a" class="mm lk it bd ll mn mo dn lp mp mq dp lt kb mr ms lx kf mt mu mb kj mv mw mf mx bi translated">步骤2:要求用户提供查询字符串参数</h2><p id="6f07" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">在<strong class="js iu"> GET </strong>方法的<strong class="js iu">方法请求</strong>页面下，我们为<strong class="js iu">请求验证器</strong>选择<strong class="js iu">“验证查询字符串参数和头”</strong>。</p><p id="c662" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu">“URL查询字符串参数”</strong>部分，我们添加了一个名为<code class="fe np nq nr ns b">id</code>的行，并标记为<strong class="js iu">必填</strong>。</p><p id="c6ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，端点检查用户是否在查询字符串中提供了参数<code class="fe np nq nr ns b">id</code>，如果不存在，则拒绝调用。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi os"><img src="../Images/5071c7b85a0d7af35d44d82f65a9427f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FArCuPNZFRSMAo2LQf9-wA.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">将id作为端点的必需参数。</figcaption></figure></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h2 id="c303" class="mm lk it bd ll mn mo dn lp mp mq dp lt kb mr ms lx kf mt mu mb kj mv mw mf mx bi translated">步骤3:将用户输入转换成DynamoDB API调用</h2><p id="908a" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">转到<strong class="js iu">集成请求</strong>页面，这是我们构造DynamoDB调用的地方。</p><p id="e978" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为<strong class="js iu">集成类型</strong>选择<strong class="js iu"> AWS服务</strong>；<strong class="js iu"> DynamoDB </strong>用于<strong class="js iu"> AWS服务</strong>；并为<strong class="js iu"> AWS区域</strong>选择DynamoDB表的区域。</p><p id="3093" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于执行角色，输入我们在步骤1中创建的角色的ARN。</p><p id="f874" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于<strong class="js iu"> HTTP方法</strong>和<strong class="js iu">动作</strong>，我们可以查看一下API参考。每个AWS服务都有自己的API请求格式。在这种情况下，我们将使用<strong class="js iu">发布</strong>查询 ( <a class="ae no" href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Query.html#API_Query_Examples" rel="noopener ugc nofollow" target="_blank"> API引用</a>)。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ot"><img src="../Images/6fc120bd943b5293dd3390d3db3353a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O9MFMx-4TrNY911Aslsoow.png"/></div></div></figure><p id="31a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">向下滚动到底部，我们可以看到<strong class="js iu">映射模板</strong>部分，那是我们构造API调用体的地方。</p><p id="676c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将添加一个新的映射模板，将<strong class="js iu">内容类型</strong>设置为<strong class="js iu">应用程序/json </strong>(我们期待来自用户请求的json)。</p><p id="da15" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于<strong class="js iu">请求体通过</strong>，我们选择<strong class="js iu">从不</strong>。任何不是JSON的请求都将被拒绝，这样外人就不能绕过我们的映射直接访问DynamoDB API。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ou"><img src="../Images/2ec8784422d69631a8a5d2464bb19f9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*99hScCyoBN6GWfLVvdEtOw.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">使用映射模板构造DynamoDB API调用</figcaption></figure><p id="3f0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最精彩的部分来了，模板本身。API Gateway中的映射模板使用<a class="ae no" href="https://velocity.apache.org/engine/devel/vtl-reference.html" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> Apache Velocity模板语言(VTL) </strong> </a>格式。我们可以使用VTL来构造API调用体，就像我们通常构造API调用一样。结合一些简单的逻辑，如if-condition、for-loop和API Gateway提供的<a class="ae no" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html" rel="noopener ugc nofollow" target="_blank">变量</a>，我们可以根据用户输入进行DynamoDB API调用。</p><p id="a015" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本例中，我们将构建一个普通的<strong class="js iu">查询</strong>调用，使用用户提供的<code class="fe np nq nr ns b">id</code>参数作为主键条件:</p><pre class="mz na nb nc gt nt ns nu nv aw nw bi"><span id="36c0" class="mm lk it ns b gy nx ny l nz oa">{<br/>    "TableName": "xxxxxxxx",<br/>    "KeyConditionExpression": "id = :id",<br/>    "ExpressionAttributeValues": {<br/>        ":id": {<br/>            "N": "$input.params('id')"<br/>        }<br/>    }<br/>}</span></pre><h2 id="19a8" class="mm lk it bd ll mn mo dn lp mp mq dp lt kb mr ms lx kf mt mu mb kj mv mw mf mx bi translated">步骤4:将查询结果转换为API响应</h2><p id="2862" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">类似于构造API调用，我们可以基于DynamoDB的结果构造对用户的响应。</p><p id="cd32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu">集成响应</strong>页面中，我们可以配置来自DynamoDB的响应和发送给用户的响应之间的映射。为了简单起见，我们将使用默认的。</p><p id="19ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu">映射模板</strong>部分下，我们添加一个新模板，其中<strong class="js iu">内容类型</strong>设置为<strong class="js iu">应用程序/json。</strong></p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ov"><img src="../Images/f530ed3286a41a14d4bcc942f29b90f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Loyo_PgGH9CVM1kLEK_M_g.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">使用映射模板将DynamoDB响应转换为用户响应</figcaption></figure><p id="25f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于模板主体，我们将使用一个For循环列出所有被查询的条目，并将它们显示为一个简单的JSON对象，而不是DyanmoDB提供的原始格式。</p><p id="1261" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者，我们可以使用if条件来检查是否有任何记录返回。如果没有返回记录，我们甚至可以将HTTP响应代码覆盖为404。(<a class="ae no" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-override-request-response-parameters.html#apigateway-override-request-response-parameters-override-response" rel="noopener ugc nofollow" target="_blank">覆盖状态代码</a>的AWS文件)</p><pre class="mz na nb nc gt nt ns nu nv aw nw bi"><span id="ae9e" class="mm lk it ns b gy nx ny l nz oa">#set($inputRoot = $input.path('$'))</span><span id="3318" class="mm lk it ns b gy ow ny l nz oa">#if($inputRoot.Items.size() == 0)<br/>#set($context.responseOverride.status = 404)<br/>{<br/>    "message":"Record not found"<br/>}<br/>#else<br/>[<br/>#foreach($item in $inputRoot.Items)<br/>    {<br/>        "id" : $item.id.N,<br/>        "name" : "$item.name.S"<br/>    }#if($foreach.hasNext),#end<br/>#end<br/>]<br/>#end</span></pre></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h2 id="8b58" class="mm lk it bd ll mn mo dn lp mp mq dp lt kb mr ms lx kf mt mu mb kj mv mw mf mx bi translated">尝试一下</h2><p id="042f" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">现在，如果我们返回到<strong class="js iu">测试</strong>页面，我们可以提供查询字符串并测试我们刚刚创建的API。</p><p id="64c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们将<code class="fe np nq nr ns b">id=1</code>放入查询字符串(我已经在DynamoDB表中创建了记录)，我们可以看到API返回我们定义的JSON数组，而不是来自DynamoDB的复杂响应结构。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ox"><img src="../Images/9936dc4a6e2c7d3fe81d47b30ede13ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*liAbjG3yrOo0RAvYnnwnRQ.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">API以我们定义的格式返回记录。</figcaption></figure><p id="5557" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们放入<code class="fe np nq nr ns b">id=2</code>(我没有这个id的记录)，API会返回一个HTTP 404错误，以及我们在模板中定义的错误消息。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi oy"><img src="../Images/279ba4f8b6b179b813c57342c4585db7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b1GeHBS0TatF5mJLGJEECA.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">当没有找到记录时，API返回404错误。</figcaption></figure></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="41b3" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">包裹</h1><h2 id="fa66" class="mm lk it bd ll mn mo dn lp mp mq dp lt kb mr ms lx kf mt mu mb kj mv mw mf mx bi translated">费用</h2><p id="2fcf" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">对于许多web应用程序来说，大部分流量是读取流量。如果我们在API Gateway中实现它们，我们可以节省那些不必要的Lambda调用的成本。</p><p id="8848" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">即使Lambda调用是不可避免的，我们仍然可以在API Gateway中进行输入验证。通过保护Lambda函数不被用户犯下愚蠢的错误，我们可以避免在做无意义的事情上浪费调用。</p></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h2 id="fad7" class="mm lk it bd ll mn mo dn lp mp mq dp lt kb mr ms lx kf mt mu mb kj mv mw mf mx bi translated">并发</h2><p id="b5fe" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">您可能会注意到API Gateway提供了5000个突发并发。然而，如果每个API调用都以Lambda函数结束，那么这个并发数就变成了1000，因为Lambda只给你这个并发数。</p><p id="651d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过将那些简单的API调用(尤其是读取流量)从Lambda中剥离出来，我们可以将宝贵的Lambda并发性留给更复杂的任务。</p></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="55c7" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">特征图像</h1><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi oz"><img src="../Images/1ecb1b9c975bd610fb7f3a67ea3ffaad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zGzKAIN11oXzVFsZLSRe6A.png"/></div></div></figure></div></div>    
</body>
</html>