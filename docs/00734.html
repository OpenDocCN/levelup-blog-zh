<html>
<head>
<title>Regular Expressions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的正则表达式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/regular-expression-in-javascript-2da9320bef67?source=collection_archive---------1-----------------------#2019-07-12">https://levelup.gitconnected.com/regular-expression-in-javascript-2da9320bef67?source=collection_archive---------1-----------------------#2019-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d447" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">RegEx概述和如何为初学者编写表达式的技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/557988248b3d16d80cf5bbee328214e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lJOWiSjcCd2Zss_7kH13rg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">安妮·斯普拉特在<a class="ae ky" href="https://unsplash.com/search/photos/coffee?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1852" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将解释什么是正则表达式的基本原理，创建简单表达式的基本规则，以及根据我的经验得到的一些通用提示。因此，你可以创建自己的网站，而不需要通过谷歌搜索。</p><p id="a17f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像大多数开发人员一样，每当我有一个可以通过简单的正则表达式完成的任务时，我就会开始在Google上搜索符合我需要的模式。然后随着项目的发展，验证需要更新，我以前的模式不再有效。我需要再搜索一遍，花很多时间才能找到合适的。</p><p id="df85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个周期让我意识到我需要自己掌握这些，这样我就可以生成自己的正则表达式，而不需要谷歌的帮助。</p><p id="cfa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">更多类似的内容，请查看</em><a class="ae ky" href="https://betterfullstack.com/stories/" rel="noopener ugc nofollow" target="_blank">https://betterfullstack.com</a></p><h2 id="70f4" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">什么是正则表达式</h2><p id="e335" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">正则表达式只是描述字符串数据模式的一种方式。</p><h2 id="c096" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">如何创建新的</h2><p id="d3db" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">创建正则表达式有两种方法:</p><ol class=""><li id="b381" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">使用RegExp构造函数:<code class="fe nd ne nf ng b">const sample = new RegExp('sample');</code></li><li id="032c" class="mu mv it lb b lc nh lf ni li nj lm nk lq nl lu mz na nb nc bi translated">通过用正斜杠(<code class="fe nd ne nf ng b">/</code>)字符:<code class="fe nd ne nf ng b">const sample = /sample/;</code>将模式括起来，写成一个文字值</li></ol><p id="8ba2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:</p><ol class=""><li id="6474" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">一些字符，比如问号<code class="fe nd ne nf ng b">?</code>和加号<code class="fe nd ne nf ng b">+</code>在正则表达式中有特殊含义，如果你想直接匹配字符，必须在前面加一个反斜杠<code class="fe nd ne nf ng b">` </code>。反斜杠对字符进行转义。示例:<code class="fe nd ne nf ng b">const sample = /sample\+/;</code></li><li id="adca" class="mu mv it lb b lc nh lf ni li nj lm nk lq nl lu mz na nb nc bi translated">正则表达式是一种对象类型<code class="fe nd ne nf ng b">typeof sample // "object"</code>。</li><li id="e7f8" class="mu mv it lb b lc nh lf ni li nj lm nk lq nl lu mz na nb nc bi translated">正则表达式由非特殊字符组成。</li></ol><h2 id="aa2e" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">如何使用正则表达式</h2><p id="cf08" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">使用<code class="fe nd ne nf ng b">test()</code>测试字符串:<code class="fe nd ne nf ng b">sample.test("sample project");</code></p><p id="74e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法将返回一个<code class="fe nd ne nf ng b">boolean</code>值，让您知道字符串是否匹配表达式的模式。</p><p id="8932" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个函数是<code class="fe nd ne nf ng b">exec()</code>方法。如果没有找到匹配项，它将<strong class="lb iu">返回</strong> <code class="fe nd ne nf ng b">null</code> <strong class="lb iu">，否则<strong class="lb iu">返回一个带有匹配项信息的对象</strong>。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/bb7d0be602ef4e1bdd8dad2a95d1fac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*hybZUr3VtPG-i1Oxa9xX1A.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">exec示例</figcaption></figure><p id="0d1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是我在使用<code class="fe nd ne nf ng b">exec</code>和分组以及问号时注意到的奇怪的事情。如果没有完全匹配，它将返回<code class="fe nd ne nf ng b">undefined</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/3cc9ee14a588475e16f9c20cae5253ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*xbpdKpToyd1LTrSk1V_onw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">未定义的值</figcaption></figure><h2 id="1da1" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">规则组</h2><p id="3fec" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">当有些字母跟在反斜杠后面时，它们有不同的意思。</p><pre class="kj kk kl km gt no ng np nq aw nr bi"><span id="64cf" class="lw lx it ng b gy ns nt l nu nv">\d        Any digit character                            <br/>\w        An alphanumeric character (“word character”)<br/>\s        Any white space character (space, tab, newline)<br/>\D        A character that is not a digit                          \W        A non alphanumeric character<br/>\S        A non white space character<br/>.         Any character except for newline</span></pre><p id="2ef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">需要记住的提示:</strong></p><p id="1c6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf ng b">d</code>为数字的数字字符。<code class="fe nd ne nf ng b">w</code>用于任何字母数字字符。<code class="fe nd ne nf ng b">s</code>为空白字符。大写字符与数字、单词和空格的相反，它以相反的情况匹配。</p><p id="3287" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">示例</strong></p><p id="13c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf ng b">const dateTime = /\d\d-\d\d-\d\d\d\d \d\d:\d\d/;</code></p><p id="0cb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注:<code class="fe nd ne nf ng b">\w</code>包括字母数字(字母和数字)的a - z和0 - 9。表示<code class="fe nd ne nf ng b">/\w/.test("0")</code>返回<code class="fe nd ne nf ng b">true</code>；</p><p id="1a0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">方括号 <code class="fe nd ne nf ng b">[]</code>内的<strong class="lb iu">有一些特殊字符有意义。</strong></p><pre class="kj kk kl km gt no ng np nq aw nr bi"><span id="4582" class="lw lx it ng b gy ns nt l nu nv">-         Range of characters<br/>^         Match any character except the ones in the set</span></pre><p id="187a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">示例</strong></p><p id="cec0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf ng b">const shouldHaveDigit = /[0123456789]/;</code></p><p id="503e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf ng b">const notContainZero = /[^0]/;</code></p><p id="c088" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注</strong></p><ol class=""><li id="98cf" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">使用<code class="fe nd ne nf ng b">[]</code>时要小心，因为当一个字符串只有一个数字，其余都是像<code class="fe nd ne nf ng b">shouldHaveDigit.test("ab2c")</code>这样的字母时，它将返回<code class="fe nd ne nf ng b">true</code>。</li><li id="9f6f" class="mu mv it lb b lc nh lf ni li nj lm nk lq nl lu mz na nb nc bi translated">小心使用<code class="fe nd ne nf ng b">^</code>,因为只有当字符串像<code class="fe nd ne nf ng b">notContainZero.test("0")</code>一样为零时，它才会返回<code class="fe nd ne nf ng b">false</code>。其余的像<code class="fe nd ne nf ng b">notContainZero.test("01")</code>将返回<code class="fe nd ne nf ng b">true</code>。</li></ol><p id="a720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上规则都是关于单个数字或字符的，那么<strong class="lb iu">匹配一个字符或一个数字的整个序列</strong>怎么样？</p><pre class="kj kk kl km gt no ng np nq aw nr bi"><span id="cfd3" class="lw lx it ng b gy ns nt l nu nv">+         Repeated 1 -&gt; n time<br/>*         Repeated 0 -&gt; n time<br/>?         Optional. Nice to have<br/>{}        Precise number of time</span></pre><p id="12f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">示例</strong></p><p id="72f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我以<code class="fe nd ne nf ng b">{}</code>为例，因为它很特别。我有时对此感到困惑，我认为其他开发人员可能会犯同样的错误。</p><p id="7196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf ng b">const atLeast4A = /a{1,4}/;</code>表示该元素必须至少出现一次，最多出现四次。<code class="fe nd ne nf ng b">atLeast4A.test("abcdef")</code>和<code class="fe nd ne nf ng b">atLeast4A.test("abcdabcdabcd")</code>返回<code class="fe nd ne nf ng b">true</code>。</p><p id="2fbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf ng b">const atLeast4A = /a{2,4}/;</code>这意味着元素必须至少出现两次，最多出现四次，并且在字符串中必须有<code class="fe nd ne nf ng b">aa</code>。<code class="fe nd ne nf ng b">atLeast4A.test("abcdabcdabcd")</code>返回<code class="fe nd ne nf ng b">false</code>，同时<code class="fe nd ne nf ng b">atLeast4A.test("abcdaabcdabcd")</code>返回<code class="fe nd ne nf ng b">true</code>。</p><p id="45bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf ng b">const atLeast4A = /a{4,}/;</code>表示四次以上，字符串中必须有<code class="fe nd ne nf ng b">aaaa</code>。<code class="fe nd ne nf ng b">atLeast4A.test("ababababab")</code>返回<code class="fe nd ne nf ng b">false</code>。但是<code class="fe nd ne nf ng b">atLeast4A.test("aaaab")</code>返回<code class="fe nd ne nf ng b">true</code>。</p><p id="4ce4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注</strong></p><ol class=""><li id="c1ae" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">您不能将<code class="fe nd ne nf ng b">+</code>、<code class="fe nd ne nf ng b">*</code>和<code class="fe nd ne nf ng b">{}</code>放在一起。导致错误<code class="fe nd ne nf ng b">Nothing to repeat</code>。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/3f07bea9e894fdf29cb0895e928449e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g0BzNlF6Wf64j97RGw-5LQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">没有要重复的错误</figcaption></figure><p id="ce1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用圆括号和像<code class="fe nd ne nf ng b">+</code>和<code class="fe nd ne nf ng b">*</code>到<strong class="lb iu">这样的操作符一次匹配多个元素</strong>。</p><p id="f662" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">示例</strong></p><p id="b587" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf ng b">const appleTree = /(ap+le tree)+\s+/;</code></p><p id="42a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个和第三个<code class="fe nd ne nf ng b">+</code>字符分别仅适用于<code class="fe nd ne nf ng b">p</code>和<code class="fe nd ne nf ng b">\s</code>。第二个<code class="fe nd ne nf ng b">+</code>适用于整个组<code class="fe nd ne nf ng b">(ap+le tree)</code>，匹配一个或多个这样的序列。</p><p id="aa2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">图案本身能有边界吗</strong></p><p id="5c66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，我们可以添加标记<code class="fe nd ne nf ng b">^</code>和<code class="fe nd ne nf ng b">$</code>。插入符号匹配输入字符串的开头，而美元符号匹配结尾。</p><p id="6a42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">示例</strong></p><p id="9bbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf ng b">const onlyabc = /^abc$/;</code>仅与<code class="fe nd ne nf ng b">"abc"</code>字符串完全匹配，这与当字符串中的任意位置包含<code class="fe nd ne nf ng b">abc</code>时<code class="fe nd ne nf ng b">/abc/</code>将返回<code class="fe nd ne nf ng b">true</code>不同。</p><p id="5cdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注</strong></p><ol class=""><li id="13d3" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">使用不带方括号的<code class="fe nd ne nf ng b">/^abc/</code>意味着它匹配任何以<code class="fe nd ne nf ng b">abc</code>开头的字符串。</li><li id="636e" class="mu mv it lb b lc nh lf ni li nj lm nk lq nl lu mz na nb nc bi translated">使用<code class="fe nd ne nf ng b">\b</code>作为<code class="fe nd ne nf ng b">\w</code>图形的边界。例如:<code class="fe nd ne nf ng b">/\bsample\b/</code>返回<code class="fe nd ne nf ng b">true</code>只针对<code class="fe nd ne nf ng b">sample</code>。</li></ol><h2 id="eb46" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">竖线字符|</h2><p id="2e5a" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">管道字符<code class="fe nd ne nf ng b">(|)</code>表示选择其左边的模式还是右边的模式</p><p id="3fa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">例子</strong></p><p id="4240" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf ng b">const bio = /\bI am (Java|Javascript|Php) developer\b;/</code></p><h2 id="e32d" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">练习题—验证电话号码</h2><p id="7bbc" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">验证电话号码遵循格式<strong class="lb iu">安-NNN-NNNN </strong>，其中A介于2和9之间，N介于0和9之间。</p><p id="ba62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将一步一步地创造它。</p><ol class=""><li id="0e60" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">首先初始化一个正则表达式文字<code class="fe nd ne nf ng b">//</code></li><li id="12eb" class="mu mv it lb b lc nh lf ni li nj lm nk lq nl lu mz na nb nc bi translated">我们想要匹配整个字符串，所以我们将使用边界字符<code class="fe nd ne nf ng b">/^$/</code></li><li id="150f" class="mu mv it lb b lc nh lf ni li nj lm nk lq nl lu mz na nb nc bi translated">第一个元素的范围从2到9。<code class="fe nd ne nf ng b">/^[2-9]$/</code></li><li id="cb05" class="mu mv it lb b lc nh lf ni li nj lm nk lq nl lu mz na nb nc bi translated">n应该是0到9之间的数字。<code class="fe nd ne nf ng b">/^([2-9]\d{2})-\d{3}-\d{4}$/</code></li></ol><h2 id="7b57" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">练习题—验证电子邮件</h2><p id="5e5e" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">按照格式<strong class="lb iu">_._@companyname.com.my</strong>验证公司电子邮件，其中“_”仅由字母数字组成。“公司名称”应为“公司a”、“公司b”</p><p id="31f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是做这件事的步骤</p><ol class=""><li id="895f" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">初始化<code class="fe nd ne nf ng b">//</code></li><li id="46be" class="mu mv it lb b lc nh lf ni li nj lm nk lq nl lu mz na nb nc bi translated">添加边界<code class="fe nd ne nf ng b">/^$/</code></li><li id="3718" class="mu mv it lb b lc nh lf ni li nj lm nk lq nl lu mz na nb nc bi translated">“_”是字母和数字，产生<code class="fe nd ne nf ng b">/^\w.\w$/</code></li><li id="1fce" class="mu mv it lb b lc nh lf ni li nj lm nk lq nl lu mz na nb nc bi translated">加上<code class="fe nd ne nf ng b">+</code>是因为<code class="fe nd ne nf ng b">\w</code>之后，它可能不止一个。<code class="fe nd ne nf ng b">/^\w+.\w+$/</code></li><li id="de09" class="mu mv it lb b lc nh lf ni li nj lm nk lq nl lu mz na nb nc bi translated">“公司名称”只能与“公司a”和“公司a”一起使用。所以我们使用管道字符。<code class="fe nd ne nf ng b">/^\w+.\w+@(companya|companyb).com.my$/</code>。</li></ol><h2 id="4899" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">摘要</h2><p id="25c6" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">理解正则表达式是开发人员生存的关键。不如自己写RegExp，充分理解它的作用。</p><p id="6d80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章对你有用！可以跟着我上<a class="ae ky" href="https://medium.com/@transonhoang" rel="noopener">媒</a>。我也在推特上。欢迎在下面的评论中留下任何问题。我很乐意帮忙！</p><h2 id="e027" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">资源/参考资料</h2><p id="c45d" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">[1]:正则表达式<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Guide/Regular _ Expressions</a></p><p id="300e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2]:第9章——本书雄辩的JavaScript<a class="ae ky" href="https://eloquentjavascript.net/09_regexp.html" rel="noopener ugc nofollow" target="_blank">https://eloquentjavascript.net/09_regexp.html</a></p><p id="28d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[3]:正则表达式库http://regexlib.com/Search.aspx?k=phone<a class="ae ky" href="http://regexlib.com/Search.aspx?k=phone" rel="noopener ugc nofollow" target="_blank"/></p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><div class="kj kk kl km gt oe"><a href="https://gitconnected.com/learn/javascript" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">学习JavaScript -最佳JavaScript教程(2019) | gitconnected</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">JavaScript是世界上最流行的编程语言之一——它随处可见。JavaScript是一种…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">gitconnected.com</p></div></div><div class="on l"><div class="oo l op oq or on os ks oe"/></div></div></a></div><div class="ot ou gp gr ov oe"><a href="https://betterfullstack.com/stories/" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">故事-更好的全栈</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">所有的故事故事为我们写指南提交故事到更好的编程博客1。故事指南避免什么…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">betterfullstack.com</p></div></div><div class="on l"><div class="ow l op oq or on os ks oe"/></div></div></a></div></div></div>    
</body>
</html>