<html>
<head>
<title>Constraint Validation in Spring Boot Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot微服务中的约束验证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/constraint-validation-in-spring-boot-microservices-b89805e9c540?source=collection_archive---------0-----------------------#2020-11-14">https://levelup.gitconnected.com/constraint-validation-in-spring-boot-microservices-b89805e9c540?source=collection_archive---------0-----------------------#2020-11-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/6851ffd5e6020732cd11798da1a0d5b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v8bwLdxBe4IF5ruvZlq3jQ.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://unsplash.com/@maxweisbecker" rel="noopener ugc nofollow" target="_blank">马克斯·魏斯贝克尔在Unsplash上拍摄的照片</a></figcaption></figure><div class=""/><div class=""><h2 id="aa4e" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">通过Java注释验证请求的轻量级介绍</h2></div><p id="f0a8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在微服务架构中，服务可能接受几个(如果不是很多)相同的输入。这种模式很容易导致服务之间的代码重复和冗余。为了减少这些缺点并保持服务代码集中，我们可以设计一个健壮的解决方案，包括Spring和Java提供的几个API。</p><blockquote class="lr ls lt"><p id="483b" class="kv kw lu kx b ky kz kh la lb lc kk ld lv lf lg lh lw lj lk ll lx ln lo lp lq ij bi translated"><em class="jg">下面的教程将假设一些Java和Spring Boot的工作知识，但是将迎合一系列的技能水平。不管怎样，看看其他开发人员的代码也无妨！</em></p></blockquote></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="ca37" class="mf mg jg bd mh mi mj mk ml mm mn mo mp km mq kn mr kp ms kq mt ks mu kt mv mw bi translated">背景</h1><p id="088c" class="pw-post-body-paragraph kv kw jg kx b ky mx kh la lb my kk ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">我们的解决方案将涉及到结合Java和Spring Boot API，分别是<code class="fe nc nd ne nf b">ConstraintValidator</code>和<code class="fe nc nd ne nf b">ResponseEntityExceptionHandler</code>。</p><p id="66e5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">作为<a class="ae jd" href="https://jcp.org/en/jsr/detail?id=380" rel="noopener ugc nofollow" target="_blank"> JSR 380 </a>的一部分得到增强的<a class="ae jd" href="http://hibernate.org/validator/" rel="noopener ugc nofollow" target="_blank"> Hibernate Validator </a>，是标准<a class="ae jd" href="https://beanvalidation.org/" rel="noopener ugc nofollow" target="_blank"> Bean验证</a>的Java API规范。在Spring Boot应用程序的上下文中，您可能会不假思索地使用它。例子包括:</p><ul class=""><li id="c4f8" class="ng nh jg kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated"><code class="fe nc nd ne nf b">@NotNull</code></li><li id="11d7" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated"><code class="fe nc nd ne nf b">@Min</code></li><li id="618b" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated"><code class="fe nc nd ne nf b">@Max</code></li><li id="4bc7" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated"><code class="fe nc nd ne nf b">@Pattern</code></li><li id="136f" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated"><code class="fe nc nd ne nf b">@Past</code></li><li id="92ad" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated"><code class="fe nc nd ne nf b">@Email</code></li><li id="9749" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated"><code class="fe nc nd ne nf b">@PositiveOrZero</code></li></ul><p id="4b61" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本教程中，我们将研究如何使用<code class="fe nc nd ne nf b">ConstraintValidator</code>接口定义我们自己的约束集来超越这些基本验证。</p><p id="809b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然Spring生态系统中存在其他形式的异常处理，但是<code class="fe nc nd ne nf b">ResponseEntityExceptionHandler</code>在服务中提供了全局(和集中)的异常处理。这种全球化对于我们的定制约束注释的有效性至关重要，因为它允许我们验证多个Beans(或其中的字段)。也就是说，我们将研究如何利用这个类来优雅地处理违反约束的情况。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="49e5" class="mf mg jg bd mh mi mj mk ml mm mn mo mp km mq kn mr kp ms kq mt ks mu kt mv mw bi translated">履行</h1><p id="8b71" class="pw-post-body-paragraph kv kw jg kx b ky mx kh la lb my kk ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">让我们开始吧。为了避免用样板代码膨胀教程，您将在下面的部分中只找到必要的代码块。本文附有一个关于<a class="ae jd" href="https://github.com/Verley93/annotation-validation" rel="noopener ugc nofollow" target="_blank"> GitHub </a>的工作示例。</p><p id="8908" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:我将在整个教程中引用这个示例项目。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="131f" class="mf mg jg bd mh mi mj mk ml mm mn mo mp km mq kn mr kp ms kq mt ks mu kt mv mw bi translated">属国</h1><p id="fc8f" class="pw-post-body-paragraph kv kw jg kx b ky mx kh la lb my kk ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">这份清单简短而甜蜜:</p><figure class="nv nw nx ny gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/2b3011bc2c83287269daa8f1b0c8f050.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DzFFKyYusejDD2Hq.png"/></div></div></figure></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="2a8f" class="mf mg jg bd mh mi mj mk ml mm mn mo mp km mq kn mr kp ms kq mt ks mu kt mv mw bi translated">创建注释</h1><p id="7a1b" class="pw-post-body-paragraph kv kw jg kx b ky mx kh la lb my kk ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">我们从简单的开始。假设我们已经实现了一个<em class="lu">冰箱</em>和<em class="lu">餐具室服务</em>，它允许我们:</p><ul class=""><li id="2a1d" class="ng nh jg kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated">管理冰箱和食品储藏室</li><li id="5da5" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">接受带有JSON有效负载的POST和/或PUT请求</li></ul><p id="6500" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们希望验证两个服务的请求模型之间的公共字段。我们的请求模型可能如下所示:</p><figure class="nv nw nx ny gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nz"><img src="../Images/4e780f760a483e18ac33cd94b40ab416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*stwKITcLvlWe8Z09.png"/></div></div></figure><p id="25bd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以构建的一个最简单的约束包括组合现有的约束，比如上面例子中的<code class="fe nc nd ne nf b">@PositiveOrZero</code>和<code class="fe nc nd ne nf b">@Max</code>。这使得我们可以给常见的约束贴上一个明确的标签，称之为“业务逻辑”。下面，我们定义<code class="fe nc nd ne nf b">@FoodQuantity</code>:</p><figure class="nv nw nx ny gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/dda5d9451a24adfc93035c42fa713040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vvyQeOi3Wve6rQhW.png"/></div></div></figure><p id="4ab9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里发生了很多事情，让我们来分解一下:</p><ul class=""><li id="0c38" class="ng nh jg kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated"><code class="fe nc nd ne nf b">@Constraint</code>将注释标记为Bean验证约束，并允许我们指定<code class="fe nc nd ne nf b">ConstraintValidator</code>实现；这里欢迎零个、一个或多个实现</li><li id="1fab" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated"><code class="fe nc nd ne nf b">@Retention</code>被设置为在运行时保留我们的注释</li><li id="ff53" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated"><code class="fe nc nd ne nf b">@Target</code>的设置使得我们可以验证不同类型的服务输入</li><li id="c3f9" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated"><code class="fe nc nd ne nf b">message</code>、<code class="fe nc nd ne nf b">groups</code>和<code class="fe nc nd ne nf b">payload</code>是<code class="fe nc nd ne nf b">@Constraint</code>所必需的，但不是必须设置的——它们提供了超出我们今天讨论范围的特性</li></ul><p id="2a65" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这绝不是一种简化。抛开冗长的内容，注释打开了几扇门，使得处理复杂性变得轻而易举，我们将在下一个例子中看到。</p><p id="678e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们为<em class="lu">类别</em>字段定义一个约束，如下所示:</p><ul class=""><li id="c42d" class="ng nh jg kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated">必须传递类别，并且类别不能为空</li><li id="aaad" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">只允许通过某些类别</li><li id="67cf" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated"><em class="lu">冰箱</em>和<em class="lu">茶水间</em>服务的类别可能不同</li></ul><p id="0ae8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了实现这个注释，我们将在第一个注释的前提上进行扩展，添加一个自定义参数并提供一个<code class="fe nc nd ne nf b">ConstraintValidator</code>接口的实现。结果看起来像这样:</p><figure class="nv nw nx ny gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ob"><img src="../Images/a8aa9ae48c6b8c8f9549fa2511420369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l1YNqD2yKwNwAPFY.png"/></div></div></figure><p id="f4a4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与<code class="fe nc nd ne nf b">@FoodQuantity</code>相比，这个注释中发生了更多的事情。我们已经指定了一个新的参数<code class="fe nc nd ne nf b">allowed</code>，来限制传递给<code class="fe nc nd ne nf b">category</code>的内容。注意默认值——只有当值没有传入<code class="fe nc nd ne nf b">@FoodCategory</code>时，这个数组才会被引用。为了处理这个约束，我们实现了<code class="fe nc nd ne nf b">FoodCategoryValidator</code>:</p><figure class="nv nw nx ny gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/dd0dfc5c9a5950591f4463e65aa98772.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2xGOlfvM3e22-e6E.png"/></div></div></figure><p id="7dc2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们分解一下新的验证器类:</p><ul class=""><li id="e36a" class="ng nh jg kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated"><code class="fe nc nd ne nf b">ConstraintValidator</code>被注释类和被验证的类型参数化—一个包含<strong class="kx jh"> <em class="lu">类别</em> </strong>的值的<code class="fe nc nd ne nf b">String</code></li><li id="9ab8" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">一个全局字段<code class="fe nc nd ne nf b">allowed</code>，在被覆盖的<code class="fe nc nd ne nf b">initialize</code>方法中设置；正是在这个方法中，我们获得了在整个验证器类中使用的<code class="fe nc nd ne nf b">@FoodCategory</code>的参数</li><li id="4e93" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated"><code class="fe nc nd ne nf b">isValid</code>是我们约束验证的核心</li><li id="599c" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">对于无效的场景，我们禁用默认的约束违反，构建适当的错误消息，并返回false——这最终会抛出一个我们稍后会感兴趣的异常</li></ul><p id="d493" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，为了充分利用我们的注释，我们将category字段传播到与每个服务相关的两个子类中。</p><p id="27fc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">经过我们所有的努力，我们已经达到了一个干净的请求模型集，准备好接受无效值的轰炸:</p><figure class="nv nw nx ny gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oc"><img src="../Images/62ec0fc9f37ba5b359257205a05d4ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RoTlPJrelL-Z6H5q.png"/></div></div></figure></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="b036" class="mf mg jg bd mh mi mj mk ml mm mn mo mp km mq kn mr kp ms kq mt ks mu kt mv mw bi translated">处理验证错误</h1><p id="5aa0" class="pw-post-body-paragraph kv kw jg kx b ky mx kh la lb my kk ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">到目前为止，我们只定义了我们(和我们的消费者)必须遵守的约束。让我们打开一个端点，允许将食物添加到冰箱中，并测试我们的约束:</p><figure class="nv nw nx ny gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/919c669e3a8019f1d839273a0798297f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gsGGpZp3tq_gsfMe.png"/></div></div></figure><p id="d096" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要使我们的注释正常工作，有几个关键方面需要注意:</p><ul class=""><li id="616e" class="ng nh jg kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated"><code class="fe nc nd ne nf b">@Validated</code>必须在<em class="lu">类</em>或<em class="lu">方法</em>级别使用，以指示需要进行验证的位置</li><li id="faf6" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated"><code class="fe nc nd ne nf b">@Valid</code>用于标记一个<em class="lu">属性</em>用于验证级联，这触发了我们的约束</li></ul><p id="2406" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们发送一个有效载荷:</p><figure class="nv nw nx ny gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi od"><img src="../Images/e92af8e1ffd3eff7eaf64fcec942af7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xoNZjLMkVsrf2HuW.png"/></div></div></figure><p id="6fd9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">成功！但是，让我们看看当我们发送另一个已知会导致错误的有效载荷时会发生什么:</p><figure class="nv nw nx ny gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi od"><img src="../Images/41b7056b2b53326bdb9c132753f57c30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3_t-MV8Q8BULBqbW.png"/></div></div></figure><p id="07eb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，我们违反了此请求模型的多个约束。您应该会看到一个包含遇到的错误和抛出的异常的详细信息的详细响应。这种冗长对于我们(或我们的消费者)来说并不理想，所以让我们通过简单地覆盖<code class="fe nc nd ne nf b">ResponseEntityExceptionHandler</code>来过滤掉重要的细节。</p><p id="cf72" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">进一步研究Spring提供的错误响应，您可能会注意到抛出的异常:<code class="fe nc nd ne nf b">MethodArgumentNotValidException</code>。这是我们在异常处理程序中处理约束违反时感兴趣的异常。</p><p id="d818" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们需要一个模型来捕捉相关信息。我们能够从原始的Spring响应中提取以下内容:</p><figure class="nv nw nx ny gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oe"><img src="../Images/943d75de15f9326d60685f8e8951d7e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wtw4XNnJrWtKMcvL.png"/></div></div></figure><p id="a656" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们将构建全局异常处理程序和一个方法来处理我们的约束:</p><figure class="nv nw nx ny gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/30eeabbc7b965a66ab6ae729d92084db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IZw6aieHsyFICDLy.png"/></div></div></figure><p id="8550" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们在这里注意一些事情:</p><ul class=""><li id="eabb" class="ng nh jg kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated"><code class="fe nc nd ne nf b">@RestControllerAdvice</code>就是这样——声明在多个控制器类之间共享的<code class="fe nc nd ne nf b">@ExceptionHandler</code>方法的类的专用组件</li><li id="5897" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">我们覆盖了<code class="fe nc nd ne nf b">@ResponseEntityExceptionHandler</code>的<code class="fe nc nd ne nf b">handleMethodArgumentNotValid</code>方法，这样我们可以:</li><li id="7644" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">记录重要信息；构建一个小的、集中的错误响应；并根据违反的约束返回我们选择的HTTP状态代码</li></ul><p id="c9b1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在发送一个违反我们定义的约束的有效负载时，您应该会看到一个简洁的响应，指出我们哪里出错了:</p><figure class="nv nw nx ny gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi of"><img src="../Images/0a1fdba62dd0a45dda66a54d5cafe7ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*y8tFhhX3vmwcdEZG.png"/></div></div></figure></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="c04a" class="mf mg jg bd mh mi mj mk ml mm mn mo mp km mq kn mr kp ms kq mt ks mu kt mv mw bi translated">挑战</h1><p id="7c7a" class="pw-post-body-paragraph kv kw jg kx b ky mx kh la lb my kk ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">本教程提供了一些基于Spring/Java的REST服务中约束验证的基本形式。如果你想更进一步，可以从以下几个地方开始:</p><ul class=""><li id="2dc2" class="ng nh jg kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated">探索违反<code class="fe nc nd ne nf b">@PathVariable</code>或<code class="fe nc nd ne nf b">@RequestParam</code>约束的不同之处</li><li id="37d0" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">在复杂的请求模型中实现嵌套约束</li><li id="8f5c" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">增加返回给消费者的HTTP状态代码的灵活性</li><li id="e462" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">扩展示例项目以处理复合服务的细微差别——例如一个<em class="lu">野餐服务</em></li><li id="a55e" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">进一步探索<code class="fe nc nd ne nf b">@Constraint</code>API——什么是<code class="fe nc nd ne nf b">payload</code>和<code class="fe nc nd ne nf b">groups</code>的用途？</li></ul></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="a66e" class="mf mg jg bd mh mi mj mk ml mm mn mo mp km mq kn mr kp ms kq mt ks mu kt mv mw bi translated">关闭</h1><p id="f7fe" class="pw-post-body-paragraph kv kw jg kx b ky mx kh la lb my kk ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">关于使用注释实现定制约束验证器的教程到此结束！如果我错过了什么，不要害怕让我知道。我当然欢迎(也欣赏)批评、问题等等。</p><p id="5c2f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">作为进一步的参考，这里是GitHub库以及本文中给出的全部工作代码和示例。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><p id="73d0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lu">最初发布于</em><a class="ae jd" href="https://verley.dev/blog/constraint-validation-in-spring-boot-microservices/" rel="noopener ugc nofollow" target="_blank"><em class="lu">https://verley . dev</em></a><em class="lu">。</em></p></div></div>    
</body>
</html>