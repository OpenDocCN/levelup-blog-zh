<html>
<head>
<title>This is the Main Difference of Writing Applications in Functional Programming vs. Object-Oriented Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这是用函数式编程和面向对象编程编写应用程序的主要区别</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/this-is-the-main-difference-of-writing-applications-in-functional-programming-vs-3ee9d9de7ea3?source=collection_archive---------8-----------------------#2021-02-23">https://levelup.gitconnected.com/this-is-the-main-difference-of-writing-applications-in-functional-programming-vs-3ee9d9de7ea3?source=collection_archive---------8-----------------------#2021-02-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fcce" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它不是不变性或继承性，而是更多地取决于如何构建您的应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eb782c32958cd9ff5385dabc4984cc27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BN4Oyr358VGDaVTg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由作者提供</figcaption></figure><p id="e35c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代数数据类型有其优点和缺点。它使您能够以类型安全的方式编写应用程序——当您进行模式匹配时，它将为您穷尽所有的数据类型。但是，如果数据类型不断变化，使用ADT也有一个缺点。</p><p id="e27f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将开门见山地告诉你不同之处——当你用函数式编程范式编写应用程序时，一切都是按操作分组的。当我们以面向对象的方式编写程序时，一切都是基于对象的一组。</p><p id="9c0a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对我来说，这是一个巨大的发现！这解释了为什么ADT有时会很痛苦。</p><p id="82e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将说明这是什么意思——这可以让你大致了解我认为用函数式编程和面向对象编程编写程序的真正区别。</p><p id="ced5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们把它变成树数据类型。在我们第一次尝试创建树时，它会是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="218d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们希望有一个计算树的高度的函数。让我们在这里做吧:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="876d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们希望有一个计算所有分支总和的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="4a46" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从上面的两个函数中，我们注意到，一旦我们创建了ADT，我们将需要在每个ADT上实现用例— <code class="fe lw lx ly lz b">height</code>和<code class="fe lw lx ly lz b">sum</code>需要实现基于两种数据类型—<code class="fe lw lx ly lz b">Branch</code>和<code class="fe lw lx ly lz b">Leaf</code>的操作。</p><p id="6ee4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想以面向对象的方式实现它，我们将把方法放在<code class="fe lw lx ly lz b">Tree</code>接口中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="a81d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在面向对象的方式中，我们基于每个类对我们的操作进行分组。所以<code class="fe lw lx ly lz b">Branch</code>会有自己的<code class="fe lw lx ly lz b">height</code>和<code class="fe lw lx ly lz b">sum</code>的功能，<code class="fe lw lx ly lz b">Leaf</code>会有自己的<code class="fe lw lx ly lz b">height</code>和<code class="fe lw lx ly lz b">sum</code>的功能。</p><p id="2f7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是构建应用程序的两种方式，它们会对您如何构建它们产生不同的影响。让我们来看看这种结构的利弊。</p><h1 id="8406" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">添加新的数据类型</h1><p id="6567" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">我们希望扩展<code class="fe lw lx ly lz b">Tree</code>以获得另一种数据类型，“Empty”，表示应用程序中的一个空的子元素。</p><p id="8616" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们最初用ADT实现我们的树类型，并在操作中对它们进行分组，我们将需要遍历每个操作，并在模式匹配情况下添加一个<code class="fe lw lx ly lz b">Empty</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="abbf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们的应用程序中有许多基于<code class="fe lw lx ly lz b">Tree</code>数据类型的函数，我们必须遍历每个函数并添加一个新的<code class="fe lw lx ly lz b">Empty</code>用例。</p><p id="fe5f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，如果我们以面向对象的方式来做，我们只需要实现一个新的类<code class="fe lw lx ly lz b">Empty</code>，它扩展了<code class="fe lw lx ly lz b">Tree</code>特征。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="22e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，如果您根据数据类型对应用程序进行分组，添加新的数据类型将会很麻烦，因为我们需要更改应用程序中的所有操作，以包含另一种情况。但是，在面向对象的方式中，由于每个函数都是基于对象分组的，所以添加新的数据类型需要实现<code class="fe lw lx ly lz b">Tree</code>接口。</p><h1 id="9eeb" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">添加新操作</h1><p id="01d9" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">我们想在<code class="fe lw lx ly lz b">Tree</code>中添加一个名为<code class="fe lw lx ly lz b">isEmpty</code>的新操作。</p><p id="8c02" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果通过分离函数和数据类型来对应用程序进行分组，那么创建一个<code class="fe lw lx ly lz b">isEmpty</code>函数就相对简单了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="ed6e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，如果我们以面向对象的方式实现我们的应用程序，我们需要遍历应用程序中的所有文件并实现<code class="fe lw lx ly lz b">isEmpty</code>函数，因为我们改变了我们的接口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="575e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这在Java中一直是个问题。如果我们有多个嵌套继承，我们需要改变所有实现接口的类。</p><p id="a30e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，以结构化应用程序代码的有用方式添加新操作的更改是局部的。然而，在以面向对象的方式构建应用程序时，添加新的进程将会深刻地改变应用程序的结构。</p><h1 id="2f70" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">我们在这里学到了什么？</h1><p id="2a5e" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">明智地构建您的数据模型！我们永远不知道我们正在构建的应用程序的未来。因此，灵活性至关重要。</p><p id="439e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">设计软件一部分是艺术，一部分是技术。因此，每个开发人员都有自己构建应用程序的风格。</p><p id="7e68" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于构建代码的最佳实践是什么，网上一直有一个话题。但是，我认为最好的方式是基于你目前的应用和业务逻辑。</p><p id="c339" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您知道您的数据类型将来会不断变化，那么以面向对象的方式创建值可能会更加灵活。如果您知道您的数据类型很可能会保持不变，那么从功能上构建您的数据模型对未来会有好处，因为新功能的添加会多于新数据类型。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="b152" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">感谢阅读！如果你喜欢这个帖子，你可以关注</strong> <a class="ae ne" href="https://medium.com/@edwardgunawan880" rel="noopener"> <strong class="la iu">中的</strong> </a> <strong class="la iu">来获得更多类似的帖子。</strong></p><p id="3a90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nf">原载于</em><a class="ae ne" href="https://edward-huang.com/functional-programming/programming/2021/02/22/this-is-the-main-difference-of-writing-applications-in-functional-programming-vs-object-oriented-programming/" rel="noopener ugc nofollow" target="_blank"><em class="nf">https://edward-huang.com</em></a><em class="nf">。</em></p></div></div>    
</body>
</html>