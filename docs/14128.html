<html>
<head>
<title>Resilience Patterns for Synchronous Microservices Communication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">同步微服务通信的弹性模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/resilience-patterns-for-synchronous-microservices-communication-1cc9a0bbfc3d?source=collection_archive---------1-----------------------#2022-11-03">https://levelup.gitconnected.com/resilience-patterns-for-synchronous-microservices-communication-1cc9a0bbfc3d?source=collection_archive---------1-----------------------#2022-11-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f8c8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">确保可靠和可预测的应用程序行为。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3792346a7359564d582fee9814d0a9e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qeg2NjIdejS84pHi"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@mimithian?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米米·蒂安</a>拍摄的照片</figcaption></figure><p id="af25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(微)服务可以通过同步HTTP调用(或gRPC调用)相互通信:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/d5fe69589a8655887d4c4cf46b84d7ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IOQiGQLkc_iYPIBTaBj8Aw.png"/></div></div></figure><p id="feaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务之间的通信是系统中一个额外的活动部分。在这一点上，许多事情可能会出错，例如，请求可能会失败或需要很长时间才能完成，从而导致性能下降。因此，一旦做出了在服务之间使用同步集成的设计决策，下一步就是考虑<strong class="lb iu">弹性模式</strong>，这将尽可能多地防止故障，或者在故障发生时帮助从故障中恢复服务。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="39a1" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">超时</h1><p id="c82e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">客户端微服务等待响应的时间越长，收到成功响应的可能性就越小。经过一段时间后，继续等待来自远程的响应通常没有意义，因此使用超时来停止等待响应。</p><p id="36f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在实现超时模式时，至少要考虑以下因素:</p><ul class=""><li id="c510" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated"><strong class="lb iu">超时间隔。</strong>在某些情况下，当预期响应时间很短时，超时可以是5秒，在其他情况下，超时可以是30秒或更长。超时间隔应根据具体情况选择。</li><li id="f3cf" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><strong class="lb iu">超时类型。</strong>设置超时间隔时，了解设置将应用于哪种类型的超时非常重要。例如，存在连接超时和请求超时。开发人员可能认为他在为请求设置超时，但实际上它将应用于连接，反之亦然。</li><li id="90fc" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><strong class="lb iu">可配置性。</strong>考虑将超时值放在配置文件中，而不是硬编码。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="44b1" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">重试模式</h1><p id="61a6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当对远程微服务的同步调用由于某种瞬时故障而返回不成功的响应时(<em class="no">可能存在暂时的网络连接问题，或者远程微服务可能由于服务请求的高峰而暂时不可用)</em>，客户端应该重试请求。</p><p id="7f84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第二次或更多次尝试后，短暂的失败很可能会消失，最终调用会成功。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/338b354f6a0050bc8961e136def68387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bicIVGpKPgIbmqoVRdzwPw.png"/></div></div></figure><p id="700d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实施重试模式时，至少要考虑以下因素:</p><ul class=""><li id="e3be" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated"><strong class="lb iu">仅选择暂时性错误类型进行重试。</strong>重试逻辑应该只在出现暂时失败后重试请求，这在HTTP调用的情况下由这些状态代码表示:429(请求太多)、503(服务不可用)或其他。然而，诸如400(错误请求)、403(禁止)、500(内部服务器错误)之类的响应是不可恢复的，因此重试逻辑不应该重试它们。</li><li id="ae58" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><strong class="lb iu">最大尝试次数。</strong>客户端可以无限次重试失败的呼叫，但这会导致无休止的操作。最大重试次数通常从3到5不等。</li><li id="e5ac" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><strong class="lb iu">尝试之间的间隔。</strong>时间间隔不能太短，以免给远程服务恢复的机会，但也不能太长，以免对系统性能产生重大影响。</li><li id="b5ef" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><strong class="lb iu">线性补偿与指数补偿。</strong>使用线性补偿时，重试之间的等待间隔是固定的，而使用指数补偿时，每次重试后等待间隔都会增加。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2e0e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">断路器</h1><p id="9bfe" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有时，重试模式并不是从故障中恢复的理想机制。这主要是因为两件事:</p><ul class=""><li id="add5" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">重试逻辑不断地向失败的服务发送请求，即使此时接收到成功响应的机会很低。这对调用者微服务的资源使用有负面影响。</li><li id="42f4" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">不断用请求轰炸失败的远程服务可能会阻止它从故障中恢复。失败的服务可能不需要呼入或者只需要少量呼叫就能够从失败中恢复。</li></ul><p id="80b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">断路器可以解决这些和其他问题。该模式充当客户端和远程服务之间的智能代理，可以跟踪失败请求的数量。一旦失败的请求超过某个阈值，断路器将立即向客户端服务返回错误，而不会尝试联系失败的远程服务。</p><p id="c9b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某个时间段之后(或者在断路器可以周期性地向失败的服务发送成功的ping请求之后)，断路器代理将开始仅向远程服务转发一小部分请求。如果这些请求成功，断路器将恢复正常，并将所有请求重定向到恢复的远程服务。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="14b9" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">回退操作</h1><p id="8adb" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">出现了这样的情况:客户端微服务在调用远程微服务后收到一个错误。在这种情况下，客户端应根据系统要求和障碍执行以下一项或多项操作:</p><ul class=""><li id="4feb" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">将错误记录到日志系统中。</li><li id="8696" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">立即向客户端抛出一个异常，让他稍后再试。</li><li id="5156" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">再次重复请求(在暂时失败的情况下)。</li><li id="d0bc" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">适用时实现空对象模式。</li></ul><p id="724d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缺少正确定义的回退操作会导致难以调查的错误。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6235" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">贮藏</h1><p id="e4c9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">虽然服务电话是必要的，但最好尽量少打。每个服务调用都会产生潜在的故障点，并影响系统性能。减少调用次数从而减少失败请求数量的一种方法是在一定时间内缓存来自远程微服务的响应。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/4c6de59b6cd9f7656cec3fcab80c3245.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iXZyMmz7t6dGp_AxYlRTkg.png"/></div></div></figure><p id="2a75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实施缓存以减少网络调用次数时需要考虑的事项:</p><ul class=""><li id="f603" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">在<strong class="lb iu">到期</strong>之前，数据应该在缓存中保留多长时间？到期时间将取决于多种因素，例如远程微服务中的数据更新频率和/或客户端微服务可以使用本地缓存中的陈旧数据多长时间。</li><li id="1f05" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">数据应该缓存在服务的<strong class="lb iu">本地缓存中，还是像Redis这样的远程缓存服务器中？诸如需要存储大量数据、扩展微服务实例等情况通常会导致需要使用远程缓存服务器。你可以在我的另一篇关于缓存的文章中读到更多。</strong></li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1f97" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">最后的想法</h1><p id="88fe" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">实现我们已经讨论过的一组持久性模式是使微服务交互更加可靠和可预测的良好开端。在设计阶段选择模式比当系统中开始出现问题时才选择和实现模式要好得多。</p><p id="b645" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用这些模式和一些超出本文范围的其他模式(隔板模式、健康检查、速率限制)可以使您的系统作为一个平衡的单元工作。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="be7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。如果你喜欢你所读到的，看看下面这个故事:</p><div class="nr ns gp gr nt nu"><a rel="noopener  ugc nofollow" target="_blank" href="/4-ways-to-establish-communication-between-microservices-984207f29497"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">微服务之间建立通信的4种方式</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">每种方法的主要优缺点</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="od l"><div class="oe l of og oh od oi ks nu"/></div></div></a></div><p id="e5eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以考虑订阅我的电报频道<a class="ae ky" href="https://t.me/sd_daily" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">软件开发日报</strong> </a>从我这里获取更多内容。</p><p id="c151" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有，考虑成为<a class="ae ky" href="https://esashamathews.medium.com/membership" rel="noopener">中等会员</a>。</p></div></div>    
</body>
</html>