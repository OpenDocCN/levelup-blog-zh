# 在 C#中计算罗马数字

> 原文：<https://levelup.gitconnected.com/calculating-roman-numerals-in-c-d8532a00b5c0>

![](img/20e440a08612fa82c820c0967169a9c0.png)

最近，我的一个伙伴给了我一个挑战，要我写一个程序，把一个整数转换成罗马数字。

# StackOverflow.com 的回答

我看了一下[这个问题](https://stackoverflow.com/questions/7040289/converting-integers-to-roman-numerals/)，对答案有点惊讶。

大多数答案都有硬编码值，如“XL”代表 40，“XC”代表 90 等。

我心想，写这个的程序员一定在脑子里用逻辑算出了 X 和 C 加起来等于 90，为什么他不能把这个逻辑写到他的代码里，从而只需要硬编码主要的符号呢？

其他解决方案的问题在于，它们没有模拟人们思考问题的方式。

通过硬编码“IV”、“IX”、“XL”和“CM”等，你到处都有重复的符号。如果你想用“X”而不是“X”呢？你需要在不止一个地方做出改变。

这不支持“集中控制点”的概念，只是比硬编码每个可能值的强力方法稍微好一点的解决方案。

# 更自然的解决方案

我决定只对 7 个独特的符号进行硬编码: *I，V，X，L，C，D，M.*

下一步是用伪代码写下来，这是一个人在计算罗马数字时的思维过程。

## 选择最大的符号

一个好的起点是选择一个随机数，比如 22。

任何时候你看到罗马数字，最大的数字总是第一个(就像任何其他数字系统，除了小端二进制)。

可用于 22 的最大罗马数字符号是 X，即 10。

## 解决剩下的问题

写下 X 后，你需要算出其余的数。既然你已经有了 10，剩下的就是 22–10 = 12。

用罗马数字写 12，我们遵循同样的过程。我们可以用来写 12 的最大数字是 10，也就是 x。

所以现在我们有 XX，它是 20，其余的是 22–20 = 2。

我们可以用来写 2 的最大数字是 1，也就是 I。

所以现在我们有 XXI 是 21，其余的是 22–21 = 1。

我们可以用来写 1 的最大数字是 1，也就是 I。

所以现在我们有 XXII，它是 22，其余的是 22–22 = 0，这意味着我们完成了。

如你所见，我们对其余的输入使用相同的过程，这意味着我们需要使用递归。

## 一些边缘情况

有相当多的数字上面的过程不会工作。例如 40 不是 XXXX 而是 XL(50 之前的 10)。

规则是，只有当较小的数乘以 10 大于或等于较大的数时，才能将较小的数放在较大的数前面。

一个更简单的方法是，如果在 7 个罗马数字字母的列表中，一个较小的数字直接出现在一个较大的数字之前，并且它是 10 的幂，那么你只能将该较小的数字放在该较大的数字之前。

这意味着你不能为 99 写 IC，因为在罗马数字字母列表中，X 在 C 之前，而不是 I(注意 L 实际上在 C 之前，但它被忽略了，因为它不是 10 的幂)。

## 想办法把一个较小的符号放在一个较大的符号前面

让我们用一个例子来试着解决这个过程，来决定我们是否可以把一个较小的符号放在一个较大的符号前面。

让我们以 39 (XXXIX)、40 (XL)和 41 (XLI)为例。

取 39 上面的罗马数字符号 50 (L)，从中减去 39。50–39 = 11.这不小于或等于 39 以下的符号，即 10 (X)。

取 40 以上的罗马数字符号 50 (L)，从中减去 40。50–40 = 10.这小于或等于 40 以下的符号，即 10 (X)。

取 41 上面的罗马数字符号 50 (L)，从中减去 41。50–41 = 9.这小于或等于 40 以下的符号，即 10 (X)。

这可以用下面的规则来概括:

如果你输入的罗马数字和上面的罗马数字之差小于或等于你输入的下面的罗马数字，那么你可以把下面的符号放在较大的符号前面。

例如，输入= 41:
因为 50–41 = 9 且 9 小于或等于 10，所以可以在 50 前面加上 10 作为输出的开始:XL

# 其他需要注意的事项

## 更多信件

在代码中，我实际上使用了 13 个独特的罗马数字字母，这是因为在字母上加一条上划线会使它乘以 1000(我使用撇号而不是上划线)。

所以用的 13 个罗马数字字母是 I(1)，V(5)，X(10)，L(50)，C(100)，D(500)，M(1000)，V'(5000)，X'(10000)，L'(50000)，C'(100000)，M'(100000)

## 最大数量

有些人认为 3'999'999 是可以用罗马数字写出的最大值。

这是因为他们认为一个罗马数字字母不能连续显示三次以上。

这不是一个规则，而是在情况允许的情况下，必须在较大的字母前面使用较小的字母的结果。

比如你不能把 4 写成 IIII，原因不是因为 IIII 在一行中比字母 I 多 3 倍，而是因为你有一种情况，你必须把 I 放在 v 前面。

一行中有三个以上字母的情况是，当你达到一个数字时，这个数字太高，以至于在一个较大的字母前面没有较小的字母，因为较大的字母不存在。

当你需要写一个大于或等于 400 万的数 M'M'M'M '时，就会出现这种情况。

# 代码

下面基本就是上面的算法转换成 C#了。

要自己运行这个应用程序，你需要克隆[回购](https://github.com/DavidKlempfner/RomanNumeralCalculator)，因为下面只列出了应用程序的核心部分。

# 分级编码

感谢您成为我们社区的一员！[订阅我们的 YouTube 频道](https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1)或者加入 [**Skilled.dev 编码面试课程**](https://skilled.dev/) 。

[](https://skilled.dev) [## 编写面试问题+获得开发工作

### 掌握编码面试的过程

技术开发](https://skilled.dev)