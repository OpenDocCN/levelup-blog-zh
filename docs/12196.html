<html>
<head>
<title>React Components Testing with React Testing Library and Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React测试库和Jest测试React组件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-components-testing-with-react-testing-library-and-jest-5c13135ede8f?source=collection_archive---------3-----------------------#2022-05-23">https://levelup.gitconnected.com/react-components-testing-with-react-testing-library-and-jest-5c13135ede8f?source=collection_archive---------3-----------------------#2022-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d31fc6bb45f1695740ab8eb848f1f622.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9GFQsUCoWJSpPS-k"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@clark_fransa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿诺德·弗朗西斯卡</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="fa95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的上一篇文章中，我们已经介绍了Jest的用法来测试我们的JavaScript代码<a class="ae kf" href="https://medium.com/gitconnected/start-testing-your-javascript-code-with-jest-81e04f546a3e" rel="noopener">用Jest </a>开始测试您的JavaScript代码。我们将进一步扩展这个主题，介绍我们如何使用React测试库和Jest来测试我们的React组件。</p><p id="fd31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">React测试库和Jest通过<code class="fe le lf lg lh b">create-react-app</code>提供了开箱即用的支持，我们不需要单独安装它们。React测试库(RTL)构建在DOM测试库之上，因为测试将使用实际的DOM。这允许测试尽可能模拟用户与DOM交互的方式。它非常容易使用，提供了一系列断言方法(从Jest扩展而来)，用户事件模拟等等。</p><p id="a4e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">create-react-app</code>使用Jest作为它的测试运行程序。Jest将查找使用以下命名约定命名的测试文件(根据官方网站):</p><ul class=""><li id="01b1" class="li lj it ki b kj kk kn ko kr lk kv ll kz lm ld ln lo lp lq bi translated">带有的文件。__tests__文件夹中的js后缀。</li><li id="2aca" class="li lj it ki b kj lr kn ls kr lt kv lu kz lv ld ln lo lp lq bi translated">带有. test.js后缀的文件。</li><li id="4810" class="li lj it ki b kj lr kn ls kr lt kv lu kz lv ld ln lo lp lq bi translated">后缀为. spec.js的文件。</li></ul><p id="9213" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天，我们将探讨如何呈现要测试的组件，在组件中找到正确的元素，并执行快照测试。让我们开始创建一个新的<code class="fe le lf lg lh b">create-react-app</code>项目:</p><pre class="lw lx ly lz gt ma lh mb mc aw md bi"><span id="884d" class="me mf it lh b gy mg mh l mi mj">npx create-react-app testing-react-demo</span></pre><p id="9d1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建完成后，将目录更改为您创建的应用程序，并在您想要的代码编辑器中打开该目录。</p><p id="ac6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您应该已经在<em class="mk"> src </em>文件夹中看到了<em class="mk"> App.test.js </em>。</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="3abb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以删除这个文件，或者留下它。在本次演示中，我将删除它，因此您不会看到它包含在测试套件中。</p><p id="6d5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来我通常会创建一个<em class="mk">组件</em>文件夹，并将属于该组件的文件(如CSS和测试文件)包含在该文件夹中。创建<em class="mk">组件</em>文件夹后，再创建两个名为<em class="mk"> SubscribeForm </em>和<em class="mk"> PokeSearch </em>的文件夹。这是我们今天要写一些测试的两个组件。</p><p id="6f0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们在SubscribeForm文件夹中创建第一个简单组件:</p><p id="7f20" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mk">订阅表单. js </em></p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="a6e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个简单的组件，其中我们有一个电子邮件地址的输入字段，以及一个点击“订阅”的按钮。该按钮首先被禁用，并在任何文本输入到输入字段之前阻止单击。这个按钮似乎是我们可以创建的完美测试用例之一。</p><p id="6cab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该按钮在文本输入前被禁用:</p><figure class="lw lx ly lz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/9974f3ef3862e7af4dccdd04c647bb79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mRStXhWdr2vj5-4DN_2-ow.png"/></div></div></figure><p id="755a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该按钮在文本输入后启用:</p><figure class="lw lx ly lz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/dfcbba8f902e1ed06b33d4e188a89bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rbagWv3I-148vwoM36zhdA.png"/></div></div></figure><p id="41c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">紧接着就是这个，我们要创建另一个组件，叫做PokeSearch(我不是口袋妖怪的粉丝，但是Poke API很好演示)。作为另一个足够简单的例子，我们有一个组件，它有一个useEffect钩子来从API获取信息，并在屏幕上显示它(Pokemon name)。在获取结果之前，我们向用户显示一个“…正在加载…”的文本。</p><p id="419e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mk"> PokeSearch.js </em></p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="6eb5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们开始测试这两个组件。对于我们的第一个组件SubscribeForm组件，我们创建了一个名为<em class="mk"> SubscribeForm.test.js </em>的新文件。我们遵循了命名约定，以便我们的测试运行人员能够识别它。为了创建测试，我们将需要来自<em class="mk">测试库/反应</em>的<code class="fe le lf lg lh b">render</code>和<code class="fe le lf lg lh b">screen</code>以及来自<em class="mk">测试库/用户事件</em>的用户事件。此外，记得导入我们想要测试的组件。</p><pre class="lw lx ly lz gt ma lh mb mc aw md bi"><span id="99e5" class="me mf it lh b gy mg mh l mi mj">import React from 'react';<br/>import { render, screen } from '@testing-library/react';<br/>import userEvent from '@testing-library/user-event';<br/>import SubscribeForm from './SubscribeForm';</span></pre><p id="4f23" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以首先创建一个测试来确保我们的按钮在页面第一次加载时被禁用，因为在电子邮件地址字段中没有输入。</p><pre class="lw lx ly lz gt ma lh mb mc aw md bi"><span id="1a37" class="me mf it lh b gy mg mh l mi mj">it("The subscribe button is disabled before typing anything in the input text box", () =&gt; {<br/>    render(&lt;SubscribeForm /&gt;);<br/><br/>    expect(screen.getByRole("button", {name: /subscribe/i})).toBeDisabled();<br/>});</span></pre><p id="eb1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上一篇文章中，我们知道我们将为我们的测试命名，并提供一个回调函数，其中包括断言。</p><p id="df1d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们使用render方法在附加到document.body的容器中呈现要测试的组件(顺便说一下，Jest 26和之前的版本使用jsdom作为默认环境)。在呈现出组件之后，我们需要找到正确的元素(即按钮)来进行测试。我们可以使用RTL的查询方法来做到这一点。DOM中的元素可以通过它们的可访问性角色和名称(稍后将详细介绍)、文本或者我们给元素的测试id来找到。官方声明给予了优先权。他们建议通过角色或文本(每个人都可以访问)、语义HTML(替代文本，如img、area等)和测试id(用户看不到或听不到这些，因此如果您无法理解前面的任何方法，请使用这些方法)进行查询。</p><pre class="lw lx ly lz gt ma lh mb mc aw md bi"><span id="7f51" class="me mf it lh b gy mg mh l mi mj">&lt;div data-testid="test-element" /&gt;</span></pre></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><pre class="ma lh mb mc aw md bi"><span id="7eac" class="me mf it lh b gy mw mx my mz na mh l mi mj">screen.getByTestId('test-element')</span></pre><p id="5a86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以在这里找到更多关于优先级的信息:<br/> <a class="ae kf" href="https://testing-library.com/docs/queries/about#priority" rel="noopener ugc nofollow" target="_blank">关于React测试库的查询</a></p><p id="179b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以这样做来找出您的组件中的可访问角色:您可以在该组件的测试中编写<code class="fe le lf lg lh b">screen.getByRole("")</code>,它会失败，但会给您可访问性信息和那些元素的名称。</p><pre class="lw lx ly lz gt ma lh mb mc aw md bi"><span id="193c" class="me mf it lh b gy mg mh l mi mj">Here are the accessible roles:<br/><br/>      heading:<br/><br/>      Name "Subscribe To Our Newsletter":<br/>      &lt;h1 /&gt;<br/><br/>      --------------------------------------------------<br/>      textbox:<br/><br/>      Name "Email Address":<br/>      &lt;input<br/>        id="email"<br/>        name="email"<br/>        placeholder="Email Address"<br/>        type="email"<br/>        value=""<br/>      /&gt;<br/><br/>      --------------------------------------------------<br/>      checkbox:<br/><br/>      Name "I agree to disagree whatever the terms and conditions are.":<br/>      &lt;input<br/>        id="agreement_checkbox"<br/>        name="agreement_checkbox"<br/>        type="checkbox"<br/>      /&gt;<br/><br/>      --------------------------------------------------<br/>      button:<br/><br/>      Name "Subscribe":<br/>      &lt;button<br/>        class="button"<br/>        disabled=""<br/>        name="subscribe-button"<br/>        type="submit"<br/>      /&gt;<br/><br/>      --------------------------------------------------</span></pre><p id="04c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从这里我们知道我们有不同的可访问性角色，比如按钮、文本框、复选框和标题。为了定位我们的订阅按钮，我们需要定位角色“按钮”。在定位角色之后，我们特别想要具有可访问名称“Subscribe”的按钮，如所提供的可访问性信息中所述(名称“Subscribe”)。“名称”的这个值可以从一个元素的可见或不可见属性中导出，按钮中的文本就是其中之一。为了搜索它的名字，我们通常把名字上不区分大小写的regex，放到getByRole ( <code class="fe le lf lg lh b">{name: /subscribe/i}</code>)的第二个对象参数中。得到那个按钮后，我们要检查这个按钮是否被禁用(应该是禁用的)。</p><p id="bd58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们有第二个测试。在这个测试中，我们模拟用户事件，在文本框中输入内容，并启用按钮。</p><pre class="lw lx ly lz gt ma lh mb mc aw md bi"><span id="08d1" class="me mf it lh b gy mg mh l mi mj">it("The subscribe button becomes enabled when we start typing in the input text box", () =&gt; {<br/>    render(&lt;SubscribeForm /&gt;);<br/><br/>    userEvent.type(screen.getByRole("textbox", {name: /email/i}), "abc@email.com");<br/><br/>    expect(screen.getByRole("button", {name: /subscribe/i})).toBeEnabled();<br/>});</span></pre><p id="6bc6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用相同的步骤将SubscribeForm呈现给文档，并使用“type”的用户事件在我们想要的元素上键入一些文本，在本例中，它是textbox，我们可以通过可访问的角色和名称来选择它(回头参考我们刚才获取的可访问性信息)。第二个参数<code class="fe le lf lg lh b">userEvent.type()</code>是您想要输入的文本。输入文本后，我们现在可以期待按钮被激活。</p><p id="b7cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们正在对React组件进行快照测试。我们需要使用react-test-renderer为快照渲染一个纯JavaScript对象(不依赖于DOM)。</p><pre class="lw lx ly lz gt ma lh mb mc aw md bi"><span id="f5c9" class="me mf it lh b gy mg mh l mi mj">npm install react-test-renderer</span></pre><p id="2d80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">安装并导入后，我们可以使用渲染器在JavaScript对象中创建SubscribeForm组件。最后，我们使用Jest中的toMatchSnapshot()函数来启动快照测试。</p><pre class="lw lx ly lz gt ma lh mb mc aw md bi"><span id="49ba" class="me mf it lh b gy mg mh l mi mj">it("Test to match snapshot of component", () =&gt; {<br/>    const subscribeFormTree = renderer.create(&lt;SubscribeForm /&gt;).toJSON();<br/>    expect(subscribeFormTree).toMatchSnapshot();<br/>})</span></pre><p id="49ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您第一次运行这个测试时，它将创建一个新的文件夹(在您运行测试后自动创建)，在您的目录中称为<em class="mk">_ _快照__ </em>，在本例中，是SubscribeForm文件夹。</p><pre class="lw lx ly lz gt ma lh mb mc aw md bi"><span id="1d06" class="me mf it lh b gy mg mh l mi mj">PASS  src/components/PokeSearch/PokeSearch.test.js<br/> PASS  src/components/SubscribeForm/SubscribeForm.test.js<br/> › 1 snapshot written.<br/><br/>Snapshot Summary<br/> › 1 snapshot written from 1 test suite.<br/><br/>Test Suites: 2 passed, 2 total<br/>Tests:       5 passed, 5 total<br/>Snapshots:   1 written, 1 total<br/>Time:        2.519 s<br/>Ran all test suites.<br/><br/>Watch Usage: Press w to show more.</span></pre><figure class="lw lx ly lz gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/81119c760da62a12822c1fad3203dffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*RmfFwQcBoSJ28GJy1v0-Jw.png"/></div></figure><p id="38b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以在里面找到一个快照文档。</p><p id="c6b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mk">subscribe form . test . js . snap</em></p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="10fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然测试套件注意到了您之前的组件快照。如果您再次运行测试，它将获取组件的另一个快照，并将其与<em class="mk">_ _ snapshot _ _</em>文件夹中的快照进行比较。如果它们不同，测试将会失败。这有助于确保我们的UI组件不会被意外更改。让我们尝试对我们的SubscribeForm组件进行更改，并再次运行测试。我们将把“订阅我们的时事通讯”改为“订阅他们的时事通讯”。</p><pre class="lw lx ly lz gt ma lh mb mc aw md bi"><span id="3191" class="me mf it lh b gy mg mh l mi mj">&lt;h1&gt;Subscribe To Their Newsletter&lt;/h1&gt;</span></pre><p id="a7ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们再次进行测试。</p><pre class="lw lx ly lz gt ma lh mb mc aw md bi"><span id="98a1" class="me mf it lh b gy mg mh l mi mj">PASS  src/components/PokeSearch/PokeSearch.test.js<br/> FAIL  src/components/SubscribeForm/SubscribeForm.test.js<br/>  ● Test to match snapshot of component</span><span id="3673" class="me mf it lh b gy nc mh l mi mj">    expect(received).toMatchSnapshot()</span><span id="aafe" class="me mf it lh b gy nc mh l mi mj">    Snapshot name: `Test to match snapshot of component 1`</span><span id="a45f" class="me mf it lh b gy nc mh l mi mj">    - Snapshot  - 1<br/>    + Received  + 1</span><span id="c1bc" class="me mf it lh b gy nc mh l mi mj">    @@ -1,10 +1,10 @@<br/>      &lt;div<br/>        className="container"<br/>      &gt;<br/>        &lt;h1&gt;<br/>    -     Subscribe To Our Newsletter<br/>    +     Subscribe To Their Newsletter<br/>        &lt;/h1&gt;<br/>        &lt;form<br/>          className="form"<br/>        &gt;<br/>          &lt;label</span><span id="ed18" class="me mf it lh b gy nc mh l mi mj">      22 | it("Test to match snapshot of component", () =&gt; {<br/>      23 |     const subscribeFormTree = renderer.create(&lt;SubscribeForm /&gt;).toJSON();<br/>    &gt; 24 |     expect(subscribeFormTree).toMatchSnapshot();<br/>         |                               ^<br/>      25 | })</span><span id="1fc1" class="me mf it lh b gy nc mh l mi mj">      at Object.&lt;anonymous&gt; (src/components/SubscribeForm/SubscribeForm.test.js:24:31)</span><span id="4dbf" class="me mf it lh b gy nc mh l mi mj"> › 1 snapshot failed.<br/>Snapshot Summary<br/> › 1 snapshot failed from 1 test suite. Inspect your code changes or press `u` to update them.</span><span id="310c" class="me mf it lh b gy nc mh l mi mj">Test Suites: 1 failed, 1 passed, 2 total<br/>Tests:       1 failed, 4 passed, 5 total<br/>Snapshots:   1 failed, 1 total<br/>Time:        3.817 s<br/>Ran all test suites.</span><span id="521e" class="me mf it lh b gy nc mh l mi mj">Watch Usage: Press w to show more.</span></pre><p id="7bac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">…测试失败了。如果这是有意的更改，我们可以通过按“u”将快照更新到最新状态。通过这样做，我们的<em class="mk">_ _ snapshot _ _</em>文件夹中的快照文件将得到更新，所有的测试都将重新运行，并且这一次它们都通过了。这和我们上次用的(酶库)挺像的。</p><pre class="lw lx ly lz gt ma lh mb mc aw md bi"><span id="a882" class="me mf it lh b gy mg mh l mi mj">PASS  src/components/PokeSearch/PokeSearch.test.js<br/> PASS  src/components/SubscribeForm/SubscribeForm.test.js<br/> › 1 snapshot updated.</span><span id="3871" class="me mf it lh b gy nc mh l mi mj">Snapshot Summary<br/> › 1 snapshot updated from 1 test suite.</span><span id="404e" class="me mf it lh b gy nc mh l mi mj">Test Suites: 2 passed, 2 total<br/>Tests:       5 passed, 5 total<br/>Snapshots:   1 updated, 1 total<br/>Time:        2.504 s<br/>Ran all test suites.</span><span id="e623" class="me mf it lh b gy nc mh l mi mj">Watch Usage: Press w to show more.</span></pre><p id="e1b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，这是测试我们的SubscribeForm组件的完整脚本。</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="0ee6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:在每次测试之后，Jest(全局注入)会自动执行一个清理过程(<code class="fe le lf lg lh b">afterEach(cleanup)</code>)来防止内存泄漏。</p><p id="398f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们还想异步测试我们的组件(PokeSearch)。</p><pre class="lw lx ly lz gt ma lh mb mc aw md bi"><span id="90db" class="me mf it lh b gy mg mh l mi mj">import React from 'react';<br/>import { render,screen,waitForElementToBeRemoved } from '@testing-library/react';<br/>import PokeSearch from './PokeSearch';<br/><br/>it("Loading is shown until the Pokemon is fetched", async () =&gt; {<br/>    render(&lt;PokeSearch /&gt;);<br/><br/>    expect(screen.getByText('...Loading...')).toBeInTheDocument();<br/><br/>    await waitForElementToBeRemoved(screen.queryByText('...Loading...'));<br/>});</span></pre><p id="f6ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们可以测试“...正在加载..."文本被正确地呈现到屏幕上。我们需要查询包含“的正确元素...正在加载..."，并使用断言方法检查它是否在DOM中。然后，我们可以使用RTL提供的异步函数，通过加载文本元素来解决，以便在获取结果后消失。除此之外，官方网站还推荐使用<code class="fe le lf lg lh b">queryBy...</code>来查询从DOM中消失的元素。</p><p id="5276" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在测试了加载的文本之后，我们可以在获取之后测试用例。在这个测试案例中，我们不想用真正的API进行测试(我们只是确保我们的组件工作正常)，我们可以模拟fetch函数。当承诺被解析时，我们通过fetch函数修复返回的数据。之后，我们将呈现PokeSearch，fetch调用用于获取我们的假数据。数据返回后，我们将尝试使用<code class="fe le lf lg lh b">findBy...</code>(异步情况下使用<code class="fe le lf lg lh b">findBy...</code>)来查找包含文本“bulbasaur”的元素，并检查该元素是否在DOM中。</p><pre class="lw lx ly lz gt ma lh mb mc aw md bi"><span id="76a3" class="me mf it lh b gy mg mh l mi mj">it("The Pokemon name is displayed correctly after it has been fetched", async () =&gt; {<br/>    // Mock the browser fetch function<br/>    window.fetch = jest.fn(() =&gt; {<br/>        const pokemon = { name: 'bulbasaur', weight: 69, height: 7 };<br/><br/>        return Promise.resolve({<br/>          json: () =&gt; Promise.resolve(pokemon),<br/>        });<br/>    });<br/>    render(&lt;PokeSearch /&gt;);<br/>    const pokemonName = await screen.findByText('bulbasaur');<br/>    expect(pokemonName).toBeInTheDocument(); <br/>});</span></pre><p id="18c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望这能让您了解如何开始测试React组件。</p></div></div>    
</body>
</html>