<html>
<head>
<title>Android: Basic app using MVVM, Hilt, Coroutines, Flow, Retrofit, and Coil.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android:使用MVVM、刀柄、协程、流程、翻新和线圈的基本应用程序。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/android-basic-app-using-mvvm-hilt-coroutines-flow-retrofit-and-coil-433763542ee0?source=collection_archive---------0-----------------------#2021-06-29">https://levelup.gitconnected.com/android-basic-app-using-mvvm-hilt-coroutines-flow-retrofit-and-coil-433763542ee0?source=collection_archive---------0-----------------------#2021-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f26967e5ff0a90bb20e3dee4eda63e51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g7u-xj_SkyamEQU5"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">卢肯·萨贝拉诺在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="b474" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> Android架构组件</strong>为应用架构提供指导，为生命周期管理和数据持久化等常见任务提供库。<strong class="kf ir">架构组件</strong>帮助你用更少的样板代码构建一个健壮的、可测试的、可维护的应用程序，通过这篇文章，我们将做同样的事情。我已经完成了几个项目，并根据我的理解选择了最好的方法。</p><p id="e7a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于下面的实现，我假设你知道MVVM、刀柄、协程、流、改型和线圈的基本知识。在我们实施的过程中，我会根据我们的要求解释这些。(如果您希望我就这些主题写文章，请随时发表评论或联系我)。</p><p id="736f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于当前的实现，我们将使用<a class="ae kc" href="https://dog.ceo/dog-api/" rel="noopener ugc nofollow" target="_blank"> Dog API </a>，对于我们的用例，我们将需要以下依赖关系:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="29b4" class="lk ll iq lg b gy lm ln l lo lp">dependencies <strong class="lg ir">{<br/>    </strong>def coroutinesVersion = '1.4.3'<br/>    def retrofitVersion = "2.9.0"<br/>    def lifeCycleVersion = '2.2.0'<br/>    def daggerHiltVersion = '2.31.2-alpha'<br/>    def hiltLifeCycleVersion = '1.0.0-alpha03'<br/>    def coilVersion = '1.2.2'</span><span id="66fd" class="lk ll iq lg b gy lq ln l lo lp">    implementation "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"<br/>    implementation 'androidx.core:core-ktx:1.5.0'<br/>    implementation 'androidx.appcompat:appcompat:1.3.0'<br/>    implementation 'com.google.android.material:material:1.3.0'<br/>    implementation 'androidx.constraintlayout:constraintlayout:2.0.4'<br/>    testImplementation 'junit:junit:4.13.2'<br/>    androidTestImplementation 'androidx.test.ext:junit:1.1.2'<br/>    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'</span><span id="9843" class="lk ll iq lg b gy lq ln l lo lp">    def activity_version = "1.1.0"<br/>    implementation "androidx.activity:activity-ktx:$activity_version"<br/>    implementation "androidx.fragment:fragment-ktx:$activity_version"</span><span id="75fb" class="lk ll iq lg b gy lq ln l lo lp">    //ViewBinding<br/>    implementation 'com.android.databinding:viewbinding:4.2.1'</span><span id="44e9" class="lk ll iq lg b gy lq ln l lo lp">    //Coroutines<br/>    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-core:$coroutinesVersion"<br/>    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:$coroutinesVersion"<br/>    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-play-services:$coroutinesVersion"</span><span id="a6de" class="lk ll iq lg b gy lq ln l lo lp">    //Retrofit<br/>    implementation "com.squareup.retrofit2:retrofit:$retrofitVersion"<br/>    implementation "com.squareup.retrofit2:converter-gson:$retrofitVersion"<br/>    implementation "com.squareup.okhttp3:logging-interceptor:4.9.1"<br/>    implementation "com.squareup.retrofit2:converter-scalars:$retrofitVersion"</span><span id="935e" class="lk ll iq lg b gy lq ln l lo lp">    //material design<br/>    implementation 'com.google.android.material:material:1.3.0'</span><span id="80a1" class="lk ll iq lg b gy lq ln l lo lp">    // ViewModel<br/>    implementation "androidx.lifecycle:lifecycle-extensions:$lifeCycleVersion"<br/>    implementation "androidx.lifecycle:lifecycle-runtime-ktx:$lifeCycleVersion"<br/>    implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:$lifeCycleVersion"<br/>    implementation "androidx.lifecycle:lifecycle-livedata-ktx:$lifeCycleVersion"<br/></span><span id="694e" class="lk ll iq lg b gy lq ln l lo lp">    //Hilt for di<br/>    implementation "com.google.dagger:hilt-android:$daggerHiltVersion"<br/>    kapt "com.google.dagger:hilt-android-compiler:$daggerHiltVersion"<br/>    // Hilt ViewModel extension<br/>    implementation "androidx.hilt:hilt-lifecycle-viewmodel:$hiltLifeCycleVersion"<br/>    kapt "androidx.hilt:hilt-compiler:$hiltLifeCycleVersion"</span><span id="7bbb" class="lk ll iq lg b gy lq ln l lo lp">    //for image rendering<br/>    implementation "io.coil-kt:coil:$coilVersion"</span><span id="b0f6" class="lk ll iq lg b gy lq ln l lo lp"><strong class="lg ir">}</strong></span></pre><p id="f423" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经在我们使用的每个依赖项上添加了注释。此外，我们将使用视图绑定，为此我们需要在模块build.gradle文件中的android标签下添加以下内容:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="405b" class="lk ll iq lg b gy lm ln l lo lp">android <strong class="lg ir">{<br/>    ....<br/>    </strong>buildFeatures <strong class="lg ir">{<br/>        </strong>viewBinding true<br/>    <strong class="lg ir">}<br/>}</strong></span></pre><p id="a6a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在清单文件中添加internet权限，</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="0807" class="lk ll iq lg b gy lm ln l lo lp">&lt;uses-permission android:name="android.permission.INTERNET"/&gt;</span></pre><p id="c913" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的API非常简单，不需要我们注册API密钥。我们将使用随机图像获取端点，</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="4f2c" class="lk ll iq lg b gy lm ln l lo lp"><a class="ae kc" href="https://dog.ceo/api/breeds/image/random" rel="noopener ugc nofollow" target="_blank">https://dog.ceo/api/breeds/image/random</a></span></pre><p id="4091" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JSON响应非常简单，</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="34ff" class="lk ll iq lg b gy lm ln l lo lp">{<br/>    "message": "https://images.dog.ceo/breeds/mexicanhairless/n02113978_147.jpg",<br/>    "status": "success"<br/>}</span></pre><p id="2e3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">响应有两个字符串键，一个是狗图片的url，另一个是响应状态。</p><p id="1ad1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我更喜欢使用数据类<a class="ae kc" href="https://github.com/wuseal/JsonToKotlinClass" rel="noopener ugc nofollow" target="_blank">插件</a>从JSON获取我的数据类。根据您的需求，您可以选择多种其他设置，变量类型(val、var)、它们的默认类型(不可为空、可为空)、序列化库等。在我们的例子中，我们将使用不可空的val类型和Gson进行序列化和反序列化。我们的数据类看起来像这样，</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="40f8" class="lk ll iq lg b gy lm ln l lo lp">data class DogResponse(<br/>    @SerializedName("message")<br/>    val message: String,<br/>    @SerializedName("status")<br/>    val status: String<br/>)</span></pre><p id="ad71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在单独的类中维护常数，</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="7d53" class="lk ll iq lg b gy lm ln l lo lp">class Constants {</span><span id="cd6c" class="lk ll iq lg b gy lq ln l lo lp">    companion object {</span><span id="1b82" class="lk ll iq lg b gy lq ln l lo lp">        const val BASE_URL = "https://dog.ceo/"<br/>        const val RANDOM_URL = "api/breeds/image/random"<br/>    }<br/>}</span></pre><p id="cb51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经在这个类中定义了基本url和API url。我们的API调用的服务类如下所示，</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="9d85" class="lk ll iq lg b gy lm ln l lo lp">interface DogService {</span><span id="df00" class="lk ll iq lg b gy lq ln l lo lp">    @GET(Constants.RANDOM_URL)<br/>    <strong class="lg ir">suspend</strong> fun getDog(): <strong class="lg ir">Response</strong>&lt;DogResponse&gt;</span><span id="a47d" class="lk ll iq lg b gy lq ln l lo lp">}</span></pre><p id="7bb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个用GET注释的简单方法。我们将使用suspend函数来非阻塞地执行我们的任务。挂起函数是协程的核心。暂停功能只是一个可以暂停并在以后恢复的功能。他们可以执行一个长时间运行的操作，并在没有阻塞的情况下等待它完成。我们的响应包含在改进响应类中。</p><p id="64c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用Hilt进行依赖注入，并开始生成Hilt组件的代码，我们需要一个应用程序类，用@HiltAndroidApp注释</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="892e" class="lk ll iq lg b gy lm ln l lo lp"><strong class="lg ir">@HiltAndroidApp</strong><br/>class DogApplication : Application() {<br/>}</span></pre><p id="ae4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要忘记在清单文件中添加DogApplication类，</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="d9cc" class="lk ll iq lg b gy lm ln l lo lp">&lt;application<br/>        android:name=".DogApplication"<br/>        ..... <br/>       &gt;<br/>&lt;/application&gt;</span></pre><p id="8237" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们创建一个DogService接口的实例，</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="2b50" class="lk ll iq lg b gy lm ln l lo lp"><strong class="lg ir">@Module<br/>@InstallIn(SingletonComponent::class)</strong><br/>object NetworkModule {<br/>    <strong class="lg ir">@Singleton<br/>    @Provides</strong><br/>    fun provideHttpClient(): <strong class="lg ir">OkHttpClient</strong> {<br/>        return OkHttpClient<br/>            .Builder()<br/>            .readTimeout(15, TimeUnit.<em class="lr">SECONDS</em>)<br/>            .connectTimeout(15, TimeUnit.<em class="lr">SECONDS</em>)<br/>            .build()<br/>    }</span><span id="a772" class="lk ll iq lg b gy lq ln l lo lp">    <strong class="lg ir">@Singleton<br/>    @Provides</strong><br/>    fun provideConverterFactory(): <strong class="lg ir">GsonConverterFactory</strong> =<br/>         GsonConverterFactory.create()</span><span id="fccf" class="lk ll iq lg b gy lq ln l lo lp">    <strong class="lg ir">@Singleton<br/>    @Provides</strong><br/>    fun provideRetrofit(<br/>        okHttpClient: OkHttpClient,<br/>        gsonConverterFactory: GsonConverterFactory<br/>    ): <strong class="lg ir">Retrofit</strong> {<br/>        return Retrofit.Builder()<br/>            .baseUrl(<em class="lr">BASE_URL</em>)<br/>            .client(okHttpClient)<br/>            .addConverterFactory(gsonConverterFactory)<br/>            .build()<br/>    }</span><span id="ce5e" class="lk ll iq lg b gy lq ln l lo lp">    <strong class="lg ir">@Singleton<br/>    @Provides</strong><br/>    fun provideCurrencyService(retrofit: Retrofit): <strong class="lg ir">DogService</strong> =<br/>        retrofit.create(DogService::class.<em class="lr">java</em>)</span><span id="94fa" class="lk ll iq lg b gy lq ln l lo lp">}</span></pre><p id="7880" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经定义了创建DogService接口实例所需的下列依赖项的单例实例，Hilt通过检查其他带注释方法的返回类型来自动检查所需的依赖项。由于这些依赖项是第三方库，我们需要用@Module注释来注释我们的对象。</p><blockquote class="ls"><p id="71da" class="lt lu iq bd lv lw lx ly lz ma mb la dk translated">挂起函数只能从协程或另一个挂起函数中调用</p></blockquote><p id="f470" class="pw-post-body-paragraph kd ke iq kf b kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">现在我们有了网络模块，让我们在远程数据源中注入服务类，并将其传播到存储库。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ffc6" class="lk ll iq lg b gy lm ln l lo lp">class RemoteDataSource @Inject constructor(private val dogService: DogService) {</span><span id="1a3a" class="lk ll iq lg b gy lq ln l lo lp">    suspend fun getDog() =<br/>        dogService.getDog()</span><span id="7803" class="lk ll iq lg b gy lq ln l lo lp">}</span></pre><p id="6ffc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们只是构造函数注入服务并调用getDog()方法。在到达存储库之前，我们将使用我们可能的响应类型创建一个网络结果类，</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="2f6b" class="lk ll iq lg b gy lm ln l lo lp">sealed class NetworkResult&lt;T&gt;(<br/>    val data: T? = null,<br/>    val message: String? = null<br/>) {</span><span id="333d" class="lk ll iq lg b gy lq ln l lo lp">    class Success&lt;T&gt;(data: T) : NetworkResult&lt;T&gt;(data)</span><span id="8d8d" class="lk ll iq lg b gy lq ln l lo lp">    class Error&lt;T&gt;(message: String, data: T? = null) : NetworkResult&lt;T&gt;(data, message)</span><span id="61b6" class="lk ll iq lg b gy lq ln l lo lp">    class Loading&lt;T&gt; : NetworkResult&lt;T&gt;()</span><span id="78c0" class="lk ll iq lg b gy lq ln l lo lp">}</span></pre><p id="5906" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的类是一个通用的密封类，具有可能的响应类型——为了更好地理解这一点，请阅读一下<a class="ae kc" href="https://medium.com/codex/kotlin-sealed-classes-for-better-handling-of-api-response-6aa1fbd23c76" rel="noopener"> this </a>,我在那里详细阐述了密封类对于更好地处理API响应的必要性。</p><p id="1c38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了封装来自viewmodel类的基本API响应检查，我们将使用一个抽象类来处理这些检查并传播API响应，</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b909" class="lk ll iq lg b gy lm ln l lo lp">abstract class BaseApiResponse {</span><span id="f71b" class="lk ll iq lg b gy lq ln l lo lp">    suspend fun &lt;T&gt; <strong class="lg ir">safeApiCall</strong>(apiCall: suspend () -&gt; Response&lt;T&gt;): NetworkResult&lt;T&gt; {<br/>        try {<br/>            val response = apiCall()<br/>            if (response.<em class="lr">isSuccessful</em>) {<br/>                val body = response.body()<br/>                body?.<em class="lr">let </em><strong class="lg ir">{<br/>                    </strong>return NetworkResult.Success(body)<br/>                <strong class="lg ir">}<br/>            </strong>}<br/>            return error("${response.code()} ${response.message()}")<br/>        } catch (e: Exception) {<br/>            return error(e.message ?: e.toString())<br/>        }<br/>    }</span><span id="6a99" class="lk ll iq lg b gy lq ln l lo lp">    private fun &lt;T&gt; error(errorMessage: String): NetworkResult&lt;T&gt; =<br/>        NetworkResult.Error("Api call failed $errorMessage")</span><span id="79bd" class="lk ll iq lg b gy lq ln l lo lp">}</span></pre><p id="aa60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">BaseApiResponse类将由我们的存储库扩展，并从存储库调用，</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="e0d7" class="lk ll iq lg b gy lm ln l lo lp"><strong class="lg ir">@ActivityRetainedScoped</strong><br/>class Repository @Inject constructor(<br/>    private val remoteDataSource: RemoteDataSource<br/>) : <strong class="lg ir">BaseApiResponse() </strong>{</span><span id="9784" class="lk ll iq lg b gy lq ln l lo lp">    suspend fun getDog(): Flow&lt;NetworkResult&lt;DogResponse&gt;&gt; {<br/>        return <em class="lr">flow</em>&lt;NetworkResult&lt;DogResponse&gt;&gt; <strong class="lg ir">{<br/>            emit</strong>(<strong class="lg ir">safeApiCall { remoteDataSource.getDog() }</strong>)<br/>        <strong class="lg ir">}</strong>.<em class="lr">flowOn</em>(Dispatchers.IO)<br/>    }</span><span id="9863" class="lk ll iq lg b gy lq ln l lo lp">}</span></pre><p id="b426" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的两个代码片段中，我们创建了一个基本响应处理类，它是从存储库中调用的，扩展了我们的抽象BaseApiResponse类。我们将<strong class="kf ir"> getDog() </strong>方法作为参数传递给<strong class="kf ir"> safeApiCall </strong>方法，后者依次执行该方法并检查响应。我们在这里添加了基本的响应检查，但是您可以根据您的API预期响应类型来更新这些检查。最后，存储库中的suspend函数发出数据。这样，我们的视图模型将更加清晰。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="d6ff" class="lk ll iq lg b gy lm ln l lo lp"><strong class="lg ir">@HiltViewModel</strong><br/>class MainViewModel <strong class="lg ir">@Inject constructor<br/>    (<br/>    private val repository: Repository,</strong><br/>    application: Application<br/>) : AndroidViewModel(application) {</span><span id="306c" class="lk ll iq lg b gy lq ln l lo lp">    private val <strong class="lg ir">_response</strong>: MutableLiveData&lt;NetworkResult&lt;DogResponse&gt;&gt; = MutableLiveData()<br/>    val <strong class="lg ir">response</strong>: LiveData&lt;NetworkResult&lt;DogResponse&gt;&gt; = _response</span><span id="fbb0" class="lk ll iq lg b gy lq ln l lo lp">    fun fetchDogResponse() = <strong class="lg ir"><em class="lr">viewModelScope</em></strong>.<em class="lr">launch </em><strong class="lg ir">{<br/>    </strong>repository.getDog().collect <strong class="lg ir">{ </strong>values <strong class="lg ir">-&gt;<br/>        </strong>_response.<em class="lr">value </em>= values<br/>    <strong class="lg ir">}<br/>  }</strong></span><span id="b99a" class="lk ll iq lg b gy lq ln l lo lp">}</span></pre><p id="b9c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用@HiltViewModel注释的ViewModel类通过构造函数注入来获取存储库。既然我们已经在BaseApiResponse类中添加了响应检查，我们只需要从API响应中收集发出的值。为了调用该方法，我们启动一个viewModelScope <strong class="kf ir"> <em class="lr"> </em> </strong>，并将响应设置为our _response变量，该变量是可变的实时数据。我们将_response变量作为私有变量，因为它是可变的，并将它的值设置为response变量，它是不可变的实时数据。我们将在我们的活动中观察同样的情况。</p><p id="2ec1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在处于演示应用程序的最后阶段，我们需要做的就是调用fetchDogResponse()方法并绑定响应，</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="273c" class="lk ll iq lg b gy lm ln l lo lp">@AndroidEntryPoint<br/>class MainActivity : AppCompatActivity() {</span><span id="c166" class="lk ll iq lg b gy lq ln l lo lp">    private val mainViewModel by <em class="lr">viewModels</em>&lt;MainViewModel&gt;()<br/>    private lateinit var _binding: ActivityMainBinding</span><span id="4607" class="lk ll iq lg b gy lq ln l lo lp">    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        _binding = ActivityMainBinding.inflate(<em class="lr">layoutInflater</em>)<br/>        setContentView(_binding.<em class="lr">root</em>)</span><span id="cb23" class="lk ll iq lg b gy lq ln l lo lp">        fetchData()<br/> <strong class="lg ir"><br/>    </strong>}<br/>}</span></pre><p id="4196" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们已经通过<em class="lr"> viewModels </em> delegate初始化了viewmodel，并使用视图绑定来绑定视图。如果你想了解更多关于视图绑定的内容，你可以在这里阅读<a class="ae kc" href="https://medium.com/geekculture/android-viewbinding-over-findviewbyid-389401b41706" rel="noopener"/>。最后，我们调用fetchData()，将视图绑定到数据，或者根据响应使用适当的操作，</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="cfc2" class="lk ll iq lg b gy lm ln l lo lp">private fun fetchData() {<br/>    mainViewModel.fetchDogResponse()<br/>    mainViewModel.response.observe(this) <strong class="lg ir">{ </strong>response <strong class="lg ir">-&gt;<br/>        </strong>when (response) {<br/>            is <strong class="lg ir">NetworkResult.Success -&gt; {<br/>               // bind data to the view<br/>            }</strong></span><span id="c3cc" class="lk ll iq lg b gy lq ln l lo lp">            is <strong class="lg ir">NetworkResult.Error -&gt; {<br/>                // show error message<br/>            }</strong></span><span id="a360" class="lk ll iq lg b gy lq ln l lo lp">            is <strong class="lg ir">NetworkResult.Loading -&gt; {<br/>                // show a progress bar<br/>            }</strong><br/>        }<br/>    <strong class="lg ir">}<br/></strong>}</span></pre><p id="3aec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们调用fetchDogResponse()方法，开始观察响应，并做必要的工作。</p><p id="acab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了通过响应渲染图像，我们将使用比其他图像加载库<a class="ae kc" href="https://coil-kt.github.io/coil/#:~:text=An%20image%20loading,Coroutine%20Image%20Loader." rel="noopener ugc nofollow" target="_blank">更好的【coil</a></p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="e97a" class="lk ll iq lg b gy lm ln l lo lp">_binding.imgDog.<strong class="lg ir"><em class="lr">load</em></strong>(<br/>    response.data.message<br/>) <strong class="lg ir">{<br/>    </strong>transformations(RoundedCornersTransformation(16f))<br/><strong class="lg ir">}</strong></span></pre><p id="7aae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用id imgDog在ImageView中呈现图像，并将图像url传递给load，这是线圈库提供的扩展函数。我们可以给我们的图像添加大量的修改，但是这里我只是为圆角添加了一个简单的变换。你可以用线圈做更多这样的事情，它是从盒子里出来的。</p><p id="6a5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在这里找到最终项目<a class="ae kc" href="https://github.com/aroranubhav/DogAPI/tree/main" rel="noopener ugc nofollow" target="_blank"/>。希望你今天学到了一些东西，干杯！</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure></div></div>    
</body>
</html>