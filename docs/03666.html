<html>
<head>
<title>The isNaN() Function For JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript的isNaN()函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-isnan-function-for-javascript-955a424bbd36?source=collection_archive---------18-----------------------#2020-05-21">https://levelup.gitconnected.com/the-isnan-function-for-javascript-955a424bbd36?source=collection_archive---------18-----------------------#2020-05-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2b49d1e7768989a92f44cd699eebaf9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FyfBjOb6jny9z0Kd4nAL2w.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">不是…猫头鹰？</figcaption></figure><p id="bdf9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<code class="fe la lb lc ld b">JavaScript</code>中，有一个全局对象的属性叫做<code class="fe la lb lc ld b"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN" rel="noopener ugc nofollow" target="_blank">NaN</a></code>。<code class="fe la lb lc ld b">NaN</code>是“不是数字”的缩写，更确切地说，是首字母缩略词，不要与美味的大饼混淆:<a class="ae le" href="https://en.wikipedia.org/wiki/Naan" rel="noopener ugc nofollow" target="_blank"> naan </a>。<code class="fe la lb lc ld b">NaN</code>很少用于编写程序或脚本。在现代web浏览器中，它是一个不可配置和不可写的属性。当一个数学(<code class="fe la lb lc ld b"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math" rel="noopener ugc nofollow" target="_blank">Math</a></code>)函数失败时，或者当一个函数无法解析一个数字时，它通常作为返回值被接收，例如<em class="lf"/><code class="fe la lb lc ld b">parseInt()</code>。<code class="fe la lb lc ld b">NaN</code>古怪而不常见，但偶尔出现，需要处理。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><p id="b5e3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在最近的一个项目中，使用<code class="fe la lb lc ld b">React</code>客户端，用户帐户包括收集的股票和相应价格的投资组合。投资组合必须包括总收入的总和。听起来很简单:从投资组合中收集所有的股票价格，并将它们加在一起。当然，事情永远不会像最初想象的那么简单。</p><p id="c8f5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当返回的用户登录到他们的帐户时，状态被加载该用户的股票，但是这些股票的价格——以及总收益——是通过获取当前市场价格的外部<code class="fe la lb lc ld b">API</code>来动态呈现的。困难在于正确地定时和调度从服务器端数据库和外部<code class="fe la lb lc ld b">API</code>获取数据的动作，同时在客户端正确地呈现组件。在这个事件链中，会调度一个动作来计算用户总收入的总和，这个动作由一个名为<code class="fe la lb lc ld b">setTotalEarnings</code>的函数来解析。</p><p id="656e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最好的解决方案是首先正确地对获取、承诺和组件呈现进行排序，或者精心设计<code class="fe la lb lc ld b">setTotalEarnings</code>函数以更好地控制返回值，或者更简单地在有条件呈现时处理虚假的返回值，但是，由于我是在很短的时间内为评估构建这个应用程序的，所以我向前推进并解决了及时工作所需的问题！长话短说，<code class="fe la lb lc ld b">setTotalEarnings</code>函数间歇地返回<code class="fe la lb lc ld b">NaN</code>，我在处理它以在适当的<code class="fe la lb lc ld b">React</code>组件中正确呈现时遇到了麻烦。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><p id="a280" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我意识到等式运算符不能可靠地确定<code class="fe la lb lc ld b">setTotalEarnings</code>的返回值是否为<code class="fe la lb lc ld b">NaN</code>，因为<code class="fe la lb lc ld b">NaN === NaN</code>的计算结果为<code class="fe la lb lc ld b">false</code>！这是<code class="fe la lb lc ld b">JavaScript</code>中离奇而独特的一幕。<code class="fe la lb lc ld b">NaN</code>是<code class="fe la lb lc ld b">JavaScript</code>中唯一不等于自身的值。有一个有用的快捷方式可以更准确地处理<code class="fe la lb lc ld b">NaN</code>:函数<code class="fe la lb lc ld b">isNaN()</code>。这很容易雇用。只需向函数传递一个参数:</p><pre class="ln lo lp lq gt lr ld ls lt aw lu bi"><span id="34d6" class="lv lw iq ld b gy lx ly l lz ma">isNaN(NaN) // true<br/>isNaN({})  // true<br/>isNaN(5)   // false</span></pre><p id="ae67" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">虽然这个函数足够简单，但是仍然存在一些奇怪和有问题的特例行为。例如:</p><pre class="ln lo lp lq gt lr ld ls lt aw lu bi"><span id="56d9" class="lv lw iq ld b gy lx ly l lz ma">isNaN(true) // false</span></pre><p id="8940" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">换句话说，“难道<code class="fe la lb lc ld b">true</code> <strong class="ke ir">不是</strong>是一个数字？”，你会认为它是正确的，来评估<code class="fe la lb lc ld b">true</code>。<code class="fe la lb lc ld b">true</code>是不是<strong class="ke ir">不是</strong>一个数字，然而<code class="fe la lb lc ld b">isNaN()</code>函数返回:<code class="fe la lb lc ld b">false</code>，暗示<code class="fe la lb lc ld b">true</code>是<strong class="ke ir">不是</strong>不是一个数字，<em class="lf">即</em> <code class="fe la lb lc ld b">true</code> <em class="lf">是</em>一个数字，这是不正确的。发生这种行为是因为<code class="fe la lb lc ld b">isNaN()</code>函数打算接受数值，即<code class="fe la lb lc ld b">number</code>类型的值。当一个非数字值被传递给<code class="fe la lb lc ld b">isNaN()</code>函数时，该值首先被强制转换成一个数字，然后进行计算。关于前面的例子，参数<code class="fe la lb lc ld b">true</code>首先被强制转换为<code class="fe la lb lc ld b">1</code>的二进制表示。<code class="fe la lb lc ld b">1</code>是一个数字，<strong class="ke ir">不是</strong> <code class="fe la lb lc ld b">NaN</code>，所以函数返回<code class="fe la lb lc ld b">false</code>。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><p id="2773" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了给对<code class="fe la lb lc ld b">NaN</code>值的评估增加额外的保险和可预测性，有一个对<code class="fe la lb lc ld b">isNaN()</code>函数的继承:<code class="fe la lb lc ld b">Number.isNaN()</code>方法。该方法在评估值的类型是否为<code class="fe la lb lc ld b">NaN</code>之前，额外评估被评估值的类型是否为<code class="fe la lb lc ld b">number</code>。</p><p id="e74c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">重温之前的例子:</p><pre class="ln lo lp lq gt lr ld ls lt aw lu bi"><span id="60cb" class="lv lw iq ld b gy lx ly l lz ma">isNaN({}) // true<br/>Number.isNaN({}) // false</span></pre><p id="3ff4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如第一种情况所确认的，输入值<code class="fe la lb lc ld b">{}</code>不是一个数字，然而，在第二种情况下，它的计算结果为<code class="fe la lb lc ld b">false</code>，因为它属于<code class="fe la lb lc ld b">object</code>类型，而不是<code class="fe la lb lc ld b">number</code>类型，这意味着输入值不是数字，不能正确地与<code class="fe la lb lc ld b">NaN</code>进行比较。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><p id="7a62" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">isNaN()</code>和<code class="fe la lb lc ld b">Number.isNaN()</code>是您可能永远都不需要使用的特殊工具，但是当有一天您需要使用时，它们是正确处理数据的便利工具。当面对一个特殊的场景时，通过一种编程语言的较少使用的能力和最大化你的分辨率总是有趣的！</p><p id="c055" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae le" href="https://github.com/dangrammer" rel="noopener ugc nofollow" target="_blank">github.com/dangrammer</a><br/>T15】linked.com/in/danieljromans<br/>T18】danromans.com</p></div></div>    
</body>
</html>