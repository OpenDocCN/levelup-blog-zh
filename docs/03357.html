<html>
<head>
<title>A Second Thought On Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于递归的再思考</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-second-thought-on-recursion-6575efeb2934?source=collection_archive---------22-----------------------#2020-05-04">https://levelup.gitconnected.com/a-second-thought-on-recursion-6575efeb2934?source=collection_archive---------22-----------------------#2020-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9425" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">递归:一个常见的面试问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fc12eb35ffad68539932447ad59dbca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ir-xXi6vdIPkyC8y4lZCPw.png"/></div></div></figure><p id="6925" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我们将探索在JavaScript/TypeScript中计算斐波那契数的各种方法。编程技术包括<em class="lq">递归函数</em>、<em class="lq">尾调用优化(TCO) </em>、<em class="lq">蹦床</em>、<em class="lq">迭代函数</em>、<em class="lq">动态编程</em>、<em class="lq">记忆化</em>。</p><p id="4afb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文的目标是让您相信在JavaScript/TypeScript中通常应该避免递归函数。相反，我们可以使用等价的迭代函数来获得更好的性能。此外，我们应该考虑使用内存化来提高重复请求的运行时性能。</p><p id="f54a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您不想通读本文的其余部分，那么您应该看看下面的截图，它显示了一组计算斐波纳契数<em class="lq"> F₂₀ </em>的函数的基准测试结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/b052c0d48f411975914f402feed14c9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*jvbLb2h1p0c_5CyhCtE4pA.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">计算斐波那契数F(20)的一组函数的基准等级。基准测试<a class="ae lw" href="https://jsben.ch/XVrhn" rel="noopener ugc nofollow" target="_blank">链接</a>。</figcaption></figure><p id="e084" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从基准测试结果中，我们可以看出递归函数的性能最低。即使像TCO和Trampoline这样的技巧可以加速递归，它们仍然比迭代函数和使用自底向上循环的动态编程要慢。</p><p id="4f54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好吧。让我们深入研究计算斐波纳契数的不同实现。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="2a3c" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">递归函数</h1><p id="d343" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">一个<em class="lq">递归函数</em>是一个调用自己直到不调用为止的函数，这种编程范式被称为<em class="lq">递归</em>。在一些计算机科学入门课上，教授们经常使用递归函数来教授排序算法、动态编程等等。</p><p id="3d5e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">递归的一个著名例子是斐波那契数的计算。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/f5be1707445de7ff06b9c232e159e94f.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*s-BmwYqKjRX8vQYK.gif"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">斐波那契数</figcaption></figure><p id="c829" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">直观地说，我们可以使用下面的函数计算斐波那契数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="37ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个递归函数模仿了数学公式，非常简洁易懂。你可能经历过许多要求你使用递归的编码面试或编程实践，因为递归是一个重要的编程概念，递归地解决问题显示了你将大问题分成小步骤的能力。因此，如果你需要为面试做准备，那么理解递归是如何工作的是很重要的，并确保你大量练习，以便能够编写优雅的递归函数。</p><p id="a15d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，除了面试和实践的场景之外，递归函数很少出现在产品代码中，这可能是由于几个问题。递归函数的一个问题是指数时间复杂度。如果我们使用上面的函数来计算<em class="lq"> F₆₀ </em>，那么代码可能会冻结，因为它是如此的低效。</p><p id="08ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个常见的问题是臭名昭著的“<em class="lq">过多递归</em>”异常(<a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Too_much_recursion" rel="noopener ugc nofollow" target="_blank">链接</a>)。当这个异常发生时，不同的浏览器显示不同的错误信息，见下文。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="cbfa" class="nj mf it nf b gy nk nl l nm nn">Error: Out of stack space (Edge)<br/>InternalError: too much recursion (Firefox)<br/>RangeError: Maximum call stack size exceeded (Chrome)</span></pre><p id="3e7a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当有太多的函数调用，或者函数缺少基本用例时，就会发生这种异常。在递归过程中，每个函数调用都会向<a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Glossary/Call_stack" rel="noopener ugc nofollow" target="_blank">调用堆栈</a>添加一个新的堆栈帧。如果递归超过最大调用堆栈大小，那么将引发“堆栈溢出”错误。</p><p id="3633" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以递归函数不仅速度慢，而且在计算比较密集的情况下也不实用。有时，人们倾向于使用一些技巧，如尾调用和蹦床，来规避“堆栈溢出”错误。</p><h1 id="47aa" class="me mf it bd mg mh no mj mk ml np mn mo jz nq ka mq kc nr kd ms kf ns kg mu mv bi translated">尾部调用优化</h1><p id="28b0" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated"><a class="ae lw" href="https://en.wikipedia.org/wiki/Tail_call" rel="noopener ugc nofollow" target="_blank">尾调用</a>是作为程序的最终动作执行的子程序调用。在递归中，尾部调用将导致同一子例程在调用链中稍后被再次调用；这种类型的递归通常被称为<em class="lq">尾递归</em>或<em class="lq">尾递归</em>。尾递归的特征是:(1)它有一个可以退出调用栈的基例；(2)它只有一个子例程，该子例程从以前的调用中结转一些数据。下面是一个计算斐波那契数列的尾部调用函数的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="187f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">记住，常规递归很难计算F₆₀.相反，上面的尾部递归函数能够轻松确定<em class="lq"> F₁₄₇₆ </em>，它是JavaScript中正数<code class="fe nt nu nv nf b">Infinity</code>之前的最后一个斐波那契数。性能提高是因为与常规递归函数相比，尾部调用不需要那么多堆栈帧。</p><p id="4eb4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<strong class="kw iu">常规递归</strong>中，函数首先执行递归调用，直到基本情况，然后根据所有递归调用的返回值计算结果。在这个范例中，需要每个调用帧来获得最终结果。另一方面，在<strong class="kw iu">尾递归</strong>中，函数在进行递归调用的同时执行计算，直到到达基例并返回最终结果。每个尾调用都将结果传递给下一个递归步骤，因此它的堆栈帧可以从调用堆栈中释放。</p><p id="fc57" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">综上所述，尾递归相对安全，比常规递归快得多。如果你真的想写递归函数，那么你必须实现TCO来避免麻烦。</p><h1 id="a8f3" class="me mf it bd mg mh no mj mk ml np mn mo jz nq ka mq kc nr kd ms kf ns kg mu mv bi translated">蹦床</h1><p id="4951" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">一个<a class="ae lw" href="https://en.wikipedia.org/wiki/Trampoline_(computing)" rel="noopener ugc nofollow" target="_blank">蹦床函数</a>是一种<em class="lq">高阶函数</em>，它返回一个包装函数，而不是直接执行函数。trampoline函数的目的是以迭代的方式控制执行，以便在任何给定时间只有一个堆栈帧被添加到调用堆栈中。</p><p id="788d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以将尾部调用函数稍微修改成一个<code class="fe nt nu nv nf b">_fib</code>函数，返回一个带有结转参数的函数。然后我们利用一个<code class="fe nt nu nv nf b">trampoline</code>函数来计算斐波那契数。下面的代码片段显示了一个示例实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a244" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nt nu nv nf b">trampoline</code>函数将递归函数<code class="fe nt nu nv nf b">fn</code>包装在一个循环中，并返回一个新函数。我们将递归函数<code class="fe nt nu nv nf b">_fib</code>作为<code class="fe nt nu nv nf b">trampoline</code>函数中的<code class="fe nt nu nv nf b">fn</code>传入，其中<code class="fe nt nu nv nf b">_fib</code>函数作为新函数被递归调用和解析，直到<code class="fe nt nu nv nf b">_fib</code>返回值。</p><p id="753a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管trampoline函数可以解决“堆栈溢出”问题，但由于包装和调用函数以及绑定函数参数等过程，它的时间开销非常大。此外，在读者掌握蹦床之前，可读性比尾部递归差。所以在采用这个花哨的蹦床函数解决递归问题之前，我们需要三思。最有可能的是，我们会发现迭代方法是救命稻草。</p><h1 id="6a5a" class="me mf it bd mg mh no mj mk ml np mn mo jz nq ka mq kc nr kd ms kf ns kg mu mv bi translated">迭代函数</h1><p id="98eb" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">迭代函数是使用循环多次重复相同过程的函数。一般来说，递归函数更易读、更简洁，但是迭代函数也更易读，因为循环是最简单的编程概念，即使对于初学者来说也是如此。</p><p id="e106" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以编写下面的函数来计算斐波那契数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="439d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个函数在计算斐波纳契数方面与tail call函数具有相同的能力。如开始部分的基准测试结果所示，这个迭代函数是所有函数中最快的，具有线性时间复杂度和恒定的空间复杂度。</p><p id="be82" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意还有很多优化技术可以让迭代更快(<a class="ae lw" href="https://www.nayuki.io/page/fast-fibonacci-algorithms" rel="noopener ugc nofollow" target="_blank"> link </a>)，这里就不展开了。</p><h1 id="2949" class="me mf it bd mg mh no mj mk ml np mn mo jz nq ka mq kc nr kd ms kf ns kg mu mv bi translated">动态规划</h1><p id="d956" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">动态规划通常用于解决可以通过其子问题解决的问题。动态规划算法通常具有良好的可读性和简洁。动态编程函数通常在内存中使用一个对象来存储中间值。</p><p id="4867" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用下面的动态编程函数<code class="fe nt nu nv nf b">fib_dp</code>以自下而上的方式计算斐波那契数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="6dfe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">函数<code class="fe nt nu nv nf b">fib_dp</code>使用一个数组来跟踪它计算的所有斐波纳契数。动态编程函数比递归函数快，但由于数组存储的开销，比纯迭代函数慢。</p><p id="17a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以将数组从函数<code class="fe nt nu nv nf b">fib_dp</code>中取出，并将数组用作全局缓存。这种技术叫做<a class="ae lw" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank"> <em class="lq">记忆化</em> </a>，在函数接收重复请求时，可以大大提高性能。因此，动态规划通常与记忆一起使用。</p><h1 id="c17d" class="me mf it bd mg mh no mj mk ml np mn mo jz nq ka mq kc nr kd ms kf ns kg mu mv bi translated">记忆化:数组与映射</h1><p id="97a4" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">在实际应用中，记忆被广泛采用。JavaScript/ TypeScript有两种常见的记忆化方法:<code class="fe nt nu nv nf b"><a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank">Array</a></code>和<code class="fe nt nu nv nf b"><a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank">Map</a></code>。我们可以将动态编程函数重写为以下两个代码片段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">使用数组对象计算带记忆的斐波那契数</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">使用地图对象计算带记忆的斐波那契数</figcaption></figure><p id="4f97" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其中一个函数使用一个<code class="fe nt nu nv nf b">Array</code>对象作为全局缓存，另一个使用一个<code class="fe nt nu nv nf b">Map</code>对象。为了展示记忆化的好处，上面的代码片段通过计算从0到999的斐波那契数来测试性能，然后从1000到1反向计算它们。</p><p id="6125" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如你所料，它们非常快。基准测试结果如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/967e7317d5fc2e9206f77f1d0257c67f.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*i3wKV1Y2dqgygObWh-trAQ.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">使用数组和映射的记忆来计算2000个斐波那契数的基准等级。基准测试<a class="ae lw" href="https://jsben.ch/RerI6" rel="noopener ugc nofollow" target="_blank">链接</a></figcaption></figure><p id="25a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，由于线性和连续的数组索引，使用<code class="fe nt nu nv nf b">Array</code>对象作为全局缓存要优于<code class="fe nt nu nv nf b">Map</code>对象。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="f6a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">经过长途跋涉，我们到达了本文的结尾。总而言之，我们的工具箱中有很多编程范例，对递归函数的重新思考可能会帮助您决定您想要采用哪种方法。</p><p id="a66e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">希望有帮助。感谢阅读。</p></div></div>    
</body>
</html>