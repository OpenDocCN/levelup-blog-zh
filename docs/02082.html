<html>
<head>
<title>Creating Web Components — Templates and Slots</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建Web组件—模板和插槽</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-web-components-templates-and-slots-bd6905a7092a?source=collection_archive---------13-----------------------#2020-02-17">https://levelup.gitconnected.com/creating-web-components-templates-and-slots-bd6905a7092a?source=collection_archive---------13-----------------------#2020-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9928365321b5737d3692d53cd03a2823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*flZ-pw8ryxNeWnty"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@b620?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">巴西托普诺</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a25b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着web应用变得越来越复杂，我们需要某种方式将代码分成易于管理的块。为此，我们可以使用Web组件来创建可重用的UI块，以便在多个地方使用。</p><p id="1cff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究如何在Web组件中使用模板和插槽。</p><h1 id="17a4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">模板</h1><p id="9476" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">template</code>元素来添加没有在DOM中呈现的内容。这使我们可以通过编写以下HTML将它们合并到任何其他元素中:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8891" class="mt lf it mk b gy mu mv l mw mx">&lt;template&gt;<br/>  &lt;p&gt;Foo&lt;/p&gt;<br/>&lt;/template&gt;</span></pre><p id="2896" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以编写以下JavaScript来将其合并到页面中:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="bd9c" class="mt lf it mk b gy mu mv l mw mx">const template = document.querySelector('template');<br/>const templateContent = template.content;<br/>document.body.appendChild(templateContent);</span></pre><p id="d36e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们加载页面时，我们应该在页面上看到“Foo”。当我们检查‘Foo’的代码时，应该会显示出<code class="fe mh mi mj mk b">p</code>元素。这证实了标记不受<code class="fe mh mi mj mk b">template</code>元素的影响。</p><h1 id="0a94" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在Web组件中使用模板</h1><p id="69de" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们也可以在Web组件中使用它们。为了使用它，我们可以在Web组件的类中获取<code class="fe mh mi mj mk b">template</code>元素，就像我们在Web组件外部所做的一样。</p><p id="dcb9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3204" class="mt lf it mk b gy mu mv l mw mx">customElements.define('foo-paragraph',<br/>  class extends HTMLElement {<br/>    constructor() {<br/>      super();<br/>      let template = document.querySelector('template');<br/>      let templateContent = template.content;<br/>      const shadowRoot = this.attachShadow({<br/>          mode: 'open'<br/>        })<br/>        .appendChild(templateContent.cloneNode(true));<br/>    }<br/>  })</span></pre><p id="8d52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们获得了<code class="fe mh mi mj mk b">template</code>元素和对<code class="fe mh mi mj mk b">templateContent</code>的调用<code class="fe mh mi mj mk b">cloneNode</code>，该调用将<code class="fe mh mi mj mk b">template.content</code>作为获取模板内容的值。</p><p id="b694" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们调用<code class="fe mh mi mj mk b">cloneNode</code>来克隆<code class="fe mh mi mj mk b">template.content</code>节点的子节点以及节点本身。这由<code class="fe mh mi mj mk b">cloneNode</code>函数调用的<code class="fe mh mi mj mk b">true</code>参数指示。</p><p id="05be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们用<code class="fe mh mi mj mk b">attachShadow</code>和<code class="fe mh mi mj mk b">appendChild</code>方法将克隆的<code class="fe mh mi mj mk b">templateContent</code>附加到Web组件的影子根中。</p><p id="dd81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以在<code class="fe mh mi mj mk b">template</code>元素中包含样式，这样我们就可以像处理HTML标记一样重用它。</p><p id="5356" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以将<code class="fe mh mi mj mk b">template</code>元素改为:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5a1e" class="mt lf it mk b gy mu mv l mw mx">&lt;template&gt;<br/>  &lt;style&gt;<br/>    p {<br/>      color: white;<br/>      background-color: gray;<br/>      padding: 5px;<br/>    }</span><span id="50f7" class="mt lf it mk b gy my mv l mw mx">  &lt;/style&gt;<br/>  &lt;p&gt;Foo&lt;/p&gt;<br/>&lt;/template&gt;</span></pre><p id="629a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们应该看到:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/5f536a8e58fe8bc83c6b80db4c165c12.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/format:webp/1*_w5KLBFe3qJJyQvCNx7N5A.png"/></div></figure><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/951182b52a3392261f81d34797e3915b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qdkn1O56wOOlZqOr"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@zoeeee_?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">zo Reeve</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="de28" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">时间</h1><p id="7952" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了使我们的模板更加灵活，我们可以添加插槽来显示我们想要的内容，而不是静态内容。使用插槽，我们可以在Web组件的开始和结束标记之间传递内容。</p><p id="176d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它的支持比模板更有限。插槽可以用于Chrome 53或更高版本，Opera从版本40开始，Firefox从版本59开始，Edge不支持。</p><p id="6372" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以通过编写以下内容来添加一些插槽:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d8c2" class="mt lf it mk b gy mu mv l mw mx">&lt;template&gt;<br/>  &lt;slot name="foo"&gt;Default text for foo&lt;/slot&gt;<br/>  &lt;slot name="bar"&gt;Default text for bar&lt;/slot&gt;<br/>  &lt;slot name="baz"&gt;Default text for baz&lt;/slot&gt;<br/>&lt;/template&gt;</span></pre><p id="0643" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后假设我们有和以前一样的代码来定义JavaScript中的<code class="fe mh mi mj mk b">foo-paragraph</code>元素，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0906" class="mt lf it mk b gy mu mv l mw mx">&lt;foo-paragraph&gt;<br/>  &lt;p slot='foo'&gt;foo&lt;/p&gt;<br/>  &lt;p slot='bar'&gt;bar&lt;/p&gt;<br/>  &lt;p slot='baz'&gt;baz&lt;/p&gt;<br/>&lt;/foo-paragraph&gt;</span></pre><p id="a11d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出将是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8364" class="mt lf it mk b gy mu mv l mw mx">foo</span><span id="1e88" class="mt lf it mk b gy my mv l mw mx">bar</span><span id="0efd" class="mt lf it mk b gy my mv l mw mx">baz</span></pre><p id="679e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们省略了<code class="fe mh mi mj mk b">foo-paragraph</code>标签中的元素，我们将得到默认文本:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="bc82" class="mt lf it mk b gy mu mv l mw mx">Default text for foo Default text for bar Default text for baz</span></pre><p id="9c00" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们用<code class="fe mh mi mj mk b">template</code>元素中的<code class="fe mh mi mj mk b">name</code>属性来命名插槽，然后在我们的Web组件中，我们使用<code class="fe mh mi mj mk b">slot</code>属性来填充我们定义的插槽。</p><p id="adc2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以像设计其他<code class="fe mh mi mj mk b">template</code>元素一样设计它们。为了对它们进行样式化，我们通过使用选择器来选择要被样式化的元素，这些选择器用于我们将要填充到槽中的元素。</p><p id="deca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1ef6" class="mt lf it mk b gy mu mv l mw mx">&lt;template&gt;<br/>  &lt;style&gt;<br/>    ::slotted(p) {<br/>      padding: 5px;<br/>      background-color: black;<br/>      color: white;<br/>    }</span><span id="b177" class="mt lf it mk b gy my mv l mw mx">    ::slotted(p[slot='foo']) {<br/>      background-color: gray;<br/>    }<br/>  &lt;/style&gt;<br/>  &lt;slot name="foo"&gt;Default text for foo&lt;/slot&gt;<br/>  &lt;slot name="bar"&gt;Default text for bar&lt;/slot&gt;<br/>  &lt;slot name="baz"&gt;Default text for baz&lt;/slot&gt;<br/>&lt;/template&gt;</span><span id="2470" class="mt lf it mk b gy my mv l mw mx">&lt;foo-paragraph&gt;<br/>  &lt;p slot='foo'&gt;foo&lt;/p&gt;<br/>  &lt;p slot='bar'&gt;bar&lt;/p&gt;<br/>  &lt;p slot='baz'&gt;baz&lt;/p&gt;<br/>&lt;/foo-paragraph&gt;</span></pre><p id="36f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">::slotted</code>伪元素表示已经放入HTML模板中的元素。因此，我们可以使用它来选择我们想要样式的槽元素。</p><p id="9ff6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mh mi mj mk b">::slotted</code>的参数中，我们可以传入我们想要样式化的元素，如果它们被传入槽中的话。这意味着只有传入的<code class="fe mh mi mj mk b">p</code>元素才会应用样式。</p><p id="b86a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">::slotted(p[slot=’foo’])</code>意味着带有<code class="fe mh mi mj mk b">slot</code>属性值<code class="fe mh mi mj mk b">foo</code>的<code class="fe mh mi mj mk b">p</code>元素将被应用样式。</p><p id="ff5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，在应用样式后，我们应该得到以下内容:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/6a060db61001d11f0e1e363b028d1398.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*feXQDce-c59piaWkJGBGrQ.png"/></div></figure><p id="3d0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">模板和插槽让我们创建可重用的组件，我们可以在Web组件中使用。元素在渲染过程中不会出现，所以我们可以把它们放在任何地方，并在任何Web组件中随意使用。</p><p id="2a50" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了插槽，我们在创建Web组件时有了更多的灵活性，因为我们可以创建可以插入其他元素来填充插槽的组件。</p><p id="e7b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在任何情况下，我们都可以随心所欲地对元素应用样式。我们有<code class="fe mh mi mj mk b">::slotted</code>伪元素来将样式应用于插槽中的特定元素。</p></div></div>    
</body>
</html>