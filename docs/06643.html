<html>
<head>
<title>map: Learning JavaScript’s Array Methods by Building Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">map:通过构建JavaScript的数组方法来学习它们</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/map-learning-javascripts-array-methods-by-building-them-32b4facb78c5?source=collection_archive---------12-----------------------#2020-12-15">https://levelup.gitconnected.com/map-learning-javascripts-array-methods-by-building-them-32b4facb78c5?source=collection_archive---------12-----------------------#2020-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c7cee700cac8848e1fecd8ae48153af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xI-A6d-09n73M6nWSx8xfg.png"/></div></div></figure><p id="3324" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">探索JavaScript数组方法系列文章的第二篇，包括如何构建自己的数组方法。本文涵盖了<code class="fe kw kx ky kz b">map</code>方法。</p><h1 id="5d99" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">介绍</h1><p id="1146" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">JavaScript的<code class="fe kw kx ky kz b">map</code>方法是处理数组的强大方法，也是最常用的方法之一。您可能会在React代码库中看到它将API中的一组数据转换为组件数组。它在复杂性上也比<code class="fe kw kx ky kz b">forEach</code>高了一小步，之前我们在<a class="ae md" href="https://zkf.io/js-array-methods-foreach/" rel="noopener ugc nofollow" target="_blank">讨论过。</a></p><p id="8817" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文是我解释JavaScript内置数组方法的系列文章的一部分。本文主要关注<code class="fe kw kx ky kz b">map</code>方法，它用于在现有数组的基础上创建一个新数组。我将描述它是如何工作的以及何时使用它，但是文章的大部分将集中在为你自己实现<code class="fe kw kx ky kz b">map</code>上。</p><h1 id="2357" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">它是如何工作的</h1><p id="598b" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated"><code class="fe kw kx ky kz b">map</code>方法获取一个现有的数组和一个函数，并对数组的每一项执行该函数。这就像<code class="fe kw kx ky kz b">forEach</code>方法一样，但是<code class="fe kw kx ky kz b">forEach</code>和<code class="fe kw kx ky kz b">map</code>之间有一个关键的区别:<code class="fe kw kx ky kz b">map</code>方法基于执行传入函数的结果返回一个新数组。对于传递给<code class="fe kw kx ky kz b">map</code>的函数有一个微妙的要求:它必须返回一些东西，这样<code class="fe kw kx ky kz b">map</code>就可以将它添加到它为我们创建的数组中。</p><p id="f41a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">描述<code class="fe kw kx ky kz b">map</code>的一种技术方式是:它基于一个函数创建一个<em class="me">派生</em>数组；</p><pre class="mf mg mh mi gt mj kz mk ml aw mm bi"><span id="1c7a" class="mn lb iq kz b gy mo mp l mq mr">const numbers = [1, 2, 3, 4, 5]</span><span id="d40f" class="mn lb iq kz b gy ms mp l mq mr">function doubleNumber(number) {<br/>	return number * 2<br/>}</span><span id="e4c3" class="mn lb iq kz b gy ms mp l mq mr">const doubles = numbers.map(doubleNumber)<br/>console.log(doubles) // [2, 4, 6, 8, 10]</span></pre><p id="28b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从一个名为<code class="fe kw kx ky kz b">numbers</code>的数字数组和一个名为<code class="fe kw kx ky kz b">doubleNumber</code>的函数开始，该函数接受一个参数并返回其double值(乘以2的结果)。通过将<code class="fe kw kx ky kz b">doubleNumber</code>传递给<code class="fe kw kx ky kz b">map</code>，我们说，“对<code class="fe kw kx ky kz b">numbers</code>数组中的每一项调用该函数”，这将产生数组<code class="fe kw kx ky kz b">[2, 4, 6, 8, 10]</code>(或原始数组，<code class="fe kw kx ky kz b">numbers</code>包含值<code class="fe kw kx ky kz b">[1, 2, 3, 4, 5]</code>)。</p><p id="a8cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重要的是要记住每一个数组方法都可以用一个<code class="fe kw kx ky kz b">for</code>循环来实现，包括<code class="fe kw kx ky kz b">map</code>。</p><p id="61ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个初学者可能会用类似这样的东西来完成将数组中的每一项加倍的任务:</p><pre class="mf mg mh mi gt mj kz mk ml aw mm bi"><span id="b3f5" class="mn lb iq kz b gy mo mp l mq mr">const numbers = [1, 2, 3, 4, 5];<br/>const doubles = []</span><span id="098a" class="mn lb iq kz b gy ms mp l mq mr">for (let i = 0; i &lt; numbers.length; i++) {<br/>  let number = numbers[i]<br/>  let double = number * 2<br/>  doubles.push(double)<br/>}</span><span id="ae76" class="mn lb iq kz b gy ms mp l mq mr">console.log(doubles) // [2, 4, 6, 8, 10]</span></pre><p id="1332" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以通过将我们正在执行的实际“动作”转换成它自己的函数并带回我们的<code class="fe kw kx ky kz b">doubleNumber</code>函数来简化这一点:</p><pre class="mf mg mh mi gt mj kz mk ml aw mm bi"><span id="6717" class="mn lb iq kz b gy mo mp l mq mr">const numbers = [1, 2, 3, 4, 5];<br/>const doubles = []</span><span id="7406" class="mn lb iq kz b gy ms mp l mq mr">function doubleNumber(number) {<br/>  return number * 2<br/>}</span><span id="8092" class="mn lb iq kz b gy ms mp l mq mr">for (let i = 0; i &lt; numbers.length; i++) {<br/>  let number = numbers[i]<br/>  let double = doubleNumber(number)<br/>  doubles.push(double)<br/>}</span><span id="5bac" class="mn lb iq kz b gy ms mp l mq mr">console.log(doubles) // [2, 4, 6, 8, 10]</span></pre><p id="d8d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这实际上让我们非常接近自己的<code class="fe kw kx ky kz b">map</code>实现。</p><h1 id="4bdb" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">实现我们自己的</h1><p id="d3b6" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">我们前面说过<code class="fe kw kx ky kz b">map</code>用于创建一个<em class="me">派生</em>数组:</p><pre class="mf mg mh mi gt mj kz mk ml aw mm bi"><span id="1669" class="mn lb iq kz b gy mo mp l mq mr">const numbers = [1, 2, 3, 4, 5]</span><span id="0ac6" class="mn lb iq kz b gy ms mp l mq mr">function doubleNumber(number) {<br/>	return number * 2<br/>}</span><span id="4e04" class="mn lb iq kz b gy ms mp l mq mr">const doubles = numbers.map(doubleNumber)<br/>console.log(doubles) // [2, 4, 6, 8, 10]</span></pre><p id="49ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前面的代码片段从数组<code class="fe kw kx ky kz b">numbers</code>开始，使用<code class="fe kw kx ky kz b">map</code>和函数<code class="fe kw kx ky kz b">doubleNumbers</code>创建<code class="fe kw kx ky kz b">doubles</code>数组。</p><p id="ce4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基于我们在这里如何使用它，我们可以确定对<code class="fe kw kx ky kz b">map</code>方法的要求是:</p><ul class=""><li id="0907" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated">接受一个数组和一个函数的函数</li><li id="050f" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">对传入数组中的每一项调用传入函数</li><li id="e3fc" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">将函数调用的结果存储在一个新数组中</li><li id="1dc9" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">返回新数组</li></ul><p id="9426" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从第一个需求开始，我们可以创建一个名为<code class="fe kw kx ky kz b">map</code>的函数，它接受一个数组和一个函数作为参数:</p><pre class="mf mg mh mi gt mj kz mk ml aw mm bi"><span id="08ce" class="mn lb iq kz b gy mo mp l mq mr">function map(arr, fn) {<br/>  // more to come here<br/>}</span></pre><p id="e1dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们希望使用与上面基本相同的循环来遍历数组，这样我们就可以在下一步中对每一项调用传入的函数:</p><pre class="mf mg mh mi gt mj kz mk ml aw mm bi"><span id="97a3" class="mn lb iq kz b gy mo mp l mq mr">function map(arr, fn) {<br/>  for (let i = 0; i &lt; arr.length; i++) {<br/>	  // more to come here<br/>  }<br/>}</span></pre><p id="0c47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们将数组中的每一项传递给<code class="fe kw kx ky kz b">fn</code>:</p><pre class="mf mg mh mi gt mj kz mk ml aw mm bi"><span id="b654" class="mn lb iq kz b gy mo mp l mq mr">function map(arr, fn) {<br/>  for (let i = 0; i &lt; arr.length; i++) {<br/>	  let item = arr[i]<br/>	  let newItem = fn(item)<br/>  }<br/>}</span></pre><p id="32c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从函数中得到了新的值。根据需求，我们需要将它存储到一个数组中并返回该数组:</p><pre class="mf mg mh mi gt mj kz mk ml aw mm bi"><span id="bca7" class="mn lb iq kz b gy mo mp l mq mr">function map(arr, fn) {<br/>	const final = []</span><span id="88b6" class="mn lb iq kz b gy ms mp l mq mr">  for (let i = 0; i &lt; arr.length; i++) {<br/>	  let item = arr[i]<br/>	  let newItem = fn(item)</span><span id="1ee0" class="mn lb iq kz b gy ms mp l mq mr">	  final.push(newItem)<br/>  }</span><span id="fe22" class="mn lb iq kz b gy ms mp l mq mr">  return final<br/>}</span></pre><p id="1586" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是全部了！</p><p id="85a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用我们的<code class="fe kw kx ky kz b">map</code>函数将数组中的每一项加倍，现在看起来像这样:</p><pre class="mf mg mh mi gt mj kz mk ml aw mm bi"><span id="752d" class="mn lb iq kz b gy mo mp l mq mr">const numbers = [1, 2, 3, 4, 5, 6];</span><span id="d617" class="mn lb iq kz b gy ms mp l mq mr">const doubles = map(numbers, doubleNumber)<br/>console.log(doubles) // [2, 4, 6, 8, 10, 12]</span></pre><p id="7893" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就像<code class="fe kw kx ky kz b">forEach</code>一样，这比写出完整的<code class="fe kw kx ky kz b">for</code>循环更容易阅读和理解。</p><h1 id="2870" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><code class="fe kw kx ky kz b">map</code>在行动</h1><p id="fe9a" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">现在我们已经为自己实现了<code class="fe kw kx ky kz b">map</code>,我们可以进一步探索它的用途。我通常在两种情况下使用<code class="fe kw kx ky kz b">map</code>:<em class="me">转换</em>数据数组或者<em class="me">从现有数组中提取</em>数据。</p><p id="3219" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将使用以下数据向您展示两者的示例:</p><pre class="mf mg mh mi gt mj kz mk ml aw mm bi"><span id="f33d" class="mn lb iq kz b gy mo mp l mq mr">const profiles = [<br/>  {<br/>    name: "Mercedes",<br/>    profession: "Software Engineer"<br/>  },<br/>  {<br/>    name: "Antonio",<br/>    profession: "Front-end Developer"<br/>  },<br/>  {<br/>    name: "Ana",<br/>    profession: "Back-end Developer"<br/>  }<br/>]</span></pre><p id="f345" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个数组包含代表工程师的对象，其中每个工程师的配置文件包含他们的姓名和职业。</p><h1 id="5007" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">转换数据</h1><p id="f748" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">上面的<code class="fe kw kx ky kz b">doubles</code>例子是一个使用<code class="fe kw kx ky kz b">map</code>转换数据的简单例子。不过，我们的数据通常没那么简单。因此，一个更复杂的例子是利用我们的<code class="fe kw kx ky kz b">profiles</code>数组，为每个工程师创建一个新的描述数组。</p><pre class="mf mg mh mi gt mj kz mk ml aw mm bi"><span id="e311" class="mn lb iq kz b gy mo mp l mq mr">const descriptions = map(<br/>  profiles,<br/>  function createDescription(profile) {<br/>    let {name, profession} = profile<br/>    return `${name} is a ${profession}`<br/>  }<br/>)</span><span id="dc10" class="mn lb iq kz b gy ms mp l mq mr">console.log(descriptions) // [ 'Mercedes is a Software Engineer', 'Antonio is a Front-end Developer', 'Ana is a Back-end Developer' ]</span></pre><p id="806f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的代码片段中，我们用<code class="fe kw kx ky kz b">createDescription</code>函数获取配置文件和<code class="fe kw kx ky kz b">map</code>的数组，该函数获取一个配置文件并返回一个字符串<code class="fe kw kx ky kz b">"&lt;name&gt; is a &lt;profession&gt;"</code>。现在，我们有了一个配置文件数组和一个包含每个工程师描述的单独数组。</p><p id="ff11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以稍微修改一下，给我们一个新的概要数组，每个概要都包含描述。这通常更有帮助:</p><pre class="mf mg mh mi gt mj kz mk ml aw mm bi"><span id="1f68" class="mn lb iq kz b gy mo mp l mq mr">map(<br/>  profiles,<br/>  function createDescription(profile) {<br/>    let {name, profession} = profile<br/>    return {<br/>      ...profile,<br/>      description: `${name} is a ${profession}`<br/>    }<br/>  }<br/>)</span></pre><p id="e5d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这段代码将生成如下所示的数组:</p><pre class="mf mg mh mi gt mj kz mk ml aw mm bi"><span id="5bf3" class="mn lb iq kz b gy mo mp l mq mr">[<br/>  {<br/>    name: 'Mercedes',<br/>    profession: 'Software Engineer',<br/>    description: 'Mercedes is a Software Engineer'<br/>  },<br/>  {<br/>    name: 'Antonio',<br/>    profession: 'Front-end Developer',<br/>    description: 'Antonio is a Front-end Developer'<br/>  },<br/>  {<br/>    name: 'Ana',<br/>    profession: 'Back-end Developer',<br/>    description: 'Ana is a Back-end Developer'<br/>  }<br/>]</span></pre><h1 id="3117" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">提取数据</h1><p id="7b92" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">使用<code class="fe kw kx ky kz b">map</code>的另一种常见方式是将数据提取到一个单独的数组中。例如，我们可以用我们的<code class="fe kw kx ky kz b">profiles</code>数组创建一个只有名字的数组:</p><pre class="mf mg mh mi gt mj kz mk ml aw mm bi"><span id="8e08" class="mn lb iq kz b gy mo mp l mq mr">const names = map(profiles, function getProfileNames(profile) {<br/>  return profile.name<br/>})</span><span id="f53d" class="mn lb iq kz b gy ms mp l mq mr">console.log(names)</span></pre><p id="33f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当一个API给了你很多你不需要的数据时，这是很常见的。当我使用API的图表库和数据时，我发现自己经常做这样的事情。来自API的数据以API模式确定的格式返回，我需要提取一些数据，并将其转换成图表库可以使用的格式。</p><h1 id="315c" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="0e23" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">我对<code class="fe kw kx ky kz b">map</code>的讨论到此结束。如果你没有看过<code class="fe kw kx ky kz b">forEach</code>的类似讨论，那么你可以在这里<a class="ae md" href="https://zkf.io/js-array-methods-foreach/" rel="noopener ugc nofollow" target="_blank">找到</a>。我将详细介绍并解释和实现每个内置数组方法，这将帮助您理解它们是如何工作的，以及何时和如何使用它们。要跟进，注册我的<a class="ae md" href="https://hawthorne.substack.com" rel="noopener ugc nofollow" target="_blank">简讯</a>并在<a class="ae md" href="https://twitter.com/ZFleischmann" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。</p></div></div>    
</body>
</html>