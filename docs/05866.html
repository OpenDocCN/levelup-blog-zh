<html>
<head>
<title>Functional Dynamic Programming With Haskell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Haskell实现函数式动态编程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/functional-dynamic-programming-with-haskell-92e68efe808?source=collection_archive---------8-----------------------#2020-10-07">https://levelup.gitconnected.com/functional-dynamic-programming-with-haskell-92e68efe808?source=collection_archive---------8-----------------------#2020-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0725" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Haskell在纯FP中实现动态编程算法的特性。</p><p id="b7ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文分为三个部分:</p><ul class=""><li id="2e16" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><strong class="jp ir"> <em class="ku">不涵盖</em> </strong> <em class="ku"> : </em>关于动态编程(DP)或者函数式编程(FP)或者Haskell或者Monads的基础知识。</li><li id="f698" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><strong class="jp ir"> <em class="ku">涵盖了</em></strong><em class="ku">:</em>Haskell中使用内存化(STArray)和有状态计算(ST Monad)解决DP问题的FP机制。</li></ul><p id="8314" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文假设读者对数组或向量等基本数据结构以及时间和空间复杂性有基本的了解。</p><p id="d185" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快速回顾一下。动态编程是解决满足两个特征的问题的范例:</p><ul class=""><li id="4908" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><strong class="jp ir"> <em class="ku">最优子结构</em> </strong> <em class="ku">:允许将问题分成小部分，并使用递归方法求解更小的部分。</em></li><li id="3af2" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><strong class="jp ir"> <em class="ku">重叠子问题</em> </strong> <em class="ku">:允许存储可重复使用的较小子问题的结果，以避免重复计算。</em></li></ul><p id="e9d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用一个这样的问题(计算错位排列)来探索如何用纯函数的方式解决它。此处给出了该问题的非常详细的解释<a class="ae la" href="https://en.wikipedia.org/wiki/Derangement" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="6adf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">举个简单的例子，如果我们有三个字母ABC。可能的错位只有BCA和CAB。</p><p id="b09c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是ACB (A在原始位置)、CBA (B在原始位置)和BAC (C在原始位置)不是有效的错位排列，因为根据问题定义，任何字母都不应该在原始位置。</p><p id="1d4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">f(x)的计数，其中x = 1，2，3，…，n</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="59c2" class="lk ll iq lg b gy lm ln l lo lp">f(1) = 0<br/>f(2) = 1<br/>f(3) = 2<br/>f(n) = (n-1) * ( f(n-1) + f(n-2) )</span></pre><p id="ae11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">f(n)暗示了该解决方案的动态编程性质，并将成为我们递归和自底向上方法公式的基础。</p><p id="3bdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从程序上讲，这可以通过4种不同的方式来解决。</p><ol class=""><li id="d7d7" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk lq kr ks kt bi translated"><strong class="jp ir">简单递归或者幼稚。</strong></li></ol><figure class="lb lc ld le gt lr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="e754" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个版本很简单，但是它产生了一个计算树，其中它对相同的“n”重复求值多次。</p><figure class="lb lc ld le gt lr gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/8be737eb117cc7f4722cffd459c75c56.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*O6jG7KYz_Jk2dy_zANCStA.png"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">n = 5的递归树</figcaption></figure><p id="3589" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从图中可以明显看出，仅仅对于f(5)，我们就对f(3)重复计算2次，f(2)重复计算3次，f(1)重复计算2次。</p><p id="8677" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即使增量很小，空间和时间也会变得更糟。</p><p id="10b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">N的运行时间和空间使用下降</strong></p><figure class="lb lc ld le gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mb"><img src="../Images/74007c26794c14eedd268ece4cfc9a0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SBmf4VEvO7RJAlVEE0rQAw.png"/></div></div></figure><figure class="lb lc ld le gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mg"><img src="../Images/3ea2347960d66e8decfcf7766c1b8dde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FLa2yzOXL2v1Fl5SyFSx-A.png"/></div></div></figure><p id="f566" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上表显示，随着n的增加，简单递归版本的空间消耗非常糟糕。</p><p id="8ccd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与任何有效的DP候选一样，可以使用自顶向下或自底向上的方法使用记忆来改进它。</p><p id="a756" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2。自顶向下递归</strong> —使用数组或向量或任何此类数据结构来存储中间结果并重用它。(我们将使用Haskell提供的STArray)</p><p id="b0aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3。自下而上</strong> —使用一个数组并存储从1到n的计算结果，结果预定义为一个或两个基本情况(本例中arr(1) = 0，arr(2) = 1)(同样，我们将使用STArray)</p><p id="ea60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">方法2和3在<a class="ae la" href="https://medium.com/@SA_19/functional-dynamic-programming-with-haskell-top-down-and-bottom-up-7ccade222337?source=your_stories_page" rel="noopener"> <em class="ku">这里</em> </a> <em class="ku">有详细介绍。</em></p><p id="2b52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 4。自下而上的空间优化</strong> —仅使用3个“变量”而不是数组进行自下而上的计算。(我们将使用StateT Monad和runST)</p><p id="5eb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的 涵盖了方法4的<a class="ae la" href="https://medium.com/@SA_19/functional-dynamic-programming-with-haskell-bottom-up-space-optimized-ef7b5f73a849" rel="noopener"> <em class="ku">。</em></a></p><p id="ea23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">安全可变性和单子</strong></p><p id="dc63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在纯FP中，我们使用单子，单子可以</p><ul class=""><li id="9331" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">是“上下文”中的一个值，可以用一致的方式操作</li><li id="c19c" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">确保安全，在纯函数式编程中提供引用透明性</li><li id="03c7" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">用于封装不安全的程序行为，如IO/Async/Randomness等。</li></ul><p id="c048" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来:<a class="ae la" href="https://medium.com/@SA_19/functional-dynamic-programming-with-haskell-top-down-and-bottom-up-7ccade222337" rel="noopener">Haskell函数式动态编程:自顶向下和自底向上</a></p></div></div>    
</body>
</html>