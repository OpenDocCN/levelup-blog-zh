<html>
<head>
<title>C# Design Patterns — Factory Method</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#设计模式—工厂方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/c-design-patterns-factory-method-23f53888b79b?source=collection_archive---------14-----------------------#2022-01-12">https://levelup.gitconnected.com/c-design-patterns-factory-method-23f53888b79b?source=collection_archive---------14-----------------------#2022-01-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7eaf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">第1部分—工厂方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dac29dc99d1a3c2a9dfeed13875261ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*urUptEH3OUVjGgkMy-rXnw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">帕特里克·亨德利在<a class="ae ky" href="https://unsplash.com/s/photos/guide?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="a195" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工厂模式是最常用的设计模式之一。它是一种创造性的模式，使用抽象类或接口来定义对象的创建，但让子类决定实例化哪个类。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="bb1f" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">工厂设计模式的优势</h2><ul class=""><li id="003e" class="mv mw it lb b lc mx lf my li mz lm na lq nb lu nc nd ne nf bi translated">允许子类选择要创建的对象类型</li><li id="d83a" class="mv mw it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">通过消除对绑定特定于应用程序的类的需求来促进<em class="nl">松耦合</em>。然后，代码将与接口或抽象类进行交互，并与实现该接口或扩展该抽象类的任何类一起工作。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="275c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比方说，你买了一栋新房子，你想更换房子的门。现在，有更大的门和更小的门，但我们可以说所有的门都有一个尺寸，这将是我们的界面，根据我们给商店工作人员的尺寸，他会向我们展示适合我们需要的或大或小的门。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="760c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nl">让我们用一些代码再举一个例子:</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/0c20717fbeb1699438848120c54c2197.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3zhN0FqV2FRvhJu9hHeTMw.png"/></div></div></figure><p id="5835" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图向我们展示了如何构建我们的工厂方法。首先，我们创建一个简单的汽车抽象类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="3907" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">枚举为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="541c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们将需要几辆不同的车，我们将创建3个类，一个为轿车，另一个为轿车，第三个为掀背车，为了简单起见，几乎是一样的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="0846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以创建我们的CarFactory方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="3d6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样，简短而甜蜜。现在，我们可以调用我们的汽车工厂，根据我们传递的车身样式，我们将得到不同类型的汽车作为回报。</p></div></div>    
</body>
</html>