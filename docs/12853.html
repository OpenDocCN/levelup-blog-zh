<html>
<head>
<title>Compare REST with GraphQL For Performance Testing Using StepZen and k6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用StepZen和k6比较REST和GraphQL的性能测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/compare-rest-with-graphql-for-performance-testing-using-stepzen-and-k6-eb71ffb4c949?source=collection_archive---------14-----------------------#2022-07-14">https://levelup.gitconnected.com/compare-rest-with-graphql-for-performance-testing-using-stepzen-and-k6-eb71ffb4c949?source=collection_archive---------14-----------------------#2022-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4570d5d9b2b4b528fcc70843a2c56e34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EhsgKIdHx-iJA6Cf.png"/></div></div></figure><p id="bcc4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于许多公司来说，性能是使用GraphQL的主要原因。但这是一个有效的论点吗？开发人员经常将GraphQL与REST APIs进行比较，并将N+1请求(或过量提取)视为使用GraphQL的一个重要原因。让我们来测试一下，看看GraphQL APIs是否真的能超越现有的REST APIs。为此，我们将采用GraphQL化的REST API，测试GraphQL的性能，并将其与REST方法进行比较。为此，我们将使用流行的性能测试工具<a class="ae kw" href="https://k6.io/" rel="noopener ugc nofollow" target="_blank"> k6 </a>。</p><h2 id="0037" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">探索GraphQL API</h2><p id="6273" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">在探索GraphQL API之前，让我们了解更多关于这项技术的知识。GraphQL是一种API的查询语言，由脸书(现为Meta)于2012年设计，用于处理低带宽网络上的API请求。内部使用后，GraphQL于2015年开源。自2019年以来，其商标一直归GraphQL基金会所有，确保了其在Meta之外的未来。GraphQL在开源社区和企业中都被广泛采用。</p><p id="ded3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GraphQL的查询语言依赖于一个模式，该模式包含可以用来请求或变更数据的所有操作以及这些操作的相应响应类型。返回虚构文章数据的GraphQL API的模式如下所示:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="cbc1" class="kx ky iq ma b gy me mf l mg mh">type Post {<br/>  id: ID!<br/>  userId: ID!<br/>  title: String<br/>  Body: String<br/>}<br/><br/>type Query {<br/>  posts: [Post]<br/>  post(id: ID!): Post<br/>}</span></pre><p id="c40c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个模式中定义了两个类型为<code class="fe mi mj mk ma b">Query</code>的操作，响应类型为<code class="fe mi mj mk ma b">Post</code>。这意味着您可以查询所有帖子的列表，或者指定标识符<code class="fe mi mj mk ma b">id</code>来获取特定的帖子。要获得一个帖子，您可以向这个GraphQL API发送一个请求，并附加一个包含获取消息的查询的主体:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="55c7" class="kx ky iq ma b gy me mf l mg mh">query {<br/>  getPost(id: 1") {<br/>    id<br/>    title<br/>    body<br/>  }<br/>}</span></pre><p id="4257" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GraphQL API的响应将遵循类型<code class="fe mi mj mk ma b">Post</code>的形状，并包括查询中定义的所有字段。在上面的查询中，您可以看到我们没有包含字段<code class="fe mi mj mk ma b">userId</code>，因此它不会包含在该查询的响应中。根据您赋予参数<code class="fe mi mj mk ma b">id</code>的值，消息将以JSON格式返回。如果对查询进行了更改，例如，添加了更多要检索的字段，这些字段将被追加到结果中。</p><blockquote class="ml mm mn"><p id="c3a9" class="jy jz mo ka b kb kc kd ke kf kg kh ki mp kk kl km mq ko kp kq mr ks kt ku kv ij bi translated">在<code class="fe mi mj mk ma b">Query</code>之后，操作也可以是<code class="fe mi mj mk ma b">Mutation</code>(用于突变数据)或<code class="fe mi mj mk ma b">Subscription</code>(用于实时或流数据)。</p></blockquote><p id="7ccf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了测试这个查询，您当然可以使用<a class="ae kw" href="https://stepzen.com/getting-started" rel="noopener ugc nofollow" target="_blank"> StepZen </a>通过CLI将REST API转换为GraphQL API，就像我为<a class="ae kw" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank"> JSONPlaceholder </a>所做的那样。免费的REST API嘲笑了帖子、用户和评论的数据；您现在可以使用GraphQL查询它了！</p><p id="9ae6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大多数GraphQL API，就像这个一样，都带有graph QL，这是一个与graph QL API交互的开源IDE。已经为您添加了一个示例查询，但是您可以进行任何更改。GraphiQL界面如下所示:</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="ab gu cl ms"><img src="../Images/5fe2b452a9d924266d529f2980fa2dc3.png" data-original-src="https://miro.medium.com/v2/format:webp/0*2LrhpHk-pe3R3WVM.png"/></div></figure><p id="3f77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在这个<a class="ae kw" href="https://public3b47822a17c9dda6.stepzen.net/api/with-jsonplaceholder/__graphql?query=query%20GetPost%20%7B%0A%20%20getPost%28id%3A%20%221%22%29%20%7B%0A%20%20%20%20id%0A%20%20%20%20title%0A%20%20%20%20body%0A%20%20%7D%0A%7D" rel="noopener ugc nofollow" target="_blank">部署的演示端点</a>上尝试这个查询。您发送给GraphQL API的查询位于屏幕的左侧，而右侧显示的是响应。该查询与我们之前描述的相同，但是这次该查询被命名为<code class="fe mi mj mk ma b">GetPost</code>。命名查询是一种推荐的模式，可以帮助GraphQL APIs进行缓存等操作。此外，响应的格式与查询的格式相同。</p><p id="a979" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是您并不局限于使用GraphQL之类的东西来与GraphQL API进行交互。GraphQL是一种与传输无关的查询语言，但是大多数实现都使用基于HTTP的GraphQL。这意味着您可以使用HTTP(S)向GraphQL API发送请求，类似于REST APIs。只有对GraphQL的请求的格式不同于对REST APIs的请求，因为您只使用HTTP-method POST，无论是在检索数据还是改变数据时，并且总是需要POST主体。</p><p id="d137" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您正在使用JavaScript发送HTTP请求，并且想要向GraphQL API发送请求，这将转化为以下内容。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="a6cc" class="kx ky iq ma b gy me mf l mg mh">fetch('https://public3b47822a17c9dda6.stepzen.net/api/with-jsonplaceholder/__graphql', {<br/>  method: 'POST',<br/>  mode: 'cors', // no-cors, *cors, same-origin<br/>  headers: {<br/>    'Content-Type': 'application/json',<br/>  },<br/>  body: JSON.stringify({<br/>    query: `<br/>      query GetPost {<br/>        getPost(id: "1") {<br/>          id<br/>          title<br/>          body<br/>        }<br/>      }<br/>    `,<br/>  }),<br/>});</span></pre><blockquote class="ml mm mn"><p id="1f77" class="jy jz mo ka b kb kc kd ke kf kg kh ki mp kk kl km mq ko kp kq mr ks kt ku kv ij bi translated">注意，内容类型被设置为<code class="fe mi mj mk ma b">application/json</code>，因为GraphQL依赖于JSON。发送和接收请求时都是如此。</p></blockquote><p id="70c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在研究了这个GraphQL API之后，让我们设置k6，以便在下一节中使用它来测试GraphQL。</p><h2 id="ccf8" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">为GraphQL设置k6</h2><p id="71bd" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">我们在上一节中探索的从REST API获取帖子的GraphQL API是使用GraphQL-over-HTTP实现的；您可以像其他REST API一样向它发送请求。获取数据的JavaScript代码片段已经展示了如何去做。这个代码片段需要稍微修改一下，以便与k6:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="4a3f" class="kx ky iq ma b gy me mf l mg mh">import http from 'k6/http';<br/><br/>const query = `<br/>  query GetPost {<br/>    getPost(id: "1") {<br/>      id<br/>      title<br/>      body<br/>    }<br/>  }<br/>`;<br/><br/>const headers = {<br/>  'Content-Type': 'application/json',<br/>};<br/><br/>export default function () {<br/>  http.post(<br/>    'https://public3b47822a17c9dda6.stepzen.net/api/with-jsonplaceholder/__graphql',<br/>    JSON.stringify({ query }),<br/>    { headers }<br/>  );<br/>}</span></pre><p id="fe15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个k6脚本现在可以使用查询来测试GraphQL API的性能。但是在每个请求上查询相同的post并不能帮助我们测试GraphQL API的性能。因此，我们可以在GraphQL查询中使用动态变量，并向查询传递一个0到100之间的随机数(REST API中的帖子数)。在此之前，我们需要向查询添加动态参数来获取文章数据。具有动态值<code class="fe mi mj mk ma b">id</code>的相同查询将如下所示:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="bb97" class="kx ky iq ma b gy me mf l mg mh">query GetPost($id: ID!) {<br/>  getPost(id: $id) {<br/>    id<br/>    title<br/>    body<br/>  }<br/>}</span></pre><p id="7046" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当发送请求时，您需要在GraphQL查询旁边附加一个JSON对象，其中包含一个值为<code class="fe mi mj mk ma b">id</code>。如果您访问<a class="ae kw" href="https://public3b47822a17c9dda6.stepzen.net/api/with-jsonplaceholder/__graphql?query=query%20GetPost%28%24id%3A%20ID%21%29%20%7B%0A%20%20getPost%28id%3A%20%24id%29%20%7B%0A%20%20%20%20id%0A%20%20%20%20title%0A%20%20%20%20body%0A%20%20%7D%0A%7D&amp;variables=%7B%0A%20%20%22id%22%3A%201%0A%7D" rel="noopener ugc nofollow" target="_blank">图形界面</a>，您可以使用“查询参数”选项卡:</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="ab gu cl ms"><img src="../Images/6f857a71f67e04dee6ad2a07596c64d5.png" data-original-src="https://miro.medium.com/v2/format:webp/0*JLOSA0ClaPBxbcEm.png"/></div></figure><p id="ebcc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用查询变量的动态值测试GraphQL API的k6脚本的更新版本如下所示。如前所述，我们可以传递一个0到100之间的随机值，因为这是REST API中以图表形式显示的帖子数量:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="d2ff" class="kx ky iq ma b gy me mf l mg mh">import http from 'k6/http';<br/><br/>const query = `<br/>  query GetPost($id: ID!) {<br/>    getPost(id: $id) {<br/>      id<br/>      title<br/>      body<br/>    }<br/>  }<br/>`;<br/><br/>const headers = {<br/>  'Content-Type': 'application/json',<br/>};<br/><br/>export default function () {<br/>  http.post(<br/>    'https://public3b47822a17c9dda6.stepzen.net/api/with-jsonplaceholder/__graphql',<br/>    JSON.stringify({<br/>      query,<br/>      variables: { id: Math.floor(Math.random() * 101) },<br/>    }),<br/>    { headers }<br/>  );<br/>}</span></pre><p id="8896" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经设置了第一个k6脚本，我们可以在下一节使用k6在GraphQL API上运行性能测试。</p><h2 id="dcf9" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">使用k6测试GraphQL性能</h2><p id="35e1" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">用k6测试GraphQL API的性能与测试REST API非常相似。使用我们在上一节中设置的脚本，我们不仅可以测试GraphQL API的性能，还可以测试在GraphQL查询中包含或排除字段是否会影响性能。在性能测试的结果中，我们将比较接收到的数据大小和迭代次数，但不比较响应时间。REST和GraphQL之间的响应时间更难测试，因为API之间的缓存机制可能非常不同。运行这些测试只需要你在本地机器上下载并安装k6 <a class="ae kw" href="https://k6.io/docs/getting-started/installation/" rel="noopener ugc nofollow" target="_blank">和</a>。</p><p id="48b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要运行第一个测试，您需要将脚本保存在一个名为<code class="fe mi mj mk ma b">single.js</code>的文件中，这样您就可以使用:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="cbc6" class="kx ky iq ma b gy me mf l mg mh">k6 run --vus 10 --duration 30s single.js</span></pre><p id="20f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个命令将使用10个vu(虚拟用户)运行K6 30秒。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="3b98" class="kx ky iq ma b gy me mf l mg mh">/\      |‾‾| /‾‾/   /‾‾/   <br/>     /\  /  \     |  |/  /   /  /    <br/>    /  \/    \    |     (   /   ‾‾\  <br/>   /          \   |  |\  \ |  (‾)  | <br/>  / __________ \  |__| \__\ \_____/ .io<br/><br/>  execution: local<br/>     script: single.js<br/>     output: -<br/><br/>  scenarios: (100.00%) 1 scenario, 10 max VUs, 1m0s max duration (incl. graceful stop):<br/>           * default: 10 looping VUs for 30s (gracefulStop: 30s)<br/><br/><br/>running (0m30.1s), 00/10 VUs, 1859 complete and 0 interrupted iterations<br/>default ✓ [======================================] 10 VUs  30s<br/><br/>     data_received..................: 932 kB 31 kB/s<br/>     data_sent......................: 459 kB 15 kB/s<br/>     http_req_blocked...............: avg=1.1ms    min=0s       med=1µs      max=206.02ms p(90)=1µs      p(95)=1µs     <br/>     http_req_connecting............: avg=159.26µs min=0s       med=0s       max=31.23ms  p(90)=0s       p(95)=0s      <br/>     http_req_duration..............: avg=160.46ms min=112.28ms med=139.78ms max=404.8ms  p(90)=258.63ms p(95)=326.02ms<br/>       { expected_response:true }...: avg=160.46ms min=112.28ms med=139.78ms max=404.8ms  p(90)=258.63ms p(95)=326.02ms<br/>     http_req_failed................: 0.00%  ✓ 0         ✗ 1859<br/>     http_req_receiving.............: avg=254.95µs min=26µs     med=142µs    max=89.41ms  p(90)=289µs    p(95)=528.69µs<br/>     http_req_sending...............: avg=172.3µs  min=33µs     med=138µs    max=8.94ms   p(90)=271.4µs  p(95)=364µs   <br/>     http_req_tls_handshaking.......: avg=924.91µs min=0s       med=0s       max=173.97ms p(90)=0s       p(95)=0s      <br/>     http_req_waiting...............: avg=160.03ms min=112.13ms med=139.46ms max=403.45ms p(90)=258.03ms p(95)=325.8ms <br/>     http_reqs......................: 1859   61.753961/s<br/>     iteration_duration.............: avg=161.72ms min=112.38ms med=139.94ms max=609.5ms  p(90)=258.79ms p(95)=327.48ms<br/>     iterations.....................: 1859   61.753961/s<br/>     vus............................: 10     min=10      max=10<br/>     vus_max........................: 10     min=10      max=10</span></pre><p id="b341" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果显示，GraphQL API在30秒内被命中约1859次，平均持续时间为160毫秒。此外，我们可以看到收到了932kb的数据，发送了459kb的数据。</p><p id="b53c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GraphQL擅长的事情之一是限制您接收的数据量。与REST APIs不同，您不会收到静态响应，但是您有权力决定返回哪些字段。让我们重新运行这个脚本，但是这次限制由GraphQL API返回的字段:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="6fbf" class="kx ky iq ma b gy me mf l mg mh">const query = `<br/>  query GetPost($id: ID!) {<br/>    getPost(id: $id) {<br/>      title<br/>    }<br/>  }<br/>`;</span></pre><p id="a632" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这次不返回<code class="fe mi mj mk ma b">id</code>、<code class="fe mi mj mk ma b">title</code>和<code class="fe mi mj mk ma b">body</code>，只返回文章的标题。如果您使用这一更改重新运行k6脚本，收到的数据量应该比第一次运行时少:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="8e0b" class="kx ky iq ma b gy me mf l mg mh">| GETPOST       | FIRST RUN      | FEWER FIELDS   |<br/>|---------------|----------------|----------------|<br/>| data_received | 932kb (31kb/s) | 594kb (20kb/s) |</span></pre><p id="4fdc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的测试中，发送的数据量没有太大变化。我们所做的唯一改进是从GraphQL查询中删除了两个字段。但是收到的数据量减少了近30%。</p><p id="8cc3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们涉及更多的数据，会发生什么？REST API将总是返回一个固定的响应，包含它返回的每个帖子的所有字段。而使用GraphQL，我们只能收到每篇文章的标题。当我们将获取所有帖子的所有字段的结果与只获取所有帖子的标题的结果进行比较时，我们能得到更有说服力的结果吗？让我们通过创建一个名为<code class="fe mi mj mk ma b">all.js</code>的新脚本来尝试一下:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="2154" class="kx ky iq ma b gy me mf l mg mh">import http from 'k6/http';<br/><br/>const query = `<br/>  query GetPosts {<br/>    getPosts {<br/>      id<br/>      title<br/>      body<br/>      userId<br/>    }<br/>  }<br/>`;<br/><br/>const headers = { 'Content-Type': 'application/json' };<br/><br/>export default function () {<br/>  http.post(<br/>    'https://public3b47822a17c9dda6.stepzen.net/api/with-jsonplaceholder/__graphql',<br/>    JSON.stringify({ query }),<br/>    { headers }<br/>  );<br/>}</span></pre><p id="a88f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个更新的k6脚本将获得所有的帖子和所有的字段，这次包括<code class="fe mi mj mk ma b">userId</code>。如果您直接调用JSONPlaceholder API，该API将有相同的响应。在与之前相同的条件下用k6运行这个脚本将会产生:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="73aa" class="kx ky iq ma b gy me mf l mg mh">| GETPOSTS      | FIRST RUN       |<br/>|---------------|-----------------|<br/>| data_received | 39mb (1.3 mb/s) |</span></pre><p id="a4a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们对k6脚本进行修改，只获取每个帖子的<code class="fe mi mj mk ma b">title</code>字段时，我们应该能够大大减少这个数字。为了进行试验，将脚本<code class="fe mi mj mk ma b">all.js</code>中的查询更新为以下内容:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="b610" class="kx ky iq ma b gy me mf l mg mh">const query = `<br/>  query GetPosts {<br/>    getPosts {<br/>      title<br/>    }<br/>  }<br/>`;</span></pre><p id="abbf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您第二次运行k6性能测试时，新的结果将在您的终端中可见。正如预期的那样，接收的数据量减少了很多，从39mb减少到“仅仅”13mb。而迭代次数也增加了，这意味着在相同的迭代次数下，接收的数据量会更少。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="a371" class="kx ky iq ma b gy me mf l mg mh">| GETPOSTS      | FIRST RUN       | FEWER FIELDS   |<br/>|---------------|-----------------|----------------|<br/>| data_received | 39mb (1.3 mb/s) | 13mb (417mb/s) |</span></pre><p id="1731" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以想象，如果每天有成千上万的用户请求帖子列表，这将产生巨大的差异。与REST API生成的响应相比，您的用户只需用GraphQL加载不到三分之一的数据，因为您可以控制返回的数据。</p><p id="6325" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">由于REST APIs的设置而检索过多的数据，这就是我们在GraphQL中所说的“溢出”。</strong>从我们运行的性能测试中，您可以看到过度蚀刻对您应用程序的影响。现在我们知道k6可以测试GraphQL API的性能，并且GraphQL API已经显示了它的价值，让我们在下一节继续测试一个更重的graph QL查询。</p><h2 id="2e71" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">嵌套GraphQL查询的性能</h2><p id="8d37" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">确定数据形状的能力并不是开发人员选择采用GraphQL作为API查询语言的唯一原因。GraphQL APIs只有一个端点，查询(或其他操作)也可以处理嵌套数据。您可以在一个请求中从不同的数据库表(如SQL连接)甚至不同的数据源请求数据。这与REST APIss不同，在REST API中，您通常必须访问多个端点才能从不同的源获取数据。这也被称为<strong class="ka ir">“下钻”(或N+1问题)，GraphQL通过让您一次查询多个数据结构来解决这个问题。</strong></p><p id="031d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们正在测试的GraphQL API的GraphQL接口中，您可以探索其他可用的查询。其中一个查询将结合来自REST API端点的数据来获取帖子和用户。在REST API中，这些是独立的请求，但在GraphQL API中，它们被组合在一个GraphQL查询中，您可以在部署的演示端点<a class="ae kw" href="https://public3b47822a17c9dda6.stepzen.net/api/with-jsonplaceholder/__graphql?query=query%20GetPost%28%24id%3A%20ID%21%29%20%7B%0A%20%20getPost%28id%3A%20%24id%29%20%7B%0A%20%20%20%20id%0A%20%20%20%20title%0A%20%20%20%20body%0A%20%20%20%20user%20%7B%0A%20%20%20%20%20%20name%0A%20%20%20%20%20%20phone%0A%20%20%20%20%20%20email%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D&amp;variables=%7B%0A%20%20%22id%22%3A%201%0A%7D" rel="noopener ugc nofollow" target="_blank">上尝试此处</a>或在下面的截图中看到:</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="ab gu cl ms"><img src="../Images/ce64e0812491e66cd52f688cfdd4c3bf.png" data-original-src="https://miro.medium.com/v2/format:webp/0*NCq-0oWE00yWOojd.png"/></div></figure><p id="4613" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了获得这些数据，GraphQL API将执行以下操作:</p><ol class=""><li id="acfb" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated">向底层JSONPlaceholder REST API发送一个请求，以获取带有指定值的post，用于<code class="fe mi mj mk ma b">id</code>到<code class="fe mi mj mk ma b"><a class="ae kw" href="https://jsonplaceholder.typicode.com/posts/[id]." rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/posts/[id]</a></code> <a class="ae kw" href="https://jsonplaceholder.typicode.com/posts/[id]." rel="noopener ugc nofollow" target="_blank">。</a></li><li id="12cf" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">基于第一个REST API请求为<code class="fe mi mj mk ma b">userId</code>返回的值，它将在第二个REST API请求中向<code class="fe mi mj mk ma b"><a class="ae kw" href="https://jsonplaceholder.typicode.com/users/[id]." rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/users/[id]</a></code> <a class="ae kw" href="https://jsonplaceholder.typicode.com/users/[id]." rel="noopener ugc nofollow" target="_blank">请求用户信息。</a></li></ol><p id="86dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于GraphQL API也有分别获取帖子(称为<code class="fe mi mj mk ma b">getPost</code>)和用户(称为<code class="fe mi mj mk ma b">getUser</code>)信息的查询，因此我们可以针对单个组合查询的请求测试这两个查询的请求性能。首先，让我们在k6脚本中测试单独的查询，以对GraphQL API进行另一个性能测试。您可以将下面的k6脚本放在一个名为<code class="fe mi mj mk ma b">batch.js</code>的新文件中:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="16da" class="kx ky iq ma b gy me mf l mg mh">import http from 'k6/http';<br/>import { group } from 'k6';<br/><br/>const post = `<br/>  query GetPost($id: ID!) {<br/>    getPost(id: $id) {<br/>      id<br/>      title<br/>      body<br/>      userId<br/>    }<br/>  }<br/>`;<br/><br/>const user = `<br/>  query GetUser($id: ID!) {<br/>    getUser(id: $id) {<br/>      id<br/>      name<br/>      username<br/>      email<br/>      phone<br/>      website<br/>      address {<br/>        street<br/>        suite<br/>        city<br/>        zipcode<br/>        latitude<br/>        longitude<br/>      }<br/>      company {<br/>        name<br/>        catchPhrase<br/>        bs<br/>      }<br/>    }<br/>  }<br/>`;<br/><br/>const headers = {<br/>  'Content-Type': 'application/json',<br/>};<br/><br/>export default function () {<br/>  http.batch([<br/>    [<br/>      'POST',<br/>      'https://public3b47822a17c9dda6.stepzen.net/api/with-jsonplaceholder/__graphql',<br/>      JSON.stringify({<br/>        query: post,<br/>        variables: {<br/>          id: Math.floor(Math.random() * 101),<br/>        },<br/>      }),<br/>      { headers },<br/>    ],<br/>    [<br/>      'POST',<br/>      'https://public3b47822a17c9dda6.stepzen.net/api/with-jsonplaceholder/__graphql',<br/>      JSON.stringify({<br/>        query: user,<br/>        variables: {<br/>          id: Math.floor(Math.random() * 11),<br/>        },<br/>      }),<br/>      { headers },<br/>    ],<br/>  ]);<br/>}</span></pre><p id="0f67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行这个k6脚本将向GraphQL API发送一批请求，模拟需要发送两个REST API请求来获取post和用户数据的场景。批处理请求是并行运行的，这比只发送一个请求更现实。当您在与之前测试相同的环境下运行它时:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="aa8e" class="kx ky iq ma b gy me mf l mg mh">k6 run --vus 10 --duration 30s batch.js</span></pre><p id="922f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在性能测试的结果中，该迭代执行了两个请求。响应时间与之前的测试相似，但是在解释接收到的数据量之前，让我们创建一个名为<code class="fe mi mj mk ma b">nested.js</code>的新脚本，首先针对单个嵌套查询运行。这个查询将获取用户写的文章的信息，这些信息嵌套在您正在检索的单个文章的数据响应中。正如我们之前所做的，我们可以限制返回的字段，因为我们只请求我们想要使用的字段:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="0061" class="kx ky iq ma b gy me mf l mg mh">import http from 'k6/http';<br/><br/>const query = `<br/>  query GetPost($id: ID!) {<br/>    getPost(id: $id) {<br/>      title<br/>      user {<br/>        name<br/>        phone<br/>        email<br/>      }<br/>    }<br/>  }<br/>`;<br/><br/>const headers = {<br/>  'Content-Type': 'application/json',<br/>};<br/><br/>export default function () {<br/>  http.post(<br/>    'https://public3b47822a17c9dda6.stepzen.net/api/with-jsonplaceholder/__graphql',<br/>    JSON.stringify({<br/>      query,<br/>      variables: {<br/>        id: Math.floor(Math.random() * 101),<br/>      },<br/>    }),<br/>    { headers }<br/>  );<br/>}</span></pre><p id="0f03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在同样的条件下运行，这样我们就可以比较结果了。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="4c1f" class="kx ky iq ma b gy me mf l mg mh">| GETPOST       | BATCH.JS       | NESTED.JS      |<br/>|---------------|----------------|----------------|<br/>| data_received | 2.0mb (65kb/s) | 759kb (25kb/s) |<br/>| data_sent     | 1.2mb (38kb/s) | 514kb (17kb/s) |<br/>| http_reqs     | 3222           | 1758           |<br/>| iterations    | 1611           | 1758           |</span></pre><p id="eda0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GraphQL API能够实现更多的迭代，但是HTTP请求更少。对GraphQL化的{ JSON }占位符API的两个REST API调用由GraphQL层执行，因此在此结果中不可见。但是收到的数据量急剧减少，而不是2.0mb，对于更大量的迭代，这次只收到759kb。这是因为并非所有字段都是从GraphQL API请求的。</p><p id="4dd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们刚刚运行的测试表明<strong class="ka ir"> GraphQL完全能够在一个请求中组合你的所有数据，同时仍然是高性能的。此外，大量减少接收的数据量，因为它可以同时解决N+1问题和过蚀刻。</strong></p><h2 id="e806" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">结论</h2><p id="00b1" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">在这篇文章中，我们探索了如何使用<a class="ae kw" href="https://k6.io/" rel="noopener ugc nofollow" target="_blank"> k6 </a>对GraphQL API进行性能测试。这个GraphQL API是开源JSONPlaceholder REST API的GraphQL化版本，使用StepZen进行转换。我们测试了开发人员采用GraphQL的各种用例:过度提取和N+1问题。在测试中，我们看到了GraphQL如何通过改变请求字段来限制接收的数据量，从而解决了过度提取的问题。尤其是在请求大量数据时，GraphQL和REST之间的差异是巨大的。N+1问题需要第二个API请求来获取所有数据，GraphQL通过允许您在一个请求中组合来自多个来源的数据解决了这个问题。这一点在获取数据所需的HTTP请求数量上变得尤为明显。GraphQL能够在相同的时间框架内进行更多的迭代，甚至比REST API返回更少的数据。</p><p id="d61e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想继续用GraphQL进行构建或性能测试吗？你可以在这里找到图形化REST API <a class="ae kw" href="https://github.com/stepzen-dev/examples/tree/main/with-jsonplaceholder" rel="noopener ugc nofollow" target="_blank">的代码，在</a><a class="ae kw" href="https://k6.io/docs/" rel="noopener ugc nofollow" target="_blank"> k6文档</a>中找到更多关于性能测试的信息。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="18db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文最初发表在k6博客上:</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/e2b09a11d908ba3e4581fec1bff7331f.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/0*MW5Hab7xwSW6TfXb.png"/></div></figure></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="f1f3" class="np ky iq bd kz nq nr ns lc nt nu nv lf nw nx ny li nz oa ob ll oc od oe lo of bi translated">分级编码</h1><p id="d9f3" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">感谢您成为我们社区的一员！更多内容请参见<a class="ae kw" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>。</p><p id="f536" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关注:<a class="ae kw" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank"> Twitter </a>，<a class="ae kw" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>，<a class="ae kw" href="https://newsletter.levelup.dev/" rel="noopener ugc nofollow" target="_blank">时事通讯</a></p><p id="dd9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">升级正在改造科技招募</strong>👉<a class="ae kw" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">加入我们的人才集体</strong> </a></p></div></div>    
</body>
</html>