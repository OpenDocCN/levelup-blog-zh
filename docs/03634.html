<html>
<head>
<title>Create and Evaluate Simple Expression Tree in Python in Object Oriented style</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以面向对象的方式在Python中创建和评估简单的表达式树</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/create-and-evaluate-simple-expression-tree-in-python-in-object-oriented-style-5eb27b6376c8?source=collection_archive---------0-----------------------#2020-05-20">https://levelup.gitconnected.com/create-and-evaluate-simple-expression-tree-in-python-in-object-oriented-style-5eb27b6376c8?source=collection_archive---------0-----------------------#2020-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9b7567b93a1dc4b9798a129b28dccc01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2kbrAfL7muAATBb2163RiA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">表达式树插图[1]</figcaption></figure><h1 id="3cff" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">什么是表达式树？</h1><p id="5804" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">在本文中，我将向您展示如何创建一个表达式树来存储二进制算术表达式的令牌。</p><p id="39a0" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">表达式树是一种二叉树，具有以下属性:</p><ol class=""><li id="e8a9" class="mg mh it lf b lg mb lk mc lo mi ls mj lw mk ma ml mm mn mo bi translated">每片叶子都是一个操作数。</li><li id="7e11" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi translated">根节点和内部节点是<em class="mp">操作符</em>。</li><li id="6bdf" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi translated">子树是子表达式，根是一个<em class="mp">操作符</em>。</li></ol><div class="mv mw gp gr mx my"><a href="https://www.eduelk.com/" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">教育</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">通过我们的练习题为您的下一次技术认证考试树立信心。我们提供课程来加速…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">www.eduelk.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm jz my"/></div></div></a></div><div class="mv mw gp gr mx my"><a href="https://www.eduelk.com/about-us" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">关于我们——教育</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">在爱德克教育，我们相信熟能生巧。我们知道准备参加技术认证是…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">www.eduelk.com</p></div></div><div class="nh l"><div class="nn l nj nk nl nh nm jz my"/></div></div></a></div><div class="mv mw gp gr mx my"><a href="https://www.eduelk.com/shop-for-practice-questions" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">通过我们负担得起的练习题获得自信——教育</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">编辑描述</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">www.eduelk.com</p></div></div><div class="nh l"><div class="no l nj nk nl nh nm jz my"/></div></div></a></div><div class="mv mw gp gr mx my"><a href="https://www.eduelk.com/book-a-lesson" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">联系方式1——教育</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">编辑描述</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">www.eduelk.com</p></div></div><div class="nh l"><div class="np l nj nk nl nh nm jz my"/></div></div></a></div><h1 id="b59b" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">什么是算术表达式？</h1><p id="5b79" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">算术表达式是遵循规定规则的符号序列。令牌可以是操作数，也可以是运算符。</p><p id="8801" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">使用标准算术运算符<strong class="lf iu">加法(+)、减法(-)、乘法(*)、除法(/</strong>)的二进制算术运算可以是操作数-运算符-操作数的形式。</p><p id="2e68" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">比如<strong class="lf iu"> 2 + 3 </strong>，其中<strong class="lf iu"> 2 </strong>和<strong class="lf iu"> 3 </strong>是<em class="mp">操作数</em>，<strong class="lf iu"> + </strong>是加法<em class="mp">运算符。</em></p><h1 id="169b" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">先决条件</h1><p id="16e5" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">在阅读本文之前，您应该了解一些先决条件。您需要对以下内容有一个基本的了解:</p><ul class=""><li id="a8eb" class="mg mh it lf b lg mb lk mc lo mi ls mj lw mk ma nq mm mn mo bi translated">面向对象编程</li><li id="15ce" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma nq mm mn mo bi translated">堆栈数据结构</li><li id="c15e" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma nq mm mn mo bi translated">功能</li><li id="7cb2" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma nq mm mn mo bi translated">条件语句</li><li id="5cc5" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma nq mm mn mo bi translated">环</li><li id="0df4" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma nq mm mn mo bi translated">链表</li></ul><h1 id="93fb" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">程序</h1><p id="7316" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">现在，程序的方式是基于一种实现表达式树的方式。</p><p id="dd67" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">以下是我将在本文中主要讲述的步骤列表:</p><ol class=""><li id="b663" class="mg mh it lf b lg mb lk mc lo mi ls mj lw mk ma ml mm mn mo bi translated">节点类</li><li id="9601" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi translated">ExpressionTree构造函数</li><li id="80e4" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi translated">ExpressionTree运算符检查函数</li><li id="76b5" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi translated">ExpressionTree插入节点函数</li><li id="3a9c" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi translated">ExpressionTree显示功能</li><li id="d500" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi translated">ExpressionTree中缀函数</li><li id="64d5" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi translated">ExpressionTree评估函数</li></ol><p id="a88e" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">好吧！让我们开始编码吧！</p><h1 id="4559" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">节点类</h1><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="c2b8" class="oa kg it nw b gy ob oc l od oe"><strong class="nw iu">class </strong>Node:<br/> <strong class="nw iu">def </strong>__init__(self, left_child_index):<br/>  self.DataValue = ""<br/>  self.LeftChild = left_child_index<br/>  self.RightChild = -1</span></pre><p id="37f3" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">这是构建链表的基础。这是为左指针指向另一个节点的下一个索引而设计的。</p><h1 id="db4b" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">ExpressionTree类</h1><h2 id="8e70" class="oa kg it bd kh of og dn kl oh oi dp kp lo oj ok kt ls ol om kx lw on oo lb op bi translated">构造器</h2><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="b79d" class="oa kg it nw b gy ob oc l od oe"><strong class="nw iu">class </strong>ExpressionTree:<br/> <strong class="nw iu">def </strong>__init__(self):<br/>  self.Tree = list()<br/>  for index in range(1, 21):<br/>   self.Tree.append(Node(index))<br/>  self.Fringe = list()<br/>  self.Root = 0<br/>  self.NextFreeChild = 0</span></pre><p id="e54c" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">我们的ExpressionTree类有一个带有以下类属性的构造函数:</p><ul class=""><li id="18c7" class="mg mh it lf b lg mb lk mc lo mi ls mj lw mk ma nq mm mn mo bi translated">树</li><li id="ce40" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma nq mm mn mo bi translated">边缘</li><li id="6440" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma nq mm mn mo bi translated">根</li><li id="c62b" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma nq mm mn mo bi translated">NextFreeChild</li></ul><p id="4af5" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">这个程序实现中的Tree属性保存一个节点对象数组。每个节点对象都有一个指向下一个节点的LeftChild。</p><figure class="nr ns nt nu gt ju gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/e5a1bafac952540ee7dc4c99c4911b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*urY5cNy90Gy9hHVTQnguXQ.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">节点的链接列表</figcaption></figure><h2 id="6359" class="oa kg it bd kh of og dn kl oh oi dp kp lo oj ok kt ls ol om kx lw on oo lb op bi translated">检查字符是否是运算符</h2><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="0684" class="oa kg it nw b gy ob oc l od oe"><strong class="nw iu">def </strong>IsOperator(self, s):<br/> if '+' in s:<br/>  return True<br/> if '-' in s:<br/>  return True<br/> if '*' in s:<br/>  return True<br/> if /' in s:<br/>  return True<br/> return False</span></pre><p id="7f86" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">这个函数将检查字符是否是一个操作符。</p><h2 id="3da2" class="oa kg it bd kh of og dn kl oh oi dp kp lo oj ok kt ls ol om kx lw on oo lb op bi translated">在二叉树中插入一个节点</h2><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="8e27" class="oa kg it nw b gy ob oc l od oe"><strong class="nw iu">def </strong>Insert(self, NewToken):<br/> if self.NextFreeChild == -1: <strong class="nw iu"># check if tree is full</strong><br/>  return “Tree is Full”</span><span id="757a" class="oa kg it nw b gy or oc l od oe"> <strong class="nw iu"># tree is not full, safe to insert new token</strong><br/> if self.NextFreeChild == 0:<br/>  self.Tree[self.Root].DataValue = NewToken<br/>  self.NextFreeChild = self.Tree[self.Root].LeftChild<br/>  self.Tree[self.Root].LeftChild = -1<br/> else:<br/>  <strong class="nw iu"># insert into tree with existing nodes</strong><br/>  <strong class="nw iu"># starting with Root</strong><br/>  Current = 0 <strong class="nw iu"># index of the current node</strong><br/>  Previous = -1 <strong class="nw iu"># index of previous node</strong><br/>  NewNode = self.Tree[self.NextFreeChild] <strong class="nw iu"># declare new node</strong><br/>  NewNode.DataValue = NewToken</span><span id="534d" class="oa kg it nw b gy or oc l od oe">  <strong class="nw iu"># Finding the node at which the NewNode can be inserted</strong><br/>  while Current != -1:<br/>   CurrNode = self.Tree[Current]<br/>   <strong class="nw iu"># check if CurrNode contains an operator</strong><br/>   if self.IsOperator(CurrNode.DataValue):<br/>    <strong class="nw iu"># if LeftChild is empty, insert here</strong><br/>    if CurrNode.LeftChild == -1:<br/>     CurrNode.LeftChild = self.NextFreeChild<br/>     self.NextFreeChild = NewNode.LeftChild<br/>     NewNode.LeftChild = -1<br/>     Current = -1<br/>    <strong class="nw iu"># if RightChild is empty, insert here</strong><br/>    elif CurrNode.RightChild == -1:<br/>     CurrNode.RightChild = self.NextFreeChild<br/>     self.NextFreeChild = NewNode.LeftChild<br/>     NewNode.LeftChild = -1<br/>     Current = -1<br/>    <strong class="nw iu"># if LeftChild is an operator</strong><br/>    <strong class="nw iu"># traverse LeftChild subtree</strong><br/>    elif self.IsOperator(self.Tree[CurrNode.LeftChild].DataValue):<br/>     Previous = Current<br/>     Current = CurrNode.LeftChild<br/>     self.Fringe.append(Previous)<br/>    <strong class="nw iu"># if RightChild is an operator</strong><br/>    <strong class="nw iu"># traverse RightChild subtree</strong><br/>    elif self.IsOperator(self.Tree[CurrNode.RightChild].DataValue):<br/>     Previous = Current<br/>     Current = CurrNode.RightChild<br/>     self.Fringe.append(Previous)<br/>    <strong class="nw iu"># traverse right subtree</strong><br/>    else:<br/>     Previous = self.Fringe.pop(-1)<br/>     Current = self.Tree[Previous].RightChild<br/>   <strong class="nw iu"># no place to insert</strong><br/>   else:<br/>    return “Cannot be inserted”</span></pre><p id="856d" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">一个示例给出了以下令牌序列:</p><ol class=""><li id="2e86" class="mg mh it lf b lg mb lk mc lo mi ls mj lw mk ma ml mm mn mo bi">+</li><li id="4a4b" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi">*</li><li id="4d7d" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi">4</li><li id="99b2" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi">2</li><li id="9336" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi">/</li><li id="406f" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi">3</li><li id="f0ae" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi">1</li></ol><p id="ef32" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">这个函数在表达式二叉树中插入一个新的节点。</p><figure class="nr ns nt nu gt ju gh gi paragraph-image"><div class="gh gi os"><img src="../Images/5f20c86ca61ead51b90119d41e826f4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:260/format:webp/1*K4mKpcP3Lxl_gKgoC3a3ww.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">第0层的根节点</figcaption></figure><p id="f3d0" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">由于表达式二叉树中没有任何节点，所以添加了一个根节点。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="063a" class="oa kg it nw b gy ob oc l od oe">Index: 0 DataValue: + LeftChild: -1 RightChild: -1</span></pre><figure class="nr ns nt nu gt ju gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/f6c1485868ff8905a159fe419c2e1f39.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*iezFPkx3U-PljS-fZP-qrg.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在第1层左侧插入节点</figcaption></figure><p id="0d87" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">因为<strong class="lf iu">根</strong>节点的<strong class="lf iu">左子节点</strong>是索引-1，所以新节点被插入到树的左侧。<strong class="lf iu">根</strong>节点的<strong class="lf iu">左子</strong>被<strong class="lf iu">更新为<strong class="lf iu"> 1 </strong>。</strong></p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="e2f3" class="oa kg it nw b gy ob oc l od oe">Index: 0 DataValue: + LeftChild: 1 RightChild: -1<br/>Index: 1 DataValue: * LeftChild: -1 RightChild: -1</span></pre><figure class="nr ns nt nu gt ju gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/8f0f66c8c59d01fc8c68beef57e34b8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*_h2PIJFTVFrFS-yH_CFaIg.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在第1层的右侧插入节点</figcaption></figure><p id="383d" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">由于<strong class="lf iu">根</strong>节点的<strong class="lf iu">左子节点</strong>指向一个<strong class="lf iu">已有节点</strong>并且<strong class="lf iu">右子节点</strong>指向索引<strong class="lf iu"> -1 </strong>，新节点被插入到<strong class="lf iu">根</strong>节点的<strong class="lf iu">右子节点</strong>上。<strong class="lf iu">根</strong>节点的<strong class="lf iu">子节点</strong>被<strong class="lf iu">更新为</strong>2。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="5793" class="oa kg it nw b gy ob oc l od oe">Index: 0 DataValue: + LeftChild: 1 RightChild: 2<br/>Index: 1 DataValue: * LeftChild: -1 RightChild: -1<br/>Index: 2 DataValue: 4 LeftChild: -1 RightChild: -1</span></pre><figure class="nr ns nt nu gt ju gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/35170ae574b5e7191ca18406d533f3ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*POxbmS16VSkBnwtSkfCczg.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在第2层左侧插入节点</figcaption></figure><p id="df5f" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">由于* <strong class="lf iu"> </strong>节点的<strong class="lf iu">左子节点</strong>是index -1，所以新节点被插入到<strong class="lf iu"> * </strong>节点的左侧。* <strong class="lf iu"> </strong>节点的<strong class="lf iu">左子节点</strong>被<strong class="lf iu">更新</strong>为索引<strong class="lf iu"> 3。</strong></p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="73bd" class="oa kg it nw b gy ob oc l od oe">Index: 0 DataValue: + LeftChild: 1 RightChild: 2<br/>Index: 1 DataValue: * LeftChild: 3 RightChild: -1<br/>Index: 2 DataValue: 4 LeftChild: -1 RightChild: -1<br/>Index: 3 DataValue: 2 LeftChild: -1 RightChild: -1</span></pre><figure class="nr ns nt nu gt ju gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/d60a0875e9e07d644b811b865aca438b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*2rqze4IGahaOLR6Vl1aW1w.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在第2层右侧插入节点</figcaption></figure><p id="1eb1" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">由于* <strong class="lf iu"> </strong>节点的<strong class="lf iu">左子节点</strong>指向一个现有节点，而<strong class="lf iu">右子节点</strong>指向索引<strong class="lf iu"> -1 </strong>，新节点被插入到<strong class="lf iu"> * </strong>节点的<strong class="lf iu">右子节点</strong>上。<strong class="lf iu"> * </strong>节点的<strong class="lf iu">右子节点</strong>被<strong class="lf iu">更新</strong>为索引<strong class="lf iu"> 4 </strong>。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="02dd" class="oa kg it nw b gy ob oc l od oe">Index: 0 DataValue: + LeftChild: 1 RightChild: 2<br/>Index: 1 DataValue: * LeftChild: 3 RightChild: 4<br/>Index: 2 DataValue: 4 LeftChild: -1 RightChild: -1<br/>Index: 3 DataValue: 2 LeftChild: -1 RightChild: -1<br/>Index: 4 DataValue: / LeftChild: -1 RightChild: -1</span></pre><figure class="nr ns nt nu gt ju gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/8c71ee61f2b14f2b154784c6965c7fac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*0x796nJZ5i68BHgIPO1JkQ.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在第3层左侧插入节点</figcaption></figure><p id="b889" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">由于<strong class="lf iu"> / </strong>节点的<strong class="lf iu">左子节点</strong>是索引<strong class="lf iu"> -1 </strong>并且为空，所以新节点被插入到<strong class="lf iu"> / </strong>节点的左侧。/ <strong class="lf iu"> </strong>节点的<strong class="lf iu">左子</strong>被<strong class="lf iu">更新</strong>到索引<strong class="lf iu"> 5。</strong></p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="d037" class="oa kg it nw b gy ob oc l od oe">Index: 0 DataValue: + LeftChild: 1 RightChild: 2<br/>Index: 1 DataValue: * LeftChild: 3 RightChild: 4<br/>Index: 2 DataValue: 4 LeftChild: -1 RightChild: -1<br/>Index: 3 DataValue: 2 LeftChild: -1 RightChild: -1<br/>Index: 4 DataValue: / LeftChild: 5 RightChild: -1<br/>Index: 5 DataValue: 3 LeftChild: -1 RightChild: -1</span></pre><figure class="nr ns nt nu gt ju gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/8a689999c0df314bc63be7bd4d52125d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*L3AlGT_fXpWTOoJ6zztYCA.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在第3层右侧插入节点</figcaption></figure><p id="4fbc" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">由于/ <strong class="lf iu"> </strong>节点的<strong class="lf iu">左子节点</strong>指向一个现有节点，而<strong class="lf iu">右子节点</strong>指向索引<strong class="lf iu"> -1 </strong>，所以新节点被插入到<strong class="lf iu"> / </strong>节点的<strong class="lf iu">右子节点</strong>上。<strong class="lf iu"> / </strong>节点的<strong class="lf iu">右子节点</strong>被<strong class="lf iu">更新</strong>到索引<strong class="lf iu"> 6。</strong></p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="3633" class="oa kg it nw b gy ob oc l od oe">Index: 0 DataValue: + LeftChild: 1 RightChild: 2<br/>Index: 1 DataValue: * LeftChild: 3 RightChild: 4<br/>Index: 2 DataValue: 4 LeftChild: -1 RightChild: -1<br/>Index: 3 DataValue: 2 LeftChild: -1 RightChild: -1<br/>Index: 4 DataValue: / LeftChild: 5 RightChild: 6<br/>Index: 5 DataValue: 3 LeftChild: -1 RightChild: -1<br/>Index: 6 DataValue: 1 LeftChild: -1 RightChild: -1</span></pre><p id="687f" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">这是在二叉树中插入一个节点的方法之一。</p><h2 id="7d95" class="oa kg it bd kh of og dn kl oh oi dp kp lo oj ok kt ls ol om kx lw on oo lb op bi translated">显示</h2><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="0663" class="oa kg it nw b gy ob oc l od oe"><strong class="nw iu">def </strong>Display(self):<br/> for index in range(len(self.Tree)):<br/>  print("Index: ", index, "DataValue: ",self.Tree[index].DataValue)</span></pre><p id="fa22" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">这个函数遍历整个树型数组，并显示每个数组元素的索引和元素中节点的值。</p><h2 id="5293" class="oa kg it bd kh of og dn kl oh oi dp kp lo oj ok kt ls ol om kx lw on oo lb op bi translated">测试</h2><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="456c" class="oa kg it nw b gy ob oc l od oe">expressionTree = ExpressionTree()<br/>expressionTree.Insert('+')<br/>expressionTree.Insert('*')<br/>expressionTree.Insert('4')<br/>expressionTree.Insert('2')<br/>expressionTree.Insert('/')<br/>expressionTree.Insert('3')<br/>expressionTree.Insert('1')<br/>expressionTree.Display()</span></pre><figure class="nr ns nt nu gt ju gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/62c6a7c17a79253d13b0ce9dc16f2e4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*pJRD_m5JCNZ8aFhbtFdmHw.jpeg"/></div></figure><h2 id="190b" class="oa kg it bd kh of og dn kl oh oi dp kp lo oj ok kt ls ol om kx lw on oo lb op bi translated">中缀(按顺序遍历)</h2><p id="3a50" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这个算法是基于<a class="ae oz" href="https://en.wikipedia.org/wiki/Tree_traversal#In-order" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Tree_traversal#In-order</a>的。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="550b" class="oa kg it nw b gy ob oc l od oe"><strong class="nw iu">def </strong>Infix(self, root, arr):<br/> if root.DataValue != "":<br/>  if self.IsOperator(root.DataValue):<br/>   arr.append('(')</span><span id="8cc7" class="oa kg it nw b gy or oc l od oe">  self.Infix(self.Tree[root.LeftChild], arr)<br/>  arr.append(root.DataValue)<br/>  self.Infix(self.Tree[root.RightChild], arr)</span><span id="a7db" class="oa kg it nw b gy or oc l od oe">  if self.IsOperator(root.DataValue):<br/>   arr.append(')')</span></pre><p id="05f2" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">给定下面的二叉树:</p><figure class="nr ns nt nu gt ju gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/8a689999c0df314bc63be7bd4d52125d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*L3AlGT_fXpWTOoJ6zztYCA.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">表达式树</figcaption></figure><p id="b429" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">下面是根据给定的二叉树在顺序遍历中做<strong class="lf iu">的步骤:</strong></p><figure class="nr ns nt nu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pa"><img src="../Images/b89995e15ade42bcc08ad9ffc1271fd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*60g1fkSEw7W_xxhb6Al7UA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">遍历左边的子树</figcaption></figure><p id="851f" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">从根节点开始，遍历左边的子树，直到叶节点结束。</p><figure class="nr ns nt nu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pb"><img src="../Images/1f63c4cc51bc7d6f8a684ac64448e7dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dg8HO0XlOQTnwu50XScVdg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">访问左子树的根</figcaption></figure><p id="6cec" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">在左边的子树中，查看子树的根。</p><figure class="nr ns nt nu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pc"><img src="../Images/56bfcb51c853e97462a0c78066d5aea4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qhYXL4pcJWVj4w6XFANrSQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">遍历右边的子树，然后遍历左边的下一个子树</figcaption></figure><p id="c1fe" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">遍历左边子树的右边，然后遍历子树的左边，它位于整个树的第3层。</p><figure class="nr ns nt nu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pc"><img src="../Images/92cd934bb11148bdf5dd31c4b033e019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EohMjfMpC49alVRLnp-_2w.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">访问子树的根</figcaption></figure><p id="9c62" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">接下来，访问第2层子树的根节点。</p><figure class="nr ns nt nu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pd"><img src="../Images/6aeffd4dabd3ce9546cd864042cd4d9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cynXhsEmiJ8qYbov9gUImw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">遍历右边的子树</figcaption></figure><p id="bb32" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">遍历到第3层子树的右边节点。</p><figure class="nr ns nt nu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pe"><img src="../Images/2f419165cb8e1069a41c20ea8b6867bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cVYMipUIVDalq_snxtSlDQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">访问整个子树的根</figcaption></figure><p id="3a1f" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">然后，返回到第0层的整个树的根节点。</p><figure class="nr ns nt nu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pf"><img src="../Images/9c4a8d68336397b085235e8d39817b82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SGBMKZtcbHPb_CDcmAgJOg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">遍历右边的子树</figcaption></figure><p id="1963" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">最后，从根节点开始，遍历右边的子树，直到叶子节点结束。</p><h2 id="670a" class="oa kg it bd kh of og dn kl oh oi dp kp lo oj ok kt ls ol om kx lw on oo lb op bi translated">测试</h2><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="a0d8" class="oa kg it nw b gy ob oc l od oe">arr = []<br/>expressionTree.Infix(expressionTree.Tree[0], arr)<br/>expression_string = ''.join(arr[1:-1])<br/>print(expression_string)</span></pre><p id="fbd1" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">下面是表达式树中顺序遍历的<strong class="lf iu">的结果，(2*(3/1))+4</strong></p><h1 id="6024" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">计算表达式</h1><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="b41a" class="oa kg it nw b gy ob oc l od oe"><strong class="nw iu">def </strong>calculate(self, expression):<br/> <strong class="nw iu">def </strong>processing(left, stack):<br/>  right = stack.pop() # get right number<br/>  right = int(right)<br/>  operator = stack.pop() # get operator<br/>  left = stack.pop() # get left number<br/>  left = int(left)</span><span id="dbe2" class="oa kg it nw b gy or oc l od oe">  # calculating depending on operator<br/>  if '+' in operator:<br/>   left += right<br/>  elif '-' in operator:<br/>   left -= right<br/>  elif '*' in operator:<br/>   left *= right<br/>  elif '/' in operator:<br/>   left /= right</span><span id="c3a0" class="oa kg it nw b gy or oc l od oe">  return left, stack</span><span id="82fa" class="oa kg it nw b gy or oc l od oe"> stack = []<br/> count = 0<br/> left = 0</span><span id="a973" class="oa kg it nw b gy or oc l od oe"> for char in expression:<br/>  stack.append(char)</span><span id="7392" class="oa kg it nw b gy or oc l od oe">  if char == ')':</span><span id="5040" class="oa kg it nw b gy or oc l od oe">   stack.pop()<br/>   left, stack = processing(left, stack)<br/>   stack.pop()<br/>   stack.append(left)</span><span id="1fca" class="oa kg it nw b gy or oc l od oe">  if count == len(expression)-1: # last char of expression string</span><span id="9174" class="oa kg it nw b gy or oc l od oe">   left, stack = processing(left, stack)</span><span id="3e3b" class="oa kg it nw b gy or oc l od oe">  count += 1</span><span id="46ba" class="oa kg it nw b gy or oc l od oe"> return left</span></pre><p id="13ce" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">这个函数根据给定的数学表达式计算一个数。该函数仅限于加法(+)、减法(-)、乘法(*)和除法(/)</p><p id="ef22" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">给定以下数学表达式:</p><blockquote class="pg ph pi"><p id="cc1c" class="ld le mp lf b lg mb li lj lk mc lm ln pj md lq lr pk me lu lv pl mf ly lz ma im bi">(2*(3/1))+4</p></blockquote><p id="4f3e" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">下面是函数中的计算:</p><figure class="nr ns nt nu gt ju gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/41d29af9dfa6cc5da1d433400839d3c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*HkP-Q0N7Xj9fgMzpS8s3Cw.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">堆栈中的数学表达式计算</figcaption></figure><p id="234a" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">该函数执行以下步骤:</p><ol class=""><li id="261e" class="mg mh it lf b lg mb lk mc lo mi ls mj lw mk ma ml mm mn mo bi translated">对于每个字符，将该字符压入堆栈</li><li id="37f0" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi translated">检查字符是否为<strong class="lf iu"> ) </strong>，然后从堆栈中弹出一个字符</li><li id="cee0" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi translated">在步骤2中，从堆栈中弹出一个字符，并将该字符指定为正确的数字</li><li id="84da" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi translated">在步骤2中，从堆栈中弹出一个字符，并将该字符指定为运算符</li><li id="8848" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi translated">在步骤2中，从堆栈中弹出一个字符，并将该字符指定为左边的数字</li><li id="3442" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi translated">在步骤2中，根据左边的数字、运算符和右边的数字计算一个数字。然后将该数字分配给左边的数字。</li><li id="4175" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi translated">在步骤2中，从堆栈中弹出一个字符</li><li id="d7c4" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi translated">在步骤2中，将左边的数字字符压入堆栈</li><li id="8cfe" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi translated">重复步骤1至8，直到表达式的最后一个字符，然后执行步骤3至6</li></ol><h2 id="f583" class="oa kg it bd kh of og dn kl oh oi dp kp lo oj ok kt ls ol om kx lw on oo lb op bi translated">测试</h2><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="8c86" class="oa kg it nw b gy ob oc l od oe">import re<br/>regex_expression = "[\/\+\-\*\(\)]|[0–9][0–9][0–9]|[0–9][0–9]|[0–9]"<br/>txt_list = re.findall(regex_expression, "(2*(3/1))+4")<br/>print(expressionTree.calculate(txt_list))<br/>txt_list = re.findall(regex_expression, "2+4")<br/>print(expressionTree.calculate(txt_list))<br/>txt_list = re.findall(regex_expression, "(2+4)-1")<br/>print(expressionTree.calculate(txt_list))<br/>txt_list = re.findall(regex_expression, "(10-(2+4)")<br/>print(expressionTree.calculate(txt_list))</span></pre><p id="226b" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">这里的正则表达式考虑了以下因素:</p><ol class=""><li id="f072" class="mg mh it lf b lg mb lk mc lo mi ls mj lw mk ma ml mm mn mo bi translated">数学运算符，如加法(+)、减法(-)、乘法(*)和除法(/)</li><li id="3fc3" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi translated">数字0到9</li><li id="0c43" class="mg mh it lf b lg mq lk mr lo ms ls mt lw mu ma ml mm mn mo bi translated">多少位数字(在本例中为1至3位数字)</li></ol><p id="57cf" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">这个正则表达式有助于将字符串转换成可用的数组。</p><h2 id="aee8" class="oa kg it bd kh of og dn kl oh oi dp kp lo oj ok kt ls ol om kx lw on oo lb op bi translated">例子</h2><blockquote class="pg ph pi"><p id="79bd" class="ld le mp lf b lg mb li lj lk mc lm ln pj md lq lr pk me lu lv pl mf ly lz ma im bi translated">给定这个数学表达式，<strong class="lf iu"> (2*(3/1))+4 </strong>，输出:</p></blockquote><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="222c" class="oa kg it nw b gy ob oc l od oe">['(', '2', '*', '(', '3', '/', '1', ')', ')', '+', '4']</span></pre><blockquote class="pg ph pi"><p id="2674" class="ld le mp lf b lg mb li lj lk mc lm ln pj md lq lr pk me lu lv pl mf ly lz ma im bi translated">给定这个数学表达式，<strong class="lf iu"> 100-(20+4) </strong>，输出:</p></blockquote><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="f4fd" class="oa kg it nw b gy ob oc l od oe">['100', '-', '(', '20', '+', '4', ')']</span></pre><h2 id="111a" class="oa kg it bd kh of og dn kl oh oi dp kp lo oj ok kt ls ol om kx lw on oo lb op bi translated">结果</h2><figure class="nr ns nt nu gt ju gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/73dbe1331ea13abb02158c98c9289673.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*BkZXftKf3cwYNq2Za4w3hg.jpeg"/></div></figure><p id="f935" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">节目到此结束。编写完这个程序后，我将继续我的想法。</p><h1 id="d1ec" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">思想</h1><p id="16bd" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">希望这篇文章有助于更新或介绍计算概念，如链表、栈数据结构、类、对象以及二叉树。如果这是有用的，并且能唤起你在大学攻读计算机科学学位时的回忆，请鼓掌。和平✌️</p><div class="mv mw gp gr mx my"><a href="https://www.eduelk.com/" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">教育</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">通过我们的练习题为您的下一次技术认证考试树立信心。我们提供课程来加速…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">www.eduelk.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm jz my"/></div></div></a></div><div class="mv mw gp gr mx my"><a href="https://www.eduelk.com/about-us" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">关于我们——教育</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">在爱德克教育，我们相信熟能生巧。我们知道准备参加技术认证是…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">www.eduelk.com</p></div></div><div class="nh l"><div class="nn l nj nk nl nh nm jz my"/></div></div></a></div><div class="mv mw gp gr mx my"><a href="https://www.eduelk.com/shop-for-practice-questions" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">通过我们负担得起的练习题获得自信——教育</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">编辑描述</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">www.eduelk.com</p></div></div><div class="nh l"><div class="no l nj nk nl nh nm jz my"/></div></div></a></div><div class="mv mw gp gr mx my"><a href="https://www.eduelk.com/book-a-lesson" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">联系方式1——教育</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">编辑描述</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">www.eduelk.com</p></div></div><div class="nh l"><div class="np l nj nk nl nh nm jz my"/></div></div></a></div><h1 id="2dd0" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">参考</h1><ol class=""><li id="c6e4" class="mg mh it lf b lg lh lk ll lo po ls pp lw pq ma ml mm mn mo bi translated">文件:Exp-tree-ex-12 . SVG(2014年2月14日)。2020年5月18日从<a class="ae oz" href="https://en.wikipedia.org/wiki/File:Exp-tree-ex-12.svg" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/File:Exp-tree-ex-12.svg</a>检索</li></ol></div></div>    
</body>
</html>