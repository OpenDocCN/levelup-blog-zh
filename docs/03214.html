<html>
<head>
<title>Learning C++: Nonmutating Algorithms of the STL Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习c++:STL的不变算法第3部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-nonmutating-algorithms-of-the-stl-part-3-94c0c04cabeb?source=collection_archive---------13-----------------------#2020-04-25">https://levelup.gitconnected.com/learning-c-nonmutating-algorithms-of-the-stl-part-3-94c0c04cabeb?source=collection_archive---------13-----------------------#2020-04-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/bd8fcd9894ef20c2df83a08e4bda23bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V0HG5NheJHI6tUpR"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">马库斯·斯皮斯克在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4519" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这最后一篇关于C++标准模板库的不变算法的文章中，我将介绍一些很少使用但仍然很重要的在容器中查找值的函数，以及其他一些任务。</p><h1 id="f581" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在序列的开头和结尾查找值</h1><p id="8765" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">STL中有两个函数用于查找序列开头或结尾的值。第一个参数<code class="fe mh mi mj mk b">find_end</code>返回最后一个序列中第一个元素的位置，该序列与作为第二个参数提供的序列相匹配。以下是此版本函数的语法模板:</p><p id="3e71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> find_end(range-start，range-end，seq-start，seq-end)；</em></p><p id="bd4a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个版本的<code class="fe mh mi mj mk b">find_end</code>在工作中的一个例子:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="717d" class="mu lf it mk b gy mv mw l mx my">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;algorithm&gt;<br/>#include &lt;list&gt;<br/>using namespace std;</span><span id="4fd4" class="mu lf it mk b gy mz mw l mx my">int main () {<br/>  vector&lt;int&gt; numbers = {8,1,2,3,4,5,8,1,3,4,5,8,1,2};<br/>  list&lt;int&gt; seq = {8,1,2};<br/>  auto found = find_end(numbers.begin(), numbers.end(),<br/>                        seq.begin(), seq.end());<br/>  int position = int(found - numbers.begin());<br/>  cout &lt;&lt; "Found last sequence match starting at: " &lt;&lt; position<br/>       &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="494e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个程序中，<code class="fe mh mi mj mk b">find_end</code>函数在数字向量中寻找序列8，1，2的最后一个匹配。以下是该程序的输出:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="f63c" class="mu lf it mk b gy mv mw l mx my">Found last sequence match starting at: 11</span></pre><p id="7193" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果该函数找不到匹配项，它将返回容器的末尾，表明它已到达容器的末尾，但没有找到匹配项。</p><p id="975f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个版本的<code class="fe mh mi mj mk b">find_end</code>可以有第五个参数，这是一个谓词函数，可以用作标准。下面是这个版本的<code class="fe mh mi mj mk b">find_end</code>的语法模板:</p><p id="3a77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> find_end(range-start，range-end，seq-start，seq-end，谓词函数)；</em></p><p id="0d08" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下示例演示了该函数的工作原理。该程序生成一个由50个随机生成的数字组成的向量。还有第二个向量有三个<code class="fe mh mi mj mk b">even</code>值。<code class="fe mh mi mj mk b">find_end</code>函数在数字向量中查找三个偶数值的最后一个序列，并报告该值。</p><p id="ad12" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">程序如下:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="e88d" class="mu lf it mk b gy mv mw l mx my">bool isEven(int number, bool even) {<br/>  if (even) {<br/>    return number % 2 == 0;<br/>  }<br/>  else {<br/>    return number % 2 == 1;<br/>  }<br/>}</span><span id="7e93" class="mu lf it mk b gy mz mw l mx my">int main () {<br/>  srand(time(0));<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 50);<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl;<br/>  vector&lt;bool&gt; threeEvens = {true, true, true};<br/>  auto found = find_end(numbers.begin(), numbers.end(),<br/>                        threeEvens.begin(), threeEvens.end(),<br/>                        isEven);<br/>  if (found != numbers.end()) {<br/>    cout &lt;&lt; "The last sequence starts at: "<br/>         &lt;&lt; int(found-numbers.begin()) &lt;&lt; endl;<br/>  }<br/>  else {<br/>    cout &lt;&lt; "No sequence like that found." &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="794d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我必须创建一个更复杂的谓词函数，因为<code class="fe mh mi mj mk b">find_end</code>函数期望谓词接受两个参数，而不是一个。</p><p id="8b4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序运行一次的输出是:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="b3df" class="mu lf it mk b gy mv mw l mx my">97 41 76 78 49 61 56 93 53 5<br/>24 65 39 61 99 24 14 11 2 91<br/>84 87 71 33 4 63 16 18 19 79<br/>61 89 90 50 66 28 31 27 29 63<br/>19 33 26 8 17 11 64 85 41 86</span><span id="5cd4" class="mu lf it mk b gy mz mw l mx my">The last sequence starts at: 33</span></pre><p id="d3cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该组中的最后一个功能是<code class="fe mh mi mj mk b">find_first_of</code>功能。该函数返回一个范围中第一个元素的位置，该范围与作为第二组参数给出的序列中的任何元素相匹配。以下是该函数的语法模板:</p><p id="191b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> find_first_of(range-start，range-end，seq-start，seq-end)；</em></p><p id="33fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个演示如何使用<code class="fe mh mi mj mk b">find_first_of</code>的程序:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="4106" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  srand(time(0));<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 50);<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl;<br/>  list&lt;int&gt; sequence {50, 51, 52};<br/>  auto found = find_first_of(numbers.begin(), numbers.end(),<br/>                             sequence.begin(), sequence.end());<br/>  if (found != numbers.end()) {<br/>    cout &lt;&lt; "Found sequence starting at: "<br/>         &lt;&lt; int(found-numbers.begin()) &lt;&lt; endl;<br/>  }<br/>  else {<br/>    cout &lt;&lt; "Sequence not found." &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="9c14" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个程序运行一次的输出:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="e83e" class="mu lf it mk b gy mv mw l mx my">25 38 45 2 50 67 74 68 14 81<br/>59 26 98 88 4 42 84 50 79 9<br/>72 55 67 72 14 24 99 85 99 38<br/>9 77 84 7 57 79 90 92 52 5<br/>60 79 66 29 49 47 84 44 46 29</span><span id="6803" class="mu lf it mk b gy mz mw l mx my">Found sequence starting at: 4</span></pre><p id="435d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二种形式的<code class="fe mh mi mj mk b">find_first_of</code>函数将谓词函数作为最后一个参数，并返回容器中第一个元素的位置，当第二个序列中的任何元素匹配谓词的标准时，返回true。</p><p id="235c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个版本的<code class="fe mh mi mj mk b">find_first_of</code>的语法模板:</p><p id="dc26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> find_first_of(range-start，range-end，seq-start，seq-end，谓词函数)；</em></p><p id="55c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个使用这个版本的函数的例子。程序将返回numbers向量中大于50、51或52(实际上是52)的第一个值。代码如下:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="c4f1" class="mu lf it mk b gy mv mw l mx my">bool greaterThan(int number, int number1) {<br/>  return number &gt; number1;<br/>}</span><span id="926f" class="mu lf it mk b gy mz mw l mx my">int main () {<br/>  srand(time(0));<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 50);<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl;<br/>  list&lt;int&gt; sequence {50, 51, 52};<br/>  auto found = find_first_of(numbers.begin(), numbers.end(),<br/>                             sequence.begin(), sequence.end(),<br/>                             greaterThan);<br/>  cout &lt;&lt; "The first value greater than 50, 51, 52 is "<br/>       &lt;&lt; *found &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="3ad9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的几次运行:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="1503" class="mu lf it mk b gy mv mw l mx my">72 13 15 98 91 66 25 78 44 85<br/>34 45 65 100 8 49 28 48 79 10<br/>57 24 13 32 18 4 81 85 29 1<br/>78 82 73 79 75 19 30 99 13 49<br/>50 78 100 63 72 26 41 84 48 95</span><span id="44d4" class="mu lf it mk b gy mz mw l mx my">The first value greater than 50, 51, 52 is 72</span><span id="5c9a" class="mu lf it mk b gy mz mw l mx my">45 22 12 69 76 7 45 72 22 17<br/>95 79 78 20 44 64 57 45 3 66<br/>86 14 67 89 44 64 22 60 68 66<br/>88 17 21 36 97 61 12 7 24 29<br/>63 75 50 88 15 27 67 66 46 92</span><span id="43b4" class="mu lf it mk b gy mz mw l mx my">The first value greater than 50, 51, 52 is 69</span></pre><h1 id="0b54" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">邻接函数</h1><p id="2a21" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">adjacent_find</code>函数用于查找两个具有相同值的相邻容器元素。该函数返回容器范围中与其后续元素具有相同值的第一个元素。</p><p id="8987" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数有两种形式。第一种形式只接受一个范围。以下是该表单的语法模板:</p><p id="7974" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">相邻_查找(range-start，range-end)；</em></p><p id="0eae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个使用<code class="fe mh mi mj mk b">adjacent_range</code>功能的程序:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="332f" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  srand(time(0));<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 50);<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl;<br/>  auto found = adjacent_find(numbers.begin(), numbers.end());<br/>  if (found != numbers.end()) {<br/>    cout &lt;&lt; "Found two adjacent, equal values: "<br/>         &lt;&lt; *found &lt;&lt; endl;<br/>    cout &lt;&lt; "Found them at position: "<br/>         &lt;&lt; int(found-numbers.begin()) &lt;&lt; endl;<br/>  }<br/>  else {<br/>    cout &lt;&lt; "No adjacent, equal values were found." &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="5da3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是该程序几次运行的输出:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="40d7" class="mu lf it mk b gy mv mw l mx my">29 72 7 13 78 92 63 30 73 97<br/>19 41 98 98 18 87 24 59 68 1<br/>2 3 35 60 17 35 50 99 59 79<br/>32 39 62 3 56 39 40 29 2 80<br/>5 21 84 74 97 69 26 40 52 51</span><span id="1c07" class="mu lf it mk b gy mz mw l mx my">Found two adjacent, equal values: 98<br/>Found them at position: 12</span><span id="ad44" class="mu lf it mk b gy mz mw l mx my">70 2 34 59 53 33 58 29 75 74<br/>59 35 30 94 9 29 18 11 85 22<br/>49 23 13 76 53 10 14 26 72 100<br/>1 15 72 13 85 25 1 97 92 27<br/>12 31 4 34 73 31 24 78 47 23</span><span id="fdd7" class="mu lf it mk b gy mz mw l mx my">No adjacent, equal values were found.</span></pre><h1 id="096c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">比较范围</h1><p id="23cd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我要检查的下一组函数用于比较两个范围的容器元素。这些功能中的第一个是<code class="fe mh mi mj mk b">equal</code>。该函数比较两个区域，看它们是否包含相同顺序的相同元素。</p><p id="8e51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个函数有两种形式。第一种形式比较两个范围是否相等。下面是这种等号形式的语法模板:</p><p id="3f25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">相等(范围1-开始，范围1-结束，范围2-开始)；</em></p><p id="d5b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，该函数只取第二个范围的开始。</p><p id="1676" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个使用equal来比较两个容器的程序:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="bfcc" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  vector&lt;int&gt; numbers = {2,1,4,3};<br/>  list&lt;int&gt; nums = {1,2,3,4};<br/>  if (equal(numbers.begin(), numbers.end(),<br/>            nums.begin())) {<br/>    cout &lt;&lt; "numbers and nums are equal." &lt;&lt; endl;<br/>  }<br/>  else {<br/>    cout &lt;&lt; "numbers and nums are not equal." &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="d0eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序将显示两个容器不相等。然而，如果numbers向量已经用<code class="fe mh mi mj mk b">{1,2,3,4}</code>初始化，那么这两个容器将是相等的。</p><p id="95c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二种形式的函数将谓词函数作为第四个参数，并使用谓词来比较两个范围是否相等。下面是该等号形式的语法模板:</p><p id="92be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> equal(range1-start，range1-end，range2-start，谓词-函数)；</em></p><p id="f616" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个演示这种形式的<code class="fe mh mi mj mk b">equal</code>的程序:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="6a76" class="mu lf it mk b gy mv mw l mx my">bool greaterThanFive(int element1, int element2) {<br/>  return (element1 &gt; 5 &amp;&amp; element2 &gt; 5);<br/>}</span><span id="5642" class="mu lf it mk b gy mz mw l mx my">int main () {<br/>  srand(time(0));<br/>  vector&lt;int&gt; numbers, numbers1;<br/>  buildVec(numbers, 10);<br/>  buildVec(numbers1, 10);<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl;<br/>  printVec(numbers1);<br/>  cout &lt;&lt; endl;<br/>  if (equal(numbers.begin(), numbers.end(),<br/>            numbers1.begin(), greaterThanFive)) {<br/>    cout &lt;&lt; "Both containers have all elements &gt; 5." &lt;&lt; endl;<br/>  }<br/>  else {<br/>    cout &lt;&lt; "Both containers do not have all elements &gt; 5."<br/>         &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="553a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是该程序两次运行的输出:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="6fe7" class="mu lf it mk b gy mv mw l mx my">30 49 11 73 25 32 30 11 63 20</span><span id="1106" class="mu lf it mk b gy mz mw l mx my">29 83 13 12 36 47 8 14 80 76</span><span id="673e" class="mu lf it mk b gy mz mw l mx my">Both containers have all elements &gt; 5.</span><span id="99b0" class="mu lf it mk b gy mz mw l mx my">29 41 82 75 22 18 81 55 62 4</span><span id="072d" class="mu lf it mk b gy mz mw l mx my">7 70 96 30 70 94 5 73 50 89</span><span id="6c5c" class="mu lf it mk b gy mz mw l mx my">Both containers do not have all elements &gt; 5.</span></pre><p id="ca1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这组函数中比较范围的下一个函数是<code class="fe mh mi mj mk b">is_permutation</code>。该函数检查两个范围的容器元素，并确定第一个范围的元素是否是第二个范围的排列。</p><p id="0a18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数的第一个版本采用容器的开始和停止范围进行比较，并采用容器元素的第二个开始范围进行比较。下面是这个版本的<code class="fe mh mi mj mk b">is_permutation</code>的语法模板:</p><p id="3e81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> is_permutation(range1-start，range1-end，range 2-start)；</em></p><p id="9660" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个演示如何使用这个版本的<code class="fe mh mi mj mk b">is_permutation</code>的程序:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="1838" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  vector&lt;int&gt; nums = {1,2,5,4};<br/>  list&lt;int&gt; numbers = {4,1,3,2};<br/>  if (is_permutation(numbers.begin(), numbers.end(),<br/>                     nums.begin())) {<br/>    cout &lt;&lt; "numbers is a permutation of nums." &lt;&lt; endl;<br/>  }<br/>  else {<br/>    cout &lt;&lt; "numbers is not a permutation of nums." &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="ad21" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="7cda" class="mu lf it mk b gy mv mw l mx my">numbers is a permutation of nums.</span></pre><p id="8b8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个版本的<code class="fe mh mi mj mk b">is_permutation</code>采用了一个额外的参数——一个用于比较两个容器范围的谓词函数。以下是此版本函数的语法模板:</p><p id="9998" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">is _ permutation(range 1-start，range1-end，range2-start，谓词-函数)；</em></p><p id="f379" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的示例中，两个范围用谓词函数进行比较，该函数检查容器的每个元素是否小于或等于4。代码如下:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="dde7" class="mu lf it mk b gy mv mw l mx my">bool lessEqualFour(int element1, int element2) {<br/>  return (element1 &lt;= 4 &amp;&amp; element2 &lt;= 4);<br/>}</span><span id="90f3" class="mu lf it mk b gy mz mw l mx my">int main () {<br/>  vector&lt;int&gt; nums = {0,2,3,4};<br/>  list&lt;int&gt; numbers = {4,1,3,2};<br/>  if (is_permutation(numbers.begin(), numbers.end(),<br/>                     nums.begin(), lessEqualFour)) {<br/>    cout &lt;&lt; "numbers is a permutation of nums." &lt;&lt; endl;<br/>  }<br/>  else {<br/>    cout &lt;&lt; "numbers is not a permutation of nums." &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="ef8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="9cf3" class="mu lf it mk b gy mv mw l mx my">numbers is a permutation of nums.</span></pre><h1 id="de82" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">找出两个范围的差异</h1><p id="5c27" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我要讨论的下一个函数会告诉你什么时候一个容器的元素不再匹配另一个容器的元素。这个功能叫做<code class="fe mh mi mj mk b">mismatch</code>。该函数返回一个<code class="fe mh mi mj mk b">pair</code>，其中<code class="fe mh mi mj mk b">first</code>字段包含第一个不匹配的元素，而<code class="fe mh mi mj mk b">second</code>字段包含第二个不匹配的元素。</p><p id="a7a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个函数有两个版本:一个只接受范围作为参数，另一个接受谓词函数进行比较。以下是这两个版本的语法模板:</p><p id="1f73" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">不匹配(范围1-开始，范围1-结束，范围2-开始)；<br/>不匹配(范围1-开始，范围1-结束，范围2-开始，谓词-函数)；</em></p><p id="ebdd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的程序演示了第一个版本的<code class="fe mh mi mj mk b">mismatch</code>是如何工作的:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="2651" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  vector&lt;int&gt; nums = {1,2,3,4,5,6};<br/>  list&lt;int&gt; numbers = {1,2,4,5,6};<br/>  auto unmatched = mismatch(nums.begin(), nums.end(),<br/>                            numbers.begin());<br/>  if (unmatched.first != nums.end()) {<br/>    cout &lt;&lt; "The first mismatch is: " &lt;&lt; *unmatched.first<br/>         &lt;&lt; endl;<br/>    cout &lt;&lt; "The second mismatch is: " &lt;&lt; *unmatched.second<br/>         &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="9645" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="dd68" class="mu lf it mk b gy mv mw l mx my">The first mismatch is: 3<br/>The second mismatch is: 4</span></pre><p id="e94c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一个程序演示了如何使用第二版的<code class="fe mh mi mj mk b">mismatch</code>。这一次比较是检查偶数，如果在第一个范围内发现奇数，将进行报告。程序是这样的:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="fa1a" class="mu lf it mk b gy mv mw l mx my">bool bothEven(int element1, int element2) {<br/>  return (element1 % 2 == 0 &amp;&amp; element2 % 2 == 0);<br/>}</span><span id="9183" class="mu lf it mk b gy mz mw l mx my">int main () {<br/>  vector&lt;int&gt; nums = {2,4,6,8,10,11,12};<br/>  list&lt;int&gt; numbers = {2,4,6,8,10,12,14};<br/>  auto unmatched = mismatch(nums.begin(), nums.end(),<br/>                            numbers.begin(), bothEven);<br/>  if (unmatched.first != nums.end()) {<br/>    cout &lt;&lt; "The first mismatch is: " &lt;&lt; *unmatched.first<br/>         &lt;&lt; endl;<br/>    cout &lt;&lt; "The second mismatch is: " &lt;&lt; *unmatched.second<br/>         &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><h1 id="a806" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">下一组算法</h1><p id="7e8c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这就完成了我对STL的非可变算法的回顾。我没有涵盖每一个函数，但我检查了其中的大部分。接下来是一组可以改变容器顺序的算法。</p><p id="b31a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请给我发电子邮件提出意见和建议。</p></div></div>    
</body>
</html>