<html>
<head>
<title>Quines: Computer programs that reproduce</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">奎因:复制的计算机程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/quines-20ad5bd5d469?source=collection_archive---------12-----------------------#2020-11-02">https://levelup.gitconnected.com/quines-20ad5bd5d469?source=collection_archive---------12-----------------------#2020-11-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b67f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">…以及用C++语言编写的一个走过的建筑。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d56171fb17bd5f6e41fce0588add1ae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bk_KXLF25wbtYdD9SQHWug.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">quine是一个在执行时输出其源代码的程序</figcaption></figure><h1 id="4559" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">介绍</h1><p id="b0f5" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">蒯因被定义为<code class="fe mj mk ml mm b">a computer program which takes no input and produces a copy of its own source code as its only output.</code>它们赋予计算机程序一个非常重要的功能——繁殖。例如，查询(他们称之为过程)可以被用作计算机病毒通过网络设备繁殖和传播的一种方法。</p><p id="6143" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">因此，在计算机编程的知识中，蒯因通常被用作有趣的挑战，但是研究它们来写这篇博客让我了解了计算机理论的一些有趣的领域——lambda编程就是其中之一。我期待着探索它，并讨论蒯因的理论方面，作为这个博客的延伸。在这篇文章中，我将带你了解这个概念，并带你了解我在C++中从头构建一个quine的思想过程，以及语言本身的属性如何帮助我们解决这个问题。</p><h1 id="f585" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">奎因的规则</h1><p id="e282" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">规则相当简单。程序在编译和执行时，需要输出自己的源代码。它必须这样做<em class="ms">，而不使用IO来读取自己的源代码文件</em>。换句话说，像这样的外壳程序是不允许的:</p><p id="e1b4" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated"><code class="fe mj mk ml mm b">cat script.sh</code></p><p id="b57e" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">同样，不允许用<code class="fe mj mk ml mm b">scanf()</code>或<code class="fe mj mk ml mm b">file()</code>访问源代码文件并打印出来。为了保持挑战的趣味性，空程序也是不允许的。从技术上讲，它输出自己的源代码，即空字符串，但这难道不是一个无聊的解决方案吗？</p><h1 id="93cd" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">任何语言中的奎因</h1><p id="cbf4" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在编程世界中，编写一个查询的可能性并不是偶然或新奇的。奎因可以用任何图灵完整语言来编写，这是一个叫做<em class="ms">克林不动点定理</em>的定理的直接结果。我们将在单独的博客中讨论定理和证明。</p><h1 id="d81b" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated"><strong class="ak">让我们建造一个</strong></h1><blockquote class="mt mu mv"><p id="5028" class="ln lo ms lp b lq mn jr ls lt mo ju lv mw mp ly lz mx mq mc md my mr mg mh mi ij bi translated">在我们开始之前，我鼓励你尝试用任何一种编程语言编写一个查询。</p></blockquote><p id="f54e" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">我花了一些时间来理解我在学习中的想法，我尽力把它分解成步骤。一定要花时间通读代码片段并理解发生了什么，您可以移动到提琴上查看输出或分叉代码，以在任何时候测试您自己的想法。我很想知道你选择的其他道路，以及它们会把你引向何方；请在评论中加入你的想法吧！</p><p id="1dd1" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated"><strong class="lp ir">骷髅</strong></p><p id="79d7" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">你可以一次就写出这么多的quine，基本思路是尝试用打印语句打印出源代码。</p><pre class="kg kh ki kj gt mz mm na nb aw nc bi"><span id="ea16" class="nd kw iq mm b gy ne nf l ng nh">#include &lt;iostream&gt;<br/>using namespace std;</span><span id="6054" class="nd kw iq mm b gy ni nf l ng nh">int main() {<br/> cout &lt;&lt; "#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\ncout &lt;&lt; <strong class="mm ir">&lt;the-quoted-text&gt;</strong>;\nreturn 0;\n}";<br/> return 0;<br/>}</span></pre><p id="6aeb" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated"><a class="ae nj" href="https://ideone.com/u3a6lZ" rel="noopener ugc nofollow" target="_blank">https://ideone.com/u3a6lZ</a></p><p id="f294" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated"><strong class="lp ir">自我参考</strong></p><p id="b8d4" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">您需要处理对<code class="fe mj mk ml mm b">&lt;the-quoted-text&gt;</code>的自我引用，以完整地打印打印声明本身。作为第一次尝试，我使用了一个不同的变量。我还试图将源代码分成3部分:<code class="fe mj mk ml mm b">beginning</code>、<code class="fe mj mk ml mm b">end</code>和<code class="fe mj mk ml mm b">the_quoted_text</code>。</p><pre class="kg kh ki kj gt mz mm na nb aw nc bi"><span id="7a5f" class="nd kw iq mm b gy ne nf l ng nh">#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>using namespace std;</span><span id="c18a" class="nd kw iq mm b gy ni nf l ng nh">int main() {<br/> string beginning = "#include &lt;iostream&gt;;\n#include &lt;string&gt;;\nusing namespace std;\n\nint main() {\nstring beginning = <strong class="mm ir">&lt;beginning&gt;</strong>\nstring end = <strong class="mm ir">&lt;end&gt;</strong>\n \ncout &lt;&lt;"; <br/> string end = ";\nreturn 0;\n}";<br/> string the_quoted_text = beginning + end;<br/> cout &lt;&lt; beginning &lt;&lt; the_quoted_text &lt;&lt; end;<br/> return 0;<br/>}</span></pre><p id="9101" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated"><a class="ae nj" href="https://ideone.com/kHKgON" rel="noopener ugc nofollow" target="_blank">https://ideone.com/kHKgON</a></p><p id="501f" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">我们仍然需要对变量<code class="fe mj mk ml mm b">beginning</code> <br/>和<code class="fe mj mk ml mm b">end</code>进行自引用，因此我尝试重用变量进行自引用，并以如下程序结束:</p><pre class="kg kh ki kj gt mz mm na nb aw nc bi"><span id="a102" class="nd kw iq mm b gy ne nf l ng nh">#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>using namespace std;</span><span id="c970" class="nd kw iq mm b gy ni nf l ng nh">int main() {<br/> string beginning = "#include &lt;iostream&gt;;\n#include &lt;string&gt;;\nusing namespace std;\n\nint main() {\nstring beginning = "; <br/> cout &lt;&lt; beginning &lt;&lt; "\"" &lt;&lt; beginning &lt;&lt; "\"" &lt;&lt; endl;<br/> cout &lt;&lt; "cout &lt;&lt; beginning &lt;&lt; \"\\\"\" &lt;&lt; beginning &lt;&lt; \"\\\"\" &lt;&lt; endl; \n...\nreturn 0;\n}";<br/> return 0;<br/>}</span></pre><p id="fb5a" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated"><a class="ae nj" href="https://ideone.com/QnEN4h" rel="noopener ugc nofollow" target="_blank">https://ideone.com/QnEN4h</a></p><p id="eec5" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">但是这导致了另一个循环陷阱，第二个<code class="fe mj mk ml mm b">cout</code>语句没有被考虑。你如何解决这个问题？</p><p id="5bac" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated"><strong class="lp ir"> C++ printf函数来拯救</strong></p><p id="0859" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">C/C++的<code class="fe mj mk ml mm b">printf</code>函数可以更直接地解析自我引用，因为我们可以在同一个变量中拥有完整的源代码(开始+引用文本(作为变量)+结束)，并且<strong class="lp ir">在打印时直接格式化字符串</strong>。</p><pre class="kg kh ki kj gt mz mm na nb aw nc bi"><span id="236e" class="nd kw iq mm b gy ne nf l ng nh">#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>using namespace std;</span><span id="8ae1" class="nd kw iq mm b gy ni nf l ng nh">int main() {<br/> char* fullString = "#include &lt;iostream&gt;;\n#include &lt;string&gt;;\nusing namespace std;\n\nint main() {\nstring fullString = \"%s;\nprintf(fullString, fullString);\nreturn 0;\""; <br/> printf(fullString, fullString);<br/> return 0;<br/>}</span></pre><p id="b9b6" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated"><a class="ae nj" href="https://ideone.com/FJouWb" rel="noopener ugc nofollow" target="_blank">https://ideone.com/FJouWb</a></p><p id="f63e" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">这一个几乎是正确的，除了正确地印刷<code class="fe mj mk ml mm b">\</code>。我们使用ascii字符的属性(34代替一个<code class="fe mj mk ml mm b">"</code>字符)来逃避“反斜杠地狱”。</p><pre class="kg kh ki kj gt mz mm na nb aw nc bi"><span id="9840" class="nd kw iq mm b gy ne nf l ng nh">#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>using namespace std;<br/>int main() {<br/> char q = 34;<br/> char* fullString = "#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() {char q = 34;char* fullString = %c%s%c;printf(fullString, q, fullString, q);return 0;}"; <br/> printf(fullString, q, fullString, q);<br/> return 0;<br/>}</span></pre><p id="6183" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated"><a class="ae nj" href="https://ideone.com/8Umk5e" rel="noopener ugc nofollow" target="_blank">https://ideone.com/8Umk5e</a></p><h1 id="8b6a" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">奎因的传说</h1><p id="689e" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">对于程序员来说，试图用特定的语言编写最短的程序是一个常见的挑战。程序员也用其他类似quine-relays的变种来挑战自己(例如，Java程序输出C++程序的源代码，c++程序输出原始的Java源代码。)和multi-quines(n种不同语言的不同程序，能够根据输入参数输出其中任何一种)。人们经常注意到，尝试用一种编程语言编写一个查询可以帮助编码者跨越理解这种语言的心理障碍。</p><p id="4d92" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">只是为了增加趣味性…在Mysql中也可以构建一个查询！<br/> <a class="ae nj" href="https://joshduff.com/2008-11-29-my-accomplishment-for-the-day-a-mysql-quine.md" rel="noopener ugc nofollow" target="_blank">看看乔希·达夫的这首歌</a></p><h1 id="b728" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">奎因的用途</h1><p id="67f5" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我发现“蒯因的概念”最重要的用途是作为哥德尔的不完全性假设的必要步骤，一旦我理解了这个假设，我希望能写出来。</p><p id="6ece" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">如前所述，Quining可用于编写自行传播的计算机病毒，而其他更简单的选项如“多次复制病毒文件”会被反病毒软件阻止/检测到。我们可以利用更多有感知能力的人工智能来进行量化，谁知道这会把我们引向何方？</p><p id="651b" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">如果你喜欢读这篇文章，可以看看我在<a class="ae nj" rel="noopener ugc nofollow" target="_blank" href="/template-metaprogramming-a-c-walkthrough-a7c6db0b4148">template-meta programming</a>上的文章，编写代码片段，在编译期间将它们构建成静态代码方法。</p><p id="aa94" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated"><strong class="lp ir">参考文献</strong></p><p id="d015" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">[1]:蒯因(自我复制程序)【http://www.madore.org/~david/computers/quine.html#sec_fp T4】</p></div></div>    
</body>
</html>