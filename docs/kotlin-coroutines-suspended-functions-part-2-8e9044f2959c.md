# Kotlin 协程(第 2 部分)——暂停函数

> 原文：<https://levelup.gitconnected.com/kotlin-coroutines-suspended-functions-part-2-8e9044f2959c>

![](img/c42cf4312238408a17f4cb96f43d2fd2.png)

马库斯·斯皮斯克在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

在本系列的[第 1 部分](https://medium.com/@faizanwar027/kotlin-coroutines-basics-part1-617389b168f8)中，我们从较高的层面观察了协程，看到了它们比传统线程更优越的性能。我们还了解了当协程和线程执行长时间运行的任务时会发生什么。既然我们现在已经熟悉了如何启动协程并在没有任何线程分配或内存泄漏的情况下获得异步结果，我们将研究协程为代码增值的另一个方面。

协程为我们提供了一个机会，通过控制流程并在可用时返回值，为长时间运行的任务编写顺序风格的代码。换句话说，它们**允许暂停代码执行，并在达到预期结果后继续执行**，而无需我们编写任何回调或通知机制。在我们深入了解这是如何发生的之前，让我们快速回忆一下目前在没有协程的 Android 中异步操作是如何处理的。

# Android 中没有协程的回调

让我们举一个简单的例子，我们在短暂的延迟后执行一个任务。

我们看到 getUserFromAPI()接受一个字符串值和一个回调对象，以便在结果可用时传回结果。为了模拟长时间运行的操作，我使用了 Thread.sleep(1000 ),让当前线程休眠一毫秒。线程唤醒后，它使用我们从主函数传递的字符串创建一个用户对象，并将其返回给主函数。如果上面的 println 代码没有放在回调函数中，我们的代码就会崩溃，因为它的值还没有初始化。让我们看看如何使用协程挂起函数以更简洁的方式编写相同的代码。

# 使用挂起的函数来清理代码

一个**暂停功能**是一个**功能**，可以暂停并在以后恢复。他们可以执行一个长时间运行的操作，并在不阻塞任何线程的情况下等待它完成。

重要的是要知道一个挂起的函数只能从协程或另一个挂起的函数中调用。否则会导致编译错误。

> 如您所见，您需要做的就是启动一个协程来卸载主线程。依靠来自协程 API 的内部线程，所以没有创建新线程的额外开销。按顺序编写代码**，即使它是**异步的**，并在调用点使用 try/catch 块，即使值可以异步产生。**

# **引擎盖下发生了什么**

**我们在这里试图实现的目标之一是不管代码是异步的还是同步的，都有一个一流的延续。正是这个**延续****操纵程序调用栈内部的执行流。它可以被描述为围绕程序的**控制状态**的抽象包装器，其中控制程序将如何以及何时进一步执行，以及它的结果将是什么——异常还是值。****

****一旦一个函数执行完毕，程序就将它从堆栈中取出，并继续执行下一个函数。诀窍在于系统如何知道每个函数执行后返回到哪里。该信息保存在前述的**延续**中。每个延续都包含一些关于调用函数的**上下文**的信息。像局部变量、函数传递的参数、调用它的线程等等。通过使用这些信息，当一个函数结束时，系统可以简单地依靠延续来告诉它需要在哪里。****

# ****下一步是什么****

****在下一篇文章中，我们将回顾开发人员为使异步编程更加优雅而采用的方法以及他们学到的经验。我们还将学习如何构建更干净、更复杂的机制，这些机制不会阻塞，可以异步或并行工作。在那之前，请继续关注并快乐编码！****

****[](/kotlin-coroutines-async-await-part-3-6108bf6be5c4) [## Kotlin 协同程序-异步/等待(第 3 部分)

### 在上一篇文章中，我们了解了协程提供的暂停函数以及它们给应用程序带来的价值

levelup.gitconnected.com](/kotlin-coroutines-async-await-part-3-6108bf6be5c4)****