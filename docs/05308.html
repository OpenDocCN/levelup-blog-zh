<html>
<head>
<title>Golang Fantasy Hunting App, 1: Deploying a Golang App to Lambda on AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang奇幻狩猎应用，1:在AWS上将Golang应用部署到Lambda</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/golang-fantasy-hunting-app-1-deploying-a-golang-app-to-lambda-on-aws-f9b950648bae?source=collection_archive---------2-----------------------#2020-08-18">https://levelup.gitconnected.com/golang-fantasy-hunting-app-1-deploying-a-golang-app-to-lambda-on-aws-f9b950648bae?source=collection_archive---------2-----------------------#2020-08-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c53c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">猎杀怪物，学习围棋</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3674832b5a0f108d39df98ca309c52e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QGwWOQObSu4q0K-v43h-hg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@polarmermaid?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">安妮·尼加德</a>在<a class="ae ky" href="https://unsplash.com/s/photos/monster?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="e1ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时候我有种奇怪的冲动，不想自责。当这种情况发生时，我停止摆弄Java、Javascript或Python，转身就走。Go是快速、轻量级和静态类型的。它的包装管理系统是一个梦想。你可以在大约三秒钟内开始使用Go，这比计算出微软在创建Typescript时所想的时间要快200万倍。</p><p id="a408" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们将使用Golang、DynamoDB、AWS Lambda和API Gateway编写和部署整个后端的系列文章的第一篇。我的目的是向您展示在Go中编写后端有多好。如果我成功地说服了你，那么这将是一个值得的过程。如果我不是，那也是值得的，因为那时你会明白你讨厌自己，你可以寻求专业的帮助。</p><h2 id="fac3" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated"><strong class="ak">我们将建造什么</strong></h2><p id="aca4" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">最终，一个幻想狩猎日志应用程序的后端，你可以添加新的怪物，查看所有条目，并记录杀戮。</p><p id="7883" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇特定的文章中，我们将创建第一个lambda(保存和更新),没有任何dynamo集成，将其部署到AWS并证明它是可行的。</p><h2 id="c607" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated"><strong class="ak">你需要什么</strong></h2><p id="dc2f" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">走吧。我不能比官方文件更好地解释安装过程，所以在这里查看这些<a class="ae ky" href="https://golang.org/doc/install#install" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="3b8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还需要一个AWS帐户和某种代码编辑器(我使用VSCode)。</p><h2 id="94a3" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated"><strong class="ak">创建Lambda </strong></h2><p id="a774" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">在我们进行任何编码之前，我们需要在AWS中创建一个lambda。转到lambda控制台(<a class="ae ky" href="https://eu-west-1.console.aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank">此处为</a>)并点击“创建功能”。输入函数名，并确保从运行时下拉菜单中选择<code class="fe mu mv mw mx b">Go 1.x</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/82b0d663d0fa852e384e68af3cc2ce71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SUlvl6ATwLNKikJnwMS0PA.png"/></div></div></figure><p id="e362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他一切保持原样，点击底部的“创建函数”。创建完成后，向下滚动到“基本设置”窗口并点击“编辑”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/26bd9bed8025ef0f25ca4ced83b46d6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3eQC0mfcyeN6O3CytChBkg.png"/></div></div></figure><p id="a259" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将“处理程序”从<code class="fe mu mv mw mx b">hello</code>更改为<code class="fe mu mv mw mx b">main</code>，因为我们的文件名为<code class="fe mu mv mw mx b">main.go</code>。</p><p id="1b9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">省省吧，暂时就这样。</p><p id="97c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">写代码</strong></p><p id="b8c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将创建一个lambda来接收HTTP请求，并将我们的<code class="fe mu mv mw mx b">monster</code>作为JSON负载。然后，我们将把JSON转换成我们的monster类型，并只返回名称。如果我们先把这三件事做好，那么我们就可以专注于dynamo，而不用担心程序中其他地方的错误。</p><p id="e529" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设你已经安装了Go，在你的电脑上创建一个名为<code class="fe mu mv mw mx b">fantasy-hunt</code>和<code class="fe mu mv mw mx b">cd</code>的目录。然后，创建一个名为<code class="fe mu mv mw mx b">save-and-update</code>的文件夹。</p><p id="072c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个目录将包含一个<code class="fe mu mv mw mx b">main.go</code>文件，我们将在这里为我们的<code class="fe mu mv mw mx b">save-and-update</code> lambda编写主入口点代码。稍后我们将有一个<code class="fe mu mv mw mx b">get-all</code> lambda，它将有自己的<code class="fe mu mv mw mx b">main.go</code>文件。</p><p id="4f3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">类型</em></p><p id="0a07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，在我们开始编写任何主代码之前，我通常喜欢定义我们的程序将使用的类型。设计强数据类型是加速开发和避免运行时错误的最佳方式。数据就是一切。没有它，编程就没有意义了。</p><p id="0365" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的节目只会有一种类型:<code class="fe mu mv mw mx b">monster</code>。在您的<code class="fe mu mv mw mx b">fantasy-hunt</code>目录中创建一个<code class="fe mu mv mw mx b">types</code>文件夹，然后在其中创建一个<code class="fe mu mv mw mx b">monster.go</code>文件，看起来应该像这样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="6fa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是你如何在Go中定义一个复杂类型，它有点像其他语言中的类，但是在Go中被称为<code class="fe mu mv mw mx b">structs</code>。这个是一个叫做Monster的struct，有三个属性:ID，Name，Hunted。</p><p id="d423" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个属性都由三部分组成，一个名称、一个类型和一个用于将对象映射到json的字符串。希望名称和类型部分是不言自明的。json部分，即<code class="fe mu mv mw mx b">`json:”id”`</code>告诉Go的<code class="fe mu mv mw mx b">json</code>库该字段应该映射到json有效载荷的哪个部分。例如，如果我们试图将一个json有效负载转换成一个monster对象，那么json库将会读取其中的每一个，并确定json中的<code class="fe mu mv mw mx b">id</code>字段对应于结构的<code class="fe mu mv mw mx b">Id</code>字段，等等。</p><p id="0dd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能已经注意到结构名和所有属性名都是大写的。这很重要。在Go中，对字段、对象和方法的访问是通过大写来控制的。如果这些名称中的任何一个以大写字母开头，就意味着它可以在定义它的直接文件之外被访问。如果它以小写字母开头，它就不是。所以在这里，因为<code class="fe mu mv mw mx b">Monster</code>和它的所有属性都是大写的，这意味着我们可以从另一个文件中引用这个类型，并且仍然可以访问它上面的所有内容。<code class="fe mu mv mw mx b">json</code>库也依赖于大写，因为它必须在封送处理时访问结构体上的字段(我们马上会看到封送处理)。</p><p id="e0e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后是顶部的包声明。这只是为代码定义了一种名称空间。因为它在<code class="fe mu mv mw mx b">types</code>文件夹中，我们就称它为类型。</p><p id="410b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">主文件</em></p><p id="eefc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主文件稍微复杂一点，所以我们将逐行处理。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><ul class=""><li id="b2e5" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">第一行</li></ul><p id="6d17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个包裹申报。因为这是主文件，所以我们将把这个包称为main，尽管这个文件夹叫做<code class="fe mu mv mw mx b">save-and-update</code>。</p><ul class=""><li id="cc54" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">第3–9行</li></ul><p id="18e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导入语句。Go的包管理系统允许你直接提取github repo并在你的代码中使用它们。这就是我们在这里为AWS lambda和events包所做的事情。一旦你在你的代码中定义了它们，你必须在你的终端中运行<code class="fe mu mv mw mx b">go get &lt;github-url&gt;</code>来将它们下载到你的机器上，例如<code class="fe mu mv mw mx b">go get github.com/aws/aws-lambda-go/lambda</code></p><p id="9006" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非github导入不需要您安装任何东西。第6行和第7行的代码来自Go标准库，该库预装了Go。我们使用<code class="fe mu mv mw mx b">net/http</code>来访问所有的HTTP StatusCode常量。我们使用<code class="fe mu mv mw mx b">encoding/json</code>解析JSON并将其转换成我们的结构类型。</p><p id="e670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第8行导入了我们的类型包。</p><ul class=""><li id="e951" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">第12–14行</li></ul><p id="3284" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个主Go包都需要一个主函数。这是我们运行Go程序时调用的函数。这个函数只调用<code class="fe mu mv mw mx b">lambda.Start(Handler)</code>，它告诉AWS当lambda被调用时，我们的<code class="fe mu mv mw mx b">Handler</code>函数(我们接下来会看到)应该被调用。</p><ul class=""><li id="0a3d" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">第17行</li></ul><p id="e474" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们的处理函数声明。它从<code class="fe mu mv mw mx b">events</code>包接收一个<code class="fe mu mv mw mx b">ApiGatewayProxyRequest</code>类型的参数<code class="fe mu mv mw mx b">req</code>。我们使用这种类型是因为我们稍后将与API Gateway集成。它返回<strong class="lb iu">两个</strong>东西；类型为<code class="fe mu mv mw mx b">ApiGatewayProxyResponse</code>的变量和一个错误。这是围棋中常见的模式。函数通常会返回实际值和一个错误值，如果错误值不是<code class="fe mu mv mw mx b">nil</code>(像其他语言中的null)，那么我们可以假设函数在某个地方失败了。我们马上会看到它的应用。</p><ul class=""><li id="deab" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">第18行</li></ul><p id="e3b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建一个类型为<code class="fe mu mv mw mx b">Monster</code>的变量。</p><ul class=""><li id="63fa" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">第20行</li></ul><p id="ee7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们将JSON有效负载转换成monster类型的地方，这就是<code class="fe mu mv mw mx b">Unmarshal</code>所做的。第一个参数必须是一个字节数组，所以我们通过调用<code class="fe mu mv mw mx b">[]byte(req.Body)</code>将<code class="fe mu mv mw mx b">req</code>参数的<code class="fe mu mv mw mx b">Body</code>字段转换为一个字节数组。第二个参数是我们创建的怪物对象。</p><p id="7f98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的<code class="fe mu mv mw mx b">&amp;</code>符号告诉Go我们想要通过引用传递我们的monster对象。这意味着在<code class="fe mu mv mw mx b">Unmarshal</code>函数中对monster对象进行的任何更改也应该在<code class="fe mu mv mw mx b">Handler</code>函数中对monster对象进行，也就是说，当<code class="fe mu mv mw mx b">Unmarshal</code>完成它的工作时，我们的monster字段将被填充，而不必显式返回它。</p><p id="ebe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mu mv mw mx b">Unmarshal</code>函数可能会返回一个错误，所以这就是为什么我们把它的结果放在一个<code class="fe mu mv mw mx b">err</code>对象中。我们使用特殊的<code class="fe mu mv mw mx b">:=</code>操作符，它有效地告诉Go创建对象，自己计算出类型，然后填充它，所有这些都是同时进行的，而不需要我们显式地去做。</p><ul class=""><li id="4caa" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">第22–24行</li></ul><p id="05e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是Go中错误处理的典型方式。如果在<code class="fe mu mv mw mx b">Unmarshal</code>函数中没有发生错误，<code class="fe mu mv mw mx b">err</code>将会是<code class="fe mu mv mw mx b">nil</code>，这意味着If语句不会执行。如果它确实执行了，它将返回调用我们的<code class="fe mu mv mw mx b">response</code>函数的结果，我们马上就会看到。我们还必须在这一行的末尾指定<code class="fe mu mv mw mx b">, nil</code>,因为这个函数应该返回2个东西，但是我们正在优雅地处理这个错误，所以我们可以让err对象为零。</p><ul class=""><li id="a1ac" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">第26行</li></ul><p id="a253" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将调用响应函数，并向它传递我们的monster的名称和http OK状态代码，因为至此我们已经成功地完成了我们想要做的事情。</p><ul class=""><li id="9d17" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">第29–37行</li></ul><p id="3ca0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们创建了一个函数，它接收一个主体和一个状态代码，然后返回amazon lambda期望我们返回的值的类型，一个<code class="fe mu mv mw mx b">events.ApiGatewayProxyResponse</code>。然后返回它，填充状态代码、主体和用于CORS目的的头映射。</p><p id="75f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">上传Lambda到AWS </em></p><p id="26ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在代码已经完成，我们可以构建和部署我们的lambda了。第一步是将我们的代码编译成linux二进制文件(aws lambda需要这样做)。</p><p id="77bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您的终端中，导航到您的<code class="fe mu mv mw mx b">save-and-update</code>文件夹并运行以下命令:</p><p id="c542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mu mv mw mx b">GOOS=linux GOARCH=amd64 go build -v main.go</code></p><p id="43ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这应该会在名为<code class="fe mu mv mw mx b">main</code>的文件夹中吐出一个二进制文件。</p><p id="a084" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用您的GUI，找到该文件并将其压缩到一个名为<code class="fe mu mv mw mx b">main.zip</code>的档案中。然后导航回你的lambda控制台，找到<code class="fe mu mv mw mx b">Function code</code>部分。选择<code class="fe mu mv mw mx b">Actions</code>下拉菜单，然后选择<code class="fe mu mv mw mx b">Upload a .zip file</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/72b39e2a4b94d4919e0d8a72b0625a2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O53fsswtRX4Qyzz5DrHrNQ.png"/></div></div></figure><p id="bf6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">找到你的<code class="fe mu mv mw mx b">main.zip</code>档案并上传。</p><p id="530c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦完成，我们就可以测试lambda是否如预期的那样工作。找到页面顶部的<code class="fe mu mv mw mx b">Test</code>按钮。它应该会打开一个模式，您可以在其中配置测试事件。找到事件模板下拉菜单并搜索<code class="fe mu mv mw mx b">Amazon API Gateway AWS Proxy</code>。当从API网关调用lambda时，这是将被发送到lambda的事件类型。</p><p id="3163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在应该填充事件有效负载了。找到顶部的<code class="fe mu mv mw mx b">body</code>属性并编辑它，这样您就可以传入:</p><pre class="kj kk kl km gt nm mx nn no aw np bi"><span id="1d58" class="lw lx it mx b gy nq nr l ns nt">"{ \"id\": \"1\", \"name\": \"A Scary Monster\", \"hunted\":true }"</span></pre><p id="417f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们庞大的JSON有效载荷的样子。为您的测试事件命名并保存它。</p><p id="85d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您点击<code class="fe mu mv mw mx b">Test</code>按钮，您的lambda应该会执行，您应该会看到如下响应:</p><pre class="kj kk kl km gt nm mx nn no aw np bi"><span id="e550" class="lw lx it mx b gy nq nr l ns nt">{<br/>  "statusCode": 200,<br/>  "headers": {<br/>    "Access-Control-Allow-Origin": "*"<br/>  },<br/>  "multiValueHeaders": null,<br/>  "body": "A Scary Monster"<br/>}</span></pre><p id="9d95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="d560" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个应用程序可以被幻想猎人使用之前，还有一点要做，但希望你已经体验过Go，并且它让你渴望更多。到目前为止，您已经学习了包、结构、函数、多重返回、错误处理、编译和部署到AWS。有了这个基础，我们就可以开始研究更复杂的东西了。但是它实际上从来不会变得太复杂，因为围棋太棒了。Go爱你。你也应该爱它。</p><p id="b786" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">你可以在这个</em> <a class="ae ky" href="https://github.com/z3n0tus/fantasy-log-basic" rel="noopener ugc nofollow" target="_blank"> <em class="lv">回购</em> </a> <em class="lv">中找到这篇文章的所有代码。</em></p></div></div>    
</body>
</html>