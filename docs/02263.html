<html>
<head>
<title>Simple Introduction to CSS Grid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CSS网格简单介绍</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/simple-introduction-to-css-grid-31a17922f12?source=collection_archive---------8-----------------------#2020-03-01">https://levelup.gitconnected.com/simple-introduction-to-css-grid-31a17922f12?source=collection_archive---------8-----------------------#2020-03-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/16e942084022fcd84fad3804ea8311ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*950Ukzyc8HrDxLtK"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@lanceanderson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">兰斯·安德森</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="9a7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">CSS grid让我们可以轻松地用CSS创建布局。</p><p id="9e98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也有利于创建响应式布局，因为我们可以将不同的项目组合在一起。</p><p id="5e5a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看如何定义一个网格布局，并使其具有响应性。</p><h1 id="d42d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">定义网格布局</h1><p id="8960" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用一些HTML和CSS定义一个网格布局。</p><p id="e1e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想定义4个div，其中一个是页眉，一个是左右div，中间有一个空格，还有一个是页脚，我们可以这样做。</p><p id="c30b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们添加HTML:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="328f" class="mq lf it mm b gy mr ms l mt mu">&lt;div class='container'&gt;<br/>  &lt;div class='item-a'&gt;<br/>    A<br/>  &lt;/div&gt;<br/>  &lt;div class='item-b'&gt;<br/>    B<br/>  &lt;/div&gt;<br/>  &lt;div class='item-c'&gt;<br/>    C<br/>  &lt;/div&gt;<br/>  &lt;div class='item-d'&gt;<br/>    D<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="d8ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们添加CSS:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fbe8" class="mq lf it mm b gy mr ms l mt mu">.item-a {<br/>  grid-area: header;<br/>  background-color: lightyellow;<br/>}</span><span id="7d25" class="mq lf it mm b gy mv ms l mt mu">.item-b {<br/>  grid-area: main;<br/>  background-color: lightgreen;<br/>}</span><span id="6803" class="mq lf it mm b gy mv ms l mt mu">.item-c {<br/>  grid-area: sidebar;<br/>  background-color: lightblue;<br/>}</span><span id="172c" class="mq lf it mm b gy mv ms l mt mu">.item-d {<br/>  grid-area: footer;<br/>  background-color: pink;<br/>}</span><span id="30db" class="mq lf it mm b gy mv ms l mt mu">.container {<br/>  display: grid;<br/>  grid-template-columns: 24vw 25vw 25vw 24vw;<br/>  grid-template-rows: auto;<br/>  grid-template-areas:<br/>    "header header header header"<br/>    "main main . sidebar"<br/>    "footer footer footer footer";<br/>}</span></pre><p id="eb5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到以下结果:</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/bab04a490a516e9f5d45d1d5b7ec7b77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*tn7h2MhHkTz3Wo5EklufKQ.png"/></div></figure><p id="e748" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">CSS有以下几个部分。</p><p id="29ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们看一下<code class="fe mx my mz mm b">container</code>类。这是网格中最重要的部分。</p><p id="aa15" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有<code class="fe mx my mz mm b">display: grid;</code>，它指定带有<code class="fe mx my mz mm b">container</code>类的div有一个网格布局。</p><p id="cc3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用<code class="fe mx my mz mm b">grid-template-columns</code>定义网格列，我们将它的值设置为<code class="fe mx my mz mm b">24vw 25vw 25vw 24vw</code>。</p><p id="4c57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们有4列，最左边和最右边的列有<code class="fe mx my mz mm b">24vw</code>，中间的列有<code class="fe mx my mz mm b">25vw</code>。</p><p id="fa1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们有<code class="fe mx my mz mm b">grid-template-rows: auto;</code>。我们将其保留为auto，因为我们不关心行的高度。</p><p id="ed6d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了用<code class="fe mx my mz mm b">container</code>类定义网格如何在div内部的组件之间共享，我们编写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a312" class="mq lf it mm b gy mr ms l mt mu">grid-template-areas:<br/>    "header header header header"<br/>    "main main . sidebar"<br/>    "footer footer footer footer";</span></pre><p id="c187" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用第一行中的<code class="fe mx my mz mm b">header</code>区域填充了第一行。</p><p id="bcb0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在新行中，我们用<code class="fe mx my mz mm b">main</code>区域填充最左边的两列。一个点代表空白区域，而<code class="fe mx my mz mm b">sidebar</code>区域代表最右边的列。</p><p id="7283" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在最下面一行，我们让<code class="fe mx my mz mm b">footer</code>区域填充整行。</p><p id="441a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以指定具有<code class="fe mx my mz mm b">item</code>类别的区域，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="29a6" class="mq lf it mm b gy mr ms l mt mu">.item-a {<br/>  grid-area: header;<br/>  background-color: lightyellow;<br/>}</span><span id="7fde" class="mq lf it mm b gy mv ms l mt mu">.item-b {<br/>  grid-area: main;<br/>  background-color: lightgreen;<br/>}</span><span id="0804" class="mq lf it mm b gy mv ms l mt mu">.item-c {<br/>  grid-area: sidebar;<br/>  background-color: lightblue;<br/>}</span><span id="e4cc" class="mq lf it mm b gy mv ms l mt mu">.item-d {<br/>  grid-area: footer;<br/>  background-color: pink;<br/>}</span></pre><p id="8a66" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们用<code class="fe mx my mz mm b">grid-area</code>将具有<code class="fe mx my mz mm b">item-a</code>类的东西指定为<code class="fe mx my mz mm b">header</code>，并设置背景颜色。</p><p id="45b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着任何具有类<code class="fe mx my mz mm b">item-a</code>的都将是填充顶行的<code class="fe mx my mz mm b">header</code>。</p><p id="fe41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们对其他3个类做同样的事情，所以任何有类<code class="fe mx my mz mm b">item-b</code>的都将填充第二行最左边的2列。具有类<code class="fe mx my mz mm b">item-c</code>的元素填充第二行最右边的列。具有类<code class="fe mx my mz mm b">item-d</code>的元素填充所有的底部行。</p><p id="f966" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是我们如何定义一个网格布局。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/b8bae427cc585bbc56c1a3174ad228a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IDeI_5OQSTeKfFh0"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@erol?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Erol Ahmed </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="48fb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">响应式布局</h1><p id="d780" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用CSS选择器定义一个响应式布局，并为窄屏幕添加一个新的布局。</p><p id="24e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以定义一个仅显示<code class="fe mx my mz mm b">header</code>、<code class="fe mx my mz mm b">main</code>和<code class="fe mx my mz mm b">footer</code>区域的窄屏幕布局，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="78e6" class="mq lf it mm b gy mr ms l mt mu">.item-a {<br/>  grid-area: header;<br/>  background-color: lightyellow;<br/>}</span><span id="4ee2" class="mq lf it mm b gy mv ms l mt mu">.item-b {<br/>  grid-area: main;<br/>  background-color: lightgreen;<br/>}</span><span id="b1a6" class="mq lf it mm b gy mv ms l mt mu">.item-c {<br/>  grid-area: sidebar;<br/>  background-color: lightblue;<br/>}</span><span id="930f" class="mq lf it mm b gy mv ms l mt mu">.item-d {<br/>  grid-area: footer;<br/>  background-color: pink;<br/>}</span><span id="3c51" class="mq lf it mm b gy mv ms l mt mu">.container {<br/>  display: grid;<br/>  grid-template-rows: auto;<br/>}</span><span id="d0d7" class="mq lf it mm b gy mv ms l mt mu"><a class="ae kf" href="http://twitter.com/media" rel="noopener ugc nofollow" target="_blank">@media</a> only screen and (min-width: 751px) {<br/>  .container {<br/>    grid-template-columns: 24vw 25vw 25vw 24vw;<br/>    grid-template-areas:<br/>      "header header header header"<br/>      "main main . sidebar"<br/>      "footer footer footer footer";<br/>  }<br/>}</span><span id="40ff" class="mq lf it mm b gy mv ms l mt mu"><a class="ae kf" href="http://twitter.com/media" rel="noopener ugc nofollow" target="_blank">@media</a> only screen and (max-width: 750px) {<br/>  .item-c {<br/>    display: none;<br/>  }</span><span id="f2f4" class="mq lf it mm b gy mv ms l mt mu">.container {<br/>    grid-template-columns: 90vw;<br/>    grid-template-rows: auto;<br/>    grid-template-areas:<br/>      "header"<br/>      "main"<br/>      "footer";<br/>  }<br/>}</span></pre><p id="c889" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们所做的就是当屏幕宽度小于或等于750像素时，用类<code class="fe mx my mz mm b">item-c</code>隐藏任何东西。否则，我们保持和以前一样的布局。</p><p id="48fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，我们只是稍微移动一下代码以防止重复。</p><p id="70ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们的屏幕变窄时，我们得到</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/a71875de7b7ea5df462e13cc87132009.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*JEvhlAgvq-olJbA5HSXyaw.png"/></div></figure><h1 id="71c4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="e235" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">使用CSS网格，制作布局比以往任何时候都容易。</p><p id="1409" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们将容器div设置为<code class="fe mx my mz mm b">display: grid</code>，使其成为网格的容器。</p><p id="20c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以定义布局，用<code class="fe mx my mz mm b">grid-template-columns</code>定义列，用<code class="fe mx my mz mm b">grid-template-rows</code>定义行。这将形成一个网格。</p><p id="1aa1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们设置<code class="fe mx my mz mm b">grid-template-areas</code>属性来定义我们的布局，一次一行。</p><p id="5d34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过使用CSS媒体查询，然后为不同的屏幕尺寸定义不同的布局来扩展这种响应。</p></div></div>    
</body>
</html>