<html>
<head>
<title>Using bcrypt to hash and compare passwords with Nodejs and MongoDB.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用bcrypt散列和比较Nodejs和MongoDB的密码。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-bcrypt-to-hash-and-compare-passwords-with-nodejs-and-mongodb-366ff80138b7?source=collection_archive---------3-----------------------#2020-04-03">https://levelup.gitconnected.com/using-bcrypt-to-hash-and-compare-passwords-with-nodejs-and-mongodb-366ff80138b7?source=collection_archive---------3-----------------------#2020-04-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="d867" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">毫无疑问，散列是任何存储敏感用户信息(如密码)的web应用程序的重要组成部分。那么，哈希是什么？哈希是将某个值转换成其他值的过程。散列函数是执行散列的函数。好的散列算法是其散列不能被解码或转换回其原始值的算法。</p><p id="5aa7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我将使用npm的bcrypt库。如需详细解释，请访问<a class="ae ko" href="https://www.npmjs.com/package/bcrypt" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="aa37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们必须安装bcrypt，以便打开您的首选终端并键入:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="304a" class="ky kz it ku b gy la lb l lc ld">npm install bcrypt</span></pre><p id="4be7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦安装了bcrypt，它就必须是必需的，如下所示:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="fa4a" class="ky kz it ku b gy la lb l lc ld">var bcrypt = require(“bcrypt”)</span></pre><p id="e54f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们继续把我们的密码转换成散列。假设从一个表单中提取数据，密码需要散列，有两个不同的函数可以使用:</p><p id="4c33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个是<strong class="js iu"> <em class="le"> hash() </em> </strong>函数，这个函数有两个参数。第一个是要散列的数据，第二个是salt或saltrounds。</p><p id="c4ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们来分析一下。</p><p id="4b81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">salt是一个额外的安全层，它被添加在哈希的开始，以在预先计算的哈希攻击的情况下保持密码的安全。salt是一个表示散列复杂度的数字。其值越高，密码被散列化的时间就越长。</p><p id="dd18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="le"> hash() </em> </strong>方法也有一个回调函数(回调函数将有error和result之类的参数)，它返回一个需要处理的承诺。下面是使用哈希函数的代码。它从表单中获取数据。启动服务器并运行这段代码。我的数据库使用Nodejs和MongoDb。</p><figure class="kp kq kr ks gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lf"><img src="../Images/ca6331c125f4315f1b5527bc9b75f42b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qyU__1rIH6TYvFKx23illA.png"/></div></div></figure><p id="eb8c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">哈希密码看起来有点像这样。</p><figure class="kp kq kr ks gt lg gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/3f2afbc7301d8de5edfee8811f89857e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*GiR9DZi8MqXj-i71TAb2KQ.png"/></div></figure><p id="4f0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个是散列密码。第二个是原密码。前7个字符是由<strong class="js iu"><em class="le">salt _ ROUND</em></strong><em class="le">生成的SALT。</em>这里它的值是12。</p><p id="c902" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二种方法是<strong class="js iu"> <em class="le"> hashSync() </em> </strong>方法，这相当简单，因为它只需要两个参数。第一个是要散列的数据或字符串，第二个是saltround。与<strong class="js iu"> <em class="le"> hash() </em> </strong>不同，该函数不返回承诺，而是返回散列输出。我更喜欢这种方法，因为它不涉及承诺，而且更简单。如果你想了解更多关于承诺的信息，请点击<a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="4d4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是<strong class="js iu"> <em class="le"> hashSync() </em> </strong>函数的代码。启动服务器并运行代码。</p><figure class="kp kq kr ks gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lo"><img src="../Images/a972a6224111b25487e20f4903dc1c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CKHb9t1Gl5CD8yFuz1_CtQ.png"/></div></div></figure><p id="ab43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，<strong class="js iu">散列密码</strong>的值是散列输出。输出的格式与上面的输出相同。</p><p id="49ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很好，现在我们已经散列了我们的密码，让我们继续比较它们。</p><p id="d8f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">必须进行密码比较，以验证进入您的web应用程序的用户，分配令牌等。</p><p id="5eac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">和前面的例子一样，有两种方法可以比较数据库中的密码和登录表单中输入的密码。</p><p id="77cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个是<strong class="js iu"> <em class="le"> compare() </em> </strong>方法，它与<strong class="js iu"> <em class="le"> hash() </em> </strong>函数一样返回一个承诺。它的第一个参数是手动输入或通过登录表单输入的未散列密码。第二个参数是一个字符串，或者说是数据库中存储的密码。它返回一个承诺，可以使用。然后()和。catch()方法。代码如下。</p><figure class="kp kq kr ks gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lp"><img src="../Images/b72b32097612078b5b33b43f1e554a0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8vAbmGh91Jgjzzgbn6Nd4g.png"/></div></div></figure><p id="b5b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出将被发送到提交表单的html页面或/login URL。</p><p id="5169" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二个方法是<strong class="js iu"> <em class="le"> compareSync </em> </strong>()方法，它与<strong class="js iu"> <em class="le"> compare() </em> </strong>函数不同，返回一个布尔值(真/假)。它的第一个参数是用户在登录表单中输入的<strong class="js iu">未散列的</strong>密码，第二个参数是存储在数据库中的散列密码或字符串。下面给出了<strong class="js iu"><em class="le">compare sync()</em></strong>函数的代码。</p><figure class="kp kq kr ks gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lq"><img src="../Images/a820b8d5ce76898de0e951527679c040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VYr2ExWW6ri7B29Ap6A4Mw.png"/></div></div></figure><p id="5ef3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它向提交表单的html页面或/login URL返回一条消息。与其他方法相比，使用同步方法的优势在于您不必处理承诺。如果你是web开发的新手，只是想要一个快速的表单验证方法。我会建议你使用上面的<strong class="js iu"> <em class="le"> hashSync() </em> </strong>和<strong class="js iu"><em class="le">compare sync()</em></strong>的方法。</p><p id="df81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，如果您要控制台记录bool和其他变量，如<strong class="js iu"><em class="le">compare sync()</em></strong>cod所示，输出将如下所示。</p><figure class="kp kq kr ks gt lg gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/77451d7abd90388393dc656868764f60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*eN9cbguxIMFtfYcQHPcQkw.png"/></div></figure></div></div>    
</body>
</html>