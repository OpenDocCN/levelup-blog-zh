<html>
<head>
<title>Creating your own simplified implementation of JSON.stringify()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建您自己的JSON.stringify()的简化实现</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-your-own-simplified-implementation-of-json-stringify-ed8e50b9144a?source=collection_archive---------0-----------------------#2020-09-10">https://levelup.gitconnected.com/creating-your-own-simplified-implementation-of-json-stringify-ed8e50b9144a?source=collection_archive---------0-----------------------#2020-09-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0183" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可能已经熟悉了函数<code class="fe ko kp kq kr b">JSON.stringify</code>，它在比较对象、实现RESTFUL APIs或简单地深度克隆一个javascript对象时很有用(尽管不推荐)。</p><p id="6d84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将讨论如何创建我们自己的这种方法的简化版本，并学习如何一步一步地改进它的实现，随着我们的进步，涵盖越来越多的情况。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/21a0d8e197fd17e682bd04055f841079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0joDx2YXUyRXAHFVISDLvQ.jpeg"/></div></div></figure><p id="3779" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你不熟悉这个功能，我们来看看<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" rel="noopener ugc nofollow" target="_blank"> MDN </a>对此有什么说法:</p><blockquote class="lf lg lh"><p id="10fb" class="jq jr li js b jt ju jv jw jx jy jz ka lj kc kd ke lk kg kh ki ll kk kl km kn im bi translated"><code class="fe ko kp kq kr b"><strong class="js iu">JSON.stringify()</strong></code>方法将JavaScript对象或值转换为JSON字符串，如果指定了replacer函数，则可选地替换值，或者如果指定了replacer数组，则可选地仅包含指定的属性。</p></blockquote><p id="3722" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它的语法可以写成这样:</p><pre class="kt ku kv kw gt lm kr ln lo aw lp bi"><span id="ea0e" class="lq lr it kr b gy ls lt l lu lv">JSON.stringify(value[, replacer[, space]])</span></pre><p id="63bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中“值”是我们要转换为字符串的对象或值。为了使本文更简单，我们可以省去另外两个参数。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4dc0" class="md lr it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">测试数据</h1><p id="ef88" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">考虑这种情况:</p><pre class="kt ku kv kw gt lm kr ln lo aw lp bi"><span id="d144" class="lq lr it kr b gy ls lt l lu lv">const sampleObj = {<br/>   "name": "Juan",<br/>   "age": 29,<br/>   "address": {<br/>      "street": "Street 1",<br/>      "number": 3<br/>   }<br/>}</span></pre><p id="01bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们将origin JSON.stringify()函数应用于该对象，我们会得到以下结果:</p><pre class="kt ku kv kw gt lm kr ln lo aw lp bi"><span id="7348" class="lq lr it kr b gy ls lt l lu lv">{"name":"Juan","age":29,"address":{"street":"Street 1","number":3}}</span></pre><p id="c1ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，这相当简单。它给属性加上双引号，如果值是一个字符串，它也会加上双引号。对于这个特殊的例子，我们将只处理这三种数据类型:数字、字符串和对象。我们将省略函数、日期、未定义的值等等，只是为了简单起见，不过我建议你阅读一下<code class="fe ko kp kq kr b">JSON.stringify</code>的文档，看看它是如何处理这些类型和其他类型的。</p><h1 id="8669" class="md lr it bd me mf nf mh mi mj ng ml mm mn nh mp mq mr ni mt mu mv nj mx my mz bi translated">该功能</h1><p id="9ee5" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">让我们从它开始:</p><pre class="kt ku kv kw gt lm kr ln lo aw lp bi"><span id="7552" class="lq lr it kr b gy ls lt l lu lv">function stringify(obj) {<br/>    let objString = '';</span><span id="3e6d" class="lq lr it kr b gy nk lt l lu lv">    // We add the opening curly brace<br/>    objString += '{';</span><span id="aa22" class="lq lr it kr b gy nk lt l lu lv">    for (const key in obj) {<br/>        const value = obj[key];<br/>        <br/>        objString += `"${key}":`;<br/>        <br/>        if (typeof obj[key] === 'object') {<br/>            objString += `${stringify(value)}`;<br/>        } else if (typeof value === 'string') {<br/>            objString += `"${value}"`;<br/>        } else if (typeof obj[key] === 'number') {<br/>            objString += `${value}`;<br/>        }<br/>        <br/>        // We add the comma<br/>        objString += `,`;<br/>    }</span><span id="5553" class="lq lr it kr b gy nk lt l lu lv">    // We add the closing curly brace<br/>    objString += '}';</span><span id="4c84" class="lq lr it kr b gy nk lt l lu lv">    return objString;<br/>}</span></pre><p id="6eca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如你所看到的，我们正在做的是手动添加花括号，然后遍历对象中的每个键，根据它的类型，我们在打印双引号中的键后打印它的值。如果键包含一个对象，我们使用递归再次调用<code class="fe ko kp kq kr b">stringify</code>函数并重复这个过程。</p><p id="f012" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们用我们的<code class="fe ko kp kq kr b">sampleObj</code>执行那个函数，结果是这样的:</p><pre class="kt ku kv kw gt lm kr ln lo aw lp bi"><span id="832e" class="lq lr it kr b gy ls lt l lu lv">{"name":"Juan","age":29,"address":{"street":"Street 1","number":3,},}</span></pre><p id="3ba7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个好的开始，但是如果你仔细观察，你会发现所有尾随的逗号破坏了JSON字符串的美观。不好！</p><p id="fcf2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们试着解决这个问题:</p><pre class="kt ku kv kw gt lm kr ln lo aw lp bi"><span id="9800" class="lq lr it kr b gy ls lt l lu lv">function stringify(obj) {<br/>    let objString = '';<br/>    <br/>    // We get the last key of this object<br/>    const lastKey = Object.keys(obj).pop();</span><span id="a6eb" class="lq lr it kr b gy nk lt l lu lv">    // We add the first curly brace<br/>    objString += '{';</span><span id="b955" class="lq lr it kr b gy nk lt l lu lv">    for (const key in obj) {<br/>        const value = obj[key];<br/>        <br/>        objString += `"${key}":`;<br/>        <br/>        if (typeof obj[key] === 'object') {<br/>            objString += `${stringify(value)}`;<br/>        } else if (typeof value === 'string') {<br/>            objString += `"${value}"`;<br/>        } else if (typeof obj[key] === 'number') {<br/>            objString += `${value}`;<br/>        }<br/>        <br/>        // We add the comma<br/>        if (key !== lastKey) {<br/>            objString += ',';<br/>        }<br/>    }</span><span id="3133" class="lq lr it kr b gy nk lt l lu lv">    // We add the last curly brace<br/>    objString += '}';</span><span id="3691" class="lq lr it kr b gy nk lt l lu lv">    return objString;<br/>}</span></pre><p id="ae47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">哇，那很简单。我们只是获取对象的最后一个键，当迭代时，如果当前元素属于最后一个键，我们不加逗号。你能想到做这件事的更好的方法吗？这个就够了。</p><p id="5a41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们再次使用我们的<code class="fe ko kp kq kr b">sampleObj</code>来看看这个函数的结果:</p><pre class="kt ku kv kw gt lm kr ln lo aw lp bi"><span id="0d35" class="lq lr it kr b gy ls lt l lu lv">{"name":"Juan","age":29,"address":{"street":"Street 1","number":3}}</span></pre><p id="33fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不错！看起来现在已经完成了，但是…如果你发送一个字符串或者一个数字而不是一个对象，会发生什么呢？让我们看看<code class="fe ko kp kq kr b">JSON.stringify</code>是如何表现的:</p><pre class="kt ku kv kw gt lm kr ln lo aw lp bi"><span id="462a" class="lq lr it kr b gy ls lt l lu lv">&gt; JSON.stringify("test");<br/>"test"</span><span id="2c08" class="lq lr it kr b gy nk lt l lu lv"><br/>&gt; JSON.stringify(42);<br/>42</span></pre><p id="f3d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们用这些值执行我们的函数，我们会得到不同的输出，让我们看看:</p><pre class="kt ku kv kw gt lm kr ln lo aw lp bi"><span id="0039" class="lq lr it kr b gy ls lt l lu lv">&gt; stringify("test");<br/>{"0":"t","1":"e","2":"s","3":"t"}</span><span id="ca10" class="lq lr it kr b gy nk lt l lu lv">&gt; stringify(42);<br/>{}</span></pre><p id="e98e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们试着解决这个问题，我们需要在迭代对象之前检查类型。这是它看起来的样子:</p><pre class="kt ku kv kw gt lm kr ln lo aw lp bi"><span id="2d27" class="lq lr it kr b gy ls lt l lu lv">function stringify(value) {<br/>    const lastKey = Object.keys(value).pop();<br/>    let objString = '';</span><span id="f4fc" class="lq lr it kr b gy nk lt l lu lv">    if (typeof value === 'object') {<br/>        // We add the first curly brace<br/>        objString += '{';</span><span id="9cc6" class="lq lr it kr b gy nk lt l lu lv">        for (const key in value) {<br/>            objString += `"${key}":${stringify(value[key])}`;<br/>            <br/>            // We add the comma<br/>            if (key !== lastKey) {<br/>                objString += ',';<br/>            }<br/>        }</span><span id="21d2" class="lq lr it kr b gy nk lt l lu lv">        // We add the last curly brace<br/>        objString += '}';<br/>    } else if (typeof value === 'string') {<br/>        objString += `"${value}"`;<br/>    } else if (typeof value === 'number') {<br/>        objString += `${value}`;<br/>    }</span><span id="19d3" class="lq lr it kr b gy nk lt l lu lv">    return objString;<br/>}</span></pre><p id="c6aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完成了。如您所见，我们将类型检查移到了当前对象的<code class="fe ko kp kq kr b">for</code>迭代器之外。我们还将参数的名称从<code class="fe ko kp kq kr b">obj</code>改为<code class="fe ko kp kq kr b">value</code>，因为现在它也可以是字符串或数字。</p><p id="60ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们用一些例子来尝试一下:</p><pre class="kt ku kv kw gt lm kr ln lo aw lp bi"><span id="b540" class="lq lr it kr b gy ls lt l lu lv">&gt; stringify("test");<br/>"test"</span><span id="c7c8" class="lq lr it kr b gy nk lt l lu lv">&gt; stringify(42);<br/>42</span><span id="b97f" class="lq lr it kr b gy nk lt l lu lv">&gt; stringify(sampleObj)<br/>{"name":"Juan","age":29,"address":{"street":"Street 1","number":3}}</span></pre><p id="2ed8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看起来是这样的，它现在适用于简单的对象、数字和字符串，我们已经到了本文的结尾，但我将留下几个问题供您思考，并尝试实现您自己的解决方案:</p><h1 id="ecc0" class="md lr it bd me mf nf mh mi mj ng ml mm mn nh mp mq mr ni mt mu mv nj mx my mz bi translated">循环引用问题</h1><p id="a3b7" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">如果您熟悉序列化方法，您可能听说过“循环引用”或“无限循环”。当你试图序列化一个引用了另一个对象的对象，而这个对象又引用了第一个对象时，就会发生这种情况！听起来很疯狂？让我们看看。</p><pre class="kt ku kv kw gt lm kr ln lo aw lp bi"><span id="447b" class="lq lr it kr b gy ls lt l lu lv">const sampleObj = {<br/>    name: 'Juan',<br/>    age: 29,<br/>    address: {<br/>        street: 'Street 1',<br/>        number: 3,<br/>    }<br/>};</span><span id="a697" class="lq lr it kr b gy nk lt l lu lv">const objTwo = {<br/>     name: 'Two',<br/>     inside: sampleObj<br/>};</span><span id="e82e" class="lq lr it kr b gy nk lt l lu lv">sampleObj.outside = objTwo;</span></pre><p id="830a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们现在试图将我们的<code class="fe ko kp kq kr b">sampleObj</code>发送给我们的<code class="fe ko kp kq kr b">stringify</code>函数，我们将得到一个错误。大多数浏览器会说:</p><pre class="kt ku kv kw gt lm kr ln lo aw lp bi"><span id="08c0" class="lq lr it kr b gy ls lt l lu lv">Uncaught RangeError: Maximum call stack size exceeded</span></pre><p id="50ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">发生这种情况是因为我们在发现一个对象时使用了递归，因此这将创建一个无限循环。你能想到什么解决办法吗？你会怎么做？我们可能会在另一篇文章中讨论这个问题，但是如果您能提供这个问题的解决方案，或者甚至分享您自己的stringify函数，那就更好了。</p><h1 id="bfcb" class="md lr it bd me mf nf mh mi mj ng ml mm mn nh mp mq mr ni mt mu mv nj mx my mz bi translated">后续步骤</h1><ul class=""><li id="b1e5" class="nl nm it js b jt na jx nb kb nn kf no kj np kn nq nr ns nt bi translated">解决循环引用问题。</li><li id="2c47" class="nl nm it js b jt nu jx nv kb nw kf nx kj ny kn nq nr ns nt bi translated">添加对“布尔值”的支持。</li><li id="6379" class="nl nm it js b jt nu jx nv kb nw kf nx kj ny kn nq nr ns nt bi translated">添加对<code class="fe ko kp kq kr b">Date</code>和其他实现<code class="fe ko kp kq kr b">toJson()</code>功能的对象的支持。</li></ul><h1 id="fd40" class="md lr it bd me mf nf mh mi mj ng ml mm mn nh mp mq mr ni mt mu mv nj mx my mz bi translated">结论</h1><p id="01cb" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">尽管大多数浏览器都支持<code class="fe ko kp kq kr b">JSON.stringify</code>,但您最好尝试一下，看看本机方法是如何实现的。它可以帮助您理解幕后发生的事情，也许有一天您会改进一个现有的函数，您的代码会包含在下一个EcmaScript版本中，谁知道呢？</p><h1 id="1e07" class="md lr it bd me mf nf mh mi mj ng ml mm mn nh mp mq mr ni mt mu mv nj mx my mz bi translated">进一步阅读</h1><ul class=""><li id="dce0" class="nl nm it js b jt na jx nb kb nn kf no kj np kn nq nr ns nt bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/all-you-need-to-know-about-json-and-its-usage-in-javascript-b5181208966d">https://level up . git connected . com/all-you-need-to-know-about-JSON-and-its-usage-in-JavaScript-b 5181208966d</a></li><li id="c737" class="nl nm it js b jt nu jx nv kb nw kf nx kj ny kn nq nr ns nt bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/5-uses-of-json-stringify-json-parse-9b79cb4d9645">https://level up . git connected . com/5-uses-of-JSON-stringify-JSON-parse-9b 79 CB 4d 9645</a></li></ul></div></div>    
</body>
</html>