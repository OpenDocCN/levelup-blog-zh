<html>
<head>
<title>Synchronize Angular and Spring Boot API specification the swagger way — at the push of a button</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以大摇大摆的方式同步Angular和Spring Boot API规范——只需按一下按钮</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/synchronize-backend-and-frontend-api-interfaces-the-swagger-way-at-the-push-of-a-button-e3b96dbf07cb?source=collection_archive---------6-----------------------#2020-05-29">https://levelup.gitconnected.com/synchronize-backend-and-frontend-api-interfaces-the-swagger-way-at-the-push-of-a-button-e3b96dbf07cb?source=collection_archive---------6-----------------------#2020-05-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/b07101226380f1a1c9ff1b61f2db14e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eidS0lzrWEplgH_0D1VPdw.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">FreeImages.com/Per·哈德斯坦</figcaption></figure><div class=""/><p id="b4ac" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在本文中，我想介绍一种不费吹灰之力就能动态更新客户机服务和dto的方法。不管框架和编程语言如何，客户端都需要知道它所使用的端点的规范。关于端点的消费，首先必须澄清一些问题。这些可能是:</p><ul class=""><li id="4adb" class="la lb jf ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">该服务支持哪种HTTP方法？</li><li id="531f" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">需要哪种内容类型？</li><li id="3914" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">出错时返回哪些HTTP状态，等等。</li></ul><p id="6074" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">似乎这还不够，客户端必须适应服务端点的变化。否则，可靠的通信将不再可能。但是为什么端点要改变呢？这里有几个例子:</p><ul class=""><li id="f498" class="la lb jf ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">端点的重命名。</li><li id="1572" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">更改HTTP响应状态。</li><li id="bec1" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">DTO将通过附加属性进行扩展。</li><li id="b3de" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">内容类型已更改。</li></ul><p id="a39e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我可以列出更多的可能性，但是现在问题应该很清楚了。基于Swagger，服务和dto的生成可以通过最少的配置工作实现自动化。下面我想介绍一种解决方法。</p><p id="d259" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi lo translated">为了简单说明，让我们考虑下面的用例。以前在Angular前端收集的用户数据应该通过HTTP PUT作为DTO传输到RESTful服务端点，这是在Spring Boot实现的。如果数据处理成功，端点返回HTTP状态200，否则返回错误状态，例如503。</p><p id="6ba1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们来看看哪些实现是确保这种交互所必需的:</p><ul class=""><li id="c84c" class="la lb jf ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">Angular前端中的客户端HTTP请求作为服务实现。</li><li id="708c" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">用于数据交互的dto。</li><li id="b6b1" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">后端的RESTful端点。</li><li id="0082" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">当然还有API接口的文档。</li></ul><p id="c329" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们现在已经创建了一个粗略的技术基础来深入研究代码。接下来，基于由Angular应用和Spring Boot后端服务组成的客户端-服务器模型来解释该过程。如果应用程序还没有安装好，下一章会有所帮助。</p><h1 id="4c2d" class="lx ly jf bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">快速配置</h1><p id="33ed" class="pw-post-body-paragraph kc kd jf ke b kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz ij bi translated">如果客户端和后端程序已经存在，你可以跳过这一章。如果没有，下面的说明会有所帮助。请记住，在设置应用程序时，本文无法深入探讨。重点是Java类的配置和设置。</p><h2 id="5d2b" class="na ly jf bd lz nb nc dn md nd ne dp mh kn nf ng ml kr nh ni mp kv nj nk mt nl bi translated">创建Spring Boot应用程序</h2><p id="aba8" class="pw-post-body-paragraph kc kd jf ke b kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz ij bi translated">基本框架可以通过<a class="ae nm" href="http://start.spring.io" rel="noopener ugc nofollow" target="_blank"> start.spring.io </a>轻松创建。🚀到随时可用的<a class="ae nm" href="https://start.spring.io/#!type=maven-project&amp;language=java&amp;platformVersion=2.2.7.RELEASE&amp;packaging=war&amp;jvmVersion=11&amp;groupId=com.example&amp;artifactId=demo&amp;name=demo&amp;description=Demo%20project%20for%20Spring%20Boot&amp;packageName=com.example.demo&amp;dependencies=web,lombok" rel="noopener ugc nofollow" target="_blank">配置</a>。</p><h2 id="4800" class="na ly jf bd lz nb nc dn md nd ne dp mh kn nf ng ml kr nh ni mp kv nj nk mt nl bi translated">设置角度应用程序</h2><p id="9756" class="pw-post-body-paragraph kc kd jf ke b kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz ij bi translated">创建应用程序最简单的方法是使用<a class="ae nm" href="https://cli.angular.io/](https://cli.angular.io" rel="noopener ugc nofollow" target="_blank"> Angular CLI </a>。</p><p id="e906" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们现在有一个后端和前端应用程序。前端和后端之间的交互仍然缺失。我们还得为此做些安排。</p><h1 id="de8f" class="lx ly jf bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">Spring Boot申请的准备</h1><p id="b734" class="pw-post-body-paragraph kc kd jf ke b kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz ij bi translated">在pom.xml中，我们为Swagger增加了两个库:</p><figure class="no np nq nr gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="db30" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Springfox主要用于使用Java注释生成现成的API规范，例如Swagger，尽管也支持其他工具。我将跳过处理Springfox配置的步骤。相反，我将参考详细记录此<a class="ae nm" href="http://springfox.github.io/springfox/docs/current/" rel="noopener ugc nofollow" target="_blank">的官方文档</a>。</p><p id="a912" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们从Spring Boot应用程序开始</p><pre class="no np nq nr gt nu nv nw nx aw ny bi"><span id="cf22" class="na ly jf nv b gy nz oa l ob oc">mvn spring-boot:run -Dspring-boot.run.profiles=dev</span></pre><p id="5cf6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我使用单独的<em class="nn">application-dev . properties</em>文件进行开发。当然你可以用任意一个。尽管如此，Spring Boot应用程序现在应该正在运行！</p><p id="a7a0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下一步是根据开头描述的用例创建一个端点。下面实现的控制器操作应该接收数据有效负载并做进一步的处理，比如更新数据库条目(不在范围内)。</p><figure class="no np nq nr gt is"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">UserApiController.java</figcaption></figure><p id="8b72" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi lo translated"><span class="l lp lq lr bm ls lt lu lv lw di"> T </span>类<code class="fe od oe of nv b">UserApiController.java</code>包含一个新的端点，它期望查询参数中的用户的<em class="nn"> ID </em>和HTTP主体中的用户数据的有效负载。这里需要特别注意注释<a class="ae nm" href="http://docs.swagger.io/swagger-core/v1.5.0/apidocs/io/swagger/annotations/ApiOperation.html" rel="noopener ugc nofollow" target="_blank"><em class="nn">@ API operation</em></a>，因为在生成客户端接口时会用到其中描述的信息。例如，<em class="nn"> operationId </em>中的值被用作Angular服务类中服务函数的名称，但稍后将对此进行详细介绍。</p><p id="8ef4" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果配置已经正确完成，并且控制器类已经创建，那么swagger文档应该可以通过端点获得</p><pre class="no np nq nr gt nu nv nw nx aw ny bi"><span id="abdd" class="na ly jf nv b gy nz oa l ob oc"><a class="ae nm" href="http://localhost:8090/swagger-ui.html" rel="noopener ugc nofollow" target="_blank">http://localhost:8090/swagger-ui.html</a></span></pre><p id="b68e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请确保输入了正确的端口。正如您将看到的，新的端点现在应该已经列在API文档中了。现在开始激动人心了。通过网址</p><pre class="no np nq nr gt nu nv nw nx aw ny bi"><span id="5d00" class="na ly jf nv b gy nz oa l ob oc"><a class="ae nm" href="http://localhost:8090/api-docs" rel="noopener ugc nofollow" target="_blank">http://localhost:8090/api-docs</a></span></pre><p id="ecdb" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你得到了开放API规范。在本例中，它被生成为JSON(也支持YAML)。</p><figure class="no np nq nr gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="9737" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接下来，Angular客户端接口和DAO应该基于OpenApi JSON自动生成。为此，应该在Angular项目中将JSON保存为<em class="nn"> swagger.json </em>。我推荐Angular项目目录下的一个子目录，比如<em class="nn"> swagger-config </em>。</p><h1 id="76f5" class="lx ly jf bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">为Angular应用程序生成客户端服务和dto</h1><p id="9167" class="pw-post-body-paragraph kc kd jf ke b kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz ij bi translated">要从JSON Open API规范生成客户端文件，需要<a class="ae nm" href="https://github.com/swagger-api/swagger-codegen" rel="noopener ugc nofollow" target="_blank"><em class="nn">swagger-codegen-CLI . jar</em></a><a class="ae nm" href="https://github.com/swagger-api/swagger-codegen](https://github.com/swagger-api/swagger-codegen))." rel="noopener ugc nofollow" target="_blank">。</a>由于规范是在OpenAPI 2.0中创建的，所以您需要版本为2.x.x的jar文件。在文件夹<em class="nn"> swagger-config </em>中，可以执行以下命令来下载该文件:</p><pre class="no np nq nr gt nu nv nw nx aw ny bi"><span id="dc6d" class="na ly jf nv b gy nz oa l ob oc">wget https://repo1.maven.org/maven2/io/swagger/swagger-codegen-cli/2.4.14/swagger-codegen-cli-2.4.14.jar -O swagger-codegen-cli.jar</span></pre><p id="c9b0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因为您必须向jar文件传递一些参数，并且我们不想一次又一次地这样做，所以shell文件是合适的。为此，在文件夹中创建一个名为<em class="nn"> swagger-client-api.sh </em>的文件，其内容如下:</p><pre class="no np nq nr gt nu nv nw nx aw ny bi"><span id="9deb" class="na ly jf nv b gy nz oa l ob oc">java -jar ./swagger-codegen-cli.jar generate \<br/> -i./swagger.json.json \<br/> -l typescript-angular \<br/> -o ../src/app/client</span></pre><p id="b958" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这些参数的含义如下:</p><ul class=""><li id="4ecc" class="la lb jf ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated"><code class="fe od oe of nv b">-i</code>是我们之前放在文件夹中的OpenAPI JSON文件的名称。</li><li id="0c2a" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated"><code class="fe od oe of nv b">-l</code>是客户端服务和DTO文件的目的地。最棒的是生成器支持各种客户端框架。</li><li id="de41" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated"><code class="fe od oe of nv b">-o</code>最后是存放文件的目标文件夹。</li></ul><p id="621d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在用<code class="fe od oe of nv b">sh swagger-client.api.sh</code>执行shell文件。Et voilà，我们应该手动编程的angular客户端和DTO已经在文件夹<code class="fe od oe of nv b">../src/app/client</code>中生成。</p><p id="5da5" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是生成的TypeScript函数(它应该执行请求)对于Angular应用程序的样子。</p><figure class="no np nq nr gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="a3c9" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">以及相应的模型:</p><figure class="no np nq nr gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h1 id="25e5" class="lx ly jf bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">我们赢了什么？</h1><p id="b9a7" class="pw-post-body-paragraph kc kd jf ke b kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz ij bi translated">我们现在能够对影响端点的变化做出快速反应。因此，只要“按下按钮”，客户端界面就可以更新。这使得我们可以专注于基本的任务，比如实现业务逻辑。</p><h1 id="dc0f" class="lx ly jf bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">最后几句话</h1><p id="c2fe" class="pw-post-body-paragraph kc kd jf ke b kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz ij bi translated">在本文中，OpenAPI规范来自java类注释。然而，首先创建规范，然后生成后端和客户机文件，这并没有什么不好。对于后端类的初始创建，这可能仍然是可取的，但是随着开发的进展，应该重新考虑这一点。因为Spring Boot端点包含自包含的逻辑，比如通过实体bean类的数据持久性，所以您不希望用生成的类覆盖它们。</p><p id="e6cd" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于客户端文件，情况有所不同。生成的服务函数返回可在不同上下文中使用的可观察值。因此，附加逻辑不是在生成的客户端服务中实现的，而是围绕它们实现的。因此，完全可以覆盖它们。</p><p id="b679" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，这并不意味着由Swagger CLI生成Java类没有用。这完全取决于项目需求和开发进度。</p><p id="31bf" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">☕️，祝你体验愉快！</p></div></div>    
</body>
</html>