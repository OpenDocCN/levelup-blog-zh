<html>
<head>
<title>JavaScript Prototype Chain and Inheritance Explained From Scratch.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript原型链和继承从头开始解释。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-prototype-chain-and-inheritance-explained-from-scratch-5f9d23f54f9?source=collection_archive---------13-----------------------#2020-06-22">https://levelup.gitconnected.com/javascript-prototype-chain-and-inheritance-explained-from-scratch-5f9d23f54f9?source=collection_archive---------13-----------------------#2020-06-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="8f8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本教程的代码笔<a class="ae ko" href="https://codepen.io/r0ss26/pen/RwrpYjP?editors=1112" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><p id="b98c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文讨论了如何在JavaScript中实现面向对象的编程模式。特别是，本文涵盖:</p><ul class=""><li id="028a" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">目标</li><li id="1a1a" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">原型遗传</li><li id="a709" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">函数构造函数</li><li id="ad9d" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">原型链</li><li id="8b9a" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">子类继承</li></ul><h1 id="558f" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">(几乎)一切都是物体</h1><p id="38cd" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">JavaScript中最基本的概念之一是“一切都是对象”。实际上，这并不完全正确，因为JavaScript也包含不是对象的原始值。这些原始值是:</p><ul class=""><li id="2a09" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">数字</li><li id="9402" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">用线串</li><li id="3a3e" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">布尔运算</li><li id="dcb9" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">不明确的</li><li id="0eaa" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">空</li></ul><p id="dc53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，除了这些原始值，JavaScript中的所有其他东西都是对象。这包括:</p><ul class=""><li id="3c8b" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">数组</li><li id="a62e" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">功能</li><li id="95fc" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">目标</li><li id="da1b" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">日期</li><li id="87e9" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">数字、字符串和布尔值的包装器</li></ul><p id="8dbc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们继续深入之前，让我们弄清楚对象和原语之间的区别。简单地说，原语没有方法——它们只是内存中表示的一个值。另一方面，对象是数据的集合，可以存储对其他实体的引用。这些实体(属性)可以是诸如字符串或数字之类的原语，也可以是其他对象(包括函数)。</p><h1 id="a0c7" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">原型遗传</h1><p id="d6d1" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">编程中的继承意味着一个对象基于另一个对象，并且可以访问其他对象的属性和方法。</p><p id="8a64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">JavaScript实现了原型继承，这与C或Java中的经典继承相反。这是一个重要的区别，因为在经典继承模型中，当一个<em class="mg">对象实例</em>从一个<em class="mg">类</em>继承，并且一个子类可以从一个父类继承时，就会发生继承。</p><p id="95d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，原型继承支持对象从任何其他对象继承，而不是从类继承。</p><p id="5dcb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">原型继承的定义特性是对象实例可以通过原型链访问继承的属性和方法。这是通过JavaScript中的每个对象都被自动赋予一个<code class="fe mh mi mj mk b">prototype</code>属性来实现的。当创建一个继承自父对象的子对象时，子对象可以访问parents <code class="fe mh mi mj mk b">prototype</code>属性。<code class="fe mh mi mj mk b">proptotype</code>属性本身是一个对象，因为子对象可以访问它们的父对象原型属性，所以子对象可以访问存储在这里的任何属性和方法。</p><p id="c780" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，假设我们有一个<code class="fe mh mi mj mk b">Vehicle</code>对象，我们将使用<code class="fe mh mi mj mk b">Vehicle</code>来创建<code class="fe mh mi mj mk b">Vehicle</code>类型的<em class="mg">实例</em>。在许多其他语言中，<code class="fe mh mi mj mk b">Vehicle</code>会被认为是一个类，因为它是创建<code class="fe mh mi mj mk b">Vehicle</code>类型实例的蓝图。然而JavaScript没有类的概念，相反<code class="fe mh mi mj mk b">Vehicle</code>是一个<em class="mg">构造器</em>——一个用作创建其他对象的蓝图的对象。</p><h1 id="470b" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">构造函数、实例和new关键字</h1><p id="6cd8" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">让我们用一个例子来说明原型继承。</p><p id="4b8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到汽车制造商，这看起来如何？在JavaScript中，我们使用函数来实现构造函数——这些被恰当地称为函数构造函数。</p><p id="e5de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是我们如何用函数构造器实现<code class="fe mh mi mj mk b">Vehicle</code>类:</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="2157" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们可以使用这个函数构造函数来创建一个车辆实例，如下所示:</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="6411" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mh mi mj mk b">myVehicle</code>变量现在保存一个使用<code class="fe mh mi mj mk b">Vehicle</code>函数构造函数创建的<code class="fe mh mi mj mk b">Vehicle</code>实例。</p><p id="e78f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可以通过使用<code class="fe mh mi mj mk b">new</code>关键字来实现。</p><p id="b3e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">new关键字与函数构造函数一起使用，以便创建实例。在幕后，新关键字通过以下步骤工作:</p><ol class=""><li id="d286" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ms kv kw kx bi translated">创建一个新的空对象<code class="fe mh mi mj mk b">{}</code>。</li><li id="d608" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ms kv kw kx bi translated">将<code class="fe mh mi mj mk b">this</code>变量设置为步骤1中创建的空对象。</li><li id="1d29" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ms kv kw kx bi translated">使用引用新创建对象的<code class="fe mh mi mj mk b">this</code>关键字执行函数。</li></ol><p id="a117" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过这些步骤，我们可以创建一个具有属性<code class="fe mh mi mj mk b">color</code> <code class="fe mh mi mj mk b">weight</code>和<code class="fe mh mi mj mk b">year</code>以及方法<code class="fe mh mi mj mk b">honk</code>的车辆。</p><p id="8929" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是原型呢？</p><p id="1ea4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们目前实施<code class="fe mh mi mj mk b">Vehicle</code>的方式并不理想。在这个实现中，我们没有利用原型的力量。因为我们已经在构造函数体中定义了honk方法，所以每个新的vehicle实例都将在内存中存储自己单独的<code class="fe mh mi mj mk b">honk</code>副本。因为<code class="fe mh mi mj mk b">honk</code>总是同一个函数，所以每个实例存储自己唯一的副本是没有意义的。</p><p id="a029" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是原型的力量所在。</p><p id="7961" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请记住，对象可以访问它们的父对象prototype属性，所以如果我们将<code class="fe mh mi mj mk b">honk</code>方法存储在<code class="fe mh mi mj mk b">Vehicle</code>的prototype属性中，所有实例都可以访问它，而不需要存储它们自己的副本。</p><p id="6f5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以这样实现:</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="ea20" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">原型链</h1><p id="3c7b" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">正如我们在前面的例子中看到的，我们的<code class="fe mh mi mj mk b">myVehicle</code>实例能够执行<code class="fe mh mi mj mk b">honk</code>方法，该方法存储在用于创建它的函数构造器的prototype属性中。这是可能的，因为原型链。</p><p id="b0d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本质上，当调用<code class="fe mh mi mj mk b">honk</code>方法时，JavaScript将查看调用对象的属性，在本例中是<code class="fe mh mi mj mk b">myVehicle</code>，用于名为<code class="fe mh mi mj mk b">honk</code>的方法(或属性)。如果在对象上没有找到这个属性，我们将原型链上移一级。</p><p id="b4c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了在对象和它的原型之间建立链接，使用了<code class="fe mh mi mj mk b">myVehicle</code>的<code class="fe mh mi mj mk b">__proto__</code>属性。这个<code class="fe mh mi mj mk b">__proto__</code>属性本质上是一个到它的构造器原型的链接。</p><p id="23aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一般来说，instances <code class="fe mh mi mj mk b">__proto__</code>属性是到它的原型的链接(它的构造器的原型属性)。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/aec9944ecaca0bb3908cb693ddd4d504.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*l43KDPcpZKHWdXhICtzqJA.jpeg"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">对象和它的构造函数之间关系的表示。</figcaption></figure><p id="65e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以在控制台中演示这一点。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="0c3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，通过<code class="fe mh mi mj mk b">__proto__</code>我们可以访问<code class="fe mh mi mj mk b">Vehicle.prototype</code>来寻找鸣喇叭方法。因为我们在原型上显式存储了鸣响方法，所以我们能够执行它。</p><p id="adc9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样，<code class="fe mh mi mj mk b">Vehicle</code>的所有实例都可以访问honk方法，而不需要存储它们自己的副本。</p><h1 id="ec2e" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">子类继承</h1><p id="f6fc" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">现在假设我们有一个不同的构造函数，它类似于<code class="fe mh mi mj mk b">Vehicle</code>但更具体，比如一个<code class="fe mh mi mj mk b">Motorcycle</code>构造函数。<code class="fe mh mi mj mk b">Motorcycle</code>具有与<code class="fe mh mi mj mk b">Vehicle</code>相同的属性和功能，但是它也有一个<code class="fe mh mi mj mk b">engineSize</code>属性和一个<code class="fe mh mi mj mk b">refuel</code>方法。</p><p id="4b38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为一个<code class="fe mh mi mj mk b">motorcycle</code>和一个<code class="fe mh mi mj mk b">Vehicle</code>共享相同的属性，我们可以使用继承来简化我们的代码。通过让摩托车从车辆继承，我们避免了两次指定共享的属性和方法。</p><p id="dfac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看如何实现一个<code class="fe mh mi mj mk b">Motorcycle</code>子类。</p><p id="5d30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mg">注意:类和子类是经典继承而非原型继承的特征，这意味着</em> <code class="fe mh mi mj mk b"><em class="mg">Motorcycle</em></code> <em class="mg">实际上不是子类。在JavaScript中，我们使用原型链来模拟类和子类。</em></p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="b479" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了一步一步地分解它，我们将从最后一行开始，在这里我们创建一个新的<code class="fe mh mi mj mk b">Motorcycle</code>实例。正如我们前面讨论的，创建了一个新的空对象，然后我们调用<code class="fe mh mi mj mk b">Motorcycle</code>函数构造函数，将<code class="fe mh mi mj mk b">this</code>的值设置为新的空对象。</p><p id="8a81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe mh mi mj mk b">Motorcycle</code>函数构造函数体内，我们遇到了<code class="fe mh mi mj mk b">call</code>方法。本质上，这一行做的是调用<code class="fe mh mi mj mk b">Vehicle</code>构造函数，传入<code class="fe mh mi mj mk b">color</code>、<code class="fe mh mi mj mk b">weight</code>和<code class="fe mh mi mj mk b">year</code>。<code class="fe mh mi mj mk b">call</code>方法允许我们为<code class="fe mh mi mj mk b">this</code>指定自己的值，该值在执行时将成为新的<code class="fe mh mi mj mk b">myMotorycle</code>对象。</p><p id="4e74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这允许我们在设置摩托车实例的属性时执行<code class="fe mh mi mj mk b">Vehicle</code>构造函数。然后我们像平常一样设置<code class="fe mh mi mj mk b">engineSize</code>属性。</p><p id="cff8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们只是少了一步。目前<code class="fe mh mi mj mk b">motorcycle</code>实例不知道如何访问<code class="fe mh mi mj mk b">Vehicles</code>原型属性，因此无法访问<code class="fe mh mi mj mk b">honk</code>方法。</p><p id="1ee3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了实现这一点，我们使用了<code class="fe mh mi mj mk b">Object.create</code>方法。<code class="fe mh mi mj mk b">Object.create</code>允许我们创建一个新对象，同时指定该对象的原型。我们传入的参数将是新创建的对象的原型。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="e376" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">至此，我们已经连接了原型链。</p><p id="a497" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mh mi mj mk b">Motorcycle.prototype</code>的<code class="fe mh mi mj mk b">__proto__</code>属性将被设置为<code class="fe mh mi mj mk b">Vehicle.prototype</code>，摩托车实例现在可以访问存储在摩托车原型和车辆原型上的所有属性和方法。</p><p id="ec8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了演示这一点，让我们将加油方法添加到摩托车原型中。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/af323ede395d0366fec9e7ae2d1d24de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KPmkmEzK6x1HpXcs92U_jg.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">控制台中的摩托车原型链。</figcaption></figure><h1 id="d00a" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结论</h1><p id="8a7b" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">JavaScript实现面向对象编程的方式不同于许多其他使用基于类的系统的语言。通过很好地掌握原型继承、函数构造器和原型链，你可以充分利用语言的特性，理解JavaScript是如何工作的。</p></div></div>    
</body>
</html>