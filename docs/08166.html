<html>
<head>
<title>Golang for Java Developers — Compiling, Packages and Modules, and Built-In Functionality</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向Java开发人员的Golang编译、包和模块以及内置功能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/go-for-java-devs-compiling-packages-and-modules-and-built-in-functionality-672597c19ae4?source=collection_archive---------13-----------------------#2021-04-06">https://levelup.gitconnected.com/go-for-java-devs-compiling-packages-and-modules-and-built-in-functionality-672597c19ae4?source=collection_archive---------13-----------------------#2021-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="82a5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从Java角度看Go编程语言——第3部分</h2></div><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/73e124459102cb94eb3dfef69193e47a.png" data-original-src="https://miro.medium.com/v2/format:webp/1*gausz1aacOvPJT1MEuBDTA.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">作者糟糕的草图</figcaption></figure><p id="9796" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个系列的第一篇<a class="ae lq" href="https://medium.com/p/348fa57f4100" rel="noopener">第一篇</a> <a class="ae lq" href="https://medium.com/p/493dad0c5129" rel="noopener">和第二篇</a>文章中，我将自己描述为一名长期从事Java工作的工程师，最近决定尝试一下。尽管我将永远热爱Java，但我知道继续学习语言很重要。我选择Go是因为它是一种静态类型的编译语言，不会面临Java面临的一些问题(比如编译时间和启动时间慢)。</p><p id="d1ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个系列不是要让Java和Go对立起来。两者都是强势语言，各有优缺点。相反，这是我作为Java开发人员对Go的第一次观察。鉴于我仍在学习Go，如果任何读者认为我误解了Go(或者Java，就此而言)，我欢迎任何反馈。</p><p id="5c9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本系列的最后一篇文章中，让我们从Go编码的本质上后退一步，讨论Go的编译和启动时间，包和模块如何帮助组织代码和依赖关系，以及内置于Go核心的一些高级功能。</p><h1 id="cdce" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">编译和启动时间</h1><p id="968c" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">围棋最常被吹捧的好处之一是它的速度。不仅仅是它的运行时性能，还有它的编译和启动时间。事实上，解决其他语言的<a class="ae lq" href="https://talks.golang.org/2012/splash.article" rel="noopener ugc nofollow" target="_blank">构建时间慢的问题</a>被这种语言的创造者称为是创造Go的主要动力。</p><p id="f8cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相比之下，Java因其编译时间和启动时间而备受批评。我大部分时间都是从Spring(一个很棒的框架，但是它的依赖连线会导致启动时间非常慢)转向更新的框架，比如<a class="ae lq" href="https://vertx.io/" rel="noopener ugc nofollow" target="_blank"> Vert.x </a>和<a class="ae lq" href="https://quarkus.io/" rel="noopener ugc nofollow" target="_blank"> Quarkus </a>。这些框架避开了Spring的大部分包袱，提供了显著的性能改进。但是仍然有明显的滞后，尤其是在云冷启动期间。</p><p id="ca63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Java社区正在努力解决这些问题，特别是使用<a class="ae lq" href="https://www.graalvm.org/reference-manual/native-image/" rel="noopener ugc nofollow" target="_blank"> GraalVM和本机构建</a>的本机构建。目前，这种方法需要一个主要的权衡:虽然启动时间快如闪电，但编译要花很长时间(如果它没有耗尽内存并先被丢弃的话)。我相信，总有一天，这些问题会得到解决。但是Java还没有出现。</p><p id="16aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相比之下，围棋是。哦，是的，一旦你开始使用Go，你会注意到这些性能优势。不管我的应用程序变得有多大，编译时间仍然明显比它们的Java类似物要短。并且启动时间保持接近瞬时。特别是，在将我的Go服务部署到GCP云运行时，我几乎没有注意到冷启动时间。</p><h1 id="1303" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">内置功能</h1><p id="74b6" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">Go的标准库提供了数量惊人的内置功能；在Java中需要使用第三方框架的功能。考虑到Go旨在变得紧凑和简单易学，这一点尤其令人惊讶。然而，事实证明，这种内置的功能很容易掌握，感觉就像是语言的一部分。</p><p id="9133" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看下面两个例子:</p><h2 id="a380" class="mo ls it bd lt mp mq dn lx mr ms dp mb ld mt mu md lh mv mw mf ll mx my mh mz bi translated">Http服务器</h2><p id="322b" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">Go的标准<code class="fe na nb nc nd b">net/http</code>包允许我们轻松地启动一个相当强大的HTTP服务器。它允许我们做以下事情:</p><ul class=""><li id="2172" class="ne nf it kw b kx ky la lb ld ng lh nh ll ni lp nj nk nl nm bi translated">将URL路径与请求处理程序相关联</li><li id="8b3d" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">访问请求参数和主体</li><li id="09fe" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">指定我们的服务器将监听的端口(或者，多个服务器将监听的多个端口)</li></ul><p id="5574" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从Java的角度来看，这有点像使用<a class="ae lq" href="https://vertx.io/docs/vertx-web/java/" rel="noopener ugc nofollow" target="_blank"> Vert.x Web </a>，当然，这是第三方框架，不是JDK发行版的一部分。</p><p id="f6d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，Go的内置HTTP服务器产品有一定的局限性。我几乎立刻注意到，我不能指定URL路径参数(例如<code class="fe na nb nc nd b">/users/<em class="ns">{id}</em>/emails/<em class="ns">{emailId}</em></code>)，也不能声明性地将请求处理程序与特定的请求方法关联起来(例如<code class="fe na nb nc nd b">GET</code>或<code class="fe na nb nc nd b">PUT</code>)。但是，也有第三方模块提供此功能。<a class="ae lq" href="https://github.com/gorilla/mux" rel="noopener ugc nofollow" target="_blank"> GorillaMux </a>尤其符合<code class="fe na nb nc nd b">net/http</code>的API，可以无缝地放置在适当的位置以扩展<code class="fe na nb nc nd b">net/http</code>的功能。</p><h2 id="7ed9" class="mo ls it bd lt mp mq dn lx mr ms dp mb ld mt mu md lh mv mw mf ll mx my mh mz bi translated">模板</h2><p id="4017" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">Go提供了一种内置的模板语言。这允许我们创建一个带有可替换标记的文本文件，然后将该文件与一个包含要换入的值的数据结构相结合，从而生成动态生成的内容。</p><p id="730e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它的用途多种多样。例如，我们可以将它与我们的<code class="fe na nb nc nd b">net/http</code>服务器结合使用，以便提供动态生成的网页。如果你已经为Kubernetes编写了<a class="ae lq" href="https://helm.sh/docs/chart_template_guide/" rel="noopener ugc nofollow" target="_blank">掌舵图</a>，你已经习惯了使用模板语言。在这方面，Go的模板语言类似于Java的<a class="ae lq" href="https://freemarker.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Freemarker </a>库，可以用作通用的模板库(即不仅仅用于网页)。</p><p id="0d8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">鉴于Go的模板语言本质上是通用的，它在任何特定领域(例如动态网页)的功能都是不全面的。当然，<a class="ae lq" href="https://github.com/avelino/awesome-go#template-engines" rel="noopener ugc nofollow" target="_blank">众多第三方</a>模块的存在填补了这一空白。</p><h1 id="990f" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">包和模块</h1><p id="2115" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">写代码是一回事；组织和包装是另一回事。Go主要为此提供了两个构造:<em class="ns">包</em>和<em class="ns">模块</em>。Go包类似于Java的包，而Go模块类似于JAR文件加Maven(或者您最喜欢的依赖管理工具)。</p><h2 id="b963" class="mo ls it bd lt mp mq dn lx mr ms dp mb ld mt mu md lh mv mw mf ll mx my mh mz bi translated">包装</h2><p id="26c1" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">Go包提供了一种将相关的结构、接口、函数、常量等分组的机制。与Java一样，我们将文件的包声明为文件中的第一行。然而，Go包不像Java包那样遵循<a class="ae lq" href="https://en.wikipedia.org/wiki/Reverse_domain_name_notation" rel="noopener ugc nofollow" target="_blank">反向域名符号</a>。相反，Go的惯例是使用简洁的单个单词的包名。此外，Go包名称不必像Java那样与底层目录结构相匹配……尽管如果包中的所有文件都位于同一个目录中会非常有帮助(如下所述)。</p><p id="2f68" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是一个在<code class="fe na nb nc nd b">api</code>包中的简单Go文件的例子:</p><pre class="ki kj kk kl gt nt nd nu nv aw nw bi"><span id="8dbc" class="mo ls it nd b gy nx ny l nz oa">package api</span><span id="e86e" class="mo ls it nd b gy ob ny l nz oa">type Person struct {<br/>  Id    string<br/>  Name  string<br/>}</span></pre><p id="1f36" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与Java导入类似，包被导入到驻留在其他包中的文件中。这是通过一个<code class="fe na nb nc nd b">import</code>声明来完成的。注意，在Go中，我们只导入包；我们不指定单独的类/结构(因此，我们不需要像在Java中那样使用通配符)。</p><p id="880e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们导入了一个包，我们就可以通过在它前面加上包名来引用从那个包中导出的任何元素。</p><p id="10d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果一个文件从上面导入了<code class="fe na nb nc nd b">api</code>包(和<code class="fe na nb nc nd b">log</code>包一起)并使用了包的<code class="fe na nb nc nd b">Person</code>结构，那么这个文件可能是这样的:</p><pre class="ki kj kk kl gt nt nd nu nv aw nw bi"><span id="39bb" class="mo ls it nd b gy nx ny l nz oa">package main</span><span id="7305" class="mo ls it nd b gy ob ny l nz oa">import (<br/>  "api"<br/>  "log"<br/>)</span><span id="7c12" class="mo ls it nd b gy ob ny l nz oa">func main() {<br/>  p := api.Person{123, "Pat Smith"}  // we prefix Person with api.<br/>  log.Printf("Person's name is %s", p.Name)<br/>}</span></pre><p id="c3e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的例子位于<code class="fe na nb nc nd b">main</code>包中。可执行应用程序(即非库)必须驻留在<code class="fe na nb nc nd b">main</code>包中。</p><p id="9c0b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="ns">记住，一个包里没有类</em> </strong> <br/>在Java里，我们倾向于把包看成类的集合。围棋就不是这样的。记住，围棋是没有职业的。上面这个带有<code class="fe na nb nc nd b">Person</code>结构的<code class="fe na nb nc nd b">api</code>包的例子有点像Java。但是回想一下，在Go中，我们可以定义正则函数(即非接收函数)。</p><p id="4457" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，该函数的作用范围是整个<em class="ns">包</em>。假设我们要在<code class="fe na nb nc nd b">person.go</code>文件内的<code class="fe na nb nc nd b">api</code>包中创建一个这样的函数:</p><pre class="ki kj kk kl gt nt nd nu nv aw nw bi"><span id="137c" class="mo ls it nd b gy nx ny l nz oa">func Name(p Person) {<br/>  return p.Name<br/>}</span></pre><p id="72d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好吧。但是现在，假设我们想在我们的<code class="fe na nb nc nd b">team.go</code>文件中为我们的<code class="fe na nb nc nd b">Team</code>结构做一些类似的事情，它也位于<code class="fe na nb nc nd b">api</code>包中:</p><pre class="ki kj kk kl gt nt nd nu nv aw nw bi"><span id="7006" class="mo ls it nd b gy nx ny l nz oa">func Name(t Team) {<br/>  return t.Name<br/>}</span></pre><p id="c480" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们会得到一个编译错误。为什么？这是因为两件事:</p><ol class=""><li id="69fd" class="ne nf it kw b kx ky la lb ld ng lh nh ll ni lp oc nk nl nm bi translated">我们不能用不同的参数“重载”常规函数。在编译器看来，那两个<code class="fe na nb nc nd b">Name</code>函数是一样的。</li><li id="d234" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp oc nk nl nm bi translated">这两个函数都在<code class="fe na nb nc nd b">api</code>包的范围内，而不是在<code class="fe na nb nc nd b">User</code>和<code class="fe na nb nc nd b">Team</code>包的范围内。</li></ol><p id="7077" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实际上，我们已经声明了两次<code class="fe na nb nc nd b">Name</code>函数。</p><h2 id="0208" class="mo ls it bd lt mp mq dn lx mr ms dp mb ld mt mu md lh mv mw mf ll mx my mh mz bi translated">模块</h2><p id="f441" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我在Go社区中看到了很多关于模块的夸大，我一直试图理解这种炒作。我想我现在明白了:</p><ul class=""><li id="023d" class="ne nf it kw b kx ky la lb ld ng lh nh ll ni lp nj nk nl nm bi translated">模块是相对较新的语言。在模块出现之前，构建和组织不同的项目——然后与其他开发人员共享这些项目——显然是一场噩梦。</li><li id="0c9d" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">对于它们所做的，模块实际上使用起来非常简单，并且许多潜在的手动/繁琐的工作自动发生。</li><li id="8d10" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">与其他语言中的许多类似工具不同，modules附带了核心Go工具集。</li></ul><p id="156f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">模块有效地充当了Go依赖管理系统的基础。模块本身是一个简单的构造:它只是一个目录，包含:</p><ul class=""><li id="9ccb" class="ne nf it kw b kx ky la lb ld ng lh nh ll ni lp nj nk nl nm bi translated">一个或多个包</li><li id="878f" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">这些包所在的根目录下的一个<code class="fe na nb nc nd b">go.mod</code>文件</li></ul><p id="6445" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe na nb nc nd b">go.mod</code>文件描述了一些事情:</p><ul class=""><li id="2106" class="ne nf it kw b kx ky la lb ld ng lh nh ll ni lp nj nk nl nm bi translated"><em class="ns">模块路径。</em>模块路径作为模块的规范名称。它还用作前缀，通过该前缀引用模块中包含的任何包。回想一下，包名不使用反向域名语法；模块路径，但是，<em class="ns">确实</em>通常使用它。</li><li id="eda0" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated"><em class="ns">Go版本。</em> <code class="fe na nb nc nd b">go.mod</code>文件可以指定用来打包模块的Go版本。</li><li id="a3c2" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated"><em class="ns">依赖性要求。</em>这些是模块所需的外部库(及其版本)。这大致等同于Maven <code class="fe na nb nc nd b">pom.xml</code>文件的<code class="fe na nb nc nd b">&lt;dependencies/&gt;</code>部分。</li></ul><p id="c9c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一个例子:</p><pre class="ki kj kk kl gt nt nd nu nv aw nw bi"><span id="31c7" class="mo ls it nd b gy nx ny l nz oa">module taubler.com/myapp</span><span id="b5fb" class="mo ls it nd b gy ob ny l nz oa">go 1.16</span><span id="e2c3" class="mo ls it nd b gy ob ny l nz oa">require (<br/>  github.com/go-sql-driver/mysql v1.5.0<br/>  github.com/gorilla/mux v1.8.0 // indirect<br/>  github.com/satori/go.uuid v1.2.0<br/>  gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c // indirect<br/>)</span></pre><p id="e84c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面显示了我的一个项目中的一个有点混乱的<code class="fe na nb nc nd b">go.mod</code>文件。模块路径在第一行(<code class="fe na nb nc nd b">taubler.com/myapp</code>)。当然，下一行显示的是Go版本。并且在<code class="fe na nb nc nd b">require</code>块中详细说明了依赖关系。</p><p id="ec66" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，我没有自己打出来。相反，我用我的前几个Go文件创建了一个项目目录，然后运行:</p><pre class="ki kj kk kl gt nt nd nu nv aw nw bi"><span id="61b4" class="mo ls it nd b gy nx ny l nz oa">go mod init</span></pre><p id="91c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">瞧啊。这个<code class="fe na nb nc nd b">go.mod</code>文件是为我创建的。后来，我开始使用依赖项(比如上面显示的SQL驱动程序、Gorilla-MUX和UUID包)。与Maven POM文件不同，我也没有手动添加这些文件。相反，我使用惯用的方式引入依赖项，这就是<code class="fe na nb nc nd b">go get</code>命令:</p><pre class="ki kj kk kl gt nt nd nu nv aw nw bi"><span id="5efe" class="mo ls it nd b gy nx ny l nz oa">go get github.com/go-sql-driver/mysql</span></pre><p id="dacb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这下载了指定的MySQL驱动程序的最新版本。如果你注意的话，你会注意到这个包是从github得到的。与使用Maven Central(或其他类似的依赖管理器)的Java不同，go包没有专用的中央存储库。相反，使用第三方存储库；<em class="ns"> GitHub </em>似乎是最常见的一个。</p><p id="fa14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我简单地从驱动模块中导入所需的包，并在我的代码中使用它。构建并运行我的应用程序后，驱动程序出现在我的<code class="fe na nb nc nd b">go.mod</code>文件中(运行<code class="fe na nb nc nd b">go mod tidy</code>也会更新你的<code class="fe na nb nc nd b">go.mod</code>文件)。</p><p id="6ebd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一切都应该这么容易！</p><p id="ca9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="ns">模块路径和包导入</em> </strong> <br/>从Go标准库中导入包时，我们只需要指定包名。例如，我们经常想要记录日志，所以我们经常导入Go标准日志包:</p><pre class="ki kj kk kl gt nt nd nu nv aw nw bi"><span id="36fa" class="mo ls it nd b gy nx ny l nz oa">import (<br/>  "log"<br/>)</span></pre><p id="3c8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是当从一个模块导入一个包时——这包括第三方模块<em class="ns">以及我们自己的应用程序模块</em>——我们需要在包名前面加上模块路径和文件路径。</p><p id="1058" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我的项目中，我有许多独立的包。例如，我在一个<code class="fe na nb nc nd b">api</code>包中定位我的域实体。重要的是，属于每个包的文件都驻留在它们自己的目录中(例如，我的<code class="fe na nb nc nd b">api</code>包中的所有文件都驻留在<code class="fe na nb nc nd b">api/</code>目录中)。这些目录都位于我的项目根目录下的一个<code class="fe na nb nc nd b">pkg/</code>目录中。比如说:</p><pre class="ki kj kk kl gt nt nd nu nv aw nw bi"><span id="c306" class="mo ls it nd b gy nx ny l nz oa">myapp/<br/>    pkg/<br/>        api/<br/>        repository/<br/>       <em class="ns"> ... other packages ...</em></span></pre><p id="597a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我想在另一个包中使用我的<code class="fe na nb nc nd b">api/</code>包，我需要导入它。当我这样做时，我需要在导入前加上前缀</p><ul class=""><li id="bb83" class="ne nf it kw b kx ky la lb ld ng lh nh ll ni lp nj nk nl nm bi translated">我的项目的模块路径，以及</li><li id="71f9" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">包中文件的目录路径，相对于模块根目录</li></ul><p id="e129" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在许多第三方模块中，包的目录直接位于模块根目录中，所以第二点对于第三方模块来说是没有意义的。但它可以发挥作用，特别是我们自己的软件包。</p><p id="9f4a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">回想一下我的项目的模块路径是<code class="fe na nb nc nd b">taubler.com/myapp</code>。因此，当从我的一个其他包中导入<code class="fe na nb nc nd b">api</code>包时，它看起来会像这样(见下面的<strong class="kw iu">粗体</strong>):</p><pre class="ki kj kk kl gt nt nd nu nv aw nw bi"><span id="05e8" class="mo ls it nd b gy nx ny l nz oa">package main</span><span id="e860" class="mo ls it nd b gy ob ny l nz oa">import ( <br/>  "log"<br/>  "github.com/gorilla/mux"<br/>  <strong class="nd iu">"taubler.com/myapp/pkg/app"</strong><br/>)</span></pre><p id="b366" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe na nb nc nd b">“taubler.com/myapp/pkg/app”</code>是我的<em class="ns">模块路径</em> ( <code class="fe na nb nc nd b">taubler.com/myapp</code> ) +期望包 ( <code class="fe na nb nc nd b">/pkg/app</code>)的<em class="ns">路径。还要注意，当导入第三方Gorilla-MUX模块时，我指定了它的模块路径(<code class="fe na nb nc nd b">github.com/gorilla</code>)加上它的包路径(<code class="fe na nb nc nd b">/mux</code>)。</em></p><h1 id="dcf0" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">向前去学习吧</h1><p id="dd28" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我在本系列文章的开头就说过:Go是一种很好的语言，非常值得学习。即使你没有决定用Go取代Java作为你的首选编程语言，它仍然是一个值得添加到你的工具箱中的工具。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="95c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">觉得这个故事有用？想多读点？只需<a class="ae lq" href="https://dt-23597.medium.com/subscribe" rel="noopener">在这里订阅</a>就可以将我的最新故事直接发送到你的收件箱。</p><p id="362b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你也可以支持我和我的写作——并获得无限数量的故事——通过今天成为媒体会员。</p></div></div>    
</body>
</html>