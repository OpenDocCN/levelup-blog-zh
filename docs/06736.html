<html>
<head>
<title>How we Built a Frontend App for WSO2 Identity Server with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何使用React为WSO2身份服务器构建前端应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-we-built-a-frontend-app-for-wso2-identity-server-with-react-6da996c673c2?source=collection_archive---------3-----------------------#2020-12-24">https://levelup.gitconnected.com/how-we-built-a-frontend-app-for-wso2-identity-server-with-react-6da996c673c2?source=collection_archive---------3-----------------------#2020-12-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e01f5df139bbb7628977ce2c1c8e24a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Ho642hyhT3TyxnYIo9HZw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">全新的控制台应用程序</figcaption></figure><p id="4f3d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">WSO2 Identity Server一直以技术精湛和功能丰富著称。但这还不足以满足我们。为了提供无与伦比的用户体验，我们想在我们的箭筒中增加一样东西。因此，我们推出了全新的控制台应用程序！</p><p id="a448" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">WSO2 Identity Server的5.11.0版本提供了我们控制台应用程序的测试版。这个应用程序提供了一个大大改善的用户体验，允许管理员和开发人员通过一个直观和精心制作的用户界面来执行他们的任务。</p><p id="e403" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在整个发布周期中，随着我们的团队集思广益，尝试不同的实现，该应用经历了多次设计和重新设计。这是控制台应用的起源故事。</p><h1 id="0b1d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">早期</h1><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/af3fa1b376f03289013635b7ec346a37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xM5m53LzKJjJWUwO"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae md" href="https://unsplash.com/photos/9U4XBVsevfo" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/9U4XBVsevfo</a></figcaption></figure><p id="8a9f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在完成我们的用户门户应用程序(从5.11.0开始将被称为“我的帐户”应用程序)的工作后不久，我们就开始着手控制台应用程序的工作。当我们开始的时候，我们确定了一件事——那就是，就像我们的My Account应用程序一样，它将使用React编写。</p><p id="e96a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">React的虚拟DOM，使状态更新更快更有效，卓越的开发者体验，当然，JSX让它成为我们的自动选择。</p><p id="7855" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们选择语义UI来构建我们的UI，因为它允许我们在React应用程序之外使用我们创建的主题。这允许我们在React应用程序和认证门户中使用相同的主题，这些应用程序和门户都是使用JSP编写的。</p><h1 id="089f" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用单一回购</h1><p id="eb08" class="pw-post-body-paragraph kc kd iq ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz ij bi translated">由于我们的My Account应用程序也使用React和语义UI框架，我们希望重用控制台应用程序中的一些实用程序和组件。然而，由于我们继续致力于改进我的帐户的代码库，我们需要一种方法来修改可重用的代码，同时继续在控制台应用程序中使用它。</p><p id="78da" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以将可重用的代码转移到一个单独的存储库中，并将其发布到NPM注册中心，然后将其作为一个依赖项添加到我们的控制台应用程序中。但是这将严重减慢我们的开发工作流程。想象一下，如果我们要修改可重用的代码，我们将不得不修改代码，测试它，发布它，然后我们将不得不在控制台应用程序中修改依赖关系的版本以获取新的更改。</p><p id="386f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">即便如此，也不能保证这些变化会如应用程序预期的那样发挥作用。确保可重用代码做它应该做的事情的最好方法是在应用程序中测试它。</p><p id="576b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是单一回购概念拯救我们的地方。mono repo允许您在同一个存储库中拥有多个包，并允许使用一个包作为另一个包的依赖项。这完全符合我们的要求，在网上粗略研究后，我们选择了Lerna，一个稳定且受欢迎的mono repo工具。</p><p id="2442" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我们在同一个存储库中拥有了我的帐户和控制台应用程序代码。可重用的React组件已经变成了一个组件库，并存在于同一个repo的模块目录中。可重用的类型脚本代码已经被捆绑到核心模块中。</p><p id="904b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，您现在拥有的是两个不同的前端应用程序在同一个repo中共享代码。这使得维护变得轻而易举，改进了开发工作流程，并使我们的代码更易于管理。保持祝福，mono repos！</p><h1 id="fc69" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">还原还是不还原</h1><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/7c64ebd057686b62541914bcb1d92dc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aTIaQkNAophaBWiL"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae md" href="https://unsplash.com/photos/pKeF6Tt3c08" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/pKeF6Tt3c08</a></figcaption></figure><p id="cd96" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们一直在问自己，并努力回答的一个问题是，我们是否需要Redux。当然，一旦我们启动了一个React项目，我们的肌肉记忆就会告诉我们安装Redux。但是，我们真的需要Redux吗？</p><p id="c916" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个问题的答案取决于你是否需要一个全球性的单一真理来源。每个React组件都有其状态形式的真实来源，props可以用来沿着组件树向下传递数据。通过巧妙的设计组件树，或者用React思考(React的人喜欢这么称呼它)，你可以减少拥有一个全球单一的真实来源的需要。</p><p id="4cc2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通常情况下，组件调用API将它们的数据保存在后端，后端数据将作为您需要的唯一来源。除非迫切需要减少API调用的数量，或者您必须在使用之前转换返回的，否则此方法就足够了。</p><p id="6c42" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是，在某些情况下，您可能希望所有组件都能够访问特定的数据。在这种情况下，将数据作为道具传递给所有组件是多余的。这里，有一个使用像Redux这样的库的强有力的例子。但是还有更多值得思考的。</p><p id="a412" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">React的新上下文API允许任何组件订阅一个数据，从而允许组件在没有props的情况下从一个源访问数据。这个和Redux提供的差不多。那么，你选哪个？</p><p id="716d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最初，我们设法避开了对全球单一真相来源的需求。然而，我们很快意识到我们需要在全球范围内访问用户档案信息。由于用例很简单，我们考虑使用上下文API。然而，我们的需求开始变得越来越复杂。我们还需要存储运行时配置细节(稍后将详细介绍)和本地化信息。</p><p id="24b4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当我们努力在两者中选择一个时，我们也遇到了React-Redux在迁移到Context API后的性能问题，以及React开发人员反对将Context API视为Flux类架构的替代品的建议。</p><p id="d35a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后来了决定性的一击。当我们想要访问React组件/JSX文件之外的单一真实来源时。Redux提供了一个API来允许我们访问React之外的状态，而使用上下文API是不可能的。所以，我们用Redux继续前进。</p><h1 id="1a4e" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">函数还是类？</h1><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/0cdc7b75adfb0d98b8f757e1035c79dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ixFB23tD6cRSalvv"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae md" href="https://unsplash.com/photos/8xAA0f9yQnE" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/8xAA0f9yQnE</a></figcaption></figure><p id="311a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有了钩子，React使功能组件和基于类的组件一样强大，很快我们就必须决定使用哪一个。我个人喜欢所提供的生命周期方法和基于类的组件的分类，并对hooks替换基于类的组件功能的能力有所疑虑。</p><p id="a8b6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，我们想要逃离基于类的组件中的高阶组件包装器地狱，并且反对一些暗示功能组件可能是未来的生命周期方法。因此，我们决定继续使用功能组件。</p><p id="ca83" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最初，我们发现不得不使用<code class="fe mj mk ml mm b">useEffect</code>钩子而不是生命周期方法令人窒息，但是随着时间的推移，无可否认地，功能组件开始在我们身上增长。一旦我们掌握了钩子的窍门，我们发现函数比类简单和直接得多。迁移在开始时是一项令人生畏的任务，但是一旦你开始从功能组件的角度考虑，请放心，你会爱上它的。</p><p id="c00c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这并不意味着功能组件不是没有缺点，因为当我们需要误差边界时，我们很快就知道了。错误边界确保组件中的错误不会破坏整个应用程序。相反，您可以在组件内处理错误并显示回退UI。但问题是在功能组件中不可能有错误边界。</p><p id="f2e3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，我们决定用一个基于类的组件来包装给定页面上的功能组件，这样，它最多是一个会断开的页面。</p><h1 id="bfd5" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">惰性装载</h1><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/7a46862f6f0f9a0eeb90176017ff586f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4l7kPYORF2hMtcGw"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae md" href="https://unsplash.com/photos/ri0ylwID5ao" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/ri0ylwID5ao</a></figcaption></figure><p id="b6b4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">随着我们的应用程序接近成熟，我们意识到最终的包有几兆字节大小。如此大的脚本文件将导致应用程序加载的相当大的延迟，对应用程序的用户体验产生负面影响。我们想减小包装的尺寸，以加快装载速度。</p><p id="2ce7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当然，我们做了显而易见的事情——我们分析了我们的依赖关系，并尝试用较小的替代方案替换较大的依赖关系。但是这并没有显示包大小有任何显著的改进。我们很快就接受了这样一个事实:我们的应用程序很大，因此我们的捆绑包也会很大。</p><p id="5271" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，我们必须将代码分成多个块。动态导入帮助我们创建代码块，并确保它们只在用户需要时才被加载。因此，当用户加载应用程序时，只加载呈现登录页面所需的代码。当用户在应用程序中导航时，可以动态加载所需的块。这解决了应用程序需要很长时间加载的问题。</p><p id="44ab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">React更进一步，帮助我们使用React Lazy特性将动态导入呈现为常规组件。我们需要做的只是将一个函数作为参数传递给React.lazy()方法，该函数将返回一个动态导入。</p><p id="550d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但这带来了一个新问题。假设您正在延迟加载一个组件。该应用程序必须等到所需的代码块加载后才能呈现组件。在此之前，您不会在组件的位置看到任何东西。这将影响用户体验。理想情况下，我们应该显示一个加载器，直到组件被加载。怎么才能做到呢？</p><p id="8957" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">别担心，React(再一次)支持你。惰性加载组件实际上应该在悬念组件中呈现。暂记组件的回退属性接受将被呈现的回退组件，直到延迟加载的组件准备好为止。</p><p id="5d57" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用React的延迟加载允许我们的应用程序在加载时间上显示出巨大的改进，这是所有大型应用程序中必须使用的。</p><h1 id="dc6e" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">运行时配置</h1><p id="fb1c" class="pw-post-body-paragraph kc kd iq ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz ij bi translated">我们希望我们的应用是可配置的。不，我们不希望我们的用户只是为了改变品牌而钻研代码。我们想要一种无代码的方式来做这件事。并且应该在运行时完成。</p><p id="8e3a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，我们创建了一个JSON文件，其中将存储所有部署配置细节。应用程序在初始化期间调度GET请求来加载该文件。一旦收到响应，我们就解析这个JSON文件，并将结果对象存储在一个全局变量中。</p><h1 id="d1e2" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">动态重塑应用品牌</h1><p id="70db" class="pw-post-body-paragraph kc kd iq ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz ij bi translated">应用程序将访问这个全局变量来加载相关的配置。例如，应用程序的名称就是从这个配置中获得的。所以，现在你知道应该做些什么来改变应用程序的名称。更改JSON文件中的名称，重新加载应用程序，瞧，标题中的名称也更改了！</p><h1 id="27ca" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">支持Internet Explorer</h1><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/8ab175fc37a590964eeb82144f44c675.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dG_QcJY3bgsRSrJ-"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae md" href="https://unsplash.com/photos/anaUCgS2fqE" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/anaUCgS2fqE</a></figcaption></figure><p id="706c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的一些客户继续使用Microsoft Internet Explorer和Microsoft Edge Legacy，我们必须确保我们的应用程序在这些浏览器中运行良好。因为在大多数其他浏览器中工作的一些本地API在微软的传统浏览器中不工作，所以我们的工作被砍掉了。</p><p id="f1af" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们最初尝试聚合填充不受Internet Explorer支持的API，但我们很快发现手动聚合填充所有缺失的浏览器API几乎是不可能的。此外，我们还遇到了一些CSS在Microsoft Internet Explorer中无法正常显示的问题。所以，我们不得不寻找一个替代方案。</p><p id="27b0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">进入巴别塔。从ts-loader切换到babel-loader允许我们将代码移植到Internet Explorer上运行。此外，我们将babel配置为使用core-js来填充在Explorer中不工作的API。</p><p id="778d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是这并不能解决CSS问题。因此，我们使用autoprefixer包和postcss-loader for webpack来传输css，以便在Internet Explorer中正确呈现。</p><p id="418c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是，聚合填充最终会增加最终束的大小。你必须在支持不同的浏览器和确保这不会影响应用程序在最常用的浏览器中的性能之间做出权衡。至于你在哪里划定界限，说我们不支持这些浏览器，这取决于开发者。</p><p id="8ee7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是你如何告诉Babel和autoprefixer这些是你打算支持的浏览器呢？那么，package.json文件中的browserslist属性允许我们以一种非常简单的方式传达这些信息。您可以在一个数组中提到您想要支持的浏览器的名称，或者像我们所做的那样，您可以决定支持浏览器——基于它们的市场份额。我们将其设置为大于0.2%，这意味着我们的应用程序将在市场份额大于0.2%的浏览器上运行。</p><h1 id="f21c" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">包扎</h1><p id="7fff" class="pw-post-body-paragraph kc kd iq ke b kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz ij bi translated">旅程并没有结束。毕竟，我们只发布了该应用的测试版。随着我们不断努力改进所有应用程序并增加新功能，我们确信将会有更多的冒险经历和经验教训。截至目前，我们的控制台应用程序正在准备经历另一个完善和丰富的发布周期。</p></div></div>    
</body>
</html>