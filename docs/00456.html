<html>
<head>
<title>Circuit Breaker in a Functional World</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">功能世界中的断路器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/circuit-breaker-in-a-functional-world-9c555c8e9527?source=collection_archive---------1-----------------------#2019-03-10">https://levelup.gitconnected.com/circuit-breaker-in-a-functional-world-9c555c8e9527?source=collection_archive---------1-----------------------#2019-03-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/28170135237e3fee0ce1d19cdade74e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LmdNCtyIoiM7aNX7ZGBv4A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">电路断路器内部构件</figcaption></figure><p id="35a1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">今天，我想谈一谈企业架构中最常用的模式之一——断路器——及其使用纯功能方法的实现。为了使它更有趣，我将把它实现为一个TypeScript模块——这样您就可以在您的前端应用程序中使用它。</p><blockquote class="la lb lc"><p id="f452" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated"><em class="iq">注意:所述包装的设计灵感来自于</em> <a class="ae lh" href="https://hackage.haskell.org/package/glue-core-0.4.2/docs/Glue-CircuitBreaker.html" rel="noopener ugc nofollow" target="_blank"> <em class="iq">胶水。断路器</em> </a> <em class="iq">模块为Haskell。模块本身在这里有:</em><a class="ae lh" href="https://github.com/YBogomolov/circuit-breaker-monad" rel="noopener ugc nofollow" target="_blank"><em class="iq">github://断路器-monad </em> </a> <em class="iq">。</em></p></blockquote><h1 id="e3cd" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">什么是断路器？</h1><h1 id="4e58" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">背景和问题定义</h1><p id="3ae4" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">您的应用程序正在通过某种协议与第三方服务进行通信。它可能是一个HTTP API、一个socket API，或者其他什么东西，但是它的主要特征是:</p><ul class=""><li id="e016" class="ml mm iq ke b kf kg kj kk kn mn kr mo kv mp kz mq mr ms mt bi translated">你不能控制网络的可靠性，所以数据包可能会被随机丢弃。</li><li id="b018" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated">您无法控制服务的可靠性，因此它可能会在意想不到的时候失败。</li><li id="011c" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated">服务错误和网络故障是暂时的。一段时间后，服务和环境会自我恢复。</li><li id="ab36" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated">如果服务在一定的超时时间后没有响应，请求将被视为失败。</li></ul><h1 id="d852" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">解决办法</h1><p id="5f62" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">断路器是一种设计模式，类似于具有以下状态的简单<a class="ae lh" href="https://en.wikipedia.org/wiki/Finite-state_machine" rel="noopener ugc nofollow" target="_blank">有限状态机</a>:</p><ol class=""><li id="07f3" class="ml mm iq ke b kf kg kj kk kn mn kr mo kv mp kz mz mr ms mt bi translated"><strong class="ke ir">关闭</strong> —请求被直接传输到服务。如果请求失败，内部错误计数器增加。如果某个时间跨度内的错误量大于给定的阈值，断路器的状态变为<strong class="ke ir">打开</strong>，并且内部计时器启动——断路器给外部服务一些时间来恢复。定时器到时，状态变为<strong class="ke ir">半开</strong>。</li><li id="623b" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mz mr ms mt bi translated"><strong class="ke ir">打开</strong> —请求立即完成，但出现错误。</li><li id="db1a" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mz mr ms mt bi translated">半开 —在这种状态下，第一个请求(从现在开始我称它为<em class="ld">金丝雀请求</em>)被允许传递给服务。如果金丝雀请求成功，则认为错误已解决，电路再次进入<strong class="ke ir">关闭</strong>状态。</li></ol><p id="0e81" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是对断路器模式的简单描述。你可能想阅读Martin Fowler 的一篇博客文章，这篇文章讲述了断路器使用传统命令式语言的实现。</p><h1 id="96ce" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">功能实现的挑战</h1><p id="15c3" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">当您阅读该模式的描述时，您可能已经注意到断路器是一个有状态模式，并且它需要该状态的原子变化(因为您希望这个东西尽可能健壮，因为它应该处理所有网络请求的<em class="ld">。</em></p><p id="4bb8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在函数世界中，我们有一种方法来实现这样的需求:一个<strong class="ke ir">IORef</strong>monad——IO monad中的一个可变变量。基本上，它让你拥有一段(纯)功能代码，与(不纯的)外部世界交流，并自动修改那些计算中的变量。你可能想看一看<a class="ae lh" href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-IORef.html" rel="noopener ugc nofollow" target="_blank">它是Haskell实现</a>以获得更多细节。</p><h1 id="8811" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">履行</h1><p id="4743" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">让我们深入研究代码！作为我选择的库，我将使用令人敬畏的<a class="ae lh" href="https://github.com/gcanti/fp-ts" rel="noopener ugc nofollow" target="_blank"> fp-ts </a>，它已经实现了<code class="fe na nb nc nd b">IORef</code>，以及<code class="fe na nb nc nd b">Task</code>、<code class="fe na nb nc nd b">Either</code>和它们的组合(<code class="fe na nb nc nd b">TaskEither</code>)单子。</p><p id="8d62" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，我们来定义一下自己的基本逻辑。</p><ol class=""><li id="c954" class="ml mm iq ke b kf kg kj kk kn mn kr mo kv mp kz mz mr ms mt bi translated">断路器是一个网络请求的代理包装器，我们将它建模为一个简单的【thunk，将调用的实现留给用户——无论他或她将使用<code class="fe na nb nc nd b">fetch</code>、普通ol’<code class="fe na nb nc nd b">XMLHttpRequest</code>还是<code class="fe na nb nc nd b">axios</code>，这都无关紧要。</li><li id="a2b8" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mz mr ms mt bi translated">当我们使用无状态函数方法来建模有状态断路器时，我们将利用一种通用的抽象技术，将状态作为主函数的参数。</li><li id="1ffa" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mz mr ms mt bi translated">断路器调用的结果我们将建模为调用的下一个状态和延迟结果的元组。我们通常使用<a class="ae lh" href="https://github.com/gcanti/fp-ts/blob/master/docs/modules/Task.ts.md" rel="noopener ugc nofollow" target="_blank">任务</a>来表示异步交互，但是请求可能会失败，导致我们也使用<code class="fe na nb nc nd b">Either</code>单子。因此，最终的调用将使用一个<a class="ae lh" href="https://github.com/gcanti/fp-ts/blob/master/docs/modules/TaskEither.ts.md" rel="noopener ugc nofollow" target="_blank">任务或者</a>单子来建模。</li></ol><p id="8ea2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们将断路器的状态表示为sum类型:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="la lb lc"><p id="0d0c" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated"><em class="iq">注意，我没有定义</em> <code class="fe na nb nc nd b"><em class="iq">BreakerHalfOpen</em></code> <em class="iq">状态。只有有状态实现才需要它，在有状态实现中，breaker本身控制它的状态。但是当我们使用“倒置”功能方法时，可以从当前时间和</em> <code class="fe na nb nc nd b"><em class="iq">BreakerOpen</em></code> <em class="iq">的有效载荷、</em> <code class="fe na nb nc nd b"><em class="iq">timeOpened</em></code> <em class="iq">的组合中容易地推断出“半开”状态。</em></p></blockquote><p id="4dd1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">给定这些状态，我们的主断路器服务可以这样定义:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="9986" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe na nb nc nd b">callIfClosed</code>的实现非常简单:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="a5ea" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">功能<code class="fe na nb nc nd b">incErrors</code>用于在错误计数达到阈值时，将断路器的状态从“闭合”更改为“断开”:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="4c56" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">功能<code class="fe na nb nc nd b">callIfOpen</code>比较有意思。请记住，如果超时结束，我们需要传递一个请求！</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ef63" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们谜题的最后一部分<code class="fe na nb nc nd b">canaryCall</code>，非常简单:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="bf99" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="f277" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">现在你有了一个(几乎)纯功能性的断路器模式！为了让它更有用，最好为<code class="fe na nb nc nd b">MAX_BREAKER_FAILURES</code>、<code class="fe na nb nc nd b">RESET_TIMEOUT</code>和<code class="fe na nb nc nd b">BREAKER_ERROR_DESCRIPTION</code>变量提供配置。我喜欢用<code class="fe na nb nc nd b">Reader</code>单子来做这件事。所以你可以在这里找到最后一个实现:<a class="ae lh" href="https://github.com/YBogomolov/circuit-breaker-monad" rel="noopener ugc nofollow" target="_blank">github://circuit-breaker-monad</a>。星，叉，并尝试在您的项目中使用！如果你有什么建议或者发现了什么问题，请在<a class="ae lh" href="https://github.com/YBogomolov/circuit-breaker-monad/issues" rel="noopener ugc nofollow" target="_blank">问题版块</a>给我写信。</p><p id="9f06" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我很乐意了解你的经历，所以请给我回电话，电报回复<a class="ae lh" href="https://t.me/ybogomolov" rel="noopener ugc nofollow" target="_blank"> @ybogomolov </a>，推特回复<a class="ae lh" href="https://twitter.com/YuriyBogomolov" rel="noopener ugc nofollow" target="_blank"> @YuriyBogomolov </a>，或者通过<a class="ae lh" href="mailto:yuriy.bogomolov@gmail.com?subject=Circuit%20Breaker%20as%20a%20Monad%20feedback" rel="noopener ugc nofollow" target="_blank">yuriy.bogomolov@gmail.com回复</a>。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><figure class="ne nf ng nh gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi nr"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure><div class="ns nt gp gr nu nv"><a href="https://gitconnected.com/learn/typescript" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">学习TypeScript -最佳TypeScript教程(2019) | gitconnected</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">18大TypeScript教程-免费学习TypeScript。课程由开发人员提交并投票，从而实现…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">gitconnected.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj jw nv"/></div></div></a></div></div></div>    
</body>
</html>