<html>
<head>
<title>Algorithm Complexity and the Big O</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法复杂性和大O</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/algorithm-complexity-and-the-big-o-cb703e093faa?source=collection_archive---------1-----------------------#2019-03-12">https://levelup.gitconnected.com/algorithm-complexity-and-the-big-o-cb703e093faa?source=collection_archive---------1-----------------------#2019-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a3c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着我对数据科学和编程的进一步了解，编写计算效率高的代码的想法变得越来越重要。雇主面试问题以及我个人在尝试运行更复杂的算法时遇到的困难都证明了这一点。</p><p id="1f36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理解这个概念并能够应用它是有好处的。我认为我理解算法复杂性的一般概念，但随着我作为一名数据科学家的不断成长，我希望有一个更明确的理解。在做任何正式的研究之前，下面是我对算法复杂性的定义，我将在这篇博文中进行介绍:</p><blockquote class="kl km kn"><p id="4283" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">“一个函数需要完成多少次操作或循环，以及重复这些操作或循环的次数，以完成一次迭代。”</p></blockquote></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><p id="b28b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，这真的是我在写这篇博客之前的定义。算法复杂性在理论计算机科学中被大量讨论，可以被认为是一种正式衡量程序或算法运行速度的方法。</p><p id="2ef0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个话题有意思的地方在于，刚开始编程的时候没必要去理解它(或者至少我没在想这个问题)。起初，我只是希望我的算法能够正确运行。然后，我希望它们以一种可读的方式编写——一种让我在审查之前编写的代码时容易理解的方式。但是随着我的算法开始增长，随着我开始考虑更大的问题，需要更好的解决方案。</p><p id="1760" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在有许多例子表明，有些人虽然没有正式学习过这个话题，但可能理解其核心原理，并在计算机科学领域非常成功。不幸的是，我这样学得不好，通常需要一个正式的回顾，以便让他们坚持下来，让我对他们的范围有一个彻底的理解。所以如果你和我一样，我希望下面的算法复杂性之旅能有所帮助！</p></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><h1 id="b43b" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">基础知识</strong></h1><p id="b12d" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">首先，解释算法完成所花费的运行时间并不一定转化为算法的复杂性是很重要的。运行时间会受到编程语言、使用的硬件或CPU指令集的影响。所以我们希望有一种方法可以取出这些变量，以便能够准确地进行比较。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mj"><img src="../Images/71dad57e8c41490876e6018fcc257397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ILITOkN7KkapwI6_.jpg"/></div></div></figure><p id="8d54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">分析器是以毫秒为单位测量运行时间的程序，可以识别代码中的瓶颈，因此可以使用识别运行时间来识别算法在哪里变慢。然而，算法复杂性是我们希望在理念层面(剔除变量)比较算法的概念。例如，用低级编程语言(<a class="ae mq" href="https://en.wikipedia.org/wiki/Assembly_language" rel="noopener ugc nofollow" target="_blank">汇编</a>)编写的糟糕算法可能比用Python或Ruby编写的好算法有更快的毫秒运行时间。那么我们如何在理念层面比较算法呢？</p><p id="7f4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过复杂性分析来做到这一点。这表明程序执行计算的速度有多快。一个很好的例子是在字符串上运行<a class="ae mq" href="https://www.regular-expressions.info" rel="noopener ugc nofollow" target="_blank">正则表达式</a>来返回定义模式的匹配。这允许我们解释当输入大小增加时算法如何表现。这个想法是，如果你能够精确地测量一个小输入的输出，那么你就可以推断出随着输入的增加，这个输出会如何变化。</p><p id="2dc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，为了测量复杂性，我们需要定义算法执行计算的意义。这发生在使用基本指令时，基本指令是CPU必须直接执行的简单任务。其中包括:</p><ul class=""><li id="1247" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated">给变量赋值</li><li id="8127" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">查找数组中的特定元素</li><li id="09ca" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">比较两个值</li><li id="b1d7" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">增加一个值</li><li id="d361" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">基本算术(加法、乘法等。)</li></ul><p id="a69a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的目标是计算发生的基本指令的数量。</p></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><p id="0d14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当计算一个算法的指令时，你是在一个<strong class="jp ir">“最坏情况分析”</strong>的思维框架中计算的。这采用了算法的“路径”,该路径将导致大多数指令被执行。得到的计数可能类似于f(n) = 6n + 4，其中6n可以表示这个特定函数每次迭代执行的指令数，而4表示无论输入大小如何都会出现的指令数。如果这是令人困惑的，不要太担心，理解这一点并不是最重要的，以掌握你将很快看到的整体概念。如果你想要进一步的解释，博客底部的链接和这个链接都是很好的资源。</p><p id="3394" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">退一小步，我们感兴趣的是当我们的算法被挑战去做一些困难的事情时，它是如何表现的。如果一种算法在处理大量输入时胜过另一种算法(比另一种算法快),那么对于更简单、更小的输入，通常也是如此。因此，第一步是从计数函数中删除所有增长缓慢的项。随着n的增加，上面例子中的4(6n+4)变得越来越不重要，所以我们去掉了4，因为它“增长缓慢”。从几千或几百万的角度来看，如果n = 1000，(6*1000 + 4)，数字4就没什么意义了。</p><p id="67c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是把常数乘数放在n(6)前面。现在我们只剩下原始方程中的n。其原因同样与不同的编程语言如何不同地编译有关，导致生成相同的输出需要不同数量的n。抛开这一点，我们忽略编程语言和编译器之间的差异，只分析算法本身的思想。</p></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><p id="21dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">刚才描述的过程是<strong class="jp ir">渐近行为</strong>，我们丢弃所有无关紧要的因素，只保留最大的增长项。</p><ul class=""><li id="ff53" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated">f(n) = 2n + 8将导致f(n) = n</li><li id="d8c8" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">f(n) = 109将导致f(n) = 1，所有其他常数也是如此。</li></ul><p id="4b6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们感兴趣的是接近无穷大时函数的极限，因为我们测试的是大输入。在严格的数学环境中，我们不能在确定极限时去掉常数，但是为了计算机科学的目的，我们可以这样做。这里还有几个例子来说明这个概念。</p><ul class=""><li id="54bd" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated">f(n) = n + 3n +112将导致f(n)= n。n变得大于3n，所以我们保留n</li><li id="6946" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">f(n) = n + 1999n + 1337将得到n</li><li id="b1e8" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">f(n) = n +平方根(n)将得到n</li></ul><p id="2a14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快速回顾一下:</p><ul class=""><li id="fc15" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated">任何没有for循环(没有迭代)的函数的复杂度应该是1，因为它需要的指令数只是一个常数(除非它使用递归，我将在后面介绍)。</li><li id="229b" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">任何具有从1到n的单个for循环的函数将具有n的复杂度，因为它将在循环之前执行恒定数量的指令，在循环之后执行恒定数量的指令，并且在循环内执行恒定数量的指令，所有这些都运行n次。</li><li id="26cc" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">嵌套在另一个for循环中的for循环的复杂度为n。如果在for循环中嵌套了一个函数，并且我们知道该函数执行n个函数，那么总复杂度也为n。</li><li id="722f" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">给定一系列for循环，最慢(或最坏情况)的循环决定了函数的渐近行为。</li></ul></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><p id="9e2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们已经计算出一个函数的复杂度时，我们说我们的函数是(1)的θ，它被表示为这样的ɵ(1，并被外推为其他函数的ɵ(n或ɵ(n。我们也可以把2n∈ɵ(n)读作“两个n是n的θ”。这仅仅意味着我们已经把一个程序需要和产生的指令数计算为2n。然后，我们算法的渐近行为将由n来描述。以下是正确的:</p><ul class=""><li id="bf43" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated">n^6+3n∈ɵ( n^6)</li><li id="7523" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">2^n+12∈ɵ( 2^n)</li><li id="62d6" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">3^n+2^n∈ɵ( 3^n)</li><li id="b3ce" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">n^n+n∈ɵ( n^n)</li></ul><p id="846a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个函数的时间复杂度(或者仅仅是复杂度)是我们在ɵ(here).中的所以ɵ(n)的复杂度为n。以下是常见的复杂度列表:</p><ul class=""><li id="1470" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated">ɵ(1)=常数时间算法</li><li id="e72e" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">ɵ(n)=线性</li><li id="8045" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">ɵ(n)=二次</li><li id="dc41" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">ɵ(log(n))=对数</li></ul><p id="0d30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总结一下复杂性，<strong class="jp ir">具有较大ɵ的算法比具有较小ɵ.的算法运行得慢</strong></p></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><h1 id="e0d7" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">大O批注</strong></h1><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="nf lf l"/></div></figure><p id="7806" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了算法复杂度的概念，以及如何比较两种算法的复杂度，我们可以开始把它转换成大O格式。对于更复杂的算法，发现复杂性可能是困难的。然而，可以更容易地说，它永远不会超过某个界限。因此，我们不需要找到它运行的确切速度(复杂性)，我们只需要找到算法的具体界限。</p><p id="d3c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了定义一个算法的边界，我们首先通过使一个算法变得比现在更糟来发现它的复杂性。这就是更好算法的上限。这可能看起来没用，但是通过找到“更差”的算法，你可以说类似O(n)，“n的平方的大oh”。这意味着我们的程序在渐近上不会比n差，只是为了说明这一点，让它变得更差可能只是在for循环中增加了一个额外的变量，这根本不会增加复杂性，但仍然会增加一个额外的基本指令。</p><p id="48df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ɵ(n)= o(n)的算法。但是O(n)的程序可能不总是等于ɵ(n)。任何是ɵ(n的程序)除了是O(n)外，也是O(n)。这种思路的一般公式是ɵ(a)是O(b)当O(b)更差时。</p><p id="5fb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，o给出了实际复杂度的上限，而ɵ给出了实际复杂度。实际的复杂性也被称为<strong class="jp ir">紧束缚的</strong>。</p></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><p id="950f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果一个算法是ɵ(n)，那么它的复杂度是n。这个算法是O(n)和O(n)。o(n)是紧束缚的，而O(n)不是，所以我们可以说O(n)，" n的平方的小O。"紧界给了我们更多的信息，因此如果能找到它们就更好了。</p><p id="177f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">o告诉我们一个上界，我们的算法永远不会比指定的慢。如果我们使我们的算法<strong class="jp ir">更好</strong>，我们使用欧米伽(𝝮，“大欧米伽”)。𝝮告诉我们一个复杂性，我们知道我们的算法不会更好。说一个程序是𝝮(n)意味着这个程序并不比n好。𝝮给了我们一个复杂度的下界。我们也可以写𝞈(一个小写的欧米伽，“小欧米伽”)来表示下界不紧。如果我们有ɵ(n的算法，那么o(n⁴和𝞈(n会准确地描述它。</p><p id="9886" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们不想仔细检查一个算法时，o和𝝮是有用的。查看下图查看刚才描述的所有内容。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/c31b1a711bbf170c8f72c61a2b851642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*SRiQdtQgty5fcZ1Ov5Nf7g.png"/></div></figure></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><h1 id="1929" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">对数</strong></h1><p id="9b17" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">对数会问这样一个问题，当我把一个数提高到多少次方时，它会给我正确的结果。一个公式化的例子是2^x = 16。在这种情况下，x = 4，所以我们可以说以2为底的16的对数是4。对数的底(2)显然可以改变。如果你对对数不熟悉，想要一个有用的解释，我发现<a class="ae mq" href="http://tutorial.math.lamar.edu/Classes/Alg/LogFunctions.aspx" rel="noopener ugc nofollow" target="_blank">这个</a>教程很棒。正如平方根是平方的倒数，对数是指数的倒数。</p></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><h1 id="62f0" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">递归复杂度</strong></h1><p id="8a09" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">如果你不熟悉编码中的递归概念，我的朋友Tom Grigg有一篇文章<a class="ae mq" href="https://towardsdatascience.com/finding-a-recursive-solution-184784b0aea0" rel="noopener" target="_blank">在这里</a>，这篇文章非常好，是我遇到的最好的解释。</p><p id="286d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单地说，递归函数就是调用自身的函数。虽然这是一个很难理解的概念，但它的复杂性是相当简单的。对于一个简单的<strong class="jp ir">递归问题，复杂度将是ɵ(n)</strong>。在不使用for循环的情况下，您几乎可以将递归视为for循环。如前所述，不管循环执行多少次，复杂度都是ɵ(n).同样的思想也适用于递归。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/89e269ccfc467864a827f8ad2e21eb85.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*M6d--iOZtApGg6DKZ36VRg.png"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">求解一个数的阶乘的简单递归问题</figcaption></figure><h1 id="4dff" class="lg lh iq bd li lj nm ll lm ln nn lp lq lr no lt lu lv np lx ly lz nq mb mc md bi translated"><strong class="ak">对数复杂度</strong></h1><p id="b416" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">试图解决的一个著名的计算机科学问题是在数组中搜索一个值。二分搜索法结合了我们刚刚谈到的递归函数和以2为底的对数。以2为底的对数经常在代码中使用，因为它可以被视为二进制解决方案(输出将是0或1 ),并且可以用于对不同类型的问题进行分类。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nr"><img src="../Images/38f57fc444f4c82797dad782ab6625ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A4obK95yhiKkjlKHRNeWgw.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">二分搜索法的伪代码</figcaption></figure><p id="29b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一般来说，我们的数组会随着每次调用分成两半，直到我们达到1。因此，每个数组中元素的数量如下:</p><ol class=""><li id="ac2c" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk ns mx my mz bi translated">第0次迭代:n</li><li id="c5fa" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk ns mx my mz bi translated">第一次迭代:n / 2</li><li id="2f13" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk ns mx my mz bi translated">第二次迭代:n / 4</li><li id="4fe7" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk ns mx my mz bi translated">第三次迭代:n / 8</li><li id="2b82" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk ns mx my mz bi translated">第I次迭代:n / (2^i)</li><li id="29f3" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk ns mx my mz bi translated">上次迭代:1</li></ol><p id="5c22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可以解释为将其元素数除以2，也就是将分母乘以2。如果我们这样做I次，我们得到n / (2^i)，其中n是数组的大小，I是达到基本情况或正确答案所需的迭代次数。按照这个函数，随着我变大，结果将趋向于1。一旦该函数减少到1 = n/(2^i)，就达到了基本情况，并且只剩下1个元素被搜索。</p><p id="d3a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们有1 = n/(2^i)…</p><ul class=""><li id="8aae" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated">这就简化为2^i = n……这看起来很像我们之前提到的对数问题，因为它是对数问题，我们可以这样对待它。</li><li id="3f67" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">当i = log(n)时，求解该二分搜索法所需的迭代次数为log(n ),其中n是原始数组中的元素</li></ul><p id="2feb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种情况的一个简化版本是用一个32的数组。这将被简化为如下一个要素:</p><ul class=""><li id="3777" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi">32 → 16 → 8 → 4 → 2 → 1</li><li id="f589" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">这是将初始数组减半的5次迭代。因此<strong class="jp ir">ɵ(log(n是二分搜索法的复杂性)</strong>。这使我们能够比较二分搜索法和线性。由于log(n)比n小得多，我们也可以假设它快得多。最终结果将是，如果我们要执行许多搜索，我们希望保持我们的结果排序，因为这样更快。</li></ul><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/1b559481ab0bc86f5a4caad0d2fa9023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*NRCzdxxwnHMN7ITQTmQLIA.png"/></div></figure><p id="3673" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以上是函数n、n的平方根和log( n)的比较。顶部以绿色绘制的线性函数n比中间以红色绘制的平方根函数增长快得多，而平方根函数又比底部以蓝色绘制的log( n)函数增长快得多。即使对于n = 100这样的小n，差异也是相当显著的。</p></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><h1 id="a47f" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">归并排序问题</strong></h1><p id="555f" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">另一个常见的计算机科学问题是将两个数组合并在一起，并创建一个新的排序数组。这类似于上面描述的二分搜索法，只是在这种排序中，我们保留了原始数组的两半。类似于二分搜索法，我们不断地将一个数组分成两半，但是因为我们每次都保留一半的数组，所以每次递归“级别”的总数等于1N。随之而来的是，每一个人的“水平”的复杂性将是ɵ(n).从前面对二分搜索法的解释中，我们知道递归问题的复杂性在于它的深度(或递归在对数表达式中出现的次数，ɵlog(n)).结合这两个独立的逻辑，我们可以得出结论，合并排序问题的<strong class="jp ir">复杂度将是ɵ(n log(n))</strong>，递归的“层”的数量乘以递归深度。</p><div class="kz la lb lc gt ab cb"><figure class="nu ld nv nw nx ny nz paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><img src="../Images/0525a000e059e535fdc0b151eadb841e.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*AEOQd9BSpQQbPyaJVaD8Yw.png"/></div></figure><figure class="nu ld oa nw nx ny nz paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><img src="../Images/e791b91a9fe1b93e5bd6ceba22399c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*Ql3aawsuJnpM2wXWIfUNmQ.png"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk ob di oc od translated">左:二分搜索法—右:合并排序的递归树</figcaption></figure></div></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><h1 id="e4b7" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">总之</strong></h1><p id="e02d" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">重温我最初的定义，我认为我的思路是正确的，但经过进一步的研究，这个话题对我来说肯定是清楚的，我现在对算法复杂性的真正含义以及它与大O符号的关系有了更好的理解。</p><p id="8a15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在阅读和理解了上面的所有内容后，我发现了几个非常有用的备忘单，它们有助于总结不同算法之间的比较，并且非常适合快速参考。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi oe"><img src="../Images/cee60e87d06cafeb3867552baf0f6b92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9j-jajhn73eLxPHZ0iPPlQ.png"/></div></div></figure><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi of"><img src="../Images/41937dcc4e9d92813c0867550dc1d34d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9NaF6hb3_5d4z56PnA2TPg.png"/></div></div></figure><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi og"><img src="../Images/2919f9c14950c8b706f8ed17160b86ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*ridvGcDyW0iSMjTMU5lr7Q.png"/></div></figure><p id="f762" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢你的阅读，我希望你喜欢它，并像我现在一样有更好的理解。如果你有任何问题，请告诉我，我很乐意尽力回答。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="oh lf l"/></div></figure><p id="e082" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还需要对Dionysis Zindros大呼小叫，他的关于算法复杂性的文章，列在下面，对我理解这个主题有很大的帮助，并提供了很好的例子来加强我的想法。</p><div class="oi oj gp gr ok ol"><a href="https://discrete.gr/complexity/" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">算法复杂性分析简介</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">然而，理论计算机科学有它的用途和应用，可以证明是非常实用的。在这个…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">离散型. gr</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz mo ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="http://bigocheatsheet.com/" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">Big-O算法复杂性备忘单(了解你的复杂性！)@ericdrowell</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">你好。这个网页涵盖了计算机科学中常用算法的空间和时间复杂性。当…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">bigocheatsheet.com</p></div></div><div class="ou l"><div class="pa l ow ox oy ou oz mo ol"/></div></div></a></div></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><div class="kz la lb lc gt ol"><a href="https://gitconnected.com/learn" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">了解如何编码-查找编码教程| gitconnected</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">使用我们完整的编码资源列表学习任何编程语言或框架。我们分享、汇总和排名…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">gitconnected.com</p></div></div><div class="ou l"><div class="pb l ow ox oy ou oz mo ol"/></div></div></a></div></div></div>    
</body>
</html>