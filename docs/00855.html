<html>
<head>
<title>How to build a REST API with gRPC and get the best of two worlds</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用gRPC构建REST API，两全其美</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-a-rest-api-with-grpc-and-get-the-best-of-two-worlds-9a4e491f30ae?source=collection_archive---------0-----------------------#2019-08-26">https://levelup.gitconnected.com/how-to-build-a-rest-api-with-grpc-and-get-the-best-of-two-worlds-9a4e491f30ae?source=collection_archive---------0-----------------------#2019-08-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dd45" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从OpenAPI描述中构建一个具有REST支持的gRPC服务。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/698a915edc23cc2c6bcc891c500b4504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XVHp9X1G8cHz3rW3sq0vHQ.png"/></div></div></figure><p id="121f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为这个谷歌代码之夏项目的一部分，我有机会与Tim和Noah(谷歌的两位软件工程师)一起开发一个叫做<a class="ae ln" href="https://github.com/googleapis/gnostic-grpc/" rel="noopener ugc nofollow" target="_blank"> gnostic-grpc </a>的工具。该工具将OpenAPI v3.0 API描述转换为gRPC服务的描述，可以使用gRPC-JSON代码转换来实现该API。gRPC服务是用协议缓冲区语言描述的。proto)。</p><p id="3bd4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了gRPC服务的转换描述，您可以用您选择的任何编程语言生成API。</p><p id="3a64" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你需要gRPC、OpenAPI和协议缓冲区的介绍，我向<a class="ae ln" href="https://medium.com/apis-and-digital-transformation/openapi-and-grpc-side-by-side-b6afb08f75ed" rel="noopener">推荐Tim的这篇</a>优秀博客。</p><p id="09ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下教程假设您对协议缓冲区和<a class="ae ln" href="https://github.com/protocolbuffers/protobuf#protocol-compiler-installation" rel="noopener ugc nofollow" target="_blank">协议编译器</a>的设置有基本的了解。</p><h1 id="8655" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">教程— gRPC网关插件</h1><p id="977f" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">本教程有七个步骤:</p><ol class=""><li id="3925" class="ml mm iq kt b ku kv kx ky la mn le mo li mp lm mq mr ms mt bi translated">生成gRPC服务(。proto)来自OpenAPI描述。</li><li id="8ccb" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">为gRPC服务生成服务器端支持代码。</li><li id="aa91" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">实现服务器逻辑。</li><li id="407c" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">为特使代理生成描述符集。</li><li id="7e12" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">设置提供HTTP代码转换的特使代理。</li><li id="797d" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">运行gRPC服务器。</li><li id="cac5" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">用curl和gRPC客户机测试您的API。</li></ol><p id="6a46" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本教程的最后，我们的架构看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/dcdb54377ab0b20819fa049ac52821fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*_31jIQVw5AqbS-bG7Febfw.png"/></div></div></figure><p id="7136" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">先决条件:</strong></p><p id="2bbc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们先来看看插件:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="c9fb" class="nf lp iq nb b gy ng nh l ni nj">go get -u github.com/googleapis/gnostic-grpc</span></pre><p id="59d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">理想情况下，当您在examples/end-to-end <a class="ae ln" href="https://github.com/googleapis/gnostic-grpc/tree/master/examples/end-to-end" rel="noopener ugc nofollow" target="_blank">目录</a>中时，您可以遵循这些步骤。</p><p id="53d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们得到了我们需要的其他依赖项:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="f87b" class="nf lp iq nb b gy ng nh l ni nj">go get -u github.com/googleapis/gnostic<br/>go get -u github.com/golang/protobuf/protoc-gen-go<br/>go get -u google.golang.org/grpc</span></pre><p id="e21d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">gnostic 是一个命令行工具，它将OpenAPI描述转换成等价的协议缓冲区表示。gnostic-grpc是gnostic的一个插件。</p><p id="2e71" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://github.com/golang/protobuf/tree/master/protoc-gen-go" rel="noopener ugc nofollow" target="_blank">Protocol-gen-go</a>是Protocol编译器的一个插件，用于从协议缓冲区定义中生成Go源代码。</p><p id="9950" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们得到了<a class="ae ln" href="http://grpc.io" rel="noopener ugc nofollow" target="_blank"> grpc </a>。</p><p id="7bbf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为简单起见，我们在当前终端内部创建了一个临时环境变量:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="bdb1" class="nf lp iq nb b gy ng nh l ni nj">export ANNOTATIONS="third-party/googleapis"</span></pre><p id="067c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">第一步:</strong></p><p id="10eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在examples/end-to-end目录中执行插件，从给定的OpenAPI描述(bookstore.yaml)中获取协议缓冲区定义:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="cb95" class="nf lp iq nb b gy ng nh l ni nj">gnostic --grpc-out=. bookstore.yaml</span></pre><p id="cf73" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个命令生成了bookstore.proto文件。这些警告描述了OpenAPI描述的哪些部分没有反映在输出文件中。</p><p id="b215" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在幕后，该命令触发gnostic，它生成OpenAPI描述的二进制协议缓冲区表示。这个表示然后被用来构建一个<a class="ae ln" href="https://godoc.org/github.com/golang/protobuf/protoc-gen-go/descriptor#FileDescriptorSet" rel="noopener ugc nofollow" target="_blank">文件描述符集</a>。FileDescriptorSet本质上表示。我们想要生成的原型文件。然后我们使用<a class="ae ln" href="https://github.com/jhump/protoreflect" rel="noopener ugc nofollow" target="_blank"> protoreflect </a>来生成输出文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/714e0f9c1c974b8076968cd0befed671.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*MF766xIDMpMM56p5SIKZlw.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">诺斯替和诺斯替-grpc</figcaption></figure><p id="6f0c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">第二步:</strong></p><p id="fd60" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们生成gRPC存根:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="71a7" class="nf lp iq nb b gy ng nh l ni nj">protoc --proto_path=. --proto_path=${ANNOTATIONS} --go_out=plugins=grpc:bookstore bookstore.proto</span></pre><p id="dcd4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个命令生成文件bookstore/bookstore.pb.go。</p><p id="8511" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">— proto_path=。告诉协议编译器在当前目录中查找。原型文件。</p><p id="34e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">— proto_path=${ANNOTATIONS}告诉协议编译器在第三方/googleapis目录中查找。原型文件。注释是定义gRPC/REST映射所必需的。</p><p id="2679" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">— go_out=plugins=grpc:bookstore告诉protoc编译器使用grpc插件生成go源代码。输出应该生成到一个名为bookstore的目录中。</p><p id="0850" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">bookstore.proto是编译器的输入文件。</p><p id="6b7e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">第三步:</strong></p><p id="f9ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在<a class="ae ln" href="https://github.com/googleapis/gnostic-grpc/blob/master/examples/end-to-end/bookstore/server.go" rel="noopener ugc nofollow" target="_blank"> bookstore/server.go中提供了一个服务器逻辑的示例实现。</a>之前生成的所有数据结构都在该服务器中使用。</p><p id="cd99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">第四步:</strong></p><p id="ff83" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">给定bookstore.proto文件，我们可以使用protocol生成FileDescriptorSet:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="cbb5" class="nf lp iq nb b gy ng nh l ni nj">protoc --proto_path=${ANNOTATIONS} --proto_path=. --include_imports --include_source_info --descriptor_set_out=envoy-proxy/proto.pb bookstore.proto</span></pre><p id="4db8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将生成文件envoy-proxy/proto.pb。正如在另一个教程的第一步中所解释的，FileDescriptorSet以二进制格式表示一个. proto文件。本质上它等于bookstore.descr我们在步骤1的图“gnostic和gnostic-grpc”中看到的。</p><p id="4bdf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">第五步:</strong></p><p id="d799" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">文件<a class="ae ln" href="https://github.com/googleapis/gnostic-grpc/blob/master/examples/end-to-end/envoy-proxy/envoy.yaml" rel="noopener ugc nofollow" target="_blank">包含一个带有gRPC-JSON </a><a class="ae ln" href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http_filters/grpc_json_transcoder_filter" rel="noopener ugc nofollow" target="_blank">代码转换器</a>的特使配置。根据配置，端口51051将gRPC请求代理到运行在localhost:50051上的gRPC服务器，并使用gRPC-JSON代码转换器过滤器来提供RESTful JSON映射。即:您可以向localhost:51051发出gRPC或RESTful JSON请求。</p><p id="b4a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用docker获取特使图像:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="dff6" class="nf lp iq nb b gy ng nh l ni nj">docker pull envoyproxy/envoy-dev:bcc66c6b74c365d1d2834cfe15b847ae13be0eb6</span></pre><p id="aae0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">文件<a class="ae ln" href="https://github.com/googleapis/gnostic-grpc/blob/master/examples/end-to-end/envoy-proxy/Dockerfile" rel="noopener ugc nofollow" target="_blank"> envoy-proxy/Dockerfile </a>使用我们刚刚提取的envoy映像作为基础映像，并将envoy.yaml和proto.pb复制到docker容器的文件系统中:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="37d0" class="nf lp iq nb b gy ng nh l ni nj">FROM envoyproxy/envoy dev:bcc66c6b74c365d1d2834cfe15b847ae13be0eb6<br/>COPY envoy.yaml /etc/envoy/envoy.yaml<br/>COPY proto.pb /tmp/envoy/proto.pb</span></pre><p id="6c91" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从docker文件构建docker映像:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="abdb" class="nf lp iq nb b gy ng nh l ni nj">docker build -t envoy:v1 envoy-proxy</span></pre><p id="aafb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用端口51051上创建的映像运行docker容器:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="a107" class="nf lp iq nb b gy ng nh l ni nj">docker run -d --name envoy -p 9901:9901 -p 51051:51051 envoy:v1</span></pre><p id="09b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">第六步:</strong></p><p id="1dc1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在端口50051上运行gRPC服务器:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="103a" class="nf lp iq nb b gy ng nh l ni nj">go run main.go</span></pre><p id="c996" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">第七步:</strong></p><p id="8df6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们测试我们的gRPC/REST API:</p><p id="eacd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在新终端内部，我们创建了一个货架:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="b79f" class="nf lp iq nb b gy ng nh l ni nj"><em class="np">curl -X POST \<br/>http://localhost:51051/shelves \<br/>-H 'Content-Type: application/json' \<br/>-d '{<br/>    "name": "Books I need to read",<br/>    "theme": "Non-fiction"<br/>}'</em></span></pre><p id="0a33" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要检查这是否可行，我们需要所有现有的货架:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="af25" class="nf lp iq nb b gy ng nh l ni nj">curl -X GET <a class="ae ln" href="http://localhost:8081/shelves" rel="noopener ugc nofollow" target="_blank">http://localhost:51051/shelves</a></span></pre><p id="341d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们为id为1的shelve(我们刚刚创建的shelve)创建一本书:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="bcee" class="nf lp iq nb b gy ng nh l ni nj"><em class="np">curl -X POST \<br/>http://localhost:51051/shelves/1/books \<br/>-H 'Content-Type: application/json' \<br/>-d '{<br/>    "author": "Hans Rosling",<br/>    "name": "Factfulness",<br/>    "title": "Factfulness: Ten Reasons We'\''re wrong about the world - and Why Things Are Better Than You Think"<br/>}'</em></span></pre><p id="c06c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要列出id为1的书架上的所有书籍，我们可以调用:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="0bf1" class="nf lp iq nb b gy ng nh l ni nj">curl -X GET <a class="ae ln" href="http://localhost:8081/shelves/1/books" rel="noopener ugc nofollow" target="_blank">http://localhost:51051/shelves/1/books</a></span></pre><p id="9d13" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好了，看起来我们的REST API正在工作。gRPC客户端怎么样？</p><p id="ae87" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在grpc-client/client.go中，我们提供了一个grpc客户端的示例实现。客户打印您货架上的所有主题:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="712c" class="nf lp iq nb b gy ng nh l ni nj">client := bookstore.NewBookstoreClient(conn) <br/>ctx, _ := context.WithTimeout(context.Background(), 10*time.Second) res, err := client.ListShelves(ctx, &amp;empty.Empty{}) <br/>if res != nil {<br/> fmt.Println("The themes of your shelves:")<br/> for _, shelf := range res.Ok.ListShelvesResponse.Shelves {<br/>   fmt.Println(shelf.Theme)<br/> }<br/>}</span></pre><p id="f0b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要运行客户端，请执行以下命令:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="1729" class="nf lp iq nb b gy ng nh l ni nj">go run grpc-client/client.go</span></pre><p id="fa34" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，gRPC客户端也调用envoy代理(端口51051)，而<strong class="kt ir">而不是</strong>直接调用gRPC服务器(端口50051)。但是，在gRPC客户端中，您也可以将端口更改为50051。</p><h1 id="4769" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">最后一句话:</h1><p id="5e21" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">综上所述:我们可以看到，我们可以生成大量的代码，我们通常不得不手动编码，这更容易出错。请随意给gnostic-grpc 投稿。</p></div></div>    
</body>
</html>