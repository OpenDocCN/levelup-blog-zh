<html>
<head>
<title>Serverless Caching Strategies — Part 4 (AppSync) 🚀</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器缓存策略—第4部分(AppSync)🚀</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/serverless-caching-strategies-part-4-appsync-7fe6ede93183?source=collection_archive---------2-----------------------#2022-01-25">https://levelup.gitconnected.com/serverless-caching-strategies-part-4-appsync-7fe6ede93183?source=collection_archive---------2-----------------------#2022-01-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/9597cbf62bf53106768cb94301d037ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xUUgegtAXY5YWT6Nl2ngPw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">由<a class="ae jd" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jd" href="https://unsplash.com/@vackground?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">真空背景</a>拍摄</figcaption></figure><div class=""/><div class=""><h2 id="bd88" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">如何在您的解决方案中使用无服务器缓存策略，包括用TypeScript和CDK编写的代码示例和视觉效果，以及GitHub中的相关代码库。第4部分介绍AWS AppSync中的缓存。</h2></div><figure class="kw kx ky kz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi kv"><img src="../Images/4331ded1711f0f873b0775988ff44f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VvyAD11dFtzQC82f.png"/></div></div></figure><h1 id="7d15" class="la lb jg bd lc ld le lf lg lh li lj lk km ll kn lm kp ln kq lo ks lp kt lq lr bi translated">介绍</h1><p id="d01a" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">这是涵盖AWS上的无服务器缓存策略以及为什么应该使用它们的文章的第4部分。Github回购可以在这里找到<a class="ae jd" href="https://github.com/leegilmorecode/serverless-caching" rel="noopener ugc nofollow" target="_blank">https://github.com/leegilmorecode/serverless-caching</a>。</p><p id="9bb6" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">这一部分将介绍AWS AppSync中的缓存。</p><p id="0180" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">🔵<a class="ae jd" href="https://leejamesgilmore.medium.com/serverless-caching-strategies-part-1-amazon-api-gateway-c2d680d5b3b" rel="noopener">本文的第1部分介绍了使用Amazon </a> API Gateway在API层进行缓存。</p><p id="2a0c" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">🔵<a class="ae jd" href="https://leejamesgilmore.medium.com/serverless-caching-strategies-part-2-amazon-dynamodb-dax-d841e1e1ad0e" rel="noopener">本文的第2部分使用<em class="mt"> DynamoDB DAX </em> </a>研究数据库级的缓存。</p><p id="81a2" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">🔵<a class="ae jd" href="https://leejamesgilmore.medium.com/serverless-caching-strategies-part-3-lambda-runtime-b3d21250927b" rel="noopener">本文的第3部分研究了<em class="mt"> Lambda </em>运行时环境本身</a>中的缓存。</p><p id="6ef9" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">🔵<strong class="lu jh">这一部分将着眼于<em class="mt"> AppSync </em>级别的缓存。</strong></p><p id="8d1a" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">🔵本文的第5部分将讨论使用<em class="mt"> CloudFront </em>在CDN级别进行缓存。</p><p id="fe7b" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">本文由<a class="ae jd" href="https://www.sedai.io/" rel="noopener ugc nofollow" target="_blank"> Sedai.io </a>赞助</p><figure class="kw kx ky kz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mu"><img src="../Images/4c77bc2d275bd557dda90aa2fe842d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LJqkQYFI-KAGHOI3cHWxJQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://www.sedai.io/" rel="noopener ugc nofollow" target="_blank">https://www.sedai.io/</a></figcaption></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="284a" class="la lb jg bd lc ld nc lf lg lh nd lj lk km ne kn lm kp nf kq lo ks ng kt lq lr bi translated">快速回顾👨‍🏫</h1><p id="26cc" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">下图显示了您可以在无服务器解决方案中缓存的一些区域:</p><figure class="kw kx ky kz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nh"><img src="../Images/2fcee51a9ac46899e5a98f5b29c6a1b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vn757WeOGp9p3h5T.png"/></div></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="6981" class="la lb jg bd lc ld nc lf lg lh nd lj lk km ne kn lm kp nf kq lo ks ng kt lq lr bi translated">我们在建造什么？🏗️</h1><p id="8436" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">正如本系列的第1部分所描述的，这是我们正在构建的；我们将重点关注本文中以粉色突出显示的区域，特别是AppSync中的缓存:</p><figure class="kw kx ky kz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ni"><img src="../Images/670031c31a4d35e1373fdc9e7f7478b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3dTMpHIDzOAnwey6IHoxoA.png"/></div></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="6578" class="la lb jg bd lc ld nc lf lg lh nd lj lk km ne kn lm kp nf kq lo ks ng kt lq lr bi translated">无服务器博客✔️</h1><p id="9dc3" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">无服务器博客有以下流程:</p><p id="a788" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">⚪一个CloudFront发行版缓存了React网站，该网站以一个S3 bucket作为其源。我们可以在这个级别缓存web应用程序。</p><p id="36be" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">react应用程序利用GraphQL API通过AWS AppSync访问其数据。<em class="mt">对于某些终端，我们可能会考虑使用AppSync缓存。</em></p><p id="7476" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">appsync api通过Lambda解析DynamoDB的数据，我们使用DAX作为数据库前端的缓存。<em class="mt">在这里，我们可以利用DAX在数据库级别进行缓存。</em></p><h1 id="28d4" class="la lb jg bd lc ld le lf lg lh li lj lk km ll kn lm kp ln kq lo ks lp kt lq lr bi translated">AWS新闻博客✔️</h1><p id="7a51" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">AWS新闻博客有以下流程:</p><p id="86aa" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">⚪一个CloudFront发行版缓存了React网站，该网站以一个S3 bucket作为其源。<em class="mt">我们可以在这个级别缓存web app。</em></p><p id="0e1a" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">react应用程序通过亚马逊API网关为其数据利用REST API。<em class="mt">我们在API网关内的API级别进行了缓存。</em></p><p id="6a87" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">⚪对于缓存未命中，我们使用Lambda函数从无服务器的Aurora数据库中检索数据。在这个场景中，我们还可以在lambda本身中缓存某些数据。</p><blockquote class="nj nk nl"><p id="922a" class="ls lt mt lu b lv mo kh lx ly mp kk ma nm mq md me nn mr mh mi no ms ml mm mn ij bi translated"><em class="jg">💡</em> <strong class="lu jh"> <em class="jg">注意</em> </strong> <em class="jg"> : </em>这是允许我们在文章中讨论关键架构点的最小代码和架构，因此这不是生产就绪的，并且不符合编码最佳实践。(例如，在端点上没有认证)。我也试着不要把代码分割得太多，这样所有依赖关系都在一个文件<em class="jg">中的例子文件很容易查看。</em></p></blockquote></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="89ef" class="la lb jg bd lc ld nc lf lg lh nd lj lk km ne kn lm kp nf kq lo ks ng kt lq lr bi translated">首先，什么是AppSync？👨‍💻</h1><blockquote class="nj nk nl"><p id="ca97" class="ls lt mt lu b lv mo kh lx ly mp kk ma nm mq md me nn mr mh mi no ms ml mm mn ij bi translated"><em class="jg">💡</em> <strong class="lu jh"> <em class="jg">注</em> </strong> <em class="jg"> : </em>如果您对AppSync有很好的了解，请随意跳到下一节</p></blockquote><p id="b0e2" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">组织选择用GraphQL构建API是因为它帮助他们更快地开发应用程序，让前端开发人员能够用一个GraphQL端点查询多个数据库、微服务和API。</p><blockquote class="np"><p id="8b95" class="nq nr jg bd ns nt nu nv nw nx ny mn dk translated">AWS AppSync是一项完全托管的服务，通过处理安全连接到数据源(如AWS DynamoDB、Lambda等)的繁重工作，可以轻松开发GraphQL APIs</p></blockquote><p id="f9f7" class="pw-post-body-paragraph ls lt jg lu b lv nz kh lx ly oa kk ma mb ob md me mf oc mh mi mj od ml mm mn ij bi translated">AWS AppSync是一个完全托管的服务，通过处理安全连接到AWS DynamoDB、Lambda等数据源的繁重工作，可以轻松开发GraphQL APIs。添加缓存以提高性能，订阅以支持实时更新，以及客户端数据存储以保持离线客户端同步也同样简单。部署完成后，AWS AppSync会自动调整GraphQL API执行引擎，以满足API请求量。”——<a class="ae jd" href="https://aws.amazon.com/appsync/" rel="noopener ugc nofollow" target="_blank">https://aws.amazon.com/appsync/</a></p><p id="0985" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">以下视频更详细地介绍了AppSync:</p><figure class="kw kx ky kz gt is"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="9fe0" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">AWS AppSync有<code class="fe og oh oi oj b">resolvers</code>的概念，它是GraphQL中的内置函数，用数据源中的数据“解析”GraphQL模式中定义的类型或字段。AppSync中的解析器有两种类型:<code class="fe og oh oi oj b">unit resolvers</code>或<code class="fe og oh oi oj b">pipeline resolvers</code>。</p><blockquote class="np"><p id="cee2" class="nq nr jg bd ns nt nu nv nw nx ny mn dk translated">AppSync管道解析器通过协调对多个数据源的请求，显著简化了客户端应用程序的复杂性，并有助于实施服务器端业务逻辑控制。它们可用于在API层实施应用程序逻辑的某些方面。”——埃德·利马·奥斯</p></blockquote><p id="ec6e" class="pw-post-body-paragraph ls lt jg lu b lv nz kh lx ly oa kk ma mb ob md me mf oc mh mi mj od ml mm mn ij bi translated">管道解析器提供了在单个API调用中对多个数据源串行执行操作的能力，由查询、突变或订阅触发。如下图所示:</p><figure class="kw kx ky kz gt is gh gi paragraph-image"><div class="ab gu cl ok"><img src="../Images/1912a5660cbd235909b3816374be060c.png" data-original-src="https://miro.medium.com/v2/format:webp/0*gpVmWIKBd3LFabgf.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://aws.amazon.com/blogs/mobile/appsync-pipeline-resolvers-1/" rel="noopener ugc nofollow" target="_blank">https://AWS . Amazon . com/blogs/mobile/app sync-pipeline-resolvers-1/</a></figcaption></figure><h1 id="0591" class="la lb jg bd lc ld le lf lg lh li lj lk km ll kn lm kp ln kq lo ks lp kt lq lr bi translated">AppSync中的缓存是如何工作的？💭</h1><p id="3322" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">AWS AppSync的服务器端数据缓存功能由<a class="ae jd" href="https://aws.amazon.com/elasticache/redis/" rel="noopener ugc nofollow" target="_blank">Amazon elastic cache for Redis</a>提供支持，使数据在高速内存缓存中可用，从而提高性能并减少延迟。这减少了直接访问数据源的需要，无论是Lambda、DynamoDB、无服务器Aurora、HTTP还是更多。</p><p id="26d2" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">"<em class="mt">缓存是一种策略，用于提高API中查询和数据修改操作的速度，同时减少对数据源的请求。使用AppSync，您可以选择</em> <a class="ae jd" href="https://aws.amazon.com/blogs/mobile/appsync-caching-transactions/" rel="noopener ugc nofollow" target="_blank"> <em class="mt">为API的单元解析器提供专用缓存</em> </a> <em class="mt">，从而加快响应时间并减轻后端服务的负担。一些客户已经能够利用AppSync中服务器端缓存的简单性和高效性，将数据库请求减少99% </em>  <em class="mt">。</em> " —埃德·利马—<a class="ae jd" href="https://aws.amazon.com/blogs/mobile/appsync-pipeline-caching/" rel="noopener ugc nofollow" target="_blank">https://AWS . Amazon . com/blogs/mobile/app sync-pipeline-caching/</a></p><p id="6ac7" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">AppSync中的缓存在两个级别上工作:</p><p id="1b15" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">🔵跨整个API缓存。</p><p id="661e" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">🔵每个解析器级别的缓存(<em class="mt"> inc管道解析器</em>)。</p><h2 id="f51c" class="ol lb jg bd lc om on dn lg oo op dp lk mb oq or lm mf os ot lo mj ou ov lq ow bi translated"><strong class="ak">跨完整API缓存</strong> ✔️</h2><p id="7d95" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">如果数据不在缓存中，则从数据源中检索并填充缓存，直到生存时间(<em class="mt"> TTL </em>)到期。</p><p id="9e59" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">对API的所有后续请求都从缓存中返回。这意味着除非TTL过期，否则不会直接联系数据源。在这个设置中，我们使用<code class="fe og oh oi oj b">$context.arguments</code>和<code class="fe og oh oi oj b">$context.identity</code>映射的内容作为缓存键。</p><blockquote class="nj nk nl"><p id="96cb" class="ls lt mt lu b lv mo kh lx ly mp kk ma nm mq md me nn mr mh mi no ms ml mm mn ij bi translated"><em class="jg">💡</em> <strong class="lu jh"> <em class="jg">注意</em></strong><em class="jg">:</em>app sync的最大TTL为3600秒(1小时)，超过后条目自动删除。</p></blockquote><h2 id="a0fc" class="ol lb jg bd lc om on dn lg oo op dp lk mb oq or lm mf os ot lo mj ou ov lq ow bi translated">每个解析程序级别的缓存✔️</h2><p id="9954" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">使用此设置，必须显式选择每个解析程序来缓存响应。</p><blockquote class="nj nk nl"><p id="1eb4" class="ls lt mt lu b lv mo kh lx ly mp kk ma nm mq md me nn mr mh mi no ms ml mm mn ij bi translated"><em class="jg">💡</em> <strong class="lu jh"> <em class="jg">注意</em> </strong> <em class="jg"> : </em>这在我们的示例中很重要，因为其他GraphQL端点不需要在AppSync中缓存，因为我们在数据库级别(即DynamoDB DAX)显式缓存。</p></blockquote><p id="979a" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">您可以在解析器上指定TTL和缓存键。您可以指定的缓存键是来自<code class="fe og oh oi oj b">$context.arguments</code>、<code class="fe og oh oi oj b">$context.source</code>和<code class="fe og oh oi oj b">$context.identity</code>映射的值。</p><p id="60de" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">TTL值是必需的，但是缓存键是可选的。如果您没有指定任何缓存键，默认为<code class="fe og oh oi oj b">$context.arguments</code>、<code class="fe og oh oi oj b">$context.source</code>和<code class="fe og oh oi oj b">$context.identity</code>映射的内容。</p><p id="d885" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">例如，我们可能会使用<code class="fe og oh oi oj b">$context.arguments.id</code>或<code class="fe og oh oi oj b">$context.arguments.InputType.id</code>、<code class="fe og oh oi oj b">$context.source.id</code>和<code class="fe og oh oi oj b">$context.identity.sub</code>或<code class="fe og oh oi oj b">$context.identity.claims.username</code>。当您只指定TTL而不指定缓存键时，解析器的行为与上面的类似。</p><p id="eb68" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">让我们看看下面使用AWS CDK的每个解析器缓存的设置:</p><figure class="kw kx ky kz gt is"><div class="bz fp l di"><div class="ox of l"/></div></figure><p id="6f94" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><strong class="lu jh">从上面简单的代码片段我们可以看出我们:</strong></p><ol class=""><li id="643d" class="oy oz jg lu b lv mo ly mp mb pa mf pb mj pc mn pd pe pf pg bi translated">创建与Lambda关联的Lambda数据源。</li><li id="c95d" class="oy oz jg lu b lv ph ly pi mb pj mf pk mj pl mn pd pe pf pg bi translated">我们为上面的数据源创建一个解析器，将缓存配置设置为<code class="fe og oh oi oj b">$context.arguements.id</code>，TTL为30秒。(<em class="mt">本质上通过ID </em>缓存给定博客的所有实例)</li><li id="3c43" class="oy oz jg lu b lv ph ly pi mb pj mf pk mj pl mn pd pe pf pg bi translated">最后，我们将缓存添加到整个AppSync API中，特别是每个解析器的缓存。(<em class="mt">这将创建缓存并将其与API相关联)</em></li></ol><blockquote class="np"><p id="7fbc" class="nq nr jg bd ns nt pm pn po pp pq mn dk translated">随着管道解析器缓存的扩展，使用完整请求缓存的客户会立即看到缓存更改的好处，因为管道解析器是完整API缓存的一部分</p></blockquote><h2 id="06f4" class="ol lb jg bd lc om pr dn lg oo ps dp lk mb pt or lm mf pu ot lo mj pv ov lq ow bi translated">我们如何使用缓存键？🔑</h2><p id="48d9" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">当考虑缓存键时，考虑想要缓存的上下文和方式是很重要的。例如，在我们的示例中，您可能想要缓存所有的博客帖子，而不管是谁在访问它们。或者，您可能希望根据地理区域缓存博客文章。</p><p id="d777" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">如果这是某个特定用户的特定信息，比如他们来自朋友的最新消息，那么您很可能也想在您的缓存密钥中使用<code class="fe og oh oi oj b">$context.identity.sub</code>(<em class="mt">即特定用户的身份</em>)。</p><h2 id="b1e4" class="ol lb jg bd lc om on dn lg oo op dp lk mb oq or lm mf os ot lo mj ou ov lq ow bi translated">我们如何使缓存无效？🗑️</h2><p id="585f" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">当您设置AWS AppSync的服务器端缓存时，您可以配置最大TTL。该值定义了缓存条目在内存中存储的时间。</p><p id="816f" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">在必须从缓存中删除特定条目的情况下(<em class="mt">比如底层条目被更新或删除</em>)，可以在解析器的请求或响应映射模板中使用AWS AppSync的<code class="fe og oh oi oj b">evictFromApiCache</code>扩展实用程序。(<em class="mt">例如，当您的数据源中的数据已经更改，并且您的缓存条目现在已经过时。</em>)</p><p id="33f5" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">在我们的场景中，使缓存无效的一个例子如下(<em class="mt">为了清楚起见，DynamoDB中的项的底层更新被删除</em>):</p><figure class="kw kx ky kz gt is"><div class="bz fp l di"><div class="ox of l"/></div></figure><p id="fa6a" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">扩展方法<strong class="lu jh">的参数</strong>是<code class="fe og oh oi oj b">type</code>、<code class="fe og oh oi oj b">field</code>和<code class="fe og oh oi oj b">caching keys</code>。</p><p id="88b9" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">您可以将此代码添加到正在更新资源的端点的请求或响应映射中的VTL模板中。</p><p id="5992" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">如果一个条目被成功清除，则响应在<code class="fe og oh oi oj b">extensions</code>对象中包含一个<code class="fe og oh oi oj b">apiCacheEntriesDeleted</code>值，该值显示删除了多少条目:</p><pre class="kw kx ky kz gt pw oj px py aw pz bi"><span id="ddf9" class="ol lb jg oj b gy qa qb l qc qd">"extensions": {  "apiCacheEntriesDeleted": 1}</span></pre></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="27ab" class="la lb jg bd lc ld nc lf lg lh nd lj lk km ne kn lm kp nf kq lo ks ng kt lq lr bi translated">入门！✔️</h1><p id="d957" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">首先，使用以下git命令克隆以下repo:</p><pre class="kw kx ky kz gt pw oj px py aw pz bi"><span id="3856" class="ol lb jg oj b gy qa qb l qc qd">git clone <a class="ae jd" href="https://github.com/leegilmorecode/serverless-caching" rel="noopener ugc nofollow" target="_blank">https://github.com/leegilmorecode/serverless-caching</a></span></pre><p id="db39" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">这将把示例代码下载到您的本地机器上。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="0371" class="la lb jg bd lc ld nc lf lg lh nd lj lk km ne kn lm kp nf kq lo ks ng kt lq lr bi translated">部署解决方案！👨‍💻</h1><blockquote class="nj nk nl"><p id="a4a3" class="ls lt mt lu b lv mo kh lx ly mp kk ma nm mq md me nn mr mh mi no ms ml mm mn ij bi translated"><em class="jg"> 🛑 </em></p></blockquote><p id="3351" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">在repo的'<code class="fe og oh oi oj b">serverless-blog</code>'文件夹中运行以下命令来安装所有依赖项:</p><pre class="kw kx ky kz gt pw oj px py aw pz bi"><span id="6217" class="ol lb jg oj b gy qa qb l qc qd">npm i</span></pre><p id="ac73" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">完成此操作后，运行以下命令来部署解决方案:</p><pre class="kw kx ky kz gt pw oj px py aw pz bi"><span id="4597" class="ol lb jg oj b gy qa qb l qc qd">npm run deploy</span></pre><blockquote class="nj nk nl"><p id="6484" class="ls lt mt lu b lv mo kh lx ly mp kk ma nm mq md me nn mr mh mi no ms ml mm mn ij bi translated"><em class="jg"> 🛑 </em></p><p id="8828" class="ls lt mt lu b lv mo kh lx ly mp kk ma nm mq md me nn mr mh mi no ms ml mm mn ij bi translated"><em class="jg">💡</em> <strong class="lu jh"> <em class="jg">注意</em> </strong> <em class="jg"> : </em>我们使用CustomResource作为部署的一部分来创建blogs表，并用一些虚拟数据填充它，因此您可以直接使用它<em class="jg">。</em></p></blockquote></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="89cd" class="la lb jg bd lc ld nc lf lg lh nd lj lk km ne kn lm kp nf kq lo ks ng kt lq lr bi translated">测试解决方案🎯</h1><p id="9c92" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">现在，我们已经为AppSync API建立了以下与缓存相关的架构，下面的粉色圆圈中突出显示了感兴趣的要点:</p><figure class="kw kx ky kz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi qe"><img src="../Images/00b72af5dc7473467d877ec0f91e8a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5SzmFpkWt5_-J2mz01SLYg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">AppSync缓存的架构示例</figcaption></figure><h2 id="2bc0" class="ol lb jg bd lc om on dn lg oo op dp lk mb oq or lm mf os ot lo mj ou ov lq ow bi translated">让我们看看如何测试缓存，看看它是如何工作的</h2><p id="b1b0" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">使用控制台，我们可以在短时间内对<code class="fe og oh oi oj b">getBlogNoDax</code>执行以下查询12次:</p><figure class="kw kx ky kz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi qf"><img src="../Images/a7570e11b2794ad28e6c77ba0856b1cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MPPefs9TYXOifnX-9ljzcw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">我们在getBlogNoDax上执行查询</figcaption></figure><p id="5f62" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">然后我们可以在CloudWatch中看到，我们有<strong class="lu jh"> 1缓存未命中</strong> ( <em class="mt">初始调用</em>)和<strong class="lu jh"> 11缓存命中</strong> ( <em class="mt">缓存被填充时的后续调用，明显快得多</em>)。这些调用也没有触及DynamoDB，因此我们节省了读取容量成本。</p><figure class="kw kx ky kz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi qg"><img src="../Images/173bd64a617835224ae80e85a5e02165.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GtK08q5w2u7Q39-pFjM_7A.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">该图像显示了基于我们的查询的缓存命中</figcaption></figure><p id="ac67" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">然后，我们可以更进一步，查看X-Ray的ServiceLens图，了解缓存和延迟方面的情况:</p><figure class="kw kx ky kz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi qh"><img src="../Images/05a8c185e3cdc826bcd14ecab92c16a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QNCl__7l9hcteIusPYOz8A.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">服务镜头地图</figcaption></figure><p id="ce9f" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我们可以看到，缓存填充后的延迟为:</p><p id="fd14" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><code class="fe og oh oi oj b">Latency (avg): <strong class="lu jh">&lt;1ms<br/></strong>Requests: <strong class="lu jh">1.63/min<br/></strong>Faults: <strong class="lu jh">0.00/min</strong></code></p><p id="3b25" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">并且初始高速缓存未命中的等待时间(<em class="mt">λ</em>)是:</p><p id="52db" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><code class="fe og oh oi oj b">Latency (avg): <strong class="lu jh">567ms<br/></strong>Requests: <strong class="lu jh">0.13/min<br/></strong>Faults: <strong class="lu jh">0.00/min</strong></code></p><h2 id="4ea6" class="ol lb jg bd lc om on dn lg oo op dp lk mb oq or lm mf os ot lo mj ou ov lq ow bi translated"><strong class="ak">测试缓存失效</strong></h2><p id="d01c" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">接下来，我们将看看如何测试缓存失效。</p><p id="81bb" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">由于缓存仍然是由我们之前对<code class="fe og oh oi oj b">getBlogNoDax</code>的查询填充的，因此我们可以通过使用我们的突变<code class="fe og oh oi oj b">updateBlog</code>更新博客文章(如下图所示的<em class="mt">)来清空缓存:</em></p><figure class="kw kx ky kz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi qi"><img src="../Images/41db4ff9845f7beb0db22ba34863b016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VshkJEBl0i04vN1soJr_sg.png"/></div></div></figure><p id="32c5" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">根据变异的返回值，我们可以看到属性'<code class="fe og oh oi oj b">apiCacheEntriesDeleted</code>'在响应中返回了值1。这表明在我们的更新之后，我们已经使这篇博文的缓存失效了。</p><p id="a888" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">如果您在一行中进行两次更新，您将会看到您只在第一次调用时返回该属性，因为当您第二次调用变异时，缓存中没有任何内容。</p><p id="dd5c" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">最后，让我们看看在成功更新博客文章后实际执行缓存失效的代码:</p><figure class="kw kx ky kz gt is"><div class="bz fp l di"><div class="ox of l"/></div></figure><p id="9311" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">您可以看到，我们的请求映射模板正在DynamoDB中使用传递给变异的输入执行一个<code class="fe og oh oi oj b">putItem</code>，然后我们的响应映射模板使用相同的键(<em class="mt">即博客ID </em>)清除<code class="fe og oh oi oj b">getBlogNoDax</code>类型的查询缓存，最后将结果返回给消费者。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="ad08" class="la lb jg bd lc ld nc lf lg lh nd lj lk km ne kn lm kp nf kq lo ks ng kt lq lr bi translated">有什么优缺点？📝</h1><p id="7a3f" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">现在我们已经介绍了如何在AppSync中进行缓存；有什么优缺点？</p><h2 id="b22e" class="ol lb jg bd lc om on dn lg oo op dp lk mb oq or lm mf os ot lo mj ou ov lq ow bi translated">✔️的优势</h2><p id="09d2" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">🔵提高性能并大大减少最终用户的延迟。</p><p id="b088" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">🔵我们不需要管理底层缓存实例(<em class="mt">即安装补丁等</em>)。</p><p id="a77c" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">🔵我们有可能大幅降低访问下游服务(如DynamoDB)的成本(<em class="mt">降低99% </em>)</p><p id="639b" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">🔵我们有可能减少遗留下游服务的负载。</p><h2 id="aeb7" class="ol lb jg bd lc om on dn lg oo op dp lk mb oq or lm mf os ot lo mj ou ov lq ow bi translated">❌的劣势</h2><p id="c11f" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">🔵尽管我们不需要管理实例，但是随着非无服务器服务的引入，我们仍然限制了无服务器解决方案的可伸缩性。</p><p id="0510" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">🔵存在与底层缓存实例相关的成本，根据您的使用情形和吞吐量，这可能会变得非常昂贵。<strong class="lu jh">注意</strong>，实例从<strong class="lu jh">小型</strong> 1个vCPU，1.5 GiB RAM，到<strong class="lu jh">12个大型</strong> 48个vCPU，317.77 GiB RAM，10gb网络性能，取决于您的具体需求。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="f97f" class="la lb jg bd lc ld nc lf lg lh nd lj lk km ne kn lm kp nf kq lo ks ng kt lq lr bi translated">包扎👋</h1><p id="bbcb" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">我希望你觉得有用！</p><p id="73e7" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">请<a class="ae jd" href="https://www.youtube.com/channel/UC_Bi6eLsBXpLnNRNnxKQUsA" rel="noopener ugc nofollow" target="_blank">去我的YouTube频道</a>订阅类似内容！</p><figure class="kw kx ky kz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi qj"><img src="../Images/429f62757080017523be1c12bd0fb171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fBl7bZav_nncfENHlrwEXA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://www.youtube.com/channel/UC_Bi6eLsBXpLnNRNnxKQUsA" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/channel/UC_Bi6eLsBXpLnNRNnxKQUsA</a></figcaption></figure><p id="1512" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我很乐意就以下任何一个方面与您联系:</p><p id="0d12" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><a class="ae jd" href="https://www.linkedin.com/in/lee-james-gilmore/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/lee-james-gilmore/</a><br/>T17】https://twitter.com/LeeJamesGilmore</p><p id="bb97" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">如果你觉得这些文章鼓舞人心或有用，请随时用虚拟咖啡<a class="ae jd" href="https://www.buymeacoffee.com/leegilmore" rel="noopener ugc nofollow" target="_blank">https://www.buymeacoffee.com/leegilmore</a>来支持我，不管怎样，让我们联系和聊天吧！☕️</p><p id="078f" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">如果你喜欢这些帖子，请关注我的简介<a class="ae jd" href="https://medium.com/u/2906c6def240?source=post_page-----39c4f4ae5aff----------------------" rel="noopener">李·詹姆斯·吉尔摩</a>以获取更多的帖子/系列，不要忘记联系我并打招呼👋</p><p id="ee4e" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">如果你喜欢，也请使用帖子底部的“鼓掌”功能！(<em class="mt">可以不止一次鼓掌！！</em>)</p><p id="ab26" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">如果您喜欢这篇文章，您可能会喜欢以下内容:</p><div class="ip iq gp gr ir qk"><a href="https://leejamesgilmore.medium.com/serverless-content-46ef5b562d8e" rel="noopener follow" target="_blank"><div class="ql ab fo"><div class="qm ab qn cl cj qo"><h2 class="bd jh gy z fp qp fr fs qq fu fw jf bi translated">无服务器内容🚀</h2><div class="qr l"><h3 class="bd b gy z fp qp fr fs qq fu fw dk translated">我的所有无服务器内容的索引，可以在一个地方轻松浏览，包括视频、博客文章等..</h3></div><div class="qs l"><p class="bd b dl z fp qp fr fs qq fu fw dk translated">leejamesgilmore.medium.com</p></div></div><div class="qt l"><div class="qu l qv qw qx qt qy ix qk"/></div></div></a></div><h1 id="1d69" class="la lb jg bd lc ld le lf lg lh li lj lk km ll kn lm kp ln kq lo ks lp kt lq lr bi translated">关于我</h1><p id="4fdf" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">"<em class="mt">大家好，我是Lee，英国的AWS社区构建者、博客作者、AWS认证云架构师和首席软件工程师；目前是一名技术云架构师和首席无服务器开发人员，过去5年主要从事AWS上的全栈JavaScript工作。</em></p><p id="f154" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我认为自己是一个无服务器的布道者，热爱AWS、创新、软件架构和技术。</p><p id="57a4" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><strong class="lu jh"> **提供的信息是我个人的观点，我对信息的使用不承担任何责任。** </strong></p></div></div>    
</body>
</html>