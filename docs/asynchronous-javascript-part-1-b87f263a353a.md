# 异步 Javascript 第 1 部分:单线程编程和调用堆栈

> 原文：<https://levelup.gitconnected.com/asynchronous-javascript-part-1-b87f263a353a>

![](img/bbbab6fc99628470add15052bb51d73c.png)

默认情况下，Javascript 是一种同步语言。这意味着所有的语句和函数都按照预先定义的顺序一个接一个地执行。Javascript 之所以如此，是因为它只有一个执行线程。像 Java 这样的其他语言提供了一个多线程的执行环境，其中有主线程和其他线程，可以在运行时创建这些线程来并行运行任务。因此，在这些语言中实现异步非常简单直接。

然而，由于 Javascript 只为我们提供了单线程的执行，我们需要理解某些看似异步的函数，比如`setTimeout`函数，是如何运行的。但在此之前，我们先来看看**单线程执行**流程是如何工作的。

# 单线程执行

以这个简单的程序为例

输出:

```
1
2
```

在第 1 行，程序将函数声明保存到变量' *sayOne* '中。请注意，它只保存了函数声明，但还没有调用它。因此，在这一点上，它的代码实际上都没有运行，因此第 2 行还没有执行。在第 5 行，它将另一个函数定义保存到一个变量' *sayTwo* '(但还没有调用它)。在第 9 行，它调用函数 *sayOne* 。此时，执行保存的 *sayOne* 的函数定义，导致程序的第 2 行被执行，数值“1”被打印到控制台上。类似地，在第 10 行，程序调用函数 *sayTwo* ，这导致第 6 行被执行，它将值“2”打印到控制台上。

上面的执行流程看起来非常简单易懂。Javascript 逐行执行程序，并按顺序执行。然而，正如你可能已经看到的，程序并没有真正的一行一行的执行，由于函数调用，在执行行的顺序上有一些跳跃。我们将在本文的后面看到它。这里要注意的另一件好事是，Javascript 不会移动到下一行执行，直到上一行被执行。

例如，让我们假设 *sayOne* 函数有一个复杂的代码，需要很长时间来执行(例如，一秒钟)。在这种情况下，当在第 9 行时，程序将等待直到 *sayOne* 功能被完全执行，然后移动到第 10 行以在那里执行 *sayTwo* 功能。这是因为，正如我们前面指出的，Javascript 运行在所有函数共享的单个执行线程上。因此，程序会等到当前函数完全执行完毕后再继续运行。

让我们稍微修改一下上面的代码，试着理解接下来会发生什么。让我们添加第三个名为' *sayThree* '的函数。

现在让我们在代码中调用这个函数

如你所见，我们在函数 *sayOne* 的主体中调用了 *sayThree* 函数(它将“3”打印到控制台上)。因此，在执行上述程序时，当调用函数 *sayOne* 时，您认为第 14 行会发生什么？控制台会先记录“1”，然后继续执行 *sayThree* 的代码，还是会暂停自己的执行，调用 *sayThree* 函数，等待它完成，然后继续最终将“1”打印到控制台上？

嗯，上面程序的输出将是

```
3
1
2
```

为了理解这一点，我们需要理解 Javascript 如何在内部维护函数的顺序。

# 调用栈

Javascript 有一个叫做**调用栈**的东西，用来跟踪要执行的函数的顺序。调用栈，顾名思义，就是一个栈。因此，添加到此堆栈的项目将按照“[后进先出](https://www.geeksforgeeks.org/lifo-last-in-first-out-approach-in-programming/)”的顺序退出堆栈。

在上面的程序中，当程序到达第 14 行时，Javascript 程序看到函数 *sayOne* 将被调用。发生这种情况时，它会将函数 SayOne 添加到调用堆栈中。因此，堆栈目前看起来像这样

```
|            |
|            |
|            |
|            |
|  sayOne()  |
|____________|

  Call stack
```

该函数保留在调用堆栈中，只有在执行完成后才会弹出。Javascript 的工作方式是，它总是首先执行堆栈顶部的函数，然后将它弹出堆栈，然后移动到堆栈中的下一个函数。因此，程序现在“跳转”到执行栈顶的函数，即 *sayOne* 函数。 *sayOne* 的执行从第 2 行开始，程序看到 *sayThree* 函数将被调用。因此，Javascript 也将这个函数添加到调用堆栈中。更新后的调用堆栈现在看起来像这样

```
|             |
|             |
|             |
|  sayThree() |
|  sayOne()   |
|_____________|

  Call stack
```

然后程序跳转到执行栈顶的函数，也就是 sayThree 函数。现在运行 *sayThree* 函数的代码，其中第 11 行将“3”打印到控制台上。然后程序看到它已经到达了 *sayThree* 函数的末尾，因此将它弹出堆栈。现在堆栈看起来像这样

```
|             |
|             |
|             |
|             |
|  sayOne()   |
|_____________|

  Call stack
```

Javascript 然后看到 *sayOne* 函数在栈顶，因此跳回到它在执行中停止的地方。第 3 行将“1”打印到控制台上。再一次，在到达 *sayOne* 函数的末尾时，Javascript 将它弹出堆栈，如下所示

```
|             |
|             |
|             |
|             |
|             |
|_____________|

  Call stack
```

在看到堆栈为空后，Javascript 程序跳回到最初执行时停止的地方，也就是第 15 行，在那里看到调用了 *sayTwo* 函数。你可能已经猜到了，sayTwo 被添加到堆栈中

```
|             |
|             |
|             |
|             |
|  sayTwo()   |
|_____________|

  Call stack
```

由于它是堆栈中最顶层的函数，程序的执行跳转到 *sayTwo* 的执行，在第 7 行，值“2”被打印到控制台上。到达函数末尾时，它会弹出堆栈，调用堆栈现在为空。没有更多的行要运行，因此程序终止。

当我们讨论调用堆栈时，您可能对 Javascript 在执行过程中如何“跳转”到调用堆栈顶部的函数感到有些困惑。Javascript 如何知道一个新函数何时被添加到堆栈中，或者一个函数何时被从堆栈中移除，因此它需要继续执行堆栈中的下一个函数？

我将在这个系列的[第二部分](https://medium.com/@kabir4691/asynchronous-javascript-part-2-26ac20fc5ad7)中讨论这个问题以及更多内容。