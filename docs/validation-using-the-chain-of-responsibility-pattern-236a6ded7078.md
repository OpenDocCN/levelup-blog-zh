# 使用责任链模式进行验证

> 原文：<https://levelup.gitconnected.com/validation-using-the-chain-of-responsibility-pattern-236a6ded7078>

![](img/27261efaacb19446b50051e3c404cca2.png)

责任链模式是软件工程中最有用的设计模式之一。至少在我的经验中，这也是最少实现的方法之一。在我参与开发的商业应用程序中，我只在野外遇到过一次——我认为这是一种耻辱。

责任链模式可以描述为面向对象版本的*if…else if…else…end if*blocks；但它远不止于此——它允许甚至鼓励松耦合，这反过来带来了许多好处。

为了乐趣、利润和更好的代码库，我们可以实现责任链模式的一个地方是验证器。

我已经很快地(并且相当复杂和肮脏地)收集了一个例子来说明这可能是什么样子。

在这个例子中，我们得到了一个“插入”一个*汽车模型*实例的服务。验证我们将要放入数据库的东西是相当明智的，所以这看起来是一个不错的例子。

让我们看看可以插入的模型。

![](img/c1a4adaa2e15e3557a3898bbd8bc62c8.png)

模型类

到目前为止，一切都很简单。这四个都实现了 *IVehicleModel* 接口，如下所示，并且具有相同的基本属性。

![](img/42b64218e71c50415732a54dee91c13d.png)

IVehicleModel 接口。如果我们真的要实现这个，我们可能会使用一个抽象基类。尽管对于这个例子来说，接口是很好的。

现在让我们看看服务。

![](img/b4911429adfce0ffe8113f64e270762c.png)

车辆服务—我们验证然后插入

这个服务有一个单独的依赖项——一个 *IVehicleValidator* 的实例(我们一会儿就会看到它是什么样子)。第 9 行调用验证器的 *Validate* 方法，如果模型验证失败，则 *InsertVehicleModel* 方法返回。出于示例的目的，验证结果被写入控制台。

再说一次——这是非常简单的，我相信这是一个我们都很熟悉的概念。验证输入-如果验证通过，则继续，否则返回。

那么， *IVehicleValidator* 长什么样呢？嗯，看起来是这样的。一个单独的方法 *Validate* ，它将 *IVehicleModel* 的一个实例作为其参数，并返回一个*vehicle validation result*。

![](img/c6bca6a02dd658f77e7fae1822fd2f68.png)

简单的 IVehicleValidator 接口

![](img/2c0d72340809f96724befffa9929b82f.png)

验证结果类

*vehicle validation result*有一个布尔属性来表示模型是否有效，还有一个消息字符串列表——验证失败的原因。如果我们的实现需要的话，我们可以很容易地用异常来代替字符串。

好了——这就是我们的设置。我们有一个服务，一些模型和一些接口。现在我们需要在这些骨头上放些肉。让我们使用责任链实现一个没有的验证器**。下面的代码展示了如何做到这一点——对于这个例子来说有些笨拙。**

![](img/af66d469ecdcad789bc5cc43596300e6.png)

由于这个验证器需要迎合不同的模型类型，我们有 *if* 块，它在执行所需的验证之前检查模型的类型。如果我们的执行失败了，因为不支持或意外的类型被传递给了 validate 方法，就会抛出 *NotImplementedException* 。

从表面上看，这似乎很好。对于那些永远不会增长或修改的小应用程序来说，可能是这样的。老实说，你开发过多少永远不会增长或修改的小应用程序？

这种“整体”方法有一些潜在的问题等待着我们:

*   可扩展性——当必须支持一个新的模型类型时会发生什么？没错——我们需要修改这个类并重新测试它，因为我们已经修改了这个类，所以我们也需要重新测试依赖于它的任何东西。
*   可扩展性(再次)——让我们假设这是多租户应用程序的一部分，不同的租户开始为不同类型的车辆改变验证规则。一种可能允许只有[三个轮子的汽车](https://duckduckgo.com/?q=reliant+robin&iax=images&ia=images)，另一种可能允许[无引擎汽车](https://duckduckgo.com/?q=flintsones+car&iar=images&iax=images&ia=images)。实现这一点意味着要么是每租户验证器，要么是在 *if* 语句中的一堆 *if* 语句。两者都不可取。
*   可维护性——对验证器的任何更改都会增加 *Validate* 方法的圈复杂度，使得维护变得更加困难。新的规则，或者说变化的规则，意味着更多的条件代码。变化意味着更多的测试，以及对任何依赖于它的类的更多测试。

这个验证器也违反了*单一责任原则*——验证汽车的东西没有验证船的权利。

如果我们使用责任链模式实现一个验证器，我们可以解决这些问题。

第一步是将验证器分解成单独的验证器，每个验证器负责一个 *IVehicleModel* 的实现。我们将实现三个，它们都遵循相同的基本模式。下面显示的是*汽车验证器*。

![](img/b780ade1db3e168220f454ad9830ba6d.png)

CarValidator 类—链中的第一个链接

可以看出，该类实现了 *IVehicleValidator* ，就像单片验证器一样，并使用相同的规则来验证汽车模型。不过还有一些额外的东西。

首先是构造函数——我们现在有一个，而不是默认的，它需要一个参数。我们正在形成一个链，所以每个环节都需要访问下一个环节。我们将链中的下一个链接传递给每个验证器实例。

其次，看看第 11 行到第 14 行。有一个 *if* 语句，看起来非常像我们实现的第一个验证器类中的条件。但是有一点不同——如果当前的不负责模型类型，那么责任会传递给下一个验证器，而不是对特定的模型类型进行验证。

下面显示的是另外两个模型验证器——遵循相同的模式。如果模型不是验证者的责任，那么它将被传递到链中的下一个环节。

![](img/0870b5ef6b765eaeb60154e0259d6360.png)

BikeValidator 类

![](img/d97c28d4655cf8c3fff733b0b3021fa5.png)

BoatValidator 类

好的——这几乎取代了单一的验证器，但是还缺少一样东西。如果一个模型在所有条件下都失败了会发生什么？如果到了链条的末端，没有一个环节承担责任，会发生什么？

这就是下面这个类出现的原因:

![](img/a8f050531dc380451c403cdf8900cf15.png)

NoResultValidator——一种结束我们的链的方法

我们从 *VehicleValidator* 中替换了 *NotImplementedException* ，并创建了一个链接，只是为了结束这个链。在这个例子中，除了返回一个*NoResultVehicleValidationResult*(命名事物，最难的是软件……)之外，什么都不做。这个“默认”结果如下所示:

![](img/fc550fd998e8b521ec4ddc5ac87037c5.png)

是啊——给东西命名……

这里什么也看不到…在实际的实现中，我们可能会检查结果类型并输出一些有用的信息到日志中。可能是验证失败消息，也可能是存在无法验证的模型类型。

嗯——这就是我们的责任链。我们有三个验证器，每个负责一个模型类型，还有一个类结束这个链。

它解决了可维护性问题——每个验证器中的代码要少得多，任何更改都只需要重新测试那个验证器，并且只重构它的单元测试。

它以两种方式解决了可扩展性问题。第一个——即当我们需要验证一个新模型时会发生什么——很容易解释。我们创建一个新的验证器，并将其添加到链中。就是这样。完成了。没有重构其他验证器，也没有大量重写单元测试。

第二个可扩展性问题——上面描述了多租户应用程序的假设——需要另一个代码片段来解释…

![](img/3a2f7e7b1226a3201ca2f3ee2d561579.png)

使用 Unity 创建链。这里有一个与策略模式的交叉，特别是当我们讨论多租户应用程序时

这里我们有一种方法可以使用 IoC 提供者实现验证链(在这个例子中使用了 Unity，但是几乎可以使用任何东西)。每个验证器都被注册，每个验证器通过其构造函数接收链中的下一个链接。服务注册到链中的第一个链接，在这个例子中是 *CarValidator* 。

顺便说一句——如果您在 Real Life 中实现这一点，您可能希望创建一个工厂来完成这种连接，除非您喜欢大量的 IoC 配置文件(我真的不喜欢)。

现在谈谈多租户应用程序的问题。一方面，有三个轮子的汽车是有效的，另一方面，没有引擎的汽车也是有效的。国际奥委会如何在这方面提供帮助？

实际上，很简单。

您实现每个租户的 IoC 配置。这是一个独立的主题，所以我现在不会详细讨论它，但简单地说，这是我如何使用 Unity (ymmv 和其他提供商)来实现它:

*   所有常见的注册都是用代码实现的
*   特定于租户的注册将以 XML 实现
*   在运行时，代码将决定加载哪个 XML 文件，特定于租户的注册将覆盖通用的注册

# 结论

这个简短的、有点笨拙的例子有望展示使用责任链模式可以带来的优势。我们可以编写更干净、更易维护、更易扩展和更可靠的代码，而不需要太多的开销。因为我们使用了多个类，并且需要将链连接在一起，所以需要的引导量会有轻微的增加，但是这对于所获得的收益来说是微不足道的。

示例代码是用 C#编写的，但是这种模式几乎适用于任何语言——包括弱类型和没有接口概念的语言(JavaScript，我正在看着你)。