<html>
<head>
<title>Introduction to Bubble Sort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">冒泡排序简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-bubble-sort-e3f454f6976c?source=collection_archive---------33-----------------------#2021-03-07">https://levelup.gitconnected.com/introduction-to-bubble-sort-e3f454f6976c?source=collection_archive---------33-----------------------#2021-03-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="00d6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">排序算法03</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a9fea6bb95cac962b8344c27f7788b1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r4NFUikoQxUQ2GfzOgNFLw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="387f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在排序算法系列的前两篇文章中，我们看了<a class="ae lu" href="https://medium.com/nerd-for-tech/introduction-to-selection-sort-19de8e72c89f" rel="noopener"> <em class="lv">选择排序</em> </a>和<a class="ae lu" href="https://medium.com/star-gazers/introduction-to-insertion-sort-756821945e3e" rel="noopener"> <em class="lv">插入排序</em> </a>。冒泡排序是另一种简单的排序算法，易于理解和实现。这个想法是比较相邻的元素，如果它们的顺序不正确，就交换它们。让我们用一个例子来理解冒泡排序是如何工作的。</p><p id="8f7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设要排序的数组是(8，4，3，9，1)，下图说明了冒泡排序如何执行多次迭代，直到数组被完全排序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/882d0af390ae2468d5e2fecb22d18487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k8hcRa02ZCvtjgrk2Apv_A.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/97fe083e74310318fadbf47efdfc21f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I-UEP4R1Zp96g0WKx4U0gA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="f1d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第一次迭代中，我们从比较前两个元素8和4开始。从8 &gt; 4开始，我们交换它们。然后我们比较第二个和第三个元素，8和3。从8 &gt; 3开始，我们交换它们。然而，当我们比较接下来的两个元素8和9时，它们的顺序是正确的(8 &lt; 9). Hence we do not swap them. We continue this process until the last two elements are compared. At the end of the first iteration, the largest element 9 is brought to the end of the array. Similarly, the second largest element 8 is brought to its correct position at the end of the second iteration. Also note that in the <em class="lv"> i </em> ᵗʰ迭代，我们必须比较直到(n - <em class="lv"> i </em> )ᵗʰ元素，其中n是数组中元素的总数，并且<em class="lv"> i </em> ≥ 0。例如，在上述示例的第二次迭代中，我们不考虑9(最后一个元素)；在第三次迭代中，我们不考虑最后两个元素。</p><p id="66f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上述示例中，数组按升序排序。要按降序对数组进行排序，我们应该只在左边的元素小于右边的元素时交换元素(与我们在示例中所做的相反)。</p><p id="0b8b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">经过<em class="lv"> m </em>次迭代后，数组的最后<em class="lv"> m </em>个元素将排序。</p><h2 id="4574" class="ly lz it bd ma mb mc dn md me mf dp mg lh mh mi mj ll mk ml mm lp mn mo mp mq bi translated">用C实现</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="7835" class="ly lz it bd ma mb mc dn md me mf dp mg lh mh mi mj ll mk ml mm lp mn mo mp mq bi translated">冒泡排序分析</h2><ul class=""><li id="dffe" class="mt mu it la b lb mv le mw lh mx ll my lp mz lt na nb nc nd bi translated">冒泡排序是一种就地算法，这意味着它不需要额外的内存空间来执行排序。</li><li id="c683" class="mt mu it la b lb ne le nf lh ng ll nh lp ni lt na nb nc nd bi translated">冒泡排序的最佳时间复杂度为O(n)。当数组已经排序时(这是最好的情况)，冒泡排序可以在一次迭代中检测到它并将终止。如果在一次迭代中没有执行交换，则表明数组已经排序(见下图)。上述实现中交换的布尔变量<em class="lv">服务于该目的。</em></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/434dc30303f4a8b193c24043b958c932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9HTeAv2ouQPrbzh-S5Nq0Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><ul class=""><li id="5a65" class="mt mu it la b lb lc le lf lh nk ll nl lp nm lt na nb nc nd bi translated">冒泡排序在最坏情况和一般情况下的时间复杂度为O(n)。假设数组的大小为n，它应该在第一次迭代中执行(n-1)次比较，在下一次迭代中执行(n-2)次比较，这种模式一直持续到最后一次迭代(见下图)。因此，比较的总数将是(n - 1) + (n - 2) + …… + 1 = n(n-1)/2，因此为O(n)。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/d0b909438bc7bc393e37e6a41e724821.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nfWpwrwLdTosQumgyTUZQw.png"/></div></div></figure><ul class=""><li id="9280" class="mt mu it la b lb lc le lf lh nk ll nl lp nm lt na nb nc nd bi translated">由于二次最坏情况时间复杂度，当要排序的元素数量很大时，冒泡排序是低效的。</li><li id="6d09" class="mt mu it la b lb ne le nf lh ng ll nh lp ni lt na nb nc nd bi translated">由于冒泡排序的就地排序功能，当可用的空闲内存有限时，可以使用它。然而，在现实世界的应用中，插入排序经常取代冒泡排序，因为它的性能更好。</li></ul><h2 id="2076" class="ly lz it bd ma mb mc dn md me mf dp mg lh mh mi mj ll mk ml mm lp mn mo mp mq bi translated">冒泡排序vs插入排序vs选择排序</h2><ul class=""><li id="0196" class="mt mu it la b lb mv le mw lh mx ll my lp mz lt na nb nc nd bi translated">所有这三种排序算法在最坏情况和平均情况下的时间复杂度均为O(n)。插入排序和冒泡排序的最佳时间复杂度为O(n)，而选择排序的最佳时间复杂度为O(n)。</li><li id="c099" class="mt mu it la b lb ne le nf lh ng ll nh lp ni lt na nb nc nd bi translated">都是原地算法(空间复杂度为O(1))。</li><li id="4677" class="mt mu it la b lb ne le nf lh ng ll nh lp ni lt na nb nc nd bi translated">假设元素将按升序排序，在冒泡排序的<em class="lv"> i </em>次迭代之后，数组中最后的<em class="lv"> i </em>元素将是排序顺序中最大的<em class="lv"> i </em>元素。类似地，对于选择排序，数组的第一个<em class="lv"> i </em>元素将是排序顺序中最小的<em class="lv"> i </em>元素。然而，插入排序将只排序第一个<em class="lv"> i </em>元素。下图将有助于更好的理解。(<em class="lv">请注意，这可能会根据算法的实现方式而改变。例如，阵列也可以从右向左移动</em></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/0246346fddd59e1cab4e1d8ada5e09a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sy4HiHi0t2WY5D5eOrfpQg.png"/></div></div></figure><p id="a404" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">希望这篇文章对你有用！</p></div></div>    
</body>
</html>