<html>
<head>
<title>Dapr Service Invocation with Azure Container Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure容器应用程序的Dapr服务调用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dapr-service-invocation-with-azure-container-apps-5918f59db088?source=collection_archive---------15-----------------------#2022-11-06">https://levelup.gitconnected.com/dapr-service-invocation-with-azure-container-apps-5918f59db088?source=collection_archive---------15-----------------------#2022-11-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ffd5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过与Azure容器应用的集成，我们可以使用DaprService调用来调用其他容器应用。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/512c88613fe55a5070b94ab842938065.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DUJJ5TD22as81tty.png"/></div></div></figure><p id="ab31" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上周我有一点时间来学习Dapr，所以我开始阅读。NET开发者的电子书，可以在我们的文档中找到(顺便说一下，完全免费！).在前面的一章中，该书概述了一个教程，您可以在本地运行该教程，以使用服务调用在两个应用程序之间进行通信。</p><p id="e043" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本地运行相当简单，所以我想将这两个应用程序部署为容器应用程序，因为它在平台中支持Dapr。</p><p id="a727" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，本文将简单介绍Dapr中的服务调用，容器应用程序如何支持Dapr，以及我们如何设置容器应用程序环境来支持我们的Dapr应用程序。</p><h1 id="2485" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">Dapr中的服务调用</h1><p id="52b5" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">Dapr有几个构建块，我们可以用它们来构建分布式微服务。构建块是可以从应用程序代码中调用的HTTP或gRPC APIs。它们有助于解决我们在构建微服务时面临的挑战，并将最佳实践和模式整理成文。</p><p id="9d4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其中一个构建块支持服务调用，这允许您的应用程序使用HTTP或gRPC与其他应用程序进行可靠的通信。服务调用就像一个反向代理，提供服务发现、访问控制、指标、重试等等。</p><p id="70bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于Dapr中服务调用的更多信息，<a class="ae ln" href="https://docs.dapr.io/developing-applications/building-blocks/service-invocation/service-invocation-overview/" rel="noopener ugc nofollow" target="_blank">查看文档</a>。</p><h1 id="7e62" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">Azure容器应用中的Dapr</h1><p id="06cb" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">可以在容器应用上构建Dapr应用。您可以在您的环境中启用容器应用程序来使用Dapr，并且可以在环境级别配置Dapr组件，这些组件可以在多个容器应用程序之间共享。</p><p id="4f66" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们为支持Dapr的容器应用程序提供一个标识符，用于服务发现、状态封装和发布/订阅消费。</p><p id="6b73" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于这个例子，我们不会配置任何Dapr组件。通过服务调用，我们将只使用Dapr在我们的应用程序之间进行通信。如果我们要为我们的容器应用程序使用组件，我们可以将我们的组件扩展到需要使用这些组件的特定Dapr应用程序。</p><p id="9cd0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更多关于Dapr与Azure容器应用集成的信息，<a class="ae ln" href="https://learn.microsoft.com/en-us/azure/container-apps/dapr-overview?tabs=bicep1%2Cyaml" rel="noopener ugc nofollow" target="_blank">请看下面的</a>。</p><h1 id="6e1e" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">在我们的应用中使用服务调用。</h1><p id="c3f9" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在我的<a class="ae ln" href="https://github.com/willvelida/aca-dapr-service-invocation" rel="noopener ugc nofollow" target="_blank">示例代码</a>中，我有两个C#项目:一个是ASP.NET核心web应用程序(充当我们的前端应用程序)，它将通过Dapr与ASP.NET核心Web API(将成为我们的后端应用程序)通信。它所做的就是使用服务调用构建块从API中检索天气预报。</p><p id="f185" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了实现这一点，我们需要在前端应用程序中进行以下更改。首先，我们需要安装Dapr。NET SDK:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="0513" class="mq lp iq mm b gy mr ms l mt mu">Install-Package Dapr.AspNetCore</span></pre><p id="58a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们需要在Program.cs文件中添加DaprClient:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="899a" class="mq lp iq mm b gy mr ms l mt mu">// Add services to the container.<br/>builder.Services.AddDaprClient();<br/>builder.Services.AddRazorPages();<br/><br/>// REST OF THE FILE</span></pre><p id="47a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将向ASP.NET核心依赖注入系统注册DaprClient。现在，当我们需要与服务调用构建块通信时，我们可以将DaprClient实例注入到代码中。</p><p id="cf37" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将在主页上显示天气预报数据，因此需要在Index.cshtml.cs文件中进行更改。在我们的OnGet()方法中，我们需要进行以下更改:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="8b2b" class="mq lp iq mm b gy mr ms l mt mu">public async Task OnGet()         {             var forecasts = await _daprClient.InvokeMethodAsync&lt;IEnumerable&lt;WeatherForecast&gt;&gt;(                 HttpMethod.Get,                 "mybackend",                 "weatherforecast");              ViewData["WeatherForecastData"] = forecasts;         }</span></pre><p id="aeca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">InvokeMethodAsync正在进行服务调用调用。查看参数:</p><ul class=""><li id="73db" class="mv mw iq kt b ku kv kx ky la mx le my li mz lm na nb nc nd bi translated">HttpMethod。Get =这是我们将对服务使用的HTTP方法。在本例中，我们对容器应用程序发出GET请求。</li><li id="6135" class="mv mw iq kt b ku ne kx nf la ng le nh li ni lm na nb nc nd bi translated">“my back end”=这是我们调用的Dapr应用程序的应用程序Id，我们将在容器应用程序配置中设置它。<strong class="kt ir">请注意</strong>在编写的时候，容器应用程序有一个限制，即应用程序名称必须全部小写，所以请确保在这个方法中使用正确的名称。</li><li id="2392" class="mv mw iq kt b ku ne kx nf la ng le nh li ni lm na nb nc nd bi translated">“weather forecast”=这是我们后端将调用的方法名。这将是我们后端api中的“GetWeatherForecast”方法。</li></ul><h1 id="c026" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">配置我们的Bicep代码以支持Dapr</h1><p id="7242" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">正如我前面提到的，Dapr是在容器应用程序级别启用的。Dapr APIs通过Dapr sidecar暴露给每个容器应用程序，Dapr sidecar将通过HTTP从我们的容器应用程序调用。</p><p id="ea1a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将在Bicep模板中为两个容器应用程序启用Dapr:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="a002" class="mq lp iq mm b gy mr ms l mt mu">var frontendName = 'myfrontend'<br/>var backendName = 'mybackend'<br/><br/>// Omitted Bicep code<br/><br/>resource env 'Microsoft.App/managedEnvironments@2022-06-01-preview' = {<br/>  name: containerEnvironmentName<br/>  location: location<br/>  tags: tags<br/>  properties: {<br/>   daprAIConnectionString: appInsights.properties.ConnectionString<br/>   appLogsConfiguration: {<br/>    destination: 'log-analytics'<br/>    logAnalyticsConfiguration: {<br/>      customerId: logAnalytics.properties.customerId<br/>      sharedKey: logAnalytics.listKeys().primarySharedKey<br/>    }<br/>   } <br/>  }<br/>}<br/><br/>resource frontend 'Microsoft.App/containerApps@2022-06-01-preview' = {<br/>  name: frontendName<br/>  location: location<br/>  tags: tags<br/>  properties: {<br/>    managedEnvironmentId: env.id<br/>    configuration: {<br/>      activeRevisionsMode: 'Multiple'<br/>      ingress: {<br/>        external: true<br/>        transport: 'http'<br/>        targetPort: 80<br/>        allowInsecure: false<br/>      }<br/>      dapr: {<br/>        enabled: true<br/>        appPort: 80<br/>        appId: frontendName<br/>      }<br/>      secrets: [<br/>        {<br/>          name: 'container-registry-password'<br/>          value: containerRegistry.listCredentials().passwords[0].value<br/>        }<br/>      ]<br/>      registries: [<br/>        {<br/>          server: '${containerRegistry.name}.azurecr.io'<br/>          username: containerRegistry.listCredentials().username<br/>          passwordSecretRef: 'container-registry-password'<br/>        }<br/>      ]<br/>    }<br/>    template: {<br/>      containers: [<br/>        {<br/>          image: frontendImage<br/>          name: frontendName<br/>          env: [<br/>            {<br/>              name: 'ASPNETCORE_ENVIRONMENT'<br/>              value: 'Development'<br/>            }<br/>          ]<br/>          resources: {<br/>            cpu: json('0.5')<br/>            memory: '1.0Gi'<br/>          }<br/>        }<br/>      ]<br/>      scale: {<br/>        minReplicas: 0<br/>        maxReplicas: 5<br/>      }<br/>    }<br/>  }<br/>  identity: {<br/>    type: 'SystemAssigned'<br/>  }<br/>}<br/><br/>resource backend 'Microsoft.App/containerApps@2022-06-01-preview' = {<br/>  name: backendName<br/>  location: location<br/>  tags: tags<br/>  properties: {<br/>    managedEnvironmentId: env.id<br/>    configuration: {<br/>      activeRevisionsMode: 'Multiple'<br/>      ingress: {<br/>        external: false<br/>        transport: 'http'<br/>        targetPort: 80<br/>        allowInsecure: false<br/>      }<br/>      dapr: {<br/>        enabled: true<br/>        appPort: 80<br/>        appId: backendName<br/>      }<br/>      secrets: [<br/>        {<br/>          name: 'container-registry-password'<br/>          value: containerRegistry.listCredentials().passwords[0].value<br/>        }<br/>      ]<br/>      registries: [<br/>        {<br/>          server: '${containerRegistry.name}.azurecr.io'<br/>          username: containerRegistry.listCredentials().username<br/>          passwordSecretRef: 'container-registry-password'<br/>        }<br/>      ]<br/>    }<br/>    template: {<br/>      containers: [<br/>        {<br/>          image: backendImage<br/>          name: backendName<br/>          env: [<br/>            {<br/>              name: 'ASPNETCORE_ENVIRONMENT'<br/>              value: 'Development'<br/>            }<br/>          ]<br/>          resources: {<br/>            cpu: json('0.5')<br/>            memory: '1.0Gi'<br/>          }<br/>        }<br/>      ]<br/>      scale: {<br/>        minReplicas: 0<br/>        maxReplicas: 5<br/>      }<br/>    }<br/>  }<br/>  identity: {<br/>    type: 'SystemAssigned'<br/>  }<br/>}</span></pre><p id="0397" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的容器应用程序环境中，我们正在配置我们的Application Insights实例，以收集当我们的不同服务之间发生通信时，Dapr将生成的遥测数据。</p><p id="0200" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本例中，我使用连接字符串连接到我的Application Insights工作区。在2025年3月31日，<a class="ae ln" href="https://learn.microsoft.com/en-us/azure/azure-monitor/app/separate-resources#about-resources-and-instrumentation-keys" rel="noopener ugc nofollow" target="_blank">对Application Insights中检测密钥摄取的支持将终止</a>，所以现在就开始使用连接字符串吧。(也不是容器应用特定的)。</p><p id="7239" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的容器应用中，我们像这样配置Dapr:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="b42c" class="mq lp iq mm b gy mr ms l mt mu">var frontendName = 'myfrontend'<br/>var backendName = 'mybackend'<br/><br/>// frontend dapr config<br/>dapr: {<br/>  enabled: true<br/>  appPort: 80<br/>  appId: frontendName<br/>  enableApiLogging: true<br/>}<br/><br/>// backend dapr config<br/>dapr: {<br/>  enabled: true<br/>  appPort: 80<br/>  appId: backendName<br/>  enableApiLogging: true<br/>}</span></pre><p id="2c8a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的两个容器应用程序中，我们将appId (Dapr应用程序标识符)设置为容器应用程序的名称。回想一下，在我们的前端代码中，我们使用“mybackend”的appId对后端进行服务调用，因此这需要成为我们后端应用程序的appId。</p><p id="7b86" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还为Dapr边车启用了API日志。在Bicep中，我们可以为Dapr边车设置日志级别。我没有设置一个明确的值，而是将它保持为默认值“info ”,但是您可以定义一个符合您需求的级别。请记住，此遥测数据将由Application Insights收集，可能会产生额外的相关费用。</p><p id="258b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要了解如何在Bicep中为您的容器应用程序配置Dapr，请查看<a class="ae ln" href="https://learn.microsoft.com/en-us/azure/templates/microsoft.app/managedenvironments?pivots=deployment-language-bicep" rel="noopener ugc nofollow" target="_blank">容器应用程序环境</a>和<a class="ae ln" href="https://learn.microsoft.com/en-us/azure/templates/microsoft.app/containerapps?pivots=deployment-language-bicep" rel="noopener ugc nofollow" target="_blank">容器应用程序</a>参考文档。</p><h1 id="9606" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">监控我们的容器应用</h1><p id="bce8" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">看看应用洞察，我们可以看到Dapr生成的以下遥测数据:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/bd7623d1702e2290193b579bf628f42f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/0*1b0lpgR_vVnl2akX.png"/></div></figure><p id="f386" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，我们看到Dapr正在向我们的后端服务发出GET请求，以检索我们的天气预报信息。在我们的前端代码中，每当我们导航到主页时，我们就定义这个GET调用。“mybackend”是我们的容器应用程序的Dapr Id，而“weatherforecast”是我们想要调用的方法。我们可以在“rpc.service”属性中看到，该调用已被标识为对我们的“service . name”my front end的ServiceInvocation调用。</p><p id="6ac6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在日志分析中，通过运行以下KQL查询，我们可以看到从我们的容器应用程序发出的日志:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="89cb" class="mq lp iq mm b gy mr ms l mt mu">ContainerAppConsoleLogs_CL<br/>| where ContainerAppName_s == 'myfrontend'<br/>| project Time=TimeGenerated, AppName=ContainerAppName_s, Revision=RevisionName_s, Container=ContainerName_s, Message=Log_s<br/>| take 100</span></pre><p id="1435" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">容器应用程序中有两种类型的日志。控制台日志(由您的应用发出)和系统日志(由容器应用服务发出)。查看我们的前端应用程序的控制台日志(在本例中，它将由我们的Dapr sidecar生成)，我们可以看到我们的前端正在对我们的后端进行服务调用:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/c7be2197a15b036c5b82c86e43ca151a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9YKNBQF8OZ3v_Kb1.png"/></div></div></figure><p id="5930" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于登录Azure容器应用的更多信息，请看下面的<a class="ae ln" href="https://learn.microsoft.com/en-us/azure/container-apps/logging" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h1 id="b148" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="0cae" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在本文中，我们讨论了服务调用如何在Dapr中工作。然后，我们讨论了Dapr如何与Azure容器应用程序集成，我们如何在容器应用程序中配置Dapr，以便我们可以在代码中调用服务。最后，我们讨论了如何监控我们的容器应用程序，并查看由我们的容器应用程序和Dapr sidecar生成的日志。</p><p id="0f83" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你对以上内容有任何疑问，欢迎在twitter上联系我</p><p id="0f8a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下次见，编码快乐！🤓🖥️</p></div></div>    
</body>
</html>