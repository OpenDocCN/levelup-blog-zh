<html>
<head>
<title>How to write a Golang HTTP server with Linux system calls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Linux系统调用编写Golang HTTP服务器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-write-a-golang-http-server-with-linux-system-calls-444a3a296812?source=collection_archive---------10-----------------------#2022-03-22">https://levelup.gitconnected.com/how-to-write-a-golang-http-server-with-linux-system-calls-444a3a296812?source=collection_archive---------10-----------------------#2022-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="4d06" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">背景</h1><p id="9263" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe lj lk ll lm b">HTTP</code>无处不在。作为一名软件工程师，你每天都在使用<code class="fe lj lk ll lm b">HTTP</code>协议。如果你使用任何现代语言或框架，启动一个<code class="fe lj lk ll lm b">HTTP</code>服务器将是一件容易的事情。例如，在Golang中，您可以通过下面几行代码来实现:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="21a9" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">因为<code class="fe lj lk ll lm b">net/http</code>包完全实现了<code class="fe lj lk ll lm b">HTTP</code>协议，所以您可以轻松地完成这项工作。没有<code class="fe lj lk ll lm b">net/http</code>包你怎么做？这就是本文的目标。</p><p id="c774" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated"><strong class="kn ir">注</strong>:这篇文章的灵感来源于<a class="ae lz" href="https://joe.schafer.dev/go-server-with-syscalls/" rel="noopener ugc nofollow" target="_blank">乔·斯查费的帖子</a>。我的实现有些不同，它完全消除了对Golang的<code class="fe lj lk ll lm b">net</code>包的依赖，但是在Golang中使用<code class="fe lj lk ll lm b">system call</code>来建立TCP/IP连接的想法是相同的。非常感谢乔·斯查费有趣的帖子。</p><p id="e084" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">我需要提到的另一件事是，这篇文章将涵盖许多概念，但很难详细讨论它们。要顺利理解这篇文章，需要一些<code class="fe lj lk ll lm b">OSI model</code>、<code class="fe lj lk ll lm b">TCP/IP stack</code>、<code class="fe lj lk ll lm b">socket programming</code>、<code class="fe lj lk ll lm b">HTTP protocol</code>、<code class="fe lj lk ll lm b">system call</code>等必备知识。我将添加一些关于这些主题的解释，以帮助您理解本文，并提供一些参考和链接，让您继续探索更高级的内容。</p><p id="14c7" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated"><strong class="kn ir">注意</strong>这篇文章最初发表在我的<a class="ae lz" href="https://organicprogrammer.com/2021/07/31/how-to-implement-simple-http-server-golang/" rel="noopener ugc nofollow" target="_blank">博客</a>上，你可以在那里找到更多信息。谢了。</p><h1 id="4b39" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">OSI网络模型</h1><p id="eafa" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe lj lk ll lm b"><a class="ae lz" href="https://en.wikipedia.org/wiki/OSI_model" rel="noopener ugc nofollow" target="_blank">OSI model</a></code>将通信系统中的数据流划分为<strong class="kn ir">七个抽象层</strong>。这些层形成了一个协议栈，每一层都与上一层和下一层进行通信，如下所示:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/55802e2c1ccf633c8be9072bef908a00.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/0*mHvPnKdNQcSCGFCG.png"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">OSI模型</figcaption></figure><p id="68b5" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">例如，<code class="fe lj lk ll lm b">HTTP</code>在<strong class="kn ir">层7 </strong>中，<code class="fe lj lk ll lm b">TCP</code>在<strong class="kn ir">层4 </strong>中，<code class="fe lj lk ll lm b">IP</code>在<strong class="kn ir">层3 </strong>中。</p><p id="7d03" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">OSI是一种通用模型，在20世纪80年代初首次被指定。<strong class="kn ir">但是传统的和现代的网络协议都不适合这种模式</strong>。例如，<code class="fe lj lk ll lm b">TCP/IP</code> stack没有定义三个上层:会话层、表示层和应用层。事实上，它没有定义传输层之上的任何东西。从<code class="fe lj lk ll lm b">TCP/IP</code>的角度来看，传输层之上的一切都是<br/>应用的一部分。所以更符合Linux的分层网络模型(TCP/IP栈是在Linux内核中实现的)如下:</p><ul class=""><li id="8e14" class="mh mi iq kn b ko lu ks lv kw mj la mk le ml li mm mn mo mp bi translated">应用层(远程登录、ftp、http)</li><li id="8712" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">主机到主机传输层(TCP、UDP)</li><li id="1d2b" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">互联网层(IP和路由)</li><li id="5943" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">网络接入层(以太网、wi-fi)</li></ul><p id="b370" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">再次强调，<strong class="kn ir">重要的是要指出上层——第5层、第6层和第7层——不是TCP/IP协议栈的一部分</strong>。</p><p id="e48c" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">另一个需要理解的关键点是<code class="fe lj lk ll lm b">data encapsulation</code>。在应用程序中，数据流从最底层的物理层流向最高层的数据表示。</p><p id="061f" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">每一层都有它必须保存的关于自己层的管理信息。当数据包向下传递时，它会将报头信息添加到从上一层接收的数据包中。每个报头包含关于消息内容的信息。例如，一台<code class="fe lj lk ll lm b">HTTP</code>服务器从一台主机向另一台主机发送数据。它在<code class="fe lj lk ll lm b">IP</code>协议之上使用<code class="fe lj lk ll lm b">TCP</code>协议，该协议可以通过<code class="fe lj lk ll lm b">Ethernet</code>发送。这看起来像:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/bb56348590024d6c14388905a046c58f.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/0*54yTdrhNkB0uDj_G.png"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">数据封装</figcaption></figure><p id="3194" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">通过以太网传输的数据包位于底部。在接收端，当数据包向上移动时，这些报头会被删除。</p><p id="96b4" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">接下来让我们看看<code class="fe lj lk ll lm b">TCP/IP</code>栈如何封装<code class="fe lj lk ll lm b">HTTP</code>消息，并通过<code class="fe lj lk ll lm b">socket</code>在网络上发送它。这个想法可以用下图来说明:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/cccecee627facde61e1e80c2624b41fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/0*QdwzY7LJw73Z_Nom.png"/></div></figure><p id="c186" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">我将通过从头编写一个HTTP服务器来解释它是如何工作的，你可以参考这个<a class="ae lz" href="https://github.com/baoqger/http-server-scratch" rel="noopener ugc nofollow" target="_blank"> Github repo </a>来获取所有代码。</p><h1 id="25bc" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">传输控制协议</h1><p id="1c00" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe lj lk ll lm b">TCP/IP</code>栈源于<code class="fe lj lk ll lm b"><a class="ae lz" href="https://en.wikipedia.org/wiki/ARPANET" rel="noopener ugc nofollow" target="_blank">ARPANET</a></code>项目，作为<code class="fe lj lk ll lm b">TCP/IP</code>协议的第一个实现集成到Unix BSD OS中。</p><p id="81ec" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">如今，<code class="fe lj lk ll lm b">TCP/IP</code>依然在操作系统层面实现。对于Linux系统，可以在内核内部找到源代码。详细的实现超出了本文的范围。你可以在这个Github <a class="ae lz" href="https://github.com/torvalds/linux/tree/master/net/ipv4" rel="noopener ugc nofollow" target="_blank">链接</a>里研究一下。</p><h1 id="01cc" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">(电源)插座</h1><p id="d325" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">正如我在上面几节中提到的，HTTP服务器运行在应用程序级别。它如何与内核中的<code class="fe lj lk ll lm b">TCP/IP</code>堆栈一起工作？答案是<code class="fe lj lk ll lm b">socket</code>。</p><p id="e4df" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated"><code class="fe lj lk ll lm b">socket</code>接口最初是作为BSD操作系统的一部分开发的。套接字提供了应用层程序和TCP/IP协议栈之间的接口。Linux(或其他操作系统)提供了一个API和套接字，应用程序使用这个API来访问内核中的网络设施。</p><p id="fc16" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">套接字接口实际上是TCP/IP通向世界的窗口。在大多数包含TCP/IP的现代系统中，套接字接口是应用程序利用TCP/IP协议集的唯一方式。</p><p id="ccb6" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">Unix或Linux系统中套接字的一个主要优点是套接字被视为一个<code class="fe lj lk ll lm b">file descriptor</code>，所有标准的I/O函数都像处理本地文件一样处理套接字。文件描述符只是一个与打开的文件相关联的整数。</p><p id="fe19" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">你可能听说过Unix中的所有东西都是一个文件。该文件可以是网络连接、管道、磁盘中的真实文件、设备或任何其他东西。所以当你想通过因特网向另一个程序发送数据时，你可以通过文件描述符来完成。</p><p id="19a5" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">在我们的HTTP服务器案例中，<strong class="kn ir">它将通过从套接字读取数据来获取请求，并通过将数据写入套接字</strong>来发送响应。</p><p id="d8dd" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">接下来，让我们回顾一下源代码，看看HTTP服务器是如何实现的。</p><p id="1791" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">首先，我们需要通过socket建立TCP连接，这个过程可以在下图中描述:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/2e73ddc3faba71c469ae701857e76f74.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/0*38K18YbNKQdlVCwA.png"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">TCP套接字进程</figcaption></figure><p id="69c3" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">在Golang中，<code class="fe lj lk ll lm b">net</code>包提供了所有与套接字相关的功能。因为本文的目的是从头开始编写一个HTTP服务器，所以我创建了一个名为<strong class="kn ir"> simplenet </strong>的包来提供非常基本的实现:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="9a3c" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated"><strong class="kn ir">创建netSocket </strong>数据模型来表示Socket，它只包含一个字段<strong class="kn ir"> fd </strong>表示文件描述符。所有与socket相关的API:<strong class="kn ir">读</strong>，<strong class="kn ir">写</strong>，<strong class="kn ir">接受</strong>和<strong class="kn ir">关闭</strong>，都被定义了。socket API的用法不在本文的讨论范围之内，您可以很容易地在网上找到许多关于它的优秀文档。</p><p id="093b" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated"><strong class="kn ir"> netSocket </strong>的逻辑并不复杂，因为它通过<code class="fe lj lk ll lm b">system call</code>将作业委托给内核。系统调用是程序向内核请求服务的一种编程方式，详细你可以参考这篇<a class="ae lz" href="https://opensource.com/article/19/10/strace" rel="noopener ugc nofollow" target="_blank">文章</a>。在Golang中，所有的系统调用都封装在<code class="fe lj lk ll lm b">syscall</code>标准包中。</p><p id="4ad8" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">需要提到的一点是不同的平台有不同的<code class="fe lj lk ll lm b">syscall</code>用法，所以本文展示的演示代码只能在Linux系统上编译和构建。</p><p id="07d4" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">现在我们设置TCP服务器并等待来自客户端的连接请求。接下来，让我们看看如何通过socket来读取或写入HTTP请求和响应。</p><h1 id="e339" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">超文本传送协议</h1><p id="82bc" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">主要工作流程如下:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="f3af" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">如您所见，HTTP请求解析逻辑是在<strong class="kn ir"> simplenet </strong>包中的<strong class="kn ir"> ParseRequest </strong>方法中定义的:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="4424" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">HTTP请求消息可以分为以下三个部分<code class="fe lj lk ll lm b">request line</code>、<code class="fe lj lk ll lm b">request headers</code>和<code class="fe lj lk ll lm b">request body</code>:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/ec95633141480ec1bec24c1fbf17d40d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/0*A62ZDhFl7qW_BA78.png"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">HTTP消息</figcaption></figure><p id="f33a" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated"><strong class="kn ir"> ParseRequest </strong>内部的逻辑逐步处理这3个部分。可以参考演示代码中的注释。</p><p id="b549" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">需要强调的一点是<strong class="kn ir"> ParseRequest </strong>方法不依赖于<code class="fe lj lk ll lm b">net</code>包。因为我想展示HTTP服务器在底层是如何工作的，所以我将请求解析逻辑从<code class="fe lj lk ll lm b">net</code>包复制到我的<code class="fe lj lk ll lm b">simplenet</code>包中。对请求头部分的解析有点复杂，但这不会影响您对HTTP server主要概念的理解。想了解详情可以参考<code class="fe lj lk ll lm b">simplenet/simpleTextProto</code>套餐。需要理解的重要一点是，HTTP服务器使用<strong class="kn ir"> netSocket </strong>的<strong class="kn ir"> Read </strong>方法读取请求消息。<strong class="kn ir"> Read </strong>方法通过socket read系统调用从TCP栈获取网络数据:</p><pre class="ln lo lp lq gt my lm mz na aw nb bi"><span id="052c" class="nc jo iq lm b gy nd ne l nf ng"><strong class="lm ir">syscall.Read(ns.fd, p)</strong></span></pre><p id="10b8" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">另一方面，通过调用<code class="fe lj lk ll lm b">simplenet</code>包的<code class="fe lj lk ll lm b">WriteString</code>方法发回HTTP响应:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="2b93" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated"><code class="fe lj lk ll lm b">WriteString</code>简单调用<strong class="kn ir"> netsocket </strong>的<strong class="kn ir"> Write </strong>方法，使得socket write系统调用通过TCP栈发送数据:</p><pre class="ln lo lp lq gt my lm mz na aw nb bi"><span id="f1db" class="nc jo iq lm b gy nd ne l nf ng"><strong class="lm ir">syscall.Write(ns.fd, p)</strong></span></pre><p id="139e" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">代码部分到此为止。接下来，让我们尝试运行这个我们从头构建的简单HTTP服务器。</p><h1 id="694e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">演示</h1><p id="d121" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">使用默认选项设置构建(需要Linux平台)并运行这个HTTP服务器，并使用<code class="fe lj lk ll lm b">curl</code>向它发送请求。结果如下所示:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nh"><img src="../Images/ae4cf9cb53e59c55346bf907ee8fd250.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xAL9ijAfRFE8MFQw.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">基于Linux系统调用的Golang HTTP服务器演示</figcaption></figure><p id="e317" class="pw-post-body-paragraph kl km iq kn b ko lu kq kr ks lv ku kv kw lw ky kz la lx lc ld le ly lg lh li ij bi translated">服务器按预期工作。</p></div></div>    
</body>
</html>