<html>
<head>
<title>JavaScript Design Patterns: Observer Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript设计模式:观察者模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-design-patterns-observer-pattern-1cf90cffb1e2?source=collection_archive---------4-----------------------#2022-10-26">https://levelup.gitconnected.com/javascript-design-patterns-observer-pattern-1cf90cffb1e2?source=collection_archive---------4-----------------------#2022-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8751d67b4f5550b2449ecca7f176d6d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kLlZECGDfKKTbhan3eCuGA.png"/></div></div></figure><h2 id="3860" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">观察者</strong></h2><p id="5514" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">观察者也称为发布-订阅模式或消息机制。它定义了对象之间一对多的依赖关系。只要一个对象的状态发生变化，所有依赖它的对象都会得到通知，并且自动更新，解决了主体对象和观察者之间的功能耦合，即一个对象的状态发生变化时通知其他对象的问题。</p><p id="d601" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">只看定义，对于前端的朋友来说，这个概念可能比较模糊，而且我对观察者模式还是有一点了解的，好吧，那我再看一个生活中比较贴切的例子，相信你马上就能理解了。</p><p id="437e" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">生活中的观察者模式</strong></p><p id="656f" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">每次苹果发布新手机，都是热销。我看中了苹果14 pro，想去苹果专卖店买，但是到了店里之后，售货员告诉我这款手机很受欢迎。嗯，那我也不能天天过来问，很费时间，就把手机号留给售楼小姐了。如果他们店里有货，就让她给我打电话让我知道，像这样你就不用担心不知道什么时候有货，也不用天天跑去问。如果你已经成功购买了一部手机，那么销售小姐在那之后就不需要通知你了。</p><p id="ff9c" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><em class="lu">这样不是清楚了很多吗~这样的案例还有很多，就不赘述了。</em></p><h2 id="5f03" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">使用观察者模式</h2><p id="fcfe" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">说实话，我可以保证每个阅读这篇文章的人都使用过观察者模式。如果你不相信我，看看下面的代码:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="dec2" class="jy jz iq ma b gy me mf l mg mh">document.<strong class="ma ir">querySelector</strong>('#btn').<strong class="ma ir">addEventListener</strong>('click',<strong class="ma ir">function</strong> () {         <br/>   <strong class="ma ir">alert</strong>('You click this button');     <br/>},false)</span></pre><p id="9d1b" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">看起来眼熟吗？没错，我们通常绑定到<code class="fe mi mj mk ma b">DOM </code>的事件是一个非常典型的发布-订阅模式。这里我们需要监控用户在按钮上的<code class="fe mi mj mk ma b">click </code>事件，但是我们无法知道用户什么时候点击，所以我们订阅了按钮上的点击。事件，只要点击按钮，按钮就会向订阅者发布消息，我们就可以做相应的操作了。<br/>除了我们常见的<code class="fe mi mj mk ma b">DOM </code>事件绑定，观察者模式还有很多应用范围。<br/>比如对比目前流行的<code class="fe mi mj mk ma b">vue </code>框架，很多地方都涉及到了观察者模式，比如:数据双向绑定</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/c3ce894883e5b5464d8adafb9d5283a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TBgdmClgJsFz_YkfK72toQ.png"/></div></div></figure><p id="a8af" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">使用Object.defineProperty()劫持数据，设置一个listener Observer来监控所有属性，如果属性发生变化，需要告诉订阅者Watcher更新数据，最后命令解析器编译解析相应的命令，然后执行相应的更新函数来更新视图，实现双向绑定。</p><p id="f697" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">子组件与父组件通信</strong></p><p id="2c2e" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">在<code class="fe mi mj mk ma b">Vue</code>中，我们通过<code class="fe mi mj mk ma b">props</code>将数据从父组件传递到子组件，子组件通过自定义事件与父组件通信，即<code class="fe mi mj mk ma b">$on</code>、<code class="fe mi mj mk ma b">$emit</code>，这实际上意味着我们通过<code class="fe mi mj mk ma b">$emit</code>发布消息，并对订阅者进行统一处理<code class="fe mi mj mk ma b">$on</code></p><p id="bf8b" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">接下来，让我们自己创建一个简单的观察器:</strong></p><p id="1350" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">首先我们需要创建一个observer对象，包含一个消息容器和三个方法，分别是订阅消息方法<code class="fe mi mj mk ma b">on </code>、退订消息方法<code class="fe mi mj mk ma b">off </code>和发送订阅消息<code class="fe mi mj mk ma b">subscribe </code>。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="4313" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">好了，我们观察者的原型已经出来了，剩下的就是完善里面的三个方法了。</p><p id="d3dd" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">注册消息</strong></p><p id="3f48" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">registered message方法的作用是将订阅者注册的消息推送到消息队列中，所以需要传递两个参数:消息类型和对应的处理函数。如果存在，创建一个消息类型并将消息放入消息队列。如果消息已经存在，将相应的方法推入执行方法队列。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="1bd7" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">发布消息</strong></p><p id="d6ee" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">发布消息，它的作用是观察者发布消息时，依次执行所有订阅者订阅的消息，还需要传递两个参数，一个是消息类型，一个是对应执行函数所需的参数，其中消息类型是必需的。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="f00a" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">删除消息</strong></p><p id="c9bd" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">remove message方法的作用是清除订阅者已经从消息队列中注销的消息。它还需要传递两个参数，消息类型和执行队列中的一个函数。这里，为了避免删除中消息不存在的情况，需要检查消息的存在。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="d9e3" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">好了，至此，我们已经实现了一个基本的观察者模型，接下来是我们展示技巧的时候了。</p><p id="ee4e" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">首先，我们来做一个简单的测试，看看我们自己创建的观察者模式表现如何？</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9fe8" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">我们在消息类型<code class="fe mi mj mk ma b">say</code>的消息中注册了两个方法，一个接受参数，一个不需要参数，然后通过<code class="fe mi mj mk ma b">subscribe</code>发布<code class="fe mi mj mk ma b">say </code>和<code class="fe mi mj mk ma b">success </code>消息。结果如我们所料，控制台输出<code class="fe mi mj mk ma b">hello world</code>和<code class="fe mi mj mk ma b">success</code></p><h2 id="bf27" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">自定义数据的双向绑定</h2><p id="f1fa" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">如上所述，<code class="fe mi mj mk ma b">vue </code>双向绑定是通过数据劫持和发布订阅实现的。现在我们用这个思路自己实现一个简单的双向数据绑定。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="a7c5" class="jy jz iq ma b gy me mf l mg mh">&lt;div id="app"&gt;     <br/>   &lt;h3&gt;Two-way binding of data&lt;/h3&gt;     <br/>   &lt;div class="cell"&gt;         <br/>     &lt;div class="text" v-text="myText"&gt;&lt;/div&gt;         <br/>       &lt;input class="input" type="text" v-model="myText" &gt;          &lt;/div&gt; <br/>&lt;/div&gt;</span></pre><p id="b501" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">相信你已经知道了，我们要做的是输入标签的<code class="fe mi mj mk ma b">input </code>，通过<code class="fe mi mj mk ma b">v-text</code>绑定到类名为<code class="fe mi mj mk ma b">text </code>的div标签</p><p id="b864" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">首先我们需要创建一个类，这里姑且称之为myVue。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="2f94" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">这里我们定义了<code class="fe mi mj mk ma b">myVue </code>构造函数，并在构造函数中执行一些初始化操作。以上有注释，这里不再赘述，主要看两个关键方法<code class="fe mi mj mk ma b">_obverse </code>和<code class="fe mi mj mk ma b">_compile</code>。</p><p id="bb64" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">首先是<code class="fe mi mj mk ma b">_observe </code>法。它的功能是处理传入的<code class="fe mi mj mk ma b">data </code>并重新定义数据的<code class="fe mi mj mk ma b">set </code>和<code class="fe mi mj mk ma b">get </code>方法，以确保我们可以在数据发生变化时跟踪并发出通知，主要使用<code class="fe mi mj mk ma b">Object.defineProperty()</code></p><p id="dcbb" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">_观察</strong></p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="f308" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">接下来，我们来看看_compile方法，它实际上是一个解析器。它的功能是解析模板指令，将更新函数绑定到每个指令对应的节点，并添加订阅者来监控数据。一旦数据发生变化，只需接收通知，然后更新视图变化，具体实现如下:</p><p id="d369" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">_编译</strong></p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="d904" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">上面的代码也很清楚，我们从根元素<code class="fe mi mj mk ma b">#app</code>开始递归遍历每个节点，判断每个节点是否有对应的指令，这里我们只针对<code class="fe mi mj mk ma b">v-text</code>和<code class="fe mi mj mk ma b">v-model</code>，我们执行了<code class="fe mi mj mk ma b">v-text</code>一次new <code class="fe mi mj mk ma b">Watcher()</code>，把它放在<code class="fe mi mj mk ma b">myText</code>的指令集中，解析<code class="fe mi mj mk ma b">v-model</code>，把输入事件绑定到它的输入，通过new <code class="fe mi mj mk ma b">Watcher()</code>把它和<code class="fe mi mj mk ma b">myText </code>关联起来，所以我们要看看这个Watcher到底是什么？</p><p id="65eb" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">Watcher实际上是一个订阅者，是<code class="fe mi mj mk ma b">_observer </code>和<code class="fe mi mj mk ma b">_compile </code>之间的沟通桥梁，绑定更新函数来更新<code class="fe mi mj mk ma b">DOM </code>元素。</p><p id="7ffa" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">沃彻</strong></p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="b61c" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">每次创建<code class="fe mi mj mk ma b">Watcher </code>的实例时，都会传入相应的参数，还会执行一个<code class="fe mi mj mk ma b">_update </code>操作。在上面的<code class="fe mi mj mk ma b">_compile</code>中，我们创建了两个Watcher实例，但是两个对应的<code class="fe mi mj mk ma b">_update </code>操作是不同的。对于div来说，<code class="fe mi mj mk ma b">.text</code>的操作实际上相当于<code class="fe mi mj mk ma b">div.innerHTML=h3.innerHTML = this.data.myText </code>，对于input来说相当于<code class="fe mi mj mk ma b">input.value=this.data.myText </code>，所以每次设置数据时，我们都会触发两个<code class="fe mi mj mk ma b">_updates</code>操作，分别更新div和input中的内容。</p><p id="0ed3" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">测试</strong></p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9852" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">现在，你对观察者模式有更深的理解了吗？其实我在这里说了这么多，只是起到一个吸引新思想的作用。重要的是设计思路。可能很难学会将这种设计思想合理地应用到我们的实际开发过程中。</p><div class="mo mp gp gr mq mr"><a rel="noopener  ugc nofollow" target="_blank" href="/javascript-design-patterns-strategy-pattern-c013d3dbc059"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd ir gy z fp mw fr fs mx fu fw ip bi translated">JavaScript设计模式:策略模式</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">学习设计模式的目的是代码的可重用性，使代码更容易被其他人理解，并且…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf jw mr"/></div></div></a></div><div class="mo mp gp gr mq mr"><a rel="noopener  ugc nofollow" target="_blank" href="/javascript-design-patterns-singleton-pattern-7ada98be9a10"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd ir gy z fp mw fr fs mx fu fw ip bi translated">JavaScript设计模式:单例模式</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">Singleton模式:将类实例化的次数限制为一次，一个类只有一个实例，并且…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="na l"><div class="ng l nc nd ne na nf jw mr"/></div></div></a></div></div></div>    
</body>
</html>