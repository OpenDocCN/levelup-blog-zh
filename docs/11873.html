<html>
<head>
<title>Test pyramid as a measurable code metric</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为可测量的代码度量的测试金字塔</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/test-pyramid-as-a-measurable-code-metric-b2363e95ebe8?source=collection_archive---------19-----------------------#2022-04-24">https://levelup.gitconnected.com/test-pyramid-as-a-measurable-code-metric-b2363e95ebe8?source=collection_archive---------19-----------------------#2022-04-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a442aa55aded7a9ce8b0dc8efef5eacb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qch2pkzVojG6KfP1qSOgAw.png"/></div></div></figure><p id="1538" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为科学的几何学知道一个正方形金字塔形状的单一定义。但是软件工程师知道许多类型的金字塔形状，他们都称之为“测试金字塔”。</p><h2 id="b091" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">定义</h2><blockquote class="lp lq lr"><p id="721c" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated">“测试金字塔”是一个隐喻，它告诉我们将软件测试分成不同粒度的组。它也给出了我们应该在每一组中进行多少测试的想法。虽然测试金字塔的概念已经存在了一段时间，但是团队仍然很难将它正确地付诸实践… </p></blockquote><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lw"><img src="../Images/deef2424686599e52d434e797742bca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pUy-FCB-3iIExH_vgRL8UA.png"/></div></div></figure><p id="a295" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据<a class="ae mb" href="https://martinfowler.com/articles/practical-test-pyramid.html" rel="noopener ugc nofollow" target="_blank">马丁·福勒</a>的定义，理想的测试金字塔必须通过为特定的测试用例选择正确的测试类型来提高覆盖真实业务场景的效率和速度。保持一个正确的比例可以让大多数的测试容易编写，并且超级稳定和快速。</p><p id="e667" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从我的角度来看，产生的测试金字塔类型也是软件设计有效性的试金石，也是团队中采用TDD方法的一个很好的指示器。</p><h2 id="4a69" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">几个例子？</h2><p id="68c4" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">让我们回顾几个测试金字塔的例子，以及形成这种形状的可能原因。</p><p id="2c78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">⛔ <strong class="ka ir">警告，检测到软件设计复杂性</strong></p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/bb9ba827258f8488100f2c8cd799f67b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hkg4wQznTkHuNeahDjW4sA.png"/></div></div></figure><p id="3c29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大概架构是如此的不清晰和复杂，以至于系统只能作为一个黑盒来测试。违反了单一责任原则，因此模块和服务变得非常复杂，测试集成场景是一个很大的挑战。</p><p id="c406" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑到长期的复杂性——唯一的方法是只测试单个类的行为或一般的完整用户行为。</p><p id="36db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> ⛔警告，检测到信心不足</strong></p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/9da568af96f0a03bf2170f6007b2cd4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QtoRkwrgKXntl49QZ_ENxA.png"/></div></div></figure><p id="dc14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大概工程师连自己都不相信。即使有足够的测试来证明行为如预期的那样工作，每个行为变化仍然会在每个下一层和周围的行为上被再次检查。这表明架构仍然足够复杂——由于某些原因，您不能信任预期的流程，并且想要重新检查特定变更传播应该经过的完整路径。因此，使用更复杂、更不稳定的测试类型，花费更多的时间重新检查已经检查过的行为。</p><p id="aa2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">⛔ <strong class="ka ir">警告，检测到缺乏信任</strong></p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/c0019886dc1f05e896869c06af4f162b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JW5zsusIms-Yi1yHQ9-s5w.png"/></div></div></figure><p id="06a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">工程师非常接近于抓住测试金字塔哲学，但是没有像QA团队那样关注边缘案例和设计特性的各种场景。</p><p id="7ced" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种相对直接的业务需求让QA部门感到害怕，因此重复了许多不同的测试，并添加了许多其他测试来覆盖缺失的场景。这种类型的测试金字塔通常表明不同部门之间缺乏沟通，因此有些工作是重复的。</p><p id="c98b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">⛔ <strong class="ka ir">警告，检测到违反TDD规则</strong></p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/07ba2ff958469a18371791fd5ccfb32f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TCpj14hgjiCemyRilhI1BA.png"/></div></div></figure><p id="3be3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有证据表明测试了个别的类行为或一般的精确特性行为。这种类型的测试金字塔与上面的类似，但是有不同的含义——可能团队从一开始就没有遵循TDD作为一种实践，所以你已经以一种对TDD不友好的方式设计了层、层次和这些层之间的通信。</p><p id="07c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，这种类型的金字塔可以表明解决方案对供应商框架有很强的依赖性，因此没有很强的应用程序设计可以遵循。</p><p id="3f4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个很好的例子是，当没有引入清晰的层次结构时，Spring DI被用作事实上的引擎，从应用程序中的任何位置神奇地访问任何服务。应用这种范式时，没有专门的层来集成和交流特定的服务，而是循环复杂的服务和一组动态的依赖关系的混合，因此测试这种服务的复杂性要高得多。</p><h1 id="c875" class="ml kx iq bd ky mm mn mo lb mp mq mr le ms mt mu lh mv mw mx lk my mz na ln nb bi translated">如何控制你所拥有的测试金字塔？</h1><p id="ecd8" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">所有这些以测试金字塔为中心的开发范例听起来更像一些抽象的模式，而不是具体的可测量的测试方法。</p><p id="8f75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为工程师，我们希望持续地控制设计和测试覆盖率，并在超过定义的阈值时发出一些警告。</p><p id="473a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果代码覆盖率控制不再是一个挑战，因为有许多第三方平台，如<a class="ae mb" href="https://www.sonarqube.org/" rel="noopener ugc nofollow" target="_blank"> SonarQube </a>可以让您深入了解代码和覆盖率，那么控制测试金字塔形状仍然是一个挑战。</p><p id="2fd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">显然，我们可以将更多的注意力放在代码审查过程上，并对审查期间检测到的模式违规做出反应。这绝对是一个“必须”的实践，但是由于这里的人为因素，它并不是没有错误的。所以最好用形状识别来改进CI过程，以保证其有效性。</p><p id="a9ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">验证的公式可以很简单——大多数测试必须是“单元”类型，一小部分是“集成”和“端到端”测试。我们可以把它看作要求，即:</p><ul class=""><li id="a50c" class="nc nd iq ka b kb kc kf kg kj ne kn nf kr ng kv nh ni nj nk bi translated">所有测试的60%以上必须是单元测试</li><li id="979d" class="nc nd iq ka b kb nl kf nm kj nn kn no kr np kv nh ni nj nk bi translated">只有不到10%的<strong class="ka ir">是端到端测试</strong></li><li id="6cd4" class="nc nd iq ka b kb nl kf nm kj nn kn no kr np kv nh ni nj nk bi translated">只有不到30%的集成测试</li></ul><p id="acf3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">控制这个比例有助于我们让金字塔看起来像金字塔。因此，大多数测试将是快速和稳定的测试，非常少量的测试将检查完整的用户场景，当许多服务集成以产生复杂的流程时，层也受到足够大百分比的测试的控制。</p><p id="4221" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们的CI可以简单到:</p><ul class=""><li id="f69b" class="nc nd iq ka b kb kc kf kg kj ne kn nf kr ng kv nh ni nj nk bi translated">运行“单元”类型的所有测试，并存储执行的总计数</li><li id="21d7" class="nc nd iq ka b kb nl kf nm kj nn kn no kr np kv nh ni nj nk bi translated">运行“集成”类型的所有测试，并存储执行的总计数</li><li id="3d07" class="nc nd iq ka b kb nl kf nm kj nn kn no kr np kv nh ni nj nk bi translated">运行“端到端”类型的所有测试，并存储执行的总计数</li><li id="0737" class="nc nd iq ka b kb nl kf nm kj nn kn no kr np kv nh ni nj nk bi translated">检查每种类型的预期百分比是否在定义的范围内</li></ul><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/59aa2440be1cf0714ecd1c98a0b8fcd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*36JBwlF8Ra9Zg1rZs72UUw.png"/></div></div></figure><h2 id="9ce6" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">演示</h2><p id="fe90" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">有一个基于Jhipster的项目被创建为参考。</p><p id="9382" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有一个新的<a class="ae mb" href="https://github.com/donvadicastro/medium-test-pyramid/pull/2" rel="noopener ugc nofollow" target="_blank"> PR创建了</a>，它使用GitHub actions管道来检查测试金字塔作为门控步骤。</p><p id="6ecd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">介绍测试金字塔检查的步骤:</strong></p><ul class=""><li id="1028" class="nc nd iq ka b kb kc kf kg kj ne kn nf kr ng kv nh ni nj nk bi translated">创建GitHub操作，对每个PR操作(创建、提交)运行检查</li></ul><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><ul class=""><li id="dfd9" class="nc nd iq ka b kb kc kf kg kj ne kn nf kr ng kv nh ni nj nk bi translated">创建梯度任务以计算金字塔(每种测试类型的百分比)</li></ul><p id="8fb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于演示的目的，我们选择了最简单的测试分类策略——特定文件夹中的所有测试都属于特定的类型。此外，界面标记可用于更精细的测试分类。</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><ul class=""><li id="d512" class="nc nd iq ka b kb kc kf kg kj ne kn nf kr ng kv nh ni nj nk bi translated">作为CI验证的一部分，检查每种测试类型的测试百分比是否在规定的范围内，例如</li></ul><pre class="lx ly lz ma gt nt nu nv nw aw nx bi"><span id="9262" class="kw kx iq nu b gy ny nz l oa ob">if [[ $unit_percent &gt; .6 ]]<br/>then<br/>  echo "Pyramid is valid"<br/>else<br/>  echo "Pyramid is invalid: number of unit tests only $unit_percent"<br/>false<br/>fi</span></pre><p id="4dc9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以想象成:</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/44c587f3eb387e6cf8c5f9c422ea4bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tqDubKvMDr-xgaHF_gkwxw.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">具有测试金字塔检查的CI</figcaption></figure><p id="991e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，测试金字塔有效性可以被认为是我们可以依赖的又一个度量标准，并且不能交付使完整状态变得更糟的代码增量。</p><p id="e140" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将度量作为一个阈值指示器，可以减少代码交付过程对人工控制的依赖。类似于静态代码分析或代码覆盖，当团队在边界附近工作时，它可能是一个障碍，所以定期的设计评审和控制TDD是采用多一个门控验证的先决条件。另一方面，它有一个很好的可视化点，可以很容易地揭示现有的产品设计问题。</p></div></div>    
</body>
</html>