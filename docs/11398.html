<html>
<head>
<title>Efficient Asynchronous Code in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#中高效的异步代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/efficient-asynchronous-code-in-c-8d58fc62a88f?source=collection_archive---------8-----------------------#2022-03-14">https://levelup.gitconnected.com/efficient-asynchronous-code-in-c-8d58fc62a88f?source=collection_archive---------8-----------------------#2022-03-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8188" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何正确使用异步和等待以获得最佳性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/507e276f0ccd191a02c1c51482030111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F2J-06yts25SyB6uOxJZRA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">穆罕默德·拉赫马尼在<a class="ae ky" href="https://unsplash.com/photos/LrxSl4ZxoRs" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="ecb0" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="li iu">什么是异步编程？</strong></p><p id="d69a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">异步编程使您的程序能够启动一个可能长期运行的任务，然后不必等到该任务完成，而是能够在任务运行时继续响应其他事件。一旦任务完成，你的程序就会得到结果。这将使应用程序能够在后台完成任务的同时继续工作。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/950de94cc5a0831446a1fe6d0a1b800d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-8PdXXfJ-2A1no1noO1ZdA.jpeg"/></div></div></figure><p id="9a6b" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">好了，现在我们知道异步允许我们在等待响应的同时启动一个任务并做其他事情，但是让我们看一下我们想要一次执行3个任务的情况，如上图所示。假设我们有这样的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="7316" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果我们假设像上面的图表那样工作，执行这些调用的总时间将是90毫秒。但是异步编程是关于在线程之间划分工作负载，这意味着我们可以并行完成每个任务，或者等到所有任务完成后再处理结果。等待所有的任务，直到我们处理结果是这里的关键。我们可以这样重构代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="cb9e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这样，我们等待所有任务完成并利用线程，完成所有任务所需的时间等于最慢的任务，在我们的例子中是50毫秒，几乎快了2倍。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/eb7dd9a8718cedcc8a20c1debcfa5ecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qQoGyZ-pZ_sO8dH_fqG_1w.jpeg"/></div></div></figure><p id="7a70" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果我们需要把它形象化，它就会是这个样子。我们希望执行的所有任务同时启动，而不是一个接一个，结果会更快地一起返回。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="57ce" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">但这并不意味着你可以根据自己的需要来混合调用。例如，编写上面代码的正确方式应该是这样的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="752a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">因为我们不希望orders表上有多余的字段，所以我们可能最终会得到<em class="mg"> customerId </em>，我们将<em class="mg">等待</em>调用来首先检索客户。但是由于接下来的两个调用互不依赖，我们可以将它们分组并一起等待。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="2fd0" class="mh mi it bd mj mk ml dn mm mn mo dp mp lp mq mr ms lt mt mu mv lx mw mx my mz bi translated">结论</h2><p id="1d86" class="pw-post-body-paragraph lg lh it li b lj na ju ll lm nb jx lo lp nc lr ls lt nd lv lw lx ne lz ma mb im bi translated">如果你正在开发的软件的设计很好，并且正在进行的调用相当快，我们可能会通过编写单个等待而忽略性能，但是我确实认为作为开发人员，我们应该了解编写代码和交付最佳产品的最有效方式。在这个例子中，我们看到在一行代码的帮助下，速度几乎快了一倍，但是使用这个软件的用户会真正欣赏这个速度。</p></div></div>    
</body>
</html>