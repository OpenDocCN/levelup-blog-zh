<html>
<head>
<title>Uploading your first Docker Image using Podman</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Podman上传您的第一张Docker图片</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/uploading-your-first-docker-image-using-podman-87713e2043a0?source=collection_archive---------5-----------------------#2020-08-01">https://levelup.gitconnected.com/uploading-your-first-docker-image-using-podman-87713e2043a0?source=collection_archive---------5-----------------------#2020-08-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0f5557b9517cac6cab7d700f5ad4422a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_OcmKklCRY-ajltdvmzrxw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Podman是一个无后台容器引擎，用于在Linux系统上开发、管理和运行OCI容器。容器可以作为根运行，也可以在无根模式下运行。</figcaption></figure><p id="5a3b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Docker是一组平台即服务产品，使用操作系统级虚拟化来交付称为容器的软件包中的软件。容器是相互隔离的，捆绑了它们自己的软件、库和配置文件；他们可以通过明确定义的渠道相互交流。</p><p id="823f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一个<strong class="kh iu"> Docker映像</strong>是一个只读模板，包含一组创建容器的指令，该容器可以在<strong class="kh iu"> Docker </strong>平台上运行。它提供了一种便捷的方式来打包应用程序和预先配置的服务器环境，您可以将其用于自己的私人用途，或者与其他<strong class="kh iu"> Docker </strong>用户公开共享。</p><p id="e3cc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您将推进docker.io的图像基本上有:</p><ul class=""><li id="d7f1" class="ld le it kh b ki kj km kn kq lf ku lg ky lh lc li lj lk ll bi translated">Docker文件</li><li id="f2bc" class="ld le it kh b ki lm km ln kq lo ku lp ky lq lc li lj lk ll bi translated">应用程序(这里我们将使用python)</li><li id="9218" class="ld le it kh b ki lm km ln kq lo ku lp ky lq lc li lj lk ll bi translated">带包的文本文件(依赖)</li></ul><p id="aa2e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们首先创建一个新目录(app)并在其中设置一个<strong class="kh iu"> docker文件</strong>。</p><p id="133c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="lr"> Dockerfile : </em></p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="e616" class="mb mc it lx b gy md me l mf mg">FROM python:alpine3.7<br/>COPY . /app<br/>WORKDIR /app<br/>RUN pip install -r requirements.txt<br/>EXPOSE 8080<br/>CMD python ./index.py</span></pre><p id="e504" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">来自python:apline3.7 </strong>是linux系统中可用的最基本的python版本。</p><p id="66bf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">复制</strong>和<strong class="kh iu">工作目录</strong>只是设置<strong class="kh iu">应用</strong>作为将要工作的目录。</p><p id="7cbb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们的应用程序文件可能需要在python的基本linux版本中通常找不到的包。所以我们写了一个<strong class="kh iu"> requirements.txt </strong>(我们将在下面看到一个例子)，它将保存我们需要的包，并在<strong class="kh iu">上运行</strong>命令，所有的包都将被安装。</p><p id="5b29" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> EXPOSE </strong>是打开我们将用来连接的端口，我们也会在应用程序代码中提到这一点。</p><p id="ec9c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们已经讨论了上面的需求文件，这个应用程序很简单，不需要很多包。</p><p id="048c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="lr"> requirements.txt : </em></p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="fe39" class="mb mc it lx b gy md me l mf mg">flask</span></pre><p id="8940" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们已经准备好了<strong class="kh iu">文档</strong>和<strong class="kh iu">需求。txt </strong>接下来…</p><p id="8e52" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="lr"> app.py </em>:</p><figure class="ls lt lu lv gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="e3b1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们可以使用Docker或Podman将文件上传到docker.io或quaoy.io。</p><p id="9abc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">注意</strong>:当你必须在Knative上运行它时，确保端口是8080，flask默认为5000，在上面的代码中我们明确地声明它是8080。</p><h2 id="09dc" class="mb mc it bd mj mk ml dn mm mn mo dp mp kq mq mr ms ku mt mu mv ky mw mx my mz bi translated">您可能会面临错误的几个重要领域</h2><ul class=""><li id="dbf6" class="ld le it kh b ki na km nb kq nc ku nd ky ne lc li lj lk ll bi translated">确保您的应用程序和Docker文件中的端口号相同。</li><li id="7e5d" class="ld le it kh b ki lm km ln kq lo ku lp ky lq lc li lj lk ll bi translated">docker文件中的文件名与应用程序的名称相同。</li></ul><p id="b686" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一旦你所有的文件都设置好了，进入<strong class="kh iu"> app </strong>文件夹，那里存储着你的docker文件和剩余的文件，然后运行下面的命令。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="0920" class="mb mc it lx b gy md me l mf mg">podman build -t docker.io/neeha246/python-helloworld-demo .</span></pre><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nf"><img src="../Images/67241e5c897a5a9db319c15f917ddaa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7u46r88qMxKWRTFPh-55sA.png"/></div></div></figure><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="6f68" class="mb mc it lx b gy md me l mf mg">podman login docker.io</span></pre><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ng"><img src="../Images/253e6365ebe795a5a77452dfb4e003c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c7NMcAhA7anhY2wiPe-QBA.png"/></div></div></figure><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="6f60" class="mb mc it lx b gy md me l mf mg">podman push docker.io/neeha246/python-helloworld-demo</span></pre><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/89682c1199b69933c0b559f135ec8ac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CTDghoK18htSMlfu3s_3FA.png"/></div></div></figure><h2 id="15b2" class="mb mc it bd mj mk ml dn mm mn mo dp mp kq mq mr ms ku mt mu mv ky mw mx my mz bi translated">如何检查您的映像是否正在运行</h2><p id="9d89" class="pw-post-body-paragraph kf kg it kh b ki na kk kl km nb ko kp kq ni ks kt ku nj kw kx ky nk la lb lc im bi translated">要检查您的映像是否正常运行，您需要使用podman或docker在本地系统上运行映像，并查看应用程序是否正在部署。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="6d48" class="mb mc it lx b gy md me l mf mg">podman run -ti -p 8080:8080 -d docker.io/neeha246/python-helloworld-demo</span></pre><p id="8378" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你不得不提到端口为8080和图像链接。您还可以选择在您的系统上给图像一个本地名称，否则podman会给它一个随机的名称。然后运行下面的命令，我们可以看到你的容器被部署。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="1293" class="mb mc it lx b gy md me l mf mg">podman ps</span></pre><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/4ef1c4a2417c305c5b9a82f86e370a86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jl-jkp7KLSl7_usoTqU6Mg.png"/></div></div></figure><p id="cfdb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果在运行您的命令后，您没有找到正在部署的容器，请尝试:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="4b55" class="mb mc it lx b gy md me l mf mg">podman ps -a</span></pre><p id="366d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">上面的命令让您看到您试图部署的容器ID/名称，您可以使用它来检查podman中的日志。</p><p id="298a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在只要去任何一个浏览器，给链接<strong class="kh iu"> localhost:8080 </strong>(这里)，基本上就是localhost: &lt;端口号&gt;。你可以看到你的申请，在这里，你好世界！正在显示。</p><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/86e34fe76a75d8823fb1ac4b626de241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*1Y0omNKyTtU-f1ISE30PLQ.png"/></div></figure><p id="098c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一旦您可以看到正在部署的应用程序，您就可以确认您的映像工作正常。</p><h2 id="408f" class="mb mc it bd mj mk ml dn mm mn mo dp mp kq mq mr ms ku mt mu mv ky mw mx my mz bi translated">删除容器</h2><p id="4ff4" class="pw-post-body-paragraph kf kg it kh b ki na kk kl km nb ko kp kq ni ks kt ku nj kw kx ky nk la lb lc im bi translated">您可以对多个映像使用同一个端口，因此您需要删除不再使用的映像/容器，以便再次使用该端口。如果您运行podman ps命令，您可以看到分配给容器的随机名称podman，使用该名称删除。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="42a9" class="mb mc it lx b gy md me l mf mg">podman stop &lt;Container name&gt;</span></pre><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/4a70583f0b1c4cd861a1a503874518f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QrmoJyFMpLse8SIjIoIB7g.png"/></div></div></figure><p id="5636" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我的下一篇文章将是关于如何使用Knative部署这个映像，然后也许我们可以使用GO Lang进一步编写docker。</p></div></div>    
</body>
</html>