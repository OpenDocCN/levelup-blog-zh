<html>
<head>
<title>TypeScript Best Practices — Type Assertions and Type Annotations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型脚本最佳实践—类型断言和类型批注</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-best-practices-type-assertions-and-type-annotations-d30c0acb19ec?source=collection_archive---------11-----------------------#2020-05-31">https://levelup.gitconnected.com/typescript-best-practices-type-assertions-and-type-annotations-d30c0acb19ec?source=collection_archive---------11-----------------------#2020-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c4ffa7e2d9704bab421bbc4e0fcf7c18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1StgkAULilvsPfEA"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@eaterscollective?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">食客集体</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="6c07" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript是一个简单易学的JavaScript扩展。编写运行并执行某些操作的程序很容易。然而，很难考虑所有的用例并编写健壮的类型脚本代码。</p><p id="4614" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究使用TypeScript编写代码时要遵循的最佳实践，包括类型断言和显式类型注释。</p><h1 id="9ed4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">强制类型断言的一致使用</h1><p id="2c44" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">类型断言风格应该在我们的项目中保持一致。</p><p id="abe1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类型断言在TypeScript中也称为数据类型转换。</p><p id="6642" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，它们在技术上是不同的。</p><p id="2049" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">as</code>关键字或者<code class="fe mh mi mj mk b">&lt;&gt;</code>来给我们的值添加类型断言。</p><p id="f5e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以坚持:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="53aa" class="mt lf it mk b gy mu mv l mw mx">let x = "foo" as string;</span></pre><p id="c2e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0b3f" class="mt lf it mk b gy mu mv l mw mx">let x = &lt;string&gt;"foo";</span></pre><p id="a6b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">const</code>也是用统治来允许的。从TypeScript 3.4开始就有了，它允许我们将某些东西设为只读。</p><p id="e649" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="058b" class="mt lf it mk b gy mu mv l mw mx">let x = "foo" as const;</span></pre><p id="dbf3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2b8d" class="mt lf it mk b gy mu mv l mw mx">let x = &lt;const&gt;"foo";</span></pre><h1 id="5cd0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">与接口或类型一致的类型定义</h1><p id="ff5d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在TypeScript中，我们可以定义注释类型的接口。</p><p id="508c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以用关键字<code class="fe mh mi mj mk b">type</code>创建类型别名来做同样的事情。</p><p id="6934" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们定义类型时，与我们使用的一致是一个好主意。</p><p id="18ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以坚持使用接口:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ac24" class="mt lf it mk b gy mu mv l mw mx">interface Foo {<br/>  a: string;<br/>  b: number;<br/>}</span></pre><p id="aa6f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者键入别名:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5417" class="mt lf it mk b gy mu mv l mw mx">type Foo = {<br/>  a: string;<br/>  b: number;<br/>};</span></pre><h1 id="880e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">要求函数和类方法的显式返回类型</h1><p id="e467" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为函数和类方法添加返回类型注释是个好主意。</p><p id="7ce6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们知道每个函数或方法返回什么。</p><p id="38c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ebdc" class="mt lf it mk b gy mu mv l mw mx">function foo() {<br/>  return 'bar';<br/>}</span></pre><p id="8934" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9eba" class="mt lf it mk b gy mu mv l mw mx">function foo: string() {<br/>  return 'bar';<br/>}</span></pre><p id="a246" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，使用类方法，而不是编写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4991" class="mt lf it mk b gy mu mv l mw mx">class Foo{<br/>  method() {<br/>    return 'bar';<br/>  }<br/>}</span></pre><p id="28fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b2d9" class="mt lf it mk b gy mu mv l mw mx">class Foo{<br/>  method(): string {<br/>    return 'bar';<br/>  }<br/>}</span></pre><p id="5432" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们的方法不返回任何东西，我们使用<code class="fe mh mi mj mk b">void</code>返回类型:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5e3c" class="mt lf it mk b gy mu mv l mw mx">function foo(): void {<br/>  return;<br/>}</span></pre><p id="5d27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4071" class="mt lf it mk b gy mu mv l mw mx">class Foo{<br/>  method(): void {<br/>    return;<br/>  }<br/>}</span></pre><h1 id="62eb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在类属性和方法上需要显式的可访问性修饰符</h1><p id="9026" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们忽略了类中的可访问性修饰符，那么人们可能很难理解一个类的属性或方法是否是可访问的。</p><p id="acb3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">默认情况下，如果我们忽略它们，这个类成员就是公共的。</p><p id="77c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，在大多数情况下，我们可能还希望限制对某些成员的访问。</p><p id="bb13" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该包括他们。</p><p id="b568" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以与其写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="528a" class="mt lf it mk b gy mu mv l mw mx">class Foo {<br/>  foo() {<br/>    console.log("foo");<br/>  }</span><span id="1b67" class="mt lf it mk b gy my mv l mw mx">  bar() {<br/>    //...<br/>  }<br/>}</span></pre><p id="9f67" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可能希望通过写入以下内容来限制对某些成员的访问:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e851" class="mt lf it mk b gy mu mv l mw mx">class Foo {<br/>  foo() {<br/>    console.log("foo");<br/>  }</span><span id="70b6" class="mt lf it mk b gy my mv l mw mx">  private bar() {<br/>    //...<br/>  }<br/>}</span></pre><p id="2802" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，如果我们试图编译它，TypeScript编译器会给我们一个错误。</p><p id="2dd8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">访问修饰符包括<code class="fe mh mi mj mk b">public</code>、<code class="fe mh mi mj mk b">private</code>、<code class="fe mh mi mj mk b">readonly</code>和<code class="fe mh mi mj mk b">protected</code>。</p><p id="b340" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个<code class="fe mh mi mj mk b">public</code>成员可以做任何事情。</p><p id="923e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个<code class="fe mh mi mj mk b">private</code>成员只在类中可用。</p><p id="a838" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个<code class="fe mh mi mj mk b">readonly</code>成员是公共的，但它是只读的。</p><p id="cb0a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个<code class="fe mh mi mj mk b">protected</code>成员只在类或任何子类中可用。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/c0b92caca960194edf808e45d955515e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*osLnk99bbWP0Kwr2"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">约瑟夫·冈萨雷斯在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="1cff" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在导出的函数和类的公共类方法上需要显式的返回和参数类型</h1><p id="8295" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了使使用函数和类的公共方法更容易，我们应该添加显式的参数和返回类型，以便在使用它们时可以自动完成和出错。</p><p id="e1ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3bb2" class="mt lf it mk b gy mu mv l mw mx">export function test() {<br/>  return;<br/>}</span></pre><p id="03f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="375d" class="mt lf it mk b gy mu mv l mw mx">export function test(): void {<br/>  return;<br/>}</span></pre><p id="8f93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而不是写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b5e3" class="mt lf it mk b gy mu mv l mw mx">class Foo {<br/>  method() {<br/>    return;<br/>  }<br/>}</span></pre><p id="4b67" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a191" class="mt lf it mk b gy mu mv l mw mx">export class Foo {<br/>  method(): void {<br/>    return;<br/>  }<br/>}</span></pre><p id="d2d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，对于参数类型，我们写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3056" class="mt lf it mk b gy mu mv l mw mx">export class Foo {<br/>  method(foo: string): string {<br/>    return foo;<br/>  }<br/>}</span></pre><p id="8a88" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并且:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5032" class="mt lf it mk b gy mu mv l mw mx">export function test(foo: string): string{<br/>  return foo;<br/>}</span></pre><p id="7f2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们不必猜测或查找导出的类和函数的类型。</p><h1 id="3896" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="300c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该注释返回和参数类型，这样就不必查找导出的函数和类方法的类型。</p><p id="7272" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一致地使用类型断言符号可能也是一个好主意。</p><p id="0a26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，保持一致地使用<code class="fe mh mi mj mk b">interface</code>或<code class="fe mh mi mj mk b">type</code>来创建新类型也是一个好主意。</p></div></div>    
</body>
</html>