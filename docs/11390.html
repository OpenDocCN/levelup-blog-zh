<html>
<head>
<title>Containerizing nginx + PHP FPM on Alpine Linux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Alpine Linux上容器化nginx + PHP FPM</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/containerizing-nginx-php-fpm-on-alpine-linux-953430ea6dbc?source=collection_archive---------0-----------------------#2022-03-14">https://levelup.gitconnected.com/containerizing-nginx-php-fpm-on-alpine-linux-953430ea6dbc?source=collection_archive---------0-----------------------#2022-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5383" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我是如何学会不再担心，并爱上PHP容器的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/45cf0ad037801e09a1aa96cf5e1ad5c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pXobPOnQRv6RERTCUyL5NA.png"/></div></div></figure><p id="f85c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你曾经需要使用PHP-FPM (PHP FastCGI进程管理器)运行nginx (engine x) web服务器来进行开发或其他工作，你应该知道配置和设置是一件痛苦的事情。</p><p id="6676" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你必须启动一个虚拟机或者找到一个本地服务器(也可以是你的本地开发设备)。然后你必须安装和配置nginx。然后你必须安装和配置PHP-FPM。那你就得抱最好的希望了。</p><p id="481a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这通常是为你工作的每一个项目而做的，因为，如果没有别的原因，PHP和nginx中有太多不同的设置必须为那个项目专门设置。</p><p id="b9db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">说了这么多，如果你还在读这篇文章，我想我不需要说服你它的好处，对吗？</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="226e" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">定义</h1><p id="d2c0" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">让我们为这些技术的新用户提供一些定义吧！</p><h2 id="c8bb" class="mr lv iq bd lw ms mt dn ma mu mv dp me la mw mx mg le my mz mi li na nb mk nc bi translated">nginx</h2><p id="7021" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">发音为“<em class="nd">引擎x </em>”。对于本文上下文中的所有意图和目的，nginx是一个web服务器。在<a class="ae ne" href="http://nginx.org" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="nd"/></strong></a>处定义为:</p><blockquote class="nf ng nh"><p id="025e" class="kr ks nd kt b ku kv jr kw kx ky ju kz ni lb lc ld nj lf lg lh nk lj lk ll lm ij bi translated">HTTP和反向代理服务器、邮件代理服务器和通用TCP/UDP代理服务器。</p></blockquote></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h2 id="f4b4" class="mr lv iq bd lw ms mt dn ma mu mv dp me la mw mx mg le my mz mi li na nb mk nc bi translated">服务器端编程语言（Professional Hypertext Preprocessor的缩写）</h2><p id="c4f1" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">读作“<em class="nd"> P H P </em>”(我知道，<strong class="kt ir"> <em class="nd">非常</em> </strong> <strong class="kt ir"> <em class="nd">巧妙</em> </strong>)。这是用来构建动态网站的语言和引擎，它配备了你能想到的所有功能。对于本文，我们将关注最新版本(在撰写本文时)8.1。但是，这个设置至少可以在7.x版本上运行(我没有在之前的版本上测试过)。PHP在<a class="ae ne" href="https://www.php.net" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="nd"/></strong></a>被定义为:</p><blockquote class="nf ng nh"><p id="25ec" class="kr ks nd kt b ku kv jr kw kx ky ju kz ni lb lc ld nj lf lg lh nk lj lk ll lm ij bi translated">一种流行的通用脚本语言，特别适合web开发。</p><p id="452b" class="kr ks nd kt b ku kv jr kw kx ky ju kz ni lb lc ld nj lf lg lh nk lj lk ll lm ij bi translated">快速、灵活和实用的PHP为从你的博客到世界上最受欢迎的网站的一切提供了动力。</p></blockquote></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h2 id="6e92" class="mr lv iq bd lw ms mt dn ma mu mv dp me la mw mx mg le my mz mi li na nb mk nc bi translated">PHP FPM</h2><p id="5c0f" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">这是PHP的FastCGI进程管理器，令人惊讶的是它被称为PHP FPM。这允许nginx通过套接字或公开的TCP/IP端口访问PHP引擎。它非常快，通常为您的应用程序提供最快的响应时间(与在nginx或Apache中将PHP作为一个模块运行相比)。很简单，在https://php-fpm.org<a class="ae ne" href="https://php-fpm.org" rel="noopener ugc nofollow" target="_blank">它被定义为:</a></p><blockquote class="nf ng nh"><p id="dc94" class="kr ks nd kt b ku kv jr kw kx ky ju kz ni lb lc ld nj lf lg lh nk lj lk ll lm ij bi translated">一个简单而健壮的FastCGI进程管理器</p></blockquote></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h2 id="64de" class="mr lv iq bd lw ms mt dn ma mu mv dp me la mw mx mg le my mz mi li na nb mk nc bi translated">码头工人</h2><p id="0630" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">我们用来创建、构建和运行容器的内容。你可以在Docker、Kubernetes以及其他云提供商容器服务(比如Azure的App服务)中运行容器。然而，对于本文的范围，我们将简单地在Docker本地运行我们的容器。在<a class="ae ne" href="https://www.docker.com" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="nd"/></strong></a>处定义为:</p><blockquote class="nf ng nh"><p id="2d77" class="kr ks nd kt b ku kv jr kw kx ky ju kz ni lb lc ld nj lf lg lh nk lj lk ll lm ij bi translated">Docker消除了重复、平凡的配置任务，并在整个开发生命周期中用于快速、简单和可移植的应用程序开发——桌面和云。Docker全面的端到端平台包括ui、CLI、API和安全性，它们在整个应用交付生命周期中协同工作。</p></blockquote><h1 id="58a0" class="lu lv iq bd lw lx nl lz ma mb nm md me jw nn jx mg jz no ka mi kc np kd mk ml bi translated">先决条件</h1><h2 id="2a61" class="mr lv iq bd lw ms mt dn ma mu mv dp me la mw mx mg le my mz mi li na nb mk nc bi translated">码头工人</h2><p id="c04c" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">我们其实并不需要<strong class="kt ir"> <em class="nd">本地安装</em> </strong> PHP或者nginx来容器化它(这就是容器的妙处！).然而，我们确实需要Docker，这样我们就可以马上测试我们的容器，在macOS或Windows上最简单的方法就是安装Docker Desktop。如果你在Linux上，安装将(当然)通过Docker的CLI安装。</p><blockquote class="nf ng nh"><p id="dcd2" class="kr ks nd kt b ku kv jr kw kx ky ju kz ni lb lc ld nj lf lg lh nk lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="iq">注</em> </strong> <em class="iq"> <br/> Docker桌面包括Docker App、开发者工具、Kubernetes以及与生产Docker引擎的版本同步。Docker Desktop允许您利用经过认证的图像和模板以及您选择的语言和工具。开发工作流利用Docker Hub将您的开发环境扩展到一个安全的存储库，以实现快速自动构建、持续集成和安全协作。</em></p></blockquote><p id="5c0d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以得到。dmg或者。用于Mac和Windows的Docker桌面的exe安装程序</p><p id="0842" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="nd">在Windows上</em> </strong> <br/>在Windows上，安装就像运行。exe(你知道的，ol '双击？).</p><p id="e6ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="nd">在Mac上</em> </strong> <br/>在macOS上，安装就像运行。dmg，然后常见的拖放到应用程序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/1d4b676232a94c7cda5e9c12a86e54b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ves3fBUs1aNAP-wB.png"/></div></div></figure><blockquote class="nf ng nh"><p id="2fe7" class="kr ks nd kt b ku kv jr kw kx ky ju kz ni lb lc ld nj lf lg lh nk lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="iq">注意</em> </strong> <em class="iq"> <br/>在macOS上，您可能需要从您的</em><strong class="kt ir"><em class="iq">launch pad</em></strong><em class="iq">中启动</em><strong class="kt ir"><em class="iq">Docker</em></strong><em class="iq">才能使用Docker命令。</em></p></blockquote><p id="858a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="nd">在Linux上</em> </strong> <br/>所以——在Linux上，安装并不那么容易，但也很接近了！我们将在Ubuntu上执行这个安装，但是在其他Linux平台上的安装也是类似的。</p><p id="93f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">第1步—设置存储库</strong></p><p id="c52a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">1.确保没有现有安装。<br/> <code class="fe nr ns nt nu b"><strong class="kt ir">sudo apt-get remove docker docker-engine docker.io containerd runc</strong></code></p><p id="f7f4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.刷新APT存储库。<br/> <code class="fe nr ns nt nu b"><strong class="kt ir">sudo apt-get update</strong></code></p><p id="612c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.安装支持应用程序。</p><pre class="kg kh ki kj gt nv nu nw nx aw ny bi"><span id="0104" class="mr lv iq nu b gy nz oa l ob oc"><strong class="nu ir">sudo apt-get install apt-transport-https ca-certificates curl gnupg    lsb-release</strong></span></pre><p id="9974" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">4.添加码头工人的GPG键</p><pre class="kg kh ki kj gt nv nu nw nx aw ny bi"><span id="ddf0" class="mr lv iq nu b gy nz oa l ob oc"><strong class="nu ir">curl -fsSL </strong><a class="ae ne" href="https://download.docker.com/linux/ubuntu/gpg" rel="noopener ugc nofollow" target="_blank"><strong class="nu ir">https://download.docker.com/linux/ubuntu/gpg</strong></a><strong class="nu ir"> | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</strong></span></pre><p id="7586" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">5.建立稳定的Docker存储库</p><pre class="kg kh ki kj gt nv nu nw nx aw ny bi"><span id="820a" class="mr lv iq nu b gy nz oa l ob oc"><strong class="nu ir">echo \<br/>  "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] </strong><a class="ae ne" href="https://download.docker.com/linux/ubuntu" rel="noopener ugc nofollow" target="_blank"><strong class="nu ir">https://download.docker.com/linux/ubuntu</strong></a><strong class="nu ir"> \<br/>  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</strong></span></pre><p id="1bb2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">步骤2 —安装Docker引擎</strong></p><ol class=""><li id="a8b1" class="od oe iq kt b ku kv kx ky la of le og li oh lm oi oj ok ol bi translated">更新APT存储库。<br/> <code class="fe nr ns nt nu b"><strong class="kt ir">sudo apt-get update</strong></code></li><li id="f574" class="od oe iq kt b ku om kx on la oo le op li oq lm oi oj ok ol bi translated">安装<strong class="kt ir"> <em class="nd">码头</em> </strong>和<strong class="kt ir"> <em class="nd">集装箱</em> </strong> <em class="nd">。</em>这将安装<em class="nd"/><em class="nd">最新</em>稳定<strong class="kt ir"> <em class="nd">版本</em> </strong> <em class="nd">。</em> <br/> <code class="fe nr ns nt nu b"><strong class="kt ir">sudo apt-get install docker-ce docker-ce-cli containerd.io</strong></code></li></ol><p id="54cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.通过下载并运行示例容器，验证<strong class="kt ir"> <em class="nd"> Docker </em> </strong>引擎是否正常工作。<br/> <code class="fe nr ns nt nu b"><strong class="kt ir">sudo docker run hello-world</strong></code></p><p id="1a55" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这应该会在您的shell中生成一条如下所示的消息:</p><pre class="kg kh ki kj gt nv nu nw nx aw ny bi"><span id="a107" class="mr lv iq nu b gy nz oa l ob oc"><strong class="nu ir">Unable to find image 'hello-world:latest' locallylatest: Pulling from library/hello-worldb8dfde127a29: Pull completeDigest: sha256:9f6ad537c5132bcce57f7a0a20e317228d382c3cd61edae14650eec68b2b345cStatus: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.</strong></span></pre><blockquote class="nf ng nh"><p id="0292" class="kr ks nd kt b ku kv jr kw kx ky ju kz ni lb lc ld nj lf lg lh nk lj lk ll lm ij bi translated"><strong class="kt ir"><em class="iq">Linux上的Docker引擎</em> </strong> <em class="iq"> <br/>其他Linux发行版的安装说明可以在这里找到:【https://docs.docker.com/engine/install/】<a class="ae ne" href="https://docs.docker.com/engine/install/" rel="noopener ugc nofollow" target="_blank"><em class="iq"/></a></em></p></blockquote><p id="fe52" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">全部完成！您已经成功安装并配置了Docker！</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="0f7a" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">该项目</h1><p id="966b" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">现在我们已经准备好Docker，是时候设置我们的项目了。它将由三个主要部分组成:</p><ul class=""><li id="5dcf" class="od oe iq kt b ku kv kx ky la of le og li oh lm or oj ok ol bi translated">服务器配置包括nginx、PHP和PHP FPM</li><li id="ea35" class="od oe iq kt b ku om kx on la oo le op li oq lm or oj ok ol bi translated">满足于服务</li><li id="2050" class="od oe iq kt b ku om kx on la oo le op li oq lm or oj ok ol bi translated">码头/集装箱配置</li></ul><blockquote class="nf ng nh"><p id="4407" class="kr ks nd kt b ku kv jr kw kx ky ju kz ni lb lc ld nj lf lg lh nk lj lk ll lm ij bi translated"><strong class="kt ir">注意</strong> <br/>这是一个非常基本的设置，您几乎肯定希望至少在nginx和php中为生产部署更改配置。</p></blockquote><h2 id="c6ee" class="mr lv iq bd lw ms mt dn ma mu mv dp me la mw mx mg le my mz mi li na nb mk nc bi translated">结构</h2><p id="db3e" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">我们需要将nginx和php配置复制到容器中，以覆盖安装时的默认设置。</p><blockquote class="nf ng nh"><p id="6547" class="kr ks nd kt b ku kv jr kw kx ky ju kz ni lb lc ld nj lf lg lh nk lj lk ll lm ij bi translated"><strong class="kt ir">注意</strong> <br/>你可以通过克隆或者只是看一下我在这里提供的示例项目<a class="ae ne" href="https://github.com/johnathanesanders/docker-nginx-fpm" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">https://github.com/johnathanesanders/docker-nginx-fpm</strong></a></p></blockquote><p id="8a0e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我喜欢在项目根目录下创建一个名为<code class="fe nr ns nt nu b"><strong class="kt ir">server</strong></code>的目录，然后从那里模仿linux文件系统。因此，我们将创建一个包含<code class="fe nr ns nt nu b"><strong class="kt ir">nginx</strong></code>和<code class="fe nr ns nt nu b"><strong class="kt ir">php</strong></code>子目录的<code class="fe nr ns nt nu b"><strong class="kt ir">etc</strong></code>目录。在<code class="fe nr ns nt nu b"><strong class="kt ir">nginx</strong></code>中，我们将创建一个<code class="fe nr ns nt nu b"><strong class="kt ir">conf.d</strong></code>子目录，在<code class="fe nr ns nt nu b"><strong class="kt ir">php</strong></code>中，我们将创建一个<code class="fe nr ns nt nu b"><strong class="kt ir">php-fpm.d</strong></code>子目录。所有这些将在项目根中产生如下所示的结构:</p><pre class="kg kh ki kj gt nv nu nw nx aw ny bi"><span id="5aa9" class="mr lv iq nu b gy nz oa l ob oc"><strong class="nu ir">server<br/>   --- etc<br/>       --- nginx<br/>           --- conf.d<br/>       --- php<br/>           --- php-fpm.d</strong></span></pre><p id="90f4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还需要在项目根目录下有一个<code class="fe nr ns nt nu b"><strong class="kt ir">src</strong></code>目录。这将用于存储我们的网站内容。创建此目录后，项目目录的根目录应该如下所示:</p><pre class="kg kh ki kj gt nv nu nw nx aw ny bi"><span id="6fd6" class="mr lv iq nu b gy nz oa l ob oc"><strong class="nu ir">&lt;project root&gt;<br/>   --- server<br/>       --- etc<br/>           --- nginx<br/>           --- conf.d<br/>        --- php<br/>            --- php-fpm.d<br/>   --- src</strong></span></pre></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h2 id="2cb7" class="mr lv iq bd lw ms mt dn ma mu mv dp me la mw mx mg le my mz mi li na nb mk nc bi translated"><strong class="ak">网站内容</strong></h2><p id="2cca" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">让我们先完成简单的部分，我们的网站内容。我们将只创建两个文件一个<code class="fe nr ns nt nu b"><strong class="kt ir">index.php</strong></code>和一个<code class="fe nr ns nt nu b"><strong class="kt ir">404.html</strong></code>来提供一个例子，说明在这个设置中一个<code class="fe nr ns nt nu b"><strong class="kt ir">.php</strong></code>文件和一个静态<code class="fe nr ns nt nu b"><strong class="kt ir">.html</strong></code>文件如何一起播放。同样，在现实环境中，这里会有更多的内容(比如定制<code class="fe nr ns nt nu b"><strong class="kt ir">5xx.html</strong></code>页面)。</p><p id="b4de" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"><em class="nd">index.php</em></strong><br/>这是一个简单的<code class="fe nr ns nt nu b"><strong class="kt ir">phpinfo()</strong></code>调用来显示配置信息。这不是一个很好的索引文件，但是它向我们展示了本文所需要的东西！</p><pre class="kg kh ki kj gt nv nu nw nx aw ny bi"><span id="19fd" class="mr lv iq nu b gy nz oa l ob oc"><strong class="nu ir">&lt;?php phpinfo(); ?&gt;</strong></span></pre><p id="cc63" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"><em class="nd">404.html<br/></em></strong>一个绝对丑陋的404(未找到)页面。它只是展示了一个普通的html文件如何在我们的配置中很好地运行。</p><pre class="kg kh ki kj gt nv nu nw nx aw ny bi"><span id="74f3" class="mr lv iq nu b gy nz oa l ob oc"><strong class="nu ir">&lt;html&gt;<br/>    &lt;head&gt;<br/>        &lt;title&gt;NOT FOUND&lt;/title&gt;<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;h1&gt;404 NOT FOUND!&lt;/h1&gt;<br/>        &lt;h3&gt;Oh noes...&lt;/h3&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</strong></span></pre></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h2 id="8eb5" class="mr lv iq bd lw ms mt dn ma mu mv dp me la mw mx mg le my mz mi li na nb mk nc bi translated">服务器配置</h2><p id="c276" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">为了让nginx和php-fpm在我们的容器中正常运行，我们必须对我们的配置文件进行一些更改。这些都位于创建后容器中的<code class="fe nr ns nt nu b"><strong class="kt ir">/etc</strong></code>目录下，在我们之前在<code class="fe nr ns nt nu b"><strong class="kt ir">server</strong></code>下创建的<code class="fe nr ns nt nu b"><strong class="kt ir">etc</strong></code>的两个目录下，项目根目录下:<code class="fe nr ns nt nu b"><strong class="kt ir">nginx</strong></code>和<code class="fe nr ns nt nu b"><strong class="kt ir">php</strong></code>。</p><blockquote class="nf ng nh"><p id="6b3e" class="kr ks nd kt b ku kv jr kw kx ky ju kz ni lb lc ld nj lf lg lh nk lj lk ll lm ij bi translated"><strong class="kt ir">注意</strong><br/>nginx的配置选项数不胜数，几乎都不在本文讨论范围之内。要开始学习更多关于nginx的配置，请查看<a class="ae ne" href="https://docs.nginx.com/nginx/admin-guide/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">管理指南| NGINX </strong> </a></p></blockquote><p id="171d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"><em class="nd">nginx/nginx . conf</em><br/></strong>这是基本的nginx服务器配置文件。它是由<code class="fe nr ns nt nu b"><strong class="kt ir">conf.d</strong></code><strong class="kt ir"/><strong class="kt ir"/><code class="fe nr ns nt nu b"><strong class="kt ir">nginx</strong></code><strong class="kt ir"/>目录下提供的站点具体配置文件补充的。</p><pre class="kg kh ki kj gt nv nu nw nx aw ny bi"><span id="215b" class="mr lv iq nu b gy nz oa l ob oc"><strong class="nu ir">error_log /var/log/nginx/error.log notice;<br/>events {<br/>    worker_connections 1024;<br/>}<br/>http {<br/>    default_type application/octet-stream;<br/>    gzip on;<br/>    include /etc/nginx/mime.types;<br/>    include /etc/nginx/conf.d/*.conf;<br/>    keepalive_timeout 65;<br/>    log_format main '$remote_addr - $remote_user [$time_local "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"';</strong></span><span id="5e73" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">    access_log /var/log/nginx/access.log  main;<br/>    sendfile on;<br/>}<br/>pid /var/run/nginx.pid;<br/>user nginx;<br/>worker_processes auto;</strong></span></pre><p id="cc31" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"><em class="nd">nginx/conf . d/default . conf</em></strong><br/>您可以在这里定义多个站点配置(如果您在同一台服务器上托管多个站点)。这超出了本文的范围(并且可能与容器化的实例相反)。因此，我们将使用<code class="fe nr ns nt nu b"><strong class="kt ir">default.conf</strong></code>配置一个默认的站点配置。</p><pre class="kg kh ki kj gt nv nu nw nx aw ny bi"><span id="d55f" class="mr lv iq nu b gy nz oa l ob oc"><strong class="nu ir">server {<br/>    index index.php index.html index.htm;<br/>    listen 80;<br/>    listen [::]:80;<br/>    location / {<br/>        try_files $uri $uri/ =404;<br/>    }<br/>    location ~ \.php$ {<br/>        fastcgi_pass unix:/var/run/php/php8-fpm.sock;<br/>        include fastcgi.conf;<br/>    }<br/>    root /usr/share/nginx/html;<br/>    server_name localhost;<br/>}</strong></span></pre><p id="f984" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"><em class="nd">PHP/PHP-fpm . conf</em><br/></strong>正如您可能从名称中得到的一样，这个文件管理php-fpm的配置。不幸的是，除了初始文件中提供的注释之外，没有很多关于这个文件的文档。我们将只验证和/或设置一行代码来处理在哪里可以找到额外的php-fpm配置。我们要寻找的条目通常位于文件<code class="fe nr ns nt nu b"><strong class="kt ir">include=/etc/php8/php-fpm.d/*.conf</strong></code>的底部。请记住，如果您没有将PHP8.x安装到您的容器中，而是使用了一个旧版本的PHP，那么您需要确保路径相应地反映了这一点。整个文件应该如下所示:</p><pre class="kg kh ki kj gt nv nu nw nx aw ny bi"><span id="e87c" class="mr lv iq nu b gy nz oa l ob oc"><strong class="nu ir">;;;;;;;;;;;;;;;;;;;;;<br/>; FPM Configuration ;<br/>;;;;;;;;;;;;;;;;;;;;;</strong></span><span id="e026" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">; All relative paths in this configuration file are relative to PHP's install<br/>; prefix (/usr). This prefix can be dynamically changed by using the<br/>; '-p' argument from the command line.</strong></span><span id="4713" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">;;;;;;;;;;;;;;;;;;<br/>; Global Options ;<br/>;;;;;;;;;;;;;;;;;;</strong></span><span id="e595" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">[global]<br/>; Pid file<br/>; Note: the default prefix is /var<br/>; Default Value: none<br/>;pid = run/php-fpm8.pid</strong></span><span id="c78d" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">; Error log file<br/>; If it's set to "syslog", log is sent to syslogd instead of being written<br/>; into a local file.<br/>; Note: the default prefix is /var<br/>; Default Value: log/php8/error.log<br/>;error_log = log/php8/error.log</strong></span><span id="a40e" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">; syslog_facility is used to specify what type of program is logging the<br/>; message. This lets syslogd specify that messages from different facilities<br/>; will be handled differently.<br/>; See syslog(3) for possible values (ex daemon equiv LOG_DAEMON)<br/>; Default Value: daemon<br/>;syslog.facility = daemon</strong></span><span id="9a65" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">; syslog_ident is prepended to every message. If you have multiple FPM<br/>; instances running on the same server, you can change the default value<br/>; which must suit common needs.<br/>; Default Value: php-fpm8<br/>;syslog.ident = php-fpm8</strong></span><span id="43e6" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">; Log level<br/>; Possible Values: alert, error, warning, notice, debug<br/>; Default Value: notice<br/>;log_level = notice</strong></span><span id="d159" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">; Log limit on number of characters in the single line (log entry). If the<br/>; line is over the limit, it is wrapped on multiple lines. The limit is for<br/>; all logged characters including message prefix and suffix if present. However<br/>; the new line character does not count into it as it is present only when<br/>; logging to a file descriptor. It means the new line character is not present<br/>; when logging to syslog.<br/>; Default Value: 1024<br/>;log_limit = 4096</strong></span><span id="80e8" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">; Log buffering specifies if the log line is buffered which means that the<br/>; line is written in a single write operation. If the value is false, then the<br/>; data is written directly into the file descriptor. It is an experimental<br/>; option that can potentionaly improve logging performance and memory usage<br/>; for some heavy logging scenarios. This option is ignored if logging to syslog<br/>; as it has to be always buffered.<br/>; Default value: yes<br/>;log_buffering = no</strong></span><span id="344e" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">; If this number of child processes exit with SIGSEGV or SIGBUS within the time<br/>; interval set by emergency_restart_interval then FPM will restart. A value<br/>; of '0' means 'Off'.<br/>; Default Value: 0<br/>;emergency_restart_threshold = 0</strong></span><span id="b013" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">; Interval of time used by emergency_restart_interval to determine when<br/>; a graceful restart will be initiated.  This can be useful to work around<br/>; accidental corruptions in an accelerator's shared memory.<br/>; Available Units: s(econds), m(inutes), h(ours), or d(ays)<br/>; Default Unit: seconds<br/>; Default Value: 0<br/>;emergency_restart_interval = 0</strong></span><span id="667b" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">; Time limit for child processes to wait for a reaction on signals from master.<br/>; Available units: s(econds), m(inutes), h(ours), or d(ays)<br/>; Default Unit: seconds<br/>; Default Value: 0<br/>;process_control_timeout = 0</strong></span><span id="d3b1" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">; The maximum number of processes FPM will fork. This has been designed to control<br/>; the global number of processes when using dynamic PM within a lot of pools.<br/>; Use it with caution.<br/>; Note: A value of 0 indicates no limit<br/>; Default Value: 0<br/>; process.max = 128</strong></span><span id="eadb" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">; Specify the nice(2) priority to apply to the master process (only if set)<br/>; The value can vary from -19 (highest priority) to 20 (lowest priority)<br/>; Note: - It will only work if the FPM master process is launched as root<br/>;       - The pool process will inherit the master process priority<br/>;         unless specified otherwise<br/>; Default Value: no set<br/>; process.priority = -19</strong></span><span id="e261" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">; Send FPM to background. Set to 'no' to keep FPM in foreground for debugging.<br/>; Default Value: yes<br/>;daemonize = yes</strong></span><span id="3c96" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">; Set open file descriptor rlimit for the master process.<br/>; Default Value: system defined value<br/>;rlimit_files = 1024</strong></span><span id="f07d" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">; Set max core size rlimit for the master process.<br/>; Possible Values: 'unlimited' or an integer greater or equal to 0<br/>; Default Value: system defined value<br/>;rlimit_core = 0</strong></span><span id="a2c0" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">; Specify the event mechanism FPM will use. The following is available:<br/>; - select     (any POSIX os)<br/>; - poll       (any POSIX os)<br/>; - epoll      (linux &gt;= 2.5.44)<br/>; - kqueue     (FreeBSD &gt;= 4.1, OpenBSD &gt;= 2.9, NetBSD &gt;= 2.0)<br/>; - /dev/poll  (Solaris &gt;= 7)<br/>; - port       (Solaris &gt;= 10)<br/>; Default Value: not set (auto detection)<br/>;events.mechanism = epoll<br/></strong></span><span id="cacb" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">; When FPM is built with systemd integration, specify the interval,<br/>; in seconds, between health report notification to systemd.<br/>; Set to 0 to disable.<br/>; Available Units: s(econds), m(inutes), h(ours)<br/>; Default Unit: seconds<br/>; Default value: 10<br/>;systemd_interval = 10<br/></strong></span><span id="a079" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">;;;;;;;;;;;;;;;;;;;;<br/>; Pool Definitions ;<br/>;;;;;;;;;;;;;;;;;;;;<br/>; Multiple pools of child processes may be started with different listening<br/>; ports and different management options.  The name of the pool will be<br/>; used in logs and stats. There is no limitation on the number of pools which<br/>; FPM can handle. Your system will tell you anyway :)<br/>; Include one or more files. If glob(3) exists, it is used to include a bunch of<br/>; files from a glob(3) pattern. This directive can be used everywhere in the<br/>; file.<br/>; Relative path can also be used. They will be prefixed by:<br/>;  - the global prefix if it's been set (-p argument)<br/>;  - /usr otherwise<br/>include=/etc/php8/php-fpm.d/*.conf</strong></span></pre></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="b295" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="nd"> php/php.info </em> </strong> <br/>核心php配置文件。就本文的目的而言，我们并没有真正接触到这个文件，但是我们知道，如果您不熟悉PHP设置，您可能想看看许多配置选项。你可以在<a class="ae ne" href="https://www.php.net/configuration.file" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="nd">https://www.php.net/configuration.file</em></strong></a>找到全面的文档。</p><p id="0d0c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以在<a class="ae ne" href="https://github.com/johnathanesanders/docker-nginx-fpm" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="nd">https://github.com/johnathanesanders/docker-nginx-fpm</em></strong></a><em class="nd">的回购样本中找到一个起始<code class="fe nr ns nt nu b"><strong class="kt ir">php.info</strong></code>文件。</em></p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="471b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"><em class="nd">PHP/php-fpm . d/www . conf</em></strong><br/>这个文件管理PHP-fpm的行为方式(或错误行为，取决于您的配置)。出于本文的目的，我们只需要修改一个条目，那就是套接字的位置。在第36行附近，您应该会发现一个<code class="fe nr ns nt nu b"><strong class="kt ir">listen=</strong></code>条目，它需要将套接字更新到我们之前使用的条目:</p><p id="05a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nr ns nt nu b"><strong class="kt ir">listen = /var/run/php/php8-fpm.sock</strong></code></p><p id="cd40" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以在<a class="ae ne" href="https://github.com/johnathanesanders/docker-nginx-fpm" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="nd">https://github.com/johnathanesanders/docker-nginx-fpm</em></strong></a><em class="nd">的回购样本中找到该文件的其余部分。</em></p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="c925" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">Dockerfile文件</h1><p id="7d40" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">好了，现在我们已经解决了所有的问题，让我们创建docker配置文件。我们将基于Alpine Linux的一切，因为它是如此的轻量级和令人敬畏。</p><p id="001b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个docker文件中，我们将以一个<code class="fe nr ns nt nu b"><strong class="kt ir">FROM alpine:latest</strong></code>开始，表示最新的Alpine base图像是我们的起点。接下来，我们需要更新APK (Alpine的包管理器)，然后安装bash(告诉过你它是轻量级的！)，nginx，PHP，PHP-FPM，以及它的一些辅助库。</p><p id="2f99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们需要将上面配置的内容从<code class="fe nr ns nt nu b"><strong class="kt ir">server/etc/nginx</strong></code>中<code class="fe nr ns nt nu b"><strong class="kt ir">COPY</strong></code>到容器的<code class="fe nr ns nt nu b"><strong class="kt ir">/etc/nginx</strong></code>目录中。从<code class="fe nr ns nt nu b"><strong class="kt ir">server/etc/php</strong></code>到容器的<code class="fe nr ns nt nu b"><strong class="kt ir">/etc/php8</strong></code>目录的配置。最后，我们站点的内容从<code class="fe nr ns nt nu b"><strong class="kt ir">src</strong></code>到<code class="fe nr ns nt nu b"><strong class="kt ir">/usr/share/nginx/html</strong></code>(在上面的nginx配置中定义了)。</p><p id="bb21" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下一步是创建<code class="fe nr ns nt nu b"><strong class="kt ir">/var/run/php</strong></code>目录，它将保存我们的带有<code class="fe nr ns nt nu b"><strong class="kt ir">mkdir</strong></code>的套接字文件。</p><p id="b5de" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">根据您想要运行nginx的端口，您会想要<code class="fe nr ns nt nu b"><strong class="kt ir">EXPOSE</strong></code>它们。在下面的示例中，我们同时公开了80和443——但是在生产中，公开443 (HTTPS)以外的任何内容会很奇怪。</p><p id="4bd1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将告诉容器在<code class="fe nr ns nt nu b"><strong class="kt ir">SIGTERM</strong></code>停止。</p><p id="4948" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们将在<code class="fe nr ns nt nu b"><strong class="kt ir">CMD</strong></code>条目中运行一系列命令来启动一切。</p><ul class=""><li id="07a3" class="od oe iq kt b ku kv kx ky la of le og li oh lm or oj ok ol bi translated"><code class="fe nr ns nt nu b"><strong class="kt ir">/bin/bash -c</strong></code>简单地告诉这行代码通过bash shell执行，因为bash不是Alpine的原生代码(因此我们必须添加<code class="fe nr ns nt nu b"><strong class="kt ir">RUN apk add bash</strong></code>)。</li><li id="ed40" class="od oe iq kt b ku om kx on la oo le op li oq lm or oj ok ol bi translated"><code class="fe nr ns nt nu b"><strong class="kt ir">php-fpm8</strong></code>启动FPM PHP</li><li id="3e7e" class="od oe iq kt b ku om kx on la oo le op li oq lm or oj ok ol bi translated"><code class="fe nr ns nt nu b"><strong class="kt ir">chmod 777 /var/run/php/php8-fpm.sock</strong></code>使套接字可以被nginx和PHP使用。</li><li id="a2e7" class="od oe iq kt b ku om kx on la oo le op li oq lm or oj ok ol bi translated"><code class="fe nr ns nt nu b"><strong class="kt ir">chmod 755 /usr/share/nginx/html/*</strong></code>确保对我们的公共HTML目录的内容设置了读取和执行权限。</li><li id="73f5" class="od oe iq kt b ku om kx on la oo le op li oq lm or oj ok ol bi translated">最后，<code class="fe nr ns nt nu b"><strong class="kt ir">nginx -g 'daemon off;'</strong></code>指示nginx独立启动(比如没有systemd)。</li></ul><pre class="kg kh ki kj gt nv nu nw nx aw ny bi"><span id="66dc" class="mr lv iq nu b gy nz oa l ob oc"><strong class="nu ir">FROM alpine:latest</strong></span><span id="f556" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">RUN apk update &amp;&amp; apk upgrade<br/>RUN apk add bash<br/>RUN apk add nginx<br/>RUN apk add php8 php8-fpm php8-opcache<br/>RUN apk add php8-gd php8-zlib php8-curl</strong></span><span id="cdd5" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">COPY server/etc/nginx /etc/nginx<br/>COPY server/etc/php /etc/php8<br/>COPY src /usr/share/nginx/html</strong></span><span id="da43" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">RUN mkdir /var/run/php</strong></span><span id="becf" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">EXPOSE 80<br/>EXPOSE 443</strong></span><span id="f722" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">STOPSIGNAL SIGTERM</strong></span><span id="9c11" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">CMD ["/bin/bash", "-c", "php-fpm8 &amp;&amp; chmod 777 /var/run/php/php8-fpm.sock &amp;&amp; chmod 755 /usr/share/nginx/html/* &amp;&amp; nginx -g 'daemon off;'"]</strong></span></pre><h1 id="6606" class="lu lv iq bd lw lx nl lz ma mb nm md me jw nn jx mg jz no ka mi kc np kd mk ml bi translated">可选助手脚本</h1><p id="4532" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">虽然这不是必需的，但我发现有一个脚本可以停止一个正在运行的容器，删除它，然后根据项目的更新重新构建和重启它，这非常有帮助。否则，每当我想测试一个变化时，我就不得不手工运行所有这些。这假设您使用的是bash——但是老实说，什么执行这些行并不重要，因为它只是调用docker来执行它的命令。因此，您可以轻松地创建Powershell (.ps1)脚本、Windows批处理文件(。bat)等。来运行这些命令。</p><p id="6dc8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我使用名称<code class="fe nr ns nt nu b"><strong class="kt ir">php-nginx-run</strong></code>来表示容器，使用名称<code class="fe nr ns nt nu b"><strong class="kt ir">php-nginx</strong></code>来表示图像，但是您可以随意称呼它们！</p><p id="936a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是我的<code class="fe nr ns nt nu b"><strong class="kt ir">build.sh</strong></code>的内容:</p><pre class="kg kh ki kj gt nv nu nw nx aw ny bi"><span id="5096" class="mr lv iq nu b gy nz oa l ob oc"><strong class="nu ir">#!/bin/bash<br/>#"docker container stop php-nginx-run -t 1" only use if we want to wait for it to shutdown using -t as seconds to wait</strong></span><span id="ee74" class="mr lv iq nu b gy os oa l ob oc"><strong class="nu ir">docker container rm -f php-nginx-run<br/>docker build -t php-nginx . --no-cache<br/>docker run --name php-nginx-run -d -p 80:80 -p 443:443 php-nginx</strong></span></pre><blockquote class="nf ng nh"><p id="fecb" class="kr ks nd kt b ku kv jr kw kx ky ju kz ni lb lc ld nj lf lg lh nk lj lk ll lm ij bi translated"><strong class="kt ir">注</strong><br/><code class="fe nr ns nt nu b"><strong class="kt ir">-p 80:80</strong></code>和<code class="fe nr ns nt nu b"><strong class="kt ir">-p 443:443</strong></code>指示docker将这些端口向外界开放。如果您在docker文件中使用不同的端口，请确保在这里相应地指定它们。</p></blockquote><h1 id="c5de" class="lu lv iq bd lw lx nl lz ma mb nm md me jw nn jx mg jz no ka mi kc np kd mk ml bi translated">包扎</h1><p id="39a3" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">就是这样！从这里开始，运行我们刚刚创建的脚本来构建和运行这个新的PHP容器。</p><p id="eb4e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果一切顺利，当您导航到您的本地机器(比如通过本地主机或您的网络IP地址)时，您应该会看到一个与此类似的页面:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/1beb0936d16039ce39bcb976d082b4ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KZAU4H5ZSNVAjGez0BYH5g.png"/></div></div><figcaption class="ou ov gj gh gi ow ox bd b be z dk translated">一个在Nginx和Alpine Docker容器上运行的PHP-FPM！</figcaption></figure><h2 id="8b07" class="mr lv iq bd lw ms mt dn ma mu mv dp me la mw mx mg le my mz mi li na nb mk nc bi translated"><strong class="ak">恭喜你！从这里开始，玩得开心！</strong></h2></div></div>    
</body>
</html>