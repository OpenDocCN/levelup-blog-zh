<html>
<head>
<title>Binary Search Trees: In the Balance?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二分搜索法树:在平衡中？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/binary-search-trees-in-the-balance-40073c9e82c?source=collection_archive---------9-----------------------#2020-02-29">https://levelup.gitconnected.com/binary-search-trees-in-the-balance-40073c9e82c?source=collection_archive---------9-----------------------#2020-02-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="50f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章旨在探究一个平衡的<strong class="js iu"> A </strong>德尔森- <strong class="js iu"> V </strong>埃尔斯基- <strong class="js iu"> L </strong>和(AVL)二叉查找树的好处。在我们开始之前，让我们回顾一下树数据结构的基础。</p><h2 id="36f0" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">树形数据结构</h2><p id="942d" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">在最基本的层面上，树代表了数据的层次结构。一个常见的例子是组织结构图。在组织结构图中，节点中的每个职位可能有也可能没有任何数量的下属。我们将使用这个图表来解释关键树数据结构术语。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/bdb2b1b4ad3e925c852c8b7e7bb8ee3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9dx5PlMj_aSjZq-ySXJRFA.png"/></div></div></figure><h1 id="99b3" class="ly kp it bd kq lz ma mb kt mc md me kw mf mg mh kz mi mj mk lc ml mm mn lf mo bi translated">术语</h1><ul class=""><li id="bb94" class="mp mq it js b jt lh jx li kb mr kf ms kj mt kn mu mv mw mx bi translated"><strong class="js iu">节点:</strong>树内的一个元素。</li><li id="c0e5" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated"><strong class="js iu">根:</strong>最顶层的节点。</li><li id="99e5" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated"><strong class="js iu">边:</strong>两个节点之间的链接。</li><li id="2a0a" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated"><strong class="js iu">子节点:</strong>连接(有边)到“父”节点的节点。除了“根节点”之外的每个节点都是“子节点”。</li><li id="9177" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated"><strong class="js iu">父节点:</strong>连接到子节点的节点。除叶节点之外的每个节点。</li><li id="ca7f" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated"><strong class="js iu">叶:</strong>没有子节点的节点，或底层节点。</li><li id="a5aa" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated"><strong class="js iu">深度:</strong>单个节点到“根”的长度。</li><li id="8c42" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated"><strong class="js iu">高度:</strong>从“叶”到“根”的最长路径的长度</li><li id="69c7" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated"><strong class="js iu">广度:</strong>“叶节点”的数量</li></ul><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nd"><img src="../Images/c4598834089accb253ef40bc2053746f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qnegC2uAd_OqOCUXHGdgGA.png"/></div></div></figure><h1 id="f03d" class="ly kp it bd kq lz ma mb kt mc md me kw mf mg mh kz mi mj mk lc ml mm mn lf mo bi translated">树的类型</h1><h2 id="49f2" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">通用树</h2><p id="3351" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">数据树结构的最基本形式。树上的每个节点都可以有无限数量的子节点。这在我们的组织结构图中有所描述。</p><h2 id="6ef9" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">二叉树</h2><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi ne"><img src="../Images/451dbb9181f85b5dd053927026c46d86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3EisH5vR0BuTrOWhsqMulA.png"/></div></div></figure><p id="000b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">二叉树是一种特定的数据结构，其中每个父节点最多只能有两个子节点，一个左节点和一个右节点。</p><h2 id="eb98" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">二叉查找树</h2><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nf"><img src="../Images/ea75f82ce10b01ab744b05a7226ec450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aKAPeGOaxHTpyXOgPknAFg.png"/></div></div></figure><p id="03dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">二叉查找树或BST是一个二叉树，具有附加的约束，即左边子节点的值小于父节点的值，反之右边子节点的值大于父节点的值。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi ng"><img src="../Images/499377ea37ef4dbac7de7db89d901541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FoP8J63n3HPlQwOCZUEwLA.png"/></div></div></figure><p id="6a9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面例子的子树中，我们可以看到父母的值是15，左边孩子的值是12 ( &lt; 15 ) and the right child’s value is 20 ( &gt; 15)。</p><p id="b864" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">顾名思义，二叉查找树适合于搜索。假设我们想知道值9是否存在于BST中。</p><p id="f3be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们从根节点开始搜索。</p><ol class=""><li id="509b" class="mp mq it js b jt ju jx jy kb nh kf ni kj nj kn nk mv mw mx bi translated">当<strong class="js iu"> 9 &lt; 10 </strong>时，我们遍历<strong class="js iu">左</strong>并检查左子。</li><li id="18b0" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn nk mv mw mx bi translated">随着<strong class="js iu"> 9 &gt; 3 </strong>，我们遍历到<strong class="js iu">右侧</strong>并检查右侧节点。</li><li id="1d7f" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn nk mv mw mx bi translated">随着<strong class="js iu"> 9 &gt; 8 </strong>，我们遍历到<strong class="js iu">右侧</strong>并检查右侧节点。</li><li id="b868" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn nk mv mw mx bi translated">找到了！！！</li></ol><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nl"><img src="../Images/9781c3b8f0be72bc32a187c7317f2256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oy1Yv8UHKx2zQbq1Am1ktg.png"/></div></div></figure><p id="38a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在没有二叉查找树的情况下，必须检查每个节点的值，直到找到目标(9)，但是如上所述，只检查了黑色节点的值。这将时间复杂度从O(n)降低到O(Logn)。听起来很棒，对吧？</p><p id="2357" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，在最坏的情况下，这是不正确的。如果我们添加的节点的值已经排序到我们的树中，例如，[23，25，30，50，80，100]，会发生什么？</p><p id="1ffb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这些插入之后，我们想要检查值100是否存在于我们的树中。</p><p id="4423" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">和以前一样，使用二分搜索法，我们从根节点开始搜索。</p><ol class=""><li id="6741" class="mp mq it js b jt ju jx jy kb nh kf ni kj nj kn nk mv mw mx bi translated">100 &gt; 10 ，我们遍历<strong class="js iu">右边</strong>检查左边的孩子。</li><li id="b893" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn nk mv mw mx bi translated"><strong class="js iu"> 100 &gt; 15 </strong>，我们遍历到<strong class="js iu">右侧</strong>检查右侧节点。</li><li id="cd3d" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn nk mv mw mx bi translated">1 <strong class="js iu"> 00 &gt; 23 </strong>，我们遍历到<strong class="js iu">右侧</strong>检查右侧节点。</li><li id="bed8" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn nk mv mw mx bi translated"><strong class="js iu"> 100 &gt; 25 </strong>，我们遍历到<strong class="js iu">右侧</strong>检查右侧节点。</li><li id="17e5" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn nk mv mw mx bi translated"><strong class="js iu"> 100 &gt; 30 </strong>，我们遍历到<strong class="js iu">右侧</strong>检查右侧节点。</li><li id="a4a9" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn nk mv mw mx bi translated"><strong class="js iu"> 100 &gt; 80 </strong>，我们遍历到<strong class="js iu">右</strong>检查右节点。</li><li id="d37d" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn nk mv mw mx bi translated">找到了…但那需要一段时间，不是吗？</li></ol><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nm"><img src="../Images/3849c4eb5de46b361a6dcaff69963beb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YridRcO_6k5s4y8N1xYrdg.png"/></div></div></figure><p id="2c5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在最坏的情况下，排序的值(升序或降序)被插入到我们的树中，我们的搜索将开始变成线性的，时间复杂度将变成O(n)，否定了我们的二叉查找树的最初好处。这是因为我们的二叉查找树不平衡。</p><h2 id="3850" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">平衡AVL树</h2><p id="bb0f" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">AVL树等同于常规的二叉查找树，只是多了一个约束。</p><ul class=""><li id="4c76" class="mp mq it js b jt ju jx jy kb nh kf ni kj nj kn mu mv mw mx bi translated">左右之差必须始终≤ 1。</li></ul><p id="9d8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们上面的“最坏情况”例子中，左边的高度是2，而右边的高度是6。由于这种高度上的差异，搜索时间复杂度现在大于O(logn)并向O(n)移动。在平衡二叉查找树中，搜索节点的时间复杂度将总是为O(logn)。如果上面的树被重构为AVL树，它看起来会像这样:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nn"><img src="../Images/2fcacdea705187f19ffbde80ec7089f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PLo9f4pCAE_VZ1UfwW8bDQ.png"/></div></div></figure><p id="eb45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与非平衡BST相反，在AVL树中，左子树(3)和右子树(4)的深度之差≤ 1。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi no"><img src="../Images/2840f192456937fc39e03eca87272e37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_4XE4XPkPpP2hedkcoeJWg.png"/></div></div></figure><p id="7fd0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们再次搜索树中是否存在值100。我们继续遍历到正确的孩子，直到我们达到我们的目标，100。这在AVL树中只需要4个步骤，而在非平衡BST中需要7个步骤。</p><p id="72bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为AVL树是<strong class="js iu">自平衡的，</strong>所以为了找到一个值而遍历的层级数永远不会长于任何叶节点的最短深度+ 1。</p><p id="ca66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们已经展示了AVL树的好处，问题是如何通过自平衡以保持主约束(左子树高度=右子树高度+- 1)的方式插入新节点。</p><p id="f9ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在排序插入之前，我们将从AVL树开始:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi np"><img src="../Images/a548469c157a1d16397a830660fe7288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xPL-t5spInCuyBlZRhdxww.png"/></div></div></figure><p id="b1a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到左边的子树高度是3，右边的子树长度是2。我们的约束满足了。</p><p id="9221" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们将使用值23和25进行前两次插入。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nq"><img src="../Images/2b23bdaed3c878c9943e19a84b079531.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vqPFWgYpD0dhXRRps8vlxQ.png"/></div></div></figure><p id="0ee5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们每棵树的高度仍然满足我们的约束，因为左边是3，右边是4，但是下一次插入30会发生什么呢？</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nr"><img src="../Images/4bfc124eb83e37c2c488e63838e4decb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*boBMM6aDaMTBPpt_Ug3qcw.png"/></div></div></figure><p id="928e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在打破了约束，左边和右边的高度差现在是2。为了保持平衡，我们必须进行第一次旋转。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/343a6f9d9a5d6e8e88f8bb5ed7647b2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*u7B4Lrbc1NDOxqEPwj410Q.png"/></div></figure><p id="99a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">向左旋转将23节点移动到25节点的左侧子节点。将右子树深度的高度减少到4，并重新设置我们的约束。</p><p id="925e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着我们下一次插入50，将发生另一个旋转。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nt"><img src="../Images/ef90cc752c058e72f00899698a1c6c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zhRnLg8puMZhEL6RKrBXjA.png"/></div></div></figure><p id="4ba6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一次，旋转发生在我们树的更高处，15节点移动到25节点的左侧子节点，因此我们保持了我们的约束。</p><p id="7c04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每当新插入打破高度差约束时，该过程将重复，结果，AVL树将总是保持平衡，并且搜索时间复杂度将总是为O(logn)。通过这些旋转，AVL树自平衡到用于搜索的最佳结构。</p><p id="4da9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是AVL树的主要优点，然而，应该注意的是，节点的插入和移除(包括旋转)所增加的复杂性在某些情况下可能使得AVL不是最佳的。</p><h2 id="8de1" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">TLDR</h2><p id="8cbb" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">二分搜索法树(BST)是具有以下约束的分层数据结构:</p><ol class=""><li id="68f5" class="mp mq it js b jt ju jx jy kb nh kf ni kj nj kn nk mv mw mx bi translated">一个父节点最多可以有两个子节点。</li><li id="689d" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn nk mv mw mx bi translated">左边的子节点总是小于父节点，右边的子节点总是大于父节点。</li></ol><ul class=""><li id="685b" class="mp mq it js b jt ju jx jy kb nh kf ni kj nj kn mu mv mw mx bi translated">理想情况下，搜索时间复杂度为O(logn)。</li><li id="b22a" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">在最坏的情况下(插入排序数据)，BST的搜索时间复杂度是线性的，O(n)。</li></ul><p id="f3fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">AVL树是BST的平衡子集，增加了一个约束条件:</p><ol class=""><li id="8bdb" class="mp mq it js b jt ju jx jy kb nh kf ni kj nj kn nk mv mw mx bi translated">树的左侧和右侧之间的高度差必须始终≤ 1。</li></ol><ul class=""><li id="163e" class="mp mq it js b jt ju jx jy kb nh kf ni kj nj kn mu mv mw mx bi translated">该约束确保AVL树的搜索时间复杂度永远不会大于O(logn)。</li></ul><p id="a8c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">参考资料:</p><ul class=""><li id="6a6f" class="mp mq it js b jt ju jx jy kb nh kf ni kj nj kn mu mv mw mx bi translated"><a class="ae nu" href="https://www.youtube.com/channel/UC6Aa5t0vHN8uj_BCbgrRZcQ" rel="noopener ugc nofollow" target="_blank"> RobEdwardsSDS </a> U — AVL 1号简介</li><li id="458e" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated"><a class="ae nu" href="https://www.geeksforgeeks.org/applications-of-tree-data-structure/" rel="noopener ugc nofollow" target="_blank"> GeeksForGeeks </a> —树形数据结构的应用</li><li id="983b" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated"><a class="ae nu" href="https://www.geeksforgeeks.org/applications-of-bst/" rel="noopener ugc nofollow" target="_blank">geeks forgeeks</a>—BST的应用</li><li id="6338" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated"><a class="ae nu" href="https://www.freecodecamp.org/news/all-you-need-to-know-about-tree-data-structures-bceacb85490c/" rel="noopener ugc nofollow" target="_blank">FreeCodeCamp</a>——关于树形数据结构你需要知道的一切</li></ul></div></div>    
</body>
</html>