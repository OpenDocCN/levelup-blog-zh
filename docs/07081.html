<html>
<head>
<title>Improving Django Queries Using Django Query Profiler</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Django查询分析器改进Django查询</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/improving-django-queries-using-django-query-profiler-41cdedc97da9?source=collection_archive---------3-----------------------#2021-01-23">https://levelup.gitconnected.com/improving-django-queries-using-django-query-profiler-41cdedc97da9?source=collection_archive---------3-----------------------#2021-01-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/86a021d698ed9a087e30933886a2a4f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ClykD2USffgvtzMn"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kf" href="https://unsplash.com/@fabrizioverrecchia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fabrizio Verrecchia </a>拍摄的照片</figcaption></figure><p id="72ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你不知道<em class="le">哪个</em>查询慢，以及<em class="le">为什么</em>慢时，盲目地尝试优化查询是一种挫折。有一个非常流行的工具<a class="ae kf" href="https://django-debug-toolbar.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Django调试工具栏</a>，但是这篇文章是关于一个更简单、更集中的工具，叫做<a class="ae kf" href="https://django-query-profiler.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> Django查询分析器</a>。Django Query Profiler是一个较新的工具，但它是一个很好的轻量级工具，可以深入查询，提供计时信息，突出潜在的N+1问题，查找重复的SQL查询，并提出修复建议。作为Django查询分析器项目的一名贡献者，我可以证明它的设置和实用性。</p><h1 id="ff0c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">什么是Django查询分析器</h1><p id="7ab9" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">Django查询分析器的文档简介<a class="ae kf" href="https://django-query-profiler.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"/>:</p><blockquote class="mi mj mk"><p id="bba4" class="kg kh le ki b kj kk kl km kn ko kp kq ml ks kt ku mm kw kx ky mn la lb lc ld im bi translated">Django查询分析器是Django应用程序的分析器，用于帮助开发人员回答问题“我的Django代码或页面或API很慢，我如何找出原因？”</p><p id="7030" class="kg kh le ki b kj kk kl km kn ko kp kq ml ks kt ku mm kw kx ky mn la lb lc ld im bi translated">以下是探查器的一些功能:</p><p id="1526" class="kg kh le ki b kj kk kl km kn ko kp kq ml ks kt ku mm kw kx ky mn la lb lc ld im bi translated">显示进行N+1次sql调用的代码路径:显示进行N+1次调用的带有stack_trace的sql，以及sql计数</p><p id="0209" class="kg kh le ki b kj kk kl km kn ko kp kq ml ks kt ku mm kw kx ky mn la lb lc ld im bi translated">显示了建议的解决方案:如果减少sql的解决方案是简单地应用select_related或prefetch_related，这将作为建议突出显示</p><p id="7f08" class="kg kh le ki b kj kk kl km kn ko kp kq ml ks kt ku mm kw kx ky mn la lb lc ld im bi translated">显示完全相同的sql重复项:其中(sql，parameters)完全相同的查询数。这是一种实现查询缓存会有所帮助的sql</p><p id="8409" class="kg kh le ki b kj kk kl km kn ko kp kq ml ks kt ku mm kw kx ky mn la lb lc ld im bi translated">火焰图可视化:将所有堆栈跟踪收集在一起，以便快速识别哪个(些)代码区域产生了负载</p></blockquote><h1 id="fe16" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">N+1问题</h1><p id="557e" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated"><em class="le">如果您已经熟悉了N+1问题，可以跳到下一节来安装和配置Django Query Profiler。</em></p><h2 id="18da" class="mo lg it bd lh mp mq dn ll mr ms dp lp kr mt mu lt kv mv mw lx kz mx my mb mz bi translated">背景</h2><p id="c78d" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">Django查询分析器的一个关键特性是它能够识别遭受可怕的N+1问题的查询。对于外行来说，N+1问题是低效查询的最常见来源之一— <em class="le">它是查询设计的反模式</em>。它出现在一对多查询中，您首先需要发出一个初始请求(这是“1”部分)，然后根据初始请求的结果进行迭代以获得所需的底层数据(这是“N”部分)。更恰当的名称应该是“1+N ”,这样查询的顺序才是正确的。换句话说，当前一个查询中的每个结果导致第二个查询执行任意次时，就会出现N+1问题。</p><h2 id="60cc" class="mo lg it bd lh mp mq dn ll mr ms dp lp kr mt mu lt kv mv mw lx kz mx my mb mz bi translated">例子</h2><p id="153d" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">这个例子是人为的，但是它仍然演示了问题，如何识别它，以及如何补救它。</p><p id="3504" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了跟进这个例子，<a class="ae kf" href="https://github.com/dbudwin/MediumBlogExamples/tree/master/DjangoQueryProfilerExample" rel="noopener ugc nofollow" target="_blank">从我的回购协议中访问我的所有中型博客例子的完整代码</a>。</p><p id="774f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们有一个数据库，用博文和对博文的评论来模拟一个普通的博客。假设我们有一个评论，我们想打印数据库中所有评论的博客文章的标题。第N+1种方法是首先获取所有评论，然后获取所有博客文章标题<em class="le">到</em>评论的<code class="fe na nb nc nd b">post</code> <code class="fe na nb nc nd b">QuerySet</code>对象。</p><pre class="ne nf ng nh gt ni nd nj nk aw nl bi"><span id="63e2" class="mo lg it nd b gy nm nn l no np">comments = Comment.objects.all()<br/><br/>for comment in comments:<br/>    print(comment.post.title)</span></pre><p id="5594" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述姜戈<code class="fe na nb nc nd b">QuerySet</code>本质上可以归结为:</p><pre class="ne nf ng nh gt ni nd nj nk aw nl bi"><span id="0b52" class="mo lg it nd b gy nm nn l no np">SELECT * FROM comments</span><span id="a465" class="mo lg it nd b gy nq nn l no np">SELECT * FROM posts WHERE post_id=&lt;post ID&gt;</span></pre><p id="7575" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的查询中，我们首先得到所有的评论(这是“1”)。在第二个查询中，我们现在得到了每个评论所属的所有相应的帖子(这是“N”)。因为Django的<code class="fe na nb nc nd b">QuerySet</code>对象是延迟评估的，所以很容易用原始SQL创建<code class="fe na nb nc nd b">QuerySet</code>对象，如上例所示。幸运的是，这个例子中的修复很容易，只需修改上面的<code class="fe na nb nc nd b">QuerySet</code>以包含<code class="fe na nb nc nd b">select_related</code>:</p><pre class="ne nf ng nh gt ni nd nj nk aw nl bi"><span id="8441" class="mo lg it nd b gy nm nn l no np">comments = Comment.objects.all().select_related("post")<br/><br/>for comment in comments:<br/>    print(comment.post.title)</span></pre><p id="c095" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重构上面的查询通过添加一个<code class="fe na nb nc nd b">INNER JOIN</code>来修改原始SQL，与下面的查询没有太大的不同:</p><pre class="ne nf ng nh gt ni nd nj nk aw nl bi"><span id="0200" class="mo lg it nd b gy nm nn l no np">SELECT * FROM comments INNER JOIN posts ON comments.post_id = post.id</span></pre><p id="3882" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们不是进行N+1次查询，而是进行1次“更大”的查询。在许多情况下，这是期望的、更有效的行为。涵盖N+1问题的文献并不缺乏，所以我不想在这里深入探讨，我只想强调一个常见的场景，并在Django的上下文中演示其修复方法。</p><h2 id="6d0d" class="mo lg it bd lh mp mq dn ll mr ms dp lp kr mt mu lt kv mv mw lx kz mx my mb mz bi translated">这在Django查询分析器中是什么样子</h2><p id="8076" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">使用Django Query Profiler并在增强前后检查这些查询，将会在Django Query Profiler的Chrome扩展中呈现如下结果。</p><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/f0f808e74da07bcef417d3dce4b8d675.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mer--_WwrG0R6j7PlDDaWg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Django查询分析器Chrome扩展的结果</figcaption></figure><p id="8c56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到有两个请求。第一个是N+1版本，第二个是优化版本。“总请求时间”列从44毫秒提高到19毫秒。在更大更复杂的数据集中，我看到这从一分钟提高到不到一秒钟！我还仔细查看了右边的一列“潜在的N+1”，在第一个请求中我们可以看到有12个(每个评论一个)，而在第二个请求中有0个！理想情况下，目标应该始终是该列中的值为0。同样值得注意的是“选择”列。我们前面提到的例子只是从数据库中提取数据。在我们查询的N+1版本中，我们进行了13次<code class="fe na nb nc nd b">SELECT</code>调用，1次获取所有评论，然后再进行12次获取每篇文章的全部或标题，总共13次<code class="fe na nb nc nd b">SELECT</code>调用，哎呀！同样，在我们的优化版本中——通过<code class="fe na nb nc nd b">INNER JOIN</code>的力量——我们只有1个<code class="fe na nb nc nd b">SELECT</code>调用来收集我们在单个查询中需要的所有相关数据。这就是我们在使用Django Query Profiler识别和优化低效查询时所寻找的结果。</p><h1 id="1a5b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">安装和配置</h1><p id="54a7" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">这些安装说明将假设使用相应的Chrome扩展，而不是支持的命令行用法。</p><h2 id="6274" class="mo lg it bd lh mp mq dn ll mr ms dp lp kr mt mu lt kv mv mw lx kz mx my mb mz bi translated">安装</h2><p id="d770" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">使用您选择的Python包管理器，安装<code class="fe na nb nc nd b">django-query-profiler</code>。举几个例子:</p><h2 id="c68c" class="mo lg it bd lh mp mq dn ll mr ms dp lp kr mt mu lt kv mv mw lx kz mx my mb mz bi translated">使用画中画</h2><pre class="ne nf ng nh gt ni nd nj nk aw nl bi"><span id="d4b3" class="mo lg it nd b gy nm nn l no np">pip install django-query-profiler</span></pre><h2 id="ea97" class="mo lg it bd lh mp mq dn ll mr ms dp lp kr mt mu lt kv mv mw lx kz mx my mb mz bi translated">使用诗歌</h2><pre class="ne nf ng nh gt ni nd nj nk aw nl bi"><span id="5954" class="mo lg it nd b gy nm nn l no np">poetry add django-query-profiler</span></pre><h2 id="b895" class="mo lg it bd lh mp mq dn ll mr ms dp lp kr mt mu lt kv mv mw lx kz mx my mb mz bi translated">配置<code class="fe na nb nc nd b">INSTALLED_APPS</code></h2><p id="72bd" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">首先，在将<code class="fe na nb nc nd b">django_query_profiler</code>添加到<code class="fe na nb nc nd b">INSTALLED_APPS</code>的元组之前，一定要将<code class="fe na nb nc nd b">from django_query_profiler.settings import *</code>导入添加到<code class="fe na nb nc nd b">settings.py</code>。</p><pre class="ne nf ng nh gt ni nd nj nk aw nl bi"><span id="0a40" class="mo lg it nd b gy nm nn l no np">INSTALLED_APPS = (<br/>    ...<br/>    "django_query_profiler",<br/>    ...<br/>)</span></pre><h2 id="62a7" class="mo lg it bd lh mp mq dn ll mr ms dp lp kr mt mu lt kv mv mw lx kz mx my mb mz bi translated">配置中间件</h2><p id="da80" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">在元组中尽可能高的位置添加中间件。文档声明所有的请求和中间件都会被分析。Django应用程序中middleare的顺序很重要，所以如果有什么地方不正常，可能有必要调整顺序。</p><pre class="ne nf ng nh gt ni nd nj nk aw nl bi"><span id="3c9d" class="mo lg it nd b gy nm nn l no np">MIDDLEWARE = (<br/>    ...<br/>    "django_query_profiler.client.middleware.QueryProfilerMiddleware",<br/>    ...<br/>)</span></pre><h2 id="c83b" class="mo lg it bd lh mp mq dn ll mr ms dp lp kr mt mu lt kv mv mw lx kz mx my mb mz bi translated">配置数据库</h2><p id="9613" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">根据您的应用程序正在使用的数据库类型，修改数据库<code class="fe na nb nc nd b">ENGINE</code>设置以使用以下之一。Django Query Profiler支持SQLite3、MySQL/MariaDB、Postgres和Oracle。</p><p id="1532" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">对于SQLite3 </strong></p><p id="80bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，由于SQLite3的工作方式，它不提供作为<code class="fe na nb nc nd b">SELECT</code>查询的一部分返回的行数，所以当在Chrome中查看结果时，它将只显示一个破折号。</p><pre class="ne nf ng nh gt ni nd nj nk aw nl bi"><span id="e0d6" class="mo lg it nd b gy nm nn l no np">DATABASES = (<br/>    ...<br/>    "ENGINE": "django_query_profiler.django.db.backends.sqlite3",<br/>)</span></pre><p id="d22e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">对于MySQL/MariaDB </strong></p><pre class="ne nf ng nh gt ni nd nj nk aw nl bi"><span id="9923" class="mo lg it nd b gy nm nn l no np">DATABASES = (<br/>    ...<br/>    "ENGINE": "django_query_profiler.django.db.backends.mysql",<br/>)</span></pre><p id="110b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">对于Postgres </strong></p><pre class="ne nf ng nh gt ni nd nj nk aw nl bi"><span id="70ca" class="mo lg it nd b gy nm nn l no np">DATABASES = (<br/>    ...<br/>    "ENGINE": "django_query_profiler.django.db.backends.postgresql_psycopg2",<br/>)</span></pre><p id="1549" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">对于甲骨文</strong></p><pre class="ne nf ng nh gt ni nd nj nk aw nl bi"><span id="406f" class="mo lg it nd b gy nm nn l no np">DATABASES = (<br/>    ...<br/>    "ENGINE": "django_query_profiler.django.db.backends.oracle",<br/>)</span></pre><h2 id="7755" class="mo lg it bd lh mp mq dn ll mr ms dp lp kr mt mu lt kv mv mw lx kz mx my mb mz bi translated">配置URL</h2><p id="fbde" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">配置根<code class="fe na nb nc nd b">urls.py</code>文件。</p><pre class="ne nf ng nh gt ni nd nj nk aw nl bi"><span id="c3ed" class="mo lg it nd b gy nm nn l no np">from django.urls import include, path</span><span id="d276" class="mo lg it nd b gy nq nn l no np">urlpatterns = [<br/>    ...<br/>    path("django_query_profiler/", include("django_query_profiler.client.urls"))<br/>    ...<br/>]</span></pre><h2 id="6b19" class="mo lg it bd lh mp mq dn ll mr ms dp lp kr mt mu lt kv mv mw lx kz mx my mb mz bi translated">安装镀铬延伸件</h2><p id="6d40" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">此时只有Chrome扩展。从Chrome网上商店安装<a class="ae kf" href="https://chrome.google.com/webstore/detail/django-query-profiler/ejdgfhecpkhdnpdmdheacfmknaegicff" rel="noopener ugc nofollow" target="_blank">Chrome扩展</a>。打开开发者工具，应该会有一个Django查询分析器的新标签。</p><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/6a4815c86f945f89093dcd5596f93820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*utFIejWjF9It39bQgEcXQA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在Chrome的开发者工具窗格中哪里可以找到Django Query Profiler标签</figcaption></figure><h2 id="ff20" class="mo lg it bd lh mp mq dn ll mr ms dp lp kr mt mu lt kv mv mw lx kz mx my mb mz bi translated">启动Redis</h2><p id="f030" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">这一步是可选的，在当前文档或其他在线资源中没有提到。如果您想要访问细节并释放Django查询分析器(<strong class="ki iu">强烈推荐</strong>)的全部能力，您需要运行<a class="ae kf" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>。使用<a class="ae kf" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>，这是一个单行命令，无需进一步配置。</p><pre class="ne nf ng nh gt ni nd nj nk aw nl bi"><span id="68e9" class="mo lg it nd b gy nm nn l no np">docker run -p 6379:6379 -d redis</span></pre><h2 id="8bb0" class="mo lg it bd lh mp mq dn ll mr ms dp lp kr mt mu lt kv mv mw lx kz mx my mb mz bi translated">奔跑</h2><p id="add2" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">现在——在Chrome中——启动你的Django应用并浏览网站。在开发人员工具窗格中查看Django Query Profiler选项卡应该会随着查询的发生而开始填充。如果您运行Redis，请单击右侧的“query_signature”链接，深入了解您的查询的性能。如果Redis没有运行，此链接将不可用，它将改为显示“redis_or_urls.py_not_setup”。</p><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/0f09cfa797799c7f056d5fa3f563836a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mHZx9jXs9rG2wxOTF17Oug.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">使用前面提到的N+1示例运行Redis时，查询的细节是什么样的</figcaption></figure><p id="5ab9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，我们获得了关于查询的更多细节。我们可以看到被执行的原始查询，我们可以看到它被标记为“N+1”，我们可以看到建议的修复方法是添加一个对我们的<code class="fe na nb nc nd b">QuerySet</code>的<code class="fe na nb nc nd b">.select_related()</code>调用，正如上面通过一个例子演示的那样。</p><p id="e3fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您在一个查询中看到<code class="fe na nb nc nd b">%s</code>，您可以确定它是N+1查询的一部分。</p><h1 id="2ef8" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结束语</h1><p id="4d50" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">我希望这篇文章对你有用。你学到新东西了吗？我忘记了什么重要的事情吗？我很想听听使用Django Query Profiler如何帮助解决一个性能很差的查询。请在评论中告诉我。</p><p id="c17b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编码快乐！🧑🏻‍💻</p><p id="bcbd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://bit.ly/dbudwin-github" rel="noopener ugc nofollow" target="_blank">GitHub</a>|<a class="ae kf" href="https://bit.ly/dbudwin-linkedin" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae kf" href="https://bit.ly/dbudwin-medium" rel="noopener ugc nofollow" target="_blank">Medium</a>|<a class="ae kf" href="https://bit.ly/budw_dot_in" rel="noopener ugc nofollow" target="_blank">budw . in</a></p></div></div>    
</body>
</html>