<html>
<head>
<title>Complete Guide to Create Docker Container for Your Golang Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为您的Golang应用程序创建Docker容器的完整指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/complete-guide-to-create-docker-container-for-your-golang-application-80f3fb59a15e?source=collection_archive---------0-----------------------#2020-01-10">https://levelup.gitconnected.com/complete-guide-to-create-docker-container-for-your-golang-application-80f3fb59a15e?source=collection_archive---------0-----------------------#2020-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ca3aaa1ff787d774dd460df62e6fdb74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SstfI6yiEWj1mrnFrLTUdA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来源于<a class="ae kc" href="https://cdn.pixabay.com/photo/2018/12/06/12/02/container-3859710_1280.jpg" rel="noopener ugc nofollow" target="_blank">https://cdn . pix abay . com/photo/2018/12/06/12/02/container-3859710 _ 1280 . jpg</a></figcaption></figure><p id="c8af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在当今的软件工程界，Golang和Docker是我们经常听说的两个东西，因为它们很受欢迎。Golang之所以流行，是因为它内置了对简单并发、良好文档等的支持。此外，还有大量使用Go创建的很酷的开源项目。另一方面，Docker彻底改变了我们发布软件的方式。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h2 id="85a6" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated"><strong class="ak">为什么是docker？</strong></h2><blockquote class="mb"><p id="d988" class="mc md iq bd me mf mg mh mi mj mk la dk translated">使用docker的主要目的是容器化。那就是为您的应用程序提供一个一致的环境，并且不依赖于运行它的主机。</p></blockquote><p id="f674" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">想象一下这个场景，你在本地开发你的应用，然后它的一个功能依赖于一个操作系统包，而这个操作系统包又依赖于其他的包。开发过程完成后，您希望将应用程序部署到web服务器。此时，您必须再次确保所有的依赖项在完全相同的版本下正常运行，否则您的应用程序将会崩溃，永远无法运行。如果你想转移到另一个网络服务器，你不得不再次重复这个过程。这就是集装箱的用武之地。</p><p id="9367" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论是笔记本电脑还是web服务器，主机唯一需要的就是运行一个容器平台——这次是docker。从此你不用担心你用的是MacOS，Ubuntu，Arch，还是其他。您只需定义一次应用程序，就可以随时随地运行它。</p><p id="e0c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用容器技术还有许多其他优点。这篇文章不会涵盖所有这些，但是我鼓励你做你的研究，如果你仍然不确定的话。</p><p id="1ff8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同时使用这两种技术需要多种技术的组合，可以实现这些技术以确保最佳实践并获得最佳结果。</p><p id="c595" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我将创建一个用Golang编写的Docker容器web服务器。</p><p id="c74a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:我不会详细解释Go代码，因为这不是这篇文章的重点。</p><p id="7b79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们走吧！</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="5a46" class="mq lj iq bd lk mr ms mt ln mu mv mw lq mx my mz lt na nb nc lw nd ne nf lz ng bi translated">1.编写代码</h1><p id="18cb" class="pw-post-body-paragraph kd ke iq kf b kg nh ki kj kk ni km kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">我将使用<a class="ae kc" href="https://github.com/gin-gonic/gin" rel="noopener ugc nofollow" target="_blank"> gin </a>框架创建一个go web服务器。</p><p id="070c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们创建一个main.go并添加以下代码。</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d800" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码将通过端口3000和唯一一个到<code class="fe ns nt nu nv b">/ping</code>的路径服务于http web服务器，并返回一个JSON响应。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="ec9d" class="mq lj iq bd lk mr ms mt ln mu mv mw lq mx my mz lt na nb nc lw nd ne nf lz ng bi translated">2.创建docker图像</h1><p id="7867" class="pw-post-body-paragraph kd ke iq kf b kg nh ki kj kk ni km kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">来自Docker文档:</p><blockquote class="nw nx ny"><p id="d862" class="kd ke nz kf b kg kh ki kj kk kl km kn oa kp kq kr ob kt ku kv oc kx ky kz la ij bi translated">映像包括运行应用程序所需的一切——代码或二进制文件、运行时、依赖项以及所需的任何其他文件系统对象。</p></blockquote><p id="463d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者简单地说，映像就是你如何定义你的应用程序和它运行所需的一切。</p><p id="9401" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要创建Docker映像，必须在配置文件中指定步骤。默认且方便的文件名是<code class="fe ns nt nu nv b">Dockerfile</code> <strong class="kf ir"> </strong>，但您可以随意命名。然而，遵循标准总是一个好主意。所以创建一个名为<code class="fe ns nt nu nv b">Dockerfile</code>的文件，用下面的内容填充它。</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="329b" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated"><strong class="ak">解释</strong></h2><p id="c79d" class="pw-post-body-paragraph kd ke iq kf b kg nh ki kj kk ni km kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated"><code class="fe ns nt nu nv b"><strong class="kf ir">FROM</strong></code></p><p id="24db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们正在使用基础图像<code class="fe ns nt nu nv b">golang:alpine</code>创建我们的图像。这基本上是一个图像，就像我们想要创建的一样，可以在Docker存储库中找到。这个映像运行alpine Linux发行版，它很小，并且已经安装了Golang，非常适合我们的用例。有大量公开的码头工人图片，看看<a class="ae kc" href="https://hub.docker.com/_/golang" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/_/golang</a></p><p id="b4c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ns nt nu nv b"><strong class="kf ir">ENV</strong></code></p><p id="44ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还设置了环境变量<code class="fe ns nt nu nv b">GO111MODULE</code>，但是这到底意味着什么呢？如果您对此不熟悉，这是一个用于Go如何导入包的变量。如果你想了解更多，可以搜索一下。还可以设置其他环境变量来定义您希望go如何工作。</p><p id="a6d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ns nt nu nv b"><strong class="kf ir">WORKDIR</strong></code> <strong class="kf ir">，</strong> <code class="fe ns nt nu nv b"><strong class="kf ir">COPY</strong></code>，<strong class="kf ir">，</strong> <code class="fe ns nt nu nv b"><strong class="kf ir">RUN</strong></code></p><p id="4312" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们在目录之间移动并安装依赖项。提供的评论已经不言自明了。</p><p id="d561" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ns nt nu nv b"><strong class="kf ir">EXPORT</strong></code> <strong class="kf ir">，</strong> <code class="fe ns nt nu nv b"><strong class="kf ir">CMD</strong></code></p><p id="07da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们将端口3000从容器内部导出到外部，因为应用程序将监听这个端口来工作。我们定义了一个默认命令，在运行我们的映像时执行这个命令<code class="fe ns nt nu nv b">CMD [“/dist/main”]</code>。</p><p id="218d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要构建映像，请运行以下命令:</p><pre class="nm nn no np gt od nv oe of aw og bi"><span id="2cf3" class="li lj iq nv b gy oh oi l oj ok">docker build . -t go-dock</span></pre><p id="1eb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们构建了我们的图像，并用名称<code class="fe ns nt nu nv b">go-dock</code>标记它。现在我们已经准备好了我们的图像，但是它现在什么也做不了。接下来，我们需要运行我们的映像，以便它能够处理我们的请求。运行的图像称为容器。</p><p id="383c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要运行映像，请键入以下内容:</p><pre class="nm nn no np gt od nv oe of aw og bi"><span id="26e4" class="li lj iq nv b gy oh oi l oj ok">docker run -p 3000:3000 go-dock</span></pre><p id="10ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">标志<code class="fe ns nt nu nv b">-p</code>用于定义端口绑定。由于容器中的应用程序运行在端口3000上，因此我们将其绑定到主机端口，这次也是3000。如果您想绑定到另一个端口，那么您可以使用<code class="fe ns nt nu nv b">-p $HOST_PORT:3000</code>来运行它。比如说<code class="fe ns nt nu nv b">-p 5000:3000</code>。</p><p id="948f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们指定想要运行哪个映像，这次是<code class="fe ns nt nu nv b">go-dock</code>。</p><p id="0f31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试服务器是否正常运行。</p><pre class="nm nn no np gt od nv oe of aw og bi"><span id="cb91" class="li lj iq nv b gy oh oi l oj ok">curl <a class="ae kc" href="http://localhost:3000/ping" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/ping</a></span></pre><p id="8bd2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到了回应。</p><pre class="nm nn no np gt od nv oe of aw og bi"><span id="6a6a" class="li lj iq nv b gy oh oi l oj ok">{“message”:”pong”}</span></pre></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="05c2" class="mq lj iq bd lk mr ms mt ln mu mv mw lq mx my mz lt na nb nc lw nd ne nf lz ng bi translated">3.多阶段构建</h1><p id="dfc8" class="pw-post-body-paragraph kd ke iq kf b kg nh ki kj kk ni km kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">现在你有了一个完全正常工作的web服务器，然后呢？</p><p id="e820" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你仔细观察，我们想从Go程序中得到的唯一东西是构建过程之后的二进制输出。这就是我们想要的Docker映像，我们甚至不需要go编译器本身在运行时！Docker的一个最佳实践是保持图像较小，通过只有二进制文件，然后我们使我们的图像比前一个更小。为了实现这一点，我们将使用一种称为多阶段构建的技术，这意味着我们将通过多个步骤来构建我们的图像。</p><p id="b496" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用以下内容更新Dockerfile文件:</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="8b9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这种技术，我们将使用<code class="fe ns nt nu nv b">golang:alpine</code>作为构建映像构建二进制文件的过程与基于<code class="fe ns nt nu nv b">scratch</code>生成新映像的过程分开，T5是一个简单且非常简单的映像。我们将主二进制文件从我们命名为<code class="fe ns nt nu nv b">builder</code>的第一个映像复制到新创建的<code class="fe ns nt nu nv b">scratch</code>映像中。欲了解更多关于刮刮乐图像的信息，请访问<a class="ae kc" href="https://hub.docker.com/_/scratch" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/_/scratch</a></p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="24d8" class="mq lj iq bd lk mr ms mt ln mu mv mw lq mx my mz lt na nb nc lw nd ne nf lz ng bi translated">4.静态文件</h1><p id="fab0" class="pw-post-body-paragraph kd ke iq kf b kg nh ki kj kk ni km kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">有时你还想从Golang应用程序中获取静态文件，无论是图片、CSS、PDF等。这一次，我们将使用一个JSON文件作为只读存储器来保存应用程序所需的数据。在之前的Docker构建过程中，当我们将二进制文件复制到暂存映像中时，我们丢失了静态文件。现在，我们还需要将所需的文件复制到其中。让我们实现这一点。</p><p id="d91a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先在您的工作目录中创建一个名为<code class="fe ns nt nu nv b">/database</code>的新文件夹，然后创建一个名为<code class="fe ns nt nu nv b">data.json</code>和<code class="fe ns nt nu nv b">database.go</code>的文件。</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="8e6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将这些行添加到<code class="fe ns nt nu nv b">main.go</code></p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="208a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们需要用暂存图像中的以下行来更新我们的<code class="fe ns nt nu nv b">Dockerfile</code>:</p><pre class="nm nn no np gt od nv oe of aw og bi"><span id="d431" class="li lj iq nv b gy oh oi l oj ok">COPY ./database/data.json /database/data.json</span></pre><p id="31dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将把静态文件复制到映像中，它将在应用程序运行时可用。让我们检查一下！</p><figure class="nm nn no np gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/67aa1a05dfb9218ba5bf73945d992d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ro40iEqHnX8KmMEqW-l7dA.png"/></div></div></figure><p id="67f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！现在您已经准备好在docker容器上运行您的应用程序了。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="ba9e" class="mq lj iq bd lk mr ms mt ln mu mv mw lq mx my mz lt na nb nc lw nd ne nf lz ng bi translated">技巧</h1><blockquote class="nw nx ny"><p id="0b20" class="kd ke nz kf b kg kh ki kj kk kl km kn oa kp kq kr ob kt ku kv oc kx ky kz la ij bi translated">没有测试的代码是不干净的。不管它多么优雅，不管它多么易读易懂，如果它没有经过测试，它就是不干净的。<br/> - <strong class="kf ir">罗伯特·c·马丁，干净的代码</strong></p></blockquote><p id="4070" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们想要的另一件事是测试。我希望你能体会到测试的好处，以及它是如何让我们远离麻烦的。运行测试有两种技术。我们可以在映像构建过程中使用<code class="fe ns nt nu nv b">go test</code>命令，或者在CI/CD过程中运行它。因此，如果由于某种原因测试失败了，我们就停止构建或部署过程。从那时起，我们可以确保我们只发布经过全面测试的软件。伟大的软件就是这样创造出来的。</p><p id="a234" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章的代码可以在我的GitHub【https://github.com/afdolriski/golang-docker T4】上找到</p><h1 id="477b" class="mq lj iq bd lk mr om mt ln mu on mw lq mx oo mz lt na op nc lw nd oq nf lz ng bi translated">结束</h1><p id="5a63" class="pw-post-body-paragraph kd ke iq kf b kg nh ki kj kk ni km kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">如果您正在使用微服务，您还可以将您的应用程序容器部署到各种容器编排工具中，使其更具可扩展性。我最喜欢的是<a class="ae kc" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>和<a class="ae kc" href="https://aws.amazon.com/ecs/" rel="noopener ugc nofollow" target="_blank"> AWS ECS </a>。我也将在下一篇文章中讨论这些技术。如果你不想错过的话，请跟我来。</p><p id="181f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您有任何问题或反馈，请在下面的回复部分留下。感谢您的阅读！</p></div></div>    
</body>
</html>