<html>
<head>
<title>'Explain' Your Database Queries Before Release</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">发布前解释你的数据库查询</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/explain-your-database-queries-before-release-fc8986b0d36e?source=collection_archive---------12-----------------------#2020-03-16">https://levelup.gitconnected.com/explain-your-database-queries-before-release-fc8986b0d36e?source=collection_archive---------12-----------------------#2020-03-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2e7d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">并避免生产中一些令人讨厌的性能意外</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e554a75a6d47aa853d80bda56d23ee9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4BlA-KIGrJA0lxsMEwQpog.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片由来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1209640" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/photos/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1209640" rel="noopener ugc nofollow" target="_blank">自由照片</a>提供</figcaption></figure><p id="c324" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，我在<a class="ae ky" href="http://www.nightlife.com.au" rel="noopener ugc nofollow" target="_blank"> Nightlife Music </a>的一位同事向我(代码评审员)和另一位同事(代码编写员)展示了优化SQL查询的两种方法。这个练习让我在我们的代码审查清单中添加了一个<code class="fe lv lw lx ly b">ensure all queries are explained check</code>。</p><p id="6ab0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章的重点不是解释关键字，而是强调这样一个事实，即这样做是非常重要的，特别是当你的查询在大型数据集上运行和/或快速连续运行多次时(对我们来说都是如此)。</p><h2 id="7ad5" class="ma mb it bd mc md me dn mf mg mh dp mi li mj mk ml lm mm mn mo lq mp mq mr ms bi translated">该查询</h2><p id="3ee7" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">这是一个简单的查询，但结果是我们要连接的两个表使用了不同的编码标准。当我们使用这样的查询时，只有当两个表之间的编码相同时，才会使用索引。</p><p id="2d76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们都不知道其中一个表格使用了<code class="fe lv lw lx ly b">latin1</code>编码。其次，我们编写的查询非常简单，我们都没有想到会有任何问题。</p><p id="d09e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事情是这样的:</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="2df6" class="ma mb it ly b gy nc nd l ne nf">SELECT * FROM myDB.pizzas pizzas</span><span id="63bf" class="ma mb it ly b gy ng nd l ne nf">JOIN myDB.pastas pastas USING (pizza_code)</span><span id="f44c" class="ma mb it ly b gy ng nd l ne nf">JOIN myOtherDB.pasta_recipes pasta_recipes<br/>ON pasta_recipes.sauce = <strong class="ly iu">pastas.sauce</strong></span><span id="58d7" class="ma mb it ly b gy ng nd l ne nf">WHERE pizzas.pizza_id = my_pizza_id</span><span id="b9e2" class="ma mb it ly b gy ng nd l ne nf">AND pasta_recipes.key = 'PIZZA NAME'</span></pre><p id="3eee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来很简单，对吧？我们哪里出错了？嗯，表格<code class="fe lv lw lx ly b">pizzas</code>和<code class="fe lv lw lx ly b">pastas</code>都编码在<code class="fe lv lw lx ly b">latin1</code>中，而pasta_recipes编码在<code class="fe lv lw lx ly b">utf8</code>中。如上所述，因为我们在<code class="fe lv lw lx ly b">pastas</code>和<code class="fe lv lw lx ly b">pasta_recipes</code>之间进行连接，所以这里不能使用索引。</p><h2 id="b61b" class="ma mb it bd mc md me dn mf mg mh dp mi li mj mk ml lm mm mn mo lq mp mq mr ms bi translated">向救援队解释</h2><p id="9d24" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">尽管我们都没有意识到这些表使用了不同的编码，但我们应该测试我们的查询，以确保它使用了索引并扫描了最少的行数。在这种情况下，我们只期望得到<strong class="lb iu">一个</strong>结果，因此应该只检索一行。</p><p id="fa1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何确定我们的查询是否将使用索引以及检索了多少行？通过使用<code class="fe lv lw lx ly b">EXPLAIN</code>关键字。</p><p id="f23f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在数据库上运行它:</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="c80f" class="ma mb it ly b gy nc nd l ne nf"><strong class="ly iu">EXPLAIN</strong></span><span id="7366" class="ma mb it ly b gy ng nd l ne nf">SELECT * FROM myDB.pizzas pizzas      // latin1 table</span><span id="f40f" class="ma mb it ly b gy ng nd l ne nf">JOIN myDB.pastas pastas USING (pizza_code)   // another latin1 table</span><span id="89f7" class="ma mb it ly b gy ng nd l ne nf">JOIN myOtherDB.pasta_recipes pasta_recipes     // utf8 table<br/>ON pasta_recipes.sauce = pastas.sauce</span><span id="5f65" class="ma mb it ly b gy ng nd l ne nf">WHERE pizzas.pizza_id = my_pizza_id</span><span id="3f73" class="ma mb it ly b gy ng nd l ne nf">AND pasta_recipes.key = 'PIZZA NAME'</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/47fcd7fd08c48aa1c96a494ea15968a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1IDJBX2pP1cHGAm_pQHKgA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在没有编码转换的情况下对我们的查询使用EXPLAIN的结果</figcaption></figure><p id="23bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们搜索了500多万行来寻找符合我们的<code class="fe lv lw lx ly b">JOIN</code>标准的行。索引<em class="lz">不是</em>用于<code class="fe lv lw lx ly b">pastas</code>和<code class="fe lv lw lx ly b">pasta_recipes</code>之间的连接。</p><p id="982f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看当我们将<code class="fe lv lw lx ly b">pastas</code>转换为使用相同的编码时会发生什么:</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="3dde" class="ma mb it ly b gy nc nd l ne nf"><strong class="ly iu">EXPLAIN</strong></span><span id="fa37" class="ma mb it ly b gy ng nd l ne nf">SELECT * FROM myDB.pizzas pizzas</span><span id="01e5" class="ma mb it ly b gy ng nd l ne nf">JOIN myDB.pastas pastas USING (pizza_code)</span><span id="5a65" class="ma mb it ly b gy ng nd l ne nf">JOIN myOtherDB.pasta_recipes pasta_recipes<br/>ON pasta_recipes.sauce = <strong class="ly iu">CONVERT(pastas.sauce USING ASCII)</strong></span><span id="0776" class="ma mb it ly b gy ng nd l ne nf">WHERE pizzas.pizza_id = my_pizza_id</span><span id="bc17" class="ma mb it ly b gy ng nd l ne nf">AND pasta_recipes.key = 'PIZZA NAME'</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/5c86fc85983490c08d664a6cdcd8651f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3RJ_1U4Q7OJBqKOl_qFOGw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在连接的表之间使用相同编码时的解释结果</figcaption></figure><p id="3d7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，现在我们有进展了！让我告诉你，查询要快得多。但是，等一下，我们不是只期待一排吗？我们现在将索引用于<code class="fe lv lw lx ly b">sauce</code>列上<code class="fe lv lw lx ly b">pasta_recipes</code>和<code class="fe lv lw lx ly b">pastas</code>之间的连接，但是看起来我们正在扫描行以找到<code class="fe lv lw lx ly b">key</code>匹配<code class="fe lv lw lx ly b">pizza_name</code>的行。因此，当我们检查<code class="fe lv lw lx ly b">pasta_recipes</code>表上的索引时，发现在<code class="fe lv lw lx ly b">key, sauce and <strong class="lb iu">type</strong></code> <strong class="lb iu"> </strong>列上有一个<code class="fe lv lw lx ly b">composite index</code>。因此，我们需要在<code class="fe lv lw lx ly b">WHERE</code>子句中包含一个<code class="fe lv lw lx ly b">type</code>来真正优化我们的查询:</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="245c" class="ma mb it ly b gy nc nd l ne nf"><strong class="ly iu">EXPLAIN</strong></span><span id="15f7" class="ma mb it ly b gy ng nd l ne nf">SELECT * FROM myDB.pizzas pizzas</span><span id="0759" class="ma mb it ly b gy ng nd l ne nf">JOIN myDB.pastas pastas USING (pizza_code)</span><span id="7b09" class="ma mb it ly b gy ng nd l ne nf">JOIN myOtherDB.pasta_recipes pasta_recipes<br/>ON pasta_recipes.sauce = CONVERT(pastas.sauce USING ASCII)</span><span id="555c" class="ma mb it ly b gy ng nd l ne nf">WHERE pizzas.pizza_id = my_pizza_id</span><span id="9c9b" class="ma mb it ly b gy ng nd l ne nf">AND pasta_recipes.key = 'PIZZA NAME'</span><span id="3295" class="ma mb it ly b gy ng nd l ne nf"><strong class="ly iu">AND pasta_recipes.type = 'tomato'</strong></span></pre><p id="e2a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/a59a4649f0f733842c724481935d6bc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-UpnnArgWaGxhhaXJYHZw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">当我们使用pasta_recipes表上的索引时，我们解释的结果</figcaption></figure><p id="c75d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在已经完全优化了查询，它几乎立即返回。每个表只返回一行。快乐的日子！</p><h2 id="765b" class="ma mb it bd mc md me dn mf mg mh dp mi li mj mk ml lm mm mn mo lq mp mq mr ms bi translated">不这样做真的会伤害你(和你的数据库！)</h2><p id="65d3" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">在<a class="ae ky" href="https://www.nightlife.com.au" rel="noopener ugc nofollow" target="_blank"> Nightlife </a>中，每天早上6点左右，我们会有大约6000个这样的查询，以及成千上万的其他查询(包括读和写)，所以我们尽可能地调整它们是非常重要的。使用SQL查询的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://dev.mysql.com/doc/refman/8.0/en/explain.html" rel="noopener ugc nofollow" target="_blank">EXPLAIN</a></code>关键字，以及来自其他数据库的对应关键字，如<a class="ae ky" href="https://docs.mongodb.com/manual/reference/method/cursor.explain/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>和<a class="ae ky" href="https://neo4j.com/docs/cypher-manual/current/" rel="noopener ugc nofollow" target="_blank"> Neo4j </a>(大多数数据库都应该有对应的关键字)，我们至少可以发现什么时候出了问题，即使我们不确定如何修复它们。如果我们不知道，我们总是可以请我们信任的同事来“解释”出了什么问题。</p><p id="16ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，如果你还没有，确保你的团队在他们所有的查询中都使用了explain，并且在投入生产之前亲自看看结果！</p><p id="04bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p><h2 id="fe12" class="ma mb it bd mc md me dn mf mg mh dp mi li mj mk ml lm mm mn mo lq mp mq mr ms bi translated">资源</h2><ol class=""><li id="7bf7" class="nk nl it lb b lc mt lf mu li nm lm nn lq no lu np nq nr ns bi translated"><a class="ae ky" href="https://www.nightlife.com.au" rel="noopener ugc nofollow" target="_blank">夜生活音乐</a></li><li id="46c4" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">MySQL <a class="ae ky" href="https://dev.mysql.com/doc/refman/8.0/en/explain.html" rel="noopener ugc nofollow" target="_blank">讲解</a></li><li id="4e2a" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">MongoDB <a class="ae ky" href="https://docs.mongodb.com/manual/reference/method/cursor.explain/" rel="noopener ugc nofollow" target="_blank">解释()</a></li><li id="09d4" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">Neo4j <a class="ae ky" href="https://neo4j.com/docs/cypher-manual/current/query-tuning/how-do-i-profile-a-query/" rel="noopener ugc nofollow" target="_blank">讲解</a></li></ol></div></div>    
</body>
</html>