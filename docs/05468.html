<html>
<head>
<title>Create an Easy Custom React Hook for Dragging Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为拖动组件创建一个简单的自定义React挂钩</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/create-an-easy-custom-react-hook-for-dragging-components-3779b30d08b5?source=collection_archive---------4-----------------------#2020-09-01">https://levelup.gitconnected.com/create-an-easy-custom-react-hook-for-dragging-components-3779b30d08b5?source=collection_archive---------4-----------------------#2020-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="94bf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">或者，钩子会变成什么样？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6e07fcfae3704b0da6ff86b7cf07d972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B-okuNMYImo0c7xvWWYLZA.png"/></div></div></figure></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><p id="fb7e" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">2003年，著名的技术专家墨菲·李预言了我们当前基于模块化组件的web应用程序的状态，他问道:</p><p id="0b79" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><em class="lu">窟达钩gon be？</em></p><p id="6817" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">尽管他坚持认为自己既不需要也不想要钩子，但web开发人员今天面临的许多问题并不能简单地通过背景音乐、他们的耳机声音很大、很钝的声音来解决。</p><p id="f6de" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">自从2018年末推出Hooks以来，它们已经成为React生态系统中至关重要的一部分，难怪它们<em class="lu">很棒。</em></p><h1 id="c8c8" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">但是什么是钩子呢？</h1><p id="3d1e" class="pw-post-body-paragraph ky kz iq la b lb mn jr ld le mo ju lg lh mp lj lk ll mq ln lo lp mr lr ls lt ij bi translated">一个钩子可以是很多东西。</p><p id="6ea5" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">React提供的基本挂钩允许您在功能组件中使用有状态逻辑和生命周期功能，在它们被引入之前，这些功能只能在基于类的组件中使用。有一些钩子允许你链接回调，记忆函数和对象，并直接与DOM的引用进行通信。</p><p id="91b5" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这只是React提供的开箱即用的挂钩。钩子真正开始发光的地方是当你把它们建造出来的时候。很有可能您想要重用的任何底层逻辑都可以表示为一个自定义钩子。React社区知道这一点，并且已经创建了许多您现在就可以使用的定制挂钩。</p><p id="fefb" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">正在访问<code class="fe ms mt mu mv b">localStorage</code>？</p><div class="mw mx gp gr my mz"><a href="https://www.npmjs.com/package/@rehooks/local-storage" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">@ re books/local-storage</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">React挂钩，用于启用与本地存储的同步。API文档可以在这里找到。这可以是从…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">www.npmjs.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn kp mz"/></div></div></a></div><p id="b934" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">什么是钩子？</p><p id="8779" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">与<code class="fe ms mt mu mv b">indexDB</code> api同步？</p><div class="mw mx gp gr my mz"><a href="https://www.npmjs.com/package/react-use-idb" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">反应-使用-idb</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">管理单个indexDB项的React副作用挂钩。在旧仓库上的一次顺便更换。本地存储是…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">www.npmjs.com</p></div></div><div class="ni l"><div class="no l nk nl nm ni nn kp mz"/></div></div></a></div><p id="80c1" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">什么是钩子？</p><p id="c479" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">甚至像查看你的电脑是否在线这样简单的事情。</p><div class="mw mx gp gr my mz"><a href="https://www.npmjs.com/package/@rehooks/online-status" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">@rehooks/online-status</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">React挂钩，用于订阅“在线”/“离线”事件和“navigator.onLine”属性，以查看当前状态</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">www.npmjs.com</p></div></div><div class="ni l"><div class="np l nk nl nm ni nn kp mz"/></div></div></a></div><p id="a150" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">瓦特。达。钩子。耿。是吗？</p><h1 id="8d34" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">听起来很棒！所以，下载一堆钩子吧？</h1><p id="b395" class="pw-post-body-paragraph ky kz iq la b lb mn jr ld le mo ju lg lh mp lj lk ll mq ln lo lp mr lr ls lt ij bi translated">你可以的。如果你时间紧迫，这就是我的建议。上面的挂钩和许多类似的挂钩工作良好，经过测试，应该可以帮助你解决你面临的任何问题。</p><p id="f54f" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">但是那不会帮助你了解他们是如何工作的。</p><p id="2c34" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这就是为什么今天我要和你一起工作，帮助你构建你自己的可重用钩子来创建可拖动的组件。</p><p id="74ea" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">你可以在<a class="ae nq" href="https://github.com/timmalstead/watDaHookGonBe" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到完整的代码。</p><h1 id="3cb8" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">1.准备和安装</h1><p id="26be" class="pw-post-body-paragraph ky kz iq la b lb mn jr ld le mo ju lg lh mp lj lk ll mq ln lo lp mr lr ls lt ij bi translated">在你的终端输入<code class="fe ms mt mu mv b">npx create-react-app wat_da_hook_gon_be</code>开始吧。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/07181cfb23d529531ceac6bce39d9bf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*-PFGnTESBYZ9vIuzihZA-Q.jpeg"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">钩子会是什么？</figcaption></figure><p id="e8b3" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">下载上面200 x 200 px的图片，保存到你的<code class="fe ms mt mu mv b">src</code>文件夹，重命名为<code class="fe ms mt mu mv b">albumcover.jpg</code>，然后将下面的文字复制到你的<code class="fe ms mt mu mv b">App</code>文件中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="f9a0" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果你输入<code class="fe ms mt mu mv b">yarn start</code>到你的终端，你应该在浏览器的左上角看到图片。</p><h1 id="5fbc" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">2.添加起始位置和状态</h1><p id="df41" class="pw-post-body-paragraph ky kz iq la b lb mn jr ld le mo ju lg lh mp lj lk ll mq ln lo lp mr lr ls lt ij bi translated">在我们正在构建的钩子中将会有相当多的事情发生。因此，为了我们双方的利益，我将把事情分解成几个步骤，并解释我在这个过程中所做的事情。</p><p id="faa2" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我知道当我学习新概念和新技术时，我喜欢缓慢的、一步一步的解释。所以我会尽可能简单地分解它。</p><p id="2f89" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">用以下代码修改<code class="fe ms mt mu mv b">App.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="f250" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们来分析一下这是怎么回事。</p><p id="d90a" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在我们第一次导入的顶部，我们正在导入<code class="fe ms mt mu mv b">useState</code>钩子。</p><p id="6348" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><code class="fe ms mt mu mv b">useState</code>是React中功能组件的主力。它接受一个参数，一个要使用的初始状态，并返回两个值:一个表示状态的变量和一个更新状态的函数。在使用函数更新状态时，会触发一个rerender，并更新订阅状态变量的任何内容。</p><p id="f089" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在我们上一步设置好内联样式之后，我们正在从全局<code class="fe ms mt mu mv b">window</code>对象中析构<code class="fe ms mt mu mv b">innerHeight</code>和<code class="fe ms mt mu mv b">innerWidth</code>属性。</p><p id="0c36" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在下一行中，我们将这些析构值用于设置我们的初始位置值。我们将它们除以二，然后从中减去100。由于我们的图像是200 x 200像素，这将设置我们的图片的中间到我们的浏览器的中间。</p><p id="e628" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">接下来我们有了<code class="fe ms mt mu mv b">useState</code>的初始值。首先，我们将布尔值<code class="fe ms mt mu mv b">isDragging</code>设置为<code class="fe ms mt mu mv b">false.</code>,这将用于判断组件是否被主动拖动。接下来的三个属性将始终是包含x和y值的普通对象。这些代表屏幕的x轴和y轴，以像素为单位。我们将从x : 0和y : 0处的<code class="fe ms mt mu mv b">origin</code>开始。<code class="fe ms mt mu mv b">translation</code>和<code class="fe ms mt mu mv b">lastTranslation</code>，我们稍后会详细讨论，将从我们的<code class="fe ms mt mu mv b">startingPosition</code>变量中设置的值开始。</p><p id="5430" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">屏幕上还没有发生任何变化，但我们正在前进。</p><h1 id="4b38" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">3.添加handleMouseDown</h1><p id="0c52" class="pw-post-body-paragraph ky kz iq la b lb mn jr ld le mo ju lg lh mp lj lk ll mq ln lo lp mr lr ls lt ij bi translated">处理鼠标事件时，一个非常常见的模式是将逻辑分解为三个函数，处理鼠标按钮被单击、鼠标被移动和鼠标按钮被释放时的逻辑。我们将利用这个模式的三个功能，称为<code class="fe ms mt mu mv b">handleMouseDown</code>、<code class="fe ms mt mu mv b">handleMouseMove</code>和<code class="fe ms mt mu mv b">handleMouseUp</code>。</p><p id="c808" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">观察下面的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="61c7" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在我们开始之前，我们将从我们的<code class="fe ms mt mu mv b">dragInfo</code>状态变量中析构<code class="fe ms mt mu mv b">isDragging</code>，以使事情更容易处理。</p><p id="5d07" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><code class="fe ms mt mu mv b">handleMouseDown</code>函数将接受两个参数<code class="fe ms mt mu mv b">clientX</code>和<code class="fe ms mt mu mv b">clientY</code>，这两个参数是由触发鼠标事件构造的。这些是我们单击想要拖动的元素时X和Y轴上的坐标。不太复杂吧？</p><p id="eaef" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果<code class="fe ms mt mu mv b">isDragging</code>设置为假，我们将进入我们的功能。我们将调用我们的<code class="fe ms mt mu mv b">setDragInfo</code>方法来更新我们的<code class="fe ms mt mu mv b">dragInfo</code>状态，将<code class="fe ms mt mu mv b">isDragging</code>更改为<code class="fe ms mt mu mv b">true</code>，将<code class="fe ms mt mu mv b">origin</code>坐标更改为<code class="fe ms mt mu mv b">clientX</code>和<code class="fe ms mt mu mv b">clientY</code>。</p><h1 id="fffc" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">4.添加handleMouseMove</h1><p id="5993" class="pw-post-body-paragraph ky kz iq la b lb mn jr ld le mo ju lg lh mp lj lk ll mq ln lo lp mr lr ls lt ij bi translated">无论我们按住鼠标多长时间，只要我们移动鼠标，<code class="fe ms mt mu mv b">handleMouseMove</code>功能就会一次又一次地触发。所以，我想我们应该试着把它做好，你说呢？</p><p id="8d23" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">看哪！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="35fa" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">像我们最后一个函数一样，<code class="fe ms mt mu mv b">handleMouseMove</code>将析构的<code class="fe ms mt mu mv b">clientX</code>和<code class="fe ms mt mu mv b">clientY</code>属性作为参数。如果<code class="fe ms mt mu mv b">isDragging</code>解析为<code class="fe ms mt mu mv b">true</code>，则<code class="fe ms mt mu mv b">origin</code>和<code class="fe ms mt mu mv b">lastTranslation</code>值从<code class="fe ms mt mu mv b">draginfo</code>开始被析构，我们再次调用<code class="fe ms mt mu mv b">setDragInfo</code>动作来更新我们的状态。你知道这实际上是如何一次又一次地快速更新状态的吗？</p><p id="d093" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们现在唯一感兴趣改变的值是<code class="fe ms mt mu mv b">translation</code>。我们将添加我们在<code class="fe ms mt mu mv b">mouseDown</code>函数中存储的<code class="fe ms mt mu mv b">origin</code>值，将它们添加到我们最后的翻译值中，并从鼠标事件触发的<code class="fe ms mt mu mv b">client</code>参数值中减去它们。为了避免得到负值，我们将把整个等式放在<code class="fe ms mt mu mv b">Math.abs</code>中。这个函数调用绝对值，所以只有正值会从这个函数返回，因此它会留在屏幕上。</p><p id="fc60" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">下一步，我们将把<code class="fe ms mt mu mv b">translation</code>值直接附加到可拖动对象的CSS值上，在每次渲染时更新它们。</p><h1 id="b1d9" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">5.操作鼠标并把它们绑在一起</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="a560" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">对于我们的最后一个函数，我们将<em class="lu">不</em>需要任何参数，因为我们要做的就是关闭我们的拖动，并为我们的下一次拖动设置一个值。</p><p id="f67a" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为此，如果我们的<code class="fe ms mt mu mv b">isDragging</code>变量解析为<code class="fe ms mt mu mv b">true</code>，我们将从<code class="fe ms mt mu mv b">dragInfo</code>析构<code class="fe ms mt mu mv b">translation</code>。请记住，这是我们刚刚在<code class="fe ms mt mu mv b">handleMouseMove</code>函数中更改了很多次的值。再次调用我们的<code class="fe ms mt mu mv b">setDragInfo</code>方法，我们将把<code class="fe ms mt mu mv b">isDragging</code>更改为<code class="fe ms mt mu mv b">false</code>，结束拖动循环，将<code class="fe ms mt mu mv b">lastTranslation</code>的值设置为从<code class="fe ms mt mu mv b">handleMouseMove</code>返回的<code class="fe ms mt mu mv b">translation</code>的最后一个值，并传播其余的值。</p><p id="8e8b" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">是啊！真的就这么简单。差不多就是用鼠标更新x和y的值。但是在它工作之前，我们需要以某种方式将所有这些元素附加到我们的元素上。我们用内嵌样式变量<code class="fe ms mt mu mv b">picturePosition</code>来做这件事。它将我们的<code class="fe ms mt mu mv b">position</code>规则改为<code class="fe ms mt mu mv b">absolute</code>，并将<code class="fe ms mt mu mv b">right</code>和<code class="fe ms mt mu mv b">bottom</code>规则附加到<code class="fe ms mt mu mv b">translation</code>的x和y值上。因为它是在每次渲染时生成的，所以当我们拖动它时，它会为我们拖动的项目生成一个新的位置。</p><p id="8bc8" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">然后，在<code class="fe ms mt mu mv b">picturePosition</code>和<code class="fe ms mt mu mv b">pictureStyle</code>中展开内联样式对象，并将鼠标事件附加到我们希望被拖动的元素上适当的合成事件监听器，这是一件简单的事情。</p><p id="1e60" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">但是等一下，为什么有两个事件连着<code class="fe ms mt mu mv b">handleMouseMove</code>？当鼠标离开元素时，我们不希望它，你知道，离开吗？</p><p id="106a" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">尝试在没有侦听器的情况下使用此代码。大部分情况下，这是可行的。问题是当你移动指针太快时，通常鼠标移动的速度会超过函数的速度，你会失去拖动。或者，您不会失去拖动，但可能会发生其他奇怪的行为，如不再能够悬停在元素上。将<code class="fe ms mt mu mv b">handleMouseMove</code>连接到<code class="fe ms mt mu mv b">onMouseMove</code>和<code class="fe ms mt mu mv b">onMouseLeave</code>上消除了这种头痛。由于我们使用布尔值来检测拖动是否发生，我们不必担心拖动状态会陷入永久的“开”状态。</p><p id="2354" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">就是这样！一个可拖动组件附加到一个元素！</p><p id="96da" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">虽然它不是非常模块化。在我们的下一步中，我们将看到钩子真正闪光的地方，并将它抽象成一个可重用的<code class="fe ms mt mu mv b">useDrag</code>钩子</p><h1 id="8b88" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">6.使用抹布</h1><p id="f8f0" class="pw-post-body-paragraph ky kz iq la b lb mn jr ld le mo ju lg lh mp lj lk ll mq ln lo lp mr lr ls lt ij bi translated">在您的<code class="fe ms mt mu mv b">src</code>文件夹中创建一个名为<code class="fe ms mt mu mv b">useDrag</code>的新文件，并将下面的代码移入其中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="2abe" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这里，我们把所有的逻辑都放在了拖出我们的组件上，并把它放在一个我们可以在需要的时候一次又一次重用它的地方。</p><p id="4d0b" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">完成之后，您可以将<code class="fe ms mt mu mv b">App</code>更改为以下内容。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="cdff" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">最后的想法</h1><p id="da0f" class="pw-post-body-paragraph ky kz iq la b lb mn jr ld le mo ju lg lh mp lj lk ll mq ln lo lp mr lr ls lt ij bi translated">今天，我们已经知道如何用一个简单的三函数过程来处理鼠标按下事件、鼠标移动事件和鼠标抬起事件，从而使任何元素都可以拖动。我们还学习了如何将该模式抽象成一个可重用的钩子，因此我们可以将它用于任何我们需要的组件。我希望这篇文章对你来说是令人愉快和有启发性的，并且你喜欢阅读它就像我喜欢写它一样。</p></div></div>    
</body>
</html>