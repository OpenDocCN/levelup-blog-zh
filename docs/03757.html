<html>
<head>
<title>How to Use TypeScript for AWS Lambda in 3 Steps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在3个步骤中使用AWS Lambda的TypeScript</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-use-typescript-for-aws-lambda-in-3-steps-1996243547eb?source=collection_archive---------0-----------------------#2020-05-26">https://levelup.gitconnected.com/how-to-use-typescript-for-aws-lambda-in-3-steps-1996243547eb?source=collection_archive---------0-----------------------#2020-05-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/1a58a55ea3fc391291eef50a2e3f313d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t6cjGkhJNMcEMJP6O4JZAg.png"/></div></div></figure><div class=""/><h1 id="38bb" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">AWS Lambda/NodeJS(类型脚本)系列</h1><ol class=""><li id="6d24" class="kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><a class="ae lo" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-typescript-for-aws-lambda-in-3-steps-1996243547eb">如何在3个步骤中使用AWS Lambda的TypeScript</a></li><li id="647b" class="kw kx jb ky b kz lp lb lq ld lr lf ls lh lt lj lk ll lm ln bi translated"><a class="ae lo" href="https://medium.com/@zijing/unit-test-and-integration-test-for-aws-lambda-nodejs-in-typescript-2235a0f69f5" rel="noopener">TypeScript中AWS Lambda/NodeJS的单元测试和集成测试</a></li></ol><h1 id="4281" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">情况</h1><p id="8a00" class="pw-post-body-paragraph lu lv jb ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">当我们使用NodeJS作为AWS Lambdas的运行时，JavaScript是默认语言。然而，由于JavaScript中缺乏类型检查，不时会有错误代码被不经意地部署到Lambda中。比如这样一个小小的错别字:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="485b" class="ms jz jb mo b gy mt mu l mv mw">exports.lambdaHandler = async (event, context) =&gt; {<br/><br/>  <strong class="mo jc">const </strong>queries = event.que<strong class="mo jc">yt</strong>StringParameters;<br/><br/>  <em class="mx">// ...<br/></em>}</span></pre><p id="296e" class="pw-post-body-paragraph lu lv jb ky b kz my lw lx lb mz ly lz ld na mb mc lf nb me mf lh nc mh mi lj ij bi translated">我们本想得到<code class="fe nd ne nf mo b">que<strong class="ky jc">ry</strong>StringParameters</code>，但是由于粗心大意<code class="fe nd ne nf mo b">queries</code>最终变成了<code class="fe nd ne nf mo b">undefined</code>。</p><h1 id="d813" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">目标</h1><p id="0e13" class="pw-post-body-paragraph lu lv jb ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">我们希望利用TypeScript来编写lambda处理程序。使用TypeScript，我们将获得以下好处:</p><ol class=""><li id="cb0a" class="kw kx jb ky b kz my lb mz ld ng lf nh lh ni lj lk ll lm ln bi translated">编程时的普通代码完成提示</li><li id="5316" class="kw kx jb ky b kz lp lb lq ld lr lf ls lh lt lj lk ll lm ln bi translated">编译时错误检查以避免冗余部署</li></ol><p id="e009" class="pw-post-body-paragraph lu lv jb ky b kz my lw lx lb mz ly lz ld na mb mc lf nb me mf lh nc mh mi lj ij bi translated">这并不难做到，本文将介绍完成这项工作的3个步骤。</p><h1 id="8967" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">准备</h1><p id="ba17" class="pw-post-body-paragraph lu lv jb ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">在经历这3个步骤之前，让我们用<a class="ae lo" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html" rel="noopener ugc nofollow" target="_blank"> SAM CLI </a>创建一个经典lambda项目:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="e802" class="ms jz jb mo b gy mt mu l mv mw">sam init</span></pre><p id="9268" class="pw-post-body-paragraph lu lv jb ky b kz my lw lx lb mz ly lz ld na mb mc lf nb me mf lh nc mh mi lj ij bi translated">在上面的命令之后，我们将得到一个包含这些文件的文件夹:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="ba76" class="ms jz jb mo b gy mt mu l mv mw">├── README.md<br/>├── events<br/>│   └── event.json<br/>├── hello-world<br/>│   ├── app.js<br/>│   ├── package.json<br/>│   └── tests<br/>│       └── unit<br/>│           └── test-handler.js<br/>└── template.yaml</span></pre><p id="f6a6" class="pw-post-body-paragraph lu lv jb ky b kz my lw lx lb mz ly lz ld na mb mc lf nb me mf lh nc mh mi lj ij bi translated">然后我们就开始把这个JS包转移到TS包。</p><h1 id="a794" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">步骤1:添加TypeScript依赖项</h1><p id="aa33" class="pw-post-body-paragraph lu lv jb ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">在<code class="fe nd ne nf mo b">package.json</code>中，添加以下代码:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="ca3a" class="ms jz jb mo b gy mt mu l mv mw">"scripts": {<br/>  "compile": "tsc"<br/>},<br/>"devDependencies": {<br/>  "aws-sdk": "^2.655.0",<br/>  "@types/aws-lambda": "^8.10.51",<br/>  "@types/node": "^13.13.5",<br/>  "typescript": "^3.8.3"<br/>}</span></pre><ul class=""><li id="7856" class="kw kx jb ky b kz my lb mz ld ng lf nh lh ni lj nj ll lm ln bi translated"><strong class="ky jc">脚本/编译</strong>:这将用于将类型脚本代码编译成JavaScript</li><li id="1c6f" class="kw kx jb ky b kz lp lb lq ld lr lf ls lh lt lj nj ll lm ln bi translated"><strong class="ky jc"> devDependencies </strong>:由于这只是为了开发，我们不需要将包添加到<code class="fe nd ne nf mo b">dependencies</code>块中</li><li id="865f" class="kw kx jb ky b kz lp lb lq ld lr lf ls lh lt lj nj ll lm ln bi translated"><strong class="ky jc"> aws-sdk </strong>:取决于你是否在lambda中使用AWS SDK</li><li id="994c" class="kw kx jb ky b kz lp lb lq ld lr lf ls lh lt lj nj ll lm ln bi translated">这对于代码完成和类型检查来说是非常重要的</li><li id="8609" class="kw kx jb ky b kz lp lb lq ld lr lf ls lh lt lj nj ll lm ln bi translated"><strong class="ky jc"> @types/node </strong>:内置类型需要这个包</li><li id="6192" class="kw kx jb ky b kz lp lb lq ld lr lf ls lh lt lj nj ll lm ln bi translated"><strong class="ky jc">打字稿</strong>:其中<code class="fe nd ne nf mo b">tsc</code>来自</li></ul><blockquote class="nk nl nm"><p id="11bd" class="lu lv mx ky b kz my lw lx lb mz ly lz nn na mb mc no nb me mf np nc mh mi lj ij bi translated">如果你觉得这篇文章有用，请关注这个帐户，以便将来更新。感谢支持！</p></blockquote><h1 id="4482" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">第二步:添加<code class="fe nd ne nf mo b">tsconfig.json</code></h1><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="178d" class="ms jz jb mo b gy mt mu l mv mw">{<br/>  "compilerOptions": {<br/>    "module": "CommonJS",<br/>    "target": "ES2017",<br/>    "noImplicitAny": true,<br/>    "preserveConstEnums": true,<br/>    "outDir": "./built",<br/>    "sourceMap": true<br/>  },<br/>  "include": ["src-ts/**/*"],<br/>  "exclude": ["node_modules", "**/*.spec.ts"]<br/>}</span></pre><p id="44ef" class="pw-post-body-paragraph lu lv jb ky b kz my lw lx lb mz ly lz ld na mb mc lf nb me mf lh nc mh mi lj ij bi translated">TypeScript编译器需要<code class="fe nd ne nf mo b">tsconfig.json</code>来弄清楚如何将TypeScript转换成JavaScript。</p><ul class=""><li id="5517" class="kw kx jb ky b kz my lb mz ld ng lf nh lh ni lj nj ll lm ln bi translated"><strong class="ky jc">模块</strong> : <em class="mx">普通</em>这里没问题</li><li id="a11a" class="kw kx jb ky b kz lp lb lq ld lr lf ls lh lt lj nj ll lm ln bi translated"><strong class="ky jc">目标</strong>:应用<em class="mx"> ES2017 </em>将保留<code class="fe nd ne nf mo b">async</code>和<code class="fe nd ne nf mo b">await</code>语法，而不是将其转换为<code class="fe nd ne nf mo b">Promise</code>代码。因为我们使用Node12作为运行时环境，所以Lambda函数支持解释语法。同时，保持<code class="fe nd ne nf mo b">async</code>和<code class="fe nd ne nf mo b">await</code>使得代码简洁明了</li><li id="aa34" class="kw kx jb ky b kz lp lb lq ld lr lf ls lh lt lj nj ll lm ln bi translated"><strong class="ky jc">无注入</strong>:推荐有。如果有一个变量没有类型声明，编译器将抛出一个错误</li><li id="a644" class="kw kx jb ky b kz lp lb lq ld lr lf ls lh lt lj nj ll lm ln bi translated"><strong class="ky jc">preserve constanums</strong>:更像是一个语法糖，但是我想继续使用它，因为它可以在JavaScript代码中以<code class="fe nd ne nf mo b">object</code>的形式保存<code class="fe nd ne nf mo b">enum</code>类，这有助于理解JavaScript代码</li><li id="260c" class="kw kx jb ky b kz lp lb lq ld lr lf ls lh lt lj nj ll lm ln bi translated"><strong class="ky jc"> outDir </strong>:您想要设置为编译输出的任何文件夹</li><li id="a3a0" class="kw kx jb ky b kz lp lb lq ld lr lf ls lh lt lj nj ll lm ln bi translated">这个是可选的</li></ul><h1 id="d27f" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">第三步:修改代码</h1><p id="a084" class="pw-post-body-paragraph lu lv jb ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">首先，创建文件夹<code class="fe nd ne nf mo b">src-ts</code>，并将<code class="fe nd ne nf mo b">app.js</code>移动到该文件夹。</p><p id="b219" class="pw-post-body-paragraph lu lv jb ky b kz my lw lx lb mz ly lz ld na mb mc lf nb me mf lh nc mh mi lj ij bi translated"><code class="fe nd ne nf mo b">app.js</code>现在看起来是这样的:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="c926" class="ms jz jb mo b gy mt mu l mv mw">exports.lambdaHandler = <strong class="mo jc">async </strong>(event, context) =&gt; {<br/>  <strong class="mo jc">const </strong>queries = <strong class="mo jc"><em class="mx">JSON</em></strong>.stringify(event.queytStringParameters);<br/>  <strong class="mo jc">return </strong>{<br/>    <strong class="mo jc">statusCode</strong>: 200,<br/>    <strong class="mo jc">body</strong>: <strong class="mo jc">`Queries: </strong>${queries}<strong class="mo jc">`<br/>  </strong>}<br/>};</span></pre><p id="0338" class="pw-post-body-paragraph lu lv jb ky b kz my lw lx lb mz ly lz ld na mb mc lf nb me mf lh nc mh mi lj ij bi translated">让我们创建<code class="fe nd ne nf mo b">app.ts</code>并替换它:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="fc38" class="ms jz jb mo b gy mt mu l mv mw"><strong class="mo jc">import </strong>{ <br/>  APIGatewayProxyEvent, <br/>  APIGatewayProxyResult <br/>} <strong class="mo jc">from "aws-lambda"</strong>;</span><span id="f731" class="ms jz jb mo b gy nq mu l mv mw"><strong class="mo jc">export const </strong><em class="mx">lambdaHandler </em>= <strong class="mo jc">async </strong>(<br/>  event: <strong class="mo jc">APIGatewayProxyEvent</strong><br/>): Promise&lt;<strong class="mo jc">APIGatewayProxyResult</strong>&gt; =&gt; {<br/>  <strong class="mo jc">const </strong>queries = <strong class="mo jc"><em class="mx">JSON</em></strong>.stringify(event.<strong class="mo jc">queryStringParameters</strong>);<br/>  <strong class="mo jc">return </strong>{<br/>    <strong class="mo jc">statusCode</strong>: 200,<br/>    <strong class="mo jc">body</strong>: <strong class="mo jc">`</strong>Queries<strong class="mo jc">: </strong>${queries}<strong class="mo jc">`<br/>  </strong>}<br/>}</span></pre><p id="f340" class="pw-post-body-paragraph lu lv jb ky b kz my lw lx lb mz ly lz ld na mb mc lf nb me mf lh nc mh mi lj ij bi translated">由于这个TypeScript文件将被编译到<code class="fe nd ne nf mo b">built</code>文件夹中，我们还需要修改<code class="fe nd ne nf mo b">template.yaml</code>中的<code class="fe nd ne nf mo b">Handler</code>字段，以确保<code class="fe nd ne nf mo b">lambda</code>资源可以在正确的路径中定位代码:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="9255" class="ms jz jb mo b gy mt mu l mv mw"><strong class="mo jc">Resources</strong>:<br/>  <strong class="mo jc">HelloWorldFunction</strong>:<br/>    <strong class="mo jc">Type</strong>: AWS::Serverless::Function<em class="mx"><br/>    </em><strong class="mo jc">Properties</strong>:<br/>      <strong class="mo jc">CodeUri</strong>: hello-world/built<br/>      <strong class="mo jc">Handler</strong>: app.lambdaHandler</span></pre><p id="b99d" class="pw-post-body-paragraph lu lv jb ky b kz my lw lx lb mz ly lz ld na mb mc lf nb me mf lh nc mh mi lj ij bi translated">我们在文件夹<code class="fe nd ne nf mo b">hello-world</code>后面添加了路径<code class="fe nd ne nf mo b">built</code>，这样AWS Lambda就可以正确地找到处理程序。</p><p id="e224" class="pw-post-body-paragraph lu lv jb ky b kz my lw lx lb mz ly lz ld na mb mc lf nb me mf lh nc mh mi lj ij bi translated">现在，该目录如下所示:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="4de2" class="ms jz jb mo b gy mt mu l mv mw">├── README.md<br/>├── <strong class="mo jc">hello-world</strong><br/>│   ├── <strong class="mo jc">built</strong><br/>│   │   ├── app.js<br/>│   │   └── app.js.map<br/>│   ├── package-lock.json<br/>│   ├── package.json<br/>│   ├── <strong class="mo jc">src-ts</strong><br/>│   │   ├── app.ts<br/>│   │   └── tests<br/>│   └── tsconfig.json<br/>├── samconfig.toml<br/>└── template.yaml</span></pre><h1 id="1aab" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">部署和测试</strong></h1><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="7247" class="ms jz jb mo b gy mt mu l mv mw">cd hello-world<br/>npm install<br/>npm run compile<br/>cd ..<br/>sam deploy --guided</span></pre><p id="ba60" class="pw-post-body-paragraph lu lv jb ky b kz my lw lx lb mz ly lz ld na mb mc lf nb me mf lh nc mh mi lj ij bi translated">部署成功后，我们将在AWS控制台中看到Lambda函数，如下所示:</p><figure class="mj mk ml mm gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/b652713402bea9325a32c5f810d73761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qALGdyMT3Cus9PzAKMuCjg.png"/></div></div></figure><p id="86de" class="pw-post-body-paragraph lu lv jb ky b kz my lw lx lb mz ly lz ld na mb mc lf nb me mf lh nc mh mi lj ij bi translated">我们应该能够使用以下命令测试Lambda函数:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="37af" class="ms jz jb mo b gy mt mu l mv mw">▶ curl https://[API_ID].amazonaws.com/Prod/hello\?weather\=sunny<br/>Queries: {"weather":"sunny"}</span></pre><h1 id="4970" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论和下一步</h1><p id="5b8b" class="pw-post-body-paragraph lu lv jb ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">示例代码可以在<a class="ae lo" href="https://github.com/zijing07/aws-lambda-nodejs-ts" rel="noopener ugc nofollow" target="_blank">https://github.com/zijing07/aws-lambda-nodejs-ts</a>找到</p><p id="435e" class="pw-post-body-paragraph lu lv jb ky b kz my lw lx lb mz ly lz ld na mb mc lf nb me mf lh nc mh mi lj ij bi translated">在为我的Lambda函数利用了TypeScript支持之后，我发现这真的令人耳目一新。一方面，它可以节省我在API文档中查找方法名或参数列表的大量时间。另一方面，<code class="fe nd ne nf mo b">tsc</code>也帮助我在部署之前检测到任何潜在的问题。</p><p id="64b9" class="pw-post-body-paragraph lu lv jb ky b kz my lw lx lb mz ly lz ld na mb mc lf nb me mf lh nc mh mi lj ij bi translated">在<a class="ae lo" href="https://medium.com/@zijing/unit-test-and-integration-test-for-aws-lambda-nodejs-in-typescript-2235a0f69f5" rel="noopener">下一篇文章</a>中，我会谈到如何对Lambda函数进行局部集成测试。</p><div class="ip iq gp gr ir ns"><a href="https://medium.com/@zijing/unit-test-and-integration-test-for-aws-lambda-nodejs-in-typescript-2235a0f69f5" rel="noopener follow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jc gy z fp nx fr fs ny fu fw ja bi translated">TypeScript中AWS Lambda/NodeJS的单元测试和集成测试</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">在我的上一篇文章中，我们讨论了如何将TypeScript应用于AWS SAM CLI创建的NodeJS项目，请查看链接…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">medium.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og ix ns"/></div></div></a></div><blockquote class="nk nl nm"><p id="86a3" class="lu lv mx ky b kz my lw lx lb mz ly lz nn na mb mc no nb me mf np nc mh mi lj ij bi translated">如果你觉得这篇文章有用，请关注这个帐户，以便将来更新。感谢支持！</p></blockquote></div><div class="ab cl oh oi hu oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="ij ik il im in"><h1 id="2c2c" class="jy jz jb bd ka kb oo kd ke kf op kh ki kj oq kl km kn or kp kq kr os kt ku kv bi translated">分级编码</h1><p id="9489" class="pw-post-body-paragraph lu lv jb ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">感谢您成为我们社区的一员！升级正在改变技术招聘。<a class="ae lo" href="https://jobs.levelup.dev/talent" rel="noopener ugc nofollow" target="_blank"> <strong class="ky jc">在最好的公司</strong>找到你最理想的工作 </a> <strong class="ky jc">。</strong></p><div class="ip iq gp gr ir ns"><a href="https://jobs.levelup.dev/talent" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jc gy z fp nx fr fs ny fu fw ja bi translated">提升——改变招聘流程</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">🔥让软件工程师找到他们热爱的完美角色🧠寻找人才是最痛苦的部分…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">作业. levelup.dev</p></div></div><div class="ob l"><div class="ot l od oe of ob og ix ns"/></div></div></a></div></div></div>    
</body>
</html>