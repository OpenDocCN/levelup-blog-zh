<html>
<head>
<title>Yahoo Finance Portfolio: Rendering high performance financial data table in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Yahoo Finance Portfolio:在React中呈现高性能财务数据表</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/yahoo-finance-portfolio-rendering-high-performance-financial-data-table-in-react-634fe2d6a381?source=collection_archive---------1-----------------------#2017-08-13">https://levelup.gitconnected.com/yahoo-finance-portfolio-rendering-high-performance-financial-data-table-in-react-634fe2d6a381?source=collection_archive---------1-----------------------#2017-08-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/f92c0e58e91bccfab2c254d81e298e00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*npwjNvplxxjvTzNmCHo74g.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">雅虎金融投资组合简介</figcaption></figure><div class=""/><p id="da31" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">每秒60帧(fps)是任何前端渲染基础设施的核心。实现高帧率的关键在于主线程上高性能渲染功能和工作负载编排的结合。</p><p id="46ad" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">呈现类似Excel的大型表格并不是一个新问题。然而，不断变化的前端浏览器和功能允许我们探索新的途径，用不同的权衡来解决这个问题。我们已经彻底探索了脸书和谷歌的现有解决方案，但无法确定我们的使用案例。因此，我们决定建立一个内部解决方案，并建立一套可以在整个雅虎通用的最佳实践。</p><h1 id="ed89" class="la lb jf bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">背景</h1><p id="a092" class="pw-post-body-paragraph kc kd jf ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">Portfolio是Finance中的一个实用工具，它允许用户创建一个由一组定制的数据列和一系列用户指定的符号组成的电子表格。我们通过识别99%的使用模式开始着手解决这个问题。这使我们处于大约20列(4000–5000个单元格)的200–250个分笔成交点的范围内。</p><p id="8242" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一般用户反馈还要求支持整个表格的复制/粘贴和打印，这使得传统的单元格重用/踩踏操作过于复杂。最重要的是，作为新体验的一部分，第一列(符号列)和标题行在viewport中是固定的，这给设计复合层以尽量减少使用期间的重新布局带来了很大的挑战。</p><h1 id="5872" class="la lb jf bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">现有解决方案</h1><p id="0308" class="pw-post-body-paragraph kc kd jf ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">最流行的开源解决方案是<a class="ae md" href="https://github.com/facebook/fixed-data-table" rel="noopener ugc nofollow" target="_blank">脸书固定数据表</a>，专有的是Google Sheets。</p><p id="7757" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">脸书数据表利用了<a class="ae md" href="https://en.wikipedia.org/wiki/Treadmilling" rel="noopener ugc nofollow" target="_blank"/>，这是一种常见的做法，它呈现一组固定的行，并在用户滚动时将看不见的前排移动到后排。<br/>由于并非所有的单元格都被渲染，这使得用户无法复制/粘贴/打印整个表格。此外，这种解决方案的帧速率较低，在严重回流的情况下徘徊在20–30 fps左右。</p><figure class="mf mg mh mi gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi me"><img src="../Images/58079cb79341fe1b6d922c05b4f2d728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7yQwQWRg0qN6PDb3IDnLJg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">固定数据表性能配置文件</figcaption></figure><p id="a23a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Google solution使用了相同的方法，但是由于使用canvas作为主干，它具有更好的性能。Google Sheets确实在画布表的顶部放置了一个元素表，主要用于单元格选择和用户交互。这个解决方案不是开源的，实现起来非常复杂。其在持续流式数据集下的性能也未得到验证。</p><h1 id="7d66" class="la lb jf bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">我们的一般方法</h1><p id="63fa" class="pw-post-body-paragraph kc kd jf ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">在高层次上，我们确定了从结构到微操作的关键优化:</p><ul class=""><li id="46d0" class="mj mk jf ke b kf kg kj kk kn ml kr mm kv mn kz mo mp mq mr bi translated"><strong class="ke jg">基准测试/分析基础设施</strong>:没有一个稳定的基准测试/分析基础设施，我们就无法安全前进。Chrome等浏览器提供了一套很好的分析工具，从CPU/内存使用情况到UI重组所用时间的图表。</li><li id="8620" class="mj mk jf ke b kf ms kj mt kn mu kr mv kv mw kz mo mp mq mr bi translated"><strong class="ke jg">一般布局</strong>:由于粘滞的行/列行为，这些元素需要特殊处理，这不仅影响标记结构，也影响样式。</li><li id="94b4" class="mj mk jf ke b kf ms kj mt kn mu kr mv kv mw kz mo mp mq mr bi translated"><strong class="ke jg">单元格渲染优化</strong>:最后，它归结为对整个表格影响最大的单个单元格渲染性能的组合。我们花了大量时间分别调整每种细胞类型。</li></ul><h1 id="ebb7" class="la lb jf bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">基准/分析基础设施</h1><p id="ad92" class="pw-post-body-paragraph kc kd jf ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">我们依赖几个关键绩效指标(KPI ):</p><ul class=""><li id="ccae" class="mj mk jf ke b kf kg kj kk kn ml kr mm kv mn kz mo mp mq mr bi translated"><strong class="ke jg"> CPU时间</strong>:这可以通过在受控环境下反复渲染某一类型的单元格来衡量。这种实践也被称为微基准测试。我们利用<a class="ae md" href="https://benchmarkjs.com/" rel="noopener ugc nofollow" target="_blank"> benchmark.js </a>和React字符串呈现作为代理来收集这些信息。</li><li id="e626" class="mj mk jf ke b kf ms kj mt kn mu kr mv kv mw kz mo mp mq mr bi translated"><strong class="ke jg"> CPU使用量</strong>:流式票数据点需要重新渲染某些单元格。Chrome DevTool profiling与任务管理器的结合为我们提供了这个数字的近似值。</li><li id="c89e" class="mj mk jf ke b kf ms kj mt kn mu kr mv kv mw kz mo mp mq mr bi translated"><strong class="ke jg">内存使用</strong>:由于数据集是实时变化的，我们希望确保这不会影响浏览器中的GC周期，否则会导致线程暂停。Chrome DevTool也提供了这一功能。</li><li id="86ba" class="mj mk jf ke b kf ms kj mt kn mu kr mv kv mw kz mo mp mq mr bi translated"><strong class="ke jg">布局/排版时间</strong>:重新计算布局所花费的时间，这本身就很昂贵。这将对帧速率产生负面影响。chrome dev tool flame graph profiling为我们提供了花费在UI布局计算上的时间明细。</li></ul><h1 id="0e9e" class="la lb jf bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">总平面</h1><p id="dca4" class="pw-post-body-paragraph kc kd jf ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">由于标题/第一列的粘性，我们开始将这些元素克隆到一个单独的层中，并将它们放在表格的顶部。</p><p id="983c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这种方法的优点是可以控制布局和样式的重新计算。这使我们能够根据CPU可用性来专门限制/批处理/拆分这些操作。</p><p id="2a95" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">缺点是，由于其灵活的宽度特性和同步滚动位置，我们必须花费额外的CPU周期将这些元素的尺寸与核心表同步。</p><p id="1c84" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，这可以通过缩小可能影响维度更改的事件集来缓解。这些是<code class="fe mx my mz na b">resize</code>、<code class="fe mx my mz na b">data column change</code>事件、<code class="fe mx my mz na b">ticker change</code>事件和<code class="fe mx my mz na b">navigation</code>事件。通过了解这些何时发生，这使我们能够控制何时最好地重新计算这些布局并最小化成本。</p><p id="4fa7" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，同步位置是极其昂贵的，因为去抖动/节流它们将导致无序的毛刺，并且实时地进行它们会影响滚动性能。最后，我们决定使用<code class="fe mx my mz na b">position: sticky</code>和<a class="ae md" href="https://github.com/wilddeer/stickyfill" rel="noopener ugc nofollow" target="_blank"> polyfill </a>只分离出标题行，并保留第一列作为核心表的自然流程的一部分。之后，我们<code class="fe mx my mz na b">preventDefault</code>表格的水平滚动行为，并手动计算滚动位置和滚动速度，以确保列总是同步的。</p><h1 id="1cae" class="la lb jf bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">单元渲染优化</h1><h2 id="adcb" class="nb lb jf bd lc nc nd dn lg ne nf dp lk kn ng nh lo kr ni nj ls kv nk nl lw nm bi translated">普通单元格</h2><p id="a86c" class="pw-post-body-paragraph kc kd jf ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">我们从当前单元渲染CPU时间的基线开始:</p><pre class="mf mg mh mi gt nn na no np aw nq bi"><span id="4152" class="nb lb jf na b gy nr ns l nt nu">Row w/ 62 cells x 190 ops/sec ±3.06% (73 runs sampled)<br/>CPU time for Row w/ 62 cells: 5.253441030475995ms</span></pre><p id="5740" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们决定尝试通过将<code class="fe mx my mz na b">Component</code>改为功能<code class="fe mx my mz na b">StatelessComponent</code>来消除React开销，以最小化某些单元类型上的<code class="fe mx my mz na b">createElement</code>开销。假设这些单元类型在流式传输期间具有非常高的值改变概率，因此使得差异检查不相关。</p><pre class="mf mg mh mi gt nn na no np aw nq bi"><span id="523e" class="nb lb jf na b gy nr ns l nt nu">Row w/ 62 cells x 344 ops/sec ±3.72% (72 runs sampled)<br/>CPU time for Row w/ 62 cells: 2.908777648130453ms</span></pre><h2 id="7b4e" class="nb lb jf bd lc nc nd dn lg ne nf dp lk kn ng nh lo kr ni nj ls kv nk nl lw nm bi translated">数字单元格</h2><p id="9d12" class="pw-post-body-paragraph kc kd jf ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">由于我们的大多数单元格类型都是需要国际化格式的数字，但设置非常相似，我们决定<code class="fe mx my mz na b">memoize</code>通过将构造函数选项序列化为一个键来实现格式化机制。这极大地减少了重构格式化程序的需要。</p><pre class="mf mg mh mi gt nn na no np aw nq bi"><span id="ee9c" class="nb lb jf na b gy nr ns l nt nu">Row w/ 62 cells x 562 ops/sec ±2.52% (80 runs sampled)<br/>CPU time for Row w/ 62 cells: 1.7808359339126558ms</span></pre><h2 id="8d5c" class="nb lb jf bd lc nc nd dn lg ne nf dp lk kn ng nh lo kr ni nj ls kv nk nl lw nm bi translated">图形单元格</h2><p id="2e0f" class="pw-post-body-paragraph kc kd jf ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">我们的一些单元格是自定义图形(如图表和数字范围)。这些最初是使用常规DOM元素和SVG的组合呈现的。然而，尽管SVG是灵活的和基于向量的，但它需要不同的组合层。这在滚动/调整大小/流动期间不断地被重新计算。我们决定将它们重写为基于<code class="fe mx my mz na b">canvas</code>的实现，以充分利用光栅化。</p><p id="813a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">有色流式细胞</strong></p><p id="64d7" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">彩色流动池是特殊的流动池，根据变化是负还是正而“闪烁”(<code class="fe mx my mz na b">background-color</code>变化)成红色/绿色。虽然这可能很简单，<code class="fe mx my mz na b">background-color</code>不容易被<a class="ae md" href="https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/" rel="noopener ugc nofollow" target="_blank"> GPU加速的</a>动画化，但是<code class="fe mx my mz na b">opacity</code>却很容易。</p><p id="864c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们决定探索一种“三明治”的方法，为这个单元格创建3个单独的层，1层用于绿色，1层用于红色，1层用于实际内容。这两个背景层是使用<code class="fe mx my mz na b">pseudo</code>元素<code class="fe mx my mz na b">:before</code>和<code class="fe mx my mz na b">:after</code>创建的，并基于3 <code class="fe mx my mz na b">keyframes</code>制作动画以模仿类似<code class="fe mx my mz na b">bezier-curve</code>的动画。<code class="fe mx my mz na b">background-color</code>也固定为红色/绿色，而<code class="fe mx my mz na b">opacity</code>正在被激活。关键帧设置如下所示:</p><pre class="mf mg mh mi gt nn na no np aw nq bi"><span id="979d" class="nb lb jf na b gy nr ns l nt nu"><a class="ae md" href="http://twitter.com/keyframes" rel="noopener ugc nofollow" target="_blank">@keyframes</a> trendAnimUp1 {<br/>  25% {<br/>    opacity: 1;<br/>    display: block;<br/>  }<br/>  75% {<br/>    opacity: 1;<br/>  }<br/>  100% {<br/>    opacity: 0;<br/>    display: none;<br/>  }<br/>}</span></pre><p id="05c6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里的关键技术是:</p><ul class=""><li id="154f" class="mj mk jf ke b kf kg kj kk kn ml kr mm kv mn kz mo mp mq mr bi translated"><strong class="ke jg">操纵显示属性</strong>:创建额外层的缺点是合成它们的成本。通过将<code class="fe mx my mz na b">display</code>改为<code class="fe mx my mz na b">none</code>，我们实质上在这些层完成动画制作后移除了它们，从而降低了复杂度。</li><li id="462c" class="mj mk jf ke b kf ms kj mt kn mu kr mv kv mw kz mo mp mq mr bi translated"><strong class="ke jg">旋转动画</strong>:由于关键帧不能轻易暂停/恢复/重置，我们创建重复的关键帧，并使用<code class="fe mx my mz na b">class</code>在它们之间切换，有效地触发关键帧重置。</li></ul><p id="14d3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用这些技术，我们能够将<strong class="ke jg">32.04毫秒</strong> CPU时间转换为<strong class="ke jg">9.72毫秒</strong> (-68%) CPU时间&amp;<strong class="ke jg">1.2毫秒</strong> GPU时间。</p><h1 id="2188" class="la lb jf bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结果和主要收获</h1><p id="e344" class="pw-post-body-paragraph kc kd jf ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">我们为大约2000行的货币渲染一个持续流动的表格的最终fps大约是<strong class="ke jg"> 54fps </strong>。在这个过程中，我们还发现了一些重要的经验:</p><ul class=""><li id="404a" class="mj mk jf ke b kf kg kj kk kn ml kr mm kv mn kz mo mp mq mr bi translated"><strong class="ke jg">移除React样式机制，支持纯CSS </strong>:渲染样式和图标，React在两个CPU &amp; GPU时间中引入开销，而不是将SVG内联到CSS中。</li><li id="110a" class="mj mk jf ke b kf ms kj mt kn mu kr mv kv mw kz mo mp mq mr bi translated"><strong class="ke jg">栅格化极大地帮助了FPS</strong>:通过从基于矢量的SVG切换到栅格化的画布，我们能够从我们的flamegraph中移除一大块布局构图。SVG中的动画也非常昂贵。</li><li id="479e" class="mj mk jf ke b kf ms kj mt kn mu kr mv kv mw kz mo mp mq mr bi translated"><strong class="ke jg">针对GPU加速进行优化</strong>:在我们的彩色值用例中，通过将繁重的UI任务从CPU转移到多个CPU &amp; GPU，我们能够显著减少主线程中的CPU时间。</li><li id="d584" class="mj mk jf ke b kf ms kj mt kn mu kr mv kv mw kz mo mp mq mr bi translated">尽可能多的记忆:通过在我们的需求范围内尽可能多的记忆，我们能够重用昂贵的国际化格式化程序。</li></ul></div></div>    
</body>
</html>