<html>
<head>
<title>Let’s Make Tic-Tac-Toe!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们做井字游戏！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lets-make-tic-tac-toe-51dd3fd188d?source=collection_archive---------16-----------------------#2020-06-08">https://levelup.gitconnected.com/lets-make-tic-tac-toe-51dd3fd188d?source=collection_archive---------16-----------------------#2020-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/268c141adfc1c4b610b019fe1e3bf4a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/1*SUHdGkfnNcmFnQaktoRtfg.gif"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">一款非常简单的井字游戏！</figcaption></figure><p id="5dc3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将制作一个超级简单的井字游戏！这种双人纸笔游戏有着非常古老的起源，在许多文化中无处不在。这个版本将由Java编写，我将使用IntelliJ IDE。这款游戏还将配备一台超级简单的电脑，可以随机放置棋子。在未来的博客文章中，我们将讨论如何使用极大极小算法使其不可战胜，但现在我们只需要在屏幕上显示一些东西，并确保我们知道游戏何时获胜。按照每一步的图片和描述，让我们开始编码吧！</p><p id="6ef3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们首先决定如何将我们的项目关注点分开。由于Java是一种面向对象的语言，我们需要从面向对象的角度来考虑我们的游戏。你可能想分开你的文件不同，所以觉得自由这样做。在Main.Java，我会提示问题，但我需要参考用户和计算机所做的移动。游戏逻辑也将保存在不同的文件中。一旦你决定了如何分离你的关注点，让我们开始编程吧！因为我们的游戏超级简单，所以让用户总是先走，并且永远是x。计算机会跟着走，并且是o。</p><h1 id="668a" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">第一步:设置</h1><p id="f68e" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我将让IntelliJ为我做所有困难的工作，所以只需在您想要的目录中创建一个新项目，并将其命名为TicTacToe。让我们也制作三个Java类文件。一个是游戏逻辑的Game.java，一个是简单的电脑玩家的Computer.java，最后一个是TicTacToe.java，我们会提示用户问题。下面是我的文件结构！</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/64bc38f27f5279d03518a8406459b54b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*WTJMT3woGDMbwcFUShGwzg.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">ItelliJ为我们处理了大部分工作！</figcaption></figure><h1 id="ce1f" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">第二步:棋盘和游戏</h1><p id="1784" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我们将在Game.java制作我们的棋盘和所有的游戏逻辑。该局将是一个2D字符阵列展示如下。我还将使用另一个名为placements的数组来跟踪仓位。有8个获胜的位置，所以我创建了一个函数来检查位置数组中的位置，并且在每次移动后都调用这个函数。我还添加了getter函数。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mh"><img src="../Images/cc0d2bed5a162d81b5dd10300895f098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ypW-wnZfgdWKmezGgRYiJg.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">目前为止我的功能。</figcaption></figure><p id="ca59" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我还创建了一个名为show options的函数，它将显示所有的选项和打印板。给函数命名是如此简单，令人惊讶。这些函数是嵌套循环，在2D数组上迭代。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mm"><img src="../Images/a9e7892e6ee78c1ace540d85d962c4ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AiXSBm3Zqr8CT2_XWj2fHg.png"/></div></div></figure><p id="ddc2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后这些是为电脑或玩家定位的函数。用户的位置编号为1–9，因此我减去1，使其更容易匹配位置数组。它带有一个字符X或O以及一个位置。我们需要检查那个位置是否已经被占用，所以我们还要创建一个函数来检查那个位置是否被占用，并返回一个布尔值。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mn"><img src="../Images/bbbb2c0a787341415a9459b583eb0cc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*huETET86Y8A2EFpmY2su5w.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">我的功能</figcaption></figure><p id="fefd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们需要函数来检查游戏是否是平局，最后一步棋已经走完，或者游戏已经赢了。我们已经做了所有的艰苦工作，所以这些是简单的功能。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mo"><img src="../Images/c469501807018beb82b926c59dcee88a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SdLJidttJnYsdySkFDcmhQ.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">我的代码…</figcaption></figure><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mp"><img src="../Images/84a1b88b152ba63fdc1db0a407c793fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vp70FAHVxRMS8E3vxT0teA.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">…一切都结束了…</figcaption></figure><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mq"><img src="../Images/3da58b1e1ed56f0afaa710515d3f7fae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7WDXpH-KMcYSxVhFkRSo2g.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">…这个地方！</figcaption></figure><p id="5575" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这应该是棋盘和游戏逻辑的总结。这是最密集的部分，干得好！</p><h1 id="90a3" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">3 .电脑</h1><p id="492e" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我们的计算机所要做的就是放置随机的零件，因为这是我们最小的可行产品(简称MVP)。我需要得到位置数组并选择一个随机数。如果这个随机数被占用，那么选择另一个直到它没有被占用。一旦它找到了一个动作，它需要做的只是放置它！真的就这么简单！我们可以使用最小最大算法使它变得更困难，但这是一个单独的话题。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mr"><img src="../Images/c9e47563cb25620b3fe8e516064145ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q1hYXIEAYh2C6H_T8RD7ow.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">真的那么简单！</figcaption></figure><h1 id="2a47" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">第四步:用户</h1><p id="641d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">最后一步是把它们放在一起！我们首先需要通过实例化将所有这些组件组合在一起，并创建一个漂亮的小intro函数！</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ms"><img src="../Images/a1b01624e87fbedebcd17d7bfc63993e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bmh3xIEEELdn7gcTiz6THA.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">我们的实例化和介绍函数！</figcaption></figure><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mt"><img src="../Images/0dfeac851100a7d397670cd061884766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n31ZNwWIJ1suwoq2R2HG4g.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">调用我们的显示选项方法</figcaption></figure><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/0bda1e5fd6084e0c6654cdee4ff41455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*Poy3txQBBpObYCFdwQjmJA.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">看起来相当不错！</figcaption></figure><p id="1eeb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在提示之后，我们需要采取用户行动。我们需要验证这个输入，以确保它是一个数字1-9。我使用一个try catch块来检查它是否是一个整数，如果是，程序就退出。这是一个while循环，用于检查数字是小于1还是大于9，如果是，将提示他们选择另一个数字，最后，如果该位置被占用，他们必须再次选择！这需要大量的验证！计算机有它自己的小功能，因为我们给它编了程序，使它只能做出正确的选择。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mv"><img src="../Images/ff86c1e2b60266bd3ed8d3192b15d28f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_IAtZ0Q-4snRlyt_m-qutA.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">有点复杂，但做了它需要做的事情！</figcaption></figure><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mw"><img src="../Images/5c813421cad63bcf52432887169a9a83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b4vfThWt6sSqI45VHpppmA.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">一个简单得多的函数！</figcaption></figure><p id="6fe1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在这部分是我自己的，因为我喜欢分解成更小的函数，但是如果游戏打成平手或者赢了，我会为打印信息创建函数，但是之后我们需要做的就是把它打包。我设计的方式是让用户是X，总是先走。我在每一步棋后都检查游戏是否赢了，这有点过分，但这是我们的MVP！现在我们有9个位置，2个玩家，第一个玩家将有最后一步棋。如果不小心的话，你可能会陷入一个无限循环。如果你在两个棋步结束时都检查了一个平手游戏，并且你下了你的棋步，那么计算机会继续寻找一个棋子，但是没有！再次，它结束了杀戮，但我检查是否有任何平局游戏后，用户每一轮。一旦我们有了它，我们就有了一个全功能的TicTacToe游戏！干得好！在以后的博客文章中，我们将使用最小最大算法制造一台无与伦比的计算机！</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mx"><img src="../Images/139bc587e59182f2c97b0232da18cef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KUuou2MAmHhERL5coUw3Cw.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">我们最后一个总结的方法！</figcaption></figure></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="f466" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">布拉德利哈利<br/> </strong> <em class="nf">全栈开发者寻找我的下一场演出<br/></em><a class="ae ng" href="https://github.com/bshaley25" rel="noopener ugc nofollow" target="_blank">GitHub</a><strong class="kd iu">|</strong><a class="ae ng" href="https://www.linkedin.com/in/bradley-haley-44a85b19a/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><strong class="kd iu">|</strong>|<a class="ae ng" href="https://medium.com/@bshaley25" rel="noopener">Medium</a><strong class="kd iu">|</strong><a class="ae ng" href="https://bradley-s-website.web.app/" rel="noopener ugc nofollow" target="_blank">网站</a></p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><div class="md me mf mg gt nh"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">编写面试问题</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">技术开发</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv jv nh"/></div></div></a></div></div></div>    
</body>
</html>