<html>
<head>
<title>I Accidentally Wrote a Lua Game Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我不小心写了一个Lua游戏引擎</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/i-accidentally-wrote-a-lua-game-engine-a45bd5f74b30?source=collection_archive---------13-----------------------#2021-01-04">https://levelup.gitconnected.com/i-accidentally-wrote-a-lua-game-engine-a45bd5f74b30?source=collection_archive---------13-----------------------#2021-01-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b25772e8748076290c13fbca4f1e6d9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BhclCDQtAFtcU9rqFjtSAw.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">简单的机制允许用户用图形表示一个对象的属性；右图显示了y轴位置</figcaption></figure><p id="7df3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最近我一直在研究<a class="ae la" href="https://github.com/mkhan45/SIMple-Mechanics" rel="noopener ugc nofollow" target="_blank">简单物理</a>，这是一套教育物理模拟器，旨在帮助直观地教和学物理，而无需昂贵的实验室设备或亲自上课。每个模拟器都允许用户导入和导出场景，并可能通过Lua添加一些更高级的功能。</p><p id="fe4f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">直到最近，Lua脚本还相当有限。它可以用来添加/删除对象和改变变量，例如但重要的是，一旦对象被创建，它就不能影响它们。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="eec3" class="ln lo iq le b gy lp lq l lr ls">-- this example instantiates a multicolored grid of circles<br/>for row = 1,HEIGHT do<br/>    for col = 1,WIDTH do<br/>        color = {<br/>            r = (row * col) / (WIDTH * HEIGHT) * 255,<br/>            g = col / WIDTH * 255,<br/>            b = row / HEIGHT * 255<br/>        }<br/>        add_shape{<br/>            shape = "circle", <br/>            x = col * OFFSET + START_X_OFFSET, <br/>            y = row * OFFSET, <br/>            r = RAD, <br/>            mass = 1, <br/>            color = color<br/>        }<br/>    end<br/>end</span></pre><p id="80a5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">重要的是，一旦实例化，就没有办法直接影响单个对象。到现在为止，你可能已经明白这是怎么回事了。</p><p id="3712" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">关于这个项目，我已经和我的物理学教授联系过了，他告诉我，他希望学生们能够对我们在课堂上学到的方程进行编码。例如，通过欧拉方法或碰撞方程的基本位置积分。因此，我决定为Lua接口实现一种能够更新单个对象的方法。</p><p id="6983" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我得到的是特定于对象的更新函数。通过指定每一帧在对象上调用的函数，用户现在可以修改对象的特征，包括位置、速度、颜色等。这是集成实验室的MVP，让学生编写自己的集成方法:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="ec79" class="ln lo iq le b gy lp lq l lr ls">-- the student should edit this function<br/>local function integrate(x, y, v_x, v_y, dt)<br/>    return {<br/>        new_x = x + v_x * dt,<br/>        new_y = y + v_y * dt,<br/>    }<br/>end</span><span id="3bfa" class="ln lo iq le b gy lt lq l lr ls">X_VEL = 1<br/>Y_VEL = -1</span><span id="1eae" class="ln lo iq le b gy lt lq l lr ls">-- this function is called on the circle every frame<br/>function update_fn(obj)<br/>    local old_x, old_y = obj.x, obj.y<br/>    data = integrate(old_x, old_y, X_VEL, Y_VEL, DT / 100)<br/>    obj.x, obj.y = data.new_x, data.new_y<br/>    return obj<br/>end</span><span id="f020" class="ln lo iq le b gy lt lq l lr ls">add_shape {<br/>    shape="circle",<br/>    x=SCREEN_X/2,<br/>    y=SCREEN_Y/2,<br/>    r=1,<br/>    mass=1,<br/>    update_function="update_fn"<br/>}</span><span id="30ea" class="ln lo iq le b gy lt lq l lr ls">GRAVITY = 0</span></pre><p id="3129" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个想法是，学生将编写他们自己的<code class="fe lb lc ld le b">integrate()</code>函数。理想情况下，应该有另一个圆使用模拟器的物理引擎，通过比较两个形状的行为，可以看出欧拉积分中的错误。</p><p id="ba31" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我编写示例时，我意识到特定于对象的更新功能与Unity的ECS的工作方式非常相似。更新功能本质上是一个脚本组件。虽然只能给每个对象添加一个更新函数，但这是一个很容易绕过的限制。</p><p id="d977" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">基于这种认识，我决定写Flappy Bird。我承认这个标题有点clickbaity:仍然没有办法处理来自Lua脚本的用户输入，所以这个程序仍然不能真正被称为游戏引擎。用户可以用鼠标拖动物体，因此可以在场景中设置物理按钮，并且还有全局的<code class="fe lb lc ld le b">MOUSE_X</code>和<code class="fe lb lc ld le b">MOUSE_Y</code> Lua变量，但是Lua看不到键盘或鼠标点击。正因为如此，我写了一个超级简单的AI来玩Flappy Bird。</p><p id="e589" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我的Lua代码有点业余，对于一个代码片段来说太长了，所以如果你想看的话，我鼓励你去GitHub 上查看一下。</p><p id="e29b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">像这样在物理引擎上建造Flappy Bird非常有趣。我没有费心去写一个结束游戏的条件，但是如果小鸟撞上了其中一个管道，它们都会飞走。我没有手动更新管道的x位置，而是将它们的速度初始化为负。我假设这和它在Unity或Godot中的工作方式相似。然而，虽然使用这个引擎来编写游戏是完全可能的，但它并不太符合人体工程学。不过，我不介意。</p><p id="8753" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我感到惊讶的另一件事是与Rust的Lua接口的速度。每一帧，程序都将Lua对象的许多字段拉进物理引擎，并将它们传递回Lua。在Flappy Bird的例子中，物理引擎几乎是不活动的，所以我期望Lua系统比物理引擎更密集，但是如果我正确地读取我的分析器，它使用了大约十分之一的性能。我很想把简单物理学的<a class="ae la" href="https://github.com/mkhan45/SIMple-Gravity" rel="noopener ugc nofollow" target="_blank">万有引力部分改写成Lua脚本。</a></p></div></div>    
</body>
</html>