# 佐布里斯特散列法

> 原文：<https://levelup.gitconnected.com/zobrist-hashing-305c6c3c54d0>

![](img/8ce495a5f59c4076c528d9652ea56ede.png)

[https://unsplash.com/photos/w7ZyuGYNpRQ](https://unsplash.com/photos/w7ZyuGYNpRQ)

Zobrist hashing 以其发明者 Albert Zobrist 的名字命名，是一种将棋盘位置(如国际象棋或围棋)表示为哈希值的技术。它主要与转置表一起使用，转置表是一种特殊的哈希表，由电路板位置索引，用于避免多次分析同一电路板位置。

# 它有什么好处

在博弈论中，有像 [Minimax](https://en.wikipedia.org/wiki/Minimax) 或 [AlphaBeta](https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning) 这样的算法，用于分析棋盘位置，并在给定情况下找到最佳可能的棋步。这可能适用于国际象棋、围棋或井字游戏。

这些算法采用一个给定的起始位置，用每个玩家所有可能的移动来模拟游戏的进一步过程。在开发者规定的评估方法的帮助下，该算法可以在每种游戏情况下计算分数。基于这个分数，算法知道一个位置是好还是坏，或者导致这个位置的移动。理想情况下，这种算法的输出是其计算得分的最佳可能移动。

一个问题是，计算最佳走法可能需要很长时间，尤其是像国际象棋这样的游戏。这是因为像国际象棋这样的游戏有一个巨大的博弈树。博弈树是一个有向图，它的节点是博弈中的位置，边是棋步。像 Minimax 这样的算法构建了这样一个图，并遍历它来寻找最佳可能的移动。

在[转置表](https://en.wikipedia.org/wiki/Transposition_table)的帮助下，加速这些算法是可能的。换位表就像一个缓存，存储已经分析过的电路板位置。在构建游戏树的时候，你通常会不止一次碰到同一个棋盘位置。如果没有换位台，您每次都必须重新分析电路板位置。因此，一旦算法评估了一个位置，它就将结果存储在转置表中，以避免这种行为。下次算法遇到这个位置时，它可以从转置表中得到结果。

总而言之:在算法中使用转置表来避免多次分析相同的位置。

大多数情况下，转置表是作为散列表实现的，其中的键是字符串表示中的棋盘位置。因此，关于棋盘位置，可以存储一些信息，比如最佳走法。

这就是 **Zobrist hash** 出现的地方:Zobrist hashing 是一种将给定的棋盘位置表示为(唯一的)哈希值的方法。这个散列在转置表中用于将信息(如最佳移动)映射到棋盘，并使其可访问。

所以下面的段落描述了 Zobrist hash 是如何工作的，以及它是如何计算的。这里以井字游戏为例。在这篇文章的最后，你会发现一个 Kotlin 的实现。

# 它是如何工作的

Zobrist hashing 使用一组随机生成的数字的`xor`操作，称为密钥。我们将其分为两部分:

*   生成密钥
*   计算哈希值

## 生成密钥

首先，我们必须根据以下方案生成密钥:

> 对于每个可用的棋盘单元和其中一个单元中的每个可能的游戏角色，我们生成一个随机数。

这听起来可能有点令人困惑，但实际上很简单。让我们来看看我们的例子，井字游戏:

在井字游戏棋盘中，有 9 个可用的单元格。在这些单元的每一个中，可以放置 2 个不同的游戏角色:`X`或`O`。所以根据上面的引用，我们必须生成 18 (9*2)个随机数。

```
cell  |   player 1 (X)  |   player 2 (O)
------------------------------------------
0     |      44532      |      72217
1     |      90195      |      10291
2     |      81410      |      65932
3     |      36721      |      91854
...
```

实际上，大多数时候，64 位数字，例如数据类型`Long`的数字，被用作随机数。这降低了以后计算哈希值时发生冲突的风险。

## 计算哈希值

现在，生成密钥后，可以计算给定棋盘位置的 Zobrist 散列:

> 取之前生成的每个游戏角色所在单元格的随机数，并通过`xor`操作将它们组合起来。

同样，这比听起来容易。我们来举个例子。

在我们开始之前，有一个小提示:井字游戏的单元格是这样排序的:从 0 到 8。

```
0 1 2 
3 4 5
6 7 8
```

好了，现在是举例子的时候了。看看下面的棋盘位置:

```
X . O
X . .
. . .Player 1 (X) in cells: 0, 3
Player 2 (O) in cells: 2
```

玩家在以下单元格中进行游戏:

*   玩家 1: 0，3
*   玩家 2: 2

最后，我们可以计算这个位置的 Zobrist 散列:我们从上面获取这些单元格的随机数/密钥，并通过`xor`操作将它们组合起来。操作的顺序无关紧要:

```
 44532 (cell #0 player 1)
XOR 65932 (cell #2 player 2)
XOR 36721 (cell #3 player 1)
---------
  = 74505 (Zobrist hash)
```

我们成功计算了游戏位置的 Zobrist hash:`74505`。

现在，这个散列可以用来存储转置表中的电路板位置。在这种情况下，计算出的哈希值被用作密钥。

## 重用哈希

这个过程的一个巨大的优点是，它不需要在一步棋走完之后计算全新的散列:我们可以获取新棋走完的单元格的关键字，并将其与已经存在的 Zobrist 散列相结合。

假设我们有与上面相同的位置:

```
X . O
X . .
. . .=> 74505 (Zobrist hash)
```

现在，参与人 O 在 1 号单元格中采取行动，尽管这是一个糟糕的行动:

```
X O O
X . .
. . .
```

同样，我们希望为新创建的董事会职位计算 Zobrist 散列。我们使用旧的散列值`74505`，并通过`xor`操作将其与新播放的单元格(#1)的密钥再次组合:

```
 74505 (old Zobrist hash)
XOR 10291 (cell #1 player 2)
---------
  = 68410 (new Zobrist hash)
```

在走完一步棋后，重新使用旧的散列来计算新的散列，这使得遍历游戏树变得非常有效。

此外，撤销一个移动也很容易:我们使用新创建的 Zobrist hash，并将其与我们想要撤销的单元格的键相结合。让我们从上面撤销 1 号单元格中参与人 2 的最后一步棋。

```
 68410 (new Zobrist hash)
XOR 10291 (cell #1 player 2)
---------
  = 74505 (Zobrist hash after undo last move) Resulting position:X . O
X . .
. . .
```

佐布里斯特杂凑，`74505`，等于开始时的杂凑，在参与人 2 的移动开始之前。

**这篇文章最初发表在我的博客上。看一看。**

 [## 佐布里斯特散列法

### 2020 年 8 月 2 日 Zobrist hashing 以其发明者 Albert Zobrist 的名字命名，是一种表示游戏棋盘的技术…

拉斯瓦切特.德夫](https://larswaechter.dev/blog/zobrist-hashing/) 

最后但并非最不重要的一个例子是在 Kotlin 中实现井字游戏: