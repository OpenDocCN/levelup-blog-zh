<html>
<head>
<title>Adding Start, Pause, Resume and Stop to our App (Part 5)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向我们的应用程序添加开始、暂停、恢复和停止(第5部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/adding-start-pause-resume-and-stop-to-our-app-part-5-dd562d82d0a3?source=collection_archive---------7-----------------------#2021-03-21">https://levelup.gitconnected.com/adding-start-pause-resume-and-stop-to-our-app-part-5-dd562d82d0a3?source=collection_archive---------7-----------------------#2021-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jn jo jp jq gh gi paragraph-image"><div class="ab gu cl jr"><img src="../Images/f56304e6a017e72d558bcf5f3e3cd1fe.png" data-original-src="https://miro.medium.com/v2/format:webp/0*55eLFcyH1xpMZ5Mf.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">礼貌:timeanddate.com</figcaption></figure><p id="27d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">欢迎来到本系列的第5部分。在上一个教程中，我们关注于构建我们的用户界面，设计我们的布局，并为我们的应用程序添加最少的功能。现在我们已经准备好了我们的UI，我们可以考虑让UX更好。</p><h1 id="671c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">之前的教程</h1><p id="7c2b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如果您是第一次阅读这一部分，那么您一定要看看本系列的第4部分。</p><ul class=""><li id="e587" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated"><a class="ae mi" href="https://github.com/rajtilakls2510/Stopwatch/tree/S4_Setting_up_the_UI_of_Swing_App" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">代号</strong> </a>直到现在。</li><li id="8714" class="lz ma iq ka b kb mj kf mk kj ml kn mm kr mn kv me mf mg mh bi translated"><a class="ae mi" href="https://rajtilakls2510.medium.com/starting-with-the-swing-app-part-4-7b9395a5960c" rel="noopener">第四部</a></li></ul></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="6315" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们的应用程序看起来像这样:</p><figure class="mw mx my mz gt jq gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/a1919158d598920a362bbd77cff3ee5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*DOBB0ipqr0qMAstvpEvH2w.png"/></div></figure><p id="8b3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们必须给用户开始，暂停，恢复和停止的功能。我们已经准备好了开始和停止按钮。所以这是一个优点。但是我们不想再做两个暂停和恢复的按钮。这将使我们的应用程序看起来非常非常丑陋。我们能做的是:当用户按下开始时，将开始按钮的功能改为暂停。这是因为用户在启动秒表后不需要启动按钮。类似地，当按下暂停按钮时，我们可以将按钮的功能更改为恢复。Stop按钮会一直在那里帮助用户重置秒表。</p><p id="3c2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们更清楚地了解一下这个东西:</p><ul class=""><li id="50fd" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">当我们的应用程序第一次启动时，它看起来像这样。</li></ul><figure class="mw mx my mz gt jq gh gi paragraph-image"><div class="gh gi na"><img src="../Images/09d4fae6210ce037e5f65662a01b1a2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*NngExWN25d_zjaX5esJk-A.png"/></div></figure><ul class=""><li id="ad9b" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">当用户按下start时，秒表将开始计时，Start按钮的名称将变为Pause。</li></ul><figure class="mw mx my mz gt jq gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/1e10e16d9a9f0b4f0ff7c1066a8dc91d.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*RnW5vEQASfSZFSrFpkWAsA.png"/></div></figure><ul class=""><li id="803b" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">当用户按下Pause时，秒表暂停，Pause按钮的名称更改为Resume。</li></ul><figure class="mw mx my mz gt jq gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/db56efe04e2394f29b979732e8239bf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*NQuvb-oj6elMdikL8Mborg.png"/></div></figure><ul class=""><li id="d3a2" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">在启动秒表后的任何时候，如果用户按下停止按钮，“计时器显示”将变为零，应用程序将返回到其初始状态。</li></ul><figure class="mw mx my mz gt jq gh gi paragraph-image"><div class="gh gi na"><img src="../Images/09d4fae6210ce037e5f65662a01b1a2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*NngExWN25d_zjaX5esJk-A.png"/></div></figure><p id="a884" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注:实际上，当用户处于初始状态时，我们不需要停止按钮。当然，用户不会试图停止已经复位的秒表。因此，我们也将从初始状态中删除停止按钮。我们的初始状态将是这样的:</p><figure class="mw mx my mz gt jq gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/e65925c06ccbec902d9d7d48ce6fec60.png" data-original-src="https://miro.medium.com/v2/resize:fit:458/format:webp/1*Y89TCjyYPHWaU4lkvUHQBA.png"/></div></figure><p id="0886" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意这里发生了什么。当用户按下任何按钮时，应用程序的状态都在变化。基于此，我准备了一个状态图。看看这个:</p><figure class="mw mx my mz gt jq gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ne"><img src="../Images/634b1ef262e23b6b65aa6eda932a8ec3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ag0L8fpt--aRLer5bHUUsg.png"/></div></div></figure><p id="5083" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个状态图显示了我们的应用程序的完整状态转换。有三种状态:</p><ul class=""><li id="de72" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated"><strong class="ka ir">未运行:</strong>这是秒表尚未启动的初始状态。</li><li id="9bc8" class="lz ma iq ka b kb mj kf mk kj ml kn mm kr mn kv me mf mg mh bi translated"><strong class="ka ir">运行:</strong>秒表运行时的状态。</li><li id="9f97" class="lz ma iq ka b kb mj kf mk kj ml kn mm kr mn kv me mf mg mh bi translated"><strong class="ka ir">暂停:</strong>秒表暂停时的状态。</li></ul><p id="caba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们开始编码吧。我们首先将这些状态添加到我们的应用程序中。状态将是带有一些值的正常整数。还将有一个“currentState”变量来保存秒表的当前状态。打开StopwatchSwing.java，将这些整数相加:</p><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="fe57" class="no kx iq nk b gy np nq l nr ns">public class StopwatchSwing implements Observer {<br/><br/>    ...<br/>    final int NOT_RUNNING=0, RUNNING=1, PAUSED=2;<br/>    int currentState;<br/>    ....</span><span id="c106" class="no kx iq nk b gy nt nq l nr ns">}</span></pre><p id="26a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意这里的<strong class="ka ir"> final </strong>关键字。最终的状态是我们不能在初始化后改变状态的值。这完全没问题，因为我们只需要通过名称来标识我们的州。</p><p id="0b44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当应用程序启动时，当前状态应该处于未运行状态。因此，在构造函数中，我们必须使currentState处于未运行状态。</p><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="cce5" class="no kx iq nk b gy np nq l nr ns">StopwatchSwing()<br/>{<br/>    currentState=NOT_RUNNING;<br/>    ...<br/><br/><br/>}</span></pre><p id="edcd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">主要问题是当用户按下开始按钮时。当用户按下开始按钮时，状态会随着用户界面和秒表的变化而不断变化。因此在handleStartPress()方法中我们必须处理各种各样的问题。第一个是识别当前状态。然后根据它采取一些行动。然后，改变状态。识别状态很容易:currentState已经保存了应用程序的当前状态，我们可以将它与我们的任何状态进行匹配。我们可以这样写。</p><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="fafa" class="no kx iq nk b gy np nq l nr ns">private void handleStartPress() {<br/>    if(currentState==NOT_RUNNING)<br/>    {<br/>    }<br/>    else if(currentState==RUNNING)<br/>    {<br/>    }<br/>    else if(currentState==PAUSED)<br/>    {<br/>    }<br/><br/>}</span></pre><p id="3f09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将正确识别当前状态并执行适当的块。接下来要做的是填满每一块积木。</p><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="6750" class="no kx iq nk b gy np nq l nr ns">private void handleStartPress() {<br/>    if(currentState==NOT_RUNNING)<br/>    {<br/>        sw =  new Stopwatch();<br/>        sw.registerObserver(this);<br/>        sw.start();<br/>        start.setText("Pause");<br/>        stop.setVisible(true);<br/>        currentState=RUNNING;<br/>    }<br/>    ....<br/><br/>}</span></pre><p id="c8af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当用户处于非运行状态时:</p><ul class=""><li id="aa87" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">我们正在创建一个新的秒表对象并注册一个观察者(可能看起来有点可疑，因为我们已经在构造函数中创建了一个秒表，但是当我们编写handleStopPress()方法时，您会理解我们为什么要这样做)。</li><li id="09ff" class="lz ma iq ka b kb mj kf mk kj ml kn mm kr mn kv me mf mg mh bi translated">然后，我们使用setText()方法将按钮的名称从开始更新为暂停。我们现在也使停止按钮可见。停止按钮直到现在才可见，因为用户在非运行状态下不需要它。</li><li id="5111" class="lz ma iq ka b kb mj kf mk kj ml kn mm kr mn kv me mf mg mh bi translated">最后，我们将状态更改为正在运行。</li></ul><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="37dc" class="no kx iq nk b gy np nq l nr ns">private void handleStartPress() {<br/>    ...<br/>    else if(currentState==RUNNING)<br/>    {<br/>        sw.stop();<br/>        start.setText("Resume");<br/>        currentState=PAUSED;<br/>    }<br/>    ...<br/><br/>}</span></pre><p id="26a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当用户处于运行状态并按下暂停(或开始)时:</p><ul class=""><li id="e640" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">我们使用秒表的stop方法暂停秒表。记住，我们可以通过稍后调用它的start()方法随时恢复秒表。</li><li id="7927" class="lz ma iq ka b kb mj kf mk kj ml kn mm kr mn kv me mf mg mh bi translated">我们将按钮的名称改为Resume。</li><li id="2757" class="lz ma iq ka b kb mj kf mk kj ml kn mm kr mn kv me mf mg mh bi translated">最后，我们将状态更改为暂停。</li></ul><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="72eb" class="no kx iq nk b gy np nq l nr ns">private void handleStartPress() {<br/>    ...<br/>    else if(currentState==PAUSED)<br/>    {<br/>        sw.start();<br/>        start.setText("Pause");<br/>        currentState=RUNNING;<br/>    }<br/><br/>}</span></pre><p id="2176" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当用户处于暂停状态并按下Resume(或Start)时:</p><ul class=""><li id="2f47" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">我们通过调用它的start()方法来恢复秒表。</li><li id="5e38" class="lz ma iq ka b kb mj kf mk kj ml kn mm kr mn kv me mf mg mh bi translated">我们将开始按钮的名称从继续改为暂停</li><li id="e4b4" class="lz ma iq ka b kb mj kf mk kj ml kn mm kr mn kv me mf mg mh bi translated">最后，我们将状态更改为正在运行。</li></ul><p id="d65b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你能考虑一下我们将如何处理停止新闻吗？我们重置秒表的唯一方法是创建一个新的对象。在应用程序的任何时候，当Stop按钮被按下时，我们将丢弃当前的秒表并制作一个新的。</p><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="9b74" class="no kx iq nk b gy np nq l nr ns">private void handleStopPress(){<br/>    if(sw!=null)<br/>        sw.stop();<br/>    sw = null;<br/>    timerDisplay.setText("Time: 000");<br/>    start.setText("Start");<br/>    stop.setVisible(false);<br/>    currentState=NOT_RUNNING;<br/>}</span></pre><p id="fbcc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当用户按下停止按钮时:</p><ul class=""><li id="2d16" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">我们首先丢弃秒表(sw=null)。如果秒表可用，我们调用它的stop()方法。<em class="nu">这很重要，因为秒表是在后台线程上运行的。如果我们不显式地停止它，线程将继续运行，直到应用程序关闭才会停止。因此，在丢弃一个秒表之前，我们必须调用它的stop()方法来停止它的后台线程。</em></li><li id="8deb" class="lz ma iq ka b kb mj kf mk kj ml kn mm kr mn kv me mf mg mh bi translated">接下来，我们初始化timerDisplay的文本，并将其设置为000。</li><li id="d464" class="lz ma iq ka b kb mj kf mk kj ml kn mm kr mn kv me mf mg mh bi translated">接下来，我们将开始按钮的文本改为开始。我们隐藏了停止按钮，因为用户不再需要它了。(当用户再次按下开始按钮时，它会返回)。</li><li id="fbc8" class="lz ma iq ka b kb mj kf mk kj ml kn mm kr mn kv me mf mg mh bi translated">最后，我们将状态更改为不运行。</li></ul><p id="711b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！我们要做一些清理工作，然后就可以开始了。</p><p id="6a58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">记住在创建Stop按钮后隐藏它，否则，当应用程序启动时，用户会看到它。</p><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="e7cf" class="no kx iq nk b gy np nq l nr ns">StopwatchSwing()<br/>{<br/>    ....<br/>    stop = new JButton("Stop");<br/>    stop.setVisible(false);<br/>    ...<br/><br/>}</span></pre><p id="4a5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很长时间以来，我们一直在延迟时间格式化函数。是时候写了。如果你写了你自己的，干得好。看看我的吧。</p><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="bd2c" class="no kx iq nk b gy np nq l nr ns">String formatTime(long time)<br/>{<br/>    int time1 = (int)time;<br/>    int milis=0, secs = 0, minutes = 0, hours = 0;<br/>    String formattedTime="";<br/><br/>    milis = time1%1000;<br/>    time1 = time1 / 1000;<br/>    secs = time1 % 60;<br/>    time1 = time1 / 60;<br/>    minutes = time1 % 60;<br/>    time1 = time1 / 60;<br/>    hours = time1 % 60;<br/><br/>    formattedTime = String.<em class="nu">format</em>("%02d", secs) + ":" +String.<em class="nu">format</em>("%03d", milis);<br/>    if(minutes&gt;0)<br/>        formattedTime = String.<em class="nu">format</em>("%02d", minutes) + ":" + formattedTime;<br/>    if(hours&gt;0)<br/>        formattedTime = String.<em class="nu">format</em>("%02d", hours) + ":" + formattedTime;<br/>    return formattedTime;<br/><br/>}</span></pre><p id="7c69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了formatter函数，我们可以在更新timerDisplay JLabel中的时间时使用它。</p><p id="cd83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在构造函数中，将“timer display”JLabel创建行替换为:</p><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="815c" class="no kx iq nk b gy np nq l nr ns">timerDisplay = new JLabel("Time: "+formatTime(0L));</span></pre><p id="6eed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在update()方法中，将timerDisplay setText()方法替换为:</p><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="dcf7" class="no kx iq nk b gy np nq l nr ns">timerDisplay.setText("Time: "+formatTime(time));</span></pre><p id="f6f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在handleStopPress()方法中，将setText()方法更新为:</p><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="5c06" class="no kx iq nk b gy np nq l nr ns">timerDisplay.setText("Time: "+formatTime(0L));</span></pre><p id="774b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！现在运行应用程序，看看所有的功能是否正常工作。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="0353" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我想让你最后看一下这段代码:</strong></p><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="1964" class="no kx iq nk b gy np nq l nr ns">if(currentState == NOT_RUNNING)<br/>{<br/>    sw = new Stopwatch();<br/>    sw.registerObserver(this);<br/>    sw.start();<br/>    start.setText("Pause");<br/>    stop.setVisible(true);<br/>    currentState=RUNNING;<br/>}<br/>else if(currentState == RUNNING)<br/>{<br/>    sw.stop();<br/>    start.setText("Resume");<br/>    currentState=PAUSED;<br/>}<br/>else if(currentState == PAUSED)<br/>{<br/>    sw.start();<br/>    start.setText("Pause");<br/>    currentState=RUNNING;<br/>}</span></pre><p id="3ebc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">这看起来不难看吗？太多的if-else语句，在这些语句中，我们所有的代码都是交错排列的。所有的陈述并不一致。我们在结构化程序中想要的只是一致性，而在这些代码中根本没有一致性。这告诉我，还有提升的空间。此外，当我们试图通过增加更多功能来扩展这个应用程序时，我们将会非常努力。我们能不能用一些很酷的OOP特性让这段代码保持一致？幸运的是，我们有另一种模式可以拯救我们:国家模式。我们将在下一个教程中看到这是什么。在那里见！</strong></p><h1 id="413a" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">下一个教程:</h1><p id="1e53" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><a class="ae mi" href="https://rajtilakls2510.medium.com/implementing-the-state-pattern-part-6-7631a532c0ea" rel="noopener">实现状态模式</a></p><h1 id="e1b5" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">完整代码</h1><p id="f3f3" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">完整的代码在这里。</p><p id="c0e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">StopwatchSwing.java</p><pre class="mw mx my mz gt nj nk nl nm aw nn bi"><span id="18ff" class="no kx iq nk b gy np nq l nr ns">import javax.swing.*;<br/>import java.awt.*;<br/>import java.awt.event.ActionEvent;<br/>import java.awt.event.ActionListener;<br/><br/>public class StopwatchSwing implements Observer {<br/><br/>    Stopwatch sw;<br/>    JFrame frame;<br/>    JPanel panel1, panel2;<br/>    JLabel timerDisplay;<br/>    JButton start, stop;<br/>    final int NOT_RUNNING=0, RUNNING=1, PAUSED=2;<br/>    int currentState;<br/><br/>    StopwatchSwing()<br/>    {<br/>        currentState=NOT_RUNNING;<br/>        sw = new Stopwatch();<br/>        sw.registerObserver(this);<br/><br/>        <em class="nu">// Initializing the JFrame<br/>        </em>frame = new JFrame("Stopwatch");<br/>        frame.setSize(300,300);<br/>        frame.setMinimumSize(new Dimension(300,300));<br/>        frame.setLayout(new GridLayout(2,1));<br/>        frame.setDefaultCloseOperation(JFrame.<em class="nu">EXIT_ON_CLOSE</em>);<br/><br/>        <em class="nu">// Setting Up Panels<br/>        </em>panel1 = new JPanel();<br/>        panel1.setLayout(new FlowLayout(FlowLayout.<em class="nu">CENTER</em>, 0, 50));<br/><br/>        timerDisplay = new JLabel("Time: "+formatTime(0L));<br/>        Font font = timerDisplay.getFont();<br/>        timerDisplay.setFont(new Font(font.getFontName(), font.getStyle(), 18));<br/><br/>        panel1.add(timerDisplay);<br/><br/><br/>        panel2 = new JPanel();<br/>        panel2.setLayout(new FlowLayout(FlowLayout.<em class="nu">CENTER</em>));<br/>        start = new JButton("Start");<br/>        stop = new JButton("Stop");<br/>        stop.setVisible(false);<br/>        panel2.add(start);<br/>        panel2.add(stop);<br/><br/>        frame.add(panel1);<br/>        frame.add(panel2);<br/><br/>        frame.setVisible(true);<br/><br/><br/>        <em class="nu">// Adding Listeners to the Buttons<br/><br/>        </em>start.addActionListener(new ActionListener() {<br/>            @Override<br/>            public void actionPerformed(ActionEvent e) {<br/>                handleStartPress();<br/>            }<br/>        });<br/><br/>        stop.addActionListener(new ActionListener() {<br/>            @Override<br/>            public void actionPerformed(ActionEvent e) {<br/>                handleStopPress();<br/>            }<br/>        });<br/><br/><br/>    }<br/><br/>    private void handleStartPress() {<br/>        if(currentState==NOT_RUNNING)<br/>        {<br/>            sw =  new Stopwatch();<br/>            sw.registerObserver(this);<br/>            sw.start();<br/>            start.setText("Pause");<br/>            stop.setVisible(true);<br/>            currentState=RUNNING;<br/>        }<br/>        else if(currentState==RUNNING)<br/>        {<br/>            sw.stop();<br/>            start.setText("Resume");<br/>            currentState=PAUSED;<br/>        }<br/>        else if(currentState==PAUSED)<br/>        {<br/>            sw.start();<br/>            start.setText("Pause");<br/>            currentState=RUNNING;<br/>        }<br/><br/>    }<br/>    private void handleStopPress(){<br/>        if(sw!=null)<br/>            sw.stop();<br/>        sw = null;<br/>        timerDisplay.setText("Time: "+formatTime(0L));<br/>        start.setText("Start");<br/>        stop.setVisible(false);<br/>        currentState=NOT_RUNNING;<br/>    }<br/><br/>    public static void main(String[] args) {<br/>        SwingUtilities.<em class="nu">invokeLater</em>(new Runnable() {<br/>            @Override<br/>            public void run() {<br/>                new StopwatchSwing();<br/>            }<br/>        });<br/>    }<br/><br/>    String formatTime(long time)<br/>    {<br/>        int time1 = (int)time;<br/>        int milis=0, secs = 0, minutes = 0, hours = 0;<br/>        String formattedTime="";<br/><br/>        milis = time1%1000;<br/>        time1 = time1 / 1000;<br/>        secs = time1 % 60;<br/>        time1 = time1 / 60;<br/>        minutes = time1 % 60;<br/>        time1 = time1 / 60;<br/>        hours = time1 % 60;<br/><br/>        formattedTime = String.<em class="nu">format</em>("%02d", secs) + ":" +String.<em class="nu">format</em>("%03d", milis);<br/>        if(minutes&gt;0)<br/>            formattedTime = String.<em class="nu">format</em>("%02d", minutes) + ":" + formattedTime;<br/>        if(hours&gt;0)<br/>            formattedTime = String.<em class="nu">format</em>("%02d", hours) + ":" + formattedTime;<br/>        return formattedTime;<br/><br/>    }<br/>    @Override<br/>    public void update(long time) {<br/>        timerDisplay.setText("Time: "+formatTime(time));<br/>    }<br/>}</span></pre><h1 id="a563" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">参考资料:</h1><ul class=""><li id="9f89" class="lz ma iq ka b kb lu kf lv kj nv kn nw kr nx kv me mf mg mh bi translated">书:<a class="ae mi" href="https://www.oreilly.com/library/view/head-first-design/0596007124/" rel="noopener ugc nofollow" target="_blank"> Head First设计模式</a>，作者埃里克·弗里曼、伊丽莎白·罗布森、伯特·贝茨、凯西·塞拉。</li></ul></div></div>    
</body>
</html>