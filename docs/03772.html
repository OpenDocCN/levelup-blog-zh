<html>
<head>
<title>How to Pay People In Ruby!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Ruby给人发工资！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-pay-people-in-ruby-108f76519a22?source=collection_archive---------15-----------------------#2020-05-26">https://levelup.gitconnected.com/how-to-pay-people-in-ruby-108f76519a22?source=collection_archive---------15-----------------------#2020-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7285" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编码问题演练。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/cf912904b667963cca1f5514a293b46f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/0*bR8jkbTxOj-WeY80.jpg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">哦，克莱伯先生，你是一个普通的史高治·麦克老鸭。</figcaption></figure><p id="7b8e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像大多数初级开发人员一样，我正在找工作，找工作包括很多代码挑战。现在，技术上来说，<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/hourglass-sums-in-two-dimensional-arrays-the-stonecutters-handshake-of-programming-87b6bebc3bad?source=---------7------------------">在我取笑了我做的最后一个代码挑战</a>之后，它确实出现在一家FAANG公司的面试中。所以我自己可能也在金星化。</p><p id="e88e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是这个代码挑战是一个非常实际的例子。它还特别要求我使用Ruby，因为这是公司的堆栈。为了不起诉我，一些变量被改变了。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="3a6c" class="lw lx it ls b gy ly lz l ma mb">Given an array of people we have to pay with an amount of money that would be sent to a popular payment API like Stripe or Braintree, organize each payment into a separate group so that each transaction can be grouped with another transaction from a different person, but not two of the same. </span><span id="439a" class="lw lx it ls b gy mc lz l ma mb">Also take in as an optional argument a maximum group size for a group of payments in case we need that with a default size of 100.</span></pre><p id="6e81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这看起来很简单，但结果比我想象的要复杂一点。首先，我们有这样的东西:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="f7ca" class="lw lx it ls b gy ly lz l ma mb">module PayPeople</span><span id="da79" class="lw lx it ls b gy mc lz l ma mb">end</span></pre><p id="4d5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们知道，我们将需要一些东西来支付模块内的人员，并接受一个数组和一个可选的<code class="fe md me mf ls b">max_group_size</code>。</p><p id="85b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以现在我们有了这样的东西:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="a08b" class="lw lx it ls b gy ly lz l ma mb">module PayPeople</span><span id="44c8" class="lw lx it ls b gy mc lz l ma mb">  def self.group_payments(pay_array, max_group_size=100)</span><span id="8bb6" class="lw lx it ls b gy mc lz l ma mb">  end</span><span id="5fc1" class="lw lx it ls b gy mc lz l ma mb">end</span></pre><p id="e647" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">进步！但是我们仍然没有对我们的论点做任何事情。</p><p id="5f58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">旁白:我们使用<em class="mg"> self </em>关键字，因为这是<a class="ae lq" href="https://ruby-doc.com/docs/ProgrammingRuby/html/tut_modules.html" rel="noopener ugc nofollow" target="_blank">一个Ruby模块，我们可以调用属于单个文件</a>的一组方法，但是我们可以通过一些导入语法在整个应用程序中调用它们。</p><p id="fed9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当考虑一个问题时，我喜欢先考虑在函数结束时我将返回什么，这将是一个数组，因为我们将一个支付列表分成不同的组。我知道至少会有一个小组在那里，假设我们正在处理一些付款。所以我会像这样给我的返回变量赋值。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="1fa7" class="lw lx it ls b gy ly lz l ma mb">module PayPeople</span><span id="0a86" class="lw lx it ls b gy mc lz l ma mb">  def self.group_payments(pay_array, max_group_size=100)</span><span id="9e8c" class="lw lx it ls b gy mc lz l ma mb">    final = [[]] # an array of arrays</span><span id="5c7c" class="lw lx it ls b gy mc lz l ma mb">      #do stuff here</span><span id="cc9c" class="lw lx it ls b gy mc lz l ma mb">    final # the last line of a Ruby method is what is returned.</span><span id="e0d9" class="lw lx it ls b gy mc lz l ma mb">  end</span><span id="0981" class="lw lx it ls b gy mc lz l ma mb">end</span></pre><p id="32ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好了，更进步了！我们现在有了一个<em class="mg">结构</em>，它包含了函数接受和返回的内容。现在让我们想想我们在做什么。嗯，我知道我要在一个对象或散列数组上循环来检查每一个，所以在Ruby中有一种方法可以用<em class="mg">来完成。每个</em>语法。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="c77b" class="lw lx it ls b gy ly lz l ma mb">module PayPeople</span><span id="7fe7" class="lw lx it ls b gy mc lz l ma mb">  def self.group_payments(pay_array, max_group_size=100) </span><span id="0aa7" class="lw lx it ls b gy mc lz l ma mb">    final = [[]] # an array of arrays</span><span id="aee3" class="lw lx it ls b gy mc lz l ma mb">    pay_array.each do |payment|</span><span id="0e8c" class="lw lx it ls b gy mc lz l ma mb"># do something with the payment here</span><span id="1688" class="lw lx it ls b gy mc lz l ma mb">    end</span><span id="4888" class="lw lx it ls b gy mc lz l ma mb">    final # the last line of a Ruby method is what is returned.</span><span id="e3a2" class="lw lx it ls b gy mc lz l ma mb">  end</span><span id="182b" class="lw lx it ls b gy mc lz l ma mb">end</span></pre><p id="cca1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好吧，酷，所以我们现在可以访问每笔付款。但是我们需要查看用户/电子邮件是否已经在支付数组中，所以我们需要第二个循环！在这个例子中，我们必须检查最终数组中的每个<em class="mg">数组，看看用户是否已经在其中。这次我将使用一个<em class="mg"> for/in </em>循环:</em></p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="db5b" class="lw lx it ls b gy ly lz l ma mb">module PayPeople</span><span id="8dd1" class="lw lx it ls b gy mc lz l ma mb">  def self.group_payments(pay_array, max_group_size=100)</span><span id="e40f" class="lw lx it ls b gy mc lz l ma mb">    final = [[]] # an array of arrays</span><span id="cdf5" class="lw lx it ls b gy mc lz l ma mb">    pay_array.each do |payment|</span><span id="715c" class="lw lx it ls b gy mc lz l ma mb">      for arr in final do <br/>        # for each array in our final array do something</span><span id="f280" class="lw lx it ls b gy mc lz l ma mb">      end    </span><span id="9b13" class="lw lx it ls b gy mc lz l ma mb">    end</span><span id="26fa" class="lw lx it ls b gy mc lz l ma mb">    final # the last line of a Ruby method is what is returned.</span><span id="a92f" class="lw lx it ls b gy mc lz l ma mb">  end</span><span id="eb0f" class="lw lx it ls b gy mc lz l ma mb">end</span></pre><p id="0d75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好了，现在我们越来越接近了，我们的代码越来越乱。我们将需要一个<em class="mg"> if/else语句</em>来查看付款是否已经在我们最终数组中的数组组中，但是我没有在那里写大部分逻辑，而是决定写第二个<em class="mg"> helper方法</em>来使这变得更容易，如果您的代码在受压的情况下变得混乱，我推荐这种技术。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="d7c9" class="lw lx it ls b gy ly lz l ma mb">module PayPeople</span><span id="ec0e" class="lw lx it ls b gy mc lz l ma mb">  def self.group_payments(pay_array, max_group_size=100)</span><span id="cc66" class="lw lx it ls b gy mc lz l ma mb">    final = [[]] # an array of arrays</span><span id="115f" class="lw lx it ls b gy mc lz l ma mb">    pay_array.each do |payment|</span><span id="4aa1" class="lw lx it ls b gy mc lz l ma mb">      for arr in final do <br/>        # for each array in our final array do something</span><span id="f69f" class="lw lx it ls b gy mc lz l ma mb">      end</span><span id="6dcd" class="lw lx it ls b gy mc lz l ma mb">    end</span><span id="12ce" class="lw lx it ls b gy mc lz l ma mb">    final # the last line of a Ruby method is what is returned.</span><span id="8b45" class="lw lx it ls b gy mc lz l ma mb">  end</span><span id="ce38" class="lw lx it ls b gy mc lz l ma mb">  # new stuff</span><span id="5d21" class="lw lx it ls b gy mc lz l ma mb">  def self.isEmailThere?(array, email)</span><span id="60af" class="lw lx it ls b gy mc lz l ma mb">  # let's check for an email!</span><span id="2c4d" class="lw lx it ls b gy mc lz l ma mb">  end</span><span id="e327" class="lw lx it ls b gy mc lz l ma mb">end</span></pre><p id="15a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">酷，所以我们现在有第二个方法要用，在这里我将使用一些奇特的语法和<em class="mg"> include？</em>法。请注意，我的助手函数有一个“？”因为按照Ruby的惯例，像我们这样返回布尔值的函数通常会以“？”结尾</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="c06a" class="lw lx it ls b gy ly lz l ma mb">def self.isEmailThere?(array, email)</span><span id="6ca0" class="lw lx it ls b gy mc lz l ma mb">  array.map{|payment| payment[:email]}.include?(email)</span><span id="7aa4" class="lw lx it ls b gy mc lz l ma mb">end</span></pre><p id="57f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这表示对于每个数组，对于数组中的每笔支付，我们将检查电子邮件是否包含我们传入的电子邮件。我们通过将我们的支付数组改为电子邮件数组，然后查看我们的电子邮件是否在其中来做到这一点。</p><p id="9081" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们快完成了！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="012a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们必须考虑的唯一事情是最大组大小以及我们将要做的事情，即<em class="mg">将</em>推入哪个阵列。最终的代码会是这样的！</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="edd0" class="lw lx it ls b gy ly lz l ma mb">module PayPeople</span><span id="f2d9" class="lw lx it ls b gy mc lz l ma mb">  def self.group_payments(pay_array, max_group_size=100)</span><span id="d253" class="lw lx it ls b gy mc lz l ma mb">    final = [[]] # an array of arrays</span><span id="d6e8" class="lw lx it ls b gy mc lz l ma mb">    pay_array.each do |payment|</span><span id="54f9" class="lw lx it ls b gy mc lz l ma mb">      for arr in final do </span><span id="2a3f" class="lw lx it ls b gy mc lz l ma mb">        if !PayPeople.isEmailThere?(arr, payment[:email]) &amp;&amp; arr.length &lt; max_group_size</span><span id="d343" class="lw lx it ls b gy mc lz l ma mb">          arr.push(payout)</span><span id="afe8" class="lw lx it ls b gy mc lz l ma mb">          break</span><span id="f4c5" class="lw lx it ls b gy mc lz l ma mb">        else</span><span id="7ad1" class="lw lx it ls b gy mc lz l ma mb">          final.push([payment])</span><span id="a18c" class="lw lx it ls b gy mc lz l ma mb">          break</span><span id="2709" class="lw lx it ls b gy mc lz l ma mb">        end</span><span id="6e37" class="lw lx it ls b gy mc lz l ma mb">      end</span><span id="4ef6" class="lw lx it ls b gy mc lz l ma mb">     end</span><span id="c599" class="lw lx it ls b gy mc lz l ma mb">     final </span><span id="4f25" class="lw lx it ls b gy mc lz l ma mb">    end</span><span id="bb29" class="lw lx it ls b gy mc lz l ma mb">    def self.isEmailThere?(array, email)</span><span id="504e" class="lw lx it ls b gy mc lz l ma mb">      array.map{|payment| payment[:email]}.include?(email)</span><span id="51c7" class="lw lx it ls b gy mc lz l ma mb">  end</span><span id="7ae3" class="lw lx it ls b gy mc lz l ma mb">end</span></pre><p id="9195" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有很多“如果”和“结束”的话，但基本上是说，如果<code class="fe md me mf ls b">final</code>中的数组不包括当前的电子邮件，并且足够小，那么让我们将支付信息推入其中，否则，将它推入一个新的数组中！</p><p id="2366" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个示例输入可能看起来像:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="f086" class="lw lx it ls b gy ly lz l ma mb">example = [</span><span id="00c3" class="lw lx it ls b gy mc lz l ma mb">{ email: "bob@example.com", amount: 400 },</span><span id="c3c3" class="lw lx it ls b gy mc lz l ma mb">{ email: "susan@example.com", amount: 8000 },</span><span id="8eba" class="lw lx it ls b gy mc lz l ma mb">{ email: "bob@example.com", amount: 400 },</span><span id="5000" class="lw lx it ls b gy mc lz l ma mb">{ email: "alan@example.com", amount: 300 },</span><span id="ffe2" class="lw lx it ls b gy mc lz l ma mb">{ email: "alan@example.com", amount: 12 },</span><span id="bcc5" class="lw lx it ls b gy mc lz l ma mb">{ email: "dana@example.com", amount: 675 }</span><span id="3a99" class="lw lx it ls b gy mc lz l ma mb">]</span></pre><p id="8bb8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">示例输出可能如下所示:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="6615" class="lw lx it ls b gy ly lz l ma mb">[[{:email=&gt;"bob@example.com", :amount=&gt;400}, {:email=&gt;"susan@example.com", :amount=&gt;8000}, {:email=&gt;"alan@example.com", :amount=&gt;300}, {:email=&gt;"dana@example.com", :amount=&gt;675}], [{:email=&gt;"bob@example.com", :amount=&gt;400}], [{:email=&gt;"alan@example.com", :amount=&gt;12}]]</span></pre><p id="74a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们有两个“Bob”和两个“Alan ”,所以它们被放入两个不同的数组中。成功！</p><p id="ff59" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从时间角度来看，这不是一个非常好的解决方案。我通过放入<em class="mg"> break </em>语句对其进行了一些改进，这样一旦我们的插入完成，我们就可以停止对每笔支付的循环，但这仍然是指数时间的大O倍 这意味着它不是这个问题的“快速”解决方案，因为随着输入大小变大，它将变得越来越复杂。</p><p id="d9ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果有人有更快/更酷的解决方案，请在评论中告诉我；)</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="5702" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">说到快和酷，我想我在展望公园遇到的游侠两者都是。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mq"><img src="../Images/146e571071cf6a53eee9ea794ff5e5dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*unUjwJtHEri-nyjMlJQlTg.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">游侠！</figcaption></figure><p id="a129" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，从这张照片上你不会这么做，但是护林员是一个真正的公园护林员，所以他知道什么时候该坐下来等待。</p><p id="b2de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">他有速度和纪律来解决困难的编码问题，或者至少，拥抱我的心。</p><p id="1300" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在就白了！</p><p id="1af8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">网络信息中心(Network Information Center)ˌ网路界面卡(Network Interface Card)ˌ全国工业理事会(National Industrial Council)ˌ航行情报中心(Navigation Information Center)</p></div></div>    
</body>
</html>