<html>
<head>
<title>Basics of the Combine framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">联合收割机框架的基础</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/basics-of-combine-framework-64dbd18da341?source=collection_archive---------8-----------------------#2020-03-23">https://levelup.gitconnected.com/basics-of-combine-framework-64dbd18da341?source=collection_archive---------8-----------------------#2020-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5f06" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">带有图形示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d06866b9abfcfcbca99641730c82de7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ctlXcDMArs0-14gQCtNUEQ.png"/></div></div></figure><p id="1e6b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文介绍了Combine的基础知识，这是一个框架，允许您编写可靠、安全且经过良好测试的异步代码。在这篇文章中，我们将集中讨论它的理论基础和关键点，并提供图形示例。在编写任何一行异步代码之前，这是必不可少的。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="8ab8" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated"><strong class="ak">首先:异步代码</strong></h1><p id="34f8" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">如果我们查看苹果文档，我们会发现以下关于Combine的描述:<em class="mu">“通过组合事件处理操作符来定制异步事件的处理”。实际上这非常准确，但是如果你开始使用Combine，它可能会有点复杂或抽象。这样，让我们从异步代码的概念开始。</em></p><p id="515c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，同步运行的程序按顺序执行它的代码行。结帐如下例。只有一个执行线程，因此您很容易知道数据的状态。在这种情况下，输出将是<code class="fe mv mw mx my b">2</code>。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="21ea" class="nd ly it my b gy ne nf l ng nh"><strong class="my iu">var</strong> myNumber = 1<br/>myNumber+=1<br/>print(myNumber)</span></pre><p id="339d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在创建前面代码的异步版本。在这种情况下，我们将随机安排代码行。代码在不同的内核上并发运行，因此我们每次执行代码时都会得到不同的结果。有时它打印<code class="fe mv mw mx my b">1</code>，有时打印<code class="fe mv mw mx my b">2</code>。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="b274" class="nd ly it my b gy ne nf l ng nh"><strong class="my iu">var</strong> myNumber = 1<br/><strong class="my iu">let</strong> randomDeadline = .now() + Double.random(in: 1.0...5.0)<br/><strong class="my iu">let</strong> anotherRandomDeadline = .now() + Double.random(in: 1.0...5.0)</span><span id="fd6b" class="nd ly it my b gy ni nf l ng nh">DispatchQueue.main.asyncAfter(deadline: randomDeadline) {<br/>    myNumber+=1<br/>}</span><span id="d8e2" class="nd ly it my b gy ni nf l ng nh">DispatchQueue.main.asyncAfter(deadline: anotherRandomDeadline) {<br/>    print(myNumber)<br/>}</span></pre><p id="e642" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意</strong>:您可以在Xcode Playground中运行代码行来测试它。</p><h1 id="3e90" class="lx ly it bd lz ma nj mc md me nk mg mh jz nl ka mj kc nm kd ml kf nn kg mn mo bi translated">处理异步代码的传统方式</h1><p id="2b66" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">到目前为止，Swift为我们提供了几种处理异步事件的方法。我们已经有了一些功能，如闭包、作为委托或通知的设计模式，甚至其他框架(如GCD)。</p><p id="18d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有这些工具帮助我们正确地实现异步代码，同时我们遵循良好的实践。然而，当我们同时使用所有不同种类的异步API时，问题就来了。如下图所示的场景。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/813aadb1ca709925daffabcb40e0ede4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0NzSkJ8EDWaY644isFJ5Pg.png"/></div></div></figure><p id="48dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些元素共享数据状态。在这种情况下，异步代码和资源共享会产生难以重现、追踪和最终修复的问题。</p><p id="ed82" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是Combine出现的地方，它提供了这些问题的解决方案。Combine集成在Swift生态系统中，处理所有流程，以组织这种异步环境。所以让我们从基础开始。</p><h1 id="5e6b" class="lx ly it bd lz ma nj mc md me nk mg mh jz nl ka mj kc nm kd ml kf nn kg mn mo bi translated">组合要素</h1><p id="ef00" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">Combine为我们提供了几个实现异步代码的元素，但主要的是:发布者、操作者和订阅者。将所有这些放在一起，我们可以制作函数链，将值从一个传递到另一个。这创建了从输入流向输出的<em class="mu">流</em>值。</p><h2 id="a4d6" class="nd ly it bd lz np nq dn md nr ns dp mh ld nt nu mj lh nv nw ml ll nx ny mn nz bi translated">出版商</h2><p id="0c96" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">它们可以随着时间的推移释放出价值。这些值由订户实例使用。通过这种方式，发布者可以发出以下几种类型的事件:</p><ul class=""><li id="5b5f" class="oa ob it kw b kx ky la lb ld oc lh od ll oe lp of og oh oi bi translated">发布者的输出值，那是一个通用的<code class="fe mv mw mx my b">Output</code>类型。</li><li id="3421" class="oa ob it kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated">成功的完成</li><li id="04d0" class="oa ob it kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated">错误完成。键入它可能发布的内容。</li></ul><p id="1ece" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些<code class="fe mv mw mx my b">Output</code>和<code class="fe mv mw mx my b">Failure</code>类型包含在发布者遵循的协议中。此外，请注意，发布者可以发出零个或多个<code class="fe mv mw mx my b">Output</code>值，但只能完成一次。一旦发送出去，发布者就结束它的活动。</p><p id="9ce0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除此之外，发布者实现了<code class="fe mv mw mx my b">receive(subscriber:)</code>方法来连接订阅者。换句话说，发布者的输出与订阅者的输入相匹配，对于失败类型也是如此。</p><p id="106f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，假设在一个发布器中，每秒钟都会发出一组斐波纳契数列。类似于:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/7a0a6d323ff19100fc3932759f68adea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OgTirDANuaJawMIGp7YEPA.png"/></div></div></figure><h2 id="c26e" class="nd ly it bd lz np nq dn md nr ns dp mh ld nt nu mj lh nv nw ml ll nx ny mn nz bi translated">经营者</h2><p id="2dca" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">在发布者协议上声明的特殊方法返回另一个发布者。它们有输入/输出和错误处理。除此之外，它们可以被组合(😉)制作运算符链来实现复杂的逻辑。</p><p id="cfc7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种创建和连接异步元素的方式避免了数据的共享状态。那个问题以前评论过。</p><p id="4af4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">继续Fibonacci publisher的例子，我们可以有两个操作符将<code class="fe mv mw mx my b">&lt;Int, Error&gt;</code>输入转换为<code class="fe mv mw mx my b">&lt;String, Never&gt;</code>输出。那个<code class="fe mv mw mx my b">String</code>可以是斐波纳契数及其表示(即<code class="fe mv mw mx my b">"F(8) = 21"</code>):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/9d40263416f50c641204f001327816b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2LC4iujgz-f2j2Oq73Qiqg.png"/></div></div></figure><p id="e26a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意</strong>:一个<code class="fe mv mw mx my b">Failure</code>是<code class="fe mv mw mx my b">Never</code>类型的发布者意味着它不会失败。</p><h2 id="69b6" class="nd ly it bd lz np nq dn md nr ns dp mh ld nt nu mj lh nv nw ml ll nx ny mn nz bi translated">订阅者</h2><p id="b034" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">任何这些出版商和运营商链最终都有一个订户。它接收这些值。Combine提供两个内置订户:</p><ul class=""><li id="a9a6" class="oa ob it kw b kx ky la lb ld oc lh od ll oe lp of og oh oi bi translated"><code class="fe mv mw mx my b">sink(receiveCompletion:receiveValue:)</code>:使用os闭包处理接收到的元素和完成事件。</li><li id="3762" class="oa ob it kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated"><code class="fe mv mw mx my b">assign(to:on:)</code>:绑定在数据模型的属性或UI控件上接收的元素。该属性由密钥路径标识。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/1385ad9c970efff4b385dc4d8a40333f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lfX6imklzZEGKHDJQRHX4A.png"/></div></div></figure><h1 id="2081" class="lx ly it bd lz ma nj mc md me nk mg mh jz nl ka mj kc nm kd ml kf nn kg mn mo bi translated">组合与传统方法</h1><p id="5126" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">正如我们之前看到的，Swift已经拥有足够的工具来开发能够正确处理所有与异步流程相关的应用程序。然而，和许多其他框架一样，Combine为异步代码提供了额外的抽象。这个额外的一层比我们提出的任何其他解决方案都更加高效、安全且经过充分测试，原因如下:</p><ul class=""><li id="370c" class="oa ob it kw b kx ky la lb ld oc lh od ll oe lp of og oh oi bi translated">Combine是系统级的，所以它使用了我们作为开发者无法接触到的特性。</li><li id="1ac1" class="oa ob it kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated">异步代码使用相同的接口。您可以轻松提高代码的组合性、可伸缩性和可重用性。</li><li id="8bd1" class="oa ob it kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated">非组合方法意味着使用几种解决方案(闭包、委托、分派……)。将所有这些复杂性结合起来。</li><li id="b388" class="oa ob it kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated">这种抽象是由操作者提供的。它们是高度可组合的，这使得我们可以轻松地实现复杂的逻辑。</li></ul><h1 id="8835" class="lx ly it bd lz ma nj mc md me nk mg mh jz nl ka mj kc nm kd ml kf nn kg mn mo bi translated">结论</h1><p id="ae2e" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">如您所见，Combine为我们提供了许多关于当前解决方案的工具。此时，我们应该考虑将这个框架集成到我们的项目中。请注意，这并不意味着改变你的应用程序结构和删除所有已完成的工作。组合可以集成为部分和迭代的方式。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="d4f1" class="nd ly it bd lz np nq dn md nr ns dp mh ld nt nu mj lh nv nw ml ll nx ny mn nz bi translated">资源:</h2><ul class=""><li id="e26b" class="oa ob it kw b kx mp la mq ld or lh os ll ot lp of og oh oi bi translated">Combine:使用Swift进行异步编程(<a class="ae ou" href="https://store.raywenderlich.com/products/combine-asynchronous-programming-with-swift" rel="noopener ugc nofollow" target="_blank">https://store . raywenderlich . com/products/combine-Asynchronous-Programming-with-Swift</a>)</li><li id="f9e9" class="oa ob it kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated">https://developer.apple.com/documentation/combine<a class="ae ou" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank"/></li><li id="c8cc" class="oa ob it kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated"><a class="ae ou" href="https://www.vadimbulavin.com/swift-combine-framework-tutorial-getting-started/" rel="noopener ugc nofollow" target="_blank">https://www . vadimbulavin . com/swift-combine-framework-tutorial-getting-started/</a></li></ul></div></div>    
</body>
</html>