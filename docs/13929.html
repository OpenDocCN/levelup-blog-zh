<html>
<head>
<title>Implementing Cursor-based Pagination for Every GraphQL API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为每个GraphQL API实现基于光标的分页</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-cursor-based-pagination-for-every-graphql-api-3bcdcd9cc4bd?source=collection_archive---------24-----------------------#2022-10-17">https://levelup.gitconnected.com/implementing-cursor-based-pagination-for-every-graphql-api-3bcdcd9cc4bd?source=collection_archive---------24-----------------------#2022-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/50ba410aacf6743e53ba41faec3237ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DVDf5MAWJD_iq230.png"/></div></div></figure><p id="2737" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">后端通常会返回大量数据，同时获取所有数据会导致更多开销并增加响应时间。分页通过在后续请求中接收小块数据来保持应用程序的性能，直到接收到整个数据集。</p><p id="ad79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当脸书公开发布GraphQL作为一种客户端驱动的基于API的查询语言时，它迅速得到了大肆宣传，因为它允许前端开发人员轻松修改他们的后端。使用GraphQL的应用程序效率更高，可以在慢速网络上快速工作，因此，它正在迅速取代REST等传统API架构。分页是GraphQL中的一个基本概念，但是GraphQL中关于分页的资源并不多。</p><p id="f5c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将比较在GraphQL中处理分页的不同方式，并学习如何使用StepZen配置REST指令来为每个REST API执行基于光标的分页。</p><blockquote class="kw kx ky"><p id="48a6" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka ir">TL；DR </strong>:你可以在这里找到使用StepZen <a class="ae ld" href="https://stepzen.com/docs/connecting-backends/rest-services-graphql-pagination" rel="noopener ugc nofollow" target="_blank">分页GraphQL的完整文档。</a></p></blockquote><h2 id="09c7" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">比较GraphQL中不同的分页方法</h2><p id="66a4" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">GraphQL中的分页与REST APIs中的分页没有什么不同，尽管某些类型的分页更适合GraphQL。在讨论GraphQL中首选的分页方法之前，我们先来看看不同的分页类型。通常，API提供了三种分页方法。这些是:</p><ul class=""><li id="6052" class="mc md iq ka b kb kc kf kg kj me kn mf kr mg kv mh mi mj mk bi translated"><a class="ae ld" href="https://stepzen.com/blog#1-offset-pagination" rel="noopener ugc nofollow" target="_blank">胶印分页</a></li><li id="8481" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated"><a class="ae ld" href="https://stepzen.com/blog#2-page-number-pagination" rel="noopener ugc nofollow" target="_blank">页码分页</a></li><li id="155e" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated"><a class="ae ld" href="https://stepzen.com/blog#3-cursor-pagination" rel="noopener ugc nofollow" target="_blank">光标分页</a></li></ul><h2 id="969d" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">1.偏移分页</h2><p id="1b41" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">偏移量分页由两个主要参数组成:limit和Offset。该限制表示要显示的最大结果数。偏移量表示列表中分页开始的位置。</p><p id="682f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设您有一个100名学生的列表。如果将limit参数设置为10，offset参数设置为20，则数据库引擎将从第20个学生开始计数，并在每次迭代中显示接下来的10个学生。例如，第一次迭代将显示学生从20岁到30岁，然后从30岁到40岁，等等。</p><p id="0928" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然偏移分页是最直接的方法，但是它有一个很大的缺点。当添加或删除某些项时，偏移分页会导致重复或丢失数据值。</p><p id="9ba3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">优点:</strong></p><ul class=""><li id="b144" class="mc md iq ka b kb kc kf kg kj me kn mf kr mg kv mh mi mj mk bi translated">通常最常用的分页方式。</li><li id="0fbe" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">实现相对简单。</li><li id="6fde" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">大多数基于SQL的数据库支持limit和offset变量，因此映射值更容易。</li></ul><p id="3fdc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">缺点:</strong></p><ul class=""><li id="7c51" class="mc md iq ka b kb kc kf kg kj me kn mf kr mg kv mh mi mj mk bi translated">容易出现数据不一致(数据重复或缺失)。</li><li id="05fe" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">它不提供关于更多页面、总页面或检索以前页面的信息。</li></ul><h2 id="ca58" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">2.页码分页</h2><p id="bb10" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">顾名思义，页码分页为每个请求返回一页。在处理表格时，你们都见过“下一页”选项；每张表显示相同数量的结果或条目。类似地，页码分页为每个请求返回相同数量的结果。</p><p id="5673" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们举个例子来了解一下它的工作原理。页码分页使用after参数来指示分页的起点。例如，如果您有一个30名学生的列表，并将after和limit参数分别设置为23和5，那么输出列表将显示从第23到第28个条目的5名学生的列表。</p><p id="bf43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">页码分页更加可靠，因为即将到来的结果是从最后获取的值开始的。</p><p id="6fb8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">优点:</strong></p><ul class=""><li id="b54a" class="mc md iq ka b kb kc kf kg kj me kn mf kr mg kv mh mi mj mk bi translated">更容易实现。</li><li id="a30b" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">不需要复杂的逻辑分析。</li></ul><p id="531d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">缺点:</strong></p><ul class=""><li id="7ff5" class="mc md iq ka b kb kc kf kg kj me kn mf kr mg kv mh mi mj mk bi translated">数据不一致。</li></ul><h2 id="1135" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">3.光标分页</h2><p id="f09d" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">第三种分页是基于光标的分页。然而，它是最复杂的，但适用于动态数据。因此，这是在GraphQL中进行分页的首选方式。</p><p id="d360" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此方法包括光标的特定参数。游标只是一个参考点，它显示了数据库中某项的位置。在图形表示中，数据表示为节点，光标表示为边。</p><p id="4627" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">游标是一个base64编码的数字。为基于光标的分页编写的查询返回一个对象表示，而不是一个列表。</p><p id="ecd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">优点:</strong></p><ul class=""><li id="8b9e" class="mc md iq ka b kb kc kf kg kj me kn mf kr mg kv mh mi mj mk bi translated">在GraphQL中进行分页的首选方式。</li><li id="1598" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">为UX的使用提供了有价值的数据。</li><li id="de55" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">允许反向分页。</li><li id="e2a3" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">在动态数据的情况下没有问题，因为分页是针对特定的行进行的。</li></ul><p id="7d2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">缺点:</strong></p><ul class=""><li id="c1f9" class="mc md iq ka b kb kc kf kg kj me kn mf kr mg kv mh mi mj mk bi translated">它不允许随机访问。</li><li id="08e0" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">需要复杂的查询。</li></ul><h2 id="e82c" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">如何使用StepZen在GraphQL中实现分页</h2><p id="1d49" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">现在您已经了解了所有可能的分页方法，以及在GraphQL中进行分页的首选方式，即基于光标的分页。如果您的REST API支持偏移量或页码分页，那么您可以使用StepZen在GraphQL中轻松实现基于光标的分页。</p><p id="1e66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您需要为每种分页类型指定的两个基本参数是<code class="fe mq mr ms mt b">type</code>和<code class="fe mq mr ms mt b">setters</code>。<code class="fe mq mr ms mt b">type</code>参数定义了您想要实现的分页样式。它有三个可能的值:<code class="fe mq mr ms mt b">PAGE_NUMBER</code>、<code class="fe mq mr ms mt b">OFFSET</code>和<code class="fe mq mr ms mt b">NEXT_CURSOR</code>。接下来是<code class="fe mq mr ms mt b">setters</code>参数，它需要指向一个字段，指示响应将输出多少结果或页面。您可以在<a class="ae ld" href="https://stepzen.com/docs/connecting-backends/rest-services-graphql-pagination/" rel="noopener ugc nofollow" target="_blank">文档</a>中找到不同分页样式的所有参数列表。</p><p id="50aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一些例子:</p><h2 id="80bf" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">1.为偏移量实现游标分页</h2><p id="b184" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">下面的代码片段演示了如何使用StepZen for REST APIs实现GraphQL基于光标的分页，该API支持偏移分页。请注意，参数<code class="fe mq mr ms mt b">first</code>被设置为所需结果的数量。第二个参数<code class="fe mq mr ms mt b">after</code>被设置为分页的起点。</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="afd2" class="le lf iq mt b gy nc nd l ne nf">customers(<br/>  first: Int! = 20 <br/>  after: String! = ""<br/>): CustomerConnection<br/>  @rest(<br/>    endpoint:"https://api.example.com/customers?limit=$first&amp;offset=$after"<br/>    pagination: {<br/>        type: OFFSET<br/>        setters: [{field:"total" path: "meta.total_count"}]<br/>      }<br/>    )</span></pre><p id="fb7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为这是第一个请求，<code class="fe mq mr ms mt b">after</code>参数等于一个空字符串。<code class="fe mq mr ms mt b">first</code>参数设置为<code class="fe mq mr ms mt b">20</code>，表示将返回前20个结果。在第二次请求时，您可以将<code class="fe mq mr ms mt b">after</code>的值更改为等于前一次请求的<code class="fe mq mr ms mt b">first</code>的值。每个新请求都是<code class="fe mq mr ms mt b">first</code>参数的倍数。</p><h2 id="2fef" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">2.实现页码分页</h2><p id="43bc" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">当您的REST API依赖于页码分页时，请查看以下代码，以便更好地理解如何使用StepZen在GraphQL中实现基于光标的分页:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="ea0b" class="le lf iq mt b gy nc nd l ne nf">customers(<br/>  first: Int! = 20 <br/>  after: String! = ""<br/>): CustomerConnection<br/>  @rest(<br/>    endpoint:"https://api.example.com/customers?page=$after&amp;per_page=$first"<br/>    pagination: {<br/>        type: NEXT_CURSOR<br/>        setters: [{field:"nextCursor" path: "meta.next"}]<br/>      }<br/>    )</span></pre><p id="fff7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的例子说明了一些重要的方面。<code class="fe mq mr ms mt b">after</code>参数设置为空字符串，表示这是第一个请求。相比之下，第一个参数设置为<code class="fe mq mr ms mt b">20</code>，意味着每页将返回20个结果。记住，第一个参数的值对于后续请求也保持不变。即将到来的请求中的<code class="fe mq mr ms mt b">after</code>参数将根据您想要返回的页码。例如，第三页是<code class="fe mq mr ms mt b">3</code>，第四页是<code class="fe mq mr ms mt b">4</code>。</p><h2 id="5169" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">3.实现游标分页</h2><p id="ce9b" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">实现基于光标的分页与其他两种分页方法非常相似。唯一的区别是您需要将<code class="fe mq mr ms mt b">type</code>参数指定为<code class="fe mq mr ms mt b">NEXT_CURSOR</code>，并将setters参数更改为指向表示下一个光标的字段。</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="dd53" class="le lf iq mt b gy nc nd l ne nf">customers(<br/>  first: Int! = 20 <br/>  after: String! = ""<br/>): CustomerConnection<br/>  @rest(<br/>    endpoint:"https://api.example.com/customers?first=$first&amp;after=$after"<br/>    pagination: {<br/>        type: NEXT_CURSOR<br/>        setters: [{field:"nextCursor" path: "meta.next"}]<br/>      }<br/>    )</span></pre><p id="d1c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，这只适用于REST API已经支持基于光标的分页的情况。</p><h2 id="81d2" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">如何在GraphQL中查询光标分页</h2><p id="e10c" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">在上一节中，您已经了解了如何使用StepZen为任何REST API实现基于光标的分页。例如，基于光标的分页由<a class="ae ld" href="https://relay.dev/graphql/connections.htm" rel="noopener ugc nofollow" target="_blank"> Relay </a>使用，并且也由StepZen GraphQL API支持。基于光标的分页是GraphQL中进行分页的首选方式，因为它为UX的使用提供了有价值的数据。但是，正如我们在第一节中看到的，它也带来了查询更复杂的缺点。</p><p id="67de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看基于光标的分页所使用的<code class="fe mq mr ms mt b">Connection</code>类型:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="37df" class="le lf iq mt b gy nc nd l ne nf">type Customer {<br/>  activities: [Activity]<br/>  addresses: [Address]<br/>  contacts: Contacts<br/>  description: String<br/>  designation: String<br/>}<br/><br/>type CustomerEdge {<br/>  node: Customer<br/>  cursor: String<br/>}<br/><br/>type CustomerConnection {<br/>  pageInfo: PageInfo!<br/>  edges: [CustomerEdge]<br/>}</span></pre><p id="f763" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mq mr ms mt b">CustomerConnection</code>类型是由<code class="fe mq mr ms mt b">customers</code>查询返回的类型。它包含一个类型为<code class="fe mq mr ms mt b">PageInfo</code>的<code class="fe mq mr ms mt b">pageInfo</code>字段。<code class="fe mq mr ms mt b">PageInfo</code>类型包含以下字段:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="09a4" class="le lf iq mt b gy nc nd l ne nf">query MyQuery {<br/>  customers {<br/>    pageInfo {<br/>      endCursor<br/>      hasNextPage<br/>      hasPreviousPage<br/>      startCursor<br/>    }<br/>  }<br/>}</span></pre><p id="2d81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些字段通知您当前页面，以及是否有更多页面要获取。<code class="fe mq mr ms mt b">endCursor</code>和<code class="fe mq mr ms mt b">startCursor</code>字段是您需要在下一个请求中使用的光标。<code class="fe mq mr ms mt b">hasNextPage</code>和<code class="fe mq mr ms mt b">hasPreviousPage</code>字段指示是否有更多页面要获取。</p><p id="c2fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mq mr ms mt b">edges</code>字段包含一列<code class="fe mq mr ms mt b">CustomerEdge</code>对象。<code class="fe mq mr ms mt b">CustomerEdge</code>类型包含一个<code class="fe mq mr ms mt b">Customer</code>类型的<code class="fe mq mr ms mt b">node</code>字段。要获得关于客户的信息，您需要使用<code class="fe mq mr ms mt b">node</code>字段:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="c8f0" class="le lf iq mt b gy nc nd l ne nf">query MyQuery {<br/>  customers(first: 3, after: "eyJjIjoiTzpRdWVyeTpwYXJrcyIsIm8iOjl9") {<br/>    edges {<br/>      node {<br/>        id<br/>        description<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="f7c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“边和节点”的概念有点混乱，但非常简单。它来源于GraphQL中的一切都是图的概念。<code class="fe mq mr ms mt b">edges</code>字段包含一个<code class="fe mq mr ms mt b">CustomerEdge</code>对象列表，该列表是特定于该连接的信息，但不是所有节点共享的。类型<code class="fe mq mr ms mt b">CustomerEdge</code>包含类型<code class="fe mq mr ms mt b">Customer</code>的<code class="fe mq mr ms mt b">node</code>字段。这是真实的客户信息。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/aeeb736698000c988af96be78ac252c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VDGMzLwYMQPkAJbM.png"/></div></div></figure><p id="bd53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于中继，您可以在<a class="ae ld" href="https://relay.dev/graphql/connections.htm" rel="noopener ugc nofollow" target="_blank">文档</a>中找到有关GraphQL连接的更多信息。</p><h2 id="c4cc" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">结论</h2><p id="c27d" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">GraphQL允许不同种类的分页。但是，如何决定哪一个效果最好呢？GraphQL建议使用基于光标的分页。但是，这取决于您的应用程序的要求。如果您使用的REST API已经支持基于光标的分页，那么这是显而易见的。但是如果您使用的REST API不支持基于光标的分页，那么您可以使用StepZen来实现它。</p><p id="c574" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最常见和最简单的分页方式是<strong class="ka ir">偏移</strong>和<strong class="ka ir">页码</strong>。尽管它们实现起来相对简单，但它们更适合静态数据。相比之下，<strong class="ka ir">基于光标的分页</strong>比较复杂，但是最适合更改数据，因为它可以防止数据不一致。使用StepZen，可以直接为任何API实现基于光标的分页。</p><p id="7c8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请访问<a class="ae ld" href="https://stepzen.com/docs/quick-start" rel="noopener ugc nofollow" target="_blank"> StepZen Docs </a>了解更多信息。用一个<a class="ae ld" href="https://stepzen.com/signup" rel="noopener ugc nofollow" target="_blank">免费账户</a>试试吧，我们很乐意得到你的反馈，并回答关于我们<a class="ae ld" href="https://discord.com/invite/9k2VdPn2FR" rel="noopener ugc nofollow" target="_blank">不和</a>的任何问题。</p></div></div>    
</body>
</html>