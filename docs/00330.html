<html>
<head>
<title>Slaying the Sudoku Puzzle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">破解数独谜题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/slaying-the-sudoku-puzzle-13bc6dd6ff78?source=collection_archive---------2-----------------------#2019-01-10">https://levelup.gitconnected.com/slaying-the-sudoku-puzzle-13bc6dd6ff78?source=collection_archive---------2-----------------------#2019-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/5599e4d8f1a432ba6a6b7465c2fba16c.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*4HTcMGzbeO6Gd54b3zibIw.png"/></div></figure><div class=""/><div class=""><h2 id="cf97" class="pw-subtitle-paragraph ju iw ix bd b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dk translated">用Python实现约束传播和搜索的人工智能技术来解决数独板</h2></div><blockquote class="km kn ko"><p id="97e2" class="kp kq kr ks b kt ku jy kv kw kx kb ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">世界上似乎有两种主要的人，纵横字谜和数独。—丽贝卡·麦肯锡</p></blockquote></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><p id="0787" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">在本文中，你将通过编写一个程序来解决<strong class="ks iy">数独</strong>棋盘上的<code class="fe lw lx ly lz b">constraint propagation</code>和<code class="fe lw lx ly lz b">search</code>。所有代码都是用<strong class="ks iy"> Python3 </strong>编写的，可以在我的GitHub个人资料上找到，还有如何使用和执行代码的说明。</p><p id="76e5" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated"><a class="ae ma" href="https://github.com/zahash/ArtificialIntelligence/tree/master/sudoku" rel="noopener ugc nofollow" target="_blank">https://github . com/zahash/artificial intelligence/tree/master/sudoku</a></p><p id="bcbf" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">在直接进入代码之前，让我们先熟悉一些数独的术语和规则。</p><figure class="mc md me mf gt is gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/b892420f311917996641ffec17169268.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*qLoHl1ijYx00_7OE-tt9VQ.png"/></div></figure><p id="8aa1" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">对于所有正在阅读这篇文章的外星人来说，这是一个典型的未解数独棋盘的样子。</p></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h1 id="9642" class="mg mh ix bd mi mj mk ml mm mn mo mp mq kd mr ke ms kg mt kh mu kj mv kk mw mx bi translated">熟悉数独</h1><p id="ebe4" class="pw-post-body-paragraph kp kq ix ks b kt my jy kv kw mz kb ky lt na lb lc lu nb lf lg lv nc lj lk ll ij bi translated">每个<strong class="ks iy"> 9x9 </strong>数独板被分成九个<strong class="ks iy"> 3x3 </strong>部分。</p><p id="7d7b" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">这些行将标有字母<strong class="ks iy"> A、B、C、D、E、F、G、H、I </strong>。这些列将标有数字<strong class="ks iy"> 1、2、3、4、5、6、7、8、9 </strong>。请注意，标签惯例只是为了我们的理解，实际上并不存在于公告板上。</p><p id="e76b" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">行和列交叉处的单个方块将被称为<code class="fe lw lx ly lz b">boxes</code>。这些盒子将贴有标签“A1”、“A2”、“I9”。编码时，我们将使用这些标签来唯一地标识板上的每个方框</p><p id="3954" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">每个行、列和3×3的正方形将被称为一个<code class="fe lw lx ly lz b">unit</code>。因此，每个单元是一组9个盒子，总共有27个单元。</p><p id="df74" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">对于一个特定的盒子(如‘E7’)，它的<code class="fe lw lx ly lz b">peers</code>将是属于一个公共单元的所有其他盒子(即，属于同一行、列或3×3正方形的那些盒子)。</p><p id="9be7" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">游戏规则非常简单。用一个数字填充棋盘上所有的空方格，这样在同一行、同一列或同一3×3方格中没有一个方格有相同的数字。</p></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h1 id="6bdd" class="mg mh ix bd mi mj mk ml mm mn mo mp mq kd mr ke ms kg mt kh mu kj mv kk mw mx bi translated">编码板</h1><p id="962e" class="pw-post-body-paragraph kp kq ix ks b kt my jy kv kw mz kb ky lt na lb lc lu nb lf lg lv nc lj lk ll ij bi translated">我们必须找到一种方法，用一种合适的数据结构来表示棋盘和与之相关的一切。</p><p id="4c4b" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">这可能是项目中最重要的部分，因为其他一切都取决于它。如果你做错了，那么代码要么效率低下，要么不能正常工作。</p><h2 id="a30e" class="nd mh ix bd mi ne nf dn mm ng nh dp mq lt ni nj ms lu nk nl mu lv nm nn mw no bi translated">输入</h2><ul class=""><li id="c7fa" class="np nq ix ks b kt my kw mz lt nr lu ns lv nt ll nu nv nw nx bi translated">未解析纸板的起始值将由一串带点(.)来表示框是否为空。</li><li id="18e6" class="np nq ix ks b kt ny kw nz lt oa lu ob lv oc ll nu nv nw nx bi translated">输入的正确格式应该由行中数字的所有读数串联而成，从上到下取行。</li><li id="d77f" class="np nq ix ks b kt ny kw nz lt oa lu ob lv oc ll nu nv nw nx bi translated">上面显示的数独的输入字符串是</li></ul><p id="ef49" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi">‘53..7….6..195….98….6.8…6…34..8.3..17…2…6.6….28….419..5….8..79’</p><h2 id="e5ba" class="nd mh ix bd mi ne nf dn mm ng nh dp mq lt ni nj ms lu nk nl mu lv nm nn mw no bi translated">董事会</h2><ul class=""><li id="7156" class="np nq ix ks b kt my kw mz lt nr lu ns lv nt ll nu nv nw nx bi translated">电路板本身将以<strong class="ks iy">字典</strong>的形式表示，其中键是每个盒子的标签(‘E7’)，值是盒子中的数字</li></ul><h2 id="9206" class="nd mh ix bd mi ne nf dn mm ng nh dp mq lt ni nj ms lu nk nl mu lv nm nn mw no bi translated">单位</h2><ul class=""><li id="1b79" class="np nq ix ks b kt my kw mz lt nr lu ns lv nt ll nu nv nw nx bi translated">这27个单元将被存储为列表的<strong class="ks iy">列表</strong>，每个内部列表代表一个单元，该单元包含出现在同一行或列或3×3正方形中的所有盒子的标签</li><li id="fb0c" class="np nq ix ks b kt ny kw nz lt oa lu ob lv oc ll nu nv nw nx bi translated">我们将使用这个单元列表来创建一个单元<strong class="ks iy">字典</strong>来存储关于哪个盒子是哪个单元的一部分的信息。它的键是盒子的标签，它的值是盒子所属的所有单元的列表</li></ul><h2 id="968e" class="nd mh ix bd mi ne nf dn mm ng nh dp mq lt ni nj ms lu nk nl mu lv nm nn mw no bi translated">同龄人</h2><ul class=""><li id="aa12" class="np nq ix ks b kt my kw mz lt nr lu ns lv nt ll nu nv nw nx bi translated">对等体将被存储为一个<strong class="ks iy">字典</strong>，其中的键代表盒子的标签，值代表盒子的所有对等体的集合</li></ul><p id="0da1" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">现在我们已经对电路板进行了编码，让我们直接进入编码部分</p></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><h1 id="0016" class="mg mh ix bd mi mj mk ml mm mn mo mp mq kd mr ke ms kg mt kh mu kj mv kk mw mx bi translated">编码部分</h1><p id="c524" class="pw-post-body-paragraph kp kq ix ks b kt my jy kv kw mz kb ky lt na lb lc lu nb lf lg lv nc lj lk ll ij bi translated">现在让我们编写代码来对电路板进行编码</p><p id="8fca" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">编写一个助手函数，它接受两个可迭代对象(比如一个字符串),并返回它们的笛卡尔积</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="a987" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">另一个助手功能，以视觉上吸引人的方式打印数独板</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="2df8" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">现在是实际的编码</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="1fb3" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">以上代码就是整个<strong class="ks iy">主函数</strong>。现在，只看第24行</p><h2 id="163e" class="nd mh ix bd mi ne nf dn mm ng nh dp mq lt ni nj ms lu nk nl mu lv nm nn mw no bi translated">排除法</h2><figure class="mc md me mf gt is gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/fc24a171585d7234a80311d2e31ce576.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*7rOoXOTskJV-ee2L5yc1iA.png"/></div></figure><p id="dfd9" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">看着黑板上高亮显示的方框，猜测所有可能的值。</p><p id="3b4a" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">通过观察它的行，我们可以说这个盒子不能包含3，6，8。通过观察它的列，盒子不能包含1，4，8，最后通过观察它的3x3正方形，盒子不能包含2，3，6，8。所以这个盒子剩下的选项是5，7，9。</p><p id="b192" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">这是排除法背后的主要思想。我们根据规则排除可能的值，得到一个简化版的谜题。</p><p id="6e8b" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">要在代码中做到这一点，让我们替换所有由点(.)与字符串“123456789”一起使用，因为所有值在消除之前最初都是可能的。</p><p id="64b7" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated"><strong class="ks iy">查看</strong> <strong class="ks iy">上方主函数中第29到32行的代码</strong></p><p id="8210" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">现在，创建一个函数，它接受未解决的数独棋盘(作为字典)并返回相同的棋盘(作为字典)，但是在对所有的盒子应用“一次”消除之后</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="e556" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">对电路板进行编码，并运行一次消除功能。使用给定的显示功能显示消除前后的纸板。</p><h2 id="f09f" class="nd mh ix bd mi ne nf dn mm ng nh dp mq lt ni nj ms lu nk nl mu lv nm nn mw no bi translated">唯一的选择方法</h2><p id="280e" class="pw-post-body-paragraph kp kq ix ks b kt my jy kv kw mz kb ky lt na lb lc lu nb lf lg lv nc lj lk ll ij bi translated">运行消除函数后，我们将得到一个部分解决的数独——就像这样</p><pre class="mc md me mf gt of lz og oh aw oi bi"><span id="ed22" class="nd mh ix lz b gy oj ok l ol om">  5     3    124  |  26    7    8246 | 1948  1924   82  <br/>  6     47   247  |  1     9     5   | 8347   24   827  <br/>  12    9     8   |  32    34    24  |13547   6    247  <br/>------------------+------------------+------------------<br/>  8     15   195  |  7     6     14  | 9547  9254   3   <br/>  4     2    926  |  8     5     3   |  97   925    1   <br/>  7     15   1935 |  9     2     14  | 854    54    6   <br/>------------------+------------------+------------------<br/> 193    6   19354 |  35    35    7   |  2     8     4   <br/>  2     87   327  |  4     1     9   |  36    3     5   <br/> 132   1254 13254 | 3256   8     26  | 1346   7     9</span></pre><p id="da82" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">这里，如果一个盒子有一个数字，那么它意味着它的值是固定的，如果一个盒子有一个以上的数字，那么它意味着那些是可以填入那个盒子的可能的值。</p><p id="0c8a" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">现在，仔细观察中上方的3x3方块</p><pre class="mc md me mf gt of lz og oh aw oi bi"><span id="2f86" class="nd mh ix lz b gy oj ok l ol om">  26    7    8246 <br/>  1     9     5   <br/>  32    34    24  </span></pre><p id="333d" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">根据游戏规则，我们应该将1到9的所有数字放在一个3x3的正方形内。</p><p id="20a9" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">如果我们仔细观察包含“8246”的盒子，我们可以看到它是3×3正方形中唯一可以包含数字“8”的盒子，因为没有其他盒子有这种可能性。</p><p id="7c76" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">因此，我们可以很高兴地将数字“8”固定在那个盒子中(因为我们应该将所有数字放在一个3×3的正方形中，而其他盒子不能有它)</p><p id="9a68" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">它不仅限于3×3的正方形。事实上，对于一个给定的盒子，我们查看它的所有三个单元，其中一个是3x3的正方形(另外两个是盒子的行和列)</p><p id="4d5a" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">这被简单地称为<strong class="ks iy">唯一选择</strong>的方法/策略。</p><p id="7e1c" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">代码看起来像这样…</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="1592" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">在对数独的每一个盒子都应用了唯一选择函数之后，我们得到了以下结果</p><pre class="mc md me mf gt of lz og oh aw oi bi"><span id="3c24" class="nd mh ix lz b gy oj ok l ol om">  5     3    124  |  6     7     8   |  9     1     2   <br/>  6     7    247  |  1     9     5   |  3     24    8   <br/>  12    9     8   |  3     4     24  |  5     6     7   <br/>------------------+------------------+------------------<br/>  8     15    9   |  7     6     14  |  4     2     3   <br/>  4     2     6   |  8     5     3   |  7     9     1   <br/>  7     15    3   |  9     2     14  |  8     5     6   <br/>------------------+------------------+------------------<br/>  9     6   19354 |  35    35    7   |  2     8     4   <br/>  2     8     7   |  4     1     9   |  6     3     5   <br/> 132   1254 13254 | 3256   8     26  |  1     7     9</span></pre><p id="df6c" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">但是这些方法有一个主要的<strong class="ks iy">缺点</strong>。就是有时候不管你怎么淘汰或者做唯一的选择，都不能再降板了。这叫<strong class="ks iy">卡住</strong>。</p><p id="2204" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">试试这块板子' 8……36……7..9.2…5…7…….457…..1…3…1….68..85…1..9….4..'</p><p id="950e" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">事实上，那块板子被认为是世界上最难的数独游戏。</p><h2 id="1e54" class="nd mh ix bd mi ne nf dn mm ng nh dp mq lt ni nj ms lu nk nl mu lv nm nn mw no bi translated">所以现在我们有两个挑战要解决。</h2><ul class=""><li id="99c8" class="np nq ix ks b kt my kw mz lt nr lu ns lv nt ll nu nv nw nx bi translated">找出我们什么时候卡住了</li><li id="5fb2" class="np nq ix ks b kt ny kw nz lt oa lu ob lv oc ll nu nv nw nx bi translated">卡住后怎么办</li></ul><p id="cdb8" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">应对第一个挑战相当容易。只需记录淘汰和做出唯一选择前后的纸板值。如果价值观没有改变，那就意味着我们被卡住了。</p><p id="a23c" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">让我们编写一个简单的函数来实现这一点</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="692d" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">这里，我们将布尔变量<code class="fe lw lx ly lz b">stuck</code>初始化为<strong class="ks iy"> False。</strong>然后使用一个<strong class="ks iy"> while循环</strong>我们在每次迭代中检查棋盘上固定(一位数)值的数量在应用消除和唯一选择策略之前和之后是否相同。如果它们相同，那么<code class="fe lw lx ly lz b">stuck</code>将为<strong class="ks iy">真</strong>否则为<strong class="ks iy">假。</strong></p><p id="f62c" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">但是有一个问题！注意到函数末尾的<strong class="ks iy"> if语句</strong>了吗？这告诉我们数独在当前的配置下是可解的还是不可解的。</p><p id="809b" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">如果在任何一个盒子里都没有可以解决的数字，那么数独就是无解的。</p><p id="ce12" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">还有，不要局限于只是淘汰和唯一选择。有很多解决数独棋盘的策略。把你最喜欢的策略写成一个函数，和另外两个一起执行。</p><p id="371c" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">最后…</p><p id="58e9" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">我们直到现在所做的一切也被称为<strong class="ks iy"> <em class="kr">约束传播。</em> </strong></p><p id="d388" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">约束传播就是在一个空间中使用局部约束(在数独的情况下，每个方块的约束)来极大地减少搜索空间。当我们实施每个约束时，我们会看到它如何为电路板的其他部分引入新的约束，这可以帮助我们进一步减少可能性的数量。</p><p id="5e40" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated"><strong class="ks iy">进入第二个挑战</strong> …</p><p id="819a" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">世界上最难的数独谜题被称为“世界上最难的数独谜题”是有原因的。也就是说，你不能仅仅使用约束传播来解决这个难题，因为你会被卡住！</p><p id="aadd" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">所以，我要给你介绍一下<strong class="ks iy">搜索。</strong>如果你学过数据结构和算法，你可能已经知道什么是搜索了！如果你不知道，让我解释</p><p id="2ca8" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">假设你有一个想从商店购买的食品清单。你去商店买清单上的商品，不需要遵循任何特定的顺序。将它们添加到购物车后，从列表中删除该商品。现在，比方说，您想知道您是否在购物车中添加了牛奶。为了找到答案，你将打开你的清单，从上到下查看每一项，直到你找到牛奶，看看它是否被划掉。</p><p id="0515" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">说白了就是线性搜索！(因为您是以线性方式逐项搜索)</p><p id="835e" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">有许多类型的搜索算法，像线性搜索，二分搜索法，等等。在这里，我们将使用<strong class="ks iy">深度优先搜索。</strong></p><p id="47c6" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">我不会在这篇文章中详细讨论深度优先搜索，因为它会很长。但是请记住，DFS使用“回溯”来搜索</p><p id="ac1b" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">我们将使用DFS来搜索<strong class="ks iy">游戏树。</strong></p><p id="37da" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">但是什么是博弈树呢？这是一个简单的树，包含了游戏中所有可能的走法。看下图就明白了。</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="oo op di oq bf or"><div class="gh gi on"><img src="../Images/fbe54e2af2c59d5c99a9a38f43ef7be4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wTvtOoEtGJvArSK8xfbCPw.jpeg"/></div></div><figcaption class="os ot gj gh gi ou ov bd b be z dk translated">这是井字游戏的完整游戏树</figcaption></figure><p id="8ef9" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">现在，来到数独难题，这背后的主要思想是，当我们陷入困境时，我们将固定具有最少数量的可能值(通常是两个)的单元格的值，并在该方向上扩展博弈树。</p><p id="4523" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">我们将重复上述步骤，直到我们解决董事会或发现目前的配置是无法解决的。在这种情况下，我们回溯并扩展另一个节点。</p><p id="647b" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">我知道这有点难以理解。我也很难解释课文中的一切。也许用一个视频来解释这个过程会更实际。</p><blockquote class="km kn ko"><p id="1a94" class="kp kq kr ks b kt ku jy kv kw kx kb ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有时间的话我会做个视频嵌入这篇文章。</p></blockquote><p id="6646" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">代码看起来像这样</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="od oe l"/></div></figure><h1 id="27c7" class="mg mh ix bd mi mj ow ml mm mn ox mp mq kd oy ke ms kg oz kh mu kj pa kk mw mx bi translated">结论</h1><p id="627b" class="pw-post-body-paragraph kp kq ix ks b kt my jy kv kw mz kb ky lt na lb lc lu nb lf lg lv nc lj lk ll ij bi translated">就这样，现在你知道了如何编写自己的程序来解决数独。但最重要的是，你现在知道了人工智能中最强大的两个概念——“约束传播”和“搜索”。</p><p id="2334" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">你可以用这两种技术来解决很多问题，比如密码算法难题(我讨厌它们)。</p><p id="bd8f" class="pw-post-body-paragraph kp kq ix ks b kt ku jy kv kw kx kb ky lt la lb lc lu le lf lg lv li lj lk ll ij bi translated">另外，如果你想看更多关于数据科学、机器学习、人工智能和一般编程的文章，请关注我。</p></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><figure class="mc md me mf gt is gh gi paragraph-image"><a href="https://levelup.gitconnected.com/"><div class="gh gi pb"><img src="../Images/ff5028ba5a0041d2d76d2a155f00f05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaoZbi7tTKJ5vL7i2OAYMQ.png"/></div></a></figure><div class="ip iq gp gr ir pc"><a href="https://gitconnected.com/learn/python" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iy gy z fp ph fr fs pi fu fw iw bi translated">学习Python -最佳Python教程(2019) | gitconnected</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">77大Python教程。课程由开发者提交并投票，让你找到最好的Python…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">gitconnected.com</p></div></div><div class="pl l"><div class="pm l pn po pp pl pq it pc"/></div></div></a></div></div></div>    
</body>
</html>