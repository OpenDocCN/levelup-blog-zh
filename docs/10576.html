<html>
<head>
<title>How to improve user experience by using the actor model and the state machine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过使用参与者模型和状态机来改善用户体验</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-improve-user-experience-by-using-the-actor-model-and-the-state-machine-9d130587e313?source=collection_archive---------9-----------------------#2021-12-22">https://levelup.gitconnected.com/how-to-improve-user-experience-by-using-the-actor-model-and-the-state-machine-9d130587e313?source=collection_archive---------9-----------------------#2021-12-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/1f42dffcbf15ee6459e8bdcd57cfef58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Anj7sZzTIZ-BgTpb4Pympg.png"/></div></div></figure><div class=""/><p id="7b8e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天我将讨论两个流行的编程抽象:参与者模型和状态机。我将解释在软件开发中如何以及在哪里使用它们，并向您展示为什么将它们合并到您的工具箱中是一个好主意。</p><p id="29cc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从一个让我想到演员模型和国家机器的真实故事开始。有一次，我想在网上订机票，执行起来差点把我逼疯。我打开网站，搜索航班，填写乘客的详细信息，添加一些额外的内容，提交几份表格等。到目前为止一切如常。</p><p id="b5f8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后它问我护照号码、出生日期和地址，我记不清了。所以我离开了电脑，取来了文件，又花了五分钟把所有的东西都填好，最终准备好继续。我点击了按钮，窗口立即弹出:“您的会话已过期。请重新开始。”</p><p id="a1d1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">哇？我刚刚花了将近30分钟填写所有要求的表格，而我得到的只是一个暂停？这远不是令人愉快的用户体验。在这一点上，一个普通用户会深呼吸几次然后重试，但是我开始思考为什么会这样。我脑海里出现了快速的询问:</p><p id="5650" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">-填充的信息可以缓存在某个地方吗？例如，保存在个人资料中？为什么要过期呢？<br/> -如果我之前已经提供了这些细节，我可以跳过一些步骤吗？还是回顾确认？<br/> -不小心关闭了浏览器窗口怎么办？<br/> -如果我在手机上开始这个过程，然后决定在笔记本上继续，会怎么样？还是等我准备好所有文件后再继续？</p><p id="9e5a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这些情况下，参与者模型和状态机将有助于创建一个更加动态、可伸缩和友好的用户工作流。</p><p id="b43c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">什么是状态机？</strong> <br/>状态机是一种流行的编程范例，它允许对状态和转换进行建模和描述。有时它被称为有限状态机，因为它有有限数量的状态。第一条规则是，用户(或程序执行)在任何时候都可以处于一种状态，而不是多种状态。它通常还指定了如何在不同状态之间转移。例如，可以允许从状态A切换到状态B，但不允许切换到状态c。可能有启动状态转换的动作或触发器。现实生活中的一个例子是电灯开关。它有两种状态:开和关，你可以通过按一个按钮在它们之间切换。</p><p id="3a23" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在不同的编程语言中找到这一原则的许多实现。Net开发人员会发现这些<a class="ae kw" href="https://docs.microsoft.com/en-us/dotnet/framework/windows-workflow-foundation/state-machine-workflows" rel="noopener ugc nofollow" target="_blank">状态机工作流</a>对框架或[<a class="ae kw" href="https://github.com/dotnet-state-machine/stateless" rel="noopener ugc nofollow" target="_blank">dot net-State-Machine/stateless</a>]库很有帮助。您还可以为您的项目使用备选方案或实现自定义状态机。</p><p id="dfab" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">什么是演员模特？</strong> <br/>让我们继续一个演员模型的定义。这是20世纪70年代的数学模型和编程范式，但即使在今天也很流行。主要是因为它可以简化并发编程的方式。actor是包含数据和逻辑的基本计算单元。数据通常被称为参与者状态，但不要将其与上面的状态混淆。参与者逻辑只能通过消息触发。这些消息可以由参与者异步处理，一次一个，这保证了参与者状态的一致性。除了消息之外，没有什么可以修改执行元状态。参与者可以通过ID来标识，例如用户ID。底层实现处理参与者的创建和其他生命周期活动。一个明显的好处是程序员不需要检查参与者是否存在。您所需要的只是一个具有特定ID的特定状态的参与者，您可以向其发送特定的数据并异步接收结果。</p><p id="c978" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上，它可能是这样的——通过ID获取一个对象，通过传递特定的数据来调用一个方法，当方法调用完成时开始所需的操作，结果就准备好了。如果您熟悉面向对象编程，这并不是什么新鲜事。</p><p id="4a39" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">多种语言(如Erlang)在实现时支持开箱即用的角色。其他人有包含actor模型的库和框架——AKKA(和AKKA。网)，奥尔良，或DAPR，仅举几例。</p><p id="e2dd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">奥尔良和DAPR的例子</strong> <br/>例如，奥尔良运行在集群中，水平扩展，支持多种持久性选项，并为演员的停用提供了简单的方法。最初是微软的一个内部研究项目，后来变成了一个公共开源项目。早期用例之一是对Halo等在线游戏的后端支持，这些游戏在全球拥有数百万用户。那么，奥尔良为什么有用呢？</p><p id="5e9d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Orleans性能的出色之处在于actors驻留在它的集群节点中，并且可以在一段时间后停用。然后可以将用户数据等参与者状态保存到存储或数据库中。</p><p id="9dc3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为什么这很重要？当玩家离开游戏时，没有必要将他的数据保存在内存中。然而，同一个玩家可能会在第二天重新加入，这时他们的演员会被激活并使用最新数据进行更新。</p><p id="9151" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">DAPR也使用了演员模型。但它的作用不止于此。它是一个构建分布式应用的平台。DAPR是微软最近的一个开源项目，它利用了sidecar应用程序的概念，抽象了分布式系统开发的复杂性。</p><p id="ba48" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我想发布一条来自用C#编写的服务的消息。该消息将由用其他语言编写的其他服务使用。感谢DAPR API，我不用担心消息总线和它的客户端的API，因为DAPR处理一切。</p><p id="333a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">参与者状态的持久性也被抽象出来。不需要担心特定的数据库访问提供者。这是通过集群配置完成的。无论数据驻留在Redis、关系数据库(如SQL Server)还是其他地方，它都不一定是应用程序业务逻辑的一部分。</p><p id="e6bd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">如何用机器状态和演员模型做出更好的app？</strong> <br/>够了理论。让我们讨论一下如何使用上述工具来顺利完成租车预订。租车永远是一个涉及多个阶段的半人工程序，无疑还有自动化的空间。怎么会？开发商如何加快租车流程？</p><p id="dc64" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们想象一个完美的预订流程，它可以通过实现一些后端升级来实现。你打开租车网站，选择日期，浏览汽车目录。许多租赁在这个阶段失败，因为他们没有一个可用性日历来显示哪些车是空的。但这不是唯一的问题。</p><p id="d355" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注册时，您应该会收到一个ID。它可以是电子邮件、电话号码，或者最好是系统生成的号码。如果您开始预订流程，应用程序将创建一个填充了初始数据的actor实例。选车的时候，车要有它的ID，也要处于演员状态。就像这样，如果预订被中断，您将确保没有数据丢失。然后就可以进入下一阶段了。该网站将让你选择额外的东西，如儿童座椅、全球定位系统或额外的保险。您可以勾选这些选项，然后继续。底层行动者具有触发状态改变的状态机，例如，从汽车选择到额外租赁。</p><p id="8402" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当前阶段总是存储在actor状态中，所以如果您的连接断开，您不会丢失您的进度。您甚至可以切换您的设备，并从您离开的地方继续。当然，开发人员可以实现额外的触发器，例如，您想要额外的保险→我们将需要这些额外的信息。那么，当所有内容都已填满并准备提交时，会发生什么呢？</p><p id="89ed" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">等待阶段很方便。您提交数据，状态机切换到“等待批准”阶段，并通知后台系统。汽车租赁公司的员工可以立即查看他们从参与者状态获得的数据和文档。当他们批准后，他们只需向参与者发回一条消息，就可以进入下一个阶段。然后，演员转换到“预订确认”阶段，并通知客户。前端app可以随时从演员状态中取出所有数据。当然，可能还有其他类似“预订取消”或“预订拒绝”的状态。</p><p id="09d4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我相信这个工作流程听起来比我订机票时遇到的要友好得多。状态机确保始终定义流程的阶段。因此，如果被中断或改变到另一个设备，不需要从头开始。通过基于用户输入的转换逻辑，该过程也可以变得更加动态。</p><p id="9873" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以这种方式建模和编程的工作流肯定会提升用户体验。流程的当前阶段始终是确定的。如果中断或切换到另一台设备时，无需从头开始。这个过程可以是非常动态的，根据用户输入转换逻辑。此外，该流程的开发可能不太复杂，因为不太需要管理并发数据访问。</p><p id="1a09" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是都是彩虹和阳光，还是有什么弊端？当然有。每种技术、模型和实现都需要一些努力来学习它的原理和API。调试参与者状态也可能是一个巨大的挑战。此外，如果应用程序在单个集群中运行，则无需担心数据一致性。但是，如果您使用多集群环境和蓝/绿部署，情况就完全不同了。</p><p id="d6f3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">寻求更多信息。<br/> <a class="ae kw" href="https://www.linkedin.com/in/olegln/" rel="noopener ugc nofollow" target="_blank">奥列格</a>，高级软件工程师</p></div></div>    
</body>
</html>