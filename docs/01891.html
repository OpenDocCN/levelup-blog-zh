<html>
<head>
<title>Streaming data from a home cinema device using RXJava on Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Android上的RXJava从家庭影院设备流式传输数据</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/streaming-data-from-a-home-cinema-device-using-rxjava-on-android-44de8f5a29a0?source=collection_archive---------17-----------------------#2020-02-04">https://levelup.gitconnected.com/streaming-data-from-a-home-cinema-device-using-rxjava-on-android-44de8f5a29a0?source=collection_archive---------17-----------------------#2020-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/66a380b50ae7fe5fc001c94444157d0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EqRvdtDFZ3fFou8Q5bMP5g.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片由pixabay.com提供</figcaption></figure><h1 id="86fc" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">介绍</h1><p id="b345" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">在我关于为我的NAD家庭影院接收器构建一个Android配套应用的最初博客文章中，我解释了我如何使用Android的Netwerk服务发现来发现局域网上的设备。</p><p id="d4fc" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">在这篇文章中，我将解释我如何使用RxJava以一种反应式的流方式连接到家庭影院接收器。同时，这也是最有趣的部分，另一方面，也是最具挑战性的部分。</p><p id="0e08" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">如果您对使用RxJava的原因不感兴趣，请跳过下面的部分，直接进入实现。</p><h1 id="f6b1" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">为什么是reactive和RxJava？</h1><p id="a16b" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">作为一名技术人员，当我在业余爱好项目上投入时间时，我喜欢将实用性和技术性结合起来。我这么说的意思是，我喜欢解决问题，但我也喜欢从技术上挑战自己，从教育的角度去做。</p><p id="fe4a" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">作为一个至少8年没有接触Android生态系统的人，我很高兴不知道这个生态系统变成了什么。我非常兴奋地看到，反应式编程在Android生态系统中也获得了很大的吸引力。为执行异步代码而创建AsyncTasks的日子仍然让我不寒而栗，幸运的是这种日子已经一去不复返了。</p><p id="2d54" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">在过去的5年里，我大部分时间都在使用Scala，我写的很多软件都是在牢记<a class="ae mb" href="https://www.reactivemanifesto.org/" rel="noopener ugc nofollow" target="_blank">反应宣言</a>的基础上构建的。我使用Akka Streams已经好几年了，并且已经习惯了<a class="ae mb" href="https://www.reactive-streams.org/" rel="noopener ugc nofollow" target="_blank">反应流计划</a>。该计划致力于为具有非阻塞背压的异步流处理提供一个标准。</p><p id="28da" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">连接到外部设备，如我的家庭影院接收器，并发送和接收其音量未预先确定的数据非常适合反应式应用的用例。</p><h2 id="4113" class="mh kg it bd kh mi mj dn kl mk ml dp kp lo mm mn kt ls mo mp kx lw mq mr lb ms bi translated">为Android选择实现</h2><p id="3314" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">对于Java，我知道<a class="ae mb" href="https://projectreactor.io/" rel="noopener ugc nofollow" target="_blank">项目Reactor </a>，它是一个反应流实现。然而，为了迎合尽可能多的潜在用户，我想将最低SDK版本设置为Android 6.0(API版本23)。不幸的是，这个版本的Android不包括运行Reactor所需的JDK版本。</p><p id="40a0" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">我了解到RxJava是Android上最受欢迎的选择。幸运的是，RxJava 2还增加了对Reactive Streams API规范的支持。</p><h1 id="8751" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">深入实施</h1><p id="29c1" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">整个设置从<a class="ae mb" href="https://developer.android.com/topic/libraries/architecture/viewmodel" rel="noopener ugc nofollow" target="_blank">视图模式</a>开始。<code class="fe mt mu mv mw b">ViewModel</code>是一个设计用来以生命周期意识的方式管理UI相关数据的类。</p><p id="b4d4" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">当<code class="fe mt mu mv mw b">ViewModel</code>初始化时，我开始2个<code class="fe mt mu mv mw b">Observable</code>流。一个用于监控WiFi状态，一个用于发现网络上的家庭影院接收器。</p><p id="ce22" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">可观察的服务发现是一切开始的地方。当这个流发出时，我引导管理设备连接的可观察对象。</p><h1 id="a7b6" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">监控WiFi状态</h1><p id="fe21" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">对于我们的第一个流，我会保持简单。每当用户没有连接到WiFi网络时，我想通知他们，这实际上使应用程序变得无用。</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="ab41" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">为了监控WiFi状态，我使用了一个<code class="fe mt mu mv mw b">BehaviorSubject</code>，它连接到安卓<code class="fe mt mu mv mw b">ConnectivityManager.NetworkCallback</code>。A <code class="fe mt mu mv mw b">BehaviorSubject</code>向每个订阅的观察者发送它最近观察到的项目和所有后续观察到的项目。</p><p id="46e4" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">正如您在上面的代码片段中看到的，在类的实例化中，我创建了一个私有的<code class="fe mt mu mv mw b">BehaviorSubject</code>，并将<code class="fe mt mu mv mw b">BehaviorSubject</code>作为<code class="fe mt mu mv mw b">state</code>属性对外公开。通过实现<code class="fe mt mu mv mw b">ConnectivityManager.NetworkCallback</code>的两个方法，我在<code class="fe mt mu mv mw b">ViewModel</code>中向我们的下游订阅发出正确的状态。</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="536e" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">在<code class="fe mt mu mv mw b">ViewModel</code>中，我能够调整与UI相关的属性，这些属性更新我的视图以向用户显示信息性消息。</p><h2 id="d5e8" class="mh kg it bd kh mi mj dn kl mk ml dp kp lo mm mn kt ls mo mp kx lw mq mr lb ms bi translated">服务发现可观测量</h2><p id="6460" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">自从我在<a class="ae mb" href="https://mrooding.me/using-androids-network-service-discovery-to-connect-to-a-device-on-the-local-network-577002324a19" rel="noopener ugc nofollow" target="_blank">博客上发布了关于在网络上发现设备的帖子</a>之后，我发现相当多的用户拥有使DNS-SD不可用的网络路由设备，这导致了相当多的用户感到沮丧。</p><p id="1f4c" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">我最近发现NAD通过UDP端口11430发出一个辅助的、专有的服务发现协议。我已经更新了应用程序来扫描这两种实现。这意味着有两个可观察的流，当它们发现一个设备时，可能都发出一个项目。我不关心哪个协议能找到设备。我所关心的是找到一个设备，我可以开始连接尝试。</p><p id="8867" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">为了解决这个问题，我创建了一个<code class="fe mt mu mv mw b">ServiceDiscoveryProtocol</code>接口，我将用它来实现这两个协议。除此之外，第三个实现将负责启动和停止两个协议实现，最重要的是，它将把两个可观察对象合并成一个可观察对象，供下游使用。</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="3e1d" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">所有实现都公开了一个<code class="fe mt mu mv mw b">Observable&lt;ServiceDiscoveryState&gt;</code>,这是一个指示发现状态的数据结构。</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="a4ca" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">每个实现都使用与<code class="fe mt mu mv mw b">WifiManager</code>所示相同的模式:通过隐藏真实可观察对象的身份来暴露私有属性。与<code class="fe mt mu mv mw b">WifiManager</code>的不同之处在于，两个发现协议的实现使用了<code class="fe mt mu mv mw b">PublishSubject</code>而不是<code class="fe mt mu mv mw b">BehaviorSubject</code>。<code class="fe mt mu mv mw b">BehaviorSubject</code>会记住最后发出的项目，即使消费者尚未订阅。<code class="fe mt mu mv mw b">PublishSubject</code>只发出订阅发生后发出的值。</p><p id="ffc8" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">下面显示了我在最初的帖子中展示的网络服务发现的一个过于简化的实现。就像在<code class="fe mt mu mv mw b">WifiManager</code>中一样，每当触发正确的侦听器回调时，我都会向下游发出一个项目。</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="2713" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">最后但并非最不重要的一点是，将所有东西都联系在一起的<code class="fe mt mu mv mw b">ServiceDiscoveryProtocol</code>的实现使用<code class="fe mt mu mv mw b">Observable.merge</code>来合并这两个可观测量。</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="fa66" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">现在我已经有了合并两个可能的服务发现协议的<code class="fe mt mu mv mw b">ServiceDiscoveryProtocol</code>实现，我可以在我的<code class="fe mt mu mv mw b">ViewModel</code>中创建它的一个实例。使用该实例，我可以订阅暴露的<code class="fe mt mu mv mw b">Observable</code>并处理发现的设备。</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="aa5d" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">连接到设备</h1><h2 id="11f9" class="mh kg it bd kh mi mj dn kl mk ml dp kp lo mm mn kt ls mo mp kx lw mq mr lb ms bi translated">创建套接字</h2><p id="5b53" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">如<code class="fe mt mu mv mw b">ViewModel</code>实现的最后一段代码所示，当找到一个设备时，就会调用一个<code class="fe mt mu mv mw b">connect</code>方法。connect方法最重要的部分是建立套接字连接，以便向NAD发送和接收数据。</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="f2d5" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">为此，我创建了一个类，它将公开一个<code class="fe mt mu mv mw b">Observable&lt;Either&lt;Throwable, Socket&gt;&gt;</code>以供进一步使用。<code class="fe mt mu mv mw b">Observable</code>将尝试根据设备的IP地址和主机名创建一个<code class="fe mt mu mv mw b">Socket</code>。可见链的起点是一个<code class="fe mt mu mv mw b">PublishSubject</code>。建立套接字连接将以可重试的方式进行。这在<code class="fe mt mu mv mw b">retryWhen</code>块中处理，该块最多重试10次，延迟500毫秒。如果超过10次尝试，将返回一个<code class="fe mt mu mv mw b">Observable.error</code>。</p><p id="76ff" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">然而，我不想让流失败，这就是为什么<code class="fe mt mu mv mw b">Observable</code>返回一个<code class="fe mt mu mv mw b">Either</code>类型。这个<code class="fe mt mu mv mw b">Either</code>类型来自<a class="ae mb" href="https://arrow-kt.io/" rel="noopener ugc nofollow" target="_blank"> arrow </a> Kotlin库，它在Kotlin标准库的基础上增加了很多函数类型。通过使用这个<code class="fe mt mu mv mw b">Either</code>类型，当我在下游使用<code class="fe mt mu mv mw b">Observable</code>时，我可以区分“软故障”(一个<code class="fe mt mu mv mw b">Either.left&lt;Throwable&gt;</code>)和成功案例(一个<code class="fe mt mu mv mw b">Either.right&lt;Socket&gt;</code>)。为了转换重试次数达到最大尝试次数时发生的<code class="fe mt mu mv mw b">Observable.error</code>，我使用<code class="fe mt mu mv mw b">onErrorReturn</code>函数将失败的<code class="fe mt mu mv mw b">Observable</code>转换为<code class="fe mt mu mv mw b">Either.left</code>。</p><p id="720f" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">这种方法的主要优点是我可以将一个不可变的<code class="fe mt mu mv mw b">Observable</code>声明为类属性val。如果我不使用<code class="fe mt mu mv mw b">Either</code>类型，那么流就会失败，当重新连接时，我必须重新实例化包含<code class="fe mt mu mv mw b">Observable</code>属性的类。如下一段代码所示，重新连接现在就像使用<code class="fe mt mu mv mw b">PublishSubject</code>发出一个<code class="fe mt mu mv mw b">Unit</code>一样简单。</p><p id="a94f" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">最后但同样重要的是，该流使用<code class="fe mt mu mv mw b">cache</code>函数来确保最新的值被缓存。这将防止我每次订阅并使用发出的值时创建新的套接字。至关重要的是，我将在下一节中定义的下游<code class="fe mt mu mv mw b">Source</code>和<code class="fe mt mu mv mw b">Sink</code>使用相同的<code class="fe mt mu mv mw b">Socket</code>实例。如果它们不使用同一个插座，使用<code class="fe mt mu mv mw b">Sink</code>发送到设备的命令将不会在<code class="fe mt mu mv mw b">Source</code>上收到应答。你可能会想，等等，他是不是把<code class="fe mt mu mv mw b">Sink</code>和<code class="fe mt mu mv mw b">Source</code>搞混了？请记住，我是从应用程序的角度来引用这些概念的。这意味着我发送到设备的数据将使用<code class="fe mt mu mv mw b">Sink</code>。我们的应用程序从设备接收的数据将通过<code class="fe mt mu mv mw b">Source</code>接收。</p><h2 id="0f13" class="mh kg it bd kh mi mj dn kl mk ml dp kp lo mm mn kt ls mo mp kx lw mq mr lb ms bi translated">构建源和汇</h2><p id="2a66" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">有了<code class="fe mt mu mv mw b">SocketProvider</code>之后，我现在想在此基础上创建一个<a class="ae mb" href="https://github.com/square/okio" rel="noopener ugc nofollow" target="_blank"> Okio </a> <code class="fe mt mu mv mw b">Source</code>和<code class="fe mt mu mv mw b">Sink</code>。Okio是一个Kotlin库，可以更容易地执行io操作。其中，它提供了它的流类型<code class="fe mt mu mv mw b">Source</code>和<code class="fe mt mu mv mw b">Sink</code>，它们本质上是<code class="fe mt mu mv mw b">InputStream</code>和<code class="fe mt mu mv mw b">OutputStream</code>的包装器，有几个好处。</p><p id="b87f" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated"><code class="fe mt mu mv mw b">SourceProvider</code>和<code class="fe mt mu mv mw b">SinkProvider</code>的实现完全相同，它们都将<code class="fe mt mu mv mw b">Observable&lt;Either&lt;Throwable, Socket&gt;&gt;</code>映射到<code class="fe mt mu mv mw b">Observable&lt;Either&lt;Throwable, A&gt;&gt;</code>，其中<code class="fe mt mu mv mw b">A</code>要么是<code class="fe mt mu mv mw b">BufferedSource</code>要么是<code class="fe mt mu mv mw b">BufferedSink</code>。这个新的<code class="fe mt mu mv mw b">Observable</code>再次被公开为一个公共类属性，就像我以前做的那样。</p><p id="cfc3" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">最后但同样重要的是，这两个类再次使用了<code class="fe mt mu mv mw b">cache</code>函数来防止创建过多的冗余实例。</p><p id="aee5" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">刚刚描述的<code class="fe mt mu mv mw b">SourceProvider</code>的整个实现:</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="7959" class="mh kg it bd kh mi mj dn kl mk ml dp kp lo mm mn kt ls mo mp kx lw mq mr lb ms bi translated">从NAD读取数据</h2><p id="6d9b" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">控制发送命令和接收响应的逻辑位于一个<code class="fe mt mu mv mw b">ReceiverRepository</code>类中。</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="eba4" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">为了读取设备发送的响应，我声明了一个名为<code class="fe mt mu mv mw b">responses</code>的类属性，它将我们的<code class="fe mt mu mv mw b">SourceProvider</code>返回的<code class="fe mt mu mv mw b">Observable&lt;Either&lt;Throwable, BufferedSource&gt;&gt;</code>映射到一个<code class="fe mt mu mv mw b">Observable&lt;Either&lt;Throwable, SocketResponse&gt;&gt;</code>。<code class="fe mt mu mv mw b">SocketResponse</code>是设备支持的协议的包装器，但是它封装了设备发送的单个响应行。</p><p id="03be" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">阅读反应的核心发生在<code class="fe mt mu mv mw b">createSocketResponseStream</code>方法中。在这里，我把<code class="fe mt mu mv mw b">fold</code>放在<code class="fe mt mu mv mw b">Either&lt;Throwable, BufferedSource&gt;</code>上。如果它是一个<code class="fe mt mu mv mw b">Either.left</code>，因此是一个<code class="fe mt mu mv mw b">Throwable</code>，我简单地把它传递给下游。如果它是一个<code class="fe mt mu mv mw b">Either.right</code>，因此是一个有效的<code class="fe mt mu mv mw b">Source</code>，我创建一个<code class="fe mt mu mv mw b">Observable.interval</code>，它将尝试每10毫秒从<code class="fe mt mu mv mw b">Source</code>中读取一行。</p><p id="4526" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">这样做的原因是我需要一种方法来保持从<code class="fe mt mu mv mw b">Source</code>中读取行。如果<code class="fe mt mu mv mw b">Source</code>没有任何新的行要读取，它将阻塞用于运行<code class="fe mt mu mv mw b">Observable.interval</code>的线程。如果没有收到数据，它就不会持续触发10毫秒的时间间隔，而是耐心等待新的数据。</p><p id="31f5" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">在收到新的一行时，我试图解析那一行。如果成功，我返回一个<code class="fe mt mu mv mw b">Either.right&lt;SocketResponse&gt;</code>。如果它失败了，我再次通过使用<code class="fe mt mu mv mw b">Either.left</code>构造优雅地防止流失败。</p><h2 id="6cdd" class="mh kg it bd kh mi mj dn kl mk ml dp kp lo mm mn kt ls mo mp kx lw mq mr lb ms bi translated">向NAD发送命令</h2><p id="6a30" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">发送命令的逻辑比读取响应要简单得多。然而，Kotlin协程的形式增加了一点复杂性。</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="ee55" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">使用Kotlin协程是为了防止我在UI线程上运行IO操作。为了向家庭影院接收器发送命令，我使用<code class="fe mt mu mv mw b">.take(1).blockingLast()</code>以阻塞方式获取<code class="fe mt mu mv mw b">Observable&lt;Either&lt;Throwable, BufferedSink&gt;&gt;</code>的最后发射值。然后，我映射结果，在<code class="fe mt mu mv mw b">map</code>中，我将命令写入并刷新到设备。</p><h1 id="b923" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">把它们连在一起</h1><p id="eb92" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">谜题的最后一部分是从<code class="fe mt mu mv mw b">ReceiverRepository</code>订阅我们的<code class="fe mt mu mv mw b">responses</code>流。我在我的<code class="fe mt mu mv mw b">MainViewModel</code>订阅了信息流。通过订阅流，我能够根据连接状态做一些事情。我可以控制呈现给用户的用户界面，在第一次连接时向NAD发送命令，最后但同样重要的是，在<code class="fe mt mu mv mw b">ViewModel</code>状态下保存收到的响应。</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="be33" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">结论</h1><p id="dab2" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">虽然听起来很简单，但连接到家庭影院以及从家庭影院发送和接收信息要比想象中复杂得多。在我构建Android应用的整个过程中，这无疑是最复杂的部分。我使用了很多不同的RxJava技术，最终得到了一个高性能、容错、可维护、松散耦合且易于测试的解决方案。总的来说，还有改进的地方需要重构，但是总的来说，我对这个实现非常满意。</p><p id="6837" class="pw-post-body-paragraph ld le it lf b lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw mg ly lz ma im bi translated">我确实认识到这个解决方案非常复杂，我非常好奇尝试其他方法，比如Kotlin Flow，看看我是否能降低代码复杂性。</p></div></div>    
</body>
</html>