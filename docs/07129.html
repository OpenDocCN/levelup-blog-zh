<html>
<head>
<title>Massively Parallel Serverless Computing in AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS中的大规模并行无服务器计算</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/massively-parallel-serverless-computing-in-aws-d99b6090f8b4?source=collection_archive---------8-----------------------#2021-01-26">https://levelup.gitconnected.com/massively-parallel-serverless-computing-in-aws-d99b6090f8b4?source=collection_archive---------8-----------------------#2021-01-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="55be" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">摘要</h1><p id="fcdb" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这篇文章是关于实现一个大规模并行科学数据处理系统的设计和挑战，该系统运行大约<strong class="ku ir"><em class="lq">【5K】</em></strong><em class="lq"/><a class="ae lr" href="https://en.wikipedia.org/wiki/OS-level_virtualization" rel="noopener ugc nofollow" target="_blank">集装箱</a>并发计算一个美国东海岸的<em class="lq">飓风风足迹模型</em>用<strong class="ku ir"> FORTRAN </strong>。总共约有<strong class="ku ir"><em class="lq"/></strong><em class="lq"/>个集装箱以容错方式运行了<strong class="ku ir"/>四天来计算东海岸的美国风足迹(USWFPT)模型，实现了<strong class="ku ir"> <em class="lq"> 10x </em> </strong>的加速。</p><p id="9d3a" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">大多数需要如此大规模并行处理的科学计算通常在超级计算机(OpenMP + FORTRAN)上运行，没有多少人有机会使用这些计算机。这个问题有多种解决方案(缩放FORTRAN代码)；这只是在这个规模上成功运作的一个例子。主要思想是在云中为这个问题构建大规模并行解决方案时所遵循的设计原则。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="d786" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">项目目标</h1><ol class=""><li id="d077" class="lx ly iq ku b kv kw kz la ld lz lh ma ll mb lp mc md me mf bi translated">使用用<strong class="ku ir"> FORTRAN编写的现有代码库。</strong></li><li id="354f" class="lx ly iq ku b kv mg kz mh ld mi lh mj ll mk lp mc md me mf bi translated">对代码基础的最小修改</li><li id="3b8b" class="lx ly iq ku b kv mg kz mh ld mi lh mj ll mk lp mc md me mf bi translated">显著减少计算时间。</li><li id="3bb7" class="lx ly iq ku b kv mg kz mh ld mi lh mj ll mk lp mc md me mf bi translated">零基础设施维护</li><li id="9312" class="lx ly iq ku b kv mg kz mh ld mi lh mj ll mk lp mc md me mf bi translated">启用CI/CD(持续集成和持续交付)</li></ol></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="9e56" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">为什么这很重要？</h1><p id="2fba" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">美国飓风是全球保险业最昂贵的风险之一。根据保险信息研究所(Insurance Information Institute)的数据，根据财产索赔服务数据(<a class="ae lr" href="https://www.iii.org/fact-statistic/facts-statistics-us-catastrophes" rel="noopener ugc nofollow" target="_blank">https://www . iii . org/fact-statistics/facts-statistics-US-灾变</a>)，飓风占1917年至2016年美国保险灾难损失的近40%。因此，计算登陆飓风带来的风险非常重要。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ml"><img src="../Images/c11dfb0d6d43e73366bfd822cf428923.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YNajOjGx_P_N3YjjE7QLXw.jpeg"/></div></div></figure><p id="ceb5" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated"><strong class="ku ir"> <em class="lq">稍微讲一下飓风</em> </strong></p><p id="8461" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">飓风(也称为台风或热带气旋)是一类源于全球热带地区的风暴，在中心低压、平静的“风眼”周围有一个近似轴对称、非常强大的气旋环流。</p><p id="8a5a" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">根据风暴的不同，风力影响可以延伸到距离风暴中心约10英里(2008年热带风暴马可-有记录以来最小)，约200英里(2017年飓风伊尔玛)到距离风暴中心500英里以上(2012年飓风桑迪-影响美国最大的飓风)的任何地方。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/a2b1d4e210fe1f59a0e9e3022b012989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*UhMGVYQQlckZbzZ2U4SUsw.jpeg"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd jw">这是GOES-16卫星图像，由美国国家海洋和大气管理局(NOAA)于2019年9月1日星期日17:00 UTC拍摄，显示飓风多利安(右)正在大西洋上空翻腾。飓风多里安周日袭击了巴哈马北部，成为灾难性的5级风暴。时速185英里的大风掀翻了屋顶，掀翻了电线，数百人躲在学校、教堂和其他避难所。</strong></figcaption></figure></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="8f29" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">突变模型</h1><p id="49a5" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">灾难模型可以用来量化登陆飓风带来的风险。这些模型计算了大量热带气旋(<em class="lq"/>或更多事件)造成的损失。飓风事件造成的损失有三种主要方式(次级风险):</p><ol class=""><li id="58f5" class="lx ly iq ku b kv ls kz lt ld nc lh nd ll ne lp mc md me mf bi translated"><strong class="ku ir">风</strong>(建筑物的结构性破坏)</li><li id="55f6" class="lx ly iq ku b kv mg kz mh ld mi lh mj ll mk lp mc md me mf bi translated"><strong class="ku ir">风暴</strong> <strong class="ku ir">汹涌</strong>(沿海洪水)</li><li id="2e57" class="lx ly iq ku b kv mg kz mh ld mi lh mj ll mk lp mc md me mf bi translated"><strong class="ku ir">降雨</strong>与风暴(内陆洪水)有关</li></ol><p id="65a9" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">从建模的角度来看，每个子风险都是单独建模的。这个例子只关注<strong class="ku ir">风的危害</strong>。与风相关的损失估计是基于飓风经过期间任何地点经历的最大阵风(在10米高度持续3秒的阵风)。事件集事件的所有足迹的完整集合构成了灾难模型的风灾部分。</p><p id="741b" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated"><strong class="ku ir"> USWFPT </strong>模型目前用FORTRAN编写，使用一组软件库和独立于机器的数据格式，支持创建、访问和共享面向数组的科学数据，以计算<strong class="ku ir"> <em class="lq">事件足迹</em> </strong>。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="c246" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">事件足迹</h1><p id="c90a" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">所有具有显著阵风的位置的集合被称为<strong class="ku ir"> <em class="lq">事件足迹</em> </strong>。</p><p id="8455" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">为了创建<strong class="ku ir"> <em class="lq">事件足迹，</em> </strong>需要知道风暴的几个物理参数，例如:</p><ul class=""><li id="95cc" class="lx ly iq ku b kv ls kz lt ld nc lh nd ll ne lp nf md me mf bi translated">风暴中心周围的最大风力</li><li id="6113" class="lx ly iq ku b kv mg kz mh ld mi lh mj ll mk lp nf md me mf bi translated">最大风出现时距中心的距离</li><li id="3ad2" class="lx ly iq ku b kv mg kz mh ld mi lh mj ll mk lp nf md me mf bi translated">风暴的规模</li><li id="34bb" class="lx ly iq ku b kv mg kz mh ld mi lh mj ll mk lp nf md me mf bi translated">风暴路径是一系列纬度和经度，对应于风暴在其生命周期中的位置。</li><li id="9ab0" class="lx ly iq ku b kv mg kz mh ld mi lh mj ll mk lp nf md me mf bi translated">此外，还需要计算最大阵风的沿海和内陆位置。</li></ul></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="db73" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">问题是</h1><p id="1029" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">计算一个事件和几个位置并不特别需要计算——尽管它不应该被认为是微不足道的；有许多物理过程需要考虑。</p><p id="3af3" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">当需要为<strong class="ku ir"><em class="lq"/></strong><strong class="ku ir">事件</strong>和覆盖整个美国东海岸的位置网格<strong class="ku ir">500万网格点</strong>重复计算时，<strong class="ku ir"> <em class="lq">挑战</em> </strong>就显现出来了。<strong class="ku ir"> FORTRAN </strong>计算变得过于繁琐和耗时，因为计算<em class="lq"> 150K </em>事件需要超过两个<strong class="ku ir">月</strong>。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="7eaa" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">一切都始于一个容器。</h1><blockquote class="ng nh ni"><p id="7f00" class="ks kt lq ku b kv ls kx ky kz lt lb lc nj lu lf lg nk lv lj lk nl lw ln lo lp ij bi translated">千里之行始于足下——老子</p></blockquote><p id="c6f0" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">在我们的例子中，它以<em class="lq">单个</em> <a class="ae lr" href="https://en.wikipedia.org/wiki/OS-level_virtualization" rel="noopener ugc nofollow" target="_blank"> <em class="lq">容器</em> </a>开始。容器是一种操作系统虚拟化的方法，对测试和实验软件应用程序很有吸引力。</p><p id="3f24" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">正如在上面的一个项目目标中提到的，由于各种原因，用FORTRAN之外的另一种语言重写代码并不是一个理想的选择，这些原因包括但不限于截止日期、开发人员的工作效率、专有的科学数据格式和库。对于那些以前使用过FORTRAN的人来说，您必须意识到FORTRAN在处理跨版本兼容性问题上是出了名的棘手。</p><p id="6191" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">一般来说，由给定版本的FORTRAN编译器(版本8或更高版本)编译的代码可以与由同一编译器的更高版本编译的代码链接，只要使用更高版本的语言库和工具(如链接器)即可。反之则不然，由较新版本编译的目标代码不支持与较旧版本的库和工具链接。</p><p id="16d6" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">在克服了docker容器中的跨版本兼容性问题之后，运行单个事件足迹的计算就成功了。现在，我们需要做的就是运行<em class="lq"> 150K </em>这些容器，每个容器包含不同的事件足迹。</p><p id="5533" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">在我们弄清楚如何运行和在哪里同时运行数千个这样的事件之前，如果我们能让这些事件的计算令人尴尬地并行，将会对我们有很大的帮助；我的意思是，存放FORTRAN代码的容器对事件足迹的计算与其他事件足迹的计算很少或没有相关性。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="4f38" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">系统结构</h1><p id="e2bb" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="ku ir">为什么云？</strong></p><p id="6f7e" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">很明显，在这个阶段，我们正在处理<em class="lq">大规模并行计算问题，</em>我们需要一个集群。传统的本地集群对集群基础架构采用一刀切的方法。然而，云提供了广泛的可能性，并允许优化性能和成本。</p><p id="d696" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">您可以将整个工作负载定义为代码(基础设施即代码)，并在云中更新它。这使您能够自动化重复的过程或程序。您受益于能够一致地复制基础结构和实现操作过程。这包括自动化作业提交过程和对事件的响应，如作业开始、完成或失败。</p><p id="5ae5" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">AWS和任何其他云提供商一样，提供了为应用程序设计集群的能力。对于每个应用程序的单个集群，不再需要一刀切的模式。当在AWS上运行各种应用时，<em class="lq">可以使用各种架构</em>来满足每个应用的需求。这可以实现最佳性能，同时最大限度地降低成本。</p><p id="87ff" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated"><strong class="ku ir">云架构</strong></p><p id="2e89" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">最适合运行此类工作负载的云架构是什么？—运行<em class="lq"> 150K </em>容器的<em class="lq">大规模并行工作负载</em>，每个容器计算一个事件足迹。</p><p id="8127" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">让我们通过问一系列问题来更深入地研究一下我们拥有的大规模并行工作负载，并最终确定一个合适的云架构。</p><ol class=""><li id="4640" class="lx ly iq ku b kv ls kz lt ld nc lh nd ll ne lp mc md me mf bi translated"><strong class="ku ir">我们的工作负载并行得令人尴尬吗？</strong> <em class="lq">是的</em>，如前所述，我们的工作负载是令人尴尬的并行——计算很少或根本不依赖于其他计算。整个工作量不是迭代的。</li><li id="8ba9" class="lx ly iq ku b kv mg kz mh ld mi lh mj ll mk lp mc md me mf bi translated"><strong class="ku ir">我们的工作负载在存储需求方面是否有所不同？</strong> <em class="lq">不，</em>我们的工作负载在存储要求方面没有什么不同，但受传输、读取和写入数据所需的性能和可靠性的驱动。</li><li id="b68c" class="lx ly iq ku b kv mg kz mh ld mi lh mj ll mk lp mc md me mf bi translated"><strong class="ku ir">我们的工作负载在计算要求方面有所不同吗？</strong> <em class="lq">是的，</em>我们的工作负载在计算要求方面确实有所不同。有些事件足迹需要几秒钟，有些需要几个小时，因此需要为容器选择合适的内存与计算比率。您可以优化并找到整个工作负载的最佳比率(<em class="lq"> 2GB RAM:1个vCPU </em>)，或者定制每个工作负载的比率(【1 <em class="lq"> GB RAM:1个vCPU】，【2GB RAM:1个vCPU】</em>)。</li><li id="ad73" class="lx ly iq ku b kv mg kz mh ld mi lh mj ll mk lp mc md me mf bi translated">我们的工作负载需要高网络带宽/延迟吗？ <em class="lq">否</em>，因为我们的工作负载通常不会相互交互，所以工作负载的可行性或性能对网络带宽和容器之间的延迟能力不敏感。因此，集群放置组对于我们的情况来说是不必要的，因为它们削弱了弹性而没有提供性能增益。</li></ol><p id="df7c" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">在分析了上述问题的答案后，适合这种设计的架构是一种松散耦合的云架构<strong class="ku ir"><em class="lq"/></strong>。需要注意的另一点是，在上面的问题列表中，工作负载的可伸缩性明显缺失。可伸缩性是显而易见的，因为我们正在处理一个大规模并行系统。</p><p id="612d" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">松散耦合应用在许多领域都有，包括蒙特卡罗模拟、图像处理、基因组分析和电子设计自动化(EDA)。在松散耦合的工作负载中，丢失一个节点或一个作业通常不会延迟整个计算。丢失的工作可以稍后重新获得或者完全省略。计算中涉及的节点可能在规格和功率上有所不同。</p><p id="5d2f" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated"><strong class="ku ir">无服务器</strong></p><p id="0474" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">松散耦合的云之旅通常会带来一个完全无服务器的环境，这意味着您可以专注于您的应用程序，而将服务器配置责任留给托管服务。您可以运行代码，而无需配置或管理服务器。您只需为您消耗的计算时间付费，当您的代码不运行时，则不收费。您上传您的代码或您的容器，系统会处理运行和缩放您的代码所需的一切。</p><p id="b812" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">可伸缩性是无服务器方法的另一个优势。虽然每个任务的规模可能不大，例如，一个计算核心带有一些内存，但该架构可以产生数千个并发节点，从而达到较大的计算吞吐量。</p><p id="f29e" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated"><strong class="ku ir"> AWS Fargate </strong></p><p id="ba2c" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">AWS中的无服务器是Lambda函数的同义词，Lambda不是AWS中唯一的无服务器计算引擎，Lambda也有其局限性。一个主要的限制是可用的计算时间(15分钟)。在我们的项目中，每个任务的计算时间是不同的，从几秒到几小时不等，因此选择了<a class="ae lr" href="https://aws.amazon.com/fargate/" rel="noopener ugc nofollow" target="_blank"> Fargate </a>，这是一个用于容器的<em class="lq">无服务器</em>计算引擎。另一个限制是Lambda函数中可用的编程语言的选择。Lambda函数不支持FORTRAN代码，我们需要扩展FORTRAN代码，最好的方法之一就是使用容器来扩展它。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nm"><img src="../Images/79742cc4fa01b614b991723b0fa7ea1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B5od9pCxsZxIdIcQfZdE-Q.png"/></div></div></figure><p id="1c32" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">在上述架构中，用户通过由<a class="ae lr" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank">亚马逊API网关</a>托管并由<a class="ae lr" href="https://aws.amazon.com/cognito/" rel="noopener ugc nofollow" target="_blank">亚马逊认知</a>保护的<a class="ae lr" href="https://en.wikipedia.org/wiki/Application_programming_interface" rel="noopener ugc nofollow" target="_blank"> API </a>调用来触发这些大规模并行工作负载，并且在通过API启动运行之前，用户还必须确保输入数据存在于适当的<a class="ae lr" href="https://aws.amazon.com/s3/" rel="noopener ugc nofollow" target="_blank"> S3 </a>桶(uswind/input)中。</p><p id="516a" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">API网关触发一个Lambda函数来处理和验证请求，并启动“切片器”服务。</p><p id="4919" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">顾名思义，“切片器”服务是一个fargate任务，负责处理包含大约150K个事件的输入文件。这些事件被送入一个入站<a class="ae lr" href="https://aws.amazon.com/sqs/" rel="noopener ugc nofollow" target="_blank"> SQS </a>队列。</p><p id="063f" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">当这些事件开始流入入站SQS队列时，就会触发“Q处理器”lambda函数。它处理这些单独的事件，然后将这些事件送入另一个出站SQS队列。</p><p id="267c" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">由出站SQS队列触发的“fargate-launcher”lambda函数处理这些请求，并在AWS的fargate集群中启动这些fargate任务。</p><p id="a314" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">我们现在有一个无状态的系统，可以处理10、100甚至1000个事件。如果你打算发起10K活动，会发生什么？系统崩溃是因为AWS有一个设置限制，在任何时间点只能运行<em class="lq"> 5K </em>并行Fargate任务。</p><p id="f3dc" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">您可能还想知道为什么要通过两个SQS队列和几个Lambda函数来运行Fargate集群中的任务。这个问题的答案在于AWS速率限制fargate任务为每秒1个任务。他们在每个帐户每个地区的基础上限制RunTask API调用。我们计划总共举办150，000场比赛，同时举办大约5，000场比赛。因此，我们需要实现一个带有指数补偿的重试机制，以避免过多的请求淹没系统。</p><p id="2684" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">这个硬限制使得系统的设计经历了从无状态系统到有状态系统的范式转变。如果AWS没有上述运行<em class="lq"> 5K </em>并行任务的硬性限制，事情会简单得多。我们本应该以一种受控的方式启动<em class="lq"> 150K </em>任务/容器并完成，但是现在我们必须跟踪系统的状态。我们需要确切地知道当前有多少任务正在被处理，以及Fargate集群中每个任务的状态(成功或失败)。因此在架构中引入了<a class="ae lr" href="https://aws.amazon.com/dynamodb/" rel="noopener ugc nofollow" target="_blank"> DynamoDB </a>。</p><p id="2e90" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">所有的lambda函数和服务(切片器)现在更新DynamoDB来记录系统的当前状态。通过启用<a class="ae lr" href="https://aws.amazon.com/cloudwatch/" rel="noopener ugc nofollow" target="_blank"> Cloudwatch </a>来跟踪Fargate集群中的任务，并触发“update-status”lambda函数，该函数通过更新DynamoDB来处理状态变化，系统从无状态系统到有状态系统的蜕变现在已经完成。</p><p id="f73d" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">在fargate任务中遇到的错误由Cloudwatch捕获，并收集在DLQ(死信队列)桶中。如果需要进行代码更改，研究人员/开发人员需要做的只是将FORTRAN代码推送到DevOps系统(Azure DevOps)，构建docker映像，并将其发布到ECR。最新的图像被“fargate-launcher”lambda函数引用，该函数将容器作为Fargate集群中的任务运行。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="39d8" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">优化Fortran代码</h1><p id="cb3e" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在本节中，有两种类型的优化，一种是改进代码本身的算法，另一种(“O3”标志)是指编译器优化。</p><p id="147d" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated"><a class="ae lr" href="https://docs.oracle.com/cd/E19957-01/805-4940/6j4m1u7q6/index.html" rel="noopener ugc nofollow" target="_blank"> gprof </a> (1)命令提供了子程序级别的程序计时的详细事后分析，包括子程序被调用了多少次，谁调用了它，它调用了谁，以及它调用的例程和例程花费了多少时间。</p><p id="232f" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">其中一个事件的基线测试结果是实际运行时间为12分16秒。最初的gprof报告表明，代码中500万个4中大约有450万个被用于“<em class="lq"> apply_fric_full </em>”子例程。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nn"><img src="../Images/064e5ae8b42f566739f392fc343eac86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kvWvTzk89aAQAXwhKC1XfA.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><code class="fe no np nq nr b">The table above shows the <strong class="bd jw">gprof</strong> report and actual run time after each optimization is applied starting with the original profiling report.</code></figcaption></figure><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/038a016264af20de2c8362b7f7450681.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*h_jL4Jmgwzrxubz22bfPLQ.png"/></div></figure><p id="238f" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">通过应用优化，活动的总运行时间从12分16秒减少到3分49秒，减少了大约70%。所使用的有效优化技术之一是使用“-O3”标志，这有助于减少大约50%的运行时间。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="ee1f" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">成本分析</h1><p id="f7a8" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这里我们分析架构中最昂贵的部分AWS Fargate的成本，因为上述架构中的其他资源在成本上相对可以忽略不计。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nt"><img src="../Images/8269ddd2c2c772a1cb0b8980dc51d059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jPbHDGCXzI0P-x6h25aDSw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">定价基于任务所需的vCPU和内存资源。这两个维度可以独立配置。</figcaption></figure><p id="9aff" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">使用Fargate，不需要预先付费，您只需为您使用的资源付费。您需要为容器化应用消耗的vCPU和内存资源量付费，四舍五入到最接近的秒。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="cdc9" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="e656" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">上述大规模并行性的实现可归因于以下三个因素:</p><ol class=""><li id="605d" class="lx ly iq ku b kv ls kz lt ld nc lh nd ll ne lp mc md me mf bi translated">容器:使用容器，我们可以用任何语言在任何合理的时间内运行计算，并控制容器的内存与计算的比率。编程语言的选择非常重要。FORTRAN已经使用了几十年。在科学和工程社区中，每天都有大量的FORTRAN软件在使用。</li><li id="f8f2" class="lx ly iq ku b kv mg kz mh ld mi lh mj ll mk lp mc md me mf bi translated"><strong class="ku ir">云</strong>:在云中，可以战略性地选择网络、存储类型、计算类型，甚至部署方法，以优化特定工作负载的性能、成本和可用性，并且我们的架构可以是动态的:根据项目的需求增长和收缩。</li><li id="0b51" class="lx ly iq ku b kv mg kz mh ld mi lh mj ll mk lp mc md me mf bi translated"><strong class="ku ir">架构</strong>:运行大规模并行工作负载或多或少分为两类:松耦合和紧耦合。明智的做法是知道这些类别中哪一个更适合你，并相应地设计架构。上面的项目是一个松散耦合的大规模并行工作负载，通过分析上面“云架构”一节中的工作负载可以证明这一点。</li></ol><p id="9557" class="pw-post-body-paragraph ks kt iq ku b kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll lw ln lo lp ij bi translated">过去需要<strong class="ku ir"> <em class="lq">两个月</em> </strong>的本地工作负载现在大约需要<strong class="ku ir"> <em class="lq">四天</em> </strong>才能完成15万个事件。因此，需要设计一个可伸缩的、可靠的、可维护的系统，以因子<strong class="ku ir"> <em class="lq"> ~10x </em> </strong>显著减少计算时间。现在，我们可以自信地说，我们确实在“九霄云外”</p><h1 id="4a18" class="ju jv iq bd jw jx nu jz ka kb nv kd ke kf nw kh ki kj nx kl km kn ny kp kq kr bi translated">参考</h1></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><ol class=""><li id="b5f6" class="lx ly iq ku b kv ls kz lt ld nc lh nd ll ne lp mc md me mf bi translated"><a class="ae lr" href="https://aws.amazon.com/architecture/well-architected/" rel="noopener ugc nofollow" target="_blank">https://aws.amazon.com/architecture/well-architected/</a></li><li id="8ba3" class="lx ly iq ku b kv mg kz mh ld mi lh mj ll mk lp mc md me mf bi translated"><a class="ae lr" href="https://aws.amazon.com/fargate/pricing/" rel="noopener ugc nofollow" target="_blank">https://aws.amazon.com/fargate/pricing/</a></li><li id="90de" class="lx ly iq ku b kv mg kz mh ld mi lh mj ll mk lp mc md me mf bi translated"><a class="ae lr" href="https://docs.oracle.com/cd/E19957-01/805-4940/6j4m1u7q6/index.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/CD/e 19957-01/805-4940/6j 4 m1 u7q 6/index . html</a></li></ol></div></div>    
</body>
</html>