<html>
<head>
<title>How I Upgrade my Code-Style of MediatR Pipeline using .NET 6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何使用？网络6</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-i-upgrade-my-code-style-of-mediatr-pipeline-using-net-6-ed49aca61f47?source=collection_archive---------0-----------------------#2021-12-30">https://levelup.gitconnected.com/how-i-upgrade-my-code-style-of-mediatr-pipeline-using-net-6-ed49aca61f47?source=collection_archive---------0-----------------------#2021-12-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="de74" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">软件架构和重构</h2><div class=""/><div class=""><h2 id="c836" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">我想和你分享一下。NET 6新的<a class="ae kr" href="https://github.com/ITIXO/MediatR.Extensions.AttributedBehaviors" rel="noopener ugc nofollow" target="_blank">mediator的特性。NuGet包帮助我完善了我的MediatR管道。</a></h2></div><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/ad24c09b5566e1f86e5e1df3b72bb9bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GqBgtXJWRQbFdGRvHujPXQ.jpeg"/></div></div></figure><h1 id="c5ac" class="le lf it bd lg lh li lj lk ll lm ln lo ki lp kj lq kl lr km ls ko lt kp lu lv bi translated">什么是MediatR</h1><p id="1df1" class="pw-post-body-paragraph lw lx it ly b lz ma kd mb mc md kg me mf mg mh mi mj mk ml mm mn mo mp mq mr im bi translated">它是由<a class="ae kr" href="https://jimmybogard.com/" rel="noopener ugc nofollow" target="_blank"> Jimmy Boggard </a>为C#创建的一个流行的<a class="ae kr" href="https://github.com/jbogard/MediatR" rel="noopener ugc nofollow" target="_blank">库</a>，可以描述为一个简单的<a class="ae kr" rel="noopener ugc nofollow" target="_blank" href="/ugly-dependency-graph-the-mediator-design-pattern-is-the-solution-for-you-8b35df60558b"> Mediator模式</a>在. NET中的实现，Mediator<a class="ae kr" href="https://www.nuget.org/packages/MediatR/" rel="noopener ugc nofollow" target="_blank">NuGet包</a>目前有将近<strong class="ly jd">5000万次下载</strong>并且还在上升。</p><p id="5267" class="pw-post-body-paragraph lw lx it ly b lz ms kd mb mc mt kg me mf mu mh mi mj mv ml mm mn mw mp mq mr im bi translated">GitHub上的维基页面说:</p><p id="1798" class="pw-post-body-paragraph lw lx it ly b lz ms kd mb mc mt kg me mf mu mh mi mj mv ml mm mn mw mp mq mr im bi translated"><em class="mx">mediator是一个低野心的库，试图解决一个简单的问题——将消息的进程内发送从消息处理中分离出来。</em></p><p id="e981" class="pw-post-body-paragraph lw lx it ly b lz ms kd mb mc mt kg me mf mu mh mi mj mv ml mm mn mw mp mq mr im bi translated"><strong class="ly jd">工序内</strong>一词必不可少。这不是Kinesis或RabbitMQ那样的消息代理。这是关于从一个地方发送消息和在不同的地方处理这样的消息，但是仍然在一个过程中。</p><p id="8b13" class="pw-post-body-paragraph lw lx it ly b lz ms kd mb mc mt kg me mf mu mh mi mj mv ml mm mn mw mp mq mr im bi translated">我使用MediatR来分离命令和查询请求。所以在我的例子中，MediatR消息是查询或命令，这取决于数据流的方向。这个架构设计被称为<strong class="ly jd">命令-查询分离</strong>，我在博客文章<a class="ae kr" rel="noopener ugc nofollow" target="_blank" href="/3-cqrs-architectures-that-every-software-architect-should-know-a7f69aae8b6c?source=friends_link&amp;sk=b6dea517e74c8804f718418c834daa80">的第一段解释了每个软件架构师都应该知道的</a>3 CQRS架构。</p><p id="d63d" class="pw-post-body-paragraph lw lx it ly b lz ms kd mb mc mt kg me mf mu mh mi mj mv ml mm mn mw mp mq mr im bi translated">在下面的代码示例中，通过将<code class="fe my mz na nb b">GetWarehousesQuery</code>定义为MediatR请求(消息),将<code class="fe my mz na nb b">GetWarehousesQueryHandler</code>定义为其处理程序，您可以看到我是如何处理HTTP GET的。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">仓库查询处理</figcaption></figure></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="c887" class="le lf it bd lg lh np lj lk ll nq ln lo ki nr kj lq kl ns km ls ko nt kp lu lv bi translated">用升级代码。NET 6特性</h1><h2 id="111f" class="nu lf it bd lg nv nw dn lk nx ny dp lo mf nz oa lq mj ob oc ls mn od oe lu iz bi translated">记录</h2><p id="b343" class="pw-post-body-paragraph lw lx it ly b lz ma kd mb mc md kg me mf mg mh mi mj mk ml mm mn mo mp mq mr im bi translated">实际上，记录从1960年就伴随着我们。NET 5和C# 9，但它与一篇博客文章的主题有关，所以我也将向您介绍它们。名为<a class="ae kr" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record" rel="noopener ugc nofollow" target="_blank">的特征记录</a>。Records引入了一个更短的语法来定义一个不可变的类。我发现在声明命令或查询类时很有帮助。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="88b7" class="pw-post-body-paragraph lw lx it ly b lz ms kd mb mc mt kg me mf mu mh mi mj mv ml mm mn mw mp mq mr im bi translated">看第8行。<code class="fe my mz na nb b">GetWarehousesQuery</code>的定义现在是<strong class="ly jd">单行码</strong>。我喜欢将查询和命令类与它们的处理程序类放在一个地方，这使我的代码更整洁。</p><p id="0153" class="pw-post-body-paragraph lw lx it ly b lz ms kd mb mc mt kg me mf mu mh mi mj mv ml mm mn mw mp mq mr im bi translated">有一个<strong class="ly jd">缺点</strong>。记录初始化后，您将无法更改任何属性值。它是一个不可变的对象，每个属性的setter都是用<code class="fe my mz na nb b">init</code>关键字定义的。</p><h2 id="e561" class="nu lf it bd lg nv nw dn lk nx ny dp lo mf nz oa lq mj ob oc ls mn od oe lu iz bi translated">全球使用</h2><p id="3d6a" class="pw-post-body-paragraph lw lx it ly b lz ma kd mb mc md kg me mf mg mh mi mj mk ml mm mn mo mp mq mr im bi translated">糖的另一个特点。NET 6是<a class="ae kr" href="https://blog.jetbrains.com/dotnet/2021/11/18/global-usings-in-csharp-10/" rel="noopener ugc nofollow" target="_blank">全局使用</a>。在使用directive之前的新关键字<code class="fe my mz na nb b">global</code>使得在我们实现来自MediatR库的接口的每个文件中不包含<code class="fe my mz na nb b">using MediatR</code>成为可能。</p><p id="923a" class="pw-post-body-paragraph lw lx it ly b lz ms kd mb mc mt kg me mf mu mh mi mj mv ml mm mn mw mp mq mr im bi translated">全局使用是项目范围的，所以我建议您<strong class="ly jd">在项目文件夹的根目录下为它们创建一个专用文件</strong>。只在那里定义你的全局使用。一旦你开始在一个随机文件中写<code class="fe my mz na nb b">global using </code>，事情就会变得一团糟。</p><p id="e324" class="pw-post-body-paragraph lw lx it ly b lz ms kd mb mc mt kg me mf mu mh mi mj mv ml mm mn mw mp mq mr im bi translated">让我们用这行代码创建一个<code class="fe my mz na nb b">GlobalUsings.cs</code>文件:</p><pre class="kt ku kv kw gt of nb og oh aw oi bi"><span id="a895" class="nu lf it nb b gy oj ok l ol om">global using MediatR;</span></pre><p id="5ad9" class="pw-post-body-paragraph lw lx it ly b lz ms kd mb mc mt kg me mf mu mh mi mj mv ml mm mn mw mp mq mr im bi translated">现在，我们可以从代码示例中移除<code class="fe my mz na nb b">using MediatR;</code>。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="a91a" class="nu lf it bd lg nv nw dn lk nx ny dp lo mf nz oa lq mj ob oc ls mn od oe lu iz bi translated">文件范围的命名空间</h2><p id="42fb" class="pw-post-body-paragraph lw lx it ly b lz ma kd mb mc md kg me mf mg mh mi mj mk ml mm mn mo mp mq mr im bi translated">文件范围的名称空间意味着为每个文件定义一个名称空间，没有花括号。所以我们的代码样本可以更干净。看看下面。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="3490" class="pw-post-body-paragraph lw lx it ly b lz ms kd mb mc mt kg me mf mu mh mi mj mv ml mm mn mw mp mq mr im bi translated">一个短文件中的查询和处理程序。我就喜欢这样。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="c127" class="le lf it bd lg lh np lj lk ll nq ln lo ki nr kj lq kl ns km ls ko nt kp lu lv bi translated">使用MediatR属性化行为升级代码</h1><h2 id="2371" class="nu lf it bd lg nv nw dn lk nx ny dp lo mf nz oa lq mj ob oc ls mn od oe lu iz bi translated">MediatR管道</h2><p id="e5ee" class="pw-post-body-paragraph lw lx it ly b lz ma kd mb mc md kg me mf mg mh mi mj mk ml mm mn mo mp mq mr im bi translated">在进行最后一次升级之前，我需要解释一下什么是MediatR管道。它是为一个MediatR请求(消息)定义的管道。管道执行从<code class="fe my mz na nb b">Mediator.Send</code>方法调用开始，并将MediatR请求的对象传递给它。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi on"><img src="../Images/cfe5699d657f2c968c6fe31925f0d37c.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*rUoz8LPrnBU5ugAiXPBuWg.jpeg"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">简单管道</figcaption></figure><h2 id="5df3" class="nu lf it bd lg nv nw dn lk nx ny dp lo mf nz oa lq mj ob oc ls mn od oe lu iz bi translated">管道行为</h2><p id="564e" class="pw-post-body-paragraph lw lx it ly b lz ma kd mb mc md kg me mf mg mh mi mj mk ml mm mn mo mp mq mr im bi translated">MediatR有一个特性叫做<strong class="ly jd">管道行为</strong>。通过定义适当的接口实现，可以将行为附加到管道中。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi oo"><img src="../Images/ba68208f6ea5774a7693dd956bfd6e50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*feUMAZsDk1F7msB0uaghTg.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">带有行为的管道</figcaption></figure><p id="da6d" class="pw-post-body-paragraph lw lx it ly b lz ms kd mb mc mt kg me mf mu mh mi mj mv ml mm mn mw mp mq mr im bi translated">您可以在处理程序之前或之后附加行为<strong class="ly jd">，这取决于您将在哪里调用<code class="fe my mz na nb b">next()</code>委托。一个典型的例子是在处理程序之前验证MediatR请求表单的验证行为。</strong></p><p id="d9f5" class="pw-post-body-paragraph lw lx it ly b lz ms kd mb mc mt kg me mf mu mh mi mj mv ml mm mn mw mp mq mr im bi translated">现在是一些代码。这是我的新<code class="fe my mz na nb b">CreateWarehouseCommand</code>管道。处理程序中的代码对于概念的证明并不重要。它的作用是将新的仓库记录持久化到数据库中。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="799c" class="pw-post-body-paragraph lw lx it ly b lz ms kd mb mc mt kg me mf mu mh mi mj mv ml mm mn mw mp mq mr im bi translated">现在让我们定义验证行为。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="9267" class="pw-post-body-paragraph lw lx it ly b lz ms kd mb mc mt kg me mf mu mh mi mj mv ml mm mn mw mp mq mr im bi translated">因为我们在验证后调用<code class="fe my mz na nb b">next</code>委托，所以<code class="fe my mz na nb b">ValidateCreateWarehouseBehavior</code>将在处理程序之前执行。如果<code class="fe my mz na nb b">await next()</code>在<code class="fe my mz na nb b">if</code>之前在第14行，那么处理程序将在验证之前被调用。这就是你如何管理行为相对于处理程序或管道中另一个行为的位置。</p><p id="d018" class="pw-post-body-paragraph lw lx it ly b lz ms kd mb mc mt kg me mf mu mh mi mj mv ml mm mn mw mp mq mr im bi translated">行为必须手动注册到DI容器<strong class="ly jd">中</strong>。</p><pre class="kt ku kv kw gt of nb og oh aw oi bi"><span id="e3cc" class="nu lf it nb b gy oj ok l ol om">services.AddScoped&lt;IPipelineBehavior&lt;CreateWarehouseCommand, NewRecordDto&lt;string&gt;&gt;, ValidateCreatedWarehouseBehavior&gt;();</span></pre><p id="dbe6" class="pw-post-body-paragraph lw lx it ly b lz ms kd mb mc mt kg me mf mu mh mi mj mv ml mm mn mw mp mq mr im bi translated">顺便说一下，如果一个管道有多个行为，它们的<strong class="ly jd">执行顺序由注册到DI容器的</strong>顺序定义。这是MediatR令人不愉快的隐藏行为方式。但是在下一段我有一个很好的解决方法。</p><h2 id="b214" class="nu lf it bd lg nv nw dn lk nx ny dp lo mf nz oa lq mj ob oc ls mn od oe lu iz bi translated">中介归因行为</h2><p id="5e7a" class="pw-post-body-paragraph lw lx it ly b lz ma kd mb mc md kg me mf mg mh mi mj mk ml mm mn mo mp mq mr im bi translated">最后一次升级是mediator的扩展库，名为<a class="ae kr" href="https://github.com/ITIXO/MediatR.Extensions.AttributedBehaviors" rel="noopener ugc nofollow" target="_blank">mediator属性化行为</a>。这个库帮助你<strong class="ly jd">从开发者那里移除手工DI注册</strong>行为的责任。此外，您可以在MediatR请求定义上看到管道的行为。看一下最后一个代码示例。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="4f00" class="pw-post-body-paragraph lw lx it ly b lz ms kd mb mc mt kg me mf mu mh mi mj mv ml mm mn mw mp mq mr im bi translated">这个扩展库的另一个功能是定义行为的顺序和范围，并将其作为其他参数传递。</p><pre class="kt ku kv kw gt of nb og oh aw oi bi"><span id="485a" class="nu lf it nb b gy oj ok l ol om">[MediatRBehavior(typeof(MySingletonPipelineBehavior&lt;MyQuery&gt;), serviceLifetime: ServiceLifetime.Singleton, order: 1)]<br/>public class MyQuery : IRequest</span></pre></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="e335" class="le lf it bd lg lh np lj lk ll nq ln lo ki nr kj lq kl ns km ls ko nt kp lu lv bi translated">来源</h1><ul class=""><li id="e736" class="op oq it ly b lz ma mc md mf or mj os mn ot mr ou ov ow ox bi translated"><a class="ae kr" href="https://github.com/jbogard/MediatR" rel="noopener ugc nofollow" target="_blank">联发科GitHub </a></li><li id="6900" class="op oq it ly b lz oy mc oz mf pa mj pb mn pc mr ou ov ow ox bi translated"><a class="ae kr" href="https://github.com/ITIXO/MediatR.Extensions.AttributedBehaviors" rel="noopener ugc nofollow" target="_blank">mediator属性GitHub </a></li></ul></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="c86d" class="le lf it bd lg lh np lj lk ll nq ln lo ki nr kj lq kl ns km ls ko nt kp lu lv bi translated">遗言</h1><p id="3279" class="pw-post-body-paragraph lw lx it ly b lz ma kd mb mc md kg me mf mg mh mi mj mk ml mm mn mo mp mq mr im bi translated">感谢你的关注。在这里，我为我的每篇博文都列了一个非限制性链接列表。我是Itixo公司的一员。NET中欧会议，<a class="ae kr" href="https://www.updateconference.net/en" rel="noopener ugc nofollow" target="_blank">布拉格更新会议</a>。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><a href="https://updateconference.net"><div class="gh gi pd"><img src="../Images/be56b0efd2a363c3a712f1f8027cd179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IexAZ-1kN0ZG98cH7ZmcQQ.png"/></div></a></figure><figure class="kt ku kv kw gt kx gh gi paragraph-image"><a href="https://www.itixo.com"><div class="gh gi pe"><img src="../Images/12a16920adec927f11650961801386db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*YznkawEwT8HakguGP6GX2A.png"/></div></a><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">赞助商</figcaption></figure><h1 id="07cc" class="le lf it bd lg lh li lj lk ll lm ln lo ki lp kj lq kl lr km ls ko lt kp lu lv bi translated">进一步阅读</h1><div class="pf pg gp gr ph pi"><a rel="noopener  ugc nofollow" target="_blank" href="/from-monolith-to-microservices-in-5-minutes-83069677d021"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd jd gy z fp pn fr fs po fu fw jc bi translated">5分钟内从整体服务到微服务</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">微服务架构风格是将单个应用程序开发成一套小型服务的方法——</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pr l"><div class="ps l pt pu pv pr pw lc pi"/></div></div></a></div><div class="pf pg gp gr ph pi"><a rel="noopener  ugc nofollow" target="_blank" href="/let-me-hear-you-screaming-architecture-3adcc02f2ca3"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd jd gy z fp pn fr fs po fu fw jc bi translated">文件夹和尖叫建筑的功能组织</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">架构应该表达系统的意图——鲍勃叔叔</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pr l"><div class="px l pt pu pv pr pw lc pi"/></div></div></a></div><div class="pf pg gp gr ph pi"><a rel="noopener  ugc nofollow" target="_blank" href="/layers-in-software-architecture-that-every-sofware-architect-should-know-76b2452b9d9a"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd jd gy z fp pn fr fs po fu fw jc bi translated">每个软件架构师都应该知道的软件体系结构的层次</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">“所有的架构都有相同的目标——关注点的分离。都是通过分软件来实现的…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pr l"><div class="py l pt pu pv pr pw lc pi"/></div></div></a></div><div class="pf pg gp gr ph pi"><a rel="noopener  ugc nofollow" target="_blank" href="/3-domain-centric-architectures-every-software-developer-should-know-a15727ada79f"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd jd gy z fp pn fr fs po fu fw jc bi translated">每个软件开发人员都应该知道的3个以领域为中心的架构</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">建筑师首先关心的是确保房子是可用的，而不是确保房子是…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pr l"><div class="pz l pt pu pv pr pw lc pi"/></div></div></a></div></div></div>    
</body>
</html>