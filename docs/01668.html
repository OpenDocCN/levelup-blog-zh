<html>
<head>
<title>Dear for Loop Fans: Let Us Use Array Methods in Peace</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">亲爱的for循环爱好者:让我们和平地使用数组方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dear-for-loop-fans-let-us-use-array-methods-in-peace-af851ca9e85f?source=collection_archive---------3-----------------------#2020-01-21">https://levelup.gitconnected.com/dear-for-loop-fans-let-us-use-array-methods-in-peace-af851ca9e85f?source=collection_archive---------3-----------------------#2020-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f525" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">性能不是唯一有效的关注点</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/ba12c6040125d8763309e9cf61d4d9a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gA6WTIFZV9diggLwijZtoQ.png"/></div></div></figure><p id="3c81" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">你有没有推过一些JavaScript代码，有人说:“用一个<code class="fe lr ls lt lu b">for</code>循环，比<code class="fe lr ls lt lu b">forEach</code>快”？真是令人失望。我总是讨厌在一个有十几个物体的阵列上移除一个<code class="fe lr ls lt lu b">forEach</code>，这看起来像是浪费时间。所以，在为数组方法辩护的时候，让我们来谈谈为什么我们应该被允许使用它们而不感到内疚或羞耻。</p><h1 id="f730" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">问题中的方法有哪些？</h1><p id="05f3" class="pw-post-body-paragraph kv kw it kx b ky mo ju la lb mp jx ld le mq lg lh li mr lk ll lm ms lo lp lq im bi translated">数组方法有很多，但我说的是数组迭代器:<code class="fe lr ls lt lu b">forEach</code>、<code class="fe lr ls lt lu b">map</code>、<code class="fe lr ls lt lu b">filter</code>、<code class="fe lr ls lt lu b">every</code>、<code class="fe lr ls lt lu b">reduce</code>之类的。我喜欢Ruby中的它们，当JS的年度修订版添加了我的最爱时，我激动不已。</p><h2 id="eaf0" class="mt lx it bd ly mu mv dn mc mw mx dp mg le my mz mi li na nb mk lm nc nd mm ne bi translated">示威游行</h2><p id="f632" class="pw-post-body-paragraph kv kw it kx b ky mo ju la lb mp jx ld le mq lg lh li mr lk ll lm ms lo lp lq im bi translated">我很高兴现在不是这样了:</p><pre class="kk kl km kn gt nf lu ng nh aw ni bi"><span id="2274" class="mt lx it lu b gy nj nk l nl nm"><em class="lv">const</em> <strong class="lu iu">goodUsers</strong> = [];<br/><em class="lv">for</em> (<em class="lv">let</em> <strong class="lu iu">i</strong> = 0; <strong class="lu iu">i</strong> &lt; <strong class="lu iu">users</strong>.length; <strong class="lu iu">i</strong>++) { <br/>  <em class="lv">const</em> <strong class="lu iu">user</strong> = <strong class="lu iu">users</strong>[<strong class="lu iu">i</strong>];<br/>  <em class="lv">if</em> (<strong class="lu iu">user.</strong>isGood) <strong class="lu iu">goodUsers</strong>.push(<strong class="lu iu">user</strong>);<br/>};</span></pre><p id="eb13" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我可以做:</p><pre class="kk kl km kn gt nf lu ng nh aw ni bi"><span id="e30b" class="mt lx it lu b gy nj nk l nl nm">const <strong class="lu iu">goodUsers</strong> = <strong class="lu iu">users.</strong>filter(<strong class="lu iu">user</strong> =&gt; <strong class="lu iu">user.</strong>isGood);</span></pre><h1 id="9140" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">他们简直太棒了</h1><p id="fd22" class="pw-post-body-paragraph kv kw it kx b ky mo ju la lb mp jx ld le mq lg lh li mr lk ll lm ms lo lp lq im bi translated">如您所见，它们减少了对重复的样板代码的需求，但也增加了可读性。使用<code class="fe lr ls lt lu b">map</code>告诉我我正在返回一个数组，<code class="fe lr ls lt lu b">reduce</code> <a class="ae nn" rel="noopener ugc nofollow" target="_blank" href="/javascript-has-a-reduce-method-you-should-use-it-ff4dd29d6c9d">意味着我正在将</a>减少到一个值，而<code class="fe lr ls lt lu b">filter</code>…嗯，这意味着我正在过滤。如果你不想做什么疯狂的事情，就在数组上捕捉一个方法，然后就到此为止。这些直观的方法可以节省你的工程时间，这样你就可以担心更重要的事情。</p><h1 id="80a0" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">那么，有什么问题呢？</h1><p id="c04d" class="pw-post-body-paragraph kv kw it kx b ky mo ju la lb mp jx ld le mq lg lh li mr lk ll lm ms lo lp lq im bi translated">你不会免费得到任何东西；使用这些方法会降低性能速度。使用数组方法所需的开销意味着JS的效率会降低。在当今这个沉迷于时间的世界，这似乎是对这些方法的一个致命的标记。但事实并非如此。因为速度的差异通常停留在百分之一秒的<em class="lv">范围内。</em></p><h1 id="f8ab" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">这是关于优先权的问题</h1><p id="b1b0" class="pw-post-body-paragraph kv kw it kx b ky mo ju la lb mp jx ld le mq lg lh li mr lk ll lm ms lo lp lq im bi translated">当高级开发人员说“使用for循环，这样更快”时，他们是正确的。但是谁说100%优化是我唯一在乎的？如果我必须过滤一个100个字符串的数组，我不在乎使用<code class="fe lr ls lt lu b">for</code>循环可以节省多少毫秒。我更喜欢干净、<em class="lv">简洁、</em>易读的代码。</p><h2 id="ac3b" class="mt lx it bd ly mu mv dn mc mw mx dp mg le my mz mi li na nb mk lm nc nd mm ne bi translated">不要闻</h2><p id="6c1e" class="pw-post-body-paragraph kv kw it kx b ky mo ju la lb mp jx ld le mq lg lh li mr lk ll lm ms lo lp lq im bi translated">担心数组方法的速度意味着"<a class="ae nn" href="http://wiki.c2.com/?PrematureOptimization" rel="noopener ugc nofollow" target="_blank">过早的代码优化</a>"如果你只担心性能<em class="lv">如果速度</em> 成为问题 <strong class="kx iu"> <em class="lv">你会做得更多。即使这样，它也可能是其他一些逻辑上的，而不是语法上的，低效的代码。但是不要误解我的意思，<code class="fe lr ls lt lu b">for</code>循环也不是“坏”的。远非如此！</em></strong></p><h1 id="56a5" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">什么时候使用for循环？</h1><p id="c6dd" class="pw-post-body-paragraph kv kw it kx b ky mo ju la lb mp jx ld le mq lg lh li mr lk ll lm ms lo lp lq im bi translated">如果您需要处理庞大的列表，这时就可以感觉到性能的影响。除了速度，<code class="fe lr ls lt lu b">for</code>循环还能给你定制的行为。他们可以做一些特殊的事情，比如:使用<code class="fe lr ls lt lu b">break</code>或<code class="fe lr ls lt lu b">continue</code>；使用数字而不是数组；使用<code class="fe lr ls lt lu b">await</code>；从任何地方开始，向任何方向移动任何数量。但是要注意，在循环中使用<a class="ae nn" href="https://eslint.org/docs/rules/no-continue" rel="noopener ugc nofollow" target="_blank">中断/继续</a>和<a class="ae nn" href="https://eslint.org/docs/rules/no-await-in-loop#top" rel="noopener ugc nofollow" target="_blank">等待也是有成本的。请注意，这些都不是很宽泛的原因，这解释了为什么更多的开发人员默认使用新奇的方法，而<code class="fe lr ls lt lu b">for</code>只在必要时循环。</a></p><h1 id="78ff" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">事情正在发生变化</h1><p id="d817" class="pw-post-body-paragraph kv kw it kx b ky mo ju la lb mp jx ld le mq lg lh li mr lk ll lm ms lo lp lq im bi translated">多年来，<code class="fe lr ls lt lu b">for</code>循环是唯一真正的选择。我认为我主要从老开发者那里听到抱怨的原因是因为改变看起来是不必要的。从技术上来说<em class="lv">比</em>更有性能，方法也没有<em class="lv">那么</em>不同，所以不继续用老方法了？相信我，我能理解。JS开发者倾向于涌向最新的东西，仅仅因为它是<strong class="kx iu">新的</strong> <em class="lv"> ( </em>看着你<em class="lv">苗条)</em>。但是使用数组迭代器并不像是为了改变而改变，而是对长期困扰的一个很好的改进。这仅仅是下一个<em class="lv">迭代。</em></p><p id="41dd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">大家编码快乐，</p><p id="5628" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">麦克风</p></div></div>    
</body>
</html>