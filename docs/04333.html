<html>
<head>
<title>Reactive Streams in JavaScript with RSocket Flowable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用RSocket flow的JavaScript中的反应流</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/reactive-streams-in-javascript-with-rsocket-flowable-683097ff91eb?source=collection_archive---------13-----------------------#2020-06-21">https://levelup.gitconnected.com/reactive-streams-in-javascript-with-rsocket-flowable-683097ff91eb?source=collection_archive---------13-----------------------#2020-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/94e43153339b8f47f22d8d1df755d7a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-F82T8-BWOMjye7rc_AVCg.png"/></div></div></figure><div class=""/><p id="725d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">使用rsocket-flow在JavaScript中进行消息流、反压、取消和异步编程。</em></p><p id="46f9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在编程异步操作时，JavaScript开发人员通常至少熟悉承诺、异步/等待和回调。然而，较新的异步模型，如react vex(JavaScript中的<a class="ae la" href="https://github.com/ReactiveX/rxjs" rel="noopener ugc nofollow" target="_blank"> RxJS </a>)，并不那么受欢迎。在本文中，我们深入探讨与RxJS相似但略有不同的东西；一个名为<a class="ae la" href="https://github.com/rsocket/rsocket-js/blob/master/docs/03-flowable-api.md" rel="noopener ugc nofollow" target="_blank">RSocket flow</a>的反应流实现(RSocket-flow on NPM)。</p><h1 id="aafa" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">核心概念</h1><p id="a82c" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">r socket flow的核心是观察者模式，通过<strong class="kd jf">单个</strong>和<strong class="kd jf">可流动</strong>接口在r socket-flow中实现。</p><blockquote class="me mf mg"><p id="eddf" class="kb kc kz kd b ke kf kg kh ki kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ky im bi translated"><em class="je">观察者模式是一种软件设计模式，其中一个名为主题的对象维护一个名为观察者的依赖者列表，并自动通知它们任何状态变化，通常是通过调用它们的方法之一。</em><a class="ae la" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">【https://en.wikipedia.org/wiki/Observer_pattern】T21</a></p></blockquote><h1 id="a207" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">单一和可流动的界面</h1><figure class="mk ml mm mn gt iv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="9572" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Single是一个可观察的接口，支持以下交互:</p><ul class=""><li id="1e1c" class="mq mr je kd b ke kf ki kj km ms kq mt ku mu ky mv mw mx my bi translated">通过<code class="fe mz na nb nc b">subscriber.onComplete</code>回调发出单个值</li><li id="a23d" class="mq mr je kd b ke nd ki ne km nf kq ng ku nh ky mv mw mx my bi translated">通过<code class="fe mz na nb nc b">subscriber.onError</code>回调发出一个错误值</li><li id="2d39" class="mq mr je kd b ke nd ki ne km nf kq ng ku nh ky mv mw mx my bi translated">通过<code class="fe mz na nb nc b">cancel</code>回调的取消通过<code class="fe mz na nb nc b">onSubscribe</code>回调传递给观察者</li></ul><p id="8ac9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了取消，这些操作应该感觉很熟悉，因为它们与承诺的交互几乎相同，因为承诺只能解决或拒绝。</p><h2 id="0555" class="ni lc je bd ld nj nk dn lh nl nm dp ll km nn no lp kq np nq lt ku nr ns lx nt bi translated">单一示例</h2><p id="4886" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">消费单一接口的一个实际例子是包装一个promise API/操作，比如<code class="fe mz na nb nc b">fetch</code> API。在下面的例子中，我们就是这样做的；我们创建了一个新的Single实例，当订阅该实例时，它将调用Starwars API来检索有关卢克·天行者的数据。</p><figure class="mk ml mm mn gt iv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="cdba" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可流动是支持以下交互的可观察界面:</p><ul class=""><li id="ee7e" class="mq mr je kd b ke kf ki kj km ms kq mt ku mu ky mv mw mx my bi translated">通过<code class="fe mz na nb nc b">subscriber.onComplete</code>回调发出单个值</li><li id="2e1a" class="mq mr je kd b ke nd ki ne km nf kq ng ku nh ky mv mw mx my bi translated">当订阅<strong class="kd jf">请求回调</strong>被调用时，通过<code class="fe mz na nb nc b">subscriber.onNext</code>回调发出一个或多个值</li><li id="4973" class="mq mr je kd b ke nd ki ne km nf kq ng ku nh ky mv mw mx my bi translated">通过<code class="fe mz na nb nc b">subscriber.onError</code>回调发出一个或多个错误值</li><li id="b265" class="mq mr je kd b ke nd ki ne km nf kq ng ku nh ky mv mw mx my bi translated">通过<code class="fe mz na nb nc b">cancel</code>回调的取消通过<code class="fe mz na nb nc b">onSubscribe</code>回调传递给观察者</li></ul><p id="9a50" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">“可流动”与“单一”在根本上不同，因为我们期望“可流动”发出一个或多个值。Single只应该发出单个值或没有值。此外，可流动支持背压的概念。</p><p id="b9f8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">来自《反应宣言》:</p><blockquote class="me mf mg"><p id="ca57" class="kb kc kz kd b ke kf kg kh ki kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ky im bi translated"><em class="je"> …背压是一种重要的反馈机制，它允许系统优雅地响应负载，而不是在负载下崩溃</em><a class="ae la" href="https://www.reactivemanifesto.org/glossary#Back-Pressure" rel="noopener ugc nofollow" target="_blank"><em class="je">https://www.reactivemanifesto.org/glossary#Back-Pressure</em></a></p></blockquote><p id="6d00" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">背压的概念并不完全是rsocket-flow独有的，但与通过RxJS提供的背压支持相比，它更简单。用最简单的话来说，可流动的反压支持允许观察者控制被观察物发出或“发布”值的速率。为了支持这一点，<strong class="kd jf">可流动接口接受必须实现请求方法</strong>的订户。这个请求方法充当回调，负责根据观察者的请求“发布”值。</p><p id="a46d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">request方法负责以观察器请求的速率发布数据，观察器通过传递一个表示它可以处理的事件数量的int值来控制数据流。</p><figure class="mk ml mm mn gt iv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="fc6b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个例子中，调用<code class="fe mz na nb nc b">sub.request(3)</code>将导致用值<code class="fe mz na nb nc b">0, 1, 2</code>调用<code class="fe mz na nb nc b">onNext()</code>。</p><p id="2032" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于更复杂的“真实世界”使用示例，请阅读标记为“可流动代码示例解释”的利用可流动算法的详细解释，或者直接跳到标记为“可流动代码示例”的相应代码示例</p><p id="2cd2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面我们实现了一个可流动的发布器，它将为每部包含卢克·天行者角色的电影发送从星球大战API中检索到的数据。为了实现这一点，我们实现了传递给<code class="fe mz na nb nc b">filmsSubscriber.onSubscribe()</code>的订阅对象的请求方法，该方法大致遵循以下算法:</p><p id="ec48" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一次调用请求方法时:</p><ul class=""><li id="087a" class="mq mr je kd b ke kf ki kj km ms kq mt ku mu ky mv mw mx my bi translated">从星球大战API中获取卢克·天行者的数据，并从响应中销毁电影数组。将电影集合保存到一个<code class="fe mz na nb nc b">pendingFilms</code>变量中，这样我们可以在后续调用<code class="fe mz na nb nc b">request</code>时引用它。</li></ul><p id="ef13" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一次调用request方法时，以及以后每次调用request时:</p><ul class=""><li id="b38a" class="mq mr je kd b ke kf ki kj km ms kq mt ku mu ky mv mw mx my bi translated">遍历<code class="fe mz na nb nc b">pendingFilms</code>数组中的每个URL。</li><li id="63ba" class="mq mr je kd b ke nd ki ne km nf kq ng ku nh ky mv mw mx my bi translated">如果我们请求了观察者所请求的电影数量，则中断循环(<code class="fe mz na nb nc b">requestedFilmsCount</code>)。</li><li id="8de2" class="mq mr je kd b ke nd ki ne km nf kq ng ku nh ky mv mw mx my bi translated">如果加载了所有电影的数据，则中断循环。</li><li id="ab8e" class="mq mr je kd b ke nd ki ne km nf kq ng ku nh ky mv mw mx my bi translated">从<code class="fe mz na nb nc b">pendingFilms</code>列表中检索电影的新URL。</li><li id="f611" class="mq mr je kd b ke nd ki ne km nf kq ng ku nh ky mv mw mx my bi translated">获取从<code class="fe mz na nb nc b">pendingFilms</code>列表中删除的电影的数据，并将得到的承诺添加到未完成的承诺数组中(<code class="fe mz na nb nc b">fetches</code>)。</li><li id="d0ab" class="mq mr je kd b ke nd ki ne km nf kq ng ku nh ky mv mw mx my bi translated">一旦承诺完成，将结果数据传递给<code class="fe mz na nb nc b">filmsSubscriber.onNext(filmData)</code>。</li><li id="e95e" class="mq mr je kd b ke nd ki ne km nf kq ng ku nh ky mv mw mx my bi translated">如果承诺拒绝，则将产生的错误传递给<code class="fe mz na nb nc b">filmsSubscriber.onError(err)</code>。</li><li id="6f03" class="mq mr je kd b ke nd ki ne km nf kq ng ku nh ky mv mw mx my bi translated">一旦保存到unsettled promises数组(<code class="fe mz na nb nc b">fetches</code>)的所有承诺都已解决，检查我们是否还有尚未加载数据的电影。</li><li id="c491" class="mq mr je kd b ke nd ki ne km nf kq ng ku nh ky mv mw mx my bi translated">如果还有电影还没有加载数据，什么都不做，等待观察者对其订阅执行对<code class="fe mz na nb nc b">request</code>的后续调用。</li><li id="c867" class="mq mr je kd b ke nd ki ne km nf kq ng ku nh ky mv mw mx my bi translated">如果没有更多的电影等待加载，调用<code class="fe mz na nb nc b">filmsSubscriber.onComplete()</code>，这将向观察者表示所有可能的数据都已加载。</li></ul><p id="ee30" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种算法比利用<code class="fe mz na nb nc b">Single</code>转发承诺结果这种更简单的情况要复杂得多。然而，对控制我们提取额外数据的速率的支持，以及对取消的支持(通过小的调整)，使得增加的可流动的复杂性成为一个值得的权衡。</p><figure class="mk ml mm mn gt iv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h1 id="91a8" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">懒惰的可观测量</h1><p id="0543" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">由rsocket-flowerable实现的可观察接口是“懒惰的”，这意味着在观察者订阅可观察接口之前没有“工作”开始。这些可观测量也可以被称为“冷可观测量”，这与“热可观测量”相反。当处理热可观察对象时，无论是否存在任何观察对象，可观察对象都可能发出值。</p><figure class="mk ml mm mn gt iv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="8611" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">相比之下，您可能已经熟悉了承诺形式的“热切”或“热”界面的概念。对于Promise，一旦创建了Promise实例，就会调用传递给Promise构造函数的回调函数(或者，如果您想更具体一些，可以在事件循环的下一个节拍调用)。</p><p id="a1be" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果一棵树倒在树林里是一个热的可观测物，它会发出声音，不管周围是否有人听到。</p><figure class="mk ml mm mn gt iv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="7c6c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的例子中，无论<code class="fe mz na nb nc b">.then()</code>原型方法是否被调用，传递给Promise构造函数的回调中的<code class="fe mz na nb nc b">setTimeout</code>方法都会被调用。您可以通过将上面的示例复制到您的浏览器的dev tools控制台来验证这一点，在那里您会看到立即打印出一个控制台日志行，大约一秒钟后，紧接着是一个随机int值。</p><h1 id="32ed" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">取消</h1><p id="78b5" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">取消是可观察接口的一个强大特性，比如rsocket-flow。取消允许观察者向被观察者表明他们对正在进行的任何操作的结果不再感兴趣。在用ReactJS这样的框架编写用户界面时，取消是很有用的，在react js这样的框架中，能够取消正在进行的异步操作对于清除状态以避免卸载组件时的副作用是必不可少的。当使用WebSockets之类的协议实现有状态web服务时，取消支持也很有用，在这种情况下，客户端可以随时终止它们的连接，并且在它们断开连接后继续代表它们执行操作可能没有意义。</p><p id="a631" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在下面的示例中，我们创建了一个可流动的实例，它将发出一个整数值，直到被取消，订阅者每500毫秒(半秒钟)请求一个随机数。订户将在三秒钟后额外取消int流。这个例子类似于如何实现异步操作的超时，比如网络请求或文件读取。</p><figure class="mk ml mm mn gt iv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="2a9a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">重要的是要理解，取消可观察的流仅指示可观察的订阅者不再关心接收更新，它不会自动取消发布者可能已经执行的任何操作。如果被取消的反应对你的观察对象来说是至关重要的，那么你可以实现<code class="fe mz na nb nc b">subscription.cancel</code>回调来根据需要执行清理。</p><p id="10e5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，使用<code class="fe mz na nb nc b">rsocket-flowable@0.0.14</code>，为了避免下面的类型错误，如果您打算从订阅者调用cancel，您必须在发布者上实现cancel回调。</p><figure class="mk ml mm mn gt iv"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h1 id="e9b5" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">r socket flow的未来</h1><p id="39b2" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">在之前的一篇文章<a class="ae la" href="https://gist.github.com/the-state-of-rsocket-in-javascript" rel="noopener ugc nofollow" target="_blank">JavaScript中RSocket的状态</a>中，我们回顾了rsocket-js的未来是如何不确定的，并且随着rsocket-js的维护者声明r socket flow可能会在未来被一个<a class="ae la" href="https://github.com/rsocket/rsocket-js/issues/45#issuecomment-522035252" rel="noopener ugc nofollow" target="_blank">新项目</a>所取代，我对r socket flow也有同样的感觉。然而，GitHub回购提议的替代已经超过16个月没有收到有意义的贡献，所以很难说这是否会发生。当然，这个项目也有可能在幕后开发，作为一个封闭源码项目，将来作为OSS发布。</p><h1 id="ccf3" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">最后的想法</h1><p id="df4c" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">诸如RSocket之类的进步支持可观察模式的持续采用。RSocket对在系统中流畅流动的消息流进行建模，每个消息流都利用ReactiveX或React Streams实现。在发现RSocket之后，Reactive Streams和ReactiveX(在JavaScript中实现为RxJS)在我身上成长起来，我相信在接下来的几年中，我们将继续看到这些模式的成长和采用。在Java生态系统中，通过流行的Project Reactor，Reactive Streams已经变得越来越流行。</p><p id="76b4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果构建高度可伸缩的反应式微服务和实时接口引起了您的兴趣，我建议您深入研究这些概念。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="e644" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">最初发布于</em><a class="ae la" href="https://viglucci.io/reactive-streams-in-javascript-with-rsocket-flowable" rel="noopener ugc nofollow" target="_blank">https://viglucci . io/reactive-streams-in-JavaScript-with-rsocket-flow</a></p></div></div>    
</body>
</html>