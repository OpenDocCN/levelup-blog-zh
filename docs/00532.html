<html>
<head>
<title>Creating a Chat App with Serverless, WebSockets, and Python: A Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用无服务器、WebSockets和Python创建聊天应用程序:教程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-a-chat-app-with-serverless-websockets-and-python-a-tutorial-54cbc432e4f?source=collection_archive---------0-----------------------#2019-04-14">https://levelup.gitconnected.com/creating-a-chat-app-with-serverless-websockets-and-python-a-tutorial-54cbc432e4f?source=collection_archive---------0-----------------------#2019-04-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/496a4b7cfdd152b5227ad5f8abd08e14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iMp5eOUJthw-12RkPG3NBw.png"/></div></div></figure><p id="2a85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">临近2018年底，亚马逊在API网关中发布了对<a class="ae kw" href="https://aws.amazon.com/blogs/compute/announcing-websocket-apis-in-amazon-api-gateway/" rel="noopener ugc nofollow" target="_blank"> WebSockets的支持，最近，无服务器框架</a><a class="ae kw" href="https://serverless.com/blog/api-gateway-websockets-support/" rel="noopener ugc nofollow" target="_blank">也紧随其后</a>。有了这两种工具直接支持的WebSockets，创建一个实时、双向的应用程序比以往任何时候都更容易。</p><p id="c5e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在撰写本文时，有一些关于使用WebSockets和无服务器的教程，但是没有一个教程使用Python作为主要语言，或者从头到尾完整地描述了构建无服务器WebSocket应用程序:本文试图填补这个空白。</p><p id="2b05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本教程中，我们将构建一个规范的“聊天”应用程序，它在AWS Lambda和API Gateway的基础上使用<a class="ae kw" href="https://serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>作为后端，以及一个简单的Django客户端。另外，我们将使用<a class="ae kw" href="https://github.com/lgoodridge/django-uniauth/" rel="noopener ugc nofollow" target="_blank"> django-uniauth </a>来认证用户，并使用<a class="ae kw" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JSON Web Tokens (JWT) </a>来保护我们的请求。</p><h1 id="a132" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">步骤1:创建一个AWS用户</strong></h1><p id="aa86" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们要做的第一件事是创建一个AWS用户来管理应用程序。您也可以使用您已经创建的应用程序，但是为每个应用程序设置单独的用户对于安全性(和组织)来说稍微好一点。</p><p id="a91d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">登录<a class="ae kw" href="https://console.aws.amazon.com/iam/home" rel="noopener ugc nofollow" target="_blank"> IAM管理控制台</a>，进入用户，点击“添加用户”。给它一个用户名，并确保在继续之前检查“编程访问”。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/a4730290eb4200c43c7f9a4c8bc3544c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aztLoqxaehn44jAAh6MtXQ.png"/></div></div></figure><p id="b6be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，选择“直接附加现有策略”，并授予用户“AdministratorAccess”。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/883f0822e822589f23cc920d35ee672b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MRQOWyo45aqFjy7qATRDwQ.png"/></div></div></figure><p id="a9f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了简单起见，我们使用这个策略，但是对于实际的应用程序，您应该准确地选择您需要的权限。</p><p id="8529" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您愿意，可以为用户添加标签，否则，继续添加，直到最终创建用户。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/139dd08ec289b5c68674637e626bf7f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sQLJIWDk8dMa70GaJAlzhA.png"/></div></div></figure><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/ca481d92c13d1ca4a9adc7249538d627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WVS-8Mb8uVqG8MrQM7xUpw.png"/></div></div></figure><p id="69f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下载凭证CSV文件并将其存储在安全的地方，或者至少记下访问密钥和秘密密钥。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/90848e46df5a71ad373630c9adf9c96c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c272rOvHXtr8WXnS5USOEA.png"/></div></div></figure><p id="57a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在在<code class="fe mg mh mi mj b">~/.aws/credentials</code>中为其添加条目</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="9c40" class="mo ky iq mj b gy mp mq l mr ms">[serverless-chat-tutorial]<br/>aws_access_key_id = &lt;YOUR_ACCESS_KEY&gt;<br/>aws_secret_access_key = &lt;YOUR_SECRET_KEY&gt;</span></pre><h1 id="b171" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">步骤2:安装+配置无服务器</h1><p id="eb3e" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">与所有Python项目一样，使用一个虚拟环境来隔离我们的依赖关系是一个好主意。为应用程序创建目录:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="06aa" class="mo ky iq mj b gy mp mq l mr ms">mkdir serverless-chat-tutorial<br/>cd serverless-chat-tutorial</span></pre><p id="6838" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后创建并激活虚拟环境:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="4268" class="mo ky iq mj b gy mp mq l mr ms">virtualenv -p python3 venv<br/>. venv/bin/activate</span></pre><p id="befa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们安装无服务器:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="a36e" class="mo ky iq mj b gy mp mq l mr ms">sudo npm install -g serverless</span></pre><p id="f8ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并导出必要的环境变量:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="c49c" class="mo ky iq mj b gy mp mq l mr ms">export AWS_PROFILE=serverless-chat-tutorial<br/>export AWS_REGION=us-east-1</span></pre><p id="a340" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我喜欢设置我的虚拟环境，通过将这些行添加到<code class="fe mg mh mi mj b">venv/bin/activate</code>脚本中，在环境被激活时导出它们。</p><h1 id="a9f9" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">步骤3:编写一个无服务器Ping函数</h1><p id="64db" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">让我们通过编写一个简单的“ping”函数来尝试一下无服务器框架，这个函数只是向调用者返回一个字符串。</p><p id="842e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，为后端创建一个文件夹:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="8de7" class="mo ky iq mj b gy mp mq l mr ms">mkdir backend<br/>cd backend</span></pre><p id="d56c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，让Serverless为我们创建一些样板代码:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="c6f6" class="mo ky iq mj b gy mp mq l mr ms">serverless create --template aws-python3 --name serverless-chat</span></pre><p id="dfe3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个命令为名为“无服务器聊天”的服务创建一个模板<code class="fe mg mh mi mj b">handler.py</code>和<code class="fe mg mh mi mj b">serverless.yml</code>。它还在当前目录中创建一个<code class="fe mg mh mi mj b">.gitignore</code>(如果您愿意，可以删除它)。</p><p id="f04d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">忽略注释，初始的<code class="fe mg mh mi mj b">serverless.yml</code>文件将如下所示:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ff9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个文件负责配置Serverless将如何部署您的服务，包括您的AWS Lambda函数，以及最终您的服务需要的任何资源。</p><p id="7561" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mg mh mi mj b">handler.py</code>文件将如下所示:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="60ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您所料，这个文件实际上会保存已部署的AWS Lambda函数的代码。如果您愿意，您可以将这些方法拆分成单独的文件，但是为了简单起见，本教程将把所有内容都放在<code class="fe mg mh mi mj b">handler.py</code>中。</p><p id="8a9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些模板文件一起构成了一个简单的Hello World函数，可以立即部署。我们开始吧！</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="9e72" class="mo ky iq mj b gy mp mq l mr ms">serverless deploy</span></pre><p id="db16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果一切顺利，您将看到如下所示的输出:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="7fc2" class="mo ky iq mj b gy mp mq l mr ms">Serverless: Packaging service...<br/>Serverless: Excluding development dependencies...<br/>Serverless: Creating Stack...<br/>Serverless: Checking Stack create progress...<br/>.....<br/>Serverless: Stack create finished...<br/>Serverless: Uploading CloudFormation file to S3...<br/>Serverless: Uploading artifacts...<br/>Serverless: Uploading service serverless-chat.zip file to S3 (307 B)...<br/>Serverless: Validating template...<br/>Serverless: Updating Stack...<br/>Serverless: Checking Stack update progress...<br/>................<br/>Serverless: Stack update finished...<br/>Service Information<br/>service: serverless-chat<br/>stage: dev<br/>region: us-east-1<br/>stack: serverless-chat-dev<br/>resources: 5<br/>api keys:<br/>  None<br/>endpoints:<br/>  None<br/>functions:<br/>  hello: serverless-chat-dev-hello<br/>layers:<br/>  None</span></pre><p id="945d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以使用以下命令调用您的函数:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="9434" class="mo ky iq mj b gy mp mq l mr ms">serverless invoke -f hello</span></pre><p id="6925" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它应该会返回如下内容:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="1db0" class="mo ky iq mj b gy mp mq l mr ms">{<br/>    "statusCode": 200,<br/>    "body": "{\"message\": \"Go Serverless v1.0! Your function executed successfully!\", \"input\": {}}"<br/>}</span></pre><p id="b93a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了，它还活着！但是现在，调用这个函数的唯一方法是通过命令行:如果我们要构建一个API，它需要通过一个公共URL来访问。我们不是想要一个“ping”功能吗？让我们改变这一点。</p><p id="9fd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mg mh mi mj b">handler.py</code>中，将“hello”函数名改为“ping”，并将正文改为简单回显“PONG！”：</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="abbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mg mh mi mj b">serverless.yml</code>中，将“hello”函数更新为“ping ”,并使用新的处理函数。另外，添加一个事件，在请求<code class="fe mg mh mi mj b">/ping</code> URL路径时触发该函数:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d63a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在重新部署:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="e80d" class="mo ky iq mj b gy mp mq l mr ms">serverless deploy</span></pre><p id="5acc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在部署输出的末尾，您应该会看到服务公开的公共端点的列表。它将类似于以下内容:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="4410" class="mo ky iq mj b gy mp mq l mr ms">...<br/>endpoints:<br/>  GET - https://**********.execute-api.us-east-1.amazonaws.com/dev/ping<br/>...</span></pre><p id="0e79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以用浏览器访问这个URL，或者通过<code class="fe mg mh mi mj b">curl</code>或任何其他您喜欢的命令行工具来测试它。(测试时使用您自己的端点URL)</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="d57f" class="mo ky iq mj b gy mp mq l mr ms">curl "https://**********.execute-api.us-east-1.amazonaws.com/dev/ping"</span><span id="b25a" class="mo ky iq mj b gy mv mq l mr ms">PONG!</span></pre><p id="d30c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">成功！</p><h1 id="6770" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">步骤4:添加和查看日志</h1><p id="af59" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们最终需要调试我们的API。使用无服务器基础设施使这变得有点棘手，因为没有服务器可以登录和测试，但使用<a class="ae kw" href="https://aws.amazon.com/cloudwatch/" rel="noopener ugc nofollow" target="_blank"> AWS CloudWatch </a>仍然是可行的。</p><p id="0d23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Lambda函数中的任何<a class="ae kw" href="https://docs.aws.amazon.com/lambda/latest/dg/python-logging.html" rel="noopener ugc nofollow" target="_blank"> print语句或Logger方法</a>都会在AWS CloudWatch中生成一个日志条目。默认情况下，使用Logger方法将为我们提供时间戳和可过滤的日志级别，因此我们将在本教程中使用它们。</p><p id="22e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">返回到<code class="fe mg mh mi mj b">handler.py</code>，添加代码以导入<code class="fe mg mh mi mj b">logging</code>模块，创建一个记录器，并在<code class="fe mg mh mi mj b">ping</code>函数中使用它。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b324" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重新部署后端，然后调用ping函数。</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="e03a" class="mo ky iq mj b gy mp mq l mr ms">serverless deploy</span><span id="6471" class="mo ky iq mj b gy mv mq l mr ms">...</span><span id="1401" class="mo ky iq mj b gy mv mq l mr ms">curl "&lt;YOUR_PING_ENDPOINT&gt;"</span></pre><p id="40c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，<a class="ae kw" href="https://console.aws.amazon.com/cloudwatch/home" rel="noopener ugc nofollow" target="_blank">登录CloudWatch </a>，进入日志。您应该看到已经为AWS Lambda ping函数创建了一个新的日志组。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/50d753797d661f7ec44994c61a85bed9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-T5SKsuklrZG7CcBjfPfMQ.png"/></div></div></figure><p id="12e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">单击该日志组，然后单击最新的日志流，您应该会看到最近一次调用该函数时生成的日志，包括您的新“Ping requested”条目。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/68d653439df408f28a64d59a0c64a1b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ukjRySYZGAldHeuZes-Ztg.png"/></div></div></figure><p id="0244" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在AWS Lambda / Serverless上调试更复杂的函数时，这将是您最好的资产之一。</p><h1 id="a221" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">步骤5:添加数据库+ Python依赖项</h1><p id="3e43" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们正准备开始编写我们的WebSocket API，但是首先，我们需要一个数据库。在本教程中，我们将使用<a class="ae kw" href="https://aws.amazon.com/dynamodb/" rel="noopener ugc nofollow" target="_blank"> DynamoDB </a>，这是一个易于设置的NoSQL数据库。</p><p id="c9cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要一个表来跟踪我们的WebSocket连接id，另一个表来存储在聊天室中发送的消息。让我们首先创建连接表。</p><p id="89fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://console.aws.amazon.com/dynamodb/home" rel="noopener ugc nofollow" target="_blank">登录DynamoDB </a>，点击“创建表格”。为该表命名，并输入“ConnectionID”作为分区键。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/c222ae9c3069671095dd79111255f94c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PP5pfVjs6ZSaEmp7iIQN1w.png"/></div></div></figure><p id="59ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">连接表加载完成后，再次单击“创建表”。给它命名，这一次，输入“Room”作为分区键，输入“Index”作为数字排序键。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/7367e0acd0e5ee08d41410be2137912d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dbqVUxSiVvfah6eM_FaB7Q.png"/></div></div></figure><p id="bf31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创造它。如果您希望仔细检查您的主键列，请在完成后单击Items选项卡。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/ca0e3efb9e2c0104cabdc0024f33c8ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ypebO0UctKof6K68IiK66Q.png"/></div></div></figure><p id="a926" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在它是空的，但是您可以返回到此选项卡，在输入项目时查看表中的项目。</p><p id="f86f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们需要设置我们的后端代码，以便能够与数据库进行交互。在Python中，你通过<code class="fe mg mh mi mj b"><a class="ae kw" href="http://boto.cloudhackers.com/en/latest/" rel="noopener ugc nofollow" target="_blank">boto</a></code> <a class="ae kw" href="http://boto.cloudhackers.com/en/latest/" rel="noopener ugc nofollow" target="_blank">模块</a>与亚马逊服务进行交互。亚马逊Lambda实际上已经在它的服务器上默认安装了<code class="fe mg mh mi mj b">boto</code>，但是在这篇文章发表的时候，预装的版本已经过时了，并且缺少我们需要的关键特性，所以我们无论如何都需要指定我们自己的。</p><p id="e956" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，打开<code class="fe mg mh mi mj b">serverless.yml</code>，并添加一个<code class="fe mg mh mi mj b">iamRoleStatement</code>以允许DynamoDB操作(如果您在不同的地区，请更改“us-east-1”)。</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="8c52" class="mo ky iq mj b gy mp mq l mr ms">provider:<br/>    name: aws<br/>    runtime: python3.7<br/>    iamRoleStatements:<br/>        - Effect: Allow<br/>          Action:<br/>              - "dynamodb:PutItem"<br/>              - "dynamodb:GetItem"<br/>              - "dynamodb:UpdateItem"<br/>              - "dynamodb:DeleteItem"<br/>              - "dynamodb:BatchGetItem"<br/>              - "dynamodb:BatchWriteItem"<br/>              - "dynamodb:Scan"<br/>              - "dynamodb:Query"<br/>          Resource:<br/>              - "arn:aws:dynamodb:us-east-1:*:*"</span></pre><p id="71d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了指定我们的python依赖项，我们将使用一个名为“<a class="ae kw" href="https://www.npmjs.com/package/serverless-python-requirements" rel="noopener ugc nofollow" target="_blank">server less-python-requirements</a>”的插件，它将读取根部署目录中的一个<code class="fe mg mh mi mj b">requirements.txt</code>文件，并在将处理函数推送到AWS Lambda之前为我们安装它们。整洁！</p><p id="547e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，通过运行以下命令在本地安装插件:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="7ada" class="mo ky iq mj b gy mp mq l mr ms">serverless plugin install -n serverless-python-requirements</span></pre><p id="9f24" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，这也将在当前目录中创建<code class="fe mg mh mi mj b">package.json</code>、<code class="fe mg mh mi mj b">package-lock.json</code>和一个<code class="fe mg mh mi mj b">node_modules</code>文件夹。</p><p id="57ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，将以下几行添加到<code class="fe mg mh mi mj b">serverless.yml</code>(前两行可能已经被上面的命令添加了):</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="593d" class="mo ky iq mj b gy mp mq l mr ms">plugins:<br/>    - serverless-python-requirements</span><span id="963f" class="mo ky iq mj b gy mv mq l mr ms">custom:<br/>    pythonRequirements:<br/>        dockerizePip: true<br/>        noDeploy: []</span></pre><p id="f1a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前两行告诉serverless使用python-requirements插件，剩下的几行是我们如何配置它的。</p><p id="811c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要<code class="fe mg mh mi mj b">dockerizePip</code>,因为Amazon Lambda处理程序运行一个我们目前可能没有开发的特定版本的Linux。因此，所有依赖项在被推送到AWS之前都被安装在Docker实例中。(注意，这需要你下载并安装<a class="ae kw" href="https://www.docker.com/get-started" rel="noopener ugc nofollow" target="_blank"> Docker </a>，如果你还没有的话)。</p><p id="654a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第<code class="fe mg mh mi mj b">noDeploy</code>行告诉Amazon Lambda使用我们指定的任何软件包版本，如果它们碰巧已经安装了的话。更新后的<code class="fe mg mh mi mj b">serverless.yml</code>文件应该如下所示:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f39b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，安装<code class="fe mg mh mi mj b">boto3</code>和<code class="fe mg mh mi mj b">botocore</code> python包:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="dcf7" class="mo ky iq mj b gy mp mq l mr ms">pip install boto3 botocore</span></pre><p id="68a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并创建一个<code class="fe mg mh mi mj b">requirements.txt</code>文件，将它们列为依赖项:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="ea3c" class="mo ky iq mj b gy mp mq l mr ms">pip freeze &gt; requirements.txt</span></pre><p id="ce1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，我的<code class="fe mg mh mi mj b">requirements.txt</code>看起来是这样的(你可能有不同的版本号):</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="c73b" class="mo ky iq mj b gy mp mq l mr ms">boto3==1.9.130<br/>botocore==1.12.130<br/>... (Less important packages) ...</span></pre><p id="bed2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的后端目录如下所示:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="0799" class="mo ky iq mj b gy mp mq l mr ms">.<br/>├── .gitignore<br/>├── .serverless/<br/>├── handler.py<br/>├── node_modules/<br/>├── package-lock.json<br/>├── package.json<br/>├── requirements.txt<br/>└── serverless.yml</span></pre><p id="07f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在应该能够在Python处理程序中读取和更新数据库了。让我们修改ping方法来证明它。</p><p id="0a65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">导入<code class="fe mg mh mi mj b">boto3</code>并在文件顶部创建一个Dynamo DB资源，然后编写一些代码来访问Messages表并向其中添加一个条目。你可能会发现boto3文档很有帮助。</p><p id="b8bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更新后的<code class="fe mg mh mi mj b">handler.py</code>应该有点像这样:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9759" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，我已经为数据库中的项目添加了一些额外的键:</p><ul class=""><li id="b820" class="mw mx iq ka b kb kc kf kg kj my kn mz kr na kv nb nc nd ne bi translated">时间戳:跟踪消息的创建时间</li><li id="cfc9" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated">用户名:创建消息的人的用户名</li><li id="d372" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated">内容:消息中的实际文本</li></ul><p id="d1cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在重新部署并调用ping函数:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="64d9" class="mo ky iq mj b gy mp mq l mr ms">serverless deploy</span><span id="902f" class="mo ky iq mj b gy mv mq l mr ms">...</span><span id="ea04" class="mo ky iq mj b gy mv mq l mr ms">curl "&lt;YOUR_PING_ENDPOINT&gt;"</span></pre><p id="e2ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您访问DynamoDB，然后转到Messages表并单击Items选项卡，您应该会看到新创建的消息。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/7f3aed38fd616dccc6040e707e6e1ffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a-f2WpqDS5QK7hT0_7-dJg.png"/></div></div></figure><p id="6e57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果没有，请按照步骤4中的描述访问CloudWatch，以帮助您调试出了什么问题。</p><h1 id="cd99" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">步骤6:编写WebSocket处理程序</h1><p id="53dc" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们终于找到好东西了！设置完成后，是时候编写核心WebSocket处理程序了。</p><p id="65c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的API将支持四个函数:<code class="fe mg mh mi mj b">connectionManager</code>用于处理与WebSocket的连接和断开，<code class="fe mg mh mi mj b">sendMessage</code>用于向聊天室发送消息，<code class="fe mg mh mi mj b">getRecentMessages</code>用于检索最近的聊天消息(在第一次连接时使用)，以及<code class="fe mg mh mi mj b">defaultMessage</code>用于优雅地处理API不支持的请求。</p><p id="24ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开<code class="fe mg mh mi mj b">handler.py</code>，为连接管理器创建一个函数:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a116" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Amazon Lambda <a class="ae kw" href="https://docs.aws.amazon.com/lambda/latest/dg/python-programming-model-handler-types.html" rel="noopener ugc nofollow" target="_blank">通过事件参数传递事件数据</a>，我们可以用它来访问<code class="fe mg mh mi mj b">connectionId</code>。我们还可以访问<code class="fe mg mh mi mj b">eventType</code>，它告诉我们用户是连接还是断开WebSocket。</p><p id="0692" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，编写代码，在连接时将<code class="fe mg mh mi mj b">connectionId</code>添加到连接表中，在断开时将其移除。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2042" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，函数应该在退出时返回一个响应字典，就像我们的ping函数一样。我们需要做很多这样的工作，所以我创建了一个助手函数来帮我打包。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="74e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，让我们创建发送消息的处理程序。我们需要做的第一件事是解析来自客户端的消息数据。客户端需要提供消息的内容，现在还需要提供发送消息的人的用户名。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2507" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在更新WebSocket侦听器之前，我们应该将新消息存储在数据库中。我们项目中的一个<code class="fe mg mh mi mj b">Message</code>项有<code class="fe mg mh mi mj b">Username</code>、<code class="fe mg mh mi mj b">Content</code>、<code class="fe mg mh mi mj b">Room</code>、<code class="fe mg mh mi mj b">Index</code>和<code class="fe mg mh mi mj b">Timestamp</code>字段。<code class="fe mg mh mi mj b">Username</code>和<code class="fe mg mh mi mj b">Content</code>是客户提供给我们的。现在，每个人都将发布到同一个<code class="fe mg mh mi mj b">Room</code>，所以我们可以将其设置为某个常量字符串(如果我们想要支持私人聊天，客户端也将发送<code class="fe mg mh mi mj b">Room</code>来发布到)。我们将通过查询数据库中的最后一个<code class="fe mg mh mi mj b">Message</code>来手动计算<code class="fe mg mh mi mj b">Index</code>，并将其索引递增1。最后，我们可以使用Python的<code class="fe mg mh mi mj b">time</code>模块轻松计算出<code class="fe mg mh mi mj b">Timestamp</code>。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7168" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，消息应该发送给连接到WebSocket的所有侦听器。首先，我们查询Connections表中的所有连接id，然后我们将消息(去掉所有不必要的数据)发送给每个连接。为了实际发送消息，我们可以使用<code class="fe mg mh mi mj b"><a class="ae kw" href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/apigatewaymanagementapi.html#ApiGatewayManagementApi.Client.post_to_connection" rel="noopener ugc nofollow" target="_blank">boto3</a></code> <a class="ae kw" href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/apigatewaymanagementapi.html#ApiGatewayManagementApi.Client.post_to_connection" rel="noopener ugc nofollow" target="_blank">的API网关管理API </a>中的<code class="fe mg mh mi mj b">post_to_connection</code>方法。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ef4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们编写获取10条最新消息的处理程序。为此，我们以反向索引顺序查询前10项，这是通过设置<code class="fe mg mh mi mj b">Limit=10</code>和<code class="fe mg mh mi mj b">ScanIndexForward=False</code>实现的。然而，这给了我们按时间倒序排列的原始的<code class="fe mg mh mi mj b">Message</code>项，所以在发送给客户机之前，我们颠倒了列表，去掉了项，只包含了<code class="fe mg mh mi mj b">username</code>和<code class="fe mg mh mi mj b">content</code>。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d38b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们将编写默认的消息处理程序，它只是记录事件并返回400状态代码。我还将数据库测试从ping函数处理程序中取出，并更新它以使用<code class="fe mg mh mi mj b">_get_response</code>助手函数。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="5e6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">写完所有的处理函数后，我们只需要为无服务器配置它们。打开<code class="fe mg mh mi mj b">serverless.yml</code>并将下列行添加到<code class="fe mg mh mi mj b">provider</code>:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="5df7" class="mo ky iq mj b gy mp mq l mr ms">provider:<br/>    ...<br/>    websocketApiName: serverless-chat-api<br/>    websocketApiRouteSelectionExpression: $request.body.action</span></pre><p id="d6af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一行由API Gateway在设置WebSocket端点时内部使用。第二个指定使用数据字典中的哪个键来确定“路线”，这决定了要运行的API函数(稍后将详细介绍)。</p><p id="5daa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要给予无服务器权限来管理WebSocket连接:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="a6ba" class="mo ky iq mj b gy mp mq l mr ms">provider:<br/>    ...<br/>    iamRoleStatements:<br/>        - Effect: Allow<br/>          Action:<br/>              - "execute-api:ManageConnections"<br/>          Resource:<br/>              - "arn:aws:execute-api:*:*:**/@connections/*"<br/>        ...</span></pre><p id="69e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们需要将我们的函数处理程序链接到WebSocket路由，如下所示:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="0c4e" class="mo ky iq mj b gy mp mq l mr ms">functions:<br/>    ...<br/>    defaultMessage:<br/>        handler: handler.default_message<br/>        events:<br/>            - websocket:<br/>                route: $default<br/>    ...</span></pre><p id="5cba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，<code class="fe mg mh mi mj b">$connect</code>、<code class="fe mg mh mi mj b">$disconnect</code>和<code class="fe mg mh mi mj b">$default</code>是特殊的路由，如果您想要各自的内置WebSocket事件，需要在前面加上“$”。没有其他路由需要“$”。</p><p id="34de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最终的<code class="fe mg mh mi mj b">serverless.yml</code>文件应该是这样的:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8b93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">WebSockets API终于准备好了。重新部署:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="eae2" class="mo ky iq mj b gy mp mq l mr ms">serverless deploy</span></pre><p id="8e6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并重新检查输出的端点。您应该会看到在您的ping函数下出现了一个新的:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="822b" class="mo ky iq mj b gy mp mq l mr ms">...<br/>endpoints:<br/>  GET - &lt;YOUR_PING_ENDPOINT&gt;<br/>  wss://**********.execute-api.us-east-1.amazonaws.com/dev<br/>...</span></pre><p id="480f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">新的端点是您的WebSocket端点。你可以用任何你想要的工具来测试它。一个简单的选项是<a class="ae kw" href="https://github.com/websockets/wscat" rel="noopener ugc nofollow" target="_blank"> WebSocket cat </a>，您可以使用以下命令安装它:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="f208" class="mo ky iq mj b gy mp mq l mr ms">npm install -g wscat</span></pre><p id="d541" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装后，连接到您的WebSocket端点:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="6f82" class="mo ky iq mj b gy mp mq l mr ms">wscat -c &lt;YOUR_WEBSOCKET_ENDPOINT&gt;</span></pre><p id="61bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后发送请求，使用“action”作为路由值:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="c6e5" class="mo ky iq mj b gy mp mq l mr ms">{"action": "sendMessage", "username": "test-websocket-user", "content": "Testing the Websocket API."}</span></pre><p id="1a4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和以前一样，如果出现任何问题，您可以使用CloudWatch和DynamoDB控制台来帮助您进行调试。</p><h1 id="af67" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">步骤7:编写客户端</h1><p id="4018" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">随着后端功能的完善，我们现在可以编写一个简单的客户端来与之交互。本教程将使用<a class="ae kw" href="https://www.djangoproject.com/" rel="noopener ugc nofollow" target="_blank"> Django </a>，一个流行的Python web框架。</p><p id="a2a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(注意:本教程的重点是无服务器和WebSockets，而不是构建客户端，因此我将假设对Django有一些熟悉，并略读任何与WebSocket无关的组件。)</p><p id="7b0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，安装Django:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="5476" class="mo ky iq mj b gy mp mq l mr ms">pip install Django</span></pre><p id="ac2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后进入包含<code class="fe mg mh mi mj b">backend</code>目录的目录，并开始一个新的Django项目。</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="fdea" class="mo ky iq mj b gy mp mq l mr ms">django-admin startproject project<br/>mv project client</span></pre><p id="bd82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在项目中创建新的“聊天”应用程序。</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="b6ed" class="mo ky iq mj b gy mp mq l mr ms">cd client<br/>python manage.py startapp chat</span></pre><p id="2fdb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的存储库现在看起来像这样:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="c35d" class="mo ky iq mj b gy mp mq l mr ms">.<br/>├── backend/<br/>├── client/<br/>    ├── chat/<br/>        ├── __init__.py<br/>        ├── admin.py<br/>        ├── app.py<br/>        ├── migrations/<br/>        ├── models.py<br/>        ├── tests.py<br/>        └── views.py<br/>    ├── manage.py<br/>    └── project/<br/>        ├── __init__.py<br/>        ├── settings.py<br/>        ├── urls.py<br/>        └── wsgi.py<br/>└── venv/</span></pre><p id="c954" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mg mh mi mj b">client</code>目录中，进行以下编辑:</p><p id="f034" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mg mh mi mj b">project/settings.py</code>中，将“聊天”添加到<code class="fe mg mh mi mj b">INSTALLED_APPS</code>设置中。</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="c749" class="mo ky iq mj b gy mp mq l mr ms">INSTALLED_APPS = [<br/>    ...<br/>    'chat',<br/>]</span></pre><p id="39a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mg mh mi mj b">project/urls.py</code>中，在空路径中包含聊天应用程序URL。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="158d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">进入聊天应用目录。</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="c8a9" class="mo ky iq mj b gy mp mq l mr ms">cd chat</span></pre><p id="af48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一个<code class="fe mg mh mi mj b">templates</code>目录，并在其中创建一个<code class="fe mg mh mi mj b">chat</code>目录。</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="881f" class="mo ky iq mj b gy mp mq l mr ms">mkdir templates<br/>mkdir templates/chat</span></pre><p id="dad3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在新的<code class="fe mg mh mi mj b">templates/chat</code>目录中，为应用程序创建一个<code class="fe mg mh mi mj b">index.html</code>文件。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6581" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在聊天应用目录中，创建一个<code class="fe mg mh mi mj b">static</code>目录，并在其中创建一个<code class="fe mg mh mi mj b">chat</code>目录。</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="f6fa" class="mo ky iq mj b gy mp mq l mr ms">mkdir static<br/>mkdir static/chat</span></pre><p id="00b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在新的<code class="fe mg mh mi mj b">static/chat</code>目录中，创建一个<code class="fe mg mh mi mj b">style.css</code>文件来设计索引页面。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="5f2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们只需要创建并路由一个视图来显示新模板。回到聊天应用目录，将以下内容添加到<code class="fe mg mh mi mj b">views.py</code>:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b395" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，创建一个名为<code class="fe mg mh mi mj b">urls.py</code>的文件，并将索引视图路由到空路径。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="acfe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">移回到<code class="fe mg mh mi mj b">client</code>目录，应用任何初始迁移，并启动Django服务器。</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="ee44" class="mo ky iq mj b gy mp mq l mr ms">cd ..<br/>python manage.py migrate<br/>python manage.py runserver</span></pre><p id="db66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在浏览器中访问<code class="fe mg mh mi mj b">localhost:8000</code>，您应该会看到索引页面。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/0b6567d93b86517b8847f6b93ae5ca66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JNIs7SCMJV83Vm7KZgTPgg.png"/></div></div></figure><p id="4b89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，它实际上没有连接到任何东西，底部的Post按钮目前没有任何作用。是时候弥补了。</p><p id="3e8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从聊天应用程序目录，在<code class="fe mg mh mi mj b">static/chat</code>目录中创建一个名为<code class="fe mg mh mi mj b">custom.js</code>的新文件。这个文件将包含我们的客户端WebSocket交互代码。</p><p id="5b8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先创建一个函数来设置WebSocket，并初始化一个Socket变量。Javascript有一个<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket" rel="noopener ugc nofollow" target="_blank">内置的WebSocket api </a>，但是我喜欢将这个<a class="ae kw" href="https://github.com/joewalnes/reconnecting-websocket" rel="noopener ugc nofollow" target="_blank">重新连接WebSocket库</a>用于不想关闭WebSocket连接的页面。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="07dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们定义在某些WebSocket事件上调用的回调函数。例如，当WebSocket最初打开时，将调用<code class="fe mg mh mi mj b">socket.onopen</code>处的函数。</p><p id="e130" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的<code class="fe mg mh mi mj b">onopen</code>回调函数，我们想要调用<code class="fe mg mh mi mj b">getRecentMessages</code> API函数，以最初填充消息列表。我们的API的路由关键字是“action”，所以我们创建一个字典设置“action”为“getRecentMessages”，用JSON序列化它，然后在socket上发送它。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2940" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当客户端在WebSocket上接收数据时，就会调用<code class="fe mg mh mi mj b">socket.onmessage</code>回调。对于我们的应用程序，我们只想反序列化数据，然后在消息列表中显示新消息。</p><p id="2bc4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">包含一些额外的逻辑来显示“您”,而不是当前用户发布的消息的用户名。由于用户还没有用户名(因为没有任何东西可以登录)，我们使用一个随机生成的数字来制作一个假用户名。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="547f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，编写一个发布新消息的方法。我们只需要获取输入字段中的文本，然后在socket上发送它，以“sendMessage”作为“动作”，我们生成的用户名作为“用户名”，文本作为“内容”。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="5f95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后返回到<code class="fe mg mh mi mj b">templates/chat</code>目录下的<code class="fe mg mh mi mj b">index.html</code>。链接新的<code class="fe mg mh mi mj b">custom.js</code>脚本，在页面加载时设置WebSocket连接，并在按下post按钮或<code class="fe mg mh mi mj b">&lt;Enter&gt;</code>时发布新消息。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="03cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，回到<code class="fe mg mh mi mj b">client</code>目录，并重启服务器。</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="0138" class="mo ky iq mj b gy mp mq l mr ms">cd ..<br/>python manage.py runserver</span></pre><p id="c09d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在浏览器窗口中重新加载<code class="fe mg mh mi mj b">localhost:8000</code>。您应该可以看到最初加载的数据库中的前10条消息，现在也应该可以发布消息了。</p><p id="9436" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更有趣的是，尝试一次打开多个浏览器窗口到<code class="fe mg mh mi mj b">localhost:8000</code>。所有客户端都应该在新消息发布时进行更新，并且它们应该能够相互通信。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/9609b4e4af2e27b40ac28a19431d3135.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uqTMClSeLvD_ZzPzxgrgxg.png"/></div></div></figure><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/6309930f63add7bef1229a1bd697764d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2rPnSZCGuAaxCbps8i4uyA.png"/></div></div></figure><h1 id="67ae" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">步骤8:保护应用程序</h1><p id="08ff" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">至此，大部分功能已经编写完成，但是没有持久的身份感，恶意用户可以通过修改Javascript伪装成任何人。真正的应用程序几乎肯定需要身份验证机制，并且不能依赖客户端代码(如Javascript)向后端提供信息，因为它不可信。</p><p id="83fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，为了让应用程序更加真实，我们将添加登录和注册视图(利用内置于<code class="fe mg mh mi mj b"><a class="ae kw" href="https://github.com/lgoodridge/django-uniauth" rel="noopener ugc nofollow" target="_blank">django-uniauth</a></code>的视图)，并用JWT保护对后端API的调用。基于令牌的认证是目前保护WebSocket APIs最流行的方式，而JWT本身就是一个流行且简单的基于令牌的认证方案，这使它成为一个合适的选择。</p><p id="3a91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先安装<code class="fe mg mh mi mj b">django-uniauth</code>。</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="b1ba" class="mo ky iq mj b gy mp mq l mr ms">pip install django-uniauth</span></pre><p id="9a08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，在<code class="fe mg mh mi mj b">project/settings.py</code>中将“uniauth”添加到<code class="fe mg mh mi mj b">INSTALLED_APPS</code>。</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="9bbf" class="mo ky iq mj b gy mp mq l mr ms">INSTALLED_APPS = [<br/>    ...<br/>    'uniauth',<br/>]</span></pre><p id="d9fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将<code class="fe mg mh mi mj b">AUTHENTICATION_BACKENDS</code>设置为适当的后端。(如果该设置不存在，您可能需要创建它)。</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="b1f8" class="mo ky iq mj b gy mp mq l mr ms">AUTHENTICATION_BACKENDS = [<br/>    'uniauth.backends.UsernameOrLinkedEmailBackend',<br/>]</span></pre><p id="ae3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并添加以下设置:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e48f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一行设置当用户试图在没有登录的情况下访问受<code class="fe mg mh mi mj b">login_required</code> decorator保护的视图时被重定向到哪个URL。第二行设置手动登录时重定向到哪个URL。第三个选项从登录页面中删除了CAS登录选项，因为我们没有任何CAS服务器可以登录。</p><p id="cbde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第四行告诉Django将所有发出的电子邮件打印到控制台。使用电子邮件进行电子邮件验证之类的事情，所以这是一种简单的方法，仍然可以在本地获得该功能，而无需设置实际的SMTP后端。最后一行将这些电子邮件中的“发件人”地址设置为适当的名称。</p><p id="b56b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，在<code class="fe mg mh mi mj b">project/urls.py</code>中包含包的URL。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="81d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用提供的<code class="fe mg mh mi mj b">login_required</code>装饰器保护<code class="fe mg mh mi mj b">chat/views.py</code>中的索引视图。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="abb2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，返回到<code class="fe mg mh mi mj b">client</code>目录，应用任何新的迁移，并重启服务器。</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="ac7c" class="mo ky iq mj b gy mp mq l mr ms">python manage.py migrate<br/>python manage.py runserver</span></pre><p id="adee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在浏览器中访问<code class="fe mg mh mi mj b">localhost:8000</code>后，您应该会看到<code class="fe mg mh mi mj b">django-uniauth</code>登录页面。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/cc8e6896c65e0dd79e5943e6065eaf38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GD30ewbiWlLcuNVSP6AlMg.png"/></div></div></figure><p id="26d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一个帐户，方法是点击“创建一个帐户”并完成注册过程(检查运行服务器的控制台窗口以获得电子邮件验证链接！)，或者通过Django的<code class="fe mg mh mi mj b">createsuperuser</code>命令。</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="c8ab" class="mo ky iq mj b gy mp mq l mr ms">python manage.py createsuperuser</span></pre><p id="28e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论哪种方式，一旦创建了一个帐户，登录，你应该会回到索引页面。</p><p id="833a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们已经有了正确的用户认证，让我们设置JWT。在本教程中，我们将使用<a class="ae kw" href="https://pyjwt.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> PyJWT库</a>。首先，安装它。</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="ec5e" class="mo ky iq mj b gy mp mq l mr ms">pip install pyjwt</span></pre><p id="947b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后移动到您的<code class="fe mg mh mi mj b">backend</code>目录，并将其添加到您的<code class="fe mg mh mi mj b">requirements.txt</code>中。添加的行应该如下所示:</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="0345" class="mo ky iq mj b gy mp mq l mr ms">PyJWT==*.*.*</span></pre><p id="e064" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将在<code class="fe mg mh mi mj b">pip install</code>命令输出的末尾看到版本号。或者，您可以运行<code class="fe mg mh mi mj b">pip freeze</code>来查看所有已安装的包，然后将以“PyJWT”开头的行复制到<code class="fe mg mh mi mj b">requirements.txt</code>中。</p><p id="3798" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，打开<code class="fe mg mh mi mj b">handler.py</code>，修改连接处理程序以读取作为URL参数传递的令牌，并尝试使用您选择的字符串对其进行解码(在本例中，我使用的是“FAKE_SECRET”)。这个字符串将是后端API和客户端应用程序之间的共享秘密，JWT使用它来编码/解码令牌。因此，如果JWT能够成功解码令牌(它将作为<code class="fe mg mh mi mj b">decode</code>方法的一部分自动验证签名)，我们就知道它是由我们的客户端应用程序创建的。</p><p id="fb06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果没有提供令牌，或者令牌无法解码，连接应该会立即失败。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f72e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还将在<code class="fe mg mh mi mj b">send_message</code>函数中使用JWT来确保用户不能假冒他们的用户名。编辑<code class="fe mg mh mi mj b">send_message</code>,要求<code class="fe mg mh mi mj b">token</code>作为数据字段，而不是<code class="fe mg mh mi mj b">username</code>,然后验证令牌，如果成功的话，从有效负载中提取<code class="fe mg mh mi mj b">username</code>(我们将很快设置客户端遵守这一点)。如果令牌验证失败，则提前终止函数。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="aba4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，重新部署后端API。</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="a35c" class="mo ky iq mj b gy mp mq l mr ms">serverless deploy</span></pre><p id="7836" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到<code class="fe mg mh mi mj b">client</code>目录，转到你的聊天应用目录，打开<code class="fe mg mh mi mj b">views.py</code>。修改索引视图，使用有效负载中包含的用户名和您选择的秘密字符串作为秘密对令牌进行编码，并将令牌作为视图上下文的一部分进行传递。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="1757" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，打开<code class="fe mg mh mi mj b">static/chat/custom.js</code>，移除随机生成的用户名。修改<code class="fe mg mh mi mj b">setupWebSocket</code>以接受一个<code class="fe mg mh mi mj b">username</code>和<code class="fe mg mh mi mj b">token</code>作为参数，并在连接到WebSocket时将令牌作为URL参数传递。修改<code class="fe mg mh mi mj b">postMessage</code>以接受一个<code class="fe mg mh mi mj b">token</code>参数，并将其作为消息字典的一部分，而不是<code class="fe mg mh mi mj b">username</code>。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7472" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后打开<code class="fe mg mh mi mj b">templates/chat/index.html</code>并修改事件处理程序来传递适当的参数。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0bc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在重新启动客户端服务器，检查最终产品！</p><pre class="mb mc md me gt mk mj ml mm aw mn bi"><span id="8893" class="mo ky iq mj b gy mp mq l mr ms">python manage.py runserver</span></pre><p id="6041" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它应该在功能上等同于上次运行应用程序，但现在发送消息的用户名将与登录用户的用户名相匹配。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/6e19df35a9950c931bec03f6b67a8a9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5LhdD7NRMWA1lmojHt6JAw.png"/></div></div></figure><h1 id="65e1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">就是这样！</h1><p id="4efa" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">现在，您已经从头开始构建了一个无服务器的WebSocket应用程序，并且希望在这个过程中学到了一些东西。</p><p id="df0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在<a class="ae kw" href="https://github.com/lgoodridge/serverless-chat" rel="noopener ugc nofollow" target="_blank"> this Github repo </a>找到本教程中使用的代码。欢迎在评论中留下任何反馈！</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><div class="mb mc md me gt nr"><a href="https://gitconnected.com/learn/python" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">学习Python -最佳Python教程(2019) | gitconnected</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">50大Python教程-免费学习Python。课程由开发人员提交并投票，使您能够…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">gitconnected.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of jw nr"/></div></div></a></div></div></div>    
</body>
</html>