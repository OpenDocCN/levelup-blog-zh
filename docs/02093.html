<html>
<head>
<title>Dependency Injection in Python 3 with Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3中的依赖注入与测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dependency-injection-in-python-3-with-testing-55b64ca60ae1?source=collection_archive---------4-----------------------#2020-02-18">https://levelup.gitconnected.com/dependency-injection-in-python-3-with-testing-55b64ca60ae1?source=collection_archive---------4-----------------------#2020-02-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c7375ba32e6bde82f7bce2464b950b02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UV-m38xifsHAWHoh"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@cdr6934?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯里德</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="0cbc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">依赖反转是控制反转(IoC)的一种具体实现，是一种面向对象的软件设计原则，它通过将较低级别的类与较高级别的类解耦来创建不太脆弱的代码，并使编写测试更容易。它通过将对象作为参数传递给类的构造函数，而不是在类本身内部实例化新的对象，来完成这一壮举。本文并不打算支持依赖注入的优点——这已经是一个很好的主题<a class="ae kf" href="https://medium.com/better-programming/the-6-benefits-of-dependency-injection-7802b207ec69" rel="noopener">——而是展示一个Python中的例子，以及如何为使用依赖反转的代码编写单元测试。依赖<em class="le">注入</em>是一种依赖倒置，通常通过采用依赖注入框架，创建一个容器对象来管理依赖。</a></p><p id="eba9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将:</p><ul class=""><li id="a910" class="lf lg it ki b kj kk kn ko kr lh kv li kz lj ld lk ll lm ln bi translated">创建一个没有依赖注入的格式化字符串消息的人为例子。</li><li id="71f5" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">重构它以使用依赖倒置，并编写一个简单的单元测试。</li><li id="da8a" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">再次重构它，使用<a class="ae kf" href="https://github.com/ets-labs/python-dependency-injector" rel="noopener ugc nofollow" target="_blank">python-dependency-injector</a>，这是一个流行的DI框架，用于在容器中创建依赖关系。</li></ul><h1 id="ac43" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">没有依赖注入的例子</h1><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">无依赖性反转的示例</figcaption></figure><p id="f179" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面例子的第8行，<code class="fe mx my mz na b">MessageFormatter</code>依赖项被硬连接到<code class="fe mx my mz na b">MessageWriter</code>类。这段代码运行得非常好，但是如果在未来的版本中,<code class="fe mx my mz na b">MessageWriter</code>的实现被更改为接受构造函数参数，该怎么办呢？这将包括在所有类之间传递参数，这是没有必要的。此外，我们怎么可能为我们的<code class="fe mx my mz na b">write</code>函数编写一些有意义的单元测试，它甚至不返回任何东西！在构造函数或方法中实例化一个对象是一种代码味道，说明这个类在实现中太死板了。</p><p id="55d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">严格代码的一个长期后果是意大利面条式的代码，这是由于依赖关系被随意地连接在整个代码库中，使得几乎不可能理解谁拥有什么以及类的真实范围是什么。当您发现修改一个类需要更改多个类来添加同一个参数时，依赖反转很可能就是您的锦囊妙计中缺少的工具。</p><h1 id="db25" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">重构以包含依赖倒置</h1><p id="be44" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">那么，这怎么解决呢？我们可以将<code class="fe mx my mz na b">MessageFormatter</code>的一个实例传递给<code class="fe mx my mz na b">MessageWriter</code>，而不是在<code class="fe mx my mz na b">MessageWriter</code>的构造函数中创建<code class="fe mx my mz na b">MessageFormatter</code>。</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">依赖倒置的例子</figcaption></figure><p id="e1e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">起初，这种差别是微妙的，但却是强大的。现在，如果我们想为<code class="fe mx my mz na b">MessageWriter</code>编写单元测试，我们可以创建一个<code class="fe mx my mz na b">MessageFormatter</code>的模拟实例，并将其作为参数传递给<code class="fe mx my mz na b">MessageWriter</code>的构造函数。这个模拟允许我们替换依赖项，因为这不是我们单元测试所关心的。以下示例使用了<a class="ae kf" href="https://docs.pytest.org/en/latest/" rel="noopener ugc nofollow" target="_blank"> pytest </a>和<a class="ae kf" href="https://github.com/pytest-dev/pytest-mock/" rel="noopener ugc nofollow" target="_blank"> pytest-mock </a>。</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">依赖倒置的单元测试示例</figcaption></figure><p id="be62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这段代码开始变得更好看了。它不那么脆弱，并且有可能编写简洁而有意义的单元测试。不幸的是，这个例子有一个隐藏的问题。随着这个代码库的增长，更多的依赖会出现在<code class="fe mx my mz na b">main()</code>函数中，导致它失控。最后，我们会发现我们一直在从程序的最高层向程序的最底层传递依赖关系。这是乏味的，并且会导致一些带有大量参数的非常粗糙的构造函数。幸运的是，仍然有一种更好的方法可以做到这一点，那就是依赖依赖注入。</p><h1 id="4225" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">重构以使用依赖注入</h1><p id="d4dd" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">许多语言都有依赖注入框架，允许创建一个容器对象来管理依赖及其创建的细节。C#有<a class="ae kf" href="https://autofac.org/" rel="noopener ugc nofollow" target="_blank"> Autofac </a>和<a class="ae kf" href="http://www.ninject.org/" rel="noopener ugc nofollow" target="_blank"> Ninject </a>，C++有<a class="ae kf" href="https://boost-experimental.github.io/di/" rel="noopener ugc nofollow" target="_blank">【Boost】。DI </a>和Python有<a class="ae kf" href="https://github.com/ets-labs/python-dependency-injector" rel="noopener ugc nofollow" target="_blank">依赖注入器</a>。所有这些框架的工作方式本质上都是一样的。首先创建一个容器类来注册您的依赖项(在依赖注入器的说法中，这些注册被称为提供者)，然后在您的各种类中，您调用容器对象来为您解析依赖项。</p><p id="cdfb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据具体情况，有许多类型的提供程序可供使用。从依赖注入器文档中:</p><blockquote class="ng nh ni"><p id="ecee" class="kg kh le ki b kj kk kl km kn ko kp kq nj ks kt ku nk kw kx ky nl la lb lc ld im bi translated"><strong class="ki iu">提供者</strong> —基本提供者类。</p><p id="c36b" class="kg kh le ki b kj kk kl km kn ko kp kq nj ks kt ku nk kw kx ky nl la lb lc ld im bi translated"><strong class="ki iu"> Callable </strong> —在每次调用时调用包装的可调用程序的提供者。支持位置和关键字参数注入。</p><p id="6fdd" class="kg kh le ki b kj kk kl km kn ko kp kq nj ks kt ku nk kw kx ky nl la lb lc ld im bi translated"><strong class="ki iu">工厂</strong> —在每次调用时创建指定类的新实例的提供者。支持位置和关键字参数注入，以及属性注入。</p><p id="d751" class="kg kh le ki b kj kk kl km kn ko kp kq nj ks kt ku nk kw kx ky nl la lb lc ld im bi translated"><strong class="ki iu"> Singleton </strong> —提供者在第一次调用时创建指定类的新实例，并在下一次调用时返回相同的实例。支持位置和关键字参数注入，以及属性注入。</p><p id="720c" class="kg kh le ki b kj kk kl km kn ko kp kq nj ks kt ku nk kw kx ky nl la lb lc ld im bi translated"><strong class="ki iu">对象</strong> —按“原样”返回所提供实例的提供者。</p><p id="9eaf" class="kg kh le ki b kj kk kl km kn ko kp kq nj ks kt ku nk kw kx ky nl la lb lc ld im bi translated"><strong class="ki iu"> ExternalDependency </strong> —对于开发需要外部依赖的自给自足的库、模块和应用程序非常有用的提供者。</p><p id="5a85" class="kg kh le ki b kj kk kl km kn ko kp kq nj ks kt ku nk kw kx ky nl la lb lc ld im bi translated"><strong class="ki iu">配置</strong> —帮助实现配置选项的后期静态绑定的提供者—先使用，后定义。</p></blockquote><p id="c766" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从我个人的经验来看，使用<code class="fe mx my mz na b">Factory</code>和<code class="fe mx my mz na b">Singleton</code>提供者可以解决大多数用例。下面演示了如何创建一个容器对象——下面恰当地命名为<code class="fe mx my mz na b">Container</code>——然后是如何利用在容器中创建的提供者来解析<code class="fe mx my mz na b">MessageFormatter</code>依赖关系。</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">依赖注入的例子</figcaption></figure><p id="2836" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第27行，我们使用<code class="fe mx my mz na b">Factory</code>提供者来定义如何创建一个<code class="fe mx my mz na b">MessageFormatter</code>对象。每次我们像在第14行那样调用<code class="fe mx my mz na b">Container.message_formatter()</code>，我们都会得到一个新的<code class="fe mx my mz na b">MessageFormatter</code>实例。前面演示的单元测试和最后一个例子一样。为了让上面的例子与我们的单元测试一起工作，我们必须在<code class="fe mx my mz na b">MessageWriter</code>构造函数中实现一个if语句。虽然这并不理想，但它的缺点被依赖注入的优点掩盖了。</p><p id="1e91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，这段代码的优势在于，通过能够替换具体的实现，它变得更加模块化；通过能够模拟更高级别的依赖关系，它变得更加可测试；通过没有过多的构造函数参数，它变得更加简洁。更高级别的依赖不再通过不直接使用依赖的类来编织。对于代码库的长期可维护性(和可读性)来说，没有什么比引用一个类中的对象更糟糕的了，该对象的存在只是为了传递给更低级别的依赖项。依赖注入器框架很小，简单，易于使用；几乎没有什么能让它成为任何Python项目的直接和有价值的组成部分。</p><h1 id="05c6" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">结束语</h1><p id="264c" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">希望这篇博文能提供一些信息，并向您展示如何在Python项目中包含依赖注入，重点是可测试性。对于这篇博文中包含的完整的、可运行的代码示例，请访问我的GitHub页面。</p><p id="a53b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">快乐编码！🧑🏻‍💻</p><p id="5737" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://bit.ly/dbudwin-github" rel="noopener ugc nofollow" target="_blank">git hub</a>|<a class="ae kf" href="https://bit.ly/dbudwin-linkedin" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae kf" href="https://bit.ly/dbudwin-medium" rel="noopener ugc nofollow" target="_blank">中</a> | <a class="ae kf" href="https://bit.ly/budw_dot_in" rel="noopener ugc nofollow" target="_blank"> Budw.in </a></p></div></div>    
</body>
</html>