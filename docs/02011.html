<html>
<head>
<title>Unity: Localization Made Easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">统一:本地化变得容易</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/unity-localization-made-easy-37b14adfc581?source=collection_archive---------2-----------------------#2020-02-12">https://levelup.gitconnected.com/unity-localization-made-easy-37b14adfc581?source=collection_archive---------2-----------------------#2020-02-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ed6736559aacf992db45122d60964ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W8duaMTxqjJx8O-jBexAZA.jpeg"/></div></div></figure><p id="aab5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://youtu.be/e_c3JAZ7Zyo" rel="noopener ugc nofollow" target="_blank"> <em class="la">视频教程点击这里</em> </a></p><p id="d34f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你是一个独立开发者或者一个小工作室，本地化是你最有可能不会在游戏的初始版本中实现的事情。然而，为了增加你的观众和吸引新玩家，多语言支持是你在后续版本中考虑的一个基本要素。在本教程中，我将展示一个非常简单的方法来为你的游戏做本地化，不需要任何第三方资产。</p><h1 id="186b" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">先决条件</strong></h1><p id="4334" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">我将使用Unity 2019.3，但早期版本也可以。我已经在我的一个游戏中使用了这些机制——<a class="ae kz" href="https://play.google.com/store/apps/details?id=pro.pudding.zen" rel="noopener ugc nofollow" target="_blank">Zen Jigsaw</a>——你可以在那里看到它的运行。</p><p id="a6a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">和往常一样，GitHub提供了源代码，请在本文末尾找到链接。</p><p id="8bb5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本教程中描述的方法最适合中小型游戏。需要两个组件:保存所有游戏文本的属性文件和填充所需文本的语言解析器。</p><p id="d47e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本教程中，将使用两种语言——英语和俄语——但是这种方法可以方便地扩展到所有其他支持的语言。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi me"><img src="../Images/960338460d64881f9973bc9264323fda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dcCWWf_8CIFy1MlE"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">场景设置</figcaption></figure><p id="1f96" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Unity之前，我有过一次使用另一个流行的游戏开发框架Libgdx的经历。如果您曾经使用过它，您可能会在这里描述的技术中发现某些相似之处。Libgdx中的本地化支持开箱即用，并且以极其简单的方式实现。我有点惊讶，Unity还缺少这个必备功能。是的，<a class="ae kz" href="https://docs.unity3d.com/Packages/com.unity.localization@0.4/manual/" rel="noopener ugc nofollow" target="_blank">有0.4 </a>包可用，但仍处于早期开发阶段。</p><h1 id="6615" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">第一部分。创建属性文件</strong></h1><p id="590b" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">为了从代码中访问属性文件，我们将把它们存储在Resources文件夹中。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/cbe3a5c9a5b3325acccc69f1eb7dfeb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/0*-E4HbSHKVrmRSOyc"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">属性文件设置</figcaption></figure><p id="84ab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我称那些文件为“属性”是因为其结构，例如English.txt文件有以下内容:</p><pre class="mf mg mh mi gt mo mp mq mr aw ms bi"><span id="18fb" class="mt lc it mp b gy mu mv l mw mx">welcome=Welcome!<br/>long_text=This is a\nvery long\ntext</span></pre><p id="9124" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个财产文件将履行合同:</p><ul class=""><li id="a445" class="my mz it kd b ke kf ki kj km na kq nb ku nc ky nd ne nf ng bi translated">单行由两部分组成—分隔符左侧的键和右侧的值</li><li id="6d2f" class="my mz it kd b ke nh ki ni km nj kq nk ku nl ky nd ne nf ng bi translated">各行之间用换行符隔开</li><li id="73da" class="my mz it kd b ke nh ki ni km nj kq nk ku nl ky nd ne nf ng bi translated">文件名对应于Unity <code class="fe nm nn no mp b">SystemLanguage</code>枚举</li><li id="c14d" class="my mz it kd b ke nh ki ni km nj kq nk ku nl ky nd ne nf ng bi translated">所有属性文件都有相同的关键字，但不同的<em class="la">本地化</em>值</li><li id="0735" class="my mz it kd b ke nh ki ni km nj kq nk ku nl ky nd ne nf ng bi translated">键和值之间的分隔符是“=”，您也可以使用任何其他符号</li></ul><h1 id="e766" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">第二部分。读取属性文件</strong></h1><p id="25de" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">为了利用之前准备的文件，让我们创建一个脚本，该脚本将负责逐行读取文件，收集所有的键值对并将它们填充到文本组件中:</p><pre class="mf mg mh mi gt mo mp mq mr aw ms bi"><span id="6a4a" class="mt lc it mp b gy mu mv l mw mx">public class LangResolver : MonoBehaviour<br/>{<br/>    private const char <em class="la">Separator </em>= '=';<br/>    private readonly Dictionary&lt;string, string&gt; _lang = new Dictionary&lt;string, string&gt;();<br/>    private SystemLanguage _language;</span><span id="5508" class="mt lc it mp b gy np mv l mw mx">    private void Awake()<br/>    {<br/>        DontDestroyOnLoad(gameObject);<br/>        ReadProperties();<br/>        Debug.Log(_lang.Count);<br/>        Debug.Log(_lang.Keys.First());<br/>        Debug.Log(_lang.Values.First());<br/>    }</span><span id="7b49" class="mt lc it mp b gy np mv l mw mx">    private void ReadProperties()<br/>    {<br/>        _language = Application.systemLanguage;<br/>        var file = Resources.Load&lt;TextAsset&gt;(_language.ToString());<br/>        if (file == null)<br/>        {<br/>            file = Resources.Load&lt;TextAsset&gt;(SystemLanguage.English.ToString());<br/>            _language = SystemLanguage.English;<br/>        }<br/>        foreach (var line in file.text.Split('\n'))<br/>        {<br/>            var prop = line.Split(<em class="la">Separator</em>);<br/>            _lang[prop[0]] = prop[1];<br/>        }<br/>    }<br/>}</span></pre><p id="2fdb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们创建一个新的空游戏对象并将LangResolver附加到它。</p><p id="6aac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您现在点击播放按钮，您将看到以下输出:</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/baf592b6f7ea38d64cc53c6a17dcdc87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9ycXabpgaYR_vFYj"/></div></div></figure><p id="53e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是<code class="fe nm nn no mp b">_lang </code>字典的大小，也是英语属性文件中的第一个键和值！</p><p id="24a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有一个默认值是很重要的，以防有人用不支持的语言运行你的游戏。通常，使用英语，但它可能会有所不同。</p><blockquote class="nr ns nt"><p id="218d" class="kb kc la kd b ke kf kg kh ki kj kk kl nu kn ko kp nv kr ks kt nw kv kw kx ky im bi translated"><strong class="kd iu">注意！这个脚本只需要初始化一次，最好是在第一个场景(通常是飞溅的场景)。如果你没有这样的场景，应该添加一个重复的检查。</strong></p></blockquote><p id="6a11" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此时，您可能想知道:语言选择器在哪里？我故意将UX的这一部分排除在教程范围之外。在现代游戏中，语言改变选项不再是必须的，依靠系统语言是完全可以的。但是我在<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/unity-advanced-localization-802cb954ca16">高级本地化教程</a>中有它的封面，一定要去看看！</p><h1 id="d5f7" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">第三部分。本地化</h1><p id="60f5" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">下一步是将属性中的键绑定到文本组件。为此，让我们创建以下助手类:</p><pre class="mf mg mh mi gt mo mp mq mr aw ms bi"><span id="cdf9" class="mt lc it mp b gy mu mv l mw mx">public class LangText : MonoBehaviour<br/>{<br/>    public string Identifier;<br/>}</span></pre><p id="ea6f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个脚本将被附加到我们希望用文件中的文本填充的每个文本组件上。<strong class="kd iu">标识符</strong>字段是来自属性的一个键。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/6da834a2bff39645814ff12a383a3597.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/0*0QPNC3Jb1wGLwQhH"/></div></figure><p id="e259" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后一步是填写所有文本。让我们在LangResolver中添加以下公共方法:</p><pre class="mf mg mh mi gt mo mp mq mr aw ms bi"><span id="6793" class="mt lc it mp b gy mu mv l mw mx">public void ResolveTexts()<br/>{<br/>    var allTexts = Resources.FindObjectsOfTypeAll&lt;LangText&gt;();<br/>    foreach (var langText in allTexts)<br/>    {<br/>        var text = langText.GetComponent&lt;Text&gt;();<br/>        text.text = Regex.Unescape(_lang[langText.Identifier]);<br/>    }<br/>}</span></pre><blockquote class="nr ns nt"><p id="e32f" class="kb kc la kd b ke kf kg kh ki kj kk kl nu kn ko kp nv kr ks kt nw kv kw kx ky im bi translated"><strong class="kd iu">注意！</strong> <code class="fe nm nn no mp b">Regex.Unescape</code>方法用于正确解析属性文件中的新行和其他可能的格式化字符。</p></blockquote><p id="7b43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然你可以从脚本内部调用这个方法(例如，从Awake中)，但我更喜欢有一个专用的<code class="fe nm nn no mp b">UIResolver </code>类:</p><pre class="mf mg mh mi gt mo mp mq mr aw ms bi"><span id="88ab" class="mt lc it mp b gy mu mv l mw mx">public class UIResolver : MonoBehaviour<br/>{<br/>    private void Start()<br/>    {<br/>        FindObjectOfType&lt;LangResolver&gt;().ResolveTexts();<br/>    }<br/>}</span></pre><h1 id="9d49" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">第四部分。测试</strong></h1><p id="857f" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">现在棘手的部分是用不同的语言测试它，因为你需要调整你的操作系统语言。我相信您不希望这样做，所以让我们通过将<code class="fe nm nn no mp b">ReadProperties </code>方法中的第一行改为<code class="fe nm nn no mp b">_language = SystemLanguage.Russian</code>来“模拟”这种行为</p><p id="275b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你点击播放按钮，你会看到:</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi me"><img src="../Images/aa2b8c9ff750fbc6b76c16ba12ec0390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Weem8H54Sr0O2zYu"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">俄语</figcaption></figure><p id="f6c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">看不懂西里尔文也不用担心，文字是直接翻译的。</p><p id="9a8b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认情况下，使用英语的结果将是:</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi me"><img src="../Images/482dd6e6d2eb23269172e8b075f39a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w4fLaaWzOge2kIE1"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">英语</figcaption></figure><p id="df77" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通常，您不需要在文本组件本身中保留任何文本，因为它的文本无论如何都会被替换。然而，从UX的角度来看，理解文本的外观可能会有所帮助，所以我建议在Unity editor中保留一些文本，同时使用属性文件作为最终的事实来源。</p><h1 id="a85d" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">事后</strong></h1><p id="0d58" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">完成教程做得很好！如果你有任何问题，请在下面的评论区留言。</p><p id="ffee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">项目源文件可以在<a class="ae kz" href="https://github.com/Enigo/UnityEasyLocalization" rel="noopener ugc nofollow" target="_blank">这个GitHub资源库</a>中找到</p><p id="01c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我提到的游戏可以在这里下载<a class="ae kz" href="https://play.google.com/store/apps/details?id=pro.pudding.zen" rel="noopener ugc nofollow" target="_blank">禅宗七巧板</a>。</p><h1 id="4ef1" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">支持</h1><p id="884d" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">如果你喜欢你看的内容，想支持作者——非常感谢！<br/>这里是我的以太坊钱包给小费:<br/><strong class="kd iu">0x b 34 C2 BCE 674104 a7 ca 1 ecebf 76d 21 Fe 1099132 f 0</strong></p></div></div>    
</body>
</html>