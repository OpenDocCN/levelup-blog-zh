<html>
<head>
<title>Design Patterns In TypeScript — Singleton</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的设计模式— Singleton</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/design-patterns-in-typescript-singleton-d165e8058cb7?source=collection_archive---------1-----------------------#2021-06-06">https://levelup.gitconnected.com/design-patterns-in-typescript-singleton-d165e8058cb7?source=collection_archive---------1-----------------------#2021-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1307" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何将一个类的实例化限制到一个对象</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/42c0bb0b27da9a05a8d877e4624af5cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kU-iuv7kBhMAxMi6AQQUuw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">与<a class="ae ky" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>合影。</figcaption></figure><p id="de7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Singleton是软件开发中最常用的设计模式之一。在这篇文章中，我们将学习如何在使用TypeScript的web开发环境中实现这种模式。</p><h1 id="f4d5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是Singleton？</h1><p id="e49f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">《设计模式:可重用面向对象软件的元素》一书的作者将单例模式定义为:</p><blockquote class="ms mt mu"><p id="ab6e" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">单例类是有一个<strong class="lb iu">单个对象</strong>的类，这个唯一的对象构成了所有客户端的全局工具。</p></blockquote><p id="133d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，单例模式迫使你通过一个<strong class="lb iu">类方法</strong>或者一个<strong class="lb iu"> getter </strong>来获得一个类的实例。因此，不是使用<code class="fe mz na nb nc b">new</code>操作符创建一个实例，而是所有客户端都将访问由该类创建和存储的实例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/9f175ed0fe216448aecb3d514a44a630.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_BwBlhYLSD5AXvVv729S3g.png"/></div></div></figure><p id="64ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种特殊情况下，您的应用程序中只有一个该类的实例，并且您可以确保所有客户端都将使用相同的实例属性。这是减少内存消耗的好方法，因为对于这个类的实例，我们在内存中只有一个对象。</p><h1 id="9aeb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">履行</h1><p id="ae42" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最初，我们将定义类和其中的私有构造函数。通过将该类的构造函数设置为private，我们可以防止客户端错误地实例化该类。</p><blockquote class="ms mt mu"><p id="c46b" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated"><strong class="lb iu">专业提示</strong>:即使类没有参数，定义一个<strong class="lb iu">私有构造函数</strong>也很重要。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9ee2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是创建一个静态私有属性，该属性将与类的实例一起分配:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3d20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们创建将成为实例创建者的<code class="fe mz na nb nc b">getInstance</code>公共方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="65a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户端可以通过调用这个方法得到<code class="fe mz na nb nc b">MySingleton</code>实例:</p><pre class="kj kk kl km gt ng nc nh ni aw nj bi"><span id="66a6" class="nk lw it nc b gy nl nm l nn no">MySingleton.getInstance();</span></pre><p id="c7d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">公开类实例的另一种方法是为静态实例定义一个getter:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="6e34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且客户端可以通过getter获得<code class="fe mz na nb nc b">MySingleton</code>实例:</p><pre class="kj kk kl km gt ng nc nh ni aw nj bi"><span id="76bf" class="nk lw it nc b gy nl nm l nn no">MySingleton.instance;</span></pre><h1 id="a06e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">例子</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="c5c5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="749a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在TypeScript中实现这种单例模式非常容易，特别是对于来自其他语言如Java或Golang的程序员。但是，您必须确保您的代码是正确的、线程安全的，并且能够正确地使用所有JavaScript特性，比如异步代码。</p></div></div>    
</body>
</html>