<html>
<head>
<title>Method and Function Overriding in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的方法和函数覆盖</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/method-and-function-overriding-in-python-96a000274248?source=collection_archive---------4-----------------------#2021-05-02">https://levelup.gitconnected.com/method-and-function-overriding-in-python-96a000274248?source=collection_archive---------4-----------------------#2021-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/031a625671bf2182913ac42091f4053d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gMdS_iRYegm4JNkk_FOU4Q.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">来自<a class="ae jg" href="https://www.pexels.com/photo/woman-coding-on-computer-3861958/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>的<a class="ae jg" href="https://www.pexels.com/@thisisengineering?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">摄影</a></figcaption></figure><div class=""/><div class=""><h2 id="43df" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">使用@functools.singledispatch和type批注。</h2></div><p id="6942" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">方法和函数重写是一种非常有用的技术。它允许您在代码中多次定义同一个方法，但是每个方法都采用不同类型的参数。</p><h2 id="1285" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">术语注释，给那些关心的人！</h2><p id="ba03" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">方法在类上定义。当子类重新定义父类中可用的方法时，就会发生重载。因此我们称这个<strong class="la jk"> <em class="ms">方法重载</em> </strong>。我不会在本文中讨论方法重载。</p><p id="3cf9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">函数不是在类对象上定义的(正常情况下)。当我们定义一个函数的多个版本时，称为<strong class="la jk"> <em class="ms">函数覆盖</em> </strong>。这篇文章是关于Python中的函数覆盖的。</p><h2 id="9e63" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">一个没有函数覆盖的例子</h2><p id="a7ba" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">让我们用一个圆形类和一个方形类的标志性例子。</p><figure class="mt mu mv mw gt iv"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2d1c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里没什么可看的。正方形有一个实例属性:它的边长，而圆定义了一个半径属性。每个实例的<code class="fe mz na nb nc b">__init__</code>方法取一个初始化值，默认值为0。这是面向对象的Python 101，目前为止没什么特别的。我们以后会需要这个代码。</p><h2 id="446d" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated"><strong class="ak">计算物体面积的函数。</strong></h2><p id="6afa" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">正方形面积的计算不同于圆形面积的计算。我的函数，<code class="fe mz na nb nc b">area</code>，可以取一个正方形或者圆形物体，并计算其面积。它知道计算这两种几何形状面积的不同方法。将来，我可能想添加对其他形状的支持。</p><figure class="mt mu mv mw gt iv"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5f70" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个函数使用一个<code class="fe mz na nb nc b">if … elif</code>构造来识别对象是圆形还是方形，然后使用不同的计算方法。此函数不使用覆盖。它接受任何类型的参数，并计算出如何处理它们。</p><p id="902c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是函数的驱动因素:</p><figure class="mt mu mv mw gt iv"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="92c0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我终端的输出:</p><pre class="mt mu mv mw gt nd nc ne nf aw ng bi"><span id="3140" class="lu lv jj nc b gy nh ni l nj nk">113.09733552923255<br/>144.0</span></pre><p id="c0d0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在Github 上找到这个例子。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h2 id="c95d" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">使用函数覆盖的示例</h2><p id="0946" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">到目前为止,<code class="fe mz na nb nc b">area</code>功能运行得很好——没有什么问题。然而，当我增加对越来越多的几何形状的支持时，它会变得臃肿。随着它的成长，测试也将变得更加困难。</p><p id="7d26" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们使用覆盖将函数分解成更具体的变量。用以下代码替换之前的<code class="fe mz na nb nc b">area</code>函数:</p><figure class="mt mu mv mw gt iv"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8b6f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事情是这样的:</p><ul class=""><li id="415b" class="ns nt jj la b lb lc le lf lh nu ll nv lp nw lt nx ny nz oa bi translated">第1行:从functools模块导入<code class="fe mz na nb nc b">singledispatch</code>。这就是“奇迹”发生的地方。</li><li id="5f53" class="ns nt jj la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">第2行:在名为<code class="fe mz na nb nc b">area.</code>的函数上使用装饰器</li><li id="b468" class="ns nt jj la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">第3-#4行:基础函数area没有实现，并返回一个错误。</li><li id="7f1b" class="ns nt jj la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">第7行:<em class="ms">寄存器</em>一个用于<code class="fe mz na nb nc b">area</code>函数的覆盖，该函数带有一个<code class="fe mz na nb nc b">Circle</code>参数</li><li id="99ca" class="ns nt jj la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">第12行:<em class="ms">寄存器</em>一个用于<code class="fe mz na nb nc b">area</code>函数的覆盖，该函数带有一个<code class="fe mz na nb nc b">Square</code>参数</li><li id="6898" class="ns nt jj la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">第8行和第9行:注册的函数被简单地命名为_因为它们不会被直接调用。</li></ul><p id="6868" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您所看到的，我们已经注册了两个特定的处理程序来分派(或处理)函数的单个参数的变化。这就是为什么装修工叫<code class="fe mz na nb nc b">singledispatch</code>的原因。这是在Python版本3.4中引入的。</p><h2 id="3f86" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated"><strong class="ak">为什么在基本函数上引发NotImplementedError？</strong></h2><p id="ff34" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">这是一点惯例，但非常有用。如果我正在写一个库供其他人使用，那么他们可能会定义一些形状，比如五角星形，这我不知道。我们选择引发一个异常供客户端处理，而不是默默地返回0。我们已经明确定义了<code class="fe mz na nb nc b">area</code>不知道如何返回作为参数传入的对象的计算值。</p><p id="1949" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行这段代码，我得到了和以前完全一样的输出！你可以在Github 上看到完整的例子。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h2 id="5582" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">改为使用类型批注</h2><p id="685f" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">到目前为止，我们已经使用以下装饰器注册了基本方法的特定变体，并显式指定了类型:</p><pre class="mt mu mv mw gt nd nc ne nf aw ng bi"><span id="7257" class="lu lv jj nc b gy nh ni l nj nk">@area.register(Circle)<br/>@area.register(Square)</span></pre><p id="418d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有一个更聪明的方法，使用类型注释！从3.7版本开始，Python非常乐意使用函数参数上的类型注释来推断分派函数的正确类型。</p><p id="8aaa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是相同代码的一个示例，更新后使用了类型批注:</p><figure class="mt mu mv mw gt iv"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5ae9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如你在第7行和第12行看到的，我们没有指定注册函数的类型。相反，正确的类型是从第8行和第13行的注释中推断出来的。</p><pre class="mt mu mv mw gt nd nc ne nf aw ng bi"><span id="4132" class="lu lv jj nc b gy nh ni l nj nk"><em class="ms">def </em>_(<strong class="nc jk"><em class="ms">any_object</em></strong>: Circle): ...<br/><em class="ms">def </em>_(<strong class="nc jk"><em class="ms">any_object</em></strong>: Square): ...</span></pre><p id="6b84" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在注册调度处理程序时使用注释使得代码自文档化，因此更易于维护和理解。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h2 id="4e91" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">了解将调用哪个调度程序</h2><p id="8997" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">如果将不同的类型传递给函数，那么确定将调用哪个调度程序有时会很有用。</p><p id="9ba8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下示例显示了不同的函数如何注册为基本函数的调度程序:</p><figure class="mt mu mv mw gt iv"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7c43" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我的终端中的结果—您将获得不同的地址。</p><pre class="mt mu mv mw gt nd nc ne nf aw ng bi"><span id="42b2" class="lu lv jj nc b gy nh ni l nj nk">&lt;function _ints at 0x10b2a0dc0&gt;<br/>&lt;function _lists at 0x10b2a0e50&gt;<br/>&lt;function _floats at 0x10b2a0ee0&gt;<br/>&lt;function fancy_print at 0x10b2a0af0&gt;</span></pre></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h2 id="c026" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">使用@singledispatchmethod重写实例方法</h2><p id="1991" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">实例方法总是有一个附加的，第一个参数，通常命名为<strong class="la jk"><em class="ms"/></strong>。functools模块提供了一个名为<strong class="la jk"> singledispatchmethod </strong>的singledispatch的替代品，用于实例方法。它可以处理初始自身参数。</p><p id="e995" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个关于狗类的人为例子。它会叫，有不同的品质。发送整数值会让狗叫多次。发一串也会改变狗叫声的质量。</p><figure class="mt mu mv mw gt iv"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="baed" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我的终端的输出:</p><pre class="mt mu mv mw gt nd nc ne nf aw ng bi"><span id="ef81" class="lu lv jj nc b gy nh ni l nj nk">BARK BARK BARK BARK BARK <br/>quiet bark</span></pre><p id="a11f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从这个例子中可以看出，通过使用<code class="fe mz na nb nc b">@singledispatchmethod</code> decorator可以覆盖一个类的实例方法。</p><h2 id="621e" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">结论和警告</h2><p id="ad0a" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在functools模块中，Python从3.4版本开始提供了两个装饰器:@singledispatchmethod用于实例方法，而@singledispatch用于函数。从版本3.7开始，这些已经能够使用类型注释。</p><p id="bc84" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一项了不起的能力——但它有其局限性。这些装饰符只能用于覆盖方法或函数签名中的第一个参数。如果您需要能够覆盖多个参数，您将不得不去别处寻找。也许PyPi模块<a class="ae jg" href="https://pypi.org/project/multipledispatch/" rel="noopener ugc nofollow" target="_blank"> multipledispatch </a>正是您所需要的！</p><p id="36fc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想了解更多关于Python中面向对象编程的知识，可以看看我的其他文章！</p><div class="is it gp gr iu og"><a href="https://medium.com/@quinn.richard/objects-classes-instances-in-python-for-beginners-4dc35b39c785" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jk gy z fp ol fr fs om fu fw ji bi translated">如何有效地使用Python类</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">让我们探索Python中强大的面向对象编程概念！</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">medium.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ja og"/></div></div></a></div></div></div>    
</body>
</html>