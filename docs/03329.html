<html>
<head>
<title>Things we should know as a beginner JavaScript developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为一个初学JavaScript的开发者，我们应该知道的事情</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/things-we-should-know-as-a-beginner-javascript-developer-801dc58e74d6?source=collection_archive---------13-----------------------#2020-05-03">https://levelup.gitconnected.com/things-we-should-know-as-a-beginner-javascript-developer-801dc58e74d6?source=collection_archive---------13-----------------------#2020-05-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="7674" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">今天我要讲一些所有初学者都应该知道的重要JavaScript话题。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/bf314794de1b05e59c88470347def53f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b43pt60z8Jtl3hyI"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae le" href="https://unsplash.com/@m47h4r?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Mazhar Zandsalimi </a>拍摄的照片</figcaption></figure><h1 id="023e" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">类型</strong></h1><h2 id="56fb" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak"> 1)相等和比较</strong></h2><p id="0a45" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">在JavaScript中，我们可以用两种方式检查等式:</p><p id="4d72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">a)相等运算符“==”</p><p id="fdec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将检查两个操作数的值是否相同。它不会检查数据类型。它只检查值是否相等。示例:</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="4ccd" class="md lg it mv b gy mz na l nb nc"> 0 == “” // true<br/> 0 == “0” // true<br/> false == “false” // false<br/> false == “0” // true<br/> false == undefined // false</span></pre><p id="40a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">b)严格相等运算符“===”</p><p id="c72b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将检查两个操作数的值是否相同。它还会检查数据类型是否匹配。只有当值和数据类型完全匹配时，它才返回true。示例:</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="1607" class="md lg it mv b gy mz na l nb nc"> "" === "0" // false<br/> 0 === ""// false<br/> 0 === "0" // false<br/> false === "false" // false<br/> false === "0" // false<br/> false === undefined // false</span></pre><h2 id="1e3e" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak"> 2)一个对象的类</strong></h2><p id="0e0c" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">我们只能用一种方法来确定一个对象的[[Class]]值，那就是使用Object.prototype.toString。</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="a579" class="md lg it mv b gy mz na l nb nc">'[object '+ valueOfClass + ']', e.g [object String] or [object Array]</span></pre><p id="a25b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下面的例子中，Object.prototype.toString被调用，其中<a class="ae le" href="http://bonsaiden.github.io/JavaScript-Garden/?fbclid=IwAR2e20gx1u-UtS9WJLCU92ZuIcREUXLfyTLuevNdS2a_3hoO-M8SfGW6nTU#function.this" rel="noopener ugc nofollow" target="_blank">的值this </a>被设置为应该检索其[[Class]]值的对象。</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="c0ea" class="md lg it mv b gy mz na l nb nc">function is(type, obj) {<br/>  var clas = Object.prototype.toString.call(obj).slice(8, -1);<br/>  return obj !== undefined &amp;&amp; obj !== null &amp;&amp; clas === type;<br/>}<br/> <br/>is('String', 'test'); // true<br/>is(‘String’, new String('test')); // true</span></pre><h2 id="3f3f" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak"> 3)使‘type of’操作符有用的唯一情况</strong></h2><p id="6459" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">下面提供的代码将检查“bar”是否被声明。</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="05c7" class="md lg it mv b gy mz na l nb nc">console.log(typeof bar !== 'undefined') //false</span></pre><p id="b0fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">仅引用“bar”会导致ReferenceError。</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="e928" class="md lg it mv b gy mz na l nb nc">console.log(bar) //error: Uncaught ReferenceError: bar is not defined</span></pre><h2 id="0de3" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak"> 4)铸造类型</strong></h2><p id="823d" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">类型转换的最佳选择是显式转换为三种可能类型中的一种。</p><p id="9cc1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> a)浇铸到管柱上</strong></p><p id="61fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过在前面添加一个空字符串，可以很容易地将值转换为字符串。</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="1978" class="md lg it mv b gy mz na l nb nc"> '' + 10 === '10'; // true</span></pre><p id="1e11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> b)铸造至编号</strong></p><p id="74e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用一元加号运算符可以转换为一个数字。</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="d04a" class="md lg it mv b gy mz na l nb nc">+'10' === 10; // true</span></pre><p id="2b72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> c)铸造到布尔</strong></p><p id="cda8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过在一个值前使用两次not运算符，可以将该值转换为布尔值。</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="8033" class="md lg it mv b gy mz na l nb nc">!!'foo'; // true<br/> !!''; // false<br/> !!'0'; // true<br/> !!'1'; // true<br/> !!'-1' // true<br/> !!{}; // true<br/> !!true; // true</span></pre><h2 id="e61c" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak"> 5)为什么我们不应该使用eval() </strong></h2><p id="a83d" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">我们不应使用eval，因为:</p><p id="408d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">a)eval()的任务可以用其他备选方案来完成，并且eval()也比备选方案慢</p><p id="40a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">b) eval()使用调用者的权限执行它传递的代码。这真的很危险！</p><p id="85aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">c)使用可能受到恶意方影响的字符串运行eval()</p><h2 id="7ecb" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated">6)未定义</h2><p id="5837" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">“未定义”是指已经声明但尚未赋值的变量。以下是返回未定义值时的一些示例:</p><ul class=""><li id="97c4" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn ni nj nk nl bi translated">访问已声明的<em class="nm">但未初始化的</em>变量。</li><li id="f249" class="nd ne it js b jt nn jx no kb np kf nq kj nr kn ni nj nk nl bi translated">由于缺少return语句而导致的函数隐式返回。</li><li id="e871" class="nd ne it js b jt nn jx no kb np kf nq kj nr kn ni nj nk nl bi translated">没有显式返回任何内容的语句。</li><li id="1b1f" class="nd ne it js b jt nn jx no kb np kf nq kj nr kn ni nj nk nl bi translated">查找不存在的属性。</li><li id="7824" class="nd ne it js b jt nn jx no kb np kf nq kj nr kn ni nj nk nl bi translated">没有传递任何显式值的函数参数。</li><li id="4567" class="nd ne it js b jt nn jx no kb np kf nq kj nr kn ni nj nk nl bi translated">任何被设置为undefined值的东西。</li><li id="0c76" class="nd ne it js b jt nn jx no kb np kf nq kj nr kn ni nj nk nl bi translated">任何形式的表达都是无效的(表达式)</li></ul><h2 id="daf9" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak"> 7)吊装</strong></h2><p id="f4b0" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">如果我们在函数中的任何地方使用var关键字声明一个变量，javascript会认为该变量是在该函数范围之上声明的。所以我们可以在变量声明语句之前访问它。这叫吊装。示例:</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="95a8" class="md lg it mv b gy mz na l nb nc">function showSomething(){<br/>  console.log(x,y,z) //undefinded undefined undefined<br/>  var x = 10;<br/>  var y = 5;<br/>  if(true){<br/>    var z = 100;<br/>  }<br/>  console.log(x,y,z) //10 5 100<br/>}</span><span id="d705" class="md lg it mv b gy nv na l nb nc">showSomething()</span></pre><p id="1ab6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，由于提升，我们可以在声明为一个<code class="fe ns nt nu mv b">undefined</code>变量之前访问所有三个x、y、z变量。</p><h2 id="a7bc" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak"> 8)块级声明</strong></h2><p id="fc61" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">块级声明意味着在块范围内声明的变量不能从外部访问。要在块级声明变量，我们使用两个关键字:</p><p id="9e10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> a)让</strong></p><p id="d0ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">let声明类似于var声明，但是不同之处在于let声明不在作用域的顶部。它只在我们声明它的块中有效。示例:</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="9345" class="md lg it mv b gy mz na l nb nc">function showSomething(){<br/>  console.log(x) //ReferenceError<br/>  console.log(y) //ReferenceError<br/>  console.log(z) //ReferenceError<br/>  let x = 10;<br/>  let y = 5;<br/>  if(true){<br/>    let z = 100;<br/>    console.log(z) //100<br/>  }<br/>  console.log(x) //10<br/>  console.log(y) //5<br/>  console.log(z) //ReferenceError<br/>}</span></pre><p id="a14b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们不能重新声明一个已经用<code class="fe ns nt nu mv b">let</code>关键字声明的变量。但是使用<code class="fe ns nt nu mv b">var</code>关键字是可能的。示例:</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="6d13" class="md lg it mv b gy mz na l nb nc">function showSomething(){<br/>  var x = 100<br/>  console.log(x) //100<br/> <br/>  var x = 20<br/>  console.log(x) //20</span><span id="7170" class="md lg it mv b gy nv na l nb nc">  let y = 19<br/>  console.log(y) //19</span><span id="e678" class="md lg it mv b gy nv na l nb nc">  let y = 18 // error: Identifier ‘y’ has already been declared<br/>}</span><span id="3327" class="md lg it mv b gy nv na l nb nc">showSomething()</span></pre><p id="f77b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> b)常量</strong></p><p id="04e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ns nt nu mv b">const</code>声明也是像<code class="fe ns nt nu mv b">let</code>声明一样的块级声明，但是区别在于我们不能改变用<code class="fe ns nt nu mv b">const</code>声明的变量的值。同样，如果我们用const声明一个变量，但不赋值，就会出错。</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="ae5a" class="md lg it mv b gy mz na l nb nc">// Valid constant<br/> const maxItems = 30;</span><span id="06ae" class="md lg it mv b gy nv na l nb nc">//TypeError: Assignment to constant variable<br/> maxItems = 20;</span><span id="aba4" class="md lg it mv b gy nv na l nb nc">// Syntax error: missing initialization<br/> const name;</span></pre><h1 id="0f0f" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">字符串</strong></h1><h2 id="c54a" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated">9) <strong class="ak">包含():</strong></h2><p id="7954" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">Includes是String对象的函数，它检查字符串是否包含指定的字符串/字符，如果存在则返回true，如果不存在则返回false。示例:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/0e8a869c999183793897a5633fd37a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/0*MicsgoRD--h5wb4J"/></div></figure><h2 id="6f37" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated">10) <strong class="ak"> endsWith(): </strong></h2><p id="0f33" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">endsWith()是String对象的一个函数，它检查一个字符串是否以指定的字符串/字符结尾，并基于此返回true或false。示例:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/326865851c8e02c7bbb134951ac5f077.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/0*TghHlkZ0d-B2FS0P"/></div></figure><h1 id="8e92" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">编号</strong></h1><h2 id="8639" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated">11) <strong class="ak">伊斯南()</strong></h2><p id="847a" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">isNaN()是Number对象的函数，它检查一个值是否“不是数字”，并根据结果返回true或false。示例:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/279ab7ac3bcac6089f532864f9019b09.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/0*di4O3TId1BNALbHt"/></div></figure><h1 id="6a9b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">阵列</strong></h1><h2 id="ba29" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak">12)</strong>T29】凡()</h2><p id="678f" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">every()是Array对象的一个函数，它检查数组中的每个元素是否都通过了测试。示例:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/76da8ee7d7a73c7092b2af88bbf928e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/0*KHTUtH6XLAQbQJfq"/></div></figure><h2 id="3e67" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak">13)</strong>T33】lastIndexOf()</h2><p id="3606" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">lastIndexOf()是Array对象的一个函数，它在数组中搜索一个元素，从末尾开始，并返回它的位置。示例:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/618f2c17dc5be446faa34f6fc666288d.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/0*LQtVM_2KCzZKGy0a"/></div></figure><h2 id="6d6e" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak">14)</strong>T37】shift()</h2><p id="e9b7" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">shift()是Array对象的一个函数，它删除数组的第一个元素，并返回该元素。示例:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/5ac85a1f63612badac8a163ed4a37efc.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/0*apsA_61BlH_6Yp_m"/></div></figure><h2 id="9c68" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak">15)</strong>T10】un shift()</h2><p id="f14b" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">unshift()是Array对象的一个函数，它向数组的开头添加新元素，并返回新的长度。示例:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/cba8165e0622f9b64adb226ce0bc40b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/0*2jTed9ry5RG1ox98"/></div></figure><h2 id="ada2" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak">16)</strong>T14】拼接()</h2><p id="704d" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">是Array对象的一个函数，用于在数组中添加/删除元素。示例:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi od"><img src="../Images/088812a5c3b9297580abe8811cf031af.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/0*h_GPyy4LommCbzM9"/></div></figure><h1 id="5b68" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">对象:</strong></h1><h2 id="8d17" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak">17)</strong>T20】冻结()</h2><p id="311d" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">freeze()是对象的一个功能，用于防止向其添加新属性。此外，它还防止现有属性被删除，并防止现有属性的值被更改。示例:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/5a63de789120468885e4f4333d9bf9f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/0*1yOS729GLePKlCpf"/></div></figure><h2 id="0ee7" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak">18)</strong>T24】印章()</h2><p id="0939" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">seal()是Object的一个函数，它从一个字符串中提取两个指定索引之间的字符。示例:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi of"><img src="../Images/ed6b8637a5db050312885e533be64b38.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/0*cfH_6owa3n_o0y7f"/></div></figure><h2 id="a726" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated">19)“括号符号”比“点符号”有优势</h2><p id="033d" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">假设我们有一个如下所示的对象:</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="6dac" class="md lg it mv b gy mz na l nb nc">let obj = {<br/>  name: 'Carrot',<br/>  details: {<br/>    color: 'orange',<br/>    size: 12<br/>  }<br/>}</span></pre><p id="4f1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我们不能使用“点符号”访问属性“for ”,因为在运行时它会给我们一个错误，即“for”是一个保留关键字。但是，如果我们试图访问使用'括号符号',那么我们可以访问属性，因为我们传递的关键作为一个字符串，这就是为什么它不会给出任何错误！</p><p id="aaef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">obj.for = ' Shadab//语法错误，因为“for”是保留关键字<br/>obj[' for ']= ' Shadab '；//成功了</p><h1 id="d9fd" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">破坏</strong></h1><h2 id="734f" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak"> 20)对象破坏</strong></h2><p id="9820" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">对象析构语法在赋值操作的左侧使用对象文字。例如:</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="835d" class="md lg it mv b gy mz na l nb nc">let node = {<br/>  type: “Identifier”,<br/>  name: “foo”<br/>};</span><span id="5fd5" class="md lg it mv b gy nv na l nb nc">let { type, name } = node;</span><span id="c32b" class="md lg it mv b gy nv na l nb nc">console.log(type); // “Identifier”<br/>console.log(name); // “foo”</span></pre><p id="c8a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这段代码中，<code class="fe ns nt nu mv b">node.type</code>的值存储在名为<code class="fe ns nt nu mv b">type</code>的变量中，<code class="fe ns nt nu mv b">node.name</code>的值存储在名为<code class="fe ns nt nu mv b">name</code>的变量中。</p><h2 id="12e2" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak"> 21)数组解构</strong></h2><p id="4cc5" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">数组析构语法在赋值操作的左侧使用数组文字。例如:</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="8889" class="md lg it mv b gy mz na l nb nc">let colors = [ “red”, “green”, “blue” ];<br/>let [ firstColor, secondColor ] = colors;</span><span id="60cc" class="md lg it mv b gy nv na l nb nc">console.log(firstColor); // “red”<br/>console.log(secondColor); // “green”</span></pre><p id="3d13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，数组析构从颜色数组中取出值“红色”和“绿色”，并将它们存储在<code class="fe ns nt nu mv b">firstColor</code>和<code class="fe ns nt nu mv b">secondColor</code>变量中。选择这些值是因为它们在数组中的位置。</p><h2 id="39ac" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak"> 22)析构参数</strong></h2><p id="9df5" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">当JavaScript函数带有大量可选参数时，我们可以创建一个<code class="fe ns nt nu mv b">options</code>对象，其属性指定附加参数，如下所示:</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="ba2a" class="md lg it mv b gy mz na l nb nc">// properties on options represent additional parameters<br/>function setCookie(name, value, options) {</span><span id="4420" class="md lg it mv b gy nv na l nb nc">    options = options || {};</span><span id="37eb" class="md lg it mv b gy nv na l nb nc">    let { secure, path, domain, expires } = options;</span><span id="5c41" class="md lg it mv b gy nv na l nb nc">    // code to set the cookie<br/>}</span><span id="c74c" class="md lg it mv b gy nv na l nb nc">// third argument maps to options<br/>setCookie(“type”, “js”, {<br/>    secure: true,<br/>    expires: 60000<br/>});</span></pre><p id="c807" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个函数中，<code class="fe ns nt nu mv b">name</code>和<code class="fe ns nt nu mv b">value</code>参数是必需的，但是<code class="fe ns nt nu mv b">secure</code>、<code class="fe ns nt nu mv b">path</code>、<code class="fe ns nt nu mv b">domain</code>和<code class="fe ns nt nu mv b">expires</code>不是必需的。因为其他数据没有优先级顺序，所以只使用带有命名属性的<code class="fe ns nt nu mv b">options</code>对象比列出额外的命名参数更有效。</p><h1 id="1525" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">功能</h1><h2 id="9dce" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak"> 23)带有默认参数的功能</strong></h2><p id="e7d7" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">我们可以创建带有默认参数值的函数。这意味着如果我们没有从函数调用中传递参数值，那么它将使用我们在函数声明期间为该参数设置的默认值。示例:</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="b8cc" class="md lg it mv b gy mz na l nb nc">function add(x, y=5){<br/>  console.log(x + y)<br/>}</span><span id="0d8b" class="md lg it mv b gy nv na l nb nc">add(10) //15</span></pre><p id="c527" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们将函数声明期间的参数y=5的值设置为默认值。</p><h2 id="0cb6" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak"> 24)块级功能</strong></h2><p id="dc43" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">如果一个函数声明出现在一个块中，那么它被称为块级函数。块级函数被提升到定义它们的块的顶部。示例:</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="3fde" class="md lg it mv b gy mz na l nb nc">if(true){<br/>  function hello(){<br/>    return “hello world”<br/>  }<br/>  console.log(hello()) //hello world<br/>}</span><span id="209f" class="md lg it mv b gy nv na l nb nc">console.log(hello()) //hello world</span></pre><h2 id="2b52" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated">25)关闭</h2><p id="a376" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">如果我们在另一个函数A()中声明了一个函数B()，那么即使函数A()执行完毕，函数B()也可以访问函数A()中声明的所有变量，但是函数B()仍然可以访问它的变量。这叫做闭包。例如:</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="ab91" class="md lg it mv b gy mz na l nb nc">function a(x) {<br/>  return function(y) {<br/>    return x + y;<br/>  };<br/>}<br/>var add5 = a(5);<br/>var add20 = a(20);<br/>console.log(add5(6)); //11<br/>console.log(add20(7)); // 27</span></pre><p id="0614" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，add5()和add20()函数仍然可以访问函数a()的值x，但是a()已经完成了它的执行。</p><h1 id="50c2" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">客户端存储</h1><h2 id="612a" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated">26)使用Web存储API存储数据</h2><p id="5f76" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">我们可以通过存储一些必要的数据来利用客户端浏览器的web存储API，这可以提高我们的web应用程序的性能。web浏览器中有两种类型的类对象存储。这两种存储都可以使用键值对来存储数据。我们可以存储的数据类型有字符串、数字等。这些存储是:</p><p id="3198" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">a)本地存储—这种存储长期存储数据。b)会话存储—只要浏览器处于打开状态，此存储就会存储数据。</p><p id="da05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用3种类型的函数来设置、获取和删除这两种存储类型中的数据。</p><p id="0a6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">a) setItem(key，value)——这个函数帮助我们在这些存储器中保存我们想要的数据。例如，如果我们想在sessionStorage中存储username，我们必须编写以下代码:</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="7673" class="md lg it mv b gy mz na l nb nc">sessionStorage.setItem('userName', 'Shadab');</span></pre><p id="6234" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">b) getItem(key) —该函数帮助我们从存储器中获取保存的数据。我们将键作为参数传递，它返回保存在该键下的数据/值。例如</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="e0e4" class="md lg it mv b gy mz na l nb nc">localStorage.getItem('cart');</span></pre><p id="5594" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">c) removeItem(key) —此函数帮助我们从存储器中删除保存的数据。我们将该键作为参数传递，它会删除保存在该键下的数据/值。例如</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="a117" class="md lg it mv b gy mz na l nb nc">localStorage.removeItem('cart');</span></pre><h1 id="b0cb" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">跨浏览器测试</h1><h2 id="800e" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated">27)跨浏览器测试</h2><p id="edcf" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">跨浏览器测试的任务是测试我们开发的网站/web应用程序在不同浏览器之间的兼容性。<br/> <br/>跨浏览器测试步骤:<br/> <br/> a)首先我们要在我们的开发机器上，通过在不同的浏览器上运行来测试我们的网站。<br/> <br/> b)如果应用程序的结构和设计看起来不错，那么我们必须测试所有的前端功能，如动画，响应等。工作正常。c)如果可能的话，我们必须在像电视这样的大型设备上测试这些东西，因为现在人们也在电视上浏览互联网。<br/> <br/> d)现在，我们必须检查智能手表、手机、平板电脑等较小设备上的应用程序的响应能力，以及其他功能是否正常工作。</p><h1 id="c447" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">错误处理</strong></h1><h2 id="79a7" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak">28)</strong>T14】试一试……抓住……最后</h2><p id="ae3f" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">它是这样工作的:</p><p id="1302" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，执行try {…}中的代码。</p><p id="c240" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果没有错误，那么catch(err)将被忽略:执行到达try的末尾并继续，跳过catch。</p><p id="4d80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果出现错误，try执行将停止，控制将转到catch(err)的开头。err变量(我们可以使用它的任何名称)将包含一个error对象，该对象详细描述了所发生的事情。</p><p id="7709" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果finally块存在，它将在所有情况下运行:</p><p id="a71e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">a)在尝试之后，如果没有错误，</p><p id="bf07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">b)在catch之后，如果有错误。</p><p id="bad5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例:</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="a831" class="md lg it mv b gy mz na l nb nc">try {<br/>  alert( 'try' );<br/>  if (confirm('Make an error?')) BAD_CODE();<br/>} catch (e) {<br/>  alert( 'catch' );<br/>} finally {<br/>  alert( 'finally' );<br/>}</span></pre><h1 id="6350" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak"> DOM树</strong></h1><h2 id="d779" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak">29)</strong>T20】什么是DOM？</h2><p id="c46b" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated"><strong class="js iu">文档对象模型</strong> ( <strong class="js iu"> DOM </strong>)是一个跨平台和独立于语言的接口，它将XML或HTML文档视为一个树形结构，其中每个节点都是一个表示文档一部分的对象。DOM表示一个带有逻辑树的文档。树的每个分支都以一个节点结束，每个节点都包含对象。DOM方法允许对树的编程访问；有了它们，人们可以改变文档的结构、风格或内容。节点可以附加事件处理程序。一旦事件被触发，事件处理程序就会被执行。</p><p id="1f7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例:</p><p id="2012" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> HTML </strong></p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="b006" class="md lg it mv b gy mz na l nb nc">&lt;!DOCTYPE HTML&gt;<br/>&lt;html&gt;<br/> &lt;head&gt;<br/>  &lt;title&gt;About elk&lt;/title&gt;<br/> &lt;/head&gt;<br/> &lt;body&gt;<br/>  The truth about elk.<br/> &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="3818" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">DOM将HTML表示为标签的树形结构。它看起来是这样的:</p><p id="0194" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> DOM树</strong></p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="02f9" class="md lg it mv b gy mz na l nb nc">HTML<br/>&gt;&gt;&gt; HEAD<br/>    &gt;&gt;&gt; #text <br/>␣␣␣␣<br/>    &gt;&gt;&gt;TITLE<br/>       &gt;&gt;&gt;#text About elk<br/>    &gt;&gt;&gt; #text <br/>␣␣␣␣<br/>&gt;&gt;&gt; #text <br/>␣␣␣␣<br/>&gt;&gt;&gt; BODY<br/>    &gt;&gt;&gt; #text The truth about elk.</span></pre><p id="626c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是关于DOM树的一些要点:</p><p id="16ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个树节点都是一个对象。是父节点，和是其子节点。</p><p id="8be6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">元素内的文本形成文本节点，标记为#text。它只包含一个字符串。它可能没有孩子，永远是一片树叶或一棵树。</p><p id="ccfe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">文本节点中的特殊字符:</p><p id="d14e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">A)换行符:<br/>(在JavaScript中称为\n)</p><p id="30b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">b)一个空间:␣</p><p id="f0c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只有两种顶级排除:</p><p id="032c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">a)忽略前的空格和换行符。</p><p id="72c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><root>b)如果我们在</root>内部。所以</p><p id="cca5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> DOM修改</strong></p><p id="b564" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 30)例子由createElement() </strong></p><p id="3563" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们通过一个例子来看看如何创建一个新元素和修改现有的页面内容或DOM。</p><p id="86a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们有一个网页，我们想显示一个信息。但是我们不想显示alert()，而是创建一个元素来显示消息。</p><p id="02b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的消息将显示在一个div中，该div的类将是“alert”。</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="1750" class="md lg it mv b gy mz na l nb nc">&lt;script&gt;<br/>   let div = document.createElement('div');<br/>   div.className = "alert";<br/>   div.innerHTML = "&lt;strong&gt;Hi there!&lt;/strong&gt; You've read an   important message.";<br/>&lt;/script&gt;</span></pre><p id="77d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了显示div，我们需要将它插入到文档中的某个位置。例如，在document.body中</p><p id="705b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有一个特殊的方法append:document . body . append(div)。</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="b22a" class="md lg it mv b gy mz na l nb nc">&lt;script&gt;</span><span id="975d" class="md lg it mv b gy nv na l nb nc">  let div = document.createElement(‘div’);</span><span id="797d" class="md lg it mv b gy nv na l nb nc">  div.className = “alert”;</span><span id="82a1" class="md lg it mv b gy nv na l nb nc">  div.innerHTML = “&lt;strong&gt;Hi there!&lt;/strong&gt; You’ve read an important message.”;</span><span id="35e3" class="md lg it mv b gy nv na l nb nc">  document.body.append(div);</span><span id="06d7" class="md lg it mv b gy nv na l nb nc">&lt;/script&gt;</span></pre><h1 id="bbd2" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">面向对象编程</strong></h1><h2 id="3100" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated">面向对象程序设计及其核心概念</h2><p id="c96c" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">面向对象编程(OOP)是一种计算机编程范例，其中我们使用“对象”的概念来表示数据和方法来编写计算机程序。</p><p id="d76d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里列出了在谈论面向对象编程(OOP)时最常用的概念:</p><ul class=""><li id="8a7d" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn ni nj nk nl bi translated">包装</li><li id="cba2" class="nd ne it js b jt nn jx no kb np kf nq kj nr kn ni nj nk nl bi translated">抽象</li><li id="38ee" class="nd ne it js b jt nn jx no kb np kf nq kj nr kn ni nj nk nl bi translated">可重用性/继承性</li><li id="450c" class="nd ne it js b jt nn jx no kb np kf nq kj nr kn ni nj nk nl bi translated">多态性</li></ul><p id="5aac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> a)封装</strong></p><p id="71bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">封装意味着隐藏信息或数据。它指的是对象执行其功能而不向调用者透露任何执行细节的能力。我们使用私有字段和方法来实现封装。示例:</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="cc15" class="md lg it mv b gy mz na l nb nc">class Book{<br/>   #title = '';<br/>   #author = '';</span><span id="2734" class="md lg it mv b gy nv na l nb nc">   constructor(title, author){<br/>     this.#title = title;<br/>     this.#author = author;<br/>   }<br/> <br/>   summary() { <br/>     console.log(`${this.#title} written by ${this.#author}.`);<br/>   } <br/> <br/>}</span><span id="e4c7" class="md lg it mv b gy nv na l nb nc">const book1 = new Book('Hippie', 'Paulo Coelho');<br/>book1.summary();<br/>console.log(book1.#title) //error</span></pre><p id="e87f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> b)抽象</strong></p><p id="e1c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">抽象意味着实现隐藏。这是一种隐藏实现细节的方式，只向调用者显示基本特性。换句话说，它隐藏了不相关的细节，只显示了对外部世界必要的东西。缺乏抽象会导致代码可维护性的问题。示例:</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="002b" class="md lg it mv b gy mz na l nb nc">class Foo {<br/>   constructor(text){<br/>       this._text = text;<br/>   }<br/> <br/>   //Implementation optional<br/>   genericMethod() {<br/>       console.log('running from super class. Text: '+this._text);<br/>   }<br/> <br/>   //Implementation required<br/>   doSomething() {<br/>     throw new Error('You have to implement the method doSomething!');<br/>   }<br/>}</span></pre><p id="62ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> c)继承</strong></p><p id="fb90" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">继承是一种允许我们使用现有类创建新类的机制。这意味着子类继承了父类的所有属性和行为。示例:</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="a1dd" class="md lg it mv b gy mz na l nb nc">class Person{<br/>   constructor(props){<br/>     this.name = props.name;<br/>     this.age = props.age;<br/>   }</span><span id="cb53" class="md lg it mv b gy nv na l nb nc">   getPersonInfo(){<br/>     return {<br/>         name: this.name,<br/>         age: this.age<br/>     }<br/>   }<br/>}</span><span id="cac6" class="md lg it mv b gy nv na l nb nc">class Student extends Person{<br/>   constructor(props){<br/>     super(props);<br/>     this.id = 10;<br/>   }</span><span id="fac3" class="md lg it mv b gy nv na l nb nc">   getStudentInfo(){<br/>     return {<br/>       id: this.id,<br/>       name: this.name,<br/>       age: this.age<br/>     }<br/>   }<br/>}</span><span id="dcff" class="md lg it mv b gy nv na l nb nc">let student = new Student({ name: ‘pip’, age:20})<br/>console.log(student.getStudentInfo())</span></pre><p id="e331" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> d)多态性</strong></p><p id="0c5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对不同的对象调用相同的方法并让每个对象以自己的方式响应的能力被称为多态性。</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="fc81" class="md lg it mv b gy mz na l nb nc">class Person{<br/>   constructor(props){<br/>      this.name = props.name;<br/>      this.age = props.age;<br/>   }</span><span id="a61e" class="md lg it mv b gy nv na l nb nc">   getInfo(){<br/>      return {<br/>         name: this.name,<br/>         age: this.age<br/>     }<br/>   }<br/>}</span><span id="5324" class="md lg it mv b gy nv na l nb nc">class Student extends Person{<br/>    constructor(props){<br/>      super(props);<br/>      this.id = 1 + Math.random()*10;<br/>   }</span><span id="a329" class="md lg it mv b gy nv na l nb nc">   getInfo(){<br/>     console.log(‘info of: ‘+ this.name)<br/>   }<br/>}</span><span id="73ff" class="md lg it mv b gy nv na l nb nc">let student1 = new Student({ name: ‘pip’, age:20})<br/>let student2 = new Student({ name: ‘pop’, age: 22})</span><span id="1918" class="md lg it mv b gy nv na l nb nc">student1.getInfo()<br/>student2.getInfo()</span></pre><h1 id="dfbf" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">功能编程</strong></h1><h2 id="9864" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated">什么是函数式编程</h2><p id="a898" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">函数式编程是一种编程范式，通过应用和组合函数来构造程序。它是一种声明式编程范式，其中函数定义是每个返回值的表达式树，而不是改变程序状态的命令性语句序列。</p><h2 id="81a5" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak"> 33)纯功能</strong></h2><p id="692b" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">纯函数是具有以下性质的函数:</p><ol class=""><li id="d5a4" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn og nj nk nl bi translated">对于相同的参数，它的返回值是相同的。(不随局部静态变量、非局部变量等变化。)</li><li id="b187" class="nd ne it js b jt nn jx no kb np kf nq kj nr kn og nj nk nl bi translated">它的求值没有副作用(没有局部静态变量、非局部变量、可变引用参数或I/O流的突变)。</li></ol><p id="f502" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例:</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="c03c" class="md lg it mv b gy mz na l nb nc">let array = [1,2,3]</span><span id="c2fc" class="md lg it mv b gy nv na l nb nc">//pure function<br/> function addToArray(arr, x){<br/>     return […arr, x];<br/> }</span><span id="5c82" class="md lg it mv b gy nv na l nb nc">let newArray = addToArray(array, 4);<br/>console.log(array)<br/>console.log(newArray)</span></pre><h2 id="dd6c" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak"> 34)功能不纯</strong></h2><p id="d709" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">不纯函数是在其词法范围之外变异变量/状态/数据的函数。示例:</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="aad8" class="md lg it mv b gy mz na l nb nc">let array = [1,2,3]</span><span id="24cd" class="md lg it mv b gy nv na l nb nc">//impure function<br/> function addToArray(arr, x){<br/>     arr.push(x);<br/> }</span><span id="9a0b" class="md lg it mv b gy nv na l nb nc">addToArray(array, 4);<br/>console.log(array)</span></pre><h2 id="818f" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated">不变性</h2><p id="a547" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">不可变对象是在创建后其状态不能被修改的对象。示例:</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="e8d4" class="md lg it mv b gy mz na l nb nc">const obj = Object.freeze({id: 100})</span><span id="dec1" class="md lg it mv b gy nv na l nb nc">//this will have no effect<br/>obj.id=20<br/>obj.name="shadab"</span><span id="1fef" class="md lg it mv b gy nv na l nb nc">console.log(obj)// { id: 100 }</span></pre><h2 id="84c3" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak"> 36)功能组成</strong></h2><p id="10d0" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">功能组合是将两个或多个功能组合起来产生一个新功能的过程。将函数组合在一起就像将一系列管道连接在一起，让我们的数据流过。</p><p id="3dc5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简单地说，函数`<em class="nm"> f` </em>和`<em class="nm"> g` </em>的组合可以定义为<em class="nm"> `f(g(x))`，</em>从内到外(从右到左)求值。换句话说，评估顺序是:</p><ol class=""><li id="7cd5" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn og nj nk nl bi translated"><em class="nm"> `x` </em></li><li id="e87a" class="nd ne it js b jt nn jx no kb np kf nq kj nr kn og nj nk nl bi translated"><em class="nm"> `g` </em></li><li id="7dce" class="nd ne it js b jt nn jx no kb np kf nq kj nr kn og nj nk nl bi translated"><em class="nm"> `f` </em></li></ol><p id="7a0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于函数组合的几个要点:</p><ol class=""><li id="cdaf" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn og nj nk nl bi translated">我们可以组合任意数量的函数(不限于两个)。</li><li id="ad22" class="nd ne it js b jt nn jx no kb np kf nq kj nr kn og nj nk nl bi translated">组合函数的一种方法是简单地从一个函数中取出输出，并将其传递给下一个函数(即f(g(x))。</li></ol><p id="fde1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例:</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="a595" class="md lg it mv b gy mz na l nb nc">// h(x) = x + 1<br/>// number -&gt; number<br/> function h(x) {<br/>     return x + 1;<br/> }</span><span id="1eb9" class="md lg it mv b gy nv na l nb nc">// g(x) = x²<br/>// number -&gt; number<br/> function g(x) {<br/>     return x * x;<br/> }</span><span id="9742" class="md lg it mv b gy nv na l nb nc">// f(x) = convert x to string<br/>// number -&gt; string<br/> function f(x) {<br/>     return x.toString();<br/> }</span><span id="0bbd" class="md lg it mv b gy nv na l nb nc">// y = (f ∘ g ∘ h)(1)<br/> const y = f(g(h(1)));<br/> console.log(y); // ‘4’</span></pre><h2 id="234e" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak"> 37)高阶函数</strong></h2><p id="5e30" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">高阶函数是以其他函数为自变量的函数<em class="nm">或</em>返回函数作为结果。</p><p id="4dfa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将另一个函数作为参数通常被称为<em class="nm">回调函数</em>，因为它被高阶函数回调。这是Javascript大量使用的一个概念。</p><p id="1f95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，数组上的<em class="nm">映射</em>函数是一个高阶函数。<em class="nm">映射</em>函数将一个函数作为参数。示例:</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="ce4c" class="md lg it mv b gy mz na l nb nc">const double = (n,index) =&gt; arr[index] = (n *= 2)</span><span id="23e6" class="md lg it mv b gy nv na l nb nc">const arr = [1, 2, 3, 4];</span><span id="b563" class="md lg it mv b gy nv na l nb nc">arr.map(double)</span><span id="9908" class="md lg it mv b gy nv na l nb nc">console.log(arr) // [ 2, 4, 6, 8 ]</span></pre><h2 id="2829" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak"/></h2><p id="0a46" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">Currying是这样一个过程:获取一个带有多个参数的函数，然后返回一系列带有一个参数的函数，最终解析为一个值。</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="44c6" class="md lg it mv b gy mz na l nb nc">function curry(f) { // curry(f) does the currying transform<br/>  return function(a) {<br/>    return function(b) {<br/>      return f(a, b);<br/>    };<br/>  };<br/>}</span><span id="a3cf" class="md lg it mv b gy nv na l nb nc">// usage<br/>function sum(a, b) {<br/>  return a + b;<br/>}</span><span id="53e5" class="md lg it mv b gy nv na l nb nc">let curriedSum = curry(sum);<br/>console.log( curriedSum(1)(2) ); // 3</span></pre><h1 id="fc3d" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">并发&amp;事件循环</strong></h1><h2 id="2673" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak"> 39)调用堆栈</strong></h2><p id="47db" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">调用堆栈是一个简单的数据结构，它记录了我们当前所在的代码。因此，如果我们单步执行一个函数调用，它将被推送到调用堆栈。当我们从一个函数返回时，它被弹出堆栈。</p><p id="5f17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例:</p><pre class="kp kq kr ks gt mu mv mw mx aw my bi"><span id="dee2" class="md lg it mv b gy mz na l nb nc">function multiply(x,y) {<br/>     return x * y;<br/>}</span><span id="9795" class="md lg it mv b gy nv na l nb nc">function squared(n) {<br/>    return multiply(n,n)<br/>}</span><span id="32df" class="md lg it mv b gy nv na l nb nc">function printSquare(n) {<br/>    return squared(n)<br/>}</span><span id="989f" class="md lg it mv b gy nv na l nb nc">let numberSquared = printSquare(5);<br/>console.log(numberSquared);</span></pre><p id="d351" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，当代码执行时，运行时将通读每个函数定义。但是当它到达调用第一个函数<strong class="js iu"> printSquare(5) </strong>的那一行时，它会将这个函数推入调用堆栈。</p><p id="ba0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，这个函数将执行。在返回之前，它将遇到另一个函数，<strong class="js iu"> squared(n)，</strong>，因此它将暂停当前操作，并将该函数推到现有函数的顶部。</p><p id="0017" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它执行函数(在这种情况下是平方函数)，最后遇到另一个函数<strong class="js iu"> multiply(n，n)。</strong>然后它挂起当前的执行，并将该函数推入调用堆栈。函数multiply执行并返回相乘后的值。</p><p id="8d40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，squared函数返回并弹出堆栈，printSquare也是如此。最终的平方值被分配给numberSquared变量。</p><p id="cb7a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们再次遇到函数调用(在本例中是一个console.log()语句),因此运行时将它推送到堆栈中。这将执行它，从而在控制台上打印平方数。</p><h2 id="bcc1" class="md lg it bd lh me mf dn ll mg mh dp lp kb mi mj lt kf mk ml lx kj mm mn mb mo bi translated"><strong class="ak"> 40)事件循环</strong></h2><p id="2792" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">事件循环是一个不断运行的过程，它检查调用堆栈是否为空。我们可以把它想象成一个时钟，每当它<em class="nm">滴答</em>时，它就会查看调用堆栈，如果它是空的，它就会查看事件队列。如果事件队列中有正在等待的东西，它将被移动到调用堆栈中。如果不是，那么什么都不会发生。</p><p id="71ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">今天到此为止。快乐编程。:)</p></div></div>    
</body>
</html>