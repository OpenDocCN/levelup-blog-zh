<html>
<head>
<title>Observer Design Pattern Implementation in Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Typescript中的观察者设计模式实现</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/observer-design-pattern-implementation-in-typescript-332477ee5b30?source=collection_archive---------2-----------------------#2021-03-16">https://levelup.gitconnected.com/observer-design-pattern-implementation-in-typescript-332477ee5b30?source=collection_archive---------2-----------------------#2021-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="60c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我们将学习观察者模式和这种设计模式的用法。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/b3f44fd7aab6f1bb4458e83ebd84c1ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4k2yFHs9kEbNWE7UgyhMWA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">观察者设计模式</figcaption></figure><h2 id="8992" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">观察者设计模式定义</h2><p id="f689" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">根据GoF的定义，观察者模式定义了对象之间一对多的依赖关系，因此当一个对象改变状态时，它的所有依赖对象都会得到通知并自动更新。它也被称为发布-订阅模式。</p><p id="3b2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，当你想知道另一个对象的变化时，你可以使用<strong class="jp ir">观察者设计模式</strong>。</p><p id="b08f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">观察者设计模式是一种<strong class="jp ir">行为模式</strong>，这意味着它是一种对象间通信的<em class="lz">模式</em>。</p><p id="162c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种设计模式的其他名称有<strong class="jp ir">事件订阅者</strong>、<strong class="jp ir">监听器、发布订阅者</strong></p><h2 id="a2df" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated"><strong class="ak">这种设计模式的真实例子有哪些？</strong></h2><p id="6b2e" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">社交应用程序是这种设计模式的真实例子。当我们在Instagram上关注某人时，我们只是想了解这个人的状态变化。</p><p id="feec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您使用NodeJS或Javascript，您应该熟悉事件监听器。我们听一个事件，我们想做一些事情。例如，当输入值改变时，我们想重新计算一些东西。这与我们通常使用观察者设计模式想要做的事情非常相似。</p><p id="6352" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个简单的例子是，当我们想从商店购买一种产品，但它已经卖完了，我们希望当它再次可用时得到通知。我们只是想知道这个产品的状态。在我们购买该产品后，我们不想知道该产品的变化。我们将在实现中使用这些简单的概念。</p><h2 id="5bbf" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">设计模式UML</h2><p id="b6ec" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">让我们看一下UML，然后，我们将使用typescript实现一个简单的示例:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/446d89560b7ad353bbe43af831aecd44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Jhtau0xFtdXyJlOSqNRZhw.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">观察者设计模式UML</figcaption></figure><p id="a80d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主题<strong class="jp ir">是我们想知道的事情。它包含了一些我们可能在不同文章中看到的不同名称的方法:</strong></p><ul class=""><li id="c7b1" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated"><strong class="jp ir">register observer</strong>=<strong class="jp ir">register</strong><strong class="jp ir">=</strong><strong class="jp ir">attach</strong>=<strong class="jp ir">subscribe</strong>:这是我们用来添加一个观察者的方法。</li><li id="9237" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated"><strong class="jp ir">unregister observer</strong><strong class="jp ir">= unregister =</strong><strong class="jp ir">detach</strong><strong class="jp ir">=</strong><strong class="jp ir">unsubscribe</strong>:这是我们用来删除一个观察者的方法。</li><li id="6e54" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated"><strong class="jp ir">notify observer</strong><strong class="jp ir">=</strong><strong class="jp ir">notify</strong>:这个方法将对每个观察器运行另一个方法，换句话说，这个方法将通知观察器有变化。</li><li id="6a55" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated"><strong class="jp ir">更新</strong>:这个方法是在Observer类中实现的，这是我们在主题改变时想要做的事情。</li></ul><h2 id="feed" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">空谈不值钱！</h2><p id="9974" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">让我们看看如何使用Typescript实现这一点:</p><p id="9158" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们应该安装Typescript来将我们的代码转换成JavaScript。</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="a4d1" class="lb lc iq mq b gy mu mv l mw mx">npm init -y<br/>npm install typescript</span></pre><p id="4995" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们创建我们的类型脚本文件:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">Typescript中观察者设计模式的基本实现</figcaption></figure><p id="a024" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现之后，我们在第35行和第36行创建了两个观察者。在第38行，我们创建了一个主题。</p><p id="870e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第40行<code class="fe na nb nc mq b">firstObserver</code>订阅了主题。因此，如果我们运行notify，我们应该只会看到<code class="fe na nb nc mq b">firstObserver</code>的日志。</p><p id="f05d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第42行，我们订阅了<code class="fe na nb nc mq b">secondObserver</code>，所以如果运行<code class="fe na nb nc mq b">notify</code>，现在我们应该可以看到这两个观察者的日志。</p><p id="5923" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第46行，我们取消了对<code class="fe na nb nc mq b">secondObserver</code>的订阅，所以如果执行<code class="fe na nb nc mq b">notify</code>，我们应该只能看到来自<code class="fe na nb nc mq b">firstObserver</code>的日志。</p><p id="2d65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，日志应该是这样的:</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="bb9a" class="lb lc iq mq b gy mu mv l mw mx">[LOG]: "Observer 1 is updating..."</span><span id="84ce" class="lb lc iq mq b gy nd mv l mw mx">[LOG]: "-----"</span><span id="36e4" class="lb lc iq mq b gy nd mv l mw mx">[LOG]: "Observer 1 is updating..."</span><span id="dda7" class="lb lc iq mq b gy nd mv l mw mx">[LOG]: "Observer 2 is updating..."</span><span id="62b6" class="lb lc iq mq b gy nd mv l mw mx">[LOG]: "-----"</span><span id="9e02" class="lb lc iq mq b gy nd mv l mw mx">[LOG]: "Observer 2 is updating..."</span></pre><h2 id="0081" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated"><strong class="ak">让我们实现一些更有意义的东西吧！</strong></h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">简单设计模式的例子</figcaption></figure><p id="326c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有一个CR7社交页面，我们想关注这个页面上的新闻。每个想关注这个页面的人都应该订阅，每次我们有一条新闻，我们就调用<code class="fe na nb nc mq b">notify</code>函数，在这里我们传递新闻，这个函数将新闻传递给粉丝，他们的<em class="lz">更新</em>实现可以很容易地将这条新闻添加到他们的<code class="fe na nb nc mq b">feed</code>数组中。之后，通过调用<code class="fe na nb nc mq b">showFeed</code>函数我们可以看到这些粉丝的反馈。</p><p id="2f55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们应该在控制台中看到的输出:</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="5654" class="lb lc iq mq b gy mu mv l mw mx">[LOG]: "alice recieved  a news"</span><span id="301c" class="lb lc iq mq b gy nd mv l mw mx">[LOG]: "bob recieved  a news"</span><span id="0b32" class="lb lc iq mq b gy nd mv l mw mx">[LOG]: "bob recieved  a news"</span><span id="0539" class="lb lc iq mq b gy nd mv l mw mx">[LOG]: "alice:CR7 has sent off"</span><span id="afad" class="lb lc iq mq b gy nd mv l mw mx">[LOG]: "bob:CR7 has sent off,CR7 scored a goal against Inter Milan."</span></pre></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="94ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是对这种设计模式的简单解释。就我个人而言，我只在看到一些例子时才理解这种东西，这里我的意图是通过使用简单的例子和用法来解释这种设计模式。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h2 id="a5f4" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">参考</h2><p id="7d25" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated"><a class="ae nl" href="https://howtodoinjava.com/design-patterns/behavioral/observer-design-pattern/#:~:text=A%20real%20world%20example%20of,at%20any%20point%20of%20time" rel="noopener ugc nofollow" target="_blank">https://howtodoinjava . com/design-patterns/behavioral/observer-design-pattern/#:~:text = A % 20 real % 20 world % 20 example % 20 of，at % 20 any % 20 point % 20 of % 20 time</a>。</p><p id="9e95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae nl" href="https://refactoring.guru/design-patterns/observer" rel="noopener ugc nofollow" target="_blank">https://refactoring.guru/design-patterns/observer</a></p></div></div>    
</body>
</html>