<html>
<head>
<title>How to Avoid the Headache With Non-deterministic Bugs in Software</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何避免软件中令人头痛的非确定性错误</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-avoid-the-headache-with-non-deterministic-bugs-in-software-e24457f05c9b?source=collection_archive---------25-----------------------#2021-02-23">https://levelup.gitconnected.com/how-to-avoid-the-headache-with-non-deterministic-bugs-in-software-e24457f05c9b?source=collection_archive---------25-----------------------#2021-02-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="674b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">再现性:有时</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/acd4395be3239d907b63005b70293c6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eFz6W73WL0P-yGn5"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@pankajpatel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">潘卡杰·帕特尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="413d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">QA工程师测试软件应用程序，发现问题，并将它们报告给像吉拉这样的错误跟踪系统。标签必须包含尽可能多的细节，以便软件工程师可以用来重现bug。理想情况下，描述bug的标签应该指定问题出现的环境、先决条件和重现步骤。</p><p id="06af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时程序员无法重现bug，即使有全面的信息。我不是在说试图在不同的环境中重现这个bug。这是一种常见的情况，即错误出现在UAT环境中，而不是QA环境中。这可能是由于数据库不一致或其他外部因素。真正的问题是，每10或20次试图重现它时，这个bug就会随机出现在相同的环境中。它只表明应用程序代码本身导致了不确定性。</p><p id="7f13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于尝试10次、50次或100次重现一个bug的程序员来说，这不是最佳选择。不能保证工程师会重现这一点。另一种耗时较少的方法如下所示:</p><ul class=""><li id="2774" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">分析代码的哪些部分可能与bug有关。</strong></li><li id="a354" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">检查代码中导致不确定行为的反模式。</strong></li></ul><p id="b845" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，不确定性行为是由三种情况引起的:缺乏线程同步、误用系统日期和时间，以及暂停线程一段时间。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a776" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">缺少线程同步</h1><p id="0501" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">根据我的经验，缺乏线程同步是应用程序中不确定性行为的最常见原因。如果并行运行的多个线程在没有适当同步的情况下同时修改共享数据，它们通常会给出不同的(不确定的)结果。</p><p id="6abb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="1899" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码克隆了订单集合。在某种程度上，工程师可能会决定通过将<code class="fe np nq nr ns b">foreach</code>循环分成块并在单独的处理器上执行每个块来加速这段代码。英寸NET中，这可以简单地通过使用<code class="fe np nq nr ns b">Parallel</code>类来完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="fd51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，工程师得到的不是快速代码，而是具有不确定性行为的代码，因为根本没有线程同步。方法<code class="fe np nq nr ns b">CloneOrders</code>将总是为相同的输入返回不同数量的订单。</p><p id="9b1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的特殊例子中，可以通过简单地将第7行包含在<code class="fe np nq nr ns b">Lock</code>语句中来改善这种情况。然而，并发和线程同步是一个庞大而复杂的话题。如果软件工程师发现多个线程同时修改共享数据，他们必须根据自己的情况仔细选择解决方案。</p><h1 id="5e88" class="mq mr it bd ms mt nt mv mw mx nu mz na jz nv ka nc kc nw kd ne kf nx kg ng nh bi translated">逻辑取决于当前时间</h1><p id="792f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">处理当前日期和时间的逻辑可以不确定地工作。</p><p id="7987" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们举个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="522f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果代码执行得非常快，方法<code class="fe np nq nr ns b">GetCount</code>将返回预期的计数3。如果执行缓慢，那么所有的<code class="fe np nq nr ns b">DateTime.Now</code>属性将返回不同的值，所以方法<code class="fe np nq nr ns b">GetCount</code>将返回0。此外，该方法可以返回1或2。订单的数量取决于代码执行的速度，由于许多外部因素，代码执行的速度总是不同的。</p><p id="0503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的特例中，<code class="fe np nq nr ns b">DateTime.Now</code>属性只需要在方法中被访问一次。我们可以将当前的时间值存储在某个变量中并重用它，这样行为就变得确定了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="71d7" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">挂起线程执行</h1><p id="5d9a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">有时候，线程A需要等待线程B完成。否则，线程A将无法正确完成其工作。最简单也是最不正确的方法是使用<code class="fe np nq nr ns b">Thread.Sleep(ms)</code>或<code class="fe np nq nr ns b">Task.Delay(ms)</code>语句，因为永远不可能预测线程A是否会在指定的毫秒数内完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="5d04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">访问<code class="fe np nq nr ns b">Length</code>属性的线程需要另一个线程来初始化文本。如果text属性初始化得足够快，长度将被正确地计算出来。如果文本没有初始化，将抛出<code class="fe np nq nr ns b">NullReferenceException</code>。行<code class="fe np nq nr ns b">Thread.Sleep(1)</code>试图阻止对文本的访问，直到初始化完成。但是，如果文本是通过HTTP调用接收的，就不可能预先知道初始化需要多长时间。</p><p id="1c57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的特殊情况下，文本处理逻辑应该放在一个单独的回调函数中。一旦文本被加载，加载文本的线程应该通过事件触发回调函数。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="7dfa" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">最后的想法</h1><p id="89d6" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">一旦带有非确定性反模式的代码被合并到主分支中，很可能在测试过程中没有人会注意到这个bug。您的客户可能是第一个发现生产环境中问题的人。</p><p id="4150" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">软件工程师在进行代码评审时，应该注意非确定性的反模式。否则，客户或QA工程师可能会变得有点疯狂，无法确定他们是否看到了真正的bug，或者他们是否有幻觉。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c99b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">更多关于软件质量的文章</h1><div class="ny nz gp gr oa ob"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-fix-bugs-and-not-introduce-new-ones-9f35e625673a"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">如何在不破坏应用程序的情况下修复Bug</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">更改源代码时更自信的步骤。</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op ks ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-design-reusable-software-components-213e05119796"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">开发人员编写可重用代码的两个简单技巧</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">加快发展应遵循的两个基本原则</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ok l"><div class="oq l om on oo ok op ks ob"/></div></div></a></div></div></div>    
</body>
</html>