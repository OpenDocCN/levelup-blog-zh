<html>
<head>
<title>Depth &amp; Breadth First Search in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋深度和广度优先搜索</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/depth-breadth-first-search-in-go-8a6ddcdc73d9?source=collection_archive---------3-----------------------#2021-02-06">https://levelup.gitconnected.com/depth-breadth-first-search-in-go-8a6ddcdc73d9?source=collection_archive---------3-----------------------#2021-02-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1c70" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">每个开发者都应该知道的两个图算法！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/90284180cb3e2f684cf9c5f1beb86583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*X8eNRBO7FdiF148b.jpg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">从<a class="ae ky" href="http://paradise.caltech.edu/~cook/papers/TwoNeurons.pdf" rel="noopener ugc nofollow" target="_blank">开始，骑一辆自行车需要两个神经元</a></figcaption></figure><p id="535f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">在</span>数据时代，图遍历算法是软件工程师最适用的工具。图遍历是在网络中寻找一些路径的过程，或者只是以特定的方式探索网络。有几十种遍历图的算法和策略——广度优先搜索(BFS)和深度优先搜索(DFS)被证明是处理图问题的简单而高效的算法。</p><p id="e000" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，除了用我最喜欢的编程语言Go实现这两种算法之外，我们还将学习理解它们。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="fac2" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">理解算法</h1><p id="ad7b" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">在我们开始任何代码之前，理解问题总是好的第一步。画出想象图，研究例子，向自己重复这个问题是逐步解决问题的好方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/026e28621bce79ad29b4a6ec4577b81c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Myg0u2yxIVsWPHkDyXpArA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">用LucidChart做的</figcaption></figure><p id="18bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从基础开始，一个图形网络可以有无限多种大小和配置。本文将关注树格式的图，其中有一个根节点和许多子节点。</p><p id="526c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何子节点都被指定为子节点，它所派生的节点被标记为其父节点。</p><p id="b694" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">树的每一层都由子层次结构的深度决定。对于理解本文上下文中的图表来说，这些信息已经足够了。</p><p id="ce8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，进入算法！</p><p id="9883" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">深度优先搜索</strong> (DFS)将深入而非广泛地探索一个图形。当谈到理解图论时，可视化是关键。如果一张图片胜过千言万语，那么一张gif就非常有价值。</p><p id="b12d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个简单但很棒的例子，说明深度优先搜索如何在继续前进之前深入到图形中。你是否会使用这个特殊的算法，完全取决于你的问题的背景，以及你是否想快速到达图的末端。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/ca8e407069813475a3fe7af904798bb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*plZ-x_Wuq0tc8mC5.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://commons.wikimedia.org/wiki/File:Depth-First-Search.gif" rel="noopener ugc nofollow" target="_blank">维基媒体</a></figcaption></figure><p id="daa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">广度优先搜索 (BFS)将广泛而非深入地探索一个图形。虽然DFS试图尽可能快地到达图表的端点，但BFS将逐层探索图表。在DFS和BFS之间做出选择取决于具体环境，它们都以自己的方式同样有用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/3ff8bb464700080c5f636807c03d3635.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*tDMgFqo4ImTjMWdw.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://commons.wikimedia.org/wiki/File:Breadth-First-Search-Algorithm.gif" rel="noopener ugc nofollow" target="_blank">维基媒体</a></figcaption></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="409b" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">Go中的实现</h1><p id="e0de" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">现在到了你们真正想要的部分。通过这些例子，我不禁欣赏Go在创建自己的定制数据类型时所提供的简单性。这是我们将使用的示例树:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/37b8a72319e427e5305237ff1441798a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9S0fO-DIX6UhXJMptY7N8A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">用LucidChart做的</figcaption></figure><p id="3880" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在编码面试中，经常会要求在这样的树上执行DFS或BFS。像这样的问题通常要求返回一个数组，该数组由图中节点的值组成，这些值根据我们使用的算法按顺序排列。以下是我们的示例返回值:</p><p id="63b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">DFS:</strong>【1，2，5，9，10，6，3，4，7，8】</p><p id="6d9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">BFS:</strong>【1，2，3，4，5，6，7，8，9，10】</p><h2 id="c7bc" class="nl mm it bd mn nm nn dn mr no np dp mv li nq nr mx lm ns nt mz lq nu nv nb nw bi translated">围棋深度优先搜索</h2><p id="5ec8" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">DFS的代码真的不多。我不会在这篇文章中包含构建树的代码，但是如果你真的想看的话，请在下面留下评论，我会添加的！回到我们的例子，我们的<code class="fe nx ny nz oa b">Node</code>数据类型有两个属性<code class="fe nx ny nz oa b">Value</code>和一个表示其子节点的节点数组。</p><p id="35d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe nx ny nz oa b">DepthFirstSearch()</code>函数通过将传递的节点结构作为它的前一个参数<code class="fe nx ny nz oa b">(n *Node)</code>来操作它。然后，我们按照遍历方法的顺序传递保存数组值的数组。DFS很简单，因为我们只需在每个节点的子节点上立即调用DFS。</p><p id="1202" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>这不是递归算法！我们只是在从前一个节点解包的每个子节点上调用DFS。我们使用<code class="fe nx ny nz oa b">range</code>关键字遍历一个节点的子节点，并丢弃第一个参数<code class="fe nx ny nz oa b">_</code>，因为它只是一个我们不关心的索引。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="9d46" class="nl mm it bd mn nm nn dn mr no np dp mv li nq nr mx lm ns nt mz lq nu nv nb nw bi translated"><strong class="ak">Go中的广度优先搜索</strong></h2><p id="42b5" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">BFS比DFS复杂一点，但也不复杂多少！主要的区别在于，我们不是立即遍历我们找到的下一个子节点，而是在移动到下一层之前，将单个节点的每个子节点的值相加。</p><p id="e411" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过利用一个<code class="fe nx ny nz oa b">queue</code>来实现，我们在第7行将其初始化为一个数组，存储对以单个结构开始的节点的引用。然后，我们开始一个for循环，只要队列中还有项目，这个循环就会继续。因为<code class="fe nx ny nz oa b">queue</code>表示我们要遍历的节点的顺序，所以我们知道一旦<code class="fe nx ny nz oa b">queue</code>为空，我们就已经探索了整个图。</p><p id="03f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">外部的for循环表示我们所在的图的级别。所以我们首先用第9行队列的第一个元素初始化当前节点。然后我们通过在Go中使用数组切片来“弹出”我们的队列。这是通过说我们想要第一个元素和随后的所有元素，即<code class="fe nx ny nz oa b">queue[1:]</code>来实现的。</p><p id="fa02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将刚才遍历的当前值添加到要返回的值数组中。最后一步是将该节点的所有子节点添加到我们的<code class="fe nx ny nz oa b">queue</code>中，这是通过在节点的子节点上再次使用<code class="fe nx ny nz oa b">range</code>关键字来完成的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><blockquote class="od oe of"><p id="82a0" class="kz la og lb b lc ld ju le lf lg jx lh oh lj lk ll oi ln lo lp oj lr ls lt lu im bi translated"><em class="it">总之，DFS和BFS的主要区别在于DFS会立即遍历下一个子节点，而DFS会通过队列逐层浏览图。</em></p></blockquote></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="87db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢阅读这篇文章。如果你想增加更多的细节或者想学习另一种算法，请在下面留下你的评论！感谢阅读。</p></div></div>    
</body>
</html>