<html>
<head>
<title>How Promises can fix callback-hell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">承诺如何修复回调-地狱</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-promises-can-fix-callback-hell-52ba72c3bd0f?source=collection_archive---------5-----------------------#2021-03-04">https://levelup.gitconnected.com/how-promises-can-fix-callback-hell-52ba72c3bd0f?source=collection_archive---------5-----------------------#2021-03-04</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj jr"><img src="../Images/c804cd18795af78658d7bec756e548dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qTcbMuIHaRRNeH71"/></div></div></figure><p id="9551" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">有过无休止的回调链吗？是的，我也是。我们称之为“回调-地狱”，它被称为“地狱”是有原因的。</p><p id="bb20" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">很多年来，我忽略了承诺，主要是因为我在几年内都在使用不容易实现的技术。然而，当添加这种支持时，我仍然避开它们，因为我认为创建承诺然后到处使用<code class="fe la lb lc ld b">.then()</code>没有任何好处。感觉编写几个函数并使用回调也一样容易。</p><p id="bd41" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">当然，我避开了无休止的嵌套，并且我经常以这样的代码结束:</p><pre class="le lf lg lh gu li ld lj lk aw ll bi"><span id="0db1" class="lm ln iu ld b gz lo lp l lq lr">function wrappedLogic() {<br/>    function a() {<br/>        asyncSomething(b);<br/>    }<br/>    function b(e) {<br/>        // do something with e here<br/>        asyncSomething(c);<br/>    }<br/>    function c(e) {<br/>        // do something with e here<br/>    }<br/>}</span></pre><p id="c7a1" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这只是3个不同的函数执行2个不同的异步动作，无论是图像操作、API调用还是线程化的东西。</p><p id="91b5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在我看来，使用承诺，我必须在<code class="fe la lb lc ld b">asyncSomething</code>函数中创建这个承诺，然后我将做<code class="fe la lb lc ld b">asyncSomething().then(b)</code>而不是<code class="fe la lb lc ld b">asyncSomething(b)</code>。虽然这可能读起来更干净(因为这个原因)，我从来没有真正看到它的好处。</p><p id="fcf1" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">当然，我在这里跳过了很多好处，比如<a class="ae ls" href="https://javascript.info/promise-chaining" rel="noopener ugc nofollow" target="_blank">承诺链、</a>但是如果你的思想没有看到任何好处，那就需要更多一点的东西来最终让事情“点击”。</p><p id="ea1c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">但最终让我看到光明的是<code class="fe la lb lc ld b">async/await</code>。现在我开始自责，我一直以来是多么的愚蠢，我本可以把承诺用在像连锁这样的事情上，但尤其是用在<code class="fe la lb lc ld b">await</code>上。</p><p id="88f2" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">以上面的3函数示例代码为例，如果上面的<code class="fe la lb lc ld b">asyncSomething</code>函数返回一个承诺，那么它应该是这样编写的。</p><pre class="le lf lg lh gu li ld lj lk aw ll bi"><span id="551f" class="lm ln iu ld b gz lo lp l lq lr">async function wrappedLogic() {<br/>    const result = await asyncSomething();<br/>    // do something with result<br/>    const secondResult = await asyncSomething();<br/>    // do something with secondResult<br/>}</span></pre><p id="3cac" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">那么你脑子里有没有什么东西还想把它写成我之前写的3个函数那样？这看起来是不是好多了？</p><p id="7bf5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">你能想象编写需要10个函数的代码逻辑吗？还是只有10个在等着？那样看起来会更好吗？</p><p id="92ba" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我是这样认为的，这最终使我更深入地研究了承诺，现在我在任何地方都使用它们，并且在过去的几年中，我一直试图在所有代码中实现它们。</p><h2 id="818c" class="lm ln iu bd lt lu lv dn lw lx ly dp lz kn ma mb mc kr md me mf kv mg mh mi mj bi translated">包装遗留软件</h2><p id="d8a4" class="pw-post-body-paragraph kc kd iu ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz in bi translated">所以现在我们到了让我犹豫了一段时间的点，遗留软件不支持承诺。这并不是说你不能使用承诺。更多的问题是SDK没有这些功能，在相当多的方面仍然没有。您可以用promise声明包装任何异步功能，并使用该promise返回到您想要的任何<code class="fe la lb lc ld b">async/await</code>功能。我用自己的应用程序做这个已经有一段时间了，但是最近我也调整了我的一个<a class="ae ls" href="https://github.com/Topener/XHR" rel="noopener ugc nofollow" target="_blank">开源项目</a>，这样其他人也可以使用它。当然，我几年前就该这么做了，但一直没时间去做。但是根据那些仅仅因为它有前景就想使用它的人的反应，我意识到我应该写一篇关于这个学习的博客。</p><p id="2ed5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">因为有一件事对我来说是显而易见的，仅仅因为一种语言支持某种使生活变得更容易的东西，并不意味着使用这种语言的每个人实际上都在使用它。我花了很长时间才理解它，而且有很多人在使用JavaScript，他们甚至从来没有使用过承诺。</p><p id="9b9d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">那么如何包装遗留软件呢？嗯…基本上是承诺101。不是在函数中不返回任何内容，而是接受回调作为参数，而是将整个内容包装在promise声明中，然后进行resolve/reject。</p><p id="f064" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">拿这个例子来说:</p><pre class="le lf lg lh gu li ld lj lk aw ll bi"><span id="0299" class="lm ln iu ld b gz lo lp l lq lr">function somethingAsync(callback){<br/>    doApiCall(result =&gt; {<br/>        callback(JSON.parse(result.response));<br/>    });<br/>}</span></pre><p id="18bd" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">让我们假设<code class="fe la lb lc ld b">doApiCall</code>是您使用的SDK提供的一个方法，它不容易调整(在我使用<a class="ae ls" href="https://titaniumsdk.com/api/titanium/network/httpclient.html" rel="noopener ugc nofollow" target="_blank">跨平台应用程序开发SDK </a>的情况下就是这样)，那么您可以这样包装它:</p><pre class="le lf lg lh gu li ld lj lk aw ll bi"><span id="0ede" class="lm ln iu ld b gz lo lp l lq lr">function somethingAsync(){<br/>    return new Promise((resolve, reject) =&gt; {<br/>        doApiCall(result =&gt; {<br/>            resolve(JSON.parse(result.response));<br/>        });<br/>    });<br/>}</span></pre><p id="869b" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这样，你突然用你的<code class="fe la lb lc ld b">somethingAsync</code>函数支持一个承诺，并且你不必调整SDK来实现它。这在很多理想世界不存在的情况下非常重要。现在，您可以用<code class="fe la lb lc ld b">await</code>调用函数，并且在代码中的任何其他地方都不必担心回调。</p><h2 id="b819" class="lm ln iu bd lt lu lv dn lw lx ly dp lz kn ma mb mc kr md me mf kv mg mh mi mj bi translated">进一步阅读</h2><p id="6ef2" class="pw-post-body-paragraph kc kd iu ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz in bi translated">所以现在你知道了使用承诺的(众多)理由之一，希望你至少理解了其中一部分的重要性。希望你能看到，就像我几年前看到的一样，如果你还没有在读这篇文章之前看到的话。</p><p id="d3a9" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">现在你可能想开始检查mdn 上<a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺的文档和mdn </a>上<a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" rel="noopener ugc nofollow" target="_blank">等待的文档。</a></p><p id="9a3a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><strong class="ke iv">反馈</strong></p><p id="929d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我错过了什么明显的东西吗？你最近学到的东西？请回复我或者给我发一条<a class="ae ls" href="https://twitter.com/wraldpyk" rel="noopener ugc nofollow" target="_blank">推文</a>！</p></div></div>    
</body>
</html>