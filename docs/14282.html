<html>
<head>
<title>Easy to Master the Generics in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">容易掌握TypeScript中的泛型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/easy-to-master-the-generics-in-typescript-c288e2995bc6?source=collection_archive---------8-----------------------#2022-11-14">https://levelup.gitconnected.com/easy-to-master-the-generics-in-typescript-c288e2995bc6?source=collection_archive---------8-----------------------#2022-11-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7737e362d51850e245fb505331f8fa78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SwuiHZDiMn-cEQx_1EmLyA.jpeg"/></div></div></figure><h2 id="3e12" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">为什么我需要一个泛型？</h2><blockquote class="ku kv kw"><p id="c8d7" class="kx ky kz la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">软件工程的一个主要部分是构建组件，这些组件不仅要有定义良好且一致的API，还要可重用。能够处理今天的数据和明天的数据的组件将为您提供构建大型软件系统的最灵活的能力。</p><p id="aa85" class="kx ky kz la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在像C#和Java这样的语言中，工具箱中用于创建可重用组件的主要工具之一是<em class="iq">泛型</em>，也就是说，能够创建一个可以在多种类型而不是单一类型上工作的组件。这允许用户消费这些组件并使用他们自己的类型。</p></blockquote><p id="8738" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">上面官方的解释对于初学者来说很难理解。</p><p id="5c48" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">我认为初学者首先应该明白为什么需要泛型，它解决了什么问题。而不是看这种议论文式的定义。</p><p id="6a1e" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">让我们看一个像这样的例子，感受一下泛型解决的问题。</p><p id="88f1" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">定义一个<code class="fe lw lx ly lz b">print </code>函数，打印出传入的参数并返回它。传入参数是字符串类型，函数返回字符串。</p><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="4e94" class="mi jz iq lz b be mj mk l ml mm">function print(arg:string):string {<br/>    console.log(arg)<br/>    return arg<br/>}</span></pre><p id="1fd2" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">现在要求改变了，我仍然需要打印号码类型，我能做什么？</p><p id="8132" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">您可以使用联合类型进行转换。</p><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="be29" class="mi jz iq lz b be mj mk l ml mm">function print(arg:string | number):string | number {<br/>    console.log(arg)<br/>    return arg<br/>}</span></pre><p id="2d55" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">现在要求又变了，我还需要打印字符串数组，数字数组，甚至任何类型，该怎么办？</p><p id="483c" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">有一种愚蠢的方法可以编写尽可能多的受支持的联合类型。</p><p id="ed45" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">或者将参数类型改为<code class="fe lw lx ly lz b">any</code>。</p><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="e3c9" class="mi jz iq lz b be mj mk l ml mm">function print(arg:any):any {<br/>    console.log(arg)<br/>    return arg<br/>}</span></pre><p id="fdd2" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">不是说写<code class="fe lw lx ly lz b">any </code>类型不好，毕竟尽量不要在TypeScirpt里面写<code class="fe lw lx ly lz b">any </code>。</p><p id="2251" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">而这不是我们想要的结果，只能说传入值是any类型，传出值是any类型，传入值和返回值不统一。</p><p id="e057" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">甚至还有这样的bug:</p><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="128d" class="mi jz iq lz b be mj mk l ml mm">const res:string = print(123)</span></pre><p id="9842" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">定义一个字符串类型来接收打印函数的返回值返回一个数字类型，TS并没有向我们报错。</p><p id="8d3a" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">这就是泛型的用武之地，它们可以轻松解决输入输出一致的问题。</p><blockquote class="ku kv kw"><p id="7050" class="kx ky kz la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">注意:Generic不是为解决这一问题而设计的。泛型还解决了许多其他问题，这里用这个例子引出泛型。</p></blockquote><h2 id="d160" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">泛型的基本用法</h2><ol class=""><li id="74e2" class="mn mo iq la b lb mp lf mq kh mr kl ms kp mt lv mu mv mw mx bi translated"><strong class="la ir">处理功能参数</strong></li></ol><p id="bd6a" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">泛型类型的语法是将类型参数写在&lt;&gt;中，一般可以表示为t。</p><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="d5c4" class="mi jz iq lz b be mj mk l ml mm">function print&lt;T&gt;(arg:T):T {<br/>    console.log(arg)<br/>    return arg<br/>}</span></pre><p id="a7bc" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">这样，我们实现了输入输出的统一类型，可以输入输出任何类型。</p><p id="9ef7" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">泛型类型中的T就像一个占位符或变量，当与已定义的类型一起使用时，可以像参数一样传入，也可以按原样输出。</p><blockquote class="ku kv kw"><p id="e35d" class="kx ky kz la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">泛型的编写方式对于前端工程师来说有点奇怪，比如&lt;&gt; T，但是最好记住，只要你一看到&lt;&gt;，就知道它是一个泛型。</p></blockquote><p id="ba21" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">当我们使用它时，有两种方法可以指定类型。</p><ul class=""><li id="ca12" class="mn mo iq la b lb lc lf lg kh my kl mz kp na lv nb mv mw mx bi translated">定义要使用的类型</li><li id="3adf" class="mn mo iq la b lb nc lf nd kh ne kl nf kp ng lv nb mv mw mx bi translated">TS类型推断来自动派生类型</li></ul><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="b8c6" class="mi jz iq lz b be mj mk l ml mm">print&lt;string&gt;('hello')  // Define T as string<br/>print('hello')  <br/>// TS type inference, automatic derivation of the type string</span></pre><p id="ec72" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">我们知道，类型和接口都可以定义函数类型，所以我们也用通用术语来写。</p><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="c0a1" class="mi jz iq lz b be mj mk l ml mm">type Print = &lt;T&gt;(arg: T) =&gt; T<br/>const printFn:Print = function print(arg) {<br/>    console.log(arg)<br/>    return arg<br/>}</span></pre><p id="60f5" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">界面这样写。</p><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="6639" class="mi jz iq lz b be mj mk l ml mm">interface Iprint&lt;T&gt; {<br/>    (arg: T): T<br/>}<br/>function print&lt;T&gt;(arg:T) {<br/>    console.log(arg)<br/>    return arg<br/>}<br/>const myPrint: Iprint&lt;number&gt; = print</span></pre><p id="0346" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated"><strong class="la ir"> 2。默认参数</strong></p><p id="0062" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">如果你想给一个泛型类型添加默认参数，你可以这样写。</p><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="f167" class="mi jz iq lz b be mj mk l ml mm">interface Iprint&lt;T = number&gt; {<br/>    (arg: T): T<br/>}<br/>function print&lt;T&gt;(arg:T) {<br/>    console.log(arg)<br/>    return arg<br/>}<br/>const myPrint: Iprint = print</span></pre><p id="b1ef" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">所以默认是数字类型，怎么样，感觉T像不像函数参数？</p><p id="f4d1" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated"><strong class="la ir"> 3。处理多个功能参数</strong></p><p id="899a" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">现在有一个函数传入一个只有两项的元组，交换元组的项0和项1，返回元组。</p><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="b9e2" class="mi jz iq lz b be mj mk l ml mm">function swap(tuple) {<br/>    return [tuple[1], tuple[0]]<br/>}</span></pre><p id="cb00" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">这样写，我们失去了类型，用一个泛型类型对它进行了一点转换。</p><p id="9350" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">我们用T表示0项的类型，U表示1项的类型。</p><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="bea5" class="mi jz iq lz b be mj mk l ml mm">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T]{<br/>    return [tuple[1], tuple[0]]<br/>}</span></pre><p id="46aa" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">这使得能够控制元组项目0和项目1类型。</p><p id="3be7" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated"><strong class="la ir"> 4。功能副作用操作</strong></p><p id="5aba" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">泛型不仅便于将参数类型约束到函数中，而且对于执行副作用操作的函数也是如此。</p><p id="69e0" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">例如，我们有一个通用的异步请求方法，它希望基于不同的url请求返回不同类型的数据。</p><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="3bfa" class="mi jz iq lz b be mj mk l ml mm">function request(url:string) {<br/>    return fetch(url).then(res =&gt; res.json())<br/>}</span></pre><p id="4b49" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">调用一个接口来获取用户的信息。</p><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="a006" class="mi jz iq lz b be mj mk l ml mm">request('user/info').then(res =&gt;{<br/>    console.log(res)<br/>})</span></pre><p id="5f02" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">返回结果res是一个<code class="fe lw lx ly lz b">any</code>类型，很烦。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/d77c39354428c840ad1d9d62195336e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*5__LKcAqJl9XkjTYD4H3_g.png"/></div></figure><p id="efab" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">我们希望API调用清楚返回类型是什么数据结构，所以我们可以这样做。</p><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="7dba" class="mi jz iq lz b be mj mk l ml mm">interface UserInfo {<br/>    name: string<br/>    age: number<br/>}<br/>function request&lt;T&gt;(url:string): Promise&lt;T&gt; {<br/>    return fetch(url).then(res =&gt; res.json())<br/>}<br/>request&lt;UserInfo&gt;('user/info').then(res =&gt;{<br/>    console.log(res)<br/>})</span></pre><p id="2bdc" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">这使得获取接口返回的数据类型变得非常容易，并且使得开发更加高效。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/f39f72d56508fa60bae84319eb9ddc5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*bgYvlkOnRLDXxTswguM9WQ.png"/></div></figure><h2 id="9d71" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">约束泛型</h2><p id="4199" class="pw-post-body-paragraph kx ky iq la b lb mp ld le lf mq lh li kh nj ll lm kl nk lp lq kp nl lt lu lv ij bi translated">假设现在有这样一个函数，打印传入参数的长度，我们这样写。</p><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="d2e6" class="mi jz iq lz b be mj mk l ml mm">function printLength&lt;T&gt;(arg: T): T {<br/>    console.log(arg.length)<br/>    return arg<br/>}</span></pre><p id="931f" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">因为不确定T是否具有长度属性，所以会报告一个错误。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/0109ce620e66b0eb7afbe9e478fdc36f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vcqWms8Py4XHu2cumjuEvw.png"/></div></div></figure><p id="c621" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">所以现在我想约束泛型类型，它必须有一个长度属性，我该怎么做？</p><p id="5395" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">您可以将它与interface结合起来约束类型。</p><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="394a" class="mi jz iq lz b be mj mk l ml mm">interface ILength {<br/>    length: number<br/>}<br/><br/>function printLength&lt;T extends ILength&gt;(arg: T): T {<br/>    console.log(arg.length)<br/>    return arg<br/>}</span></pre><p id="ee89" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">这里的关键是<code class="fe lw lx ly lz b">&lt;T extends ILength&gt;</code>，它允许泛型从接口<code class="fe lw lx ly lz b">ILength </code>继承，这样它就可以约束泛型。</p><p id="8801" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">我们定义的变量必须有<code class="fe lw lx ly lz b">length </code>属性，比如下面的<code class="fe lw lx ly lz b">str</code>、<code class="fe lw lx ly lz b">arr </code>和<code class="fe lw lx ly lz b">obj </code>，才能通过TS编译。</p><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="0ed5" class="mi jz iq lz b be mj mk l ml mm">const str = printLength('lin')<br/>const arr = printLength([1,2,3])<br/>const obj = printLength({ length: 10 })</span></pre><p id="e8c5" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">这个例子也重申了接口的<code class="fe lw lx ly lz b">duck typing</code>。</p><p id="187e" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">只要你有<code class="fe lw lx ly lz b">length </code>属性，你就符合约束，所以你是<code class="fe lw lx ly lz b">str</code>、<code class="fe lw lx ly lz b">arr</code>还是<code class="fe lw lx ly lz b">obj</code>都没关系。</p><p id="784f" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">当然，如果我们定义一个不包含<code class="fe lw lx ly lz b">length </code>属性的变量，比如一个数字，它会报告一个错误:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/512e47f15960e26dea9026aa7a22bdda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h3o-28_haI6FAL1SVqzOLA.png"/></div></div></figure><h2 id="4a7b" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">泛型的一些应用</h2><p id="a0d3" class="pw-post-body-paragraph kx ky iq la b lb mp ld le lf mq lh li kh nj ll lm kl nk lp lq kp nl lt lu lv ij bi translated">使用泛型类型，您可以定义函数、接口或类，而无需事先指定特定的类型，而是在使用时指定类型。</p><ol class=""><li id="910c" class="mn mo iq la b lb lc lf lg kh my kl mz kp na lv mu mv mw mx bi translated"><strong class="la ir">通用约束类</strong></li></ol><p id="194e" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">用两种方法定义一个栈，栈内和栈外。如果你希望栈内和栈外元素是统一的类型，你可以这样写。</p><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="8442" class="mi jz iq lz b be mj mk l ml mm">class Stack&lt;T&gt; {<br/>    private data: T[] = []<br/>    push(item:T) {<br/>        return this.data.push(item)<br/>    }<br/>    pop():T | undefined {<br/>        return this.data.pop()<br/>    }<br/>}</span></pre><p id="5f6b" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">当定义实例时，写类型，例如，如果栈内和栈外都是number类型，那么写这个。</p><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="dd7a" class="mi jz iq lz b be mj mk l ml mm">const s1 = new Stack&lt;number&gt;()</span></pre><p id="c10d" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">这样，堆叠字符串将会报告错误。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/15e55742f71e52b2868858783a5606e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QfW0GRzllDjIDDZZg2ce3g.png"/></div></div></figure><p id="f8fc" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">这是非常灵活的，如果需求发生变化，并且传入和传出堆栈是<code class="fe lw lx ly lz b">string </code>类型，只需在定义实例时更改它。</p><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="683d" class="mi jz iq lz b be mj mk l ml mm">const s1 = new Stack&lt;string&gt;()</span></pre><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/2781f7455e90b3d5fa00513bcc865c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mZ9hSA6U8Ul-7jHTLUyHWg.png"/></div></div></figure><p id="8911" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">特别要注意，泛型不能约束类的静态成员。</p><p id="c312" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">为pop方法定义static关键字会报告一个错误:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/bce3cfc4894762681d20cc4a754f3fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RNjN9FuuM0H1lPzvIRxwvg.png"/></div></div></figure><p id="7d00" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated"><strong class="la ir"> 2。通用约束接口</strong></p><p id="3549" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">使用泛型，您还可以调整接口，使其更加灵活。</p><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="f4ab" class="mi jz iq lz b be mj mk l ml mm">interface IKeyValue&lt;T, U&gt; {<br/>    key: T<br/>    value: U<br/>}<br/><br/>const k1:IKeyValue&lt;number, string&gt; = { key: 18, value: 'lin'}<br/>const k2:IKeyValue&lt;string, number&gt; = { key: 'lin', value: 18}</span></pre><p id="a13f" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated"><strong class="la ir"> 3。通用定义数组</strong></p><p id="e069" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">定义一个数组，就像我们之前写的那样。</p><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="38f4" class="mi jz iq lz b be mj mk l ml mm">const arr: number[] = [1,2,3]</span></pre><p id="cca4" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">现在也可以这样写。</p><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="08b7" class="mi jz iq lz b be mj mk l ml mm">const arr: Array&lt;number&gt; = [1,2,3]</span></pre><p id="effb" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">数组项类型错误，报告了错误</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/f97cdec6c8f820c0223426f8ab6b76e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MFyD5-s1m5p6Ci9rI6KW3g.png"/></div></div></figure><h2 id="5fed" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">后端接口参数类型的实用、通用约束</h2><p id="a440" class="pw-post-body-paragraph kx ky iq la b lb mp ld le lf mq lh li kh nj ll lm kl nk lp lq kp nl lt lu lv ij bi translated">让我们看看泛型类型的一种用法，它对项目开发非常有帮助，约束后端接口参数类型。</p><pre class="ma mb mc md gt me lz mf bn mg mh bi"><span id="0f17" class="mi jz iq lz b be mj mk l ml mm">import axios from 'axios'<br/><br/>interface API {<br/>    '/book/detail': {<br/>        id: number,<br/>    },<br/>    '/book/comment': {<br/>        id: number<br/>        comment: string<br/>    }<br/>    ...<br/>}<br/><br/><br/>function request&lt;T extends keyof API&gt;(url: T, obj: API[T]) {<br/>    return axios.post(url, obj)<br/>}<br/><br/>request('/book/comment', {<br/>    id: 1,<br/>    comment: 'great!'<br/>})</span></pre><p id="42a0" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">这样，当调用接口时会有提醒，例如</p><p id="abf9" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">写入了错误的路径:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/594d4f8290a17b7d1889dfd374695fb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1FBBLpSKF_f9e49MenSKwQ.png"/></div></div></figure><p id="7c5c" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">传递了错误的参数类型:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/3564b91993a196dfaea1f0f8d4e3c2ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FTEnzTpzIqW8uqYnOgZtow.png"/></div></div></figure><p id="182b" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">传递的参数少于:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/61ae4d0059a4daff9a4168defb545189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3GjnuZFeUz1103xcLyGs5A.png"/></div></div></figure><h2 id="3c87" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">摘要</h2><p id="6d65" class="pw-post-body-paragraph kx ky iq la b lb mp ld le lf mq lh li kh nj ll lm kl nk lp lq kp nl lt lu lv ij bi translated">从字面上看，泛型是广义的。<br/>通用类型是在没有预先指定具体类型的情况下定义的函数、接口或类，而是在使用时指定类型。<br/>泛型类型中的T就像一个占位符，或者变量，在使用的时候可以像参数一样在定义的类型中传递，可以按原样输出。<br/>泛型类型提供了成员之间有意义的约束，可以是:函数参数、函数返回值、类的实例成员、类的方法等。</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="2992" class="pw-post-body-paragraph kx ky iq la b lb lc ld le lf lg lh li kh lk ll lm kl lo lp lq kp ls lt lu lv ij bi translated">如果你对我的文章感兴趣，可以关注我的<a class="ae oa" href="https://hyhwell.medium.com/" rel="noopener">媒体</a>或<a class="ae oa" href="https://twitter.com/Maxwell_hyh" rel="noopener ugc nofollow" target="_blank">推特</a>。</p><div class="ob oc gp gr od oe"><a rel="noopener  ugc nofollow" target="_blank" href="/making-it-easier-to-get-started-with-typescript-a39dc2abffd9"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">使开始使用TypeScript变得更加容易</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">TypeScript中的函数定义、类和继承</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="on l"><div class="oo l op oq or on os jw oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a href="https://javascript.plainenglish.io/one-article-to-understand-typescript-object-oriented-59346983c466" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">理解面向对象的类型脚本的一篇文章</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">理解静态属性、静态方法、多态、抽象类和接口定义</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="on l"><div class="ot l op oq or on os jw oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a rel="noopener  ugc nofollow" target="_blank" href="/10-advanced-typescript-tips-for-development-2666298d50f"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">用于开发的10个高级打字技巧</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">高级打字技巧</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">用于开发高级打字稿Tipslevelup.gitconnected.com</p></div></div><div class="on l"><div class="ou l op oq or on os jw oe"/></div></div></a></div></div></div>    
</body>
</html>