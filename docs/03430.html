<html>
<head>
<title>The Mysterious JavaScript Object’s __proto__ Property</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">神秘的JavaScript对象的__proto__属性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-mysterious-javascript-objects-proto-property-67b7c6b3140c?source=collection_archive---------4-----------------------#2020-05-08">https://levelup.gitconnected.com/the-mysterious-javascript-objects-proto-property-67b7c6b3140c?source=collection_archive---------4-----------------------#2020-05-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5c154f9e17a83b4e86b494e72c86ee3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q-yDN5O7YCMx8dxA"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@priscilladupreez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">普里西拉·杜·普里兹</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="d978" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种基于原型的面向对象语言。这意味着JavaScript对象从原型而不是从其他类继承它们的成员。</p><p id="f161" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看JavaScript对象拥有的<code class="fe le lf lg lh b">__proto__</code>，以及我们是否应该使用它。</p><h1 id="123c" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">__proto__属性</h1><p id="6daa" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">Object.prototype</code>的<code class="fe le lf lg lh b">__proto__</code>属性是一个访问器属性。它公开了内部<code class="fe le lf lg lh b">[[Prototype]]</code>的属性，可以是一个对象或<code class="fe le lf lg lh b">null</code>。它是对象自己的原型，与<code class="fe le lf lg lh b">prototype</code>相反，T5是构造器的原型，用于构造具有<code class="fe le lf lg lh b">__proto__</code>属性的对象。</p><p id="cef2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还可以用于在创建时使用对象文字的<code class="fe le lf lg lh b">[[Prototype]]</code>，作为将原型对象传递给<code class="fe le lf lg lh b">Object.create</code>的替代方法。</p><p id="812a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以通过编写以下代码来设置对象的原型:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="495f" class="mt lj it lh b gy mu mv l mw mx">const Square = function() {};<br/>const shape = {};<br/>const square = new Square();</span><span id="a2fa" class="mt lj it lh b gy my mv l mw mx">shape.__proto__ = square;</span></pre><p id="ee2f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以设置<code class="fe le lf lg lh b">shape</code>对象文字的原型。</p><p id="2de0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">__proto__</code>之前ES6以神秘的方式工作。在ES6之前，没有标准的方法来改变现有对象的原型，但是我们可以用<code class="fe le lf lg lh b">Object.create</code>用给定的原型创建一个新对象。</p><p id="0ad2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3b33" class="mt lj it lh b gy mu mv l mw mx">const Square = function() {};<br/>const square = new Square();<br/>const shape = Object.create(square);</span></pre><p id="2381" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后Firefox让我们用非标准的<code class="fe le lf lg lh b">__proto__</code>属性改变现有对象的原型。</p><p id="7cbd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用它来改变对象的原型，就像我们在上面的代码中所做的那样。</p><h1 id="78cb" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">通过<code class="fe le lf lg lh b">__proto__ Before ES6</code>子类化<code class="fe le lf lg lh b">Array</code></h1><p id="41ad" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在ES6之前，无法在JavaScript中对内置对象进行子类化。例如，要在ES6之前子类化<code class="fe le lf lg lh b">Array</code>对象，我们必须编写一个函数来返回我们的子类的实例。通过直接设置<code class="fe le lf lg lh b">__proto__</code>属性来创建<code class="fe le lf lg lh b">Array</code>子类的实例，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="2039" class="mt lj it lh b gy mu mv l mw mx">function CustomArray() {<br/>  var instance = new Array();<br/>  instance.__proto__ = CustomArray.prototype;<br/>  return instance;<br/>}</span><span id="9d09" class="mt lj it lh b gy my mv l mw mx">CustomArray.prototype = Object.create(Array.prototype);<br/>CustomArray.prototype.foo = function() {};</span></pre><p id="88d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">构造函数<code class="fe le lf lg lh b">CustomArray</code>在将其<code class="fe le lf lg lh b">__proto__</code>属性设置为<code class="fe le lf lg lh b">CustomArray</code>的<code class="fe le lf lg lh b">prototype</code>后，显式返回<code class="fe le lf lg lh b">instance</code>，该<code class="fe le lf lg lh b">CustomArray</code>具有构造函数的成员。</p><p id="1bcb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样做的问题是，它把对象级和元级混在了一起。<code class="fe le lf lg lh b">__proto__</code>应该是一个元级属性，但是我们将<code class="fe le lf lg lh b">CustomArray</code>的<code class="fe le lf lg lh b">prototype</code>直接设置为它，就好像它是一个对象的常规属性一样。</p><p id="aea0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很容易意外地将<code class="fe le lf lg lh b">__proto__</code>用作对象级属性。</p><p id="8830" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了ES6，这就容易多了:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="582d" class="mt lj it lh b gy mu mv l mw mx">class CustomArray extends Array {<br/>  foo() {}<br/>}</span></pre><p id="05de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用类语法创建像<code class="fe le lf lg lh b">Array</code>这样的内置对象的子类没有问题。</p><h1 id="3612" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><code class="fe le lf lg lh b">__proto__</code>在ECMAScript 6</h1><p id="9188" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">ES6有一个通过<code class="fe le lf lg lh b">Object.prototype.__proto__</code>实现的get和setter。此外，在对象文字中，我们可以将<code class="fe le lf lg lh b">__proto__</code>属性键视为一个特殊的操作符，用于指定所创建对象的原型。</p><p id="2852" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在ES6中，我们可以用object literal中的值来设置<code class="fe le lf lg lh b">__proto__</code>属性，从而设置它的原型的值。</p><p id="efa6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4a52" class="mt lj it lh b gy mu mv l mw mx">const obj = {<br/>  __proto__: {<br/>    a: 1<br/>  }<br/>};</span></pre><p id="22d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后当我们跑的时候:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6568" class="mt lj it lh b gy mu mv l mw mx">Object.getPrototypeOf(obj)</span></pre><p id="cd68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们就得到<code class="fe le lf lg lh b">{ a: 1 }</code>作为<code class="fe le lf lg lh b">obj</code>的原型。</p><p id="3b65" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以将属性名写成字符串。以下代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c2e5" class="mt lj it lh b gy mu mv l mw mx">const obj = {<br/>  '__proto__': {<br/>    a: 1<br/>  }<br/>};</span></pre><p id="630f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与上例中的<code class="fe le lf lg lh b">obj</code>相同。</p><p id="a312" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将字符串<code class="fe le lf lg lh b">'__proto__'</code>放入计算的属性不会改变原型。相反，它创建自己的属性。</p><p id="b6bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9a0f" class="mt lj it lh b gy mu mv l mw mx">const obj = {<br/>  ['__proto__']: {<br/>    a: 1<br/>  }<br/>};</span></pre><p id="3847" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，如果我们记录<code class="fe le lf lg lh b">Object.getPrototypeOf(obj)</code>的返回值，那么我们会看到<code class="fe le lf lg lh b">Object.prototype</code>被记录。</p><p id="375c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们不想意外地设置一个对象文字的原型，我们可以使用<code class="fe le lf lg lh b">Object.defineProperty</code>或者将字符串<code class="fe le lf lg lh b">'__proto__'</code>放在一个计算属性中，那么在ES6下，它将被视为一个普通的对象属性。</p><p id="c65b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="60cb" class="mt lj it lh b gy mu mv l mw mx">const obj = {};<br/>Object.defineProperty(obj, '__proto__', {<br/>  a: 1<br/>})</span></pre><p id="668b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让JavaScript解释器将<code class="fe le lf lg lh b">__proto__</code>视为普通属性。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/7f2ccdccde8702fe6cb0888907051d21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*spXytHwnMssaKrAM"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">罗伯特·库伦尼在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="f793" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">检测对ES6风格的支持<code class="fe le lf lg lh b">__proto__</code></h1><p id="817a" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以使用下面的<code class="fe le lf lg lh b">hasOwnProperty</code>方法来检查<code class="fe le lf lg lh b">__proto__</code>属性是否存在:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="a4f7" class="mt lj it lh b gy mu mv l mw mx">({}).hasOwnProperty.call(Object.prototype, '__proto__');</span></pre><p id="a9d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码检查<code class="fe le lf lg lh b">__proto__</code>属性是否作为非继承属性存在于<code class="fe le lf lg lh b">Object.prototype</code>中。</p><p id="907d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以通过查看将对象文字的<code class="fe le lf lg lh b">__proto__</code>设置为<code class="fe le lf lg lh b">null</code>是否会生成对象文字的原型<code class="fe le lf lg lh b">null</code>来检查<code class="fe le lf lg lh b">__proto__</code>的存在，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c707" class="mt lj it lh b gy mu mv l mw mx">Object.getPrototypeOf({__proto__:<!-- --> <!-- -->null})<!-- --> <!-- -->===<!-- --> <!-- -->null</span></pre><h1 id="5d5a" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="1229" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">__proto__</code>属性是一个特殊的属性，它具有对象实例或文字属性的原型。</p><p id="68ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它在ES6中是标准化的。然而，我们不应该用它来设置对象的原型。相反，我们应该使用类或<code class="fe le lf lg lh b">Object.create</code>来创建带有对象原型的对象。</p></div></div>    
</body>
</html>