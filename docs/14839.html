<html>
<head>
<title>Am I Overreacting? Or is React Over-Reacting?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我反应过度了吗？还是React反应过度了？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/am-i-overreacting-or-is-react-over-reacting-d3e7d0cb4d37?source=collection_archive---------1-----------------------#2022-12-28">https://levelup.gitconnected.com/am-i-overreacting-or-is-react-over-reacting-d3e7d0cb4d37?source=collection_archive---------1-----------------------#2022-12-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/56eaa711b6ba410ab0b1eff0b395e8fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oq11KE9qUSdyIuTDo23O_A.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">一个真正的图书馆</figcaption></figure><p id="ab4b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="ld">原载于</em><a class="ae le" href="https://devtails.xyz/@adam/am-i-overreacting-or-is-react-over-reacting" rel="noopener ugc nofollow" target="_blank"><em class="ld">https://devtails . XYZ</em></a><em class="ld">。</em></p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="4ca8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> <em class="ld">编辑2023年1月4日</em> </strong></p><p id="4d11" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="ld">不出所料，这个具体的例子引起了很多关注。虽然有些批评是有根据的，但这篇文章的重点并不是所展示的具体行为。相反，它是关于演示具有大量元素的单个React渲染的开销，并显示您需要添加多少额外的层来撤消React提供的自动渲染。如果我能想出一个更好的例子，我可能会做后续工作。</em></p><p id="6ce5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这篇文章的代码可以在这里找到<a class="ae le" href="https://github.com/adamjberg/react-overreact" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="3d26" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当我第一次开始做web开发时，主要是用Python/Django。一切都是服务器端渲染的，我从来没有想过“渲染性能”。10年后，随着计算机速度至少提高一倍，渲染性能现在比以往任何时候都更成问题。像React这样的单页应用程序和前端库鼓励并支持高度动态的网页。不幸的是，根据我的经验，默认推荐的React代码编写方式实际上并不能很好地支持高度动态的页面。</p><p id="25b1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这篇文章中，我将探索标准React代码带来的问题，改进React性能的推荐选项，最后用vanilla JS中的例子来反驳这些问题。</p><h2 id="5e62" class="lm ln it bd lo lp lq dn lr ls lt dp lu kq lv lw lx ku ly lz ma ky mb mc md me bi translated">我们正在建造的东西</h2><p id="9f4e" class="pw-post-body-paragraph kf kg it kh b ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky mj la lb lc im bi translated">想出一个简洁的例子是困难的，因为真实项目的复杂性更好地展示了所有事情是如何结合在一起的。这篇文章将介绍一个基本的“动态”例子，突出React在状态频繁变化时的表现。这个例子是500个文本div，当鼠标悬停在其中一个元素上时，它们的背景颜色会更新。在每一组修改之后，我会包含概要分析器的源代码和截图，以显示React在渲染上花费了多少时间。</p><h2 id="7ccd" class="lm ln it bd lo lp lq dn lr ls lt dp lu kq lv lw lx ku ly lz ma ky mb mc md me bi translated">使用创建React应用程序初始化项目</h2><p id="c444" class="pw-post-body-paragraph kf kg it kh b ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky mj la lb lc im bi translated">此代码的初始基础来自create-react-app typescript模板。我只修改了示例中的<code class="fe mk ml mm mn b">App.tsx</code>文件，以便更容易一次看到所有的变化。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="5078" class="lm ln it mn b gy mw mx l my mz">npx create-react-app react-overreact --template typescript</span></pre><h2 id="9429" class="lm ln it bd lo lp lq dn lr ls lt dp lu kq lv lw lx ku ly lz ma ky mb mc md me bi translated">简单反应溶液</h2><p id="cb4e" class="pw-post-body-paragraph kf kg it kh b ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky mj la lb lc im bi translated">在第一个例子中，我们将捕获当前悬停的元素作为状态，并使用它来更新元素的背景颜色。在你举起你的干草叉说这可以简单地用CSS <code class="fe mk ml mm mn b">:hover</code>完成之前，想象一下这个悬停状态是其他事情所需要的，我们只是使用<code class="fe mk ml mm mn b">backgroundColor</code>属性作为一种可视化状态变化的方式。</p><p id="de52" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请参见下面的代码。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="cc59" class="lm ln it mn b gy mw mx l my mz">// App.tsx<br/>import React, { useState } from "react";<br/>import "./App.css";<br/><br/>function App() {<br/>  const [hoveredElementId, setHoveredElementId] = useState("");<br/><br/>  const elements = [];<br/><br/>  for (let i = 0; i &lt; 500; i++) {<br/>    const elementId = String(i);<br/>    const isHovered = hoveredElementId === elementId;<br/><br/>    elements.push(<br/>      &lt;div <br/>        key={i}<br/>        style={ { marginBottom: 8, backgroundColor: isHovered ? "#eee" : "" } }<br/>        onMouseEnter={() =&gt; {<br/>          setHoveredElementId(elementId);<br/>        }}<br/>        onMouseLeave={()=&gt; {<br/>          if (elementId == hoveredElementId) {<br/>            setHoveredElementId("");<br/>          }<br/>        }}<br/>      &gt;<br/>        div<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/><br/>  return &lt;&gt;{elements}&lt;/&gt;;<br/>}<br/><br/>export default App;</span></pre><h2 id="6e5d" class="lm ln it bd lo lp lq dn lr ls lt dp lu kq lv lw lx ku ly lz ma ky mb mc md me bi translated">仿形铣床</h2><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/e50f1797017a166c0d4d4dfc5dac00e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kAG6CT30NXY2TBBW.png"/></div></div></figure><p id="c839" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在M1 Macbook Pro <strong class="kh iu">上，单个渲染时钟在3毫秒到9毫秒之间。</strong>你还可以看到，每当一个新元素被悬停时，一个新的渲染被触发。如果你认为10毫秒以下听起来很快，请记住，M1芯片是目前最快的单线程执行CPU之一。很容易想象会有比这至少慢两倍的旧设备。这也是所有最简单的文本元素。即使只是重复元素中的几个元素也会增加几毫秒的渲染时间。</p><p id="0966" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我承认使用开发构建会有“一些”开销，但是我不认为打开生产模式会对这个例子有实质性的影响。</p><p id="e8bc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">更新:</strong></p><p id="5563" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我尝试了几种不同的方法在生产中进行分析，但是每种方法都得出了相同的结论。与我在本文结尾的最后一个例子相比，最公平的比较是一个完整的生产版本(<code class="fe mk ml mm mn b">yarn build</code>)和Chrome Performance标签。</p><h2 id="e0e8" class="lm ln it bd lo lp lq dn lr ls lt dp lu kq lv lw lx ku ly lz ma ky mb mc md me bi translated">Chrome性能标签</h2><p id="24c1" class="pw-post-body-paragraph kf kg it kh b ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky mj la lb lc im bi translated">下面你可以看到没有任何额外React开发开销的数字看起来与React开发工具显示的非常相似。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/7c2ac1e88cff71b572157223343d8358.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bLM90ZxGBCwAJG1s.png"/></div></div></figure><p id="40ee" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我来自一个游戏开发背景，在那里你根深蒂固地认为，为了保持每秒60帧，你的帧需要在16毫秒内完成所有处理。仅仅用了500个元素，我就已经用React接近这个门槛了。一旦一帧超过16毫秒，停顿变得明显，并导致排队，导致可怕的用户体验。</p><h2 id="8a6c" class="lm ln it bd lo lp lq dn lr ls lt dp lu kq lv lw lx ku ly lz ma ky mb mc md me bi translated">优化React的性能</h2><p id="cb7f" class="pw-post-body-paragraph kf kg it kh b ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky mj la lb lc im bi translated">在React的<a class="ae le" href="https://reactjs.org/docs/optimizing-performance.html" rel="noopener ugc nofollow" target="_blank">优化性能页面</a>上，他们声称“对于许多应用程序来说，使用React将导致快速的用户界面，而无需做太多工作来专门优化性能。”在我看来，这应该重新措辞为“大多数应用不会有足够的元素来担心React的默认过度渲染”。</p><p id="9d9a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个列表中的第一个建议是<a class="ae le" href="https://reactjs.org/docs/optimizing-performance.html#virtualize-long-lists" rel="noopener ugc nofollow" target="_blank">虚拟化长列表</a>。根据他们的文档:“如果您的应用程序呈现很长的数据列表(数百或数千行)，我们建议使用一种称为“窗口”的技术”。这在无限列表的领域中是有意义的，但是在100多个元素中，这是一个不必要的复杂问题。在我撰写本文的真实示例中，有高度嵌套的组件，这意味着有时单个元素非常简单，而有时单个元素可能有几个其他组件。使用这种方法设置窗口需要计算每个元素的动态高度，这可能会导致比一开始就显示所有元素更差的性能。</p><p id="379d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">下一个例子建议<a class="ae le" href="https://reactjs.org/docs/optimizing-performance.html#avoid-reconciliation" rel="noopener ugc nofollow" target="_blank">避免和解</a>。本质上是建议更新组件，这样如果道具没有改变，组件就不会重新渲染。当我第一次了解到这一点时，我不得不重复一遍。我认为React的整个要点是，如果道具没有改变，那么组件中就没有工作要做。但结果是<strong class="kh iu">反应只是盲目地重新渲染整个子树，如果一个父节点的属性改变的话。</strong></p><p id="56f7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">还记得建议这一点的有用页面吗？实际上，没有一个告诉你如何用功能组件做到这一点。react网站上唯一一个致力于性能优化的页面并没有给出任何关于如何使用钩子进行优化的信息(这是现在推荐的React使用方式)。相反，关于钩子优化的细节隐藏在<a class="ae le" href="https://reactjs.org/docs/hooks-faq.html#performance-optimizations" rel="noopener ugc nofollow" target="_blank">钩子常见问题</a>中，一旦发现就太晚了。</p><h2 id="9de3" class="lm ln it bd lo lp lq dn lr ls lt dp lu kq lv lw lx ku ly lz ma ky mb mc md me bi translated">避免与React.memo协调(或不协调)</h2><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="c8cd" class="lm ln it mn b gy mw mx l my mz">import React, { useState } from "react";<br/>import "./App.css";<br/><br/>type ElementProps = {<br/>  id: string;<br/>  hoveredElementId: string;<br/>  onMouseEnter: (id: string) =&gt; void;<br/>  onMouseLeave: (id: string) =&gt; void;<br/>};<br/><br/>function Div(props: ElementProps) {<br/>  const isHovered = props.hoveredElementId === props.id;<br/><br/>  return (<br/>    &lt;div<br/>      style={ { marginBottom: 8, backgroundColor: isHovered ? "#eee" : "" } }<br/>      onMouseEnter={() =&gt; {<br/>        props.onMouseEnter(props.id);<br/>      }}<br/>      onMouseLeave={() =&gt; {<br/>        props.onMouseLeave(props.id);<br/>      }}<br/>    &gt;<br/>      div<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>function App() {<br/>  const [hoveredElementId, setHoveredElementId] = useState("");<br/><br/>  const handleMouseEnter = (id: string) =&gt; {<br/>    setHoveredElementId(id);<br/>  };<br/><br/>  const handleMouseLeave = (id: string) =&gt; {<br/>    if (id == hoveredElementId) {<br/>      setHoveredElementId("");<br/>    }<br/>  };<br/><br/>  const elements = [];<br/><br/>  for (let i = 0; i &lt; 500; i++) {<br/>    elements.push(<br/>      &lt;Div<br/>        key={i}<br/>        id={String(i)}<br/>        hoveredElementId={hoveredElementId}<br/>        onMouseEnter={handleMouseEnter}<br/>        onMouseLeave={handleMouseLeave}<br/>      /&gt;<br/>    );<br/>  }<br/><br/>  return &lt;&gt;{elements}&lt;/&gt;;<br/>}<br/><br/>export default App;</span></pre><p id="2d34" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">首先，我们将内部元素放入它自己的React组件中，以便从防止重新渲染的能力中受益。从功能上讲，这应该与我们开始的第一个代码块非常相似。分析器显示我们现在在4毫秒到16毫秒之间。最后一个数字应该看起来很熟悉…我们已经从引入一个React组件来包装我们的基本div开始接近60fps了(您可以发挥想象力来想象当内部组件有多个自己的子组件时会发生什么)。</p><h2 id="b314" class="lm ln it bd lo lp lq dn lr ls lt dp lu kq lv lw lx ku ly lz ma ky mb mc md me bi translated">仿形铣床</h2><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/d27027c7e2f360decad0a2983adbc1b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jjba3UjXZfDjnJXo.png"/></div></div></figure><p id="b0fd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">每当悬停的元素id改变时，<strong class="kh iu">上面的代码仍然触发完全渲染。</strong>这是因为我们将<code class="fe mk ml mm mn b">hoveredElementId</code>传递给元素，因此每次悬停的元素改变时，每个孩子的道具都会改变，从而触发所有内容的完全重新渲染。</p><h2 id="993f" class="lm ln it bd lo lp lq dn lr ls lt dp lu kq lv lw lx ku ly lz ma ky mb mc md me bi translated">使用<code class="fe mk ml mm mn b">React.memo</code>和<code class="fe mk ml mm mn b">propsAreEqual</code>回调</h2><p id="9a80" class="pw-post-body-paragraph kf kg it kh b ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky mj la lb lc im bi translated">如果<code class="fe mk ml mm mn b">hoveredElementId</code>是当前元素(在这种情况下，我们需要更新backgroundColor)，或者前一个<code class="fe mk ml mm mn b">hoveredElementId</code>与当前元素匹配(在这种情况下，我们需要移除backgroundColor样式)，则元素只需要重新呈现。</p><p id="6c9d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在下面的代码中，我们检查<code class="fe mk ml mm mn b">prevProps.hoveredElementId</code>或<code class="fe mk ml mm mn b">nextProps.hoveredElementId</code>是否匹配我们的元素的id。如果是，我们返回<code class="fe mk ml mm mn b">false</code>来指示组件应该被重新渲染。我们还需要确保对其他属性的更改会触发重新渲染，因此我们要确保使用lodash的<code class="fe mk ml mm mn b">isEqual</code>对其余属性执行相等检查。默认情况下，React.memo进行浅层比较，但据我所知，它们实际上并没有公开一个方便的函数供您用来进行自己的浅层比较。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="fac7" class="lm ln it mn b gy mw mx l my mz">import _ from "lodash";<br/>import React, { useState } from "react";<br/>import "./App.css";<br/><br/>type ElementProps = {<br/>  id: string;<br/>  hoveredElementId: string;<br/>  onMouseEnter: (id: string) =&gt; void;<br/>  onMouseLeave: (id: string) =&gt; void;<br/>};<br/><br/>function Element(props: ElementProps) {<br/>  const isHovered = props.hoveredElementId === props.id;<br/><br/>  return (<br/>    &lt;div<br/>      style={ { marginBottom: 8, backgroundColor: isHovered ? "#eee" : "" } }<br/>      onMouseEnter={() =&gt; {<br/>        props.onMouseEnter(props.id);<br/>      }}<br/>      onMouseLeave={() =&gt; {<br/>        props.onMouseLeave(props.id);<br/>      }}<br/>    &gt;<br/>      div<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>const MemoedElement = React.memo(Element, (prevProps, nextProps) =&gt; {<br/>  const { hoveredElementId: oldHoveredElementId, ...oldProps } = prevProps;<br/>  const { hoveredElementId: newHoveredElementId, ...newProps } = nextProps;<br/><br/>  if (oldHoveredElementId === nextProps.id) {<br/>    return false;<br/>  }<br/>  if (newHoveredElementId === nextProps.id) {<br/>    return false;<br/>  }<br/>  return _.isEqual(oldProps, newProps);<br/>});<br/><br/>function App() {<br/>  const [hoveredElementId, setHoveredElementId] = useState("");<br/><br/>  const handleMouseEnter = (id: string) =&gt; {<br/>    setHoveredElementId(id);<br/>  };<br/><br/>  const handleMouseLeave = (id: string) =&gt; {<br/>    if (id === hoveredElementId) {<br/>      setHoveredElementId("");<br/>    }<br/>  };<br/><br/>  const elements = [];<br/><br/>  for (let i = 0; i &lt; 500; i++) {<br/>    elements.push(<br/>      &lt;MemoedElement<br/>        key={i}<br/>        id={String(i)}<br/>        hoveredElementId={hoveredElementId}<br/>        onMouseEnter={handleMouseEnter}<br/>        onMouseLeave={handleMouseLeave}<br/>      /&gt;<br/>    );<br/>  }<br/><br/>  return &lt;&gt;{elements}&lt;/&gt;;<br/>}<br/><br/>export default App;</span></pre><h2 id="5571" class="lm ln it bd lo lp lq dn lr ls lt dp lu kq lv lw lx ku ly lz ma ky mb mc md me bi translated">仿形铣床</h2><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/e1b49274d770faf8632d5db378f90303.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oauQ1aphn6DpnZ_0.png"/></div></div></figure><p id="a3b4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">不幸的是，第一次尝试失败了。其原因非常不明显。当<code class="fe mk ml mm mn b">hoveredElementId</code>状态改变时，它触发<code class="fe mk ml mm mn b">App</code>组件的重新渲染。在每次渲染时，<code class="fe mk ml mm mn b">handleMouseEnter</code>和<code class="fe mk ml mm mn b">handleMouseLeave</code>回调被重新定义。这意味着当它们被传递回<code class="fe mk ml mm mn b">MemoedElement</code>时，它们不再是同一个引用，这导致<code class="fe mk ml mm mn b">MemoedElement</code>再次完全重新呈现自身。</p><p id="b3fb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我已经做了学习React内部如何工作的工作，但是必须向初级开发人员解释这超出了一个应该简化这类事情的库所需要的。</p><h2 id="2c04" class="lm ln it bd lo lp lq dn lr ls lt dp lu kq lv lw lx ku ly lz ma ky mb mc md me bi translated">使用回调来防止回调触发不必要的呈现</h2><p id="d9da" class="pw-post-body-paragraph kf kg it kh b ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky mj la lb lc im bi translated">钩子常见问题解答的另一个问题是<a class="ae le" href="https://reactjs.org/docs/hooks-faq.html#are-hooks-slow-because-of-creating-functions-in-render" rel="noopener ugc nofollow" target="_blank">“钩子慢是因为在render中创建函数吗”</a>。</p><blockquote class="nb nc nd"><p id="51de" class="kf kg ld kh b ki kj kk kl km kn ko kp ne kr ks kt nf kv kw kx ng kz la lb lc im bi translated">传统上，React中内联函数的性能问题与在每次渲染时传递新回调如何破坏子组件中的shouldComponentUpdate优化有关</p></blockquote><p id="24b1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里React承认了这样一个事实，即功能组件中的回调在默认情况下是中断的。在下面的代码中，我更新了我的回调函数，用神奇的<code class="fe mk ml mm mn b">useCallback</code>来包装。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="5dfa" class="lm ln it mn b gy mw mx l my mz">import _ from "lodash";<br/>import React, { useCallback, useState } from "react";<br/>import "./App.css";<br/><br/>type ElementProps = {<br/>  id: string;<br/>  hoveredElementId: string;<br/>  onMouseEnter: (id: string) =&gt; void;<br/>  onMouseLeave: (id: string) =&gt; void;<br/>};<br/><br/>function Element(props: ElementProps) {<br/>  const isHovered = props.hoveredElementId === props.id;<br/><br/>  return (<br/>    &lt;div<br/>      style={ { marginBottom: 8, backgroundColor: isHovered ? "#eee" : "" } }<br/>      onMouseEnter={() =&gt; {<br/>        props.onMouseEnter(props.id);<br/>      }}<br/>      onMouseLeave={() =&gt; {<br/>        props.onMouseLeave(props.id);<br/>      }}<br/>    &gt;<br/>      div<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>const MemoedElement = React.memo(Element, (prevProps, nextProps) =&gt; {<br/>  const { hoveredElementId: oldHoveredElementId, ...oldProps } = prevProps;<br/>  const { hoveredElementId: newHoveredElementId, ...newProps } = nextProps;<br/><br/>  if (oldHoveredElementId === nextProps.id) {<br/>    return false;<br/>  }<br/>  if (newHoveredElementId === nextProps.id) {<br/>    return false;<br/>  }<br/>  return _.isEqual(oldProps, newProps);<br/>});<br/><br/>function App() {<br/>  const [hoveredElementId, setHoveredElementId] = useState("");<br/><br/>  const handleMouseEnter = useCallback((id: string) =&gt; {<br/>    setHoveredElementId(id);<br/>  }, [setHoveredElementId]);<br/><br/>  const handleMouseLeave = useCallback((id: string) =&gt; {<br/>    if (id === hoveredElementId) {<br/>      setHoveredElementId("");<br/>    }<br/>  }, [setHoveredElementId]);<br/><br/>  const elements = [];<br/><br/>  for (let i = 0; i &lt; 500; i++) {<br/>    elements.push(<br/>      &lt;MemoedElement<br/>        key={i}<br/>        id={String(i)}<br/>        hoveredElementId={hoveredElementId}<br/>        onMouseEnter={handleMouseEnter}<br/>        onMouseLeave={handleMouseLeave}<br/>      /&gt;<br/>    );<br/>  }<br/><br/>  return &lt;&gt;{elements}&lt;/&gt;;<br/>}<br/><br/>export default App;</span></pre><h2 id="2170" class="lm ln it bd lo lp lq dn lr ls lt dp lu kq lv lw lx ku ly lz ma ky mb mc md me bi translated">仿形铣床</h2><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/6eb1052c9a552153ace1c383297a4727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9VzwQhM5InlqPBm5.png"/></div></div></figure><p id="789c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您可以在profiler截图中看到，这已经成功地实现了在每次悬停时不重新渲染每个组件的目标。</p><p id="9184" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了实现这一点，任何存在的回调都必须包装在这个<code class="fe mk ml mm mn b">useCallback</code>中。不要错过依赖数组中的一些东西，否则你会发现自己有一些奇怪的行为。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="5fd6" class="lm ln it mn b gy mw mx l my mz">const handleMouseEnter = useCallback((id: string) =&gt; {<br/>  setHoveredElementId(id);<br/>}, [setHoveredElementId]);</span></pre><p id="cdd2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在编程中，人们常说“过早优化是万恶之源”。这通常是正确的，建议的方法是，仅当问题区域本身成为问题时，才描述并明确地针对问题区域。</p><p id="b752" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这也适用于编写React代码，但是React中事后优化的过程是不愉快的。当您知道性能是个问题时，您已经有了几个不同的组件，它们都需要单独记忆。一旦你做到了这一点，你需要找出所有回调给你带来痛苦的例子。</p><p id="ee87" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最终的代码仍然是合理的(如果你知道这些模式和问题的话)，但是依赖数组和arePropsEqual的微妙之处很容易引入新的问题。添加“只需再做一件事”，可以很容易地打破记忆，让你回到糟糕表现的起点。</p><p id="5272" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">FAQ接下来建议<code class="fe mk ml mm mn b"><a class="ae le" href="https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down" rel="noopener ugc nofollow" target="_blank">useReducer</a></code> <a class="ae le" href="https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down" rel="noopener ugc nofollow" target="_blank">避免在多个组件之间传递回调</a>。在本文中，我不会详细介绍它是什么样子的(尽管您可能会在将来看到一个这样的例子)。</p><h2 id="96c3" class="lm ln it bd lo lp lq dn lr ls lt dp lu kq lv lw lx ku ly lz ma ky mb mc md me bi translated">我们需要做出反应吗？</h2><p id="12f3" class="pw-post-body-paragraph kf kg it kh b ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky mj la lb lc im bi translated">在这篇文章中，我介绍了至少3个独立的主要React概念(<code class="fe mk ml mm mn b">React.memo</code>、<code class="fe mk ml mm mn b">arePropsEqual</code>和<code class="fe mk ml mm mn b">useCallback</code>)，以便获得可以说是默认行为的性能(坦率地说，对于500个元素来说，1毫秒仍然相当尴尬)。我长期以来一直质疑React实际上给了我什么好处，我在性能领域经历的这些挫折令人极其失望。</p><p id="4519" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在以后的文章中，我想探索和分享一些我为了摆脱React而做的实验。但是作为一个引子，下面是用普通的旧JavaScript编写的类似例子的代码。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="9e78" class="lm ln it mn b gy mw mx l my mz">const root = document.createElement("div");<br/>document.body.appendChild(root);<br/><br/>for (let i = 0; i &lt; 500; i++) {<br/>  const element = document.createElement('div');<br/>  element.style.marginBottom = "8px";<br/>  element.innerText = "div";<br/><br/>  element.addEventListener("mouseenter", () =&gt; {<br/>    element.style.backgroundColor = "#eee"<br/>  });<br/><br/>  element.addEventListener("mouseleave", () =&gt; {<br/>    element.style.backgroundColor = ""<br/>  });<br/>  <br/>  root.appendChild(element);<br/>}</span></pre><h2 id="1e37" class="lm ln it bd lo lp lq dn lr ls lt dp lu kq lv lw lx ku ly lz ma ky mb mc md me bi translated">仿形铣床</h2><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/a881b03e50786a8b214f28e649a7e0c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eZy1sR-kkN0Pnl-r.png"/></div></div></figure><p id="f117" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">React Profiler不能再用了，但是Chrome Performance标签显示最差的帧是2ms的脚本。其他的都是0毫秒。</p><h2 id="ca24" class="lm ln it bd lo lp lq dn lr ls lt dp lu kq lv lw lx ku ly lz ma ky mb mc md me bi translated">结论</h2><p id="4778" class="pw-post-body-paragraph kf kg it kh b ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky mj la lb lc im bi translated">React的支持者会声称这是一种不公平的表现，React的好处会随着你的项目变大而显现。到时候，我会分享如何使用上面介绍的简单代码来毫无问题地维持大型项目。</p><p id="5895" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您不必学习React复杂的组件生命周期工作方式，而是可以学习自己管理它。在过去的几个月里，我一直在自己的项目中这样做，我不认为我会回头。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="cc06" class="nh ln it bd lo ni nj nk lr nl nm nn lu no np nq lx nr ns nt ma nu nv nw md nx bi translated">分级编码</h1><p id="6a10" class="pw-post-body-paragraph kf kg it kh b ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky mj la lb lc im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="73d4" class="ny nz it kh b ki kj km kn kq oa ku ob ky oc lc od oe of og bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="fd80" class="ny nz it kh b ki oh km oi kq oj ku ok ky ol lc od oe of og bi translated">📰查看<a class="ae le" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>中的更多内容</li><li id="fa24" class="ny nz it kh b ki oh km oi kq oj ku ok ky ol lc od oe of og bi translated">🔔关注我们:<a class="ae le" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae le" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae le" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="23a3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">🚀👉<a class="ae le" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kh iu">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>