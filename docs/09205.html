<html>
<head>
<title>Quantum Computing Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">量子计算解释了</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/quantum-computing-explained-a212a4f30ac1?source=collection_archive---------3-----------------------#2021-07-15">https://levelup.gitconnected.com/quantum-computing-explained-a212a4f30ac1?source=collection_archive---------3-----------------------#2021-07-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cd23" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么量子计算机可以更快地解决(某些)问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2a8e5fd06caf36e18fcead7091016df7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B1EeifKec04jGCwuwOjE6w.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">IBM的量子计算机</figcaption></figure><p id="4564" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我应该首先披露我是量子计算机专家，而不是T2。我是一名计算机科学家，对我所在领域的下一场大革命充满好奇。我也碰巧对理论物理有终生的兴趣。我开始研究质量控制的基础不久，我一直在努力理解为什么量子计算机能够比我们目前最先进的计算机更快地解决一些问题。我想与我的读者分享我的见解。</p><h1 id="d8f1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">量子力学的一些规则</h1><p id="8226" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">把量子计算机想象成一个装有某种电路的盒子。我们准备一个处于特定状态的量子系统，把它放在盒子里，让它在电路中搅动。当它在盒子里时，我们不能观察它。当我们需要关于系统的信息时，我们执行<strong class="kx ir">测量</strong>。这涉及到选择我们想要测量的物理变量，如能量、动量、极化等。这些变量被称为<strong class="kx ir">可观测量</strong>，测量它们会产生对应于系统不同状态的几种可能结果之一。</p><p id="7a3a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是一些描述量子力学状态及其行为的定量规则:</p><ul class=""><li id="b7e5" class="mp mq iq kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated">一个特定的可观测值，比如说S，在测量时可以产生固定数量的状态，比如说<em class="lr"> n </em>。我们将这些状态表示为向量空间中的基向量。在量子力学符号中，这个基础被写成as|s₁ &gt;，|s₂ &gt;，…，|sₙ &gt;。我们可以把这些看作是正常三维空间中单位向量<strong class="kx ir"> x，y，z </strong>(或<strong class="kx ir"> i，j，k </strong>)的推广。</li><li id="57f5" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">在测量之前，系统的状态是由这些结果的线性组合形成的向量，称为<strong class="kx ir">叠加</strong>，其中<code class="fe nd ne nf ng b">ci</code>是复数:</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/eb1a4db7d8bb5e48177574ee9cd18cc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/0*RMoxkyWDr_iEUdoc"/></div></figure><ul class=""><li id="910e" class="mp mq iq kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated">|sᵢ&gt;.说，当我们测量可观测的s时，自然会选择其中一个结果除非我们以其他方式与这个系统互动，否则任何后续的相同可观测值的测量都会产生相同的状态。这种从叠加态到单一结果的转换被称为<strong class="kx ir">坍缩态。</strong></li><li id="f9d4" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">大自然是如何选择结局的？在某种程度上，它掷骰子。这个状态坍缩到|sᵢ&gt;的概率由state,|cᵢ|系数的平方模给出。注意，由于这个要求，称为<strong class="kx ir">玻恩法则</strong>，cᵢ不能是任意的，但它们必须满足以下条件:</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/398492abf05fd686bfb95c4214087d1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:236/0*zardIppjGj5_iCaR"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">平方模形成概率密度</figcaption></figure><h2 id="da2a" class="nj lt iq bd lu nk nl dn ly nm nn dp mc le no np me li nq nr mg lm ns nt mi nu bi translated">量子力学中的随机性和确定性</h2><p id="ee99" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">简要说明是为了阐明量子力学系统中确定性和随机性的界限。只要系统开始于一个已知的状态，并且它通过已知操作的应用而发展，系统的状态是完全确定的，在这个意义上，我们知道描述任意时间点的状态向量<code class="fe nd ne nf ng b">(c1, c2,.., cn)</code>的复数。随机性只有在测量的时候才表现出来，也就是说在状态坍缩的时候，选择一个可观测值。</p><h1 id="4451" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">量子位和量子门</h1><p id="ec60" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在经典计算机中，一位是最小的信息单位。它可以处于通常用0和1表示的两种状态之一。更大的信息单元可以通过将几个比特组合成一个类似<code class="fe nd ne nf ng b">01100111</code>的字符串来构建。</p><p id="03c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在量子力学中，一个比特对应的信息单位可以是0和1的叠加。因此最简单的量子力学系统是二维复向量空间。标准状态由代表向量[1，0]的|0 &gt;和代表向量[0，1]的|1 &gt;表示。系统的一般状态是一个矢量</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/80ea4e1492bd9617aaa2228a8538709e.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/0*7ZuWF9cx4N-7Tg0W"/></div></figure><p id="cbea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其中<em class="lr"> c </em>和<em class="lr"> d </em>为满足<em class="lr"> |c| + |d| = 1 </em>的复数。<em class="lr"> |c| </em>是测量时系统处于状态|0 &gt;的概率，而| <em class="lr"> d| </em>是系统处于状态|1 &gt;的概率。</p><p id="4354" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">和经典计算机一样，我们可以组合几个量子位来编码更多的信息。在这种情况下，相应的系统将是位串所有可能组合的叠加。例如，对于3量子位系统，状态的一般表达式是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/e9a5aad1a0393e4350f3a170d5d24619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/0*koo7JN5VS7br5R7m"/></div></div></figure><p id="9945" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一般来说，一个<em class="lr"> n </em>量子位的系统由一个2ⁿ.维度的向量空间来建模</p><p id="ee07" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以通过组合逻辑门来构建量子逻辑电路，就像我们构建经典电路一样。量子门与经典门有一些重要的不同:</p><ul class=""><li id="0618" class="mp mq iq kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated">每个门都必须是可逆的。例如，不允许简单的AND运算，因为0的结果不能重建原始的两位。因此，所有量子门的输出和输入一样多。</li><li id="a738" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">门应该能够作用于任何叠加态。</li><li id="e8e4" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">门线性地作用于状态。如果v和w是状态，c是复数，那么一个门G必须满足<em class="lr"> G(v+w) = G(v )+G(w) </em>和<em class="lr"> G(cv) = cG(v) </em>。换句话说，门可以表示为状态向量空间上的矩阵。</li><li id="28e5" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">门必须保持总概率加起来必须等于1的要求。换句话说，我们要求对于每个向量v，<em class="lr"> ||Gv|| = 1 </em>，使得<em class="lr"> ||v|| = 1。</em></li></ul><p id="2531" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">随着这些规则的建立，我们可以通过被称为<strong class="kx ir">酉</strong>的2ⁿ矩阵将一个<em class="lr"> n </em>量子位系统中的每个量子门表示为一种特殊的2ⁿ。当一个量子系统在状态|x &gt;“通过”一个门G时，得到的状态由矩阵乘法给出。</p><p id="c5a9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有一个广泛使用的门的例子，称为<strong class="kx ir">哈达玛门</strong>，它作用于一个1量子位系统:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/89ca408f9984e273a555044ece0eeaab.png" data-original-src="https://miro.medium.com/v2/resize:fit:348/0*C2B3Ud27CoXnFUt7"/></div></figure><p id="c403" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">哈达玛门的特性是，它采用一个标准的量子位状态，并将其转换成一个叠加态，其中每个结果都有相等的概率。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/66c42a875ce832adaac758d928894774.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/0*Wb_Dqyrds2cJcWg2"/></div></figure><p id="803b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2的平方根出现在分母中，因为概率是由振幅的平方给出的。出于同样的原因，第二个表达式中的负号是不重要的，因为它的平方也给出1/2的概率。哈达玛门可以组合起来，把几个量子位元放在一个相等重量的叠加态中。</p><p id="b118" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">量子电路中经常使用的另一种结构是<strong class="kx ir">控制的</strong>门，其中对输入量子位|x &gt;的操作是通过与控制位|y &gt;执行XOR来控制的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/47eaa106dc5a4c12e7da5136430a6c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*DS0INi4CP4FdWcSOr0pBtQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">受控门</figcaption></figure><p id="0d56" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上图中，f是一个任意函数。注意，即使函数<em class="lr"> f </em>是不可逆的——例如，它将所有内容映射到0——门<em class="lr"> Uf </em>是可逆的。事实上，这是它自己的反面。</p><h1 id="83d0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">量子算法</h1><p id="cb05" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">量子计算机的优势来自以下事实:当我们需要为每个可能的输入评估一个函数时，经典计算机必须执行与输入一样多的计算。在量子计算机中，如果我们操纵状态，使其处于所有可能输入的叠加状态，那么当我们应用函数(作为门)时，在某种意义上，状态将是函数所有可能值的叠加。</p><p id="fdfe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种“神奇”的平行评价有其局限性。函数应用后，系统处于未知状态，我们无法直接观察到。当我们测量机器的输出时，叠加态会崩溃，我们可能会丢失测量前包含的信息。更糟糕的是，一条被称为<a class="ae oa" href="https://en.wikipedia.org/wiki/No-cloning_theorem" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">不可克隆定理</strong> </a>的量子力学定律规定我们不能复制状态。如果可以的话，我们会复制多份，然后全部测量，这样就可以还原出隐藏在叠加态中的统计数据。</p><p id="8bed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">量子算法中的聪明之处在于，为了提取未知函数值之间的<em class="lr">关系</em> <strong class="kx ir"> <em class="lr"> </em> </strong>，而不是单个值本身，计算出在未知函数前后应用什么变换。</p><p id="aeb6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有一个例子。考虑一个函数，它采用两个<em class="lr"> n </em>位整数，并计算它们的逐位内积，从而返回0或1。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/c24cc5c79916678b097cf2fa30b067ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/0*liUQq2MKKyRUS2fq"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">两个数的按位内积</figcaption></figure><p id="f81a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">数字<strong class="kx ir"> <em class="lr"> s </em> </strong>是未知的，但我们可以代入<strong class="kx ir"> <em class="lr"> x </em> </strong>的各种值来试着算出来。经典计算机需要对函数进行<em class="lr"> n </em>次求值才能完全确定值<em class="lr">s。</em>然而，有一种量子算法，称为<strong class="kx ir"> Bernstein-Vazirani算法</strong>，可以在一次求值中完成。下面是一个4量子位系统的算法电路图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/3ddad066479d9d3ba9a7ef5479cba483.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CkqsZOepEvehESabpihrxw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Bernstein-Vazirani算法的量子电路——用Qiskit编码</figcaption></figure><p id="972c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第五个量子位用于携带隐藏内积的结果。内积盒本身是一个量子电路，它使用受控门技巧将所讨论的函数变成一个酉门。</p><p id="d72d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">量子位1到4在|0 &gt;状态被初始化。哈达玛门(H)用于将它们置于叠加态。它们代表上式中<strong class="kx ir"> <em class="lr"> x </em> </strong>的值。最后的M个盒子是对每个量子位的测量操作。测量每个位将迫使其进入|0 &gt;或|1 &gt;。事实证明，当最后的比特被测量时，它们将精确地包含<strong class="kx ir"> <em class="lr"> s </em> </strong>的未知值。</p><p id="ae83" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">解释该算法的工作原理超出了本简介的范围。我向感兴趣的读者推荐优秀的Qiskit文档，它提供了算法和许多其他内容的完整解释，以及实现它们的代码。</p><p id="1c51" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有一点需要澄清:代表未知函数的黑盒从何而来？<em class="lr"> s </em>的每个值对应一个略有不同的电路。这些电路可以被认为是程序中的子程序。可以说，在用户或I/O设备提供外部输入的情况下，它们是“动态”编译的。</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="1223" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[2]:例如，对于一个3位数，我们需要为x提供这些值:100，010，001</p><h1 id="7357" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">量子优势</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/445cd31e807dea6b88aedcf60eca50e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KwMXspSzJ-I6dmgtV1UZdA.jpeg"/></div></div></figure><p id="93c0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Bernstein-Vazirani算法演示了一个可以由量子计算机在单次评估中解决的问题，其中经典计算机需要执行线性数量的评估。诚然，这个问题有些做作。人们也可以认为，简单地计算函数求值不足以描述算法的整个计算复杂性。事实上，要证明量子优势——即量子计算机可以比经典计算机更有效地解决一些问题——还需要更多。</p><p id="665b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对量子计算机能力的最具戏剧性的测试之一是由Shor的算法提供的，该算法可以在多项式时间而不是指数时间内解决整数因式分解问题。这个问题不仅仅是数学上的好奇。大多数现代非对称密码系统，如RSA，都依赖于这样一个假设，即分解大整数在计算上是不可行的。给定足够的量子位和足够的稳定性，看起来量子计算机可以破解这些加密系统。有关Shor算法的详细概述和模拟，请查看<a class="ae oa" href="https://qiskit.org/textbook/ch-algorithms/shor.html" rel="noopener ugc nofollow" target="_blank"> Qiskit文档</a>。</p><p id="413f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望这份对量子计算机和算法世界的旋风般的介绍激起了读者对这个迷人的研究领域的兴趣。目前，量子优势还没有降临到我们头上，部分原因是建造稳定的量子计算机是一项艰巨的任务，但作为计算机科学家，我们应该关注量子技术的进步，因为它很可能是我们工艺的未来。</p><h1 id="6184" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">参考资料和资源</h1><ul class=""><li id="6aa7" class="mp mq iq kx b ky mk lb ml le ol li om lm on lq mu mv mw mx bi translated">Noson S. Yanofsky和Mirco A. Mannucci，<em class="lr">计算机科学家的量子计算</em>，剑桥大学出版社，2019年</li><li id="6204" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">大卫·默明，<em class="lr">量子计算机科学，</em>剑桥大学出版社，2007</li><li id="57d8" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">Scott Aaronson，<em class="lr">量子信息科学导论</em>，2018:<a class="ae oa" href="https://www.scottaaronson.com/qclec.pdf" rel="noopener ugc nofollow" target="_blank">https://www.scottaaronson.com/qclec.pdf</a></li><li id="e132" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">IBM的Quantum Composer可以用来模拟量子电路，甚至在真实的量子计算机上执行:<a class="ae oa" href="https://quantum-computing.ibm.com/composer" rel="noopener ugc nofollow" target="_blank">https://quantum-computing.ibm.com/composer</a></li><li id="ece8" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">Qiskit是一个用于构建量子电路的Python库。这些电路可以在IBM的一组门电路中传输，在量子计算机上运行:<a class="ae oa" href="https://qiskit.org/" rel="noopener ugc nofollow" target="_blank">https://qiskit.org/</a></li></ul></div></div>    
</body>
</html>