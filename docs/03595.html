<html>
<head>
<title>Implementing Classed Based Viewsets in Django REST Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Django REST框架中实现基于类的视图集</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-classed-based-viewsets-in-django-rest-framework-fd0224852f50?source=collection_archive---------9-----------------------#2020-05-18">https://levelup.gitconnected.com/implementing-classed-based-viewsets-in-django-rest-framework-fd0224852f50?source=collection_archive---------9-----------------------#2020-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="c504" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用Django Rest框架将基于函数的视图重构为基于类的视图集的简单例子。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="gh gi kv"><img src="../Images/3d5780263ed61bea45d302bc951ed027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kR89JbQQK9aAkNVyxE63pg.png"/></div></figure></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><blockquote class="ld le lf"><p id="fe7a" class="jq jr lg js b jt ju jv jw jx jy jz ka lh kc kd ke li kg kh ki lj kk kl km kn im bi translated">Django REST框架是一个用于构建Web APIs的强大而灵活的工具包。</p></blockquote><p id="4c85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这不是一个使用Django REST框架的教程，但是你可以在https://www.django-rest-framework.org/tutorial/quickstart/的<a class="ae lk" href="https://www.django-rest-framework.org/tutorial/quickstart/" rel="noopener ugc nofollow" target="_blank">上学习。</a></p><h1 id="eb3c" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">为什么要使用Django REST框架？</h1><p id="2724" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn im bi translated">Django是一个用非常详细的文档创建web应用程序的强大框架。您可以仅使用Django创建应用程序的前端和后端，但是有时在混合中加入前端框架可能是有益的。有很多流行的前端框架，包括React、Vue、Angular等等。</p><p id="ed80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了允许这些前端框架与Django提供的后端进行通信，我们需要一个API。这个API序列化数据，允许前端框架和后端之间的通信。你可以从头开始创建这些序列化器，但是Django REST框架可以用很少的代码创建序列化器。</p><h1 id="c888" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">如何创建这些API</h1><p id="8ff6" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn im bi translated">使用Django REST，我们可以用许多不同的方式创建这些API。一旦创建了序列化程序，就需要创建视图来处理前端发出的请求。我们将讨论您将会遇到的典型请求:GET、POST、PUT和DELETE。我们可以创建视图函数，以两种方式处理这些请求:</p><ol class=""><li id="6f46" class="mo mp it js b jt ju jx jy kb mq kf mr kj ms kn mt mu mv mw bi translated">使用<code class="fe mx my mz na b">@api_view</code>装饰器的基于函数的视图</li><li id="4042" class="mo mp it js b jt nb jx nc kb nd kf ne kj nf kn mt mu mv mw bi translated">基于类的视图/视图集</li></ol><h1 id="b643" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">Django休息/反应卡路里跟踪器API</h1><p id="929f" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn im bi translated">我目前正在开发一个简单的卡路里跟踪器，在REST API中使用Django-REST，在前端使用React-Redux。大部分功能都是在网站上实现的，我只是在重构，给项目添加一些小细节。下面是该应用程序的简短演示。该应用程序的代码可以在以下位置找到:</p><div class="ng nh gp gr ni nj"><a href="https://github.com/Kristian-Roopnarine/Django-React-Calorie-Tracker" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">kristian-Roopnarine/Django-React-Calorie-Tracker</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">一个Django/React-Redux应用程序，允许用户跟踪每日卡路里摄入量。…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">github.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx lb nj"/></div></div></a></div><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="7c90" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当用户填写表单、编辑食物日志或删除条目时，我们会向后端发出请求来处理这些信息。</p><p id="76b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最初，我创建了基于函数的视图来处理这些请求。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi oa"><img src="../Images/2b3c1f93a040cd18017a22871a63ba4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8FuP03ettsWzhVfLU5fiiw.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated">基于函数的API视图</figcaption></figure><p id="a18d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我编写了两个不同的视图函数，每个函数都使用条件来处理两个请求。它们都返回一个包含要在前端呈现的序列化数据的<code class="fe mx my mz na b">Response</code>对象。</p><p id="6f36" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我不记得为什么我创建了两个不同的函数来处理这些请求，但我记得基于函数的逻辑可以提取到基于类的视图集中。当您必须对数据执行特定的修改或查询时，基于函数的视图是很好的，而不是基于类的视图。</p><p id="c336" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">基于重构类的视图集看起来简单多了— </strong></p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi oj"><img src="../Images/ab60df1b738b1eab9c70ec200f18eb4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gi4PUUrX0cSSSXSoKjjvWA.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated">重构的CBV</figcaption></figure><p id="48ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们能够将跨越30多行代码的函数变成近10行代码。基于类的视图集处理所有基本的HTTP请求:GET、POST、PUT、DELETE，而不需要硬编码任何逻辑。</p><p id="2028" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您需要任何特定的功能，您可以覆盖这些方法。当我们的用户登录应用程序时，他们收到的食物日志数据应该是今天和那个用户的。要指定这一点，我只需简单地覆盖为该视图集返回queryset的方法。</p><p id="742c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个食物日志条目都与用户有一个<code class="fe mx my mz na b">ForeignKey</code>关系，这个关系在通过覆盖<code class="fe mx my mz na b">perform_create</code>方法创建条目时应用。</p><h1 id="a1b1" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">API端点呢？</h1><p id="7757" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn im bi translated">Django REST框架使得创建与这个API交互的端点变得简单！在应用程序<code class="fe mx my mz na b">urls.py</code>文件中，我们创建了一个<code class="fe mx my mz na b">DefaultRouter</code>实例，它为我们创建了端点。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi ok"><img src="../Images/f7b007e5f4916464ed5afd313b024495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*foXc0G8jWxBzDoFb0Vy-9g.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated">Django REST框架创建API端点。</figcaption></figure><p id="676f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在路由器中注册视图集，并提供一个起始正则表达式字符串来与视图集交互。Django REST将根据请求创建以下URL:</p><ul class=""><li id="fa79" class="mo mp it js b jt ju jx jy kb mq kf mr kj ms kn ol mu mv mw bi translated">获得:<code class="fe mx my mz na b">api/food-log/</code></li><li id="49ed" class="mo mp it js b jt nb jx nc kb nd kf ne kj nf kn ol mu mv mw bi translated">帖子:<code class="fe mx my mz na b">api/food-log/</code></li><li id="6129" class="mo mp it js b jt nb jx nc kb nd kf ne kj nf kn ol mu mv mw bi translated">删除:<code class="fe mx my mz na b">api/food-log/id/</code></li><li id="181b" class="mo mp it js b jt nb jx nc kb nd kf ne kj nf kn ol mu mv mw bi translated">放:<code class="fe mx my mz na b">api/food-log/id/</code></li></ul><h1 id="b2a2" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">摘要</h1><p id="aee1" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn im bi translated">当创建应用程序时，我们很容易过于专注于实现一个特性，而忽略了它在我们的程序中是如何工作的。我非常兴奋地让我的应用程序的部分工作起来，我决定单独编写这些视图函数，没有花时间去想这些请求可以一下子处理。我能够使用Django REST框架提供的基于类的视图集来补救这种情况。下次你实现一个特性的时候，仔细想想它是如何在你的程序中工作的，以防止以后不必要的重构！</p><div class="ng nh gp gr ni nj"><a href="https://github.com/Kristian-Roopnarine" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">克里斯蒂安-Roopnarine -概述</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">Kristian-Roopnarine有29个存储库。在GitHub上关注他们的代码。</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">github.com</p></div></div><div class="ns l"><div class="om l nu nv nw ns nx lb nj"/></div></div></a></div></div></div>    
</body>
</html>