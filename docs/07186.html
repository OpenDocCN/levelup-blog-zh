<html>
<head>
<title>Creating and filling a Postgres DB with Docker compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Docker compose创建和填充Postgres数据库</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-and-filling-a-postgres-db-with-docker-compose-e1607f6f882f?source=collection_archive---------0-----------------------#2021-01-30">https://levelup.gitconnected.com/creating-and-filling-a-postgres-db-with-docker-compose-e1607f6f882f?source=collection_archive---------0-----------------------#2021-01-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6dc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很多时候，我们需要用虚拟数据填充并最终共享一个数据库，要么测试我们的管道，测试查询，演示新服务的操作，要么作为一种工具对公司的未来成员进行测试。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><blockquote class="ks kt ku"><p id="a491" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">Github回购:https://github.com/jdaarevalo/docker_postgres_with_data</p></blockquote><h1 id="27fb" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak">简介</strong></h1><p id="a2af" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">在解决这一需求的各种选择中，我们可以使用或共享CSV、parquet、s3等文件，但这些文件在我们要面对的每一项挑战中都有局限性。</p><p id="a092" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个问题可以通过利用Docker提供给我们的功能来轻松解决。</p><p id="bd8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们这里的目标是用它们各自的外键创建下面的表并填充这些表，同时它们可以很容易地与其他用户共享。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/020813b1d582ced73153b1f04cdb75cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8NflH-AaNaoWI8qeETyo_Q.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">ER图</figcaption></figure><h1 id="5050" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">初始化Postgres服务</h1><p id="4227" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">我们将使用Docker Compose通过这个<em class="kv"> docker-compose.yml </em>文件管理Postgres的实例:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="a29c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以用一个简单的命令启动Postgres:</p><pre class="md me mf mg gt mu mv mw mx aw my bi"><span id="dfdd" class="mz la iq mv b gy na nb l nc nd">$ docker-compose up</span></pre><p id="dc36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者用这个命令在后台运行Postgres，增加<strong class="jp ir"> <em class="kv"> -d </em> </strong>分离模式</p><pre class="md me mf mg gt mu mv mw mx aw my bi"><span id="9bbe" class="mz la iq mv b gy na nb l nc nd">$ docker-compose up -d</span></pre><p id="0b39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并停止Postgres服务的运行</p><pre class="md me mf mg gt mu mv mw mx aw my bi"><span id="f671" class="mz la iq mv b gy na nb l nc nd">$ docker-compose down</span></pre><p id="902c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本例中，我们将本地端口<strong class="jp ir"> 5438 </strong>映射到容器内的端口<strong class="jp ir"> 5432 </strong> (Postgres默认端口)。此外，我们还会将数据保存在我们的机器中，防止在删除容器时丢失数据，为此，我们使用文件夹<code class="fe ne nf ng mv b">postgres-data</code>作为存储Postgres数据的位置来添加卷。</p><h1 id="7915" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">创建表格</h1><p id="6fbf" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">为了在我们的数据库中创建表格，我们需要将我们的<code class="fe ne nf ng mv b">create_tables.sql</code>脚本复制到<code class="fe ne nf ng mv b">/docker-entrypoint-initdb.d/</code></p><p id="d056" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该脚本包含创建所需的每个表、主键和外键的命令</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="f5cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有的源代码都在这里<a class="ae nh" href="https://github.com/jdaarevalo/docker_postgres_with_data" rel="noopener ugc nofollow" target="_blank">https://github.com/jdaarevalo/docker_postgres_with_data</a></p><h1 id="5485" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">为什么在<code class="fe ne nf ng mv b">docker-entrypoint-initdb.d/ ?</code></h1><p id="7542" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">PostgreSQL Docker官方镜像<a class="ae nh" href="https://hub.docker.com/_/postgres/" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/_/postgres/</a>允许我们将SQL文件放在<code class="fe ne nf ng mv b">/docker-entrypoint-initb.d</code>文件夹中，服务第一次启动时，它会导入并执行那些SQL文件。</p><p id="7758" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的Postgres容器中，我们将找到这个bash脚本<code class="fe ne nf ng mv b">/usr/local/bin/docker-entrypoint.sh</code>，其中每个*。嘘，**。sql和*。*sql.gz文件将被执行</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="54ad" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">用数据填充表格</h1><p id="b882" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">现在我们想使用脚本sql/filling_tables.sql来填充这些表</p><p id="de1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将变量定义为销售数量、国家数量和销售的开始日期……和结束日期，我们将使用会话变量来完成</p><blockquote class="ks kt ku"><p id="944a" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated"><em class="iq">SET&lt;会话变量&gt;语句接受两个参数:变量名和用于修改变量的值。变量名不区分大小写。</em></p><p id="9fd1" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">更多详情请点击<a class="ae nh" href="https://www.postgresql.org/docs/10/sql-set.html" rel="noopener ugc nofollow" target="_blank">https://www.postgresql.org/docs/10/sql-set.html</a></p></blockquote><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="42ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">定义变量后，继续创建SQL脚本来填充数据</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="14aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">参数current_setting获取第一部分中定义的变量，GENERATE_SERIES是一个Postgres函数，如果未定义，它会生成一系列值，从<code class="fe ne nf ng mv b">start</code>到<code class="fe ne nf ng mv b">stop</code>的值，步长为1</p><p id="80ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们填充了表country、city、store、users、product、status_name。对于order_status和sale表，我们需要几个Postgres函数或额外的逻辑步骤</p><p id="0539" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Sale ID </strong>:这里我们想要一个列<a class="ae nh" href="http://sale.id/" rel="noopener ugc nofollow" target="_blank"> sale.id </a>的UUID，幸运的是，Postgres通过UUID支持通用唯一标识符(uuid)作为列数据类型，我们将使用它来创建sale_id，为此我们在当前会话数据库/模式中加载pgcrypto扩展</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="13ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Dates </strong>:这里我们将使用PostgreSQL TO_TIMESTAMP()函数根据给定的格式将字符串转换为时间戳，另外我们将使用random()函数在创建的范围内生成随机日期</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="82a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">随机id:</strong>请注意，每笔销售都需要一个产品id、用户id和商店id。这里，我们使用函数floor来返回对随机函数生成的值进行舍入后的值</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="f8a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了填充order_status表，我们将使用sale表</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="8d3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">order_status中的更新日期是在销售日期加5天之间创建的，以防止在销售前更新订单。</p><p id="7206" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们添加所有脚本来填充脚本sql/fill_tables.sql中的表</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="8865" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在运行<code class="fe ne nf ng mv b">docker-compose up</code>之后，我们会看到类似这样的东西</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ni"><img src="../Images/00085dc2efeaa1997ee47bda81327ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z-xG3o2Xhzb_G2dBQFGt8Q.png"/></div></div></figure><p id="9ffb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，您可以生成并使用包含表和值的数据库来测试模型、管道或评估候选人的SQL、git、docker技能。</p><p id="ebd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要连接到Postgres，您可以使用类似于<strong class="jp ir"> DBeaver </strong>的数据库工具，或者从命令行运行以下命令:</p><pre class="md me mf mg gt mu mv mw mx aw my bi"><span id="5e04" class="mz la iq mv b gy na nb l nc nd">$ docker ps -f "name=postgres"<br/><br/>    -f: Filter output based on conditions provided</span></pre><p id="e8ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">获取正在运行的容器的<strong class="jp ir"> CONTAINER_ID </strong>，并执行</p><pre class="md me mf mg gt mu mv mw mx aw my bi"><span id="59a9" class="mz la iq mv b gy na nb l nc nd">$ docker exec -it &lt;CONTAINER_ID&gt; /bin/bash</span></pre><p id="de36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并像这样运行查询</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nj"><img src="../Images/f03c0e19fff20a79c589a89ac86282d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*irVDkdPTK-wTsYXUFFGctA.png"/></div></div></figure><blockquote class="ks kt ku"><p id="bbb1" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated"><strong class="jp ir"> Github回购:</strong>https://github.com/jdaarevalo/docker_postgres_with_data T21</p></blockquote><p id="8564" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请随意分享、使用或贡献给知识库。如果你有任何意见或建议，我会很感激</p><p id="e4b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问候</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><h1 id="cc9d" class="kz la iq bd lb lc nk le lf lg nl li lj lk nm lm ln lo nn lq lr ls no lu lv lw bi translated">分级编码</h1><p id="9489" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">感谢您成为我们社区的一员！升级正在改变技术招聘。<a class="ae nh" href="https://jobs.levelup.dev/talent" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">在最好的公司</strong>找到你最理想的工作 </a> <strong class="jp ir">。</strong></p><div class="np nq gp gr nr ns"><a href="https://jobs.levelup.dev/talent" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd ir gy z fp nx fr fs ny fu fw ip bi translated">提升——改变招聘流程</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">🔥让软件工程师找到他们热爱的完美角色🧠寻找人才是最痛苦的部分…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">作业. levelup.dev</p></div></div><div class="ob l"><div class="oc l od oe of ob og mm ns"/></div></div></a></div></div></div>    
</body>
</html>