<html>
<head>
<title>False Sharing — The lesser known performance killer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">虚假分享——鲜为人知的性能杀手</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/false-sharing-the-lesser-known-performance-killer-bbb6c1354f07?source=collection_archive---------10-----------------------#2021-05-14">https://levelup.gitconnected.com/false-sharing-the-lesser-known-performance-killer-bbb6c1354f07?source=collection_archive---------10-----------------------#2021-05-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="61f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我们将研究伪共享的概念，以及它如何影响应用程序的性能。我们还将探索一些相关的概念，如缓存一致性、缓存行和Java的防止错误共享的竞争注释。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="ab gu cl kq"><img src="../Images/7ce363650bfd476ca96962133e1cef48.png" data-original-src="https://miro.medium.com/v2/format:webp/1*7Sc9SbuqZw2Ia1hXHjavNw.jpeg"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">图片来源:U<a class="ae kx" href="https://images.unsplash.com/photo-1589779255718-3c459da9ffeb?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=2089&amp;q=80" rel="noopener ugc nofollow" target="_blank">n flash</a></figcaption></figure><h1 id="2c6e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是虚假分享？</h1><p id="32a7" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">让我们看看维基百科是如何定义这个概念的:</p><blockquote class="mb mc md"><p id="d17d" class="jn jo me jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">假共享</em> </strong> <em class="iq">是一种降低性能的使用模式，在具有分布式、</em> <a class="ae kx" href="https://en.wikipedia.org/wiki/Cache_coherence" rel="noopener ugc nofollow" target="_blank"> <em class="iq">一致高速缓存的系统中会出现这种情况</em> </a> <em class="iq">，其大小为由高速缓存机制管理的最小资源块。当系统参与者试图定期访问永远不会被另一方更改的数据，但这些数据与</em>被<em class="iq">更改的数据共享一个缓存块时，缓存协议可能会迫使第一个参与者重新加载整个单元，尽管缺乏逻辑必要性。高速缓存系统不知道该块内的活动，并强制第一个参与者承担真正共享访问资源所需的高速缓存系统开销。</em></p></blockquote><p id="7fd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在深入探讨虚假分享之前，让我们先看看一些相关的概念。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="c3d9" class="ky kz iq bd la lb mp ld le lf mq lh li lj mr ll lm ln ms lp lq lr mt lt lu lv bi translated">硬件缓存和缓存线</h1><p id="a78b" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们都知道从机器内存中读写是一个缓慢的过程，尽管比从硬盘中读取要快得多。为了解决这种缓慢的内存访问，当今大多数处理器都使用缓存来提高性能。</p><p id="9901" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在的机器使用多级缓存，称为L1、L2、L3和L4。L1是最快的，但也是最昂贵的，所以机器往往有低大小的L1缓存。另一方面，L2与L1相比速度较慢，但成本较低，因此机器倾向于拥有较大的L2缓存。</p><p id="86a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当从内存中读取数据时，所请求的数据及其周围的数据从内存加载到缓存中，然后从缓存中提供程序。这被称为高速缓存行。高速缓存行被正式定义为高速缓存和主存储器之间的数据传输单位。这种加载整个缓存行而不是单个字节的方式可以显著提高应用程序的性能。在我们的笔记本电脑上，L1和L2的缓存行大小都是64字节。由于应用程序经常以顺序的方式从内存中读取字节，所以它们可以通过在缓存行中加载一系列数据来避免每次请求都命中主存。这增加了所需数据已经存在于缓存中的机会。</p><p id="b4a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以通过运行以下命令sysctl -a | grep cache来检查便携式计算机的硬件缓存细节。我的系统(Macbook pro 2015)有32KB的L1缓存(L1I和L1D)，256KB的L2缓存和3MB的L3缓存</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/928c759e809ace3ec121823d5a318380.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/0*XbH5B3aHYr9h90og.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">命令:sysctl -a | grep缓存</figcaption></figure></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="7302" class="ky kz iq bd la lb mp ld le lf mq lh li lj mr ll lm ln ms lp lq lr mt lt lu lv bi translated">缓存一致性</h1><p id="87f0" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在共享内存的多处理器系统中，每个处理器都有一个单独的高速缓存，共享数据可能有多个副本:一个副本在主内存中，另一个在请求它的每个处理器的本地高速缓存中。当其中一个数据副本发生更改时，其他副本必须反映该更改。缓存一致性是一种机制，可以确保共享数据中的更改及时传播到整个系统。这确保了主存储器中的高速缓存数据与其他高速缓存中的数据同步</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/28ef8868c306eef1af05078ccc05fd60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/0*G9ydDaQp_WL-0y8p.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">src:<a class="ae kx" href="https://en.wikipedia.org/wiki/Cache_coherence#/media/File:Cache_Coherency_Generic.png" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Cache _ coherence #/media/File:Cache _ coherence _ generic . png</a></figcaption></figure><p id="8f4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> MESI协议</strong>是缓存一致性协议，也是最常见的协议之一。在MESI协议中，<strong class="jp ir">每条高速缓存线可以处于以下四种不同状态之一:已修改、独占、共享或无效。</strong></p><p id="de5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们通过一个示例来进一步了解该协议:</p><ol class=""><li id="777c" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated">两个内核内核X和内核Y试图从主内存中读取长值X和Y。让我们假设x和y彼此靠近，并且位于相同的高速缓存行中。</li><li id="4282" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">内核X从主存储器中读取X的值。如前所述，这个内核将从内存中获取更多的值，并将它们存储到缓存行中。然后，它将该高速缓存线标记为<strong class="jp ir">独占</strong>，因为核心X是在该高速缓存线上操作的唯一核心。现在，只要有可能，这个内核将从高速缓存行读取值，而不是从主存储器读取效率较低的值。</li><li id="4603" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">现在假设核心Y也决定从主存中读取Y的值。因为y和x在同一个高速缓存行中，所以两个内核都将其高速缓存行标记为<strong class="jp ir">共享</strong></li><li id="bf07" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">假设现在核心X决定修改X的值，它修改其本地缓存，并将其缓存行的状态更改为<strong class="jp ir"> modified。</strong></li><li id="c733" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">核心X将其更改传达给核心Y，核心Y会将其缓存线标记为<strong class="jp ir">无效。</strong>这样，核心X和Y都是一致的。</li></ol></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="aed1" class="ky kz iq bd la lb mp ld le lf mq lh li lj mr ll lm ln ms lp lq lr mt lt lu lv bi translated">虚假分享</h1><p id="3496" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">现在，让我们回到虚假分享的话题。让我们以上面解释的例子来看看错误共享是如何发生的。</p><ol class=""><li id="109f" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated">简单回顾一下，我们的核心X缓存行处于修改状态，而核心Y缓存行处于无效状态。</li><li id="8101" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">现在，假设内核Y想要再次读取Y的值。由于高速缓存行无效，它不能从高速缓存中读取值，而必须从主存储器中进行低效读取(高速缓存未命中)。</li><li id="8526" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">这将迫使核心X刷新它的存储缓冲区。现在两者都将更新的高速缓存线标记为共享状态。你可能会想什么是存储缓冲区。通常，处理器在将修改刷新回主存之前，会在它们的<em class="me">存储缓冲区</em>中缓冲修改。它将一堆小写操作(比如8字节写操作)打包成一个更大的事务(一个64字节的缓存行)，然后发送到内存系统。批量缓冲和刷新可以极大地提升性能。</li><li id="d730" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">这种缓存未命中的现象，即使数据块驻留在不同的内存位置并且没有直接更新，也称为假共享。即使两个内核不在同一个内存位置上运行，这也会对一个内核造成缓存未命中，并对另一个内核造成早期缓冲区刷新</li></ol><p id="2b1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过增加高速缓存未命中的数量和从主存储器更频繁地访问数据，系统的性能受到负面影响。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="3a85" class="ky kz iq bd la lb mp ld le lf mq lh li lj mr ll lm ln ms lp lq lr mt lt lu lv bi translated">避免错误共享</h1><p id="02f5" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">现在，我们知道了什么是虚假分享以及它是如何发生的，让我们看看如何避免它。我们还将看看java为解决这个问题提供了哪些支持</p><p id="da10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从前面的例子可以看出，整个问题的发生是因为两个值x和y位于同一个缓存行。解决这个问题的一个简单方法是<strong class="jp ir">在这两个值周围添加填充符</strong>，这样这两个值就位于不同的缓存行中。</p><p id="d432" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们的高速缓存行大小是64字节，而long是8字节。我们知道现有的x和y变量都是长变量。因此，通过添加7个长变量作为填充，我们可以确保长y在不同的缓存行。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/2c37d7be68968f18ec6927adc6702f84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/0*sWdatxSwqVcTDQHo.png"/></div></figure><p id="0882" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用volatile降低了我们填充的未使用变量被JVM移除的风险。<strong class="jp ir">死代码消除</strong>是由JVM完成的一项优化，删除不影响程序结果的代码。避免<strong class="jp ir">死代码消除</strong>现象的另一种方法是通过日志记录。</p><h2 id="4c46" class="nl kz iq bd la nm nn dn le no np dp li jy nq nr lm kc ns nt lq kg nu nv lu nw bi translated">@有争议的注释(特定于Java)</h2><p id="659b" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">Java通过@ Contended注释在内部处理错误的共享。Java代码将该注释描述如下-</p><blockquote class="mb mc md"><p id="6098" class="jn jo me jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated"><em class="iq">表示对象和/或其字段预计会遇到内存争用的注释，一般以“假共享”的形式出现。</em> <strong class="jp ir"> <em class="iq">这个注释作为一个提示，这样的对象和字段应该驻留在与其他对象或字段隔离的位置。对内存争用的敏感性是对象和字段的预期用途的属性，而不是它们的类型或限定符。这种注释的效果几乎总是会给对象增加大量的空间开销。</em> </strong></p></blockquote><p id="57b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="http://twitter.com/Contended" rel="noopener ugc nofollow" target="_blank">@ contributed</a>是一个sun.misc注释，这意味着理想情况下我们不应该在代码中使用它</p><p id="5b41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些核心java代码(java 8)的例子，其中@ Contended被广泛使用</p><ol class=""><li id="9d9c" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated"><strong class="jp ir"> ForkJoinPool </strong></li></ol><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="ny nz di oa bf ob"><div class="gh gi nx"><img src="../Images/c4165d6f6616b7bbe736e85cb79e2b36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5V73qZIN-R9SY1O3.png"/></div></div></figure><p id="bb2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<strong class="jp ir">threadlocalrrandom</strong></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="ny nz di oa bf ob"><div class="gh gi oc"><img src="../Images/664b58db183eb032bffc18cf7de71f38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2GphSvjdgmdB8HNS.png"/></div></div></figure><p id="ab76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">伙计们，这都是我的观点。我希望这篇文章对你有意义。快乐编码:)<br/>请不吝反馈。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="5a39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="me">原载于2021年5月14日</em><a class="ae kx" href="https://www.aboutall.tech/false-sharing.html" rel="noopener ugc nofollow" target="_blank"><em class="me">https://www . about all . tech</em></a><em class="me">。</em></p></div></div>    
</body>
</html>