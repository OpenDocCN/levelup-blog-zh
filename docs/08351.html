<html>
<head>
<title>Golang: Optimizing Docker Image Size from 2.4 GB to 100 MB using Docker Multi-Stage Build Process.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang:使用Docker多阶段构建流程将Docker映像大小从2.4 GB优化到100 MB。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/golang-optimizing-docker-image-size-from-2-4-gb-to-100-mb-using-docker-multi-stage-build-process-5b808f20e808?source=collection_archive---------1-----------------------#2021-04-24">https://levelup.gitconnected.com/golang-optimizing-docker-image-size-from-2-4-gb-to-100-mb-using-docker-multi-stage-build-process-5b808f20e808?source=collection_archive---------1-----------------------#2021-04-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5f874efa421b8438d74017ba52930f91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LKkq6La-zip4QrNa"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">马克·奥尔森在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="42d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在开发人员想到的数百种优化中，减少docker图像大小是最不重要的。我们也是。</p><p id="895b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果，我们的docker映像开始重约2.4 GB，这间接提高了我们开发人员的工作效率。以下是我们面对较大docker图像尺寸时遇到的问题</p><p id="e55a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> - &gt;运行自动化集成测试的延迟</strong></p><p id="2cbc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每当我们向发布分支提出合并请求时，我们都有一个自动化的过程，它从提出的MR代码中构建一个新的映像，从它旋转出一个新的容器，并针对当前版本构建(<strong class="kf ir">连接到产品数据库</strong>)和稳定的生产构建发出数千个自动化请求，并比较两个响应，以检查当前发布是否没有破坏现有的功能，作为自动化集成测试的一部分。</p><p id="0b20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">痛点</strong></p><ul class=""><li id="0660" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">这里的构建过程没有缓存，因此每次有发布的合并请求时，构建映像需要20-25分钟，集成测试需要10分钟。</li><li id="af3c" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">如果其中一个集成测试失败了，我们就退出这个过程，开发人员不得不假设一些极端的情况，修复，并再次重新推送，其中仍然不能保证修复后测试会通过。开发人员不得不一直等待这个成功，这会影响他/她的生产力。</li></ul><p id="1f0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> - &gt;创建构建标签的延迟</strong></p><p id="31ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦集成测试通过，代码被审查并被推送到发布，OpenCI自动化就会启动并创建一个构建标签(<strong class="kf ir">release-&lt;version&gt;</strong>)。在这个过程中，应用程序的依赖项被提取，然后最终生成的图像被推送到工件。</p><p id="34d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们继续创建一个带有发布标签和后期批准的JIRA标签，<strong class="kf ir"> Edge Automation </strong>开始工作并创建新的容器。</p><p id="e33d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">痛点</strong></p><ul class=""><li id="1fc4" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">提取依赖关系并通过网络将生成的庞大图像推送到工件会消耗大量时间，并且速度取决于网络带宽。</li></ul><p id="343c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> - &gt;自动缩放</strong></p><p id="c53e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有关docker图像大小w.r.t，自动缩放效果的详细信息，请参考我下面的另一篇文章。</p><div class="lp lq gp gr lr ls"><a rel="noopener  ugc nofollow" target="_blank" href="/effects-of-docker-image-size-on-autoscaling-w-r-t-single-and-multi-node-kube-cluster-29c4f689cd99"><div class="lt ab fo"><div class="lu ab lv cl cj lw"><h2 class="bd ir gy z fp lx fr fs ly fu fw ip bi translated">Docker图像大小对自动缩放w.r.t单节点和多节点Kube集群的影响</h2><div class="lz l"><h3 class="bd b gy z fp lx fr fs ly fu fw dk translated">当你问开发人员提高应用程序性能的两个关键因素是什么时，答案是…</h3></div><div class="ma l"><p class="bd b dl z fp lx fr fs ly fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mb l"><div class="mc l md me mf mb mg jw ls"/></div></div></a></div></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="2263" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们已经了解了拥有如此巨大的docker图像的痛点，让我们试着分析一下是什么让docker图像如此巨大。为此，让我们看一看我们最初的docker形象。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="5a0a" class="mx my iq mt b gy mz na l nb nc"><strong class="mt ir">FROM centos:7</strong></span><span id="c0c9" class="mx my iq mt b gy nd na l nb nc">RUN \<br/>  yum install -y epel-release bison python-setuptools bzip2 wget make gcc gcc-c++ zlib-devel <strong class="mt ir">git</strong> lsof &amp;&amp; \<br/>  easy_install supervisor &amp;&amp;  \<br/>  mkdir -p /opt/logs /etc/supervisord.d  &amp;&amp; \<br/>  yum clean all &amp;&amp; \<br/>  rm -f /etc/localtime &amp;&amp; \<br/>  ln -s /usr/share/zoneinfo/Asia/Kolkata /etc/localtime</span><span id="1156" class="mx my iq mt b gy nd na l nb nc">#Install Go<br/><strong class="mt ir">RUN \<br/>  cd /tmp &amp;&amp; \<br/>  wget </strong><a class="ae kc" href="https://storage.googleapis.com/golang/go1.12.6.linux-amd64.tar.gz" rel="noopener ugc nofollow" target="_blank"><strong class="mt ir">https://storage.googleapis.com/golang/go1.12.6.linux-amd64.tar.gz</strong></a><strong class="mt ir"> &amp;&amp; \<br/>  tar -C /usr/local -xzf go1.12.6.linux-amd64.tar.gz &amp;&amp; \<br/>  ln -s /usr/local/go/bin/go /bin/go &amp;&amp; \<br/>  ln -s /usr/local/go/bin/gofmt /bin/gofmt</strong><br/></span><span id="ec2f" class="mx my iq mt b gy nd na l nb nc">ENV <em class="ne">PATH</em>=$<em class="ne">PATH</em>:/usr/local/go/bin:/usr/local/goibibo/&lt;projectName&gt;/bin<br/>ENV <em class="ne">GO111MODULE</em>=auto <em class="ne">CGO_ENABLED</em>=1<br/>ENV <em class="ne">GODEBUG</em>="madvdontneed=1"</span><span id="7088" class="mx my iq mt b gy nd na l nb nc">ARG <em class="ne">GIT_TOKEN</em></span><span id="82c8" class="mx my iq mt b gy nd na l nb nc">RUN git config --global url."https://$<em class="ne">GIT_TOKEN</em>@github.com/goibibo/".insteadOf "https://github.com/goibibo/"<br/>EXPOSE 80<br/>#Set argument env - to receive input<br/>ARG <em class="ne">env</em></span><span id="95a2" class="mx my iq mt b gy nd na l nb nc">WORKDIR /usr/local/goibibo/&lt;projectName&gt;</span><span id="01fc" class="mx my iq mt b gy nd na l nb nc">#Add supervisord and functions in startup scripts<br/>COPY ./init/supervisord /etc/rc.d/init.d/<br/>COPY ./init/services/* /etc/supervisord.d/</span><span id="7d6b" class="mx my iq mt b gy nd na l nb nc">COPY ./go.mod .    </span><span id="5471" class="mx my iq mt b gy nd na l nb nc">RUN go mod download</span><span id="7eab" class="mx my iq mt b gy nd na l nb nc">#Copy source directory<br/><strong class="mt ir">COPY ./ .</strong></span><span id="c8bb" class="mx my iq mt b gy nd na l nb nc">RUN make</span><span id="3b27" class="mx my iq mt b gy nd na l nb nc">RUN chmod 0644 /etc/deployments/&lt;build&gt;.sh &amp;&amp; \<br/>    chmod 0755 /etc/rc.d/init.d/supervisord</span></pre><p id="61be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们继续分析增加图像大小的步骤(粗线)。</p><ul class=""><li id="e21c" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">首先，我们将centos 7作为基础映像。</li><li id="2d8e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">然后，我们安装所有需要的外部软件。</li><li id="ad58" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">然后，我们在centos base image上下载并安装相应的Golang版本来构建代码。</li><li id="c630" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">然后我们执行<strong class="kf ir"> go mod download </strong>来提取所有的模块依赖关系，并将所有的内部代码模块复制到工作目录中，最后<strong class="kf ir"> make </strong>来生成二进制文件。</li></ul><p id="0866" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个步骤都需要一些存储，所有提取的依赖项都将被复制到最终生成的映像中。</p><p id="bf0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是对于在生产环境中运行的代码，我们所需要的只是一个从代码中生成的二进制文件和一个我们可以在其上执行二进制文件的基本操作系统(足够执行二进制文件的功能)。但是在我们的docker映像中，一旦生成了二进制文件，我们就有一大堆无用的依赖项，其中包括(Git、GCC、GCC-C++、Golang、Go模块、代码模块等),占用了将近2 GB的空间。<strong class="kf ir">除此之外，对于我们的用例，我们不需要完整的centos功能来运行二进制文件。一个裸露的Alpine OS映像(5 MB)足以运行二进制文件。</strong></p><p id="2649" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有两种方法可以避免将这2 GB的数据复制到最终映像。</p><ul class=""><li id="4cb6" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">步骤1 -&gt;作为构建二进制文件后的最后一步，我们可以进入有不必要模块的单独目录并修剪目录。这一过程会导致太多的手动工作来识别并在每个安装了不需要的依赖项的目录中使用一个<strong class="kf ir"> rm -R </strong>命令，并且在我们需要向现有映像添加更多依赖项时会变得非常忙碌。</li><li id="fa11" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">步骤2 -&gt;使用docker多阶段构建过程的便捷方式。让我们详细了解一下多阶段构建过程。</li></ul><p id="867a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，docker多阶段是如何工作的呢？</p><p id="a6b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">多阶段帮助我们做各种杂耍来下载或安装构建二进制文件所需的依赖项，而不需要将依赖项复制到最终映像。我们来看看改造后的多级docker形象，过一遍。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="ca6a" class="mx my iq mt b gy mz na l nb nc"><strong class="mt ir"># Stage 1<br/></strong>FROM alpine:3.11.5 AS <em class="ne">builder</em></span><span id="cd10" class="mx my iq mt b gy nd na l nb nc">RUN apk update \<br/>    &amp;&amp; apk add --virtual build-dependencies \<br/>        bash \<br/>        build-base \<br/>        coreutils \<br/>        ca-certificates \<br/>        gcc \<br/>        g++ \<br/>        git \<br/>        make \<br/>        lsof \<br/>        wget \<br/>        curl \<br/>        musl-dev \<br/>        tzdata \<br/>        pkgconfig \<br/>        pkgconf</span><span id="d2ea" class="mx my iq mt b gy nd na l nb nc">#Install Go<br/><strong class="mt ir">RUN \<br/>  cd /tmp &amp;&amp; \<br/>  wget </strong><a class="ae kc" href="https://storage.googleapis.com/golang/go1.12.6.linux-amd64.tar.gz" rel="noopener ugc nofollow" target="_blank"><strong class="mt ir">https://storage.googleapis.com/golang/go1.12.6.linux-amd64.tar.gz</strong></a><strong class="mt ir"> &amp;&amp; \<br/>  tar -C /usr/local -xzf go1.12.6.linux-amd64.tar.gz &amp;&amp; \<br/>  ln -s /usr/local/go/bin/go /bin/go &amp;&amp; \<br/>  ln -s /usr/local/go/bin/gofmt /bin/gofmt</strong>RUN ln -s /usr/local/go/bin/go /bin/go &amp;&amp; \<br/>  ln -s /usr/local/go/bin/gofmt /bin/gofmt</span><span id="96da" class="mx my iq mt b gy nd na l nb nc">ENV <em class="ne">PATH</em>=$<em class="ne">PATH</em>:/usr/local/go/bin:/usr/local/goibibo/&lt;projectName&gt;/bin</span><span id="335d" class="mx my iq mt b gy nd na l nb nc">ENV <em class="ne">GO111MODULE</em>=auto <em class="ne">CGO_ENABLED</em>=1<br/>ENV <em class="ne">GODEBUG</em>="madvdontneed=1"<br/>ENV <em class="ne">GOPRIVATE </em>&lt;Private-Repo-Link&gt;</span><span id="80de" class="mx my iq mt b gy nd na l nb nc">ARG <em class="ne">GIT_TOKEN</em></span><span id="48a4" class="mx my iq mt b gy nd na l nb nc">RUN git config --global url."https://$<em class="ne">GIT_TOKEN</em>@github.com/goibibo/".insteadOf "https://github.com/goibibo/"</span><span id="ef17" class="mx my iq mt b gy nd na l nb nc">WORKDIR /usr/local/goibibo/&lt;projectName&gt;</span><span id="0f7f" class="mx my iq mt b gy nd na l nb nc">COPY ./pkg ./pkg<br/>COPY ./go.mod .</span><span id="8c41" class="mx my iq mt b gy nd na l nb nc">RUN go mod download</span><span id="de25" class="mx my iq mt b gy nd na l nb nc">#Copy source directory<br/>COPY ./ .</span><span id="3358" class="mx my iq mt b gy nd na l nb nc">RUN make<br/><em class="ne">                      -----------------</em></span><span id="2019" class="mx my iq mt b gy nd na l nb nc"><strong class="mt ir"># Final Stage - Stage 2</strong><br/><strong class="mt ir">FROM alpine:3.11.5 as <em class="ne">baseImage</em></strong></span><span id="40a9" class="mx my iq mt b gy nd na l nb nc"><strong class="mt ir">RUN apk update \<br/>    &amp;&amp; apk add --virtual build-dependencies \<br/>        tzdata \<br/>        supervisor \<br/>        ca-certificates</strong></span><span id="61df" class="mx my iq mt b gy nd na l nb nc"><strong class="mt ir">RUN \<br/>  mkdir -p /opt/logs /etc/supervisord.d  &amp;&amp; \<br/>  rm -f /etc/localtime &amp;&amp; \<em class="ne"><br/>  </em>ln -s /usr/share/zoneinfo/Asia/Kolkata /etc/localtime<br/></strong></span><span id="d1fa" class="mx my iq mt b gy nd na l nb nc"><strong class="mt ir">ARG <em class="ne">BINARY_PATH</em>=/usr/local/goibibo/&lt;projectName&gt;/bin</strong></span><span id="2cf8" class="mx my iq mt b gy nd na l nb nc"><strong class="mt ir">ENV <em class="ne">PATH</em>=$<em class="ne">PATH</em>:/usr/local/go/bin:/usr/local/goibibo/&lt;projectName&gt;/bin</strong></span><span id="34f9" class="mx my iq mt b gy nd na l nb nc"><strong class="mt ir">COPY --from=<em class="ne">builder </em>$<em class="ne">BINARY_PATH </em>$<em class="ne">BINARY_PATH</em></strong></span><span id="1c9a" class="mx my iq mt b gy nd na l nb nc"><strong class="mt ir">WORKDIR /usr/local/goibibo/&lt;projectName&gt;</strong></span><span id="09eb" class="mx my iq mt b gy nd na l nb nc"><strong class="mt ir">#Add supervisord and functions in startup scripts<br/>COPY ./init/supervisord /etc/rc.d/init.d/<br/>COPY ./init/services/* /etc/supervisord.d/<br/>COPY ./deployments/ /etc/deployments/</strong></span><span id="31d4" class="mx my iq mt b gy nd na l nb nc"><strong class="mt ir">RUN chmod 0644 /etc/deployments/&lt;build&gt;.sh &amp;&amp; \<br/>    chmod 0755 /etc/rc.d/init.d/supervisord</strong></span></pre><p id="b85c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看一下修改后的多阶段docker构建流程。我们将整个构建过程分为两个阶段。</p><p id="7f8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一阶段(<strong class="kf ir">阶段名为构建者</strong>)是我们获取生成代码构建所需的所有软件和外部模块依赖关系的阶段。</p><p id="74cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第二阶段，我们所做的就是</p><ul class=""><li id="45c9" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">将<strong class="kf ir"> Alpine </strong>作为基本图像(5 MB)大小。安装supervisor(用于维护流程)和其他一些必需的依赖项(20 MB)。</li><li id="c412" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">使用以下命令将阶段1生成的二进制文件复制到阶段2。在我们的例子中，二进制文件的大小是65mb(<strong class="kf ir">COPY—from =<em class="ne">&lt;stage name&gt;</em>&lt;<em class="ne">from path</em>&gt;<em class="ne"/>&lt;<em class="ne">toPath</em>&gt;<em class="ne">)在使用上述命令进行多阶段构建的情况下，我们可以以自顶向下的方式从任何阶段复制到任何阶段。</em>T11】</strong></li><li id="2171" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">这里我们没有将代码或go模块复制到最后阶段。它只是二进制的。</li><li id="5854" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">将静态文件复制到最终图像。</li><li id="9685" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">有一个RUN命令来启动执行二进制文件的管理程序，并监控由二进制文件启动的进程的健康状况。</li></ul><p id="b099" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这种方式，我们使用多阶段构建流程，以最小的努力将一个庞大的2.4GB docker映像转换为一个小巧的100 MB( <strong class="kf ir">取决于二进制文件的大小和所需的其他依赖关系</strong> ) docker映像。</p><p id="4067" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果这篇文章需要更详细的解释或任何改进，请在评论部分告诉我。</p></div></div>    
</body>
</html>