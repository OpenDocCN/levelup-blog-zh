<html>
<head>
<title>Functional options on steroids</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类固醇的功能选项</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/functional-options-on-steroids-a9ab31092b97?source=collection_archive---------15-----------------------#2020-01-28">https://levelup.gitconnected.com/functional-options-on-steroids-a9ab31092b97?source=collection_archive---------15-----------------------#2020-01-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="08bb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使使用功能选项变得轻而易举的最佳实践</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6755f57c202137d730b5dd225371d0d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CbfFB2zja0Vtd0fOtPhpZg.jpeg"/></div></div></figure><p id="b947" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">原载于</em><a class="ae lo" href="https://sagikazarmark.hu/blog/functional-options-on-steroids/" rel="noopener ugc nofollow" target="_blank"><em class="ln">https://sagikazarmark . Hu</em></a><em class="ln">。</em></p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="6859" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Functional options是Go for clean and extensible APIs中的一个范例，由<a class="ae lo" href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis" rel="noopener ugc nofollow" target="_blank">戴夫·切尼</a>和<a class="ae lo" href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" rel="noopener ugc nofollow" target="_blank">罗布·派克</a>推广。这篇文章是关于自从这个模式被首次引入以来围绕着它出现的实践。</p><p id="21f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">功能选项作为一种创建漂亮干净的API配置的方式出现，特别是涉及到可选设置。有许多显而易见的方法可以做到这一点(构造函数变体、配置结构、设置器方法等)，但是当一个包有十几个选项时，这些方法就不够了，而且产生的API不如函数选项好。</p><h1 id="e859" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">重述—什么是功能选项？</h1><p id="1f78" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">通常，当您构造一个“对象”时，您可以通过调用一个构造函数并向其传递必要的参数来实现:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="f10a" class="my lx iq mu b gy mz na l nb nc">obj := New(arg1, arg2)</span></pre><p id="bc39" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">(暂且忽略Go中没有传统构造函数的事实。)</em></p><p id="a6bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">函数选项允许用可选参数扩展API，将上面的代码行变成这样:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="c2e2" class="my lx iq mu b gy mz na l nb nc">// I can still do this...<br/>obj := New(arg1, arg2)<br/><br/>// ...but this works too<br/>obj := New(arg1, arg2, myOption1, myOption2)</span></pre><p id="9cfe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">函数选项基本上是变量函数类型实参，接受构造(或中间配置)类型作为参数。由于变量的性质，调用一个没有任何选项的构造函数是完全有效的，即使当你想回到缺省值时，也能保持它的整洁。</p><p id="ebc1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了更好地演示该模式，让我们看一个实际的例子(首先没有功能选项):</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="ac02" class="my lx iq mu b gy mz na l nb nc">type Server struct {<br/>    addr string<br/>}<br/><br/>// NewServer initializes a new Server listening on addr.<br/>func NewServer(addr string) *Server {<br/>    return &amp;Server {<br/>        addr: addr,<br/>    }<br/>}</span></pre><p id="d38b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">添加超时选项后，代码如下所示:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="2ae2" class="my lx iq mu b gy mz na l nb nc">type Server struct {<br/>    addr string<br/><br/>    // default: no timeout<br/>    timeout time.Duration<br/>}<br/><br/>// Timeout configures a maximum length of idle connection in Server.<br/>func Timeout(timeout time.Duration) func(*Server) {<br/>    return func(s *Server) {<br/>        s.timeout = timeout<br/>    }<br/>}<br/><br/>// NewServer initializes a new Server listening on addr with optional configuration.<br/>func NewServer(addr string, opts ...func(*Server)) *Server {<br/>    server := &amp;Server {<br/>        addr: addr,<br/>    }<br/><br/>    // apply the list of options to Server<br/>    for _, opt := range opts {<br/>        opt(server)<br/>    }<br/><br/>    return server<br/>}</span></pre><p id="9ef3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由此产生的API易于使用和阅读:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="83eb" class="my lx iq mu b gy mz na l nb nc">// no optional paramters, use defaults<br/>server := NewServer(":8080")<br/><br/>// configure a timeout in addition to the address<br/>server := NewServer(":8080", Timeout(10 * time.Second))<br/><br/>// configure a timeout and TLS in addition to the address<br/>server := NewServer(":8080", Timeout(10 * time.Second), TLS(&amp;TLSConfig{}))</span></pre><p id="9aed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">相比之下，下面是构造函数变量和配置结构版本的样子:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="d893" class="my lx iq mu b gy mz na l nb nc">// constructor variants<br/>server := NewServer(":8080")<br/>server := NewServerWithTimeout(":8080", 10 * time.Second)<br/>server := NewServerWithTimeoutAndTLS(":8080", 10 * time.Second, &amp;TLSConfig{})<br/><br/><br/>// config struct<br/>server := NewServer(":8080", Config{})<br/>server := NewServer(":8080", Config{ Timeout: 10 * time.Second })<br/>server := NewServer(":8080", Config{ Timeout: 10 * time.Second, TLS: &amp;TLSConfig{} })</span></pre><p id="8c60" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与构造函数变体相比，使用函数选项的优势可能是显而易见的:它们更易于维护和读/写。当没有选项传递给构造函数(空结构)时，函数选项也胜过配置结构，但是在下面的部分中，我将展示更多配置结构可能不足的例子。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="82ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">点击帖子介绍中的链接，阅读功能选项的完整内容。</em></p><h1 id="2584" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">功能选项实践</h1><p id="a7a2" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">函数选项本身只不过是传递给构造函数的函数。仅仅使用普通函数的简单性提供了灵活性和很大的潜力。正因为如此，这些年来围绕该模式出现了相当多的实践也就不足为奇了。以下是我认为最受欢迎和最有用的实践。</p><p id="0bd0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你觉得少了什么，请写信给我。</p><h1 id="b16d" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">选项类型</h1><p id="cb65" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">在应用函数选项模式时，您可能要做的第一件事是为选项函数定义一个类型:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="c82a" class="my lx iq mu b gy mz na l nb nc">// Option configures a Server.<br/>type Option func(s *Server)</span></pre><p id="224d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然这看起来不是一个很大的改进，但是通过使用类型名而不是函数定义，它实际上使代码更具可读性:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="5dc0" class="my lx iq mu b gy mz na l nb nc">func Timeout(timeout time.Duration) func(*Server) { /*...*/ }<br/><br/>// reads: a new server accepts an address<br/>// and a set of functions that accepts the server itself<br/>func NewServer(addr string, opts ...func(s *Server)) *Server<br/><br/>// VS<br/><br/>func Timeout(timeout time.Duration) Option { /*...*/ }<br/><br/>// reads: a new server accepts an address and a set of options<br/>func NewServer(addr string, opts ...Option) *Server</span></pre><p id="34cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">拥有选项类型的另一个优点是<a class="ae lo" href="https://godoc.org/" rel="noopener ugc nofollow" target="_blank"> Godoc </a>在类型下组织选项功能:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/45d43fab4814fc7fe2c3a4a1f7ea09e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NvRR_Bizl20UKBbL.png"/></div></div></figure><h1 id="193f" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">选项列表类型</h1><p id="6949" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">通常，功能选项用于创建某个事物的单个实例，但情况并非总是如此。创建多个实例时重用默认选项列表也并不少见:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="7bb3" class="my lx iq mu b gy mz na l nb nc">defaultOptions := []Option{Timeout(5 * time.Second)}<br/><br/>server1 := NewServer(":8080", append(defaultOptions, MaxConnections(10))...)<br/><br/>server2 := NewServer(":8080", append(defaultOptions, RateLimit(10, time.Minute))...)<br/><br/>server3 := NewServer(":8080", append(defaultOptions, Timeout(10 * time.Second))...)</span></pre><p id="0505" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然这不是非常可读的代码，但是使用函数选项的目的是拥有友好的API。幸运的是，有一种方法可以简化它。我们只需要让<code class="fe ne nf ng mu b">[]Option</code>切片成为<code class="fe ne nf ng mu b">Option</code>本身:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="bf43" class="my lx iq mu b gy mz na l nb nc">// Options turns a list of Option instances into an Option.<br/>func Options(opts ...Option) Option {<br/>    return func(s *Server) {<br/>        for _, opt := range opts {<br/>            opt(s)<br/>        }<br/>    }<br/>}</span></pre><p id="0293" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用<code class="fe ne nf ng mu b">Options</code>函数替换切片后，上面的代码变成:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="7eed" class="my lx iq mu b gy mz na l nb nc">defaultOptions := Options(Timeout(5 * time.Second))<br/><br/>server1 := NewServer(":8080", defaultOptions, MaxConnections(10))<br/><br/>server2 := NewServer(":8080", defaultOptions, RateLimit(10, time.Minute))<br/><br/>server3 := NewServer(":8080", defaultOptions, Timeout(10 * time.Second))</span></pre><h1 id="5890" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated"><code class="fe ne nf ng mu b">With</code> / <code class="fe ne nf ng mu b">Set</code>选项名称前缀</h1><p id="f4db" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">选项通常是复杂类型，不像超时或最大连接数。例如，服务器包可能会定义一个<code class="fe ne nf ng mu b">Logger</code>接口作为选项(默认情况下会返回到noop logger):</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="d2d1" class="my lx iq mu b gy mz na l nb nc">type Logger interface {<br/>    Info(msg string)<br/>    Error(msg string)<br/>}</span></pre><p id="1def" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ne nf ng mu b">Logger</code>作为名称显然不能用于选项，因为它已经被接口使用。可能有用，但这不是一个友好的名字。当你把构造函数看作一个句子时，你会想到单词<strong class="kt ir">和</strong>，在我们的例子中是:<code class="fe ne nf ng mu b">WithLogger</code>。</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="851d" class="my lx iq mu b gy mz na l nb nc">func WithLogger(logger Logger) Option {<br/>    return func(s *Server) {<br/>        s.logger = logger<br/>    }<br/>}<br/><br/>// reads: create a new server that listens on :8080 with a logger<br/>NewServer(":8080", WithLogger(logger))</span></pre><p id="3d48" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">复杂类型选项的另一个常见示例是值的列表(切片):</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="9d11" class="my lx iq mu b gy mz na l nb nc">type Server struct {<br/>    // ...<br/><br/>    whitelistIPs []string<br/>}<br/><br/>func WithWhitelistedIP(ip string) Option {<br/>    return func(s *Server) {<br/>        s.whitelistIPs = append(s.whitelistIPs, ip)<br/>    }<br/>}<br/><br/>NewServer(":8080", WithWhitelistedIP("10.0.0.0/8"), WithWhitelistedIP("172.16.0.0/12"))</span></pre><p id="ecac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这种情况下，默认行为通常是append而不是set，这符合这样一个事实，即<strong class="kt ir"> with </strong>建议添加到一个列表中，而不是覆盖它。如果需要覆盖现有的一组值，可以在选项名中使用<strong class="kt ir"> set </strong> word:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="414a" class="my lx iq mu b gy mz na l nb nc">func SetWhitelistedIP(ip string) Option {<br/>    return func(s *Server) {<br/>        s.whitelistIPs = []string{ip}<br/>    }<br/>}<br/><br/>NewServer(<br/>    ":8080",<br/>    WithWhitelistedIP("10.0.0.0/8"),<br/>    WithWhitelistedIP("172.16.0.0/12"),<br/>    SetWhitelistedIP("192.168.0.0/16"), // overwrites any previous values<br/>)</span></pre><p id="e39e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">类似地，如果需要的话，可以很容易地创建一个前置选项。</p><h1 id="598a" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">预设模式</h1><p id="618e" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">特定的用例通常足够通用，可以在库中支持它们。在配置的情况下，这可能意味着一组选项被组合在一起，并用作用例的预设。在我们的示例中，<code class="fe ne nf ng mu b">Server</code>可能有一个公共和一个内部用例，它们以不同的方式配置超时、速率限制、连接数等:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="685b" class="my lx iq mu b gy mz na l nb nc">// PublicPreset configures a Server for public usage.<br/>func PublicPreset() Option {<br/>    return Options(<br/>        WithTimeout(10 * time.Second),<br/>        MaxConnections(10),<br/>    )<br/>}<br/><br/>// InternalPreset configures a Server for internal usage.<br/>func InternalPreset() Option {<br/>    return Options(<br/>        WithTimeout(20 * time.Second),<br/>        WithWhitelistedIP("10.0.0.0/8"),<br/>    )<br/>}</span></pre><p id="ec16" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然预设在某些情况下很有用，但它们可能在内部库中更有价值，而在公共的通用库中价值较低。</p><h1 id="b67d" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">默认值与默认预设</h1><p id="c80b" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">在Go中，空值总是有一个默认值。对于数字，它通常是零，对于布尔值，它是<code class="fe ne nf ng mu b">false</code>，以此类推。在可选配置中依赖默认值被认为是一个好的做法。例如，零值应该意味着无限制的超时，而不是“无超时”(这通常是无意义的)。</p><p id="c549" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是在某些情况下，零值并不是一个好的默认值。例如，<code class="fe ne nf ng mu b">Logger</code>的默认值是<code class="fe ne nf ng mu b">nil</code>，这将导致混乱(除非您使用条件检查来保护日志调用)。</p><p id="d233" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这些情况下，在构造函数中设置值(在应用选项之前)是定义回退的好方法:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="c16d" class="my lx iq mu b gy mz na l nb nc">func NewServer(addr string, opts ...func(*Server)) *Server {<br/>    server := &amp;Server {<br/>        addr:   addr,<br/>        logger: noopLogger{},<br/>    }<br/><br/>    // apply the list of options to Server<br/>    for _, opt := range opts {<br/>        opt(server)<br/>    }<br/><br/>    return server<br/>}</span></pre><p id="aeb4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我见过一些默认预设的例子(使用上一节解释的模式)。然而，我不认为这是一个好的做法。这比简单地在构造函数中设置默认值更缺乏表现力:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="c0f0" class="my lx iq mu b gy mz na l nb nc">func NewServer(addr string, opts ...func(*Server)) *Server {<br/>    server := &amp;Server {<br/>        addr:   addr,<br/>    }<br/><br/>    // what are the defaults?<br/>    opts = append([]Option{DefaultPreset()}, opts...)<br/><br/>    // apply the list of options to Server<br/>    for _, opt := range opts {<br/>        opt(server)<br/>    }<br/><br/>    return server<br/>}</span></pre><h1 id="37ce" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">配置结构选项</h1><p id="e30d" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">将<code class="fe ne nf ng mu b">Config</code> struct作为函数选项可能不太常见，但也不是没有先例。其思想是函数选项引用一个配置结构，而不是引用正在创建的实际对象:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="c42a" class="my lx iq mu b gy mz na l nb nc">type Config struct {<br/>    Timeout time.Duration<br/>}</span><span id="d494" class="my lx iq mu b gy nh na l nb nc">type Option func(c *Config)</span><span id="7b45" class="my lx iq mu b gy nh na l nb nc">type Server struct {<br/>    // ...</span><span id="95d0" class="my lx iq mu b gy nh na l nb nc">    config Config<br/>}</span></pre><p id="c3c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当您有大量选项，并且创建一个配置结构似乎比在一个函数调用中列出所有选项更干净时，这种模式很有用:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="dfa3" class="my lx iq mu b gy mz na l nb nc">config := Config{<br/>    Timeout: 10 * time.Second<br/>    // ...<br/>    // lots of other options<br/>}<br/><br/>NewServer(":8080", WithConfig(config))</span></pre><p id="7108" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此模式的另一个用例是设置默认值:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="43fc" class="my lx iq mu b gy mz na l nb nc">config := Config{<br/>    Timeout: 10 * time.Second<br/>    // ...<br/>    // lots of other options<br/>}<br/><br/>NewServer(":8080", WithConfig(config), WithTimeout(20 * time.Second))</span></pre><h1 id="dfa9" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">高级模式</h1><p id="935d" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">在编写了几十个功能选项之后，您可能会开始怀疑是否有更好的方法。不是从消费者的角度，而是从维护者的角度。</p><p id="a4e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，如果我们可以定义类型并将它们用作选项会怎么样:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="41cb" class="my lx iq mu b gy mz na l nb nc">type Timeout time.Duration<br/><br/>NewServer(":8080", Timeout(time.Minute))</span></pre><p id="d98d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(注意从消费者的角度来看API是如何保持不变的)</p><p id="a204" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">事实证明，通过改变<code class="fe ne nf ng mu b">Option</code>类型，我们可以很容易地做到这一点:</p><p id="d87d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将选项功能重新定义为接口，为实现功能选项的许多新方法打开了大门:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="dc99" class="my lx iq mu b gy mz na l nb nc">// Option configures a Server.<br/>type Option interface {<br/>    // apply is unexported,<br/>    // so only the current package can implement this interface.<br/>    apply(s *Server)<br/>}</span></pre><p id="1223" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">各种内置类型可以用作没有函数包装的选项:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="5a95" class="my lx iq mu b gy mz na l nb nc">// Timeout configures a maximum length of idle connection in Server.<br/>type Timeout time.Duration<br/><br/>func (t Timeout) apply(s *Server) {<br/>    s.timeout = time.Duration(t)<br/>}</span></pre><p id="5826" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">选项列表和配置结构(见前面章节)也可以像这样重新定义:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="9398" class="my lx iq mu b gy mz na l nb nc">// Options turns a list of Option instances into an Option.<br/>type Options []Option<br/><br/>func (o Options) apply(s *Server) {<br/>    for _, opt := range o {<br/>        o.apply(s)<br/>    }<br/>}<br/><br/>type Config struct {<br/>    Timeout time.Duration<br/>}<br/><br/>func (c Config) apply(s *Server) {<br/>    s.config = c<br/>}</span></pre><p id="8259" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不过，我个人最喜欢的是在多个构造函数中重用一个选项的可能性:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="23ed" class="my lx iq mu b gy mz na l nb nc">// ServerOption configures a Server.<br/>type ServerOption interface {<br/>    applyServer(s *Server)<br/>}<br/><br/>// ClientOption configures a Client.<br/>type ClientOption interface {<br/>    applyClient(c *Client)<br/>}<br/><br/>// Option configures a Server or a Client.<br/>type Option interface {<br/>    ServerOption<br/>    ClientOption<br/>}<br/><br/><br/>func WithLogger(logger Logger) Option {<br/>    return withLogger{logger}<br/>}<br/><br/>type withLogger struct {<br/>    logger Logger<br/>}<br/><br/>func (o withLogger) applyServer(s *Server) {<br/>    s.logger = o.logger<br/>}<br/><br/>func (o withLogger) applyClient(c *Client) {<br/>    c.logger = o.logger<br/>}<br/><br/>NewServer(":8080", WithLogger(logger))<br/>NewClient("http://localhost:8080", WithLogger(logger))</span></pre><h1 id="d7bd" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">摘要</h1><p id="dbc1" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">Functional options是一种功能强大的模式，可以用几十个选项来创建干净的(可扩展的)API。虽然这比维护一个简单的配置结构要多一点工作，但是它提供了更多的灵活性，并且比其他选择产生了更干净的API。</p><h1 id="1f48" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">进一步阅读</h1><div class="ni nj gp gr nk nl"><a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">友好API的功能选项</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">下面是我今年在dotGo上发表的演讲文本，友好API的功能选项。它…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">dave.cheney.net</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz kp nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">自指函数与选项设计</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">我一直在尝试找到一种好的方法来处理我正在编写的Go包中的设置选项。上的选项…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">commandcenter.blogspot.com</p></div></div><div class="nu l"><div class="oa l nw nx ny nu nz kp nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a href="https://www.sohamkamani.com/blog/golang/options-pattern/" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">Go中的函数选项:在Golang中实现选项模式</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">这篇文章讨论了Go中有哪些功能选项，以及我们如何使用选项模式来实现它们…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">www.sohamkamani.com</p></div></div></div></a></div><div class="ni nj gp gr nk nl"><a href="https://www.calhoun.io/using-functional-options-instead-of-method-chaining-in-go/" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">在Go - Calhoun.io中使用函数选项代替方法链</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">在Java中，使用方法链(也称为构建器模式)来构造库是很常见的。</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">www.calhoun.io</p></div></div><div class="nu l"><div class="ob l nw nx ny nu nz kp nl"/></div></div></a></div></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="ad6a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">原载于</em><a class="ae lo" href="https://sagikazarmark.hu/blog/functional-options-on-steroids/" rel="noopener ugc nofollow" target="_blank"><em class="ln">https://sagikazarmark . Hu</em></a><em class="ln">。</em></p></div></div>    
</body>
</html>