<html>
<head>
<title>A glimpse into the mind of a JavaScript framework author</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一瞥JavaScript框架作者的想法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-glimpse-into-the-mind-of-a-javascript-framework-author-689216a8619c?source=collection_archive---------5-----------------------#2019-11-19">https://levelup.gitconnected.com/a-glimpse-into-the-mind-of-a-javascript-framework-author-689216a8619c?source=collection_archive---------5-----------------------#2019-11-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d5a02d3f78d0b44b3ce10571d34098aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D-YK7sovWhwegd3nloJi3g.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">马库斯·斯皮斯克在<a class="ae kf" href="https://unsplash.com/s/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="0289" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你曾经读过一个流行的库的源代码，并且遇到过解释代码做什么的注释吗？有时给出的解释很简单，但有时却让你摸不着头脑。最近我有一个这样的时刻，在挠头之后，它让我对开源工具的努力有了更深的理解，并激励我写了这篇文章。</p><p id="231c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在调查前端框架如何将事件处理程序附加到DOM元素时，我遇到了问题中的代码。在过去的几个月里，我一直在重建前端堆栈的不同部分，以此来提高我的知识，其中一部分涉及到创建一个基于虚拟DOM范式的UI框架。</p><p id="f203" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我看到的代码来自<a class="ae kf" href="https://mithril.js.org" rel="noopener ugc nofollow" target="_blank"> Mithril </a>。在内部，它通过创建一个对象并将其作为第二个参数传递给<code class="fe le lf lg lh b">document.addEventListener</code>方法来注册DOM元素上的事件。相关的源代码是:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="9a93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第三点:"<em class="lo">对象不从</em> <code class="fe le lf lg lh b"><em class="lo">Object.prototype</em></code> <em class="lo">继承，以避免任何潜在的干扰(如setters)。</em>“是什么引起了我的注意。我通过秘银<a class="ae kf" href="https://gitter.im/mithriljs/mithril.js/archives/2019/09/04?at=5d6fce6c11f374371a0d6a8b" rel="noopener ugc nofollow" target="_blank"> Gitter </a>聊天联系了秘银核心维护者<a class="ae kf" href="https://mobile.twitter.com/isiahmeadows1" rel="noopener ugc nofollow" target="_blank"> Isiah Meadows </a>，他的解释是我们接下来要讨论的。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="396e" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">防范流氓第三方代码</h1><p id="65ae" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">想象一下，<code class="fe le lf lg lh b">EventDict</code>的原型不是继承自<code class="fe le lf lg lh b">null</code>，而是<code class="fe le lf lg lh b">Object.prototype</code>。然后，一个Mithril用户编写以下代码或使用一个库来执行以下操作:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="43a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，应用程序编写如下:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="396b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果提交表单，控制台将记录<code class="fe le lf lg lh b">I am on the setter</code>而不是<code class="fe le lf lg lh b">I am on the form</code>。getter和setter函数的内容并不重要，但是它们的存在意味着<code class="fe le lf lg lh b">onsubmit</code>事件处理程序并没有像预期的那样在表单上注册。</p><p id="6988" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为当事件被触发时，<code class="fe le lf lg lh b">EventDict.prototype.handleEvent</code>方法被执行，这一行<code class="fe le lf lg lh b">var handler = this["on" + ev.type]</code>返回<code class="fe le lf lg lh b">Object.prototype</code>上的<code class="fe le lf lg lh b">onsubmit</code>函数，而不是表单元素上指定的函数。</p><p id="551a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当Mithril运行在一个<code class="fe le lf lg lh b">Object.prototype</code>以更简单的方式扩展的环境中时，上面的问题也会出现，如下所示:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="b7df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">应用程序代码是:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="2dc4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本例中，我们将<code class="fe le lf lg lh b">onreset</code>事件添加到了表单中。为了理解它带来的问题，我们首先要看看Mithril的<code class="fe le lf lg lh b">updateEvent</code>方法。每当在DOM元素上设置或移除<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Event_handlers" rel="noopener ugc nofollow" target="_blank"> on-event处理程序</a>时，该方法就会运行。</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="b141" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像Mithril这样的虚拟DOM框架将像<code class="fe le lf lg lh b">m('button', { type: 'reset'}, 'Reset')</code>这样的调用转化为表示给定DOM元素的对象。在Mithril中，这些对象被称为<code class="fe le lf lg lh b">vnodes</code>(作为比较，在React中这些对象被称为<code class="fe le lf lg lh b">fibers</code>。我已经在这里写了关于他们的文章。<code class="fe le lf lg lh b">key</code>是事件名称，<code class="fe le lf lg lh b">value</code>是被分配来处理该事件的任何对象或函数。</p><p id="6bcb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当执行代码时，表单元素的<code class="fe le lf lg lh b">vnode</code>对象被传递给<code class="fe le lf lg lh b">updateEvent</code>函数。在函数内部，<code class="fe le lf lg lh b">else if</code>子句运行，因为<code class="fe le lf lg lh b">vnode</code>的<code class="fe le lf lg lh b">events</code>属性是<code class="fe le lf lg lh b">undefined</code>。一旦函数执行完毕，<code class="fe le lf lg lh b">vnode</code>对象将如下所示:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="3131" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">属性<code class="fe le lf lg lh b">events</code>被赋予了一个<code class="fe le lf lg lh b">EventDict</code>实例，然后这个实例被赋予了一个对<code class="fe le lf lg lh b">onreset</code>函数的引用作为它的属性之一。此外，表单DOM元素有一个针对<code class="fe le lf lg lh b">onreset</code>事件的事件监听器。到目前为止，一切顺利。</p><p id="cae1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">updateEvent</code>为DOM元素上出现的每个事件运行。第二次调用时，它被作为<code class="fe le lf lg lh b">key</code>参数传递给<code class="fe le lf lg lh b">onsubmit</code>。然而，这一次，第一个<code class="fe le lf lg lh b">if</code>子句运行，因为<code class="fe le lf lg lh b">vnode.events</code>不再是<code class="fe le lf lg lh b">null</code>。</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="2330" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个<code class="fe le lf lg lh b">if</code>语句中还有另外两个<code class="fe le lf lg lh b">if</code>语句。第一个被跳过，因为<code class="fe le lf lg lh b">vnode.events[key]</code>不等于<code class="fe le lf lg lh b">value</code>，在本例中是<code class="fe le lf lg lh b">onsubmit</code>函数。其实<code class="fe le lf lg lh b">vnode.events[key]</code>的值就是<code class="fe le lf lg lh b">1</code>。为什么？请记住，这段代码运行的环境是有人编写的:<code class="fe le lf lg lh b">Object.prototype.onsubmit = 1</code>。由于表单<code class="fe le lf lg lh b">EventDict</code>实例还没有<code class="fe le lf lg lh b">onsubmit</code>属性，并且它继承自<code class="fe le lf lg lh b">Object.prototype</code>，JavaScript引擎将沿着原型链向上，发现<code class="fe le lf lg lh b">onsubmit</code>存在于<code class="fe le lf lg lh b">Object.prototype</code>上。</p><p id="e178" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后下一个<code class="fe le lf lg lh b">if</code>子句检查<code class="fe le lf lg lh b">value</code>是否有一个函数或对象。这个检查通过了，但是关键的是，<code class="fe le lf lg lh b">onsubmit</code>事件的事件监听器没有附加到表单元素上，因为<code class="fe le lf lg lh b">vnode.events[key]</code>不是它应该的<code class="fe le lf lg lh b">null</code>，它的值是<code class="fe le lf lg lh b">1</code>。下一行将<code class="fe le lf lg lh b">onsubmit</code>属性和相关函数添加到表单元素<code class="fe le lf lg lh b">vnode</code>的<code class="fe le lf lg lh b">EventDict</code>实例中。</p><p id="25eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就像第一个例子中使用<code class="fe le lf lg lh b">Object.defineProperty</code>将<code class="fe le lf lg lh b">onsubmit</code>属性添加到<code class="fe le lf lg lh b">Object.prototype</code>一样，当表单被提交时，它不会像开发人员预期的那样运行。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="ebb6" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">摘要</h1><p id="e895" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">上面的两个例子看起来都很奇怪，但这是防御性的编码框架和库作者必须要做的事情。使用构造函数方法创建一个不从<code class="fe le lf lg lh b">null</code>继承的新对象意味着新创建的对象受<code class="fe le lf lg lh b">Object.prototype</code>添加的任何内容的支配。</p></div></div>    
</body>
</html>