<html>
<head>
<title>Table Relationships in Sequelize</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">序列中的表关系</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/table-relationships-in-sequelize-2e2533580c2a?source=collection_archive---------2-----------------------#2020-06-29">https://levelup.gitconnected.com/table-relationships-in-sequelize-2e2533580c2a?source=collection_archive---------2-----------------------#2020-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="aa11" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">设置外键并制作ORM连接表</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3d3e2251c472b5b1f3a5dcc73e035090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_Mt6Y5eR-2i7eZgh"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@abelycosta?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿贝尔·Y·科斯塔</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="b7e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开始使用Sequelize可能会有点令人生畏。但是对于那些更熟悉JavaScript和面向对象编程的人来说，它也可以使使用数据库变得更加容易。在这篇文章中，我将关注这个API的关系映射方面:设置外键和创建连接表。</p><h2 id="0757" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">介绍</h2><p id="f038" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Sequelize是一个节点包，它在服务器或后端代码与SQL数据库(MySQL、SQLite、PostgreSQL或MSSQL)之间执行对象关系映射(ORM)。ORM是什么？它基本上使用面向对象的代码在不兼容的数据类型系统(即SQL和JavaScript)之间转换数据。使用Sequelize，我们可以使用JavaScript创建数据库和表，以及对数据库的查询。</p><h2 id="3991" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">模型</h2><p id="19a8" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Sequelize不是创建表，而是使用模型来创建表。JavaScript中将使用一个模型来存储属性(即表中的字段或列)，以及它与其他模型/表的关联和它查询数据库的方法。类似于在SQL中创建表，当您定义一个模型时，您还将定义每个键/列的数据类型。</p><p id="dfb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，让我们想象一个数据库，其中有用户、项目和一个连接表，用于按项目跟踪所有用户。在我们分配它们之间的关系之前，我们需要制作模型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="05ff" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">联合</h2><p id="e0f0" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在SQL中，我们设置外键来连接表，并且通常建立表之间的关系——数据库不知道您的表和它们的键之间的关系是什么类型。而在Sequelize中，我们实际上可以声明两个表之间的关联类型。</p><p id="38b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例数据库中有两种类型的关系:</p><ul class=""><li id="f9e2" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">每个项目都有一个项目经理(用户):一对一的关系</li><li id="96ac" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">每个项目可以有许多成员(用户),每个用户可以有许多项目:多对多关系</li></ul><p id="2629" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在数据库中建立模型之后，可以声明关联。这里有三种顺序关联类型:<code class="fe nh ni nj nk b">belongsTo</code>、<code class="fe nh ni nj nk b">hasMany</code>和<code class="fe nh ni nj nk b">belongsToMany</code>。下面是它们的使用方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="a80f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nh ni nj nk b">belongsTo</code> &amp; <code class="fe nh ni nj nk b">hasMany</code>关联设置了多对一的关系。每个项目都有一个项目经理，那个项目<em class="ms">属于那个用户</em>，而那个用户<em class="ms">可以有许多</em>项目。Sequelize将知道用户的外键将在项目表上设置。</p><p id="1ef5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，外键的列标题可以设置为这些方法中的第二个参数。这一步不是必需的——Sequelize将自动命名外键<code class="fe nh ni nj nk b">user_id </code>或<code class="fe nh ni nj nk b">userId</code>，这取决于您是否启用了camelCase或snake_case(参见文档中的<a class="ae kv" href="https://sequelize.org/master/manual/naming-strategies.html" rel="noopener ugc nofollow" target="_blank">命名策略</a>)。在我们的例子中，我们希望首先拥有<code class="fe nh ni nj nk b">id</code>,并注意这个用户是项目经理。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="5b77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于设置多对多关联和创建连接表，需要在两个模型上使用<code class="fe nh ni nj nk b">belongsToMany</code>。每个用户可以<em class="ms">属于多个</em>项目，每个项目可以<em class="ms">属于多个</em>用户。这些方法调用中的每一个都将在结果连接表中设置外键。注意，<code class="fe nh ni nj nk b">through</code>关键字在这里设置了连接表的名称。您可以在不创建模型的情况下创建多对多连接表，但是，如果您希望将数据存储在默认id列之外的列中，模型会很有用(请参见模型部分中的上一个示例)。</p><p id="cc6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Sequelize中还可以进行其他的关联，比如一对一，我在这里没有涉及到。在文档中阅读更多关于可以在Sequelize中设置的所有<a class="ae kv" href="https://sequelize.org/master/manual/assocs.html" rel="noopener ugc nofollow" target="_blank">关联</a>的信息。</p><h2 id="b99d" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">方法</h2><p id="9302" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Sequelize的模型和关联的强大之处在于它们提供了查询数据库的方法。下面我有两个例子，一个用于添加项目，另一个用于在连接表中链接项目和用户。</p><p id="eb96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(注意，这里我使用的是async/await——sequel ize方法是异步的并返回承诺，您可以使用ES6承诺或async/await来处理它们。)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="bc3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第一个例子<code class="fe nh ni nj nk b">addProject</code>中，我们使用一些基本的模型方法在表中查找和创建记录。一旦我们找到了用户并创建了新项目，我们就需要真正地<em class="ms">设置</em>外键。先前建立的关联为我们的模型生成了<em class="ms">获取器</em>和<em class="ms">设置器</em>。这里，我们使用自定义设置器<code class="fe nh ni nj nk b">setUser</code>，将用户的id指定为新项目的外键。注意，从数据库返回的整个记录需要传递到这个方法中，以分配外键。</p><p id="a151" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第二个例子<code class="fe nh ni nj nk b">joinUserProject</code>中，我们正在创建连接表。我们需要检索这两个记录，并使用另一个定制生成的方法<code class="fe nh ni nj nk b">addUser</code>来连接它们。</p><p id="b3e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为所有这些关联生成自定义方法。我只展示了两个，<code class="fe nh ni nj nk b">set</code>和<code class="fe nh ni nj nk b">add</code>。例如，项目和用户之间的<code class="fe nh ni nj nk b">hasMany</code>关联会生成以下特殊方法:</p><ul class=""><li id="cdd8" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated"><code class="fe nh ni nj nk b">project.getUsers()</code></li><li id="3d36" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><code class="fe nh ni nj nk b">project.countUsers()</code></li><li id="6b14" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><code class="fe nh ni nj nk b">project.hasUser()</code></li><li id="f4b6" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><code class="fe nh ni nj nk b">project.hasUsers()</code></li><li id="8e1e" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><code class="fe nh ni nj nk b">project.setUsers()</code></li><li id="f4ef" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><code class="fe nh ni nj nk b">project.addUser()</code></li><li id="efe9" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><code class="fe nh ni nj nk b">project.addUsers()</code></li><li id="6af9" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><code class="fe nh ni nj nk b">project.removeUser()</code></li><li id="bd25" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><code class="fe nh ni nj nk b">project.removeUsers()</code></li><li id="fd4d" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><code class="fe nh ni nj nk b">project.createUser()</code></li></ul><p id="6e43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在文档中阅读更多关于<a class="ae kv" href="https://sequelize.org/master/manual/assocs.html#special-methods-mixins-added-to-instances" rel="noopener ugc nofollow" target="_blank">序列特殊方法</a>的信息。</p><h2 id="0a3b" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">要使用哪个关联</h2><p id="1e62" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">很难确定要建立哪种关联，但是有一些策略可以帮助你确定这一点。首先是从目标和源模型的角度来考虑。源是外键来自的地方，目标是外键将存在的模型或表:</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="7ded" class="ls lt iq nk b gy np nq l nr ns">sourceModel.hasOne(targetModel)<br/>sourceModel.hasMany(targetModel)<br/>targetModel.belongsTo(sourceTable)</span></pre><p id="1711" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面这段有用的代码片段来自<a class="ae kv" href="https://lorenstewart.me/2016/09/12/sequelize-table-associations-joins/" rel="noopener ugc nofollow" target="_blank"> Loren Stewart关于同一主题的博客</a>，绝对值得一试。</p><p id="e155" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个策略是尝试两种方法，然后在数据库中检查结果。如果你没有在正确的地方看到外键，你很可能把它弄反了！这里有更多关于为什么关联是成对定义的，以及如何确定使用哪一个:<a class="ae kv" href="https://sequelize.org/master/manual/assocs.html#why-associations-are-defined-in-pairs-" rel="noopener ugc nofollow" target="_blank">为什么关联是成对定义的？</a></p><h2 id="4862" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">结论</h2><p id="a797" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在设置和使用序列式关联方面，还有很多需要探索的地方。在这篇文章中，我介绍了Sequelize对象关系映射的基础——使用这个ORM设置外键，在SQL数据库中创建连接表，并使用这些关联创建的一些特殊方法。Sequelize提供了一种关系数据库查询方法，对于熟悉面向对象编程的人来说，这种方法可以使设置和处理数据变得更加容易和快速。</p></div></div>    
</body>
</html>