<html>
<head>
<title>JavaScript Problems — Elements, Strings, and Loops</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript问题—元素、字符串和循环</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-problems-elements-strings-and-loops-f38ca0b82a7c?source=collection_archive---------11-----------------------#2020-07-06">https://levelup.gitconnected.com/javascript-problems-elements-strings-and-loops-f38ca0b82a7c?source=collection_archive---------11-----------------------#2020-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8d32dc13aa0dd1d9e880391754d37755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d7aX3uLY3I433ZfL"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@rudol?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">rafarudol</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="f9f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何类型的应用程序一样，当我们编写JavaScript应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些常见JavaScript问题的解决方案</p><h1 id="8903" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">按ID删除元素</h1><p id="042a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过ID删除一个元素。</p><p id="209e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有几种方法可以做到这一点。例如，我们可以将元素的<code class="fe mh mi mj mk b">outerHTML</code>属性设置为空字符串:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a181" class="mt lf it mk b gy mu mv l mw mx">document.getElementById("element-id").outerHTML = "";</span></pre><p id="5840" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以获得元素的父节点。</p><p id="0d20" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们可以在父元素上调用<code class="fe mh mi mj mk b">removeChild</code>并把我们想要移除的元素作为参数传入时:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8b3d" class="mt lf it mk b gy mu mv l mw mx">const element = document.getElementById("element-id");<br/>element.parentNode.removeChild(element);</span></pre><h1 id="2dfb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">偏移HTML锚点以调整另一个元素</h1><p id="58e3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以让一个元素的<code class="fe mh mi mj mk b">position</code>属性成为相对属性，然后我们可以把它移动到我们喜欢的任何地方。</p><p id="43af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有一个<code class="fe mh mi mj mk b">a</code>元素:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="bc3e" class="mt lf it mk b gy mu mv l mw mx">&lt;a class="anchor"&gt;&lt;/a&gt;</span></pre><p id="f102" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以通过书写来移动它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="074d" class="mt lf it mk b gy mu mv l mw mx">a.anchor {<br/>  display: block;<br/>  position: relative;<br/>  top: -250px;<br/>  visibility: hidden;<br/>}</span></pre><p id="c633" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过将<code class="fe mh mi mj mk b">position</code>设置为<code class="fe mh mi mj mk b">relative</code>，我们可以将锚元素移动到我们喜欢的任何地方。</p><h1 id="5cf1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">比较JavaScript对象</h1><p id="2b6e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用几种方法比较物体。</p><p id="cb49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，我们不能使用比较运算符来比较它们，因为只有当两个对象引用内存中的同一个对象时，它们才被认为是相等的。</p><p id="eade" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">Object.is</code>也是如此。</p><p id="266b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，两个都不能用。</p><p id="99ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，比较两个对象的一种方法是使用<code class="fe mh mi mj mk b">JSON.stringify</code>方法。</p><p id="5195" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们的对象中只有原始值或其他对象，那么我们可以使用它。</p><p id="3ea8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2403" class="mt lf it mk b gy mu mv l mw mx">JSON.stringify(obj1) === JSON.stringify(obj2)</span></pre><p id="a019" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">属性的顺序对此很重要。</p><p id="d503" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果它们的顺序不同，那么它们被认为是不同的。</p><p id="d258" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c23e" class="mt lf it mk b gy mu mv l mw mx">const obj1 = { a: 1, b: 2 };<br/>const obj2 = { b: 2, a: 1 };</span></pre><p id="15f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后它们会按照这个顺序被字符串化，所以它们会是不同的字符串。</p><p id="27d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以使用Lodash来比较它们。它有<code class="fe mh mi mj mk b">isEqual</code>方法来比较它们。</p><p id="3c6c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a5ad" class="mt lf it mk b gy mu mv l mw mx">_.isEqual(obj1 , obj2)</span></pre><p id="512f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">来比较它们。</p><h1 id="7136" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从下拉列表中获取选定的选项</h1><p id="dd91" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用jQuery的<code class="fe mh mi mj mk b">text</code>方法来获取选中的值。</p><p id="ba90" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e155" class="mt lf it mk b gy mu mv l mw mx">const selected = $('#dropdown').find(":selected").text();</span></pre><p id="51f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设select元素的ID为<code class="fe mh mi mj mk b">dropdown</code>，我们可以使用<code class="fe mh mi mj mk b">:selected</code>属性来获取选中的项目。</p><p id="8978" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以使用<code class="fe mh mi mj mk b">text</code>方法来获得实际选择的值。</p><p id="1371" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">val()</code>不起作用，因为点击一个选项不会改变下拉列表的值。</p><p id="4d13" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只添加了<code class="fe mh mi mj mk b">:selected</code>属性。</p><h1 id="57cd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Async和Await和forEach</h1><p id="0c97" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不能将<code class="fe mh mi mj mk b">forEach</code>与<code class="fe mh mi mj mk b">async</code>和<code class="fe mh mi mj mk b">await</code>一起用于并行或顺序处理事情。</p><p id="5416" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想按顺序运行多个承诺，我们可以使用for-of循环:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="bdd3" class="mt lf it mk b gy mu mv l mw mx">const printFiles = async () =&gt; {<br/>  const files = await getFilePaths();</span><span id="7d91" class="mt lf it mk b gy my mv l mw mx">  for (const file of files) {<br/>    const contents = await fs.readFile(file, 'utf8');<br/>    console.log(contents);<br/>  }<br/>}</span></pre><p id="a841" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">for-of循环将按顺序运行承诺。</p><p id="a739" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">自ES2018年以来，还推出了“等待”。</p><p id="3660" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7902" class="mt lf it mk b gy mu mv l mw mx">const printFiles = async () {<br/>  const files = await getFilePaths()</span><span id="107a" class="mt lf it mk b gy my mv l mw mx">  for await (const file of fs.readFile(file, 'utf8')) {<br/>    console.log(contents)<br/>  }<br/>}</span></pre><p id="8473" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们都做同样的事情。</p><p id="7f08" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想并行运行承诺，我们可以使用<code class="fe mh mi mj mk b">Promise.all</code>。</p><p id="d3a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c61e" class="mt lf it mk b gy mu mv l mw mx">const printFiles = async () =&gt; {<br/>  const files = await getFilePaths();<br/>  const contents = <!-- -->await Promise.all(files.map((file) =&gt; fs.readFile(file, 'utf8')));<br/>  console.log(contents);<br/>}</span></pre><p id="f9a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将<code class="fe mh mi mj mk b">files</code>条目映射到承诺，以便我们可以与<code class="fe mh mi mj mk b">Promise.all</code>并行运行它们。</p><h1 id="aa25" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">检查字符串是否以给定的子字符串结尾</h1><p id="e60e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">string有<code class="fe mh mi mj mk b">endsWith</code>方法来检查一个字符串是否以给定的子字符串结尾。</p><p id="a743" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="19cb" class="mt lf it mk b gy mu mv l mw mx">const endWithWord = str.endsWith("world");</span></pre><p id="4134" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只需用想要检查的子字符串调用<code class="fe mh mi mj mk b">endsWith</code>。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/7e5798c1158a1636c85043aa25b5b9ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j-N0rKBXlxkxlE_M"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@behz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Behzad Ghaffarian </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="9b79" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="b81f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">异步函数不能与<code class="fe mh mi mj mk b">forEach</code>一起工作。相反，我们可以使用for-of、for-await-of或<code class="fe mh mi mj mk b">Promise.all</code>来运行多个承诺。</p><p id="8129" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">endsWith</code>来检查一个字符串是否以给定的字符串结尾。</p><p id="860c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要从下拉列表中获取选中的项目，我们可以使用<code class="fe mh mi mj mk b">:selected</code> CSS属性。</p><p id="acda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过ID移除一个元素，方法是获取它的父元素，然后在我们想要移除的元素上调用<code class="fe mh mi mj mk b">removeChild</code>。</p></div></div>    
</body>
</html>