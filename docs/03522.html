<html>
<head>
<title>Learning C++: Function Templates and the STL Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习C++:函数模板和STL第2部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learlearning-c-function-templates-and-the-stl-part-2-19182d2c0da2?source=collection_archive---------15-----------------------#2020-05-13">https://levelup.gitconnected.com/learlearning-c-function-templates-and-the-stl-part-2-19182d2c0da2?source=collection_archive---------15-----------------------#2020-05-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/eccb249765b3caf032aeceda739e6a60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VSdLLrfLyg60i1hY"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@killerfvith?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">黄福生</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="612a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我的上一篇文章中，我讨论了什么是函数模板以及如何使用它们。在第二篇文章中，我将继续讨论如何使用默认的模板参数，如何重载函数模板，以及一些其他的函数模板技术。本文中的一些例子摘自Vandevoore、Josuittis和Gregor的书<em class="le"> C++模板:完全指南</em>。</p><h1 id="27a4" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">默认模板参数</h1><p id="9083" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">默认模板参数是模板参数的默认<em class="le">值</em>。可以使用这种技术来声明和定义这样的变量(给定最大值函数的正确定义):</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3f44" class="mr lg it mn b gy ms mt l mu mv">auto max_value = maximum(3.14159, 3);</span></pre><p id="e3c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实现默认模板参数的一种方法是使用<code class="fe mw mx my mn b">common_type</code>来定义返回类型参数。这个定义是这样的:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="e68e" class="mr lg it mn b gy ms mt l mu mv">template &lt;typename T1, typename T2,<br/>  typename RT = common_type_t&lt;T1, T2&gt;&gt;<br/>RT maximum(T1 val1, T2 val2) {<br/>  return val1 &lt; val2 ? val2 : val1;<br/>}</span></pre><p id="dd47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个测试程序及其输出，用于演示实际运行的功能:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="ac0e" class="mr lg it mn b gy ms mt l mu mv">int main()<br/>{<br/>  int num = 3;<br/>  double dnum = 3.14159;<br/>  auto maxVal = maximum(num, dnum);<br/>  cout &lt;&lt; "The largest value of 3 and 3.14159 is: "<br/>       &lt;&lt; maxVal &lt;&lt; endl;<br/>  return 0;<br/>}</span><span id="cc6c" class="mr lg it mn b gy mz mt l mu mv">The largest value of 3 and 3.14159 is 3.14159</span></pre><p id="869e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，您总是可以显式指定返回类型:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="f2f4" class="mr lg it mn b gy ms mt l mu mv">int main()<br/>{<br/>  int num = 3;<br/>  double dnum = 3.14159;<br/>  auto maxVal = maximum&lt;int, double, double&gt;(num, dnum);<br/>  cout &lt;&lt; "The largest value of 3 and 3.14159 is: "<br/>       &lt;&lt; maxVal &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="5a59" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个版本显然要求显式声明三种数据类型，这在大多数情况下并不是首选。</p><p id="45fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">获得默认模板参数的另一种方法是将默认值放在模板参数列表中，如下所示:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="99a2" class="mr lg it mn b gy ms mt l mu mv">template &lt;typename RT = double, typename T1, typename T2&gt;<br/>RT maximum(T1 val1, T2 val2) {<br/>  return val1 &lt; val2 ? val2 : val1;<br/>}</span></pre><p id="2736" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当明确存在真正的“默认”数据类型时，此选项很有意义，例如当您将整数值与浮点值组合在一起时，将浮点值作为默认值是可以接受的，因为整数将被扩大为浮点值。情况不会总是这样。</p><p id="f4ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不过，要完成我们在这里试图实现的目标，最好的方法是让编译器使用<code class="fe mw mx my mn b">decltype</code>来推断返回类型。我在上一篇关于函数模板的文章中已经提到了这一点，但为了完整起见，这里还是给出了定义:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="09b1" class="mr lg it mn b gy ms mt l mu mv">template &lt;typename T1, typename T2&gt;<br/>auto maximum(T1 val1, T2 val2) -&gt;<br/>  decltype(val1 &lt; val2 ? val2 : val1) {<br/>  return val1 &lt; val2 ? val2 : val1;<br/>}</span></pre><h1 id="624e" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">重载函数模板</h1><p id="9001" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">模板化函数可以像普通函数一样重载。事实上，一个常规函数可以用一个模板函数重载，就像这个交换函数的例子一样:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3592" class="mr lg it mn b gy ms mt l mu mv">void my_swap(int &amp;val1, int &amp;val2) {<br/>  int temp = val1;<br/>  val1 = val2;<br/>  val2 = temp;<br/>}</span></pre><p id="c8b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个函数可以用一个模板重载:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="4432" class="mr lg it mn b gy ms mt l mu mv">void my_swap(int &amp;val1, int &amp;val2) {<br/>  int temp = val1;<br/>  val1 = val2;<br/>  val2 = temp;<br/>}</span><span id="44c0" class="mr lg it mn b gy mz mt l mu mv">template &lt;typename T1, typename T2&gt;<br/>  void my_swap(T1 &amp;val1, T2 &amp;val2) {<br/>  T temp = val1;<br/>  val1 = val2;  <br/>  val2 = temp;<br/>}</span></pre><p id="0aab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个演示这两个功能的程序:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="eeb4" class="mr lg it mn b gy ms mt l mu mv">int main()<br/>{<br/>  int inum1 = 2;<br/>  int inum2 = 3;<br/>  cout &lt;&lt; "inum1: " &lt;&lt; inum1 &lt;&lt; ", inum2: " &lt;&lt; inum2 &lt;&lt; endl;<br/>  my_swap(inum1, inum2);<br/>  cout &lt;&lt; "inum1: " &lt;&lt; inum1 &lt;&lt; ", inum2: " &lt;&lt; inum2 &lt;&lt; endl;<br/>  double dnum1 = 2.11;<br/>  double dnum2 = 3.33;<br/>  cout &lt;&lt; "dnum1: " &lt;&lt; dnum1 &lt;&lt; ", dnum2: " &lt;&lt; dnum2 &lt;&lt; endl;<br/>  my_swap(dnum1, dnum2);<br/>  cout &lt;&lt; "dnum1: " &lt;&lt; dnum1 &lt;&lt; ", dnum2: " &lt;&lt; dnum2 &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="c4e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="7437" class="mr lg it mn b gy ms mt l mu mv">inum1: 2, inum2: 3<br/>inum1: 3, inum2: 2<br/>dnum1: 2.11, dnum2: 3.33<br/>dnum1: 3.33, dnum2: 2.11</span></pre><p id="4950" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，除了说明函数可以用函数模板重载之外，没有理由使用函数的int版本。</p><p id="96e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个更复杂的例子是用另一个函数模板重载一个函数模板。在下面的例子中，我们重载了一个add函数，这样在一个版本中，可以在运行时提供数据类型，而在另一个版本中，编译器可以推导出数据类型。下面是代码、测试程序和该程序的输出:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="76f9" class="mr lg it mn b gy ms mt l mu mv">template &lt;typename T&gt;<br/>T add(T val1, T val2) {<br/>  return val1 + val2;<br/>}</span><span id="736d" class="mr lg it mn b gy mz mt l mu mv">template &lt;typename T1, typename T2&gt;<br/>auto add(T1 val1, T2 val2) -&gt; decltype(val1 + val2) {<br/>  return val1 + val2;<br/>}</span><span id="ea48" class="mr lg it mn b gy mz mt l mu mv">int main()<br/>{<br/>  int num1 = 2, num2 = 3;<br/>  cout &lt;&lt; "Sum: " &lt;&lt; add&lt;int&gt;(num1, num2) &lt;&lt; endl;<br/>  double dnum1 = 2.1, dnum2 = 3.2;<br/>  cout &lt;&lt; "Sum: " &lt;&lt; add&lt;double&gt;(dnum1, dnum2) &lt;&lt; endl;<br/>  cout &lt;&lt; "Sum: " &lt;&lt; add(num1, dnum1) &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="7ae8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="97b0" class="mr lg it mn b gy ms mt l mu mv">Sum: 5<br/>Sum: 5.3<br/>Sum: 4.1</span></pre><h1 id="c676" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">非类型函数模板参数</h1><p id="9e48" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">函数模板的参数不一定是类型的占位符，它们也可以是值。下面是一个函数示例，该函数根据通过模板参数传入的数量以及测试程序和输出绘制成绩曲线:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="f9d4" class="mr lg it mn b gy ms mt l mu mv">template &lt;int val, typename T&gt;<br/>T curveGrade(T grade) {<br/>  return grade + val;<br/>}</span><span id="ee9e" class="mr lg it mn b gy mz mt l mu mv">int main()<br/>{<br/>  int igrade = 77;<br/>  cout &lt;&lt; "Not curved: " &lt;&lt; igrade &lt;&lt; ", Curved: "<br/>       &lt;&lt; curveGrade&lt;4, int&gt;(igrade) &lt;&lt; endl;<br/>  double dgrade = 76.25;<br/>  cout &lt;&lt; "Not curved: " &lt;&lt; dgerade &lt;&lt; ", Curved: "<br/>       &lt;&lt; curveGrade&lt;5, double&gt;(dgrade) &lt;&lt; endl;<br/>  return 0;<br/>}</span><span id="01fa" class="mr lg it mn b gy mz mt l mu mv">Not curved: 77, Curved: 81<br/>Not curved: 76.25, Curved: 81.25</span></pre><p id="bcdc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">传递非类型模板函数参数的一个有趣的变化是，它们也可以用来派生函数的返回类型。下面是上面使用<code class="fe mw mx my mn b">curveGrade</code>函数的一个例子:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="6089" class="mr lg it mn b gy ms mt l mu mv">template &lt;typename T, T val = T{}&gt;<br/>T curveGrade(T grade) {<br/>  return grade + val;<br/>}</span><span id="9dc0" class="mr lg it mn b gy mz mt l mu mv">int main()<br/>{<br/>  int igrade = 77;<br/>  cout &lt;&lt; "Not curved: " &lt;&lt; igrade &lt;&lt; ", Curved: "<br/>       &lt;&lt; curveGrade&lt;int, 4&gt;(igrade) &lt;&lt; endl;<br/>  return 0;<br/>}</span><span id="3a6c" class="mr lg it mn b gy mz mt l mu mv">Not curved: 77, Curved: 81</span></pre><p id="3d65" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码片段<code class="fe mw mx my mn b">T val = T{</code> }获取该类型的默认值，并将其赋给<code class="fe mw mx my mn b">val</code>。</p><p id="f483" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你会注意到我在测试程序中没有使用<code class="fe mw mx my mn b"> double </code>。这是因为C++不能从非整数值派生类型。</p><h1 id="fd8f" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">转到类模板</h1><p id="0e54" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">这就结束了我对函数模板的介绍性讨论。在我的下一篇文章中，我将介绍如何用模板定义类，以获得与函数模板相同的泛型。</p><p id="02cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请发送电子邮件提出意见和建议。</p></div></div>    
</body>
</html>