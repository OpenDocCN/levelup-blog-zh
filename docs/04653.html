<html>
<head>
<title>Running DBT in Azure Functions with a Snowflake Backend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用雪花后端在Azure函数中运行DBT</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/running-dbt-in-azure-functions-with-a-snowflake-backend-99d01dff399e?source=collection_archive---------2-----------------------#2020-07-08">https://levelup.gitconnected.com/running-dbt-in-azure-functions-with-a-snowflake-backend-99d01dff399e?source=collection_archive---------2-----------------------#2020-07-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="39bf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在接近实时的场景下运行Azure函数中的DBT</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0cb31a094fa7eb84326d1ce2cc5815b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kfb4hpQEIJHTpnO4"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">泰勒·维克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2693" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> D </span> <strong class="lb iu"> ataOps </strong>实践正在被专注于数据的公司迅速采用，尤其是那些正在迁移到<strong class="lb iu">云数据仓库</strong>的公司。近年来出现了一些支持数据操作的工具，比如<a class="ae ky" href="https://www.getdbt.com/" rel="noopener ugc nofollow" target="_blank">数据构建工具</a>或dbt。dbt由<a class="ae ky" href="https://www.fishtownanalytics.com/" rel="noopener ugc nofollow" target="_blank"> Fishtown Analytics </a>构思和开发，是一个命令行工具，它在<strong class="lb iu"> E </strong> xtract、<strong class="lb iu"> L </strong> oad、<strong class="lb iu">T</strong>transform(<strong class="lb iu">ELT)</strong>管道中运行数据转换。它从<strong class="lb iu"> DevOps </strong>和<strong class="lb iu">软件工程</strong>的世界中借用了一些核心原则，并采用了与大多数数据工程师所习惯的不同的SQL开发方法。</p><p id="d46f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DBT拥有Apache许可证，通常在持续集成和部署(<strong class="lb iu"> CI </strong> / <strong class="lb iu"> CD) </strong>管道中运行，或者从<a class="ae ky" href="https://cloud.getdbt.com/" rel="noopener ugc nofollow" target="_blank"> dbt云</a>运行。后者是该软件的托管版本，由Fishtown Analytics提供，有三个不同的<a class="ae ky" href="https://www.getdbt.com/pricing/" rel="noopener ugc nofollow" target="_blank">定价计划</a>。批处理工作负载，尤其是dbt中常见的分析工作负载，只需要一个CI/CD执行模型。</p><p id="1e0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我最近参与的一个项目中，我们需要在接近实时的场景中使用dbt。该解决方案有一个事件驱动的架构，具有雪花后端和Azure功能来响应事件。挑战在于近乎实时地触发dbt，由另一个函数将消息发送到Azure存储队列。每条消息都包含有关数据转换的信息，这些信息必须在数据加载后立即执行。CI/CD管道在这里是不可能的，因为它更适合批处理。所以我们必须开发一个运行dbt的Azure触发器函数。在接下来的几个段落中，我将通过一步一步的指导告诉你如何去做。</p><p id="5375" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们直入主题吧！</p><h1 id="e6cb" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">让我们从DBT基础开始</h1><p id="f26f" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">我不是数据工程师，但我第一次使用dbt是在一年前，纯粹出于好奇。当时，只有几家公司在使用它，还有来自<a class="ae ky" href="https://youtu.be/2xVjlOMMZFY" rel="noopener ugc nofollow" target="_blank"> Monzo Bank </a>和<a class="ae ky" href="https://youtu.be/bqIBNvA9xjo" rel="noopener ugc nofollow" target="_blank"> Gitlab </a>的几个演示视频。据我所知，Fishtown Analytics在他们的首页上发布了一份公告，宣布了1290万美元的A轮投资，以及一个更大的、令人印象深刻的公司列表，这些公司目前正在使用他们的产品。这表明像这样的DataOps工具被业界采用并成为标准实践的速度有多快。但是它到底是做什么的？</p><p id="1092" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DBT是一个用Python编写的命令行工具，使用SQL、Jinja脚本和宏来表达数据转换。它带有内置的连接器，可以连接到流行的云数据仓库，如雪花、<a class="ae ky" href="https://aws.amazon.com/redshift/" rel="noopener ugc nofollow" target="_blank">红移</a>或<a class="ae ky" href="https://cloud.google.com/bigquery" rel="noopener ugc nofollow" target="_blank">谷歌大查询</a>。数据工程师在由<a class="ae ky" href="https://docs.getdbt.com/tutorial/create-a-project-dbt-cli" rel="noopener ugc nofollow" target="_blank"> dbt CLI命令</a>初始化的结构化项目中开发他们的代码，每个项目由包含所有模型、宏、特别查询、测试等的文件夹组成。乍一看，dbt项目与任何软件项目都很相似。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/c5557743d8b46e5b2bf19d3cf029dd37.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*Df-K0tzFVqG1MdPJbk76cQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图1:VS代码中典型的DBT项目结构。</figcaption></figure><p id="0801" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以将项目设置为针对不同的数据库和模式运行，并使用不同的角色和用户。所有这些都在一个<code class="fe nc nd ne nf b"><strong class="lb iu">profiles.yml</strong></code>文件中进行配置，该文件类似于Node.js开发中的<code class="fe nc nd ne nf b"><strong class="lb iu">package.json</strong></code>。</p><p id="2e90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">dbt的一个常见执行模型是运行一个<a class="ae ky" href="https://medium.com/hashmapinc/doing-devops-for-snowflake-with-dbt-in-azure-db5c6249e721" rel="noopener"> <strong class="lb iu"> Azure DevOps </strong> </a>或<a class="ae ky" href="https://www.youtube.com/watch?v=bqIBNvA9xjo" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Gitlab </strong> </a>管道，首先安装dbt，运行一些测试，然后触发数据转换。dbt命令行提供了一些选项，比如执行特定的模型或者使用标记系统对模型进行分组。这允许我们在特定的表和视图上运行转换，而不影响数据库的其余部分。模型选择是有用的功能，可以在许多用例中使用，比如事件驱动的架构。</p><h2 id="caa8" class="ng mf it bd mg nh ni dn mk nj nk dp mo li nl nm mq lm nn no ms lq np nq mu nr bi translated">模型选择和标记</h2><p id="5b72" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">在深入研究模型选择之前，首先理解什么是模型是很重要的。dbt项目中的模型文件是基本组件，工程师在其中开发他们所有的数据转换。它们混合了<code class="fe nc nd ne nf b"><strong class="lb iu">SELECT</strong></code>语句、Jinja宏和配置参数。当dbt运行模型时，数据库表和视图被刷新或增量更新。配置参数定义了所用模型的类型、数据库模式、标签等等。标签是将一组模型组合在一起的有用机制。例如，您可能有3个与客户订单相关的模型文件。通过一个<code class="fe nc nd ne nf b">tag="CUSTOMER"</code>，您可以运行所有3个模型的转换，并更新3个不同的表，而不必运行单独的脚本或SQL语句。</p><p id="ec3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个模型文件的示例，该文件从原始源中选择客户信息，并将其放入概要文件中定义的目标模式和表中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">示例dbt模型源代码。</figcaption></figure><p id="4fc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，dbt CLI运行models文件夹中的所有模型，但是也可以使用标记选择一个特定的模型或一组模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">从命令行运行dbt。</figcaption></figure><h1 id="d00e" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">用消息触发DBT</h1><p id="5b26" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">微软Azure基础设施支持具有不同类型Azure功能的无服务器计算，这些功能可以由平台上引发的事件或消息以及HTTP请求触发。完全自动化的数据管道可以从这些功能中受益，并使用事件驱动的方法来实现。在这里区分事件和消息是很重要的。事件是条件或状态变化的轻量级通知，其中消息是由诸如Azure函数之类的服务产生的数据。</p><p id="264e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过事件驱动的架构，当数据到达云存储(如Azure Blob容器)时，事件被引发，并通过事件订阅将它们发送到<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/storage/queues/storage-queues-introduction" rel="noopener ugc nofollow" target="_blank"> Azure存储队列</a>。Azure函数一直在监听这个队列，一旦它检索到一个事件，就会根据收到的信息触发一个新的工作负载。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/3d1cc55c9ef925032d3c33ddb42deb9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IU70v76_C-anSa5iosIXUA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图2:当数据进入Blob存储时的操作链。</figcaption></figure><p id="83b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Azure存储队列是一种可靠的机制，用于累积事件和消息，并将它们分派给Azure函数。在某些用例中，可以有多个队列，这允许函数之间相互通信。</p><p id="0cbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的示例中，执行ELT管道加载部分的Azure函数向dbt队列发送一条消息，该队列随后触发特定模型或标签的数据转换。要创建存储队列，我们只需使用Azure门户，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/d646f92687a9e6768a9160e85320707d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZLU7_fiJtt-P1CeKTSAWIA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图3:向存储帐户添加新队列。</figcaption></figure><h1 id="af41" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">创建Azure触发器功能</h1><p id="71b9" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">一旦队列就位，我们继续使用Visual Studio代码和Microsoft Azure Functions扩展创建Azure队列存储触发器函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/64ddaf288605e347a2b216ebf021a847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O4FST7sDTKFXMJQsg8nzMQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图4:创建Azure队列存储触发器函数。</figcaption></figure><p id="a150" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦创建了Azure函数，我们就连接到我们的函数将监听新消息的队列中。此时，项目应该有一个处理传入事件的<code class="fe nc nd ne nf b"><strong class="lb iu">main</strong></code>函数和一个具有触发器绑定的<code class="fe nc nd ne nf b"><strong class="lb iu">function.json</strong></code>，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/0ff4e06c6178963383b295bd44209032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c96gubUtRYjlhlju1ILmhg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图5:监听特定存储队列的功能设置。</figcaption></figure><h1 id="2f4c" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">在Azure函数中添加DBT项目</h1><p id="11a1" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">通常，团队为他们的dbt项目拥有单独的存储库。我们在这里想要实现的是允许dbt模型在我们创建的Azure函数中运行。一种方法是将dbt项目作为<code class="fe nc nd ne nf b"><strong class="lb iu">git submodule</strong></code>添加到Azure Function项目中。这样，数据工程团队对dbt项目所做的任何更改都会保持同步，并且函数中运行的所有模型都是最新的。这里我使用的是由Fishtown Analytics创建的演示库<a class="ae ky" href="https://github.com/fishtown-analytics/jaffle_shop/tree/38707ee7273c1d6d5a0cd5ec487a6c632ec6a83b" rel="noopener ugc nofollow" target="_blank"> jaffle_shop </a>项目。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/25d4192c4aacffb0e329382c018dd7d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*BJh2iOESrLf9ofH7Vt72Og.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图6:添加jaffle_shop作为git子模块</figcaption></figure><p id="b445" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，还没有针对dbt的Python API，所以运行它最健壮的方法是创建一个<code class="fe nc nd ne nf b"><strong class="lb iu">subprocess Popen</strong></code>包装器。只需要一个简单的runner类，以及一个接受要使用的模型和标签作为参数的方法。下面是<code class="fe nc nd ne nf b"><strong class="lb iu">DBTRunner</strong></code>类和<code class="fe nc nd ne nf b"><strong class="lb iu">exec_dbt</strong></code>方法的一个片段，该方法使用位于我们项目根的<code class="fe nc nd ne nf b"><strong class="lb iu">profiles.yml</strong></code>作为执行配置文件。您可以在这里找到函数<a class="ae ky" href="https://github.com/dtraskas/funcapp-dbt" rel="noopener ugc nofollow" target="_blank">的其余源代码。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">dbt Runner类的部分实现。</figcaption></figure><p id="e8f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">概要文件包含运行dbt时要使用的数据库和模式的连接信息。所有这些参数都可以作为环境变量传递，并以这种方式定义，这样它们就不会暴露出来。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">带有目标数据库参数的profiles.yml文件。</figcaption></figure><p id="e6e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个Azure函数都包含应用程序设置，这些设置作为环境变量传递给我们的代码，并最终替换上面看到的变量。触发器函数现在已经准备好处理传入的消息并运行dbt模型。</p><h1 id="7541" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">设置Azure功能部署</h1><p id="0f84" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">当dbt运行时，它生成日志信息并将代码编译成目标SQL，这将在雪花或我们选择的任何其他数据库中执行。当在容器环境(比如Azure函数)中运行dbt时，这是一个挑战，因为您会遇到权限问题，这会阻止模型的执行并在日志中生成错误。</p><p id="fb86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DBT项目包含一个<code class="fe nc nd ne nf b"><strong class="lb iu">dbt_project.yml</strong></code>文件，其中有所有必要路径的定义。在设置任何部署之前，使用我们的主机Linux服务器上的临时文件夹来设置这些路径是至关重要的。项目文件应该类似于下面的<code class="fe nc nd ne nf b"><strong class="lb iu">YAML</strong></code>,所有路径都指向Linux临时文件夹。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">带有临时文件夹的DBT项目文件。</figcaption></figure><p id="f79d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在所有的组件都就位了，我们准备创建一个Azure DevOps构建管道。管道将安装在<code class="fe nc nd ne nf b"><strong class="lb iu">requirements.txt</strong></code>文件中定义的dbt和其他库，构建Docker映像，并通过Azure DevOps连接将其推送到我们的注册表<code class="fe nc nd ne nf b"><strong class="lb iu">svc-demo-docker-reg</strong></code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Azure DevOps为dbt Azure触发器函数构建管道。</figcaption></figure><h1 id="02cf" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">最后一步</h1><p id="35bd" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">在部署Azure功能之前，我们需要创建一个功能应用程序，作为多个Azure功能的主机，并位于指定的资源组和地理区域内。我们只需选择订阅、资源组、名称和区域，并将部署类型指定为<strong class="lb iu"> Docker容器</strong>。我们在这里选择Docker容器，因为我们发现它是在函数中安装和运行dbt的最可靠的方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/6875062bb57cd831c143fce07ae57cd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M3gjjSjduOX0eaYcFcFVrw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图7:用Docker容器部署创建Azure Function App。</figcaption></figure><p id="27ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦提供了功能应用程序，我们就建立一个Azure DevOps发布管道来部署我们之前构建的Docker映像。下面，我将向您展示发布管道的概述以及插入了<strong class="lb iu">应用服务部署任务</strong>的主要工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/b68b4f493b3ee92707a1cdc82d44a93b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*iQjiWmx_GAmqBj_yVgvZwg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图8: Azure DevOps发布管道</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/5e68e8f9002abb9c4b08b7bad0459284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H2DCp-xw7YQjOgxVpmogeg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图9:使用Azure应用服务部署任务</figcaption></figure><p id="85a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经部署并运行了Azure函数，是时候运行一些测试了。jaffle shop项目包含一些虚拟数据和模型，它们代表一个虚构的在线商店中的客户和订单。让我们假设另一个Azure函数已经完成了所有的数据加载，现在正在发送一条消息，要求用一些转换来更新客户订单。我们将通过向<code class="fe nc nd ne nf b"><strong class="lb iu">dbt-queue</strong></code>添加一条消息来模拟这种情况。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/0e5f57210711e63ad2bd0586150e0792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PYLomzYkF_TwIGUa5uSd1g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图10:向dbt发送一个事件来执行stg_orders模型。</figcaption></figure><p id="0cab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦添加了消息，我们的函数就会被触发，dbt开始运行。它选择了<code class="fe nc nd ne nf b"><strong class="lb iu">stg_orders</strong></code> <strong class="lb iu"> </strong>模型并成功运行了所有的转换。诚然，这是一个非常简单的例子，但设置工作非常大的项目，可以很容易地扩展。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/0782282431abe10da1a7387035f29dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XQyZLWU5YcE2d1Qn3862Nw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图11: Azure函数日志dbt输出。</figcaption></figure><h1 id="6575" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">结论</h1><p id="2930" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">DBT是一个强大的数据转换工具，它将——“没有双关语”——改变你的数据工程团队的工作方式。它有一个陡峭的学习曲线，需要耐心，特别是对于不习惯数据操作实践的团队。在Azure函数中连接dbt并基于传入事件执行模型是一种强大的机制，可以在很多有趣的场景中使用。如果您想了解更多关于Azure设置的信息或有任何问题，请随时联系我们。</p></div></div>    
</body>
</html>