<html>
<head>
<title>Explaining Recursion in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释JavaScript中的递归</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/explaining-recursion-in-javascript-9168e4aba8f2?source=collection_archive---------25-----------------------#2020-08-24">https://levelup.gitconnected.com/explaining-recursion-in-javascript-9168e4aba8f2?source=collection_archive---------25-----------------------#2020-08-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="ef2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个博客将介绍javascript中的递归。</p><p id="4766" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">递归是调用函数本身的行为。这允许您递归或迭代传入的参数，同时在内存中保存每次迭代的值。一旦函数调用完毕，每个堆栈值将减为一。还有其他方法来迭代数据，但是当有可执行的可重复模式时，递归会很有用。</p><p id="8327" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">递归看起来很危险，因为你的函数有可能无限地调用它自己，但是记住下面这三点，希望你能避免这种情况。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/ec260db0c00c197ff3fb4d70ed84128d.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*M6j33Ez_oKuaNop4sTCoQA.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">onions.png</figcaption></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="017b" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">递归需要3个简单的部分:</h1><ul class=""><li id="e258" class="mf mg it js b jt mh jx mi kb mj kf mk kj ml kn mm mn mo mp bi translated">在内部调用它自己</li><li id="10ff" class="mf mg it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated">递归情况</li><li id="0a80" class="mf mg it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated">基本情况/返回语句</li></ul><h1 id="fdbd" class="lh li it bd lj lk mv lm ln lo mw lq lr ls mx lu lv lw my ly lz ma mz mc md me bi translated">概念:</h1><p id="7316" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">递归背后的思想是通过调用函数本身来计算返回语句。每个函数调用将允许你更深入地了解你的参数。在下面的函数中，我们将在一个整数数组中添加元素，以返回一个数组中所有元素的总和。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="64a5" class="lh li it bd lj lk mv lm ln lo mw lq lr ls mx lu lv lw my ly lz ma mz mc md me bi translated"><strong class="ak">决定目的地并制定计划</strong></h1><h2 id="309d" class="nf li it bd lj ng nh dn ln ni nj dp lr kb nk nl lv kf nm nn lz kj no np md nq bi translated"><strong class="ak">在递归中迭代一个参数时，你一次只关注一层。</strong></h2><p id="de2a" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">当这个函数被调用时，参数将是一个数字数组，因此，我们在迭代时一次只关注一个数字。该函数的输出将是给定数组中所有数字的总和。记住你的预期产出将有助于你理解如何计划。</p><h1 id="954d" class="lh li it bd lj lk mv lm ln lo mw lq lr ls mx lu lv lw my ly lz ma mz mc md me bi translated"><strong class="ak">递归案例和函数调用— <em class="nr">【踪迹】</em> </strong></h1><h2 id="c4f5" class="nf li it bd lj ng nh dn ln ni nj dp lr kb nk nl lv kf nm nn lz kj no np md nq bi translated">递归事例由函数在每次迭代中采取的动作组成。最后一步是返回函数调用。</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/12fbeb63ed8c45a462f15be50c3ef728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*Qeeo2NwDZCVDJaULYv-yyA.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">depth.png</figcaption></figure><p id="2810" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每次调用递归函数时，返回的结果都存储在内存中，留下一串值。示例函数返回一串数字，并使用加法运算符将值相加。为了让函数停止调用自身，并在本例中将值相加，需要一个基本用例。</p><h1 id="b180" class="lh li it bd lj lk mv lm ln lo mw lq lr ls mx lu lv lw my ly lz ma mz mc md me bi translated"><strong class="ak">基础案例— <em class="nr">【回归】</em> </strong></h1><h2 id="4333" class="nf li it bd lj ng nh dn ln ni nj dp lr kb nk nl lv kf nm nn lz kj no np md nq bi translated"><strong class="ak">一个基本用例由一个条件组成，该条件告诉你的函数何时停止递归，并将其值返回到链的上游</strong></h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/67fb2d8ffc68ffe62dd4f5028a713460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*CwvQwFgwO6XeHXek4f1OsA.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">return.png</figcaption></figure><p id="2065" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦函数停止调用自己，递归堆栈就会崩溃，返回链中的每个值。在上述函数的情况下，一旦到达数组的最后一个元素，函数就会停止。一旦数组长度为零，条件将被设置为返回。一旦所有值加在一起，该值将被设置为返回零，以保持真正的总和。</p><p id="6098" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据你的条件，你需要调整你的函数，这样才能达到基本情况。在这种情况下，需要满足的条件是递归到数组中的最后一个元素。函数中采用的方法是使用slice方法在内存中保留第一个元素。具体来说，这也改变了数组中的第一个元素，进一步进入递归调用。新数组被传递到递归调用中，每次调用时长度递减，直到满足最后一个条件。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="2c8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是全部了！我希望这澄清了一点，为什么递归不是那么糟糕，在某些情况下，这是一种非常独特的解决问题的方式。</p></div></div>    
</body>
</html>