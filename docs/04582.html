<html>
<head>
<title>Writing Falling Dots Game with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React写落点游戏</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/writing-falling-dots-game-with-react-8b2884fa683d?source=collection_archive---------2-----------------------#2020-07-04">https://levelup.gitconnected.com/writing-falling-dots-game-with-react-8b2884fa683d?source=collection_archive---------2-----------------------#2020-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b90ba449919c63538f91ffdf7e8a8453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J79q3crod69EWXqH"/></div></div></figure><p id="c6df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们抛开一般的教程，在ReactJS库中尝试一个有趣的应用程序。在本教程中，我们将创建一个遵循以下规则的游戏。</p><ul class=""><li id="56b9" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">游戏场是一个矩形，具有相应的宽度和固定的高度</li><li id="3aa9" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">每秒钟都会有一个点随机出现在这片区域的顶部边缘</li><li id="a0fc" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">每个点可以有不同的大小和颜色(从列表中随机挑选)</li><li id="1424" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">每个点每秒下降X个像素</li><li id="f241" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">速度可以在游戏过程中随时改变</li><li id="a5ea" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">如果你成功点击圆点，它就会消失，你就可以得分了</li><li id="bde0" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">圆点越小，你得到的分数就越多</li><li id="3c93" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">当一个点离开棋盘，它就消失了(没有得分)</li><li id="1c73" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">游戏可以随时暂停，以停止下降和产卵点</li><li id="d72c" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">游戏区域可以被清空以完全重置该过程</li></ul><p id="af54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">给你一个小引子，游戏过程看起来是这样的:</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lk"><img src="../Images/ab8489eae616aa447ae25cf4ae6262a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TVOcDiwVFn_axmR6Z1dpMw.png"/></div></div></figure><p id="5b46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使我们的任务更有趣，我们将遵循函数式编程概念，使用现代的React钩子和函数式组件方法。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="d30a" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">技术栈</h1><p id="a3f4" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">在本教程中，我们将使用一个简单的技术堆栈。</p><ul class=""><li id="11cb" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">React JS —用于重新渲染优化和基于组件的结构</li><li id="cb57" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae mz" href="https://recoiljs.org/" rel="noopener ugc nofollow" target="_blank">反冲</a>——作为一个简单的状态管理库。你可以在我的<a class="ae mz" href="https://medium.com/swlh/a-quick-glance-at-recoil-d276c22c7efe" rel="noopener">上一篇文章</a>中看到关于这个闪亮的新库的教程。</li><li id="06ef" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">CSS —对于样式，这里没有魔法:)</li><li id="87dc" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">create-react-app —用于引导应用程序</li></ul><p id="dca7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在<a class="ae mz" href="https://github.com/KilroggD/dots-game-react-recoil" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中跟随源代码。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="9d9c" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">创建应用程序和定义配置</h1><p id="151c" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">首先，我们创建一个框架式的react应用程序</p><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="183f" class="nf lx iq nb b gy ng nh l ni nj">npx create-react-app dots-game</span></pre><p id="bd6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，通过导航到app文件夹并运行以下命令，安装新的闪亮的<a class="ae mz" href="https://recoiljs.org/" rel="noopener ugc nofollow" target="_blank">反冲</a>库:</p><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="d30f" class="nf lx iq nb b gy ng nh l ni nj">npm install recoil</span></pre><p id="59b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后可以运行<code class="fe nk nl nm nb b">npm start</code>看教程app运行。然后清理App.js文件，进入下一步。</p><p id="e597" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们创建一个<code class="fe nk nl nm nb b">game</code>文件夹来存放我们的游戏组件。然后用我们需要定义的主要参数定义一个<a class="ae mz" href="http://Let's create a game folder to put our game components there." rel="noopener ugc nofollow" target="_blank">常量</a>文件。</p><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="b254" class="nf lx iq nb b gy ng nh l ni nj">// color for dots to pick from list<br/>export const COLORS = ['red', 'green', 'blue', 'orange'];</span><span id="1a84" class="nf lx iq nb b gy nn nh l ni nj">// size vales for dots to pick from list<br/>export const SIZES = [10, 15, 20, 25, 30, 35, 40, 45];</span><span id="24e5" class="nf lx iq nb b gy nn nh l ni nj">// step to control speed px/sec<br/>export const SPEED_STEP = 10;</span><span id="8bfd" class="nf lx iq nb b gy nn nh l ni nj">// Max value of points - each dot will cost MAX - size points<br/>export const MAX_POINTS = 50;</span><span id="044f" class="nf lx iq nb b gy nn nh l ni nj">// Interval to spawn a new dot<br/>export const SPAWN_INTERVAL = 1000;</span></pre></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="8640" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">国家结构</h1><p id="ea5c" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">正如我之前提到的，在本教程中，我们使用<a class="ae mz" href="https://recoiljs.org/" rel="noopener ugc nofollow" target="_blank">反冲</a>作为一个简单的状态管理库。我们可以用Redux / MobX甚至简单的<em class="no"> useState </em>钩子来完成这个任务，但是获得更多使用新库的经验可能会很有用。这也给了我们一个机会将状态从组件中分离出来，而不需要安装一个巨大的附加模板(参见我对反冲的想法<a class="ae mz" href="https://medium.com/swlh/a-quick-glance-at-recoil-d276c22c7efe" rel="noopener">那里</a>)。对于这个游戏，我们将只需要<a class="ae mz" href="https://recoiljs.org/docs/introduction/core-concepts" rel="noopener ugc nofollow" target="_blank">基本功能</a>的后坐力。</p><p id="713f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mz" href="https://github.com/KilroggD/dots-game-react-recoil/blob/master/src/game/atom.js" rel="noopener ugc nofollow" target="_blank">这里</a>是我可以建议的简单状态结构:</p><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="e6ef" class="nf lx iq nb b gy ng nh l ni nj">import  { atom } from 'recoil';</span><span id="90ff" class="nf lx iq nb b gy nn nh l ni nj">// Control params - if game is launched and current speed<br/>export const controlOptions = atom({<br/>    key: 'controlOptions',<br/>    default: {<br/>        isRunning: false,<br/>        speed: 5,<br/>    },<br/>});</span><span id="47ab" class="nf lx iq nb b gy nn nh l ni nj">// List of dots in the game - empty by default<br/>export const dotsState = atom({<br/>    key: 'dotsState',<br/>    default: [],<br/>});</span><span id="1255" class="nf lx iq nb b gy nn nh l ni nj">// Current score - zero by default<br/>export const scoreState = atom({<br/>    key: 'scoreState',<br/>    default: 0,<br/>});</span></pre><p id="670d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不要忘记将<code class="fe nk nl nm nb b">RecoilRoot</code>导入到您的<a class="ae mz" href="https://github.com/KilroggD/dots-game-react-recoil/blob/master/src/App.js" rel="noopener ugc nofollow" target="_blank"> App.js </a>中，以便在所有游戏组件中访问您的反冲状态。</p><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="541e" class="nf lx iq nb b gy ng nh l ni nj">import React from "react";<br/>import { RecoilRoot } from "recoil";</span><span id="7f4d" class="nf lx iq nb b gy nn nh l ni nj">// import Game from './game/Game';</span><span id="7714" class="nf lx iq nb b gy nn nh l ni nj">import './App.css';</span><span id="77d1" class="nf lx iq nb b gy nn nh l ni nj">function App() {<br/>    return (<br/>      &lt;RecoilRoot&gt;<br/>          {/*&lt;Game /&gt;*/}<br/>      &lt;/RecoilRoot&gt;<br/>  );<br/>}</span><span id="5bc3" class="nf lx iq nb b gy nn nh l ni nj">export default App;</span></pre></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="5aa7" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">主要组件和样式</h1><p id="978c" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">让我们将组件的结构定义为<a class="ae mz" href="https://github.com/KilroggD/dots-game-react-recoil/tree/master/src/game" rel="noopener ugc nofollow" target="_blank">跟随</a>:</p><ul class=""><li id="7480" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><a class="ae mz" href="https://github.com/KilroggD/dots-game-react-recoil/blob/master/src/game/Game.js" rel="noopener ugc nofollow" target="_blank"> Game.js </a> —渲染游戏领域的主要组件和所有其他组件。包含与游戏领域相关的主要逻辑和钩子。我们将在下一节回到这个组件。现在，让我们制作一个虚拟游戏场</li></ul><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="093f" class="nf lx iq nb b gy ng nh l ni nj">const Game = () =&gt; {<br/>   return (<br/>        &lt;div className="main"&gt;<br/>            &lt;div className="panel"&gt;<br/>                {/* &lt;Control/&gt; */}<br/>                {/* &lt;Score /&gt; */ }<br/>            &lt;/div&gt;<br/>            &lt;div className="field"&gt;<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span><span id="bada" class="nf lx iq nb b gy nn nh l ni nj">export default Game;</span></pre><ul class=""><li id="aaeb" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><a class="ae mz" href="https://github.com/KilroggD/dots-game-react-recoil/blob/master/src/game/Control.js" rel="noopener ugc nofollow" target="_blank"> Control.js </a> —处理控制(启动/停止/清除、速度变化)的组件。我们稍后也会回到这个问题。</li><li id="afb1" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae mz" href="https://github.com/KilroggD/dots-game-react-recoil/blob/master/src/game/Score.js" rel="noopener ugc nofollow" target="_blank"> Score.js </a> —表示当前得分的组件—此处不变:)</li><li id="80f4" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae mz" href="https://github.com/KilroggD/dots-game-react-recoil/blob/master/src/game/Dot.js" rel="noopener ugc nofollow" target="_blank"> Dot.js </a> —表示落点的组件</li></ul><p id="3815" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想展示关于最后一个的更多细节。为了能够使点“下落”,我们应该在我们的场中沿Y轴移动它。此外，每个点应该有它的X坐标，以便能够水平扩展它们。对于坐标表示，我们可以使用<em class="no">左侧</em>和<em class="no">顶部</em>的CSS属性。点的宽度应该等于它的大小。为了简单起见，让我们用React中的<a class="ae mz" href="https://reactjs.org/docs/dom-elements.html#style" rel="noopener ugc nofollow" target="_blank">内嵌样式</a>来做。我们还需要为dot定义一个<em class="no"> onClick </em>处理程序，因为这是我们游戏的主要目标:)</p><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="0e99" class="nf lx iq nb b gy ng nh l ni nj">const Dot = (props) =&gt; {<br/>    const {color, x, y, size, index, onClick} = props;    <br/>    const dotStyle = {<br/>        backgroundColor: color,<br/>        height: `${size}px`,<br/>        width: `${size}px`,<br/>        left: `${x}px`,<br/>        top: `${y}px`,<br/>    };</span><span id="7497" class="nf lx iq nb b gy nn nh l ni nj">return (<br/>        &lt;div <br/>            className="dot"<br/>            style={dotStyle}<br/>            onClick={() =&gt; onClick(index)}<br/>        /&gt;<br/>    );<br/>};</span><span id="8b64" class="nf lx iq nb b gy nn nh l ni nj">export default Dot;</span></pre><p id="5bfc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我忘了什么吗？哦，点必须是圆，我们的领域必须尊重其坐标。这是在<a class="ae mz" href="https://github.com/KilroggD/dots-game-react-recoil/blob/master/src/App.css" rel="noopener ugc nofollow" target="_blank"> App.css </a>文件中完成的</p><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="7054" class="nf lx iq nb b gy ng nh l ni nj">/* Generic padding */<br/>.main {<br/>    text-align: center;<br/>    padding: 25px 50px 25px 50px;<br/>}</span><span id="5c94" class="nf lx iq nb b gy nn nh l ni nj">/* Field params */<br/>.field {<br/>    height: 500px;<br/>    border: 2px solid black;<br/>    position: relative;<br/>    overflow-y: hidden;<br/>}</span><span id="9390" class="nf lx iq nb b gy nn nh l ni nj">/* Dot positioning */<br/>.dot {<br/>    border: 1px solid #000;<br/>    border-radius: 50%;<br/>    position: absolute;<br/>}</span></pre><p id="a080" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要隐藏溢出-y字段，以防止点离开边缘。圆点是圆形的，并且<em class="no">绝对- </em>位于视场内。你可以通过在字段中添加几个点来检查它是如何工作的。</p><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="b93e" class="nf lx iq nb b gy ng nh l ni nj">return (<br/>        &lt;div className="main"&gt;<br/>            &lt;div className="panel"&gt;<br/>                {/*&lt;Control onClear={clear} /&gt;*/}<br/>                {/*&lt;Score /&gt;*/}<br/>            &lt;/div&gt;<br/>            &lt;div className="field"&gt;<br/>                &lt;Dot <br/>                    color="red" <br/>                    x="100" y="200" <br/>                    onClick={() =&gt; {}} <br/>                    size="40" <br/>                /&gt;<br/>                &lt;Dot <br/>                    color="green" <br/>                    x="200" y="300" <br/>                    onClick={() =&gt; {}} <br/>                    size="35" /&gt;<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;<br/>    );</span></pre><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/1c9a2261acf54b28fdd27c71679721f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NSkZ4B4UyNN7_hfh_Kvr0g.png"/></div></div></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="6978" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">主逻辑—用点操纵</h1><p id="6813" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">因为落点是游戏中的主要对象，我们需要围绕它们建立逻辑。首先，我们需要能够在字段上添加/删除点。</p><p id="f861" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了不把所有东西都放在我们的游戏组件中，我们定义了<a class="ae mz" href="https://github.com/KilroggD/dots-game-react-recoil/blob/master/src/game/utils.js" rel="noopener ugc nofollow" target="_blank"><em class="no">utils</em></a><em class="no"/>一组帮助器，它们具有游戏逻辑所需的一些有用的功能。</p><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="36c4" class="nf lx iq nb b gy ng nh l ni nj">import { MAX_POINTS, COLORS, SIZES } from './constants';</span><span id="c840" class="nf lx iq nb b gy nn nh l ni nj">export const createDot = () =&gt; {<br/>    // pick random color and size<br/>    const color = COLORS[Math.floor(Math.random() * COLORS.length)]<br/>    const size = SIZES[Math.floor(Math.random() * SIZES.length)]<br/>    <br/>    let x = Math.floor(Math.random() * 100);</span><span id="d5a1" class="nf lx iq nb b gy nn nh l ni nj">    return {<br/>        color,<br/>        size,<br/>        x,<br/>        y: 0,<br/>      }<br/>};</span><span id="2ba9" class="nf lx iq nb b gy nn nh l ni nj">export const removeDot = (dots, index) =&gt; {<br/>    const newDots = [...dots];<br/>    newDots.splice(index, 1);<br/>    return newDots;    <br/>};</span><span id="c054" class="nf lx iq nb b gy nn nh l ni nj">export const calculatePoints = (dot) =&gt; {<br/>    return MAX_POINTS - dot.size;<br/>};</span></pre><p id="9771" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个<em class="no"> createDot </em>函数是一个工厂函数，返回一个带有点参数(颜色、大小、坐标)的对象。下一个<em class="no"> removeDot </em>方法是从主状态列表中删除给定索引处的点的实用方法。另一个效用函数<em class="no"> calculatePoints </em>将返回一个点的数量，计算方式为常量MAX_POINTS值减去一个点的大小。</p><p id="4966" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与dots相关的主要逻辑位于主组件<a class="ae mz" href="https://github.com/KilroggD/dots-game-react-recoil/blob/master/src/game/Game.js" rel="noopener ugc nofollow" target="_blank"> <em class="no"> Game.js </em> </a>中的回调函数中。</p><ul class=""><li id="4ecc" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">产生一个新的点</li></ul><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="b8d9" class="nf lx iq nb b gy ng nh l ni nj">const spawnDot = useCallback(() =&gt; {<br/>    updateDots((oldDots) =&gt; [...oldDots, createDot()]);<br/>}, [updateDots]);</span></pre><ul class=""><li id="7cb9" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">成功点击时删除点并添加点</li></ul><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="e56a" class="nf lx iq nb b gy ng nh l ni nj">const onDotClick = (index) =&gt; {<br/>    setScore(score + calculatePoints(dots[index]));<br/>    updateDots(removeDot(dots, index));<br/>};</span></pre><p id="7858" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要考虑如何在球场上放置我们的点。我们有一个从1到100随机选取的X坐标，但假设我们有一个可变的屏幕或设备宽度，我们如何将它映射到实际的字段？为了解决这个问题，我们使用<a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetWidth" rel="noopener ugc nofollow" target="_blank"><em class="no">offsetWidth</em></a><em class="no"/>属性，根据从1到100的X值和当前的<em class="no"> offsetWidth </em>值计算我们的实际X值，这样我们的X值总是与当前宽度成比例。因为我们需要引用实际的HTML属性，<a class="ae mz" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank"><em class="no">useRef</em></a>React hook将在这里帮助我们。</p><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="30b1" class="nf lx iq nb b gy ng nh l ni nj">const [dots, updateDots] = useRecoilState(dotsState);</span><span id="6caf" class="nf lx iq nb b gy nn nh l ni nj">const fieldRef = useRef();</span></pre><p id="b924" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的Game.js组件中定义Ref，稍后:</p><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="f333" class="nf lx iq nb b gy ng nh l ni nj">&lt;div className="field" ref={fieldRef}&gt;<br/>    {dots.map((dot, index) =&gt; {<br/>        const x = (<br/>            fieldRef.current.offsetWidth - dot.size<br/>        ) * dot.x / 100<br/>        return &lt;Dot<br/>            key={`dot-${index}`} <br/>            {...dot}<br/>            x={x}<br/>            index={index} <br/>            onClick={onDotClick} <br/>        /&gt;;<br/>     })}<br/>&lt;/div&gt;</span></pre><p id="be5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">计算X值的公式将我们的实际像素值定义为总<em class="no">偏移量</em>的百分比，从1%到100%，因此我们模拟了一个正确的坐标轴。如果X值接近100%,<code class="fe nk nl nm nb b">— dot.size</code>部分确保圆点不会偏离右边。因此，我们可以基于<em class="no"> offsetWidth </em>、点的索引和回调函数(用于正确的<em class="no"> onClick </em>处理)以及其他点属性来传递X值，从而保持点组件从我们的状态中抽象出来。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="5438" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">使其移动(requestAnimationFrame)</h1><p id="c2ba" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">现在是时候考虑实际的游戏过程了——我们如何让整个游戏动起来？</p><p id="023e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们需要每秒产生一个新的点，或者常量文件中定义的间隔来产生点。</p><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="8c8a" class="nf lx iq nb b gy ng nh l ni nj">import { SPEED_STEP, SPAWN_INTERVAL } from './constants';</span></pre><p id="5b38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在我们的Game.js组件中，我们为spawn dots interval定义了ref。</p><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="f55b" class="nf lx iq nb b gy ng nh l ni nj">const intervalRef = useRef();</span></pre><p id="da6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个引用将保存我们的超时点生成方法。然后，创建一个spawn dot函数来创建新的点。</p><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="7e99" class="nf lx iq nb b gy ng nh l ni nj">const spawnDot = useCallback(() =&gt; {<br/>        updateDots((oldDots) =&gt; [...oldDots, createDot()]);<br/>}, [updateDots]);</span></pre><p id="054e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还记得我们的<em class="no"> createDot </em>函数吗？我们在回调中使用它。</p><p id="2f04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是产生新的点还不够，我们还希望它们以给定的速度沿Y轴向下移动。让我们为此定义一个函数。为了让这个方法以或多或少优化的方式执行移动动画，我们将使用<a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" rel="noopener ugc nofollow" target="_blank"><em class="no">request animation frame</em></a><em class="no"/>方法，该方法通常每秒调用我们的回调60次。</p><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="893d" class="nf lx iq nb b gy ng nh l ni nj">const requestRef = useRef();</span><span id="95e9" class="nf lx iq nb b gy nn nh l ni nj">const advanceStep = useCallback(() =&gt; {<br/>        updateDots((oldDots) =&gt; {<br/>            const newDots = [];<br/>            for (let dot of oldDots) {<br/>                const newY = dot.y + SPEED_STEP * controlState.speed / 60;<br/>                if (newY &lt;= fieldRef.current.offsetHeight - dot.size / 2) {<br/>                    newDots.push(<br/>                        {<br/>                            ...dot,<br/>                            y: newY,<br/>                        }<br/>                    );<br/>                }<br/>            }<br/>            return newDots;<br/>        });<br/>        requestRef.current = requestAnimationFrame(advanceStep);<br/>    }, [controlState.speed, updateDots]);</span></pre><p id="6cfa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么这个函数是干什么用的呢？首先，它遍历所有现有的点。然后，它试图将每个点沿Y轴向下移动<em class="no">SPEED _ STEP * current _ SPEED/60px</em>，因为我们的<em class="no"> SPEED_STEP </em>常量表示每速度单位每秒的像素数，回调每秒被调用60次。</p><p id="8ad0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果一个点落在当前<a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight" rel="noopener ugc nofollow" target="_blank"> <em class="no">偏置场的高度</em> </a>一半或更多——我们认为该点已经消失并删除它(不包括在<em class="no">新点</em>数组中)。ref <em class="no"> requestRef </em>保持超时回调。</p><p id="6242" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们的主<em class="no"> useEffect </em>钩子将根据游戏控制状态下的<em class="no"> isRunning </em>标志处理生成点和移动点逻辑。</p><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="15f7" class="nf lx iq nb b gy ng nh l ni nj">useEffect(() =&gt; {<br/>    const stop = () =&gt; {<br/>        intervalRef.current &amp;&amp;         <br/>            clearInterval(intervalRef.current);<br/>        requestRef.current &amp;&amp; <br/>           cancelAnimationFrame(requestRef.current);<br/>    }<br/>    if (controlState.isRunning) {<br/>        intervalRef.current = setInterval(<br/>            spawnDot, SPAWN_INTERVAL<br/>        );<br/>        requestRef.current = requestAnimationFrame(advanceStep);<br/>    } else {<br/>            stop();<br/>    }<br/>    return () =&gt; stop();<br/>}, [controlState.isRunning, advanceStep, spawnDot])</span></pre><p id="04ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果<em class="no">正在运行</em>标志变为真，我们启动两种超时方法。我们调用<em class="no"> stop </em>函数作为钩子的清理效果，如果<em class="no"> controlState isRunning </em>标志变为false，我们也调用它。请不要忘记，之前定义的裁判对于停止比赛/清理我们的间隔非常有用。</p><p id="f801" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们定义一个<em class="no">清除</em>函数传递给<em class="no">清除</em>控制按钮。</p><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="8579" class="nf lx iq nb b gy ng nh l ni nj">const clear = useCallback(() =&gt; {<br/>    setControlState({...controlState, isRunning: false, speed: 5});<br/>    updateDots([]);<br/>    setScore(0);<br/>}, [setControlState, setScore, updateDots, controlState]);</span></pre><p id="dc29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它停止执行，清除场上所有的点，并清除当前得分。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="7c6c" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">让游戏控制发挥作用</h1><p id="f8db" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated"><a class="ae mz" href="https://github.com/KilroggD/dots-game-react-recoil/blob/master/src/game/Control.js" rel="noopener ugc nofollow" target="_blank">控制</a>组件连接到<em class="no">控制状态</em>，允许我们开始/暂停游戏或改变速度。</p><p id="64e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">渲染部分非常简单——它包括2个按钮和一个控制速度的<em class="no">范围</em>输入。</p><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="8dd1" class="nf lx iq nb b gy ng nh l ni nj">return (<br/>        &lt;div className="control"&gt;<br/>            &lt;div className="control__buttons"&gt;<br/>                {<br/>                    isRunning ? <br/>                        (<br/>                            &lt;button onClick={togglePause}&gt;<br/>                                PAUSE<br/>                            &lt;/button&gt;<br/>                        ) : (<br/>                            &lt;button onClick={onStart}&gt;<br/>                                START<br/>                            &lt;/button&gt;<br/>                        )                        <br/>                }<br/>                &lt;button onClick={onClear}&gt;CLEAR&lt;/button&gt;<br/>            &lt;/div&gt;<br/>            &lt;div className="control__speed"&gt;<br/>                &lt;p&gt;{`Current speed: ${speed}`}&lt;/p&gt;<br/>                &lt;input<br/>                    type="range"<br/>                    min="1"<br/>                    max="10"<br/>                    value={speed}<br/>                    onChange={onChangeSpeed}<br/>                /&gt;<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;<br/>    )</span></pre><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/e4866beb7acb3b831b709da57ee9372d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sMM17eGwTTqPL-fh2zqiSQ.png"/></div></div></figure><p id="51c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了Clear按钮之外，每个按钮都有一个回调处理程序，这个处理程序是从游戏组件传递过来的。</p><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="65cf" class="nf lx iq nb b gy ng nh l ni nj">const onChangeSpeed = useCallback((event) =&gt; {<br/>        setControlState(<br/>             {...controlState, speed: event.target.value}<br/>        );<br/>    }, [setControlState, controlState]);</span></pre><p id="d626" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意非常特殊的<em class="no">使用效果</em>逻辑。我注意到一个非常严重的性能问题。每当玩家在浏览器中切换到一个新标签时，游戏就会以一种中断的方式继续在后台运行(新的点继续产生，但没有移动发生)。它会导致该选项卡的行为中断和潜在的内存泄漏，因为点可以无限繁殖。为了防止这种情况，我们想在当前标签不可见时使用<a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API" rel="noopener ugc nofollow" target="_blank">文档可见性API </a>停止游戏。</p><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="ea56" class="nf lx iq nb b gy ng nh l ni nj">useEffect(() =&gt; {<br/>    document.addEventListener("visibilitychange", () =&gt; {<br/>        setControlState(oldState =&gt; {<br/>            return {...oldState, isRunning: false};<br/>        });<br/>     });<br/>     return () =&gt; document.removeEventListener("visibilitychange");        <br/>}, [setControlState]);</span></pre><p id="b347" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当可见性状态改变时，我们暂停游戏，这样当用户回到游戏标签页时可以继续游戏。</p><p id="bb7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要创建一个可视化组件来显示当前的<a class="ae mz" href="https://github.com/KilroggD/dots-game-react-recoil/blob/master/src/game/Score.js" rel="noopener ugc nofollow" target="_blank">分数</a>。</p><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="9ce9" class="nf lx iq nb b gy ng nh l ni nj">import React from 'react';<br/>import {useRecoilValue} from 'recoil';</span><span id="cf4a" class="nf lx iq nb b gy nn nh l ni nj">import {scoreState} from './atom';</span><span id="90af" class="nf lx iq nb b gy nn nh l ni nj">const Score = () =&gt; {<br/>    const score = useRecoilValue(scoreState);</span><span id="d2d8" class="nf lx iq nb b gy nn nh l ni nj">return (<br/>        &lt;div className="score"&gt;<br/>            &lt;p&gt;{`Score: ${score}`}&lt;/p&gt;<br/>        &lt;/div&gt;<br/>    );<br/>};</span><span id="468d" class="nf lx iq nb b gy nn nh l ni nj">export default Score;</span></pre><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/3397ed09cd73b2f45ea8dd6593353b89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*YzQ2ATkBP__Peuw2xfv-5w.png"/></div></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="1d93" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">测试一下！</h1><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4efdde0aee7bada69d5df4438b794de9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ypY3JNlATL0dBO1R"/></div></div></figure><p id="2440" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要测试游戏的运行，只需克隆<a class="ae mz" href="https://github.com/KilroggD/dots-game-react-recoil" rel="noopener ugc nofollow" target="_blank">库</a>，转到它的根文件夹并运行我们可能都知道的命令:</p><pre class="ll lm ln lo gt na nb nc nd aw ne bi"><span id="7bee" class="nf lx iq nb b gy ng nh l ni nj">npm install</span><span id="d0d0" class="nf lx iq nb b gy nn nh l ni nj">npm start</span></pre><p id="e620" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，您可以导航到<code class="fe nk nl nm nb b">http://localhost:3000</code>并看到它的工作！</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lk"><img src="../Images/6e3dd80f611c7c751832c5e56e4f1aa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pMoV6NdNnBiye-wnUyGEyw.png"/></div></div></figure><p id="cc6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GG WP:)</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="bd55" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">下一步是什么？要考虑的其他挑战</h1><p id="e884" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">我希望这个教程是有用的，或者至少你对这个非常不寻常的反作用和反冲堆栈的应用有一些兴趣。</p><p id="e769" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想强调一些额外的食物想法:</p><ul class=""><li id="265d" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">我们没有考虑到我们的圈子可能会重叠。如果我们想改善整体体验，开发一个更复杂的点生成算法来考虑“繁忙”点并且不在那里放置任何点是有意义的</li><li id="05aa" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">我们可以通过使用变换属性和一些动画缓动特性来进行CSS优化</li><li id="b27b" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">最后，我们可以使用<a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" rel="noopener ugc nofollow" target="_blank">画布</a>来代替React渲染，但在这种情况下，这并不是一个React教程，因为我们将所有的视觉渲染移动到画布上，并将React仅用作状态容器</li></ul><p id="31ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读这篇长文:)在我的下一个教程中再见</p></div></div>    
</body>
</html>