<html>
<head>
<title>New RegEx Features with Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有示例的新正则表达式特性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/es2018-new-regex-features-with-examples-89d889846d1d?source=collection_archive---------4-----------------------#2019-07-30">https://levelup.gitconnected.com/es2018-new-regex-features-with-examples-89d889846d1d?source=collection_archive---------4-----------------------#2019-07-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="724d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">ES2018中引入的功能—“s”<strong class="ak">dotAll标志</strong>、<strong class="ak">命名捕获组</strong>、<strong class="ak"> Lookbehind断言</strong>和<strong class="ak"> Unicode属性转义</strong>。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2960cc64d4743de607eee7ea25234ca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cwm6o1o-RgZBWY6fBtdLWg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@transonhoang?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">黄川</a>在<a class="ae ky" href="https://unsplash.com/@transonhoang?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="f5e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ES2018中引入了最新的正则表达式功能。这些更新包括4个新功能— <code class="fe lv lw lx ly b">s</code> (dotAll)，命名捕获组，后视断言，Unicode属性转义。</p><p id="1e6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多类似的内容，请查看https://betterfullstack.com的</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ma"><img src="../Images/f5f3b09f3bc0792aec8ddf376661deaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WTGXzT5nKrV8wvl3yraxnA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">正则表达式的建议</figcaption></figure><h2 id="de1f" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated"><a class="ae ky" href="https://github.com/tc39/proposal-regexp-dotall-flag" rel="noopener ugc nofollow" target="_blank">“s”(</a><code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/tc39/proposal-regexp-dotall-flag" rel="noopener ugc nofollow" target="_blank">dotAll</a></code><a class="ae ky" href="https://github.com/tc39/proposal-regexp-dotall-flag" rel="noopener ugc nofollow" target="_blank">)标志为正则表达式</a></h2><p id="e958" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><strong class="lb iu">问题</strong>:</p><ol class=""><li id="2709" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">正则表达式与星号(<a class="ae ky" href="https://en.wikipedia.org/wiki/Plane_(Unicode)" rel="noopener ugc nofollow" target="_blank">非BMP </a>)字符不匹配。例如:<code class="fe lv lw lx ly b">/^.$/.test('😀') // false</code>。</li><li id="3e0a" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">正则表达式与<code class="fe lv lw lx ly b">\r</code>和<code class="fe lv lw lx ly b">\n</code>不兼容。例子:<code class="fe lv lw lx ly b">/./.test('\n') // false</code>。</li></ol><p id="63ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时我们仍然可以通过添加两个相反的速记字符类<code class="fe lv lw lx ly b">[\w\W]</code>来检查这一点，比如<code class="fe lv lw lx ly b">/[\w\W]/.test('\n') // true</code>。</p><p id="1e40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">解决方案</strong>:</p><p id="d884" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ES2018通过添加标志<code class="fe lv lw lx ly b">\s</code>(长名称为<code class="fe lv lw lx ly b">dotAll</code>)修复了这个问题</p><ol class=""><li id="0717" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">/^.$/s.test('😀') // true</code></li><li id="1920" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">/./s.test('\n') // true</code></li></ol><h2 id="7e28" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated"><a class="ae ky" href="https://github.com/tc39/proposal-regexp-named-groups" rel="noopener ugc nofollow" target="_blank"> RegExp命名的捕获组</a></h2><p id="7986" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以将捕获组命名为正则表达式匹配的字符串的特定部分。</p><p id="8ddb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法:<code class="fe lv lw lx ly b">(?&lt;name&gt;...)</code></p><p id="0ab5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从我上一篇关于验证电话号码的文章中取一个例子。</p><pre class="kj kk kl km gt nn ly no np aw nq bi"><span id="de64" class="mb mc it ly b gy nr ns l nt nu">const reg = /^([2-9]\d{2})-\d{3}-\d{4}$/;</span></pre><p id="43d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们使用<code class="fe lv lw lx ly b">exec</code>获取输出时，很难检索到我们想要的信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/13c0766af19dce3dff28c7991e536443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*QQic8Nj19xefHPSaip8iBg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">执行电话号码后输出</figcaption></figure><p id="51ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以通过用<code class="fe lv lw lx ly b">first</code>、<code class="fe lv lw lx ly b">second</code>和<code class="fe lv lw lx ly b">third</code>为每个组命名来应用这个新技术。</p><pre class="kj kk kl km gt nn ly no np aw nq bi"><span id="e9ea" class="mb mc it ly b gy nr ns l nt nu">const newReg = /^(?&lt;first&gt;[2-9]\d{2})-(?&lt;second&gt;\d{3})-(?&lt;third&gt;\d{4})$/;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/f0199d8659529175436762a7ca412fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3CYBXLDg7x2Ujpyf4D2yqQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用捕获组后的输出</figcaption></figure><p id="557f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以很容易地通过析构来获取值。</p><pre class="kj kk kl km gt nn ly no np aw nq bi"><span id="335e" class="mb mc it ly b gy nr ns l nt nu">const {groups: {first,second,third}} = newReg.exec("234-234-0123");</span></pre><p id="1e92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢的一点是，<strong class="lb iu">我们可以通过<code class="fe lv lw lx ly b">\k&lt;name&gt;</code>语法在模式</strong>中调用一个命名的捕获组。</p><pre class="kj kk kl km gt nn ly no np aw nq bi"><span id="b95e" class="mb mc it ly b gy nr ns l nt nu">const duplicate = /\b(?&lt;half&gt;\w+)\s+\k&lt;half&gt;\b/;<br/>duplicate.test('I will go to school tomorrow'); // false<br/>duplicate.test('I will go to to school tomorrow  '); // true<br/>console.log(duplicate.exec('I will go to to school tomorrow  ')); // object</span></pre><p id="770a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子帮助我们检查重复的单词。</p><h2 id="b981" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated"><a class="ae ky" href="https://github.com/tc39/proposal-regexp-lookbehind" rel="noopener ugc nofollow" target="_blank">正则表达式后视断言</a></h2><p id="11c1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在ES2018之前，我们只有正面和负面的前瞻断言。</p><p id="4f41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">正向前瞻</strong>T5】</p><p id="4210" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">/apple (?=tree)/</code>。这意味着<code class="fe lv lw lx ly b">apple</code>之后一定是<code class="fe lv lw lx ly b">tree</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/f393f7e817420a3ffddaf932ec73f8f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*P6hEmBh6DI1yb8GvZiGAnQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">积极前瞻</figcaption></figure><p id="af6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">负前视</strong> <code class="fe lv lw lx ly b">?!...</code></p><p id="f8f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">/apple (?!tree)/</code>。这意味着单词follow <code class="fe lv lw lx ly b">apple</code>不能是<code class="fe lv lw lx ly b">tree</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/bbbf6f9f26bbb2089adf00e35a0731c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*kb3tTGq1Aq9F-HD1eVaKYw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">消极前瞻</figcaption></figure><p id="c2e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从ES2018开始，JavaScript允许我们执行后视断言。</p><p id="cefe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">正向后视</strong> <code class="fe lv lw lx ly b">?&lt;=...</code></p><p id="0a51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">/(?&lt;=apple) tree/</code>。这仅在<code class="fe lv lw lx ly b">apple</code>在<code class="fe lv lw lx ly b">tree</code>之后时匹配。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/c8bf6e7534c3949f7dee8033c7d1922b.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*L6eBABFv2c43iIb7GmynRw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">积极回顾</figcaption></figure><p id="895c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">否定后视</strong> <code class="fe lv lw lx ly b">?&lt;!…</code></p><p id="8744" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">/(?&lt;!apple) tree/</code>。这仅在<code class="fe lv lw lx ly b">apple</code>不在<code class="fe lv lw lx ly b">tree</code>后面时匹配。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/05c1c225d8ba1e1485e5a280e8242f11.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*QSIfLMrTUZdi1k0zJLNnaA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">消极回顾</figcaption></figure><h2 id="75f6" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated"><a class="ae ky" href="https://github.com/tc39/proposal-regexp-unicode-property-escapes" rel="noopener ugc nofollow" target="_blank"> RegExp Unicode属性转义</a></h2><p id="ad12" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">设置<code class="fe lv lw lx ly b">\u</code>时，Unicode属性转义<code class="fe lv lw lx ly b">\p{...}</code>和<code class="fe lv lw lx ly b">\P{...}</code>现在在正则表达式中可用。</p><p id="793f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这解决了这些问题:</p><ol class=""><li id="88bf" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">创建支持Unicode的正则表达式不再痛苦。</li><li id="716a" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">不依赖于运行时库。</li><li id="abbb" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">正则表达式模式简洁易读——不再有文件大小膨胀。</li><li id="ce63" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">不再需要创建在构建时生成正则表达式的脚本。</li><li id="d57a" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">从开发人员的角度来看，使用Unicode属性escapes的代码“自动”保持最新:每当Unicode标准获得更新时，ECMAScript引擎都会更新其数据。</li></ol><p id="9093" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">怎么用？</strong></p><ol class=""><li id="ca9a" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">对于非二进制Unicode属性如下:<code class="fe lv lw lx ly b">\p{<em class="lz">UnicodePropertyName</em>=<em class="lz">UnicodePropertyValue</em>}</code></li><li id="08bd" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">对于二进制属性<code class="fe lv lw lx ly b">\p{<em class="lz">LoneUnicodePropertyNameOrValue</em>}</code></li></ol><p id="2e1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt nn ly no np aw nq bi"><span id="9684" class="mb mc it ly b gy nr ns l nt nu">const str = '𝟠';<br/>console.log(/\p{Number}/u.test(str));<!-- --> // true</span></pre><p id="ca87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者</p><pre class="kj kk kl km gt nn ly no np aw nq bi"><span id="8e2f" class="mb mc it ly b gy nr ns l nt nu">const regexGreekSymbol = /\p{Script=Greek}/u;<br/>regexGreekSymbol.test('π'); // true</span></pre><p id="ad60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我怎么知道<code class="fe lv lw lx ly b">UnicodePropertyName</code><strong class="lb iu"><em class="lz"/></strong><code class="fe lv lw lx ly b">UnicodePropertyValue</code><strong class="lb iu"><em class="lz"/></strong>和<code class="fe lv lw lx ly b">LoneUnicodePropertyNameOrValue</code>？</p><p id="5544" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以查看<a class="ae ky" href="http://unicode.org/Public/UNIDATA/PropertyValueAliases.txt" rel="noopener ugc nofollow" target="_blank"> PropertyValueAliases </a>或<a class="ae ky" href="https://tc39.es/proposal-regexp-unicode-property-escapes/#sec-runtime-semantics-unicodematchproperty-p" rel="noopener ugc nofollow" target="_blank">提案文件</a>了解更多信息。</p><p id="1886" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我收集了一些最流行的如下:</p><ol class=""><li id="ffd4" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">\p{Script=...}</code>。从PropertyValueAliases中的<strong class="lb iu"> # Script (sc) </strong>获取。</li><li id="874e" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">\p{General_Category=...}</code>。您从PropertyValueAliases中的<strong class="lb iu"> # General_Category (gc) </strong>获取值。但是，您可以使用<code class="fe lv lw lx ly b">General_Category</code>值的简写，例如用<code class="fe lv lw lx ly b">\p{Letter}</code>代替<code class="fe lv lw lx ly b">\p{General_Category=Letter}</code>。</li><li id="f7ae" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">按照<a class="ae ky" href="http://unicode.org/reports/tr51/" rel="noopener ugc nofollow" target="_blank"> UTR51 </a>匹配表情符号，如<strong class="lb iu">表情符号_修饰符_基础</strong>、<strong class="lb iu">表情符号_修饰符</strong>、<strong class="lb iu">表情符号_呈现</strong>、<strong class="lb iu">表情符号</strong>。</li></ol><p id="38a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:</p><p id="019c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要匹配Unicode中的任何非单词符号，而不仅仅是<code class="fe lv lw lx ly b">[^a-zA-Z0-9_]</code>，请使用:<code class="fe lv lw lx ly b">[^\p{Alphabetic}\p{Mark}\p{Decimal_Number}\p{Connector_Punctuation}\p{Join_Control}]</code>。</p><p id="aacd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">\P{…}</code>是<code class="fe lv lw lx ly b">\p{…}</code>的否定形式</p><p id="3d68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt nn ly no np aw nq bi"><span id="0f74" class="mb mc it ly b gy nr ns l nt nu">const str = '𝟠';<br/>console.log(/\P{Number}/u.test(str));<!-- --> // false</span></pre><p id="ae5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者</p><pre class="kj kk kl km gt nn ly no np aw nq bi"><span id="e9f4" class="mb mc it ly b gy nr ns l nt nu">const regexGreekSymbol = /<strong class="ly iu">\P</strong>{Script=Greek}/u;<br/>regexGreekSymbol.test('π'); // false</span></pre><h2 id="a468" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">摘要</h2><p id="a1be" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">新的正则表达式功能，我们可以节省更多的时间来做一个复杂的任务。<strong class="lb iu">点全标志</strong>改变点的行为。<strong class="lb iu">命名的捕获组</strong>让我们检索数据更容易。<strong class="lb iu">后视断言</strong>使我们能够匹配一个模式，只要它前面有另一个模式。最后，我们将不再痛苦地通过使用<strong class="lb iu"> Unicode属性转义</strong>来创建支持Unicode的正则表达式。</p><p id="5bd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然是新功能，你得先<strong class="lb iu">检查浏览器兼容性</strong>。</p><p id="4c43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章对你有用！可以跟着我上<a class="ae ky" href="https://medium.com/@transonhoang?source=post_page---------------------------" rel="noopener">媒</a>。我也在推特上。欢迎在下面的评论中留下任何问题。我很乐意帮忙！</p><h2 id="ad2a" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">资源/参考资料</h2><p id="6c5c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">[1]:带标志的高级搜索<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Advanced_searching_with_flags_2" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Guide/Regular _ Expressions # Advanced _ searching _ with _ flags _ 2</a></p><p id="0fb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2]:新的JavaScript特性将改变您编写Regex的方式<a class="ae ky" href="https://www.smashingmagazine.com/2019/02/regexp-features-regular-expressions/" rel="noopener ugc nofollow" target="_blank">https://www . smashingmagazine . com/2019/02/regexp-Features-regular-expressions/</a></p><p id="b364" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[3]:完成提案<a class="ae ky" href="https://github.com/tc39/proposals/blob/master/finished-proposals.md" rel="noopener ugc nofollow" target="_blank">https://github . com/tc39/Proposals/blob/master/Finished-Proposals . MD</a></p><p id="f70a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[4]:浏览器兼容性<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#Browser_compatibility" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/RegExp # Browser _ compatibility</a></p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><div class="kj kk kl km gt oi"><a href="https://betterfullstack.com/stories/" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">故事-更好的全栈</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">所有的故事故事为我们写指南提交故事到更好的编程博客1。故事指南避免什么…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">betterfullstack.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ks oi"/></div></div></a></div></div></div>    
</body>
</html>