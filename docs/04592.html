<html>
<head>
<title>Using Redux in Event-Driven Chrome Extensions: Problem/Solution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在事件驱动的Chrome扩展中使用Redux:问题/解决方案</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-redux-in-event-driven-chrome-extensions-problem-solution-30eed1207a42?source=collection_archive---------6-----------------------#2020-07-05">https://levelup.gitconnected.com/using-redux-in-event-driven-chrome-extensions-problem-solution-30eed1207a42?source=collection_archive---------6-----------------------#2020-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/39515ab2b8e0416c9ef07ca29f381207.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*dOklv9wLB1EM0a3XgLe1LA.jpeg"/></div></figure><p id="4c7a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这篇文章面向有经验的web开发人员，解决了在所谓的<em class="kv">事件驱动的</em>扩展中使用Redux的问题——Chrome扩展实现了基于事件的模型。</p><h1 id="6323" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">事件驱动扩展的细节</h1><p id="1f47" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">2012年发布的Chrome 22首次引入了基于事件的扩展模型。它假设一个<a class="ae lz" href="https://developer.chrome.com/extensions/background_pages" rel="noopener ugc nofollow" target="_blank">后台脚本</a>(如果有的话)只在需要的时候加载/运行(主要是响应事件)，空闲的时候卸载。</p><p id="2047" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">Chrome开发者文档强烈建议<a class="ae lz" href="https://developer.chrome.com/extensions/background_migration" rel="noopener ugc nofollow" target="_blank">将</a>现有的持久扩展迁移到基于事件的模型，并将其用于新的扩展，唯一的例外是<a class="ae lz" href="https://developer.chrome.com/extensions/webRequest" rel="noopener ugc nofollow" target="_blank">。但是现在似乎很多扩展都是持久的，即使它们可能是事件驱动的。当然，它们中的许多都是在基于事件的模型为开发人员所知之前首次发布的。现在他们的作者没有动力去迁移到新的模型。这甚至更糟，因为它意味着几乎所有地方都要进行大量的更改，而不仅仅是在后台脚本中。</a></p><p id="9ded" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">此外，扩展开发者使用<a class="ae lz" href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Build_a_cross_browser_extension" rel="noopener ugc nofollow" target="_blank">跨浏览器方法</a>从相同的源代码为不同的浏览器构建扩展是很常见的。基于事件的模型是Chrome特有的特性，与大多数浏览器支持的持久模型有很大的不同。这使得跨浏览器开发成为一个相当困难的问题。</p><p id="6b4b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，一些相对较新的扩展也继续使用持久模型，尽管它们可能是潜在的事件驱动模型。最终，主要原因与迁移案例相同:基于事件的模型和持久模型之间的主要差异，这主要反映在如何处理/管理扩展的状态。</p><h1 id="7719" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Redux的问题</h1><p id="ce30" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">状态管理是对现代web开发有特殊价值的事情之一。一旦变得足够复杂，每个web应用程序(以及浏览器扩展)都需要一种统一的、最好是简单的方式来管理其状态。而这正是Redux大放异彩的地方。Redux 是一个流行的库，它以一致且非常简单的方式帮助管理应用程序的状态。问题是Redux不支持Chrome扩展。</p><p id="c7e9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">首先，所有扩展都有一个固有的问题(不仅仅是Chrome的)，这与一个叫做“真实的单一来源”的基本Redux规则有关，它要求所有的状态都存储在同一个地方。扩展通常由多个独立的组件(如背景或内容脚本)组成，因此很难遵守这一规则。幸运的是，这个问题是可以解决的，有像<a class="ae lz" href="https://github.com/tshaddix/webext-redux" rel="noopener ugc nofollow" target="_blank"> Webext Redux </a>这样的库使用<a class="ae lz" href="https://developer.chrome.com/extensions/messaging" rel="noopener ugc nofollow" target="_blank">消息传递</a>来解决这个问题。不幸的是，由于已经提到的基于事件的模型和持久模型之间的差异，这种解决方案不能应用于事件驱动的扩展。现在是时候仔细看看这些差异以及它们所造成的影响了。</p><p id="690b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在<strong class="jz iu"> <em class="kv">持久</em> </strong>模型中，通常在持久后台脚本中保存扩展的状态(通常在某个局部变量中),该脚本在浏览器关闭之前一直存在/运行，因此该状态总是可以通过后台脚本供其他扩展组件(例如弹出窗口或内容脚本)使用，从而扮演<em class="kv">服务器</em>的角色。这是Webext Redux等库使用的标准持久化方法。</p><figure class="mb mc md me gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ma"><img src="../Images/d6b86b3839081fcee51413b5af203a85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dEG-dW1iHSrEGbl6bCd-9A.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">持续的状态管理方法</figcaption></figure><p id="fc71" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">关于<strong class="jz iu"> <em class="kv">基于事件的</em> </strong>模型，不可能有上面这样的服务器，因为从生命周期的角度来看，包括后台脚本在内的所有组件都是<em class="kv">等于</em>。更具体地说，不能将状态存储在后台脚本中，因为后者可能在任何时刻<em class="kv">从内存中卸载</em>(这是事先无法知道的)。幸运的是这个问题也有解决方案。</p><h1 id="f085" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">解决办法</h1><p id="4b4b" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">解决方案是使用<code class="fe mn mo mp mq b"><a class="ae lz" href="https://developer.chrome.com/extensions/storage" rel="noopener ugc nofollow" target="_blank">chrome.storage</a></code>作为存储/操作扩展状态的<em class="kv">直接</em>位置/方式。顺便提一下，这种方法是官方迁移指南明确建议的，它假设状态立即存储在T1中，每当需要改变状态或跟踪这种改变时，就会调用这个API。</p><figure class="mb mc md me gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ma"><img src="../Images/165276bfdeff80c8a6d82adfaab4f68a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2EDODI2okBEuqk9zBIbLWg.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated"><code class="fe mn mo mp mq b">chrome.storage</code>以国家管理为基础的方法</figcaption></figure><p id="32aa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">作为扩展API的一个集成部分，<code class="fe mn mo mp mq b">chrome.storage</code>有许多优点，其中最重要的是任何扩展组件都可以直接访问它，而不需要任何中介。另一个优点(同时也是其规范的一部分)是通过浏览器会话的状态持久化，这是其开箱即用的内置特性。</p><p id="8aef" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">同样值得注意的是，这种方法在基于事件的模型和持久模型中都有效(以同样的方式)。所以最终我们有了一个被大多数浏览器支持的统一解决方案，这使得跨浏览器开发(有点)更加合理。</p><p id="b029" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">唯一剩下的问题就是<code class="fe mn mo mp mq b">chrome.storage</code>与Redux有差异，无法以Redux的方式使用。当然，你可以直接使用<code class="fe mn mo mp mq b">chrome.storage</code>,或者为它写一些自定义的包装。然而，Redux成为了当今国家管理中的某种标准。因此，最好以某种方式使<code class="fe mn mo mp mq b">chrome.storage</code>适应Redux规则，或者换句话说，从<code class="fe mn mo mp mq b">chrome.storage</code>获得Redux。</p><p id="6d8e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这篇文章中，我们的目标是为<code class="fe mn mo mp mq b">chrome.storage</code>制作Redux兼容的接口，它将把它的行为转换成Redux的术语。在API方面，我们需要实现Redux功能的接口，立即处理Redux存储。它包括<code class="fe mn mo mp mq b">createStore</code>函数，以及它返回的<code class="fe mn mo mp mq b">Store</code>对象(代表Redux store)。下面是它们用JSDoc标签表示的接口:</p><figure class="mb mc md me gt ju"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="caa5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="kv">注意</em>:还有一个<code class="fe mn mo mp mq b">Store.replaceReducer</code>方法在我们的例子中是不需要的，因为内置了状态持久特性。像<code class="fe mn mo mp mq b">combineReducers</code>或<code class="fe mn mo mp mq b">applyMiddleware</code>这样的补充功能也是不需要的，因为它们不会立即处理Redux store。</p><h1 id="1a8b" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">履行</h1><p id="d51e" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">所以我们要写一个实现<code class="fe mn mo mp mq b">Store</code>接口的类。姑且称之为<code class="fe mn mo mp mq b">ReduxedStorage</code>。</p><p id="7b3b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在我们的类中实现<code class="fe mn mo mp mq b">getState</code>和<code class="fe mn mo mp mq b">subscribe</code>方法非常简单，因为它们在<code class="fe mn mo mp mq b">chrome.storage</code> : <code class="fe mn mo mp mq b"><a class="ae lz" href="https://developer.chrome.com/extensions/storage#method-StorageArea-get" rel="noopener ugc nofollow" target="_blank">get</a></code>方法和<code class="fe mn mo mp mq b"><a class="ae lz" href="https://developer.chrome.com/extensions/storage#event-onChanged" rel="noopener ugc nofollow" target="_blank">onChanged</a></code>事件中有紧密的对应关系。当然，它们不会被用来直接替换各自的<code class="fe mn mo mp mq b">Store</code>方法，但是它们将有助于在我们的类中保持状态的最新本地副本。我们可以通过在<code class="fe mn mo mp mq b">ReduxedStorage</code>创建/实例化时调用<code class="fe mn mo mp mq b">chrome.storage</code>的<code class="fe mn mo mp mq b">get</code>方法来初始化我们的类中的状态，然后，每当<code class="fe mn mo mp mq b">onChanged</code>事件触发时，相应地更新状态。因此，我们确保状态总是最新的。那么<code class="fe mn mo mp mq b">getState</code>将是我们类中一个微不足道的getter。<code class="fe mn mo mp mq b">subscribe</code>方法的实现有点困难:它将向一些侦听器数组添加一个侦听器函数，以便在<code class="fe mn mo mp mq b">onChanged</code>事件触发时调用。</p><p id="6555" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">与<code class="fe mn mo mp mq b">getState</code>和<code class="fe mn mo mp mq b">subscribe</code>不同，<code class="fe mn mo mp mq b">chrome.storage</code>没有与<code class="fe mn mo mp mq b">dispatch</code>类似的方法。直接使用像<code class="fe mn mo mp mq b">set</code>这样的<code class="fe mn mo mp mq b">chrome.storage</code>方法与Redux原则不兼容:在Redux中，状态只在创建存储时设置一次，然后只能通过<code class="fe mn mo mp mq b">dispatch</code>调用来更改。所以我们必须以某种方式在我们的<code class="fe mn mo mp mq b">ReduxedStorage</code>类中复制<code class="fe mn mo mp mq b">Store.dispatch</code>的行为。有两种方法可以做到。激进的一将意味着在<code class="fe mn mo mp mq b">chrome.storage</code> API上的相关Redux功能的实际再现。但也有一个折中的选择，将在这篇文章中使用。</p><p id="eb4d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">关键思想是每当在我们的类中调度一些动作时，在内部实例化一个新的Redux存储。当然，这看起来有点奇怪，但这是实际复制的唯一选择。更具体地说，每当我们的<code class="fe mn mo mp mq b">dispatch</code>方法被调用时，我们必须通过调用实际Redux的<code class="fe mn mo mp mq b">createStore</code>函数来实例化一个新的Redux存储，用我们的类的当前状态来初始化它的状态，并调用<code class="fe mn mo mp mq b">Store.dispatch</code>来传递我们的<code class="fe mn mo mp mq b">dispatch</code>方法调用的动作参数。同样，在同一个Redux store上，我们必须添加一个一次性的change listener，用分派的动作产生的新状态更新<code class="fe mn mo mp mq b">chrome.storage</code>(一旦准备好)。每个这样的更新都应该由我们上面描述的<code class="fe mn mo mp mq b">chrome.storage.onChanged</code>监听器来跟踪和处理。</p><p id="53dc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">关于状态初始化的一些注意事项:由于<code class="fe mn mo mp mq b">chrome.storage</code>的<code class="fe mn mo mp mq b">get</code>方法异步运行，我们不能在构造函数内部调用它。因此，我们必须将相关代码放在一个单独的方法中，在构造函数之后立即调用。这个方法，姑且称之为<code class="fe mn mo mp mq b">init</code>，将在<code class="fe mn mo mp mq b">get</code>完成时返回一个待解决的承诺。在<code class="fe mn mo mp mq b">init</code>方法中，我们还需要实例化另一个实际的Redux存储，以便在<code class="fe mn mo mp mq b">chrome.storage</code>当前为空时获得默认状态值作为后备。</p><p id="c247" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这就是<code class="fe mn mo mp mq b">ReduxedStorage</code>类在第一次近似时的样子:</p><figure class="mb mc md me gt ju"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="fbfd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="kv">注意</em>:我们必须使用特定键(由<code class="fe mn mo mp mq b">this.key</code>常量指定)下的一部分<code class="fe mn mo mp mq b">chrome.storage</code>数据，以便能够在<code class="fe mn mo mp mq b">chrome.storage.onChanged</code>监听器中立即获得新状态，而无需额外的<code class="fe mn mo mp mq b">chrome.storage</code>的<code class="fe mn mo mp mq b">get</code>调用。此外，如果状态应该表示为数组，这也是有用的，因为<code class="fe mn mo mp mq b">chrome.storage</code>只允许普通对象存储在根级别。</p><p id="09d7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">不幸的是，上面的实现有一个不明显的缺陷，这是由我们通过<code class="fe mn mo mp mq b">chrome.storage</code>的<code class="fe mn mo mp mq b"><a class="ae lz" href="https://developer.chrome.com/extensions/storage#method-StorageArea-set" rel="noopener ugc nofollow" target="_blank">set</a></code>方法和<code class="fe mn mo mp mq b">chrome.storage.onChanged</code>监听器间接更新<code class="fe mn mo mp mq b">this.state</code>属性造成的。这本身不是问题。然而，在<code class="fe mn mo mp mq b">dispatch</code>方法中创建一个Redux存储依赖于<code class="fe mn mo mp mq b">this.state</code>，这可能是一个问题，因为<code class="fe mn mo mp mq b">this.state</code>可能不总是反映实际状态。如果一个人在一行中同时调度多个动作，就可能出现这种情况。在这种情况下，第二次和所有后续的<code class="fe mn mo mp mq b">dispatch</code>调用处理<code class="fe mn mo mp mq b">this.state</code>中的过期数据，由于<code class="fe mn mo mp mq b">chrome.storage</code>的<code class="fe mn mo mp mq b">set</code>方法的异步特性，这些数据在调用时还没有更新。因此，分派多个同步动作可能会导致意想不到的/不想要的结果。</p><p id="7ae2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了解决上面的问题，可以修改<code class="fe mn mo mp mq b">dispatch</code>方法，为多个动作重用相同的Redux存储(以及相关的状态)。这种缓冲存储必须在一小段超时时间后复位/重新创建，默认为100毫秒。这意味着我们必须为缓冲的Redux存储和相关状态分配额外的类属性。下面是这种缓冲的<code class="fe mn mo mp mq b">dispatch</code>版本可能的样子:</p><figure class="mb mc md me gt ju"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="9680" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">正如经常发生的那样，解决一个问题可能会引发另一个问题。在我们的例子中，使用缓冲的可重用存储代替本地一次性存储可能会破坏Redux中的异步逻辑。默认情况下，Redux中没有的异步逻辑可以使用中间件引入，如<a class="ae lz" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank"> Redux Thunk </a>。使用Redux Thunk，可以通过编写返回函数而不是动作的动作创建器来延迟动作的分派。下面是这种动作创建者的一个例子:</p><figure class="mb mc md me gt ju"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="257b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe mn mo mp mq b">delayAddTodo</code>延迟1秒发出<code class="fe mn mo mp mq b">ADD_TODO</code>动作。</p><p id="763b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果我们试图将这个动作创建器与上述缓冲的<code class="fe mn mo mp mq b">dispatch</code>方法一起使用，我们在调用<code class="fe mn mo mp mq b">this.buffStore.subscribe</code>回调中的<code class="fe mn mo mp mq b">this.buffStore.getState</code>时会得到一个错误。这是因为在这种特定情况下，当<code class="fe mn mo mp mq b">this.buffStore</code>已经被重置为<code class="fe mn mo mp mq b">null</code>(从<code class="fe mn mo mp mq b">dispatch</code>调用起100毫秒)时，在<code class="fe mn mo mp mq b">dispatch</code>调用之后至少1秒将调用<code class="fe mn mo mp mq b">this.buffStore.subscribe</code>回调。相比之下，以前的“dispatch”版本可以很好地处理这种异步动作创建器(以及单同步创建器),因为它使用一个本地存储，该存储对于相关的<code class="fe mn mo mp mq b">subscribe</code>回调总是可用的。</p><p id="d217" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，我们必须结合两种方法，即使用Redux存储的缓冲版本和本地版本。前者将用于同步操作，后者用于需要一些时间的异步操作，就像上面的<code class="fe mn mo mp mq b">delayAddTodo</code>。然而，这并不意味着我们在一个<code class="fe mn mo mp mq b">dispatch</code>调用中需要两个独立的Redux store实例。我们可以在<code class="fe mn mo mp mq b">this.buffStore</code>类属性中实例化一次Redux store(对应缓冲版本)，然后将其引用复制到一个局部变量中，姑且称之为<code class="fe mn mo mp mq b">lastStore</code>。所以当<code class="fe mn mo mp mq b">this.buffStore</code>被重置为<code class="fe mn mo mp mq b">null</code>时，<code class="fe mn mo mp mq b">lastStore</code>应该仍然引用同一个Redux存储，并可用于相关的<code class="fe mn mo mp mq b">subscribe</code>回调。因此，如果<code class="fe mn mo mp mq b">this.buffStore</code>不可用(这意味着异步操作),我们可以使用内部<code class="fe mn mo mp mq b">subscribe</code>监听器中的<code class="fe mn mo mp mq b">lastStore</code>作为后备。当在内部<code class="fe mn mo mp mq b">subscribe</code>回调中处理状态变化时，取消订阅给定的回调/监听器并重置<code class="fe mn mo mp mq b">lastStore</code>变量以释放相关资源会很有用。</p><p id="3d58" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">此外，最好对整体代码进行一些改进/重构，例如:</p><ul class=""><li id="a021" class="mt mu it jz b ka kb ke kf ki mv km mw kq mx ku my mz na nb bi translated">使<code class="fe mn mo mp mq b">this.areaName</code>和<code class="fe mn mo mp mq b">this.key</code>属性可变/可定制。</li><li id="b2c2" class="mt mu it jz b ka nc ke nd ki ne km nf kq ng ku my mz na nb bi translated">把直接调用<code class="fe mn mo mp mq b">chrome.storage</code> API的代码移到一个单独的类中，姑且称之为<code class="fe mn mo mp mq b">WrappedStorage</code>。</li></ul><p id="342b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">所以下面是结果实现:</p><figure class="mb mc md me gt ju"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="dfbb" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">它的用法类似于原始的Redux，除了我们的商店创建者被包装在一个定制器函数中，并以异步方式工作，返回一个承诺而不是一个新的商店，这是由于<code class="fe mn mo mp mq b">chrome.storage</code> API的异步特性。</p><p id="d628" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">标准用法如下:</p><figure class="mb mc md me gt ju"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="3156" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">此外，随着<code class="fe mn mo mp mq b">async/await</code>功能的推出(从ES 2017开始)，我们的界面可以以如下高级方式使用:</p><figure class="mb mc md me gt ju"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="b8df" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><a class="ae lz" href="https://github.com/hindmost/reduxed-chrome-storage" rel="noopener ugc nofollow" target="_blank">这里的</a>是我们刚刚做的库的源代码。你可以根据需要使用它。</p><p id="3c76" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">它还提供NPM套装:</p><pre class="mb mc md me gt nh mq ni nj aw nk bi"><span id="0200" class="nl kx it mq b gy nm nn l no np">npm install reduxed-chrome-storage</span></pre></div></div>    
</body>
</html>