<html>
<head>
<title>Linear Algebra Concepts (For Machine Learning)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">线性代数概念(用于机器学习)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/linear-algebra-concepts-for-machine-learning-fa7549c6a722?source=collection_archive---------15-----------------------#2020-07-15">https://levelup.gitconnected.com/linear-algebra-concepts-for-machine-learning-fa7549c6a722?source=collection_archive---------15-----------------------#2020-07-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="2d7f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="36fb" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">机器学习的基础是完全纯粹的数学和逻辑。我们可以理解逻辑，进一步实现它取决于个人的经验和创造性思维，但为此，我们需要理解一些线性代数的基础知识，以及如何处理矩阵和张量。</p><p id="0a25" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我将使用<em class="lo"> NumPy </em>作为大部分数学函数和处理数据的主库。</p><p id="1fd3" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">所有代码都在我的Github资源库中，<a class="ae lp" href="https://github.com/aryanchugh816/Data-Science/tree/master/03%20-%20Linear%20Algebra%20(For%20Machine%20Learning)" rel="noopener ugc nofollow" target="_blank">点击这里</a>访问它。我已经开始了一系列很好的解释性文章，这些文章将涵盖数据科学管道的所有主要主题，请访问我的主<a class="ae lp" href="https://github.com/aryanchugh816/Data-Science" rel="noopener ugc nofollow" target="_blank"> Github库</a>以阅读更多这样的文章和代码。</p><p id="0707" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这篇文章需要对Numpy有一个基本的了解，所以我建议先浏览下面的文章。</p><div class="lq lr gp gr ls lt"><a href="https://medium.com/swlh/numpy-basics-for-machine-learning-4e5e0af3b0c3" rel="noopener follow" target="_blank"><div class="lu ab fo"><div class="lv ab lw cl cj lx"><h2 class="bd ir gy z fp ly fr fs lz fu fw ip bi translated">机器学习的Numpy基础</h2><div class="ma l"><h3 class="bd b gy z fp ly fr fs lz fu fw dk translated">统计数字</h3></div><div class="mb l"><p class="bd b dl z fp ly fr fs lz fu fw dk translated">medium.com</p></div></div><div class="mc l"><div class="md l me mf mg mc mh mi lt"/></div></div></a></div><h1 id="667e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">主题:</h1><ul class=""><li id="0ff5" class="mj mk iq kn b ko kp ks kt kw ml la mm le mn li mo mp mq mr bi translated">标量和向量</li><li id="eba2" class="mj mk iq kn b ko ms ks mt kw mu la mv le mw li mo mp mq mr bi translated">矩阵和张量</li><li id="c66e" class="mj mk iq kn b ko ms ks mt kw mu la mv le mw li mo mp mq mr bi translated"><strong class="kn ir">操作:</strong></li><li id="82c6" class="mj mk iq kn b ko ms ks mt kw mu la mv le mw li mo mp mq mr bi translated">1.移项</li><li id="d330" class="mj mk iq kn b ko ms ks mt kw mu la mv le mw li mo mp mq mr bi translated">2.广播</li><li id="9251" class="mj mk iq kn b ko ms ks mt kw mu la mv le mw li mo mp mq mr bi translated">4.矩阵乘法</li><li id="0fc0" class="mj mk iq kn b ko ms ks mt kw mu la mv le mw li mo mp mq mr bi translated">5.哈达玛乘积(逐元素乘法)</li><li id="7095" class="mj mk iq kn b ko ms ks mt kw mu la mv le mw li mo mp mq mr bi translated">规范</li><li id="91c7" class="mj mk iq kn b ko ms ks mt kw mu la mv le mw li mo mp mq mr bi translated">决定因素</li><li id="ca3c" class="mj mk iq kn b ko ms ks mt kw mu la mv le mw li mo mp mq mr bi translated">相反的</li><li id="bb1d" class="mj mk iq kn b ko ms ks mt kw mu la mv le mw li mo mp mq mr bi translated">线性方程组</li></ul><h1 id="e2c3" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">标量和向量</h1><p id="990b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">出于编程的目的，我们不会使用标量和向量的正式定义(如物理学中的定义),而是一个更有用和简单的定义。</p><p id="21a1" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">一个<strong class="kn ir">标量</strong>是一个单一的数字，通常表示为<em class="lo"> x. </em>我们可以把标量看作常量/值，用来缩放一个矢量，甚至形成一个矢量。</p><p id="c345" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">一个<strong class="kn ir">向量</strong>是一个标量数组，用<strong class="kn ir"> x <em class="lo"> </em> </strong>表示，因此向量可以有n个标量<strong class="kn ir"> <em class="lo">。</em> </strong>向量可以看做列表(从计算机系学生的角度)，也可以看做空间中的箭头(从物理系学生的角度)。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="697f" class="ng jo iq nc b gy nh ni l nj nk">import numpy as np</span><span id="fb79" class="ng jo iq nc b gy nl ni l nj nk"># Two ways of representing vectors:</span><span id="fca0" class="ng jo iq nc b gy nl ni l nj nk"># 1) Representing vector as a row vector, that is having multiple columns<br/>x1 = np.array([4,5,6])<br/>print(x1)<br/>print(x1.shape)<br/>print("----------------------------------")</span><span id="4c84" class="ng jo iq nc b gy nl ni l nj nk"># 2) Representing vector as a column vector, that is having multiple rows<br/>x2 = np.array([[4], [5], [8]])<br/>print(x2)<br/>print(x2.shape)</span></pre><h2 id="3046" class="ng jo iq bd jp nm nn dn jt no np dp jx kw nq nr kb la ns nt kf le nu nv kj nw bi translated">输出</h2><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="3f99" class="ng jo iq nc b gy nh ni l nj nk">[4 5 6]<br/>(3,)<br/>----------------------------------<br/>[[4]<br/> [5]<br/> [8]]<br/>(3, 1)</span></pre><h1 id="3c73" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">矩阵和张量</h1><p id="6c43" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kn ir">矩阵</strong>是由<em class="lo"> X表示的2D标量数组。</em>以矩阵形式表示数字数据将有助于更快、更有效地执行不同的操作。</p><figure class="mx my mz na gt ny gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/7c2fb454488ce005c3fdd73d10d4e47b.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*-yHwB6I4dshs27doID7ENg.jpeg"/></div></figure><ul class=""><li id="9e08" class="mj mk iq kn b ko lj ks lk kw oa la ob le oc li mo mp mq mr bi translated">这个矩阵有2(m)行和2(n)列</li><li id="ef2e" class="mj mk iq kn b ko ms ks mt kw mu la mv le mw li mo mp mq mr bi translated">这个矩阵的每个元素都是一个标量</li><li id="1769" class="mj mk iq kn b ko ms ks mt kw mu la mv le mw li mo mp mq mr bi translated">如果m = n，则该矩阵称为方阵</li></ul><p id="78a9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">张量</strong>是一个多于2个轴的数组，即张量是一个可以容纳N维数据的容器。张量由<strong class="kn ir"> X. </strong>表示</p><figure class="mx my mz na gt ny gh gi paragraph-image"><div class="gh gi od"><img src="../Images/d9f7286580112afce028f14e05ddf458.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*6hLroaW5a8SPG8y210F9dg.jpeg"/></div></figure><ul class=""><li id="a0fe" class="mj mk iq kn b ko lj ks lk kw oa la ob le oc li mo mp mq mr bi translated">可以把张量看作是具有两个以上轴的数组的推广</li><li id="5045" class="mj mk iq kn b ko ms ks mt kw mu la mv le mw li mo mp mq mr bi translated">我们可以把张量看成一个以上(m×n)的矩阵，一层一层地堆叠在一起</li><li id="81c1" class="mj mk iq kn b ko ms ks mt kw mu la mv le mw li mo mp mq mr bi translated">张量在深度学习任务中非常有用</li></ul><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="bc34" class="ng jo iq nc b gy nh ni l nj nk"># Here T is a Tensor<br/>T = np.array([[[4,5,7], [10,11,13]], [[56,80,90], [9,8,10]]])</span><span id="9ff5" class="ng jo iq nc b gy nl ni l nj nk">print(T.shape)<br/>print(T)</span></pre><h2 id="0bb9" class="ng jo iq bd jp nm nn dn jt no np dp jx kw nq nr kb la ns nt kf le nu nv kj nw bi translated">输出</h2><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="b9e1" class="ng jo iq nc b gy nh ni l nj nk">(2, 2, 3)<br/>[[[ 4  5  7]<br/>  [10 11 13]]<br/><br/> [[56 80 90]<br/>  [ 9  8 10]]]</span></pre><h1 id="0a4a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">操作</h1><h2 id="85b6" class="ng jo iq bd jp nm nn dn jt no np dp jx kw nq nr kb la ns nt kf le nu nv kj nw bi translated">矩阵的转置</h2><p id="ab6c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">矩阵的转置只不过是它沿对角线的镜像。对于2D矩阵，转置可以由A(i，j) = A(j，I)得到。在向量的情况下，转置使一列向量变成一行。因此，列向量也可以表示为X = [x1，x2，x3 … xn]^T.</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="5026" class="ng jo iq nc b gy nh ni l nj nk">X = np.array([[4,5,7], [10,11,13], [56,80,90]])<br/>print(X)<br/>print("----------------------------------")</span><span id="7b33" class="ng jo iq nc b gy nl ni l nj nk"># Transpose of x:<br/>Xt = np.transpose(X)<br/>print(Xt)<br/># Can also find transpose using the following method: X.T</span></pre><h2 id="3dc4" class="ng jo iq bd jp nm nn dn jt no np dp jx kw nq nr kb la ns nt kf le nu nv kj nw bi translated">输出</h2><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="91fc" class="ng jo iq nc b gy nh ni l nj nk">[[ 4  5  7]<br/> [10 11 13]<br/> [56 80 90]]<br/>----------------------------------<br/>[[ 4 10 56]<br/> [ 5 11 80]<br/> [ 7 13 90]]</span></pre><h2 id="a5fa" class="ng jo iq bd jp nm nn dn jt no np dp jx kw nq nr kb la ns nt kf le nu nv kj nw bi translated">广播</h2><p id="04cb" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">术语<strong class="kn ir"> <em class="lo">广播</em> </strong>是指Numpy在导致某些约束的算术运算期间如何处理不同维度的数组，较小的数组在较大的数组中广播，以便它们具有兼容的形状。</p><p id="cd11" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">广播在机器学习和深度学习操作中非常有用，因为它将我们使用嵌套循环替代执行的数组操作矢量化。我们将在以下示例中看到这一点:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="d129" class="ng jo iq nc b gy nh ni l nj nk">l1 = np.array([1,2,3,4])<br/>l1 = l1 + 1 # Broadcasting operation<br/>print(l1)<br/>print("----------------------------------")</span><span id="820e" class="ng jo iq nc b gy nl ni l nj nk"># We can perform broadcasting operations on  matrix too<br/>l = np.array([[1,2,3,4], [5,6,7,8]])<br/>print(l)<br/>print("----------------------------------")</span><span id="f60e" class="ng jo iq nc b gy nl ni l nj nk">l = l**2<br/>print(l)</span></pre><h2 id="9e77" class="ng jo iq bd jp nm nn dn jt no np dp jx kw nq nr kb la ns nt kf le nu nv kj nw bi translated">输出</h2><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="ad4e" class="ng jo iq nc b gy nh ni l nj nk">[2 3 4 5]<br/>----------------------------------<br/>[[1 2 3 4]<br/> [5 6 7 8]]<br/>----------------------------------<br/>[[ 1  4  9 16]<br/> [25 36 49 64]]</span></pre><p id="18a1" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在广播中，较小维度的数组/矩阵被整形并扩展到较大矩阵的维度，然后对较大矩阵进行逐元素操作，因此广播操作比C或C++中的嵌套循环更快。</p><p id="79bd" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir"> Python列表不支持广播</strong>，所以你最好在使用它们之前先把它们转换成Numpy数组，否则我们将使用<strong class="kn ir">映射一个函数来对列表执行任何简单的操作</strong>。</p><h2 id="1787" class="ng jo iq bd jp nm nn dn jt no np dp jx kw nq nr kb la ns nt kf le nu nv kj nw bi translated">矩阵乘法</h2><figure class="mx my mz na gt ny gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/c823d7d97805f929106d8ff6405f081b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*gUeS7olaK8z7TZTpf38h5g.jpeg"/></div></figure><ul class=""><li id="0e3e" class="mj mk iq kn b ko lj ks lk kw oa la ob le oc li mo mp mq mr bi translated">C= AB仅在A的第二维度与B的第一维度匹配时定义</li><li id="4713" class="mj mk iq kn b ko ms ks mt kw mu la mv le mw li mo mp mq mr bi translated">此外，如果A的形状为(m，n ), B的形状为(n，p ),则C的形状为(m，p)</li><li id="24b6" class="mj mk iq kn b ko ms ks mt kw mu la mv le mw li mo mp mq mr bi translated">通过取A的第I行与B的第j列的点积来计算C(ij)</li><li id="d54c" class="mj mk iq kn b ko ms ks mt kw mu la mv le mw li mo mp mq mr bi translated">考虑矩阵乘法的更有用的方法是矩阵A的列的线性组合，由矩阵B的列条目加权(该方法在第一行的图像的下部描述)</li></ul><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="0894" class="ng jo iq nc b gy nh ni l nj nk">X = np.array([[4,5,7], [10, 11,13], [56,80,90]])<br/>Y = np.array([[40,50,70], [100,110,130], [560,800,900]])<br/>print(X.shape)<br/>print("----------------------------------")<br/>print(Y.shape)<br/>print("----------------------------------")</span><span id="023a" class="ng jo iq nc b gy nl ni l nj nk"># To get the matrix multiplication result of the two arrays:<br/>prod = np.dot(X,Y)<br/>print(prod)</span></pre><h2 id="4b87" class="ng jo iq bd jp nm nn dn jt no np dp jx kw nq nr kb la ns nt kf le nu nv kj nw bi translated">输出</h2><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="a64d" class="ng jo iq nc b gy nh ni l nj nk">[[ 4  5  7]<br/> [10 11 13]<br/> [56 80 90]]<br/>----------------------------------<br/>[[ 40  50  70]<br/> [100 110 130]<br/> [560 800 900]]<br/>----------------------------------<br/>[[ 4580  6350  7230]<br/> [ 8780 12110 13830]<br/> [60640 83600 95320]]</span></pre><h2 id="1a76" class="ng jo iq bd jp nm nn dn jt no np dp jx kw nq nr kb la ns nt kf le nu nv kj nw bi translated">哈达玛乘积(逐元素乘法)</h2><p id="243b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果我们对一个数组中的每个元素只应用前一个数组中的相应元素的运算，我们会得到一个元素式乘积。</p><figure class="mx my mz na gt ny gh gi paragraph-image"><div class="gh gi of"><img src="../Images/c2c31b6dd5df49e283d0c3db8a6dd0de.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*1bmwNgcON7xWvrnFhMaVUg.png"/></div></figure><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="ffcd" class="ng jo iq nc b gy nh ni l nj nk">X = np.array([[4,5,7], [10, 11,13], [56,80,90]])<br/>Y = np.eye(3)</span><span id="f895" class="ng jo iq nc b gy nl ni l nj nk"># Element wise multiplication:<br/>print(X*Y)<br/>print("----------------------------------")</span><span id="67ac" class="ng jo iq nc b gy nl ni l nj nk">#VS<br/># Matrix multiplication<br/>print(np.dot(X,Y))</span></pre><h2 id="3597" class="ng jo iq bd jp nm nn dn jt no np dp jx kw nq nr kb la ns nt kf le nu nv kj nw bi translated">输出</h2><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="f6d6" class="ng jo iq nc b gy nh ni l nj nk">[[ 4.  0.  0.]<br/> [ 0. 11.  0.]<br/> [ 0.  0. 90.]]<br/>----------------------------------<br/>[[ 4.  5.  7.]<br/> [10. 11. 13.]<br/> [56. 80. 90.]]</span></pre><h1 id="dbcd" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">规范</h1><p id="8380" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kn ir">向量</strong>空间中向量的<strong class="kn ir">范数是一个真实的非负值，直观地表示向量的长度、大小或大小。</strong></p><figure class="mx my mz na gt ny gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi og"><img src="../Images/a553e82a5398814e8cd6281265ac9f0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e-UorixKNMmK7qLvMdvyaQ.jpeg"/></div></div></figure><p id="6df1" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">需要记住以下几点:</p><ul class=""><li id="749f" class="mj mk iq kn b ko lj ks lk kw oa la ob le oc li mo mp mq mr bi translated">l-范数，也称为<em class="lo">欧几里德范数</em>是最常用的范数</li><li id="63c8" class="mj mk iq kn b ko ms ks mt kw mu la mv le mw li mo mp mq mr bi translated">l-范数是向量所有元素的简单和</li><li id="4f91" class="mj mk iq kn b ko ms ks mt kw mu la mv le mw li mo mp mq mr bi translated">L^{infinity}给出了该数组的最大数，我们可以通过上面给出的公式来验证这一点</li></ul><p id="b531" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">规范使用Numpy </strong></p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="30fe" class="ng jo iq nc b gy nh ni l nj nk">X = np.array([-5,3,10])</span><span id="cccd" class="ng jo iq nc b gy nl ni l nj nk"># Finding norm of a vector using numpy</span><span id="2098" class="ng jo iq nc b gy nl ni l nj nk">lp2 = np.linalg.norm(X) <br/># By default it is treated as L2 norm and 'linalg' stands for linear algebra module</span><span id="4f01" class="ng jo iq nc b gy nl ni l nj nk">print(lp2)</span></pre><h2 id="7890" class="ng jo iq bd jp nm nn dn jt no np dp jx kw nq nr kb la ns nt kf le nu nv kj nw bi translated">输出</h2><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="d79f" class="ng jo iq nc b gy nh ni l nj nk">11.575836902790225</span></pre><h1 id="0934" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">决定因素</h1><p id="f56f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">行列式有助于我们找到矩阵的逆矩阵，并为我们提供有关矩阵的信息，这些信息可用于不同的应用，如方程组、微积分等。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="4603" class="ng jo iq nc b gy nh ni l nj nk">A = np.array([[1,2],<br/>              [3,4]])<br/>print(np.linalg.det(A))</span></pre><h2 id="2df5" class="ng jo iq bd jp nm nn dn jt no np dp jx kw nq nr kb la ns nt kf le nu nv kj nw bi translated">输出</h2><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="5e64" class="ng jo iq nc b gy nh ni l nj nk">-2.0000000000000004</span></pre><h1 id="bded" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">相反的</h1><p id="6c4b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在下面的代码中，我们将实现两种类型的反演:-</p><ol class=""><li id="5087" class="mj mk iq kn b ko lj ks lk kw oa la ob le oc li ol mp mq mr bi translated"><strong class="kn ir">正逆</strong>:这个只能在矩阵的行列式不为零且为方阵的情况下计算。</li><li id="5489" class="mj mk iq kn b ko ms ks mt kw mu la mv le mw li ol mp mq mr bi translated"><strong class="kn ir"> Moore-Penrose伪逆</strong>:这个逆可以在非零非方阵上计算。如果矩阵是可逆的，我们得到与正规逆矩阵相同的结果。关于这个<a class="ae lp" href="https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/pseudinv.htm#:~:text=The%20Moore%2DPenrose%20pseudo%20inverse%20is%20a%20generalization%20of%20the,when%20A%20is%20not%20invertible." rel="noopener ugc nofollow" target="_blank">的更多信息，请点击这里</a>。</li></ol><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="da1b" class="ng jo iq nc b gy nh ni l nj nk">A = np.array([[1,2],<br/>              [3,4]])</span><span id="3a6f" class="ng jo iq nc b gy nl ni l nj nk">Ainv = np.linalg.inv(A) # Normal Inverse<br/>print(Ainv)<br/>print("----------------------------------")<br/>       <br/>pinv = np.linalg.pinv(A) # Pseudo Inverse<br/>print(pinv)<br/>print("----------------------------------")</span><span id="411c" class="ng jo iq nc b gy nl ni l nj nk">B = np.array([[6,3], # Matrix with determinant = 0<br/>              [8,4]])</span><span id="19fd" class="ng jo iq nc b gy nl ni l nj nk">pinv = np.linalg.pinv(B)<br/>print(inv)</span></pre><h2 id="6019" class="ng jo iq bd jp nm nn dn jt no np dp jx kw nq nr kb la ns nt kf le nu nv kj nw bi translated">输出</h2><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="cf64" class="ng jo iq nc b gy nh ni l nj nk">[[-2.   1. ]<br/> [ 1.5 -0.5]]<br/>----------------------------------<br/>[[-2.   1. ]<br/> [ 1.5 -0.5]]<br/>----------------------------------<br/>[[0.048 0.064]<br/> [0.024 0.032]]</span></pre><h1 id="14a6" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">解线性方程组</h1><figure class="mx my mz na gt ny gh gi paragraph-image"><div class="gh gi om"><img src="../Images/9bef9c2b6c232a06120fc1117becb643.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*xwvMNlLb05s7VEkU4eGR1A.png"/></div></figure><p id="2232" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这个可以用来解一个线性方程组，<a class="ae lp" href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.solve.html#numpy.linalg.solve" rel="noopener ugc nofollow" target="_blank">点击这里</a>查看函数。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="9763" class="ng jo iq nc b gy nh ni l nj nk">A = np.array([[2, 4, 6],<br/>              [4, 5, 6],<br/>              [3, 1, -2]])<br/>B = np.array([18, 24, 4])</span><span id="d492" class="ng jo iq nc b gy nl ni l nj nk">print(np.linalg.solve(A,B))</span></pre><h2 id="ede1" class="ng jo iq bd jp nm nn dn jt no np dp jx kw nq nr kb la ns nt kf le nu nv kj nw bi translated">输出</h2><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="bd47" class="ng jo iq nc b gy nh ni l nj nk">[ 4. -2.  3.]</span></pre><h1 id="e9e1" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="9f8f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我希望这篇文章对使用基本的线性代数概念有一个简要的了解，并在各种应用中使用它们，并鼓励你学习更多或用它创造一些好东西。</p><p id="5a5d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">更多有趣的项目和说明代码请随意浏览我的</strong><a class="ae lp" href="https://github.com/aryanchugh816/Data-Science" rel="noopener ugc nofollow" target="_blank"><strong class="kn ir">Github repositor</strong></a><strong class="kn ir">y。</strong></p><p id="c650" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果您喜欢我的任何工作，请随时<a class="ae lp" href="mailto:%20chugharyan816@gmail.com" rel="noopener ugc nofollow" target="_blank"> <strong class="kn ir">联系我</strong> </a>有关任何项目合作或工作机会。</p></div></div>    
</body>
</html>