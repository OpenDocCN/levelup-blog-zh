<html>
<head>
<title>Advanced TypeScript Types with Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有示例的高级类型脚本类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/advanced-typescript-types-with-examples-1d144e4eda9e?source=collection_archive---------0-----------------------#2018-06-28">https://levelup.gitconnected.com/advanced-typescript-types-with-examples-1d144e4eda9e?source=collection_archive---------0-----------------------#2018-06-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a435" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">提高您对TypeScript的理解，并学习这些高级技术来帮助您掌握这种语言并通过React使用TypeScript</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/317ca7bf0aaaa77b42a3089a16d5cca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Su5pVgmuDMgBnKMH3hhkBQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">不同种类的水果:)照片由<a class="ae kv" href="https://unsplash.com/photos/1cWZgnBhZRs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卢克·迈克尔</a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="b696" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我去年冬天开始使用TypeScript时，我已经从默认使用<code class="fe ls lt lu lv b">any</code>来处理所有比<code class="fe ls lt lu lv b">string</code>或<code class="fe ls lt lu lv b">number</code>更复杂的类型，到现在对高级内置类型和自定义类型的使用感到很舒服。通过切换到TypeScript向JavaScript代码添加类型，以编写密封的应用程序。本文将提供使用高级类型的例子，以及如何在React应用程序中使用它们。</p><p id="1fcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将讨论<code class="fe ls lt lu lv b">Record</code><em class="lw"/><code class="fe ls lt lu lv b">Partial</code><em class="lw"/><code class="fe ls lt lu lv b">Required</code><em class="lw"/><code class="fe ls lt lu lv b">Pick</code>和一个自定义的<code class="fe ls lt lu lv b">Omit</code>类型。</p><div class="lx ly gp gr lz ma"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd ir gy z fp mf fr fs mg fu fw ip bi translated">编写面试问题</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">技术开发</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo kp ma"/></div></div></a></div><h1 id="f219" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">记录</h1><p id="9a80" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">Typescript 2.1 引入的一个非常有用的内置类型<a class="ae kv" href="https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#typescript-21" rel="noopener ugc nofollow" target="_blank">是<code class="fe ls lt lu lv b">Record</code>:它允许你创建一个类型化的<code class="fe ls lt lu lv b">map</code>，对于创建复合接口非常有用。要将变量类型化为<code class="fe ls lt lu lv b">Record</code>，您必须将一个字符串作为一个键，并为其相应的值传递一些类型。最简单的情况是当您有一个<code class="fe ls lt lu lv b">string</code>作为值时:</a></p><pre class="kg kh ki kj gt nm lv nn no aw np bi"><span id="de82" class="nq mq iq lv b gy nr ns l nt nu">const SERVICES: Record&lt;string, string&gt; = { <br/>    doorToDoor: "delivery at door",<br/>    airDelivery: "flying in",<br/>    specialDelivery: "special delivery",<br/>    inStore: "in-store pickup",<br/>};</span></pre><p id="3ef1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可能看起来微不足道，但它为您的日常代码输入提供了便利。<code class="fe ls lt lu lv b">Record</code>运行良好的一个流行的例子是一个业务实体的接口，它作为键-值对保存在字典中。这个模型可以表示联系人、事件、用户数据、交通请求、电影票等等的集合。在下面的示例中，我们为用户可以添加到购物车中的产品创建了一个模型:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/2bb79255c9b385e131fd7fa07eeea14d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SlIL-nD7yMgKDgLrEkKo_Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">类型记录用于用户购物车中的产品字典。</figcaption></figure><p id="5b01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将看到编辑器自动完成功能如何帮助我们定义一个类型化的对象，并将变量标记为一个错误，因为没有定义所有必需的属性:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/a6d02627ff726abadaf75b1ed908b5d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P9AmX5SnG1TDngdZYuvOdg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Webstorm自动完成工具建议为CartState变量添加名称和数量</figcaption></figure><p id="03c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，Typescript不允许我们为某个已定义的形状创建一个空对象，然后用属性填充它，但是这里的<code class="fe ls lt lu lv b">Record</code>可以帮助我们。</p><p id="48ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也可以使用<code class="fe ls lt lu lv b">string</code> <code class="fe ls lt lu lv b">enum</code>作为<code class="fe ls lt lu lv b">Record</code>类型的键。例如，我们将使用<code class="fe ls lt lu lv b">ErrorsEnum</code>来保存和访问可能的错误值(消息):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/f152fdef25fe4525345cd9d101a6f3c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5EUEcXmo8nfmsB8FPvnDhg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在业务模型中使用错误记录字典</figcaption></figure><blockquote class="ny nz oa"><p id="bd44" class="kw kx lw ky b kz la jr lb lc ld ju le ob lg lh li oc lk ll lm od lo lp lq lr ij bi translated">让我们看看如何在使用<a class="ae kv" href="https://material-ui-next.com" rel="noopener ugc nofollow" target="_blank"> Material-UI </a>库时使用它来增强类型。正如指南所说，您可以使用<a class="ae kv" href="https://material-ui-next.com/customization/css-in-js/" rel="noopener ugc nofollow" target="_blank"> CSS-in-JS符号</a>添加自定义样式，并通过<code class="fe ls lt lu lv b">withStyles</code> HOC注入它们。您可以将样式定义为一个函数，该函数将一个<code class="fe ls lt lu lv b">theme</code>作为参数，并返回带有对应样式的未来<code class="fe ls lt lu lv b">className</code>，并且您想要为此函数定义一个类型:</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/a823c3b1686605b5d2e37a613d9e4ed6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yEY0CgvEhoFgxXE3KF8nHg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在每个组件文件中添加样式函数的类型</figcaption></figure><p id="e8b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您会注意到为每个样式对象添加这些<code class="fe ls lt lu lv b">as CSSProperties</code>会变得非常烦人。或者，您可以利用<code class="fe ls lt lu lv b">Record</code>类型的优势，为<code class="fe ls lt lu lv b">styles</code>函数定义一个类型:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/4ff52d8dc0384d859250c1b5a73e8ba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*okfK0Q1VYfQKzKaaVL-9zg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">到处使用一次定义的createThemeFunction类型</figcaption></figure><p id="b2df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您可以在每个组件中安全地使用它，并在您的样式中摆脱硬编码类型的CSS属性。</p><h1 id="9b61" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">部分和必需</h1><p id="2aa3" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Partial</code>类型使对象中的所有属性都是可选的。在许多情况下，它会对您有所帮助，例如，当您正在处理某个组件将呈现的数据，但您知道在挂载时可能无法获取该数据时:</p><div class="kg kh ki kj gt ab cb"><figure class="og kk oh oi oj ok ol paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/b207b0881e9b9c74ac5ca372a3ec2a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*11cUeBpNXN7Wf9I_xmdw6A.png"/></div></figure><figure class="og kk om oi oj ok ol paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/1e280a8521c2f8321599ec0e8cd94939.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*5tHlioPY6tgAnr8fE3B-Tg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk on di oo op translated">左侧:使用分部类型达到与右侧相同的结果，在右侧，每个属性都标记为可选</figcaption></figure></div><p id="1216" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者你可以使用<code class="fe ls lt lu lv b">Partial</code> <em class="lw"> </em>来定义一些道具作为你的组件的默认道具:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/489ff06974e7e2d380ee2d2facbc0d6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YbGQpSVa0Ju9F2-5Dp-t7w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在默认属性的类型中使用偏旁</figcaption></figure><p id="bd7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，Typescript v2.8中引入的<code class="fe ls lt lu lv b">Required</code>内置类型使得被描述对象的所有属性都是必需的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/ffe323837291f3e9cc715f0a9a449397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bspXbS_te7-x_c_dckM6Cg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">此组件的OwnProps中的所有字段都是必需的</figcaption></figure><p id="5468" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Required的一个用例是<strong class="ky ir">选择器</strong>:有时你想为一个嵌套对象的属性创建一个选择器，并且你知道在选择器调用的时候这个属性将被定义。你可以通过打字指出来:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/9677fc3ceaf0fd09dd5894ec201c7c95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F1nDgrYxupjrFSiJturisQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">一个小黑客确保编译器ticketOffer是选择器处理所必需的</figcaption></figure><p id="d5a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这看起来像一个骗局，如果你开始从可选属性继承必需属性，它会导致类型错误，所以要小心！</p><blockquote class="ny nz oa"><p id="f1e3" class="kw kx lw ky b kz la jr lb lc ld ju le ob lg lh li oc lk ll lm od lo lp lq lr ij bi translated">也许这听起来很愚蠢，但是当你拥有自动生成的代码，并且你手中的所有接口都是部分的，并且你的UI的所有元素都只需要T10必需的T11时，这种情况并不少见。在这里，您将开始检查<em class="iq">上每个未定义的嵌套对象😨</em>。</p></blockquote><h1 id="2f60" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">挑选和省略</h1><p id="31f2" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">你有没有因为意识到下一个类不需要这一堆属性而试图缩小一个类型？或者你可能在重构的过程中到达了这个点，试图以一种新的方式分布系统的各个部分。有几种类型可以解决这个问题。</p><p id="44e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">帮助你使用一个已经定义好的接口，但是只从对象中取出你需要的那些键。</p><p id="27c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Omit</code>在<code class="fe ls lt lu lv b">lib.d.ts</code>中没有预定义，但是很容易用<code class="fe ls lt lu lv b">Pick</code>和<code class="fe ls lt lu lv b">Exclude</code>来定义。它排除了您不想从接口中获取的属性。</p><p id="c28d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这两幅图像中，<code class="fe ls lt lu lv b">ProductPhotoProps</code>将包含除名称和描述之外的所有<code class="fe ls lt lu lv b">Product</code>属性:</p><div class="kg kh ki kj gt ab cb"><figure class="og kk ot oi oj ok ol paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/df13939fbeb8c7a40637c4ed3f3f8db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*AJL4dNcuLV4fHB7lbKZ91g.png"/></div></figure><figure class="og kk ou oi oj ok ol paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/75414977f84c8c192302d7ce542a84b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*47qUKESj3sL5Jhma5kZQ0Q.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk ov di ow op translated">挑选和省略是重用接口的灵活方式</figcaption></figure></div><blockquote class="ny nz oa"><p id="47fc" class="kw kx lw ky b kz la jr lb lc ld ju le ob lg lh li oc lk ll lm od lo lp lq lr ij bi translated">在我目前的项目中，这种情况的一个实际例子是重构一个具有复杂字段依赖关系的大型表单。有<code class="fe ls lt lu lv b">FormProps</code>类型，其中包含错误字段。在重新考虑这个架构之后，错误对于第一个子组件来说变得不必要，但是对于第二个子组件来说仍然是需要的。我使用Pick获取一部分字段，除了一个新接口的错误，它工作得很好。</p></blockquote><p id="1d99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，有不同的方法来组合类型和定义它们的关系。如果你一开始就把一个大的东西分解成小块，也许你就从另一个侧面解决了一个物体排除属性的问题。您应该扩展类型。</p><h1 id="0c37" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">扩展类型/接口</h1><p id="6b02" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">当您扩展接口时，在源接口/类型中描述的所有属性将在结果接口中可用。让我们看看如何将小界面组合成一个与我们的任务相对应的界面:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/d06f5cd1aadb869c19199e2c2320fa5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CgnIw2r9gYNgWzT5HLeL1w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">扩展紧凑接口，以便在不同的组件类型中重用它们</figcaption></figure><p id="e8e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法并不方便，因为你必须事先想象物体的形状。另一方面，它又快又简单，这使得它非常适合于原型开发或构建简单的UI，比如将数据呈现到只读块中。</p><h1 id="0b60" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">摘要</h1><p id="cbec" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">我们已经用真实的代码示例探索了一些流行的预定义类型脚本类型。我们使用的项目只是一个演示，但所有这些类型至少在我所知道的一个真实世界的应用程序中是有效的😉。我希望这篇文章对你有用，并鼓励你不要害怕打字。我用React-Redux SPA创建了一个<a class="ae kv" href="https://github.com/ainalain/sandbox" rel="noopener ugc nofollow" target="_blank"> repo </a>，在这里你可以找到大多数这样的例子或者它们的替代品。</p><p id="d7f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，我想再说一点关于静态类型的事情。通常，当您探索一项新技术或在功能开发过程中面临挑战时，您开始解决一个技术问题，并且可能会忘记您的目标。静态打字不是你工作的一个目标，它只是一个工具。如果它成为了一个项目的核心，那就表明你已经忘乎所以了🚀。记住你的应用程序的商业/技术部分的平衡和快乐编码！</p><div class="lx ly gp gr lz ma"><a href="https://gitconnected.com/learn/typescript" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd ir gy z fp mf fr fs mg fu fw ip bi translated">学习TypeScript -最佳TypeScript教程(2020) | gitconnected</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">21大TypeScript教程-免费学习TypeScript。课程由开发人员提交并投票，从而实现…</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">gitconnected.com</p></div></div><div class="mj l"><div class="oy l ml mm mn mj mo kp ma"/></div></div></a></div></div></div>    
</body>
</html>