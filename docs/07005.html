<html>
<head>
<title>Uploading images in your Rails — React project using Cloudinary API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Rails中上传图像——使用Cloudinary API对项目进行反应</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/uploading-images-in-your-rails-react-project-using-cloudinary-api-3bf546e0e430?source=collection_archive---------2-----------------------#2021-01-18">https://levelup.gitconnected.com/uploading-images-in-your-rails-react-project-using-cloudinary-api-3bf546e0e430?source=collection_archive---------2-----------------------#2021-01-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="550c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">想建立一个图像库？在你的Rails/React项目中，有很多处理图片上传的方法；例如使用载波、主动存储等等。在这篇文章中，我不打算谈论一个相对于另一个的优缺点。相反，我将指导您设置Cloudinary API，因为这是一种处理上传图像的超级简单的方法。</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/e7ceb2dd62c8e31c51b1390d2d4e6065.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ultxf7z1BD5Kwy1WaUF9_w.png"/></div></div></figure><p id="3275" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Cloudinary是一个基于云的图像和视频管理平台。它使用户能够为网站上传、存储、管理、操作和传送图像和视频。要开始使用Cloudinary，你需要在他们的网站(【cloudinary.com】T2)上注册，以获取你的云信息。您将需要一个<strong class="jp ir">云名称</strong>、<strong class="jp ir"> API密钥、</strong>和<strong class="jp ir"> API秘密</strong>来在您的项目中设置它。所有这些信息都可以在帐户控制台的仪表板页面中找到。</p><p id="6cfe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们开始使用Rails API设置我们的后端。</p><p id="2853" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，你需要将<em class="kl">云宝石</em>添加到你的宝石文件中。这个gem简化了将Cloudinary API集成到您的项目中。</p><p id="45f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">增加</p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="b344" class="le lf iq la b gy lg lh l li lj">gem 'cloudinary'</span></pre><p id="1b4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">添加到您的Gemfile并运行</p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="3ca6" class="le lf iq la b gy lg lh l li lj">bundle install</span></pre><p id="8028" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在<strong class="jp ir">config/initializer</strong>文件夹中创建一个文件，并将其命名为<strong class="jp ir"> cloudinary.rb </strong></p><p id="4058" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，将以下代码添加到该文件中:</p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="e65c" class="le lf iq la b gy lg lh l li lj">Cloudinary.config do |config|</span><span id="9e12" class="le lf iq la b gy lk lh l li lj"> config.cloud_name = ENV['cloud_name']</span><span id="acf9" class="le lf iq la b gy lk lh l li lj"> config.api_key = ENV['cloud_api_key']</span><span id="7ec2" class="le lf iq la b gy lk lh l li lj"> config.api_secret = ENV['cloud_api_secret']</span><span id="0b4a" class="le lf iq la b gy lk lh l li lj"> config.secure = true</span><span id="f206" class="le lf iq la b gy lk lh l li lj"> config.cdn_subdomain = true</span><span id="2f7f" class="le lf iq la b gy lk lh l li lj">end</span></pre><p id="db5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个文件中，我们将设置全局配置参数。<strong class="jp ir">云名</strong>、<strong class="jp ir"> api_ key </strong>和<strong class="jp ir"> api_secret </strong>为强制设置。云名称用于为您的所有媒体资产构建公共URL。Api_key和api_secret用于与Cloudinary API通信并签署请求。<strong class="jp ir"> <em class="kl">安全</em> </strong>是一个可选参数，它强制HTTP用于资产交付，即使它们嵌入在不安全的HTTP页面中。</p><p id="a7d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir"> config </strong>文件夹中，您必须已经有了<strong class="jp ir"> application.yml </strong>文件(如果您正在使用<strong class="jp ir">gem‘figaro’</strong>来保护您的API密钥，否则您可以手动创建application.yml)。将您的Cloudinary密钥添加到该文件中。</p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="9485" class="le lf iq la b gy lg lh l li lj">cloud_name: 'xxxxxxxxx'</span><span id="c3a7" class="le lf iq la b gy lk lh l li lj">cloud_api_key: 'xxxxxxxx'</span><span id="f647" class="le lf iq la b gy lk lh l li lj">cloud_api_secret: 'xxxxxxxxx'</span></pre><p id="855d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:确保您的密钥以字符串格式存储，并将<strong class="jp ir"><em class="kl">application . yml</em></strong>添加到您的<strong class="jp ir"> <em class="kl">。gitignore </em> </strong>(如果你用的是<strong class="jp ir">【费加罗】</strong>它会把<em class="kl"> application.yml </em>添加到<em class="kl">。gitignore </em>自动)。</p><p id="c3f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在已经完成了为云设置密钥。现在让我们为我们的照片创建一个模型。你可以用你喜欢的任何方式做这件事。我更喜欢用发电机。</p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="c012" class="le lf iq la b gy lg lh l li lj">rails g model Photo image:string</span></pre><p id="802a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后创建一个控制器:</p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="a53a" class="le lf iq la b gy lg lh l li lj">rails g controller photos</span></pre><p id="ff03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">别忘了路线。在<strong class="jp ir"> routes.rb </strong>文件中我们添加</p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="54b4" class="le lf iq la b gy lg lh l li lj">resources :photos</span></pre><p id="9a4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您只是练习创建和删除照片，请分别更新您的路线。</p><p id="35a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了上传从客户端发送到云端的图像，我们需要在我们的<strong class="jp ir"> PhotosController中使用<strong class="jp ir"> create </strong>方法。</strong>一旦用户在我们的网站上上传照片，Cloudinary将发送一个响应，其中包含上传到我们云的照片的URL字符串。在Rails数据库中，我们不存储实际的照片，我们只存储由Cloudinary托管的照片的URL字符串。</p><p id="25f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> Cloudinary gem </em>让我们可以使用所有Cloudinary方法。我们要用来上传照片的是</p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="107b" class="le lf iq la b gy lg lh l li lj">Cloudinary::Uploader.upload(file, options ={})</span></pre><p id="6c6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">方法，它接受一个图像作为参数。(举个例子:cloud inary::uploader . upload(' my _ image . jpg '))。</p><p id="5af3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上传完成后，即可对上传的图像进行操作。上传调用返回给我们一个对象；现在我们只需要用<strong class="jp ir">键[‘URL’]</strong>提取一个值。该网址让我们可以访问存储在云中的上传照片。</p><p id="53b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir"> PhotosController </strong>中添加以下代码:</p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="c402" class="le lf iq la b gy lg lh l li lj">def create</span><span id="6a2e" class="le lf iq la b gy lk lh l li lj">   result = Cloudinary::Uploader.upload(params[:image])</span><span id="8cdb" class="le lf iq la b gy lk lh l li lj">  photo = Photo.create(user_id: current_user.id, image:   result['url'])</span><span id="81f9" class="le lf iq la b gy lk lh l li lj">     if photo.save</span><span id="efff" class="le lf iq la b gy lk lh l li lj">        render json: photo</span><span id="fe10" class="le lf iq la b gy lk lh l li lj">     else</span><span id="bbb4" class="le lf iq la b gy lk lh l li lj">        render json: photo.errors</span><span id="8d7b" class="le lf iq la b gy lk lh l li lj">     end</span><span id="4b6b" class="le lf iq la b gy lk lh l li lj">end</span></pre><p id="66f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">(在我的例子中，我有</em> <strong class="jp ir"> <em class="kl">属于</em> </strong> <em class="kl">关系，这就是为什么我在创建时也传递了一个user_id。)</em></p><p id="d431" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，现在我们可以继续我们的React应用程序，为我们的前端构建一个上传功能。首先，让我们创建一个组件，该组件将呈现一个上传照片的表单，并将处理向Rails API提交照片。</p><p id="cae2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">(使用XHR CORS请求从浏览器直接上传。确保您在Rails后端使用了</em><strong class="jp ir"><em class="kl">gem‘rack-CORS’</em></strong><em class="kl">，并取消注释掉</em><strong class="jp ir"><em class="kl">CORS . Rb</em></strong><em class="kl">文件中的代码，将origins改为</em><strong class="jp ir"><em class="kl">' *</em></strong><em class="kl">。)</em></p><p id="1939" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们用<strong class="jp ir">类型的‘文件’</strong>创建一个输入字段，这样用户可以从他们的本地机器上选择一个文件。此外，我们在<strong class="jp ir">接受属性</strong>中包含一个通配符<strong class="jp ir"> (*) </strong>来表示任何格式的类型都是可接受的。</p><p id="1330" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输入监听<strong class="jp ir"> onChange </strong>事件，该事件将为我们的照片设置一个状态。我们通过<strong class="jp ir"><em class="kl">event . target . files .</em></strong>访问我们的附加文件，而不是通过<em class="kl"> event.target.value </em>访问值</p><p id="ee66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们需要创建一个新的<strong class="jp ir"> FormData对象</strong>，并向其添加一个新的键值对。在我们的例子中，键是'<em class="kl">照片</em>'，值是<em class="kl">照片的状态</em>。一旦创建了新对象，我们就可以向后端提交请求了。</p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="306c" class="le lf iq la b gy lg lh l li lj">import React from 'react'<br/></span><span id="c56d" class="le lf iq la b gy lk lh l li lj">class NewPhoto extends React.Component {</span><span id="dcca" class="le lf iq la b gy lk lh l li lj"> state = {</span><span id="3faf" class="le lf iq la b gy lk lh l li lj">   photo: null</span><span id="6428" class="le lf iq la b gy lk lh l li lj"> }</span><span id="af90" class="le lf iq la b gy lk lh l li lj"> onChange = (e) =&gt; {</span><span id="55bf" class="le lf iq la b gy lk lh l li lj">   e.persist()</span><span id="2afe" class="le lf iq la b gy lk lh l li lj">   <em class="kl">this</em>.setState(() =&gt; {</span><span id="7424" class="le lf iq la b gy lk lh l li lj">     return {</span><span id="ebd7" class="le lf iq la b gy lk lh l li lj">      <em class="kl"> //Upload only one file, multiple uploads are not allowed</em><br/>       [e.target.name]: e.target.files[0]</span><span id="f4bc" class="le lf iq la b gy lk lh l li lj">     }</span><span id="d83f" class="le lf iq la b gy lk lh l li lj">   })</span><span id="b7de" class="le lf iq la b gy lk lh l li lj">  }</span><span id="190d" class="le lf iq la b gy lk lh l li lj"> onSubmit = (e) =&gt; {</span><span id="2b43" class="le lf iq la b gy lk lh l li lj">   e.preventDefault()</span><span id="75d1" class="le lf iq la b gy lk lh l li lj">   <em class="kl"> //create a FormData object</em><br/>   const formData = new FormData()</span><span id="3356" class="le lf iq la b gy lk lh l li lj">  <em class="kl"> // Add the file to the AJAX request<br/>   </em>formData.append('photo', <em class="kl">this</em>.state.photo)</span><span id="ff3a" class="le lf iq la b gy lk lh l li lj">   <em class="kl">this</em>.props.handleUploadPhoto(formData)</span><span id="0cc2" class="le lf iq la b gy lk lh l li lj">}</span><span id="759d" class="le lf iq la b gy lk lh l li lj"> render(){</span><span id="1310" class="le lf iq la b gy lk lh l li lj">   return (</span><span id="6095" class="le lf iq la b gy lk lh l li lj">     &lt;form onSubmit={<em class="kl">this</em>.onSubmit} &gt;</span><span id="9fb7" class="le lf iq la b gy lk lh l li lj">      &lt;input type='file' name='photo' accept='image/*'</span><span id="9ca0" class="le lf iq la b gy lk lh l li lj">      onChange={<em class="kl">this</em>.onChange}/&gt;</span><span id="89ac" class="le lf iq la b gy lk lh l li lj">      &lt;button type='submit' value='Submit&gt;Submit&lt;/button&gt;</span><span id="9b4a" class="le lf iq la b gy lk lh l li lj">    &lt;/form&gt;</span><span id="678a" class="le lf iq la b gy lk lh l li lj">   )</span><span id="93b2" class="le lf iq la b gy lk lh l li lj"> }<br/></span><span id="a95d" class="le lf iq la b gy lk lh l li lj">}</span><span id="c800" class="le lf iq la b gy lk lh l li lj">export default NewPhoto</span></pre><p id="dd0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将<strong class="jp ir"> handleUploadPhoto </strong>放在了一个不同的组件中，但是你可以用相同的组件来写它。这是个人喜好的问题。</p><p id="cacf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要将存储照片状态的对象传递给<strong class="jp ir"> handleUploadPhoto </strong>，并向服务器发出<strong class="jp ir"> <em class="kl"> POST </em> </strong>请求。请注意，在body中，我们<em class="kl">附加了我们的formData对象</em>。一旦用户上传照片并点击提交按钮，一个请求将被发送到服务器，在前端更新我们的状态，用户被直接带到他们刚刚上传的照片。</p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="6622" class="le lf iq la b gy lg lh l li lj">handleUploadPhoto = (formData) =&gt;{</span><span id="8fb0" class="le lf iq la b gy lk lh l li lj">  fetch('http://localhost:3000/photos', {</span><span id="8571" class="le lf iq la b gy lk lh l li lj">  method:'POST',</span><span id="e202" class="le lf iq la b gy lk lh l li lj">  body: formData</span><span id="5290" class="le lf iq la b gy lk lh l li lj">  })</span><span id="ebb1" class="le lf iq la b gy lk lh l li lj"> .then(resp =&gt; resp.json())</span><span id="19ea" class="le lf iq la b gy lk lh l li lj"> .then(data =&gt; {</span><span id="791a" class="le lf iq la b gy lk lh l li lj"><em class="kl">   this</em>.setState((prevState) =&gt;({</span><span id="2c88" class="le lf iq la b gy lk lh l li lj">    photos: [...prevState.photos, data]</span><span id="84af" class="le lf iq la b gy lk lh l li lj">   }))</span><span id="97d1" class="le lf iq la b gy lk lh l li lj"><em class="kl"> //scroll down to the uploaded photo</em></span><span id="5773" class="le lf iq la b gy lk lh l li lj"> window.scrollTo(0,document.body.scrollHeight)</span><span id="fcd9" class="le lf iq la b gy lk lh l li lj">})</span><span id="f851" class="le lf iq la b gy lk lh l li lj">}</span></pre><p id="a65c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！现在，用户可以上传将要存储在我们的云中的照片，在后端，数据库存储这些照片的所有URL。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ca"><img src="../Images/32e081cfaeb2a0bb5e12b08830894256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cUWCLbAnbGeP2O6FwALXRA.png"/></div></div></figure></div></div>    
</body>
</html>