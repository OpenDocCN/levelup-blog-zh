<html>
<head>
<title>Node.js advanced pattern: Dependency Injection Container</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js高级模式:依赖注入容器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/node-js-advanced-pattern-dependency-injection-container-fc58a1946638?source=collection_archive---------0-----------------------#2019-06-29">https://levelup.gitconnected.com/node-js-advanced-pattern-dependency-injection-container-fc58a1946638?source=collection_archive---------0-----------------------#2019-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/5247623b7e45a233b2e2825dacd85bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A6T-abUnVJ9YGe7sfOpnhQ.jpeg"/></div></div></figure><div class=""/><p id="1cc3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我将介绍依赖注入容器(DIC ),这是Node.js中大多数应用程序和库使用的一种高级模块连接模式。这种模式之所以广泛使用是有原因的，它通过提供依赖注入模式的所有好处，同时消除其大多数缺点，使您的代码更加灵活。我们将回顾模式的基本原则，然后编写我们自己的DIC。</p><p id="af1d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">如果你不熟悉模块连接和依赖注入，我推荐你先阅读我在模块连接</strong> <a class="ae kz" href="https://isamatov.com/node-module-wiring-dependencies/" rel="noopener ugc nofollow" target="_blank"> <strong class="kd jf">这里</strong> </a> <strong class="kd jf">上的帖子。</strong></p><h1 id="8ef6" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是依赖注入</h1><p id="88cd" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">简而言之，依赖注入(DI)是一种连接模式，其中依赖项不是硬编码在模块内部，而是由外部实体作为输入提供。</p><p id="6fdb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通常，开发人员使用<code class="fe md me mf mg b">require</code>导入模块依赖。这种方法很好，但是它不太灵活，而且更难进行单元测试。让我们来看看这个简单的例子:</p><figure class="mh mi mj mk gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="b697" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是我们如何使用DI来为我们的模块提供db实例:</p><figure class="mh mi mj mk gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="e37a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在假设我们想通过提供一个虚拟数据库实例来对这个模块进行单元测试。在第一个例子中，我们必须修改模块的代码，而在第二个例子中，我们所要做的就是提供虚拟实例作为参数。</p><h2 id="5571" class="mn lb je bd lc mo mp dn lg mq mr dp lk km ms mt lo kq mu mv ls ku mw mx lw my bi translated">依赖注入的优点:</h2><ul class=""><li id="a1c4" class="mz na je kd b ke ly ki lz km nb kq nc ku nd ky ne nf ng nh bi translated">更高的可重用性——在我们的例子中，通过不同的数据库实例使用我们的电影建议服务要容易得多。</li><li id="65c7" class="mz na je kd b ke ni ki nj km nk kq nl ku nm ky ne nf ng nh bi translated">更容易的单元测试——为单元测试提供虚拟数据变得微不足道。</li></ul><h2 id="5c69" class="mn lb je bd lc mo mp dn lg mq mr dp lk km ms mt lo kq mu mv ls ku mw mx lw my bi translated">依赖注入的大弊端</h2><p id="3666" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">虽然DI有很多优点，但它也有一个缺点:随着项目依赖项数量的增长，手动管理它们变得更加困难。</p><p id="5bad" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，让我们来看一个样本<code class="fe md me mf mg b">app.js</code>文件，我们用它来设置我们项目中的依赖图:</p><figure class="mh mi mj mk gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="3990" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的例子中，我们实际上是为我们的应用程序手动设置依赖图。每个对象的实例化依赖于前一个对象，实例化的顺序至关重要。我们可以看到，如果我们继续沿着这条路走下去，这很容易变得不可收拾。</p><p id="33ef" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么是不是不值得使用依赖注入呢？幸运的是，在DI的基础上构建了一个更高级的模式，减轻了它的大部分缺点。</p><h1 id="336b" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">依赖注入容器</h1><p id="123c" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">本质上，依赖注入容器是模块或外部服务，其唯一目的是处理项目中的依赖注入。使用DIC，您可以享受依赖注入的所有优势，同时也不必手动处理项目的依赖图。</p><p id="296a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于DIC的效率和可伸缩性，它被大量的Node.js库和项目所使用。</p><h2 id="5539" class="mn lb je bd lc mo mp dn lg mq mr dp lk km ms mt lo kq mu mv ls ku mw mx lw my bi translated">不同的依赖注入容器实现方法:</h2><p id="67b5" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">有多种不同的方法可以在运行时为DIC提供依赖列表，这里有两种最广泛使用的方法。</p><ol class=""><li id="1716" class="mz na je kd b ke kf ki kj km nn kq no ku np ky nq nf ng nh bi translated"><strong class="kd jf">在运行时评估工厂参数的名称</strong>。在第三方软件包的帮助下，您可以将给定函数的参数名提取为字符串数组。这用于在运行时预测依赖项的名称。</li><li id="60e0" class="mz na je kd b ke ni ki nj km nk kq nl ku nm ky nq nf ng nh bi translated"><strong class="kd jf">附加特殊属性。</strong>您可以将自定义属性(<code class="fe md me mf mg b">_inject</code>)附加到工厂函数的原型，并在该属性中指定工厂函数的所有依赖项名称。之后，您可以定制您的DIC来使用<code class="fe md me mf mg b">_inject</code>在运行时获取依赖列表。</li></ol><h2 id="9ae9" class="mn lb je bd lc mo mp dn lg mq mr dp lk km ms mt lo kq mu mv ls ku mw mx lw my bi translated">实现依赖注入容器</h2><p id="2e7d" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">第一种方法侵入性最小，也最受欢迎，因此我们将使用这种方法来实现我们的DIC。我们将使用<code class="fe md me mf mg b"><a class="ae kz" href="https://www.npmjs.com/package/parse-function" rel="noopener ugc nofollow" target="_blank">parse-function</a></code> npm包，它可以用来解析任何给定函数的参数名:</p><figure class="mh mi mj mk gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="8e98" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里需要注意几件事:</p><ul class=""><li id="32a0" class="mz na je kd b ke kf ki kj km nn kq no ku np ky ne nf ng nh bi translated">我们使用属性<code class="fe md me mf mg b">this.dependencies</code>和<code class="fe md me mf mg b">this.factories</code>进行缓存。</li><li id="ebaf" class="mz na je kd b ke ni ki nj km nk kq nl ku nm ky ne nf ng nh bi translated"><code class="fe md me mf mg b">register</code>是注册新依赖项的简单方法。</li><li id="8159" class="mz na je kd b ke ni ki nj km nk kq nl ku nm ky ne nf ng nh bi translated"><code class="fe md me mf mg b">factory</code>是注册依赖工厂的简单方法。</li><li id="c102" class="mz na je kd b ke ni ki nj km nk kq nl ku nm ky ne nf ng nh bi translated">如果可用，方法返回注册的依赖项。否则，它使用其工厂实例化依赖项，然后返回它。</li><li id="2003" class="mz na je kd b ke ni ki nj km nk kq nl ku nm ky ne nf ng nh bi translated">最后也是最重要的是<code class="fe md me mf mg b">inject</code>方法。这个方法是我们DIC逻辑的核心所在。<code class="fe md me mf mg b">inject</code>将工厂参数的名称提取为字符串数组。然后，它将每个参数与其他注册的依赖项进行匹配，并使用这些依赖项调用工厂函数。</li></ul><p id="433f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">注意</strong>:为了让<code class="fe md me mf mg b">inject</code>方法工作，您必须确保注册的依赖项名称与依赖这些依赖项的工厂参数的名称相匹配。</p><p id="f370" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们来看看重写后的<code class="fe md me mf mg b">app.js</code>，它将处理依赖图的责任转移给了我们的<code class="fe md me mf mg b">DiContainer</code></p><figure class="mh mi mj mk gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="077e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们所要做的就是创建一个新的<code class="fe md me mf mg b">DiContainer</code>实例，并注册我们的依赖项和工厂。我们注册依赖关系的顺序不再重要。此外，我们不再需要担心向依赖工厂提供正确的参数。要得到一个<code class="fe md me mf mg b">MovieController</code>的工作实例，我们所要做的就是调用<code class="fe md me mf mg b">get</code>方法，剩下的由<code class="fe md me mf mg b">DiContainer</code>来处理。</p><p id="ee4a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的<code class="fe md me mf mg b">DiContainer</code>实现使用惰性加载方法，仅在应用程序需要时实例化依赖项。</p><h2 id="5d22" class="mn lb je bd lc mo mp dn lg mq mr dp lk km ms mt lo kq mu mv ls ku mw mx lw my bi translated"><strong class="ak">使用依赖注入容器的好处:</strong></h2><ul class=""><li id="46e9" class="mz na je kd b ke ly ki lz km nb kq nc ku nd ky ne nf ng nh bi translated">依赖注入的所有优点。</li><li id="b755" class="mz na je kd b ke ni ki nj km nk kq nl ku nm ky ne nf ng nh bi translated">DIC在运行时自动识别模块所需的依赖关系。这意味着我们不再需要担心为工厂提供正确的参数。</li><li id="0c09" class="mz na je kd b ke ni ki nj km nk kq nl ku nm ky ne nf ng nh bi translated">模块甚至不知道DIC的存在，这意味着DIC和模块是松耦合的。</li></ul><h2 id="8985" class="mn lb je bd lc mo mp dn lg mq mr dp lk km ms mt lo kq mu mv ls ku mw mx lw my bi translated">第三方依赖注入容器</h2><p id="b6bb" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">虽然编写我们自己版本的DIC有助于更好地理解其背后的原因，但使用第三方解决方案要实用得多。NPM注册中心有很多DIC库，它们为我们提供了很多有用的特性，比如惰性加载和开箱即用的装饰器，其中之一就是<code class="fe md me mf mg b"><a class="ae kz" href="https://www.npmjs.com/package/bottlejs" rel="noopener ugc nofollow" target="_blank">bottlejs</a></code>。</p><p id="04ce" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个帖子到此为止！Dependency Injection Container是一种更高级的模块连接模式，不仅在Node.js中广泛使用，在一般的软件开发领域中也广泛使用。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="710c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ny">原载于2019年6月29日</em><a class="ae kz" href="https://isamatov.com/node-js-dependency-injection-container/" rel="noopener ugc nofollow" target="_blank"><em class="ny">https://isamatov.com</em></a><em class="ny">。</em></p></div></div>    
</body>
</html>