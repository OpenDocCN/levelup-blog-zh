<html>
<head>
<title>Great New Features Released with TypeScript 3.4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 3.4中发布的优秀新功能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/great-new-features-released-with-typescript-3-4-6c353d49f48d?source=collection_archive---------6-----------------------#2020-01-31">https://levelup.gitconnected.com/great-new-features-released-with-typescript-3-4-6c353d49f48d?source=collection_archive---------6-----------------------#2020-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7bf52b6dcd334b16b6daa256fc8630c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_VuAtvzwLDTuhkRO"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@elenatrn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Elena Taranenko </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="9491" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript每天都在改进。我们在每个版本中都不断获得新的特性。在本文中，我们将看看TypeScript 3.4中发布的新内容。</p><p id="dca4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">新特性包括更好的高阶泛型函数的类型推断。对<code class="fe le lf lg lh b">readonly</code>类型的更改和使用<code class="fe le lf lg lh b">--increment</code>标志的更快构建，等等。</p><h1 id="89cd" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">TypeScript 3.4中的新功能</h1><h2 id="e7e7" class="mg lj it bd lk mh mi dn lo mj mk dp ls kr ml mm lw kv mn mo ma kz mp mq me mr bi translated">-增量标志</h2><p id="c756" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">为了在第一次构建后加快构建速度，TypeScript编译器的<code class="fe le lf lg lh b">--incremental</code>标志将让我们只根据发生的变化来构建。</p><p id="96db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将选项添加到我们项目的<code class="fe le lf lg lh b">tsconfig.json</code>来获得这个特性，在<code class="fe le lf lg lh b">compilerOptions</code>部分下，如下所示:</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="cf59" class="mg lj it lh b gy nf ng l nh ni">{<br/>    "compilerOptions": {<br/>        "incremental": true,<br/>        "outDir": "./lib"<br/>    },<br/>    "include": ["./src"]<br/>}</span></pre><p id="6fad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它通过寻找第一次构建时创建的<code class="fe le lf lg lh b">.tsbuildinfo</code>来工作。如果它不存在，那么它会被生成。它将使用这个文件来了解什么已经建立，什么还没有。</p><p id="6a32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它可以被安全地删除，不会影响我们的构建。我们可以通过在<code class="fe le lf lg lh b">compilerOptions</code>部分<code class="fe le lf lg lh b">tsconfig.json</code>添加一个<code class="fe le lf lg lh b">tsBuildInfoFile</code>选项，用不同的名称命名文件，如下所示:</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="12c6" class="mg lj it lh b gy nf ng l nh ni">{<br/>    "compilerOptions": {<br/>        "incremental": true,<br/>        "tsBuildInfoFile": "./front-end-app",<br/>        "outDir": "./lib"<br/>    },<br/>    "include": ["./src"]<br/>}</span></pre><p id="611b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于在<code class="fe le lf lg lh b">tsconfig.json</code>中将<code class="fe le lf lg lh b">composite</code>标志设置为<code class="fe le lf lg lh b">true</code>的复合项目，不同项目之间的引用也可以增量构建。这些项目总是会生成一个<code class="fe le lf lg lh b">.tsbuildinfo</code>文件。</p><p id="4c38" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当使用<code class="fe le lf lg lh b">outFile</code>选项时，构建信息文件名将基于输出文件名。例如，如果输出文件是<code class="fe le lf lg lh b">foo.js</code>，那么构建信息文件将是<code class="fe le lf lg lh b">foo.tsbuildinfo</code>。</p><h1 id="2854" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">一般函数中的高阶类型推理</h1><p id="c16f" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">当我们的函数将其他函数作为参数时，我们将得到传入和返回的函数类型的类型推断。</p><p id="a278" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有一个由多个函数组成的函数，返回一个新函数，如下所示:</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="733e" class="mg lj it lh b gy nf ng l nh ni">function compose&lt;A, B, C, D&gt;(<br/>    f: (arg: A) =&gt; B,<br/>    g: (arg: B) =&gt; C,<br/>    h: (arg: C) =&gt; D<br/>): (arg: A) =&gt; D {<br/>    return x =&gt; h(g(f(x)));<br/>}</span></pre><p id="544b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们按如下方式填写通用标记的类型时:</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="a484" class="mg lj it lh b gy nf ng l nh ni">function compose&lt;A, B, C, D&gt;(<br/>    f: (arg: A) =&gt; B,<br/>    g: (arg: B) =&gt; C,<br/>    h: (arg: C) =&gt; D<br/>): (arg: A) =&gt; D {<br/>    return x =&gt; h(g(f(x)));<br/>}</span><span id="d801" class="mg lj it lh b gy nj ng l nh ni">interface Employee {<br/>    name: string;    <br/>}</span><span id="b744" class="mg lj it lh b gy nj ng l nh ni">const getName = (employee) =&gt; employee.name;<br/>const splitString = (name) =&gt; name.split('');<br/>const getLength = (name) =&gt; name.length;</span><span id="acc2" class="mg lj it lh b gy nj ng l nh ni">const fn = compose(getName, splitString, getLength)</span></pre><p id="c749" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以通过编写来调用<code class="fe le lf lg lh b">fn</code>函数:</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="4b8e" class="mg lj it lh b gy nf ng l nh ni">const len: number = fn(&lt;Employee&gt;{ name: 'Joe' });</span></pre><p id="2cf5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript 3.4或更高版本足够智能，可以遍历函数调用链，并自动推断每个函数的类型以及从<code class="fe le lf lg lh b">compose</code>返回的函数的返回类型。</p><p id="c834" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它可以推断出<code class="fe le lf lg lh b">fn</code>返回一个数字。</p><p id="698f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">早于3.4的TypeScript版本将推断出空对象类型，并且我们得到上面的赋值表达式的错误。</p><h1 id="ec94" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><code class="fe le lf lg lh b">ReadonlyArray</code>和<code class="fe le lf lg lh b">readonly</code>元组</h1><p id="6867" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">在TypeScript 3.4中，使用只读数组类型现在更容易了。我们现在可以用关键字<code class="fe le lf lg lh b">readonly</code>声明一个只读数组。</p><p id="eef2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们想要一个只读的字符串数组，我们可以写:</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="3079" class="mg lj it lh b gy nf ng l nh ni">const strArr: readonly string[] = ['a', 'b', 'c'];</span></pre><p id="eafa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们有了一个数组，我们不能将它压入、更改条目或做任何修改数组的事情。</p><p id="2e2c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与<code class="fe le lf lg lh b">ReadOnlyArray&lt;string&gt;</code>型相比，这款更加紧凑。</p><p id="4cc7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在TypeScript 3.4中，我们有了新的只读元组类型。我们可以声明一个只读元组，如下所示:</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="4e6c" class="mg lj it lh b gy nf ng l nh ni">const strTuple: readonly [string, string] = ['foo', 'bar'];</span></pre><p id="9e60" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">映射类型上的<code class="fe le lf lg lh b">readonly</code>修饰符将把类似数组的类型转换成它们对应的<code class="fe le lf lg lh b">readonly</code>类型。</p><p id="3149" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有这样的类型:</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="092c" class="mg lj it lh b gy nf ng l nh ni">type ReadOnly&lt;T&gt; = {<br/>    readonly [K in keyof T]: T[K]<br/>}</span></pre><p id="428a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们将一个类型传入通用类型占位符<code class="fe le lf lg lh b">Readonly</code>时，如下所示:</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="7681" class="mg lj it lh b gy nf ng l nh ni">type foo = Readonly&lt;{foo: number, bar: string}&gt;;</span></pre><p id="0e96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到<code class="fe le lf lg lh b">foo</code>类型为:</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="4c6d" class="mg lj it lh b gy nf ng l nh ni">type foo = {<br/>    readonly foo: number;<br/>    readonly bar: string;<br/>}</span></pre><p id="170b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，两个字段都变成了<code class="fe le lf lg lh b">readonly</code>，这在TypeScript 3.4之前并不是这样。</p><p id="5eca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以使用映射类型从所有字段中移除<code class="fe le lf lg lh b">readonly</code>修饰符。为此，我们在<code class="fe le lf lg lh b">readonly</code>修饰符前添加了一个<code class="fe le lf lg lh b">-</code>。</p><p id="4e3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="8da0" class="mg lj it lh b gy nf ng l nh ni">type Writable&lt;T&gt; = {<br/>    -readonly [K in keyof T]: T[K]<br/>}</span><span id="0214" class="mg lj it lh b gy nj ng l nh ni">interface Foo{<br/>    readonly foo: string;<br/>    readonly bar: number;<br/>}</span><span id="ad7f" class="mg lj it lh b gy nj ng l nh ni">type foo = Writable&lt;Foo&gt;;</span></pre><p id="66a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到:</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="3a7d" class="mg lj it lh b gy nf ng l nh ni">type WriteFoo = {<br/>    foo: string;<br/>    bar: number;<br/>}</span></pre><p id="9662" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于类型<code class="fe le lf lg lh b">foo</code>。</p><p id="f17f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">readonly</code>修饰符只能用于数组类型和元组类型的语法。不能用在别的东西上。</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2ae6815fcc0a529bba64de98f017716b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a0nRyh9G0WkI3S2E"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@erinw?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾琳·威尔森</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="caee" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">常量断言</h1><p id="aab8" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">TypeScript 3.4引入了一个名为<code class="fe le lf lg lh b">const</code>断言的构造函数。当我们使用它时，我们发出信号，文字类型不能改变为范围更广的类型，比如从<code class="fe le lf lg lh b">1</code>到<code class="fe le lf lg lh b">string</code>。对象文字得到<code class="fe le lf lg lh b">readonly</code>属性。数组文字变成了<code class="fe le lf lg lh b">readonly</code>元组。</p><p id="bf8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，以下是有效的:</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="a2df" class="mg lj it lh b gy nf ng l nh ni">let x: 'foo' = "foo" as const;</span></pre><p id="c616" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们检查它的类型时，我们得到<code class="fe le lf lg lh b">x</code>是类型<code class="fe le lf lg lh b">'foo'</code>。</p><p id="1819" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个例子是数字数组:</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="f92f" class="mg lj it lh b gy nf ng l nh ni">let x = [1, 2] as const;</span></pre><p id="f060" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们将鼠标悬停在<code class="fe le lf lg lh b">x</code>上方时，我们得到的类型是<code class="fe le lf lg lh b">readonly [1, 2]</code>。</p><h1 id="c06d" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="e68e" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">在TypeScript 3.4中，我们对只读类型进行了多处修改，包括使用<code class="fe le lf lg lh b">readonly</code>关键字来声明只读数组和元组。</p><p id="5ca0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以添加和删除映射类型的<code class="fe le lf lg lh b">readonly</code>修饰符，在索引签名或字段名之前添加<code class="fe le lf lg lh b">readonly</code>和<code class="fe le lf lg lh b">-readonly</code>修饰符。</p><p id="73e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">const</code>断言用于将值转换成只读实体。</p><p id="6c97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">高阶泛型函数允许我们将多个函数组合在一起返回一个新的组合函数，与早期版本相比，它还具有更智能的类型推断。</p><p id="b986" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们有<code class="fe le lf lg lh b">--incremental</code>标志来创建增量构建，这使得代码在后续构建中构建得更快。</p></div></div>    
</body>
</html>