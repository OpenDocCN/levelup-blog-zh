<html>
<head>
<title>Understanding Javascript: the Hoisting Phenomenon</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Javascript:提升现象</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-javascript-the-hoisting-phenomenon-cd8b15f6663b?source=collection_archive---------6-----------------------#2020-09-09">https://levelup.gitconnected.com/understanding-javascript-the-hoisting-phenomenon-cd8b15f6663b?source=collection_archive---------6-----------------------#2020-09-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cf3a7836be4576243813a2beb5e07d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gmh-aePwDfsKr49P"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">马克斯·兰格洛特在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="d9de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">学习JavaScript既有趣又令人兴奋，尤其是当你想成为一名前端开发人员的时候。很多前端框架都是用JavaScript写的，比如React，Angular，Vue。然而，当开始使用这些框架学习时，它们所建立的基础很容易被忽略。</p><p id="ec9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让初级开发人员感到困惑的一个概念是被称为<em class="lb">提升</em>的现象。</p><p id="dc41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">提升某物的意思是举起或拉起。一个背上背包的学生也可以被看作是一个把背包扛在肩上的学生。在JavaScript中，提升是指将声明(即变量和函数)移动到顶部。这是一个默认行为，每当程序被执行时就会发生。但是这对您的代码意味着什么呢？</p><p id="c5da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们继续之前，我想声明一个免责声明。这里展示的例子摘自Anthony Alicea的Udemy课程，名为<em class="lb"> Javascript:理解奇怪的部分</em>。我觉得Alicea的例子很简单，我在这里用它们来说明提升是如何工作的。</p><h2 id="31e5" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">例子</h2><p id="8bad" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">好吧，我们来做个小练习。对于那些编程新手来说，请继续阅读，因为示例中有详细的解释。对于那些对Javascript有基本了解的人，请花点时间回答这个问题:您认为控制台会为每个代码块输出什么？</p><div class="ma mb mc md gt ab cb"><figure class="me jr mf mg mh mi mj paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/631d68df61f4cc47fd48defdefa68526.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*G7xAnE87cMGN4kdebmSJjg.png"/></div></figure><figure class="me jr mk mg mh mi mj paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/f6ab5a588d913a4e10359964f5a78ce9.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*vErW32y1aOqrOwj8b5xFHw.png"/></div></figure><figure class="me jr ml mg mh mi mj paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/bf247b65155a67d46ddc64c7d8047f26.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*nZkh8SgnPTvfbTGT6MK_Ew.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk mm di mn mo translated">示例1、2和3(按顺序)</figcaption></figure></div><p id="1cf4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们先细分每个例子:</p><p id="0775" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在示例1中，我们声明了一个名为“a”的变量，它被赋予了字符串“Hello World”我们还有一个名为“b”的函数，它将控制台记录字符串“Called function b！”无论何时执行。向下移动代码，调用函数b，然后调用变量a的控制台日志。</p><p id="bc47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在示例2中，我们通过调用函数b开始代码，然后调用变量“a”的控制台日志。向下移动代码，变量“a”被声明并被赋予字符串“Hello World”最后，创建函数b。例1和例2中的变量“a”和函数“b”是相同的。</p><p id="9e0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在示例3中，代码看起来与示例2完全相同，但是缺少变量声明“a”。</p><h2 id="5530" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">控制台的输出</h2><p id="b983" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">让我们看看每个示例的输出:</p><div class="ma mb mc md gt ab cb"><figure class="me jr mp mg mh mi mj paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/25299b8e18841db1bc224fd8d8249994.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*ZRVnNwoD0rsQ4JnWo4FVjA.png"/></div></figure><figure class="me jr mq mg mh mi mj paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/554c5b49b265835bd760e38266f3ca01.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*tUN3EVRqGEvsC8jV5SEDhw.png"/></div></figure><figure class="me jr mr mg mh mi mj paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/982f5a053345a2e60dc5a12650bd0094.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*oFtQ7hfUjYe3KmDWJaQeSg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk ms di mt mo translated">示例1、2和3的控制台输出(按顺序)</figcaption></figure></div><p id="202f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在示例1中，字符串“调用了函数b！”首先记录到控制台，然后是变量“a的赋值”Hello World。'</p><p id="43a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在示例2中，字符串“调用了函数b！”首先记录到控制台，后面跟着一个未定义的语句。</p><p id="010e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在示例3中，字符串“调用了函数b！”首先被记录到控制台，然后是一个ReferenceError，表示“未定义”</p><p id="16f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你做对了吗？在每个例子中，函数b都成功地执行了'被调用的函数b！'首先打印到控制台。然而，变量a的值在每个例子中是不同的。这就是所谓的<em class="lb">提升现象。</em></p><h1 id="234b" class="mu ld iq bd le mv mw mx lh my mz na lk nb nc nd ln ne nf ng lq nh ni nj lt nk bi translated">解释了提升现象</h1><p id="4fa8" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">当一个程序被执行时，JavaScript (JS)开始一个叫做执行上下文的东西。这基本上是JS根据您编写的代码设置环境的方式。编译器会检查你的代码，寻找JS保留的关键字，并根据它如何解释你的代码来设置环境。需要指出的是，当编译器运行你的代码时，它会识别出你创建变量和函数的<em class="lb">。JS在执行上下文中做了很多事情，让您的代码为成功做好准备。在这个博客中，我们将重点关注的是导致提升现象的部分。它发生在执行上下文的两个阶段:创建阶段和执行阶段。</em></p><h2 id="ec52" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">创造阶段</h2><p id="1d61" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">在创建阶段，函数和变量被分配内存空间。然而，只有函数是完整设置的——函数名、参数和代码逻辑。变量被创建，但没有被赋值。相反，它最初被分配给JS中的一个特殊单词，称为<em class="lb">未定义的</em>。这只是一个变量的占位符，表示“我已经为这个变量分配了空间，但是我还没有把它分配给你声明的任何东西。”在创建阶段之后，变量被赋予你在代码<em class="lb">中声明的内容，在</em>执行阶段，变量被赋予<em class="lb">中声明的内容。</em></p><h2 id="b4de" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">执行阶段</h2><p id="1c66" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">在执行阶段，JS将再次检查代码，但这一次是一行一行地检查，也称为同步行为。它的内存空间中有所有的变量和函数(在创建阶段创建的),并准备好用它们做一些事情。因此，当变量在创建阶段声明时，直到执行阶段才会被赋予您为其编写的值。这在示例2中可以看到，控制台打印出的不是“Hello World”，而是“undefined”</p><h2 id="2d78" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">参考错误解释</h2><p id="bfa5" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">在示例3中，给出了一个ReferenceError，因为在创建阶段从未创建变量“a”。没有为这个变量分配内存空间，因为它从一开始就没有被声明。这就是初级开发人员感到困惑的地方，因为“未定义”并不像在英语中那样意味着“未定义”。Undefined是JS中的保留字，用作占位符，直到它被赋值替换。</p><h2 id="bb01" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">包装它</h2><p id="a653" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">因此，虽然提升意味着提升或拖拉，但在JavaScript中，它可以被视为在创建阶段将变量和函数提升到代码的顶部。这是分配给它们的内存空间，等待在执行阶段使用。</p><p id="3f31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望这有助于你理解起重现象。我将做一系列“理解Javascript”的概念，所以如果你想阅读更多类似的内容，请关注我的博客。</p><p id="4f38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">快乐编码😄</p></div></div>    
</body>
</html>