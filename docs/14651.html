<html>
<head>
<title>Understanding Kotlin Coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Kotlin协程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-kotlin-coroutines-a47d89178a7f?source=collection_archive---------19-----------------------#2022-12-14">https://levelup.gitconnected.com/understanding-kotlin-coroutines-a47d89178a7f?source=collection_archive---------19-----------------------#2022-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="c98d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将带您了解协程内部是如何工作的，以及<a class="ae ko" href="https://kotlinlang.org/docs/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank"> Kotlin协程</a>给我们带来了什么好处。<a class="ae ko" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank">科特林</a>协程解决了JVM世界中一直存在的一些问题；为我们的多线程应用提供安全、可读和可扩展的解决方案。</p><p id="c04f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们先试着理解什么是协程吧！</p><h1 id="e539" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">介绍</h1><p id="2ef2" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">Kotlin协程是非常轻量级的线程，能够在等待任何类型的<a class="ae ko" href="https://en.wikipedia.org/wiki/Input/output" rel="noopener ugc nofollow" target="_blank"> IO操作</a>时暂停自己，以这种方式释放他们的平台线程，以便它可以为另一个协程做有用的工作。</p><p id="603a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于更有效地利用了现有资源，这使得处理更加有效。</p><p id="28fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你读过我们的文章<a class="ae ko" href="https://theboreddev.com/understanding-java-virtual-threads/" rel="noopener ugc nofollow" target="_blank">“理解Java虚拟线程:异步编程之死”</a>，所有这些对你来说都很熟悉。</p><p id="2338" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Java虚拟线程和Kotlin协同程序在某些方面是相似的，尽管Kotlin已经提供了一个<a class="ae ko" href="https://theboreddev.com/understanding-structured-concurrency/" rel="noopener ugc nofollow" target="_blank">结构化并发</a>构造，这是Java仍然没有的。然而，有计划很快发布类似的东西(范围)，有一些工作作为<a class="ae ko" href="https://openjdk.org/jeps/428" rel="noopener ugc nofollow" target="_blank"> JEP 428 </a>的一部分完成，如果你有兴趣可以查看。</p><p id="063e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于平台线程和操作系统线程之间的对等性，他们都试图解决JVM生态系统中可伸缩性方面的一个主要限制。</p><p id="7913" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能会觉得Java在某种程度上抄袭了Kotlin协程，但是我们既不能证实也不能否认这个假设。Kotlin协同例程于2018年首次发布，而Java虚拟线程则是最近才作为预览功能发布的；不过<a class="ae ko" href="https://openjdk.org/projects/loom/" rel="noopener ugc nofollow" target="_blank"> Project Loom </a>从2017年就开始了。</p><p id="a97d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，很难判断是谁首先提出了这个想法，尤其是当我们谈论JVM生态系统的时候。我们只知道Kotlin比Java更早发布了这个特性，你唯一能做的就是做出自己的结论。</p><p id="f143" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">之前我们在文章<a class="ae ko" href="https://theboreddev.com/a-new-future-for-java/" rel="noopener ugc nofollow" target="_blank">“Java的新未来”</a>中提到过，我们称之为<em class="ls">“Java的kotlinization”</em>我们在Java最近的变化中看到一种趋势，倾向于提供Kotlin之前已经呈现的特性。这是为了让Java对开发者更友好，避免不必要的工作和麻烦。</p><p id="6caa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，我们不能保证到底发生了什么。其中一些术语，如<a class="ae ko" href="https://en.wikipedia.org/wiki/Structured_concurrency" rel="noopener ugc nofollow" target="_blank">“结构化并发”</a>，最早是在60年代听到的，所以这在计算领域并不新鲜。</p><p id="6172" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看Kotlin协程是如何工作的！</p><h1 id="a13d" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">Kotlin协同程序内部</h1><p id="4461" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">现在是时候看看Kotlin协程是如何工作的，以及它们在不同条件下是如何表现的。Kotlin协程内部工作的方式是使用一种叫做<a class="ae ko" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-continuation/" rel="noopener ugc nofollow" target="_blank">延续</a>的东西。<em class="ls">继续</em>基本上允许我们从暂停的地方恢复一些工作。</p><p id="dff1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它的工作方式是，当我们调用一个<em class="ls"> suspendable </em>函数时，它的局部变量在堆栈上被创建。当该函数到达必须等待IO操作的点时，它将挂起自己；保存它的上下文、局部变量和它暂停的地方。</p><p id="3014" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，底层线程将为不同的协程执行一些其他工作。一旦IO操作完成，协程将尝试恢复。如果没有可用的线程，它将等待，直到有线程可用，否则它将立即恢复，并从它之前离开工作的点继续。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/a35a35716efa2ce857f087f0d59e08c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*namubwTWHGejphGN.jpg"/></div></figure><p id="e57e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将向您展示非常简单的示例，以使您容易理解我们的每个示例是如何处理我们的任务的。</p><p id="5b43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于我们的每个示例，我们将使用一段非常简单的代码来模拟一批任务，它能够在需要时自行挂起。在每个任务中，我们使用<code class="fe mb mc md me b">delay</code>模拟10ms的IO等待，一旦完成，我们就打印该批任务的任务号以及它运行在什么平台线程和协同程序上。看起来是这样的:</p><pre class="lu lv lw lx gt mf me mg bn mh mi bi"><span id="7138" class="mj kq it me b be mk ml l mm mn">package com.theboreddev<br/><br/>import kotlinx.coroutines.delay<br/>class Coroutines {<br/>    suspend fun process(batchName: String) {<br/>        for (i in 1..50) {<br/>            delay(10)<br/>            println("Processed task $i for batch $batchName on thread ${Thread.currentThread().name}")<br/>        }<br/>    }<br/>}</span></pre><p id="afcf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如你所见，这很简单。那么让我们来看第一个例子吧！</p><h2 id="04dc" class="mo kq it bd kr mp mq dn kv mr ms dp kz kb mt mu ld kf mv mw lh kj mx my ll mz bi translated">顺序任务</h2><p id="eec0" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">我们使用Kotlin coroutines库的事实并不意味着我们的任务总是多线程和并行运行的。我们可以使用Kotlin协同程序启动两个任务，它们仍将按顺序运行，例如这个测试:</p><pre class="lu lv lw lx gt mf me mg bn mh mi bi"><span id="a449" class="mj kq it me b be mk ml l mm mn">@OptIn(ExperimentalCoroutinesApi::class)<br/>    @Test<br/>    fun `should run sequentially`() = runTest {<br/>        val time = measureTimeMillis {<br/>            val job = GlobalScope.launch {<br/>                coroutines.process("batch a")<br/>                coroutines.process("batch b")<br/>            }<br/>            job.join()<br/>        }<br/>        println("Completed in $time milliseconds")<br/>    }</span></pre><p id="391f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个测试中，我们使用<code class="fe mb mc md me b">GlobalScope.launch</code>运行两批任务。这将创建一个新的协程来运行我们的任务，尽管两个批处理都将在相同的平台线程和协程上运行。我们可以看到，如果我们在运行该测试后检查日志:</p><pre class="lu lv lw lx gt mf me mg bn mh mi bi"><span id="1582" class="mj kq it me b be mk ml l mm mn">Processed task 1 for batch batch a on thread DefaultDispatcher-worker-1 @coroutine#2<br/>...<br/>Processed task 50 for batch batch a on thread DefaultDispatcher-worker-1 @coroutine#2<br/>Processed task 1 for batch batch b on thread DefaultDispatcher-worker-1 @coroutine#2<br/>...<br/>Processed task 50 for batch batch b on thread DefaultDispatcher-worker-1 @coroutine#2<br/>Completed in 1230 milliseconds</span></pre><p id="85ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了避免不必要的混乱，我们省略了大部分日志，因为每个任务都运行在同一个平台线程和协程上，这是意料之中的。这是因为我们只定义了一个协程，在其中我们运行两个批处理的每个任务。</p><p id="6b6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能想知道，当我运行顺序任务时有什么好处呢？当运行潜在阻塞的顺序代码时，Kotlin协同程序仍然有很大的好处。</p><p id="8210" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每当一个协程被暂停等待一个IO操作时，底层平台线程不必等待它的完成。相反，平台线程被分配给另一个协程，以便在此期间继续发挥作用。让我们通过一个简单的测试来证明这一点:</p><pre class="lu lv lw lx gt mf me mg bn mh mi bi"><span id="6ae9" class="mj kq it me b be mk ml l mm mn">@OptIn(ExperimentalCoroutinesApi::class)<br/>@Test<br/>fun `should reuse platform threads when paused`() = runTest {<br/>        val jobs = mutableListOf&lt;Job&gt;()<br/>        val time = measureTimeMillis {<br/>            withContext(Dispatchers.IO) {<br/>                jobs += launch {<br/>                    coroutines.process("batch a")<br/>                    coroutines.process("batch b")<br/>                    coroutines.process("batch c")<br/>                    coroutines.process("batch d")<br/>                    coroutines.process("batch e")<br/>                }<br/>                async {<br/>                    coroutines.process("batch aa")<br/>                    coroutines.process("batch bb")<br/>                }<br/>                async {<br/>                    coroutines.process("batch ba")<br/>                    coroutines.process("batch ab")<br/>                }<br/>            }<br/>            jobs.joinAll()<br/>        }<br/>        println("Completed in $time milliseconds")<br/>}</span></pre><p id="2298" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在按顺序运行多个批处理，除此之外，我们在单独的协同程序中运行两组批处理，以便能够证明当按顺序运行的批处理中的协同程序暂停时，我们可以重用底层线程。</p><p id="c2ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这三组任务应该同时运行，然后，我们将在结果中看到平台线程将如何为这些任务组中的任何一组工作。每当协程因为必须等待IO操作而放弃时，底层线程可以在其他地方重用。因此，下次恢复协程时，底层线程可能已经发生了变化。让我们在日志中看看结果。</p><pre class="lu lv lw lx gt mf me mg bn mh mi bi"><span id="2a2d" class="mj kq it me b be mk ml l mm mn">Processed task 1 for batch batch aa on thread DefaultDispatcher-worker-7 @coroutine#3<br/>Processed task 1 for batch batch ba on thread DefaultDispatcher-worker-5 @coroutine#5<br/>Processed task 1 for batch batch a on thread DefaultDispatcher-worker-3 @coroutine#2<br/>Processed task 2 for batch batch aa on thread DefaultDispatcher-worker-3 @coroutine#3<br/>Processed task 2 for batch batch a on thread DefaultDispatcher-worker-5 @coroutine#2<br/>Processed task 2 for batch batch ba on thread DefaultDispatcher-worker-7 @coroutine#5<br/>Processed task 3 for batch batch aa on thread DefaultDispatcher-worker-7 @coroutine#3<br/>Processed task 3 for batch batch a on thread DefaultDispatcher-worker-5 @coroutine#2<br/>Processed task 3 for batch batch ba on thread DefaultDispatcher-worker-3 @coroutine#5<br/>Processed task 4 for batch batch aa on thread DefaultDispatcher-worker-3 @coroutine#3<br/>Processed task 4 for batch batch ba on thread DefaultDispatcher-worker-7 @coroutine#5<br/>Processed task 4 for batch batch a on thread DefaultDispatcher-worker-5 @coroutine#2<br/>Processed task 5 for batch batch aa on thread DefaultDispatcher-worker-5 @coroutine#3<br/>Processed task 5 for batch batch a on thread DefaultDispatcher-worker-6 @coroutine#2<br/>Processed task 5 for batch batch ba on thread DefaultDispatcher-worker-7 @coroutine#5<br/>...<br/>Completed in 3070 milliseconds</span></pre><p id="5bd5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您会注意到每个批处理总是在同一个协程上运行，但是底层线程变化非常频繁。例如，“<em class="ls">批次aa </em>”总是在协程号3上运行。但是，如果您检查池中使用的底层线程，它在前五次执行中使用了多达3个不同的平台线程！</p><p id="9b7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们对调度的工作原理有了更多的了解，如果我们想并行运行它们以节省时间，我们应该怎么做呢？让我们看看我们能做什么！</p><h2 id="04e5" class="mo kq it bd kr mp mq dn kv mr ms dp kz kb mt mu ld kf mv mw lh kj mx my ll mz bi translated">并行任务</h2><p id="5177" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">如果我们想并行运行它们，只需为每个批处理创建一个协程。我们的测试应该是这样的:</p><pre class="lu lv lw lx gt mf me mg bn mh mi bi"><span id="a888" class="mj kq it me b be mk ml l mm mn">    @OptIn(ExperimentalCoroutinesApi::class)<br/>    @Test<br/>    fun `should run in parallel`() = runTest {<br/>        val jobs = mutableListOf&lt;Job&gt;()<br/>        val time = measureTimeMillis {<br/>            withContext(Dispatchers.IO) {<br/>                jobs += launch {<br/>                    coroutines.process("batch y")<br/>                }<br/>                jobs += launch {<br/>                    coroutines.process("batch z")<br/>                }<br/>            }<br/>            jobs.joinAll()<br/>        }<br/>        println("Completed in $time milliseconds")<br/>    }</span></pre><p id="1849" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在并行启动两个协同程序，如果我们查看日志，我们可以看到它们现在如何使用不同的协同程序并行运行。</p><pre class="lu lv lw lx gt mf me mg bn mh mi bi"><span id="adce" class="mj kq it me b be mk ml l mm mn">Processed task 1 for batch batch z on thread DefaultDispatcher-worker-3 @coroutine#3<br/>Processed task 1 for batch batch y on thread DefaultDispatcher-worker-2 @coroutine#2<br/>Processed task 2 for batch batch y on thread DefaultDispatcher-worker-3 @coroutine#2<br/>Processed task 2 for batch batch z on thread DefaultDispatcher-worker-2 @coroutine#3<br/>Processed task 3 for batch batch y on thread DefaultDispatcher-worker-2 @coroutine#2<br/>Processed task 3 for batch batch z on thread DefaultDispatcher-worker-3 @coroutine#3<br/>...<br/>Completed in 630 milliseconds</span></pre><p id="6409" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你会注意到我们使用<code class="fe mb mc md me b">launch</code>来创建一个新的协程，但是我们之前已经看到过<code class="fe mb mc md me b">async</code>也可以用于这个目的。那有什么区别呢？</p><p id="db94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">唯一不同的是<code class="fe mb mc md me b"><em class="ls">launch</em></code>在完成内部任务后并不返回值，它只是返回一个<code class="fe mb mc md me b"><a class="ae ko" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/" rel="noopener ugc nofollow" target="_blank">Job</a></code>对象。然而，<code class="fe mb mc md me b"><a class="ae ko" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html" rel="noopener ugc nofollow" target="_blank">async</a></code>返回一个<code class="fe mb mc md me b"><a class="ae ko" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/" rel="noopener ugc nofollow" target="_blank">Deferred</a></code>对象，它也是一个<code class="fe mb mc md me b">Job</code>，但是它包含一个在内部任务完成后返回的值。你可以看到<code class="fe mb mc md me b">Deferred</code>接口是如何从<code class="fe mb mc md me b">Job</code>延伸出来的:</p><pre class="lu lv lw lx gt mf me mg bn mh mi bi"><span id="a377" class="mj kq it me b be mk ml l mm mn">public interface Deferred&lt;out T&gt; : Job</span></pre><p id="12a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将修改前面的示例，添加两个并行任务的结果，如下所示:</p><pre class="lu lv lw lx gt mf me mg bn mh mi bi"><span id="f9c9" class="mj kq it me b be mk ml l mm mn">    @OptIn(ExperimentalCoroutinesApi::class)<br/>    @Test<br/>    fun `should run in parallel and get values`() = runTest {<br/>        val jobs = mutableListOf&lt;Deferred&lt;Int&gt;&gt;()<br/>        var result: Int<br/>        val time = measureTimeMillis {<br/>            withContext(Dispatchers.IO) {<br/>                jobs += async {<br/>                    delay(100)<br/>                    Random.nextInt(0, 100)<br/>                }<br/>                jobs += async {<br/>                    delay(100)<br/>                    Random.nextInt(0, 100)<br/>                }<br/>            }<br/>            result = jobs.awaitAll().sum()<br/>        }<br/>        println("Completed in $time milliseconds with result $result")<br/>    }</span></pre><p id="d72a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以看到我们现在有了一个<code class="fe mb mc md me b">Deferred</code>对象列表。我们可以使用<code class="fe mb mc md me b"><a class="ae ko" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/await-all.html" rel="noopener ugc nofollow" target="_blank">awaitAll</a></code>来等待所有这些任务的完成。我们将为每个任务获得一个包含一个<code class="fe mb mc md me b">Int</code>的<code class="fe mb mc md me b">List&lt;Int&gt;</code>，一旦我们有了它，我们就可以使用<code class="fe mb mc md me b"><a class="ae ko" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sum.html" rel="noopener ugc nofollow" target="_blank">sum</a></code>来添加值。</p><p id="6633" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们只有一个任务返回值，而不是使用<code class="fe mb mc md me b">awaitAll</code>，我们就必须使用<code class="fe mb mc md me b">await</code>。这很直观，但是让我们看一个简短的例子:</p><pre class="lu lv lw lx gt mf me mg bn mh mi bi"><span id="6c97" class="mj kq it me b be mk ml l mm mn">val r = async {<br/>  delay(100)<br/>  Random.nextInt(0, 100) <br/>}<br/>r.await()</span></pre><p id="079d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">话虽如此，如果我们运行上面所示的测试，我们会得到预期的结果:</p><pre class="lu lv lw lx gt mf me mg bn mh mi bi"><span id="b5ea" class="mj kq it me b be mk ml l mm mn">Completed in 112 milliseconds with result 93</span></pre><p id="bf77" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在使用<code class="fe mb mc md me b">launch</code>的例子中，您还会注意到，我们使用<code class="fe mb mc md me b">launch</code>方法启动了两个不同的协程，而不是<code class="fe mb mc md me b">GlobalScope.launch</code>。这是为什么呢？让我们试着更好地理解<em class="ls">作用域</em>！</p><h2 id="4370" class="mo kq it bd kr mp mq dn kv mr ms dp kz kb mt mu ld kf mv mw lh kj mx my ll mz bi translated">协程作用域</h2><p id="2088" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">每次我们启动Kotlin协程时，我们都需要一个上下文来附加我们的协程。当我们使用<code class="fe mb mc md me b">GlobalScope</code>时，我们使用的是全局作用域，它将贯穿整个应用程序的生命周期。这意味着我们的协程可以存在于应用程序的整个生命周期中。</p><p id="77f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们被迫总是在一个上下文中运行协程，以便能够有一个更安全的并发代码。通过将协程附加到协程上下文，运行时总是知道在协程失败时该做什么。</p><p id="da74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们有多个嵌套协程的情况下，在一个层次结构中，每个协程都有其父级，但它可能同时也是父级，运行时将知道在失败的情况下应该取消哪些协程。这就是我们所说的<a class="ae ko" href="https://theboreddev.com/understanding-structured-concurrency/" rel="noopener ugc nofollow" target="_blank">结构化并发！</a></p><p id="2a83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下图中，您可以清楚地看到Kotlin中的结构化并发是什么样子的，在kot Lin中，创建一个新的协程总是需要在当前作用域内创建一个嵌套作用域。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/cdfb1a4d943aa192283c03658988eea4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*d8Pza4am7n_T5STt.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">鸣谢:作者</figcaption></figure><p id="b3fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的应用程序中不再有线程挂起，不再需要小心翼翼地到处泄露它们！<em class="ls">结构化并发</em>的巨大好处之一是我们可以在应用程序中定义线程的层次结构。如果我们在任何级别的任何一个孩子失败了，那么我们层次结构中的每个协程都会被取消。</p><p id="3071" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">不推荐使用</strong> <code class="fe mb mc md me b"><strong class="js iu">GlobalScope</strong></code> <strong class="js iu">，</strong>因为它不会取消我们的协程，除非应用程序关闭！请记住，默认情况下，每个启动的协程都从其父进程继承上下文。这意味着在我们在<code class="fe mb mc md me b">GlobalScope.launch</code>中启动多个嵌套协程的情况下，它们都从它那里继承全局范围！</p><p id="ea4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是非常危险的，因为协程将永远运行，直到应用程序关闭。相反，我们应该使用<code class="fe mb mc md me b"><a class="ae ko" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html" rel="noopener ugc nofollow" target="_blank">withContext</a></code>方法创建一个上下文。该方法接受一个上下文和一个<em class="ls"> suspend </em>函数，如果我们不指定任何上下文，它将使用Kotlin中提供的<a class="ae ko" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html" rel="noopener ugc nofollow" target="_blank">默认调度器</a>。</p><p id="c4f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还有一个特定的调度器用于阻塞任务，您可以通过将<code class="fe mb mc md me b"><a class="ae ko" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-i-o.html" rel="noopener ugc nofollow" target="_blank">Dispatchers.IO</a></code>传递给<code class="fe mb mc md me b">withContext</code>方法来使用它。</p><p id="71be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您的应用程序是IO绑定的，大多数情况下您将不得不使用<code class="fe mb mc md me b">Dispatchers.IO</code>，但是，我们建议您阅读关于<a class="ae ko" href="https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html" rel="noopener ugc nofollow" target="_blank">现有调度程序</a>的信息，以了解哪一个更适合您的情况。</p><h1 id="c6fc" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">结论</h1><p id="f8e8" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在本文中，我们向您深入介绍了Kotlin协同例程，以及它们如何帮助我们以安全、高效、简单和可读的方式运行并发代码。我们已经看到了Kotlin协程上下文对于我们应用程序的安全性有多重要，以及Kotlin协程的资源利用效率有多高。</p><p id="66dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这都是我们今天送的！我们希望你喜欢我们一起通过Kotlin协同程序的旅程，并希望学到一些新东西！期待很快再次见到你！</p><p id="30c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢阅读我们！</p></div></div>    
</body>
</html>