<html>
<head>
<title>Inference Using Web Workers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Web Workers进行推理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/inference-using-web-workers-f47266b7ef11?source=collection_archive---------13-----------------------#2020-12-09">https://levelup.gitconnected.com/inference-using-web-workers-f47266b7ef11?source=collection_archive---------13-----------------------#2020-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="603f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过机器学习进行打字练习</h2></div><blockquote class="kf kg kh"><p id="97b3" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">本系列文章:<br/> 1。<a class="ae lf" href="https://medium.com/@bayan.bennett/typing-practice-with-machine-learning-introduction-aa3bb5d24134" rel="noopener">简介</a> <br/> 2。<a class="ae lf" rel="noopener ugc nofollow" target="_blank" href="/pseudo-english-typing-practice-with-machine-learning-5700eb4dc54">伪英语</a>T9】3。<a class="ae lf" rel="noopener ugc nofollow" target="_blank" href="/keyboard-input-typing-practice-w-machine-learning-b5c5a9a362a7">键盘输入</a> <br/> 4。使用Web Workers进行推理(您在这里)</p><p id="7d30" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">完工项目位于:<a class="ae lf" href="https://www.bayanbennett.com/projects/rnn-typing-practice" rel="noopener ugc nofollow" target="_blank">https://www.bayanbennett.com/projects/rnn-typing-practice</a></p></blockquote><p id="e944" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">最后一篇文章，<a class="ae lf" rel="noopener ugc nofollow" target="_blank" href="/keyboard-input-typing-practice-w-machine-learning-b5c5a9a362a7">键盘输入</a>，是关于准备用于生成后续字符行的数据。本文研究如何使用该输入，以及如何使用TensorFlow模型生成一行文本。此外，该模型将完全在WebWorker上运行。</p><p id="756b" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">为了更多地了解web workers，我在这里创建了一个软介绍:<a class="ae lf" href="https://medium.com/weekly-webtips/barebones-web-workers-bb0436cc440d" rel="noopener">准系统Web Workers </a>。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/3b887911f84ed8729875b03acdbd643c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w7SdYiNh9rAFlm9a"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">迈克尔·泽兹奇在<a class="ae lf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="500f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">设置员工</h1><p id="49f3" class="pw-post-body-paragraph ki kj iq kl b km mr jr ko kp ms ju kr lg mt ku kv lh mu ky kz li mv lc ld le ij bi translated">下面的代码都在<code class="fe mw mx my mz b">mlKeyboard.worker.js</code>文件内。首先，导入TensorflowJS文件:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="d561" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated"><a class="ae lf" href="https://js.tensorflow.org/api/2.6.0/#enableProdMode" rel="noopener ugc nofollow" target="_blank">启用生产模式</a></p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="37ee" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">将后端设置为<code class="fe mw mx my mz b">webgl</code>，这样我们就可以调用GPU了。如果这个不可用，TensorFlowJS后端将默认为<code class="fe mw mx my mz b">cpu</code>。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="8b4b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">获取模型</h1><p id="d23b" class="pw-post-body-paragraph ki kj iq kl b km mr jr ko kp ms ju kr lg mt ku kv lh mu ky kz li mv lc ld le ij bi translated">这必须从服务器上的端点加载。一旦它被加载，将它保存到我们的worker的状态对象中，并向主窗口发布一条消息，表明worker已经准备好了。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="7682" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">在初始化期间以及当用户完成输入一行时，主窗口将发送一条类型为<code class="fe mw mx my mz b">actionTypes.worker.getNextLine</code>的消息。运行了一些其他函数，但最终调用了下面的函数<code class="fe mw mx my mz b">generateLine</code>。这个函数初始化一个34个字符的数组，并依次调用一个异步函数来生成每个密钥。之所以选择34，是因为它非常适合桌面和移动屏幕。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="2ed2" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">规范化二元模型</h1><p id="7f76" class="pw-post-body-paragraph ki kj iq kl b km mr jr ko kp ms ju kr lg mt ku kv lh mu ky kz li mv lc ld le ij bi translated">在上一篇文章<a class="ae lf" rel="noopener ugc nofollow" target="_blank" href="/keyboard-input-typing-practice-w-machine-learning-b5c5a9a362a7">键盘输入</a>中，生成了一个二元模型，记录了任意一对击键之间的平均延迟。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/01b7585cb1df9f195f2c5750620c2e17.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/0*cehrI9bhTAyHCg01.png"/></div></figure><p id="3a5e" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">为了创建上面的图像以及在模型中使用它，需要对它进行规范化。</p><p id="f34f" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">在这种情况下，我选择简单地将每个值转换成平均值的标准偏差数，然后使它成为e的幂。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nd nb l"/></div></figure><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="b180" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">生成每个字符</h1><p id="6816" class="pw-post-body-paragraph ki kj iq kl b km mr jr ko kp ms ju kr lg mt ku kv lh mu ky kz li mv lc ld le ij bi translated">现在事情变得有趣了，运行ML模型！</p><h1 id="7121" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">生成第一个字符</h1><p id="fbc5" class="pw-post-body-paragraph ki kj iq kl b km mr jr ko kp ms ju kr lg mt ku kv lh mu ky kz li mv lc ld le ij bi translated">模型需要最后一个字符的输入，那么如果没有呢？一种选择是用所有以空格开头的单词来训练模型。在这种情况下，第一个字符将始终是一个空格。</p><p id="1125" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">然而，在我的例子中，我想对第一个角色有更多的控制，所以我选择生成第一个角色。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="ce2a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">获取行中的最后一个字符</h1><p id="3b48" class="pw-post-body-paragraph ki kj iq kl b km mr jr ko kp ms ju kr lg mt ku kv lh mu ky kz li mv lc ld le ij bi translated">这里没什么。直白。从该行中获取最后一个字符，如果该行由于某种原因为空，则返回一个<code class="fe mw mx my mz b">space</code>。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="9a61" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">使用推理获得下一个字符</h1><p id="62a7" class="pw-post-body-paragraph ki kj iq kl b km mr jr ko kp ms ju kr lg mt ku kv lh mu ky kz li mv lc ld le ij bi translated">这就是奇迹发生的地方。它从<code class="fe mw mx my mz b"><a class="ae lf" href="https://js.tensorflow.org/api/latest/#tf.Sequential.predict" rel="noopener ugc nofollow" target="_blank">tf.Sequential.predict</a></code>为每个角色生成概率开始，然后应用角色调整，<code class="fe mw mx my mz b"><a class="ae lf" href="https://js.tensorflow.org/api/latest/#multinomial" rel="noopener ugc nofollow" target="_blank">tf.multinomial</a></code>返回一个角色。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="c19a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">计算空间的概率</h1><p id="c489" class="pw-post-body-paragraph ki kj iq kl b km mr jr ko kp ms ju kr lg mt ku kv lh mu ky kz li mv lc ld le ij bi translated">你可能注意到了上面的<code class="fe mw mx my mz b">spaceAdjustment</code>变量。数据集由不同长度的单词组成，这使得模型很难准确预测单词何时结束。知道了字长的分布，预测就可以朝着正确的方向推进。这是空间累积分布函数:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="ne nb l"/></div></figure><p id="2660" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">其中<em class="kk"> k = 0.64766 </em>和<em class="kk"> x_0 = 6.18632 </em>。这些值是通过拟合字长分布得到的。例如，一个5个字母的单词会使出现空格的概率增加46%。</p><h1 id="624b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">把所有的放在一起</h1><p id="40a9" class="pw-post-body-paragraph ki kj iq kl b km mr jr ko kp ms ju kr lg mt ku kv lh mu ky kz li mv lc ld le ij bi translated">大部分重要的逻辑已经在上面描述过了，下面的代码将它们放在一起。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="4347" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">获取最后一个字符，如果是空格或空字符，生成单词的第一个字符。否则，通过在模型中运行最后一个字符并输出预测来生成下一个字符。如果下一个字符是<code class="fe mw mx my mz b">space</code>或<code class="fe mw mx my mz b">null</code>，将间距设置为<code class="fe mw mx my mz b">0</code>。然后对该行中的每个字母重复该功能。</p><h1 id="917e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">总结想法</h1><p id="a141" class="pw-post-body-paragraph ki kj iq kl b km mr jr ko kp ms ju kr lg mt ku kv lh mu ky kz li mv lc ld le ij bi translated">这篇文章演示了ML模型推理如何在WebWorker上运行。我惊喜地发现只需要这么少的样板代码。所有的代码只是TensorFlowJS库和一些辅助函数。</p><p id="73e8" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">最终，这些方法将有助于在不影响可用性的情况下创建具有高级ML功能的web应用程序。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="1ab2" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">最初来自:</p><div class="nm nn gp gr no np"><a href="https://www.bayanbennett.com/posts/inference-using-web-workers-typing-practice-w-machine-learning" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">使用Web Workers进行推理-使用机器学习进行打字练习</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">完成的项目位于这里:https://www.bayanbennett.com/projects/rnn-typing-practice最后一个职位，键盘…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">www.bayanbennett.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od lt np"/></div></div></a></div></div></div>    
</body>
</html>