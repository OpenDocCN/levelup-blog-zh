<html>
<head>
<title>Object orientation for functional programmers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向函数式程序员的对象</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/object-orientation-for-functional-programmers-606c8a160e4?source=collection_archive---------36-----------------------#2020-06-29">https://levelup.gitconnected.com/object-orientation-for-functional-programmers-606c8a160e4?source=collection_archive---------36-----------------------#2020-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b264b4ad5f8b8d4988e5504748669a2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xbvnhaf_GB0zf-javOZlnw.jpeg"/></div></div></figure><p id="2d56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">亲爱的函数式程序员朋友们，看来面向对象是由停留决定的，所以是时候了解一下它了。在本文中，我们将这个函数式程序转变为面向对象的语言，保留了不变性、模式匹配、可组合性和类型安全。这些例子是用OCaml和Java编写的，但是应该可以无缝地翻译成任何函数式和面向对象的语言。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="b95b" class="lf lg iq lb b gy lh li l lj lk">type 'a list =<br/>  | Nil<br/>  | Cons of 'a * 'a list</span><span id="2a03" class="lf lg iq lb b gy ll li l lj lk">(* fold_right : ('a -&gt; 'b -&gt; 'b) -&gt; 'b -&gt; 'a list -&gt; 'b *)<br/>let rec fold_right step base xs =<br/>  match xs with<br/>    | Nil -&gt; base<br/>    | Cons (x, xs') -&gt; step x (fold_right step base xs')</span><span id="2711" class="lf lg iq lb b gy ll li l lj lk">(* map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list *)<br/>let map f xs = <br/>  fold_right (fun x xs' -&gt; Cons (f x, xs')) Nil xs</span></pre><p id="8b03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们正在构建一个“列表库”，所以我们将所有内容放在一个Java类中。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="3687" class="lf lg iq lb b gy lh li l lj lk">public class List { }</span></pre><p id="086a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了清晰起见，我还保留了OCaml命名风格，尽管它在Java中看起来很可怕。让我们依次看每一部分。</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lm"><img src="../Images/2833c6f1d4289ac8b8a4d999c3c6f931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vaThRiefqi-GDUruAE1PCw.jpeg"/></div></div></figure><h1 id="8c67" class="ln lg iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">不可变数据类型</h1><p id="c1cf" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">我们首先需要移动的是构造函数<code class="fe mp mq mr lb b">Nil</code>和<code class="fe mp mq mr lb b">Cons</code>。我们可以使用具有公共接口的类来实现这些。在这种情况下，我们选择不通过使它们成为静态内部类来公开它们，但这并不重要。</p><p id="c2b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">OCaml类型是多态的，所以我们的Java接口(和类)需要是通用的。<code class="fe mp mq mr lb b">Nil</code>没有参数，所以Java类没有字段，<code class="fe mp mq mr lb b">Cons</code>有两个，所以Java类有两个字段。</p><p id="2feb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，因为数据类型在OCaml中是不可变的，所以我们也需要继承这个属性。在Java中，我们可以通过使用<code class="fe mp mq mr lb b">final</code>关键字来使字段不可变。</p><p id="7079" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们最终会得到:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="07f5" class="lf lg iq lb b gy lh li l lj lk">public class List {<br/>  private interface list&lt;A&gt; { }<br/>  private static class Nil&lt;A&gt; implements list&lt;A&gt; { }<br/>  private static class Cons&lt;A&gt; implements list&lt;A&gt; {<br/>    public final A element;<br/>    public final list&lt;A&gt; rest;<br/>    public Cons(A element, list&lt;A&gt; rest) {<br/>      this.element = element;<br/>      this.rest = rest;<br/>    }<br/>  }<br/>}</span></pre><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lm"><img src="../Images/05212edb2d1dbe191a98fef48b3135ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RAGcpECURoIjqHA8kO9SuA.jpeg"/></div></div></figure><h1 id="c564" class="ln lg iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">模式匹配</h1><p id="c534" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">是时候处理复杂的<code class="fe mp mq mr lb b">fold_right</code>功能，从而进行模式匹配了。面向对象的语言有一个复杂的变通方法，以<em class="ms">设计模式</em>的形式来弥补语言缺乏模式匹配的缺陷；具体来说，访问者模式。我们用另一个接口实现了这一点，并向构造函数添加了一个<code class="fe mp mq mr lb b">visit</code>方法。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="617d" class="lf lg iq lb b gy lh li l lj lk">public class List {<br/>  private interface listVisitor&lt;A, B&gt; {<br/>    B visit(Nil&lt;A&gt; xs);<br/>    B visit(Cons&lt;A&gt; xs);<br/>  }<br/>  private interface list&lt;A&gt; {<br/>    &lt;B&gt; B visit(listVisitor&lt;A, B&gt; visitor);<br/>  }<br/>  private static class Nil&lt;A&gt; implements list&lt;A&gt; {<br/>    public &lt;B&gt; B visit(listVisitor&lt;A, B&gt; visitor) {<br/>      return visitor.visit(this);<br/>    }<br/>  }<br/>  private static class Cons&lt;A&gt; implements list&lt;A&gt; {<br/>    // ...<br/>    public &lt;B&gt; B visit(listVisitor&lt;A, B&gt; visitor) {<br/>      return visitor.visit(this);<br/>    }<br/>  }<br/>}</span></pre><p id="ee0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">忽略高阶函数<code class="fe mp mq mr lb b">step</code>直到下一节，使用Visitor模式，直接实现<code class="fe mp mq mr lb b">fold_right</code>方法。它比OCaml略显繁琐，但不难看出相同的结构:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="490b" class="lf lg iq lb b gy lh li l lj lk">&lt;A, B&gt; B fold_right(??? step, B base, list&lt;A&gt; xs) {<br/>  return xs.visit(new listVisitor&lt;A, B&gt;() {<br/>    public B visit(Nil&lt;A&gt; xs) {<br/>      return base;<br/>    }<br/>    public B visit(Cons&lt;A&gt; xs) {<br/>      return step.apply(xs.element, xs.rest.visit(this));<br/>    }<br/>  });<br/>}</span></pre><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/26a44b97843e3bb655853ff81a1e05df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SQzpwd77-vTRa5S8khi61A.jpeg"/></div></div></figure><h1 id="1be6" class="ln lg iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">高阶函数</h1><p id="4835" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">谜题的最后一部分是高阶函数。它需要是我们可以作为参数的东西，我们只有一样东西符合这个标准:对象。所以对于每个函数签名，我们简单地为它创建一个类。这个符合<code class="fe mp mq mr lb b">fold_right</code>的目的:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="036a" class="lf lg iq lb b gy lh li l lj lk">private interface FoldFunc&lt;A, B&gt; {<br/>  B apply(A elem, B rest);<br/>}</span></pre><p id="b7b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着我们也可以实现<code class="fe mp mq mr lb b">map</code>方法:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="cfda" class="lf lg iq lb b gy lh li l lj lk">private interface MapFunc&lt;A, B&gt; {<br/>  B apply(A elem);<br/>}<br/>&lt;A, B&gt; list&lt;B&gt; map(MapFunc&lt;A, B&gt; f, list&lt;A&gt; xs) {<br/>  return fold_right(new FoldFunc&lt;A, list&lt;B&gt;&gt;() {<br/>    public list&lt;B&gt; apply(A elem, list&lt;B&gt; rest) {<br/>      return new Cons&lt;B&gt;(f.apply(elem), rest);<br/>    }<br/>  }, new Nil&lt;B&gt;(), xs);<br/>}</span></pre><h1 id="1351" class="ln lg iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="0018" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">尽管在Java中有点笨拙和冗长，但进行函数式编程是可能的。使用lambdas和diamond操作符确实让它看起来漂亮了一点，但是它们没有增加任何表现力。</p><p id="ed26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的书中，我讨论了如何从已经面向对象的代码转向通过重构从函数式编程中获得的许多相同的好处:</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><a href="https://www.manning.com/books/five-lines-of-code"><div class="gh gi mu"><img src="../Images/ac2e56b71c80f26c090280c2ea7d0b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*gVCoNzmp-Ua8ui0NQlEVaw.png"/></div></a></figure></div></div>    
</body>
</html>