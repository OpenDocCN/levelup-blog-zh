# 用 PHP 中的例子简化坚实的原理

> 原文：<https://levelup.gitconnected.com/solid-principles-simplified-php-examples-based-dc6b4f8861f6>

![](img/0b0d80ba4712104583c9f45ff267ab4f.png)

照片由[扎克·赖纳](https://unsplash.com/@_zachreiner_?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

SOLID 是**前五个面向对象设计(OOD)原则的首字母缩写**和是一系列指导原则，开发人员可以使用它们以一种易于维护和扩展的方式构建软件。理解这些概念将使您成为更好的开发人员，并使您能够避免代码味道。

实心代表:

*   单一责任原则
*   **O:** 开闭原理
*   **L:** 利斯科夫替代原理
*   **I:** 界面偏析原理
*   **D:** 依存倒置原则

让我们更深入地了解这些原则！

# 单一责任原则

> 一个类应该有且只有一个改变的理由，这意味着一个类应该只有一个作业。

这意味着如果我们的类承担不止一个责任，我们将有一个高耦合。原因是我们的代码在任何变化下都是脆弱的。

假设我们有一个用户类，如下所示:

在这种情况下，方法`store`超出了范围，这个职责应该属于管理数据库的类。这里的解决方案是创建两个类，每个类都有适当的职责。

# 开闭原理

> 对象或实体应该对扩展开放，但对修改关闭。

根据这一原则，软件实体必须**易于扩展新功能，而不必修改其使用中的现有代码**。

假设我们必须计算一些物体的总面积，为此我们需要一个 *AreaCalculator* 类，它只计算每个形状面积的总和。这里的问题是每个形状都有不同的方法来计算自己的面积。

如果我们添加另一个形状，如*圆*，我们必须改变*面积计算器*来计算新形状的面积，这是不可持续的。这里的解决方案是创建一个简单的*形状*接口，该接口具有 area 方法，并将由所有其他形状实现。这样，我们将只使用一种方法来计算总和，如果我们需要添加一个新的形状，它将只实现*形状*接口。

# 利斯科夫替代原理

> 设 q(x)是关于 t 类型的对象 x 的一个可证明的性质，那么 q(y)对于 S 类型的对象 y 应该是可证明的，其中 S 是 t 的子类型。

原则上说**对象必须可以被其子类型的实例替换，而不改变我们系统**的正确功能。

想象一下管理两种类型的咖啡机。根据用户计划，我们将使用基本或高级咖啡机，唯一的区别是高级机器比基本机器做出更好的香草咖啡。两台机器的主程序行为必须相同。

# 界面分离原理

> 永远不要强迫客户端实现它不使用的接口，也不要强迫客户端依赖它们不使用的方法。

这个原则定义了**一个类不应该实现不使用**的接口。在这种情况下，意味着在我们的实现中，我们将拥有不需要的方法。解决方法是**开发专用接口，而不是通用接口**。

想象一下，我们发明了既能飞行又能驾驶的未来汽车

如你所见，主要问题是*汽车*和*飞机*有不使用的方法。解决方案是将*车辆接口*分成两个更具体的接口，仅在必要时使用，如下所示:

# 从属倒置原则

> 实体必须依赖抽象，而不是具体。它声明高级模块不能依赖于低级模块，但是它们应该依赖于抽象。

这个原则意味着**一个特定的类不应该直接依赖于另一个类，而是依赖于这个类的抽象**。这个原则允许解耦和更多的代码可重用性。

让我们来看第一个 *UserDB* 类的例子。该类可能依赖于数据库连接:

在这种情况下， *UserDB* 类直接依赖于 MySQL 数据库。这意味着，如果我们要改变正在使用的数据库引擎，我们需要重写这个类，违反了开闭原则。

解决方案是开发数据库连接的抽象:

这些原则代表了代码质量的艺术状态，遵循这些原则可以让你写出易于扩展、重用和重构的软件。

我希望这篇文章能帮助你更好地理解什么是代码质量，也许还能提高你的编码能力！编码快乐！😄