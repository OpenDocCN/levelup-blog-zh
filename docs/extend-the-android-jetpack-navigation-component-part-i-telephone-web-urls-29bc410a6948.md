# 扩展 Android Jetpack 导航组件:电话和网络 URL

> 原文：<https://levelup.gitconnected.com/extend-the-android-jetpack-navigation-component-part-i-telephone-web-urls-29bc410a6948>

## 将 Jetpack 推向新的高度

![](img/f6b016c4f3f711686b9c5eeea1d51fa3.png)

Android Jetpack 导航组件革新并标准化了 Android 上的路由方式。然而，随着每一次演进，都有一个学习曲线来使现有的约定适应新的实现。让我们看看如何修改这个库来将用户路由到电话号码和 web URLs。

# 电话处理员

我在同一篇文章中将电话和 web URLs 的处理程序分组在一起，因为它们是相似的。然而，首先，我将只关注电话和`tel:`协议的实现。

## 期望

我想这个分机接受和路由到任何电话号码交给它。这样，如果我的应用程序能够路由到几个电话号码，我只需要导航图中的一个节点就可以处理所有的电话号码。

就代码而言，我希望导航图是这样的:

提议的电话导航模式

到此目的地的路由应该如下所示:

使用导航图路由到电话号码的示例代码

期望一定程度的容错也是合理的。具体来说，从没有电话拨号器的设备(如平板电脑)拨打电话不应该无声无息地失败，当然也不应该导致应用程序崩溃。在这个场景中，我想向用户显示这个号码，这样他或她就可以用座机打电话了。

既然期望已经设定，我们就可以开始实现了。

## 构建骨架

每个自定义导航器都有一个基本框架，我们必须在深入研究之前实现它。我们的导航器的基础是这样的:

电话导航仪骨架

请允许我分解相关部分:

*   `@Navigator.Name("telephone")` -将出现在导航图的 XML 文件中的节点名称。在这种情况下，我会使用`<telephone />`来创建这种目的地。
*   `Navigator<>` -所有的自定义导航器都必须继承这个类。
*   `popBackStack() = true` -由于拨号器很可能是一个外部应用程序，您的图形不负责外部后台堆栈。因此，每当拨号器完成自身并返回到您的应用程序时，该目的地已经弹出，导航器指示`true`移除成功。
*   `@NavDestination.ClassType(Activity::class)` -不是严格要求，但我喜欢给导航图一个这个目的地将会是什么样的视图的概念。由于 Android 的拨号器应用程序几乎肯定在你的应用程序之外，我认为它是某种通用的`Activity`。
*   在这种情况下并不令人兴奋。这个类通常映射并获取从 XML 传递到 Kotlin(或 Java)代码的定制属性，以便进行后续处理。然而，由于我选择通过参数动态传递我的属性，所以我不需要在这里指定任何静态参数属性。

## 简单的实现

对于我们工作的第一次迭代，让我们忽略边缘情况，并假设当给定一个电话号码时，总有一个操作系统可以用来打电话的处理程序。按照预期，我们已经完成了`createDestination()`和`popBackStack()`方法的必要工作。剩下的就是`navigate()`方法了。

如果您还记得我上面的 XML 示例，我希望名为`phoneNumber`的`<argument />`提供数据，我需要正确地处理路由。该信息通过`navigate()`功能上的`args`参数获得。获取信息的方式如下:

简单的导航实现

注意方法末尾的`return null`。这与`popBackStack() = true`的原因相同。如果我返回了`destination`，这将把这个导航器添加到当前应用程序的后台堆栈，并路由到外部拨号器。在这种情况下，我通过返回`null`来离开我的后台堆栈的状态。不必管理另一个后台堆栈，这让我的工作变得更加轻松。

## 错误处理

我在上面的实现中看到了三个突出的问题:

1.  如果给定的电话号码为空或空白怎么办？
2.  号码无效怎么办？
3.  如果设备没有`tel:`协议的处理程序(即没有拨号器应用程序)，该怎么办？

第一个和最后一个问题很容易解决。

更强大的导航方法，具有错误处理功能

第二个问题是一个相当大的滑坡。有几个为 Android 开发的库可以达到这个目的。分别是 [PhoneNumberUtils](https://go.oliverspryn.com/phonenumberutils) 和 [libphonenumber](https://go.oliverspryn.com/libphonenumber) 。然而，根据我的研究，每个库都有大量的陷阱，这些陷阱要么没有很好的理由，要么期望一个格式略有不同的数字，即使它仍然有效。我的建议是在导航器中放弃这种验证。在我开发的所有应用程序中，提供的电话号码都是预先确定的，要么是硬编码的，要么来自我们公司维护的数据库。的确，如果我们分发的是畸形的电话号码，我们要处理的问题比让它们从我们的电话导航仪中溜走更大。

## 使用

在我们开始使用新的导航器之前，导航主机必须意识到它的存在。这是通过将我们的导航器添加到现有支持的导航器列表中来实现的。

首先，创建一个名为`CustomNavHostFragment`的新导航主机，并像这样实现它:

支持电话导航器的导航主机片段

最后，打开包含导航主机的活动的布局文件，将`android:name`属性替换为您刚刚创建的导航主机的全限定类名:

实现自定义导航主机的片段容器视图

现在，您可以自由地路由到新的目的地类型，就像本文开头所描述的那样。让我们将这个新的目的地添加到我们的`nav_graph.xml`文件中:

简化的导航图，显示使用中的电话目的地

从这里，我们可以随心所欲地选择路线:

使用导航图路由到电话号码的示例代码

# Web URL 处理程序

对于那些有 web 背景的人来说，知道 HTTP 处理程序和电话处理程序之间的唯一区别是协议可能并不奇怪。网页链接使用`http:`或`https:`，而电话使用`tel:`。本节将介绍这种导航目的地在实现和预期方面的差异。

## 期望

我希望这个目的地能够处理通过类似电话处理程序的参数传递给它的任何 URL。它在导航图上的签名应该如下所示:

建议的 web URL/HTTP 导航模式

到此目的地的路由应该如下所示:

使用导航图路由到 URL 的示例代码

你已经开发了一个被成千上万人使用的应用，你已经习惯了思考边缘情况。只要设备上没有 HTTP 处理程序，这个处理程序就应该能够恢复。是的。它发生了。我的 Web URL 处理程序的第一次迭代没有考虑到这种情况，最终会在没有 Web 浏览器的设备上崩溃。这是一个疯狂的世界。

## 实施

首先，复制`TelephoneNavigator`的整个实现，并如下所示进行调整。在这种情况下，由于代码非常相似，我将只包括不同之处，以便您可以更改相关部分:

HTTP navigator 只强调它与电话导航器之间的区别

## 使用

再一次，这一部分是电话导航器使用的清洗、漂洗和重复，尽管使用了`<http />`标签而不是`<telephone />`。请记住，您可以向`CustomNavHostFragment`添加任意数量的自定义导航器。因此，如果你的应用程序需要这两种导航器，把它们添加到列表中并使用它们。

# 结论

我希望您喜欢我在这个系列中的第一篇文章。希望它让您很好地理解了向导航工具集添加自定义附件的基本技术。由于它们的相似性，这两个是我期望分组的唯一扩展。即将到来的导航库的改编将提供更多的洞察力，让我们作为工程师能够更好地利用这个工具。

以下是一些我用来帮助我收集想法和构建这种导航器的资源:

*   [安卓导航组件文档](https://go.oliverspryn.com/getting-started-with-the-navigation-component)
*   [自定义对话框导航器](https://go.oliverspryn.com/dialog-navigator)
*   [带有自定义视图的 Jetpack 导航](https://go.oliverspryn.com/jetpack-navigation-with-custom-views)

# 喜欢你读的东西吗？

媒体上还有成千上万篇类似的文章。我是这个网站的付费会员，我完全认为这项投资是值得的。 [**点击此处加入**](https://go.oliverspryn.com/medium-membership) ，你将以你的一部分会员身份支持我的工作。

本文最初发表于[https://oliverspryn.com/](https://go.oliverspryn.com/extend-the-android-jetpack-navigation-component-telephone-and-web-urls)。 [**加入我的邮件列表。**](https://go.oliverspryn.com/medium-subscribe)