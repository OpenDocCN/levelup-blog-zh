<html>
<head>
<title>Handling multiple environments in React with Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Docker处理多种环境</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/handling-multiple-environments-in-react-with-docker-543762989783?source=collection_archive---------0-----------------------#2019-03-24">https://levelup.gitconnected.com/handling-multiple-environments-in-react-with-docker-543762989783?source=collection_archive---------0-----------------------#2019-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="04a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文讨论了使用Docker (Bonus:和Kubernetes)在React应用程序中处理不同环境的四种方式(比如用于开发、阶段和生产的API端点)。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/8d94ac3dbfe3cef048817d790a831a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wyxuq21keffc5b0d_lMkUw.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图片由<a class="ae le" href="https://unsplash.com/photos/ZMraoOybTLQ?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Artem Sapegin </a>在<a class="ae le" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="ac8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我是一个热情的react开发人员和devops爱好者。我们公司的许多团队将React与Docker和Docker Compose结合用于本地开发，将Kubernetes用于部署应用程序。</p><p id="72cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在大多数项目中，我们有几个环境(生产、登台和本地开发)，在一些项目中，甚至每个特性或分支一个环境。许多React开发人员在某种程度上面临着如何管理这些环境并使他们的React应用程序指向正确的API端点的挑战。</p><p id="b5b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">来自后端开发的我想:嗯，这很容易，我使用环境变量，这总是很顺利…不幸的是，它并不那么容易。在这篇文章中，我将向你展示我在试验和与其他开发者交流时遇到的四个解决方案。但是首先我要谈一点关于…</p><h1 id="246b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">背景React中的环境变量有什么问题？</h1><p id="d46d" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">环境变量显然是在应用程序的环境中定义的变量，并且可以用于相应地配置应用程序，例如，将前端指向正确的API端点。</p><p id="090b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于React应用程序(或任何JavaScript应用程序)，环境是…用户的浏览器。不幸的是，我们不能要求每个用户在他的本地机器上设置一些环境变量，以便我们的网站工作；)因此，webpack为我们提供了一个方便的特性，可以使用<a class="ae le" href="https://webpack.js.org/plugins/define-plugin/" rel="noopener ugc nofollow" target="_blank"> DefinePlugin </a>来设置它们(如果您使用create-react-app，那么您的webpack配置默认包含这个特性)。Create React App通过在变量前添加<code class="fe mi mj mk ml b">REACT_APP_</code>来识别我们想要传递给浏览器的变量。</p><p id="5a6f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们运行<code class="fe mi mj mk ml b">npm run build</code>时，webpack将此时的环境变量<strong class="js iu">硬编码到JavaScript代码包中。这也意味着您在</strong>命令<code class="fe mi mj mk ml b">npm run build</code>之后设置的任何环境变量都不会有任何影响，因为旧的已经被硬编码，新的不会被解释。这要求我们必须意识到在哪个点运行<code class="fe mi mj mk ml b">npm run build</code>，以及在哪个上下文中定义环境变量。我尝试了以下选项:</p><h1 id="2458" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">选项1:在服务器启动时运行npm运行构建</h1><p id="5e3f" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在该选项中，我们存储了一些默认设置(例如在<code class="fe mi mj mk ml b">src/config.js)</code>中),并可选地用环境变量覆盖它们:</p><pre class="kp kq kr ks gt mm ml mn mo aw mp bi"><span id="1e69" class="mq lg it ml b gy mr ms l mt mu"><strong class="ml iu">const </strong>defaultSettings = {<br/>  REACT_APP_API_URL: '<em class="mv">http://localhost:3001'</em>,<br/>  REACT_APP_<em class="mv">GA_PROPERTY: 'track me',</em><br/>};</span><span id="ca94" class="mq lg it ml b gy mw ms l mt mu"><strong class="ml iu">const</strong> settings = {defaultSettings, ...process.env};</span><span id="0704" class="mq lg it ml b gy mw ms l mt mu"><strong class="ml iu">export default </strong>settings;</span></pre><p id="9e5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重要提示:你必须给你的变量加上前缀<code class="fe mi mj mk ml b">REACT_APP</code>，否则Webpack会忽略它们。</p><p id="f329" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们在启动web服务器之前运行<code class="fe mi mj mk ml b">npm run build</code>。我们的Docker命令可能如下所示:</p><p id="e086" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mi mj mk ml b">docker run my-image sh -c "npm run build &amp;&amp; serve build"</code></p><p id="247b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该解决方案的优势:</p><ul class=""><li id="b451" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated">它简单而直观:你可以以任何你想要的方式设置你的环境变量，例如，将它们传递给Docker ( <code class="fe mi mj mk ml b">docker run -e REACT_APP_API_URL=http://localhost:3001 my-image sh -c "npm run build &amp;&amp; serve build"</code>)或者在Kubernetes中将它们设置为环境变量。</li></ul><p id="6b71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">缺点:</p><ul class=""><li id="26b7" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated">缩放时的持续时间:如果您启动同一个映像的多个容器，您将多次运行(非常昂贵和冗长的)构建过程，即使所有容器都使用完全相同的代码。</li><li id="436e" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">缩放时的会话处理:运行<code class="fe mi mj mk ml b">npm run build</code>时，webpack会在生成的文件名中附加一个哈希(例如<code class="fe mi mj mk ml b">main1234.js</code>)，帮助浏览器正确刷新缓存。如果您用不同的代码启动容器，那么即使代码的其余部分是相同的，它也可能包含不同的散列。如果您的负载平衡器引导流量循环，您的<code class="fe mi mj mk ml b">index.html</code>可能会指向<code class="fe mi mj mk ml b">main.js</code>，它不在这个容器中，而是在另一个容器中。提示:启用<a class="ae le" href="https://kubernetes.github.io/ingress-nginx/examples/affinity/cookie/" rel="noopener ugc nofollow" target="_blank">会话粘性</a>来解决这个问题。</li><li id="7423" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">阻塞的资源:<code class="fe mi mj mk ml b">npm run build</code>命令在CPU和内存方面非常消耗资源。尽管提供现成的html和js文件非常便宜。如果在运行<code class="fe mi mj mk ml b">npm run build</code>时使用小实例，它们可能没有足够的资源而退出，即使它们足以提供内容。在Kubernetes中，您的容器可能需要很高的资源限制并永久阻塞资源，这实际上只在启动容器的前几分钟需要。</li></ul><p id="6443" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好吧，这种解决方案很简单，但是在扩展或工作资源效率方面有明显的缺点。显然，对相同的代码只运行一次<code class="fe mi mj mk ml b">npm run build</code>会很好…</p><h1 id="6c91" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">选项2:当Docker构建运行时构建JS</h1><p id="52e1" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">好的，所以我们在docker文件中包含了<code class="fe mi mj mk ml b">npm run build</code>,它将只对每个图像运行一次，而与我从它开始运行多少个容器无关，对吗？对！但是请记住:webpack将此时的环境变量<strong class="js iu">硬编码到JavaScript代码包中。你的图像将永远指向此刻所指向的API。这意味着您不能在不同的环境中重用相同的映像，即使它实际上包含相同的代码。</strong></p><p id="6565" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该解决方案的优势:</p><ul class=""><li id="927f" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated">缩放时没有问题:你的容器将有相同的<code class="fe mi mj mk ml b">mainX.js</code>文件，你只需要在构建映像时等待一次漫长的构建过程。</li><li id="1b27" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">资源优化:您可以在低资源限制的情况下运行现成的映像，并且只确保在您的<code class="fe mi mj mk ml b">docker build</code>运行时有足够的资源(例如，在您的CI管道中)。</li></ul><p id="16e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">缺点:</p><ul class=""><li id="288d" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated">您不能在不同的环境中使用相同的映像，即使它们包含完全相同的代码。</li><li id="877b" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">管道中的多个设置:如果您以自动化的方式(CI管道)创建Docker映像，那么您需要使用不同的环境变量来运行构建阶段，以便为每个环境获得不同的映像。如果环境的数量非常大(例如，当每个特性或分支运行一个Kubernetes名称空间时)，这可能会非常不方便。</li></ul><p id="8ae4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好的，所以理想情况下，我们的解决方案将独立于环境构建相同的Docker映像，但仍然将<code class="fe mi mj mk ml b">npm run build</code>作为<code class="fe mi mj mk ml b">docker build</code>阶段的一部分运行。这让我们想到:</p><h1 id="0d9e" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">选项3:使用相对API URL</h1><p id="7e88" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">如果我们的API-url是相对的(例如<code class="fe mi mj mk ml b">/api</code>)，我们的解决方案将满足这一要求。例如，您可以通过以下方式之一完成此操作:</p><ol class=""><li id="0997" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nl nd ne nf bi translated">让Kubernetes负载均衡器根据路径将流量导向前端或后端容器，这对于使用<a class="ae le" href="https://kubernetes.io/docs/concepts/services-networking/ingress/#the-ingress-resource" rel="noopener ugc nofollow" target="_blank">Ingres</a>来说非常容易。</li><li id="61a1" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nl nd ne nf bi translated">只有一个包含前端和后端的Docker映像，并在内部进行路由。我不会进一步考虑这个解决方案，因为我想保持一种微服务方法，并且在前端和后端使用完全不同的技术。</li></ol><p id="f636" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用Kubernetes负载平衡的优势:</p><ul class=""><li id="708c" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated">它简单、直观，开箱即用。听起来很完美，但是…</li></ul><p id="a158" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">缺点:</p><ul class=""><li id="6d6e" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated">除非您想花时间在本地运行类似的负载平衡(例如，通过Minicube或nginx)，否则您不能将相同的设置用于本地开发。但是这将意味着把只需要本地开发的功能放到您的项目中。</li><li id="a9b5" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">这个解决方案只适用于API URL。如果您有其他特定于环境的设置(例如，Google Analytics Id，一些错误跟踪工具，如Sentry)，这种方法不能为这些提供解决方案。</li></ul><p id="cd06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，理想情况下，我们的解决方案将构建相同的Docker映像，将<code class="fe mi mj mk ml b">npm run build</code>作为<code class="fe mi mj mk ml b">docker build</code>阶段的一部分运行，并使用非URL的设置。我们开始吧:</p><h1 id="aee9" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">选项4:使用单独的配置文件</h1><p id="ae52" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在这个过程中，我们根本不使用环境变量，而是将配置从webpack构建的资源中移出。实现这一点的一种方法是提供一个单独的文件，在React启动之前加载该文件。您可以在文件中指定您的设置(例如<code class="fe mi mj mk ml b">src/public/config.js</code>):</p><pre class="kp kq kr ks gt mm ml mn mo aw mp bi"><span id="ebdb" class="mq lg it ml b gy mr ms l mt mu"><em class="mv">window.env.API_URL=http://my-server.com/api/v1/<br/>window.env.GA_PROPERTY=TRACK_ME</em></span></pre><p id="4fd4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，在React加载之前，您将该文件加载到您的<code class="fe mi mj mk ml b">&lt;HEAD&gt;</code>中的<code class="fe mi mj mk ml b">public/index.html</code>中:</p><pre class="kp kq kr ks gt mm ml mn mo aw mp bi"><span id="3fb0" class="mq lg it ml b gy mr ms l mt mu">&lt;head&gt;<br/>  &lt;title&gt;I like this&lt;/title&gt;<br/>  &lt;script src="%PUBLIC_URL%/config.js"&gt;&lt;/script&gt;</span></pre><p id="f2d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您可以在React代码中直接访问这些设置。如果你不喜欢一直在React中直接访问<code class="fe mi mj mk ml b">window</code>(像我一样)，你可以在<code class="fe mi mj mk ml b">src/config.js</code>这样的中央位置将设置“翻译”成可导入的常量:</p><pre class="kp kq kr ks gt mm ml mn mo aw mp bi"><span id="6b26" class="mq lg it ml b gy mr ms l mt mu"><strong class="ml iu">const </strong>settings = {<br/>  API_URL: <em class="mv">window.env.API_URL</em>,<br/>  <em class="mv">GA_PROPERTY: window.env.GA_PROPERTY,</em><br/>};<br/><br/><strong class="ml iu">export default </strong>settings;</span></pre><p id="6eab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我通常将本地开发所需的设置放在一个默认文件<code class="fe mi mj mk ml b">src/public/config</code>中。在不同的环境中，我将包含环境设置的文件版本挂载到容器中。如果您使用plain Docker，它可能看起来像这样:</p><pre class="kp kq kr ks gt mm ml mn mo aw mp bi"><span id="e601" class="mq lg it ml b gy mr ms l mt mu">docker run -v %{PWD}/config-prod.js:/app/build/config.js my-image serve build</span></pre><p id="07b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您使用Kubernetes，我建议将文件的内容放在一个ConfigMap中并挂载它。</p><p id="9d1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该解决方案的优势:</p><ul class=""><li id="fbbe" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated">您只需要运行<code class="fe mi mj mk ml b">npm run build</code>一次，就可以在所有环境中使用相同的映像。</li><li id="0048" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">您可以用这种方式处理所有设置，而不仅仅是API URL。</li></ul><p id="1258" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">缺点:</p><ul class=""><li id="0555" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated">需要再加载一个外部文件(虽然我不认为这对站点加载时间有明显的影响)。</li><li id="8203" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">不使用环境变量，而是使用一个挂载的配置文件，这可能看起来不熟悉(尽管在Kubernetes中这很常见)。</li></ul><h1 id="4637" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论——我应该使用哪个选项？</h1><p id="ae22" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">到目前为止，我尝试过的所有上述选项都有优点和缺点。目前在我的项目中我更喜欢选项4，因为在Kubernetes的一个卷中挂载一个ConfigMap对我来说没问题，并且额外加载文件的成本相当低。然而，我不认为这是完美的，我很好奇你是如何处理的。您在项目中使用哪种解决方案？</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><figure class="kp kq kr ks gt kt gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi nt"><img src="../Images/ff5028ba5a0041d2d76d2a155f00f05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaoZbi7tTKJ5vL7i2OAYMQ.png"/></div></a></figure><div class="nu nv gp gr nw nx"><a href="https://gitconnected.com/learn/webpack" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">学习Webpack -最佳Webpack教程(2019) | gitconnected</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">8大Webpack教程-免费学习Webpack。课程由开发人员提交并投票，使您能够…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">gitconnected.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ky nx"/></div></div></a></div></div></div>    
</body>
</html>