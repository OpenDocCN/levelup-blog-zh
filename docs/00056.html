<html>
<head>
<title>Enhancing your React + GraphQL app with Redux and Redux-Thunk</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Redux和Redux-Thunk增强您的React + GraphQL应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/enhancing-your-react-graphql-app-with-redux-and-redux-thunk-90c556aff1c5?source=collection_archive---------2-----------------------#2017-12-21">https://levelup.gitconnected.com/enhancing-your-react-graphql-app-with-redux-and-redux-thunk-90c556aff1c5?source=collection_archive---------2-----------------------#2017-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4430" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">继续React + GraphQL全栈教程，应用Redux方法和中间件</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/b1bc7557288906bbde0f47b5a9168ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DQQF56-cFjBZEZrdw01zyQ.jpeg"/></div></div></figure><h1 id="7720" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">回到过去</h1><p id="0064" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在我的<a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/using-graphql-api-with-node-js-and-react-forms-8b13f4b26361">之前的故事</a>中，我们用React JS单页应用程序(SPA)创建了一个GraphQL API作为前端。在那篇教程中，我们避免了现实世界应用程序的一些复杂性，以使事情尽可能简单。在该教程中，每次页面加载时，用户搜索表单都是空白的。为了解决这个问题，我们将使用临时存储来存储搜索参数。</p><p id="6c2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还将为后面的故事保存用户验证。在这个故事中不考虑它，因为这个主题值得一个完全独立的文章。</p><p id="7f2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们在上一篇教程中使用了<a class="ae ma" href="https://github.com/KilroggD/GraphQL-react/tree/master/client/src/containers" rel="noopener ugc nofollow" target="_blank">容器</a>方法，其中一些组件是管理自身状态的容器，并且还执行所有副作用，比如AJAX API调用。这种方法适用于相对较小的应用程序，但是当应用程序增长时，将状态和动作一起保存在组件中就变得不那么方便了。</p><p id="fed2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">找出状态的哪个片段和哪个动作位于哪个组件中并不总是一个简单的问题。此外，随着时间的推移，包含组件代码的JavaScript文件变得越来越大，可读性越来越差。为了解决这个问题，我们需要从容器中提取状态，并使全局应用程序状态成为“真实的单一来源”基于状态的操作动作，以及所有副作用，如API调用或存储使用，也应该从组件代码中抽象出来。</p><p id="cf69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解决这个问题，我建议使用流行的、众所周知的状态管理方法和名为<a class="ae ma" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>的库。您可以在这个新的库中找到、克隆和启动工作代码，这个库是为后端带有GraphQL的Redux-enhanced应用程序创建的。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="48e9" class="kx ky iq bd kz la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu bi translated">为什么是Redux？</h1><p id="8c90" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">有许多用于数据流和状态管理的工具——那么为什么是Redux呢？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mn"><img src="../Images/3c22603a543293e24ed755b5ba14c2ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q6wdZadbo9G5Fqq-."/></div></div></figure><ul class=""><li id="4049" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">著名的JS应用程序状态管理容器，有一个大的社区和积极的支持。</li><li id="dfc9" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">非常适合React JS应用程序。</li><li id="c9ce" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">允许您拥有一个全局状态存储作为“真实的单一来源”</li><li id="6d1b" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">保持状态树独立于UI和表示组件。</li><li id="d693" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">状态的某些部分可以映射到应用程序的特定部分。</li><li id="de9b" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">提供处理动作和副作用(API调用等)的灵活性。).</li></ul><p id="0d88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面最后一点值得特别注意。根据<a class="ae ma" href="https://redux.js.org/docs/introduction/CoreConcepts.html" rel="noopener ugc nofollow" target="_blank"> Redux concepts </a>的说法，reducer是一个<a class="ae ma" href="https://en.wikipedia.org/wiki/Pure_function" rel="noopener ugc nofollow" target="_blank">纯函数</a>，它管理你的app状态的一个片段(接受一个初始状态和动作作为参数，并返回一个新状态)。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="a693" class="nh ky iq nd b gy ni nj l nk nl">const formReducer = (state = initialState, action) =&gt; {<br/>    switch (action.type) {<br/>        case 'FORM_LOAD':<br/>            return {<br/>                ...state,<br/>                data: action.data,<br/>            }<br/>        default:<br/>            return state<br/>    }<br/>}</span></pre><p id="7f45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，不应该在reducers中使用诸如API调用或存储操作之类的副作用。但是如果我们需要它们，该怎么办呢？比如异步加载用户/待办事项列表？为了这个目的，<a class="ae ma" href="https://redux.js.org/docs/advanced/Middleware.html" rel="noopener ugc nofollow" target="_blank">中间件</a> connect存在了。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="c11e" class="kx ky iq bd kz la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu bi translated">中间件和异步操作</h1><p id="eb6c" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">中间件对于异步操作和API调用非常有用。您可以使用中间件来处理从AJAX请求开始到检索数据的所有管道。让我们看一个小例子——我们需要请求一个后端API为我们提供一个用户列表，但是当API调用正在进行时，我们希望将我们的应用程序置于“正在加载”状态，如果我们在调度数据时出现任何错误，则置于“错误”状态。</p><p id="3456" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种模式被称为中间件。它接受你的参数并返回一个新的函数，这个函数实现所有需要的副作用并分派你的实际动作，随后影响你的reducers和你的应用程序的状态。我们还能够使用async/await模式来处理承诺和AJAX调用。</p><p id="f35c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用redux-thunk中间件，它将看起来像。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="ead7" class="nh ky iq nd b gy ni nj l nk nl">const getUsers = (params) =&gt; async dispatch =&gt; {<br/>    try {<br/>        dispatch(requestUsers())<br/>        const data = await ApiService.getUsers(params)<br/>        dispatch(receiveUsers(data))<br/>    } catch(e) {<br/>        dispatch(failureUsers())<br/>    }<br/>}</span></pre><p id="050a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建异步操作后，我们将通过调度requestUsers()操作将容器置于加载状态。它将等待从服务器检索数据，然后，要么通过调用receiveUsers()操作用用户列表更新我们的状态，要么通过调度failureUsers()操作将其置于错误状态。</p><p id="d3a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个中间件有更多的“超能力”，比如通过getState函数访问应用程序的当前状态。这个故事后面会讲。</p><p id="6f7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有的动作都是触发reducers的简单函数。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="65a3" class="nh ky iq nd b gy ni nj l nk nl">const requestUsers = () =&gt; ({<br/>    type: 'USERS_REQUEST'<br/>})</span><span id="15fa" class="nh ky iq nd b gy nm nj l nk nl">const receiveUsers = (data) =&gt; ({<br/>    type: 'USERS_RECEIVE',<br/>    data<br/>})</span><span id="d0ca" class="nh ky iq nd b gy nm nj l nk nl">const failureUsers = () =&gt; ({<br/>    type: 'USERS_FAILURE',<br/>})<br/></span></pre></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="7872" class="kx ky iq bd kz la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu bi translated">重新思考容器</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mn"><img src="../Images/45b0e6f4d9adb0d725346f908f210a50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jJ4WpYpe0pF9ifDx."/></div></div></figure><p id="5e7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们在前面的故事中看到的，容器是“智能”组件，它处理自己的状态并触发动作和副作用，如API调用，存储状态中接收的数据并将其作为道具传递给子组件。</p><p id="be9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们重构的应用程序，我们需要以一种冗余的方式重新思考容器。Redux中的容器是连接到全局状态存储的“无状态”组件。Redux让我们能够映射我们需要的状态片段和我们想要传递给容器道具的动作。代替<em class="nn">状态</em>，容器的<em class="nn">属性</em>被更新。Redux的核心原则之一是通过存储和reducers处理整个应用程序状态。</p><p id="f973" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的例子展示了我们的<a class="ae ma" href="https://github.com/KilroggD/GraphQL-react-redux/blob/master/client/src/containers/TodoListContainer.js" rel="noopener ugc nofollow" target="_blank"> TodosListContainer </a>。我们通过reducers管理状态，并通过mapStateToProps将特定的状态片段映射到组件的Props，通过mapDispatchToProps函数将特定的动作映射到props。我们通过从“react-redux”模块导入的connect()函数将这些函数应用于我们的容器。</p><p id="8007" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在组件挂载上调度loadTodos来检索Todos列表。我们还有特定的条件来处理来自与“Todo”部分相关的状态位的加载和错误标志。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="03ca" class="nh ky iq nd b gy ni nj l nk nl">import React from 'react'<br/>import TodoList from '../components/TodoList'<br/>import { Link } from 'react-router-dom'<br/>import { connect } from 'react-redux'<br/>import { todosAction } from '../actions/todosActions'</span><span id="b867" class="nh ky iq nd b gy nm nj l nk nl">class TodoListContainer extends React.Component {</span><span id="e1aa" class="nh ky iq nd b gy nm nj l nk nl">    componentDidMount() {<br/>        const userId = parseInt(this.props.match.params.userId, 10);<br/>        //load todos here<br/>        this.props.loadTodos(userId)<br/>    }</span><span id="caad" class="nh ky iq nd b gy nm nj l nk nl">    render() {</span><span id="89ef" class="nh ky iq nd b gy nm nj l nk nl">//add loading and failure state<br/>        if (this.props.isLoading) {<br/>            return &lt;span&gt;Loading...&lt;/span&gt;<br/>        }</span><span id="8bde" class="nh ky iq nd b gy nm nj l nk nl">        if (this.props.isFailure) {<br/>            return &lt;span&gt;Error loading todos!&lt;/span&gt;<br/>        }</span><span id="5149" class="nh ky iq nd b gy nm nj l nk nl">        return (<br/>            &lt;div className="todo"&gt;<br/>                &lt;TodoList todos={this.props.todos} /&gt;<br/>                &lt;Link className="todo__linkback" to='/'&gt;<br/>                     Back to Users search<br/>                &lt;/Link&gt;<br/>            &lt;/div&gt;<br/>        );<br/>    }</span><span id="bbd1" class="nh ky iq nd b gy nm nj l nk nl">}</span><span id="c31e" class="nh ky iq nd b gy nm nj l nk nl">const mapStateToProps = ({ todos }) =&gt; {<br/>    return {<br/>        ...todos<br/>    }<br/>}</span><span id="d034" class="nh ky iq nd b gy nm nj l nk nl">const mapDispatchToProps = (dispatch) =&gt; {<br/>    return {<br/>        loadTodos: (userId) =&gt; {<br/>            dispatch(todosAction({ userId }))<br/>        }<br/>    }<br/>}</span><span id="1f15" class="nh ky iq nd b gy nm nj l nk nl">export default connect(<br/>    mapStateToProps, mapDispatchToProps<br/>)(TodoListContainer);</span></pre></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="2e63" class="kx ky iq bd kz la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu bi translated">冗余路由器</h1><p id="87a1" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated"><a class="ae ma" href="https://github.com/reactjs/react-router-redux" rel="noopener ugc nofollow" target="_blank"> Redux router </a>或react-router-redux是一个增强的React路由器，它允许您将React路由器与您的Redux商店协调，并将与路由相关的一段状态与您的商店同步。它还为您提供了一个非常有用的push()函数，允许您以函数的方式在Redux操作中执行重定向。</p><p id="4ef8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本教程中，我们将不会使用Redux路由器的主要功能，但它有利于我们应用程序的未来改进(即认证)。如果你不想安装和使用它，在本教程中使用通用的React-router也可以。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="4acb" class="kx ky iq bd kz la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu bi translated">将存储用于搜索表单</h1><p id="f27c" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">为了保持不同路径之间的表单数据同步，我们需要一些存储空间，既可以现在存放表单数据，也可以以后从中检索。对于本教程，我们将选择<a class="ae ma" href="https://www.w3schools.com/html/html5_webstorage.asp" rel="noopener ugc nofollow" target="_blank">本地存储</a>。这有几个原因:</p><ul class=""><li id="c763" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">本地存储数据没有生存期，它会一直存在，直到我们删除它。</li><li id="cf13" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">本地存储不需要任何额外的库或工具——一切都可以通过HTML5 localStorage API来完成。</li></ul><p id="7de6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了从实际的存储引擎中抽象出来——以便我们可以切换到会话存储或cookies，并遵循更好的常规做法——我们创建了一个StorageService来处理本地存储数据。</p><p id="3209" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该类包含对实际存储引擎的引用以及获取/设置/删除值的有用方法。我们将在redux中间件中调用它来填充搜索表单数据。</p><p id="ae24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在成功的搜索请求之后用数据填充这个存储——这将在本教程的后面描述。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="813a" class="nh ky iq nd b gy ni nj l nk nl">class StorageService {<br/>    constructor() {<br/>        this.storage = window.localStorage<br/>        this.form_key = 'search_form'<br/>    }</span><span id="08fe" class="nh ky iq nd b gy nm nj l nk nl">getSearchData() {<br/>        let data = this.storage.getItem(this.form_key) || false;<br/>        if (data) {<br/>            return JSON.parse(data)<br/>        }<br/>    }</span><span id="7510" class="nh ky iq nd b gy nm nj l nk nl">setSearchData(data) {<br/>        if (data) {<br/>            this.storage.setItem(<br/>                this.form_key, JSON.stringify(data)<br/>            );<br/>        }<br/>    }</span><span id="6373" class="nh ky iq nd b gy nm nj l nk nl">removeSearchData() {<br/>        this.storage.removeItem(this.form_key);<br/>    }</span><span id="2497" class="nh ky iq nd b gy nm nj l nk nl">}</span><span id="0260" class="nh ky iq nd b gy nm nj l nk nl">export default new StorageService()</span></pre></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="31d8" class="kx ky iq bd kz la mi lc ld le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu bi translated">用redux处理表单</h1><p id="7d46" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在之前的教程中，我们控制了<a class="ae ma" href="https://github.com/KilroggD/GraphQL-react/blob/master/client/src/forms/UserForm.js" rel="noopener ugc nofollow" target="_blank"> UserForm </a>组件，它有自己的状态，所有的输入变化都映射到其中。为了让这个表单以Redux友好的方式工作，我们需要为它创建一个reducer和actions。还有令人敬畏的<a class="ae ma" href="https://redux-form.com" rel="noopener ugc nofollow" target="_blank"> Redux-Form </a>库，它给你很多“开箱即用”的功能，但这可能是另一个故事的一部分。:)</p><p id="fd2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">先说行动。我们定义了从localStorage加载表单数据的操作，如果其中一个输入发生了变化，就改变表单数据，并清除表单数据，因为我们将从这里开始存储成功的搜索请求，所以需要一个清除方法。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="20a6" class="nh ky iq nd b gy ni nj l nk nl">import StorageService from '../StorageService'</span><span id="1e7a" class="nh ky iq nd b gy nm nj l nk nl">const loadForm = (data) =&gt; ({<br/>    type: 'FORM_LOAD',<br/>    data,<br/>})</span><span id="7b6b" class="nh ky iq nd b gy nm nj l nk nl">const clearForm = () =&gt; ({<br/>    type: 'FORM_CLEAR',<br/>})</span><span id="f61f" class="nh ky iq nd b gy nm nj l nk nl">export const loadFormAction = () =&gt; (dispatch) =&gt; {<br/>    //load form data from local storage<br/>    const data = StorageService.getSearchData() || {}<br/>    //dispatch an action<br/>    dispatch(loadForm(data))<br/>}</span><span id="3e88" class="nh ky iq nd b gy nm nj l nk nl">export const clearFormAction = () =&gt; (dispatch) =&gt; {<br/>    StorageService.removeSearchData()<br/>    dispatch(clearForm())<br/>}</span></pre><p id="9019" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">表单的缩减器看起来非常简单——只需要loadForm从用户输入或本地存储中加载表单数据，clearForm清除数据。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="130a" class="nh ky iq nd b gy ni nj l nk nl">const formReducer = (state = {}, action) =&gt; {<br/>    switch (action.type) {<br/>        case 'FORM_LOAD':<br/>            return {<br/>                ...state,<br/>                ...action.data,<br/>            }<br/>        case 'FORM_CLEAR':<br/>            return {}<br/>        default:<br/>            return state<br/>    }<br/>}</span><span id="9587" class="nh ky iq nd b gy nm nj l nk nl">export default formReducer</span></pre><p id="e8f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以看到<a class="ae ma" href="https://github.com/KilroggD/GraphQL-react-redux/blob/master/client/src/forms/UserForm.js" rel="noopener ugc nofollow" target="_blank">用户表单</a>组件是如何重写的，以及处理程序和道具是如何从<a class="ae ma" href="https://github.com/KilroggD/GraphQL-react-redux/blob/master/client/src/containers/UserListContainer.js" rel="noopener ugc nofollow" target="_blank">用户容器</a>组件传递到那里的。</p><h1 id="53c8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">总结—在我们的应用中重复主要概念</h1><p id="c3ab" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">要安装所有讨论过的依赖项，只需运行:</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="27de" class="nh ky iq nd b gy ni nj l nk nl">npm i -s redux react-redux redux-thunk<br/>npm i -s react-router-redux@next //if you want to use redux-router</span></pre><p id="f2d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者使用可以使用<a class="ae ma" href="https://github.com/KilroggD/GraphQL-react-redux" rel="noopener ugc nofollow" target="_blank">资源库</a>中的package.json文件。</p><p id="56d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使用全局状态的所有reducers，我们将使用Redux中的combineReducers函数。它允许我们将每个reducer的状态片段与适当的别名结合起来。参见/reducers中的<a class="ae ma" href="https://github.com/KilroggD/GraphQL-react-redux/blob/master/client/src/reducers/index.js" rel="noopener ugc nofollow" target="_blank"> index.js </a>文件。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="a2de" class="nh ky iq nd b gy ni nj l nk nl">const reducer = combineReducers(<br/>    {<br/>        form: formReducer,<br/>        todos: todosReducer,<br/>        users: usersReducer,<br/>        routerReducer<br/>    }<br/>)</span><span id="57fb" class="nh ky iq nd b gy nm nj l nk nl">export default reducer</span></pre><p id="fcae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在此之后，我们的状态对象将看起来像:</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="4884" class="nh ky iq nd b gy ni nj l nk nl">state = {<br/>    form: {}, //form reducer part<br/>    users: {}, //users reducer part<br/>    todos: {}, //todos reducer part<br/>    routerReducer: {}, //react-router-redux part<br/>}</span></pre><p id="cc60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们转到主<a class="ae ma" href="https://github.com/KilroggD/GraphQL-react-redux/blob/master/client/src/index.js" rel="noopener ugc nofollow" target="_blank"> index.js </a>文件:</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="6e3e" class="nh ky iq nd b gy ni nj l nk nl">const history = createHistory()<br/>const middleware = [thunk, routerMiddleware(history)]</span><span id="7a0d" class="nh ky iq nd b gy nm nj l nk nl">const store = createStore(<br/>    reducer,<br/>    applyMiddleware(...middleware)<br/>);</span><span id="e4a7" class="nh ky iq nd b gy nm nj l nk nl">ReactDOM.render(<br/>    &lt;Provider store={store}&gt;<br/>        &lt;ConnectedRouter history={history}&gt;<br/>            &lt;App /&gt;<br/>        &lt;/ConnectedRouter&gt;<br/>    &lt;/Provider&gt;,<br/>    document.getElementById('root'));<br/>registerServiceWorker();</span></pre><p id="2039" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前两行创建所有需要的中间件——thunk用于中间件，async actions和routerMiddleware用于处理历史和路由。</p><p id="8d49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们只需用前面提到的组合缩减器初始化存储，并将应用程序包装在Provider中，并将存储传递给它。</p><p id="361d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以<a class="ae ma" href="https://github.com/KilroggD/GraphQL-react-redux/blob/master/client/src/containers/UserListContainer.js" rel="noopener ugc nofollow" target="_blank"> UsersListContainer </a>为例，让我们看看Redux容器是如何工作的:</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="5fd0" class="nh ky iq nd b gy ni nj l nk nl">import React from 'react'<br/>import UserList from '../components/UserList'<br/>import UserForm from '../forms/UserForm'<br/>import { connect } from 'react-redux'<br/>import { getUsers } from '../actions/usersActions'<br/>import { loadForm, loadFormAction, clearFormAction } from '../actions/formActions'</span><span id="3fe3" class="nh ky iq nd b gy nm nj l nk nl">class UserListContainer extends React.Component {</span><span id="2289" class="nh ky iq nd b gy nm nj l nk nl">    componentDidMount() {<br/>        this.props.loadForm();<br/>        this.props.search();<br/>    }</span><span id="e196" class="nh ky iq nd b gy nm nj l nk nl">    render() {<br/>        //add loading and failure state<br/>        if (this.props.isLoading) {<br/>            return &lt;span&gt;Loading...&lt;/span&gt;<br/>        }</span><span id="7e19" class="nh ky iq nd b gy nm nj l nk nl">        if (this.props.isFailure) {<br/>            return &lt;span&gt;Error loading users!&lt;/span&gt;<br/>        }</span><span id="361b" class="nh ky iq nd b gy nm nj l nk nl">        return &lt;div className="user"&gt;<br/>            &lt;UserForm data={this.props.form}<br/>                submitHandler={this.props.search}<br/>                changeHandler={this.props.changeForm}<br/>                clearHandler={this.props.clearForm} /&gt;<br/>            {this.props.users &amp;&amp; <br/>               &lt;UserList users={this.props.users} /&gt;}<br/>          &lt;/div&gt;;<br/>    }<br/>}</span><span id="3061" class="nh ky iq nd b gy nm nj l nk nl">const mapStateToProps = ({ users, form }) =&gt; {<br/>    return {<br/>        ...users,<br/>        form,<br/>    }<br/>}</span><span id="505b" class="nh ky iq nd b gy nm nj l nk nl">const mapDispatchToProps = (dispatch) =&gt; {<br/>    return {<br/>        search: () =&gt; { dispatch(getUsers()) },<br/>        loadForm: () =&gt; { dispatch(loadFormAction()) },<br/>        changeForm: (params) =&gt; { dispatch(loadForm(params)) },<br/>        clearForm: (params) =&gt; {<br/>            dispatch(clearFormAction())<br/>            dispatch(getUsers())<br/>         },<br/>    }<br/>}</span><span id="3b8b" class="nh ky iq nd b gy nm nj l nk nl">export default connect(mapStateToProps, mapDispatchToProps)(UserListContainer);</span></pre><p id="4e3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个容器中，我们将状态的“用户”和“表单”部分映射到容器的属性。我们还通过mapDispatchToProps函数映射我们需要的所有动作。当组件挂载时，我们从存储中加载表单数据，并使用当前参数执行用户搜索。我们还将一些动作作为处理程序传递给UserForm。</p><p id="c08e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae ma" href="https://github.com/KilroggD/GraphQL-react-redux/blob/master/client/src/reducers/usersReducer.js" rel="noopener ugc nofollow" target="_blank"> Users Reducer </a>管理我们状态中与用户相关的部分，并处理请求/接收/失败动作类型:</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="1614" class="nh ky iq nd b gy ni nj l nk nl">const initialState = {<br/>    isLoading: false,<br/>    isFailure: false,<br/>    users: null,<br/>}</span><span id="37d8" class="nh ky iq nd b gy nm nj l nk nl">const usersReducer = (state = initialState, action) =&gt; {<br/>    switch (action.type) {<br/>        case 'USERS_REQUEST':<br/>            return {<br/>                ...state,<br/>                isLoading: true,<br/>                isFailure: false,<br/>            }<br/>        case 'USERS_RECEIVE':<br/>            return {<br/>                ...state,<br/>                isLoading: false,<br/>                isFailure: false,<br/>                users: action.data,<br/>            }<br/>        case 'USERS_FAILURE':<br/>            return {<br/>                ...state,<br/>                isLoading: false,<br/>                isFailure: true,<br/>            }<br/>        default:<br/>            return state<br/>    }<br/>}</span><span id="2f94" class="nh ky iq nd b gy nm nj l nk nl">export default usersReducer</span></pre><p id="d2b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae ma" href="https://github.com/KilroggD/GraphQL-react-redux/blob/master/client/src/actions/usersActions.js" rel="noopener ugc nofollow" target="_blank">用户动作</a>文件包含一个中间件函数，它调度所有这些动作，执行异步API调用，并在请求成功时存储表单数据。注意，在本教程中，我们在中间件函数中使用了getState功能。这个函数为您提供了对当前状态的访问，因此您可以获取表单数据或其他状态位，而不必将它们传递给操作。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="b2d8" class="nh ky iq nd b gy ni nj l nk nl">import ApiService from '../ApiService'<br/>import StorageService from '../StorageService'</span><span id="559a" class="nh ky iq nd b gy nm nj l nk nl">const requestUsers = () =&gt; ({<br/>    type: 'USERS_REQUEST',<br/>})</span><span id="17e1" class="nh ky iq nd b gy nm nj l nk nl">const receiveUsers = (data) =&gt; ({<br/>    type: 'USERS_RECEIVE',<br/>    data,<br/>})</span><span id="d92d" class="nh ky iq nd b gy nm nj l nk nl">const failureUsers = () =&gt; ({<br/>    type: 'USERS_FAILURE',<br/>})</span><span id="b9d6" class="nh ky iq nd b gy nm nj l nk nl">export const getUsers = (params) =&gt; async (dispatch, getState) =&gt; {<br/>    try {<br/>        dispatch(requestUsers())<br/>        const params = getState().form<br/>        const data = await ApiService.getUsers(params)<br/>        if (Object.keys(params).length &amp;&amp; data) {<br/>            //save successful request<br/>            StorageService.setSearchData(params)<br/>        }<br/>        dispatch(receiveUsers(data))<br/>    } catch (e) {<br/>        dispatch(failureUsers())<br/>    }<br/>}</span></pre><p id="d351" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果，我们现在有了SPA，状态完全由Redux管理。我们有两个“智能”容器(TodosList和UsersList ),我们没有改变表示组件(除了在UserForm组件中进行了一点重构，这不仅仅是为了表示)。表单数据现在可以在路线更改之间保存:例如，我们可以搜索一个用户，查看todos，然后返回到列表，它仍然会被过滤！随意克隆回购并测试代码:)</p><p id="f49c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我接下来的故事中，我们将讨论在GraphQL和React-Redux中处理认证，以及React-Redux应用程序的单元测试。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mn"><img src="../Images/966fe76453a92e24f4f726e9cd2ece21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GeR-boZHUDYHw_Ar."/></div></div></figure></div></div>    
</body>
</html>