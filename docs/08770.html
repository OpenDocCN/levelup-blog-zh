<html>
<head>
<title>The Dependency Inversion Principle Made Simple</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">依赖性反转原理变得简单</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-dependency-inversion-principle-made-simple-70108b88dc76?source=collection_archive---------8-----------------------#2021-06-02">https://levelup.gitconnected.com/the-dependency-inversion-principle-made-simple-70108b88dc76?source=collection_archive---------8-----------------------#2021-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f40f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">或者检查是否应用了其他可靠的原则。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/80cb151f65a0d472b83c0b9a1f652cc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rQcIU3LFGGXtGD95FfN5uw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">米海三都</figcaption></figure><p id="faac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不，这并不意味着依赖关系应该倒置。原则声明，在你的低级和高级模块之间不应该有直接的联系。实际上，这个原则是五个原则中最简单的</p><p id="c4bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想想一辆车。如果方向盘直接连接到车轮上会怎么样？每次更换车轮时，都需要对方向盘进行一些调整。</p><p id="dd2e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们知道这是一个糟糕的设计。因此，我们在它们之间有一个“接口”,负责通信，这样它们就没有直接的链接。</p><p id="aef3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">罗伯特·马丁将该原则定义为:</p><ol class=""><li id="7006" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">高层模块不应该依赖低层模块。两者都应该依赖于抽象。</li><li id="6bfd" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">抽象不应该依赖于细节。细节应该依赖于抽象。</li></ol><p id="4f30" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，方向盘就像一个处理复杂逻辑的高级模块。轮子是提供实用功能的低级模块。</p><p id="3ae6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个原理听起来可能比实际更复杂。我们来看一个例子。</p><h1 id="6476" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">新是违反原则的最大标志</h1><p id="cceb" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">想象以下应用程序:</p><ul class=""><li id="7e4b" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt nf ma mb mc bi translated">我们有一个带有文本表单和添加按钮的用户界面。每当用户单击按钮时，就会触发一个事件，并执行对控制器类的调用。</li><li id="1d38" class="lu lv it la b lb md le me lh mf ll mg lp mh lt nf ma mb mc bi translated">控制器将实例化一个业务域类并验证输入。</li><li id="6cd1" class="lu lv it la b lb md le me lh mf ll mg lp mh lt nf ma mb mc bi translated">然后它将实例化一个保存文本的数据访问类。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/91c43eaefe42392b56d6824ec999936b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XPLeScyZzV42f3RVzneICg.png"/></div></div></figure><p id="7911" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种设计的问题是它会导致紧耦合。假设业务域类构造函数被更改为接受另一个参数。这会影响控制器的代码。</p><p id="e569" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">提示</strong>:使用“new”关键字通常是紧密耦合的标志。尽可能避免。</p><h1 id="6696" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">使用控制反转(IoC)</h1><p id="334b" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">我相信现在你也同意没有依赖听起来很棒。为了实现这个目标，我们需要使用控制引擎的反转。你可以找到每一种面向对象语言的IoC库。没必要自己开发一个。</p><p id="9e29" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在谷歌搜索什么是最适合<em class="nh">*插入你的编程语言* </em>的IoC容器之前，请花点时间理解容器是如何工作的。我发现理解它们的最好方法是建立一个你自己的。网上有很多培训，像这个<a class="ae ni" href="https://www.codeproject.com/Articles/347651/Define-Your-Own-IoC-Container" rel="noopener ugc nofollow" target="_blank">一个</a>。</p><p id="e35c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管您永远不会在生产代码中使用IoC，但这是一个有趣的练习，可以教会您内部的工作原理。这反过来可能有助于您将来的调试。</p><h1 id="229f" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">DI原则是一种确认</h1><p id="564a" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">对于本文，我没有提供任何代码示例。每当我应用其他四个和IoC容器时，我发现自己总是遵循这个原则。所以，长话短说，就是这样。</p><h1 id="be83" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">外卖食品</h1><ul class=""><li id="bfcb" class="lu lv it la b lb na le nb lh nj ll nk lp nl lt nf ma mb mc bi translated">该原理在高级和低级模块之间引入了一个层:接口。</li><li id="7345" class="lu lv it la b lb md le me lh mf ll mg lp mh lt nf ma mb mc bi translated">直接实例化(或使用“new”关键字)是可能违反原则的迹象</li><li id="dd6a" class="lu lv it la b lb md le me lh mf ll mg lp mh lt nf ma mb mc bi translated">依赖倒置原则与开-闭和利斯科夫替换原则密切相关。你需要确保你遵循这些原则。这是对可靠代码的确认</li></ul><p id="4f7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">坚实的原理制作简单的系列:</strong></p><ul class=""><li id="bc4e" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt nf ma mb mc bi translated"><a class="ae ni" rel="noopener ugc nofollow" target="_blank" href="/the-single-responsibility-principle-made-simple-4e1597a44d7d">单一责任原则</a> (SRP)</li><li id="5321" class="lu lv it la b lb md le me lh mf ll mg lp mh lt nf ma mb mc bi translated"><a class="ae ni" rel="noopener ugc nofollow" target="_blank" href="/the-open-closed-principle-made-simple-cc3d0ed70553">开合原理</a> (OCP)</li><li id="8182" class="lu lv it la b lb md le me lh mf ll mg lp mh lt nf ma mb mc bi translated"><a class="ae ni" rel="noopener ugc nofollow" target="_blank" href="/the-liskov-substitution-principle-made-simple-5e69165e7ab5">利斯科夫替代原理</a> (LSP)</li><li id="5723" class="lu lv it la b lb md le me lh mf ll mg lp mh lt nf ma mb mc bi translated"><a class="ae ni" rel="noopener ugc nofollow" target="_blank" href="/interface-segregation-principle-made-simple-990da495441c">接口隔离原理</a> (ISP)</li><li id="f9ad" class="lu lv it la b lb md le me lh mf ll mg lp mh lt nf ma mb mc bi translated">依赖性倒置原则</li></ul><h1 id="eec5" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">进一步阅读</h1><div class="nm nn gp gr no np"><a href="https://stackify.com/dependency-inversion-principle/" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">坚实的设计原则解释:依赖倒置原则与代码示例</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">坚实的设计原则是由罗伯特·c·马丁提出的，也是当今最著名的设计原则之一</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">stackify.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od ks np"/></div></div></a></div><div class="nm nn gp gr no np"><a href="https://www.tutorialsteacher.com/ioc/dependency-inversion-principle" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">从属倒置原则</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">在前一章中，我们学习了使用工厂模式实现IoC原则，并实现了</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">www.tutorialsteacher.com</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od ks np"/></div></div></a></div></div></div>    
</body>
</html>