# Kadane 的算法:通向动态编程的大门

> 原文：<https://levelup.gitconnected.com/kadanes-algorithm-gateway-to-dynamic-programming-26e95ec13c7f>

![](img/c266c8a7481f180cb461b0210b57cd1d.png)

图片来自 [Pixabay](https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3088958) 的 [xresch](https://pixabay.com/users/xresch-7410129/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3088958)

在学习算法的过程中，有很多针对具体案例的解决方案需要我们去学习。不是所有人都能教给我们广泛适用的经验，尽管知道这些经验还是有好处的。然而，这些问题中有几个特别有利于拓展我们的思维，并能给我们提供工具，让我们在更广泛的案例中使用。

最大子阵列问题是让我大开眼界的问题之一。使用 Kadane 算法的解决方案是对动态编程的一个很好的介绍，我认为在这个问题上多花一点时间是值得的。在研究了这个问题之后，我知道了如何寻找更有效的解决方案，而不是总是用低效的嵌套循环编写迭代解决方案。它将向您展示如何将一个具有指数时间复杂度的解决方案转化为线性时间复杂度。

例子将用 Javascript 编写。

# 问题是

[最大子数组](https://leetcode.com/problems/maximum-subarray/)问题给我们一个数字数组，并要求我们返回最长的连续子数组的和。

```
Input: [-1,5,2,-2,1,3,-4,2,-5,6]
Output: 9
```

输出应该是 9，因为值 5、2、-2、1 和 3 加在一起大于整个数组加在一起或任何其他连续组合。

如果我们试图用最直接的方式来解决这个问题，我们可以通过三重(是的，三重)嵌套的 for 循环。外部循环将遍历每个可能的起始索引，中间循环将从给定的起始点遍历每个可能的结束索引，内部循环将累加该范围内的每个值，并检查其总和是否大于当前最大值。

```
function maxSubArray(nums){
  if (nums.length < 1) return null;
  if (nums.length === 1) return nums[0]; let max = -Number.MAX_VALUE; for (let start = 0; start < nums.length; start++) {
    for (let end = start; end <= nums.length; end++) {
      let subtotal = 0; for (let i = start; i < end; i++) {
        subtotal += nums[i];
      } if (subtotal > max) max = subtotal;
    }
  } return max;
};
```

使用这种解决方案的主要问题是，它将永远需要。执行这个函数所需的时间将增加 3 的幂次。n^2 已经够糟了。n^3 是灾难性的。如果我们的函数完成的话，它不需要很长的输入数组就可以花几分钟来执行。

# 解决方案

动态编程很大程度上是关于优化的，那么暴力解决方案是次优的呢？除了当前最大值之外，它不保留任何计算信息。该函数最终会一遍又一遍地迭代相同的值，因为它不记得上次运行的结果是什么。

不过，我们不需要将每个子数组的总和存储在内存中。这对我们没什么帮助。但是，如果我们可以设计一种方法，根据以前的工作只存储我们需要的信息，我们可以将函数的重复迭代减少到零。

再次查看示例输入[-1，5，2，-2，1，3，-4，2，-5，6]，我们可以开始想象如果我们遍历数组一次，将每个值相加，并在遍历总数时替换每个值，直到并包括该索引，会发生什么。会产生这样一个数组:

```
[-1,4,6,4,5,8,4,6,1,7]
```

如果你像我一样，当我第一次尝试解决这个问题时，你可能会看到从-1 到 8 的运行，并看到一个解决方案的提示。如果将这个数组绘制成图，我们将看到最低的波谷和最高的波峰，并且能够识别波谷和波峰之间的最大差异，因为它们是按这个顺序出现的。在这个例子中，这似乎是可行的。

但是当我们遍历数组，把所有的东西加起来的时候，我们真的不需要在前面一直数-1，不是吗？-1 不会成为结果最大值的一部分。我们想要的是，当我们点击 4 并看到 4 > -1，或者更具体地说，4 + -1 是>-1 时，我们可以忽略前一个索引的总和，并从 4 开始重新计数。

这带给我们的是一个简单的比较。在每个索引处，我们希望比较该索引处的值(nums[n])，不仅要比较之前索引处的总数，还要比较当前索引处的值(nums[n] + nums [n — 1])。

```
function maxSubArray(nums) {
  for (let n = 1; n < nums.length; n++){
    nums[n] = Math.max(nums[n], nums[n] + nums[n-1])
  }
  return Math.max(...nums)
};
```

这就是全部的解决方案。

此函数将 nums 数组[-1，5，2，-2，1，3，-4，2，-5，6]转换为到该点为止最大可能总和的数组[-1，5，7，5，6，9，5，7，2，8]。剩下的就是返回数组中的最大值，9。

# 结论

看起来解决方案不应该这么简单，但这就是问题的关键和美妙之处。该解决方案专门围绕只收集我们需要知道的信息进行了优化，没有必要收集关于每个可能的子阵列的大量重复和无关的数据。对我来说，知道这样的解决方案是可能的帮助我在其他问题中寻找更线性的解决方案。这并没有使他们变得容易，但它打开了可能性。我希望它对你也一样。