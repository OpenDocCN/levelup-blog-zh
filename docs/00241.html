<html>
<head>
<title>The Complete Nuxt Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">完整的Nuxt指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-complete-nuxt-guide-940751e1a6a5?source=collection_archive---------0-----------------------#2018-10-17">https://levelup.gitconnected.com/the-complete-nuxt-guide-940751e1a6a5?source=collection_archive---------0-----------------------#2018-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8fbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看我们的视频课程:</p><div class="kl km gp gr kn ko"><a href="https://www.udemy.com/complete-nuxtjs-course/?couponCode=MEDIUM_PROMO_CNG" rel="noopener  ugc nofollow" target="_blank"><div class="kp ab fo"><div class="kq ab kr cl cj ks"><h2 class="bd ir gy z fp kt fr fs ku fu fw ip bi translated">完成Nuxt.js 2.4+课程| Udemy</h2><div class="kv l"><h3 class="bd b gy z fp kt fr fs ku fu fw dk translated">作为Vue的增强版，Nuxt有更多的功能，也更容易配置。使用Nuxt，您可以编码…</h3></div><div class="kw l"><p class="bd b dl z fp kt fr fs ku fu fw dk translated">www.udemy.com</p></div></div><div class="kx l"><div class="ky l kz la lb kx lc ld ko"/></div></div></a></div><p id="7ee1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看我们全新的完整Nuxt 2.4+指南:</p><p id="e35b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae le" href="https://medium.com/@onlykiosk/the-new-complete-nuxt-2-4-course-e30a561e6800" rel="noopener">https://medium . com/@ only kiosk/the-new-complete-nuxt-2-4-course-e30a 561 e 6800</a></p><p id="1231" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">什么是Nuxt </strong></p><p id="3399" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Vue是一个基于JavaScript的框架。我们用它来创建客户端应用程序。</p><p id="e69e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Nuxt是一个基于Vue的框架。你可以把它看成是Vue的加强版。</p><p id="0d97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它是vue、vue路由器、vuex、vue服务器渲染器和vue meta的组合。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/55625832069d4871e81c12cd76c21ad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0zC9HVE2gEULITk-xxp36Q.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">Nuxt.js是由什么组成的</figcaption></figure><p id="b408" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">手册上说Nuxt是用来创建通用应用的。通用只是客户端和服务器端的一个花哨词。在服务器端工作并不意味着Nuxt.js就是Express那样的后端框架。服务器端Nuxt实际上是一个预配置的vue服务器渲染器。它为我们做SSR。SSR的意思是服务器端渲染。</p><p id="0c58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> SSR </strong></p><p id="f513" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">SSR的意思是服务器端渲染。</p><p id="9361" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Vue应用程序通常是一个SPA单页应用程序。我们用它来和用户交流。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lu"><img src="../Images/e39b7610de0c2122e16d9cdde36d8d22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WYOpt_TlPB7UarrvYmIqxQ.png"/></div></div></figure><p id="81b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据存储在数据库中。SPA本身没有任何数据。它也不操作数据库。后端程序位于SPA和数据库之间。它接受SPA的命令，并据此采取行动。</p><p id="b0d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的Vue应用程序通过ajax与后端程序通信。换句话说，vue app使用的是异步数据。</p><p id="7450" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种设计的优点是我们可以将客户端代码与服务器端代码完全分离。程序开发和维护要简单得多。</p><p id="fbbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是缺点是搜索引擎还不能识别异步数据。搜索引擎不会等待您的SPA加载异步数据。这意味着对于搜索引擎来说，你的网站只是一个空白页面。自然，用户将无法通过搜索引擎找到你的网站。</p><p id="e901" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个缺点是，由于数据完全是由ajax程序获取的，所以在整个程序被加载和执行之前，应用程序页面将是空的。有时，这可能需要一段时间。这只是糟糕的用户体验。</p><p id="a8ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">SSR可以为我们解决这两个问题。</p><p id="8783" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Vue.js使用Vue.js服务器端渲染器处理SSR。其官方网站如下:</p><div class="kl km gp gr kn ko"><a href="https://ssr.vuejs.org/" rel="noopener  ugc nofollow" target="_blank"><div class="kp ab fo"><div class="kq ab kr cl cj ks"><h2 class="bd ir gy z fp kt fr fs ku fu fw ip bi translated">Vue SSR指南| Vue.js服务器端渲染指南</h2><div class="kv l"><h3 class="bd b gy z fp kt fr fs ku fu fw dk translated">Vue.js服务器端渲染指南</h3></div><div class="kw l"><p class="bd b dl z fp kt fr fs ku fu fw dk translated">Vue.js服务器端渲染Guidessr.vuejs.org</p></div></div></div></a></div><p id="939d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">SSR的权衡</strong></p><blockquote class="lv lw lx"><p id="821c" class="jn jo ly jp b jq jr js jt ju jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj kk ij bi translated">发展制约因素。特定于浏览器的代码只能在特定的生命周期挂钩中使用；一些外部库可能需要特殊处理才能在服务器渲染的应用程序中运行。</p><p id="20c3" class="jn jo ly jp b jq jr js jt ju jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj kk ij bi translated">更复杂的构建设置和部署需求。与可以部署在任何静态文件服务器上的完全静态的SPA不同，服务器渲染的应用程序需要一个可以运行Node.js服务器的环境。</p><p id="8c4e" class="jn jo ly jp b jq jr js jt ju jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj kk ij bi translated">更多的服务器端负载。在Node.js中呈现一个完整的应用程序显然会比只提供静态文件更消耗CPU资源，因此如果您预计流量很高，请为相应的服务器负载做好准备，并明智地采用缓存策略。</p><p id="b34b" class="jn jo ly jp b jq jr js jt ju jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj kk ij bi translated">在为你的应用程序使用SSR之前，你应该问的第一个问题是你是否真的需要它。这主要取决于内容时间对你的应用有多重要。例如，如果您正在构建一个内部仪表板，在这个仪表板中，初始加载额外的几百毫秒并不重要，那么SSR将是一个大杀器。然而，在内容获取时间非常关键的情况下，SSR可以帮助您实现最佳的初始加载性能。</p></blockquote><div class="kl km gp gr kn ko"><a href="https://ssr.vuejs.org/#why-ssr" rel="noopener  ugc nofollow" target="_blank"><div class="kp ab fo"><div class="kq ab kr cl cj ks"><h2 class="bd ir gy z fp kt fr fs ku fu fw ip bi translated">Vue SSR指南| Vue.js服务器端渲染指南</h2><div class="kv l"><h3 class="bd b gy z fp kt fr fs ku fu fw dk translated">Vue.js服务器端渲染指南</h3></div><div class="kw l"><p class="bd b dl z fp kt fr fs ku fu fw dk translated">Vue.js服务器端渲染Guidessr.vuejs.org</p></div></div></div></a></div><p id="166c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你的后端程序是用NodeJS以外的语言写的，SEO对你特别重要，那么你就没有必要学习Nuxt，因为你没有地方去应用它。</p><p id="b3d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">点击下面的链接查看我的证明:</p><div class="kl km gp gr kn ko"><a href="https://ssr.vuejs.org/guide/non-node.html" rel="noopener  ugc nofollow" target="_blank"><div class="kp ab fo"><div class="kq ab kr cl cj ks"><h2 class="bd ir gy z fp kt fr fs ku fu fw ip bi translated">Vue SSR指南|在非Node.js环境中的使用</h2><div class="kv l"><h3 class="bd b gy z fp kt fr fs ku fu fw dk translated">Vue.js服务器端渲染指南</h3></div><div class="kw l"><p class="bd b dl z fp kt fr fs ku fu fw dk translated">ssr.vuejs.org</p></div></div></div></a></div><p id="083f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Nuxt模式/生命周期</strong></p><p id="7c8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Vue是有生命周期的。</p><p id="1f11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这张图表向我们展示了当我们开始一个Vue项目时会发生什么。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mc"><img src="../Images/a09f15311841def8c09e7fceafcdd233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*byyX8EW6mIhRsCBWwByNYg.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">Vue.js生命周期</figcaption></figure><p id="3d4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为一个扩展的Vue框架，Nuxt也有生命周期。</p><p id="6713" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个图表显示了当我们启动一个Nuxt程序时和vue程序启动前发生的情况。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi md"><img src="../Images/b92003cabd771c2755d4f4250fc85e71.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*CM9tZI28r0sJjb53MtjmYw.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">Nuxt.js架构</figcaption></figure><p id="cd5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">把这两个图表放在一起，你会得到一个当你启动一个Nuxt程序时会发生什么的全貌。</p><p id="5519" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时此刻，这张图表可能包含你没听说过的概念。不要担心，你将在后面的课程中了解它们。</p><p id="93b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">设置新的Nuxt.js应用</strong></p><p id="dfc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要安装Nuxt，我们还是用vue cli。我们只需要切换到一个新的模板:nuxt dash社区斜线starter dash模板。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi me"><img src="../Images/13d688b875d01144812202b562b3dfee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d92L_PpexCV4o7hkurcrbg.png"/></div></div></figure><p id="a4de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装完成后，我们使用npm run dev打开dev服务器。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mf"><img src="../Images/a2a95a1d08d77ffb03cf65a3d9ee93cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hlb6JsxVdogujAiJ68P3NA.png"/></div></div></figure><p id="03a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在项目根文件夹中，您会看到十个子文件夹。第十个是. nuxt。它只会在我们打开dev server后出现。默认情况下，此文件夹是隐藏的。如果找不到，请检查您的计算机设置。确保隐藏的文件和文件夹设置为可见。</p><p id="9284" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，Nuxt托管在端口3000。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mg"><img src="../Images/2c6f8a382fe8a96b7997d93048daed6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JcKjbHcW0wdDLt0BZhqxFg.png"/></div></div></figure><p id="bd41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们可以重置port inn package.json。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mh"><img src="../Images/47766c0d414edbf756859565c7c03cfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KjB6I6cQFZSBOY2dG1BmdQ.png"/></div></div></figure><p id="56e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Nuxt根目录</strong></p><p id="6494" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总共，你会看到十个目录。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mi"><img src="../Images/e5a4c40044a2d3d887ee668fe888ac47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9_5559moBmWwgxl2Xv6bpA.png"/></div></div></figure><p id="0bc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">静态和资产都用于存储静态文件。图像、视频、音频等。存储在这两个目录中。至于两者之间的区别，我们以后会给你看。</p><p id="c889" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">组件目录用于存储dot vue文件。您的单列组件存储在这里。</p><p id="e184" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在您未来的开发中，您将主要创建和处理两种类型的文件:。vue和。js文件。</p><p id="725f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">插件、商店和中间件是用来存储的。js文件。</p><p id="5168" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">布局、页面和组件用于存储。vue文件。</p><p id="428c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Nuxt.config.js存储配置信息。我们以后会经常编辑这个文件。</p><p id="3ff4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">nuxt . js主页是如何创建的:</strong></p><p id="09dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是默认的Nuxt.js程序。它由starter-template创建。我们还没有对它做任何修改。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mj"><img src="../Images/006bc9f984528e5853d9c95c4a13a8d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C9F7gs_EvnG6Mh9kzZynxg.png"/></div></div></figure><p id="9d19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在pages目录中，只有一个文件:index.vue。</p><p id="612b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在组件目录中，也只有一个文件:AppLogo.vue。</p><p id="e58a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Pages/index.vue创建了我们在浏览器中看到的主页。徽标图像由components/AppLogo.vue创建。</p><p id="0322" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Pages/index.vue导入、声明和安装组件/AppLogo.vue。(如下所示)</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mk"><img src="../Images/9e225a46ae0280604fc73599f4f4ee38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GkLVzQVGgSDJRSAOt70sbw.png"/></div></div></figure><p id="179c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在页面目录中，index是一个特殊的名称。Nuxt将其视为默认选择。如果不指定文件名，Nuxt将查找并显示索引文件。这就是为什么我们可以通过localhost:8080访问pages/index vue。不需要在URL中指定索引。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ml"><img src="../Images/139cb783ffa72061d626a2e64d3a0be4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uncv0Fwpg-tbrBz-2f3XLg.png"/></div></div></figure><p id="a19c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在导入AppLogo组件时，您可能已经注意到了~字符。~和@代表项目根目录。</p><p id="b6ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">外挂</strong></p><p id="c0d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">页面目录用于存储页面文件。组件目录用于存储可重用的组件。</p><p id="5963" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么插件目录是干什么的呢？</p><p id="4b19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">存储插件配置文件。</p><p id="4d52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将以iView为例向您展示如何使用它。</p><p id="1604" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">iView是一个Vue UI库。它需要一个JS文件作为配置文件。我们应该把它的配置文件放在插件目录中。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mm"><img src="../Images/e8be31c43085ac92e0cece33aeb006b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*snw2Crlu1hNtHX2L_1faCg.png"/></div></div></figure><p id="5e5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建配置文件并将其放入插件目录只是第一步。</p><p id="d099" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们需要转到nuxt.config.js文件。</p><p id="621a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们创建一个插件属性。</p><p id="8123" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它的值是一个数组。每个数组元素都是配置文件的URL。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mn"><img src="../Images/12d4717a58672ded371ff0584b29d2cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i6JF81wnPM4frw9sjJFgoQ.png"/></div></div></figure><p id="aea5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，iView已成为一个全球性组件。这里的全局意味着整个Nuxt程序。你可以在任何你想去的地方使用它。但是有一个问题。就像我们之前说过的，pages目录中的每个dot vue文件都是一个独立的SPA。在本例中，我们在pages目录中有两个文件。这意味着我们的Nuxt计划由两个Vue SPAs组成。因此，当我们输出我们的程序时，iView将被捆绑两次。如果我们定义了很多页面，那么这种重复捆绑的问题会非常严重。为了解决这个问题，我们找到build属性并向其中添加一个新属性:vendor。vendor的值仍然是一个数组。每个数组元素都是插件名。在这里，我们将其设置为iview</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mo"><img src="../Images/23992ff1801495f3258c6bad58c63470.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iKYBAhrthX667WoQfKBdtw.png"/></div></div></figure><p id="2b10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Nuxt路线</strong></p><p id="17c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本课中，我们将了解nuxt路由器的工作原理。与vue路由器不同，您不需要为nuxt路由器创建配置文件。Nuxt将扫描页面目录并自动生成路由规则。</p><p id="aafd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">页面目录将被视为根文件夹。里面的文件可以通过localhost斜杠文件名直接访问。当nuxt扫描一个目录时，它会自动搜索索引文件。因此，我们可以通过localhost直接访问index dot vue文件。我们不需要在localhost后面添加斜杠索引。</p><p id="4b80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果我们创建另一个文件:another.vue，我们需要在URL中放入另一个文件。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mp"><img src="../Images/55063fbd3ead22ca473e860ea4231cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7rAm36zbdP0aFDw3ObCLeg.png"/></div></div></figure><p id="2c47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在pages目录中，我们创建一个子目录:user。在用户目录中，我们创建两个文件:index.vue和ID.vue。</p><p id="ca06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要访问pages/user/index.vue，我们需要的URL是:localhost:8080/user。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mq"><img src="../Images/7680eb70ae52abd5a7dcd2a17b33daed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lsH6s-BOWC_2YZmtl-QceA.png"/></div></div></figure><p id="3c05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是要访问pages/user/id.vue，我们需要的URL是:localhost:8080/user/id。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mr"><img src="../Images/819d54da0ec84e64ef8e036f21bcbc32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2RQcM3SHuDPoGV0fQmOgqQ.png"/></div></div></figure><p id="6b0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">URL可用于传递值。如果我们在URL中存储一个ID属性，我们如何访问它？</p><p id="03c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Nuxt路由器和vue路由器很像。为了访问查询值，我们使用$route点查询。</p><p id="1224" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">URL也可以通过参数传递值。</p><p id="4a3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接收参数值很简单，我们将查询转换成参数。</p><p id="57cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是挑战在于如何在URL中传递参数？</p><p id="0ffa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要将id点vue文件重命名为下划线ID点vue。下划线是一个信号，告诉Nuxt这个文件是用来处理参数的。</p><p id="a868" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果不提供任何参数值，Nuxt将显示索引文件。通常，我们使用索引文件来处理没有提供参数值的情况。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ms"><img src="../Images/5acb0757a9f7d56018d44a84bc2e63cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*edVnxFM9MqxVlXOqvUOo5w.png"/></div></div></figure><p id="9459" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">验证</strong></p><p id="b721" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有用户提交的数据都应经过验证。Nuxt为此提供了验证方法。validate方法应该安装在dot vue文件的导出对象中。你把它想象成一个钩子，就像在vue里创造的一样。在Nuxt的生命周期中，validate将在中间件之后、asyncData之前被调用。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi md"><img src="../Images/003b90a607578b5f3574ae65fb18fd34.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*JJCS-aZEdKAORSHQsrdGWQ.png"/></div></figure><p id="7e5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">validate方法应该安装在_id.vue中，validate方法的参数值是一个具有三个属性的对象:params、query和store。商店给了我们接触vuex的机会。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mt"><img src="../Images/7c7d909e8de109536178a9489e8e9678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qVYDon3tTXyF-khSxxjwKw.png"/></div></div></figure><p id="e141" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">validate方法用于验证值，而不是重置值。最后，它必须返回true或false。如果它返回-true，下划线ID文件将被正常加载。如果返回false，Nuxt将直接显示预定义的错误页面。但是地址框中的URL不会改变。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mu"><img src="../Images/9810f95bf5bda86a6bf3ae1ca282cf0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fcbgyjFBDrjmOJPjL1oAaw.png"/></div></div></figure><p id="1973" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">嵌套路线:</strong></p><p id="2aa2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在pages目录中，我们有一个子目录:user。如果我们在pages目录下创建一个user.vue文件会怎么样？</p><p id="9dfb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">会发生什么？谁会被选中？User.vue还是user/index.vue？</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/b17121050b9d79bc377aebd86ed1c50b.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*A87G-iHRqRo3wDkk0Mm-iw.png"/></div></figure><p id="708c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是结果:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mw"><img src="../Images/eba26ecae2f008832e1aba9733e21b60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7wNtAo-3Z9aIyywSbwpt5Q.png"/></div></div></figure><p id="a9f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">user.vue将覆盖user/index.vue。但这并不意味着您应该避免使用相同的文件名和目录名。相反，命名文件和目录会给我们带来非常有用的东西:嵌套路由。</p><p id="212f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在user.vue中，我们添加了一个组件:<nuxt-child/>。</p><p id="1842" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们将得到的:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mx"><img src="../Images/92d941d9f41d225f4dd89a64ee823519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0VPbWwP2JNaXheReM137Wg.png"/></div></div></figure><p id="c203" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">user/interface.vue将显示在<nuxt-child/>中。</p><p id="788f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">中间件:</strong></p><p id="c409" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这节课中，我们将向你展示如何使用中间件。</p><p id="1afc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本质上，中间件是一个预定义的功能。我们可以将它应用于特定页面或所有页面。在Nuxt生命周期中，中间件在validate方法之前被调用。因为中间件在很早的时候就被调用了，所以我们可以用它来做很多事情，比如检查登录状态、验证用户提交的数据等等。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi md"><img src="../Images/d2e81d879f8e3b712b55cc6ccb8973e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*3rLQdzzPwWzeqpx8o5ZlTA.png"/></div></figure><p id="b199" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应该在一个JS文件中定义一个中间件。中间件目录用于存储中间件文件。</p><p id="526b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何创建一个微波文件？</p><p id="9502" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们在中间件目录中创建一个JS文件。</p><p id="6e53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在JS文件中，我们<em class="ly">导出默认的</em>匿名函数。</p><p id="544f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">匿名函数将是中间件函数。</p><p id="1480" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Nuxt将把上下文分配给匿名函数作为它的参数值。</p><p id="9d08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上下文非常有用。它让中间件功能几乎可以完全访问整个程序。</p><p id="8835" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Context.params和context.query可以获取URL中传递的us值。</strong></p><p id="f9f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Context.store为我们带来VueX。</strong></p><p id="7e37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Context.error()可以帮助我们触发错误页面，并向错误页面发送值。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi my"><img src="../Images/c912cb925b8fdb80b7ecb0375298e5c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HRxCMTfLwaBY4IiMl6dxsw.png"/></div></div></figure><p id="b148" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如何使用中间件？</strong></p><p id="0d10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">中间件可以绑定到特定页面或所有页面。</p><p id="3145" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想将一个MW绑定到一个特定的页面，那么您可以向该页面添加中间件属性。中间件属性的值是一个数组。每个数组元素是一个MW名。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mz"><img src="../Images/9090ca2190eb573769345930e7afb9d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zNEFZjo0KQXWaoOAMO6xSQ.png"/></div></div></figure><p id="b25d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想将一个MW绑定到所有页面，您可以转到nuxt.config.js。</p><p id="eb2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先添加一个新属性:路由器。</p><p id="2f77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">路由器的值是一个对象文字。在它里面，你添加中间件。</p><p id="cd5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图显示了如何设置路由器和中间件属性。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi na"><img src="../Images/7f57e09bede72d6b158eeb94d16c5a16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kaobLl8tIPPU1A0bvPYrcw.png"/></div></div></figure><p id="1ae3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，MW1和MW2是绑定到所有页面全局中间件。</p><p id="3cf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">布局:定制视图</strong></p><p id="c41b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本课中，我们将向您展示如何自定义页面布局。自然，我们将在布局目录上工作。此时，layouts目录只有一个文件:default . vue。它控制每个页面文件的当前页面布局。让我们打开它。</p><p id="136b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">乍一看，这个文件没有什么不同。它看起来和其他的一样。vue文件。</p><p id="b781" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在模板中，有一个<nuxt/>。</p><p id="b5be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">。pages目录中的vue文件将显示在这里。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nb"><img src="../Images/8c1d7e2c8aa13ef557ddc2e6398d289d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g_bnR6hZugzKf5g3Vglaqg.png"/></div></div></figure><p id="6b07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们在<nuxt/>的顶部添加一个P标签，那么每个页面都会自动继承这个P标签。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nc"><img src="../Images/270a6b167cab6f369fabe8e0fc88fecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-smtdVrFYNBmZxgFR090Vg.png"/></div></div></figure><p id="b61d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以定义自己的布局模板。只要确保在模板中添加<nuxt/>即可。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nd"><img src="../Images/a929d08025aa0f13722787505a3af615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eBaQHALGEEfYIKmkCE8aaA.png"/></div></div></figure><p id="f202" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建我们自己的默认布局文件只是第一步。我们需要将它应用于页面文件。这是我们的做法。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nc"><img src="../Images/2098b4ee98959283ae3f10cf27b9681a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hjGnf0I56PV-ptwS6uhoyQ.png"/></div></div></figure><p id="ee90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">定制错误页面</strong></p><p id="3df3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在layouts目录中，我们创建一个新文件:error.vue。这就是我们如何在Nuxt中定义自己的自定义错误页面。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nb"><img src="../Images/9470b922dcab843d09524dc27eb5b7e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2jyv3CdXPvS6nsdFsQcnew.png"/></div></div></figure><p id="ef65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用context.error()触发错误页面。</p><p id="4257" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Context.error()可以将信息传递给错误页面。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ne"><img src="../Images/96cb11d11177885598cfe0a993ec4336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KrevTKmwOWB6uVIZK3go9Q.png"/></div></div></figure><p id="c2a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但问题是错误页面如何接收context.error()传递的信息？</p><p id="1b88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自定义错误页面仍然是一个Vue组件。Vue组件通过props接收外部信息。所以这是我们应该做的:我们声明error为prop in error.vue。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nf"><img src="../Images/d293b471bf710b192d3dcf531ab67fa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SZmHrnyiXYSTkP5INZScGQ.png"/></div></div></figure><p id="fc27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">context.error()的参数值将被传递给错误属性。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ne"><img src="../Images/ac1afce924dafd5659a807b90de42ed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aOnkyRQxsXxIhF5YnDvMkg.png"/></div></div></figure><p id="f5c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">处理静态文件</strong></p><p id="f5d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本课中，我们将了解静态和资产目录。这两个目录都用于存储静态文件，如图像、视频、音频、CSS文件、字体文件等。</p><p id="467c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是这两个目录之间有一些细微的差别。</p><p id="9376" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">资产文件将由url加载器处理。在nuxt程序中，应该通过完整的绝对地址来访问资产文件。从Nuxt 2.0开始，如果您在CSS中链接一个资产文件，例如，在后台URL中，您需要删除波浪号和资产之间的斜杠。URL加载器将为捆绑文件提供一个散列码，以保持其名称的唯一性。小于1kb的文件将被内联为base-64数据URL。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ng"><img src="../Images/7b180dd4b833526dfd11218c7c34db2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pC7nh2HJv2f0yRsrgS47dQ.png"/></div></div></figure><p id="8440" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">静态文件将被直接捆绑到项目根目录中。您可以使用斜杠文件名来访问它们。静态文件将被捆绑到项目根目录中。</p><p id="0824" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，如果您通过完整的URL链接一个静态文件，那么这个静态文件将被视为资产文件，这意味着这个静态文件将由URL加载器处理。</p><p id="5929" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以总是通过斜杠文件名链接一个静态文件。永远不要通过完整的URL链接任何静态文件。</p><p id="cf82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">异步数据</strong></p><p id="390b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您不想在Nuxt项目中使用VueX，那么asyncData方法就是您用来与后端程序和数据库通信的方法。在Nuxt模式中，asyncData将在validate()之后、Vue渲染之前被调用。就像validate()一样，asyncData也将接收上下文作为其参数值。背景可以打开很多门。</p><p id="c6fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">asyncData的另一个重要特性是它会被自动调用。这使得它成为从后端程序和数据库中检索初始数据的完美候选。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nh"><img src="../Images/72ced92bf65230006254c36beceba84f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mqqUOmuB1b5jkJlRYQLGhg.png"/></div></div></figure><h1 id="d211" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated">AsyncData不具备这一点，因为它在validate方法之后、Vue渲染之前被调用。</h1><p id="3c19" class="pw-post-body-paragraph jn jo iq jp b jq og js jt ju oh jw jx jy oi ka kb kc oj ke kf kg ok ki kj kk ij bi translated">这意味着在调用asyncData方法时，还没有创建vue组件。因此，asyncData中的<em class="ly">这个</em>不会为您获取组件实例。Nuxt手册也强调了这一点。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ol"><img src="../Images/2a556d708193b8c8d1504e504c689952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bfNRtIIlmMNzJAqvZVbHmw.png"/></div></div></figure><h1 id="5f66" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated">asyncData方法最重要的一点是，它返回的结果将自动与vue数据合并。</h1><p id="96dd" class="pw-post-body-paragraph jn jo iq jp b jq og js jt ju oh jw jx jy oi ka kb kc oj ke kf kg ok ki kj kk ij bi translated">这解决了<em class="ly">这个</em>不指向组件实例的问题。asyncData方法返回的属性可以直接显示在template中。</p><p id="9efe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">关于异步数据的总结:</strong></p><ol class=""><li id="04dd" class="om on iq jp b jq jr ju jv jy oo kc op kg oq kk or os ot ou bi translated">将自动调用asyncData。</li><li id="7cb8" class="om on iq jp b jq ov ju ow jy ox kc oy kg oz kk or os ot ou bi translated">asyncData在Vue渲染之前被调用，因此，它没有这个。</li><li id="6508" class="om on iq jp b jq ov ju ow jy ox kc oy kg oz kk or os ot ou bi translated">asyncData接收上下文作为其参数。Context为asyncData提供对context.params、context.query、context.store和context.error()的访问</li><li id="1edb" class="om on iq jp b jq ov ju ow jy ox kc oy kg oz kk or os ot ou bi translated">asyncData返回的结果将自动与Vue数据合并。这意味着在asyncData中定义的属性可以直接显示在模板中。这是一个很棒的功能！</li></ol><p id="5ea6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图显示了asyncData方法的实际应用。</p><p id="0e5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在asyncData中安装了axios.post方法，并使用它从后端程序和数据库中检索数据。这里注意，我们必须返回axios方法。</p><p id="d5bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们返回检索结果car_list。</p><p id="7da5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Car_list将自动与Vue数据合并。因此，我们可以直接在模板中显示car_list。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pa"><img src="../Images/736993914035c55d9a1ae065d7f14524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o4n0mE8dvUV2aXPCmsaYdQ.png"/></div></div></figure><p id="785a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果出错，我们可以使用context.error()触发错误页面，如下所示:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pb"><img src="../Images/5fafc8bb36ddd780a5a6ca966fde00cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B_W_KvobKjyL_x9qE2OmnQ.png"/></div></div></figure><p id="095f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Nuxt VueX </strong></p><p id="ad2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">VueX配置文件应存储在存储目录中。文件名应该是index dot js。</p><p id="3688" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个普通的vuex配置文件由四部分组成:导入VueX包、准备配置对象、实例化存储方法和导出存储方法。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pc"><img src="../Images/336da39a99990732124283edb6798f26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W3bW7zCgCXHNjte--wcggw.png"/></div></div></figure><p id="938e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Nuxt中使用的config文件基本上是一样的，除了一点不同:我们不直接导出store方法。我们在一个匿名函数中返回它，并导出那个函数。Vue.use()在Nuxt VueX配置文件中是可选的。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pd"><img src="../Images/287dbe0a8a5692eb891d515002ef52d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YsrgYP6dM97op4sDsBWhkA.png"/></div></div></figure><p id="4f43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> fetch() </strong></p><p id="6df6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能想知道，如果我们想把数据处理完全转移到VueX，我们如何获得初始数据？在Vue中，我们使用创建的钩子来检索初始数据。在Nuxt中，我们有两个选项:fetch方法和nuxtServerInit方法。这两个方法都将被自动调用。但是它们将在不同的时间被调用。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi md"><img src="../Images/9aabb69c2c6f0c088a7d54f969bbe1bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*-M29zNF_j61bxcDsBS5n0Q.png"/></div></figure><p id="07c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将获取方法。</p><p id="f925" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">fetch方法安装在页面文件中。就像中间件和asyncData一样，fetch方法也接收上下文作为参数值。</p><p id="e95c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Context.params和context.query使fetch方法能够访问URL中传递的数据。它们允许根据URL传递的数据进行提取。例如，我们可以在URL中传递一个ID，fetch方法可以将这个ID发送给后端程序，并相应地查询数据库。</p><p id="3b3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Context.error()使fetch方法能够在出错时触发错误页面。</p><p id="6fa6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">fetch方法从后端程序和数据库中获取数据后，如何将这些数据发送给VueX？</p><p id="7399" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Context.store.commit()允许fetch方法触发VueX突变方法，该方法可以设置VueX状态属性。</p><p id="622a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们再一次看到了语境的力量。它实际上提供了对Nuxt程序每个角落的完全访问。个人觉得比这个好用。</p><p id="d295" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图显示了fetch方法在真实程序中的样子。</p><p id="493f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它通过axios方法与后端程序通信。但是记得返回axios方法。</p><p id="8eaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它通过提交方法将检索到的数据发送到VueX状态。它可以通过context.store访问提交方法。</p><p id="2e0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果出错，它将调用context.error()方法来显示错误页面。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pe"><img src="../Images/297429b69a54bc4dc3cfbabe168f095e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I7kDWwx2gUYMPlada-DCjQ.png"/></div></div></figure><p id="4351" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> nuxtServerInit() </strong></p><p id="a044" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">fetch()不是检索初始数据的唯一方法。我们也可以使用nuxtServerInit。</p><p id="2651" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">NuxtServerInit是一个VueX操作方法。与普通的action方法不同，nuxtServerInit会被自动调用。在Nuxt生命周期中，nuxtServerInit方法将在最开始被调用。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi md"><img src="../Images/9aabb69c2c6f0c088a7d54f969bbe1bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*-M29zNF_j61bxcDsBS5n0Q.png"/></div></figure><p id="ad04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">dispatch方法调用一个普通的action方法，它有两个参数。第一个是VueX上下文，第二个是dispatch方法传递的值。</p><p id="b89b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然nuxtServerInit是由Nuxt调用的，那么Nuxt会向它传递什么类型的值呢？或者它的第二个论点是什么？</p><p id="f23e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">就像fetch和asyncData一样，nuxtServerInit也会接收上下文。</strong></p><p id="0ee4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">所以nuxtServerInit有两个上下文。第一个是VueX上下文，第二个是Nuxt上下文。</strong></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pf"><img src="../Images/faf4fa8a1889fa3466ee546f4d1b5662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W0LiZAp86ua__14kfIKSYQ.png"/></div></div></figure><p id="b30f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图显示了nuxtServerInit方法在真实程序中的样子。</p><p id="0e51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它有两个参数:vuex_context和nuxt_context。</p><p id="26f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管如此，我们还是使用axios方法从后端程序中检索数据，并且需要返回axios方法。</p><p id="77c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过第一个参数访问VueX突变方法:vuex_context.commit()。</p><p id="789f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果出现问题，我们可以通过error方法调用错误页面。error方法可以通过第二个参数来访问:nuxt_context。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pg"><img src="../Images/e9c8852f82a3b1e310e79bf27124c2a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IA4-YufZJRGEFz6t03x0FQ.png"/></div></div></figure><p id="b9d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">练习</strong></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ph"><img src="../Images/6490b6c7bc70a81702e096f67987ebfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8KW5kcjplPRMHR2Deouf3w.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">应用+实践=精通</figcaption></figure><p id="8902" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从现在开始，我们将应用我们所学的关于Nuxt的一切，并创建一个应用程序。</p><p id="cfc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将要创建的应用程序是专门为帮助你复习你所学的每一个Nuxt技术而设计的。你也会学到一些新的东西。</p><p id="f898" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">我们将要创建的应用:</strong></p><p id="c5c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们来看看我们将要创建的应用程序。我们的应用程序由两个页面组成:一个主页和一个详细页面。详细信息页面有三个子页面:简介、规格和历史。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ms"><img src="../Images/d86b976a88449823572086d8833d6cbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CRiJt3NDkNH1jfUyQGcUHQ.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">主页和详细信息页</figcaption></figure><p id="a343" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了主页和详细信息页面，该应用程序还有两个错误页面，一个用于404错误，另一个用于其他类型的错误。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pi"><img src="../Images/6d85dbe59d18650e902993983113de66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kCyrPNWzByRCt6WNZoG3fQ.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">错误页面</figcaption></figure><p id="65d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们使用Vue CLI建立一个新的Nuxt项目。</p><h1 id="3fbb" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated">那么我们需要的命令是什么呢？</h1><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pj"><img src="../Images/a60bcd6df4dd57a270ad42c3a2041075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C3kEUP08MzlNvs-ZrI-TSA.png"/></div></div></figure><p id="6483" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们建立了Nuxt项目之后，我们打开它。默认情况下，Nuxt将驻留在端口3000。我们想换到8080端口？</p><h1 id="e1e4" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated">怎么换港？</h1><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/63a3570fcbd5d44170aa793163ce5cb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*HYzCAG7uejMf8b0zJPLvuQ.png"/></div></figure><p id="5b05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们需要安装两个插件:axios和iView。我们首先通过NPM安装它们。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pl"><img src="../Images/672230271b390082ca88a6a1f543b993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*61dUd7w201GWDV6xTjDR5A.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">NPM安装axios和iView</figcaption></figure><p id="77ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">NPM安装只是第一步。我们还需要配置插件。</p><h1 id="5311" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated">如何配置插件？</h1><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/97697555d16c20c09c446518f55da82b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*BKKO0hwh1ZFLZPScW9_X3Q.png"/></div></figure><h1 id="cfd6" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated">供应商是做什么的？</h1><p id="f9ea" class="pw-post-body-paragraph jn jo iq jp b jq og js jt ju oh jw jx jy oi ka kb kc oj ke kf kg ok ki kj kk ij bi translated">防止同一个包重复捆绑。</p><h1 id="7f1f" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated">如何处理iView的配置文件？</h1><p id="d884" class="pw-post-body-paragraph jn jo iq jp b jq og js jt ju oh jw jx jy oi ka kb kc oj ke kf kg ok ki kj kk ij bi translated">两步:<br/> 1。在插件目录中创建一个JS文件。此JS文件将存储iView的配置代码。</p><p id="734a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.使用plugins属性将这个配置文件链接到<em class="ly"> nuxt.config.js </em>文件。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pn"><img src="../Images/f0c04923618c642fca44204e5fe0fe2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SePJWrSq7GTS_oPqtLY1SA.png"/></div></div></figure><p id="3a5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们的Nuxt程序已经设置好了。先从主页说起。</p><p id="dde8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主页有三个主要部分:页眉、页脚和中间的正文。</p><p id="f804" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将在标题上工作。</p><p id="f3e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用固定位置将页眉定位到页面顶部。我们还给标题一个高的z-index值，这样它就可以一直位于其他页面元素之上。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi po"><img src="../Images/16a5335d0daecec41cb9d742c586d3fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qM5Dj0tMQYIWSBOKSp5dHQ.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">标题</figcaption></figure><p id="0c77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们解决页脚。页脚相对简单。我们使用固定位置将其定位到页面底部。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pp"><img src="../Images/5f2cd5858492310ca1ea0da2d06dd751.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iK1v_AZojQZEPKNGAg72SA.png"/></div></div></figure><p id="dcf6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">页眉和页脚都是通过固定位置定位的。这会给我们带来一个小问题:流入的元素会被它们堵住。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pq"><img src="../Images/ec9cac1ff632cfc4e10aae2fd4fc1545.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iSNhx4_its9Df6I5S90UqA.png"/></div></div></figure><p id="50ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个问题非常容易解决:我们给主体一个上下填充。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pr"><img src="../Images/26ce126f187e3ac69de23eb3d74b363d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5uPL9yQV9Wj5m27BqheJ3g.png"/></div></div></figure><p id="2780" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，每个人都很开心。所有页面元素都应该放在主DIV中。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ps"><img src="../Images/de0ae3a466b80515abacfd03ee979c91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pizrD1Q_LyXSbDa5m2vYdQ.png"/></div></div></figure><h1 id="2fa0" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated">主页的HTML和CSS设置摘要</h1><ol class=""><li id="dbd5" class="om on iq jp b jq og ju oh jy pt kc pu kg pv kk or os ot ou bi translated">主页由三部分组成:页眉、页脚和正文。</li><li id="bdf8" class="om on iq jp b jq ov ju ow jy ox kc oy kg oz kk or os ot ou bi translated">页眉和页脚通过固定位置定位，这将使它们脱离流程。因此，流入元素将显示在页眉和页脚下。</li><li id="8682" class="om on iq jp b jq ov ju ow jy ox kc oy kg oz kk or os ot ou bi translated">为了解决这个问题，我们给主DIV一个顶部和底部的填充。所有页面元素都应该放在主DIV中。</li></ol><p id="29f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们想要创建一个新页面。将页眉、页脚和正文复制到新页面文件中并不是一个好的解决方案。</p><h1 id="ac8b" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated">重复使用页眉和页脚的最好方法是什么？</h1><p id="83f6" class="pw-post-body-paragraph jn jo iq jp b jq og js jt ju oh jw jx jy oi ka kb kc oj ke kf kg ok ki kj kk ij bi translated">把它们变成组件。组件文件应该存储在组件目录中。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pw"><img src="../Images/8c2f1fade550cbb46f5659f81f135d6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TMy0nvzuVAKeE3BZG2fmDQ.png"/></div></div></figure><p id="769c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要使用组件，我们仍然要遵循三个步骤:</p><ol class=""><li id="b5a1" class="om on iq jp b jq jr ju jv jy oo kc op kg oq kk or os ot ou bi translated">导入组件</li><li id="1c2a" class="om on iq jp b jq ov ju ow jy ox kc oy kg oz kk or os ot ou bi translated">声明组件</li><li id="3f13" class="om on iq jp b jq ov ju ow jy ox kc oy kg oz kk or os ot ou bi translated">安装组件</li></ol><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi px"><img src="../Images/7c8cf4ed20b64e1c8d6165c1cb8a544f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MNtM19BaKaWDYfV8bm7drw.png"/></div></div></figure><p id="40e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们“组件化”主DIV。Car_list仍然会存储在index.vue中，我们通过props将它发送到主组件中。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi py"><img src="../Images/28b7ef9b52679330a1ab6630ae81c391.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VmWyVtaMywylluHAXW_1EA.png"/></div></div></figure><p id="5509" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每当我们创建一个新的页面，我们必须导入，声明和安装页眉和页脚。然后，我们需要创建一个主DIV，顶部和底部填充。</p><p id="991a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这还是不够方便。有没有更好的解决办法？</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pz"><img src="../Images/6f789cf75b33c2dcf48154abf00ecd41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MOeel3MY1pn_6b9fu-ycMA.png"/></div></div></figure><h1 id="179e" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated">使用布局！！！</h1><p id="56cd" class="pw-post-body-paragraph jn jo iq jp b jq og js jt ju oh jw jx jy oi ka kb kc oj ke kf kg ok ki kj kk ij bi translated">我们将页眉和页脚导入layouts/default.vue。</p><p id="e8d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们用页眉和页脚“夹”住<nuxt/>。</p><p id="6273" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们用一个主DIV包装<nuxt/>。这个主DIV生成顶部和底部填充。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qa"><img src="../Images/3594c9c06dc3f64f387dee919b1cf545.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I6ODbbHaEEFivObf7tTSHw.png"/></div></div></figure><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/f56d1b04aa21d6de57fab8fec0e6a0ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*gd2a_4DFoKMUym1vT7la6g.png"/></div></figure><p id="c250" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，所有新页面将自动继承页眉、页脚和#main DIV。因此，创建新页面非常简单方便。我们再也不用担心页眉、页脚和填充了！</p><h1 id="4408" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated">在Nuxt中尝试VueX</h1><p id="37ac" class="pw-post-body-paragraph jn jo iq jp b jq og js jt ju oh jw jx jy oi ka kb kc oj ke kf kg ok ki kj kk ij bi translated">Nuxt自带VueX安装。但是我们需要创建VueX配置文件。</p><h1 id="e5c1" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated">关于Nuxt VueX配置文件，你应该记住三件事</h1><ol class=""><li id="1bb7" class="om on iq jp b jq og ju oh jy pt kc pu kg pv kk or os ot ou bi translated">将VueX配置文件存储在存储目录中。</li><li id="2b27" class="om on iq jp b jq ov ju ow jy ox kc oy kg oz kk or os ot ou bi translated">在Nuxt VueX配置文件中，<em class="ly"> vue.use() </em>是可选的。</li><li id="4679" class="om on iq jp b jq ov ju ow jy ox kc oy kg oz kk or os ot ou bi translated">在Nuxt VueX配置文件中，你把新的VueX。在匿名函数中存储(config)并返回它。然后导出默认的匿名函数。</li></ol><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qc"><img src="../Images/e68ca2f5075ab0edeaa571880199e9f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SPNG7UECoKurkuB_gy-bMA.png"/></div></div></figure><p id="ace9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在组件中访问VueX:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qd"><img src="../Images/826a9303d3783ac5565019379a522314.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7j7QlHMj_a16ETuT_ZwXkg.png"/></div></div></figure><p id="2a5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要将初始数据注入VueX状态，您有两种选择。</p><h1 id="a53e" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated">这两个选项是什么？</h1><p id="b1ef" class="pw-post-body-paragraph jn jo iq jp b jq og js jt ju oh jw jx jy oi ka kb kc oj ke kf kg ok ki kj kk ij bi translated">安装在组件中的fetch方法和安装在VueX操作中的nuxtServerInit方法。它们都有上下文作为参数值。Context.store为他们提供了访问VueX的权限。</p><h1 id="1843" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated"><strong class="ak">对上下文的一点总结</strong></h1><p id="5b20" class="pw-post-body-paragraph jn jo iq jp b jq og js jt ju oh jw jx jy oi ka kb kc oj ke kf kg ok ki kj kk ij bi translated">中间件函数fetch()和nuxtServerInit都会接收上下文作为它们的参数值。上下文可以让我们完全访问整个Nuxt程序。它解决了由于缺少这一点而导致的问题。</p><p id="8318" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Context.params和context.query允许您访问通过URL传递的值。</p><p id="8261" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Context.error()允许您触发Nuxt错误页面并向其传递值。</p><p id="6c40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Context.store让您可以访问VueX。</p><h1 id="8d31" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated">在详细页上工作</h1><p id="0266" class="pw-post-body-paragraph jn jo iq jp b jq og js jt ju oh jw jx jy oi ka kb kc oj ke kf kg ok ki kj kk ij bi translated">每次我们点击一辆汽车，我们都希望被定向到详细信息页面，在那里显示被点击汽车的详细信息。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qe"><img src="../Images/01e3bbbab0c9302ca43411da9f0daf85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cyrbefJ1A7XYIglMNIm5VQ.png"/></div></div></figure><p id="2415" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要将点击的汽车的ID传递到详细页面。最好的方法是通过URL传递ID。</p><p id="9e09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有两个选项:查询或参数。</p><p id="c2e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们想要一个短而干净的网址，所以我们会用参数。</p><p id="98e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">详细页面由两部分组成:上部和下部。上半部分由父组件创建，下半部分由子组件创建。</p><p id="3d1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">子组件将通过<nuxt-child/>显示。</p><p id="46c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过$store.state访问VueX状态。我们可以通过$route.params.id访问ID。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qf"><img src="../Images/46a595d2d5a1a07478ce45799d279661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Yj2wCCYb8GobPpNqtdHqQ.png"/></div></div></figure><p id="dca7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是详细信息页面的上半部分。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qg"><img src="../Images/d2b3b8cb62a2b25365cea1fe0b46d140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XiB-ekUsmZut9ohhgY1XxQ.png"/></div></div></figure><p id="e5a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们解决下半部分或子组件。</p><p id="ed74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们需要使用嵌套路由。</p><p id="5705" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">建议您先阅读以下内容:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qh"><img src="../Images/81aa431dc8a46ce14b011db71f82bff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e2O7vW2dtmt2O1m_9bYLzA.png"/></div></div></figure><p id="995d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在pages目录中，我们创建一个新目录:_id。</p><p id="9cdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">_id目录和_id.vue将生成嵌套路由。_id.vue为父组件，_id目录下的文件为子组件，通过<nuxt-child/>显示。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qi"><img src="../Images/66189ed5d04717c96f59c1bc50843181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*itVlOQMz6iYJFJEF8tCw9w.png"/></div></div></figure><p id="b9df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Localhost/ID可以为我们获取_id.vue文件。默认情况下，<nuxt-child/>会在_id目录中搜索index.vue。我们希望介绍页面成为默认页面，因此，我们将其命名为index.vue。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qj"><img src="../Images/31e4977b70fb9ea468b24001fc58bab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DyLDuivOw9yWm2xPuWu_-w.png"/></div></div></figure><p id="3bc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">介绍页面:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qk"><img src="../Images/5acfdec05c14a372ca00431a3e3908e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HyFQUWOzaG_JP3tL-K1CmQ.png"/></div></div></figure><p id="ae46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">规格页面:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ql"><img src="../Images/510a8a2459d96ec0acd3f25f11db5e0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q9bs798s3sYwgeZiFDrAIQ.png"/></div></div></figure><p id="3178" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">历史页面:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qm"><img src="../Images/a74b6dfe994a5ade8cd81e3d9ef03518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WIiwoCiSZ6DJKU1QTpzeKw.png"/></div></div></figure><h1 id="ba32" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated">如何创建通用CSS？</h1><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qn"><img src="../Images/9bdff69d8c706aed2d787b564b0cbea4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vEbIHhX9870o-LC3O58a_g.png"/></div></div></figure><p id="ce49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你使用通用CSS时，一定要记住通用CSS将首先在HTML文件中排列。这意味着通用CSS的优先级最低。组件CSS将覆盖它。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qo"><img src="../Images/a91cb2e0a4bca71dbea9711e195f3469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQDRD153gGQR7EWGsesRFg.png"/></div></div></figure><h1 id="adab" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated">过渡效果:</h1><p id="64cf" class="pw-post-body-paragraph jn jo iq jp b jq og js jt ju oh jw jx jy oi ka kb kc oj ke kf kg ok ki kj kk ij bi translated">通用CSS为创建过渡效果奠定了基础。</p><p id="a66b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将过渡CSS代码存储在一个通用CSS中，然后将过渡效果应用于所有或选定的页面。</p><p id="6093" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在资产目录中，我们创建一个CSS文件:transition.css。</p><p id="2c5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，我们需要在nuxt.config.js文件中记录transition.css。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qp"><img src="../Images/547787883c13645ea065937205b0b439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bO3mVC1fQZZJuFs-iPlNFA.png"/></div></div></figure><p id="adf9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Nuxt中设置过渡类与在Vue中相同。所以强烈建议复习一下如何在Vue中设置过渡类。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qq"><img src="../Images/a935864e9005e376845df645e10a067d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c7sTUq44At4z_5iqClOjpQ.png"/></div></div></figure><p id="8a2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个类名都以page为前缀。页面前缀会将过渡应用到所有页面。</p><p id="d1b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您不想对所有页面应用相同的过渡效果，请选择不同的前缀。例如，我们选择褪色。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qr"><img src="../Images/eb26ae013cb6680416fd185d6e19d042.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z8MVeTojO7faGymf9pIJUw.png"/></div></div></figure><p id="a6f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们去页面文件，我们要添加淡入淡出过渡效果。例如，我们希望将过渡效果添加到spec页面。下图显示了您应该在规格页面中做些什么。</p><p id="c135" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在导出的对象中，添加过渡属性。它的值是您在transition.css中使用的前缀名称。现在，我们在进入规范页面时将只有一个渐变过渡。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qs"><img src="../Images/b8104d6d20fcb6ba4ddeee4dc566c605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qDYEB4CnuEuCY2djPDcK_g.png"/></div></div></figure><p id="6bae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果想要更花哨的过渡效果，可以引入animate.css。</p><p id="6c70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它的官网是:<a class="ae le" href="https://daneden.github.io/animate.css/" rel="noopener ugc nofollow" target="_blank">https://daneden.github.io/animate.css/</a></p><p id="bdd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在assets目录中，创建一个CSS文件来存储animate.css的源代码。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qt"><img src="../Images/9175334b92372ae7474dc3a6278c77f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BuWi0ckreZUvH9V-agvmlg.png"/></div></div></figure><p id="52b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后将这个新的CSS文件添加到nuxt.config.css中。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qu"><img src="../Images/7c1a54834046ccf494416f8bc1298bad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L-aUAzQcWvCSziIbI2rNow.png"/></div></div></figure><p id="1f77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们转到我们想要添加过渡的页面文件。</p><p id="2a29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在导出的对象中，我们仍然安装转换属性。但是这一次，属性值是一个对象。</p><p id="d4a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">持续时间控制过渡效果持续的时间。它以毫秒为单位。</p><p id="c48a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">LeaveActiveClass控制当前页面离开浏览器的方式，enterActiveClass控制目标页面进入浏览器的方式。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qv"><img src="../Images/6e8e0076dc97d955db002693b9526234.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PvgBcE42_x7Eyz2YO8AW0w.png"/></div></div></figure><h1 id="eb00" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated">head()方法</h1><p id="fab4" class="pw-post-body-paragraph jn jo iq jp b jq og js jt ju oh jw jx jy oi ka kb kc oj ke kf kg ok ki kj kk ij bi translated">head()方法允许我们在head标签中设置内容。它是Nuxt的vue meta的API。</p><p id="0553" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正确设置META对SEO至关重要。</p><p id="c2f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不像中间件fetch()或者nuxtServerInit，head()有这个。head()方法的结构与vue数据和asyncData非常相似。</p><p id="e3e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你在里面返回一个对象。所有设置都存储在返回的对象中。</p><p id="479e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">若要设置页面标题，请添加title属性。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qw"><img src="../Images/29da0291c4ebbb933b8580be3c70d380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SvDYV9pX74BuvrCWtjPmaQ.png"/></div></div></figure><p id="5cd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用这个，你也可以设置一个动态标题。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qx"><img src="../Images/137afff592f833cc7258e2e0da0c8d25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-C_XVAB_fYd0RokHRkkKlA.png"/></div></div></figure><p id="1efd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">head()方法的另一个重要应用是设置各种元标签，尤其是描述标签。</p><p id="103d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是默认的描述元:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qy"><img src="../Images/2c33bc2c4ddc8fd012d1e19d66657ff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UxOM3Ne-08M9rT-zfOrqJA.png"/></div></div></figure><p id="f617" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它是由存储在nuxt.config.js中的head()方法设置的。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi qz"><img src="../Images/9806a7de6ac2f397e5a65ec26cd65907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZS9Kv798V6LjQBYvdn7bdQ.png"/></div></div></figure><p id="21dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能已经注意到了hid属性。那么这是为了什么？</p><p id="ac5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个页面都应该有自己的描述元。但是如果我们处理一个由父组件和子组件组成的页面呢？例如，我们刚刚创建的详细页面。</p><p id="fd8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自然，我们只想保留子组件的描述元。父组件的描述元将用作后备选择。如果子组件没有描述元，父组件的描述元将会出现并保存这一天。</p><p id="1612" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">H ID可以帮助我们删除父组件的元。如果没有它，父组件和子组件的描述元都将被保留。显然，这不是我们想要的。</p><p id="1a64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，如果我们从父组件和子组件中删除h id，猜猜会发生什么？</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ra"><img src="../Images/a2d1f78ff2498424df6af74ad414049c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ULksNiYzxHcZlhhG9wh0Og.png"/></div></div></figure><p id="a616" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们得到的结果:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi rb"><img src="../Images/2dd578aa4c018504ff1c200f1d119669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aGOUXA9obPBX4JxyYz079A.png"/></div></div></figure><p id="4024" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，永远不要忘记h id。</p><h1 id="a73d" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated">验证()</h1><p id="babe" class="pw-post-body-paragraph jn jo iq jp b jq og js jt ju oh jw jx jy oi ka kb kc oj ke kf kg ok ki kj kk ij bi translated">验证的参数值是{params，query，store}。它提供对存储在URL和VueX中的数据的验证访问。它的参数值非常类似于上下文，但它不是上下文。Validate()无权访问错误方法。</p><p id="6c5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你设置了validate方法，你必须在某个时候返回TRUE，否则，你将永远无法访问当前页面。</p><p id="5503" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在细节页面的父组件中，我们安装了validate方法来确保用户提供的每个ID值都是一个数字，并且不大于car_list的长度。否则，我们返回false来触发Nuxt的默认错误处理机制，即404页面。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pa"><img src="../Images/1b7620c96822220c6919bfb95afcabed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ptmOO09Q4MKmSbGAlC2eXg.png"/></div></div></figure><h1 id="c287" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated">自定义错误页面以及如何触发它</h1><p id="1b56" class="pw-post-body-paragraph jn jo iq jp b jq og js jt ju oh jw jx jy oi ka kb kc oj ke kf kg ok ki kj kk ij bi translated">在layouts目录中，我们创建一个新文件:error.vue。</p><p id="8a7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个文件将被用作我们的自定义错误页面。</p><p id="b9f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的自定义错误页面可以由context.error()触发。error方法可以通过error prop向它传递值。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi rc"><img src="../Images/9a6c2d76798d6f5082babf65c6bb9af6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tj8akf3xgCe1kAc1xi-oJg.png"/></div></div></figure><p id="ca9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就像我们之前说过的，validate方法不能访问context.error()。因此，它只能触发一个404页面。如果我们想为非法ID显示我们自己的错误页面怎么办？</p><p id="4d6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，我们不能使用validate方法来检查ID。我们使用中间件进行检查。</p><h1 id="0eed" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated">你还记得如何定义和安装中间件吗？</h1><p id="9936" class="pw-post-body-paragraph jn jo iq jp b jq og js jt ju oh jw jx jy oi ka kb kc oj ke kf kg ok ki kj kk ij bi translated">在中间件目录中，定义一个JS文件。</p><p id="84b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在JS文件中，导出默认的匿名函数。这个函数是中间件函数，将接收上下文作为它的参数值。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi rd"><img src="../Images/6241464911b470293110ba20d7fe1c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NG38X6MAzE1BSRGSt9fegA.png"/></div></div></figure><p id="d92f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是check-id中间件的样子。</p><p id="e025" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果身份证是合法的，我们什么也不做。否则，我们调用context.error()并将错误消息传递给错误页面。</p><p id="a4ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在错误页面端，我们可以通过error.message访问错误消息。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi re"><img src="../Images/36f611ca71c49fe624646e51b523a113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jg9T4wV7n1lK3k7-H_1trA.png"/></div></div></figure><h1 id="92ac" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated">如何安装一个中间件？</h1><p id="d65d" class="pw-post-body-paragraph jn jo iq jp b jq og js jt ju oh jw jx jy oi ka kb kc oj ke kf kg ok ki kj kk ij bi translated">您可以在全局或本地安装中间件。</p><p id="7de7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要在本地安装它，可以使用中间件属性。</p><p id="ba92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，中间件将从validate方法中接管ID验证工作。如果ID值非法，中间件将通过context.error()触发错误页面。Context.error()可以通过error prop将信息传递给错误页面。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi rf"><img src="../Images/27c22ae26bd39241ff270439526fe678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vN_l1Hsi-hY2GjStk7Njeg.png"/></div></div></figure><p id="d021" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">源代码可以从这个地址下载:<a class="ae le" href="https://github.com/OnlyKioskAccount/nuxt_practice_app" rel="noopener ugc nofollow" target="_blank">https://github.com/OnlyKioskAccount/nuxt_practice_app</a></p><h1 id="e881" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated">(待编辑完善……)</h1><h1 id="01c2" class="ni nj iq bd nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bi translated">结束了。</h1><p id="0439" class="pw-post-body-paragraph jn jo iq jp b jq og js jt ju oh jw jx jy oi ka kb kc oj ke kf kg ok ki kj kk ij bi translated">如果你喜欢这篇文章，请为^_^鼓掌，并点击下面的链接查看我们的Nuxt课程。</p><p id="bbb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">【https://www.udemy.com/complete-nuxtjs-course/? T2】couponCode=MEDIUM_PROMO_CNG </p><p id="ea5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看我们完整的VueJS课程:</p><p id="9753" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">https://www . udemy . com/vue js-for-students-with-zero-es6-foundation/？couponCode=MEDIUM_PROMO_1</p><p id="2fda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看我们完整的web开发课程:</p><p id="6876" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">https://www . udemy . com/we b-development-html 5-css3-PHP-OOP-and-MySQL-database/？couponCode=MEDIUM_WEB_DEV。</p></div></div>    
</body>
</html>