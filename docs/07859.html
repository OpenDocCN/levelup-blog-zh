<html>
<head>
<title>Node.js MySQL Transaction: a step-by-step tutorial with a real-life example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js MySQL事务:一步一步的教程，包含一个真实的例子</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/node-js-mysql-transaction-5713b33c53e8?source=collection_archive---------3-----------------------#2021-03-16">https://levelup.gitconnected.com/node-js-mysql-transaction-5713b33c53e8?source=collection_archive---------3-----------------------#2021-03-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6c33d1e94205fb84b628877323f727e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9BPcuFiSEHRMA_RGvo7-bw.jpeg"/></div></div></figure><p id="5313" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">事务是关系数据库的重要特征之一。在Node.js MySQL事务演练中，我们将研究它如何帮助您实现数据一致性，将困难的事情推到数据库级别。我们开始吧！</p><h2 id="f08a" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">什么是数据库事务？</h2><p id="96ec" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">定义关系数据库事务的最简单的方法是“要么全部要么全无”。您可以运行一系列SQL查询，例如，您可以运行4个SQL查询。如果第三个数据库出现问题，整个过程都可以回滚，将数据状态恢复到运行任何查询之前的状态。</p><p id="2c85" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">维基百科说:</p><blockquote class="lx"><p id="c0ed" class="ly lz it bd ma mb mc md me mf mg ky dk translated">数据库事务象征着在数据库管理系统(或类似系统)中针对数据库执行的一个工作单元，并且以独立于其他事务的一致和可靠的方式来处理。事务通常代表数据库中的任何变化。</p></blockquote><p id="d0f2" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">一个典型的例子是两个银行账户之间的资金转移。要么该操作应该完全发生，要么根本不发生。数据不应处于过渡状态，即从转让人的账户中扣除资金，但不记入受让人的账户。</p><h2 id="4099" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">锁和隔离级别的重要性</h2><p id="47c6" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">对于数据库事务，我们的目标是保持数据的一致性。关于数据一致性，数据库行锁和隔离级别总是它的一部分。理解数据库隔离的最简单方法是，当没有其他并发运行的事务可能竞争相同的行/资源时，数据库允许事务执行的能力。</p><p id="a902" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了实现良好的隔离，锁定开始发挥作用。所以我们可以锁定表中的一些行，更新它们，然后提交它。当行被更新时，我们可以阻止其他查询读取这些行。如果我们允许读取未提交的行/数据，这被称为脏读。</p><p id="0ec3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，这不是一个简单的用100个词来描述的话题，所以我强烈推荐阅读这篇关于<a class="ae mm" href="https://retool.com/blog/isolation-levels-and-locking-in-relational-databases/" rel="noopener ugc nofollow" target="_blank">数据库隔离和锁定</a>的文章。下面是来自维基百科的4个隔离级别的总结:</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/55e0a0d7fabca4875394324753c96cf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sgmBOkbWpj4pOYQD.jpg"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">数据库中的隔离级别</figcaption></figure><p id="9360" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">MySQL的默认事务隔离级别是根据其<a class="ae mm" href="https://dev.mysql.com/doc/refman/5.6/en/set-transaction.html#set-transaction-isolation-level" rel="noopener ugc nofollow" target="_blank">文档</a>的可重复读取。在我们的示例中，我们将使用不同的隔离级别。</p><p id="0fb5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这让我们明白了为什么关系数据库对事务和数据的一致性如此严格。这是因为酸性合规性，这将在下一部分讨论:</p><h2 id="b0ad" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">酸性顺应性</h2><p id="1e35" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">ACID代表原子性一致性隔离持久性，它保证可靠地处理数据库事务。<a class="ae mm" href="https://www.essentialsql.com/sql-acid-database-properties-explained/" rel="noopener ugc nofollow" target="_blank"> Essential SQL </a>已经给出了银行转账的经典例子来解释ACID。在示例中，它阐述了:</p><blockquote class="lx"><p id="187b" class="ly lz it bd ma mb mc md me mf mg ky dk translated">原子意味着要么整个银行转账将通过，要么什么都不会发生。一致性确保审计跟踪，这意味着在交易回滚的情况下，两个帐户都将恢复到原始余额。</p></blockquote><p id="b3de" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">此外，帖子描述:</p><blockquote class="lx"><p id="8802" class="ly lz it bd ma mb mc md me mf mg ky dk translated">隔离确保其他银行交易不会影响这一特定余额转移的结果。其他竞争事务将等待该事务完成。最后，持久性意味着一旦事务被保存或提交，即使在断电或系统崩溃的情况下，它也是可用的(不会丢失)。基本上，安全地保存到磁盘。</p></blockquote><p id="81f9" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">你也可以在这个<a class="ae mm" href="https://www.bmc.com/blogs/acid-atomic-consistent-isolated-durable/" rel="noopener ugc nofollow" target="_blank"> BMC博客</a>上了解更多。</p><p id="062a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">MySQL尤其是InnoDB引擎，T4说它与ACID模型紧密结合。但是，不用说，关于它有不同的<a class="ae mm" href="https://dba.stackexchange.com/questions/177569/is-mysql-acid-compliant" rel="noopener ugc nofollow" target="_blank">意见</a>也是因为旧的MyISAM引擎是<a class="ae mm" href="https://www.percona.com/blog/2016/10/11/mysql-8-0-end-myisam/" rel="noopener ugc nofollow" target="_blank">非事务性的</a>，但它不是现在的默认引擎。</p><p id="ce6c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，您可能想多读一点关于<a class="ae mm" href="https://en.wikipedia.org/wiki/CAP_theorem" rel="noopener ugc nofollow" target="_blank">上限定理</a>的内容——一致性、可用性和分区容差。除非你相信<a class="ae mm" href="https://www.dbta.com/Columns/Emerging-Technologies/Emerging-Technologies-Spanner-Stretches-the-CAP-Theorem-131092.aspx" rel="noopener ugc nofollow" target="_blank">谷歌扳手</a>拥有这三样东西中的全部三样，否则你只能拥有其中的两样。</p><p id="9827" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">多读一点关于基础——基本上可用的软状态，最终的一致性)将有助于理解<a class="ae mm" href="https://www.freecodecamp.org/news/nosql-databases-5f6639ed9574/" rel="noopener ugc nofollow" target="_blank"> NoSQL数据库</a>的“速度”以及它们所采取的权衡。简单说一下，我将留给你们这幅关于最终一致性的巧妙漫画，可能出自<a class="ae mm" href="https://twitter.com/mykola/status/1101337299525267457" rel="noopener ugc nofollow" target="_blank">米科拉</a>:</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mw"><img src="../Images/359ea92d566714e85a815ae469e71e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eyNBjji7Bjwje0mV.jpeg"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">用一张图简单解释最终的一致性</figcaption></figure><p id="9ece" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回到正题，让我们深入到代码或Node.js MySQL事务示例中。</p><h2 id="642a" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">Node.js MySQL事务示例</h2><p id="bafd" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">在本教程中，我们将以一种特殊的在线商店为例。这家商店是一家虚构的政府经营的网上商店，出售必需品，因为COVID只向养老金领取者提供短缺。对于这个MySQL事务示例，我们将有两个表sales_order和product(也有库存计数)。以下是这个虚拟商店的规则:</p><ol class=""><li id="79e8" class="mx my it kd b ke kf ki kj km mz kq na ku nb ky nc nd ne nf bi translated">它只卖卫生纸、米饭、意大利面、鸡胸肉和洗手液。总共只有5个项目。</li><li id="7d1f" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">在一份订单中，您最多只能购买1件以上物品(每天/每人)。这样做是为了使逻辑非常简单。</li><li id="e907" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">为了简单和更容易计算，所有价格都以美分存储，以美元显示。</li><li id="ad03" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">对于这个过于简单的例子，我们不关心客户或支付数据，在现实生活中，这些东西是至关重要的。</li></ol><p id="c204" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">利用上述规则来简化事务，在接下来的步骤中，我们将创建表、一些记录并为Node.js MySQL事务插图编写代码。</p><h2 id="291e" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">Node.js MySQL事务表</h2><p id="45cb" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">基于上述假设，让我们创建两个过于简化的表，产品和销售订单，如下所示:</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7101" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是两个不同的表，没有任何关系。因为这是一个非常简单的例子，sales_order将有items列，这是一个逗号分隔的产品名称值。让我们添加这5个项目，每个项目500个，如下所示:</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a55a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们创造了我们销售的5种产品。除了卫生纸，他们每个人都有500个数量。我们稍后将使用卫生纸来测试脱销场景。</p><h2 id="5359" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">Node.js MySQL事务代码</h2><p id="82b1" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">在写代码之前，我们先分析一下动作的过程。这是非常重要的，也是我认为初级工程师缺乏的技能之一。先解决问题，再写代码是最重要的<a class="ae mm" href="https://geshan.com.np/blog/2018/12/the-most-important-tip-for-beginner-software-engineers-is/" rel="noopener ugc nofollow" target="_blank">编码技巧</a>。解决这个问题的步骤如下:</p><ol class=""><li id="41f9" class="mx my it kd b ke kf ki kj km mz kq na ku nb ky nc nd ne nf bi translated">我们将隔离级别设置为“READ COMMITTED”</li><li id="3c0f" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">开始交易</li><li id="6b6d" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">锁定SKU的行，因为SKU是独一无二的。</li><li id="8890" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">阅读库存行</li><li id="a7fb" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">计算订单总额和项目</li><li id="2458" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">在订单表中插入订单</li><li id="f72e" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">更新产品扣除数量1。</li><li id="e46e" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">提交事务</li><li id="a5fc" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">如果第3步到第8步之间有问题，它将回滚整个事务</li></ol><p id="ac99" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是带有创建订单功能的订单服务，其中包含Node.js MySQL事务:</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0d73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想快速体验一下，你可以在这个开源的<a class="ae mm" href="https://github.com/geshan/nodejs-mysql-transaction" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>中找到代码。</p><h2 id="79e2" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">MySQL事务代码如何工作</h2><p id="cc87" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">是时候看看代码是如何组织的了:</p><ul class=""><li id="7f76" class="mx my it kd b ke kf ki kj km mz kq na ku nb ky nn nd ne nf bi translated">首先需要MySQL2库，我们用<code class="fe no np nq nr b">npm install --save mysql2</code>从NPM安装了这个库，并在config.js文件中为我们的MySQL服务器配置了凭证。</li><li id="5c29" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nn nd ne nf bi translated">我们有一个<code class="fe no np nq nr b">createOrder</code>函数来完成所有繁重的工作。</li><li id="90d8" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nn nd ne nf bi translated">首先创建一个到数据库的连接，我们将使用这个连接来处理所有相关的查询。</li><li id="a1ed" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nn nd ne nf bi translated">然后，我们将隔离级别设置为<code class="fe no np nq nr b">READ COMMITTED</code>，这意味着只有在当前锁定事务提交/回滚后，其他事务才能读取锁定的行。</li><li id="12f9" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nn nd ne nf bi translated">因此，我们从<code class="fe no np nq nr b">beginTransaction</code>开始交易</li><li id="e79b" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nn nd ne nf bi translated">之后，我们锁定第5行商品的SKU行，它们是<code class="fe no np nq nr b">RI0002</code>和<code class="fe no np nq nr b">CB0004</code>。</li><li id="b08a" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nn nd ne nf bi translated">随后，我们得到相同产品的名称、数量和价格。</li><li id="9bc2" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nn nd ne nf bi translated">然后，我们循环遍历每个项目，查看它是否有库存(数量不小于1)，如果它没有库存，我们抛出一个错误，回滚事务，否则它将继续进行。</li><li id="da96" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nn nd ne nf bi translated">之后，我们计算订单总数，并将名称压入<code class="fe no np nq nr b">orderItems</code>数组</li><li id="a99b" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nn nd ne nf bi translated">因此，我们在<code class="fe no np nq nr b">sales_order</code>表中插入一行，包含计算出的订单总数，并用逗号<code class="fe no np nq nr b">,</code>连接<code class="fe no np nq nr b">orderItems</code>的名称。</li><li id="7eb2" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nn nd ne nf bi translated">然后，我们将订单中的项目数量减去1(记住每个订单1个项目的规则)</li><li id="3f9b" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nn nd ne nf bi translated">最后，我们提交事务来密封整个流程。</li><li id="6e83" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nn nd ne nf bi translated">如果事务中有任何问题，我们在catch部分有一个回滚。</li><li id="57a1" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nn nd ne nf bi translated">我们有一个<code class="fe no np nq nr b">testOrderCreate</code>函数，它只调用<code class="fe no np nq nr b">createOrder</code>并退出进程。</li></ul><p id="8a15" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们测试一下我们的代码，看看它能做我们想要做的事情。</p><h2 id="03d7" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">测试Node.js MySQL事务代码</h2><p id="ce75" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">我们可以运行两个并发和竞争的事务，但是由于我们的隔离和锁定级别是最佳的，所以其中一个会等待另一个完成。如果它是一个API，我们可以在完全相同的时间(毫秒或微秒)获得对相同项目的2个或更多请求，但我们的代码仍然可以很好地处理它。测试我们的代码(目前只是一个脚本)最简单的方法之一是使用Tmux。</p><p id="b68f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Tmux也被称为终端多路复用器，它就像是你终端中的一个窗口管理器。我们可以将终端分成多个“窗格”。我们还可以使用<a class="ae mm" href="https://medium.com/@bingorabbit/tmux-propagate-to-all-panes-9d2bfb969f01" rel="noopener">同步窗格</a>设置在多个窗格中传播相同的命令。我们将使用相同的synchronize panes“on”设置在两个窗格中运行该命令，模拟两个竞争事务，如下所示:</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/74a331fd6488b2df5f53cbc6d55103f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yCylh8J0KVEdu9V0.jpg"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">正在进行的竞争性交易</figcaption></figure><p id="7f9e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如我们所看到的，上面的窗格首先被执行，因为它读取数量为484，并下了id为17的订单。然后，在上述事务的提交操作释放锁之后，下面的窗格从product表中读取行。它显示大米和鸡胸肉的数量都是483，订单id是18。接下来，让我们看看如果两个人想同时订购最后一个项目会发生什么，从逻辑上讲，其中一个人应该退出库存消息。</p><h2 id="4ad8" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">处理缺货问题的交易</h2><p id="d665" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">你可能知道，在2020年3月初，人们为卫生纸而疯狂。以至于他们诉诸<a class="ae mm" href="https://www.abc.net.au/news/2020-03-08/coronavirus-toilet-paper-fight-at-woolworths-leads-to-charges/12037046" rel="noopener ugc nofollow" target="_blank">打斗</a>和扯头发来争夺最后一卷卫生纸。我们将重演这场战斗，没有人受伤，我们不需要涉及任何执法人员。</p><p id="9610" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于我们的商店是在线的，所以争论的焦点将是谁先点击“立即付款”按钮:)。卫生纸的数量是1。即使两个人同时使用数据库行锁和正确的隔离级别，也不会产生任何争论，怎么做呢？</p><blockquote class="lx"><p id="1078" class="ly lz it bd ma mb mc md me mf mg ky dk translated">通过正确的隔离和锁定，对于place order事务，一个竞争事务将等待另一个成功。</p></blockquote><p id="d192" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">因此，等待中的顾客会收到如下“缺货”错误:</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/a6ba7b6131f800b26db0058767e19732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AQW9F4xS0TaZ2m2n.jpg"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">缺货测试，库存中的最后一件商品</figcaption></figure><p id="d6f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以在这个<a class="ae mm" href="https://github.com/geshan/nodejs-mysql-transaction/pull/7/files" rel="noopener ugc nofollow" target="_blank">拉动请求</a>中查看我们对库存示例中的最后一卷卫生纸所做的代码更改。在下方屏幕上下单的人收到了订单，而在上方屏幕上不走运的人收到了缺货信息。另一种测试方法是使用<a class="ae mm" href="https://rknn.de/blog/major-promise-allsettled-vs-promise-all-difference-by-example" rel="noopener ugc nofollow" target="_blank"> promise.allSettled </a>。我把这种探索留给你:)。</p><p id="a08c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当行被及时锁定而另一个竞争事务正在等待时，系统的这种正常行为是可能的。当第一个交易完成时，它将数量设置为0，因此第二个交易读取的数量为0，从而产生有效的缺货消息。</p><h2 id="f292" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">结论</h2><p id="d056" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">锁定、隔离级别和事务在关系数据库环境中非常重要和有用。</p><blockquote class="lx"><p id="eab2" class="ly lz it bd ma mb mc md me mf mg ky dk translated">如果您必须编写一系列SQL查询来写入数据，或者多个SQL查询需要将数据写入多个表，那么您可能需要一个数据库事务来保持数据的完整性。</p></blockquote><p id="37e0" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">好好使用事务，希望你能远离<a class="ae mm" href="https://vladmihalcea.com/database-deadlock/" rel="noopener ugc nofollow" target="_blank">数据库死锁</a>:)，继续编码！</p></div></div>    
</body>
</html>