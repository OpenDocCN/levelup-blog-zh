<html>
<head>
<title>Automated Versioning With CI/CD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CI/CD实现自动化版本控制</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/automated-versioning-with-ci-cd-8cb974399d0c?source=collection_archive---------4-----------------------#2020-12-28">https://levelup.gitconnected.com/automated-versioning-with-ci-cd-8cb974399d0c?source=collection_archive---------4-----------------------#2020-12-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a4cb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">凹凸版本:2020.12.28.2-dev → 2020.12.28.2</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c777d9f627cf3c3088e3e1688aaa6be6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*od78NHPR6wkZIE4P"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="d5ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将向您展示一个如何使用CI/CD基于日期自动化版本控制的例子。我将使用Bitbucket和Bitbucket管道，但是您可以使用任何Git和CI/CD工具，只要它们公开API端点来创建、批准和合并pull请求。我将使用bump2version来增加版本号，但是这些原则当然也可以应用于其他工具。</p><h1 id="72c9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">版本控制结构</h1><p id="4ab5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在我们的例子中，我们希望构建类似于<code class="fe mp mq mr ms b">2020.12.28.1</code>或<code class="fe mp mq mr ms b">2020.12.28.5-dev</code>的版本，其中前三段组合起来是日期:<code class="fe mp mq mr ms b">year.month.day</code>，最后一个数字是当天发布的数量，可选地带有一个<code class="fe mp mq mr ms b">dev</code>(开发)标签，这样您就可以在一天内发布更多的版本。您还可以选择用时间替换这个发布号，这样您的标签看起来就像下面这样:<code class="fe mp mq mr ms b">year.month.day.hour.minute</code>或<code class="fe mp mq mr ms b">2020.12.28.09.00</code>。</p><h2 id="3231" class="mt lt iq bd lu mu mv dn ly mw mx dp mc lf my mz me lj na nb mg ln nc nd mi ne bi translated">您将需要:</h2><ul class=""><li id="93dd" class="nf ng iq ky b kz mk lc ml lf nh lj ni ln nj lr nk nl nm nn bi translated">存储库中启用的管道。</li><li id="684b" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">bot的Bitbucket帐户，可以对您的存储库进行写访问。</li></ul><h1 id="897f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">储存库变量</h1><p id="8bd2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">您不希望在管道配置中添加硬编码的bot帐户的位存储桶凭据。我们将它们设置为可以在管道中访问的(安全的)存储库变量。在您的存储库设置中，转到存储库变量并添加两个新的存储库变量:</p><ul class=""><li id="34ad" class="nf ng iq ky b kz la lc ld lf nt lj nu ln nv lr nk nl nm nn bi translated">名称:<strong class="ky ir">bit bucket _ BOT _ USERNAME</strong><br/>值:您刚刚创建的Bitbucket Bot帐户的用户名。</li><li id="90b1" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">名称:<strong class="ky ir">bit bucket _ BOT _ PASSWORD</strong><br/>值:您刚刚创建的Bitbucket bot账户的密码。<br/>同时勾选<code class="fe mp mq mr ms b">Secured</code>复选框。</li></ul><h1 id="f959" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">添加Bumpversion配置</h1><p id="ff03" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://pypi.org/project/bump2version/" rel="noopener ugc nofollow" target="_blank"> Bump2version </a>需要一个配置文件(. bumpversion.cfg或setup.cfg)，您可以在其中配置您的版本外观以及您希望在版本升级时更新的文件。请将. bumpversion.cfg或setup.cfg(我使用的是后者)添加到您的存储库中，其根目录包含以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="3ea7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">[bumpversion:file:filename]</code>块表示在版本升级时需要更新哪些文件。它将在文件中寻找当前的标签，在这个例子中是<code class="fe mp mq mr ms b">2020.12.28.1</code>，并用新的标签替换它，例如<code class="fe mp mq mr ms b">2020.12.28.2</code>。注意:如果bumpversion在这个文件中找不到当前标记，它将抛出一个错误，您的管道将失败。因此，如果您的目录中没有pyproject.toml，请删除该块，或者用包含当前版本号的另一个文件替换它。请将version.txt块保存在该文件中，我们将使用该文件实际创建正确的版本。</p><h1 id="9896" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">添加版本文件</h1><p id="44db" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">将version.txt文件添加到存储库的根目录中。作为内容，添加对应于setup.cfg → <code class="fe mp mq mr ms b">current_version</code>的值，在我们的例子中是<code class="fe mp mq mr ms b">2020.12.28.1</code>。请确保version.txt只包含版本号，不包含其他信息！</p><h1 id="9457" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">添加位桶管道配置文件</h1><p id="85a5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">将bitbucket-pipelines.yml文件添加到项目文件夹的根目录，并添加以下内容。请注意，这是管道的最小设置，不包含任何部署逻辑。我将在下面解释管道中发生的事情。</p><p id="4e6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">【2022年3月更新:我们遇到了标签不再包含在构建上下文中的问题。您可能希望在设置<code class="fe mp mq mr ms b">NUMBER_RELEASES</code>之前手动获取所有标签，使用:</p><pre class="kg kh ki kj gt ny ms nz oa aw ob bi"><span id="f7cd" class="mt lt iq ms b gy oc od l oe of">git fetch -all -tags</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h2 id="8f0c" class="mt lt iq bd lu mu mv dn ly mw mx dp mc lf my mz me lj na nb mg ln nc nd mi ne bi translated">提升到开发步骤</h2><p id="d253" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我将从解释“提升到开发”这一步中发生的事情开始。请注意，我用3个点(…)替换了另一个配置，以突出显示该特定步骤，请不要使用下面的代码片段，而是始终使用上面的代码片段。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="8d97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个手动的步骤(所以你每次都必须按下‘Run’)，可以在将变更引入开发时运行。在我的情况下，我想决定什么时候创建一个新版本。自动化这些步骤还会导致流水线循环，这必须用额外的逻辑来解决。</p><p id="1b9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，安装所需的依赖项。jq需要解析来自curl命令的JSON响应。实际创建新版本需要bump2version。</p><p id="8ad0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装完依赖项后，获取UTC日期并解析为<code class="fe mp mq mr ms b">year.month.day</code>。这将在我们的版本中使用。但是我们还需要日期来获取我们当天已经创建的发布量。</p><p id="8c60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过执行下面的命令获得从当前日期开始并以<code class="fe mp mq mr ms b">dev</code>结束的所有git标签(因为我们想要部署一个创建开发版本:<code class="fe mp mq mr ms b">git tag -l "v${DATE}*-dev"</code>)。这将输出如下内容:</p><pre class="kg kh ki kj gt ny ms nz oa aw ob bi"><span id="c450" class="mt lt iq ms b gy oc od l oe of">v2020.12.28.1-dev<br/>v2020.12.28.2-dev</span></pre><p id="6832" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们可以计算用<code class="fe mp mq mr ms b">wc -l</code>输出的<code class="fe mp mq mr ms b">git tag</code>命令的行数，并将其存储为一个名为<code class="fe mp mq mr ms b">NUMBER_RELEASES</code>的变量。</p><pre class="kg kh ki kj gt ny ms nz oa aw ob bi"><span id="47a3" class="mt lt iq ms b gy oc od l oe of">NUMBER_RELEASES=$(git tag -l "v${DATE}*-dev" | wc -l)</span></pre><p id="344d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以稍后使用这个数字来计算当天的新发布号。<br/>下一步是“试运行”bumpversion命令(注意<code class="fe mp mq mr ms b">--no-commit --no-tag --allow-dirty</code>标志)。</p><p id="a4a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些标志确保该命令不会影响我们的存储库的远程状态，而是临时在管道内本地撞击新版本。然后，通过阅读version.txt，我们知道我们的新版本是什么，我们可以创建一个包含新版本名称的新发布分支。</p><p id="ad45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个release分支实际上是用来创建新版本和git标签的，因为我不想直接在development分支上这样做，而且我的development分支上总是有写保护。</p><p id="9822" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在检查完管道中的这个发布分支后，我用<code class="fe mp mq mr ms b">git reset — hard HEAD~0</code>重置了bumpversion所做的更改，所以这次我们可以真正创建新版本了。</p><p id="59c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在转储这个版本之后，我们将更改——提交更新setup.cfg文件中指定的版本和新标签——推送到远程存储库。然后我们有了一个新的发布分支，它带有一个用我们的新版本标记的提交。</p><p id="81b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您接下来可以做的是从我们的新发布分支手动创建一个pull请求到开发，但是我也想自动化这个步骤。</p><p id="65b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">自动合并新版本<br/>下面的代码负责创建一个pull请求并合并它。再次注意:我用3个点替换了另一个配置。</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="8d74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用Bitbucket API创建一个端点为<code class="fe mp mq mr ms b">https://api.bitbucket.org/2.0/repositories/${BITBUCKET_REPO_FULL_NAME}/pullrequests</code>的pull请求。这是一个POST请求，您必须将Bitbucket用户的凭证添加到请求中，同时添加一个请求体(JSON，转义为一行程序)，您可以在下面看到(修饰过的)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="c33e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当请求成功时，您将检索一个包含URL的响应主体，以合并新创建的pull请求。您可以使用jq解析响应并检索<code class="fe mp mq mr ms b">.links.merge.href</code>值。然后，您可以使用这个值(它是一个URL)发出一个新的curl请求。这也是一个POST请求。</p><h2 id="003e" class="mt lt iq bd lu mu mv dn ly mw mx dp mc lf my mz me lj na nb mg ln nc nd mi ne bi translated">提升到生产步骤</h2><p id="8557" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">“升级到生产”步骤与“升级到开发”步骤略有不同。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="9745" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此步骤仅在创建并推送带有<code class="fe mp mq mr ms b">-dev</code>的版本时可用。这将自动触发标记管道，然后您可以手动触发“升级到生产”步骤。另一个略有不同的是，将有两个合并。</p><p id="b73c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们假设我们刚刚创建了版本<code class="fe mp mq mr ms b">2020.12.28.1-dev</code>。当该版本创建成功并推送到远程时，会触发<code class="fe mp mq mr ms b">pipelines.tags.v*-dev</code>。</p><p id="4078" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当执行手动步骤“Promote to prod”时，版本将被转移到<code class="fe mp mq mr ms b">2020.12.18.1</code>(末尾没有-dev)。在此过程中创建的发布分支将被合并到开发中，但是在此之后，开发也将被自动合并到主开发中。</p><p id="85f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这远远不是一个理想的情况，肯定可以优化，因为它可能会发生，新的功能已被拉入开发，但对我们来说，这将是现在。</p><p id="9b1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能希望将发布分支分别拉进开发和主控，而不是在将发布分支拉进开发之后再将开发拉进主控，但是这取决于您自己！</p><h1 id="25c9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">自动化部署</h1><p id="df62" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">示例中不包括自动部署。然而，根据您的需要，您可以在<code class="fe mp mq mr ms b">pipelines.tags.v*</code>或<code class="fe mp mq mr ms b">pipelines.tags.v*-dev</code>中添加构建和部署步骤。</p><h1 id="4776" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">问题、建议或反馈</h1><p id="dd3f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果您对本文有任何问题、建议或反馈，请告诉我！</p></div></div>    
</body>
</html>