# Pro 之路—指针和功能

> 原文：<https://levelup.gitconnected.com/road-to-go-pro-pointer-functions-1b4f18b4fdb0>

*开始前的几句话。你可以在这个* [*资源库*](https://github.com/songx23/RoadToGoPro) *中找到本教程使用的代码。你可以在这里* *找到 Road to Go Pro* [*的全部内容。如果你错过了最后一个，你可以通过这个*](https://medium.com/@songx/road-to-go-pro-f9d1f8a51fad) [*链接*](/road-to-go-pro-flow-control-dfcc7b9a5395) *找到它。*

我们在教程的最后一部分讨论了流量控制和循环。在这一篇中，我们将讨论指针和函数。在完成了 Road to Go Pro 的前 4 个部分后，您就可以开始使用 Go 编写脚本或控制台应用程序了。

# **指针**

![](img/9462dfd8c7244cb9874f0459ab111de8.png)

照片由 [Nathalie SPEHNER](https://unsplash.com/@nathalie_spehner?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

如果你用过 C 或 C++，你就已经知道什么是指针了。然而，在像 Java、C#、Javascript、Python 等最流行的编程语言中。没有明确的语法来表示指针。当我第一次听说这个名字时，我不知道它是什么。

简而言之，指针保存一个值的底层内存地址。等等，内存地址？Go 不是高级编程语言吗？

> 我们什么时候需要知道变量的内存地址呢？

这是一个很好的问题，但在探索答案之前，我们需要快速绕道。让我们看看如何声明指针以及如何在函数中使用它们。一旦我们涵盖了这些，你将更容易理解下面的推理和例子。所以坚持住。

## **声明指针**

每当我们在 Go 中声明一个变量时，编译器都会分配一段内存来存储它。该变量的值存储在那里，直到被垃圾收集器回收。

指针是复合数据类型。我们通过在指针指向的数据类型前添加一个`*`来形成指针类型。例如，`*string`表示指向字符串类型变量的指针的类型。

要获得现有变量的指针值，我们需要在变量前面添加一个`&`。

指针示例

我们在[之前的教程](https://medium.com/swlh/road-to-go-pro-types-structures-21e5fedc5fe0)中提到过，声明变量时不需要指定数据类型。这也适用于指针类型。在上面的例子中，变量`p`的类型将被自动推断为`*string`。

我们也可以通过使用`*`解除对指针的引用，经由指针访问或设置存储的值。

通过指针访问和更改 var 值

注意，在处理指针时，我们需要记住`nil`，因为指针的默认值是`nil`。因此，我们需要小心零指针解引用。

零指针取消引用异常

# **功能**

![](img/a10b157e515667bbf66d19b0d10a8a6d.png)

莱尼·屈尼在 Unsplash 上的照片

函数，也称为方法，创建执行特定任务的可重用逻辑。你可以把它想象成一个“工厂”。它接受 0 到 n 个参数，并返回 0 到 n 个结果。函数的结构如下所示:

函数语法

接收器、输入参数和输出参数是我们在声明函数时可以指定的三个可选组件。

## **输入/输出**

首先，让我们谈谈输入和输出参数。输入参数也称为函数参数，它们是传入工厂的成分。输出参数是工厂产生的返回值。下面是一个指定了输入和输出参数的函数示例。

功能示例

字符串`country`是`isCovidSafe`函数的输入参数。当指定输入参数时，我们需要首先声明名称，然后声明类型。而对于输出参数，我们通常只声明类型。

如果我们有一个以上的输入参数，我们可以使用一个方便的快捷方式来缩短声明，只有当部分参数具有相同的类型。

具有多个输入参数的函数

例如，`isStateCovidSafe`函数有一个额外的参数`state`，它和`country`有相同的类型。我们可以省略重复的类型声明，而不是像`(country string, state string)`那样指定两次类型。但是，这仅适用于输入参数。对于输出参数，我们必须单独指定它们，即使它们是相同的类型。关于输出的另一个注意事项，当我们有多个输出参数时，我们需要用括号`()`将类型括起来。例如，如果一个函数返回两个字符串，那么这个函数应该看起来像`func func_name(inputs string) (string, string) {}`。

如上所述，输入和输出参数是可选的。然而，没有输入和输出参数的函数可能不是很有用。

没有输入/输出参数的函数

## **数值/指针接收器**

到目前为止，我们看到的示例函数可以在同一个包中的任何地方调用。一旦我们为一个函数添加了一个接收器组件，它就使该函数属于接收器。接收者只能是本地类型。我们不能定义属于原始类型或在当前包之外定义的类型的函数。让我们来看看一些例子。首先，我们需要定义一个名为`Person`的局部类型。

声明个人结构

然后我们可以添加`Person`类型作为函数的接收者。Go 中有两种形式的接收者，即值接收者和指针接收者。

值接收器示例

`FullName()`函数有一个值接收器(`Person`)。当指定接收者时，我们需要说明接收者的名称和类型。接收者名称是可选的。如果在函数中没有使用接收方值，我们可以省略接收方名称。但是接收器类型是必需的。接收器命名的约定是使用接收器类型名的第一个字符。在函数内部，我们可以访问接收方值，并使用它们来执行某些操作。但是，值接收器不会将变量`person`的原始副本传递给函数。而是传递了一个`person`的副本。因此，即使我们改变函数中的年龄，也不会影响原始变量。你看，琼恩·雪诺还是 23 岁。唷。

如果我们想改变一个接收器的原始值，我们需要使用另一种形式的接收器，指针接收器。

指针接收器示例

指针接收器将原始变量的指针传递给函数。因此，当我们修改它的值时，它会影响原始变量。大多数时候，我使用指针接收器而不是值接收器，因为它可以避免复制接收器值。因此，指针接收器效率更高。但是，我想指出的是，使用指针接收器来改变接收器值的模式并不理想。我会避免使用这种模式，因为它使代码库更难维护和调试。

## **实现一个接口**

我们在[之前的教程](https://medium.com/swlh/road-to-go-pro-types-structures-21e5fedc5fe0)中学到了什么是接口。简单概括一下，接口是函数声明的集合。它定义了需要做什么，但没有具体说明如何去做。

要实现一个接口，我们需要定义一个结构，这个结构需要有该接口的所有声明的函数。当实现所需的函数时，我们必须在函数声明中使用值接收器或指针接收器。

使用值接收器实现接口

Go 自动识别出`Dog`结构实现了`Animal`接口，因为它已经实现了`Animal`接口中所有声明的函数。

> 你可能会想:为什么我们在实现函数时不使用指针接收器？

很高兴你问了。我们可以使用指针接收器。

现在让我们创建一个名为`Cat`的结构，我们将在实现`Animal`接口时使用指针接收器。

使用指针接收器实现接口

这里，指针`*Cat`实现了`Animal`接口而不是`Cat`结构，因为我们在`Eat()`和`Drink()`函数中使用了指针接收器。

> 那么，哪种方式更好呢？

要回答这个问题，我们需要回到何时需要使用指针的问题上来。

# **回指针**

好吧，我承认，那不是快速绕道。现在我们知道了什么是指针以及如何使用它。是时候看看什么时候应该使用指针，以及使用指针时需要注意什么了。

![](img/b9e46421aece883bd20448446f98b6e0.png)

照片由[缺口编号](https://unsplash.com/@jannerboy62?utm_source=medium&utm_medium=referral)在[防溅板](https://unsplash.com?utm_source=medium&utm_medium=referral)上拍摄

一条通用的经验法则是，只有在万不得已的情况下才使用指针。否则，就放过它吧。

以下是一些可以考虑使用指针的场景。

## 1.当你需要一个 nilable (nullable)类型时。

让我们为这个场景创建一个业务需求。假设您想存储人们是否愿意参加您的聚会的决定。有三种选择。首先，一个人可以决定加入。第二，一个人可以决定不加入。第三，一个人还没有做出决定。

将该值存储在`bool`类型中不符合要求，因为`bool`只能有两个值，true 和 false。在这种情况下，我们可以使用一个指针`*bool`，它可以保存三个值:真(连接)、假(不连接)和零(未决定)。

使用*bool 存储 true、false 和 nil

虽然`*bool`满足了需求，但是它引入了一个臭名昭著的副作用，**零解引用**。

在取消引用之前，我们需要检查`Going`字段的值是否为零。否则，我们将遇到运行时错误:“无效内存地址或零指针取消引用”。这在处理`Going`字段时增加了不必要的复杂性，并且非常容易出错，因为我们需要记住显式处理 nil 解引用。

有一个更好的方法来解决这个特殊的问题。它使用枚举作为`Going`字段的类型。

使用“枚举”替换*bool 类型

**注意:* `*iota*` *是简化递增整数定义的关键字。更多信息请查看* [*维基*](https://github.com/golang/go/wiki/Iota) *。*

## 2.当选择在函数中使用哪个接收器时。

如前一节所述，在大多数情况下，我们选择指针接收器而不是值接收器，因为它们更有效。

但是，它也带来了一个副作用，就是偶然突变。意外的数据突变使得代码更难调试和维护。我不会改变指针值。如果必须的话，我会让变异变得小而明显。像上面的例子一样，`ChangeName()`函数对一个人的名和姓进行变异。它做了一个简单的改变，函数名使得意图对其他人来说非常明显。

这里有一个更详细的关于如何在值接收器和指针接收器之间选择的[指南](https://github.com/golang/go/wiki/CodeReviewComments#receiver-type)。

## 3.当需要单身的时候。

一个[单例](https://en.wikipedia.org/wiki/Singleton_pattern)是我们在一个应用程序的生命周期中只启动一次的东西。例如，当我们需要集成第三方 API 时，我们希望为该 API 创建一个客户端，它可以是单例的。或者当我们想在应用程序中使用缓存时，缓存客户端也可以是单例的。

单例示例

我们通常在`main()`函数中初始化单例实例，然后将它传递给代码库的不同部分。在上面的例子中，我们创建了两个潜在的单例，`PointerSlackClient`和`ValueSlackClient`。如果我们像对待`ValueService`一样将 singleton 作为函数参数传递，那么`ValueSlackClient`就不再是真正的 singleton 了，因为当作为参数传递时，Go 使用了`ValueSlackClient`的副本。因此，我们将拥有不止一个`ValueSlackClient`实例。使用指针时，Go 不会复制实例。所以在应用程序中实际上只有一个`PointerSlackClient`实例。

这些是我认为我们可以利用指针的一些场景。也就是说，第一条规则仍然是:

> 尽可能避免使用指针。

# **接下来是什么？**

![](img/14f72cc9643321e377f1997ee32b550c.png)

照片由 [Olesya Grichina](https://unsplash.com/@lsgr?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

到目前为止，我们已经学习了数据类型、流控制、循环、指针和函数。这些是围棋最基本的组成部分。在接下来的教程中，我们将从另一个角度来看围棋。我将讨论包、模块以及如何从头开始一个 Go 项目。希望这篇教程对你有所帮助。如果你想了解更多关于围棋的内容，请继续关注，我们下一期再见。

如果你遇到任何问题或者需要帮助，请在下面留下你的评论。随时欢迎反馈。感谢您的阅读！

***特别感谢*** [***马克谟-库克***](https://medium.com/@mhumecook) ***对本教程的点评。***