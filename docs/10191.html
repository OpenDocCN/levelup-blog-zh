<html>
<head>
<title>Set your parents free with Angular’s dependency injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Angular的依赖注入释放你的父母</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/set-your-parents-free-with-angulars-dependency-injection-8b7aa3ee2c3?source=collection_archive---------6-----------------------#2021-11-04">https://levelup.gitconnected.com/set-your-parents-free-with-angulars-dependency-injection-8b7aa3ee2c3?source=collection_archive---------6-----------------------#2021-11-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2c372b762920be91bb993b62c8650d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GjgQorA34VTJGbGGnVS7mA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">资料来源:Freepik</figcaption></figure><p id="a741" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您使用模块化的、组件驱动的架构，您将面临的最大挑战之一是如何在父组件和子组件/指令之间实现通信。一方面，您希望每个组件/指令独立地专注于它们的用途。另一方面，您需要它们一起工作，就好像它们是作为一个有凝聚力的单元构建的一样。</p><p id="d619" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">幸运的是，Angular提供了您在任何情况下所需的一切！</p><p id="002a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您的父视图包含子视图，一种常见的方法是使用<a class="ae ld" href="https://angular.io/guide/inputs-outputs" rel="noopener ugc nofollow" target="_blank">@ Input()和@Output()装饰符</a>。要与父级通信，您可以通过子级发出自定义事件。若要与子节点通信，可以传递绑定到父节点的属性。</p><p id="efd8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">还可以用<a class="ae ld" href="https://angular.io/api/core/ViewChild#description" rel="noopener ugc nofollow" target="_blank"> @ViewChild/@ViewChildren </a>和<a class="ae ld" href="https://angular.io/api/core/ContentChild" rel="noopener ugc nofollow" target="_blank">@ content child/@ content children</a>来打破亲子墙。(我会在以后的文章中讨论这些强大的装饰者。)</p><p id="83b8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您的父视图不直接包含子视图，或者根本没有关系，您可以在服务中使用observables来传递数据。这样，实际的关系并不重要，因为任何注入服务的人都可以更新和订阅observables。</p><h1 id="cf92" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">为什么要使用依赖注入来寻找父节点</h1><p id="ca3e" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">我创建了一个任务系统，在表格行组件中显示每个任务。我还创建了按钮组件来对表行进行操作。但是，我不想在表行组件中包含按钮组件，这样无论它们是否在表中，都可以使用它们。</p><p id="1166" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我面临的问题是如何给按钮组件分配一个特定的ID，而不必一遍又一遍地传递ID作为输入。例如，下面是表行组件的HTML，它遍历一组任务。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4e86" class="mq lf it mm b gy mr ms l mt mu">&lt;ces-table-row *ngFor="let task of tasks; let index = index;" [id]="task.id" [index]="index"&gt;<br/>    &lt;ces-table-column class="justify-center"&gt;<br/>        &lt;ces-view-pin [active]="task.pinned"&gt;&lt;/ces-view-pin&gt;<br/>        &lt;ces-view-delete&gt;&lt;/ces-view-delete&gt;<br/>    &lt;/ces-table-column&gt;<br/>    &lt;ces-table-column class="justify-center"&gt;{{ task.id }}&lt;/ces-table-column&gt;<br/>    &lt;ces-table-column class="justify-center"&gt;<br/>        &lt;ces-task-menu-statuses [default]="task.status"&gt;&lt;/ces-task-menu-statuses&gt;<br/>    &lt;/ces-table-column&gt;<br/>    &lt;ces-table-column&gt;{{ task.dateUpdated | date: 'short' }}&lt;/ces-table-column&gt;<br/>    &lt;ces-table-column&gt;{{ task.title }}&lt;/ces-table-column&gt;<br/>    &lt;ces-table-column&gt;{{ task.notes }}&lt;/ces-table-column&gt;<br/>&lt;/ces-table-row&gt;</span></pre><p id="4291" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我提到的按钮组件使用了选择器‘ces-view-pin’和‘ces-view-delete’。我希望这些组件只负责按钮交互的状态，并在它们被按下时向服务发送消息。这样，我可以避免每次使用它们时重复多余的代码，而且无论谁在使用它们，它们的行为都是一样的。</p><p id="45c5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因为表行组件正在获取任务ID，所以我需要一种方法在层次结构中向上导航来访问它。幸运的是，Angular提供了一种简单的方式来搜索层次结构。</p><h1 id="dd5a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">搜索父接口</h1><h2 id="532f" class="mq lf it bd lg mv mw dn lk mx my dp lo kq mz na ls ku nb nc lw ky nd ne ma nf bi translated">步骤1:创建一个抽象类</h2><p id="9111" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">我首先创建了一个抽象类，它包含了我希望按钮组件能够访问的属性。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8864" class="mq lf it mm b gy mr ms l mt mu">export abstract class View {<br/>  abstract id: number;<br/>  abstract index: number;<br/>}</span></pre><h2 id="47d9" class="mq lf it bd lg mv mw dn lk mx my dp lo kq mz na ls ku nb nc lw ky nd ne ma nf bi translated">步骤2:实现抽象类并添加提供者</h2><p id="a878" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">下一步是实现抽象类，并为任何试图注入它的人提供一个参考。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="596c" class="mq lf it mm b gy mr ms l mt mu">import { Component, forwardRef, Input } from '@angular/core';<br/>import { View } from 'projects/view/src/public-api';</span><span id="6a86" class="mq lf it mm b gy ng ms l mt mu">@Component({<br/>  selector: 'ces-table-row',<br/>  templateUrl: './table-row.component.html',<br/>  styleUrls: ['./table-row.component.scss'],<br/>  providers: [{<br/>    provide: View, useExisting: forwardRef(() =&gt; TableRowComponent)<br/>  }]<br/>})<br/>export class TableRowComponent implements View {<br/>  @Input() id!: number;<br/>  @Input() index: number = -1;</span><span id="f50c" class="mq lf it mm b gy ng ms l mt mu">  constructor() { }<br/>}</span></pre><h2 id="72e6" class="mq lf it bd lg mv mw dn lk mx my dp lo kq mz na ls ku nb nc lw ky nd ne ma nf bi translated">步骤3:将接口注入子组件/指令</h2><p id="93c6" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">最后一步是使用<a class="ae ld" href="https://angular.io/api/core/Optional" rel="noopener ugc nofollow" target="_blank"> @Optional() decorator </a>将视图类注入到任何需要访问抽象类中定义的父类属性/方法的子类中。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3df4" class="mq lf it mm b gy mr ms l mt mu">export class ViewDeleteComponent {</span><span id="6967" class="mq lf it mm b gy ng ms l mt mu">  constructor(<br/>    protected _viewService: ViewService,<br/>    @Optional() public view: View<br/>  ) { }</span><span id="9e4c" class="mq lf it mm b gy ng ms l mt mu">  delete() {<br/>    const message: ApiChange = {<br/>      id: this.view.id,<br/>      index: this.view.index,<br/>      action: 'delete',<br/>    }</span><span id="c99e" class="mq lf it mm b gy ng ms l mt mu">    this._viewService.setChange(message);<br/>  }<br/>}</span></pre><p id="a61e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你想看到所有三个组件的代码，查看这个<a class="ae ld" href="https://gist.github.com/yokoishioka/0fc3a8e1794a33657060ae4a8cbe73b5" rel="noopener ugc nofollow" target="_blank"> github要点</a>。</p></div></div>    
</body>
</html>