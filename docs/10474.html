<html>
<head>
<title>How to Build a Note Taking Command Line Interface (CLI) With Rust: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Rust构建笔记命令行界面(CLI ):第2部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-a-note-taking-command-line-application-with-rust-part-2-ec738dd97c48?source=collection_archive---------12-----------------------#2021-12-10">https://levelup.gitconnected.com/how-to-build-a-note-taking-command-line-application-with-rust-part-2-ec738dd97c48?source=collection_archive---------12-----------------------#2021-12-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/51d94b184ff5a790dd798a68cd475b52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fjuW91urikTWjMyRaY11Og.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">温哥华下了很多雨，但是在下面的帖子里可以找到唯一的锈迹</figcaption></figure><p id="f2bb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这个系列的第一部分<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/how-to-build-a-note-taking-command-line-application-with-rust-part-1-34b9cd5be6b9">中，我们创建了一个基本的rust CLI程序，它允许我们<strong class="kh iu">创建</strong>笔记并将它们保存在sqlite数据库中。如果你还没有读过那篇文章，你应该从那里开始，因为这是在那篇文章停止的地方建立的。</a></p><p id="dd6e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这下一部分将涵盖CRUD的其余部分:<strong class="kh iu">读取</strong>，<strong class="kh iu">更新</strong>，以及<strong class="kh iu">删除</strong>。</p><p id="1bd1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">本系列中描述的Rust应用程序已经在<a class="ae ld" href="https://github.com/adamjberg/engram/tree/main/clients/cli/ego" rel="noopener ugc nofollow" target="_blank">开源repo for engram </a>中登陆。如果您想更密切地关注开发，请登录Github，这样您就可以记得回来查看。</p><h1 id="cacb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">阅读</h1><p id="52a3" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">下一个合乎逻辑的步骤是添加读取刚刚创建的任何内容的能力。在命令行应用程序中，这里的选项非常有限，这使得我们可以跳过讨论所有与图形用户界面(GUI)相关的主题。但是这并不一定会使事情变得简单。</p><p id="912c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于如何在我们的应用程序中工作，有一些考虑。即我们希望如何触发并向用户显示历史记录。</p><h1 id="4991" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">触发器或命令</h1><p id="3bb3" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">notes应用程序将在启动后继续运行，直到提交一个空字符串。为了查询某种类型的信息，我们需要发明一些功能，允许用户区分简单的注释和更高级的命令。</p><p id="f463" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为此，我们将实现“斜杠命令”。这些已经被Slack和concept之类的公司推广开来，应该能很好地满足我们的需求。如果注释以“/”开头，后面的文本将被解释为命令。更具体地说，为了阅读笔记，我们将添加一个“/list”命令。为了简单起见，它将转储数据库中的所有注释。我们将在随后的帖子中对此进行跟进，以改进其工作方式。每一个新的功能都比你最初意识到的要多得多，所以推迟某些事情可以防止你被无关紧要的细节所困扰。</p><h1 id="379c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">/列表</h1><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2a4b" class="mq lf it mm b gy mr ms l mt mu">let mut running = true;<br/>    while running == true {<br/>        let mut buffer = String::new();<br/>        io::stdin().read_line(&amp;mut buffer)?;</span><span id="c7a9" class="mq lf it mm b gy mv ms l mt mu">        let trimmed_body = buffer.trim();<br/>        if trimmed_body == "" {<br/>            running = false;<br/>        } <br/>        else if trimmed_body == "/list" {<br/>            let mut stmt = conn.prepare("SELECT id, body from notes")?;<br/>            let mut rows = stmt.query(rusqlite::params![])?;<br/>            while let Some(row) = rows.next()? {<br/>                let id: i32 = row.get(0)?;<br/>                let body: String = row.get(1)?;<br/>                println!("{} {}", id, body.to_string());<br/>            }<br/>        }<br/>        else {<br/>            conn.execute("INSERT INTO notes (body) values (?1)", [trimmed_body])?;<br/>        }<br/>    }</span></pre><p id="bd1f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">每当提交一个注释时，我们检查是否输入了“/list”。如果是，我们进入<code class="fe mw mx my mm b">else if</code>块打印现有的笔记。</p><p id="3429" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe mw mx my mm b">let mut stmt = conn.prepare("SELECT id, body from notes")?;</code></p><p id="948f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这将使用我们在main函数开始时初始化的连接准备一条SQL语句。<code class="fe mw mx my mm b">SELECT id, body from notes</code>指定我们要从notes表中返回id和body列。</p><p id="7e1d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe mw mx my mm b">let mut rows = stmt.query(rusqlite::params![])?;</code></p><p id="9849" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后，我们在准备好的语句上发出<code class="fe mw mx my mm b">query</code>方法。因为我们选择了所有的音符，所以没有参数，这就是为什么我们使用<code class="fe mw mx my mm b">rusqlite::params![]</code>传递空参数。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c69b" class="mq lf it mm b gy mr ms l mt mu">while let Some(row) = rows.next()? {<br/>    let id: i32 = row.get(0)?;<br/>    let body: String = row.get(1)?;<br/>    println!("{} {}", id, body.to_string());<br/>}</span></pre><p id="3caf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">上面的代码遍历了所有返回的行。每一行将是一个说明，以前已经输入到我们的数据库中。<code class="fe mw mx my mm b">row.get(0)</code>和<code class="fe mw mx my mm b">row.get(1)</code>获取相关列索引的值。在我们的例子中，我们的查询指定:<code class="fe mw mx my mm b">SELECT id, body from notes</code>，这意味着id将位于索引0，而body将位于索引1。</p><p id="dce6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Rust无法推断这些属性的类型，这就是为什么它们必须被指定为<code class="fe mw mx my mm b">let id: i32 = row.get(0)?;</code>和<code class="fe mw mx my mm b">let body: String = row.get(1)?;</code>。用<code class="fe mw mx my mm b">i32</code>标识id是一个32位整数，用<code class="fe mw mx my mm b">String</code>标识主体是一个字符串。</p><p id="927a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后，我们将这两者传递给<code class="fe mw mx my mm b">println</code>函数，以便将它们输出回终端。</p><p id="39e9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">同样，你现在可以用<code class="fe mw mx my mm b">cargo run</code>运行应用程序，如果你发出一个<code class="fe mw mx my mm b">/list</code>命令，你现在应该可以看到你提交的所有笔记都打印出来了。</p><h2 id="2290" class="mq lf it bd lg mz na dn lk nb nc dp lo kq nd ne ls ku nf ng lw ky nh ni ma nj bi translated">删除</h2><p id="cf71" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">我几乎总是在更新前删除。这是一个简单的操作，可以很快实现。它也可以作为编辑项目的临时方法。在我们的notes示例中，如果我想编辑一个注释，我可以先删除它，然后用正确的正文创建一个新的注释。如上所述，这在像这样的小例子中不太相关，但是在更大的应用程序中，编辑GUI可能会非常复杂。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="83a0" class="mq lf it mm b gy mr ms l mt mu">...<br/>let trimmed_body = buffer.trim();<br/>let cmd_split = trimmed_body.split_once(" ");</span><span id="7d18" class="mq lf it mm b gy mv ms l mt mu">let mut cmd = trimmed_body;<br/>let mut msg = "";<br/>if cmd_split != None {<br/>    cmd = cmd_split.unwrap().0;<br/>    msg = cmd_split.unwrap().1;<br/>}</span><span id="8d79" class="mq lf it mm b gy mv ms l mt mu">if cmd == "/del" {<br/>    let id = msg;<br/>    conn.execute("delete from notes where id = (?1)", [id])?;<br/>}<br/>...</span></pre><p id="1eab" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe mw mx my mm b">/del</code>命令有一些<code class="fe mw mx my mm b">/list</code>命令没有的东西——一个附加参数。我们需要指定要删除的笔记。想了一下，决定还是通过<code class="fe mw mx my mm b">/del 1</code>删除id为1的笔记吧。</p><p id="f650" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了区分“命令”和“参数”，我决定使用<code class="fe mw mx my mm b">split_once</code>方法。</p><p id="2368" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe mw mx my mm b">let cmd_split = trimmed_body.split_once(" ");</code></p><p id="4cc9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe mw mx my mm b">split_once</code>方法根据传递的分隔符分割字符串。在我们的例子中，“/del 1”将作为<code class="fe mw mx my mm b">Some(("/del", "1"))</code>返回。然后，我开始解开这些值，并将它们存储在<code class="fe mw mx my mm b">cmd</code>和<code class="fe mw mx my mm b">msg</code>变量中。</p><p id="42c5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe mw mx my mm b">if cmd_split != None {</code></p><p id="1041" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这种相等性检查涵盖了没有空格的情况。在这种情况下，<code class="fe mw mx my mm b">split_once</code>方法返回None来标识分隔符" "不存在。</p><p id="7541" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我还是新手，觉得这个有点笨重。我怀疑可能有一个更好的方式来写这个，但现在它做的工作。我已经多次学会不要纠结于小细节，因为仅仅这一点就可能导致30分钟的兔子洞生锈文档。如果你有任何建议，欢迎在评论区分享。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a772" class="mq lf it mm b gy mr ms l mt mu">if cmd == "/del" {<br/>    let id = msg;<br/>    conn.execute("delete from notes where id = (?1)", [id])?;<br/>}</span></pre><p id="54cc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们现在检查输入文本的第一部分是不是<code class="fe mw mx my mm b">/del</code>，如果是，我们知道我们可以从<code class="fe mw mx my mm b">msg</code>变量中得到要删除的id。</p><p id="7a29" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe mw mx my mm b">"delete from notes where id = (?1)", [id]</code></p><p id="8f0b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是从notes表中删除与指定id匹配的行的SQL命令。</p><p id="c021" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你可以再次运行<code class="fe mw mx my mm b">cargo run</code>，现在尝试<code class="fe mw mx my mm b">/del 1</code>，它会删除你创建的第一条消息。您可以通过运行<code class="fe mw mx my mm b">/list</code>来确认它是否工作，并且您应该不会再看到索引为1的注释。</p><h1 id="29e5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">更新</h1><p id="8b49" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">对于如何进行更新，有几个选项。为了继续保持简单，我决定编辑应该作为一个命令发出。<code class="fe mw mx my mm b">/edit 1 the new body I want to have</code>。与删除类似，传递一个<code class="fe mw mx my mm b">id</code>来标识要编辑哪个注释。跟随在<code class="fe mw mx my mm b">id</code>之后的所有物体都被当作新物体来覆盖现有物体。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c912" class="mq lf it mm b gy mr ms l mt mu">else if cmd == "/edit" {<br/>    let msg_split = msg.split_once(" ").unwrap();<br/>    let id = msg_split.0;<br/>    let body = msg_split.1;</span><span id="2f17" class="mq lf it mm b gy mv ms l mt mu">    conn.execute("update notes set body = (?1) where id = (?2)", [body, id])?;<br/>}</span></pre><p id="ff29" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe mw mx my mm b">/edit</code>命令的启动类似于<code class="fe mw mx my mm b">/del</code>。主要的区别是我们需要再次用空白分割<code class="fe mw mx my mm b">msg</code>。使用<code class="fe mw mx my mm b">split_once</code>仅在第一个空白上分割，这允许主体保持完整。</p><p id="177c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe mw mx my mm b">"update notes set body = (?1) where id = (?2)", [body, id]</code></p><p id="13de" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个update命令指定我们将把<code class="fe mw mx my mm b">body</code>列设置为我们从输入中解析的内容，该输入包含与指定的<code class="fe mw mx my mm b">id</code>相匹配的<code class="fe mw mx my mm b">id</code>。</p><p id="9838" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe mw mx my mm b">(?1)</code>和<code class="fe mw mx my mm b">(?2)</code></p><p id="4ed1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这些表示位置参数。我们之前所有的SQL语句都只有一个，但是在这里有两个。<code class="fe mw mx my mm b">(?1)</code>将被所提供参数<code class="fe mw mx my mm b">[body, id]</code>(或本例中的<code class="fe mw mx my mm b">body</code>)中的第一个条目替换。<code class="fe mw mx my mm b">(?2)</code>将被<code class="fe mw mx my mm b">id</code>变量替换。</p><p id="31f1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">再次启动它，并尝试编辑您现有的笔记之一。您可以使用<code class="fe mw mx my mm b">/list</code>命令查看之前的注释，然后发出和<code class="fe mw mx my mm b">/edit</code>命令，最后发出另一个<code class="fe mw mx my mm b">/list</code>命令来确认注释被正确修改。</p><h1 id="4ef6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">安装您的Notes应用程序</h1><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="183a" class="mq lf it mm b gy mr ms l mt mu">cargo install --path .</span></pre><p id="b6dd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">运行以上程序将编译rust应用程序，并将其添加到您的系统路径中。如果您在开始时使用了<code class="fe mw mx my mm b">cargo new notes</code>命令，现在您应该可以从终端访问<code class="fe mw mx my mm b">notes</code>命令。如果您想更新可执行文件的名称，您可以修改<code class="fe mw mx my mm b">Cargo.toml</code>文件中的<code class="fe mw mx my mm b">name</code>属性来匹配您喜欢的名称。</p><p id="5929" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我已经开发了一个名为<code class="fe mw mx my mm b">engram</code>的notes应用程序，为了保持我的可执行文件名称简短，我将其简称为<code class="fe mw mx my mm b">eg</code>。现在，我在终端中的任何时候都可以输入<code class="fe mw mx my mm b">eg</code>并立即访问我的笔记。</p><h1 id="f1b2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">总结</h1><p id="dd96" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">如果您遵循了整个教程，现在您应该有一个用Rust编写的可以从终端访问的功能性notes应用程序。我将在此基础上继续写文章，但当我为engram的CLI应用程序构建新功能时，它们可能会是关于更具体的主题。</p></div></div>    
</body>
</html>