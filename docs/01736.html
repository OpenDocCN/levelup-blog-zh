<html>
<head>
<title>JavaScript Events Handlers — Mouse Enter and Leave Events</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript事件处理程序—鼠标进入和离开事件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-events-handlers-mouse-enter-and-leave-events-f04f6891828f?source=collection_archive---------8-----------------------#2020-01-26">https://levelup.gitconnected.com/javascript-events-handlers-mouse-enter-and-leave-events-f04f6891828f?source=collection_archive---------8-----------------------#2020-01-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0bad2d14ba6a95f7ba5246b7731ec65c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8uQHTiGbQIuDbnA9"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Bonnie Kittle 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="6a9a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中，事件是应用程序中发生的动作。它们是由各种事情触发的，比如输入、提交表单、调整大小等元素变化，或者应用程序运行时发生的错误等。我们可以分配一个事件处理器来处理这些事件。发生在DOM元素上的事件可以通过为相应事件的DOM对象的属性分配一个事件处理程序来处理。在本文中，我们将看看<code class="fe le lf lg lh b">mouseenter</code>和<code class="fe le lf lg lh b">mouseleave</code>事件。</p><h1 id="3dee" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">onmouseenter</h1><p id="ccff" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">当鼠标之类的定点设备移动到分配了<code class="fe le lf lg lh b">onmouseenter</code>事件监听器函数的元素上时，触发<code class="fe le lf lg lh b">mouseenter</code>事件。它类似于<code class="fe le lf lg lh b">mouseover</code>事件，但是<code class="fe le lf lg lh b">mouseenter</code>事件不会冒泡，当指针从一个元素的后代的物理空间移动到它自己的物理空间时，它不会被发送到后代。</p><p id="bfdd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着无论鼠标移动到另一个元素，无论它在层次结构中的位置如何，都会触发<code class="fe le lf lg lh b">mouseenter</code>事件。因此，<code class="fe le lf lg lh b">mouseenter</code>事件可能会被触发多次，这会导致严重的性能问题。如果当鼠标在一个有很多后代的大元素上时，我们需要监听整个元素树中的事件，那么最好使用<code class="fe le lf lg lh b">mouseover</code>事件。</p><p id="ea83" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当与鼠标离开元素时触发的<code class="fe le lf lg lh b">mouseleave</code>事件结合时，<code class="fe le lf lg lh b">mouseenter</code>事件的行为方式非常类似于CSS <code class="fe le lf lg lh b">:hover</code>伪类。</p><p id="7dc2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以使用它在图像上创建一个偷窥效果，当鼠标指针悬停在图像的一部分上时，我们显示图像的一部分。</p><p id="44b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们添加图像的HTML代码和隐藏图像的黑盒。此外，我们添加了一个circle div元素来显示我们所悬停的图像的一部分。为此，我们放入以下代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3271" class="mt lj it lh b gy mu mv l mw mx">&lt;div class='container'&gt;<br/>  &lt;div class="view" hidden&gt;&lt;/div&gt;<br/>  &lt;img src='<a class="ae kf" href="https://images.unsplash.com/photo-1503066211613-c17ebc9daef0?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1500&amp;q=80'" rel="noopener ugc nofollow" target="_blank">https://images.unsplash.com/photo-1503066211613-c17ebc9daef0?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1500&amp;q=80'</a>&gt;</span><span id="9130" class="mt lj it lh b gy my mv l mw mx">&lt;/div&gt;</span></pre><p id="ce96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">添加<code class="fe le lf lg lh b">.container</code> div是为了显示遮盖图像的黑盒。<code class="fe le lf lg lh b">.view</code> div是一个圆圈，当我们将鼠标悬停在它上面时，它会显示图像的一部分，而<code class="fe le lf lg lh b">img</code>元素则显示图像本身。</p><p id="2982" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们将CSS代码添加到样式<code class="fe le lf lg lh b">div</code>元素中，就像我们刚刚描述的那样，添加以下CSS代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="1444" class="mt lj it lh b gy mu mv l mw mx">.container {<br/>  background: black;<br/>  width: 500px;<br/>}</span><span id="9f2e" class="mt lj it lh b gy my mv l mw mx">.view {<br/>  position: absolute;<br/>  width: 200px;<br/>  height: 200px;<br/>  background: white;<br/>  border-radius: 50%;<br/>}</span><span id="3b2e" class="mt lj it lh b gy my mv l mw mx">img {<br/>  mix-blend-mode: darken;<br/>  width: 500px;<br/>}</span></pre><p id="5b26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们添加JavaScript代码来完成我们刚刚描述的工作:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9acd" class="mt lj it lh b gy mu mv l mw mx">const img = document.querySelector('img');<br/>const view = document.querySelector('.view');<br/>const container = document.querySelector('.container');</span><span id="9df4" class="mt lj it lh b gy my mv l mw mx">const showView = (event) =&gt; {<br/>  view.removeAttribute('hidden');<br/>  view.style.left = event.clientX - 50 + 'px';<br/>  view.style.top = event.clientY - 50 + 'px';<br/>  event.preventDefault();<br/>}</span><span id="dcbd" class="mt lj it lh b gy my mv l mw mx">const moveView = (event) =&gt; {<br/>  view.style.left = event.clientX - 50 + 'px';<br/>  view.style.top = event.clientY - 50 + 'px';<br/>}</span><span id="0eb3" class="mt lj it lh b gy my mv l mw mx">container.onmousemove = moveView;<br/>container.onmouseenter = showView;</span></pre><p id="8ad0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们通过使用<code class="fe le lf lg lh b">querySelector</code>方法获得了<code class="fe le lf lg lh b">.container</code>元素。我们对<code class="fe le lf lg lh b">img</code>和<code class="fe le lf lg lh b">.view</code>元素做了同样的处理。一旦我们这样做了，我们编写事件处理函数。</p><p id="a419" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">.container</code> <code class="fe le lf lg lh b">div</code>元素的<code class="fe le lf lg lh b">onmouseenter</code>属性被设置为<code class="fe le lf lg lh b">showView</code>函数，该函数在鼠标按钮按下时运行。在函数内部，我们从<code class="fe le lf lg lh b">.view</code> <code class="fe le lf lg lh b">div</code>元素中移除了<code class="fe le lf lg lh b">hidden</code>属性，以显示<code class="fe le lf lg lh b">div</code>下面的图像。从拥有<code class="fe le lf lg lh b">Event</code>对象的<code class="fe le lf lg lh b">event</code>参数中，我们获得了<code class="fe le lf lg lh b">clientX</code>和<code class="fe le lf lg lh b">clientY</code>属性，它们拥有点击位置的鼠标坐标。我们将其设置为代表<code class="fe le lf lg lh b">.view</code>元素的<code class="fe le lf lg lh b">view</code> DOM对象的位置。然后我们调用<code class="fe le lf lg lh b">event.preventDefault()</code>来停止默认动作，因为我们已经用它之前的代码进行了揭示。</p><p id="dfdd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">.container</code> <code class="fe le lf lg lh b">div</code>元素的<code class="fe le lf lg lh b">onmousemove</code>事件处理程序被设置为<code class="fe le lf lg lh b">moveView</code>函数，该函数处理<code class="fe le lf lg lh b">mousemove</code>事件。当鼠标移动时触发该事件。在函数中，我们将<code class="fe le lf lg lh b">.view</code>元素设置为鼠标指针当前所在的位置，同样使用<code class="fe le lf lg lh b">event</code>参数的<code class="fe le lf lg lh b">clientX</code>和<code class="fe le lf lg lh b">clientY</code>属性，该参数是<code class="fe le lf lg lh b">MouseEvent</code>对象。</p><p id="a8c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们做了所有这些，当我们将鼠标悬停在黑盒上时，我们就会显示下面的那部分图像。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/c129a5282132215b6464f50905984925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u4VFKD4FQzkWL5YK"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@moyathebunny?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">陈天鹅</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h1 id="9c4d" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">onmouseleave</h1><p id="6208" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">DOM元素的<code class="fe le lf lg lh b">onmouseleave</code>属性让我们分配一个事件处理程序来处理<code class="fe le lf lg lh b">mouseleave</code>事件。当鼠标之类的定点设备从附加了侦听器的元素上移开时，将触发该事件。</p><p id="8a7d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着无论鼠标移动到另一个元素，无论它在层次结构中的位置如何，都会触发<code class="fe le lf lg lh b">mouseleave</code>事件。因此，<code class="fe le lf lg lh b">mouseleave</code>事件可能会被触发多次，这会导致严重的性能问题。如果当鼠标停留在一个有很多后代的大元素上时，我们需要监听整个元素树中的事件，那么最好使用<code class="fe le lf lg lh b">mouseout</code>事件。</p><p id="483a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以用它来跟踪鼠标是否在一个元素上。首先，我们添加一个HTML div元素，就像我们在下面的代码中做的那样:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="eb8d" class="mt lj it lh b gy mu mv l mw mx">&lt;div id='log'&gt;</span><span id="ff11" class="mt lj it lh b gy my mv l mw mx">&lt;/div&gt;</span></pre><p id="a2e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们添加一些CSS在div上添加一个边框并调整它的大小:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="83fe" class="mt lj it lh b gy mu mv l mw mx">#log {<br/>  width: 300px;<br/>  height: 150px;<br/>  border: 1px solid black;<br/>}</span></pre><p id="044c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们可以添加以下JavaScript代码，根据鼠标是否在<code class="fe le lf lg lh b">log</code> div上来设置不同的文本:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="63ad" class="mt lj it lh b gy mu mv l mw mx">const log = document.getElementById('log');<br/>log.onmouseover = () =&gt; {<br/>  log.textContent = 'Mouse over'<br/>}</span><span id="5b40" class="mt lj it lh b gy my mv l mw mx">log.onmouseleave = () =&gt; {<br/>  log.textContent = 'Mouse left'<br/>}</span></pre><p id="00ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们这样做了，当我们的鼠标在盒子上时，我们应该在盒子里看到“鼠标在上面”的消息，当我们的鼠标指针离开盒子时，我们应该看到“鼠标离开”的消息。</p><p id="795e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe le lf lg lh b">mouseleave</code>事件的另一个例子是根据鼠标是否在图像元素上来显示不同的图像。我们只需像在下面的代码中那样更改HTML:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7c76" class="mt lj it lh b gy mu mv l mw mx">&lt;img src='<a class="ae kf" href="https://images.unsplash.com/photo-1503066211613-c17ebc9daef0?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1500&amp;q=80'" rel="noopener ugc nofollow" target="_blank">https://images.unsplash.com/photo-1503066211613-c17ebc9daef0?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1500&amp;q=80'</a>&gt;</span></pre><p id="4168" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们将CSS更改为以下内容:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="5829" class="mt lj it lh b gy mu mv l mw mx">img {<br/>  width: 300px;<br/>}</span></pre><p id="2aa1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，在JavaScript代码中，我们更改了<code class="fe le lf lg lh b">onmouseover</code>和<code class="fe le lf lg lh b">onmouseleave</code>事件处理函数中<code class="fe le lf lg lh b">img</code>元素的<code class="fe le lf lg lh b">src</code>，就像我们在下面的代码中所做的那样:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="260e" class="mt lj it lh b gy mu mv l mw mx">const img = document.querySelector('img');<br/>img.onmouseover = () =&gt; {<br/>  img.src = '<a class="ae kf" href="https://images.unsplash.com/photo-1503066211613-c17ebc9daef0?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1500&amp;q=80'" rel="noopener ugc nofollow" target="_blank">https://images.unsplash.com/photo-1503066211613-c17ebc9daef0?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1500&amp;q=80'</a><br/>}</span><span id="d483" class="mt lj it lh b gy my mv l mw mx">img.onmouseleave = () =&gt; {<br/>  img.src = '<a class="ae kf" href="https://images.unsplash.com/photo-1546182990-dffeafbe841d?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=740&amp;q=80'" rel="noopener ugc nofollow" target="_blank">https://images.unsplash.com/photo-1546182990-dffeafbe841d?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=740&amp;q=80'</a><br/>}</span></pre><p id="0cac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后，当我们将鼠标悬停或离开<code class="fe le lf lg lh b">img</code>元素时，我们将得到不同的图像。</p><p id="25fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当鼠标等定点设备移动到分配了<code class="fe le lf lg lh b">onmouseenter</code>事件监听器函数的元素上时，触发<code class="fe le lf lg lh b">mouseenter</code>事件。它类似于<code class="fe le lf lg lh b">mouseover</code>事件，但是<code class="fe le lf lg lh b">mouseenter</code>事件不会冒泡，并且当指针从元素的一个后代的物理空间移动到它自己的物理空间时，它不会被发送到后代。</p><p id="ba9b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">DOM元素的<code class="fe le lf lg lh b">onmouseleave</code>属性让我们分配一个事件处理程序来处理<code class="fe le lf lg lh b">mouseleave</code>事件。当鼠标之类的定点设备从附加了侦听器的元素上移开时，将触发该事件。</p><p id="18ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以为这两个事件使用事件处理函数来做各种事情，比如当鼠标指针在某物上或不在某物上时显示或隐藏项目。</p></div></div>    
</body>
</html>