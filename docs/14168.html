<html>
<head>
<title>Measuring Software Modularity — Part 1: Cohesion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测量软件模块化—第1部分:内聚性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/measuring-software-modularity-part-1-cohesion-127de06a4c0d?source=collection_archive---------18-----------------------#2022-11-06">https://levelup.gitconnected.com/measuring-software-modularity-part-1-cohesion-127de06a4c0d?source=collection_archive---------18-----------------------#2022-11-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3e8473a7a745fe0e8699bf4e12d8e2c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gppY7ofj52DYQz1G"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/ja/@chelsea777?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">佐佐木小次郎</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="2b90" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">模块化是优秀软件设计的必备条件。它有助于扩展性、可读性、可维护性等等。让你的代码模块化当然不容易，但是到底什么是模块化，我们如何度量它？</p><h1 id="c183" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">定义</h1><p id="76cf" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">模块化描述了相关代码的逻辑分组，可以是一组类或函数。[1]</p><p id="22be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">模块化衡量你的代码被分成不同的模块或功能块的程度。你的代码越模块化，就越容易改变。让你的代码模块化不是目的，而是达到目的的一种手段:你想让其他人(包括你自己)更容易理解你的代码做什么以及它是如何工作的。</p><h2 id="a9f5" class="mh lf it bd lg mi mj dn lk mk ml dp lo kr mm mn ls kv mo mp lw kz mq mr ma ms bi translated">边注</h2><p id="458f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">以前，我写过关于<a class="ae kf" href="https://softwarengineer.substack.com/p/how-to-stand-out-as-a-software-engineer" rel="noopener ugc nofollow" target="_blank">如何成为一名优秀的软件工程师的文章，</a>，我认为在编写代码时考虑模块化会让你从一大群工程师中脱颖而出。</p><h1 id="4b23" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">我们如何衡量模块化？</h1><p id="3d5b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有很多有用的度量标准来衡量模块化。在这个系列中，我将尽力帮助您理解<em class="mt">内聚、耦合和共生。</em></p><p id="4686" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这部分将重点介绍<strong class="ki iu"> <em class="mt">衔接</em> </strong>，我们开始吧。</p><h1 id="3d73" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">内聚力</h1><p id="a0c0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在《软件架构基础》一书中，Mark Richards和Neal Ford定义了什么是内聚模块。</p><blockquote class="mu mv mw"><p id="af7d" class="kg kh mt ki b kj kk kl km kn ko kp kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated"><em class="it">内聚模块是指所有部分都应该打包在一起的模块，因为将它们分解成更小的部分需要通过模块之间的调用将这些部分耦合在一起以获得有用的结果。[1] </em></p></blockquote><p id="9b2e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们从一个简单的类示例开始</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="6488" class="mh lf it nf b gy nj nk l nl nm">class C:<br/>  def __init__(self):<br/>    self.a = 1<br/>    self.b = 2</span><span id="f5db" class="mh lf it nf b gy nn nk l nl nm">  def do_a(self):<br/>    func(self.a)</span><span id="7e7f" class="mh lf it nf b gy nn nk l nl nm">  def do_b(self):<br/>    func(self.b)</span></pre><p id="9a96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以上类是<strong class="ki iu"> <em class="mt">不衔接</em> </strong>。<em class="mt">为什么？<br/> </em>因为它的功能可以分成两个独立的类而不影响结果。</p><p id="0796" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了让这个类具有内聚性，我们可以把它拆分成两个不包含对某些方法过度的变量的类(变量a对方法do_b过度，变量b对方法do_a过度)。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="394f" class="mh lf it nf b gy nj nk l nl nm">class A:<br/>  def __init__(self):<br/>    self.a = 1</span><span id="7b26" class="mh lf it nf b gy nn nk l nl nm">  def do_a(self):<br/>    func(self.a)<br/></span><span id="e2a9" class="mh lf it nf b gy nn nk l nl nm">class B:<br/>  def __init(self):<br/>    self.b = 2</span><span id="8ec7" class="mh lf it nf b gy nn nk l nl nm">  def do_b(self):<br/>    func(self.b)</span></pre><p id="032a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子的基础上，我们可以用图表来说明这一点。<br/>考虑一个类，它的所有方法和变量都将是顶点。如果M1使用V1，在方法顶点M1和变量顶点V1之间有一条边。</p><p id="26ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，考虑这个场景，我们在一个类中有5个方法和5个变量。</p><ul class=""><li id="37ea" class="no np it ki b kj kk kn ko kr nq kv nr kz ns ld nt nu nv nw bi translated">方法1仅使用变量1</li><li id="967a" class="no np it ki b kj nx kn ny kr nz kv oa kz ob ld nt nu nv nw bi translated">方法2同时使用变量2和变量5</li><li id="eacf" class="no np it ki b kj nx kn ny kr nz kv oa kz ob ld nt nu nv nw bi translated">方法3仅使用变量3</li><li id="aaa1" class="no np it ki b kj nx kn ny kr nz kv oa kz ob ld nt nu nv nw bi translated">方法4仅使用变量4</li><li id="9256" class="no np it ki b kj nx kn ny kr nz kv oa kz ob ld nt nu nv nw bi translated">方法5只使用变量5</li></ul><p id="fb2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上面的场景中，我们可以生成下图</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/e54eb4da5c4bd8478388886a7ba7f4af.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/0*fK1zbviv3GkVvbYB.png"/></div></figure><p id="a0ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以认为这个类<strong class="ki iu"><em class="mt"/></strong>是非内聚的，因为大多数方法可以分成不同的类，就像我们在第一个代码示例中所做的那样。(例如，方法1不使用变量2-5，因此将它们放在同一个类中没有好处)</p><p id="ce3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相比之下，<strong class="ki iu"> <em class="mt">一个内聚类</em> </strong>就会有一个图以远<em class="mt"/><strong class="ki iu"><em class="mt"/></strong>为例</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/bff7d00765ed3ffb0b99c00340e33398.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/0*xBA3wgWyBxYSig6_.png"/></div></figure><p id="f3a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更多的边意味着每种方法使用更多的变量，分割更困难/效率更低/不可能。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h1 id="d5d7" class="le lf it bd lg lh ok lj lk ll ol ln lo lp om lr ls lt on lv lw lx oo lz ma mb bi translated">我们如何衡量凝聚力？</h1><p id="b022" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在我们对内聚的含义有了一个粗略的概念，让我们来形式化我们如何度量它。</p><blockquote class="mu mv mw"><p id="0050" class="kg kh mt ki b kj kk kl km kn ko kp kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated">给定n个<em class="it">方法</em> M1，M2，…，Mn <em class="it">包含在一个类</em> C1 <em class="it">中，该类还包含一组实例变量</em> { Ai } <em class="it">。那么对于任何方法</em> Mi <em class="it">我们可以定义</em>的划分集</p><p id="2a4b" class="kg kh mt ki b kj kk kl km kn ko kp kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated">P = {(Ai，Aj) | Ai ∩ Aj = φ} <br/> Q = {(Ai，Aj) | Ai ∩ Aj ≠ φ}</p><p id="6bcd" class="kg kh mt ki b kj kk kl km kn ko kp kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated"><em class="it">那么LCOM = |</em>P<em class="it">|—|</em>Q<em class="it">|，if |</em>P<em class="it">|&gt;|</em>Q<em class="it">|</em></p><p id="9e75" class="kg kh mt ki b kj kk kl km kn ko kp kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated"><em class="it"> =0否则</em></p><p id="a38e" class="kg kh mt ki b kj kk kl km kn ko kp kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated"><em class="it"> LCOM是相似度为零的方法对的计数。[2] </em></p></blockquote></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="2d4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们用两个图表例子来分解这个定义。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/1ea991f661997999f6d86f4c6d5bd2df.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/0*yzXTTV9UHxskOmB3.png"/></div></figure><p id="786d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">A1 = { V1 } <br/> A2 = { V2，V5 }<br/>A3 = { V3 }<br/>A4 = { V4 }<br/>A5 = { V5 }</p><p id="ff80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">A5 <em class="mt"> ∩ </em> A2 = { V2} <br/>和所有其他交集产生空集，意思是:<br/> |P| = 9，|Q| = 1 <br/> LCOM = 8</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/f86a3451bb78d2b50c1dcf997eb7bff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/0*LemY6G9Ovhr9BJm3.png"/></div></figure></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="ad0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">A1 = { V1，V3，V4 } <br/> A2 = { V2，V5 } <br/> A3 = { V2，V3 } <br/> A4 = { V4，V5 } <br/> A5 = { V1，V5 }</p><p id="ff77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">|P| = 3，|Q| = 7 <br/> LCOM = 0</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><blockquote class="mu mv mw"><p id="385e" class="kg kh mt ki b kj kk kl km kn ko kp kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated">LCOM = 0表示一个内聚类。</p><p id="c204" class="kg kh mt ki b kj kk kl km kn ko kp kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated">LCOM &gt; 0表示该类需要或可以分成两个或更多个类，因为它的变量属于不相交的集合。[2]</p></blockquote><p id="c242" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上面的例子我们可以理解，一个类/模块的内聚性是一个梯度，不一定是一个是/否的问题。</p><p id="e6f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数情况下，为了有效地使用这个度量，你要为内聚性设置一个阈值——例如，如果LCOM &gt; 20，我们认为这个类是非内聚性的，否则这个类是内聚性的。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h1 id="455f" class="le lf it bd lg lh ok lj lk ll ol ln lo lp om lr ls lt on lv lw lx oo lz ma mb bi translated">结束语</h1><p id="1517" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">最后，我想说，我希望你有一个啊哈的时刻，并且更好地理解了凝聚力意味着什么以及它是如何衡量的。</p><p id="5d83" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在接下来的几周里，我将发布本系列的下一部分，其中将涵盖更多的软件模块化度量，如耦合和共生。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="995a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我最近开始在<a class="ae kf" href="https://softwarengineer.substack.com/" rel="noopener ugc nofollow" target="_blank"> substack </a>上写博客，如果你订阅了软件上的<a class="ae kf" href="https://softwarengineer.substack.com/" rel="noopener ugc nofollow" target="_blank">，给工程师</a>(完全免费)，我会很感激你的支持。</p><div class="op oq gp gr or os"><a href="https://eliran9692.medium.com/membership" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">通过我的推荐链接加入Medium-Eliran turge man</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">阅读Eliran Turgeman(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">eliran9692.medium.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg jz os"/></div></div></a></div></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h1 id="1cba" class="le lf it bd lg lh ok lj lk ll ol ln lo lp om lr ls lt on lv lw lx oo lz ma mb bi translated">参考</h1><p id="56e9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">[1] <a class="ae kf" href="https://www.oreilly.com/library/view/fundamentals-of-software/9781492043447/" rel="noopener ugc nofollow" target="_blank">软件架构基础</a>，作者Mark Richards，Neal Ford</p><p id="af7b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[2]齐丹博，s，r，凯梅勒，c，k，面向对象设计的度量套件，<em class="mt"> IEEE Trans .论软件工程。【1994年6月第20卷第6期。</em></p></div></div>    
</body>
</html>