<html>
<head>
<title>5 Advanced Features of FastAPI You Should Try</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您应该尝试的FastAPI的5个高级特性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-advance-features-of-fastapi-you-should-try-7c0ac7eebb3e?source=collection_archive---------0-----------------------#2022-01-17">https://levelup.gitconnected.com/5-advance-features-of-fastapi-you-should-try-7c0ac7eebb3e?source=collection_archive---------0-----------------------#2022-01-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="169f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">挂载应用程序、API路由器、Jinja模板等等</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8f4ced2de8a4aead7c6379baf3c28415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pnNqIgirhBugTG6a"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@chanderr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Chander R </a>拍摄的照片</figcaption></figure><h1 id="78ec" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="8a5c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">FastAPI是用Python开发的现代web框架。最近它吸引了很多人。它的开发结构与Flask非常相似，Flask是任何使用Python开始web开发的人事实上的选择。FastAPI易于使用，它的文档写得很好，很容易理解。</p><p id="5e19" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">FastAPI提供了API构建工具的所有标准特性，但并不局限于此。它带来了很多灵活性，比如向后的WSGI挂载支持，而大多数用户并没有意识到这一点。</p><p id="9fdf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在本文中，我将介绍FastAPI的一些高级特性，我在最近的项目中一直在使用这些特性。另外，<em class="mp">下面的用例假设你对FastAPI </em>有基本的了解。</p><h2 id="acdf" class="mq kx iq bd ky mr ms dn lc mt mu dp lg lx mv mw li mb mx my lk mf mz na lm nb bi translated">1.包括Flask、Django、Dash或任何其他WSGI</h2><p id="c17d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">FastAPI是一个ASGI web框架。这意味着不同的请求不必等待其他请求完成它们的任务。不同的请求可以不按特定的顺序完成它们的任务。另一方面，WSGI框架以连续的方式处理请求。</p><p id="c9e1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">FastAPI允许任何类型的WSGI应用程序(如Flask)安装在FastAPI应用程序中。这意味着在根级别上，您可以拥有主FastAPI应用程序，此外，对于不同的路由，您可以拥有WSGI应用程序，如Flask，它将处理该特定路径的所有请求。</p><p id="ce22" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我在项目中使用的一个用例是将plotly-dash安装为WSGI中间件。我已经为我的网站的仪表板路径安装了dash服务器，它将仪表板逻辑与主要的FastAPI应用程序隔离开来。这还提供了在服务器负载增加时禁用仪表板的灵活性。这是我为其中一个项目做的WSGI中间件挂载的抽象实现。</p><p id="5345" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">以下是dashboard.py文件的示例内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Plotly dash服务器代码</figcaption></figure><p id="2ecd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要将这个dash服务器作为一个独立的应用程序包含在FastAPI中，只需将WSGI应用程序对象包装在WSGIMiddleware类中，并将这个包装的对象作为参数传递到根FastAPI对象的mount函数中。mount函数还接收应该使用该应用程序的路径。例如，该仪表板将安装在“/仪表板”路径上。请参见下面main.py文件的内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">用于在FastAPI中安装plotly-dash服务器的main.py文件</figcaption></figure><p id="db0d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果有人访问仪表板路由，所有这些请求都会被临时重定向到dash服务器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/56c01542963c3548bbbda6d4ff94f61e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zBrePwS3q5K5ZJ02LXds7Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">我的项目中的示例日志，每当有人访问仪表板路由时，它会被重定向到Dash服务器</figcaption></figure><blockquote class="nf ng nh"><p id="3389" class="lo lp mp lq b lr mk jr lt lu ml ju lw ni mm lz ma nj mn md me nk mo mh mi mj ij bi translated">链接到我的项目，该项目由FastAPI支持，使用了本文中解释的所有概念:<a class="ae kv" href="https://ipuresultskg.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">https://ipuresultskg.herokuapp.com/</a>。这是我为我的大学开发的一个结果门户。用我的报名号体验网址:43114803118(2018批次)</p></blockquote><h2 id="5ebb" class="mq kx iq bd ky mr ms dn lc mt mu dp lg lx mv mw li mb mx my lk mf mz na lm nb bi translated">2.为不同的路线安装不同的FastAPI应用程序</h2><p id="0e4d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">遵循为不同的路由挂载不同的WSGI应用程序的相同规则，您还可以在FastAPI应用程序中挂载不同的FastAPI应用程序。这意味着每个sub-FastAPI应用程序都有自己的文档，独立于其他应用程序运行，并处理特定于路径的请求。要安装它，只需创建一个主应用程序和子应用程序文件。现在，将app对象从子应用程序文件导入主应用程序文件，并将该对象直接传递给主应用程序对象的mount函数。这种变通方法不需要任何中间件。请参见下面的示例:</p><p id="8912" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">apiv1.py文件(子应用程序1)的内容如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">子应用程序1的代码</figcaption></figure><p id="db9b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下面是apiv2.py文件(子应用程序2)的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">子应用程序2的代码</figcaption></figure><p id="c901" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，我们可以在主应用程序中挂载这两个子应用程序。查看master.py文件的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">安装两个子应用程序的主应用程序代码</figcaption></figure><p id="933a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果您向各自的路径端点发出请求，该请求将由这些子应用程序处理。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/0775f3250de11dd0b9aa93fcfda774f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*O_9j7PVPApPr0FKk0o70MQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">这里，两个请求都由各自的应用程序提供服务</figcaption></figure><h2 id="b660" class="mq kx iq bd ky mr ms dn lc mt mu dp lg lx mv mw li mb mx my lk mf mz na lm nb bi translated">3.将FastAPI路由分离到不同的文件中</h2><p id="2ad0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">随着您的应用程序变得越来越大，在一个地方管理所有的路由会变得一团糟。有时，可能会发生重叠，或者您可能会在不知道后果的情况下复制一条路线。如果有一个系统可以将您的路由分组到不同的文件结构中并轻松管理它们，会怎么样？</p><p id="76cf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">FastAPI有一个APIRouters系统。这些可以被认为是迷你的FastAPI应用程序，<strong class="lq ir">是更大的应用程序</strong>的一部分。这意味着可以将较大的应用程序路由分成小的APIRouters单元，并在主应用程序中安装单独的APIRouters。</p><p id="cb83" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="mp">请注意，这些APIRouters是更大的应用程序的一部分，而不是像我们在上面两节中看到的那些独立的应用程序。因此，来自所有APIRouters的所有路由都将在主应用程序文档中列出。</em></p><p id="045f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这些APIRouters可以对路径操作、标签、依赖性和响应使用单独的前缀。因此，要实现这一点，您需要从FastAPI导入APIRouter类，然后使用它的对象来创建路由，就像在普通的fast API应用程序中一样。</p><p id="d49b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们看一个例子。假设我们正在构建一个图书馆管理系统，我们想要分别处理书籍和小说数据。让这成为book.py文件的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">book.py中的APIRouter用法</figcaption></figure><p id="4f29" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是novel.py文件的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">APIRouter在novel.py中的用法</figcaption></figure><p id="91c4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，要在主应用程序中包含这两个路由器，只需导入APIRouter的对象，并在主FastAPI应用程序对象的include_router函数中传递它们。我们还将为这些路由器添加前缀，以便两台路由器中的相同端点不会发生冲突。请参见下面的实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在主应用程序中包含APIRouters的代码</figcaption></figure><p id="e6ce" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果您点击“/book/info”和“/novel/info”端点，您将得到不同的响应，这取决于您在APIRouters中如何处理这些输入。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/2065881aa0d21d4d8fa6870da23b4027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hCp77Kpjj9G5DZF_2jwtXg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">预订APIRouter端点(截图来自FastAPI文档)</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/7a9e2345da98bb317b9d17872fa3982c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HT68T6JPuM17sph1FEua2g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">新颖的APIRouter端点(截图来自FastAPI文档)</figcaption></figure><p id="ac90" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通过这种方式，您可以拥有多个APIRouters来处理参数，这些参数基于您想要为这些端点组执行的操作类型。</p><h2 id="60e5" class="mq kx iq bd ky mr ms dn lc mt mu dp lg lx mv mw li mb mx my lk mf mz na lm nb bi translated">4.添加静态文件和Jinja模板</h2><p id="e332" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">FastAPI不仅限于作为创建API的框架。你可以提供静态文件，如HTML，CSS，JS，并加入Jinja模板引擎，就像你在Flask中做的那样。这意味着你可以用FastAPI托管一个完整的网站。</p><p id="1062" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我把这个和烧瓶联系起来。在flask框架中，您需要有一个名为“templates”的文件夹，其中可以有所有带有Jinja模板的HTML文件(<em class="mp">如果您希望我创建一篇关于Jinja模板引擎</em>的详细文章，请在评论中告诉我)，在主应用程序中，您可以直接使用Flask的render_template函数返回这些模板，并在这些模板中填充数据。</p><p id="15d0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在FastAPI中，在抽象层次上，过程保持不变，但变化很少。逐步过程:-</p><ol class=""><li id="84d3" class="no np iq lq b lr mk lu ml lx nq mb nr mf ns mj nt nu nv nw bi translated">首先，您需要为Jinja模板创建一个对象，其中需要指定templates文件夹的路径。在FastAPI中，对文件夹名称没有限制，您可以给它起任何名字。您只需要在这里提供文件夹路径。从技术上讲，您需要从快速API模板模块导入Jinja2Templates类，并使用文件夹路径为该类创建一个对象。</li><li id="1c3f" class="no np iq lq b lr nx lu ny lx nz mb oa mf ob mj nt nu nv nw bi translated">接下来，您需要在FastAPI route方法(例如:GET，POST)中提供response_class作为HTMLResponse类。这个类可以从快速API响应模块导入。此外，您需要在装饰函数中创建一个“request”类类型的请求参数。这个类可以从fast API模块导入。</li><li id="6652" class="no np iq lq b lr nx lu ny lx nz mb oa mf ob mj nt nu nv nw bi translated">为了在到达各自的端点时向这些模板呈现和提供数据，需要返回Jinja2Templates类对象“TemplateResponse”函数。这个函数接受HTML模板名和上下文字典。上下文字典必须有“request”键，其值作为您在装饰函数中创建的请求参数。要发送到Jinja模板的数据可以作为键-值对添加到这个上下文字典中。</li></ol><p id="59a2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下面是上述步骤的代码实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在FastAPI中演示Jinja模板用法的代码</figcaption></figure><p id="d4cb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，在HTML模板中，您可以按照Jinja引擎的语法填充变量，并将名称用作上下文字典中的键。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="3c40" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">启动FastAPI应用程序，您将得到以下输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/bea20591cebabcee47666a9abbee2443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*33Flio3aiRLWnCG7JZH2fQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">带有FastAPI代码的Jinja模板的输出</figcaption></figure><p id="2c40" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要在HTML中包含所有的图像、JS和CSS文件，在Flask中，您可以使用url_for并提供文件夹名“static ”,后跟filename参数。在FastAPI中，这个过程更容易。简单来说，</p><ol class=""><li id="d2f1" class="no np iq lq b lr mk lu ml lx nq mb nr mf ns mj nt nu nv nw bi translated">从fast API静态文件模块为StaticFiles类创建一个对象，并提供静态文件的文件夹路径。同样，对文件夹名称没有限制。</li><li id="495c" class="no np iq lq b lr nx lu ny lx nz mb oa mf ob mj nt nu nv nw bi translated">将这个静态文件对象挂载到其中一个路径，最好是“static ”,以避免混淆，并为这个挂载提供一个名称，供FastAPI内部使用。</li></ol><p id="e3fe" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我在用于Jinja文件服务的相同代码中添加了静态文件的逻辑:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="353a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，假设您有一个图像“img1.png ”,您希望将它包含在HTML文件中。简单地说，在img标记的src属性中，使用如下路径:</p><p id="8088" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe od oe of og b">/&lt;path_on_which_static_files_are_mounted&gt;/&lt;image_directory&gt;/&lt;image_name&gt;</code></p><p id="5e89" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="mp">(此处图片目录取决于你的文件结构)</em></p><p id="f9e2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下面是上面使用的带有图像标签的Jinja模板HTML文件的更新代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="4818" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们将得到这样的输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/b38ee6cf0989786795ea7142a1976660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8BNecJyI0WInK__5dvgKLg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">包含静态文件的FastAPI网页</figcaption></figure><p id="bac7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这样，你就可以把所有的文件加起来，创建一个由FastAPI支持的成熟的网站。</p><h2 id="d186" class="mq kx iq bd ky mr ms dn lc mt mu dp lg lx mv mw li mb mx my lk mf mz na lm nb bi translated">5.在FastAPI应用程序中模拟烧瓶的配置处理</h2><p id="5085" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果你使用Flask web框架已经有一段时间了，你必须了解应用程序的配置。您可以为应用程序定义一些参数，供应用程序的任何部分访问。这些通常包括环境变量。config属性是字典数据结构的子类，驻留在Flask类对象中。所有的配置都存储在这里。当您想对应用程序的某些部分进行硬编码并在应用程序中的任何地方调用它们时，这尤其有用。</p><p id="f3e4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是您在Flask中定义此类配置参数要做的事情:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">演示Flask中应用程序配置的代码</figcaption></figure><p id="a4cd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">FastAPI没有这种支持。虽然你们中的一些人可能认为在这种情况下可以使用应用程序状态，但是根据T<a class="ae kv" href="https://github.com/tiangolo/fastapi/issues/508#issuecomment-584245852" rel="noopener ugc nofollow" target="_blank">iangolo(FastAPI的创建者)的建议</a>，APIRouter不能访问这种状态。因此，即使您在应用程序状态中保存了一些配置，这些配置也不会在应用程序的所有部分之间共享，最终也没有任何用途。</p><p id="e56e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因此，Tiangolo提出了一个简单的解决方法，即使用Pydantic BaseSettings类并为这些设置创建一个模型。这个类提供了验证功能和类型注释。这些特性使它们不同于通常的环境变量，在通常的环境变量中，它们只能处理字符串类型的值。</p><p id="b41c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要将这些放在FastAPI应用程序中，只需从Pydantic导入BaseSettings类，并为您的设置/配置创建子类。这些是Pydantic类，因此，您可以添加默认值、Field()等等。让我给你一个例子来实现这一点。</p><p id="90a9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">以下是config.py文件的内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">演示Pydantic BaseSettings的代码</figcaption></figure><p id="a919" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这里，我将openapi_url定义为一个空字符串。它将禁用FastAPI应用程序的文档生成。在主应用程序文件中，为配置模型创建一个对象，并像在字典类型数据结构中一样访问参数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">演示如何访问设置参数的代码</figcaption></figure><p id="3c4d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这就是如何将该模型用作应用程序的全局配置。它还消除了FastAPI对配置应用程序其他部分的依赖性。</p><h1 id="c248" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">尾注</h1><p id="a63c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这些都是我在开发项目时遇到的FastAPI的高级用例。尽管文档是了解这些概念的最佳方式，但我还是尝试提供了一个更广泛、更实用的场景来应用这些概念。FastAPI高级用例不限于本文中讨论的那些。这是一个惊人的框架，正在慢慢占领整个科技行业。</p><blockquote class="nf ng nh"><p id="8f00" class="lo lp mp lq b lr mk jr lt lu ml ju lw ni mm lz ma nj mn md me nk mo mh mi mj ij bi translated">如果你想阅读/探索我的每一篇文章，那就去我的<a class="ae kv" href="https://medium.com/@kaustubhgupta1828/all-my-articles-under-one-hood-f1ab2e5eac89" rel="noopener">大师文章列表</a>，它会在我每次在任何平台上发表新文章时更新！</p></blockquote><p id="1a2d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="mp">对于</em> <strong class="lq ir"> <em class="mp">的任何疑惑、疑问，或者潜在的机会</em> </strong> <em class="mp">，您都可以通过</em>联系我</p><div class="oi oj gp gr ok ol"><a href="https://www.linkedin.com/in/kaustubh-gupta" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">Kaustubh Gupta -数据科学NLP分析师实习生-浪子| LinkedIn</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">你好，我是一名对数据分析感兴趣的Python开发人员，正在成为一名数据工程师的路上…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">www.linkedin.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz kp ol"/></div></div></a></div><p id="ae28" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">上一篇文章:</strong></p><div class="oi oj gp gr ok ol"><a href="https://medium.com/geekculture/why-does-this-website-show-no-source-code-a8bd5892d754" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">为什么这个网站显示没有源代码？</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">解释为什么therickroll.com不显示任何源代码</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="pa l ow ox oy ou oz kp ol"/></div></div></a></div></div></div>    
</body>
</html>