<html>
<head>
<title>Learn React Native Animation by Building Circular Progress Bar</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过构建圆形进度条学习反应本地动画</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learn-react-native-animation-by-building-circular-progress-bar-b22258f9db03?source=collection_archive---------10-----------------------#2019-12-10">https://levelup.gitconnected.com/learn-react-native-animation-by-building-circular-progress-bar-b22258f9db03?source=collection_archive---------10-----------------------#2019-12-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2f77b4c61a15ddb83d3fdea09b63a3b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lcPZ9Z1qY0YdxP6UCrUl4A.png"/></div></div></figure><p id="e80e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">今天我们要用React Native的<code class="fe kz la lb lc b">Animated</code>库和<em class="ld">三个半圆</em>来构建一个圆形进度条。让我们先理解概念，然后我们将深入编码。</p><h1 id="a6bf" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">概念</h1><p id="75e9" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">我们有一个基本的外圆，作为其他三个半圆的容器。我们将使用<code class="fe kz la lb lc b">transform</code>属性旋转这些半圆，以获得想要的结果。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/9d8d58a24ce307464afffdda96e04d6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/0*Fd2j8M3mxN29gCPv.png"/></div></figure><h1 id="8016" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">三个圈子是怎么运作的？</h1><p id="01f2" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">他们的状态取决于进步的价值。它可以小于或大于50。让我们看看两种可能的情况:</p><h1 id="aad1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">案例一。如果进度百分比&lt; 50</h1><h2 id="a27e" class="mm lf it bd lg mn mo dn lk mp mq dp lo km mr ms ls kq mt mu lw ku mv mw ma mx bi translated">1. First Circle</h2><p id="baa2" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">The first circle (purple) is initialized with a rotation of 180 degrees and completely covers the right portion of the outer base circle (grey).</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/2abf93d8009836494cc23633fc780458.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/0*EezedjYQbCx2oFRD.png"/></div></figure><h2 id="f4d9" class="mm lf it bd lg mn mo dn lk mp mq dp lo km mr ms ls kq mt mu lw ku mv mw ma mx bi translated">2. Second Circle</h2><p id="c226" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">The second circle is rendered on top of the first circle (purple) with the same rotation and  【T2】  equal to the outer base circle (grey). It makes the first circle disappear as grey color completely overshadows the inner purple circle.</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/19265d0ef37d655118ee04a16534bfad.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/0*Nfak6BZTI1hvxF6P.png"/></div></figure><blockquote class="my mz na"><p id="6d7e" class="kb kc ld kd b ke kf kg kh ki kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ky im bi translated"><em class="it">我已经减少了上面(灰色)圆圈的不透明度，以显示下面正在发生的事情。</em></p></blockquote><p id="de1d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当用户点击动画时，我们旋转上面的(灰色)圆圈，从后面慢慢露出里面的(紫色)圆圈。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/7f5ba8642f714bcb4639500eeb373717.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/0*ovTmdqO3zYn9q1LN.gif"/></div></figure><blockquote class="my mz na"><p id="03ac" class="kb kc ld kd b ke kf kg kh ki kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ky im bi translated"><em class="it">注:内圈(紫色)完全不动。我们旋转上面的圆(这里是半透明的),从后面显示里面的圆。</em></p></blockquote><h1 id="7fd1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">3.第三圈</h1><p id="ac4e" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">第三个半圆以0度旋转开始，因此覆盖了基础外圆的左半部分。其背景颜色为灰色(与基圆相同)。请记住，第二个圆圈(右边的灰色)正顺时针移动，并带走了外圈的一些左半部分。它看起来像这样:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/96c3ef2e6dd7b0a999e519ca4c2e86f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/0*VXuixC3BJqZqrmLf.png"/></div></figure><p id="b63c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，第三个(左侧灰色)圆具有较高的高程，这使它能够与左侧第二个圆的额外部分重叠。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/13e8fedf137ad91b3b6dd924c376c50d.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/0*1mUPrPqjUQ9Psztb.gif"/></div></figure><h1 id="804d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">案例二。如果进度百分比&gt; 50</h1><p id="672a" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">最初，所有三个半圆都以0度旋转初始化，并覆盖外基圆的左半部分(灰色)。第一个圆在底部，第二个在顶部，第三个在第二个的顶部，因为它的海拔最高。这使得基圆的右半部分是空的。</p><h2 id="14ea" class="mm lf it bd lg mn mo dn lk mp mq dp lo km mr ms ls kq mt mu lw ku mv mw ma mx bi translated">1.第一圈</h2><p id="ce5e" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">第一个和第二个圆圈(左边都是紫色的)将慢慢旋转，从0到180度覆盖右半部分。这涵盖了动画的50%。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/96a328cea64ad663acb062c0e1434ad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/0*wQpsxAj4dE5nNYaf.gif"/></div></figure><p id="3b99" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，第一个圆停止，第二个圆接手完成剩余的旋转。</p><h2 id="834d" class="mm lf it bd lg mn mo dn lk mp mq dp lo km mr ms ls kq mt mu lw ku mv mw ma mx bi translated">2.第二圈</h2><p id="02a7" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">第一个圆圈的工作是取得50%的进展，然后第二个圆圈将旋转一些来覆盖剩余的百分比。我把第二个圆做成半透明的，向你展示它是如何工作的。(为简单起见，去掉了第三个圆圈)。这是典型的<code class="fe kz la lb lc b">percent={70}</code>情况:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/0bafc224a74e6b73a69aa23358dd1603.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/0*XDXKwwB3puubplWg.gif"/></div></figure><p id="d924" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以第一个圆圈覆盖的50%区域和第二个圆圈覆盖的20%区域加起来就完成了动画。但是等等，第三圈呢？它仍然在第二个圆圈的上面，我们看不到后面的第二个圆圈。看看我们的第三圈在做什么。</p><h2 id="a6f0" class="mm lf it bd lg mn mo dn lk mp mq dp lo km mr ms ls kq mt mu lw ku mv mw ma mx bi translated">3.第三圈</h2><p id="4546" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">我们将顺时针旋转第三个和第二个圆相同的角度(在当前示例中增加20%)。它将留出空间，以便第二个圆变得可见。为了清楚地显示，第三个圆圈是黄色的，第一个和第二个被删除。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/e1f9bb3168114355307c04fd78256708.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/0*FJvHeRGC1NlnT4EZ.gif"/></div></figure><p id="b97d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">你看出这里的问题了吗？</strong>当我们的第三个圆顺时针旋转时，它占据了右半边的一部分，并覆盖了第一个圆<em class="ld">(第三个圆海拔更高，记得吗？)</em>。</p><p id="5fc9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解决方法很简单，你可能已经猜到了。切换高程值，使第三个圆进入第一个圆。</p><p id="d1c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个圆圈现在是半透明的，所以你可以看到第三个(黄色)圆圈是如何在第一个(半透明)圆圈后面的。切换提升后:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/375d3c51ddb17ae32e0a854a63a25a0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/0*2-gnrYYnqUcs1syE.gif"/></div></figure><p id="aa19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望清楚发生了什么。让我们校正颜色，看看我们的最终动画！</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/273af6a0eb4acf771199bbf861c63701.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/0*vySuAcJKu7ZiKLQa.gif"/></div></figure><p id="beac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">看起来不错，不是吗？让我们添加一个更小的内圆，这样我们的视图看起来更像一个进度条。</p><h1 id="fddc" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">核心集团</h1><p id="dce7" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">一个更小的内圈在所有东西的上面，创造了一个进度条的外观。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/fbd2d56ffa395340a34e56b0511fa646.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/0*Qxpov-yREeW79Y9C.gif"/></div></figure><h1 id="5c04" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">让我们编码</h1><p id="3a7c" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">涉及5个步骤:</p><ol class=""><li id="4eb8" class="ne nf it kd b ke kf ki kj km ng kq nh ku ni ky nj nk nl nm bi translated">渲染基圆</li><li id="5bfa" class="ne nf it kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated">初始化默认动画值</li><li id="479b" class="ne nf it kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated">呈现三个半圆</li><li id="13e9" class="ne nf it kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated">向半圆添加动画</li><li id="d179" class="ne nf it kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated">渲染内圆</li></ol><h1 id="cf64" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">步骤1:渲染基圆</h1><p id="42d1" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">用灰色背景渲染基本容器圆。它将包含其他三个半圆。</p><pre class="mi mj mk ml gt ns lc nt nu aw nv bi"><span id="33ee" class="mm lf it lc b gy nw nx l ny nz">&lt;View<br/>  style={[<br/>    styles.outerCircle,<br/>    {<br/>      height: radius * 2,<br/>      width: radius * 2,<br/>      borderRadius: radius,<br/>      backgroundColor: passiveColor, //grey color<br/>    },<br/>  ]}<br/>/&gt;</span></pre><h1 id="22a6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">步骤2:初始化默认动画值</h1><p id="4d76" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">初始化所有三个半圆的默认值。</p><pre class="mi mj mk ml gt ns lc nt nu aw nv bi"><span id="6da5" class="mm lf it lc b gy nw nx l ny nz">//for first and second circle<br/>const initialValueHalfCircle = percent &gt;= 50 ? 0 : 180;<br/><br/>//for third circle<br/>const initialValueInnerCircle = 0;<br/><br/>//initialize animated values to interpolate over degree of rotation<br/>const firstCircleAnimatedValue = new Animated.Value(initialValueHalfCircle);<br/>const secondCircleAnimatedValue = new Animated.Value(initialValueHalfCircle);<br/>const thirdCircleAnimatedValue = new Animated.Value(initialValueInnerCircle);<br/><br/>//initialize time for rotation<br/>const timePerDegree = duration / 360;<br/><br/>//first circle is always purple<br/>const firstCircleColor = activeColor;<br/><br/>//for first case: second circle was overlapping with grey background when progress &lt; 50 <br/>//for second case: it was completing the animation after 50% with active purple color<br/>const secondCircleColor = percent &gt;= 50 ? activeColor : passiveColor;</span></pre><h1 id="5f0a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">第三步:渲染三个半圆</h1><p id="591d" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">我们要渲染三个半圆，所以让我们写一个辅助函数，让我们的工作更容易。</p><pre class="mi mj mk ml gt ns lc nt nu aw nv bi"><span id="62ae" class="mm lf it lc b gy nw nx l ny nz">const renderHalf = (color, transforms = [], otherStyles = {}) =&gt; (<br/>    &lt;Animated.View<br/>      style={[<br/>        styles.half,<br/>        { backgroundColor: color, borderColor: color },<br/>        { width: radius, height: radius * 2, borderRadius: radius },<br/>        {<br/>          transform: [<br/>            { translateX: radius / 2 },<br/>            ...transforms,<br/>            { translateX: -radius / 2 },<br/>            { scale: 1.004 },<br/>          ],<br/>        },<br/>        otherStyles,<br/>      ]}<br/>    &gt;<br/>    //children<br/>    &lt;/Animated.View&gt;<br/>  );</span></pre><p id="99b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">顺时针<code class="fe kz la lb lc b">rotate</code>半圆需要一个<code class="fe kz la lb lc b">color</code>道具和一个<code class="fe kz la lb lc b">transform</code>道具。让我们现在不要担心逻辑，调用这个函数来渲染我们的第一个半圆。</p><pre class="mi mj mk ml gt ns lc nt nu aw nv bi"><span id="7e0a" class="mm lf it lc b gy nw nx l ny nz">{renderHalf(firstCircleColor, [{ rotate: rotate1 }])}</span></pre><blockquote class="my mz na"><p id="dd4f" class="kb kc ld kd b ke kf kg kh ki kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ky im bi translated"><em class="it">注意:</em> <code class="fe kz la lb lc b"><em class="it">firstCircleColor</em></code> <em class="it">两种情况下都是activeColor(紫色)。</em></p></blockquote><p id="51c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它正在接收一个<code class="fe kz la lb lc b">rotate1</code>值，这个值是我们在上一步中初始化的动画值的插值。它只是将<code class="fe kz la lb lc b">1 integer value</code>映射到<code class="fe kz la lb lc b">1 degree</code>:</p><pre class="mi mj mk ml gt ns lc nt nu aw nv bi"><span id="a7c1" class="mm lf it lc b gy nw nx l ny nz">const rotate1 = animatedValue1.interpolate({<br/>    inputRange: [0, 1],<br/>    outputRange: ['0deg', '1deg'],<br/>});</span></pre><p id="8790" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个圆也是如此:</p><pre class="mi mj mk ml gt ns lc nt nu aw nv bi"><span id="f2f1" class="mm lf it lc b gy nw nx l ny nz">{renderHalf(secondCircleColor, [{ rotate: rotate2 }])}</span></pre><blockquote class="my mz na"><p id="33d5" class="kb kc ld kd b ke kf kg kh ki kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ky im bi translated"><em class="it">注:</em> <code class="fe kz la lb lc b"><em class="it">secondCircleColor</em></code> <em class="it">第一种情况下为passiveColor(灰色)(&lt; 50)，第二种情况下为activeColor(紫色)(&gt; 50)。</em></p></blockquote><p id="65ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它的旋转值可以用我们之前初始化的<code class="fe kz la lb lc b">secondCircleAnimatedValue</code>插值。</p><pre class="mi mj mk ml gt ns lc nt nu aw nv bi"><span id="776d" class="mm lf it lc b gy nw nx l ny nz">const rotate2 = secondCircleAnimatedValue.interpolate({<br/>    inputRange: [0, 1],<br/>    outputRange: ['0deg', '1deg'],<br/>});</span></pre><p id="895f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这两种情况下，我们的第三种颜色是灰色(passiveColor ),并接收旋转值。同样，在第二种情况下(&gt; 50)，我们如前所述切换<code class="fe kz la lb lc b">elavation</code>值。<code class="fe kz la lb lc b">renderHalf</code>对于这种用例可以是:</p><pre class="mi mj mk ml gt ns lc nt nu aw nv bi"><span id="bb4c" class="mm lf it lc b gy nw nx l ny nz">{renderHalf(passiveColor, [{ rotate: rotate3 }], {<br/>  elevation: elevation3,<br/>})}</span></pre><p id="7072" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">rotate3</code>和<code class="fe kz la lb lc b">elevation3</code>值可以插值为:</p><pre class="mi mj mk ml gt ns lc nt nu aw nv bi"><span id="e62b" class="mm lf it lc b gy nw nx l ny nz">const rotate3 = thirdCircleAnimatedValue.interpolate({<br/>    inputRange: [0, 1],<br/>    outputRange: ['0deg', '1deg'],<br/>  });<br/><br/>  const elevation3 = thirdCircleAnimatedValue.interpolate({<br/>    inputRange: [0, 1],<br/>    outputRange: [0, -1],<br/>});</span></pre><blockquote class="my mz na"><p id="61ff" class="kb kc ld kd b ke kf kg kh ki kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ky im bi translated"><code class="fe kz la lb lc b"><em class="it">Elevation toggle logic:</em></code> <em class="it">第三个圆只是在第二种情况下从左半部分旋转到右半部分。一旦它开始移动，它就会占据右半边的一部分，这正是我们想要切换仰角的时候。</em></p></blockquote><h1 id="5c95" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">步骤4:给半圆添加动画。</h1><p id="bb61" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">现在我们将为这两种情况编写一个动画函数。每当我们收到一个新的<code class="fe kz la lb lc b">percent</code>值时，我们就想开始制作动画。为此，我们可以使用一个简单的<code class="fe kz la lb lc b">useEffect</code>挂钩:</p><pre class="mi mj mk ml gt ns lc nt nu aw nv bi"><span id="1ec0" class="mm lf it lc b gy nw nx l ny nz">useEffect(() =&gt; {<br/>  if (percent &lt; 50) {<br/>    firstAnimation();  //first case (&lt;50)<br/>  } else {<br/>    secondAnimation(); //second case (&gt;50)<br/>  }<br/>});</span></pre><p id="4c01" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上述函数只是根据<code class="fe kz la lb lc b">percent</code>的值选择要执行的动画。让我们为<code class="fe kz la lb lc b">first-case (&lt;50)</code>编写动画函数:</p><pre class="mi mj mk ml gt ns lc nt nu aw nv bi"><span id="7600" class="mm lf it lc b gy nw nx l ny nz">const firstAnimation = () =&gt; {<br/>  Animated.timing(secondCircleAnimatedValue, {<br/>    toValue: 180 + (percent * 3.6),<br/>    duration: (percent * 3.6) * timePerDegree,<br/>    useNativeDriver: true,<br/>    easing: Easing.linear,<br/>  }).start();<br/>};</span></pre><p id="6295" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">percent * 3.6</code>只是将百分比转换成度数。此功能将顺时针方向激活第二个圆(灰色),从后面显示第一个圆(紫色)。现在，让我们来看看<code class="fe kz la lb lc b">second-case (&gt;50)</code>的动画:</p><pre class="mi mj mk ml gt ns lc nt nu aw nv bi"><span id="210d" class="mm lf it lc b gy nw nx l ny nz">const secondAnimation = () =&gt; {<br/>    //resetting first circle to 0 degrees<br/>    firstCircleAnimatedValue.setValue(initialValueHalfCircle);<br/><br/>    Animated.parallel([<br/>      //first circle will rotate upto 180 degrees for 50% of progress<br/>      Animated.timing(firstCircleAnimatedValue, {<br/>        toValue: 180,<br/>        duration: 180 * timePerDegree,<br/>        useNativeDriver: true,<br/>        easing: Easing.linear,<br/>      }),<br/>      //second circle is rotating along with first and some more to extra progress after 50%<br/>      Animated.timing(secondCircleAnimatedValue, {<br/>        toValue: 180 + (percent - 50) * 3.6,<br/>        duration: (180 + (percent - 50) * 3.6) * timePerDegree,<br/>        useNativeDriver: true,<br/>        easing: Easing.linear,<br/>      }),<br/>      //third circle is moving along with second in clockwise direction for that extra value after 50% progress<br/>      Animated.timing(thirdCircleAnimatedValue, {<br/>        toValue: (percent - 50) * 3.6,<br/>        delay: 180 * timePerDegree,<br/>        duration: timePerDegree * ((percent - 50) * 3.6),<br/>        useNativeDriver: true,<br/>        easing: Easing.linear,<br/>      }),<br/>    ]).start();<br/>  };</span></pre><p id="d433" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就这样，我们完成了我们的动画。让我们添加一个内圈，使它看起来像一个进度条。</p><h1 id="75de" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">第五步:渲染内圆</h1><pre class="mi mj mk ml gt ns lc nt nu aw nv bi"><span id="940c" class="mm lf it lc b gy nw nx l ny nz">//styles for inner circle<br/>const innerCircleStyle = {<br/>  backgroundColor: baseColor,<br/>  width: 2 * radius - width,<br/>  height: 2 * radius - width,<br/>  borderRadius: radius,<br/>  elevation: 1000,<br/>  display: 'flex',<br/>  justifyContent: 'center',<br/>  alignItems: 'center',<br/>};<br/><br/>//Complete view after adding the inner circle<br/>return (<br/>  &lt;View style={styles.container} key={percent}&gt;<br/>    &lt;View<br/>      style={[<br/>        styles.outerCircle,<br/>        {<br/>          height: radius * 2,<br/>          width: radius * 2,<br/>          borderRadius: radius,<br/>          backgroundColor: passiveColor,<br/>        },<br/>      ]}<br/>    &gt;<br/>      {renderHalf(firstCircleColor, [{ rotate: rotate1 }])}<br/>      {renderHalf(secondCircleColor, [{ rotate: rotate2 }])}<br/>      {renderHalf(passiveColor, [{ rotate: rotate3 }], {<br/>        elevation: elevation3,<br/>      })}<br/>      &lt;View style={innerCircleStyle}&gt;<br/>        {children}<br/>      &lt;/View&gt;<br/>    &lt;/View&gt;<br/>  &lt;/View&gt;<br/>  );</span></pre><p id="4e88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们完了。点击<a class="ae oa" href="https://github.com/iamshadmirza/react-native-design-system/blob/master/src/CircularProgressBar/CircularProgressBar.js" rel="noopener ugc nofollow" target="_blank">此处</a>查看本教程使用的源代码。我希望你和react native一起学习动画很开心。编码快乐！</p><blockquote class="my mz na"><p id="bf77" class="kb kc ld kd b ke kf kg kh ki kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ky im bi translated"><em class="it">该组件由</em> <a class="ae oa" href="https://twitter.com/ankeetmaini" rel="noopener ugc nofollow" target="_blank"> <em class="it">安基特·麦尼</em> </a> <em class="it">创建。对于带打字稿的完整回购，请转至:</em><a class="ae oa" href="https://hashnode.com/util/redirect?url=https://github.com/ankeetmaini/rn-animation-circular-progress" rel="noopener ugc nofollow" target="_blank"><em class="it">【github.com/ankeetmaini/rn-animation-circula】</em></a><em class="it">…</em></p></blockquote></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="8ad2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ld">原载于</em><a class="ae oa" href="https://hashnode.com/post/learn-react-native-animation-by-building-circular-progress-bar-ck3pwh1ja00dd6vs1vntuuw2k" rel="noopener ugc nofollow" target="_blank"><em class="ld">https://hashnode.com</em></a><em class="ld">。</em></p></div></div>    
</body>
</html>