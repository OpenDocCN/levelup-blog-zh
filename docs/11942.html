<html>
<head>
<title>Microservices with CQRS and Event Sourcing in TypeScript with NestJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CQRS微服务和NestJS类型脚本中的事件源</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/microservices-with-cqrs-in-typescript-and-nestjs-5a8af0a56c3a?source=collection_archive---------0-----------------------#2022-05-02">https://levelup.gitconnected.com/microservices-with-cqrs-in-typescript-and-nestjs-5a8af0a56c3a?source=collection_archive---------0-----------------------#2022-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="350f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">基于领域驱动设计、CQRS和事件源的简单银行API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/04b31335affc7ee3c70e6c6de6b466b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F1FvnDc-ZSyojufBjGX09Q.jpeg"/></div></div></figure><p id="20e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最近，我发表了三篇文章，分别关于领域驱动设计(DDD)、CQRS和事件源。在每篇文章中，我都清楚地表明，虽然这些概念和架构是独立的，但它们<strong class="kw iu">完美地互补</strong>，尤其是在微服务和API的<strong class="kw iu">环境中。</strong></p><p id="e48e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，今天我想更深入地探讨一下这种互动。我<strong class="kw iu">为此创建了一个简单的开源应用</strong>，主要是用TypeScript编写的。</p><p id="c3d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我写了一个由两个微服务和一个API网关组成的银行账户API。我用TypeScript和NestJS实现了微服务。但是，我在Go中编写API Gateway只是为了好玩。</p><p id="3c60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个项目中，我无缝地结合了DDD、CQRS和活动采购。由于NestJS没有官方的事件源模块，我自己写了一个，并在NPM上提供了。最好别用。没有经过实地测试。</p><h1 id="0b7c" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">技术特性表</h1><ul class=""><li id="338d" class="mi mj it kw b kx mk la ml ld mm lh mn ll mo lp mp mq mr ms bi translated">领域驱动设计、CQRS和事件源相结合</li><li id="d543" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">2个NestJS微服务作为Monorepo，在命令和查询之间拆分</li><li id="1ad5" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">Go中的API网关(HTTP到gRPC)</li><li id="9c22" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">为NestJS生态系统中的事件采购创建了一个NPM包</li><li id="8786" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">使用Kafka作为异步事件流</li><li id="a8b6" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">使用gRPC作为同步传输协议</li><li id="a315" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">每个服务模式的数据库</li><li id="3b75" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">由于最终的一致性，确保幂等性</li><li id="d151" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">使用MongoDB作为写数据库的NoSQL方法(事件源)</li><li id="8e7b" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">以PostgreSQL为读数据库的SQL方法</li><li id="0b07" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">将原型文件存储在共享存储库中</li><li id="d1f7" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">除了申请之外，一切都有记录</li><li id="937e" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">传说的简化用法</li></ul><p id="b063" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们开始真正的文章之前:我建议你先阅读前面提到的文章，因为我不会在本文中再次详述每个概念。</p><ul class=""><li id="1a50" class="mi mj it kw b kx ky la lb ld my lh mz ll na lp mp mq mr ms bi translated"><a class="ae nb" rel="noopener ugc nofollow" target="_blank" href="/domain-driven-design-in-software-development-f92c3f58d012">深入领域驱动设计</a></li><li id="e8d7" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated"><a class="ae nb" rel="noopener ugc nofollow" target="_blank" href="/what-is-cqrs-8ddd74ca05bb"> CQRS解释</a></li><li id="e38b" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated"><a class="ae nb" rel="noopener ugc nofollow" target="_blank" href="/basics-of-event-sourcing-12ebe0b86788">什么是(为什么)事件采购</a></li></ul><p id="e2cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，在我们讨论应用程序本身之前，让我们快速地<strong class="kw iu">更新一下</strong>关于DDD、CQRS和事件源的知识。</p><h1 id="6169" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">CQRS DDD和理论上的事件采购</h1><p id="90f2" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">众所周知，CQRS的一切都是从一个<strong class="kw iu">命令</strong>开始的。命令是在系统中带来变化的<strong class="kw iu">意图</strong>。这非常符合DDD中的术语“命令”。DDD的一个司令部也差不多有同样的意图要做出改变。DDD的一个命令是一个聚合的<strong class="kw iu">触发器，最终目标是改变。</strong></p><p id="fba5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在CQRS和DDD之间的交互中，CQRS集成了所谓的<strong class="kw iu">队列</strong>(在本例中，是命令队列或命令总线)，因此我们创建了一个<strong class="kw iu">命令，</strong>将它传输到<strong class="kw iu">命令队列</strong>，从而产生了一个<strong class="kw iu">集合</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/64519feb2a452b0d52020868563da1ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QB5lt5CUrLoveGu1QAlOEg.jpeg"/></div></div></figure><p id="a365" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了处理这个命令，这个集合需要一个内部<strong class="kw iu">状态</strong>。所以你需要事物的当前状态，大部分来自数据库。但这正是<strong class="kw iu">事件采购</strong>发挥作用的地方。因为有了事件源，这种状态可以用过去的<strong class="kw iu">数据恢复。</strong></p><p id="c2ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">出于<strong class="kw iu">可追溯性和一致性</strong>的原因，事件源非常适合银行账户API，例如，能够随时跟踪银行账户的余额，因为有了事件源，您可以在所谓的事件存储中保存每个更改。有了事件源，可以说，你可以在任何时候<strong class="kw iu">回到过去</strong>。</p><p id="848c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后<strong class="kw iu">命令导致新的域事件</strong>生成，然后这些域事件被添加到<strong class="kw iu">事件存储器</strong>中，从而成为这种类型的后续命令的内部状态的一部分。所以你可以想象一个循环。</p><p id="1ca7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个集合也可以看作是几个任务的一种容器，也可以将域事件转发给事件API，这样这些域事件也可以用其他方式处理。考虑向客户端推送通知，以通知客户端命令的结果或其他进一步的处理，例如，通过内部应用程序基础架构的其他微服务。没有限制，并且它因应用而异。</p><p id="350c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，结合CQRS和事件源，聚集的另一个基本任务是将结果存储在查看/读取数据库中或启动该过程。该结果或该数据库随后通过查询被访问。</p><p id="e319" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">视图无非是预先计算好的视图或者<strong class="kw iu">计算出来的数据</strong>。每次领域事件发生时，也就是说，如果业务逻辑中发生了技术事件，它通常会影响一个或另一个视图，从而影响CQRS的部分查询。</p><p id="49ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">换句话说，当命令发生时，产生的域事件存储在写数据库中，但是该事件的结果最终在查看/读取数据库中更新。</p><p id="252b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，这个更新过程遵循我们熟悉的<strong class="kw iu"> CRUD逻辑</strong>，即，在发生特定事件时，会有需要添加新条目的视图，会有需要删除条目的视图，会有需要更新条目的视图。然而，如前所述，这仅发生在CQRS的查询部分，在该部分标准中不使用事件源。</p><p id="1b27" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">举个简单的例子，如果用户发送一个<em class="ng">“TransferFundsCommand”</em>将资金转移到另一个账户，它将变成一个<em class="ng">“FundsTransferredEvent”</em>，并且该事件将被存储在事件存储中。这个事件现在也被传递到查看/读取数据库，在那里这个事件被相应地解释。</p><p id="7b97" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">视图中初始化的银行账户余额减少。与此同时，另一个银行账户必须接收这笔钱，因此必须触发另一个命令。通常还会触发其他日志。</p><p id="175b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由此创建了以下任务的<strong class="kw iu">映射</strong>，这些任务被逐渐解释和处理。当然，查看/读取端的这个<strong class="kw iu">业务逻辑</strong>因应用程序而异。这在CQRS有一些组成部分，这些被称为投影。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/91dbb5c7317d0b0b859e2dbc7da99933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*92m7CERyVHrBElvVgCGMMg.jpeg"/></div></div></figure><p id="7fdc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此时，必须决定哪个域事件与哪个视图相关。然而，这里应该注意的是，视图是<strong class="kw iu">而不是唯一的真实来源</strong>，即事件存储，因为命令的当前状态可以在任何时候<strong class="kw iu">在那里再现</strong>。</p><p id="6273" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是必要的，您必须注意的是，这种投影自然会将写入事件存储区与写入视图存储区的操作分离开来，之后将从视图存储区中读取数据。</p><p id="8af6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着这些写入过程会稍有延迟，从技术角度来看，写入和读取之间的数据不会立即保持一致。这被称为<strong class="kw iu">最终一致性</strong>。因此建立了一致性，但仅<strong class="kw iu">稍微延迟了</strong>。这一开始听起来可能很奇怪，但是在99%的用例中这都不是问题。</p><p id="5143" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在标准中，事件源不发生在CQRS查询部分，这就是为什么这种交互主要指的是命令部分。</p><h1 id="46e4" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">项目描述</h1><p id="ad31" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">正如我提到的，它是分布式应用程序上的一个小型银行帐户API。这个想法就是开立和关闭一个银行账户，存入、提取和转移资金。因此，应用程序的想法再简单不过了。</p><p id="b936" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，这个项目背后的方法、概念和实现是焦点。我选择了领域驱动设计、CQRS和事件源的结合。这三个不同又独立的概念结合起来很棒。</p><p id="5ed8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">DDD和CQRS在使用微服务时并不罕见，尤其是在Java领域。如果您想获得数据的历史记录，那么事件源是有意义的，因为在事件源中，您保存了每个请求及其结果。</p><p id="36e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想想Github或者你的银行账户。在那里你有每一个变化的历史。这个概念有助于保证一致性，尤其是对于与金钱相关的应用程序。</p><p id="7455" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于这样一个简单而小的应用程序来说，这种方法势不可挡。然而，创建这个应用程序是为了演示在TypeScript和NestJS中可能实现的功能。</p><h1 id="d9d2" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">开立银行账户流程图</h1><p id="385c" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">该流程图说明了开立银行账户的POST请求。你会在流程图下面找到详细的解释。</p><blockquote class="ni nj nk"><p id="a7a0" class="ku kv ng kw b kx ky ju kz la lb jx lc nl le lf lg nm li lj lk nn lm ln lo lp im bi translated"><em class="it">过账</em>/API/v1/银行账户/打开</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/a04ac4d9792e86a09c07feba2db7e400.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VlFSFEcV6kV0EeqV3qA-Ew.jpeg"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">开户流程图</figcaption></figure><p id="0c68" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，API网关将获取HTTP请求，并将该请求作为gRPC协议转发给帐户微服务。每个微服务被拆分成一个<strong class="kw iu">命令</strong>和一个<strong class="kw iu">查询</strong>应用。由于我们将发出一个<strong class="kw iu">写请求</strong>，这个请求将到达命令应用程序。</p><p id="e5cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在那里，<em class="ng">openaccountdo</em><strong class="kw iu">验证</strong>传入的请求。命令<em class="ng"> OpenAccountCommand </em>将由<strong class="kw iu">命令总线</strong>创建和处理。执行的命令将创建聚合，它可以被视为一个事件容器。很多事情都可能发生。例如，我们可以重放这个集合以前的事件。</p><p id="25b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，这不是必须的，因为一个账户只能开一次。相反，我们只创建一个<em class="ng"> AccountOpenedEvent </em>并将该事件及其事件数据保存在<strong class="kw iu"> MongoDB </strong>数据库中。</p><p id="916c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们<strong class="kw iu">生成一条保存<strong class="kw iu">事件数据</strong>的消息</strong>，并通过<strong class="kw iu"> Kafka </strong>事件流将这条消息发送到<strong class="kw iu">查询应用程序</strong>，在那里<strong class="kw iu">消费者</strong>监听来电。</p><p id="deed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们<strong class="kw iu">向<strong class="kw iu">事件总线</strong>发布</strong>我们从<strong class="kw iu">命令应用</strong>接收到的事件<em class="ng">opened account</em>。该事件随后将在其执行过程中在<strong class="kw iu"> PostgreSQL </strong>数据库中创建一个<strong class="kw iu">新条目</strong>。最终的一致性被存档，因为写和读数据库在这一级是同步的。</p><p id="db13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同时，<em class="ng"> OpenAccountSaga </em>向第二微服务<em class="ng"> bank-funds-svc </em>发送gRPC请求，以<strong class="kw iu">存放</strong>初始期初余额。同样，这是一个写请求，因此<em class="ng"> bank-funds-svc </em>的<strong class="kw iu">命令应用程序</strong>将获取这个请求。</p><p id="189d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从这里开始，过程与最初的请求非常相似。命令将被创建和执行，聚集调用事件，创建读写数据库的条目，等等。</p><h1 id="f8c8" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">代码片段</h1><p id="5522" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">为了更好地理解变通办法，我想与您分享一些代码片段。不要忘记这个项目是开源的。您可以在下面找到存储库。</p><h2 id="67a6" class="nt lr it bd ls nu nv dn lw nw nx dp ma ld ny nz mc lh oa ob me ll oc od mg oe bi translated">控制器</h2><p id="db08" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">[命令]从API网关接收gRPC请求。由于收到此请求，同时请求主体将由DTO进行验证。将创建一个命令并执行到命令总线。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="c55f" class="nt lr it bd ls nu nv dn lw nw nx dp ma ld ny nz mc lh oa ob me ll oc od mg oe bi translated">命令处理程序</h2><p id="76d2" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">[命令]命令处理器将从命令总线接收刚刚创建的命令。将创建一个聚合。在这个聚合中，我们创建事件，并在最终提交聚合之前将该事件保存在事件存储中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="2066" class="nt lr it bd ls nu nv dn lw nw nx dp ma ld ny nz mc lh oa ob me ll oc od mg oe bi translated">事件处理程序</h2><p id="603f" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">[command]事件处理程序将捕获事件并将其生成到Kafka事件流。因此查询应用程序上等待的消费者可以接管这个事件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="cd52" class="nt lr it bd ls nu nv dn lw nw nx dp ma ld ny nz mc lh oa ob me ll oc od mg oe bi translated">消费者</h2><p id="77e5" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">[查询]消费者将通过Kafka异步接收该事件，并将该事件转发到事件总线。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="3772" class="nt lr it bd ls nu nv dn lw nw nx dp ma ld ny nz mc lh oa ob me ll oc od mg oe bi translated">事件处理程序</h2><p id="ef08" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">[query]事件处理程序(这次是在查询应用程序上)将从事件总线中提取事件，并最终使用TypeORM将其保存到读取的数据库中。最终一致性已存档。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="7fd8" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">仓库</h1><ul class=""><li id="d101" class="mi mj it kw b kx mk la ml ld mm lh mn ll mo lp mp mq mr ms bi translated"><a class="ae nb" href="https://github.com/hellokvn/bank-account-svc" rel="noopener ugc nofollow" target="_blank">银行账户微服务</a></li><li id="3c54" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated"><a class="ae nb" href="https://github.com/hellokvn/bank-funds-svc" rel="noopener ugc nofollow" target="_blank">银行资金微服务</a></li><li id="f271" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated"><a class="ae nb" href="https://github.com/hellokvn/bank-api-gateway" rel="noopener ugc nofollow" target="_blank"> API网关</a></li><li id="c5db" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated"><a class="ae nb" href="https://github.com/hellokvn/nestjs-event-sourcing" rel="noopener ugc nofollow" target="_blank">事件源模块</a></li><li id="002a" class="mi mj it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated"><a class="ae nb" href="https://github.com/hellokvn/bank-shared-proto" rel="noopener ugc nofollow" target="_blank">原型文件的共享存储库</a></li></ul><p id="8734" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您阅读我用TypeScript和Go编写的关于我的开源项目的文章。我希望你能带走一些东西。请留下一些反馈，并关注我。</p><p id="181b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">干杯！</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="c9ac" class="lq lr it bd ls lt oo lv lw lx op lz ma jz oq ka mc kc or kd me kf os kg mg mh bi translated">接下来阅读</h1><div class="ot ou gp gr ov ow"><a rel="noopener  ugc nofollow" target="_blank" href="/why-did-i-move-from-typescript-to-go-1d9f92ef882a"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">为什么我从打字稿转向Go</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">以及为什么我不会放弃使用TypeScript</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk ks ow"/></div></div></a></div><div class="ot ou gp gr ov ow"><a href="https://javascript.plainenglish.io/5-tips-on-how-to-lead-a-tech-team-dffa080c0183" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">如何领导技术团队的5个技巧</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">从软件开发人员的角度来看</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pf l"><div class="pl l ph pi pj pf pk ks ow"/></div></div></a></div><div class="ot ou gp gr ov ow"><a href="https://blog.bitsrc.io/document-your-tech-decisions-now-76cd781707fe" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">立即记录您的技术决策</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">如何记录您的技术团队决策</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">blog.bitsrc.io</p></div></div><div class="pf l"><div class="pm l ph pi pj pf pk ks ow"/></div></div></a></div></div></div>    
</body>
</html>