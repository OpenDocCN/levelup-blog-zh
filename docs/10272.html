<html>
<head>
<title>Better Enhanced Repository Pattern Implementation in .NET C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中更好地增强了存储库模式的实现。NET C#</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/better-enhanced-repository-pattern-implementation-in-net-c-4e6f4bbe48a9?source=collection_archive---------0-----------------------#2021-11-17">https://levelup.gitconnected.com/better-enhanced-repository-pattern-implementation-in-net-c-4e6f4bbe48a9?source=collection_archive---------0-----------------------#2021-11-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="602e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">设计模式</h2><div class=""/><div class=""><h2 id="e78e" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">了解如何遵循最佳实践来实现更好的增强的<strong class="ak">存储库</strong>设计模式，以满足诸如节流之类的扩展需求。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/819d307a486573d89b32e96d9b9112d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fXpdAT7EJe6gH08hInhjvw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@frankiefoto?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">弗兰克·麦肯纳</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="7090" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">故事</h1><p id="3b3b" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我和我的团队将要开始一个大项目。是关于一家大公司的网络应用程序。你无法想象我有多想透露它的名字，但不幸的是，我不能。</p><p id="1578" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">客户有一些具体的要求，其中一些实际上是技术性的。我知道这不是正常的事情，但是，这个客户已经有了自己的技术团队，他们可以应付我们的团队。</p><p id="5c06" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">长话短说，让我跳过太长的需求列表，直接跳到我对本文真正感兴趣的需求。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><div class="ks kt ku kv gt ni"><a href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener follow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd jd gy z fp nn fr fs no fu fw jc bi translated">订阅艾哈迈德的时事通讯？</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">订阅艾哈迈德的时事通讯📰直接获得最佳实践、教程、提示、技巧和许多其他很酷的东西…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">medium.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw lb ni"/></div></div></a></div></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nx"><img src="../Images/4497771cc2dc2d15940290554da6428b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RU89TcfRAR5mmclMX9x57w.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">格伦·卡斯滕斯-彼得斯在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="56b1" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">要求</h1><p id="f6e9" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">正如我所说，我们的客户有一些具体的要求，其中一些是技术性的。所以，让我带你浏览一下这些有趣的需求，我相信你会爱上它们的。</p><p id="d5ae" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">应用程序需要有一个后端来存储所有处理过的数据。而且，一旦我说<strong class="mc jd">后端</strong>，你就说… <strong class="mc jd">仓库</strong>。</p><p id="24fa" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">需求中最有趣的部分与要实现的存储库有关。因此，让我告诉你这几个。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h2 id="a684" class="ny lj it bd lk nz oa dn lo ob oc dp ls mj od oe lu mn of og lw mr oh oi ly iz bi translated">1.对存储库进行定期自动运行状况检查</h2><p id="e784" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi oj translated"><span class="l ok ol om bm on oo op oq or di">R</span>R<strong class="mc jd">需求</strong>:客户希望能够设计、实现并运行所有存储库的自动健康检查。<strong class="mc jd">无论储存库类型如何，设计都应允许盲态健康检查</strong>。</p><p id="b81d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi oj translated">D  <strong class="mc jd">设计</strong>:对于允许这样做的设计来说，系统中所有的库应该有一些<strong class="mc jd">的高级抽象。这个抽象层应该尽可能多地公开所有存储库的公共API。</strong></p><h2 id="5875" class="ny lj it bd lk nz oa dn lo ob oc dp ls mj od oe lu mn of og lw mr oh oi ly iz bi translated">2.API对查询的节流限制</h2><p id="46fb" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi oj translated"><span class="l ok ol om bm on oo op oq or di"> R </span> <strong class="mc jd">要求</strong>:所有查询都应该允许应用一些<strong class="mc jd">变量节流限制</strong>来控制每次调用检索的<strong class="mc jd">数据量</strong>。节流标准可以实现为运行时逻辑<strong class="mc jd">，而不是一些硬编码的阈值</strong>。此外，<strong class="mc jd">应告知打电话者</strong>此事，以及<strong class="mc jd">如果可能的话，获取其余</strong>数据的方式。</p><p id="7f91" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi oj translated"><span class="l ok ol om bm on oo op oq or di">D</span>D<strong class="mc jd">design</strong>:对于允许这样做的设计，我们应该实现<strong class="mc jd">分页</strong>来使用节流逻辑控制每次调用检索的数据量。此外，一些统一的返回对象应该返回给调用者，通知他有关分页和如何获得下一页，…</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi os"><img src="../Images/728f2d39f8b62bab15a247681b04376d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JWOukUlbbs3I273UzEUMhA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@mikael_seegen?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Mikael Seegen </a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="4327" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">放弃</h1><ol class=""><li id="81da" class="ot ou it mc b md me mg mh mj ov mn ow mr ox mv oy oz pa pb bi translated">一些最佳实践可能会被忽略/放弃，以便将主要焦点转移到本文中针对的其他最佳实践上。</li><li id="b169" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">所有的代码都可以在<a class="ae lh" href="https://github.com/AhmedTarekHasan/BetterRepository" rel="noopener ugc nofollow" target="_blank"> <strong class="mc jd">这个资源库</strong> </a>中找到，这样你就可以很容易地跟随。</li><li id="a721" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">客户的一些细节和项目的性质故意不透露，因为他们是机密。</li><li id="6032" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">一些代码实现只是为了演示，我不建议在生产代码中使用或模仿它。在这种情况下，会提供一个注释。</li><li id="1833" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">要完全理解本文中的代码和设计，需要对其他主题和概念有所了解。在这种情况下，会提供一个注释，也可能是一个链接。</li><li id="a0d3" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">我们的例子中使用的分页实现是专门针对内存列表应用分页的。它不适用于使用实体框架或任何其他框架的生产代码。</li><li id="c5ac" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">请将本文中的代码用作kickstarter或思想开创者。在投入生产之前，你需要修改设计，使之适应你自己的需要。</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/e5d9c392c4d0dd1873a14e51418d7419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dl0F36mQqB_LNtA_dKd3ug.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@markusspiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Markus Spiske </a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="d355" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated"><strong class="ak">更好地增强实施和分析</strong></h1><h2 id="6e51" class="ny lj it bd lk nz oa dn lo ob oc dp ls mj od oe lu mn of og lw mr oh oi ly iz bi translated">实体</h2><p id="ec6c" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我们将从一个代表雇员的非常简单的实体开始。然而，由于我们的设计通常需要一些高层次的抽象，我们需要一个抽象实体，它可以被我们所有的系统实体继承。</p><p id="cde2" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd">实体</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pi pj l"/></div></figure><p id="93f8" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">对于我们的解决方案，我们将保持简单，不为抽象的<code class="fe pk pl pm pn b">Entity</code>类提供任何公共成员。但是，对于您自己的解决方案，您可能需要这样做。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="2ccc" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd">员工</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pi pj l"/></div></figure><p id="59fe" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们在这里可以注意到:</p><ol class=""><li id="984b" class="ot ou it mc b md mw mg mx mj po mn pp mr pq mv oy oz pa pb bi translated">这是一个简单的<code class="fe pk pl pm pn b">Employee</code>类，它继承了抽象的<code class="fe pk pl pm pn b">Entity</code>类。</li><li id="1dfd" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">它有<code class="fe pk pl pm pn b">Id</code>和<code class="fe pk pl pm pn b">Name</code>。</li><li id="9476" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">它是不可变的，这就是为什么我们有一个构造函数从另一个雇员那里复制所有成员——除了Id。</li><li id="5dee" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">我们有一个<code class="fe pk pl pm pn b">ToString</code>方法的替代方法，仅用于演示目的。<strong class="mc jd">这不是可遵循的最佳实践。</strong></li></ol></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h2 id="fe31" class="ny lj it bd lk nz oa dn lo ob oc dp ls mj od oe lu mn of og lw mr oh oi ly iz bi translated">分页</h2><p id="8849" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">分页概念之前已经在文章<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/paging-partitioning-main-equations-to-make-it-easy-44fe89d5290b?sk=f65265d7b4c203ac219e7dec1208c0f2"> <strong class="mc jd">分页/分区中用代码示例解释过了——学习主要等式使其变得简单</strong> </a>。</p><p id="84c1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如果您希望理解分页代码，我建议您首先阅读这篇文章。</p><p id="7bd7" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">为了简洁起见，我将在这里包含分页代码，作为快速参考。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pi pj l"/></div></figure><p id="6e6b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们在这里可以注意到:</p><ol class=""><li id="a8f7" class="ot ou it mc b md mw mg mx mj po mn pp mr pq mv oy oz pa pb bi translated">这与关于分页的另一篇文章中解释的代码相同。</li><li id="5729" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">唯一增加的部分是关于覆盖<code class="fe pk pl pm pn b">ToString</code>方法。</li><li id="53da" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">这样做只是为了演示。这不是可遵循的最佳实践。</li></ol></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h2 id="1bfe" class="ny lj it bd lk nz oa dn lo ob oc dp ls mj od oe lu mn of og lw mr oh oi ly iz bi translated">查询结果</h2><p id="d4b1" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">这将我们引向从Get repository调用返回的统一对象，在我们的例子中称为<code class="fe pk pl pm pn b">QueryResult</code>。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pi pj l"/></div></figure><p id="2a2a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们在这里可以注意到:</p><ol class=""><li id="5bbf" class="ot ou it mc b md mw mg mx mj po mn pp mr pq mv oy oz pa pb bi translated">我们有<code class="fe pk pl pm pn b">IQueryResult</code>接口，它表示从<strong class="mc jd"> Get </strong>存储库调用返回的对象。</li><li id="522f" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">它有<code class="fe pk pl pm pn b">PagingDescriptor</code>和<code class="fe pk pl pm pn b">ActualPageZeroIndex</code>属性，因此调用者将知道他的调用所检索的数据的确切分页细节。</li><li id="429d" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">并且，作为抽象基础<code class="fe pk pl pm pn b">Entity</code>的<code class="fe pk pl pm pn b">IEnumerable</code>的<code class="fe pk pl pm pn b">Results</code>属性产生。</li><li id="df80" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated"><strong class="mc jd">注意</strong>:下一部分需要注意两个重要概念；<strong class="mc jd">差异。NET </strong>和<strong class="mc jd">在抽象中隐藏成员</strong>。如果你需要阅读关于这些概念的文章，你可以查阅两篇文章<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/covariance-and-contravariance-in-net-c-c2b8576b2155?sk=13f0128f87d2cbfb24f30219796bff31"> <strong class="mc jd">中的协变和逆变。NET C# </strong> </a>和<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/a-best-practice-for-designing-interfaces-in-net-c-2c6ebdb4f1c1?sk=1f07b674adf763b7567d652ddd9f4a43"> <strong class="mc jd">中设计接口的最佳实践。NET C# </strong> </a>。</li><li id="5168" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">我们定义了<code class="fe pk pl pm pn b">IQueryResult&lt;out TEntity&gt;</code>通用接口，这样我们就可以为特定的存储库提供强类型语言支持。</li><li id="df60" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">在这个接口上，我们隐藏了<code class="fe pk pl pm pn b">IEnumerable&lt;Entity&gt; IQueryResult.Results</code>属性，并用一个新的类型化属性替换它。</li><li id="b16c" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">然后是实现<code class="fe pk pl pm pn b">IQueryResult&lt;TEntity&gt;</code>接口的<code class="fe pk pl pm pn b">QueryResult&lt;TEntity&gt;</code>类。</li><li id="6b5d" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">我们有一个对<code class="fe pk pl pm pn b">ToString</code>方法的覆盖，仅用于演示目的。这不是可遵循的最佳实践。</li></ol></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h2 id="2e19" class="ny lj it bd lk nz oa dn lo ob oc dp ls mj od oe lu mn of og lw mr oh oi ly iz bi translated">AddOrUpdateDescriptor</h2><p id="8708" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我们将在我们的存储库上支持不同的方法，包括<code class="fe pk pl pm pn b">AddOrUpdate</code>方法。这将使来电者的生活更容易随时需要。</p><p id="bc11" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">为此，我们需要定义一个从<code class="fe pk pl pm pn b">AddOrUpdate</code>方法返回的统一对象结构。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pi pj l"/></div></figure><p id="2aa5" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们在这里可以注意到:</p><ol class=""><li id="f89f" class="ot ou it mc b md mw mg mx mj po mn pp mr pq mv oy oz pa pb bi translated">我们定义了<code class="fe pk pl pm pn b">IAddOrUpdateDescriptor</code>接口。</li><li id="6d11" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">还定义了实现<code class="fe pk pl pm pn b">IAddOrUpdateDescriptor</code>的<code class="fe pk pl pm pn b">AddOrUpdateDescriptor</code>类，它是不可变的。</li><li id="2014" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">还定义了枚举<code class="fe pk pl pm pn b">AddOrUpdate</code>。</li></ol></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h2 id="aa9b" class="ny lj it bd lk nz oa dn lo ob oc dp ls mj od oe lu mn of og lw mr oh oi ly iz bi translated">查询存储库</h2><p id="b87f" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">现在我们转到我们的存储库定义。我们将把我们的存储库方法分成两部分；<strong class="mc jd">查询</strong>和<strong class="mc jd">命令</strong>。我能听到你说<strong class="mc jd">命令和查询责任分离(CQRS) </strong>。</p><p id="0581" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">是的，我们的设计将包含CQRS的相同概念，但它没有在这里完全实现。所以，请不要认为这个设计是一个不完整的CQRS，因为它本来就不是设计出来的。</p><p id="85dc" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi oj translated"><span class="l ok ol om bm on oo op oq or di"> N </span> <strong class="mc jd"> ote </strong>:下一部分需要注意两个重要概念；<strong class="mc jd">差异。NET </strong>和<strong class="mc jd">在抽象中隐藏成员</strong>。如果你需要阅读这些概念，你可以查阅两篇文章<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/covariance-and-contravariance-in-net-c-c2b8576b2155?sk=13f0128f87d2cbfb24f30219796bff31"> <strong class="mc jd">中的协变和逆变。NET C# </strong> </a>和<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/a-best-practice-for-designing-interfaces-in-net-c-2c6ebdb4f1c1?sk=1f07b674adf763b7567d652ddd9f4a43"> <strong class="mc jd">中设计接口的最佳实践。NET C# </strong> </a>。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h2 id="629c" class="ny lj it bd lk nz oa dn lo ob oc dp ls mj od oe lu mn of og lw mr oh oi ly iz bi translated">IQueryRepository</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pi pj l"/></div></figure><p id="016d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们在这里可以注意到:</p><ol class=""><li id="410d" class="ot ou it mc b md mw mg mx mj po mn pp mr pq mv oy oz pa pb bi translated">这是我们的<code class="fe pk pl pm pn b">IQueryRepository</code>接口，它表示任何非通用的<strong class="mc jd">查询存储库</strong>。</li><li id="72bf" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">我们定义了<code class="fe pk pl pm pn b">Entity Get(int id)</code>方法来通过Id获取实体。</li><li id="4025" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">我们定义了<code class="fe pk pl pm pn b">IQueryResult&lt;Entity&gt; GetAll()</code>方法来获取实现库中的所有实体。请记住，应该应用节流限制，这就是为什么我们不只是返回实体列表，我们正在返回<code class="fe pk pl pm pn b">IQueryResult</code>。</li><li id="2e07" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">我们定义了<code class="fe pk pl pm pn b">IQueryResult&lt;Entity&gt; Get(int pageSize, int pageIndex)</code>方法来获取实体划分成一定大小的页面。请记住，这里也应该应用节流限制。因此，如果限制阈值以某种方式设置为5，并且调用者请求获取每页8个实体的页面中的实体，那么将会应用一个自适应，调用者将会通过使用返回的<code class="fe pk pl pm pn b">IQueryResult</code>对象知道这一点。</li></ol></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h2 id="ea35" class="ny lj it bd lk nz oa dn lo ob oc dp ls mj od oe lu mn of og lw mr oh oi ly iz bi translated">IQueryRepository <tentity/></h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pi pj l"/></div></figure><p id="bff6" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">遵循文章<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/a-best-practice-for-designing-interfaces-in-net-c-2c6ebdb4f1c1?sk=1f07b674adf763b7567d652ddd9f4a43"> <strong class="mc jd">中解释的相同的主要概念。NET C# </strong> </a>，我们定义了<code class="fe pk pl pm pn b">IQueryRepository&lt;TEntity&gt;</code>接口。</p><p id="11ba" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们还定义了<code class="fe pk pl pm pn b">IQueryResult&lt;TEntity&gt; GetByExpression(Expression&lt;Func&lt;TEntity, bool&gt;&gt; predicate)</code>方法，在使用传入的谓词过滤实体后获取它们。请记住，这里也应该应用节流限制。</p><p id="aa78" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">此外，我们定义了<code class="fe pk pl pm pn b">IQueryResult&lt;TEntity&gt; GetByExpression(Expression&lt;Func&lt;TEntity, bool&gt;&gt; predicate, int pageSize, int pageIndex)</code>方法，在使用传入的谓词过滤实体后应用分页。请记住，这里也应该应用节流限制。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h2 id="70ee" class="ny lj it bd lk nz oa dn lo ob oc dp ls mj od oe lu mn of og lw mr oh oi ly iz bi translated">查询存储库<tentity/></h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pi pj l"/></div></figure><p id="cc66" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们在这里可以注意到:</p><ol class=""><li id="f01d" class="ot ou it mc b md mw mg mx mj po mn pp mr pq mv oy oz pa pb bi translated">这是一个实现<code class="fe pk pl pm pn b">IQueryRepository&lt;TEntity&gt;</code>的抽象类。</li><li id="8b79" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">来自<code class="fe pk pl pm pn b">IQueryRepository&lt;TEntity&gt;</code>接口的所有<strong class="mc jd"> Get </strong>方法的实现将被委托给继承自<code class="fe pk pl pm pn b">QueryRepository&lt;TEntity&gt;</code>的子类。</li><li id="4bf6" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">对于<code class="fe pk pl pm pn b">IQueryResult&lt;Entity&gt; IQueryRepository.GetAll()</code>，默认调用另一个<code class="fe pk pl pm pn b">IQueryResult&lt;TEntity&gt; GetAll()</code>，由子类实现。</li><li id="bf7b" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">对于<code class="fe pk pl pm pn b">Entity IQueryRepository.Get(int id)</code>,默认调用另一个<code class="fe pk pl pm pn b">TEntity Get(int id)</code>,由子类实现。</li><li id="b114" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">对于<code class="fe pk pl pm pn b">IQueryResult&lt;Entity&gt; IQueryRepository.Get(int pageSize, int pageIndex)</code>，默认调用另一个<code class="fe pk pl pm pn b">IQueryResult&lt;TEntity&gt; Get(int pageSize, int pageIndex)</code>，由子类实现。</li></ol></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h2 id="a6cd" class="ny lj it bd lk nz oa dn lo ob oc dp ls mj od oe lu mn of og lw mr oh oi ly iz bi translated">命令存储库</h2><p id="83ec" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">以下是与任何命令存储库相关的定义。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h2 id="b0a8" class="ny lj it bd lk nz oa dn lo ob oc dp ls mj od oe lu mn of og lw mr oh oi ly iz bi translated">ICommandRepository</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pi pj l"/></div></figure><p id="23b1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们在这里可以注意到:</p><ol class=""><li id="5c33" class="ot ou it mc b md mw mg mx mj po mn pp mr pq mv oy oz pa pb bi translated">这是我们的<code class="fe pk pl pm pn b">ICommandRepository</code>接口，它代表了任何非通用的<strong class="mc jd">命令库</strong>。</li><li id="96fa" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">我们定义了所有需要的方法来与我们的存储库交互。像<code class="fe pk pl pm pn b">Add</code>、<code class="fe pk pl pm pn b">Update</code>、<code class="fe pk pl pm pn b">AddOrUpdate</code>和<code class="fe pk pl pm pn b">Delete</code>这样的方法。</li></ol></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h2 id="d07a" class="ny lj it bd lk nz oa dn lo ob oc dp ls mj od oe lu mn of og lw mr oh oi ly iz bi translated">ICommandRepository <in tentity=""/></h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pi pj l"/></div></figure><p id="5108" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">遵循文章<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/a-best-practice-for-designing-interfaces-in-net-c-2c6ebdb4f1c1?sk=1f07b674adf763b7567d652ddd9f4a43"> <strong class="mc jd">中解释的相同的主要概念。NET C# </strong> </a>中，我们定义了<code class="fe pk pl pm pn b">ICommandRepository&lt;in TEntity&gt;</code>接口。</p><p id="a43d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这里值得一提的是，从<strong class="mc jd"> C#8.0开始，</strong>你可以把这个添加到一个接口上。</p><p id="e71a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><code class="fe pk pl pm pn b">abstract int ICommandRepository.Add(Entity entity);</code></p><p id="a6f7" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在我们的例子中，这意味着尽管<code class="fe pk pl pm pn b">ICommandRepository&lt;in TEntity&gt;</code>扩展了<code class="fe pk pl pm pn b">ICommandRepository</code>，但是任何实现<code class="fe pk pl pm pn b">ICommandRepository&lt;in TEntity&gt;</code>接口的类都不会公开<code class="fe pk pl pm pn b">int Add(<strong class="mc jd">Entity</strong> entity)</code>方法，除非它被隐式或显式地强制转换为非泛型<code class="fe pk pl pm pn b">ICommandRepository</code>接口。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h2 id="2f48" class="ny lj it bd lk nz oa dn lo ob oc dp ls mj od oe lu mn of og lw mr oh oi ly iz bi translated">命令存储库<tentity/></h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pi pj l"/></div></figure><p id="e4da" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们在这里可以注意到:</p><ol class=""><li id="1708" class="ot ou it mc b md mw mg mx mj po mn pp mr pq mv oy oz pa pb bi translated">这是一个实现<code class="fe pk pl pm pn b">ICommandRepository&lt;TEntity&gt;</code>的抽象类。</li><li id="ccc0" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">来自<code class="fe pk pl pm pn b">ICommandRepository&lt;TEntity&gt;</code>接口的所有方法的实现将被委托给从<code class="fe pk pl pm pn b">CommandRepository&lt;TEntity&gt;</code>继承的子类。</li><li id="a731" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">对于<code class="fe pk pl pm pn b">int ICommandRepository.Add(Entity entity)</code>，默认情况下调用其他<code class="fe pk pl pm pn b">int Add(TEntity entity)</code>，这将由子类实现，但是，我们对传入的类型添加了额外的检查，以确保它与预期的类型相匹配。</li><li id="1e69" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">对于<code class="fe pk pl pm pn b">IEnumerable&lt;int&gt; ICommandRepository.Add(IEnumerable&lt;Entity&gt; entities)</code>,默认情况下调用子类实现的另一个<code class="fe pk pl pm pn b">IEnumerable&lt;int&gt; Add(IEnumerable&lt;TEntity&gt; entities)</code>,但是，我们对传入的类型增加了额外的检查，以确保它与预期的类型匹配。</li><li id="f6c9" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">对于<code class="fe pk pl pm pn b">void ICommandRepository.Update(Entity entity)</code>,默认情况下调用由子类实现的另一个<code class="fe pk pl pm pn b">void Update(TEntity entity)</code>,但是，我们对传入的类型添加了额外的检查，以确保它与预期的类型相匹配。</li><li id="a3a0" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">对于<code class="fe pk pl pm pn b">void ICommandRepository.Update(IEnumerable&lt;Entity&gt; entities)</code>,默认情况下调用另一个将由子类实现的<code class="fe pk pl pm pn b">void Update(IEnumerable&lt;TEntity&gt; entities)</code>,但是，我们对传入的类型添加了额外的检查，以确保它与预期的类型相匹配。</li><li id="ea0c" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">对于<code class="fe pk pl pm pn b">IAddOrUpdateDescriptor ICommandRepository.AddOrUpdate(Entity entity)</code>,默认情况下调用由子类实现的另一个<code class="fe pk pl pm pn b">IAddOrUpdateDescriptor AddOrUpdate(TEntity entity)</code>,但是，我们对传入的类型添加了额外的检查，以确保它与预期的类型相匹配。</li><li id="529a" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">对于<code class="fe pk pl pm pn b">IEnumerable&lt;IAddOrUpdateDescriptor&gt; ICommandRepository.AddOrUpdate(IEnumerable&lt;Entity&gt; entities)</code>,默认情况下调用另一个由子类实现的<code class="fe pk pl pm pn b">IEnumerable&lt;IAddOrUpdateDescriptor&gt; AddOrUpdate(IEnumerable&lt;TEntity&gt; entities)</code>,但是，我们对传入的类型添加了额外的检查，以确保它与预期的类型相匹配。</li><li id="265b" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">对于<code class="fe pk pl pm pn b">bool ICommandRepository.Delete(Entity entity)</code>,默认情况下调用另一个由子类实现的<code class="fe pk pl pm pn b">bool Delete(TEntity entity)</code>,但是，我们对传入的类型增加了额外的检查，以确保它与预期的类型相匹配。</li><li id="dd7b" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">对于<code class="fe pk pl pm pn b">IDictionary&lt;int, bool&gt; ICommandRepository.Delete(IEnumerable&lt;Entity&gt; entities)</code>，默认情况下调用另一个<code class="fe pk pl pm pn b">IDictionary&lt;int, bool&gt; Delete(IEnumerable&lt;TEntity&gt; entities)</code>，它将由子类实现，但是，我们对传入的类型增加了额外的检查，以确保它与预期的类型相匹配。</li></ol></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h2 id="21b0" class="ny lj it bd lk nz oa dn lo ob oc dp ls mj od oe lu mn of og lw mr oh oi ly iz bi translated">员工查询和命令存储库</h2><p id="f39c" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">现在，是时候实现我们的雇员<strong class="mc jd">查询</strong>和<strong class="mc jd">命令</strong>存储库了。这是我们开始从基础抽象类<code class="fe pk pl pm pn b">CommandRepository&lt;TEntity&gt;</code>和<code class="fe pk pl pm pn b">QueryRepository&lt;TEntity&gt;</code>继承的地方。</p><p id="f2ff" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">但是，首先让我们澄清一下，在我们的例子中，我们不会使用一个真实的数据库来存储我们的雇员数据。我们要做的是创建一个静态列表。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h2 id="3453" class="ny lj it bd lk nz oa dn lo ob oc dp ls mj od oe lu mn of og lw mr oh oi ly iz bi translated">员工持久性</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pi pj l"/></div></figure><p id="0153" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">就像员工名单一样简单。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h2 id="5219" class="ny lj it bd lk nz oa dn lo ob oc dp ls mj od oe lu mn of og lw mr oh oi ly iz bi translated">EmployeeQueryRepository</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pi pj l"/></div></figure><p id="a222" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们在这里可以注意到:</p><ol class=""><li id="5e43" class="ot ou it mc b md mw mg mx mj po mn pp mr pq mv oy oz pa pb bi translated"><code class="fe pk pl pm pn b">EmployeeQueryRepository</code>类继承自<code class="fe pk pl pm pn b">QueryRepository&lt;Employee&gt;</code>。</li><li id="5481" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">我们不必实现来自非泛型<code class="fe pk pl pm pn b">IQueryRepository</code>接口的方法，因为它们已经在抽象基类<code class="fe pk pl pm pn b">QueryRepository&lt;TEntity&gt;</code>中实现了。</li><li id="4bfb" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">所有的<strong class="mc jd"> Get </strong>方法最终都在调用<code class="fe pk pl pm pn b">IQueryResult&lt;Employee&gt; Get(Func&lt;Employee, bool&gt; predicate, int? pageSize, int? pageIndex)</code>方法中的集中式逻辑，神奇的事情发生了。</li><li id="6aaf" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">在这个方法中，使用静态的<code class="fe pk pl pm pn b">MaxResultsCountPerPage</code>和我们在<strong class="mc jd">分页</strong>部分实现的<code class="fe pk pl pm pn b">Page</code>扩展方法进行节流。</li></ol></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h2 id="e02c" class="ny lj it bd lk nz oa dn lo ob oc dp ls mj od oe lu mn of og lw mr oh oi ly iz bi translated">雇员命令仓库</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pi pj l"/></div></figure><p id="721f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们在这里可以注意到:</p><ol class=""><li id="a418" class="ot ou it mc b md mw mg mx mj po mn pp mr pq mv oy oz pa pb bi translated"><code class="fe pk pl pm pn b">EmployeeCommandRepository</code>类继承自<code class="fe pk pl pm pn b">CommandRepository&lt;Employee&gt;</code>。</li><li id="76d7" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">我们不必实现来自非泛型<code class="fe pk pl pm pn b">ICommandRepository</code>接口的方法，因为它们已经在抽象基类<code class="fe pk pl pm pn b">CommandRepository&lt;TEntity&gt;</code>中实现了。</li><li id="ed85" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">实现这些方法只是为了使用静态雇员列表。</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pr"><img src="../Images/9b07e3edb62d9965f6544a3e7cd3995f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K1vSxzCpNyH_KEz02bQKMg.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">布鲁诺·范德克朗在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="d895" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">斗牛中的最后一剑</h1><p id="1fd3" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">现在，是时候测试我们的设计了。我为快速测试创建了一个控制台应用程序。</p><p id="2dec" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">测试将分为三个部分:</p><ol class=""><li id="b523" class="ot ou it mc b md mw mg mx mj po mn pp mr pq mv oy oz pa pb bi translated">演示基本操作。</li><li id="545c" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">演示错误的铸造检查。</li><li id="6de1" class="ot ou it mc b md pc mg pd mj pe mn pf mr pg mv oy oz pa pb bi translated">演示如何处理抽象概念。</li></ol><p id="0a7a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，我们将以如下的<code class="fe pk pl pm pn b">Program</code>类结束:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pi pj l"/></div></figure><p id="b623" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们还定义了一个继承自Entity的<code class="fe pk pl pm pn b">Student</code>类，我们将在某个时候使用它进行测试。</p><p id="2c17" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在，我们来逐一实现<code class="fe pk pl pm pn b">DemonstratingBasicOperation()</code>、<code class="fe pk pl pm pn b">DemonstratingWrongCastingChecks()</code>和<code class="fe pk pl pm pn b">DemonstratingDealingWithAbstractions()</code>。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h2 id="cec7" class="ny lj it bd lk nz oa dn lo ob oc dp ls mj od oe lu mn of og lw mr oh oi ly iz bi translated">演示基本操作</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pi pj l"/></div></figure></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="69ce" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们先调用<code class="fe pk pl pm pn b">var result = m_EmployeeQueryRepository.GetAll();</code>，然后调用<code class="fe pk pl pm pn b">Console.WriteLine(result);</code>，结果是:</p><blockquote class="ps pt pu"><p id="26cb" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">ActualPageZeroIndex: 0</p><p id="1df8" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">分页描述符:<br/>———<br/>实际页数:5 <br/>页数:2</p><p id="ab92" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">pages boundries:<br/>————<br/>第一项零索引:0，最后一项零索引:4 <br/>第一项零索引:5，最后一项零索引:5</p><p id="25aa" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">结果:<br/>———<br/>Id:0，姓名:艾哈迈德<br/> Id: 1，姓名:塔里克<br/> Id: 2，姓名:帕特里克<br/> Id: 3，姓名:穆罕默德<br/> Id: 4，姓名:萨拉</p></blockquote><p id="3a42" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，<strong class="mc jd"> Get All </strong>工作正常。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="25d0" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然后我们调用<code class="fe pk pl pm pn b">result = m_EmployeeQueryRepository.Get(result.PagingDescriptor.ActualPageSize, result.ActualPageZeroIndex + 1);</code>，后面跟着<code class="fe pk pl pm pn b">Console.WriteLine(result);</code>，结果是:</p><blockquote class="ps pt pu"><p id="84e5" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">ActualPageZeroIndex: 1</p><p id="ff1b" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">分页描述符:<br/>————<br/>实际页数:5 <br/>页数:2</p><p id="970d" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">pages boundries:<br/>————<br/>first item zero index:0，last item zero index:4<br/>first item zero index:5，LastItemZeroIndex: 5</p><p id="f827" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">结果:<br/>——————————<br/>Id:5，姓名:阿里</p></blockquote><p id="411f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，<strong class="mc jd">获取分页</strong>工作正常。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="a0b4" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然后我们调用<code class="fe pk pl pm pn b">result = m_EmployeeQueryRepository.Get(6, 0);</code>，后面跟着<code class="fe pk pl pm pn b">Console.WriteLine(result);</code>，结果是:</p><blockquote class="ps pt pu"><p id="a3e7" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">ActualPageZeroIndex: 0</p><p id="1c8b" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">分页描述符:<br/>———<br/>实际页数:5 <br/>页数:2</p><p id="d0b4" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">pages boundries:<br/>————<br/>first item zero index:0，last item zero index:4<br/>first item zero index:5，LastItemZeroIndex: 5</p><p id="3a92" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">结果:<br/>———<br/>Id:0，姓名:艾哈迈德<br/> Id: 1，姓名:塔里克<br/> Id: 2，姓名:帕特里克<br/> Id: 3，姓名:穆罕默德<br/> Id: 4，姓名:萨拉</p></blockquote><p id="65e5" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这里我们需要记住<strong class="mc jd"> 5 </strong>项的应用节流限制。分析这一点，我们会确信<strong class="mc jd">使用分页</strong>工作正常。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="7d9a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然后我们先调用<code class="fe pk pl pm pn b">var tarek = m_EmployeeQueryRepository.Get(2);</code>，再调用<code class="fe pk pl pm pn b">Console.WriteLine(tarek);</code>，结果是:</p><blockquote class="ps pt pu"><p id="e3bc" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">Id: 1，姓名:Tarek</p></blockquote><p id="30be" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，<strong class="mc jd"> Get By Id </strong>工作正常。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="8c90" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然后我们先调用<code class="fe pk pl pm pn b">result = m_EmployeeQueryRepository.Get(emp =&gt; emp.Name.ToLower().Contains(“t”));</code>，再调用<code class="fe pk pl pm pn b">Console.WriteLine(result);</code>，结果是:</p><blockquote class="ps pt pu"><p id="72ad" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">ActualPageZeroIndex: 0</p><p id="f165" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">分页描述符:<br/>———<br/>实际页数:2 <br/>页数:1</p><p id="1c17" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">pages boundries:<br/>————<br/>first item zero index:0，LastItemZeroIndex: 1</p><p id="5237" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">结果:<br/>———<br/>Id:1，姓名:Tarek <br/> Id: 2，姓名:Patrick</p></blockquote><p id="b88a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，<strong class="mc jd"> Get With谓词过滤器</strong>工作正常。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="e05f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然后我们调用<code class="fe pk pl pm pn b">var erikId = m_EmployeeCommandRepository.Add(new Employee(0, “Erik”));</code>，后面跟着<code class="fe pk pl pm pn b">Console.WriteLine(erikId);</code>，结果是:</p><blockquote class="ps pt pu"><p id="9c74" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi">6</p></blockquote><p id="20f1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，<strong class="mc jd">添加</strong>工作正常。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="9464" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">那我们就打电话</p><blockquote class="ps pt pu"><p id="23d3" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">var added = m _ EmployeeCommandRepository。Add(new [] <br/> {新员工(0，“哈桑”)、新员工(0，“麦”)、新员工(0，“约翰”)})；</p></blockquote><p id="6560" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">其次是<code class="fe pk pl pm pn b">Console.WriteLine(String.Join(“\r\n”, added));</code>，结果是:</p><blockquote class="ps pt pu"><p id="cb7c" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">7 <br/> 8 <br/> 9</p></blockquote><p id="13d3" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，<strong class="mc jd">添加集合</strong>工作正常。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="6323" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">那我们就打电话</p><blockquote class="ps pt pu"><p id="cdb5" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">m_EmployeeCommandRepository。更新(新员工(1，“Tarek —更新”))；<br/>var tarek updated = m _ EmployeeQueryRepository。get(1)；</p></blockquote><p id="aaa3" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">接着是<code class="fe pk pl pm pn b">Console.WriteLine(tarekUpdated);</code>，结果是:</p><blockquote class="ps pt pu"><p id="3ce7" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">Id: 1，姓名:Tarek —已更新</p></blockquote><p id="1732" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，<strong class="mc jd">更新</strong>工作正常。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="2016" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">那我们就打电话</p><blockquote class="ps pt pu"><p id="7de3" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">m_EmployeeCommandRepository。AddOrUpdate(新员工(1，“Tarek —已更新—已更新)”)；<br/>var tarekUpdatedUpdated = m _ EmployeeQueryRepository。get(1)；</p></blockquote><p id="59f6" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">接着是<code class="fe pk pl pm pn b">Console.WriteLine(tarekUpdatedUpdated);</code>，结果是:</p><blockquote class="ps pt pu"><p id="e823" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">Id: 1，姓名:Tarek —更新—更新</p></blockquote><p id="a96d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，<strong class="mc jd">添加或更新</strong>工作正常。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="5d49" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然后我们调用<code class="fe pk pl pm pn b">var deletedTarek = m_EmployeeCommandRepository.Delete(1);</code>，后面跟着<code class="fe pk pl pm pn b">Console.WriteLine(deletedTarek);</code>，结果是:</p><blockquote class="ps pt pu"><p id="fe67" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">真实的</p></blockquote><p id="7ab4" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然后呼叫<code class="fe pk pl pm pn b">var checkTarek = m_EmployeeQueryRepository.Get(1);</code>接着是<code class="fe pk pl pm pn b">Console.WriteLine(checkTarek != null);</code>，结果是:</p><blockquote class="ps pt pu"><p id="ea78" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">错误的</p></blockquote><p id="8853" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">所以，<strong class="mc jd">删除</strong>工作正常。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h2 id="3fd6" class="ny lj it bd lk nz oa dn lo ob oc dp ls mj od oe lu mn of og lw mr oh oi ly iz bi translated">演示错误的铸造检查</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pi pj l"/></div></figure></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="1ad2" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们通过转换<code class="fe pk pl pm pn b">m_EmployeeQueryRepository</code>来定义类型为<code class="fe pk pl pm pn b">IQueryRepository</code>的局部变量<code class="fe pk pl pm pn b">queryRepository</code>。</p><p id="5cc9" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><code class="fe pk pl pm pn b">var queryRepository = m_EmployeeQueryRepository as IQueryRepository;</code></p><p id="9b42" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">并通过强制转换<code class="fe pk pl pm pn b">m_EmployeeCommandRepository</code>来定义类型为<code class="fe pk pl pm pn b">ICommandRepository</code>的局部变量<code class="fe pk pl pm pn b">commandRepository</code>。</p><p id="728e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><code class="fe pk pl pm pn b">var commandRepository = m_EmployeeCommandRepository as ICommandRepository;</code></p><p id="0c11" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然后，当试图执行<code class="fe pk pl pm pn b">commandRepository.Add(new Student());</code>时，失败并出现异常<code class="fe pk pl pm pn b">System.ArgumentException: ‘The type “BetterRepository.Student” does not match the type “BetterRepository.Entities.Employee”’</code>。</p><p id="ac4f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然后，当试图执行<code class="fe pk pl pm pn b">commandRepository.Add(new Student[] { new Student(), new Student() });</code>时，失败并出现异常<code class="fe pk pl pm pn b">System.ArgumentException: The type “BetterRepository.Student[]” does not match the type “System.Collections.Generic.IEnumerable`1[BetterRepository.Entities.Employee]”</code>。</p><p id="43e3" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，<strong class="mc jd">错误铸造检查</strong>工作正常。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h2 id="7c53" class="ny lj it bd lk nz oa dn lo ob oc dp ls mj od oe lu mn of og lw mr oh oi ly iz bi translated">演示如何处理抽象概念</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pi pj l"/></div></figure><p id="84a1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">首先，我们重置员工列表<code class="fe pk pl pm pn b">EmployeePersistence.Reset();</code>。</p><p id="6921" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然后，我们通过强制转换<code class="fe pk pl pm pn b">m_EmployeeQueryRepository</code>来定义类型为<code class="fe pk pl pm pn b">IQueryRepository</code>的局部变量<code class="fe pk pl pm pn b">queryRepository</code>。</p><p id="6153" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><code class="fe pk pl pm pn b">var queryRepository = m_EmployeeQueryRepository as IQueryRepository;</code></p><p id="af31" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">并通过强制转换<code class="fe pk pl pm pn b">m_EmployeeCommandRepository</code>来定义类型为<code class="fe pk pl pm pn b">ICommandRepository</code>的局部变量<code class="fe pk pl pm pn b">commandRepository</code>。</p><p id="0ade" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><code class="fe pk pl pm pn b">var commandRepository = m_EmployeeCommandRepository as ICommandRepository;</code></p><p id="ad8f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然后我们执行:</p><blockquote class="ps pt pu"><p id="5cdb" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">//当我们实际上不知道他们的类型<br/> //并且我们不关心他们的类型<br/>var first two items = query repository时，获取前两个雇员。Get(2，0)；<br/>控制台。WriteLine(first two items)；</p></blockquote><p id="0c1d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">结果是:</p><blockquote class="ps pt pu"><p id="1462" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">Id: 0，姓名:艾哈迈德<br/> Id: 1，姓名:塔里克</p></blockquote><p id="bddd" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然后我们执行:</p><blockquote class="ps pt pu"><p id="7ae5" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">//现在我们在不知道它们的类型<br/> //也不关心它们的类型<br/> commandRepository的情况下，盲目地删除前两项。删除(前两项。结果)；</p><p id="c8db" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">//现在我们再次让前两个雇员来检查它是否有效<br/>first two items = query repository。Get(2，0)；<br/>控制台。WriteLine(first two items)；</p></blockquote><p id="d4a1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">结果是:</p><blockquote class="ps pt pu"><p id="77e5" class="ma mb pv mc b md mw kd mf mg mx kg mi pw my ml mm px mz mp mq py na mt mu mv im bi translated">Id: 2，姓名:帕特里克<br/> Id: 3，姓名:穆罕默德</p></blockquote><p id="2116" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，<strong class="mc jd">处理抽象</strong>工作正常。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pz"><img src="../Images/be67180360063f52236fe5798b9e7c26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-DQBwCCUFLf2nA9MWKnE_Q.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">Arthur Chauvineau 在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="b8a7" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">最后的话</h1><p id="939d" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">哇，长途旅行。现在，让我们休息一下，放松一下，退一步看大局。</p><p id="6f0e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们在这里实现的不是火箭科学。这些概念并不难，只是在实现时要有稳定的手。</p><p id="2548" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">就这样，希望你觉得读这个故事和我写它一样有趣。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="e70f" class="li lj it bd lk ll qa ln lo lp qb lr ls ki qc kj lu kl qd km lw ko qe kp ly lz bi translated">希望这些内容对你有用。如果您想支持:</h1><p id="41c8" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">如果您还不是<strong class="mc jd">媒介</strong>会员，您可以使用<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek/membership" rel="noopener"> <strong class="mc jd">我的推荐链接</strong> </a>，这样我就可以从<strong class="mc jd">媒介</strong>那里获得您的一部分费用，您无需支付任何额外费用。订阅<a class="ae lh" href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener"> <strong class="mc jd">我的简讯</strong> </a>将最佳实践、教程、提示、技巧和许多其他很酷的东西直接发送到您的收件箱。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="b633" class="li lj it bd lk ll qa ln lo lp qb lr ls ki qc kj lu kl qd km lw ko qe kp ly lz bi translated">其他资源</h1><p id="643b" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">这些是你可能会发现有用的其他资源。</p><div class="qf qg gp gr qh ni"><a rel="noopener  ugc nofollow" target="_blank" href="/paging-partitioning-main-equations-to-make-it-easy-44fe89d5290b"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd jd gy z fp nn fr fs no fu fw jc bi translated">分页/分区—简化这一过程的主要等式</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">最后，这是您理解分页/分区主要等式并学习如何在代码中应用它们的机会。</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nr l"><div class="qi l nt nu nv nr nw lb ni"/></div></div></a></div><div class="qf qg gp gr qh ni"><a href="https://itnext.io/when-string-gethashcode-in-net-c-drives-you-crazy-c97ac7507d7b" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd jd gy z fp nn fr fs no fu fw jc bi translated">当字符串。中的GetHashCode()。NET C#让你抓狂</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">知道什么时候依赖字符串。中的GetHashCode()。NET C#，而当不是。</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">itnext.io</p></div></div><div class="nr l"><div class="qj l nt nu nv nr nw lb ni"/></div></div></a></div><div class="qf qg gp gr qh ni"><a rel="noopener  ugc nofollow" target="_blank" href="/useful-free-online-tools-for-developers-ed882d4761c1"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd jd gy z fp nn fr fs no fu fw jc bi translated">对开发者有用的免费在线工具</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">这是一个有用的免费在线工具列表，可以帮助开发者完成日常任务。</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nr l"><div class="qk l nt nu nv nr nw lb ni"/></div></div></a></div><div class="qf qg gp gr qh ni"><a rel="noopener  ugc nofollow" target="_blank" href="/mistakes-made-by-developers-79af38b070b7"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd jd gy z fp nn fr fs no fu fw jc bi translated">开发人员犯的错误</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">这些是开发人员最常犯的错误。</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nr l"><div class="ql l nt nu nv nr nw lb ni"/></div></div></a></div></div></div>    
</body>
</html>