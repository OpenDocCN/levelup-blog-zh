<html>
<head>
<title>What are General Responsibility Assignment Software Patterns?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是一般责任分配软件模式？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-are-general-responsibility-assignment-software-patterns-6ad9635a44da?source=collection_archive---------5-----------------------#2020-01-05">https://levelup.gitconnected.com/what-are-general-responsibility-assignment-software-patterns-6ad9635a44da?source=collection_archive---------5-----------------------#2020-01-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d465" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">低耦合、高内聚和其他七个重要的解释规则</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5114309ff3b5e4c0d60beeee5c725297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NHz8sXn8waNzZOpn0CF3-Q.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">路易斯·金特罗在<a class="ae ky" href="https://unsplash.com/s/photos/hand?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="b3bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编程中有很多有用的缩写词。并不是每一种都像固体或干燥一样具有超级明星的地位，但不太为人所知的仍然非常有用。GRASP有助于为类和对象分配职责。如果你关心写干净的代码，这些绝对值得知道。</p><h2 id="339f" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">1.信息专家</h2><p id="d278" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我应该在哪里添加新的功能或方法？这是开发人员每天问自己的最常见的问题之一。它通常是不平凡的，会引起很多头痛。</p><p id="2d12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">信息专家模式指出，我们应该寻找完成任务所需的信息。最了解它们的地方是放置该功能的最佳候选地。这样的类是为它准备的最好的，并且需要最少的修改来实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8b10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，列表的内部结构(标题和内容)泄露了。正在使用它的属性并将它们转换成HTML。这样的操作应该放在<code class="fe mv mw mx my b">Listing</code>里面。它已经有了所有需要的数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d9a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“告诉不要问”是一个规则，它规定对数据进行操作的方法应该与数据本身在同一个位置。这种方法与GRASP的信息专家非常相似。</p><h2 id="765a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">2.创造者</h2><p id="0230" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">创建新对象可能是一项非常棘手的工作。它可能包含多个步骤，并需要不同的依赖项。这是正确的地方吗？我们应该直接创建一个新对象还是使用工厂？造物主应该帮助我们做出这样的决定。</p><p id="1d3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据Creator，应该满足一个或多个规则，以便类<code class="fe mv mw mx my b">Foo</code>可以创建类<code class="fe mv mw mx my b">Bar</code>的新实例:</p><ol class=""><li id="9ed6" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><code class="fe mv mw mx my b">Foo</code>聚集<code class="fe mv mw mx my b">Bar</code>类型的对象</li><li id="43ac" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe mv mw mx my b">Foo</code>拥有初始化<code class="fe mv mw mx my b">Bar</code>所需的所有信息</li><li id="7c4e" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe mv mw mx my b">Foo</code>紧密使用<code class="fe mv mw mx my b">Bar</code>的实例</li><li id="977c" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe mv mw mx my b">Foo</code>记录一个类的实例<code class="fe mv mw mx my b">Bar</code></li></ol><p id="bf82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工厂方法和抽象工厂是强烈支持这种方法的设计模式。</p><h2 id="5405" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">3.控制器</h2><p id="de99" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这条规则规定，应该有一个与应用程序的业务逻辑分离的地方负责处理请求。它控制应用程序中会发生什么，并知道如何处理给定的用例。控制器本身不应该做任何其他事情，也没有业务逻辑。更确切地说，它是一种将工作委托给应用程序的适当部分的服务。</p><p id="b191" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们没有一个作为应用程序接口的控制器，就很容易产生许多不必要的依赖。我们可能会以纠缠不清的代码和大量的依赖关系而告终。</p><p id="6d15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模型-视图-控制器是一个众所周知的架构模式。MVC中的控制器处理请求，并使用模型来处理业务逻辑。这可以被认为是GRASP控制器的一个具体用例。</p><h2 id="df45" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">4.低耦合</h2><p id="e179" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">低耦合和高内聚是每个设计良好的系统的目标。这些很容易成为流行词汇，值得花点时间思考每个术语背后的想法。</p><p id="8ec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个软件系统在其模块和类之间都有关系和依赖。耦合是对软件组件如何相互依赖的一种度量。有不同类型的耦合。它可以基于发送的数据、触发操作或共享逻辑等属性。</p><p id="64e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当应用程序的各个部分知道彼此的实现细节时，就会发生紧密耦合。当系统的一部分改变时，其他部分也必须修改才能正常工作。低耦合基于抽象，使我们的系统更加模块化。不相关的事物不应该互相依赖。</p><p id="996e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">静态代码分析可以成为耦合测量的有用工具。</p><h2 id="dc65" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">5.高内聚力</h2><p id="a19d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">内聚性是我们的模块或类如何专注于单一职责的指示器。低内聚的软件具有非常广泛的任务范围。低内聚性软件的元素可以被转移到单独的单元，而不改变它的其他部分。具有许多不相关的实用方法的助手类是低内聚的典型例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="adbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mv mw mx my b">Utils</code>凝聚力很低。每个操作都不相互链接，并且对不同的数据进行操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/4ccd8d6cce034acc64af72a809bc1ee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y_4nGmPPuK2_xuMC7BYyBw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">要多努力才能分？—<a class="ae ky" href="https://unsplash.com/@lookscanshoot?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">劳尔·巴里奥斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/forging?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="867e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，高内聚的类需要很大的努力才能分成更小的类。此外，这些更小的类变得紧密耦合。</p><p id="710a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时变化的元素应该放在一起，因为这表明它们是紧密相关的。</p><p id="4660" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">耦合和内聚是非常相关的术语。</p><h2 id="bd47" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">6.间接</h2><p id="cb0d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">对象之间不应该有不必要的相互了解。我们希望减少应用程序某些部分之间的关系/耦合是一个常见的原因。间接模式引入了一个处理通信的中介。</p><p id="52e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">观察者、外观、桥、中介或适配器是利用间接方法的设计模式。根据使用案例和需求，我们可以使应用程序的各个部分更加独立。MVC模式中的控制器也是使用间接方法的一个例子。它将视图与模型分开。</p><p id="c763" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应该谨慎使用这种模式，因为我们可能会以巧合的复杂性而告终。</p><h2 id="da69" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">7.多态性</h2><p id="b3d0" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">多态性是面向对象编程的一个非常强大的特性。如果我们想用不同的行为表示相关的类，我们应该使用多态性。因此，客户可以使用抽象，而不是特定的具体实现，我们可以摆脱不必要的ifology。</p><h2 id="13f4" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">8.纯粹捏造</h2><p id="bfc3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果我们的应用程序的某个部分似乎有太多的职责，那么它可能会被转移到一个单独的服务中。此类服务不代表我们领域的任何特定责任。这些助手类对保持我们的代码更加整洁非常有帮助。</p><p id="88f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的一个例子是将发票保存到数据库中。<code class="fe mv mw mx my b">Invoice</code>是一个存放所有发票数据和操作的地方。对于与存储数据相关的逻辑，它也是一个很好的候选对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="08b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">凭直觉，我们知道这是不对的。连接数据库和使用SQL会使我们的类过于复杂。我们可以很容易地将这个操作转移到一个单独的服务中，该服务将只处理这个职责。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="0bc6" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">9.受保护的变化</h2><p id="a90e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">每个软件应用程序都在不断变化。这是软件的本质，而不是坏事。结果往往与我们的计划相差甚远。我们在开发过程中发现新的需求和期望，并需要调整我们的应用程序行为。</p><p id="6e29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">面向对象编程的特征之一是封装。实现细节应该对客户端隐藏。如果应用程序某个部分的内部表示或行为发生变化，其公共接口应该保持不变。我们应该让客户看不到逻辑和将来可能改变的部分。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="e5a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些规则对你来说可能很明显。说明你是一个扎实的开发者，不自觉的跟着他们走。对你有好处。尽管如此，知道他们的名字也是好的。</p><h2 id="ee16" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">资源:</h2><ul class=""><li id="fdab" class="mz na it lb b lc mo lf mp li nv lm nw lq nx lu ny nf ng nh bi translated">“应用UML和模式:面向对象分析和设计以及统一过程的介绍”，Craig Larman</li><li id="e957" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ny nf ng nh bi translated"><a class="ae ky" href="https://martinfowler.com/bliki/TellDontAsk.html" rel="noopener ugc nofollow" target="_blank">https://martinfowler.com/bliki/TellDontAsk.html</a></li><li id="445c" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ny nf ng nh bi translated"><a class="ae ky" href="https://blog.ndepend.com/lack-of-cohesion-methods/" rel="noopener ugc nofollow" target="_blank">https://blog.ndepend.com/lack-of-cohesion-methods/</a></li></ul></div></div>    
</body>
</html>