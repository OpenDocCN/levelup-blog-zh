<html>
<head>
<title>Managing User Sessions In Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Android中管理用户会话</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/managing-user-sessions-in-android-360fbf2822?source=collection_archive---------7-----------------------#2020-04-16">https://levelup.gitconnected.com/managing-user-sessions-in-android-360fbf2822?source=collection_archive---------7-----------------------#2020-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e9a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我最终不得不建造我的图书馆</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/2e4e474305901145df5758124016e127.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CmzX6J3LAIzLk1X9kUdqaQ.png"/></div></div></figure><p id="4c1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在过去的3个月里，我一直在并行开发3个Android应用程序。我不得不承认，这确实让你付出了代价。然而，你也开始认识到模式和冗余。其中一个模式是关于用户会话管理的。</p><p id="6f4f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们先简单了解一下什么是会话管理，而不要过多涉及技术细节。通常，术语会话管理是指只要某些条件成立，就保持某些系统值或状态的过程。我们希望维护的常见状态的一个例子是那些经过身份验证的用户身份。</p><p id="8854" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Android提供了几种方法来实现这一点，但一种常见的方法是使用SharedPreferences，它提供了一种以键-值对的形式存储和检索原始数据类型的简化方法。还有像AccountManagers这样的其他方法，但是说实话，如果您正在开发一个简单的应用程序，这种方法就有点过头了。</p><h2 id="ff6d" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">那么，在一次典型的会议中，具体包括哪些内容呢？</h2><p id="a772" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">当用户输入有效的凭据(<em class="ly">电话号码和OTP组合、用户名/电子邮件和密码组合等</em>)时，典型的流程大致如下:</p><ul class=""><li id="ea24" class="lz ma it js b jt ju jx jy kb mb kf mc kj md kn me mf mg mh bi translated">凭证由服务器验证</li><li id="0b52" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated">服务器发送回响应</li><li id="2aed" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated">该响应包含访问令牌、刷新令牌和到期时间(通常以秒为单位)</li></ul><p id="43b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦您收到这个响应，维护一个会话将类似于:</p><ul class=""><li id="a892" class="lz ma it js b jt ju jx jy kb mb kf mc kj md kn me mf mg mh bi translated">存储令牌、访问令牌和到期时间</li><li id="2cfe" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated">通过添加用户登录时间和令牌到期时间来跟踪实际到期日期</li><li id="7802" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated">当用户回到应用程序时，根据他们回来的时间和令牌应该过期的时间，检查令牌是否过期</li><li id="fb5e" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated">如果令牌过期，则使用刷新令牌调用服务器以获取新的访问令牌</li><li id="d0f0" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated">替换访问令牌、刷新令牌和到期时间</li><li id="8d6a" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated">重复</li></ul><p id="50dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于一个应用程序来说，这很好。构建一个简单的效用函数来完成所有这些，瞧，你就完成了。然而，请注意，当使用多个独立的应用程序时，这变得多么多余？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mn"><img src="../Images/185fcb3aad9c888c96b8c6ffb4a0b6a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*92jHMFvSDuc3_xn6Epva0w.jpeg"/></div></div></figure><p id="a1d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我寻找一个现有的库，它能做我想让它做的事情。我发现了几个，虽然它们没有被维护，而且似乎被废弃了。</p><p id="06de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本着DRY原则的精神，我决定将这个实用函数打包成一个类，并将其导出为一个库。</p><h2 id="d5a2" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">它是做什么的？</h2><p id="064e" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">这个库抽象了我们刚刚提到的内容，剩下的只是对各种方法的简单调用。</p><p id="af02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看我们的出发点。我首先决定使用单例模式。我这样做是为了确保一个全局访问点和一个我想要使用的对象实例。幸运的是，科特林让这变得超级简单</p><p id="1f28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用的单例对象</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="4752" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一步是为我们需要的方法定义存根</p><p id="14ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在非常基本的层面上，我们希望:</p><ul class=""><li id="fd8a" class="lz ma it js b jt ju jx jy kb mb kf mc kj md kn me mf mg mh bi translated">开始会话</li><li id="63da" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated">检查当前会话是否处于活动状态</li><li id="7562" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated">如果需要，结束会话</li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mo mp l"/></div></figure></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h2 id="2476" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">1.启动用户会话</h2><p id="5f80" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">如上所述，一旦我们从服务器检索到带有访问令牌、刷新令牌和到期时间的响应，用户会话就会开始。因此，要启动用户会话，我们需要:</p><ul class=""><li id="55f3" class="lz ma it js b jt ju jx jy kb mb kf mc kj md kn me mf mg mh bi translated">存储访问令牌</li><li id="2831" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated">存储到期时间=用户登录时间+令牌到期时间</li></ul><p id="0afd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用共享的引用。因此，我们也需要上下文。</p><p id="6c88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们重构启动会话的方法来反映这一点:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h2 id="2095" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">2.检查会话是否处于活动状态</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="5b71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一步是我们更新方法来检查当前会话是否仍然是活动的或者应该结束。</p><p id="9735" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了让我们检查当前会话是否是活动的，我们需要知道它是在什么时间被检查的。这就是我们称为“当前时间”的论点</p><h2 id="a42b" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">3.结束会话</h2><p id="c997" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">最后，我们需要结束会话。这包括从SharedPreference中清除所有数据。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mo mp l"/></div></figure></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h2 id="d44a" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">使用图书馆的一个例子</h2><p id="d09d" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">使用活动上的库来启动会话并检查当前会话的示例如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h2 id="8c0b" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">结论</h2><p id="5cbf" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">我很想听听你们是如何处理会议的。我将致力于重构这个库，这样您只需启动一次会话，并且检查会话是否处于活动状态是作为后台任务来完成的，这样就不需要一直调用方法来检查会话。</p><p id="7840" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">建议也非常感谢</p><p id="3561" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个库可以在GitHub上找到—<a class="ae mx" href="https://github.com/HenryKenya/session-manager-android" rel="noopener ugc nofollow" target="_blank">https://github.com/HenryKenya/session-manager-android</a></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi my"><img src="../Images/b4030e5e0890aad40c500ef3e32a3a39.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*Hg-wz5hhyNWUG_2YjDX0nA.gif"/></div></figure></div></div>    
</body>
</html>