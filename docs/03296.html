<html>
<head>
<title>JavaScript Best Practices for Writing More Robust Code — Tools and Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更健壮代码的JavaScript最佳实践—工具和测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-for-writing-more-robust-code-tools-and-tests-6aafd8e3578?source=collection_archive---------11-----------------------#2020-04-30">https://levelup.gitconnected.com/javascript-best-practices-for-writing-more-robust-code-tools-and-tests-6aafd8e3578?source=collection_archive---------11-----------------------#2020-04-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2f3114720b7ce15e2fad982506994b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*USsPO7BWojnnRX5k"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@barnimages?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">谷仓图片</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="f469" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种简单易学的编程语言。编写运行并执行某些操作的程序很容易。然而，很难考虑所有的用例并编写健壮的JavaScript代码。</p><p id="b982" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些用于编写健壮的JavaScript代码的工具和测试最佳实践。</p><h1 id="0032" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用类型脚本</h1><p id="082a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">TypeScript是一种语言，它是JavaScript的扩展，为JavaScript代码提供灵活和可选的类型检查。</p><p id="9d41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它将代码构建到JavaScript中，以便可以在浏览器或Node.js环境中运行。</p><p id="6496" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在将代码构建到最终工件之前，会检查代码的类型错误。这意味着防止了数据类型错误，如果没有被TypeScript检查，这将是运行时错误。</p><p id="7067" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一大类被消除的错误。类型检查并不严格。它提供了许多方法来注释对象的类型和函数的返回类型。</p><p id="0fa1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以创建接口来注释对象类型，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5281" class="mq lf it mm b gy mr ms l mt mu">interface Pet {<br/>    name: string;<br/>    walk(): void;<br/>}</span></pre><p id="6a2f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们创建了一个接口来指示任何具有类型<code class="fe mv mw mx mm b">Pet</code>的东西都必须具有<code class="fe mv mw mx mm b">name</code>字符串属性和一个不返回任何内容的<code class="fe mv mw mx mm b">walk</code>方法(因此有了<code class="fe mv mw mx mm b">void</code>返回类型)。</p><p id="139f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们可以如下使用它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b209" class="mq lf it mm b gy mr ms l mt mu">const dog: Pet = {<br/>    name: 'joe',<br/>    walk() {<br/>        console.log('walk');<br/>    }<br/>}</span></pre><p id="08f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们在<code class="fe mv mw mx mm b">dog</code>对象中有了<code class="fe mv mw mx mm b">name</code>字符串属性和<code class="fe mv mw mx mm b">walk</code>方法，满足了接口的要求。</p><p id="d761" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，代码将由TypeScript编译器生成并运行。如果任何东西的类型与接口不同，我们就会得到一个错误。</p><p id="10bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript的另一个好特性是类型检查的灵活性。类型不必是固定的，它们也可以是灵活的和动态的。</p><p id="d1ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下创建可空类型:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f856" class="mq lf it mm b gy mr ms l mt mu">interface Pet {<br/>    name: string;<br/>    walk?(): void;<br/>}</span></pre><p id="7d3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，<code class="fe mv mw mx mm b">walk</code>方法是可选的，方法名后面有<code class="fe mv mw mx mm b">?</code>。现在我们可以在任何类型为<code class="fe mv mw mx mm b">Pet</code>的对象中省略它。</p><p id="39f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以创建多种类型的联合类型，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8d3e" class="mq lf it mm b gy mr ms l mt mu">interface Pet {<br/>    name: string;<br/>    walk(): void;<br/>}</span><span id="1e24" class="mq lf it mm b gy my ms l mt mu">interface Animal {<br/>    breed: string;<br/>}</span><span id="d61b" class="mq lf it mm b gy my ms l mt mu">const dog: Pet | Animal = {<br/>    name: 'joe',<br/>    breed: 'labrador',<br/>    walk(){}<br/>}</span></pre><p id="c4b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有<code class="fe mv mw mx mm b">Pet | Animal</code>类型，它由组合在一起的<code class="fe mv mw mx mm b">Pet</code>和<code class="fe mv mw mx mm b">Animal</code>类型的成员组成。</p><p id="4a72" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们的<code class="fe mv mw mx mm b">dog</code>对象可以包含每个接口的任何成员。</p><p id="4eea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们不必直接指定对象的类型。如果我们的代码中已经有一个对象，并且我们希望另一个对象具有与那个对象相同的数据类型，我们可以使用如下的<code class="fe mv mw mx mm b">typeof</code>操作符来指定类型:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b649" class="mq lf it mm b gy mr ms l mt mu">const cat = {<br/>    name: 'james'<br/>}</span><span id="14b7" class="mq lf it mm b gy my ms l mt mu">const dog: typeof cat = {<br/>    name: 'joe'<br/>}</span></pre><p id="0331" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们用<code class="fe mv mw mx mm b">typeof dog</code>表达式指定了<code class="fe mv mw mx mm b">dog</code>对象的数据类型与<code class="fe mv mw mx mm b">cat</code>的数据类型相同。这样，我们就不必直接指定任何类型。</p><p id="f2b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript有更多的特性，可以帮助我们编写更可靠的JavaScript代码，防止在运行时被捕获的数据类型错误。</p><p id="9fa9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这对于大型应用程序来说尤其重要，因为它们更有可能出现这些错误。</p><p id="71c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该考虑使用TypeScript来编写更健壮的JavaScript代码。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/264d6fcfcdccb7d4a22b98393c8bd72f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wfJ803Fn65cqW02W"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@jerry_318?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jerry Wang </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="d334" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">编写测试</h1><p id="a4b5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该编写自动化测试来检查我们代码中的回归，这样我们在修改代码时就可以安心了，所有的自动化测试都通过了。</p><p id="e8bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用Jest test runner很容易编写自动化测试，它有许多特性让我们可以为前端和后端JavaScript应用程序编写和运行测试。</p><p id="0578" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以用单元测试编写一个简单的函数，如下所示:</p><p id="e608" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">math.js</code>:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8a49" class="mq lf it mm b gy mr ms l mt mu">const multiply = (a, b) =&gt; {<br/>  return a * b;<br/>}<br/>module.exports = {<br/>  multiply<br/>};</span></pre><p id="f451" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">math.test.js</code>:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9bd4" class="mq lf it mm b gy mr ms l mt mu">const math = require('./math');</span><span id="618f" class="mq lf it mm b gy my ms l mt mu">test('multiplies 1 * 2 to equal 2', () =&gt; {<br/>  expect(math.multiply(1, 2)).toBe(2);<br/>});</span></pre><p id="f93c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，<code class="fe mv mw mx mm b">math.js</code>模块有我们想要测试的函数<code class="fe mv mw mx mm b">multiply</code>。</p><p id="2a57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe mv mw mx mm b">math.test.js</code>中，我们添加了测试由<code class="fe mv mw mx mm b">math.js</code>导出的<code class="fe mv mw mx mm b">multiply</code>函数的测试。</p><p id="e76b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">文件名是Jest测试的约定，其中产品代码文件的名称与测试文件的名称相对应。</p><p id="75fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后当我们运行Jest时，这个测试将会运行并且应该通过，因为1乘以2等于2。</p><p id="6001" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们为应用程序的每个部分都编写单元测试，那么就很容易知道我们的应用程序是否仍然正常工作。</p><h1 id="8240" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="4b0e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">TypeScript可能是JavaScript最好的类型检查器。向我们的JavaScript代码添加类型注释和检查是JavaScript的自然扩展。</p><p id="7108" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编写自动化测试总是一个好主意，这样我们可以在修改代码后检查代码是否正常工作。</p></div></div>    
</body>
</html>