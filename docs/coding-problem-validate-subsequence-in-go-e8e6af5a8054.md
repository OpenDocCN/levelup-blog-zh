# 编码问题:在 Go 中验证子序列

> 原文：<https://levelup.gitconnected.com/coding-problem-validate-subsequence-in-go-e8e6af5a8054>

## 让你的计算机科学基础在这个番茄大战中保持敏锐。

![](img/f8d3a9bc81e48fee0420c3e8847b0f1b.png)

来自 [Unsplash](https://images.unsplash.com/photo-1520085601670-ee14aa5fa3e8?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1650&q=80)

验证子序列问题是一个简单的问题，但是它引入了顺序的重要概念。这可以比作寻找一个数组的子集，其中顺序是不相关的。在这篇文章中，我们将理解后续问题本身，编写测试，并最终开发一个解决方案以及它的巨大的时间和空间复杂性。

编码[番茄](https://todoist.com/productivity-methods/pomodoro-technique)现在开始！

***注意:*** *本文假设您知道如何设置 Go 工作区和安装程序依赖项。*

# 理解问题

验证一个子序列需要输入两个独立的数组。其中一个数组是一个序列，而另一个数组是一组值，可能包含也可能不包含该序列。对于编码问题，写一些例子总是一个好的开始:

```
Example #1
array = [1,0,1]
sequence = [1]
result: trueExample #2
array = [1,5,9]
sequence = [9,5]
result: falseExample #3
array = [1,4,-1,6,4,9,10]
sequence = [1,-1,10]
result: true
```

你还能想到哪些基本案例？

# 在 Go 中编写表格驱动的测试

测试驱动开发(TDD)越来越受欢迎，因为它迫使你编写高度测试的最少代码。我发现提高你的 TDD 技能的最好方法之一是在你进入更标准的软件开发环境之前，先从这些编码问题开始。谢天谢地，Go 拥有出色的内置测试支持。

在我们导入了`assert`和`testing`包之后，我们创建了函数`TestValidateSubsequence()`，它带有一个指向`testing.T`对象的指针。从那里，我们可以启动一个结构体数组作为我们的测试用例，用四个字段来描述每个测试。我们总共定义了六个结构来涵盖验证子序列的主要情况，你还能想到别的吗？

在我们定义了充当测试用例的结构数组之后，我们声明了一个`for`循环来覆盖它们。我们获得一个单独的测试用例，然后我们调用`t.Run()`来调用 Go 的测试包。我们也可以从内部调用`t.Parallel()`来提升性能(只是培养好习惯)。接下来，我们通过向函数`ValidateSubsequence()`提供当前测试用例的`inputArray`和`inputSequence`来获得函数`ValidateSubsequence()`的结果。最后，我们断言我们的函数的结果是否和我们从测试用例中所期望的一样。

Go 拥有所有语言中最优雅和简单的测试方法，改变我的想法。

# 解——O(N)时间和 O(1)空间

我只提出一个单一的解决方案，因为没有太多的方法可以解决这个问题而不使其过于复杂。您不能使用 double for 循环来运行子序列的强力检查——这将是查找有效子集的有效解决方案，并且时间为 O(N)。

不管怎样，这个问题的解决方案很简短，但是当您需要查找或验证一个子序列时，它可以用于更复杂的问题。基本上，我们希望在移动到下一个元素之前，跟踪我们是否已经看到了序列中的每个元素。如果我们在数组中找到一个序列元素，那么我们可以增加到下一个序列元素，同时跟踪我们在数组中的位置。

所以，首先我们为数组和序列初始化一个索引。然后，我们开始一个循环，如果任何一个索引超出了各自数组的范围，这个循环就会终止。我们首先检查当前数组元素是否等于当前序列元素。如果是，那么我们找到了一个序列元素匹配，并可以增加我们的序列索引。无论我们是否找到匹配，我们都必须增加数组索引来继续向前搜索。

一旦循环终止，我们返回序列索引是否与原始序列的长度相同的布尔值。我们这样做是因为这可能是真的唯一方式是我们为每个序列元素找到一个有序匹配，因此我们将序列索引增加到序列本身的长度。

该算法的运行时间受限于`array`的长度。这是因为序列只有在匹配的情况下才会递增，而我们总是递增`array`索引。即使序列比数组长，一旦数组索引太大，我们也会终止。因此，我们的时间复杂度是 O(N)，其中 N 是`array`的长度。空间复杂度是常数 O(1 ),因为我们不存储任何额外的数据结构。

我希望你喜欢阅读这篇文章，并能够学到一些新的东西。如果您发现任何部分特别有用，或者想要任何其他编码问题的教程，我鼓励您在下面留下评论！感谢阅读。