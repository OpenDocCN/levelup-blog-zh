<html>
<head>
<title>Clone saga in JavaScript part 3: Deep copying in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的克隆传奇第3部分:JavaScript中的深度复制</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/clone-saga-in-javascript-part-3-deep-copying-in-javascript-fd45bc2a31ad?source=collection_archive---------21-----------------------#2022-12-26">https://levelup.gitconnected.com/clone-saga-in-javascript-part-3-deep-copying-in-javascript-fd45bc2a31ad?source=collection_archive---------21-----------------------#2022-12-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9b83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi ko translated"><span class="l kp ky bm di kz"> <img alt="O" class="la lb lc ld le lf fc n ih dh bf" src="../Images/709408cfc9acccb3f7e693966c5f5992.png" width="67" height="79" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fit:134/1*S8Pi6_Qymqyzy_MOJ4jLhw.png"/> <span class="l kp kq kr bm ks kt ku kv kw di kx"> O </span> </span>你的JavaScript克隆传奇的最终部分已经到来！在这个系列中，我们探讨了用JavaScript复制对象的主题，这是一个由三部分组成的系列。在第一篇文章<a class="ae lg" href="https://pandaquests.medium.com/clone-saga-in-javascript-part-1-different-ways-of-how-to-copy-objects-11f625fa156a" rel="noopener">中，我们讨论了JavaScript </a>中存在哪种复制。在之前的文章中，我们将深入浅出的复制。在这篇文章中，我们将研究深度复制。系好你的安全带。越来越深了。</p><p id="1874" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这只是我们写的许多关于JavaScript或软件开发的文章中的一篇。我们试图每天发表一篇文章——即使是在节假日。关注或订阅我们，这样你就不会错过任何一个。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lh"><img src="../Images/9b05295d810f87a8a9c67f084175cf9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9lgs3ZVnNgrwSRda"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">菲尔·肖在<a class="ae lg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="84e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在JavaScript中，深层副本是对象的副本，它使用原始对象的所有属性和对象创建新对象，包括任何嵌套对象及其属性。在JavaScript中有不同的方法可以实现这一点。</p><ul class=""><li id="8b96" class="lw lx it js b jt ju jx jy kb ly kf lz kj ma kn mb mc md me bi translated">使用JSON.parse()和JSON.stringify()方法:</li></ul><pre class="li lj lk ll gt mf mg mh bn mi mj bi"><span id="8e57" class="mk ml it mg b be mm mn l mo mp">function deepCopy(obj) {<br/> return JSON.parse(JSON.stringify(obj));<br/>}<br/>const original = { a: 1, b: { c: 3 } };<br/>const copy = deepCopy(original);</span></pre><p id="24f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这通过使用JSON.stringify()将原始对象序列化为JSON字符串，然后使用JSON.parse()将JSON字符串解析回对象来创建新对象。这个方法只适用于可序列化为JSON的对象，不包括函数、未定义的和其他一些数据类型。还有一些其他的限制。在本文中阅读更多关于这种技术的局限性的内容。所以，这不是最优解。</p><ul class=""><li id="6de6" class="lw lx it js b jt ju jx jy kb ly kf lz kj ma kn mb mc md me bi translated">使用递归函数:</li></ul><pre class="li lj lk ll gt mf mg mh bn mi mj bi"><span id="aeb0" class="mk ml it mg b be mm mn l mo mp">function deepCopy(obj) {<br/>  if (typeof obj !== 'object' || obj === null) {<br/>    return obj;<br/>  }<br/>  const copy = Array.isArray(obj) ? [] : {};<br/>  for (const key in obj) {<br/>    if (obj.hasOwnProperty(key)) {<br/>      copy[key] = deepCopy(obj[key]);<br/>    }<br/>  }<br/>  return copy;<br/>}<br/>const original = { a: 1, b: { c: 3 } };<br/>const copy = deepCopy(original);</span></pre><p id="7b1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将创建一个新对象，并使用检查每个属性的值的类型的函数递归地将原始对象的属性复制到该对象中。如果该值是一个对象，则该函数调用自身来创建该对象的新副本。此方法适用于任何对象，包括具有函数、未定义和其他数据类型的对象。</p><ul class=""><li id="544f" class="lw lx it js b jt ju jx jy kb ly kf lz kj ma kn mb mc md me bi translated">或者，您可以使用类似lodash或下划线的库，它们提供了_。可用于创建对象深层副本的cloneDeep()函数:</li></ul><pre class="li lj lk ll gt mf mg mh bn mi mj bi"><span id="2e76" class="mk ml it mg b be mm mn l mo mp">const _ = require('lodash');<br/>const original = { a: 1, b: { c: 3 } };<br/>const copy = _.cloneDeep(original);</span></pre><p id="7c26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此方法适用于任何对象，包括具有函数、未定义和其他数据类型的对象。</p><p id="fb83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是用JavaScript创建对象深层副本的几种方法:</p><ul class=""><li id="7d2f" class="lw lx it js b jt ju jx jy kb ly kf lz kj ma kn mb mc md me bi translated">使用Object.getOwnPropertyNames()和Object.defineProperties()方法:</li></ul><pre class="li lj lk ll gt mf mg mh bn mi mj bi"><span id="f0e9" class="mk ml it mg b be mm mn l mo mp">function deepCopy(obj) {<br/>  const copy = {};<br/>  const propNames = Object.getOwnPropertyNames(obj);<br/>  Object.defineProperties(copy, propNames.map(name =&gt; ({<br/>    [name]: Object.getOwnPropertyDescriptor(obj, name)<br/>  })));<br/>  for (const name of propNames) {<br/>    if (typeof obj[name] === 'object' &amp;&amp; obj[name] !== null) {<br/>      copy[name] = deepCopy(obj[name]);<br/>    }<br/>  }<br/>  return copy;<br/>}<br/>const original = { a: 1, b: { c: 3 } };<br/>const copy = deepCopy(original);</span></pre><p id="5842" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将创建一个新的对象，并使用Object.getOwnPropertyNames()方法获取对象自己的属性名数组，使用Object.defineProperties()方法定义新对象的属性，将原始对象自己的属性复制到该对象中。然后，它使用一个循环来迭代数组，如果属性值是一个对象，则递归调用deepCopy()函数来创建该对象的新副本。</p><ul class=""><li id="70d2" class="lw lx it js b jt ju jx jy kb ly kf lz kj ma kn mb mc md me bi translated">使用Reflect.ownKeys()和reflect . getownpropertydescriptor()方法，如下所示:</li></ul><pre class="li lj lk ll gt mf mg mh bn mi mj bi"><span id="417c" class="mk ml it mg b be mm mn l mo mp">function deepCopy(obj) {<br/>  const copy = {};<br/>  const propKeys = Reflect.ownKeys(obj);<br/>  for (const propKey of propKeys) {<br/>    copy[propKey] = obj[propKey];<br/>  }<br/>  return Reflect.ownKeys(obj).reduce((acc, key) =&gt; {<br/>  if (typeof obj[key] === 'object' &amp;&amp; obj[key] !== null) {<br/>    acc[key] = deepCopy(obj[key]);<br/>  }<br/>  return Reflect.defineProperty(acc, key, Reflect.getOwnPropertyDescriptor(obj, key));<br/> }, copy);<br/>}<br/>const original = { a: 1, b: { c: 3 } };<br/>const copy = deepCopy(original);</span></pre><p id="da81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将创建一个新的对象，并使用Reflect.ownKeys()方法将原始对象的属性复制到该对象中，以获得该对象自己的属性键数组和一个循环来迭代该数组并将属性复制到新对象中。如果属性值是一个对象，它递归地调用deepCopy()函数来创建对象的新副本。它还使用reflect . getownpropertydescriptor()和Reflect.defineProperty()方法将原始对象自身属性的属性描述符复制到新对象中。</p><p id="0a8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此方法适用于任何对象，包括具有函数、未定义和其他数据类型的对象。如果您需要创建对象的深层副本并保留原始对象自身属性的属性描述符，这是一个不错的选择。</p><ul class=""><li id="48a6" class="lw lx it js b jt ju jx jy kb ly kf lz kj ma kn mb mc md me bi translated">使用Reflect.ownKeys()方法获取对象自己的属性键数组，使用Object.create()方法创建新对象并定义其上的属性:</li></ul><pre class="li lj lk ll gt mf mg mh bn mi mj bi"><span id="de58" class="mk ml it mg b be mm mn l mo mp">function deepCopy(obj) {<br/>  const copy = Object.create(Object.getPrototypeOf(obj));<br/>  Reflect.ownKeys(obj).forEach(key =&gt; {<br/>    if (typeof obj[key] === 'object' &amp;&amp; obj[key] !== null) {<br/>      copy[key] = deepCopy(obj[key]);<br/>    } else {<br/>      Reflect.defineProperty(copy, key, Reflect.getOwnPropertyDescriptor(obj, key));<br/>    }<br/>  });<br/>  return copy;<br/>}<br/>const original = { a: 1, b: { c: 3 } };<br/>const copy = deepCopy(original);</span></pre><p id="bc32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将使用Object.create()方法创建一个新对象，并将其原型设置为原始对象的原型。然后，它使用Reflect.ownKeys()方法获取对象自己的属性键数组，并使用Reflect.defineProperty()方法循环遍历该数组并定义新对象的属性。如果属性值是一个对象，它递归地调用deepCopy()函数来创建对象的新副本。</p><p id="f0e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此方法也适用于任何对象，并保留原始对象自身属性的属性描述符。</p><ul class=""><li id="02de" class="lw lx it js b jt ju jx jy kb ly kf lz kj ma kn mb mc md me bi translated">使用structuredClone()</li></ul><pre class="li lj lk ll gt mf mg mh bn mi mj bi"><span id="70c3" class="mk ml it mg b be mm mn l mo mp">const original = { a: 1, b: { c: 3 } };<br/>const copy = structuredClone(original);</span></pre><p id="a6bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可能是最简单的方法，因为它是JavaScript的内置函数。它使用<a class="ae lg" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm" rel="noopener ugc nofollow" target="_blank">结构化克隆算法</a>来深度复制对象。在用JavaScript克隆对象时，这是我最喜欢的方法:)然而，这是相当新的方法。仅从2022年9月和Node 17开始提供。因此，如果您使用的是旧系统，structuredClone()可能不可用。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/8cc2bdbd0385c621d36651253412f4c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:354/format:webp/1*ESY3Cfag_56ItAVpCurBNw.png"/></div></figure><p id="6b08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Phewww。我们谈了很多。难怪这是一个三部分系列。如果您喜欢这个系列，请关注或订阅我们，这样您就不会错过我们关于JavaScript或软件开发的任何精彩内容。愿原力与你同在。</p></div></div>    
</body>
</html>