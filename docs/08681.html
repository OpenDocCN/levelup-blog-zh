<html>
<head>
<title>PostgreSQL with Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Node.js的PostgreSQL</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/postgresql-with-node-js-198041f39ad1?source=collection_archive---------0-----------------------#2021-05-25">https://levelup.gitconnected.com/postgresql-with-node-js-198041f39ad1?source=collection_archive---------0-----------------------#2021-05-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cf65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过这篇博客，我将向您展示如何使用<strong class="jp ir"> Node.js </strong>和<strong class="jp ir"> PostgreSQL </strong>创建一个基本的REST API。</p><p id="a403" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将另外使用<strong class="jp ir"> express </strong>和<strong class="jp ir"> node-postgres </strong>。这个博客将<strong class="jp ir">而不是</strong>使用类似Sequelize的ORM，这样我们可以更好地理解查询部分。</p><p id="97cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的应用程序将简单地注册用户，并将他们添加到我们的数据库中。</p><h2 id="b63d" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">创建项目库</h2><p id="89f1" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">在您选择的目录中，生成一个空节点项目:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="c04c" class="kl km iq lo b gy ls lt l lu lv">npm init -y</span></pre><p id="dc07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们安装express:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="1d05" class="kl km iq lo b gy ls lt l lu lv">npm install express</span></pre><p id="f7d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了，我们现在可以开始一个基本的服务器。我们将创建主<strong class="jp ir"> app.js </strong>文件:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="eb14" class="kl km iq lo b gy ls lt l lu lv">const express = require('express');<br/>const app = express();</span><span id="1a4c" class="kl km iq lo b gy lw lt l lu lv">app.use(express.json());</span><span id="34dc" class="kl km iq lo b gy lw lt l lu lv">// we will eventually use env variables<br/>const <strong class="lo ir">PORT</strong> = <strong class="lo ir">process.env.PORT</strong> || 8080;</span><span id="1d5d" class="kl km iq lo b gy lw lt l lu lv">app.listen(<strong class="lo ir">PORT</strong>, () =&gt; {<br/>  console.log('Server Started');<br/>});</span></pre><p id="6ef9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们创建我们的<strong class="jp ir">用户</strong>表。为此，请确保您的系统上安装并运行了PostgreSQL。我们还将使用<a class="ae lx" href="https://www.pgadmin.org" rel="noopener ugc nofollow" target="_blank"> pg-admin </a>与该表进行交互。</p><p id="641b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们首先创建这个表。在pg-admin中，用您的用户名(或您选择的另一个数据库)右键单击数据库，并选择查询工具:</p><figure class="lj lk ll lm gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi ly"><img src="../Images/b9c83e168ea673ab8861dfdf0fba8ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EoK8LHXuFKI6EQb6e1r4vA.png"/></div></div></figure><p id="4789" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注册的用户应该有一个<strong class="jp ir">用户名</strong>、<strong class="jp ir">电子邮件</strong>、<strong class="jp ir">密码</strong>和一个可选的简历。我们可以写出并执行以下查询来创建该表:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="5e1c" class="kl km iq lo b gy ls lt l lu lv">CREATE TABLE users(<br/>  id <strong class="lo ir">SERIAL</strong> <strong class="lo ir">PRIMARY KEY</strong>,<br/>  username VARCHAR(40) <strong class="lo ir">NOT NULL UNIQUE</strong>, <br/>  email VARCHAR(50) <strong class="lo ir">NOT NULL UNIQUE</strong>,<br/>  password VARCHAR(100) <strong class="lo ir">NOT NULL</strong>,<br/>  bio VARCHAR(400) <strong class="lo ir">NOT NULL DEFAULT ''</strong>,<br/>  created_at <strong class="lo ir">TIMESTAMP</strong> WITH TIME ZONE <strong class="lo ir">DEFAULT CURRENT_TIMESTAMP</strong>,<br/>  updated_at <strong class="lo ir">TIMESTAMP</strong> WITH TIME ZONE <strong class="lo ir">DEFAULT CURRENT_TIMESTAMP<br/></strong>);</span></pre><p id="044d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，<strong class="jp ir">用户名和电子邮件应该始终是唯一的</strong>。该表现在应该可以在pg-admin侧边栏中看到:</p><figure class="lj lk ll lm gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi ly"><img src="../Images/e6bb06ac26e056be3aad78a616e9f2e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y9oBWTNWb9_RExeI4CXnZQ.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">边栏中可见的用户表</figcaption></figure><h1 id="849c" class="mk km iq bd kn ml mm mn kq mo mp mq kt mr ms mt kw mu mv mw kz mx my mz lc na bi translated">开始开发我们的节点应用程序</h1><h2 id="9a13" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">添加节点-postgres</h2><p id="b3f6" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">回到您的项目目录，让我们首先创建一个到数据库的连接。为此，我们将使用<a class="ae lx" href="https://node-postgres.com" rel="noopener ugc nofollow" target="_blank">节点-postgres </a>模块。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="a901" class="kl km iq lo b gy ls lt l lu lv">npm i pg</span></pre><p id="f6e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，创建一个名为<strong class="jp ir"> db </strong>的新目录，并向其中添加一个<strong class="jp ir"> index.js </strong>文件。</p><figure class="lj lk ll lm gt lz gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/f34f1711cb40fa010ab8be13cda2b635.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*-FamV9xkcBWCYg0EG0JGTw.png"/></div></figure><p id="196b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个文件将保存我们的<strong class="jp ir">连接池配置</strong>，我们可以在整个项目中导入和使用它。</p><p id="23ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打开<strong class="jp ir"> db/ index.js </strong>文件，添加以下几行:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="cbcf" class="kl km iq lo b gy ls lt l lu lv">const { <strong class="lo ir">Pool</strong> } = require('pg');<br/>const pool = new <strong class="lo ir">Pool</strong>();</span></pre><p id="ad5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个博客中，我们将使用一个<strong class="jp ir">连接池</strong>来与我们的数据库进行交互。</p><p id="01cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用<a class="ae lx" href="https://node-postgres.com/features/pooling" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">连接池</strong> </a> <strong class="jp ir"> </strong>来代替单客户端连接<strong class="jp ir"> </strong>，因为它提供了好处。但是我们如何将这个池连接到我们的数据库呢？</p><h2 id="f799" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">为我们的数据库连接添加配置</h2><p id="14c4" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">要建立数据库连接，我们需要以下信息:</p><ul class=""><li id="35cc" class="nc nd iq jp b jq jr ju jv jy ne kc nf kg ng kk nh ni nj nk bi translated">数据库<strong class="jp ir">用户</strong>(默认为您的系统用户名)</li><li id="c057" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated">数据库<strong class="jp ir">主机</strong>(数据库在哪里运行)</li><li id="cb94" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated">数据库<strong class="jp ir">端口</strong>(默认为5432)</li><li id="2762" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated"><strong class="jp ir">数据库名称</strong>(默认为您的postgres用户名)</li><li id="1165" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated"><strong class="jp ir">数据库密码</strong></li></ul><p id="7acc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于您的本地配置，应该很容易找到这些信息。</p><p id="0b34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现实世界的项目通常会使用环境变量来获取这些信息。因此，我们将创建一个<strong class="jp ir">。env </strong>文件，所有这些信息都在项目的主目录中。</p><figure class="lj lk ll lm gt lz gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/8a8222c3cb18ca4b5b0b50721662ddd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*L_DLwYDfOJ5d7Qelq45jRA.png"/></div></figure><p id="1551" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将以下条目添加到文件中，用您自己的本地数据库配置替换<strong class="jp ir"> PGUSER </strong>、<strong class="jp ir"> PGPASSWORD </strong>和<strong class="jp ir"> PGDATABASE </strong>的密钥。其他条目在大多数情况下应该是相同的。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="ca19" class="kl km iq lo b gy ls lt l lu lv"><strong class="lo ir">PGUSER</strong>='arunpant'<br/><strong class="lo ir">PGHOST</strong>='localhost'<br/><strong class="lo ir">PGDATABASE</strong>='arunpant'<br/><strong class="lo ir">PGPASSWORD</strong>='mySuperSecretPassword'<br/><strong class="lo ir">PGPORT</strong>=5432<br/>PORT=8083</span></pre><p id="f56e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你记得我们的<strong class="jp ir"> app.js </strong>文件:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="d1bb" class="kl km iq lo b gy ls lt l lu lv">const <strong class="lo ir">PORT</strong> = <strong class="lo ir">process.env.PORT</strong> || 8080;</span></pre><p id="76f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了确保像PORT这样的环境变量被拾取，我们将使用<a class="ae lx" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> dotenv </strong> </a> npm包。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="4116" class="kl km iq lo b gy ls lt l lu lv">npm i dotenv</span></pre><p id="cb37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而在<strong class="jp ir"> app.js </strong>:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="2b94" class="kl km iq lo b gy ls lt l lu lv">const express = require('express');<br/>const app = express();</span><span id="80eb" class="kl km iq lo b gy lw lt l lu lv"><strong class="lo ir">require('dotenv').config();</strong></span><span id="10d4" class="kl km iq lo b gy lw lt l lu lv">...</span></pre><h2 id="dd77" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">创建查询生成器</h2><p id="eb9f" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">让我们回到我们的<strong class="jp ir"> db/index.js </strong>文件，处理剩下的内容。我们将制作一个<strong class="jp ir">查询</strong>功能，可以导出到我们的应用程序中的其他地方进行查询。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="9fca" class="kl km iq lo b gy ls lt l lu lv">const { Pool } = require('pg');<br/>const <strong class="lo ir">pool</strong> = new Pool();</span><span id="813d" class="kl km iq lo b gy lw lt l lu lv">module.exports = {<br/>    async query(<strong class="lo ir">text</strong>, <strong class="lo ir">params</strong>) {<br/>      const res = <strong class="lo ir">await pool.query(text, params);</strong><br/>      return res;<br/>    }<br/>};</span><span id="af4b" class="kl km iq lo b gy lw lt l lu lv">// <strong class="lo ir">text</strong> will be something like '<strong class="lo ir">SELECT * FROM $1</strong>'<br/>// <strong class="lo ir">params</strong> something like this array: <strong class="lo ir">['users']</strong> i.e. the table name<br/>// <strong class="lo ir">$1</strong> =&gt; replaced by <strong class="lo ir">users</strong> in final query</span></pre><p id="48dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">文本</strong>将是我们的查询，<strong class="jp ir">参数</strong>将是这个查询的动态元素，它们被单独添加到<strong class="jp ir">防止SQL注入攻击</strong>中。</p><p id="289f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于<strong class="jp ir"> pool.query </strong>操作可能会由于多种原因而失败，比如违反约束，所以让我们添加一些基本的错误处理和日志记录:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="cf1d" class="kl km iq lo b gy ls lt l lu lv">const { Pool } = require('pg');<br/>const pool = new Pool();</span><span id="bad2" class="kl km iq lo b gy lw lt l lu lv">module.exports = {<br/>    async query(text, params) {</span><span id="3ad8" class="kl km iq lo b gy lw lt l lu lv">        // invocation timestamp for the query method<br/>        const start = Date.now();</span><span id="475e" class="kl km iq lo b gy lw lt l lu lv">        try {<br/>            const res = await pool.query(text, params);</span><span id="e40e" class="kl km iq lo b gy lw lt l lu lv">            // time elapsed since invocation to execution<br/>            const duration = Date.now() - start;</span><span id="9e97" class="kl km iq lo b gy lw lt l lu lv">            console.log(<br/>              'executed query', <br/>              {text, <strong class="lo ir">duration</strong>, rows: res.rowCount}<br/>            );<br/>            return res;<br/>        } catch (error) {<br/>            console.log('error in query', {text});<br/>            <strong class="lo ir">throw error;</strong><br/>        }<br/>    }<br/>};</span></pre><p id="1f75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将代码封装在try catch块中，并添加了一些基本的日志记录。</p><p id="35b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Node-postgres会将错误元数据添加到抛出的错误中。我们将很快使用一个这样的错误代码来识别用户名的唯一约束违反。</p><p id="e8b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以导出这个查询方法，并传入查询文本及其参数来执行查询。</p><h1 id="34f2" class="mk km iq bd kn ml mm mn kq mo mp mq kt mr ms mt kw mu mv mw kz mx my mz lc na bi translated">创建注册用户的流程</h1><p id="a1b5" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">我们将在项目中创建一个<strong class="jp ir">模型</strong>文件夹，并向其中添加一个<strong class="jp ir"> User.js </strong>文件。</p><figure class="lj lk ll lm gt lz gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/56158bfdcaa5244a9e9e0bf3dfa6b3cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*ruaFiAh2JjhUW9fewzkmxg.png"/></div></figure><p id="e97d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们首先在这个文件中为我们的用户添加基本的构造函数:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="f989" class="kl km iq lo b gy ls lt l lu lv">function User ({<br/>  username, <br/>  email, <br/>  password, <br/>  bio=`Hi, I am ${username}`<br/>}) {<br/>    <strong class="lo ir">this.username</strong> = username;<br/>    <strong class="lo ir">this.email</strong> = email;<br/>    <strong class="lo ir">this.password</strong> = password;<br/>    <strong class="lo ir">this.bio</strong> = bio;<br/>};</span></pre><p id="19ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在将向其原型<strong class="jp ir">添加一个方法，用于实际的用户创建:</strong></p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="c478" class="kl km iq lo b gy ls lt l lu lv">const db = require('../db');</span><span id="edc8" class="kl km iq lo b gy lw lt l lu lv">//User constructor<br/>function User ({<br/>  username, <br/>  email, <br/>  password, <br/>  <strong class="lo ir">bio=`Hi, I am ${username}`</strong><br/>}) {<br/>    this.username = username;<br/>    this.email = email;<br/>    this.password = password;<br/>    this.bio = bio;<br/>};</span><span id="e516" class="kl km iq lo b gy lw lt l lu lv">// add a createUser method to the prototype<br/><strong class="lo ir">User.prototype.createUser</strong> = async function() {<br/>    try {<br/>        const <strong class="lo ir">{ rows }</strong> = await <strong class="lo ir">db.query</strong>(</span><span id="564e" class="kl km iq lo b gy lw lt l lu lv">            `INSERT INTO users(username, email, password, bio) <br/>            VALUES ($1, $2, $3, $4)`,<br/>            [<strong class="lo ir">this</strong>.username, <strong class="lo ir">this</strong>.email, <strong class="lo ir">this</strong>.password, <strong class="lo ir">this</strong>.bio]</span><span id="36f4" class="kl km iq lo b gy lw lt l lu lv">        );</span><span id="8209" class="kl km iq lo b gy lw lt l lu lv">        return <strong class="lo ir">rows</strong>; <br/>    } catch (error) {<br/>        throw error;<br/>    }<br/>};</span><span id="fb77" class="kl km iq lo b gy lw lt l lu lv">module.exports = User;</span><span id="b8a8" class="kl km iq lo b gy lw lt l lu lv">// <strong class="lo ir">db.query</strong>: the query method we exported earlier from db/index.js</span></pre><blockquote class="ns nt nu"><p id="75c8" class="jn jo nv jp b jq jr js jt ju jv jw jx nw jz ka kb nx kd ke kf ny kh ki kj kk ij bi translated">默认情况下，node-postgres读取行并将它们收集到JavaScript对象中，这些对象的键与列名匹配，值与每列的相应行值匹配。</p></blockquote><p id="a17a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们解结构的<strong class="jp ir"> { rows } </strong>对象将保存这些信息，如果有的话。它将为特定查询的所有匹配行保存一个对象数组。</p><p id="417f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，我们就有了基本的用户模型。</p><h2 id="e0d1" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">为用户注册创建控制器</h2><p id="1ce8" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">让我们在项目中创建另一个名为<strong class="jp ir"> controllers </strong>的文件夹，并向其中添加一个<strong class="jp ir"> users.js </strong>文件。</p><figure class="lj lk ll lm gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi nz"><img src="../Images/f168a10715605e2f88b924b4f645d137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*kKedM2IggcPa6Msnry9VsQ.png"/></div></div></figure><p id="296b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们将控制器代码添加到这个文件中。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="6c32" class="kl km iq lo b gy ls lt l lu lv"><strong class="lo ir">const User = require('../models/User');</strong></span><span id="52b4" class="kl km iq lo b gy lw lt l lu lv"><strong class="lo ir">exports.postSignup</strong> = async (req, res, next) =&gt; {<br/>    //getting user data from request body<br/>    const {<strong class="lo ir">username, password, email, bio</strong>} = req.body;<br/>    try {<br/>        const user = <strong class="lo ir">new User({username, password, email, bio});</strong><br/>        const result = <strong class="lo ir">await user.createUser()</strong>;<br/>        res.send(user);<br/>    } catch (error) {<br/>        next(error);<br/>    }<br/>};</span><span id="7de6" class="kl km iq lo b gy lw lt l lu lv">Remember the <strong class="lo ir">createUser</strong> method we added to the User model <strong class="lo ir">prototype</strong>? It is therefore available on our <strong class="lo ir">user model instance</strong> above.</span></pre><p id="97e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">用户</strong>。<strong class="jp ir"> createUser() </strong>将执行我们的用户插入查询。例如，在违反唯一约束的情况下，该查询可能会失败。我们对用户名有一个惟一的约束，如果有人试图用相同的用户名创建一个用户，createUser方法将抛出一个错误。</p><p id="634e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该错误将保存特定类型的约束违反的元数据，包括我们可以用来识别它确实是唯一的约束违反的代码。</p><p id="8d50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Postgres带有特定的错误代码，您可以在这里查看这些代码的列表。</p><p id="dc00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是一些违反完整性约束的错误代码片段:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="cba1" class="kl km iq lo b gy ls lt l lu lv">Class 23 — Integrity Constraint Violation<br/>23000 integrity_constraint_violation<br/>23001 restrict_violation<br/>23502 not_null_violation<br/>23503 foreign_key_violation<br/><strong class="lo ir">23505 unique_violation</strong><br/>23514 check_violation<br/>23P01 exclusion_violation</span></pre><p id="a934" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">鉴于这篇博客的范围，我们不会涵盖所有的错误场景，所以让我们只添加一个违反<strong class="jp ir">唯一</strong>约束的情况。</p><p id="b1d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回到控制器中，按如下方式修改代码:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="324b" class="kl km iq lo b gy ls lt l lu lv">...</span><span id="3eb8" class="kl km iq lo b gy lw lt l lu lv">exports.postSignup = async (req, res, next) =&gt; {<br/>    const {username, password, email, bio} = req.body;<br/>    try {<br/>        const user = new User({username, password, email, bio});<br/>        const result = await user.createUser();<br/>        res.send(user);<br/>    } catch (error) {</span><span id="69e9" class="kl km iq lo b gy lw lt l lu lv">        <strong class="lo ir">const errorToThrow = new Error();<br/>        switch (error?.code) {<br/>            case '23505':<br/>                errorToThrow.message = 'User already exists';<br/>                errorToThrow.statusCode = 403;<br/>                break;<br/>            default:<br/>                errorToThrow.statusCode = 500;<br/>        }</strong></span><span id="4ec7" class="kl km iq lo b gy lw lt l lu lv"><strong class="lo ir">        //pass error to next()<br/>        next(errorToThrow);</strong></span><span id="a324" class="kl km iq lo b gy lw lt l lu lv">    }<br/>};</span></pre><p id="7d67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当查询操作遇到错误时，特定的<strong class="jp ir"> postgres错误代码(本例中为23505)</strong>被添加到错误对象中。</p><p id="11c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，我们正在检查是否违反了这个特定的代码:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="63e1" class="kl km iq lo b gy ls lt l lu lv"><strong class="lo ir">23505 unique_violation</strong></span></pre><p id="bdbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的catch块将简单地<strong class="jp ir"> next() </strong>这个错误，并且我们可以添加熟悉的快速错误处理程序来捕获<strong class="jp ir">这样的错误，在主<strong class="jp ir"> app.js </strong>文件中有一个消息和statusCode </strong>属性:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="0f00" class="kl km iq lo b gy ls lt l lu lv">...</span><span id="e148" class="kl km iq lo b gy lw lt l lu lv"><strong class="lo ir">app.use((err, req, res, next) =&gt; {<br/>    if(err.statusCode) {<br/>        res.status(err.statusCode).send(err.message);<br/>    } else {<br/>        console.log(err);<br/>        res.status(500).send('Something unexpected happened');<br/>    }<br/>});</strong></span><span id="f1ca" class="kl km iq lo b gy lw lt l lu lv">const PORT = process.env.PORT || 8080;</span><span id="9ff0" class="kl km iq lo b gy lw lt l lu lv">...</span></pre><p id="4688" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在将创建一个使用这个控制器的路由，这非常简单。</p><p id="b7a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在您的项目中创建一个名为<strong class="jp ir"> routes </strong>的文件夹，并向其中添加一个<strong class="jp ir"> users.js </strong>文件:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="1c54" class="kl km iq lo b gy ls lt l lu lv">const express = require('express');<br/>const router = express.Router();</span><span id="4c52" class="kl km iq lo b gy lw lt l lu lv">const usersController = <strong class="lo ir">require('../controllers/users')</strong>;</span><span id="8fc1" class="kl km iq lo b gy lw lt l lu lv">router.post('/signup', <strong class="lo ir">usersController.postSignup</strong>);</span><span id="7d20" class="kl km iq lo b gy lw lt l lu lv">module.exports = router;</span></pre><p id="0b3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以在我们的<strong class="jp ir"> app.js </strong>文件中注册这条路线:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="06d5" class="kl km iq lo b gy ls lt l lu lv">...</span><span id="5138" class="kl km iq lo b gy lw lt l lu lv"><strong class="lo ir">const usersRoute = require('./routes/users');</strong></span><span id="6607" class="kl km iq lo b gy lw lt l lu lv"><strong class="lo ir">app.use(usersRoute);</strong></span><span id="61de" class="kl km iq lo b gy lw lt l lu lv">...</span></pre><p id="7b2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这个，我们现在可以使用Postman检查我们的API是否按预期工作。</p><h2 id="4a8a" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">验证API行为</h2><p id="05cf" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">让我们首先开始这个项目:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="2c08" class="kl km iq lo b gy ls lt l lu lv">node app.js</span></pre><p id="74d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用postman向'/signup '路由发出POST请求，请求一个新用户:</p><figure class="lj lk ll lm gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi ly"><img src="../Images/a6b2f7e49b02d9f254f63d9859b35548.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xz0v5jxCLKghRfKOFjVWew.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">我们的帖子请求在起作用</figcaption></figure><p id="f5ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，我们向<a class="ae lx" href="http://localhost:8083/signup" rel="noopener ugc nofollow" target="_blank">http://localhost:8083/sign up</a>发出了一个请求，其中包含了我们的用户名、电子邮件和密码。</p><p id="4005" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您还记得，在我们的用户模型中，我们添加了一个默认的生物值，以防没有提供。</p><p id="3f02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看是否可以用相同的用户名创建另一个用户。</p><figure class="lj lk ll lm gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi ly"><img src="../Images/89d0c4b9b8f335b8312476b482b05bb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AdTpDet9O1eX8gZGB2yaKg.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">行动中的错误处理</figcaption></figure><p id="316e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果一切正常，您应该会看到上面的响应，带有一个<strong class="jp ir"> 403 </strong>状态代码和我们添加的“用户已经存在”消息。您的终端日志也会包含错误信息。</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="6c9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望有了这个基本的API设置，您也可以继续创建更高级的API。例如，接下来验证登录流。</p><p id="7b42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望这个博客对你有所帮助，哪怕是一点点。祝你未来的编码之旅一切顺利！</p></div></div>    
</body>
</html>