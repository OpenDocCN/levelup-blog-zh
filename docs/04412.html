<html>
<head>
<title>Writing Your First Widget for iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为iOS编写第一个小部件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/writing-your-first-widget-for-ios-e1e8acf0079?source=collection_archive---------4-----------------------#2020-06-25">https://levelup.gitconnected.com/writing-your-first-widget-for-ios-e1e8acf0079?source=collection_archive---------4-----------------------#2020-06-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ec50" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">WidgetKit入门</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/df5089fe0f3125648ab7f42619570679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*Rc32a5jxBvU9U3vqmqsUFw.jpeg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">资料来源:WWDC20</figcaption></figure><p id="e2a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你一直在关注WWDC20，那么你会完全理解这个版本的WWDC对整个苹果生态系统、用户和开发者有多么重要。随着<a class="ae lq" href="https://www.apple.com/ios/ios-14-preview/" rel="noopener ugc nofollow" target="_blank"> iOS 14 </a>的发布，许多便利的功能正在增加iOS体验的趣味。其中一个功能是<a class="ae lq" href="https://developer.apple.com/widgets/" rel="noopener ugc nofollow" target="_blank">小部件</a>。</p><p id="340b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我知道这对Android用户来说听起来并不新鲜，但这对iOS用户来说绝对是个好消息。现在，开发人员可以通过使用新的<a class="ae lq" href="https://developer.apple.com/documentation/widgetkit" rel="noopener ugc nofollow" target="_blank"> WidgetKit </a>框架来创建他们应用程序的小部件。截至目前，它仍处于测试阶段，可在<a class="ae lq" href="https://developer.apple.com/documentation/xcode-release-notes/xcode-12-beta-release-notes" rel="noopener ugc nofollow" target="_blank"> Xcode 12 Beta </a>及以上版本中使用。</p><blockquote class="lr ls lt"><p id="7991" class="ku kv lu kw b kx ky ju kz la lb jx lc lv le lf lg lw li lj lk lx lm ln lo lp im bi translated">注意:您需要Xcode 12 Beta或更高版本才能创建Widgets。</p></blockquote><p id="4e47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们开始为iOS编写第一个小部件。为此，让我们创建一个新的SwiftUI项目。我把它命名为<code class="fe ly lz ma mb b">CountrySelector</code>。这个应用程序将显示一些国家的国旗，当用户点击任何国旗，该特定国家的细节将显示在应用程序的小工具。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/bf5cfd4a1593a96829210207755bad7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*O_rFk7IL7Mcmd30uknqCag.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">先睹为快小部件将会是什么样子。在屏幕截图中，显示了中型和大型微件。</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi md"><img src="../Images/7e3a3c5cbbaed46fefb910e641116f75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uSYcgudX4mo8xjvf8zlZsA.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">创建新的SwiftUI项目</figcaption></figure><p id="706c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建项目后，项目结构将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mi"><img src="../Images/0ef6e731a32b8d09c998c3027e9b62bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8uvzX2x54FzH1lLJN0Dipw.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">项目结构</figcaption></figure><p id="646a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，让我们创建一个模型，<code class="fe ly lz ma mb b">Country</code>。这将是一个<code class="fe ly lz ma mb b">struct</code>，将持有一个国家的细节，如<code class="fe ly lz ma mb b">name</code>、<code class="fe ly lz ma mb b">flag </code>和<code class="fe ly lz ma mb b">continent</code>。让我们使它符合<code class="fe ly lz ma mb b">Codable</code>和<code class="fe ly lz ma mb b">Identifiable</code>协议，因为我们想要分别执行编码-解码操作和稍后使用<code class="fe ly lz ma mb b">ForEach</code>执行迭代。由于我们使我们的模型符合<code class="fe ly lz ma mb b">Identifiable</code>，我们将被要求在模型中添加一个<code class="fe ly lz ma mb b">id</code>属性，这是一个返回<code class="fe ly lz ma mb b">name</code>值的计算属性。因此，添加所有内容后，最终的代码将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="ac39" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后，让我们转到<code class="fe ly lz ma mb b">ContentView.swift</code>文件，在那里添加一些虚拟国家数据。因此，在<code class="fe ly lz ma mb b">ContentView</code>的<code class="fe ly lz ma mb b">body</code>属性之上，创建一个数组<code class="fe ly lz ma mb b">countries</code>，并编写以下代码:</p><pre class="kj kk kl km gt ml mb mm mn aw mo bi"><span id="6117" class="mp mq it mb b gy mr ms l mt mu">let countries = [Country(name: "Nepal", flag: "🇳🇵", continent: "Asia"),<br/>Country(name: "USA", flag: "🇺🇸", continent: "North America"),<br/>Country(name: "United Kingdom", flag: "🇬🇧", continent: "Europe"),<br/>Country(name: "France", flag: "🇫🇷", continent: "Europe"),<br/>Country(name: "China", flag: "🇨🇳", continent: "Asia"),<br/>Country(name: "India", flag: "🇮🇳", continent: "Asia"),<br/>Country(name: "Australia", flag: "🇦🇺", continent: "Australia")]</span></pre><p id="e3f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们的虚拟数据准备好了。是时候在我们的视图中显示虚拟数据了。为此，让我们创建一个新的视图，<code class="fe ly lz ma mb b">CountryView</code>。我们将使用这个视图来显示国旗。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mk l"/></div></figure><p id="a0df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe ly lz ma mb b">CountryView.swift</code>中，如果我们不想看到预览，我们可以去掉<code class="fe ly lz ma mb b">CountryView_Previews</code>结构。您也可以从其他视图中删除预览。</p><p id="742e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe ly lz ma mb b">CountryView</code>中，我们添加一个<code class="fe ly lz ma mb b">Country</code>类型的变量<code class="fe ly lz ma mb b">country</code>。它将用于存储和显示从<code class="fe ly lz ma mb b">ContentView</code>发送的数据。然后，我们可以从视图中删除<code class="fe ly lz ma mb b">Text("Hello, World!")</code>并添加以下行:</p><pre class="kj kk kl km gt ml mb mm mn aw mo bi"><span id="3230" class="mp mq it mb b gy mr ms l mt mu">Text(country.flag)<br/>    .font(.largeTitle)<br/>    .background(Color.gray)<br/>    .clipShape(Circle())</span></pre><p id="5af5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">综上所述，整体代码将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="60db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">预览将显示如下所示的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/4ac02464bdbbe48ef6bcafb838b68259.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*zsvY09_7s_YvdGewBYV-WQ.png"/></div></figure><p id="7c0d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">干杯！我们已经完成了我们的<code class="fe ly lz ma mb b">CountryView</code>。现在，让我们用在<code class="fe ly lz ma mb b">ContentView</code>中。首先，删除“你好，世界！”文本并添加以下代码:</p><pre class="kj kk kl km gt ml mb mm mn aw mo bi"><span id="9a99" class="mp mq it mb b gy mr ms l mt mu">HStack {<br/>    ForEach(countries) { country in<br/>        CountryView(country: country)<br/>            .onTapGesture {<br/>                self.selectCountry(country)<br/>            }<br/>    }<br/>}</span></pre><p id="7020" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将遍历我们之前设置的虚拟数据，并将<code class="fe ly lz ma mb b">countries</code>数组中的每一项传递给<code class="fe ly lz ma mb b">CountryView</code>，并在其上添加一个点击手势来调用方法<code class="fe ly lz ma mb b">selectCountry(_:)</code>。让我们添加一个方法<code class="fe ly lz ma mb b">selectCountry(_:)</code>，现在，在<code class="fe ly lz ma mb b">ContentView</code>中打印被点击的国家的值。</p><pre class="kj kk kl km gt ml mb mm mn aw mo bi"><span id="7d51" class="mp mq it mb b gy mr ms l mt mu">private func selectCountry(_ country: Country) {<br/>    print(country)<br/>}</span></pre><p id="8731" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ly lz ma mb b">ContentView</code>中的整体代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="3700" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们运行代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/f33baff44775c4b21697b35b3c21e018.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*ex4pL4tXD9o9gi0gjggIsw.png"/></div></figure><p id="5808" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是应用程序的外观。我们可以点击任何标志，并在控制台中查看其详细信息。</p><p id="4b37" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们在项目中添加<a class="ae lq" href="https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_security_application-groups" rel="noopener ugc nofollow" target="_blank">应用程序组</a>功能。为此，我们需要一个开发者帐户登录Xcode。我们需要使用应用程序组，因为我们想要创建一个组容器，以便我们的<code class="fe ly lz ma mb b">CountrySelector</code>应用程序及其小部件(我们将很快创建)能够访问公共数据，即当前选择的国家。以下屏幕记录显示了我们如何添加应用程序组功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mk l"/></div></figure><p id="f6bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">添加功能后，我们创建一个新的应用程序组。为此，让我们首先复制我们的捆绑包标识符，然后按下应用程序组部分中的“+”图标。将显示一个对话框，并将包标识符附加到此处的<code class="fe ly lz ma mb b">group.</code>文本。然后单击确定。之后，如果新添加的组显示为红色，持续按“+”按钮附近的重新加载按钮，直到该组不再变白。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mk l"/></div></figure><p id="d7be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们可以回到<code class="fe ly lz ma mb b">ContentView</code>进行进一步的工作。在<code class="fe ly lz ma mb b">ContentView</code>中，在<code class="fe ly lz ma mb b">countries</code>数组上方添加以下几行。</p><pre class="kj kk kl km gt ml mb mm mn aw mo bi"><span id="3588" class="mp mq it mb b gy mr ms l mt mu">@AppStorage("selectedCountry", store: UserDefaults(suiteName: "group.np.com.sagunrajlage.CountrySelector"))<br/>var selectedCountry: Data = Data()</span></pre><p id="5128" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，我们添加了一个名为<code class="fe ly lz ma mb b">@AppStorage</code>的属性包装器，这是一种访问键为<code class="fe ly lz ma mb b">"selectedCountry"</code>的<code class="fe ly lz ma mb b">UserDefaults</code>数据的方法，这些数据存储在我们的应用程序组的容器中，套件名为<code class="fe ly lz ma mb b">"group.np.com.sagunrajlage.CountrySelector"</code>。然后，我们将能够将这些数据存储在<code class="fe ly lz ma mb b">selectedCountry</code>变量中。</p><p id="3024" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们使用<code class="fe ly lz ma mb b">selectedCountry</code>变量。为此，我们创建了一个方法<code class="fe ly lz ma mb b">storeData(with:)</code>，它将<code class="fe ly lz ma mb b">Country</code>数据作为输入，对其进行编码，并将其分配给<code class="fe ly lz ma mb b">selectedCountry</code>变量。通过这样做，数据被存储在我们的应用程序组的容器中。</p><pre class="kj kk kl km gt ml mb mm mn aw mo bi"><span id="195e" class="mp mq it mb b gy mr ms l mt mu">private func storeData(with country: Country) {<br/>    guard let encodedData = try? JSONEncoder().encode(country) else { return }<br/>    selectedCountry = encodedData<br/>}</span></pre><p id="b9c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后，让我们从<code class="fe ly lz ma mb b">selectCountry(_:)</code>调用<code class="fe ly lz ma mb b">storeData(with:)</code>方法。因此，<code class="fe ly lz ma mb b">selectCountry(_:)</code>将首先打印其<code class="fe ly lz ma mb b">country</code>参数的值，然后将其发送给<code class="fe ly lz ma mb b">storeData(with:)</code>方法进行存储。这就是<code class="fe ly lz ma mb b">selectCountry(_:)</code>的样子:</p><pre class="kj kk kl km gt ml mb mm mn aw mo bi"><span id="c3dd" class="mp mq it mb b gy mr ms l mt mu">private func selectCountry(_ country: Country) {<br/>    print(country)<br/>    storeData(with: country)<br/>}</span></pre><p id="f182" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，当我们现在点击一个国家的国旗时，该国家的详细信息将以这样一种方式存储，即它们可以通过应用程序和它的小部件(我们稍后将创建)访问。</p><p id="ba11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是在应用程序中仍然存在一个缺陷。如果这是应用程序的第一次发布，但没有选择任何国家，该怎么办？为了处理这种情况，我们在<code class="fe ly lz ma mb b">ContentView</code>中添加一个初始化器，并编写以下代码:</p><pre class="kj kk kl km gt ml mb mm mn aw mo bi"><span id="4be5" class="mp mq it mb b gy mr ms l mt mu">init() {<br/>     guard let _ = try? JSONDecoder().decode(Country.self, <br/>                   from: selectedCountry) else {<br/>                       storeData(with: countries[0])<br/>                       return<br/>                   }<br/>}</span></pre><p id="00e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，如果<code class="fe ly lz ma mb b">selectedCountry</code>没有任何值，那么<code class="fe ly lz ma mb b">selectedCountry</code>的值将被设置为<code class="fe ly lz ma mb b">countries</code>数组的第一项。这是通过使用我们之前编写的<code class="fe ly lz ma mb b">storeData(with:)</code>方法实现的。</p><p id="1636" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ly lz ma mb b">ContentView</code>的最终代码是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="de8e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的申请完成了。现在，是时候创建它的小部件了。为此，我们必须通过“文件-&gt;新建-&gt;目标”来创建一个新目标在那里，我们单击“Widget Extension ”,然后单击“Next”。然后，我们将小部件的名称设为<code class="fe ly lz ma mb b">CountrySelectorWidget</code>，并取消选中<a class="ae lq" href="https://developer.apple.com/documentation/widgetkit/intentconfiguration" rel="noopener ugc nofollow" target="_blank">“包含配置意图”</a>复选框，因为我们将创建一个没有用户可配置属性的小部件或一个具有静态配置的小部件。最后，单击“完成”。之后，如果你得到对话框提示说“激活CountrySelectorWidget方案？”，单击“激活”。这将激活微件方案，稍后，当我们按下“运行”按钮时，我们的微件方案将运行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mk l"/></div></figure><p id="a212" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，如果我们在项目导航器中看到，我们将看到一个名为<code class="fe ly lz ma mb b">CountrySelectorWidget</code>的文件夹。里面有我们打开的<code class="fe ly lz ma mb b">CountrySelectorWidget.swift</code>文件。在这里，我们可以看到四种不同的结构。分别是<code class="fe ly lz ma mb b">Provider</code>、<code class="fe ly lz ma mb b">SimpleEntry</code>、<code class="fe ly lz ma mb b">PlaceholderView</code>、<code class="fe ly lz ma mb b">CountrySelectorWidgetEntryView </code>和<code class="fe ly lz ma mb b">CountrySelectorWidget</code>。</p><p id="be72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">符合<code class="fe ly lz ma mb b"><a class="ae lq" href="https://developer.apple.com/documentation/widgetkit/timelineprovider" rel="noopener ugc nofollow" target="_blank">TimelineProvider</a></code>的<code class="fe ly lz ma mb b">Provider</code>负责通知WidgetKit何时更新小部件的显示。它实现了两种协议方法，<code class="fe ly lz ma mb b">snapshot(with:completion)</code>和<code class="fe ly lz ma mb b">timeline(with:completion:)</code>。当widget要在widget gallery中显示预览时，WidgetKit调用<code class="fe ly lz ma mb b">snapshot(with:completion:)</code>方法。因此，我们应该让小部件准备好虚拟数据，并且几乎不做任何处理，这样小部件预览就可以快速显示在小部件图库中。<br/>调用<code class="fe ly lz ma mb b">timeline(with:completion:)</code>方法来更新小部件。这是我们执行处理以获取新数据并通过更新小部件来显示它们的地方。</p><p id="ac19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">符合<code class="fe ly lz ma mb b">TimelineEntry</code>的<code class="fe ly lz ma mb b">SimpleEntry</code>是一个结构，默认情况下，它指定显示小部件的日期，并且还指示小部件内容的当前相关性。如果需要，我们可以在其中添加其他属性。当我们声明<code class="fe ly lz ma mb b">SimpleEntry</code>时，我们可以包含<code class="fe ly lz ma mb b">CountrySelectorWidget</code>中的配置块呈现小部件所需的任何附加信息。</p><p id="7c65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ly lz ma mb b">PlaceholderView</code>是在数据加载到<code class="fe ly lz ma mb b">CountrySelectorWidgetEntryView</code>的过程中显示的视图，这是小部件在加载和填充数据后显示的实际视图。<code class="fe ly lz ma mb b">CountrySelectorWidgetEntryView</code>从它的<code class="fe ly lz ma mb b">entry</code>属性中获取实际数据。</p><p id="668f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ly lz ma mb b">CountrySelectorWidget</code>是上面提到的所有事情都集中在一起的地方。它标有<code class="fe ly lz ma mb b">@main</code>以便我们的小部件扩展知道这是需要调用的主函数。它有一个属性<code class="fe ly lz ma mb b">kind</code>,存储小部件扩展的名称。它有<code class="fe ly lz ma mb b">body</code>属性，可以有任何类型的<code class="fe ly lz ma mb b">WidgetConfiguration</code>。这里，我们使用了<code class="fe ly lz ma mb b"><a class="ae lq" href="https://developer.apple.com/documentation/widgetkit/staticconfiguration" rel="noopener ugc nofollow" target="_blank">StaticConfiguration</a></code>,因为我们不想在我们的小部件中有任何用户可配置的属性。否则，我们会使用<code class="fe ly lz ma mb b"><a class="ae lq" href="https://developer.apple.com/documentation/widgetkit/intentconfiguration" rel="noopener ugc nofollow" target="_blank">IntentConfiguration</a></code>。在<code class="fe ly lz ma mb b">StaticConfiguration</code>中，我们已经输入了<code class="fe ly lz ma mb b">kind</code>、<code class="fe ly lz ma mb b">provider</code>、<code class="fe ly lz ma mb b">placeholder</code>和一个获取<code class="fe ly lz ma mb b">entry</code>并将其发送到<code class="fe ly lz ma mb b">CountrySelectorWidgetEntryView</code>的块，这是我们的小部件中显示的视图。另外，我们可以在这里设置<code class="fe ly lz ma mb b">description</code>和<code class="fe ly lz ma mb b">configurationDisplayName</code>，以及我们想要支持的小部件的大小(我们将会介绍)。</p><p id="88c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">描述够了！是采取行动的时候了。</p><p id="250f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，在<code class="fe ly lz ma mb b">Provider</code>的第一行中，添加以下几行:</p><pre class="kj kk kl km gt ml mb mm mn aw mo bi"><span id="f7b6" class="mp mq it mb b gy mr ms l mt mu">@AppStorage("selectedCountry", store: UserDefaults(suiteName: "group.np.com.sagunrajlage.CountrySelector"))<br/>var selectedCountry: Data = Data()</span></pre><p id="e737" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些是我们在<code class="fe ly lz ma mb b">ContentView</code>中使用的相同的线。我们在这里再次使用它，因为我们想要访问和修改存储在我们的应用程序组容器中的数据。</p><p id="18eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后，通过添加<code class="fe ly lz ma mb b">country</code>属性来修改<code class="fe ly lz ma mb b">SimpleEntry</code>结构。如果你还记得的话，据说我们可以在必要的时候给这个结构添加我们自己的属性。因此，它看起来像这样:</p><pre class="kj kk kl km gt ml mb mm mn aw mo bi"><span id="c197" class="mp mq it mb b gy mr ms l mt mu">struct SimpleEntry: TimelineEntry {<br/>    public let date: Date<br/>    public let country: Country<br/>}</span></pre><p id="81dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，Xcode不会识别<code class="fe ly lz ma mb b">Country</code>，因为它是在另一个目标中创建的，而不是<code class="fe ly lz ma mb b">CountrySelectorWidgetExtension</code>目标的成员。因此，让我们去<code class="fe ly lz ma mb b">Country.swift</code>并使其成为<code class="fe ly lz ma mb b">CountrySelectorWidgetExtension</code>目标的一员并构建项目，如下面的视频所示。如果任何其他文件出现这样的问题，也要修改它们的目标成员。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mk l"/></div></figure><p id="dcdf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下一步是修改<code class="fe ly lz ma mb b">snapshot(with:completion:)</code>方法。删除该方法中的所有内容，并添加以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="8483" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，我试图从App Groups容器中获取<code class="fe ly lz ma mb b">selectedCountry</code>的值，并对其进行解码。如果解码成功，用当前的<code class="fe ly lz ma mb b">Date</code>和<code class="fe ly lz ma mb b">decodedData</code>将<code class="fe ly lz ma mb b">entry</code>设置为<code class="fe ly lz ma mb b">SimpleEntry</code>的一个实例，否则，设置一个虚拟数据。然后，调用完成处理程序。请注意，当小部件的预览要在小部件库中显示时，会调用此方法。为了更快地加载预览，该方法执行尽可能简单的操作是很重要的。</p><p id="2a29" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们转到<code class="fe ly lz ma mb b">timeline(with:completion:)</code>方法，它负责在用户将小部件添加到他/她的屏幕后更新小部件。该方法也将尝试使用<code class="fe ly lz ma mb b">selectedCountry</code>键从应用程序组容器中获取解码数据。并且如果存在选定的国家，则具有当前<code class="fe ly lz ma mb b">Date</code>并且该值被设置为<code class="fe ly lz ma mb b">entry</code>的<code class="fe ly lz ma mb b">SimpleEntry</code>的实例。但是，如果不存在任何选定的国家(首次启动应用程序时会出现这种情况)，则会将默认值设置为<code class="fe ly lz ma mb b">entry</code>。然后，通过将<code class="fe ly lz ma mb b">entry</code>作为数组项传递并将<code class="fe ly lz ma mb b">policy</code>设置为<code class="fe ly lz ma mb b">.atEnd</code>来创建<code class="fe ly lz ma mb b">Timeline</code>的实例。</p><p id="6b13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ly lz ma mb b">policy</code>属于<code class="fe ly lz ma mb b">TimelineReloadPolicy</code>类型，负责在时间线中的最后一个日期过去后请求新的时间线。<code class="fe ly lz ma mb b">TimelineReloadPolicy</code>负责定义小部件何时重新加载。这里，我们设置了<code class="fe ly lz ma mb b">.atEnd</code>,因为我们希望小部件在前一次输入日期过后重新加载。在当前情况下，这对我们很有用，因为当我们选择一个国家并最小化应用程序时，它会刷新小部件。我们也可以使用<code class="fe ly lz ma mb b">.never</code>从不更新小部件，使用<code class="fe ly lz ma mb b">.after(Date)</code>让它在特定的<code class="fe ly lz ma mb b">Date</code>过后重新加载。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="55c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，是时候构建显示在小部件中的视图了。让我们转到<code class="fe ly lz ma mb b">CountrySelectorWidgetEntryView</code>并将它的<code class="fe ly lz ma mb b">body</code>改为如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="30c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将显示国家的<code class="fe ly lz ma mb b">flag</code>，随后是其<code class="fe ly lz ma mb b">name</code>和<code class="fe ly lz ma mb b">continent</code>。让我们修改<code class="fe ly lz ma mb b">PlaceholderView</code>来显示虚拟数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="4734" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，在我们运行应用程序之前，让我们修改<code class="fe ly lz ma mb b">CountrySelectorWidget</code>中的<code class="fe ly lz ma mb b">configurationDisplayName</code>和<code class="fe ly lz ma mb b">description</code>。因此，<code class="fe ly lz ma mb b">CountrySelectorWidget</code>中的代码将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="4a90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，在我们通过将方案设置为<code class="fe ly lz ma mb b">CountrySelectorWidgetExtension</code>来运行应用程序后，我们将看到一个小部件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/fbc00ebcb4c8e53db96dab55425c62e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*aOcXP-IsK8wSFjG0wHQjKQ.png"/></div></figure><p id="5402" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以对小部件做的另一件事是，我们可以设置小部件支持的大小，并相应地安排视图的内容。上面显示的小工具属于<code class="fe ly lz ma mb b">.systemSmall</code>系列，并且是默认的。但是如果我们使用<code class="fe ly lz ma mb b">.systemMedium</code>或<code class="fe ly lz ma mb b">.systemLarge</code>，我们将能够在我们的小部件中看到许多空白空间。为了检查一下，让我们在<code class="fe ly lz ma mb b">.configurationDisplayName(“Country Selector Widget”)</code>前加上<code class="fe ly lz ma mb b">.supportedFamilies([.systemMedium ])</code>。这是输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/839c27d26deae4f2e3d96f1249831420.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*VwyAwBGSH5uNGAUzMbjnVw.png"/></div></figure><p id="c7db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我们所看到的，在中等大小的部件中有很多空白空间。现在，让我们通过将<code class="fe ly lz ma mb b">.supportedFamilies([.systemMedium ])</code>更改为<code class="fe ly lz ma mb b">.supportedFamilies([.systemLarge])</code>来检查大尺寸的小部件。这是输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/2d2731555bf41d1f8473b54643318ef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*5zRhK3eN3k0BFYbxNmmWdw.png"/></div></figure><p id="10c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可悲的是，它看起来更糟。但幸运的是，有一种方法可以为每种尺寸创建单独的视图。我们所需要做的就是在我们的<code class="fe ly lz ma mb b">CountrySelectorWidgetEntryView</code>中添加<code class="fe ly lz ma mb b">@Environment(\.widgetFamily) var family</code>属性，并在其<code class="fe ly lz ma mb b">body</code>属性中执行<code class="fe ly lz ma mb b">family</code>的切换。记得在<code class="fe ly lz ma mb b">body</code>上方添加<code class="fe ly lz ma mb b">@ViewBuilder</code>属性包装器，因为如果我们想在<code class="fe ly lz ma mb b">body</code>中使用一个开关盒，这是必需的。这是为每种情况添加开关情况和独立视图设计后代码的外观:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="9c8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后把<code class="fe ly lz ma mb b">.supportedFamilies([.systemLarge])</code>改成<code class="fe ly lz ma mb b">.supportedFamilies([.systemLarge, .systemMedium, .systemSmall])</code>。<code class="fe ly lz ma mb b">CountrySelectorWidget</code>的整体代码是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="ed4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在运行代码，看看神奇之处！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/eea6d8fa8175c3683f104b228d8cd1cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*7vTRYb1_C27mH0E38LDSqw.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">中小型部件</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/55bbfe4db521e9fe61abbe409983fc78.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*VR3Mrt6TqNYXiz8Iaq28zw.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">大尺寸部件</figcaption></figure><p id="199c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是我们如何在iOS中创建小部件的全部内容！</p><p id="d537" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你成功地一直读到这里，你已经做了一件了不起的工作，值得为此鼓掌。👏</p><p id="f00f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">快乐的雨燕！</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="0b0d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你觉得这篇文章有用，并且愿意支持我，请"<a class="ae lq" href="https://www.buymeacoffee.com/sagunraj" rel="noopener ugc nofollow" target="_blank">给我买杯咖啡</a>"</p><div class="ne nf gp gr ng nh"><a href="https://www.buymeacoffee.com/sagunraj" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">Sagun Raj Lage正在撰写博客和书籍，并免费教授编程。</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">我是一名iOS开发人员，有从事各种领域相关项目的经验，如交通和…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">www.buymeacoffee.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv ko nh"/></div></div></a></div></div></div>    
</body>
</html>