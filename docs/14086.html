<html>
<head>
<title>Idempotent operations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">幂等运算</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/idempotent-operations-b1d4b9b76417?source=collection_archive---------2-----------------------#2022-11-01">https://levelup.gitconnected.com/idempotent-operations-b1d4b9b76417?source=collection_archive---------2-----------------------#2022-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0136565a6a6361e0d8c75f3061ee2b59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4JwX6FBFWSRrmxhynHUspg.png"/></div></div></figure><p id="5802" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">网络通信的主要任务是在两端保持相同的状态。<br/>但是也有一些问题:<br/>【消息】一方的“消息”可能会在交流过程中丢失<br/>【答案】另一方的“答案”可能会在交流过程中丢失</p><p id="2240" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，来自客户端的请求可能由于网络延迟或后端重启而丢失，或者请求可能已经被发送到失效的后端，等等。</p><p id="545c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个例子是当服务器向客户端发送响应时发生的代理链问题。客户端的互联网连接可能很差，例如使用GPRS或EDGE，或者在漫游时使用慢速互联网连接。</p><p id="1f75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题的另一个来源可能是后端异常。例如，如果您的后端使用MySQL，并且您得到一个“锁等待超时”错误，那么业务逻辑没有被执行。</p><p id="5095" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，您如何确定客户机和服务器的状态是相等的呢？答案很简单，您应该重试来自客户端的所有请求，直到获得正常的非5xx响应状态。</p><p id="e118" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但这可能会产生不良后果。如果我们重试客户端请求，服务器上的一个操作可能会被处理多次。例如，可能会请求支付两次或更多次，或者每次重试都会将来自计费回拨的存款多次添加到用户的余额中。要解决这些问题，你应该使用幂等运算。这在很多情况下都很有用，尤其是在处理分布式系统时，消息可能会丢失，或者会乱序传递。一个真实的例子:</p><blockquote class="kw kx ky"><p id="728f" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">我:拜托，注册请求加Trx<br/>同事:干嘛？<br/>我:如果有东西丢失了，客户会得到一个“EMAIL_USED”错误<br/>同事:没问题，这很正常<br/>同事:所有网站都是这样的</p></blockquote><h1 id="476c" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated"><strong class="ak">定义</strong></h1><p id="9a29" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated"><strong class="ka ir">幂等运算</strong>是可以应用<strong class="ka ir">多次</strong>而不改变结果的运算。</p><p id="2054" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，乘以一就是这样一种运算，因为无论它被应用多少次，结果总是一样的。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="b752" class="mp le iq ml b gy mq mr l ms mt">package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>	fmt.Println(5 * 1)<br/>	fmt.Println(5 * 1 * 1 * 1 * 1)<br/>}</span></pre><p id="c070" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个幂等请求应该有一个唯一的<em class="kz"> trx </em> —操作id。这个我们以后再说。</p><h1 id="28e6" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">何时使用等幂</h1><ul class=""><li id="e674" class="mu mv iq ka b kb mb kf mc kj mw kn mx kr my kv mz na nb nc bi translated">客户端-服务器通信</li><li id="bdb6" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">eventbus消息处理</li><li id="3712" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">外部API执行</li><li id="bf60" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">来自外部API的回调</li></ul><p id="3eae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简而言之，在任何情况下，你都需要确保对方收到了你的信息并处理了它。</p><p id="fefc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看客户机-服务器通信。在客户机-服务器设置的上下文中，幂等运算尤其重要。这是因为当客户端向服务器发出请求时，并不总是保证请求会到达服务器、服务器会处理它或者客户端会得到响应。如果客户机多次发出相同的请求，服务器能够处理它而不改变结果是很重要的。</p><p id="5457" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，考虑这样一种情况，客户机向服务器请求创建一个新用户。如果服务器没有收到请求，或者请求在传输过程中丢失，客户端可以重新发送请求。在这种情况下，有两个关键点:</p><ol class=""><li id="4b8f" class="mu mv iq ka b kb kc kf kg kj ni kn nj kr nk kv nl na nb nc bi translated">重要的是，客户应该重试请求，直到他们得到非5xx响应</li><li id="62c4" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv nl na nb nc bi translated">服务器能够幂等地处理请求是很重要的，因此用户的创建只发生一次</li></ol><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="604f" class="mp le iq ml b gy mq mr l ms mt">package server<br/><br/>type Request struct {<br/>	Trx Trx    // unique for each request<br/>	// some data<br/>}<br/><br/>func (s *Server) processRequest(clientRequest *Request) (*Response, error) {<br/>	s.cacheLock.RLock()<br/>	resp, exists := s.requestCache[clientRequest.Trx]<br/>	s.cacheLock.RUnLock()<br/>	if exists {<br/>		return resp, nil<br/>	}<br/><br/>	resp, err := s.doSomething(clientRequest) // idempotent<br/>	if err != nil {<br/>		return nil, err<br/>	}<br/><br/>	s.cacheLock.Lock()<br/>	s.requestCache[clientRequest.Trx] = resp<br/>	s.cacheLock.UnLock()<br/><br/>	return resp, nil<br/>}<br/><br/>func (s *Server) doSomething(clientRequest *Request) (*Response, error) {<br/>	// ...<br/>}</span></pre><p id="a653" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的代码中，幂等性用于确保doSomething对于每个trx值只被调用一次。</p><p id="f4ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，上面的代码并不能确保同一请求的doSomething不会被多次执行。为了实现这一点，必须使用字母锁定或队列式处理。</p><h1 id="0824" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">TRX id生成</h1><p id="56ca" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated"><strong class="ka ir">随机数。</strong>这是生成trx IDs的最差方式，因为冲突概率太高。</p><p id="eefd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> UUID。</strong>唯一trx生成的最佳算法是UUID。它简单、快速，具有几乎所有语言的实现能力，并且冲突的概率非常低。此外，您可以通过指定UUIDs的上下文来显著降低冲突概率。例如，每个用户或每个站点。UUID v4碰撞的概率仍然是1000亿分之一，即使你生成10亿个UUID。</p><p id="6caf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">哈希函数为trx。</strong>你可以使用body hash来使用body作为trx，但是请注意这可能会导致一些问题。例如，如果您有一个来自支付系统的回拨，那么您可能会在不同的时间收到具有相同数据的多个呼叫。问题不大，但是实施之前要想好。</p><p id="b29a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">降低冲突概率的良好做法是使用trx ids的到期时间。</p><h1 id="09a2" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">常见的错误</h1><p id="1512" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">幂等实现中的一个常见错误是返回类似已经处理过的响应，而不是原始响应。不是等幂！例如，在通过电子邮件进行的用户注册中，您需要处理注册请求:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="af7d" class="mp le iq ml b gy mq mr l ms mt">func (s *Server) processRegistration(clientRequest *RegRequest) (*Response, error) {<br/>	if s.isEmailUsed(clientRequest.Email) {<br/>		return nil, emailUsedResponse(clientRequest)<br/>	}<br/>	// ...<br/>}</span></pre><p id="d73e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是如果请求被客户机丢弃并重新提交，用户将会收到“email used”消息，结果将会是客户机和服务器状态不一致。您经常可以在各种计费API中看到这种不良行为，其中外部服务器返回类似于已经处理的错误的内容，因此我们需要实现自定义逻辑，这使得流程更加复杂和难以理解。正确的做法是在任何处理之前，尽快使用<code class="fe nm nn no ml b">Trx</code>。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="76dc" class="mp le iq ml b gy mq mr l ms mt">package server<br/><br/>type RegRequest struct {<br/>	Trx          Trx<br/>	Email     string<br/>}<br/><br/>func (s *Server) processRegistration(clientRequest *RegRequest) (*Response, error) {<br/>	s.cacheLock.RLock()<br/>	resp, exists := s.requestCache[clientRequest.Trx]<br/>	s.cacheLock.RUnLock()<br/>	if exists {<br/>		return resp, nil<br/>	}<br/>	if s.isEmailUsed(clientRequest.Email) {<br/>		return nil, emailUsedResponse(clientRequest)<br/>	}<br/>	// ...<br/>}</span></pre><p id="cbda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，如果客户端用相同的trx发送注册请求，它应该总是得到相同的响应。如5 * 1 * 1 * 1。</p><h1 id="006c" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">数据库事务和幂等性</h1><p id="cbd8" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">乍一看，使用事务和关系数据库实现幂等性似乎是一个好的实践，但是“重复键异常”破坏了主要的幂等性原则！</p><p id="4ade" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您并行多次发送一个请求，并检查“是否存在具有此事务处理的行”,您可能会得到多个“不，此行不存在”的响应，这取决于您的数据库、事务隔离级别等，因此您将需要共享锁，例如来自Redis的锁。</p><p id="9d07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有时很难支持和理解，所以你应该经常问自己:“我可以只使用一个简单的应用程序和内存中的trx保护器来实现幂等吗，或者我真的应该使用像共享锁这样的东西吗？”</p><h1 id="9fed" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">再多一点</h1><p id="16f1" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">我们关于后端开发的书稿:<a class="ae np" href="https://github.com/octopus-foundation/backend-cookbook" rel="noopener ugc nofollow" target="_blank">https://github.com/octopus-foundation/backend-cookbook</a></p><p id="54d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">谢了。亚历山大·巴楚耶夫&amp;德米特里·萨姆索诺夫</p></div></div>    
</body>
</html>