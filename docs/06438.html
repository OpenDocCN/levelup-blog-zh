<html>
<head>
<title>Learning Python: Object-Based Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习Python:基于对象的编程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-python-object-based-programming-23a69b85109c?source=collection_archive---------12-----------------------#2020-11-24">https://levelup.gitconnected.com/learning-python-object-based-programming-23a69b85109c?source=collection_archive---------12-----------------------#2020-11-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/698986394611bbb966abdfade8e2b64b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6g1hB6O_XstjZVCL"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">奥斯卡·伊尔迪兹在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="e9c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文和接下来的几篇文章中，我将向您介绍Python中的面向对象编程。这些文章将向您展示如何创建您自己的用户定义的数据类型，从而将Python的有用性扩展到您选择的任何领域。在这第一篇文章中，我将演示如何在Python中创建可以用作用户定义类型的简单对象。</p><h1 id="0731" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是对象？</h1><p id="d385" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在编程中有很多关于对象的混淆。出于我的目的，我将这样定义对象:一个用户定义的数据类型，它定义了类型的属性和类型的行为。</p><p id="1e40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要使用您已经熟悉的编程语言，属性是描述对象某个方面的变量。比如一个人有名字，那么名字就是一个人的属性。汽车有发动机，所以发动机是汽车的一个属性。</p><p id="503c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">行为就像一个描述对象做什么的函数。猫会发出声音，所以声音是猫的一种行为。二维空间中的点可以移动，所以移动是点的行为。</p><p id="5e5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们用Python编写面向对象的程序时，我们定义具有属性和行为的对象，并将属性和行为打包到一个包中——类。如果我们不能做到这一点，我们就必须为每个属性和每个行为设置单独的变量，这很快就会变得难以管理。</p><h1 id="25fe" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在Python中创建对象</h1><p id="08f4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在本文中，我不打算创建包含所有属性和所有可能行为的完全开发的对象。相反，我将从演示如何创建对象以及如何定义和访问这些对象的一些属性开始。</p><p id="9a39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们从定义一个<code class="fe mh mi mj mk b">Point</code>对象或类开始。在此之前，让我提一下面向对象编程惯例的一个方面。当定义一个新的类时，类名应该以大写字母开头。这有助于区分类对象和其他事物，如变量。</p><p id="3e08" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是我如何定义一个<code class="fe mh mi mj mk b">Point</code>类:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a0b3" class="mt lf it mk b gy mu mv l mw mx">class Point:<br/>  """Point represents an object in 2-D space"""</span></pre><p id="3575" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">新的类对象是用关键字class后跟类名(以大写字母开头)定义的。后面的字符串叫做docstring，它可以帮助人们识别一个<code class="fe mh mi mj mk b">Point</code>对象代表什么。我可以省略它，但是它让类的定义看起来很奇怪。</p><p id="18b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我可以通过一个叫做实例化的过程来创建一个<code class="fe mh mi mj mk b">Point</code>对象。它被称为实例化，因为它创建了类的一个实例。例如:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f053" class="mt lf it mk b gy mu mv l mw mx">pt1 = Point()</span></pre><p id="6d3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">pt1</code>是<code class="fe mh mi mj mk b">Point</code>类的一个实例，现在可以在程序中使用。</p><p id="5254" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个点有两个属性，一个x坐标和一个y坐标，我可以这样定义它们:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6bf5" class="mt lf it mk b gy mu mv l mw mx">pt1.x = 2.0<br/>pt1.y = 3.0</span></pre><p id="dcfa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">点运算符用于指定类的属性。</p><p id="1cbe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我可以通过从对象中调用属性来检索它们，再次使用点运算符将实例名与属性分开:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a5a9" class="mt lf it mk b gy mu mv l mw mx">print("pt1.x:",pt1.x,", pt1.y:",pt1.y)</span></pre><p id="769c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是我在一个完整的程序中迄今为止所做的工作:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="aeb1" class="mt lf it mk b gy mu mv l mw mx">class Point:<br/>  """Point represents an object in 2-D space"""<br/>  <br/>  pt1 = Point()<br/>  pt1.x = 2.0<br/>  pt1.y = 3.0</span><span id="1d3e" class="mt lf it mk b gy my mv l mw mx">print("pt1.x:",pt1.x,", pt1.y:",pt1.y)</span></pre><p id="cc3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ec59" class="mt lf it mk b gy mu mv l mw mx">pt1 x: 2.0 , pt1 y: 3.0</span></pre><p id="3643" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">目前，您不能访问一个类对象的集合属性，例如通过编写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3764" class="mt lf it mk b gy mu mv l mw mx">print(pt1)</span></pre><p id="d342" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是我在Python shell中尝试时得到的结果:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a760" class="mt lf it mk b gy mu mv l mw mx">&gt;&gt;&gt; print(pt1)<br/>&lt;__main__.Point object at 0x00000145E8560AF0&gt;</span></pre><p id="3fad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这告诉我在这个内存地址有一个<code class="fe mh mi mj mk b">Point</code>对象，但是Python不会访问这个属性。我必须通过点运算符来访问属性。在后面的文章中，我将向您展示如何让这些代码工作，但是现在我们需要看看其他的解决方案。</p><p id="c0da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个解决方案是创建一个打印点的函数。这解决了我们眼前的问题，但不是真正的长期解决方案。我将在下一篇文章中讨论这个解决方案。</p><p id="49b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也就是说，这里有一个打印<code class="fe mh mi mj mk b">Point</code>对象内容的函数和一个使用该函数的测试程序:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="112a" class="mt lf it mk b gy mu mv l mw mx">class Point:<br/>  """Point represents an object in 2-D space"""</span><span id="b234" class="mt lf it mk b gy my mv l mw mx">def printPt(pt):<br/>  print("x:",pt.x,"y:",pt.y)</span><span id="6e0c" class="mt lf it mk b gy my mv l mw mx">pt1 = Point()<br/>pt1.x = 3.0<br/>pt1.y = 5.0<br/>printPt(pt1)</span></pre><p id="4ae1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c7a7" class="mt lf it mk b gy mu mv l mw mx">x: 3.0 y: 5.0</span></pre><p id="345a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这表明我们的用户定义对象可以用作函数的参数。用户定义的对象也可以用作函数返回值。例如，让我们定义一个函数，它可以找到两点之间的中点。下面是函数定义:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6a25" class="mt lf it mk b gy mu mv l mw mx">def midPoint(p1, p2):<br/>  p = Point()<br/>  p.x = (p1.x + p2.x)/2<br/>  p.y = (p1.y + p2.y)/2<br/>  return p</span></pre><p id="e318" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是测试该功能的完整程序:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4f42" class="mt lf it mk b gy mu mv l mw mx">class Point:<br/>  """Point represents an object in 2-D space"""</span><span id="ec6c" class="mt lf it mk b gy my mv l mw mx">def printPt(pt):<br/>  print("x:",pt.x,"y:",pt.y)</span><span id="23da" class="mt lf it mk b gy my mv l mw mx">def midPoint(p1, p2):<br/>  p = Point()<br/>  p.x = (p1.x + p2.x)/2<br/>  p.y = (p1.y + p2.y)/2<br/>  return p</span><span id="4ada" class="mt lf it mk b gy my mv l mw mx">pt1 = Point()<br/>pt1.x = 1<br/>pt1.y = 3<br/>pt2 = Point()<br/>pt2.x = -3<br/>pt2.y = 4<br/>pt3 = Point()<br/>pt3 = midPoint(pt1, pt2)<br/>printPt(pt1)<br/>printPt(pt2)<br/>print("Midpoint:",end="")<br/>printPt(pt3)</span></pre><p id="3e3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f2df" class="mt lf it mk b gy mu mv l mw mx">x: 1 y: 3<br/>x: -3 y: 4<br/>Midpoint: x: -1.0 y: 3.5</span></pre><h1 id="aef4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Python对象是可变的</h1><p id="91fb" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">您可以通过访问赋值语句中的属性来更改对象的属性。例如:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7171" class="mt lf it mk b gy mu mv l mw mx">p1 = Point()<br/>p1.x = 1<br/>p1.y = 2<br/>printPt(p1)<br/>p1.x = 4<br/>printPt(p1)</span></pre><p id="c112" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5e2a" class="mt lf it mk b gy mu mv l mw mx">x: 1 y: 2<br/>x: 4 y: 2</span></pre><h1 id="3b5b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">当心复制对象</h1><p id="0d95" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当你使用赋值来复制一个类对象时，你创建了一个原始对象的<em class="mz">浅</em>副本，有时也被称为<em class="mz">别名</em>。这意味着，如果您对原始对象进行了更改，复制的对象也会随之更改。这里有一个例子:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ae95" class="mt lf it mk b gy mu mv l mw mx">class Point:<br/>  """Point represents an object in 2-D space"""</span><span id="4587" class="mt lf it mk b gy my mv l mw mx">def printPt(pt):<br/>  print("x:",pt.x,"y:",pt.y)</span><span id="9d86" class="mt lf it mk b gy my mv l mw mx">p1 = Point()<br/>p1.x = 1<br/>p1.y = 2<br/>print("p1: ",end="")<br/>printPt(p1)<br/>p2 = p1<br/>print("p2: ",end="")<br/>printPt(p2)<br/>p1.x = 2<br/>print("p1: ",end="")<br/>printPt(p1)<br/>print("p2: ",end="")<br/>printPt(p2)</span></pre><p id="b652" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3354" class="mt lf it mk b gy mu mv l mw mx">p1: x: 1 y: 2<br/>p2: x: 1 y: 2<br/>p1: x: 2 y: 2<br/>p2: x: 2 y: 2</span></pre><p id="82b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我改变了<code class="fe mh mi mj mk b">p1 </code>的x坐标，当我这样做的时候，<code class="fe mh mi mj mk b">p2</code>的x坐标也改变了。这是因为，在内部，<code class="fe mh mi mj mk b">p2</code>对象“指向”了<code class="fe mh mi mj mk b">p1 </code>对象，所以对<code class="fe mh mi mj mk b">p1 </code>的任何更改也会发生在<code class="fe mh mi mj mk b">p2</code>上。</p><p id="25eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解决这个问题的方法是使用Python提供的复制模块。模块中有<code class="fe mh mi mj mk b">copy</code>函数，它将对传递给它的对象进行深层复制。</p><p id="62e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是上面用<code class="fe mh mi mj mk b">copy</code>函数改写的例子:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7207" class="mt lf it mk b gy mu mv l mw mx">import copy</span><span id="bc42" class="mt lf it mk b gy my mv l mw mx">class Point:<br/>  """Point represents an object in 2-D space"""</span><span id="0f76" class="mt lf it mk b gy my mv l mw mx">def printPt(pt):<br/>  print("x:",pt.x,"y:",pt.y)</span><span id="c078" class="mt lf it mk b gy my mv l mw mx">p1 = Point()<br/>p1.x = 1<br/>p1.y = 2<br/>print("p1: ",end="")<br/>printPt(p1)<br/>p2 = copy.copy(p1)<br/>print("p2: ",end="")<br/>printPt(p2)<br/>p1.x = 2<br/>print("p1: ",end="")<br/>printPt(p1)<br/>print("p2: ",end="")<br/>printPt(p2)</span></pre><p id="00a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f34b" class="mt lf it mk b gy mu mv l mw mx">p1: x: 1 y: 2<br/>p2: x: 1 y: 2<br/>p1: x: 2 y: 2<br/>p2: x: 1 y: 2</span></pre><p id="ad7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，当我复制<code class="fe mh mi mj mk b">p1</code>并更改它的一个或多个属性时，这些更改不会反映在<code class="fe mh mi mj mk b">p2</code>对象中。</p><p id="4c07" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这总结了本文中我想说的关于Python对象的所有内容。在我的下一篇文章中，我们将研究如何在类定义中移动函数，以便在类对象和对象使用的函数(在类中定义时称为方法)之间有更紧密的耦合。</p><p id="59e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读。请将您的意见和建议发电子邮件至mmmcmillan1@att.net<a class="ae kf" href="mailto:mmmcmillan1@att.net" rel="noopener ugc nofollow" target="_blank">或回复如下。</a></p></div></div>    
</body>
</html>