<html>
<head>
<title>Using WorkManager in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Android中使用工作管理器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-workmanager-in-android-be5cae1f155a?source=collection_archive---------5-----------------------#2021-08-12">https://levelup.gitconnected.com/using-workmanager-in-android-be5cae1f155a?source=collection_archive---------5-----------------------#2021-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="cb15" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Android中使用工作管理器</p><p id="d46f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">文章在此:</em><a class="ae kp" href="https://flatteredwithflutter.com/using-workmanager-in-android/" rel="noopener ugc nofollow" target="_blank"><em class="ko">https://flattered with flutter . com/using-work manager-in-Android/</em></a></p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="kv kw l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">在Android中使用工作管理器</figcaption></figure><p id="6c30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将简要介绍:</p><ol class=""><li id="8513" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn lg lh li lj bi translated">创建自定义工作管理器</li><li id="81e0" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">创建一次工作请求</li><li id="6383" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">创建PeriodicWorkRequest</li><li id="40ab" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">为工人编写测试(步骤2和步骤3)</li></ol><blockquote class="lp lq lr"><p id="c74f" class="jq jr ko js b jt ju jv jw jx jy jz ka ls kc kd ke lt kg kh ki lu kk kl km kn im bi translated">注意:本文并不解释工作管理器的<a class="ae kp" href="https://medium.com/androiddevelopers/introducing-workmanager-2083bcfc4712" rel="noopener">工作原理，而是侧重于它的使用。</a></p></blockquote><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lv"><img src="../Images/84e3039928c22044cd84f4fd46281b67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uQnlG22lgrcmYetwoZtmQw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">在Android中使用工作管理器</figcaption></figure><h1 id="7984" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">创建自定义工作管理器</h1><p id="e4e0" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">如果您不熟悉WorkManager，这里有详细的描述<a class="ae kp" href="https://developer.android.com/topic/libraries/architecture/workmanager" rel="noopener ugc nofollow" target="_blank">和</a></p><p id="6060" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据文件</p><blockquote class="lp lq lr"><p id="a693" class="jq jr ko js b jt ju jv jw jx jy jz ka ls kc kd ke lt kg kh ki lu kk kl km kn im bi translated">默认情况下，当您的应用程序启动时，WorkManager会自动配置自身。如果您需要更多地控制工作管理器如何管理和调度工作，您可以定制工作管理器配置。</p></blockquote><ul class=""><li id="f91b" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn nf lh li lj bi translated">在您的应用程序的<code class="fe ng nh ni nj b">build.gradle</code>中安装依赖项</li></ul><pre class="kq kr ks kt gt nk nj nl nm aw nn bi"><span id="26b4" class="no md it nj b gy np nq l nr ns">def work_version = "2.5.0"</span><span id="b36a" class="no md it nj b gy nt nq l nr ns">implementation "androidx.work:work-runtime-ktx:$work_version"<br/>androidTestImplementation "androidx.work:work-testing:$work_version"</span></pre><ul class=""><li id="f366" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn nf lh li lj bi translated">从<code class="fe ng nh ni nj b">AndroidManifest.xml</code>中移除默认初始化器</li></ul><pre class="kq kr ks kt gt nk nj nl nm aw nn bi"><span id="6b99" class="no md it nj b gy np nq l nr ns">&lt;provider<br/>   android:name="androidx.work.impl.WorkManagerInitializer"<br/>   android:authorities="${applicationId}.workmanager-init"<br/>   tools:node="remove" /&gt;</span></pre><ul class=""><li id="c0c4" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn nf lh li lj bi translated">创建您的应用程序类并定义您自己的自定义配置。</li></ul><pre class="kq kr ks kt gt nk nj nl nm aw nn bi"><span id="b683" class="no md it nj b gy np nq l nr ns">class TodoApplication() : Application(), Configuration.Provider {<br/>    override fun onCreate() {<br/>      super.onCreate()<br/>      // LATER PUT THE PERIODIC WORK REQUEST HERE<br/>    }</span><span id="e2d8" class="no md it nj b gy nt nq l nr ns">    override fun getWorkManagerConfiguration(): Configuration {<br/> <br/>       return if (BuildConfig.DEBUG) {         Configuration.Builder().setMinimumLoggingLevel(Log.DEBUG).build()<br/>        } <br/>        else {            Configuration.Builder().setMinimumLoggingLevel(Log.ERROR).build()<br/>        }<br/>    }</span><span id="a24c" class="no md it nj b gy nt nq l nr ns">}</span></pre><blockquote class="lp lq lr"><p id="bfb3" class="jq jr ko js b jt ju jv jw jx jy jz ka ls kc kd ke lt kg kh ki lu kk kl km kn im bi translated">这里，我们使用<strong class="js iu">配置。提供者</strong>扩展我们的TodoApplication <strong class="js iu">、</strong>并覆盖<strong class="js iu">getWorkManagerConfiguration</strong></p></blockquote><p id="cc51" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的例子中，我们只需配置日志记录级别。有关可用定制的完整列表，请参见<code class="fe ng nh ni nj b"><a class="ae kp" href="https://developer.android.com/reference/androidx/work/Configuration.Builder" rel="noopener ugc nofollow" target="_blank"><em class="ko">Configuration.Builder()</em></a></code></p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="95f1" class="mc md it bd me mf ob mh mi mj oc ml mm mn od mp mq mr oe mt mu mv of mx my mz bi translated">创建一次工作请求</h1><p id="253a" class="pw-post-body-paragraph jq jr it js b jt na jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj ne kl km kn im bi translated">这是我们的文件夹结构的样子</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi og"><img src="../Images/24b03f77f9d9bffe4622070ccbfb0f9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G2B3z87Fc8VOtTIy3hC03Q.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">应用程序中的工人</figcaption></figure><p id="be45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了创建任何工作者，我们需要以下内容:</p><ul class=""><li id="9bb8" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn nf lh li lj bi translated">Worker(此部分) :您希望在后台执行的实际工作</li><li id="e45c" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">WorkRequest(在viewmodel部分创建):这表示做一些工作的请求。</li><li id="cd05" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">工作管理器(上面创建的):安排您的<code class="fe ng nh ni nj b">WorkRequest</code>并让它运行</li></ul><p id="7904" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将从<strong class="js iu">ondemankbackupworker</strong>开始，它的基本目标是将数据保存到某个后端上(在我们的演示中，我们在网络调用中假装)</p><p id="3fd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后是<strong class="js iu">文件工作器</strong>，它在设备上创建一个文件，并将时间戳附加到新创建的文件中</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/a09f99b94bfe341186f35a09d61ade73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*qIQ1C9WNMTttHjEJjLprCw.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">文件工作器输出</figcaption></figure><h2 id="9507" class="no md it bd me oi oj dn mi ok ol dp mm kb om on mq kf oo op mu kj oq or my os bi translated">OnDemandBackupWorker</h2><ul class=""><li id="fe88" class="lb lc it js b jt na jx nb kb ot kf ou kj ov kn nf lh li lj bi translated">这个类从<a class="ae kp" href="https://developer.android.com/reference/kotlin/androidx/work/CoroutineWorker" rel="noopener ugc nofollow" target="_blank">协同工作器</a>扩展而来(提供与Kotlin协同程序的互操作)</li><li id="0275" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">我们为挂起的工作覆盖了doWork函数</li></ul><pre class="kq kr ks kt gt nk nj nl nm aw nn bi"><span id="cd09" class="no md it nj b gy np nq l nr ns">override suspend fun doWork(): Result {<br/>    val appContext = applicationContext<br/>    showNotifications("Backing up the data", appContext)</span><span id="d6eb" class="no md it nj b gy nt nq l nr ns">    return try {<br/>       val res = dummyWork()<br/>       val outputData = workDataOf(KEY_ONDEMANDWORKER_RESP to res)</span><span id="e5a4" class="no md it nj b gy nt nq l nr ns">       Result.success(outputData)<br/>    } catch (throwable: Throwable) {<br/>       Timber.e(throwable)<br/>       Result.failure()<br/>    }<br/>}</span><span id="93b5" class="no md it nj b gy nt nq l nr ns">private suspend fun dummyWork(): String {<br/>     // Faking the network call<br/>     sleep()<br/>     return "Completed successfully!"<br/>}<br/></span></pre><blockquote class="lp lq lr"><p id="8c1b" class="jq jr ko js b jt ju jv jw jx jy jz ka ls kc kd ke lt kg kh ki lu kk kl km kn im bi translated">在这里，我们创建了一个dummyWork函数，(它将线程置于睡眠状态)并返回字符串结果。</p></blockquote><ul class=""><li id="ab27" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn nf lh li lj bi translated">然后使用一个键(应该是一个字符串)将结果放入<code class="fe ng nh ni nj b">workDataOf</code>(这将对列表转换为数据对象)</li><li id="aeaa" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">这个结果/输出然后被传递到工人的<code class="fe ng nh ni nj b">Result.success</code>上，表示工作成功完成</li><li id="3153" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">如果有任何错误，我们打电话给工人的<code class="fe ng nh ni nj b">Result.failure</code></li></ul></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h2 id="82ac" class="no md it bd me oi oj dn mi ok ol dp mm kb om on mq kf oo op mu kj oq or my os bi translated">档案工作者</h2><ul class=""><li id="aed0" class="lb lc it js b jt na jx nb kb ot kf ou kj ov kn nf lh li lj bi translated">这个类从<a class="ae kp" href="https://developer.android.com/reference/androidx/work/Worker" rel="noopener ugc nofollow" target="_blank"> Worker </a>扩展而来(在后台线程上同步执行工作)</li><li id="c97b" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">我们覆盖了同步工作的doWork函数</li></ul><pre class="kq kr ks kt gt nk nj nl nm aw nn bi"><span id="0888" class="no md it nj b gy np nq l nr ns">override fun doWork(): Result {</span><span id="8384" class="no md it nj b gy nt nq l nr ns">return try {<br/>   val content="Backed up on ${dateFormatter.format(Date())}"</span><span id="d679" class="no md it nj b gy nt nq l nr ns">   val outputUri = saveToFile(appContext, content)<br/>   val data=workDataOf(KEY_FILEWORKER_RESP to outputUri.toString())</span><span id="0cd9" class="no md it nj b gy nt nq l nr ns">   Result.success(data)<br/>   <br/> } catch (throwable: Throwable) {<br/>     Timber.e(throwable)<br/>     Result.failure()<br/>   }<br/>}</span></pre><blockquote class="lp lq lr"><p id="0e2a" class="jq jr ko js b jt ju jv jw jx jy jz ka ls kc kd ke lt kg kh ki lu kk kl km kn im bi translated">这里，我们使用saveToFile创建一个文件，并将当前时间戳作为文本放入该文件</p></blockquote><ul class=""><li id="ade2" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn nf lh li lj bi translated">然后结果被放入<code class="fe ng nh ni nj b">workDataOf</code>中，像以前一样，我们将它传递给工人的<code class="fe ng nh ni nj b">Result.success</code></li></ul></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h2 id="1efc" class="no md it bd me oi oj dn mi ok ol dp mm kb om on mq kf oo op mu kj oq or my os bi translated">OnDemandBackupViewModel</h2><ul class=""><li id="acaa" class="lb lc it js b jt na jx nb kb ot kf ou kj ov kn nf lh li lj bi translated">该类负责创建工作请求，并从<a class="ae kp" href="https://developer.android.com/reference/androidx/lifecycle/AndroidViewModel" rel="noopener ugc nofollow" target="_blank"> AndroidViewModel </a>扩展而来。</li><li id="8a92" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">我们在这个类中定义了两个函数(<em class="ko"> beginBackup和cancelBackup </em>)</li></ul><pre class="kq kr ks kt gt nk nj nl nm aw nn bi"><span id="2f71" class="no md it nj b gy np nq l nr ns">internal fun beginBackup() {<br/>   val constraints = Constraints.Builder()<br/>     .setRequiresStorageNotLow(true)<br/>     .setRequiresBatteryNotLow(true)<br/>     .setRequiredNetworkType(NetworkType.CONNECTED)<br/>     .build()</span><span id="cf74" class="no md it nj b gy nt nq l nr ns">var continuation = workManager.beginUniqueWork(<br/>       ONDEMAND_BACKUP_WORK_NAME,<br/>       ExistingWorkPolicy.KEEP,<br/>    OneTimeWorkRequest.from(OnDemandBackupWorker::class.java)<br/>   )</span><span id="5628" class="no md it nj b gy nt nq l nr ns">// BACKUP WORKER<br/>   val backupBuilder = OneTimeWorkRequestBuilder&lt;OnDemandBackupWorker&gt;()<br/>        <br/>  <br/>  backupBuilder.addTag(TAG_BACKUP)<br/>  backupBuilder.setConstraints(constraints)<br/>  continuation = continuation.then(backupBuilder.build())</span><span id="5424" class="no md it nj b gy nt nq l nr ns">// SAVE FILE WORKER<br/>  val saveInFile = OneTimeWorkRequest.Builder(FileWorker::class.java)<br/>      .setConstraints(constraints)<br/>      .addTag(TAG_FILE)<br/>      .build()</span><span id="755f" class="no md it nj b gy nt nq l nr ns">  continuation = continuation.then(saveInFile)<br/>  continuation.enqueue()<br/>}<br/></span><span id="81cd" class="no md it nj b gy nt nq l nr ns">internal fun cancelBackup() {</span><span id="c730" class="no md it nj b gy nt nq l nr ns">   workManager.cancelUniqueWork(ONDEMAND_BACKUP_WORK_NAME)<br/>}</span></pre><ul class=""><li id="1daf" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn nf lh li lj bi translated">指定工作人员应该运行的约束条件(在我们的例子中，我们指定存储、电池和互联网)</li><li id="8d82" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">我们在viewmodel类中获得了一个workmanager实例。利用这个实例，我们称之为<code class="fe ng nh ni nj b">beginUniqueWork</code></li></ul><blockquote class="lp lq lr"><p id="549b" class="jq jr ko js b jt ju jv jw jx jy jz ka ls kc kd ke lt kg kh ki lu kk kl km kn im bi translated">因为我们需要链接我们的工作请求，所以我们使用<code class="fe ng nh ni nj b">beginUniqueWork</code></p></blockquote><ul class=""><li id="1dad" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn nf lh li lj bi translated">我们给我们的worker一个惟一的名字(基本上是一个字符串)，用选项<code class="fe ng nh ni nj b"><a class="ae kp" href="http://d.android.com/reference/androidx/work/ExistingWorkPolicy#keep" rel="noopener ugc nofollow" target="_blank">KEEP</a></code>指定<code class="fe ng nh ni nj b"><a class="ae kp" href="http://d.android.com/reference/androidx/work/ExistingWorkPolicy" rel="noopener ugc nofollow" target="_blank">ExistingWorkPolicy</a></code>，并从OnDemandBackupWorker类创建一个OneTimeWorkRequest</li><li id="6ef6" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated"><code class="fe ng nh ni nj b">beginUniqueWork</code>的输出是一个连续工作。</li><li id="817d" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">接下来，我们使用<code class="fe ng nh ni nj b">OneTimeWorkRequestBuilder</code>创建WorkRequest构建器。我们为这项工作添加了标签，用于以后识别这项工作的进度</li><li id="5fe5" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">该请求被添加到<code class="fe ng nh ni nj b">WorkContinuation</code></li><li id="cc5a" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">我们为我们的文件工作者重复最后两个步骤</li><li id="57bb" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">最后，我们的工作请求链需要添加到队列中(以便在后台线程上运行)。这是使用<code class="fe ng nh ni nj b">enqueue</code>完成的</li></ul><blockquote class="lp lq lr"><p id="9d1c" class="jq jr ko js b jt ju jv jw jx jy jz ka ls kc kd ke lt kg kh ki lu kk kl km kn im bi translated">注意:为了取消一个工作请求，我们简单地调用带有标签的<code class="fe ng nh ni nj b">cancelUniqueWork</code>(用于创建工作)</p></blockquote></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h2 id="4464" class="no md it bd me oi oj dn mi ok ol dp mm kb om on mq kf oo op mu kj oq or my os bi translated">跟踪工作请求的进度</h2><ul class=""><li id="fdfa" class="lb lc it js b jt na jx nb kb ot kf ou kj ov kn nf lh li lj bi translated">因为我们为我们的工人添加了标签，所以我们可以利用它们来获得任何<code class="fe ng nh ni nj b">WorkRequest</code>的状态</li><li id="c8a0" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">它返回一个保存了一个<code class="fe ng nh ni nj b"><a class="ae kp" href="http://d.android.com/reference/androidx/work/WorkInfo" rel="noopener ugc nofollow" target="_blank">WorkInfo</a></code>对象的<code class="fe ng nh ni nj b">LiveData</code>。<code class="fe ng nh ni nj b">WorkInfo</code>是一个包含关于当前状态细节的对象<code class="fe ng nh ni nj b">WorkRequest</code></li></ul><pre class="kq kr ks kt gt nk nj nl nm aw nn bi"><span id="2163" class="no md it nj b gy np nq l nr ns">internal val backupDataInfo: LiveData&lt;List&lt;WorkInfo&gt;&gt; = workManager<br/>        .getWorkInfosByTagLiveData(TAG_BACKUP)</span></pre><blockquote class="lp lq lr"><p id="d635" class="jq jr ko js b jt ju jv jw jx jy jz ka ls kc kd ke lt kg kh ki lu kk kl km kn im bi translated">这里，<code class="fe ng nh ni nj b">TAG_BACKUP</code>是我们之前指定的标签</p></blockquote></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="514a" class="mc md it bd me mf ob mh mi mj oc ml mm mn od mp mq mr oe mt mu mv of mx my mz bi translated">创建PeriodicWorkRequest</h1><blockquote class="lp lq lr"><p id="0e50" class="jq jr ko js b jt ju jv jw jx jy jz ka ls kc kd ke lt kg kh ki lu kk kl km kn im bi translated">注意:PeriodicBackupWorker与FileWorker相同(唯一的区别是文件内容)</p></blockquote><ul class=""><li id="dbd3" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn nf lh li lj bi translated">该工作执行多次，直到被取消，第一次执行立即发生，或者在满足给定的<code class="fe ng nh ni nj b"><a class="ae kp" href="https://developer.android.com/reference/androidx/work/Constraints" rel="noopener ugc nofollow" target="_blank">Constraints</a></code>后立即发生。</li><li id="b60c" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">下一次执行将发生在周期间隔期间。</li><li id="98ab" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">转到我们的应用程序类并实例化<code class="fe ng nh ni nj b"><a class="ae kp" href="https://developer.android.com/reference/androidx/work/PeriodicWorkRequest.Builder" rel="noopener ugc nofollow" target="_blank">PeriodicWorkRequest.Builder</a></code></li></ul><pre class="kq kr ks kt gt nk nj nl nm aw nn bi"><span id="4fb6" class="no md it nj b gy np nq l nr ns">val constraints = Constraints.Builder()<br/>    .setRequiresStorageNotLow(true)<br/>    .setRequiresBatteryNotLow(true)<br/>    .setRequiredNetworkType(NetworkType.UNMETERED)<br/>    .build()</span><span id="e2b4" class="no md it nj b gy nt nq l nr ns">val periodicBackup = PeriodicWorkRequestBuilder&lt;PeriodicBackupWorker&gt;(1, TimeUnit.DAYS)<br/>    .addTag(TAG_PERIODIC_BACKUP)<br/>    .setConstraints(constraints)<br/>    .build()</span><span id="1a78" class="no md it nj b gy nt nq l nr ns">WorkManager.getInstance(this).enqueueUniquePeriodicWork(<br/>     PERIODIC_BACKUP_WORK_NAME,<br/>     ExistingPeriodicWorkPolicy.KEEP,<br/>     periodicBackup<br/> )</span></pre><ul class=""><li id="c78f" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn nf lh li lj bi translated">我们根据需要指定约束</li><li id="d7a0" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">使用<code class="fe ng nh ni nj b">PeriodicWorkRequestBuilder</code>，我们创建了我们的<code class="fe ng nh ni nj b">PeriodicWorkRequest</code></li><li id="7514" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">时间间隔被指定为每天一次。</li></ul><blockquote class="lp lq lr"><p id="ed92" class="jq jr ko js b jt ju jv jw jx jy jz ka ls kc kd ke lt kg kh ki lu kk kl km kn im bi translated">周期性工作的最小间隔为15分钟。此外，如果您的定期工作有约束，即使满足了期间之间的延迟，也不会执行，直到满足约束。</p></blockquote><ul class=""><li id="ec15" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn nf lh li lj bi translated">我们使用<code class="fe ng nh ni nj b">enqueueUniquePeriodicWork</code>对<code class="fe ng nh ni nj b">PeriodicWorkRequest</code>进行排队，保持工作策略为<code class="fe ng nh ni nj b">Keep</code></li></ul><blockquote class="lp lq lr"><p id="5b1a" class="jq jr ko js b jt ju jv jw jx jy jz ka ls kc kd ke lt kg kh ki lu kk kl km kn im bi translated">PeriodicWorkRequest的正常生命周期是<code class="fe ng nh ni nj b">ENQUEUED -&gt; RUNNING -&gt; ENQUEUED</code></p></blockquote></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="17a3" class="mc md it bd me mf ob mh mi mj oc ml mm mn od mp mq mr oe mt mu mv of mx my mz bi translated">为工人编写测试</h1><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/db94bb23245c1ac44ee93f438088c956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/0*C1g7vmhrbR2S8WM_.gif"/></div></figure><p id="68af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在将为我们的工人编写测试:<code class="fe ng nh ni nj b">OnDemandBackupWorker</code>和<code class="fe ng nh ni nj b">PeriodicBackupWorker</code></p><h2 id="bfe0" class="no md it bd me oi oj dn mi ok ol dp mm kb om on mq kf oo op mu kj oq or my os bi translated"><code class="fe ng nh ni nj b">OnDemandBackupWorkerTest</code></h2><ul class=""><li id="1864" class="lb lc it js b jt na jx nb kb ot kf ou kj ov kn nf lh li lj bi translated">创建一个测试类<a class="ae kp" href="https://github.com/AseemWangoo/hands_on_kotlin/blob/master/app/src/androidTest/java/com/aseemwangoo/handsonkotlin/worker/OnDemandBackupWorkerTest.kt" rel="noopener ugc nofollow" target="_blank">ondemankbackupworkertest</a></li><li id="2eee" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">我们用<code class="fe ng nh ni nj b">AndroidJUnit4</code>注释我们的类，这是驱动单个类测试的东西。</li></ul><pre class="kq kr ks kt gt nk nj nl nm aw nn bi"><span id="cc60" class="no md it nj b gy np nq l nr ns">@RunWith(AndroidJUnit4::class)<br/>class OnDemandBackupWorkerTest {</span><span id="76e3" class="no md it nj b gy nt nq l nr ns"> private lateinit var context: Context<br/> private lateinit var executor: Executor</span><span id="2069" class="no md it nj b gy nt nq l nr ns"> @Before<br/> fun setUp() {<br/>     context = ApplicationProvider.getApplicationContext()<br/>     executor = Executors.newSingleThreadExecutor()<br/> }</span><span id="e733" class="no md it nj b gy nt nq l nr ns"> @Test<br/> fun testOnDemandBackupWorker() {<br/>    val worker = TestListenableWorkerBuilder&lt;OnDemandBackupWorker&gt; (context).build()<br/>    <br/>   runBlocking {<br/>     val result = worker.doWork()<br/>     assertTrue(result is ListenableWorker.Result.Success)<br/>   }<br/> }<br/>}</span></pre><ul class=""><li id="3465" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn nf lh li lj bi translated">我们初始化<code class="fe ng nh ni nj b">setUp</code>中的上下文和执行器，并编写一个测试<code class="fe ng nh ni nj b">testOnDemandBackupWorker</code></li><li id="0762" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">因为我们的OnDemandBackupWorker是一个协同工作器，所以我们使用了<code class="fe ng nh ni nj b">TestListenableWorkerBuilder</code>，它基本上构建了用于测试的<code class="fe ng nh ni nj b"><a class="ae kp" href="https://developer.android.com/reference/androidx/work/ListenableWorker" rel="noopener ugc nofollow" target="_blank">ListenableWorker</a></code>的实例。</li><li id="523f" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">接下来，我们调用<a class="ae kp" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html" rel="noopener ugc nofollow" target="_blank"> runBlocking </a>中的<code class="fe ng nh ni nj b">doWork</code>(它在主线程上同步执行测试，我们想要测试它)</li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi ox"><img src="../Images/c34a2c432bf4ef472a0e415b7a4da787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d3Pj16AbbPVVb-L8s2zd7Q.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">OnDemandBackupWorkerTest</figcaption></figure></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h2 id="eb87" class="no md it bd me oi oj dn mi ok ol dp mm kb om on mq kf oo op mu kj oq or my os bi translated"><code class="fe ng nh ni nj b">PeriodicBackupWorkerTest</code></h2><ul class=""><li id="4852" class="lb lc it js b jt na jx nb kb ot kf ou kj ov kn nf lh li lj bi translated">创建一个测试类<a class="ae kp" href="https://github.com/AseemWangoo/hands_on_kotlin/blob/master/app/src/androidTest/java/com/aseemwangoo/handsonkotlin/worker/PeriodicBackupWorkerTest.kt" rel="noopener ugc nofollow" target="_blank">PeriodicBackupWorkerTest</a></li><li id="8f7d" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">和以前一样，我们用<code class="fe ng nh ni nj b">setUp</code>方法初始化并编写2个测试</li></ul><pre class="kq kr ks kt gt nk nj nl nm aw nn bi"><span id="ec66" class="no md it nj b gy np nq l nr ns">// TEST 1</span><span id="1dd0" class="no md it nj b gy nt nq l nr ns">@Test<br/>fun testPeriodicBackUpWorker() {<br/>   val worker = TestWorkerBuilder&lt;PeriodicBackupWorker&gt;(<br/>        context = context,<br/>        executor = executor<br/>    ).build()</span><span id="66be" class="no md it nj b gy nt nq l nr ns">   val result = worker.doWork()<br/>   assertTrue(result is ListenableWorker.Result.Success)<br/>}</span></pre><ul class=""><li id="2745" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn nf lh li lj bi translated">因为我们的PeriodicBackupWorker是一个Worker，所以我们使用了<code class="fe ng nh ni nj b">TestWorkerBuilder</code>，它基本上构建了用于测试的<code class="fe ng nh ni nj b"><a class="ae kp" href="https://developer.android.com/reference/androidx/work/Worker" rel="noopener ugc nofollow" target="_blank">Worker</a></code>的实例。</li><li id="3520" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">接下来，我们调用<code class="fe ng nh ni nj b">doWork</code>并断言<code class="fe ng nh ni nj b">Result.success</code></li></ul></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><ul class=""><li id="2363" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn nf lh li lj bi translated">对于第二个测试，我们检查周期性工作状态是否为<code class="fe ng nh ni nj b">ENQUEUED</code></li></ul><pre class="kq kr ks kt gt nk nj nl nm aw nn bi"><span id="8613" class="no md it nj b gy np nq l nr ns">// TEST 2</span><span id="edfa" class="no md it nj b gy nt nq l nr ns">@Test<br/>fun testIfPeriodicBackupRunning() {<br/> WorkManagerTestInitHelper.initializeTestWorkManager(context)<br/> <br/> val testDriver = WorkManagerTestInitHelper.getTestDriver(context)<br/> val workManager = WorkManager.getInstance(context)</span><span id="addb" class="no md it nj b gy nt nq l nr ns"> val constraints = Constraints.Builder()<br/>     .setRequiresStorageNotLow(true)<br/>     .setRequiresBatteryNotLow(true)<br/>     .setRequiredNetworkType(NetworkType.UNMETERED)<br/>     .build()</span><span id="058e" class="no md it nj b gy nt nq l nr ns"> val request =<br/>     PeriodicWorkRequestBuilder&lt;PeriodicBackupWorker&gt; (repeatInterval=24, TimeUnit.HOURS)<br/>         .setConstraints(constraints)<br/>         .build()</span><span id="b8ba" class="no md it nj b gy nt nq l nr ns"> workManager.enqueue(request).result.get()</span><span id="5ec8" class="no md it nj b gy nt nq l nr ns"> with(testDriver) {<br/>      this?.setPeriodDelayMet(request.id)<br/>      this?.setAllConstraintsMet(request.id)<br/> }</span><span id="eddf" class="no md it nj b gy nt nq l nr ns"> val workInfo = workManager.getWorkInfoById(request.id).get()<br/> assertEquals(workInfo.state, WorkInfo.State.ENQUEUED)<br/>}</span></pre><ul class=""><li id="986f" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn nf lh li lj bi translated">我们利用<code class="fe ng nh ni nj b">WorkManagerTestInitHelper</code>帮助初始化<code class="fe ng nh ni nj b">WorkManager</code>进行测试。</li><li id="c8f1" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">设置约束，创建一个PeriodicWorkRequest，并使用workManager实例将其入队</li><li id="dda2" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn nf lh li lj bi translated">接下来，我们利用<code class="fe ng nh ni nj b">testDriver</code>来满足约束，并断言状态是否为<code class="fe ng nh ni nj b">ENQUEUED</code></li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi oy"><img src="../Images/74ce05352ed0f7c5e93b7cac602cee0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DIfcJr9nsoWlX2O0bU_O5Q.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><code class="fe ng nh ni nj b">PeriodicBackupWorkerTest</code></figcaption></figure><p id="2e3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其他文章:</p><div class="oz pa gp gr pb pc"><a rel="noopener  ugc nofollow" target="_blank" href="/using-room-in-jetpack-compose-d2b6b674d3a5"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">在Jetpack Compose中使用房间</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">在Jetpack Compose中使用房间</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">使用喷气背包Composelevelup.gitconnected.com的房间</p></div></div><div class="pl l"><div class="pm l pn po pp pl pq ma pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a rel="noopener  ugc nofollow" target="_blank" href="/using-state-in-jetpack-compose-b7445b697736"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">在Jetpack撰写中使用状态</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">介绍Jetpack编写和使用状态</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pl l"><div class="pr l pn po pp pl pq ma pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://proandroiddev.com/google-signin-compose-a9afa67b7519" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">Google登录撰写</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">Google登录撰写</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">谷歌登录Composeproandroiddev.com</p></div></div><div class="pl l"><div class="ps l pn po pp pl pq ma pc"/></div></div></a></div><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/3df7831fcb7c13e6d8dad61a5184fdc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/0*KIwPaqjcMxX3Igvy.gif"/></div></figure><pre class="kq kr ks kt gt nk nj nl nm aw nn bi"><span id="f8bb" class="no md it nj b gy np nq l nr ns"><a class="ae kp" href="https://github.com/AseemWangoo/hands_on_kotlin" rel="noopener ugc nofollow" target="_blank"><br/>Source code</a></span></pre></div></div>    
</body>
</html>