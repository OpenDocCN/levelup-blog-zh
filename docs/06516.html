<html>
<head>
<title>Validate Your PHP API Tests Against OpenAPI Definitions — A Laravel Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对照OpenAPI定义验证您的PHP API测试——一个Laravel示例</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/validate-your-php-api-tests-against-openapi-definitions-a-laravel-example-24dca3419151?source=collection_archive---------9-----------------------#2020-12-02">https://levelup.gitconnected.com/validate-your-php-api-tests-against-openapi-definitions-a-laravel-example-24dca3419151?source=collection_archive---------9-----------------------#2020-12-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="77d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">OpenAPI定义非常适合生成漂亮的文档，但是我们可以用它们做更多的事情</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/81a0454e760d3f766ea92f4b1f040117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qKgkt8oTm0sa2OkEzPjIrg.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">我为这个蒙太奇感到骄傲吗？你打赌我是(作者</figcaption></figure><p id="8ee1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae le" href="https://swagger.io/specification/" rel="noopener ugc nofollow" target="_blank"> OpenAPI </a>是一个旨在用JSON和YAML描述RESTful APIs的规范，目的是让人类和机器都能理解。</p><p id="c9e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">OpenAPI定义是与语言无关的，可以以多种不同的方式使用:</p><blockquote class="lf lg lh"><p id="57b6" class="jq jr li js b jt ju jv jw jx jy jz ka lj kc kd ke lk kg kh ki ll kk kl km kn im bi translated"><em class="it">open API定义可以被文档生成工具用来显示API，代码生成工具用来生成各种编程语言的服务器和客户端，测试工具，以及许多其他用例。</em></p></blockquote><p id="1bf5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">-<a class="ae le" href="https://swagger.io/specification/" rel="noopener ugc nofollow" target="_blank">open API规范</a></p><p id="8ee3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将看到如何使用<a class="ae le" href="https://github.com/osteel/openapi-httpfoundation-testing" rel="noopener ugc nofollow" target="_blank">open API http foundation Testing</a>包，将OpenAPI 3.0.x定义与集成测试结合起来，以验证API是否按照预期的方式运行。</p><p id="1903" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将在一个全新的<a class="ae le" href="https://laravel.com/" rel="noopener ugc nofollow" target="_blank"> Laravel </a>安装中这样做，为此我们还将使用<a class="ae le" href="https://github.com/DarkaOnLine/L5-Swagger" rel="noopener ugc nofollow" target="_blank"> L5 Swagger </a>包生成一个<a class="ae le" href="https://swagger.io/tools/swagger-ui/" rel="noopener ugc nofollow" target="_blank"> Swagger UI </a>文档。</p><p id="c6c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将首先进一步阐述为什么这是有用的，但是如果你只是为了代码，欢迎你直接跳到<em class="li"> A Laravel示例</em>部分。</p><h1 id="4b6f" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">问题</h1><p id="279d" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">API现在相当普遍，如果我们幸运的话，它们会附带某种形式的文档，帮助我们找到绕过端点的方法。这些文档有多种形式和风格(有些比其他的更好吃)，但是它们有一个共同点，那就是每当它们描述的API发生变化时，它们都需要更新。</p><p id="fb91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于许多开发人员来说，维护一个API的文档感觉像是他们已经通过了考试的额外作业；这很无聊，有时很乏味，而且往往没有回报。一些策略会有所帮助，比如使用注释将代码和文档放在一个地方；但是写起来还是很烦人，即使是最有意愿的开发人员也不能避免不被同事发现的疏忽。</p><p id="a34d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常的结果是，无论如何，文档和API变得不同步，导致消费者困惑。</p><p id="5a47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">API维护的另一个方面是确保没有端点停止正常工作；回归最终会被引入，如果没有合适的测试策略，它们可能会暂时被忽视。</p><p id="ec1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">避免这种情况的一种方法是实现集成测试，该测试将自动检查API的行为是否正确，以及最近引入的更改是否有意想不到的后果。这很好，但是仍然不能保证集成测试中设置的期望与文档中推断的完全相同。</p><p id="c764" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果有一种方法可以确保它们完美地相互反映就好了…</p><h1 id="cee7" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">一个解决方案</h1><p id="3b22" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">我们现在假设我们已经得到了一个API文档和一些集成测试，我们希望以某种方式符合他们的期望。</p><p id="a855" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着时间的推移，OpenAPI规范已经成为描述API的流行选择，但我们是否使用它并不能改变相应定义需要维护的事实；换句话说，使用OpenAPI不会自动消除上述问题。</p><p id="b17a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，使OpenAPI与众不同的是，它被用作越来越多的工具<a class="ae le" href="https://openapi.tools" rel="noopener ugc nofollow" target="_blank">的基础层，这些工具</a>使该规范的用途远远超出了简单的文档方面。</p><p id="bf38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些为PHP生态系统构建并由PHP联盟<a class="ae le" href="https://thephpleague.com" rel="noopener ugc nofollow" target="_blank">维护的工具之一是</a><a class="ae le" href="https://github.com/thephpleague/openapi-psr7-validator" rel="noopener ugc nofollow" target="_blank"> OpenAPI PSR-7消息验证器</a>，这是一个用于验证HTTP请求和响应的包，实现了针对OpenAPI定义的<a class="ae le" href="https://www.php-fig.org/psr/psr-7" rel="noopener ugc nofollow" target="_blank"> PSR-7 </a>标准。</p><p id="1942" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个想法本质上是获取HTTP请求和响应，并确保它们与OpenAPI定义中描述的操作之一相匹配。</p><p id="8319" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你能看出这是怎么回事吗？</p><p id="3e5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们基本上可以使用这个包在我们的集成测试之上添加一个额外的层，它将获取测试中获得的API响应，并确保它们与描述我们的API的OpenAPI定义相匹配。如果他们不这样做，测试就会失败。</p><p id="01db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是它看起来像一个奇特的图表:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mp"><img src="../Images/0e7777af5a23cf2b592737a7cec035a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Cf_nwwvpnfKpydEf.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://github.com/osteel" rel="noopener ugc nofollow" target="_blank">作者</a></figcaption></figure><p id="0be4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">OpenAPI定义描述了API，测试使用OpenAPI定义来确保API实际上按照定义所说的方式运行。</p><p id="dccb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">突然间，我们的OpenAPI定义成为了我们代码和测试的参考，从而成为了API唯一的事实来源。</p><h1 id="b9d7" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">PSR七号</h1><p id="e0b8" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">您可能已经注意到上一节中的一个小细节:OpenAPI PSR-7消息验证器包只适用于——它的名字是— <a class="ae le" href="https://www.php-fig.org/psr/psr-7" rel="noopener ugc nofollow" target="_blank"> PSR-7 </a>消息。这里的问题是，并不是所有的框架都支持这个现成的标准；事实上，他们中的很多人在幕后使用<a class="ae le" href="https://symfony.com/components/HttpFoundation" rel="noopener ugc nofollow" target="_blank"> Symfony的HttpFoundation组件</a>，其请求和响应默认不实现该标准。</p><p id="c600" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Symfony的人已经把我们包括在内了，因为他们已经开发了<a class="ae le" href="https://symfony.com/doc/current/components/psr7.html" rel="noopener ugc nofollow" target="_blank">桥</a>把HttpFoundation对象转换成PSR-7对象，只要给PSR-7和<a class="ae le" href="https://www.php-fig.org/psr/psr-17" rel="noopener ugc nofollow" target="_blank"> PSR-17 </a>工厂这么做，他们建议使用<a class="ae le" href="https://github.com/Nyholm" rel="noopener ugc nofollow" target="_blank">托拜厄斯·尼霍姆</a>的<a class="ae le" href="https://github.com/Nyholm/psr7" rel="noopener ugc nofollow" target="_blank"> PSR-7实现</a>。</p><p id="7117" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有这些组成了一个拼图游戏，OpenAPI HttpFoundation测试包为我们提供了这个拼图游戏，允许开发人员在利用HttpFoundation组件的项目中使用OpenAPI定义来支持他们的集成测试。</p><p id="a5d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看如何在Laravel项目中使用它，它属于这一类。</p><h1 id="4eb6" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">一个典型的例子</h1><p id="c085" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">本节包含的代码也可以作为<a class="ae le" href="https://github.com/osteel/openapi-httpfoundation-testing-laravel-example/" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>获得。</p><p id="bfcc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，让我们使用Composer创建一个新的Laravel 8项目:</p><pre class="kp kq kr ks gt mq mr ms mt aw mu bi"><span id="b310" class="mv ln it mr b gy mw mx l my mz">$ composer create-project --prefer-dist laravel/laravel openapi-example "8.*"</span></pre><p id="8c17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">进入项目的根文件夹并安装几个依赖项:</p><pre class="kp kq kr ks gt mq mr ms mt aw mu bi"><span id="bb2e" class="mv ln it mr b gy mw mx l my mz">$ cd openapi-example<br/>$ composer require --dev osteel/openapi-httpfoundation-testing<br/>$ composer require darkaonline/l5-swagger</span></pre><p id="5b82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个是前面提到的<a class="ae le" href="https://github.com/osteel/openapi-httpfoundation-testing" rel="noopener ugc nofollow" target="_blank">open API http foundation Testing</a>包，我们将其作为开发依赖项安装，因为它旨在用作我们测试套件的一部分。</p><p id="c898" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二个是<a class="ae le" href="https://github.com/DarkaOnLine/L5-Swagger" rel="noopener ugc nofollow" target="_blank"> L5 Swagger </a>，一个将<a class="ae le" href="https://github.com/zircote/swagger-php" rel="noopener ugc nofollow" target="_blank"> Swagger PHP </a>和<a class="ae le" href="https://swagger.io/tools/swagger-ui/" rel="noopener ugc nofollow" target="_blank"> Swagger UI </a>带到Laravel的热门包。这里我们实际上不需要Swagger PHP，因为它使用教条注释来生成OpenAPI定义，我们将手动编写自己的定义。然而，我们确实需要Swagger UI，并且软件包方便地对它进行了修改，以便与Laravel一起工作。</p><p id="ab8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了确保Swagger PHP不会覆盖OpenAPI定义，让我们在项目根目录下的<code class="fe na nb nc mr b">.env</code>文件中设置以下环境变量:</p><pre class="kp kq kr ks gt mq mr ms mt aw mu bi"><span id="6abf" class="mv ln it mr b gy mw mx l my mz">L5_SWAGGER_GENERATE_ALWAYS=false</span></pre><p id="cdf4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe na nb nc mr b">storage/api-docs</code>文件夹(您需要创建的文件夹)中创建一个名为<code class="fe na nb nc mr b">api-docs.yaml</code>的文件，并在其中添加以下内容:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="84ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个简单的OpenAPI定义，描述了一个操作——一个对<code class="fe na nb nc mr b">/api/test</code>端点的<code class="fe na nb nc mr b">GET</code>请求，它应该返回一个包含所需的<code class="fe na nb nc mr b">foo</code>键的JSON对象。</p><p id="337d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们检查Swagger UI是否正确显示了我们的OpenAPI定义。用这个<code class="fe na nb nc mr b">artisan</code>命令启动PHP的开发服务器，从项目的根目录运行:</p><pre class="kp kq kr ks gt mq mr ms mt aw mu bi"><span id="8f2b" class="mv ln it mr b gy mw mx l my mz">$ php artisan serve</span></pre><p id="465e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在浏览器中打开<a class="ae le" href="http://localhost:8000/api/documentation" rel="noopener ugc nofollow" target="_blank">localhost:8000/API/documentation</a>，将顶部导航栏中的<code class="fe na nb nc mr b">api-docs.json</code>替换为<code class="fe na nb nc mr b">api-docs.yaml</code>(这是因为Swagger UI加载的是YAML定义，而不是JSON定义，因为我们没有提供后者)。</p><p id="5039" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">点击<em class="li"> enter </em>键或点击<em class="li">Explore</em>——我们的OpenAPI定义现在应该呈现为一个Swagger UI文档:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nf"><img src="../Images/d918d8ba6db7b3a04aebd02e74bbf681.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0a4fRn8C0pLQBimN.png"/></div></div></figure><p id="49c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">扩展<code class="fe na nb nc mr b">/test</code>端点并进行试验——它应该会失败，并出现<code class="fe na nb nc mr b">404 Not Found</code>错误，因为我们还没有实现它。</p><p id="9cd9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们现在就解决这个问题。打开<code class="fe na nb nc mr b">routes/api.php</code>文件，用以下路径替换示例路径:</p><pre class="kp kq kr ks gt mq mr ms mt aw mu bi"><span id="cd10" class="mv ln it mr b gy mw mx l my mz">Route::get('/test', function (Request $request) {<br/>    return response()-&gt;json(['foo' =&gt; 'bar']);<br/>});</span></pre><p id="ce59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到Swagger UI选项卡，再次尝试端点——它现在应该返回一个成功的响应。</p><p id="b48a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该写测试了！打开<code class="fe na nb nc mr b">tests/Feature/ExampleTest.php</code>并用这个替换它的内容:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="cc3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们打开包装。对于那些不熟悉Laravel的人来说，<code class="fe na nb nc mr b">$this-&gt;get()</code>是由<code class="fe na nb nc mr b"><a class="ae le" href="https://github.com/laravel/framework/blob/8.x/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php" rel="noopener ugc nofollow" target="_blank">MakesHttpRequests</a></code>特征提供的一个测试方法，本质上是在提供的端点上执行一个<code class="fe na nb nc mr b">GET</code>请求，在不离开应用程序的情况下执行请求的生命周期。它返回的响应与我们从外部执行相同请求时获得的响应相同。</p><p id="53b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们使用<code class="fe na nb nc mr b">Osteel\OpenApi\Testing\ValidatorBuilder</code>类创建一个验证器，通过<code class="fe na nb nc mr b">fromYaml</code>静态方法将我们之前编写的YAML定义提供给这个验证器(<code class="fe na nb nc mr b">storage_path</code>函数是一个助手，它返回到<code class="fe na nb nc mr b">storage</code>文件夹的路径，我们在那里存储定义)。</p><p id="b42c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们有一个JSON定义，我们可以使用<code class="fe na nb nc mr b">fromJson</code>方法；此外，这两种方法分别接受YAML和JSON字符串，以及文件。</p><p id="1149" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">构建器返回一个<code class="fe na nb nc mr b">Osteel\OpenApi\Testing\Validator</code>的实例，我们对其调用<code class="fe na nb nc mr b">get</code>方法，将路径和响应作为参数传递(<code class="fe na nb nc mr b">$response</code>在这里是一个<code class="fe na nb nc mr b">Illuminate\Testing\TestResponse</code>对象，它是底层HttpFoundation对象的包装器，可以通过<code class="fe na nb nc mr b">baseResponse</code>公共属性检索)。</p><p id="11a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以上基本上相当于说:</p><blockquote class="lf lg lh"><p id="6d22" class="jq jr li js b jt ju jv jw jx jy jz ka lj kc kd ke lk kg kh ki ll kk kl km kn im bi translated"><em class="it">我想验证这个响应符合OpenAPI对</em> <code class="fe na nb nc mr b"><em class="it">/test</em></code> <em class="it">路径上的</em> <code class="fe na nb nc mr b"><em class="it">GET</em></code> <em class="it">请求的定义。</em></p></blockquote><p id="994d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也可以这样写:</p><pre class="kp kq kr ks gt mq mr ms mt aw mu bi"><span id="d1a8" class="mv ln it mr b gy mw mx l my mz">$result = $validator-&gt;get($response-&gt;baseResponse, '/test');</span></pre><p id="ca83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为validator对OpenAPI支持的每个HTTP方法都有一个快捷方法(<code class="fe na nb nc mr b">GET</code>、<code class="fe na nb nc mr b">POST</code>、<code class="fe na nb nc mr b">PUT</code>、<code class="fe na nb nc mr b">PATCH</code>、<code class="fe na nb nc mr b">DELETE</code>、<code class="fe na nb nc mr b">HEAD</code>、<code class="fe na nb nc mr b">OPTIONS</code>和<code class="fe na nb nc mr b">TRACE</code>)，这样可以更简单地测试相应操作的响应。</p><p id="98fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，指定的路径必须与OpenAPI定义的路径<a class="ae le" href="https://swagger.io/specification/#paths-object" rel="noopener ugc nofollow" target="_blank">之一</a>完全匹配。</p><p id="16a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您现在可以运行测试了，应该会成功:</p><pre class="kp kq kr ks gt mq mr ms mt aw mu bi"><span id="08f4" class="mv ln it mr b gy mw mx l my mz">$ ./vendor/bin/phpunit tests/Feature</span></pre><p id="bca4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">再次打开<code class="fe na nb nc mr b">routes/api.php</code>,改变这条的路线:</p><pre class="kp kq kr ks gt mq mr ms mt aw mu bi"><span id="40ad" class="mv ln it mr b gy mw mx l my mz">Route::get('/test', function (Request $request) {<br/>    return response()-&gt;json(['baz' =&gt; 'bar']);<br/>});</span></pre><p id="89d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">再次运行测试；它现在应该失败了，因为响应包含了<code class="fe na nb nc mr b">baz</code>而不是<code class="fe na nb nc mr b">foo</code>，而OpenAPI定义说应该是后者。</p><p id="4cc2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的测试是由OpenAPI支持的！</p><p id="e525" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了便于演示，上面的例子显然过于简单，但在实际情况中，一个好的做法是覆盖<code class="fe na nb nc mr b">MakesHttpRequests</code> trait的<code class="fe na nb nc mr b"><a class="ae le" href="https://github.com/laravel/framework/blob/8.x/src/Illuminate/Foundation/Testing/Concerns/MakesHttpRequests.php#L496" rel="noopener ugc nofollow" target="_blank">call</a></code>方法，这样它既执行测试请求又执行OpenAPI验证。</p><p id="2359" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们的测试现在只有一行:</p><pre class="kp kq kr ks gt mq mr ms mt aw mu bi"><span id="d01b" class="mv ln it mr b gy mw mx l my mz">$this-&gt;get('/api/test');</span></pre><p id="8725" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可以作为一个新的<code class="fe na nb nc mr b">MakesOpenApiRequests</code>特征来实现，它将“扩展”那个<code class="fe na nb nc mr b">MakesHttpRequests</code>特征，并且将首先调用父<code class="fe na nb nc mr b">call</code>方法来获得响应。然后，它将计算出来自URI的路径，并在返回响应之前根据OpenAPI定义验证响应，以便调用测试根据需要执行任何进一步的断言。</p><h1 id="d0c6" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="6ba1" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">虽然上述设置在提高API的健壮性方面迈出了一大步，但它并不是灵丹妙药；它需要用集成测试覆盖每一个端点，这不容易以自动化的方式执行，并且最终仍然需要开发人员的一些纪律和警惕。起初，对一些人来说，这甚至有点强制的感觉，因为结果是他们基本上被迫维护文档，以便编写成功的测试。</p><p id="25d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，附加的价值是，所述文档现在保证更加准确，从而使消费者高兴，他们将喜欢不太可能不稳定的API这反过来会让开发人员不那么沮丧，他们会花更少的时间去寻找讨厌的差异。</p><p id="1b64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总而言之，使OpenAPI定义成为API文档和集成测试的唯一真实来源，这本身就是一个保持更新的强大动力；它们自然成为优先事项，而以前它们只是事后才想到的。</p><p id="4b0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">至于维护这些定义，手动维护确实有点令人生畏。注释是一种解决方案，但我个人不喜欢注释，更喜欢直接维护YAML文件。像VSCode one这样的IDE扩展使它变得更容易，但是如果你不能忍受YAML或JSON文件，你也可以使用像T4 stop light Studio这样的T2工具来通过一个更友好的用户界面做到这一点。</p><p id="c30a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">既然我们在讨论Stoplight*，<a class="ae le" href="https://stoplight.io/blog/api-design-first-vs-code-first/" rel="noopener ugc nofollow" target="_blank">Phil Sturgeon</a><a class="ae le" href="https://twitter.com/philsturgeon" rel="noopener ugc nofollow" target="_blank">撰写的这篇关于API设计优先与代码优先的文章</a>是API文档的一个很好的起点，可能会帮助你选择一种适合你的文档方法。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="4c10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="li"> *我与交通信号灯没有任何关系</em></p><h1 id="d402" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">资源</h1><ul class=""><li id="0d7d" class="nn no it js b jt mk jx ml kb np kf nq kj nr kn ns nt nu nv bi translated"><a class="ae le" href="https://swagger.io/specification/" rel="noopener ugc nofollow" target="_blank">open API规范</a></li><li id="9dea" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated"><a class="ae le" href="https://github.com/osteel/openapi-httpfoundation-testing" rel="noopener ugc nofollow" target="_blank">open API http foundation测试包</a></li><li id="ec69" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated"><a class="ae le" href="https://github.com/osteel/openapi-httpfoundation-testing-laravel-example" rel="noopener ugc nofollow" target="_blank"> Laravel范例库</a></li><li id="bf3e" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated"><a class="ae le" href="https://swagger.io/tools/swagger-ui" rel="noopener ugc nofollow" target="_blank"> Swagger UI </a></li><li id="301b" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated"><a class="ae le" href="https://github.com/DarkaOnLine/L5-Swagger" rel="noopener ugc nofollow" target="_blank">L5 Swagger Laravel包</a></li><li id="4f8b" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated"><a class="ae le" href="https://openapi.tools" rel="noopener ugc nofollow" target="_blank"> OpenAPI。工具</a></li><li id="8469" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated"><a class="ae le" href="https://github.com/thephpleague/openapi-psr7-validator" rel="noopener ugc nofollow" target="_blank">open API PSR-7消息验证器包</a></li><li id="df61" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated"><a class="ae le" href="https://symfony.com/components/HttpFoundation" rel="noopener ugc nofollow" target="_blank">http foundation组件</a></li><li id="657a" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated"><a class="ae le" href="https://www.php-fig.org/psr/psr-7/" rel="noopener ugc nofollow" target="_blank"> PSR-7: HTTP消息接口</a></li><li id="10cc" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated"><a class="ae le" href="https://symfony.com/doc/current/components/psr7.html" rel="noopener ugc nofollow" target="_blank">PSR 7号大桥</a></li><li id="1253" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated"><a class="ae le" href="https://github.com/Nyholm/psr7" rel="noopener ugc nofollow" target="_blank"> PSR-7实施</a></li><li id="fcc5" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated"><a class="ae le" href="https://stoplight.io/blog/api-design-first-vs-code-first" rel="noopener ugc nofollow" target="_blank"> API设计优先vs代码优先</a></li></ul></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="e1f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="li">这个故事最初发表于</em><a class="ae le" href="https://tech.osteel.me/posts/openapi-backed-api-testing-in-php-projects-a-laravel-example" rel="noopener ugc nofollow" target="_blank"><em class="li">tech . osteel . me</em></a><em class="li">。</em></p></div></div>    
</body>
</html>