<html>
<head>
<title>Train/Test Complexity and Space Complexity of Linear Regression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">线性回归的训练/测试复杂度和空间复杂度</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/train-test-complexity-and-space-complexity-of-linear-regression-26b604dcdfa3?source=collection_archive---------0-----------------------#2020-08-18">https://levelup.gitconnected.com/train-test-complexity-and-space-complexity-of-linear-regression-26b604dcdfa3?source=collection_archive---------0-----------------------#2020-08-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/f60823bddb338bbdd71c6f79b786152a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*vQgBB3dsG1tZBPCu.jpeg"/></div></figure><p id="c1ca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你曾经面临过这样的情况吗？如果是，那么恭喜您，这意味着您拥有大数据！😎</p><p id="9e38" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">大数据的挑战体现在推理和计算两个方面。随着我们向更精细的推理迈进，我们面临着做出及时、准确和精确的分析和决策的普遍挑战。</p><p id="0d72" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在分析中，<strong class="jw ir">永远没有“充分”的数据</strong>。当你获得越来越多的数据时，你可以开始细分数据以获得更好的洞察力。</p><blockquote class="kt ku kv"><p id="76f6" class="ju jv ks jw b jx jy jz ka kb kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kr ij bi translated"><em class="iq"> N永远不够，因为如果它“足够”的话，你就已经开始下一个需要更多数据的问题了。—安德鲁·盖尔曼</em></p></blockquote><p id="600e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这种对数据的贪得无厌的需求导致了计算的复杂性。了解这些计算复杂性在机器学习中非常重要。那么，ML模型的计算复杂度是多少？</p><p id="d626" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">计算的复杂性是:</p><h1 id="9b67" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">1.时间复杂度</h1><p id="3900" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">在RAM中，算法所花费的“时间”是通过算法的基本运算来衡量的。虽然用户和开发人员可能更关心算法训练模型所需的挂钟时间，但使用标准最坏情况计算时间复杂性来比较模型训练所需的时间会更公平。使用计算复杂性的好处是忽略运行时使用的计算机能力和架构以及底层编程语言等差异，允许用户专注于算法基本操作的基本差异。</p><p id="8a3a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请注意，在训练和测试期间，时间复杂度可能会有很大的不同。例如，像线性回归这样的参数模型可能需要很长的训练时间，但它们在测试期间是有效的。</p><h1 id="85db" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">2.空间复杂性</h1><p id="da1d" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">空间复杂度根据输入大小来衡量算法需要运行多少内存。如果ML算法将过多的数据加载到机器的工作存储器中，那么ML程序就不能成功运行。</p><p id="e92f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">与时间复杂度类似，空间复杂度在决定算法/程序的效率方面也起着至关重要的作用。如果一个算法占用了很多时间，你仍然可以等待，运行/执行它来得到想要的输出。但是，<strong class="jw ir">如果一个程序占用了大量的内存空间，编译器就不会让你运行它</strong>。</p><p id="8ce9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在本文中，我将讨论<strong class="jw ir">线性回归</strong>的训练/测试复杂度和空间复杂度。但在此之前，让我们用一些简单的例子来理解时间和空间的复杂性。</p><h1 id="d2e3" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">时间复杂性入门</h1><p id="a4e8" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">某公司开始了一项业务，并希望通过将当月的客户列表与上月的列表相比较来跟踪其共同客户。这个任务可以使用两个python列表自动完成:<em class="ks"> curr_month </em>和<em class="ks"> prev_month。</em></p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/159c90157f09414a8ae01c5944b50883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*iV3NFe3l1WRfCRTFJ8jfNg.png"/></div></figure><p id="378d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于每月大约2000名客户的列表，这段代码片段运行了大约30秒。当这与大约2个lac客户的完整列表一起使用时，这几行代码似乎永远运行不完！</p><p id="6f1b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">是因为Python就是慢吗？该不该转Java/Go优化？答案是否定的。这是一个非常简单的问题，解决方法甚至更简单，只需大约1秒钟。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/af04e83ef4ba6758469b1145019f3808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*e1ui5BkVpadG5mwW-gUPHQ.png"/></div></figure><p id="c783" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">仔细注意不同之处。区别在于python <em class="ks"> list </em>和<em class="ks"> set </em>。一个<code class="fe mi mj mk ml b">set</code>被设计用来快速完成这些<code class="fe mi mj mk ml b">"is this element in" </code>操作。即使您将<code class="fe mi mj mk ml b">prev_month_set</code>中的元素数量增加一倍，操作<code class="fe mi mj mk ml b">cust in prev_month_set</code>运行的时间也差不多。</p><p id="c432" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">另一方面，如果您将<code class="fe mi mj mk ml b">prev_cust</code>的大小增加一倍，操作<code class="fe mi mj mk ml b">cust in prev_cust</code>将需要两倍的时间来运行。</p><h1 id="7aba" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">时间复杂性和大O</h1><p id="6d3e" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">我们知道代码片段之间存在差异，但是我们如何表达这种差异呢？这就是大O符号的由来。</p><p id="7c81" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">虽然大O有正式的定义，但你主要可以把它看作是一台机器完成算法所做的“运算”次数的估计。操作的数量与“运行时间”密切相关，它通常与数据的大小有关。</p><p id="931d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">通常，有三个层次需要求解(最佳情况、一般情况和最差情况)，它们被称为渐近符号。这些符号允许我们回答这样的问题:当输入大小增加时，算法是否突然变得非常慢？随着输入大小的增加，它是否主要保持快速运行时间？</p><p id="e96c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们快速看一下这三层:</p><p id="8cbe" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">最佳情况——表示为大ω或ω(n)</strong></p><ul class=""><li id="ce0e" class="mm mn iq jw b jx jy kb kc kf mo kj mp kn mq kr mr ms mt mu bi translated">Big-Omega通常写为ω，是给定函数最佳情况的渐近符号。它为我们提供了一个算法运行时增长率的渐近下界。</li></ul><p id="4437" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">平均情况——表示为大θ或θ(n)</strong></p><ul class=""><li id="c404" class="mm mn iq jw b jx jy kb kc kf mo kj mp kn mq kr mr ms mt mu bi translated">θ，通常写为θ，是一种渐近符号，用来表示算法运行时增长率的渐近紧界。</li></ul><p id="6e98" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">最坏情况——用大O符号或O(n)表示</strong></p><ul class=""><li id="f9c7" class="mm mn iq jw b jx jy kb kc kf mo kj mp kn mq kr mr ms mt mu bi translated">Big-O通常写为O，是给定函数最坏情况的渐近符号。它为我们提供了一个算法运行时增长率的渐近上界。</li></ul><p id="e934" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">开发人员通常会解决最糟糕的情况，因为你并不期望你的算法在最好甚至是一般的情况下运行。它允许你作出分析性的陈述，比如，“即使在最坏的情况下，我的算法也能很快扩展”。</strong></p><p id="fb25" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，让我们再次回到我们之前讨论的例子，找出代码片段的时间复杂度。如果我们查看<a class="ae mv" href="https://wiki.python.org/moin/TimeComplexity" rel="noopener ugc nofollow" target="_blank"> python关于时间复杂度</a>的文档，我们可以看到在<strong class="jw ir">的平均情况下，在s 中具有形式<em class="ks"> x的</em></strong>操作采取的步骤等于:</p><ul class=""><li id="9ae1" class="mm mn iq jw b jx jy kb kc kf mo kj mp kn mq kr mr ms mt mu bi translated">如果<code class="fe mi mj mk ml b">s</code>是一个<code class="fe mi mj mk ml b">list</code></li><li id="dcba" class="mm mn iq jw b jx mw kb mx kf my kj mz kn na kr mr ms mt mu bi translated">O(1)如果<code class="fe mi mj mk ml b">s</code>是一个<code class="fe mi mj mk ml b">set</code></li></ul><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/9f98767a4e599b41cb6743485b055998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MyvgdjEgpiuOxCKdPRUpPg.png"/></div></div></figure><p id="ec04" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，让我们再次以list为例，找出其案例中的大O:</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/7dc8ec3b8711b9a7e66247842e2e8d1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*4Jzn-r6HGMcv0_XQu_vyRg.png"/></div></figure><p id="0852" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">仔细看:</p><ol class=""><li id="e6d6" class="mm mn iq jw b jx jy kb kc kf mo kj mp kn mq kr nh ms mt mu bi translated">我们遍历curr_month列表中的n个客户。</li><li id="4514" class="mm mn iq jw b jx mw kb mx kf my kj mz kn na kr nh ms mt mu bi translated">对于每个客户，我们检查它是否在prev_month列表中。根据python关于s 中形式为<em class="ks"> x的操作的复杂性的文档:如果列表中有n个元素，则需要O(n)个步骤。因为我们遍历n个客户，所以需要n次操作。</em></li><li id="f962" class="mm mn iq jw b jx mw kb mx kf my kj mz kn na kr nh ms mt mu bi translated">添加号码只需一步。</li></ol><p id="8d22" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，循环的每次迭代大约需要O(n) + O(1)步，并且循环中有n次迭代，所以将所有n(O(n) + O(1)) = O(n)。你可以把0相加相乘，当你有几项时，你只需要去掉低阶项和系数。O(n +n) = O(n)。</p><p id="26be" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以用set做同样的事情，找到大o。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/86e02ca6c78d5ee72492bfcbda0c7bce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*bJUrh-Ge_maFJTKYfRJdDQ.png"/></div></figure><ol class=""><li id="0ec1" class="mm mn iq jw b jx jy kb kc kf mo kj mp kn mq kr nh ms mt mu bi translated">根据python文档中关于s 中形式为<em class="ks"> x的操作的复杂性:如果一个集合中有n个元素，则需要O(1)个步骤。</em></li></ol><p id="f477" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">综合起来:O(n) + n(O(1) + O(1)) = O(3n) = O(n)。与list实现相比，set非常快。</p><h1 id="85ed" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">解读大O</h1><p id="9fed" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">所以我们有一个O(n)的算法和另一个O(n)的算法。你对此如何解读？</p><p id="c05d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">看待这个问题的一种方式是通过分析数据集的估计值n来估计问题的严重程度。如果我们的数据大小为2 lac，那么O(n)算法将需要大约200000⁰运算，大约为40000000000，这是一个很大的数目。</p><p id="a547" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">相同的数据集，但是使用O(n)算法，将有大约200000次操作，这是更容易管理的。</p><p id="44e3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">希望你记得，当我们计算大o时，我们去掉了低阶项和系数，所以精确的值在这里并不重要。我们只看问题的严重性。看待这个问题的另一种方式是获得两个数据集大小之间的相对比率。</p><p id="c4a5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">假设有2000个客户，列表算法需要30秒。如果我们将数据量增加一倍，需要多长时间？所以我们现在有一个大小为2n的数据集。那么运行时间将是大约</p><p id="5910" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">O((2n) ) = O(4n)</p><p id="461d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这意味着将O(n)的数据集大小加倍会使运行时间增加4倍。我们预计它将运行120秒左右。</p><p id="5c00" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">另一方面，对于set算法，在数据大小加倍时，复杂度变为等于O(2n ),这意味着数据集加倍仅使运行时间加倍。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nj"><img src="../Images/dfb26bedbf3b924cf8d7cf0df5dfc569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*chgh7xziIBqqoKv6.jpeg"/></div></div></figure><p id="5dd3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">性能上的大差异来自于<code class="fe mi mj mk ml b">cust in prev_cust</code>和<code class="fe mi mj mk ml b">cust in prev_cust_set</code>的细微差别。这些差异有点难以察觉。</p><p id="929a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">大O符号为我们提供了一种方式来总结我们对上述两种算法如何扩展的见解。我们可以比较O(n)和O(n ),而不知道每个算法是如何实现的。这正是我们在使用<code class="fe mi mj mk ml b">x in prev_cust_set</code>是O(1)这一事实时所做的，而没有描述<code class="fe mi mj mk ml b">set</code>是如何实现这一点的。大O给我们的是一种通过描述运行时间相对于输入大小的一般形状来抽象算法的方法。</p><p id="1649" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果您知道数据集不是海量的，那么您可以选择使用较慢的算法和模型，这些算法和模型要么给出更好的结果，要么实现和维护更简单。</p><p id="51b6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在你已经理解了时间复杂性的基础，让我们深入研究线性回归的训练/测试复杂性。</p><h1 id="d052" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">线性回归的训练/测试复杂性入门</h1><p id="5ea3" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated"><strong class="jw ir">线性回归</strong>是寻找给定数据的最佳直线拟合的方法，即寻找自变量和因变量之间的最佳线性关系。<br/>用专业术语来说，线性回归是一种机器学习算法，可以在自变量和因变量之间找到任何给定数据的最佳线性拟合关系。这主要是通过残差平方和的方法来完成的。</p><p id="b032" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="ks">想了解更多关于线性回归的知识，可以登陆我的博客</em> <a class="ae mv" href="https://medium.com/analytics-vidhya/preparing-for-interview-on-machine-learning-3145caeea06b" rel="noopener"> <em class="ks">关于线性回归的面试问题</em> </a> <em class="ks">。</em></p><p id="9398" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">最小二乘法&amp;矩阵乘法</strong></p><p id="6734" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一种接近线性分析的方法是最小二乘法，它使残差平方和最小化。残差是模型拟合值和观测值之间的差异，或者是预测值和实际值之间的差异。最小化这些残差的练习将是“通过”表示这些值的笛卡尔坐标的线的试错拟合。</p><p id="1325" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">进行最小二乘法的一种方法是通过矩阵乘法求解。怎么做呢？</p><p id="ebe4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于点(x1，y1)，(x2，y2)，…，(xn，yn)，最小二乘回归线可以由下式给出:</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/e1c82b4667bb2f64830a4ef577d7c167.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*6voxNVghxlW7SbRnvM8Gyg.png"/></div></figure><p id="6207" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这将最小化平方误差的总和，平方误差是使用回归函数f(x)来估计真实y值时的误差。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/1c4a6e1f9c1070255d1e125112db1c74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*cFb_sYULByyqzpEsRFcALw.png"/></div></figure><p id="75fd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在哪里，</p><p id="f697" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">y=真y值</p><p id="93f1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">f(x)=预测的y值</p><p id="12ec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们看看能否把它建立成一个方程组，然后用矩阵求解。</p><p id="b5dc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用我们的点(x1，y1)，(x2，y2)，…，(xn，yn)，我们将得到下面的方程组。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/c5c17779420f85fcc47b65a9f1177fa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*HvqznL5wAZ-BRq5WVQixqA.png"/></div></figure><p id="0467" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，让我们建立一个矩阵:</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/ebc9b5450d38d5ef3b073420484d4eb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/0*-abcaqSs5MccID4t.jpg"/></div></figure><p id="9859" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这建立了矩阵方程:</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/e4810a1a65fa35a6511021543c962ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:226/0*3eBHj5IVAQd2P5gB"/></div></figure><p id="6c5b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">其中矩阵<em class="ks"> Y </em>包含Y值，矩阵<em class="ks"> X </em>包含一行1以及X值，矩阵<em class="ks"> A </em>由Y截距和斜率组成，矩阵<em class="ks"> E </em>是误差。请注意，矩阵<em class="ks"> X </em>中的1行需要与矩阵<em class="ks"> A </em>相乘(分别为2行和2列)。</p><p id="4889" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，我们求解A，它由下式给出:</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/fb73e91daf009181781fb34ddeeb4ebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:328/0*QAzwxLzTzdu4Cdg0"/></div></figure><p id="fa4a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">E为误差平方和，由下式给出:</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/1eecaf8b26282a669dc8dd535c511b3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*erFB7yLJLySby8sV3EKqNw.png"/></div></figure><p id="539b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是最终用于求解线性系统的最小二乘法的矩阵方程。</p><h1 id="c94d" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak">线性回归的训练复杂度</strong></h1><p id="2cb8" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">线性回归计算如下</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/fb73e91daf009181781fb34ddeeb4ebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:328/0*QAzwxLzTzdu4Cdg0"/></div></figure><p id="db6d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果X是一个(n×k)矩阵:</p><p id="47d9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">I. (X' X)花费O(n*k)时间，并产生一个(k×k)矩阵。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/066ba0ec5e2907b7086c2df17e6aa722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IxnHi1hlcSWsoIOW6QYfwQ.png"/></div></div></figure><p id="3e49" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">二。(k×k)矩阵的矩阵求逆需要O(k)时间。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nr"><img src="../Images/463aec57c8e8fe5b40a10a2f154edbbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pF0evysJ2ZtElmJKu8bR7Q.png"/></div></div></figure><p id="a406" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">三。(X' Y)花费O(n*k)时间并产生一个(k×1)矩阵</p><p id="9a43" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">四。(k×k)和(k×1)矩阵的最终矩阵乘法需要O(k <em class="ks"> </em>)时间</p><p id="5c61" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以Big-O训练时间为O(k *n + k + k*n +k <em class="ks"> </em>)。</p><p id="cd96" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，我们知道:</p><ul class=""><li id="65f2" class="mm mn iq jw b jx jy kb kc kf mo kj mp kn mq kr mr ms mt mu bi translated">k&lt; k³</li><li id="6eb3" class="mm mn iq jw b jx mw kb mx kf my kj mz kn na kr mr ms mt mu bi translated">k*n &lt; k²*n</li></ul><p id="e31a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">So, asymptotically, the actual Big-O running time is :</p><p id="beb9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"><em class="ks">O(k * n+k)</em>=<em class="ks">O(k(n+k))</em></strong></p><p id="b84b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="ks">(进一步参考</em> <a class="ae mv" href="http://en.wikipedia.org/wiki/Computational_complexity_of_mathematical_operations#Matrix_algebra" rel="noopener ugc nofollow" target="_blank"> <em class="ks">点击此处</em> </a> <em class="ks">)。)</em></p><p id="418c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，训练线性回归模型在计算上过于昂贵。这种解决方案在大多数情况下都能很好地工作，除了在下列情况下，</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/ceee84d1cca25c66f3bb740660c9e23a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/0*wpZicO4emz1l5RlB.png"/></div></figure><p id="d866" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如上所述，在封闭形式的解决方案失败的情况下，迭代解决方案可以拯救我们。梯度下降等迭代解决方案背后的思想是:</p><ul class=""><li id="363e" class="mm mn iq jw b jx jy kb kc kf mo kj mp kn mq kr mr ms mt mu bi translated">从参数的一些初始值开始，慢慢地向局部最小值移动。</li><li id="643f" class="mm mn iq jw b jx mw kb mx kf my kj mz kn na kr mr ms mt mu bi translated">以某种方式确保每次迭代中的移动都朝着它应该达到的局部最小值。</li><li id="2e41" class="mm mn iq jw b jx mw kb mx kf my kj mz kn na kr mr ms mt mu bi translated">最终确定何时停止进一步迭代并返回解。</li></ul><p id="4b29" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">梯度下降可以让计算从任意点开始，并且迭代地应用下面的计算，</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/bc60fc1dafae34ce970013f64b02f69f.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/0*_6uEAriOAn1Zsa14.png"/></div></figure><p id="622a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">用于任何维度的梯度下降的通用算法如下，</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/9d08feec0ff17067126c13a2ec92dbff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/0*oOFaoKFr4c-Bjty1.png"/></div></figure><p id="a495" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们之前讨论的线性回归的平方误差成本函数由下式给出:</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/00e72a3d2d9b27dc81e461b87f50e3ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/0*SlcCEaaEGqmrq2Ij.png"/></div></figure><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/3275c22901080163a75c02204238dec3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/0*JcUGOg8OL_s0Cfvo.png"/></div></figure><p id="58ff" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，如果我们有一个包含n个点和k个特征的数据集，并且要求我们使用梯度下降来计算时间复杂度，那么，</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/d16a2b2c2763e735c13118605594885b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*Zwow9YSd91YbR_3FdE-LCg.png"/></div></figure><p id="6a92" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，我们可以看到，使用梯度下降的复杂性降低到O(kn)。</p><p id="9a29" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了更好地理解这个等式，需要注意以下几点:</p><ol class=""><li id="e5b8" class="mm mn iq jw b jx jy kb kc kf mo kj mp kn mq kr nh ms mt mu bi translated">在任一给定点的偏导数对应于在给定点接触曲线的直线的斜率。</li><li id="26ab" class="mm mn iq jw b jx mw kb mx kf my kj mz kn na kr nh ms mt mu bi translated">学习率α确保每次迭代的移动/变化是斜率的一小部分。</li><li id="34f4" class="mm mn iq jw b jx mw kb mx kf my kj mz kn na kr nh ms mt mu bi translated">不管起始点是什么，斜率的符号都确保了运动的方向朝向预期的解决方案。</li><li id="184f" class="mm mn iq jw b jx mw kb mx kf my kj mz kn na kr nh ms mt mu bi translated">斜率值随着我们向局部最优值移动而减小，并且一旦它触及局部最优值(或非常接近局部最优值)就不再进一步改变。因为斜率在曲线中值最小的点上变为零。</li><li id="6284" class="mm mn iq jw b jx mw kb mx kf my kj mz kn na kr nh ms mt mu bi translated">学习率决定了算法运行和收敛的速度。</li></ol><p id="0f9e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，当涉及大量高维数据(即大量特征)时，梯度下降法优于OLS法。</p><h1 id="72f3" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">线性回归的测试/运行时复杂性</h1><p id="4572" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">运行时复杂性非常重要，因为在训练结束时，我们在看不见的数据上测试我们的模型，并计算我们模型的准确性。在线性回归的情况下，训练模型后，我们得到w和b。w基本上是一个k维的向量。给定任何新点，我们只需执行W^T * Xi + b运算。如果我们的模型训练良好，那么预测值和实际值之间的误差平方和将最小。现在，w是一个大小为k的向量。执行W^T*Xi + b运算需要O(k)步，如前所述。加b只需1步，即O(1)。因此，线性回归的运行时间复杂度是O(k)。</p><p id="5e85" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，我们看到，虽然线性回归有很长的训练时间，但它们在测试期间是有效的。测试/预测时间是O(k ),其中k是数据的特征数/维数。</p><h1 id="832a" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">线性回归的空间复杂性</h1><p id="ad47" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">现在，让我们看看训练和测试线性回归的空间复杂度是多少。我们之前已经看到了用于训练线性回归模型的方程组的矩阵表示。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/ebc9b5450d38d5ef3b073420484d4eb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/0*-abcaqSs5MccID4t.jpg"/></div></figure><p id="bdaa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以，我们需要在内存中保存的是分别为(n x k)和(n x 1)阶的X和Y矩阵。然后，可以使用前面讨论的下面给出的等式来计算矩阵A:</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/fb73e91daf009181781fb34ddeeb4ebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:328/0*QAzwxLzTzdu4Cdg0"/></div></figure><p id="589f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，训练时的空间复杂度为O(nk + n)。</p><p id="ceb3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在训练模型后，我们只需要在内存中保存w和b，因为给定任何新的点x，我们必须执行W^T * X + b来预测新的y值，并检查模型的准确性。因为，b与输入大小无关，所以在O(1)中存储b所需的空间。现在，W是一个大小为k的向量，所以，W的空间复杂度是O(k)。因此，运行时线性回归的空间复杂度大约为k，即O(k)。</p><h1 id="9f25" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论:我们应该如何优化我们的代码？</h1><p id="f4a0" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">如果我们对一个问题有不同的解决方案，我们可以比较它们的运行时间来得到答案。然而，时间复杂性并不是你应该考虑的唯一因素。您还应该考虑您的代码是否足够易读，以及您的代码将消耗多少内存。</p><p id="f260" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">参考资料:</p><ol class=""><li id="15b7" class="mm mn iq jw b jx jy kb kc kf mo kj mp kn mq kr nh ms mt mu bi translated"><a class="ae mv" href="https://www.thekerneltrip.com/machine/learning/computational-complexity-learning-algorithms/" rel="noopener ugc nofollow" target="_blank">https://www . thekerneltrip . com/machine/learning/computational-complexity-learning-algorithms/</a></li><li id="58f3" class="mm mn iq jw b jx mw kb mx kf my kj mz kn na kr nh ms mt mu bi translated"><a class="ae mv" href="https://stackoverflow.com/questions/1955088/what-is-the-bigo-of-linear-regression" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/1955 088/what-the-bigo-of-linear-regression</a></li><li id="e447" class="mm mn iq jw b jx mw kb mx kf my kj mz kn na kr nh ms mt mu bi translated"><a class="ae mv" href="https://www.crayondata.com/blog/machine-learning-linear-regression-gradient-descent-part-1/" rel="noopener ugc nofollow" target="_blank">https://www . crayon data . com/blog/machine-learning-linear-regression-gradient-descent-part-1/</a></li></ol><p id="e095" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="ks">如果你觉得这很有帮助，别忘了点击</em>👏图标<em class="ks">。谢谢大家！</em>😊</p></div></div>    
</body>
</html>