<html>
<head>
<title>Understanding Design Patterns: Facade in JavaScript using Pokemon and Dragonball Examples!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解设计模式:使用Pokemon和Dragonball示例的JavaScript中的Facade！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-design-patterns-facade-using-pokemon-and-dragonball-examples-c94f11326dd1?source=collection_archive---------11-----------------------#2020-01-14">https://levelup.gitconnected.com/understanding-design-patterns-facade-using-pokemon-and-dragonball-examples-c94f11326dd1?source=collection_archive---------11-----------------------#2020-01-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="16fd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">逐步解释的设计模式</h2></div><p id="3132" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原著<code class="fe le lf lg lh b">Design Patterns: Elements of Reusable Object-Oriented Software</code>中描述了23种经典设计模式。这些模式为软件开发中经常出现的特定问题提供了解决方案。</p><p id="82f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我将描述<strong class="kk iu">门面模式</strong>是如何工作的，以及何时应该应用它。</p><h1 id="79c4" class="li lj it bd lk ll lm ln lo lp lq lr ls jz lt ka lu kc lv kd lw kf lx kg ly lz bi translated">门面模式:基本思想</h1><blockquote class="ma mb mc"><p id="0c97" class="ki kj md kk b kl km ju kn ko kp jx kq me ks kt ku mf kw kx ky mg la lb lc ld im bi translated"><em class="it"/><strong class="kk iu"><em class="it">facade模式</em> </strong> <em class="it">(也拼写为facade)是一种</em> <a class="ae mh" href="https://en.wikipedia.org/wiki/Software_design_pattern" rel="noopener ugc nofollow" target="_blank"> <em class="it">软件设计模式</em> </a> <em class="it">常用于</em><a class="ae mh" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank"><em class="it"/></a><em class="it">。类似于架构中的</em><a class="ae mh" href="https://en.wikipedia.org/wiki/Facade" rel="noopener ugc nofollow" target="_blank"><em class="it">facade</em></a><em class="it">，facade是一个对象，它作为一个面向前的接口来屏蔽更复杂的底层或结构代码。—维基百科</em></p><p id="50ec" class="ki kj md kk b kl km ju kn ko kp jx kq me ks kt ku mf kw kx ky mg la lb lc ld im bi translated"><em class="it">为子系统中的一组接口提供统一的接口。Facade定义了一个更高级的接口，使得子系统更容易使用。-设计模式:可重用面向对象软件的要素</em></p></blockquote><p id="e62e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种模式的主要特点是使用一个类来简化复杂系统的接口。因此，这是该模式解决的两个问题:</p><ol class=""><li id="6539" class="mi mj it kk b kl km ko kp kr mk kv ml kz mm ld mn mo mp mq bi translated">复杂子系统更容易使用。</li><li id="4978" class="mi mj it kk b kl mr ko ms kr mt kv mu kz mv ld mn mo mp mq bi translated">对子系统的依赖性被最小化。</li></ol><p id="b9e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总而言之，facade模式包含不同类的几个实例，这些实例必须对客户端隐藏。这是简化界面的方式。这个模式的UML图如下所示:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi mw"><img src="../Images/fb331a3d5cc46bd892cfcacb3ef9f346.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AcBakQSG8muHXNTD.png"/></div></div></figure><p id="382f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">Facade</code>类是模块和外部客户端之间的中间件。在UML中有一个单一的<code class="fe le lf lg lh b">Facade</code>类，但是当接口非常复杂时，该模式可以在不同的层之间使用。</p><h1 id="2bd3" class="li lj it bd lk ll lm ln lo lp lq lr ls jz lt ka lu kc lv kd lw kf lx kg ly lz bi translated">门面模式:何时使用</h1><ol class=""><li id="0577" class="mi mj it kk b kl ni ko nj kr nk kv nl kz nm ld mn mo mp mq bi translated">有一个复杂的系统，你需要一个简单的界面来与它交流。</li><li id="600f" class="mi mj it kk b kl mr ko ms kr mt kv mu kz mv ld mn mo mp mq bi translated">由于客户需要广泛的系统知识，所以代码是紧密耦合的。Facade模式允许我们减少组件之间的耦合。</li><li id="752e" class="mi mj it kk b kl mr ko ms kr mt kv mu kz mv ld mn mo mp mq bi translated">系统需要一个进入分层软件每一层的入口点。</li></ol><p id="1dc1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Facade模式有几个优点，概括起来有以下几点:</p><ul class=""><li id="2d80" class="mi mj it kk b kl km ko kp kr mk kv ml kz mm ld nn mo mp mq bi translated">代码更容易使用、理解和测试，因为外观简化了接口。</li><li id="925f" class="mi mj it kk b kl mr ko ms kr mt kv mu kz mv ld nn mo mp mq bi translated"><strong class="kk iu">干净的代码</strong>因为客户端/上下文不使用复杂的接口，系统更加<strong class="kk iu">灵活和可重用</strong>。</li></ul><h1 id="5a2b" class="li lj it bd lk ll lm ln lo lp lq lr ls jz lt ka lu kc lv kd lw kf lx kg ly lz bi translated">外观模式——示例1:一个客户想要使用来自不同系统几个类</h1><p id="e428" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr no kt ku kv np kx ky kz nq lb lc ld im bi translated">我现在将向您展示如何使用JavaScript/TypeScript实现这种模式。在我们的例子中，我虚构了一个问题，其中有一个名为<code class="fe le lf lg lh b">Client</code>的类，它定义了两个方法，这两个方法使用了不同包中的几个类(<code class="fe le lf lg lh b">System1</code>和<code class="fe le lf lg lh b">System2</code>)。这些包由几个类组成，这些类有几个公共方法。下面的UML图显示了我刚刚描述的场景。</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nr"><img src="../Images/79b9806a15cd9c231ba30e726111d197.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6i8vDaqx9mTEqkPs.jpg"/></div></div></figure><p id="1b9c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">client</code>代码关联如下:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ns"><img src="../Images/1543c4de82c65ca44b567ea0f8187668.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0wUFafvayHmTVhop.png"/></div></div></figure><p id="67e2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种解决方案的主要问题是代码是耦合的。也就是说，客户需要知道每个类在哪里以及如何工作。进口的大清单是门面是我们问题的解决方案的第一个征兆。另一个警告症状是客户需要对每个类的操作有广泛的了解。</p><p id="6fef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解决方案是使用一个facade模式，它包含在一个使用了<code class="fe le lf lg lh b">System1</code>和<code class="fe le lf lg lh b">System2</code>的类(<code class="fe le lf lg lh b">Facade</code>)中。也就是说，使用适配器模式的新UML图如下所示:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nt"><img src="../Images/18a88243b358a951c804e0cef2c40891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hR691s07mXv8GARG.jpg"/></div></div></figure><p id="6896" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与客户端和外观相关的代码如下:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nu"><img src="../Images/af432b93c67fd9203c6f54871d57f45e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7xc_o2mDvyB71Uao.png"/></div></div></figure><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nv"><img src="../Images/b1458b58f7c5b13fedcecc00c03a2931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OMLTyOL5DL0mqBhn.png"/></div></div></figure><p id="8966" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在新代码中，客户端将责任委托给外观，但外观执行的功能与客户端相同。事实上，如果代码在增加，facade可以是一个名为<strong class="kk iu">BLOB</strong>(<a class="ae mh" href="https://sourcemaking.com/antipatterns/the-blob" rel="noopener ugc nofollow" target="_blank">https://sourcemaking.com/antipatterns/the-blob</a>)的反模式。因此，一个好主意是在每个包中使用一个facade，就像您在下面的UML中看到的那样:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nw"><img src="../Images/81836578f76ae1ab4bae4db3527a4ce1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CqRCW3BWrJ85UmXz.jpg"/></div></div></figure><p id="0dbb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本解决方案中与<code class="fe le lf lg lh b">client</code>、<code class="fe le lf lg lh b">facade</code>、<code class="fe le lf lg lh b">facadeSystem1</code>和<code class="fe le lf lg lh b">facadeSystem2</code>相关的代码如下:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nu"><img src="../Images/1d355629a370dede34e84e28f4e54ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*C9uT0D-dej_pea-t.png"/></div></div></figure><p id="d43c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">客户端与前一版本中的客户端完全相同。</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nx"><img src="../Images/72fd709548a3c97fa88e981801a7e7b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LSLpFszJ8NOukZ2l.png"/></div></div></figure><p id="4bca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">外观使用为每个子系统创建的每个外观。现在更重要的是Facade类只知道由<code class="fe le lf lg lh b">FacadeSystem1</code>和<code class="fe le lf lg lh b">FacadeSystem2</code>提供的接口。</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ny"><img src="../Images/1b93e5c140a429b8808e52eaeab62eca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0J5HmUpvT8tAtOLT.png"/></div></div></figure><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ny"><img src="../Images/1a4491f5bdb03a6e3310e3dd75fd7462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VxlROuPduOPf2pPj.png"/></div></div></figure><p id="36fe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">FacadeSystem1</code>和<code class="fe le lf lg lh b">FacadeSystem2</code>只知道它们包的类。需要提醒的是，每个facade只导出应该是公共的类，这些方法可以是内部类之间的几个方法的组合。</p><p id="26b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我已经创建了几个npm脚本，应用Facade模式运行下面显示的代码示例。</p><p id="5067" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">【T2<br/><code class="fe le lf lg lh b">npm run example1-facade-solution-1</code><br/><code class="fe le lf lg lh b">npm run example1-facade-solution-2</code></p><h1 id="3b7f" class="li lj it bd lk ll lm ln lo lp lq lr ls jz lt ka lu kc lv kd lw kf lx kg ly lz bi translated">门面格局——例2:口袋妖怪和龙珠一起包装！</h1><p id="e95b" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr no kt ku kv np kx ky kz nq lb lc ld im bi translated">使用Facade模式解决的另一个有趣的问题是，有几个具有不同接口的包，但它们可以一起工作。在下面的UML图中，您可以看到这种情况:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nz"><img src="../Images/6260f96f1815c231443a55050f30cc51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*H5SsCzoKYm7CUodJ.jpeg"/></div></div></figure><p id="14bf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，客户端使用包<code class="fe le lf lg lh b">DragonballFacade</code>和<code class="fe le lf lg lh b">PokemonFacade</code>。因此，客户端只需要知道这些外观提供的接口。例如，<code class="fe le lf lg lh b">DragonballFacade</code>提供了一个名为<code class="fe le lf lg lh b">genki</code>的方法，它计算几个一起工作的对象的值。另一方面，<code class="fe le lf lg lh b">PokemonFacade</code>提供了一个名为<code class="fe le lf lg lh b">calculateDamage</code>的方法，它与其包中的其他类进行交互。</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/6dda8d7aad763bc14c5813ff387a8716.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*q9RQ6IgMEohGr1Kl.jpg"/></div></figure><p id="e2ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与客户端相关联的代码如下:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ob"><img src="../Images/3f13e2246511acb0ba5bf41f34685749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9pQ-PHAAvoCEq6Ph.png"/></div></div></figure><p id="6df8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与正面相关的代码如下:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi oc"><img src="../Images/39eb8b99a9afc4c034b38d1649896b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Sxmb9g3YME-gSdWz.png"/></div></div></figure><p id="4118" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我已经创建了两个npm脚本，它们应用Facade模式运行下面显示的两个示例。</p><p id="71b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">npm run example2-problem</code> <br/> <code class="fe le lf lg lh b">npm run example2-facade-solution1</code></p><p id="6792" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">支持外观的一个巨大优势是从一个不那么简单的系统开发出最简单的系统。例如，在龙珠包中有一个<a class="ae mh" href="https://carloscaballero.io/design-patterns-adapter/" rel="noopener ugc nofollow" target="_blank">适配器模式</a>，它不会影响客户端的正确行为。但是口袋妖怪包的复杂性更大，因为有一个称为<a class="ae mh" href="https://carloscaballero.io/design-patterns-template-method/" rel="noopener ugc nofollow" target="_blank">模板方法</a>的设计模式用于<code class="fe le lf lg lh b">calculateDamage</code>的方法，还有一个工厂模式用于创建不同的口袋妖怪。所有这些复杂性都隐藏在外观中，这些类中的任何变化都不会影响客户的行为，这使得我们可以创建一个更加非耦合的系统。</p><h1 id="8048" class="li lj it bd lk ll lm ln lo lp lq lr ls jz lt ka lu kc lv kd lw kf lx kg ly lz bi translated">结论</h1><p id="ae35" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr no kt ku kv np kx ky kz nq lb lc ld im bi translated">当有几个包相互通信，或者一个客户需要使用几个类时，Facade模式可以避免项目的复杂性。</p><p id="871c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最重要的事情不是实现我给你展示的模式，而是能够认识到这个特定模式可以解决的问题，以及你什么时候可以或者不可以实现所说的模式。这一点至关重要，因为实现会因您使用的编程语言而异。</p><h1 id="c427" class="li lj it bd lk ll lm ln lo lp lq lr ls jz lt ka lu kc lv kd lw kf lx kg ly lz bi translated">更多更多…</h1><ul class=""><li id="af3f" class="mi mj it kk b kl ni ko nj kr nk kv nl kz nm ld nn mo mp mq bi translated">设计模式:可重用的面向对象软件的元素。</li><li id="51c3" class="mi mj it kk b kl mr ko ms kr mt kv mu kz mv ld nn mo mp mq bi translated"><a class="ae mh" href="https://en.wikipedia.org/wiki/Facade_pattern" rel="noopener ugc nofollow" target="_blank">门面模式——维基百科</a>。</li><li id="d8f0" class="mi mj it kk b kl mr ko ms kr mt kv mu kz mv ld nn mo mp mq bi translated">【https://www.dofactory.com/javascript/facade-design-pattern T4】</li><li id="1584" class="mi mj it kk b kl mr ko ms kr mt kv mu kz mv ld nn mo mp mq bi translated"><a class="ae mh" href="https://github.com/sohamkamani/javascript-design-patterns-for-humans#-facade" rel="noopener ugc nofollow" target="_blank">https://github . com/sohamkamani/JavaScript-design-patterns-for-humans #-facade</a></li></ul></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><ul class=""><li id="55ba" class="mi mj it kk b kl km ko kp kr mk kv ml kz mm ld nn mo mp mq bi translated">本帖的<strong class="kk iu"> GitHub </strong>分支为<a class="ae mh" href="https://github.com/Caballerog/blog/tree/master/adapter-pattern" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/Caballerog/blog/tree/master/facade-pattern</a></li></ul></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="0495" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="md">最初发布于</em><a class="ae mh" href="https://carloscaballero.io/design-patterns-facade" rel="noopener ugc nofollow" target="_blank"><em class="md">www . carloscaballero . io</em></a><em class="md">。</em></p></div></div>    
</body>
</html>