<html>
<head>
<title>Powerful Design Patterns to create an Amazing Stopwatch App (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">强大的设计模式来创建一个惊人的秒表应用程序(第1部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/powerful-design-patterns-to-create-an-amazing-stopwatch-app-part-1-b408addedc79?source=collection_archive---------13-----------------------#2021-03-21">https://levelup.gitconnected.com/powerful-design-patterns-to-create-an-amazing-stopwatch-app-part-1-b408addedc79?source=collection_archive---------13-----------------------#2021-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3b98d006f69ff9ab45405ba7b912c6c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*55eLFcyH1xpMZ5Mf.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">礼貌:timeanddate.com</figcaption></figure><p id="50ee" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">回答我一个问题。你认为写程序容易吗？嗯，这取决于问题(也取决于程序员的心情)。你认为编写<strong class="ke ir">结构化</strong>程序容易吗？在这个问题上加一个词就有了很大的变化。首先，你说的结构化程序是什么意思？而你如何编写程序，让其他人容易理解，甚至不需要阅读你的代码注释？这是一项相当困难的任务，面向对象编程的概念试图通过使用四个原则来解决它:抽象、封装、多态和继承。随着设计模式的出现，人们编写结构化代码变得越来越容易。这很简单，只要按照模式。你是如何学习这些模式的？让使用它的应用程序变得简单。</p><blockquote class="la lb lc"><p id="0267" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">这个系列“创建一个惊人的秒表应用程序的强大设计模式”将让你感受到如何应用普通的设计模式，如Observer和State，来创建易于理解的结构化程序。我们还将使用线程的概念，给这个应用程序一个更平滑的UX。</p></blockquote><p id="f18b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将使用Java Swing创建秒表应用程序(您将很快获得完整应用程序的预览)。我们之所以使用Swing，是因为其他平台上的应用程序需要花费大量时间来设置它们的环境。除了JDK之外，Swing不需要任何东西，而且很容易编写GUI程序，不需要任何HTML代码。我已经把这个系列分成了<strong class="ke ir">六个</strong>部分，从零开始慢慢构建，这是第一部分。在前3部分，我们将专注于使我们的核心秒表类越来越好，在接下来的3部分，我们将制作我们的Swing应用程序。所有代码都可以从Github下载。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><p id="c9a3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们预览一下我们将要构建的应用程序。完整的代码可以在<a class="ae lo" href="https://github.com/rajtilakls2510/Stopwatch/tree/S6_Implementing_the_state_pattern" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">这里</strong>找到。</a></p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/3d53084524ca1828d8266d0696c31fcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*t4biW8DH8rygOu9dim9i0g.png"/></div></figure><p id="f618" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">看起来很老派，对吧？但这就是Swing应用程序的样子。我们在这里的目标不是拥有一个非常漂亮的用户界面的应用程序，而是以这样一种方式构建后端，以便它是强大的，并且可以被每个人容易地理解。我们的主要焦点是注入设计模式。</p><p id="72d2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是我们不会一开始就采用任何模式。让我们首先弄清楚我们的核心秒表类是如何工作的。</p><p id="036e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个“秒表”将是一个普通的类(Stopwatch.java)，它的内部值(internal time)应该初始化为零。我们可以启动秒表，我们应该能够暂停它，恢复它，我们应该能够停止它。对吗？你对秒表还有什么期望！</p><p id="ea89" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是为了使我们的生活更简单，我们将只实现暂停和恢复方法。这意味着我们将只能从我们离开的地方恢复秒表，并随时暂停它。将使用这个秒表的类可以负责实现开始、暂停、恢复和停止的所有功能。从技术上讲，您可以在秒表类中实现所有四个特性，但这是一项艰巨的工作，只实现暂停和恢复就可以了。</p><p id="05e0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注意:暂停和恢复功能将使用秒表类的stop()和start()方法来实现。此外，将有一个getTime()方法来获取秒表当前的时间。</p><p id="b986" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们对将要发生的事情有一个更清晰的了解:</p><ul class=""><li id="d259" class="lu lv iq ke b kf kg kj kk kn lw kr lx kv ly kz lz ma mb mc bi translated">首先，我们将创建一个“秒表”对象。它的内部时间将被初始化为零，并且它将处于停止状态。</li><li id="a0b2" class="lu lv iq ke b kf md kj me kn mf kr mg kv mh kz lz ma mb mc bi translated">当我们单击start()方法时，秒表应该考虑内部时间并更新内部时间，从而恢复计时。</li><li id="d875" class="lu lv iq ke b kf md kj me kn mf kr mg kv mh kz lz ma mb mc bi translated">当我们单击stop()方法时，秒表应该暂停计数。</li></ul><p id="73fa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">就是这样。这就是我们秒表类要做的全部工作。</p><p id="5450" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在让我们弄清楚内部时间在我们的类中存储的逻辑。这可能有点令人困惑，但坚持到最后。我会尽力让你明白。</p><p id="7d41" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这一点上，我想鼓励你找出其中的逻辑，因为java有一个方便的方法来给系统时间。</p><pre class="lq lr ls lt gt mi mj mk ml aw mm bi"><span id="88b8" class="mn mo iq mj b gy mp mq l mr ms">System.currentTimeInMillis(); // Gives system current time in Miliseconds</span></pre><p id="dbe7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们开始吧:</p><p id="25ce" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们需要在秒表类中存储的只是</p><ul class=""><li id="c024" class="lu lv iq ke b kf kg kj kk kn lw kr lx kv ly kz lz ma mb mc bi translated">“偏移”是秒表已经运行的总时间，</li><li id="5347" class="lu lv iq ke b kf md kj me kn mf kr mg kv mh kz lz ma mb mc bi translated">秒表的状态(“停止”)，以及</li><li id="1bae" class="lu lv iq ke b kf md kj me kn mf kr mg kv mh kz lz ma mb mc bi translated">“当前启动”。</li></ul><p id="0ecb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">第一次创建秒表时，偏移量首先初始化为0。isStopped设置为true，表示秒表处于暂停/停止状态。“currentStart”存储最后一次调用Start()方法时的时间戳。</p><p id="09a4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，每当我们点击start()方法时，我们将通过存储当前系统时间来记下currentStart。然后，我们将从currentStart中减去失调。并通过将“false”放入isStopped布尔值来使秒表处于运行状态。</p><p id="3853" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">每次我们点击stop()方法时，我们只注意到偏移量是“当前系统时间-当前开始”。然后我们让停止布尔值为真。</p><p id="0f58" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">getTime()方法为我们提供秒表运行的时间(毫秒)(显示时间)。当我们调用getTime()时，我们返回“当前系统时间-当前开始”。(我们现在不编写任何格式化逻辑，但是我们可以在以后添加它)</p><p id="86dc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所有这些逻辑可能第一次有点难以理解，所以让我们看一个例子。</p><p id="2cd8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">假设我们刚刚创造了秒表。偏移量为零，秒表处于停止状态。当我们启动它时，考虑当前系统时间是5000毫秒(这是极不可能的，但考虑它作为一个例子)，它存储在currentStart中(因为5000 - 0 = 5000)。秒表的状态是这样。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/7f946a8657ed69669032eca5c5bdf8ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pSa4hpmUKS5_AG_3Dry2SA.png"/></div></div></figure><p id="b7f3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，2000毫秒后，我们调用getTime()来知道时间。在这个时间点，系统当前时间是7000 ms，秒表已经运行了2000 ms。因此，返回给我们的时间将是current time - currentStart，即7000 - 5000 = 2000。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/50e918f0b5c3811a04f735fc8fa9e330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ji94wPqWZwt_c_iUXPvTig.png"/></div></div></figure><p id="8447" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，在2000毫秒之后，我们调用stop()方法来暂停秒表。“偏移量”变为“当前时间-当前开始时间”= 9000 - 5000 = 4000。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/9c689279d5355d5756e5eae159b191d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WF4yx4_ZlkveuMf6m9r0bg.png"/></div></div></figure><p id="d891" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，当我们调用getTime()时，它应该返回偏移量而不是当前系统时间——current start，因为秒表处于停止状态。让我们再经历一次同样的过程。</p><p id="eea1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2000 ms后，我们再次调用start()。请注意，start方法是在11000 ms时调用的，而currentStart是在7000 ms时调用的，这说明了秒表最初是在5000 ms时启动的，到目前为止，在其整个生命周期中暂停了2000 ms。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/ed66ffc4819c70b471a27a96cfc3b502.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T4SaDvXnN-KqEjAkLmMmYQ.png"/></div></div></figure><p id="5fc4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2000毫秒后，当我们调用getTime()时，我们得到6000毫秒，这是秒表到现在为止已经运行的时间。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/55730acad8c43a3db4ab8d90398f5f39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jAOXfwCTB_G6VdkpLYqxGA.png"/></div></div></figure><p id="e0f0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，在2000 ms后，当我们按stop()时，总运行时间存储在offset中，并帮助秒表随后正确恢复。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/b5cf8acc96f8cbca413d8b66abc734a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WVWFl_NZTwMqUgmENuZO1A.png"/></div></div></figure><p id="d105" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">每次按start()和stop()分别恢复和暂停秒表时，都会出现这一序列。</p><p id="9073" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">既然我们已经弄清楚了我们的秒表将遵循什么逻辑，让我们把这个东西编码出来。首先，我们制作一个新的java文件“Stopwatch.java”并制作Stopwatch类。</p><pre class="lq lr ls lt gt mi mj mk ml aw mm bi"><span id="1d16" class="mn mo iq mj b gy mp mq l mr ms">public class Stopwatch<br/>{<br/>}</span></pre><p id="3d83" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们添加类变量:offset (long)、currentStart (long)和isStopped (boolean)并在构造函数中初始化它们。</p><pre class="lq lr ls lt gt mi mj mk ml aw mm bi"><span id="2885" class="mn mo iq mj b gy mp mq l mr ms">public class Stopwatch<br/>{<br/>    private long offset, currentStart;<br/>    private boolean isStopped;<br/><br/>    public Stopwatch()<br/>    {<br/>        offset = 0L;<br/>        currentStart = System.<em class="ld">currentTimeMillis</em>();<br/>        isStopped = true;<br/>    }</span><span id="bccc" class="mn mo iq mj b gy mu mq l mr ms">}</span></pre><p id="ef57" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">offset设置为零，currentStart现在可以是任何值，is stop为true，表示秒表处于停止状态。然后，我们添加start()方法来启动/恢复秒表。</p><pre class="lq lr ls lt gt mi mj mk ml aw mm bi"><span id="5fe9" class="mn mo iq mj b gy mp mq l mr ms">public class Stopwatch<br/>{<br/>    ....<br/><br/>    public void start()<br/>    {<br/>        if(isStopped)<br/>        {<br/>            currentStart = System.<em class="ld">currentTimeMillis</em>() - offset;<br/>        }<br/><br/>        isStopped = false;<br/>    }<br/>}</span></pre><p id="38fa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请注意“如果”语句。这意味着只有当秒表处于停止状态时，我们才会启动它。否则，什么都不会发生。接下来，我们创建stop()方法来停止/暂停秒表。</p><pre class="lq lr ls lt gt mi mj mk ml aw mm bi"><span id="2223" class="mn mo iq mj b gy mp mq l mr ms">public class Stopwatch<br/>{<br/>   ...<br/><br/>    public void stop()<br/>    {<br/>        if(!isStopped)<br/>        {<br/>            offset = System.<em class="ld">currentTimeMillis</em>() - currentStart;<br/>        }<br/>        isStopped = true;<br/>    }<br/>}</span></pre><p id="2e73" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如前所述，还创建了getTime()方法，它给出秒表的当前时间。</p><pre class="lq lr ls lt gt mi mj mk ml aw mm bi"><span id="fe6f" class="mn mo iq mj b gy mp mq l mr ms">public class Stopwatch<br/>{<br/>    ...<br/><br/>    public long getTime()<br/>    {<br/>        if(!isStopped)<br/>            return System.<em class="ld">currentTimeMillis</em>() - currentStart;<br/>        else<br/>            return offset;<br/>    }<br/>}</span></pre><p id="b7fb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请注意“如果”语句。这表示当秒表处于停止状态时，返回偏移量。否则，为秒表的当前时间。</p><p id="b9b3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这些都在我们的“Stopwatch.java”类中。现在让我们来测试一下。创建另一个文件“StopwatchTest.java ”,并在main方法中创建一个秒表，调用几次start()、stop()、getTime()方法，我们就完成了。</p><pre class="lq lr ls lt gt mi mj mk ml aw mm bi"><span id="47af" class="mn mo iq mj b gy mp mq l mr ms">public class StopwatchTest {<br/>    public static void main(String[] args) {<br/>        Stopwatch sw = new Stopwatch();<br/><br/>        System.<em class="ld">out</em>.println("\nStarting Stopwatch: ");<br/>        sw.start();<br/>        System.<em class="ld">out</em>.println(sw.getTime());<br/>        sw.stop();<br/>        System.<em class="ld">out</em>.println("\nStopwatch Stopped. ");<br/><br/>        System.<em class="ld">out</em>.println("\nStarting Stopwatch: ");<br/>        sw.start();<br/>        System.<em class="ld">out</em>.println(sw.getTime());<br/>        sw.stop();<br/>        System.<em class="ld">out</em>.println("\nStopwatch Stopped. ");<br/><br/>    }<br/>}</span></pre><p id="52de" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">输出可能不令人满意。你可能会看到这样的东西。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/242f8ee8bda8b0a53b43a29e0ec7bd2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*Gx_LM6AoLYBIR7N08MT0Yw.png"/></div></figure><p id="81a2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">很明显，我们没有给秒表任何运行的时间，这就是为什么当我们在start()之后调用getTime()时，我们得到0。我们可以通过注入Thread.sleep()引入时间延迟，使当前线程休眠一段时间。由于Thread.sleep()方法需要一个try-catch来处理InterruptedException，我们将创建一个名为sleep()的方法。</p><pre class="lq lr ls lt gt mi mj mk ml aw mm bi"><span id="af2b" class="mn mo iq mj b gy mp mq l mr ms">public class StopwatchTest {<br/>   ...<br/><br/>    public static void sleep(int time)<br/>    {<br/>        try {<br/>            Thread.<em class="ld">sleep</em>(time);<br/>        } catch (InterruptedException e) {<br/>            e.printStackTrace();<br/>        }<br/>    }<br/>}</span></pre><p id="943e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我们可以写了</p><pre class="lq lr ls lt gt mi mj mk ml aw mm bi"><span id="a39d" class="mn mo iq mj b gy mp mq l mr ms">public class StopwatchTest {<br/>    public static void main(String[] args) {<br/>        Stopwatch sw = new Stopwatch();<br/><em class="ld"><br/>        </em>System.<em class="ld">out</em>.println("\nStarting Stopwatch: ");<br/>        sw.start();<br/>        <em class="ld">sleep</em>(2000); // 2 sec time delay<br/>        System.<em class="ld">out</em>.println(sw.getTime());<br/>        <em class="ld">sleep</em>(2000);<br/>        sw.stop();<br/>        System.<em class="ld">out</em>.println("\nStopwatch Stopped. ");<br/><br/>        <em class="ld">sleep</em>(2000);<br/><br/>        System.<em class="ld">out</em>.println("\nStarting Stopwatch: ");<br/>        sw.start();<br/>        <em class="ld">sleep</em>(2000);<br/>        System.<em class="ld">out</em>.println(sw.getTime());<br/>        <em class="ld">sleep</em>(2000);<br/>        sw.stop();<br/>        System.<em class="ld">out</em>.println("\nStopwatch Stopped. ");<br/><br/>    }<br/><br/>    ...<br/>}</span></pre><p id="3c2b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦您运行这个，您将会看到在调用start()之后2000 ms的时间。</p><p id="2bec" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但这是我们真正想要的吗？这个不满意看这个秒表工作正常不正常(至少对我来说不是)。我想看到秒表在跑。知道我们该怎么做吗？我们可以创建另一个线程，在那个线程上显示时间，而控制逻辑在主线程上。</p><p id="b34f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注意:如果你不习惯使用线程，你一定要尝试一下。</p><p id="1c6c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是我们将要做的。我们将创建一个新线程，并在该线程上打印秒表时间。</p><pre class="lq lr ls lt gt mi mj mk ml aw mm bi"><span id="eecf" class="mn mo iq mj b gy mp mq l mr ms">public class StopwatchTest {<br/>    public static void main(String[] args) {<br/>        Stopwatch sw = new Stopwatch();<br/><br/>        Thread observerThread = new Thread(new Runnable() {<br/>            @Override<br/>            public void run() {<em class="ld"><br/><br/>            </em>}<br/>        });<br/>        observerThread.start();<br/><br/><br/>        ...<br/><br/>    }</span></pre><p id="0e01" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注意，我们正在创建一个名为“observerThread”的新线程，并向它传递一个Runnable。您在run()方法中编写的代码将在不同的线程上运行。创建线程后，我们编写observerThread.start()来启动线程。在run方法中，我们将使用它的getTime()方法无限打印出秒表时间(我们将在接下来的教程中修改它)。</p><pre class="lq lr ls lt gt mi mj mk ml aw mm bi"><span id="415e" class="mn mo iq mj b gy mp mq l mr ms">...<br/>Thread observerThread = new Thread(new Runnable() {<br/>    @Override<br/>    public void run() {<br/>        while (true)<br/>        {<br/>            System.<em class="ld">out</em>.print("\rTime: "+ sw.getTime());<br/>            <em class="ld">sleep</em>(10);<br/>        }<br/><br/>    }<br/>});<br/>...</span></pre><p id="8b91" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们运行一个无限循环，每隔10毫秒连续打印出秒表的时间，注意print语句中的“\r”。“\r”代表回车。它的工作是将光标返回到当前行的开头，以便新的内容可以打印在同一行上。它类似于在新的一行打印消息的“\n”。我想我们都明白“\r”比“\n”更重要，否则我们所有的打印语句都会出现在新的一行，从而使整个命令行变得垃圾。剩下的最后一项工作是清理getTime()方法和额外的sleep语句，我们编写这些语句是为了查看start()被调用后的时间。</p><pre class="lq lr ls lt gt mi mj mk ml aw mm bi"><span id="5391" class="mn mo iq mj b gy mp mq l mr ms">public static void main(String[] args) {<br/>    Stopwatch sw = new Stopwatch();<br/><br/>    ...<br/><br/><br/>    System.<em class="ld">out</em>.println("\nStarting Stopwatch: ");<br/>    sw.start();<br/>    <em class="ld">sleep</em>(2000);<br/>    sw.stop();<br/>    System.<em class="ld">out</em>.println("\nStopwatch Stopped. ");<br/><br/>    <em class="ld">sleep</em>(2000);<br/><br/>    System.<em class="ld">out</em>.println("\nStarting Stopwatch: ");<br/>    sw.start();<br/>    <em class="ld">sleep</em>(2000);<br/>    sw.stop();<br/>    System.<em class="ld">out</em>.println("\nStopwatch Stopped. ");<br/><br/>}</span></pre><p id="c067" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">就是这样。现在，当您运行这段代码时，您将看到时间每10毫秒更新一次，秒表将恢复并暂停2次。我将附上输出的截图，但它将无法显示时间更新。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/3beddb5bcb07b0e3c26a5311fb874aea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*AzixUl00dTo8NoNfmJck9Q.png"/></div></figure><p id="e992" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里您可能会注意到的一个问题是，即使主线程的所有代码都已完成，程序也不会完全停止执行。您可以通过按CTRL+C来强制它停止执行。我希望您找出为什么会发生这种情况。我们将在下一个教程中修正这个问题。</p><p id="0851" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这仅仅是开始。到目前为止，我们使用在客户端创建的不同线程来查看秒表更新。但是我们可以通过将线程逻辑封装在秒表类中来做得更好。我的意思是，秒表每次启动时都会在不同的线程上运行。这将使客户的生活更加轻松，因为他不再需要创建不同的线程来查看秒表。这是我们在下一个教程中要做的事情。</p><h1 id="4b8a" class="mx mo iq bd my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt bi translated">下一个教程:</h1><p id="1e53" class="pw-post-body-paragraph kc kd iq ke b kf nu kh ki kj nv kl km kn nw kp kq kr nx kt ku kv ny kx ky kz ij bi translated"><a class="ae lo" href="https://rajtilakls2510.medium.com/encapsulating-the-thread-logic-in-stopwatch-part-2-746d2e051abd" rel="noopener">封装线程逻辑。</a></p><h1 id="adc2" class="mx mo iq bd my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt bi translated"><strong class="ak">全码</strong></h1><p id="1580" class="pw-post-body-paragraph kc kd iq ke b kf nu kh ki kj nv kl km kn nw kp kq kr nx kt ku kv ny kx ky kz ij bi translated"><a class="ae lo" href="https://github.com/rajtilakls2510/Stopwatch/tree/S1_Making_the_core_stopwatch" rel="noopener ugc nofollow" target="_blank">本教程的完整代码</a>。</p><p id="34e3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Stopwatch.java</p><pre class="lq lr ls lt gt mi mj mk ml aw mm bi"><span id="b182" class="mn mo iq mj b gy mp mq l mr ms">public class Stopwatch<br/>{<br/>    private long offset, currentStart;<br/>    private boolean isStopped;<br/><br/>    public Stopwatch()<br/>    {<br/>        offset = 0L;<br/>        currentStart = System.<em class="ld">currentTimeMillis</em>();<br/>        isStopped = true;<br/>    }<br/><br/>    public void start()<br/>    {<br/>        if(isStopped)<br/>        {<br/>            currentStart = System.<em class="ld">currentTimeMillis</em>() - offset;<br/>        }<br/><br/>        isStopped = false;<br/>    }<br/><br/>    public void stop()<br/>    {<br/>        if(!isStopped)<br/>        {<br/>            offset = System.<em class="ld">currentTimeMillis</em>() - currentStart;<br/>        }<br/>        isStopped = true;<br/>    }<br/><br/>    public long getTime()<br/>    {<br/>        if(!isStopped)<br/>            return System.<em class="ld">currentTimeMillis</em>() - currentStart;<br/>        else<br/>            return offset;<br/>    }<br/>}</span></pre><p id="e830" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">StopwatchTest.java</p><pre class="lq lr ls lt gt mi mj mk ml aw mm bi"><span id="fde8" class="mn mo iq mj b gy mp mq l mr ms">public class StopwatchTest {<br/>    public static void main(String[] args) {<br/>        Stopwatch sw = new Stopwatch();<br/><br/>        Thread observerThread = new Thread(new Runnable() {<br/>            @Override<br/>            public void run() {<br/>                while (true)<br/>                {<br/>                    System.<em class="ld">out</em>.print("\rTime: "+ sw.getTime());<br/>                    <em class="ld">sleep</em>(10);<br/>                }<br/><br/>            }<br/>        });<br/>        observerThread.start();<br/><br/><br/>        System.<em class="ld">out</em>.println("\nStarting Stopwatch: ");<br/>        sw.start();<br/>        <em class="ld">sleep</em>(2000);<br/>        sw.stop();<br/>        System.<em class="ld">out</em>.println("\nStopwatch Stopped. ");<br/><br/>        <em class="ld">sleep</em>(2000);<br/><br/>        System.<em class="ld">out</em>.println("\nStarting Stopwatch: ");<br/>        sw.start();<br/>        <em class="ld">sleep</em>(2000);<br/>        sw.stop();<br/>        System.<em class="ld">out</em>.println("\nStopwatch Stopped. ");<br/><br/>    }<br/><br/>    public static void sleep(int time)<br/>    {<br/>        try {<br/>            Thread.<em class="ld">sleep</em>(time);<br/>        } catch (InterruptedException e) {<br/>            e.printStackTrace();<br/>        }<br/>    }<br/>}</span></pre><h1 id="ffad" class="mx mo iq bd my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt bi translated"><strong class="ak">参考文献:</strong></h1><ul class=""><li id="9f89" class="lu lv iq ke b kf nu kj nv kn nz kr oa kv ob kz lz ma mb mc bi translated">书籍:<a class="ae lo" href="https://www.oreilly.com/library/view/head-first-design/0596007124/" rel="noopener ugc nofollow" target="_blank"> Head First设计模式</a>，作者埃里克弗里曼、伊丽莎白罗布森、伯特贝茨、凯西塞拉。</li></ul></div></div>    
</body>
</html>