<html>
<head>
<title>Monolith to Microservices with Kafka Streaming Data Connector</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">整体到微服务，带Kafka流数据连接器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/monolith-to-microservices-with-kafka-streaming-data-connector-89714e809b7c?source=collection_archive---------13-----------------------#2020-10-21">https://levelup.gitconnected.com/monolith-to-microservices-with-kafka-streaming-data-connector-89714e809b7c?source=collection_archive---------13-----------------------#2020-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3b83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你是一个开发和维护软件的团队<a class="ae ko" href="https://en.wikipedia.org/wiki/Monolithic_application" rel="noopener ugc nofollow" target="_blank"> monolith </a>，很有可能你正在考虑或计划迁移到一个基于<a class="ae ko" href="https://en.wikipedia.org/wiki/Microservices" rel="noopener ugc nofollow" target="_blank">微服务</a>的架构。在本文中，我不会深入讨论该决策中涉及的各种权衡；相反，我将重点介绍一种可能帮助您实现这种转变的特定技术:<a class="ae ko" href="https://en.wikipedia.org/wiki/Change_data_capture" rel="noopener ugc nofollow" target="_blank">变更数据捕获</a> (CDC)</p><p id="6af3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你从零开始，围绕微服务构建一个系统是相对简单的。然而，很难规划和管理从现有整体结构的过渡。所涉及的变化可能是实质性的，当您从根本上改变系统的工作方式时，很难保持一个活跃的系统平稳运行。</p><p id="174e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个很大的转变，从一个符合<a class="ae ko" href="https://en.wikipedia.org/wiki/ACID" rel="noopener ugc nofollow" target="_blank"> ACID </a>的数据库到一个基于<a class="ae ko" href="https://en.wikipedia.org/wiki/Eventual_consistency" rel="noopener ugc nofollow" target="_blank">最终一致性</a>的分布式架构，并且在漫长的迁移过程中保持数据的一致性<em class="kp">，当不同的信息保存在系统的不同部分时，可能会特别具有挑战性。</em></p><p id="30af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">变更数据捕获(CDC)使您能够首先对生产系统进行最小的更改(如果有的话)。相反，您建立一个系统来观察您的数据库，并在关键数据发生变化时创建事件，您的“新架构”系统对这些事件做出响应。</p><h1 id="01d0" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">变更数据捕获</h1><p id="da25" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">让我们看一个例子。假设您想在应用程序中添加一个入职电子邮件流，以便新用户在创建帐户后的几天内可以收到有用的电子邮件。使用CDC，您可以将这个新流程创建为微服务。每当一个新的用户记录被添加到主<code class="fe lt lu lv lw b">users</code>表中时，就会创建一个新的事件。然后，您的新微服务将使用该事件并管理入职流程，而不需要对您的主要遗留应用程序做任何进一步的更改。另一个例子是，在用户删除他们的帐户后，向他们发送一份离职调查，以获取关于为什么您的服务不再满足他们的要求的数据。</p><p id="1369" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将通过一种技术来实现这一点，它不需要对“主”应用程序做任何改动；Heroku最近推出的<a class="ae ko" href="https://blog.heroku.com/streaming-data-connectors-beta" rel="noopener ugc nofollow" target="_blank">流数据连接器测试版</a>。</p><p id="5959" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其工作方式是向Heroku应用程序添加一个托管的<a class="ae ko" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Kafka </a>和一个“数据连接器”,定义变更应该生成事件的表和列。然后，您可以设置新的微服务来使用Kafka主题中的事件。</p><p id="322a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文的其余部分，我将带您了解如何设置它。我们将使用一个普通的数据库支持的web应用程序来表示我们的monolith，以及一个订阅了Kafka主题的独立应用程序，它将通过更改我们的数据库来消费我们生成的事件。</p><blockquote class="lx ly lz"><p id="4885" class="jq jr kp js b jt ju jv jw jx jy jz ka ma kc kd ke mb kg kh ki mc kk kl km kn im bi translated"><em class="it">流媒体数据连接器Beta目前只对</em><a class="ae ko" href="https://devcenter.heroku.com/categories/heroku-enterprise" rel="noopener ugc nofollow" target="_blank"><em class="it">Heroku Enterprise</em></a><em class="it">用户可用，因为它只在Heroku </em> <a class="ae ko" href="https://www.heroku.com/private-spaces" rel="noopener ugc nofollow" target="_blank"> <em class="it">私有空间</em> </a> <em class="it">(这是一个企业功能)中工作。</em></p></blockquote><p id="f0a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看一些代码。</p><blockquote class="lx ly lz"><p id="00a2" class="jq jr kp js b jt ju jv jw jx jy jz ka ma kc kd ke mb kg kh ki mc kk kl km kn im bi translated"><em class="it">我在一台Mac笔记本电脑上工作，但是这些命令应该在任何posix兼容的终端环境下都能正常工作。</em></p></blockquote><h1 id="0631" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">清除</h1><p id="0e7f" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">我们将要使用的一些命令会在你的Heroku帐户中创建资源，这会产生费用。完成后，请不要忘记删除您的应用程序，否则您可能会被收取这些服务的费用。</p><p id="46ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以通过在<code class="fe lt lu lv lw b">sinatra-postgres-demo</code>目录和<code class="fe lt lu lv lw b">kafka-consumer</code>目录中运行<code class="fe lt lu lv lw b">make clean</code>来实现。您也可以使用Heroku web界面删除应用程序。</p><p id="f662" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要验证所有内容都已成功删除，您可以运行:</p><p id="0db0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lt lu lv lw b">heroku apps --space ${HEROKU_PRIVATE_SPACE}</code></p><p id="c703" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请在上面的命令中使用您的Heroku私人空间的名称。</p><h1 id="5540" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">用户应用程序</h1><p id="4392" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">我们将使用一个简单的web应用程序来管理Postgres数据库中的“用户”记录。我在Sinatra 中写了这个，这是一个轻量级web应用程序的ruby库。</p><p id="55a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该应用程序有几个HTTP端点:</p><pre class="md me mf mg gt mh lw mi mj aw mk bi"><span id="413f" class="ml kr it lw b gy mm mn l mo mp">get "/" do</span><span id="5124" class="ml kr it lw b gy mq mn l mo mp">redirect "/users"</span><span id="a68e" class="ml kr it lw b gy mq mn l mo mp">end</span><span id="8d48" class="ml kr it lw b gy mq mn l mo mp">get "/users" do<br/>  erb :users, locals: { users: get_users }<br/>end</span><span id="b886" class="ml kr it lw b gy mq mn l mo mp">post "/users" do<br/>  add_user(params)  redirect "/users"<br/>end</span><span id="0672" class="ml kr it lw b gy mq mn l mo mp">post "/delete_user" do<br/>  delete_user(params["id"])  redirect "/users"<br/>end</span></pre><p id="894c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对“/users”的HTTP GET呈现数据库中的用户列表，对“/users”的POST添加新用户，对“/delete_user”的POST将删除用户。</p><p id="a47b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是数据库代码的实现:</p><pre class="md me mf mg gt mh lw mi mj aw mk bi"><span id="3a2f" class="ml kr it lw b gy mm mn l mo mp">def connection<br/>  PG.connect(ENV.fetch("DATABASE_URL"))<br/>end</span><span id="7bd2" class="ml kr it lw b gy mq mn l mo mp">def get_users<br/>  connection.exec( "SELECT * FROM users" )<br/>end</span><span id="0d88" class="ml kr it lw b gy mq mn l mo mp">def add_user(u)<br/>  addsql = %[ INSERT INTO users (first_name, last_name, password, email) VALUES ($1, $2, $3, $4) ]  connection.exec_params(addsql, [ u["first_name"], u["last_name"], u["password"], u["email"] ])<br/>end</span><span id="f04d" class="ml kr it lw b gy mq mn l mo mp">def delete_user(id)<br/>  connection.exec_params("DELETE FROM users WHERE id=$1", [ id ])<br/>end</span></pre><p id="76a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完整的应用程序可从<a class="ae ko" href="https://github.com/digitalronin/sinatra-postgres-demo" rel="noopener ugc nofollow" target="_blank">这里</a>获得。让我们开始吧。</p><p id="474a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我正在使用一个名为<code class="fe lt lu lv lw b">devspotlight-private</code>的私人空间。请在下面的代码中替换您的私人空间的名称:</p><pre class="md me mf mg gt mh lw mi mj aw mk bi"><span id="fdce" class="ml kr it lw b gy mm mn l mo mp">git clone <a class="ae ko" href="https://github.com/digitalronin/sinatra-postgres-demo" rel="noopener ugc nofollow" target="_blank">https://github.com/digitalronin/sinatra-postgres-demo</a></span><span id="a0aa" class="ml kr it lw b gy mq mn l mo mp">cd sinatra-postgres-demo</span><span id="73c0" class="ml kr it lw b gy mq mn l mo mp">export HEROKU_PRIVATE_SPACE=devspotlight-private</span><span id="8e42" class="ml kr it lw b gy mq mn l mo mp">heroku apps:create --space ${HEROKU_PRIVATE_SPACE}</span></pre><p id="d420" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将创建一个随机命名的应用程序。为了保持代码样本的一致性，我将读取名称并将其存储在环境变量<code class="fe lt lu lv lw b">APP</code>中。</p><pre class="md me mf mg gt mh lw mi mj aw mk bi"><span id="8534" class="ml kr it lw b gy mm mn l mo mp">export APP=$(heroku apps:info | head -1 | sed 's/=== //')</span><span id="bfa9" class="ml kr it lw b gy mq mn l mo mp">echo ${APP}</span></pre><p id="5b3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的应用程序需要一个数据库，为了使用流数据连接器测试版，您需要使用特定版本的Heroku Postgres插件:</p><p id="d1dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lt lu lv lw b">heroku addons:create heroku-postgresql:private-7 --as DATABASE --app ${APP}</code></p><blockquote class="lx ly lz"><p id="7313" class="jq jr kp js b jt ju jv jw jx jy jz ka ma kc kd ke mb kg kh ki mc kk kl km kn im bi translated"><em class="it">请注意，运行此命令将在您的Heroku帐户上产生费用。</em></p></blockquote><p id="86eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lt lu lv lw b">heroku addons:wait</code></p><p id="1ee2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建数据库可能需要几分钟时间，所以上面的<code class="fe lt lu lv lw b">wait</code>命令会告诉您何时可以继续下一步:</p><pre class="md me mf mg gt mh lw mi mj aw mk bi"><span id="1212" class="ml kr it lw b gy mm mn l mo mp">git push heroku master</span><span id="60c7" class="ml kr it lw b gy mq mn l mo mp">heroku run make setup-db</span></pre><p id="d796" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将部署我们的应用程序，并使用<code class="fe lt lu lv lw b">users</code>表和一些样本记录建立数据库。</p><p id="6014" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦这个过程完成，您应该能够运行<code class="fe lt lu lv lw b">heroku open</code>并看到如下所示的网页:</p><figure class="md me mf mg gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mr"><img src="../Images/2f1c90d712166f4ec09651fe53686f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fvVurQshvN371ghV"/></div></div></figure><p id="6e83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们有了一个示例web应用程序，由Postgres数据库支持，我们可以在其中添加和删除<code class="fe lt lu lv lw b">users</code>表中的记录。这代表我们的monolith应用程序。现在，让我们添加流数据连接器测试版，看看如何使用CDC添加微服务，而不改变我们的应用。</p><h1 id="ab0e" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">添加卡夫卡</h1><p id="aeb7" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">我们需要Kafka作为我们连接的应用程序的消息传递主干，因此我们需要Kafka附加组件。同样，您需要使用特定的版本:</p><p id="2a69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lt lu lv lw b">heroku addons:create heroku-kafka:private-extended-2 --as KAFKA --app ${APP}</code></p><blockquote class="lx ly lz"><p id="9dbb" class="jq jr kp js b jt ju jv jw jx jy jz ka ma kc kd ke mb kg kh ki mc kk kl km kn im bi translated"><em class="it">请注意，运行此命令将在您的Heroku帐户上产生费用。</em></p></blockquote><p id="0047" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lt lu lv lw b">heroku kafka:wait</code></p><p id="374a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，这可能需要一些时间。</p><h1 id="7e0c" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">添加数据库连接器</h1><p id="a012" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">一旦我们有了Kafka附加组件，我们就可以设置连接器，每当Postgres数据库中的表发生变化时，就生成Kafka事件。</p><p id="8ece" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要安装一个插件来添加数据库连接器:</p><p id="8169" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lt lu lv lw b">heroku plugins:install @heroku-cli/plugin-data-connectors</code></p><p id="593d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦完成，创建数据库连接器的语法如下所示:</p><pre class="md me mf mg gt mh lw mi mj aw mk bi"><span id="c2d0" class="ml kr it lw b gy mm mn l mo mp">heroku data:connectors:create \</span><span id="4415" class="ml kr it lw b gy mq mn l mo mp">--source [postgres identifier] \</span><span id="c8ed" class="ml kr it lw b gy mq mn l mo mp">--store [kafka identifier] \</span><span id="9d56" class="ml kr it lw b gy mq mn l mo mp">--table [table name]...</span></pre><p id="b0af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要获取Postgres标识符，请运行以下命令:</p><p id="9727" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lt lu lv lw b">heroku addons:info heroku-postgresql</code></p><p id="5038" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您应该会看到如下所示的输出(您的值会有所不同):</p><pre class="md me mf mg gt mh lw mi mj aw mk bi"><span id="f892" class="ml kr it lw b gy mm mn l mo mp">=== postgresql-tapered-49814</span><span id="1d64" class="ml kr it lw b gy mq mn l mo mp">Attachments:  lit-bastion-67140::DATABASE</span><span id="581d" class="ml kr it lw b gy mq mn l mo mp">Installed at: Sun Jul 19 2020 10:26:20 GMT+0100 (British Summer Time)</span><span id="832a" class="ml kr it lw b gy mq mn l mo mp">Owning app:   lit-bastion-67140</span><span id="10cc" class="ml kr it lw b gy mq mn l mo mp">Plan:         heroku-postgresql:private-7</span><span id="ec55" class="ml kr it lw b gy mq mn l mo mp">Price:        $7000/month</span><span id="f1ad" class="ml kr it lw b gy mq mn l mo mp">State:        created</span></pre><p id="c872" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要的标识符在第一行。在这种情况下，<code class="fe lt lu lv lw b">postgresql-tapered-49814</code></p><p id="b7d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">获取Kafka标识符的过程类似，标识符出现在输出的第一行:</p><p id="3eab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lt lu lv lw b">heroku addons:info heroku-kafka</code></p><p id="8dfa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们有了Postgres数据库和Kafka实例的标识符，我们可以创建数据库连接器了。我正在使用我的应用程序中的标识符，所以在运行这个命令时，您需要用您自己的标识符替换适当的值:</p><pre class="md me mf mg gt mh lw mi mj aw mk bi"><span id="198e" class="ml kr it lw b gy mm mn l mo mp">heroku data:connectors:create \</span><span id="906e" class="ml kr it lw b gy mq mn l mo mp">  --source postgresql-tapered-49814 \</span><span id="e507" class="ml kr it lw b gy mq mn l mo mp">  --store kafka-octagonal-83137 \</span><span id="852d" class="ml kr it lw b gy mq mn l mo mp">  --table public.users \</span><span id="6667" class="ml kr it lw b gy mq mn l mo mp">  --exclude public.users.password</span></pre><p id="6195" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我已经将该表指定为<code class="fe lt lu lv lw b">public.users</code>。在创建我的<code class="fe lt lu lv lw b">users</code>表时，我使用了Postgres数据库的默认<code class="fe lt lu lv lw b">public</code>模式。如果您使用了不同的模式，您将需要指定它。</p><p id="c5bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还要注意，我使用了<code class="fe lt lu lv lw b">--exclude public.users.password.</code>，这意味着在生成的Kafka事件中不会有任何关于<code class="fe lt lu lv lw b">password</code>字段值的信息。这是一个非常有用的功能，可以确保您不会意外地将敏感的用户信息从您的主应用程序发送到不需要它的微服务。</p><p id="e267" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建数据库连接器可能需要一段时间，而<code class="fe lt lu lv lw b">create</code>命令的输出将告诉您可以使用什么命令来等待数据库连接器被提供。</p><p id="db5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lt lu lv lw b">heroku data:connectors:wait [connector name]</code></p><h1 id="16ab" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">消费卡夫卡事件</h1><p id="3969" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">现在我们有了原始的数据库支持的应用程序，并且我们添加了流数据连接器测试版，所以每当我们对<code class="fe lt lu lv lw b">users</code>表进行更改时，我们应该会在Kafka服务上看到一个事件。</p><p id="de73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一步是设置另一个应用程序来使用这些事件。在真实的场景中，您可能希望对这些事件做一些有用的事情。然而，对于本文，我们要做的只是在一个非常简单的web界面中显示事件。</p><h1 id="5630" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">创建Web应用程序</h1><p id="b137" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">我写了一个非常简单的“kafka-consumer”应用程序，也使用了Ruby和Sinatra，你可以在这里看到<a class="ae ko" href="https://github.com/digitalronin/kafka-consumer.git" rel="noopener ugc nofollow" target="_blank"/>。在创建这个的过程中，我从这个<a class="ae ko" href="https://github.com/heroku/heroku-kafka-demo-ruby" rel="noopener ugc nofollow" target="_blank"> heroku-kafka-demo-ruby </a>应用程序中获取了一些代码。</p><p id="bcbc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们部署它，并将其连接到我们的Kafka实例。启动一个新的终端会话并运行这些命令。</p><p id="c464" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lt lu lv lw b">export HEROKU_PRIVATE_SPACE=devspotlight-private</code></p><p id="ee35" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">替换你自己的Heroku私人空间的名字。</p><pre class="md me mf mg gt mh lw mi mj aw mk bi"><span id="2547" class="ml kr it lw b gy mm mn l mo mp">git clone <a class="ae ko" href="https://github.com/digitalronin/kafka-consumer.git" rel="noopener ugc nofollow" target="_blank">https://github.com/digitalronin/kafka-consumer.git</a></span><span id="5289" class="ml kr it lw b gy mq mn l mo mp">cd kafka-consumer</span><span id="ec9e" class="ml kr it lw b gy mq mn l mo mp">heroku apps:create --space ${HEROKU_PRIVATE_SPACE}</span><span id="941e" class="ml kr it lw b gy mq mn l mo mp">export APP=$(heroku apps:info | head -1 | sed 's/=== //')</span></pre><p id="d14e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在部署我们的应用程序之前，我们需要做一些设置，使这个应用程序能够读取在我们设置数据库连接器时创建的Kafka主题。</p><p id="b0a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了让您的新应用程序能够访问Kafka实例，我们需要运行如下命令:</p><p id="1faf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lt lu lv lw b">heroku addons:attach [app with kafka]::KAFKA -a [app that wants to access kafka]</code></p><p id="4afd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lt lu lv lw b">[app with kafka]</code>是您的<code class="fe lt lu lv lw b">sinatra-postgres-demo</code>应用程序实例的名称，如果您在另一个终端会话中运行<code class="fe lt lu lv lw b">heroku apps:info</code>，就会看到这个实例。</p><p id="aec7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lt lu lv lw b">[app that wants to access kafka]</code>是我们现在正在创建的应用程序<code class="fe lt lu lv lw b">kafka-consumer</code>的实例。</p><p id="eab9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最初创建Kafka实例时，我们使用了<code class="fe lt lu lv lw b">KAFKA</code>标签。</p><p id="f20f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的例子中，我需要的命令如下所示(用您的应用程序替换这些值):</p><p id="be49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lt lu lv lw b">heroku addons:attach lit-bastion-67140::KAFKA -a boiling-sierra-18761</code></p><blockquote class="lx ly lz"><p id="2a85" class="jq jr kp js b jt ju jv jw jx jy jz ka ma kc kd ke mb kg kh ki mc kk kl km kn im bi translated"><em class="it">注意在</em> <code class="fe lt lu lv lw b"><em class="it">KAFKA</em></code> <em class="it">前加两个</em>冒号，否则会得 <code class="fe lt lu lv lw b"><em class="it">Couldn't find that add-on.</em></code></p></blockquote><p id="e2f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出应该如下所示:</p><pre class="md me mf mg gt mh lw mi mj aw mk bi"><span id="cc74" class="ml kr it lw b gy mm mn l mo mp">Attaching kafka-octagonal-83137 to ⬢ boiling-sierra-18761... done</span><span id="b7a3" class="ml kr it lw b gy mq mn l mo mp">Setting KAFKA config vars and restarting ⬢ boiling-sierra-18761... done, v3</span></pre><p id="f7ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您运行<code class="fe lt lu lv lw b">heroku config</code>，您将看到我们的新应用程序现在已经设置了几个<code class="fe lt lu lv lw b">KAFKA*</code>环境变量，这将使我们能够连接到Kafka实例。</p><p id="e480" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，我们还需要一件事:我们需要知道我们的事件将要发布的卡夫卡主题。这个主题是在我们添加数据库连接器时自动创建的。要找出它是什么，返回到您的<code class="fe lt lu lv lw b">sinatra-postgres-demo</code>目录并运行这个命令:</p><p id="4c40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lt lu lv lw b">heroku kafka:topics</code></p><p id="3386" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出应该如下所示:</p><pre class="md me mf mg gt mh lw mi mj aw mk bi"><span id="31ad" class="ml kr it lw b gy mm mn l mo mp">=== Kafka Topics on KAFKA_URL</span><span id="ca47" class="ml kr it lw b gy mq mn l mo mp">Name                                                  Messages  Traffic ────────────────────────────────────────────────────  ────────  ────────────</span><span id="58e3" class="ml kr it lw b gy mq mn l mo mp">connect-configs-311cea8b-0d94-4b02-baca-026dc3e345e0  0/sec     0 bytes/sec</span><span id="e2ff" class="ml kr it lw b gy mq mn l mo mp">connect-offsets-311cea8b-0d94-4b02-baca-026dc3e345e0  0/sec     7 bytes/sec</span><span id="ac1a" class="ml kr it lw b gy mq mn l mo mp">connect-status-311cea8b-0d94-4b02-baca-026dc3e345e0   0/sec     0 bytes/sec heartbeat.witty_connector_44833                       0/sec     12 bytes/sec witty_connector_44833.public.users                    0/sec     0 bytes/sec</span></pre><p id="bede" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们希望主题以<code class="fe lt lu lv lw b">public.users</code>结尾。对我来说，那就是<code class="fe lt lu lv lw b">witty_connector_44833.public.users</code>。如果在创建数据连接器时指定了多个表，您将看到每个表的主题。</p><p id="698d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的演示<code class="fe lt lu lv lw b">kafka-consumer</code>应用程序只使用了一个主题，它是从<code class="fe lt lu lv lw b">KAFKA_TOPIC</code>环境变量中获得的。所以，我们现在可以设置它了。</p><p id="3495" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到您的<code class="fe lt lu lv lw b">kafka-consumer</code>终端会话，运行这个命令(替换您自己的主题名):</p><p id="3402" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lt lu lv lw b">heroku config:set KAFKA_TOPIC=witty_connector_44833.public.users</code></p><p id="3521" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以部署我们的应用程序了:</p><p id="13b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lt lu lv lw b">git push heroku master</code></p><p id="c896" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与<code class="fe lt lu lv lw b">sinatra-postgres-demo</code>应用程序一样，您可能需要等待几分钟才能完成DNS更改。</p><h1 id="a249" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">疾控中心在行动</h1><p id="8d00" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">现在，我们已经准备好了所有的东西:</p><ul class=""><li id="1ebe" class="mz na it js b jt ju jx jy kb nb kf nc kj nd kn ne nf ng nh bi translated">用户列表—我们数据库支持的虚拟平台，<code class="fe lt lu lv lw b">sinatra-postgres-demo</code></li><li id="a78b" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ne nf ng nh bi translated">流数据连接器Beta，每当我们的<code class="fe lt lu lv lw b">users</code>表改变时，它发布事件到Kafka主题</li><li id="b726" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ne nf ng nh bi translated">消息列表——让我们看到卡夫卡事件的<code class="fe lt lu lv lw b">kafka-consumer</code>应用程序</li></ul><p id="355c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在浏览器中，使用表单添加新用户。几秒钟后，您应该会在消息列表应用程序中看到一条JSON消息。</p><figure class="md me mf mg gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mr"><img src="../Images/d5251af3d08079b4a4155fa668d49532.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yigz49A4wJLi-lev"/></div></div></figure><h1 id="8273" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">报文结构</h1><p id="a4f9" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">你能看到的JSON就是卡夫卡事件的“价值”。事件中还有其他元数据，您可以通过调整kafka-consumer应用程序来查看，但是现在让我们只看JSON数据。</p><p id="3de0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以使用<a class="ae ko" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> jq </a>之类的工具来检查JSON，或者粘贴到<a class="ae ko" href="https://jsonformatter.curiousconcept.com/" rel="noopener ugc nofollow" target="_blank">这个</a>之类的在线JSON工具中。</p><p id="ae44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">向下折叠到顶层，您可以看到消息有一个“模式”和一个“有效负载”:</p><figure class="md me mf mg gt ms gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/0654117b8913586de58ec4b391ab11bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/0*Xk2uKrDVEhR42C-B"/></div></figure><p id="0870" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“模式”部分有很多元数据，但大多数时候您可能对“有效负载”更感兴趣，它有“之前”和“之后”部分。这将向您显示数据库记录在报告的更改之前和之后的值。在关于流数据连接器测试版的<a class="ae ko" href="https://devcenter.heroku.com/articles/best-practices-for-heroku-data-connectors#usage" rel="noopener ugc nofollow" target="_blank">最佳实践</a>文档中，有一些关于“之前”的重要警告。</p><figure class="md me mf mg gt ms gh gi paragraph-image"><div class="gh gi no"><img src="../Images/a229fdb66590cc6f31f947475a5ccc19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/0*syv3vrrdmppwPCv6"/></div></figure><p id="5cb9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意“after”部分不包括用户记录的“password”字段。这是因为我们在创建数据连接器时排除了它。</p><h1 id="d82e" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">结论</h1><p id="eca9" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">让我们回顾一下我们已经讲过的内容。</p><ul class=""><li id="4873" class="mz na it js b jt ju jx jy kb nb kf nc kj nd kn ne nf ng nh bi translated">我们从一个数据库支持的web应用程序开始，管理一个<code class="fe lt lu lv lw b">users</code>表。</li><li id="e125" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ne nf ng nh bi translated">我们添加了Kafka和流数据连接器测试版，将对<code class="fe lt lu lv lw b">users</code>表的更改作为Kafka事件发布。</li><li id="856c" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ne nf ng nh bi translated">我们创建了一个单独的应用程序，并将其连接到Kafka主题，并查看数据库更改所生成的消息。</li></ul><p id="3a69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">值得强调的是，我们根本不需要对我们的“monolith”应用程序代码进行任何更改就可以实现这一点。</p><h1 id="b46c" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">清除</h1><p id="2f5a" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">完成后，不要忘记删除您的应用程序，否则您可能最终要为这些服务付费。</p><p id="f86e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以通过在<code class="fe lt lu lv lw b">sinatra-postgres-demo</code>目录和<code class="fe lt lu lv lw b">kafka-consumer</code>目录中运行<code class="fe lt lu lv lw b">make clean</code>来实现。您也可以使用Heroku web界面删除应用程序。</p><p id="6201" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要验证所有内容都已成功删除，您可以运行:</p><p id="fca9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lt lu lv lw b">heroku apps --space ${HEROKU_PRIVATE_SPACE</code></p></div></div>    
</body>
</html>