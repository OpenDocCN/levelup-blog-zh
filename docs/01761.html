<html>
<head>
<title>Building a Text-Based RPG Engine in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python构建基于文本的RPG引擎</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-text-based-rpg-engine-in-python-e571c94500b0?source=collection_archive---------1-----------------------#2020-01-28">https://levelup.gitconnected.com/building-a-text-based-rpg-engine-in-python-e571c94500b0?source=collection_archive---------1-----------------------#2020-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/add47a16f3aad58f338b2197a41a3b19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3jlOi-5_Om68gps3.jpg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来源:<a class="ae kf" href="https://www.youtube.com/watch?v=EJdzuwSF-Fc" rel="noopener ugc nofollow" target="_blank">巨蟒</a></figcaption></figure><p id="17a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">【T2篇】可用波兰语 <a class="ae kf" href="https://bulldogjob.pl/news/1209-budujemy-silnik-gry-rpg-w-pythonie?utm_source=linkedin&amp;utm_medium=organic&amp;utm_campaign=Blog" rel="noopener ugc nofollow" target="_blank"> <em class="le">此处</em> </a> <em class="le">。</em></p><p id="dbe9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我知道你在想什么…什么…为什么会有人想这么做？我的一个正在学习Python的朋友提到他想开发一个基于文本的角色扮演游戏，这让我开始思考。自从我尝试构建上一个基于文本的“游戏”monty.py以来，已经过去了七年，它只是一个简单的Monty Python短剧。这就是为什么我再次尝试用python创建一个基于文本的角色扮演游戏引擎。</p><h2 id="f34e" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">定义我们的输入和输出</h2><p id="1772" class="pw-post-body-paragraph kg kh it ki b kj ly kl km kn lz kp kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">首先，我们需要设定我们的期望。我认为在最简单的形式下，游戏需要做以下事情:</p><ol class=""><li id="2005" class="md me it ki b kj kk kn ko kr mf kv mg kz mh ld mi mj mk ml bi translated">加载包含游戏信息的文件</li><li id="fe3a" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">显示游戏的文本输出</li><li id="dcb3" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">接受玩家的输入</li></ol><p id="b235" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一点很简单。我们需要一些包含数据的文件。我们会用泡菜来包装我们的物品。每个元素的形状将更多地由接下来的两个要求决定。</p><p id="d54d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们希望将输出和输入组合在一起。我们将把它们放在我们称之为页面的东西上。每一页都有一个号码，这样我们就可以跟踪他们。以下是页面的外观:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="e762" class="lf lg it mw b gy na nb l nc nd">1: {<br/>  'text': <br/>  'options':<br/>}</span></pre><p id="435c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不希望只有大块的文本，所以“文本”应该是一个带有字符串的列表元素。这样，在输入一个输入之前，你必须点击通过多行对话。此外，我真的很喜欢它，当它看起来像是文本被输入到屏幕上，所以我们将稍后实现该功能。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="0c95" class="lf lg it mw b gy na nb l nc nd">'text': [<br/>   "This is out first line",<br/>   "And this is our second"<br/>]</span></pre><p id="50b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，对于输入。每个input语句应该有一行文本，然后还有一个指示符，表示当这个输入被选中时，将转到这个页面。因为这些数据是明确定义的，所以我们可以使用元组数组来存储这些数据，如下所示:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="fa16" class="lf lg it mw b gy na nb l nc nd">'options': [<br/>    ("Option 1", 2)<br/>    ("Option 2", 3)<br/>]</span></pre><p id="0a9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们以适当的格式编写了我们的故事，我们可以使用如下的脚本将它包装成二进制pickle文件，该文件可以从我们的引擎中分发和读取。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="bd57" class="lf lg it mw b gy na nb l nc nd">import pickle</span><span id="89e0" class="lf lg it mw b gy ne nb l nc nd">story = {<br/>  1: {<br/>    'Text': [<br/>        "Hello there..",<br/>        "I bet you werent exepecting to hear from me so soon...",<br/>        "...you seem a little confused do you know who I am?"<br/>    ],<br/>    'Options': [<br/>        ("Yeah of course!", 2),<br/>        ("I'm sorry I dont", 3)<br/>    ]<br/>  }<br/>}</span><span id="b0c6" class="lf lg it mw b gy ne nb l nc nd">with open('chapter1.ch', 'wb') as chapter:<br/>    pickle.dump(story, chapter)</span></pre><h2 id="10a0" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">输出文本</h2><p id="a03b" class="pw-post-body-paragraph kg kh it ki b kj ly kl km kn lz kp kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">我们要做的第一件事是弄清楚如何将文本缓慢地输出到屏幕上，就像有人在打字一样。用<a class="ae kf" href="https://stackoverflow.com/questions/4099422/printing-slowly-simulate-typing" rel="noopener ugc nofollow" target="_blank">这个</a>奇妙的解决方案来拯救堆栈溢出。它遍历每个字母，并将其放在输出端。sys.stdout调用提供对命令提示符的低级访问，允许您覆盖Python设置的默认值。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="2dfb" class="lf lg it mw b gy na nb l nc nd">import sys,time,random<br/><br/>def slow_type(t):<br/>    typing_speed = 100 #wpm<br/>    for l in t:<br/>        sys.stdout.write(l)<br/>        sys.stdout.flush()<br/>        time.sleep(random.random()*10.0/typing_speed)</span></pre><p id="58bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好了，现在我们已经解决了慢速打字的问题，我们可以开始真正的工作了。我们说过，我们希望一次打印一页中的每一行文本。当你点击回车键时，它应该移动到下一个输出。下面是这个函数的样子。</p><p id="b1b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它从页面的文本部分获取行列表；然后，它遍历所有的行，缓慢地输入一行，然后等待按下回车键，再移动到下一行。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="19d9" class="lf lg it mw b gy na nb l nc nd">def display_page_text(lines: list):  <br/>    for line in lines:<br/>       slow_type(line)</span><span id="e8d4" class="lf lg it mw b gy ne nb l nc nd">       # Make the user press enter to see the next line <br/>       get_input([''])</span></pre><p id="080f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是等一下！我知道我只是使用了<code class="fe nf ng nh mw b">get_input()</code>而没有展示这个函数是什么样子的。接下来，让我们看看如何获取输入值。</p><h2 id="c4bb" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated"><strong class="ak">接受输入</strong></h2><p id="2a05" class="pw-post-body-paragraph kg kh it ki b kj ly kl km kn lz kp kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">从命令行获得输入并不太糟糕。首先，我们将创建一个函数，它的唯一目的是接受输入。我们将传递给它一个有效输入字符串的列表。然后我们将接受用户输入。如果他们的输入没有列在有效输入列表中，我们会通知用户，告诉他们什么是有效输入，然后清除输入。否则，我们返回输入。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="161b" class="lf lg it mw b gy na nb l nc nd">def get_input(valid_input: list):  <br/>    while True:    <br/>        user_entered = input()    </span><span id="6146" class="lf lg it mw b gy ne nb l nc nd">        if user_entered not in valid_input:      <br/>            print("Invalid input. Please use one \<br/>                   of the following inputs:\n")<br/>            print(valid_input)      <br/>            user_entered = None    </span><span id="487d" class="lf lg it mw b gy ne nb l nc nd">        else:<br/>            return user_entered</span></pre><p id="0266" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们需要回车键，我们可以像前面提到的那样用['']调用get inputs。否则，获取输入的主要用途是决定下一步转到哪个页面。这是get a response函数的工作。向它传递表示选项的元组列表。它们有一个字符串选项，然后是页码，如下所示:(“选项1”，2)。</p><p id="1985" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Get response对元组进行迭代，为选项和选项文本打印一个数字。然后，将有效输入(选项的索引)传入get input函数以获取用户输入。最后，它返回下一个页码。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="de61" class="lf lg it mw b gy na nb l nc nd">def get_response(options: list):<br/>    for index, option in enumerate(options): <br/>        print(index + “. “ + option[0]) <br/>    <br/>    valid_inputs = [str(num) for num in range(len(options))]<br/>    option_index = int(get_input(valid_inputs))<br/> <br/>    return options[option_index][1]</span></pre><h2 id="30b9" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">振作起来</h2><p id="b467" class="pw-post-body-paragraph kg kh it ki b kj ly kl km kn lz kp kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">我们需要做的最后一件事就是把它都拉在一起。当你加载应用程序时，我们需要加载第一页。然后我们建立我们的程序循环。为了退出循环，我们将页面设置为none。</p><p id="33f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们将从story dict中获取当前页面。如果没有页面，那么我们需要跳出这个循环。这样，如果没有提到索引的页面，程序将优雅地退出。</p><p id="566a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">获取页面后，我们将使用之前定义的函数显示页面文本。一旦他们完成了页面文本，我们将获得他们输入的下一个页面。如果列表中没有任何选项，那么我们会说故事结束了，我们可以关闭这个故事了。如果有选项，我们将使用get response函数来获得它们的选择。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="2859" class="lf lg it mw b gy na nb l nc nd">def story_flow(story: dict):  <br/>    curr_page = 1   <br/>    while curr_page != None:    <br/>        page = story.get(curr_page, None)<br/>        if page == None:<br/>            curr_page = None<br/>            break<br/>  <br/>        display_page_text(page['Text'])<br/>        <br/>        if len(page['Options']) == 0:      <br/>            curr_page = None      <br/>            break     <br/>        <br/>        curr_page = get_response(page['Options'])</span></pre><p id="96fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们将让脚本加载pickle文件来播放这个故事。这是如何做到的。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="28bb" class="lf lg it mw b gy na nb l nc nd">import pickle<br/>if __name__ == "__main__":</span><span id="3a9f" class="lf lg it mw b gy ne nb l nc nd">    story= {}</span><span id="3a0e" class="lf lg it mw b gy ne nb l nc nd">    with open('chapter1.ch', 'rb') as file:<br/>        story = pickle.load(file)</span><span id="ee52" class="lf lg it mw b gy ne nb l nc nd">    story_flow(story)    </span></pre><p id="497f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就是这样！查看<a class="ae kf" href="https://github.com/dtaivpp/text_rpg_engine" rel="noopener ugc nofollow" target="_blank"> Github repo </a>看看一个完整的工作示例。还有，恭喜你！如果您遵循了这个示例，那么您已经实现了一个地图数据结构！</p></div></div>    
</body>
</html>