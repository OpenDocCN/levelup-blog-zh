<html>
<head>
<title>Streaming Heart Rate Data with IoT Core and QuestDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用物联网核心和QuestDB传输心率数据</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/streaming-heart-rate-data-with-iot-core-and-questdb-84304069592e?source=collection_archive---------7-----------------------#2021-02-05">https://levelup.gitconnected.com/streaming-heart-rate-data-with-iot-core-and-questdb-84304069592e?source=collection_archive---------7-----------------------#2021-02-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="20ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个简单物联网系统的端到端演示，用于传输和可视化心率数据。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/1133e045090c66bdcbba0b33cdd8ac93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m_6w4yHF3UKsXlLA"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae le" href="https://unsplash.com/@_louisreed?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">路易斯·里德</a>拍摄的照片</figcaption></figure><p id="201a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于健身追踪器和智能手表越来越受欢迎，越来越多的人正在密切跟踪他们的生物识别数据，并将物联网融入他们的日常生活。在我搜索DIY心率追踪器时，我发现了Brandon Freitag和<a class="lf lg ep" href="https://medium.com/u/87b2115d4438?source=post_page-----84304069592e--------------------------------" rel="noopener" target="_blank"> Gabe Weiss </a>的一个出色演示，使用谷歌云服务通过物联网核心和云数据流将数据从带有心率传感器的Raspberry Pi传输到BigQuery。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/d439b65db3d4b99c48b26b14ac044889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/0*POR1pmV-c868f6KM.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图片来源:<a class="ae le" href="https://codelabs.developers.google.com/codelabs/iotcore-heartrate#0" rel="noopener ugc nofollow" target="_blank">谷歌代码实验室</a></figcaption></figure><p id="93e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然Cloud Dataflow支持对BigQuery的流插入，但我想借此机会尝试一下我遇到的一个新的时序数据库，名为<a class="ae le" href="https://questdb.io/" rel="noopener ugc nofollow" target="_blank"> QuestDB </a>。QuestDB是一个具有Postgres兼容性的快速开源时序数据库。网站上的<a class="ae le" href="http://try.questdb.io:9000/" rel="noopener ugc nofollow" target="_blank">现场演示</a>在毫秒内查询了超过16亿行的NYC taxi rides数据集，因此我很高兴尝试一下这个数据库。为了完成端到端的演示，我使用Grafana从QuestDB中提取数据并将其可视化。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi li"><img src="../Images/35f189f97e0211c16447603895b83336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PcFIaFkLgtTSkqMduXZmSg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">数据管道</figcaption></figure><h1 id="f0cd" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">先决条件</h1><ul class=""><li id="c5cf" class="mh mi it js b jt mj jx mk kb ml kf mm kj mn kn mo mp mq mr bi translated">NodeJS v14+</li><li id="6d7f" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">码头工人</li><li id="3844" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><a class="ae le" href="https://console.developers.google.com/billing/freetrial?hl=en&amp;pli=1" rel="noopener ugc nofollow" target="_blank">谷歌云账户</a></li><li id="6324" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><a class="ae le" href="https://cloud.google.com/sdk/docs/install" rel="noopener ugc nofollow" target="_blank"> gcloud sdk </a></li><li id="7e57" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><em class="mx">可选</em> : <a class="ae le" href="https://www.arrow.com/en/research-and-events/articles/codelabs-using-iot-core-to-stream-heart-rate-data" rel="noopener ugc nofollow" target="_blank"> <em class="mx">树莓派套装</em> </a></li></ul><p id="4207" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本教程中，我们将使用一个Debian映像通过IoT Core运行模拟心率数据。如果您希望从Raspberry Pi发送真实的传感器数据，请购买上面列出的可选套件，并遵循<a class="ae le" href="https://codelabs.developers.google.com/codelabs/iotcore-heartrate#6" rel="noopener ugc nofollow" target="_blank">安装说明</a>。</p><h1 id="9c53" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">Google云设置</h1><p id="a914" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">为了使用Cloud IoT Core和Cloud Pub/Sub，你需要先创建一个Google云平台账号和一个新项目(我的叫做<code class="fe nb nc nd ne b">questdb-iot-demo</code>)。然后，在API&amp;服务- &gt;启用API和服务- &gt;搜索API&amp;服务下启用物联网核心、计算引擎和发布/订阅API:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/f8b0b20f01df9d812f9b1cf23399ac8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*JASmiIHrAIw-ZNWktXmE0g.png"/></div></figure><h2 id="8eb9" class="ng lk it bd ll nh ni dn lp nj nk dp lt kb nl nm lx kf nn no mb kj np nq mf nr bi translated">物联网核心设置</h2><p id="cda8" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">物联网核心是谷歌全面管理的物联网服务，有助于安全连接和管理物联网设备。在这个演示中，我们将创建一个名为<code class="fe nb nc nd ne b">heartrate</code>的注册中心，并发送MQTT数据。点击“创建注册表”，根据离你最近的地理区域设置注册表ID和区域(对我来说是<code class="fe nb nc nd ne b">us-central1</code>):</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/40f0b06803084dc891875a77c96b3182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*pI-2zJUOaNOi6NPeVVJ1mw.png"/></div></figure><p id="e2fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们需要配置一个发布/订阅主题来发布设备数据。在“选择一个云发布/订阅主题”下，单击“创建一个主题”，并为其指定主题ID <code class="fe nb nc nd ne b">heartratedata</code>:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nt"><img src="../Images/925841fedebfcaccfc2b6180d52cd3f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z18ffFaCdBURZO60qX1Y7A.png"/></div></div></figure><p id="a202" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">配置“注册表属性”和“云发布/订阅主题”后，单击“创建”。</p><h2 id="7002" class="ng lk it bd ll nh ni dn lp nj nk dp lt kb nl nm lx kf nn no mb kj np nq mf nr bi translated">计算引擎设置</h2><p id="8ee7" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">现在是时候添加我们的模拟设备了。为了让我们的设备与物联网核心通信，我们需要添加一个公钥。前往计算引擎-&gt;创建。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nu"><img src="../Images/faec99b3cc8ad1dce23434e357685400.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E37dquvwXKb0xf28dNFVyg.png"/></div></div></figure><p id="845e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认选项(e2-medium、Debian 10 image、us-central1)将适用于我们的模拟器(<em class="mx">注意:如果您选择了</em> <code class="fe nb nc nd ne b"><em class="mx">us-central1</em></code> <em class="mx"> </em>以外的区域，请确保该区域与物联网核心注册表区域相匹配)。一旦虚拟机准备就绪，单击“Connect”下的SSH按钮并安装项目代码:</p><pre class="kp kq kr ks gt nv ne nw nx aw ny bi"><span id="036c" class="ng lk it ne b gy nz oa l ob oc"># Install git<br/>sudo apt-get update<br/>sudo apt-get install git</span><span id="ed37" class="ng lk it ne b gy od oa l ob oc"># Clone project code<br/>git clone <a class="ae le" href="https://github.com/googlecodelabs/iotcore-heartrate" rel="noopener ugc nofollow" target="_blank">https://github.com/googlecodelabs/iotcore-heartrate</a><br/>cd <!-- -->iotcore-heartrate</span><span id="02e8" class="ng lk it ne b gy od oa l ob oc"># Install all the core packages<br/>chmod +x initialsoftware.sh<br/>./initialsoftware.sh</span><span id="b55b" class="ng lk it ne b gy od oa l ob oc"># Generate the keys<br/>chmod +x generate_keys.sh<br/>./generate_keys.sh</span><span id="94b8" class="ng lk it ne b gy od oa l ob oc"># View the keys (highlighting will copy the contents)<br/>cat ../.ssh/ec_public.pem</span></pre><h2 id="45d6" class="ng lk it bd ll nh ni dn lp nj nk dp lt kb nl nm lx kf nn no mb kj np nq mf nr bi translated">物联网设备设置</h2><p id="b093" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">一旦你有了<code class="fe nb nc nd ne b">ec_public.pem</code>键，回到物联网核心注册表。在“设备”下，单击“创建设备”。对于设备ID，输入<code class="fe nb nc nd ne b">raspberryHeartRate</code>并展开“通信、云日志、认证”下拉菜单:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/30b2471dd8e99a060aaca670444940ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*ZeqjhCAVqyJ3VhKEbdNc1Q.png"/></div></figure><p id="f688" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在身份验证下，将“公钥格式”更改为<code class="fe nb nc nd ne b">ES256</code>，并从我们的虚拟机或Raspberry Pi中粘贴密钥，然后单击“创建”:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi of"><img src="../Images/1beee61f2f0bb735e400e634245e53c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*vXv2Qb2xSqKZnvcKjD_3BQ.png"/></div></figure><h2 id="5729" class="ng lk it bd ll nh ni dn lp nj nk dp lt kb nl nm lx kf nn no mb kj np nq mf nr bi translated">发布/订阅设置</h2><p id="31dc" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">最后，我们需要为我们的发布/订阅主题创建一个订阅，以提取消息并插入到QuestDB中。前往“发布/订阅”并点击我们的<code class="fe nb nc nd ne b">heartratedata</code>主题。将订阅命名为<code class="fe nb nc nd ne b">questdb</code>并单击create。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/562404c6d687a6d109562b4f49c3fe81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E8RlFLMkdfJVDvtVk4bE1w.png"/></div></div></figure><h1 id="246b" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">QuestDB设置</h1><p id="143d" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">此时，我们在Google Cloud上拥有了向我们的发布/订阅主题发送数据的一切。现在我们需要编写一些代码来获取这些消息，并将它们插入到QuestDB中。让我们从通过Docker启动QuestDB开始。</p><pre class="kp kq kr ks gt nv ne nw nx aw ny bi"><span id="f453" class="ng lk it ne b gy nz oa l ob oc">docker run -p 9000:9000 -p 8812:8812 questdb/questdb</span></pre><p id="993d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的命令提取最新的QuestDB映像(v5.0.6)并映射控制台UI的端口<code class="fe nb nc nd ne b">9000</code>和Postgres操作的端口<code class="fe nb nc nd ne b">8812</code>。在(<a class="ae le" href="http://127.0.0.1:9000/" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:9000/ </a>)打开QuestDB控制台，并创建我们的<code class="fe nb nc nd ne b">heart_rate</code>表:</p><pre class="kp kq kr ks gt nv ne nw nx aw ny bi"><span id="716e" class="ng lk it ne b gy nz oa l ob oc">CREATE TABLE heart_rate(sensorID STRING, uniqueID STRING, timecollected TIMESTAMP, heartrate DOUBLE);</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oh"><img src="../Images/a850edf7981e132881894a9bdf0211de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4zKbzzD3sM8Cf8Zn426SiA.png"/></div></div></figure><p id="e8c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(<em class="mx">注意:UI不会自动刷新，因此如果您在tables面板上没有看到填充的</em> <code class="fe nb nc nd ne b"><em class="mx">heart_rate</em></code> <em class="mx">表，请单击表上方的刷新图标。</em>)</p><h2 id="cdd3" class="ng lk it bd ll nh ni dn lp nj nk dp lt kb nl nm lx kf nn no mb kj np nq mf nr bi translated">发布/订阅到QuestDB</h2><p id="1eaa" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">由于没有针对发布/订阅的本地集成，我们将需要编写一个简单的程序来侦听新的发布/订阅消息，并将数据插入到QuestDB中。我使用的是NodeJS v14.15.4，但是您可以为Pub/Sub和Postgres使用类似的客户端库来实现相同的目的。</p><p id="c825" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，将gcloud sdk配置为使用您的GCP项目进行身份验证，而无需下载服务帐户(有关更多详细信息，请参见<a class="ae le" href="https://medium.com/dev-genius/simple-gcp-authentication-with-service-accounts-6b877c2e2649" rel="noopener">使用服务帐户的简单GCP身份验证</a>)。</p><pre class="kp kq kr ks gt nv ne nw nx aw ny bi"><span id="e77c" class="ng lk it ne b gy nz oa l ob oc"># Set default profile<br/>$ gcloud auth application-default login</span></pre><p id="f209" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，创建一个新的NodeJS工作区，并安装<code class="fe nb nc nd ne b">@google-cloud/pubsub</code>和<code class="fe nb nc nd ne b">pg</code>库。您可以使用下面的代码来侦听Pub/Sub并流式传输到QuestDB。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="527e" class="ng lk it bd ll nh ni dn lp nj nk dp lt kb nl nm lx kf nn no mb kj np nq mf nr bi translated">发送数据</h2><p id="d86a" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">最后，我们准备发送模拟数据。切换回计算引擎，并再次ssh到虚拟机。发出以下命令，将数据发送到我们的物联网核心设备:</p><pre class="kp kq kr ks gt nv ne nw nx aw ny bi"><span id="4894" class="ng lk it ne b gy nz oa l ob oc">$ python heartrateSimulator.py --project_id=questdb-iot-demo --registry_id=heartrate --device_id=raspberryHeartRate --private_key_file=../.ssh/ec_private.pem</span></pre><p id="b44b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果成功，您应该会看到如下日志:</p><pre class="kp kq kr ks gt nv ne nw nx aw ny bi"><span id="cfc3" class="ng lk it ne b gy nz oa l ob oc">...<br/>Publishing message #544: '{"sensorID": "heartrate.raspZero", "heartrate": 72.56881801680139, "uniqueID": "c1ca9656-671f-4fa7-8c03-12fdfb4f422f-heartrate.raspZero", "timecollected": "2018-07-07 20:54:50"}'Publishing message #545: '{"sensorID": "heartrate.raspZero", "heartrate": 72.8324264524384, "uniqueID": "8d6337b7-204f-4209-88c0-46a79d1911bb-heartrate.raspZero", "timecollected": "2018-07-07 20:54:59"}'<br/>Finished.</span></pre><p id="31f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在运行我们的NodeJS代码，我们应该看到QuestDB中填充了数据:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ok"><img src="../Images/abefc48c4bcd1bd577f8c88bbfc29e9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WtWKc4mVd8S96CTyj8obeg.png"/></div></div></figure><h1 id="724e" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">用Grafana可视化数据</h1><p id="d49b" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">虽然QuestDB控制台提供了一些现成的默认可视化，但为了模拟将所有指标组合到Grafana的更真实的场景，我们将设置一个Postgres数据源并可视化我们的心率数据。</p><p id="6c0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下载Grafana并使用admin/admin登录到<a class="ae le" href="http://localhost:3000/login" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/log in</a></p><pre class="kp kq kr ks gt nv ne nw nx aw ny bi"><span id="c614" class="ng lk it ne b gy nz oa l ob oc">$ docker run -p 3000:3000 grafana/grafana</span></pre><p id="6332" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在“配置”-&gt;“数据源”下，搜索PostgreSQL。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ol"><img src="../Images/bd1664eadd0e0dba3b61ed71844270e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aOiJOAGcOGa-ebyaCb3P3A.png"/></div></div></figure><p id="23b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于PostgreSQL连接，输入以下内容(密码:quest)并保存</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi om"><img src="../Images/381b816ad72b87ff46c7413af6e2ebca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ld-vyY53sO0IeFzVkL8vaw.png"/></div></div></figure><p id="96a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，让我们创建一个仪表板。创建仪表板并添加以下SQL查询:</p><pre class="kp kq kr ks gt nv ne nw nx aw ny bi"><span id="580f" class="ng lk it ne b gy nz oa l ob oc">SELECT<br/>  timecollected AS "time",<br/>  heartrate<br/>FROM heart_rate <br/>ORDER BY time;</span></pre><p id="7ab0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们来看看心率数据样本:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi on"><img src="../Images/d6867e09f7d6bb7f0e0499abb98934f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yD7pPkHLvsPUjRc_5HAVrg.png"/></div></div></figure><p id="e16e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">顺便提一下，可以在QuestDB控制台上绘制相同的图表:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oo"><img src="../Images/42ac46e1f1f238cfb61d6bae38ed5125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SlCNCxOXEWbJW31WUtmf6w.png"/></div></div></figure><p id="7f66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此时，我们有了一个设备的端到端系统，可以通过物联网核心安全地发送数据，并将数据传输到QuestDB。我们可以将这个示例扩展到多个设备，方法是将它们添加到IoT Core下，并扩展我们的服务器以使用池化连接来更有效地将数据添加到QuestDB。在标度上，我们还可以查看平均心率，而不是原始数据点(例如<code class="fe nb nc nd ne b">avg(heartrate) as average_heartrate from heart_rate</code>)。</p></div></div>    
</body>
</html>