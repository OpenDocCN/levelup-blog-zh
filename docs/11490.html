<html>
<head>
<title>Learn the basics and get started with SQLAlchemy ORM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习基础知识并开始使用SQLAlchemy ORM</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learn-the-basics-and-get-started-with-sqlalchemy-orm-from-scratch-66c8624b069?source=collection_archive---------0-----------------------#2022-03-21">https://levelup.gitconnected.com/learn-the-basics-and-get-started-with-sqlalchemy-orm-from-scratch-66c8624b069?source=collection_archive---------0-----------------------#2022-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f79d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们以Pythonic的方式与数据库交互</h2></div><p id="365c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经介绍了如何用Python中的SQLAlchemy执行普通的SQL查询，如果您是SQL高手，但还不太了解Python或SQLAlchemy，这会很方便。然而，一旦你足够熟悉了，你就会想要编写更多的pythonic代码来与数据库交互，这可以通过SQLAlchemy<strong class="kk iu">O</strong>object<strong class="kk iu">R</strong>relational<strong class="kk iu">M</strong>apper(<strong class="kk iu">ORM</strong>)来实现。</p><blockquote class="le lf lg"><p id="9d1a" class="ki kj lh kk b kl km ju kn ko kp jx kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated"><a class="ae ll" href="https://docs.sqlalchemy.org/en/14/orm/tutorial.html" rel="noopener ugc nofollow" target="_blank"> ORM </a>提供了一种将用户定义的Python类与数据库表相关联的方法，以及将这些类(对象)的实例与它们对应的表中的行相关联的方法。</p></blockquote><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/c0cd7dbe447af658bec9b9b9c8588ba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wrvas_LBnXOoMK9g.jpg"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">图片来自<a class="ae ll" href="https://pixabay.com/illustrations/server-servers-data-computer-5451985/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>。</figcaption></figure><p id="cc54" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">ORM第一次使用时可能会让人不知所措，因为有很多新概念和CRUD操作的特殊语法。在这篇文章中，我们将介绍最常见的概念，并为常见的CRUD操作提供易于遵循的分步说明。在这篇文章之后，你会得到一个ORM的快速入门或者更新。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="865f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">强烈建议先查看<a class="ae ll" href="https://lynn-kwong.medium.com/how-to-execute-plain-sql-queries-with-sqlalchemy-627a3741fdb1" rel="noopener">关于普通SQL查询的帖子</a>，因为那里有关于系统设置和非常基础的概念的详细介绍，如方言、驱动程序、引擎、连接等。然而，这不是强制性的。您可以按照下面的基本步骤来设置本教程的环境。或者你可以通读代码和解释，也会学到很多东西，特别是当你想快速刷新的时候。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="6b08" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于本教程，我们需要有一个本地运行的MySQL服务器。出于学习目的，建议使用Docker在本地启动一个MySQL容器。这样，您可以使用任何版本的MySQL，并且可以避免潜在的端口冲突。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mf mg l"/></div></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="61a5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在使用SQLAlchemy连接到我们的数据库并创建一些ORM模型之前，我们需要安装这个包及其依赖项。建议在虚拟环境<a class="ae ll" href="https://medium.com/codex/how-to-create-virtual-environments-with-venv-and-conda-in-python-31814c0a8ec2" rel="noopener">中安装软件包</a>，这样就不会弄乱你的系统库。你可以使用<em class="lh"> venv </em>或<em class="lh"> conda </em>在Python中创建一个虚拟环境。推荐使用<a class="ae ll" href="https://medium.com/codex/how-to-create-virtual-environments-with-venv-and-conda-in-python-31814c0a8ec2" rel="noopener"> <em class="lh">康达</em> </a>，因为可以在虚拟环境中安装特定版本的Python:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="8373" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为本教程安装的软件包:</p><ul class=""><li id="528a" class="mh mi it kk b kl km ko kp kr mj kv mk kz ml ld mm mn mo mp bi translated"><a class="ae ll" href="https://pypi.org/project/SQLAlchemy/" rel="noopener ugc nofollow" target="_blank"> <em class="lh"> SQLAlchemy </em> </a> —将用于与数据库交互的主包。</li><li id="cf30" class="mh mi it kk b kl mq ko mr kr ms kv mt kz mu ld mm mn mo mp bi translated"><a class="ae ll" href="https://pypi.org/project/SQLAlchemy-Utils/" rel="noopener ugc nofollow" target="_blank"><em class="lh">SQLAlchemy-Utils</em></a>—为SQLAlchemy提供各种实用函数。</li><li id="d20c" class="mh mi it kk b kl mq ko mr kr ms kv mt kz mu ld mm mn mo mp bi translated"><a class="ae ll" href="https://github.com/agronholm/sqlacodegen" rel="noopener ugc nofollow" target="_blank"><em class="lh">sqlacodegen</em></a>—一个读取现有数据库结构并生成适当的SQLAlchemy模型代码的工具。</li><li id="890e" class="mh mi it kk b kl mq ko mr kr ms kv mt kz mu ld mm mn mo mp bi translated"><a class="ae ll" href="https://pypi.org/project/PyMySQL/" rel="noopener ugc nofollow" target="_blank"><em class="lh">PyMySQL</em></a>—SQLAlchemy使用它来连接MySQL数据库并与之交互，如果您想了解为什么选择PyMySQL，请查看<a class="ae ll" href="https://lynn-kwong.medium.com/how-to-execute-plain-sql-queries-with-sqlalchemy-627a3741fdb1" rel="noopener">这篇文章</a>。</li><li id="ded0" class="mh mi it kk b kl mq ko mr kr ms kv mt kz mu ld mm mn mo mp bi translated"><a class="ae ll" href="https://pypi.org/project/cryptography/" rel="noopener ugc nofollow" target="_blank"> <em class="lh">密码术</em> </a> —被SQLAlchemy用于认证。</li><li id="0ab1" class="mh mi it kk b kl mq ko mr kr ms kv mt kz mu ld mm mn mo mp bi translated"><a class="ae ll" href="https://pypi.org/project/ipython/" rel="noopener ugc nofollow" target="_blank"> <em class="lh"> ipython </em> </a> —用于更方便地执行交互式python代码。</li></ul></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="24f6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在一切都准备好了，我们可以开始使用SQLAlchemy ORM了。</p><p id="8e8a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似于使用SQLAlchemy处理普通SQL查询的过程，我们需要创建一个<a class="ae ll" href="https://docs.sqlalchemy.org/en/14/core/engines.html" rel="noopener ugc nofollow" target="_blank">引擎</a>，这是任何SQLAlchemy应用程序的起点。</p><p id="2e8a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要创建引擎实例，我们需要首先定义一个数据库URL，其格式如下:</p><pre class="ln lo lp lq gt mv mw mx my aw mz bi"><span id="4301" class="na nb it mw b gy nc nd l ne nf"><strong class="mw iu">dialect[+driver]://user:password@host:port/dbname</strong></span></pre><ul class=""><li id="fdbc" class="mh mi it kk b kl km ko kp kr mj kv mk kz ml ld mm mn mo mp bi translated">方言——上面介绍的方言，可以是<code class="fe ng nh ni mw b">mysql</code>、<code class="fe ng nh ni mw b">postgresql</code>等。</li><li id="416e" class="mh mi it kk b kl mq ko mr kr ms kv mt kz mu ld mm mn mo mp bi translated">driver —用于连接数据库并与之交互的DBAPI的名称，它是上面安装的PyMySQL库。</li><li id="082b" class="mh mi it kk b kl mq ko mr kr ms kv mt kz mu ld mm mn mo mp bi translated">用户、口令、主机、端口、数据库名-目标数据库的用户名、口令、主机名、端口和默认数据库/模式。请在实践中针对自己的案例使用相应的。</li></ul><p id="e114" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们为MySQL数据库创建一个引擎，从上面的Docker容器开始:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated"><a class="ae ll" href="https://gist.github.com/lynnkwong/99ec7db1c23e577f3025b1f84d005e0a" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/lynnkwong/99 EC 7 db 1c 23 e 577 f 3025 B1 f 84d 005 e0a</a></figcaption></figure><p id="2746" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ng nh ni mw b">pool_size</code>和<code class="fe ng nh ni mw b">pool_recycle</code>分别定义了池中有多少个连接(5)将保持打开，以及多长时间(3600秒)后一个连接将被回收到池中。这样，我们可以控制活动连接的数量，并且不会有已经关闭的过时连接。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="6437" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与普通的SQL查询不同，我们不需要直接创建一个<a class="ae ll" href="https://docs.sqlalchemy.org/en/14/core/connections.html#sqlalchemy.engine.Connection" rel="noopener ugc nofollow" target="_blank">连接</a>。相反，我们将创建一个<a class="ae ll" href="https://docs.sqlalchemy.org/en/14/orm/session_api.html#sqlalchemy.orm.Session" rel="noopener ugc nofollow" target="_blank">会话</a>，它是ORM的数据库“句柄”。会话在幕后创建和关闭连接实例，我们不需要担心细节。</p><p id="42ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建会话的首选方式如下:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="0001" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管我们可以直接使用<code class="fe ng nh ni mw b">session_factory</code>(它产生会话实例),但是最好使用作用域会话工厂(按照惯例由<code class="fe ng nh ni mw b">Session</code>调用),因为在同一个线程中调用时，它会产生相同的<code class="fe ng nh ni mw b">Session</code>实例:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="2287" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，作用域会话工厂在第二次被调用时“神奇地”产生了同一个<code class="fe ng nh ni mw b">Session</code>实例。</p><p id="97fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，应该注意的是<code class="fe ng nh ni mw b">Session</code>不是线程安全的，我们需要为每个线程创建一个新的<code class="fe ng nh ni mw b">Session</code>，这可以通过<code class="fe ng nh ni mw b">threading.local()</code>方法来实现:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="e634" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有关如何用<em class="lh">多线程</em>编写并发Python代码的更多信息，请查看<a class="ae ll" href="https://lynn-kwong.medium.com/how-to-write-concurrent-python-code-with-multithreading-b24dec228c43" rel="noopener">这篇文章</a>。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="145f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在SQLAlchemy的“句柄”已经准备好了，我们需要创建一个ORM模型，它只是一个普通的Python类，在我们的数据库中定义一个表。</p><p id="17f0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用现代的SQLAlchemy，ORM模型是使用声明性系统创建的，该声明性系统使用一个公共的声明性基类:</p><pre class="ln lo lp lq gt mv mw mx my aw mz bi"><span id="73b3" class="na nb it mw b gy nc nd l ne nf">&gt;&gt;&gt; <strong class="mw iu">from sqlalchemy.orm import declarative_base</strong></span><span id="b8f0" class="na nb it mw b gy nj nd l ne nf">&gt;&gt;&gt; <strong class="mw iu">Base = declarative_base()</strong></span></pre><p id="4c5b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">声明性基类<code class="fe ng nh ni mw b">Base</code>作为一个注册表工作，并维护用它创建的类和表的目录。在所有通常导入的模块中，通常应该只有一个声明性基类。这个声明性基类应该被所有ORM类继承。重要的是，带有外键约束的表的ORM类必须使用相同的基类，否则将引发异常。</p><p id="cd83" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们使用与<a class="ae ll" href="https://lynn-kwong.medium.com/how-to-execute-plain-sql-queries-with-sqlalchemy-627a3741fdb1" rel="noopener">普通SQL查询</a>相同的例子，并为<code class="fe ng nh ni mw b">data</code>模式中的<code class="fe ng nh ni mw b">product_stocks</code>表创建一个ORM类:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="876d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们刚刚创建了一个ORM类<code class="fe ng nh ni mw b">ProductStock</code>，它被映射到<code class="fe ng nh ni mw b">product_stocks</code>表。这个类继承了<code class="fe ng nh ni mw b">Base</code>类，所以它被编目在<code class="fe ng nh ni mw b">Base</code>类的元数据中。如您所见，手动创建ORM类相当麻烦。一旦我们创建了数据库和表，我们将介绍一个更方便的方法。</p><p id="1cb1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您没有遵循普通SQL查询的教程，您的本地MySQL服务器上就不会有<code class="fe ng nh ni mw b">data</code>数据库和<code class="fe ng nh ni mw b">product_stocks</code>表。我们可以在MySQL控制台中创建数据库和表，但是我想向您展示一些不同的、更酷的、更Pythonic化的东西。</p><p id="f791" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将用<a class="ae ll" href="https://sqlalchemy-utils.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy-Utils </a>库创建数据库，该库为SQLAlchemy提供各种实用函数:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="49de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ng nh ni mw b">db_url</code>与用来制造引擎的是同一个。它被从<em class="lh"> SQLAlchemy-Utils </em>库中传递给<code class="fe ng nh ni mw b">create_database()</code>函数，以创建目标数据库，在本例中是<code class="fe ng nh ni mw b">data</code>。需要注意的是，如果要创建的数据库已经存在，那么<code class="fe ng nh ni mw b">create_database()</code>会引发一个异常，因此我们需要使用同一个库中的<code class="fe ng nh ni mw b">database_exists()</code>函数来检查数据库在创建之前是否已经存在。</p><p id="eaf4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行上面的命令时，应该会创建<code class="fe ng nh ni mw b">data</code>模式(如果还没有创建的话)。然后，我们可以使用神奇的<code class="fe ng nh ni mw b">Base</code>类来创建<code class="fe ng nh ni mw b">product_stocks</code>表，上面为其定义了一个ORM类。从技术上来说，使用了<code class="fe ng nh ni mw b">Base</code>类的<code class="fe ng nh ni mw b">metadata</code>，它将创建所有ORM类继承这个<code class="fe ng nh ni mw b">Base</code>类的表:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="4425" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ng nh ni mw b"><a class="ae ll" href="https://docs.sqlalchemy.org/en/14/core/metadata.html#sqlalchemy.schema.MetaData.create_all" rel="noopener ugc nofollow" target="_blank">MetaData.create_all()</a></code>方法创建存储在<code class="fe ng nh ni mw b">Base</code>类的元数据中的所有表。默认情况下，将跳过已经存在的表，并且不会引发任何异常。</p><p id="1c22" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当运行上面的命令时，应该在<code class="fe ng nh ni mw b">data</code>模式中创建<code class="fe ng nh ni mw b">product_stocks</code>表(如果没有提前创建的话)。</p><p id="0152" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们上面提到的，手工从头开始创建一个ORM类非常麻烦。如果您已经预先创建了表(这在实践中很常见)，您可以使用<a class="ae ll" href="https://github.com/agronholm/sqlacodegen" rel="noopener ugc nofollow" target="_blank"> <em class="lh"> sqlacodegen </em> </a>库自动为表生成一个ORM类:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="f982" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一名数据工程师或软件工程师，您应该非常了解SQL语法。对于您来说，提前创建一个表并优化项目数据库中的索引，然后使用如上所示的<em class="lh"> sqlacodegen </em>库为其创建一个ORM类会更加自然。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="d1e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，数据库、表和orm类都准备好了，我们可以开始用ORM语法执行一些基本的CRUD操作。</p><p id="1c3b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在开始之前，让我们稍微组织一下代码，并将逻辑上相关的代码移到单独的模块中，这样我们就不需要重复代码了。组织代码可在<a class="ae ll" href="https://github.com/lynnkwong/sqlalchemy_orm_basic" rel="noopener ugc nofollow" target="_blank">本报告</a>中找到。</p><p id="ea0a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">DB连接代码将放在一个名为<code class="fe ng nh ni mw b"><a class="ae ll" href="https://github.com/lynnkwong/sqlalchemy_orm_basic/blob/main/db_connection.py" rel="noopener ugc nofollow" target="_blank">db_connection.py</a></code>的模块中:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="567a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ng nh ni mw b">Base</code>类和它的<code class="fe ng nh ni mw b">metadata</code>放在一个名为<code class="fe ng nh ni mw b"><a class="ae ll" href="https://github.com/lynnkwong/sqlalchemy_orm_basic/blob/main/orm_base.py" rel="noopener ugc nofollow" target="_blank">orm_base.py</a></code>的独立模块中，因此它可以被其他ORM类使用，这将在以后的教程中介绍:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="617f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们为<code class="fe ng nh ni mw b">Base</code>类指定了一个默认模式(<code class="fe ng nh ni mw b">data</code>)。这样，当使用多个模式时，如果模式是<code class="fe ng nh ni mw b">data</code>，我们不需要指定一个模式。这个后面也会更详细的介绍。</p><p id="d83b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">表<code class="fe ng nh ni mw b">product_stocks</code>的ORM类保存在一个单独的模块中，删除了<code class="fe ng nh ni mw b">Base</code>类的代码。为了更好地组织代码，为每个单独的表创建一个单独的ORM模块是一个很好的实践。如果所有表的所有ORM类都保存在同一个文件中，将很难阅读和维护。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mf mg l"/></div></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="6b75" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们先用ORM创造一个记录。。正如我们已经知道的，ORM类被映射到一个表，而类的实例被映射到表的行。让我们创建一个<code class="fe ng nh ni mw b">ProductStock</code>类的实例，并将它作为一行保存到数据库中。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="2a0c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此代码片段的注释:</p><ul class=""><li id="84ac" class="mh mi it kk b kl km ko kp kr mj kv mk kz ml ld mm mn mo mp bi translated">ORM类的工作方式就像普通的Python类一样。如果你有敏锐的眼光，你可能会注意到我们没有为ORM类创建一个<code class="fe ng nh ni mw b">__init__()</code>方法，它是由SQLAlchemy在幕后创建的。</li><li id="27dd" class="mh mi it kk b kl mq ko mr kr ms kv mt kz mu ld mm mn mo mp bi translated">我们可以使用<code class="fe ng nh ni mw b">Session</code>作为上下文管理器，所以当数据库操作完成或失败时，我们不需要显式关闭<code class="fe ng nh ni mw b">Session</code>。</li><li id="d1ec" class="mh mi it kk b kl mq ko mr kr ms kv mt kz mu ld mm mn mo mp bi translated">我们需要向<code class="fe ng nh ni mw b">Session</code>实例添加一个ORM实例，然后调用<code class="fe ng nh ni mw b">commit()</code>方法将它保存到数据库中。如果需要添加多个ORM实例，可以调用<code class="fe ng nh ni mw b">Session</code>的<code class="fe ng nh ni mw b">add_all()</code>方法。</li></ul><p id="fb5f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果在MySQL控制台中查询该表，可以看到刚刚插入的记录:</p><pre class="ln lo lp lq gt mv mw mx my aw mz bi"><span id="4aaa" class="na nb it mw b gy nc nd l ne nf">mysql&gt; <strong class="mw iu">SELECT</strong> * <strong class="mw iu">FROM</strong> data.product_stocks;<br/>+----------+----------+-------+---------------------+<br/>| stock_id | category | stock | check_time          |<br/>+----------+----------+-------+---------------------+<br/>|        1 | Laptops  |   999 | 2022-03-20 23:04:39 |<br/>+----------+----------+-------+---------------------+<br/>1 row in set (0,00 sec)</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="2e1a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们来看看刚刚创造的记录。我们需要调用<code class="fe ng nh ni mw b">query()</code>方法并用<code class="fe ng nh ni mw b">filter()</code>或<code class="fe ng nh ni mw b">filter_by()</code>方法链接它。使用这些方法，事情会变得相当复杂，但我们在这里只是触及了表面:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="ddaa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此代码片段的注释:</p><ul class=""><li id="d47d" class="mh mi it kk b kl km ko kp kr mj kv mk kz ml ld mm mn mo mp bi translated">我们首先以<code class="fe ng nh ni mw b">ProductStock</code>类为参数调用<code class="fe ng nh ni mw b">Session</code>的<code class="fe ng nh ni mw b">query()</code>方法，然后调用<code class="fe ng nh ni mw b">filter()</code>或<code class="fe ng nh ni mw b">filter_by()</code>方法按照指定的条件进行过滤。</li><li id="9429" class="mh mi it kk b kl mq ko mr kr ms kv mt kz mu ld mm mn mo mp bi translated"><code class="fe ng nh ni mw b">filter()</code>是使用SQLAlchemy ORM语法通过某些条件过滤<a class="ae ll" href="https://docs.sqlalchemy.org/en/14/orm/query.html" rel="noopener ugc nofollow" target="_blank">查询</a>的本地方式。它支持非常强大的过滤语法，这将在后面的教程中介绍。现在，您只需要知道您需要指定类和属性，并且必须使用双等号，而不是像<code class="fe ng nh ni mw b">filter_by()</code>那样使用单等号。</li><li id="71e1" class="mh mi it kk b kl mq ko mr kr ms kv mt kz mu ld mm mn mo mp bi translated"><code class="fe ng nh ni mw b">filter_by()</code>用于使用常规kwargs对列名进行简单查询。</li><li id="eb11" class="mh mi it kk b kl mq ko mr kr ms kv mt kz mu ld mm mn mo mp bi translated">如您所见，<code class="fe ng nh ni mw b">query()</code>和f <code class="fe ng nh ni mw b">ilter()</code> / <code class="fe ng nh ni mw b">filter_by()</code>方法的结果可以链接在一起。如果需要，我们可以链接更多的<code class="fe ng nh ni mw b">filter()</code> / <code class="fe ng nh ni mw b">filter_by()</code>方法。</li><li id="d265" class="mh mi it kk b kl mq ko mr kr ms kv mt kz mu ld mm mn mo mp bi translated"><code class="fe ng nh ni mw b">first()</code>方法返回查询的第一个结果。如果没有结果，将返回<code class="fe ng nh ni mw b">None</code>。如果我们想从查询中获得所有结果，我们可以使用<code class="fe ng nh ni mw b">all()</code>方法，它将返回一个结果列表，如果没有结果，则返回一个空列表。</li><li id="df65" class="mh mi it kk b kl mq ko mr kr ms kv mt kz mu ld mm mn mo mp bi translated">我们可以用结果的属性访问数据，结果是一个ORM实例。</li></ul></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="617d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们现在更新这个记录。我们把股票设为1000吧。要更新记录，我们需要首先找到记录，然后更新它，这非常简单:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="aab2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果在MySQL控制台中查询该表，可以看到记录的更新数据:</p><pre class="ln lo lp lq gt mv mw mx my aw mz bi"><span id="bdfc" class="na nb it mw b gy nc nd l ne nf">mysql&gt; <strong class="mw iu">SELECT</strong> * <strong class="mw iu">FROM</strong> data.product_stocks;<br/>+----------+----------+-------+---------------------+<br/>| stock_id | category | stock | check_time          |<br/>+----------+----------+-------+---------------------+<br/>|        1 | Laptops  |  1000 | 2022-03-20 23:04:39 |<br/>+----------+----------+-------+---------------------+<br/>1 row in set (0,00 sec)</span></pre><p id="c119" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你需要在MySQL中使用<a class="ae ll" href="https://en.wiktionary.org/wiki/upsert" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu"><em class="lh">upsert</em></strong></a>或<code class="fe ng nh ni mw b">ON DUPLICATE KEY UPDATE</code>语法，你可以使用<code class="fe ng nh ni mw b">merge()</code>方法:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><pre class="ln lo lp lq gt mv mw mx my aw mz bi"><span id="26d8" class="na nb it mw b gy nc nd l ne nf">mysql&gt; <strong class="mw iu">SELECT</strong> * <strong class="mw iu">FROM</strong> data.product_stocks;<br/>+----------+----------+-------+---------------------+<br/>| stock_id | category | stock | check_time          |<br/>+----------+----------+-------+---------------------+<br/>|        1 | Laptops  |  2000 | 2022-03-20 23:04:39 |<br/>+----------+----------+-------+---------------------+<br/>1 row in set (0,00 sec)</span></pre><p id="e357" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意<code class="fe ng nh ni mw b">merge()</code>比<code class="fe ng nh ni mw b">add()</code>或者<code class="fe ng nh ni mw b">add_all()</code>慢很多，所以只有真正需要的时候才使用。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="70ff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，让我们看看如何用ORM删除记录。让我们删除我们一直在处理的记录。要删除一条记录，我们需要在目标记录上调用<code class="fe ng nh ni mw b">delete()</code>方法，然后调用<code class="fe ng nh ni mw b">commit()</code>:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="479f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，该记录已从数据库中删除:</p><pre class="ln lo lp lq gt mv mw mx my aw mz bi"><span id="f33d" class="na nb it mw b gy nc nd l ne nf">mysql&gt; <strong class="mw iu">SELECT</strong> * <strong class="mw iu">FROM</strong> data.product_stocks;<br/>Empty set (0,00 sec)</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="82fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本教程中，我们介绍了SQLAlchemy对象关系映射器(ORM)的基础知识。更多的关注点放在如何真正从零开始使用ORM。现在，您应该对引擎、会话、ORM、查询等基本概念更加熟悉了。对于如何在实际工作中处理ORM问题，也给出了一些提示，比如如何用SQLAlchemy创建数据库，如何从现有的表中创建ORM类，而不是从头开始编写一切。</p><p id="1482" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在后面的文章中，我们将关注如何使用SQLAlchemy ORM的实际例子，这将涉及更复杂的搜索和过滤查询。我们还将介绍如何将SQLAlchemy用于流行的Python框架，如Scrapy和Flask。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="da43" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相关文章:</p><ul class=""><li id="8795" class="mh mi it kk b kl km ko kp kr mj kv mk kz ml ld mm mn mo mp bi translated"><a class="ae ll" href="https://lynn-kwong.medium.com/how-to-execute-plain-sql-queries-with-sqlalchemy-627a3741fdb1?source=your_stories_page----------------------------------------" rel="noopener">如何用Python中的SQLAlchemy执行普通SQL查询</a></li></ul></div></div>    
</body>
</html>