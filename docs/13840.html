<html>
<head>
<title>Insertion Sort Explained in Simple Words!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用简单的话解释插入排序！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/insertion-sort-explained-in-simple-words-cc0b8771131e?source=collection_archive---------23-----------------------#2022-10-10">https://levelup.gitconnected.com/insertion-sort-explained-in-simple-words-cc0b8771131e?source=collection_archive---------23-----------------------#2022-10-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0cd73aff8c39b8c3c1fdd3639ff70b2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ImqbpaQbD-eYweN0"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯利·西克玛</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="fc12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想象一下，你是一名教师，正在看纸上的1000多名学生的名单。你想在列表中找到一个学生的名字。你必须查看名单上的每个人的名字。</p><p id="1a6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，想象一下，如果这个列表是按字母顺序排列的。你只需要看列表中以你需要的字母开头的部分。电脑也是如此。遍历排序列表比普通列表更容易。</p><h1 id="936d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">排序算法</h1><p id="a921" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对一个列表(或者一个数组)进行排序有很多技巧。一种方法是比较每对元素，并相应地交换它们。这是幼稚的做法。</p><p id="0cc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了优化排序过程，可以使用插入排序、快速排序、冒泡排序等算法。在这篇文章中，我们将看看插入排序。</p><h1 id="078c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">插入排序的概念</h1><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/c5f5fd3e1a1d03cd91752c6044a25f81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z76Sv7NjOjvNqD5y"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@inesrochaferreira?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伊内斯·费雷拉</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="2011" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您要对一副牌进行排序。你可以从拿起最小的卡片插入正确的位置开始(假设是第一个索引)。直到该牌被认为是分类的牌。</p><p id="6022" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再一次，从一叠卡片中找出除了你已经挑选的卡片之外最小的卡片，并把它插入正确的位置。重复这样做，直到整包卡片都被分类。</p><p id="1d79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是插入排序背后的主要概念。您可以为每个元素找到它们在最终排序列表中的位置。</p><h1 id="13ae" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">伪代码</h1><p id="3bd3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在，我将解释函数insertionSort (arr)的伪代码。它将未排序的数组作为唯一的参数。注意，这不是实际的代码。阅读<a class="ae kc" href="https://www.geeksforgeeks.org/how-to-write-a-pseudo-code/" rel="noopener ugc nofollow" target="_blank">本</a>获取伪代码指南。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="da20" class="mo lc iq mk b gy mp mq l mr ms">for j = 1 to arr.length - 1<br/>    key = arr[j]<br/>    i = j-1<br/>    while i &gt;= 0 and arr[i] &gt; key<br/>        arr[i+1] = arr[i]<br/>        i = i-1<br/>    arr[i+1] = key</span></pre><p id="5787" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我举个例子解释一下。考虑下面的数组。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="859a" class="mo lc iq mk b gy mp mq l mr ms">arr = [12, 14, 16, 13, 15]</span></pre><p id="4d41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从1到4运行<code class="fe mt mu mv mk b">for</code>循环。最初，</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="43d0" class="mo lc iq mk b gy mp mq l mr ms">j = 1<br/>key = arr[1] = 14<br/>i = 0</span></pre><p id="0706" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">直到索引<code class="fe mt mu mv mk b">i — 1</code>，数组被排序。自从<code class="fe mt mu mv mk b">i=0</code>以来，数组的任何部分都没有被排序。</p><p id="5842" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mk b">for</code>循环的每次迭代都试图找到<code class="fe mt mu mv mk b">arr[j]</code>的正确位置，即<code class="fe mt mu mv mk b">key</code>。内部<code class="fe mt mu mv mk b">while</code>循环将每个元素的<code class="fe mt mu mv mk b">key</code>与之前的元素进行比较，并找到此时<code class="fe mt mu mv mk b">key</code>的正确位置。</p><p id="16ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一次迭代后，数组看起来与<code class="fe mt mu mv mk b">key</code>相同，即14 &gt; 12。直到12，所有元素都被排序。</p><p id="574e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第二次迭代中，</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="de75" class="mo lc iq mk b gy mp mq l mr ms">j = 2<br/>key = arr[1] = 16<br/>i = 1</span></pre><p id="4c63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，没有变化，因为16大于所有早期的元素。</p><p id="cdb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第三次迭代</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="616e" class="mo lc iq mk b gy mp mq l mr ms">j = 3<br/>key = arr[1] = 13<br/>i = 2</span></pre><p id="0749" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当条件为<code class="fe mt mu mv mk b">true</code>时，内部<code class="fe mt mu mv mk b">while</code>循环将运行。在每次迭代结束时，数组以下列方式变化。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="7f98" class="mo lc iq mk b gy mp mq l mr ms">1st itr: [12, 14, 13, 16, 15] <br/>2nd itr: [12, 13, 14, 16, 15]</span><span id="2d5b" class="mo lc iq mk b gy mw mq l mr ms">Final array after while loop ends:<br/>arr=[12, 13, 14, 16, 15]</span></pre><p id="41dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第四次迭代。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="3a4d" class="mo lc iq mk b gy mp mq l mr ms">j = 4<br/>key = arr[1] = 15<br/>i = 3</span></pre><p id="d0a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再次运行内部<code class="fe mt mu mv mk b">while</code>循环。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="4f3f" class="mo lc iq mk b gy mp mq l mr ms">1st itr: [12, 13, 14, 15, 16]</span><span id="f466" class="mo lc iq mk b gy mw mq l mr ms">Final array after while loop ends:</span><span id="4c3a" class="mo lc iq mk b gy mw mq l mr ms">arr=[12, 13, 14, 15, 16]</span></pre><p id="b478" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mk b">for</code>循环结束。您现在可以看到数组已经排序。</p><h1 id="f1f7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">时间复杂度</h1><p id="ed13" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">知道一个算法需要多少时间是很重要的。我们无法计算准确的时间，因为输入大小可能会有所不同。算法的时间复杂度作为输入大小的函数来度量。如果你对时间复杂度不熟悉，就跟着<a class="ae kc" href="https://www.youtube.com/watch?v=0IAPZzGSbME&amp;list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O" rel="noopener ugc nofollow" target="_blank">这个</a> YouTube播放列表。</p><p id="752d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们首先计算每个语句被执行的次数。</p><p id="d61f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于<code class="fe mt mu mv mk b">for</code>循环从<code class="fe mt mu mv mk b">j= 2 to n</code>开始运行，所以里面的每条语句都执行<code class="fe mt mu mv mk b">n-1</code>次。这里，条件语句执行<code class="fe mt mu mv mk b">n</code>次，因为它还检查循环不运行的退出条件。</p><p id="576f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让<code class="fe mt mu mv mk b">tⱼ</code>表示每个<code class="fe mt mu mv mk b">j</code>执行while语句的次数。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="fc5d" class="mo lc iq mk b gy mp mq l mr ms">    <strong class="mk ir">Statement</strong>                                  <strong class="mk ir">No. of times</strong></span><span id="80dc" class="mo lc iq mk b gy mw mq l mr ms">for j = 1 to arr.length - 1                        n<br/>    key = arr[j]                                  n-1<br/>    i = j-1                                       n-1<br/>    while i &gt;= 0 and arr[i] &gt; key             (n-1) * tj<br/>        arr[i+1] = arr[i]                    (n-1) * (tj-1)<br/>        i = i-1                              (n-1) * (tⱼ-1)<br/>    arr[i+1] = key                                n-1</span></pre><p id="af88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还将假设每个语句都需要一定的时间cᵢ.所有语句的运行时间为</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="1361" class="mo lc iq mk b gy mp mq l mr ms">T(n) = c1 * n + c2 * (n-1) + c3 * (n-1) + c4 * (n-1) * tⱼ <br/>       + c5 * (n-1) * (tⱼ - 1) + c6 * (n-1) * (tⱼ - 1) + c7 * (n-1)</span></pre><p id="976b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们来看两个场景。</p><h2 id="ff34" class="mo lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">最好的情况</h2><p id="2329" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">插入排序的最佳情况发生在数组已经排序的时候。在这种情况下，内部while语句每次迭代只执行一次，即(tⱼ=1).上述函数变为:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="5247" class="mo lc iq mk b gy mp mq l mr ms">T(n) = (c1 + c2 + c3 + c4 + c7)n - (c2 + c3 + c4 + c7)</span></pre><p id="1fa9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这变成了形式<code class="fe mt mu mv mk b">an + b</code>的线性函数。</p><h2 id="c7d8" class="mo lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">最坏情况</h2><p id="cfa8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">最坏的情况发生在数组按降序排序时。这是插入排序花费最长时间的时候。在这种情况下，我们将<code class="fe mt mu mv mk b">key</code>与目前为止排序的数组中的每个元素进行比较。因此，内部while循环运行到目前为止排序的数组的整个长度。</p><p id="f77e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">于是，<code class="fe mt mu mv mk b">tⱼ = j</code>为<code class="fe mt mu mv mk b">j = 2, 3,… n</code>。代入这些值，等式变为:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="88a3" class="mo lc iq mk b gy mp mq l mr ms">T(n) = (c4/2 + c5/2 + c6/2) * n² + (c1 + c2 + c3 + c4/2 - c5/2 - c6/2 + c7)n - (c2 + c3 + c4 + c7)</span></pre><p id="42f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此<code class="fe mt mu mv mk b">T(n)</code>的形式为<code class="fe mt mu mv mk b">an²+bn+c</code>，它是一个二次函数。</p><p id="8aab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是“一般情况”呢？数组是随机的会怎么样？一般情况被认为和最坏情况一样糟糕。所以，时间复杂度仍然是二次函数。</p><p id="30f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们不写完整的函数，而表示时间复杂度。我们忽略每个语句的恒定时间，只考虑增长的<em class="ni">阶</em>，即最差情况下的<code class="fe mt mu mv mk b">an²</code>的最高阶函数。</p><p id="e06a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，忽略常数，我们将最坏情况下的时间复杂度记为<code class="fe mt mu mv mk b">O(n²)</code>，即<code class="fe mt mu mv mk b">n²</code>的阶数。同样，最好的情况时间复杂度是<code class="fe mt mu mv mk b">O(n)</code>。</p><p id="6bb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有不同类型的符号用于表示时间复杂度。了解更多关于他们的<a class="ae kc" href="https://www.programiz.com/dsa/asymptotic-notations" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><h1 id="c15c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="eb3f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">排序是计算机科学中非常重要的算法。根据您的情况，您可以尝试不同的排序算法，以找到最适合您的算法。</p><p id="25c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，想象你是同一个老师。不需要比较每一个元素，你可以使用这些算法中的一种以更快的方式对列表进行排序。</p><p id="6cbb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我详细解释了插入排序背后的主要概念，算法的每一步，以及如何计算它的时间复杂度。我希望我能让你明白。</p><p id="3c1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您无法理解内容或对解释不满意，请在下面评论您的想法。新想法总是受欢迎的！如果你喜欢这篇文章，请鼓掌。<strong class="kf ir">订阅</strong>和<strong class="kf ir">关注</strong>我的每周内容。如果你想讨论什么，请随时在LinkedIn上联系我。到那时，再见！！</p><h1 id="a311" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">参考</h1><p id="260c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这篇文章引用了《算法导论》一书的内容。它对插入排序有非常详细的解释。在这篇文章中，我试图总结相同的观点。</p><p id="17c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一本关于数据结构和算法入门的好书。你可以在<a class="ae kc" href="https://www.amazon.in/Introduction-Algorithms-3Ed-International-Press/dp/0262533057/ref=sr_1_3?crid=1KI28MW62BS3L&amp;keywords=introduction+to+algorithms&amp;qid=1665069500&amp;qu=eyJxc2MiOiIyLjkxIiwicXNhIjoiMS42NyIsInFzcCI6IjEuNDYifQ%3D%3D&amp;sprefix=introduction+to+algorithms%2Caps%2C253&amp;sr=8-3" rel="noopener ugc nofollow" target="_blank">亚马逊</a> ( <a class="ae kc" href="https://www.amazon.com/Introduction-Algorithms-Leiserson-Charles-Clifford-dp-B0839JW93F/dp/B0839JW93F/ref=mt_other?_encoding=UTF8&amp;me=&amp;qid=1665069547" rel="noopener ugc nofollow" target="_blank">链接</a>美国网站)上买到这本书。</p></div></div>    
</body>
</html>