<html>
<head>
<title>Understanding Recursion and Continuation with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python理解递归和连续</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-recursion-and-continuation-with-python-c08d384fbf55?source=collection_archive---------20-----------------------#2020-06-18">https://levelup.gitconnected.com/understanding-recursion-and-continuation-with-python-c08d384fbf55?source=collection_archive---------20-----------------------#2020-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/196cdd86c249565989cf85fae3dd495a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6tBlB5O9z1qHiWJI.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图1:陈月娇&amp;尼克拉斯·奥尔罗格在Unsplash上拍摄的照片</figcaption></figure><p id="0e9e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在文章<a class="ae ld" href="https://coderscat.com/learn-programming-languages" rel="noopener ugc nofollow" target="_blank">如何学习所有编程语言</a>中，我解释了学习编程语言概念是掌握所有编程语言的有效方法。</p><p id="2300" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">递归</strong>、<strong class="kh iu">延续</strong>和<strong class="kh iu">延续传递式</strong>是函数式编程语言的基本思想。理解它们将有助于了解编程语言是如何工作的；甚至我们在日常编程任务中也不会用到它们。</p><p id="3c61" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这篇文章中，让我们通过一些简短的Python程序来学习这些编程语言的概念。</p><h1 id="e168" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">递归</h1><blockquote class="mc md me"><p id="138c" class="kf kg mf kh b ki kj kk kl km kn ko kp mg kr ks kt mh kv kw kx mi kz la lb lc im bi translated"><em class="it">计算机科学中的递归是一种解决问题的方法，其解决方案依赖于同一问题的较小实例的解决方案。</em></p><p id="59ae" class="kf kg mf kh b ki kj kk kl km kn ko kp mg kr ks kt mh kv kw kx mi kz la lb lc im bi translated">—维基百科</p></blockquote><p id="d151" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">大多数现代编程语言都支持递归，允许函数从自己的代码中调用自己。递归是许多函数式编程语言的默认编程范式，如Haskell、OCaml。</p><p id="78d4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">许多日常编程任务或算法可以更容易地用递归实现。假设您想递归地列出一个目录的所有文件和子目录，那么递归将是实现的自然选择。</p><p id="cdbd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们来看看这个简单的递归Python程序:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="4c6f" class="ms lf it mo b gy mt mu l mv mw">def fib_rec(n):<br/>    if n &lt; 2:<br/>        return 1<br/>    else:<br/>        return fib_rec(n - 1) + fib_rec(n - 2)</span><span id="0942" class="ms lf it mo b gy mx mu l mv mw">print(fib_rec(5))</span></pre><p id="48d7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是一个计算斐波那契数的简单实现。递归的一个关键点是必须有一个退出点，第三行<code class="fe my mz na mo b">return 1</code>是这个程序的退出点。</p><p id="9788" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是递归的缺点是什么呢？</p><p id="a86f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们为这个程序添加更多的调试信息，在函数的开头打印调用深度:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="c18a" class="ms lf it mo b gy mt mu l mv mw">import traceback<br/>def fib_rec(n):<br/>    print(len(traceback.extract_stack()) * '*' + ": " + str(n))<br/>    if n &lt; 2:<br/>        return 1<br/>    else:<br/>        return fib_rec(n - 1) + fib_rec(n - 2)<br/></span><span id="124f" class="ms lf it mo b gy mx mu l mv mw">print(fib_rec(5))</span></pre><p id="e7ec" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">输出将是:</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/009b02450a771aaec5e97f037ae46eeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/0*jr-gC1vGnZhS9kRn.png"/></div></figure><p id="db22" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe my mz na mo b">*</code>表示当前函数调用的调用深度。从输出中我们可以看到，有两点需要注意:</p><ol class=""><li id="6a33" class="nc nd it kh b ki kj km kn kq ne ku nf ky ng lc nh ni nj nk bi translated">在整个过程中有重复的计算。fib_rec(3)，fib_rec(2)，fib_rec(1)被多次调用。</li><li id="60fc" class="nc nd it kh b ki nl km nm kq nn ku no ky np lc nh ni nj nk bi translated">随着输入数量的增加，调用栈将快速增长。如果我们要计算fib_rec(1000)，就会抛出堆栈溢出异常。</li></ol><p id="db98" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们如何解决递归的这些普遍问题？</p><h1 id="2c41" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">尾部递归</h1><p id="434d" class="pw-post-body-paragraph kf kg it kh b ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky nu la lb lc im bi translated">尾部递归是一种特殊形式的递归，在这种递归中，过程的最后一个动作再次调用自身。在上面的程序中，最后一个动作是<code class="fe my mz na mo b">return 1</code>或<code class="fe my mz na mo b">return fib_rec(n-1) + fib_rec(n-2)</code>，这不是尾部递归。</p><p id="77d6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们试着把上面的程序转换成尾部递归:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="8c54" class="ms lf it mo b gy mt mu l mv mw">def fib_tail(n, acc1=1, acc2=1):<br/>    print(len(traceback.extract_stack()) * '*' + ": " + str(n))<br/>    if n &lt; 2:<br/>        return acc1<br/>    else:<br/>        return fib_tail(n - 1, acc1 + acc2, acc1)</span><span id="9008" class="ms lf it mo b gy mx mu l mv mw">print(fib_tail(5))</span></pre><p id="a101" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">输出是这样的:</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/b4296aa908b060e60801b6e49f2cb132.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/0*mPXxBo9WNTl3ujwN.png"/></div></div></figure><p id="9fa7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">从结果中，我们可以发现我们删除了一些重复的计算，我们解决了上述程序的问题#1。</p><h1 id="6cef" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">尾部调用优化(TCO)</h1><p id="7dc3" class="pw-post-body-paragraph kf kg it kh b ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky nu la lb lc im bi translated">有一种叫做<a class="ae ld" href="https://en.wikipedia.org/wiki/Tail_call" rel="noopener ugc nofollow" target="_blank">尾部调用优化</a>的技术可以解决问题#2，它在许多编程语言的编译器中都有实现。但不是用Python实现的。Guido解释了为什么他不想让<code class="fe my mz na mo b">tail call optimization</code> <a class="ae ld" href="http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html" rel="noopener ugc nofollow" target="_blank">出现在这篇文章</a>中。</p><p id="b9f8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">不管怎样，我们先来了解一下<code class="fe my mz na mo b">tail call optimization</code>是如何工作的。我们知道，在执行过程中，任何对子函数的调用都会创建一个新的堆栈框架。如果我们把函数调用看作一个黑盒，当尾部函数调用发生时，我们可以重用同一个堆栈帧。</p><p id="8a01" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为此，带有<code class="fe my mz na mo b">TCO</code>的编译器将尝试通过跳转操作消除最后一个尾部调用，并修复堆栈溢出问题。假设Python有一个<code class="fe my mz na mo b">goto</code>操作，我们可以用<code class="fe my mz na mo b">goto</code>替换<code class="fe my mz na mo b">fib_tail</code>的最后一个调用，并更新相关参数。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="bdf5" class="ms lf it mo b gy mt mu l mv mw"># NOTE!!! This is pseudo-code</span><span id="e070" class="ms lf it mo b gy mx mu l mv mw">def fib_tail(n, acc1=1, acc2=1):<br/>    START:<br/>    if n &lt; 2:<br/>        return acc1<br/>    else:<br/>        #return fib_tail(n - 1, acc1 + acc2, acc1)<br/>        n = n - 1<br/>        tmp = acc1<br/>        acc1 = acc1 + acc2<br/>        acc2 = tmp<br/>        goto START</span></pre><p id="8e5f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">从结果来看，编译器实际上可以将递归函数转换成迭代版本。所有的迭代函数都可以转化为递归，因为迭代只是递归的一个特例(尾递归)。</p><p id="4152" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这就是为什么即使我们以递归方式编写代码，许多FP也不会表现很差的原因。编译器做他们的工作！</p><h1 id="1dd0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">连续传球风格</h1><p id="e13c" class="pw-post-body-paragraph kf kg it kh b ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky nu la lb lc im bi translated">更有甚者，函数式编程语言采用了<a class="ae ld" href="https://en.wikipedia.org/wiki/Continuation-passing_style" rel="noopener ugc nofollow" target="_blank">延续传递风格</a> (CPS)，其中控制以延续的形式显式传递。</p><p id="7613" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">延续是程序控制状态的抽象表示。</p><p id="7c91" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">听起来晦涩难懂？</p><p id="ccfc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">假设continuation是一种数据结构，它表示在进程执行的给定点上的计算进程，我们可以保存一个执行状态并在以后继续计算进程。</p><p id="90e2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">似乎Python中的<code class="fe my mz na mo b">lambda function</code>可以用于此，因为我们可以将lambda函数作为参数传递，并在以后调用它们。</p><p id="e8ed" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们定义最简单的延拓，这个延拓将返回带有任何参数的原始值:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="64eb" class="ms lf it mo b gy mt mu l mv mw">end_cont = lambda value: value</span></pre><p id="0ba3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后我们试着把上面的fib_tail函数转换成一个CPS。我们添加了一个额外的参数叫做<code class="fe my mz na mo b">cont</code>:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="2dd6" class="ms lf it mo b gy mt mu l mv mw">def fib_cps(n, cont):<br/>    print(len(traceback.extract_stack()) * '*' + ": " + str(n))<br/>    if n &lt; 2:<br/>        return cont(1)<br/>    else:<br/>        return lambda: fib_cps(<br/>                         n - 1,<br/>                         lambda value:<br/>                           lambda: fib_cps(<br/>                                     n - 2,<br/>                                     lambda value2:<br/>                                       lambda: cont(value + value2)))<br/>print(fib_cps(5, end_cont))</span></pre><p id="9966" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">输出是:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="1239" class="ms lf it mo b gy mt mu l mv mw">&lt;function &lt;lambda&gt; at 0x101d52758&gt;</span></pre><p id="94e4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Emm，结果我们只得到一个lambda函数。记住我们可以继续执行一个延续，所以我们继续运行这个lambda函数，返回值仍然是一个延续…</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="3dc9" class="ms lf it mo b gy mt mu l mv mw">v = fib_cps(5, end_cont)<br/>print(v)</span><span id="af6b" class="ms lf it mo b gy mx mu l mv mw">print(v)<br/>v = v()<br/>print(v)</span><span id="f66d" class="ms lf it mo b gy mx mu l mv mw">v = v()<br/>print(v)</span><span id="3bd8" class="ms lf it mo b gy mx mu l mv mw">v = v()<br/>print(v)</span><span id="1bee" class="ms lf it mo b gy mx mu l mv mw">....</span><span id="a9dc" class="ms lf it mo b gy mx mu l mv mw">**: 5<br/>&lt;function &lt;lambda&gt; at 0x10d493758&gt;<br/>***: 4<br/>&lt;function &lt;lambda&gt; at 0x10d493848&gt;<br/>***: 3<br/>&lt;function &lt;lambda&gt; at 0x10d4938c0&gt;<br/>***: 2<br/>&lt;function &lt;lambda&gt; at 0x10d493938&gt;<br/>***: 1</span></pre><p id="f6d3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们包装一个函数来反复调用<code class="fe my mz na mo b">v</code>，直到我们得到一个真实的值:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="93c0" class="ms lf it mo b gy mt mu l mv mw">def trampoline(f, *args):<br/>    v = f(*args)<br/>    while callable(v):<br/>        v = v()<br/>    return v</span></pre><p id="29f3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后运行它:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="40ff" class="ms lf it mo b gy mt mu l mv mw">print(trampoline(fib_cps, 5, end_cont))</span></pre><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/03cbe8d1121052f8fc0d956d2aef843d.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/format:webp/0*e7vMxXoEoCGnbkD9.png"/></div></figure><p id="9e53" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">呜！在执行过程中，堆栈深度始终保持不变。一些函数式编程语言的编译器会自动进行CPS转换。</p><h1 id="eb27" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">向上总结</h1><p id="94e2" class="pw-post-body-paragraph kf kg it kh b ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky nu la lb lc im bi translated">我们刚刚对尾部递归、尾部调用优化和延续有了一点真实的体验。延续对于在编程语言中实现其他控制机制很有用，比如异常、生成器和协同程序。很好地理解这些概念有助于我们更深入地理解编程语言。</p><p id="25fe" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我希望你喜欢它。</p></div></div>    
</body>
</html>