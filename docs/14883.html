<html>
<head>
<title>How to implement Bloom filter in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中实现布隆过滤器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/bloom-filter-in-javascript-24c64b48f8d2?source=collection_archive---------13-----------------------#2022-12-30">https://levelup.gitconnected.com/bloom-filter-in-javascript-24c64b48f8d2?source=collection_archive---------13-----------------------#2022-12-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0acf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">布隆过滤器是用于确定元素是否是集合成员的概率数据结构。它允许您在使用相对较少的空间的同时，以较高的准确度测试集合中某个元素的成员资格。在本文中，我们将探索bloom filters是如何工作的，以及如何用JavaScript实现它。我们还将深入探讨一下位运算。如果你想了解更多关于位运算的知识，我们也在这里发表了一篇关于JavaScript中位运算基础的<a class="ae ko" href="https://medium.com/gitconnected/basics-of-bitwise-operations-in-javascript-with-practical-examples-6197b4d391b3" rel="noopener">文章。我们还将看看布鲁姆过滤器的一些实际应用，以及它们如何用于解决现实世界中的问题。对于我们当中不耐烦的人:我们在最后链接了GitHub存储库中的示例项目。</a></p><p id="1588" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这只是许多关于JavaScript和软件开发的文章中的一篇。欢迎关注我们，获取更多关于JavaScript和软件开发的精彩内容。我们尝试一周发布多次。请确保不要错过我们的任何精彩内容。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/bec947c2fea6f75f920fbe91ca93d8eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BidvUt52otD1Ijeq"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">由<a class="ae ko" href="https://unsplash.com/@nixcreative?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">泰勒·尼克斯</a>在<a class="ae ko" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="0b1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">1970年，伯顿·霍华德·布鲁姆构思了布鲁姆过滤器。它是一种概率数据结构，用于测试一个元素是否是一个集合的成员。布隆过滤器允许非常快速的成员资格查询，但是有可能产生假阳性(错误地指示元素在集合中),但是它永远不会返回假阴性结果。误报的概率使其成为一种概率数据结构。</p><p id="2e04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">布隆过滤器被实现为比特阵列，其中每个比特最初被设置为0。为了向过滤器添加一个元素，几个散列函数<br/>被应用于该元素，并且产生的散列值被用于将数组中的相应位设置为1。为了检查元素是否在过滤器中，将相同的散列函数应用于该元素，并检查数组中的相应位。如果所有位都已设置，则该元素可能在过滤器中。如果没有设置任何位，则该元素肯定不在过滤器中。</p><p id="6442" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以通过调整数组的大小和使用的哈希函数的数量来控制误报的概率。较大的数组和较大数量的散列函数将导致较低的误报概率，但也会导致较慢的成员资格查询。</p><p id="bb3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">布隆过滤器通常用于快速执行成员资格查询很重要，并且误报的代价可以接受的情况。它们通常用于网络和安全应用中，以过滤掉不需要的流量或检测恶意活动。</p><p id="8e7a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是布隆过滤器的一些使用案例:</p><ul class=""><li id="7d32" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated"><strong class="js iu">网络流量过滤</strong>:布隆过滤器可用于在网络层过滤掉不需要的流量，只允许授权的流量通过。这在防火墙或入侵检测<br/>系统中很有用。</li><li id="fa8b" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><strong class="js iu">拼写检查</strong>:布隆过滤器可以用来快速检查单词拼写是否正确。这在文本编辑器或文字处理器中可能很有用。</li><li id="f64b" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><strong class="js iu">集合成员关系</strong>:布隆过滤器可以用来测试一个元素是否是集合的成员。在快速执行成员资格查询很重要并且误报的代价可以接受的情况下，这可能是有用的。</li><li id="3f29" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><strong class="js iu">缓存失效</strong>:布隆过滤器可用于跟踪哪些项目在缓存中，并快速确定项目是否在缓存中。这在分布式缓存系统中非常有用，在向源服务器发出请求之前，快速检查缓存中是否存在某个项目非常重要。</li></ul><p id="3e34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是使用布隆过滤器的一些优点:</p><ul class=""><li id="c19d" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated"><strong class="js iu">快速成员资格查询</strong> : Bloom filters允许非常快速的成员资格查询，因为它们只需要少量的哈希函数计算和位运算。</li><li id="a008" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><strong class="js iu">低内存使用率</strong> : Bloom filters使用固定数量的内存，与集合中的项目数量无关。这使得它们适合在内存有限的情况下使用。</li><li id="087f" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><strong class="js iu">无假阴性</strong> : Bloom过滤器从不产生假阴性，这意味着如果一个元素在过滤器中，成员查询将总是返回“可能在集合中”。</li><li id="42fa" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><strong class="js iu">可调整的误报率</strong>:通过调整位数组的大小和使用的哈希函数的数量，可以控制误报的概率。这允许用户在假阳性率和成员资格查询速度之间进行权衡。</li><li id="921f" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><strong class="js iu">简单实现</strong>:布隆过滤器实现起来相对简单，只需要少量代码。</li></ul><p id="ac7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是使用布隆过滤器的一些缺点:</p><ul class=""><li id="4874" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated"><strong class="js iu">误报的可能性</strong>:布隆过滤器有可能产生误报，这意味着它们可能错误地指示元素在集合中。这可以通过使用更大的位数组和更多的哈希函数来缓解，但这也会导致成员资格查询更慢。</li><li id="9183" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><strong class="js iu">容量有限</strong> : Bloom filters只能存储有限数量的项目，之后它们的误报率迅速增加。这意味着它们不适合在项目集<br/>预计会随着时间显著增长的情况下使用。</li><li id="dfc4" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><strong class="js iu">不可移除元素</strong>:一旦一个元素被添加到布隆过滤器，它就不能被移除。这意味着过滤器总是有可能对该元素产生误报。</li><li id="f41f" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><strong class="js iu">功能受限</strong> : Bloom filters只能执行成员查询，不支持插入、删除、交集等其他集合操作。</li></ul><p id="ce7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们实现一个使用布隆过滤器的小应用程序。让我们写一个密码检查器:当你注册一个新账户时，建议不要重复使用现有的密码，而是创建一个新的。为了检查您是否已经使用了密码，我们将使用bloom filter编写一个应用程序。如果不使用您的密码，它将返回false。如果您的密码可能(也可能没有)已经被使用，那么它将返回true，并要求您创建一个新密码。如您所见，bloom filter并不完全准确，因为它可能会返回误报。但是在我们的例子中，这无关紧要，因为您只需创建一个新密码。</p><p id="1596" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们开始实现我们的密码检查器:</p><pre class="kq kr ks kt gt lt lu lv bn lw lx bi"><span id="9225" class="ly lz it lu b be ma mb l mc md">class BloomFilter {<br/> constructor(size, hashFunctions) {<br/>   this.size = size;<br/>   this.hashFunctions = hashFunctions;<br/>   this.bits = new Array(size).fill(0);<br/> }<br/> add(item) {<br/>  for (let i = 0; i &lt; this.hashFunctions.length; i++) {<br/>   const hashValue = this.hashFunctions[i](item);<br/>   const index = hashValue % this.size;<br/>   this.bits[index] |= 1 &lt;&lt; hashValue;<br/>  }<br/> }<br/> contains(item) {<br/>  for (let i = 0; i &lt; this.hashFunctions.length; i++) {<br/>   const hashValue = this.hashFunctions[i](item);<br/>   const index = hashValue % this.size;<br/>   if ((this.bits[index] &amp; 1 &lt;&lt; hashValue) === 0) {<br/>    return false;<br/>   }<br/>  }<br/>  return true;<br/> }<br/>}</span></pre><p id="22d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你一开始不明白，它是做什么的，不要着急。接下来，我们将仔细阅读每一行代码，并向您解释:</p><pre class="kq kr ks kt gt lt lu lv bn lw lx bi"><span id="9da7" class="ly lz it lu b be ma mb l mc md">class BloomFilter {<br/> constructor(size, hashFunctions) {<br/>  this.size = size;<br/>  this.hashFunctions = hashFunctions;<br/>  this.bits = new Array(size).fill(0);<br/> }</span></pre><p id="e91e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这定义了一个名为BloomFilter的类，它的构造函数有两个参数:size和hashFunctions。size参数是用于在过滤器中存储项目的位数组中的位数。hashFunctions参数是一个函数数组，用于对添加到过滤器中的项目进行哈希运算。我们将在本文后面更详细地讨论this函数的实现。</p><p id="7b9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">构造函数初始化三个实例变量:size、hashFunctions和bits。size和hashFunctions被设置为传递给构造函数的参数值，bits是一个size元素的数组，都被初始化为0。</p><pre class="kq kr ks kt gt lt lu lv bn lw lx bi"><span id="5c78" class="ly lz it lu b be ma mb l mc md">add(item) {<br/> for (let i = 0; i &lt; this.hashFunctions.length; i++) {<br/>  const hashValue = this.hashFunctions[i](item);<br/>  const index = hashValue % this.size;<br/>  this.bits[index] |= 1 &lt;&lt; hashValue;<br/> }<br/>}</span></pre><p id="fa6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是add方法，用于向过滤器添加一个项目。它<br/>遍历散列函数数组，将每个函数应用于该项，并使用得到的散列值在bits数组中相应的索引处设置一个位。它通过使用|=操作符将1 &lt; &lt;的值与位数组<br/>中索引处的位的当前值进行or运算来实现这一点。</p><pre class="kq kr ks kt gt lt lu lv bn lw lx bi"><span id="ef9c" class="ly lz it lu b be ma mb l mc md">contains(item) {<br/> for (let i = 0; i &lt; this.hashFunctions.length; i++) {<br/>  const hashValue = this.hashFunctions[i](item);<br/>  const index = hashValue % this.size;<br/>  if ((this.bits[index] &amp; 1 &lt;&lt; hashValue) === 0) {<br/>   return false;<br/>  }<br/> }<br/> return true;<br/>}</span></pre><p id="ff63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是contains方法，用于检查一个项目是否在<br/>过滤器中。它的工作方式类似于add方法，但是它不是设置bits数组中的位<br/>，而是检查这些位是否被设置。如果任何位<br/>没有被设置，它立即返回false。如果所有的位都已设置，则返回true。这意味着该项目可能在过滤器中，但有可能出现误报。它使用&amp;运算符将1 &lt; &lt;的值与bits数组中索引处的位的当前值进行哈希运算，并检查结果是否等于0。</p><p id="5627" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可能的哈希函数如下所示:</p><pre class="kq kr ks kt gt lt lu lv bn lw lx bi"><span id="a213" class="ly lz it lu b be ma mb l mc md">function hash(item) {<br/> let hash = 0;<br/> for (let i = 0; i &lt; item.length; i++) {<br/>  hash = (hash &lt;&lt; 5) + hash + item.charCodeAt(i);<br/>  hash = hash &amp; hash;<br/>  hash = Math.abs(hash);<br/> }<br/> return hash;<br/>}</span></pre><p id="f8f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这只是哈希函数的一个基本实现。这对于生产来说还不够，但是对于我们的例子来说已经足够了。下面我们将逐行解释has函数的作用:</p><pre class="kq kr ks kt gt lt lu lv bn lw lx bi"><span id="c241" class="ly lz it lu b be ma mb l mc md">function hash(item) {<br/> let hash = 0;</span></pre><p id="6e5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这定义了一个名为hash的函数，它将一个项作为参数。它将名为hash的局部变量初始化为0。</p><pre class="kq kr ks kt gt lt lu lv bn lw lx bi"><span id="0991" class="ly lz it lu b be ma mb l mc md">for (let i = 0; i &lt; item.length; i++) {<br/> hash = (hash &lt;&lt; 5) + hash + item.charCodeAt(i);</span></pre><p id="4635" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个遍历项目中每个字符的循环。对于每个字符，它将hash的值左移5位并加到<br/>本身，然后将字符的ASCII值加到hash中。这有助于将散列的比特混合在一起。</p><pre class="kq kr ks kt gt lt lu lv bn lw lx bi"><span id="9901" class="ly lz it lu b be ma mb l mc md">hash = hash &amp; hash;</span></pre><p id="b59b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将hash值与其自身进行and运算，有助于进一步混合hash位并减少冲突的机会。</p><pre class="kq kr ks kt gt lt lu lv bn lw lx bi"><span id="e1fb" class="ly lz it lu b be ma mb l mc md">hash = Math.abs(hash);</span></pre><p id="847f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这取hash的绝对值，保证它是正数。</p><pre class="kq kr ks kt gt lt lu lv bn lw lx bi"><span id="ada1" class="ly lz it lu b be ma mb l mc md">}<br/> return hash;<br/>}</span></pre><p id="f81a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，函数返回hash的值。请注意，这只是一个哈希函数的示例实现。您不希望在您的产品代码中使用这个函数。</p><p id="f951" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要在Bloom filter中使用这个散列函数，您可以将它作为散列函数数组中的一个元素传递给Bloom filter的构造函数。例如:</p><pre class="kq kr ks kt gt lt lu lv bn lw lx bi"><span id="47b4" class="ly lz it lu b be ma mb l mc md">const bloomFilter = new BloomFilter(1000, [hash]);<br/><br/>bloomFilter.add("hello");<br/>bloomFilter.add("world");<br/>bloomFilter.add("hi");<br/>bloomFilter.add("aasdf");<br/>bloomFilter.add("test123");<br/>bloomFilter.add("test1234");<br/>bloomFilter.add("1234");<br/>bloomFilter.add("password");<br/><br/>console.log(bloomFilter.contains("hello"));    // true<br/>console.log(bloomFilter.contains("world"));    // true<br/>console.log(bloomFilter.contains("hi"));       // true<br/>console.log(bloomFilter.contains("aasdf"));    // true<br/>console.log(bloomFilter.contains("test123"));  // true<br/>console.log(bloomFilter.contains("test1234")); // true<br/>console.log(bloomFilter.contains("1234"));     // true<br/>console.log(bloomFilter.contains("password")); // true<br/>console.log(bloomFilter.contains("password1"));// false</span></pre><p id="332f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">整个项目可以在我们的<a class="ae ko" href="https://github.com/pandaquests/passwordChecker/blob/main/passwordChecker.js" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>中找到:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi me"><img src="../Images/5c7fdb823e2c7f4190f716ff6bed224c.png" data-original-src="https://miro.medium.com/v2/resize:fit:304/format:webp/1*M96Lw3t2ZV4F3S-tD-N27Q.png"/></div></figure><p id="b9ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是你如何使用布鲁姆过滤器。你以前实现过布隆过滤器吗？在什么背景下？或者你有什么问题吗？请在下方留言评论。也别忘了跟着我们。我们每周发表多篇文章。所以，不要错过任何一个。再见</p></div></div>    
</body>
</html>