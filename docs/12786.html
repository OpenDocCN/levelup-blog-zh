<html>
<head>
<title>Building a serverless text-to-speech application with Amazon Polly, Step functions and WebSocket Api</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Amazon Polly、Step函数和WebSocket Api构建一个无服务器的文本到语音转换应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-serverless-text-to-speech-application-with-amazon-polly-step-functions-and-websocket-56e9871730b7?source=collection_archive---------4-----------------------#2022-07-09">https://levelup.gitconnected.com/building-a-serverless-text-to-speech-application-with-amazon-polly-step-functions-and-websocket-56e9871730b7?source=collection_archive---------4-----------------------#2022-07-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4903" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将构建“Easy Reader”，这是一个完全托管在AWS上且完全无服务器的文本到语音转换应用程序。这个应用程序只需提供一个URL就可以为你阅读在线文章</p><p id="01ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在后端，我们将使用Amazon Polly、WebSocket Api (Api网关)、编排lambda函数的Step函数(用typescript编写并使用node 16运行时)</p><p id="f262" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在前端，我们将构建一个小型的静态react应用程序，托管在s3上，由CloudFront发行版提供服务。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/ca98f2d14b9c5ad455fe5f932f3f0112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6b6opwnQ1M3OFnsvJyJUPw.png"/></div></div></figure><p id="56eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将用Github Actions和CloudFormation构建和部署这个应用程序</p><h2 id="943e" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="948c" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">你可以在这里找到完整的回购协议👉<a class="ae lv" href="https://github.com/ziedbentahar/aws-easy-reader" rel="noopener ugc nofollow" target="_blank">https://github.com/ziedbentahar/aws-easy-reader</a></p><h2 id="5363" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated"><strong class="ak">等等，为什么是WebSocket Api？</strong></h2><p id="bcd7" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">为了处理网络文章，我们将执行两个步骤:</p><ul class=""><li id="0565" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated">首先，我们提取一篇网络文章的纯文本、可读/无杂乱版本，并检测其语言</li><li id="d7fb" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">其次，我们使用Amazon Polly生成音频</li></ul><p id="933f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据要处理的文章的长度，文本提取和音频合成任务可能会很长。WebSocket Api(以及AWS ApiGateway)需要考虑的一个重要配额是最大集成超时 的<a class="ae lv" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/limits.html" rel="noopener ugc nofollow" target="_blank"> 29 <strong class="jp ir">秒。</strong></a></p><p id="ef51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可以通过两种策略来解决:</p><ul class=""><li id="46ed" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated"><strong class="jp ir">基于轮询的</strong>:让客户端定期向Api网关重复发送请求，检查文章是否处理完毕。这种策略不是资源友好的，因为它导致服务器和客户端之间的许多请求。</li><li id="c5f2" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated"><strong class="jp ir">基于WebSockets的推送</strong>:客户端和服务器之间的双向通信，当一篇文章处理完毕时，浏览器会得到通知。这将允许资源的有效使用和减少的等待时间。</li></ul><p id="a4d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">AWS API Gateway支持WebSockets，并提供与AWS lambda、HTTP端点或其他AWS服务的路由集成。这就是我们将要在这个语音合成应用程序中使用的内容</p><h2 id="5283" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">“简易阅读器”应用程序的参考架构</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mk"><img src="../Images/0c1f6ac6dff557349d011a13cac30d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eIs2DNFD8ZmKUN-pFqAUhw.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">“简易阅读器”应用程序的参考架构</figcaption></figure><ul class=""><li id="a0cf" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated"><strong class="jp ir">web socket Api</strong>公开了一个集成了“启动任务Lambda”的路由。此路由处理来自客户端的请求(包含文章URL的有效负载)，它还向集成的lambda(开始任务)提供相对于连接的客户端的连接Id。这个连接Id将用于在成功或失败的情况下对客户端进行回调</li><li id="abd8" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated"><strong class="jp ir"> Start Task Lambda </strong>触发一个步骤函数，并传递一个要处理的文章URL以及连接Id。</li><li id="9a21" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated"><strong class="jp ir">提取文本</strong>有两个职责:首先，它试图提取文本的可读版本，其次，它检测内容的语言。提取的文本数据可能会有所不同，如果有效负载大小超过265 Kb，将它传递给step函数可能会失败。我们将把内容保存在s3存储桶“内容存储桶”中。该内容将由状态机上的下一个lambda读取</li><li id="32fb" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated"><strong class="jp ir">生成音频</strong>从内容桶中读取内容，然后调用Polly以便从文章内容中生成音频</li><li id="6131" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated"><strong class="jp ir"> Notify Success </strong>向连接的客户端发送一个成功有效载荷，其中包含一个可公开访问的预签名的音频URL</li><li id="8f75" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated"><strong class="jp ir">处理错误</strong>当状态机发生错误时，向连接的客户端发送错误通知</li><li id="8811" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated"><strong class="jp ir">阶跃函数</strong>将Lamba函数编排并连接在一起</li><li id="7cae" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated"><strong class="jp ir">前端桶和CloudFront分发</strong>负责向客户端提供react应用</li></ul><h2 id="6192" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated"><strong class="ak">定义状态机</strong></h2><p id="4149" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">阶跃函数提供了一种很好的方式来协调多个Lambda函数的执行。下图显示了“简易阅读器”步骤功能所涉及的任务的逻辑流程。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/b1c0317b8531a338a19036d48040c6e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*0MaT2sapq3kMmSxZZHPCpg.png"/></div></figure><p id="cecd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是ASL(亚马逊州语言)状态机的模板定义</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="8c1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">跟随<a class="ae lv" href="https://github.com/ziedbentahar/aws-easy-reader/blob/main/aws/cfn/easy-reader-components/easy-reader-stepfunction.yml" rel="noopener ugc nofollow" target="_blank">此链接</a>获取该步骤功能的完整云形成定义</p><h2 id="fafa" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated"><strong class="ak">构建Lambda函数，相关部分</strong></h2><p id="f5c5" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated"><strong class="jp ir"> 1-文本提取器λ函数</strong></p><p id="684f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个lambda接收文章URL和连接Id作为输入，并尝试从网站中提取内容</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="5afe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用<a class="ae lv" href="https://github.com/mozilla/readability" rel="noopener ugc nofollow" target="_blank">可读性</a>来提取一篇网络文章的内容。Firefox reader使用这个库，所以它在主要内容提取方面提供了非常好的结果。我们还尝试使用“<a class="ae lv" href="https://github.com/FGRibreau/node-language-detect" rel="noopener ugc nofollow" target="_blank">language detect</a>”lib来检测语言。这就是<code class="fe ms mt mu mv b"><strong class="jp ir">extractContentFromArticleUrl</strong></code> <strong class="jp ir"> </strong>的作用:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="2481" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦提取了内容，这个lambda函数通过WebSocket连接发布通知来通知连接的客户端。</p><pre class="km kn ko kp gt mw mv mx my aw mz bi"><span id="f369" class="kx ky iq mv b gy na nb l nc nd">await <strong class="mv ir">postNotificationToConnection</strong>(<strong class="mv ir">connectionId</strong>, { type: “contentExtracted”, articleUrl: articleUrl, contentUrl: articleContentUrl, });</span></pre><p id="dce4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个函数调用Api网关管理API向一个连接Id发送消息</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="b5da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个lambda函数必须有<code class="fe ms mt mu mv b">allow</code> <code class="fe ms mt mu mv b">execute-api:ManageConnections</code>策略，才能通过WebSocket Api将数据发送到连接</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="69d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里找到lambda函数<a class="ae lv" href="https://github.com/ziedbentahar/aws-easy-reader/blob/main/aws/cfn/easy-reader-components/text-extractor-lambda.yml" rel="noopener ugc nofollow" target="_blank">的完整云模板</a></p><p id="8fba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2-生成音频λ功能</strong></p><p id="5ac7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相当简单的过程。首先我们从内容桶中获取提取的内容，然后通过调用<code class="fe ms mt mu mv b">synthesize</code>函数生成音频，最后我们将生成的音频保存在内容桶中</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="4e94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ms mt mu mv b">synthesize</code>函数使用亚马逊Polly SDK生成音频。波利文本合成api接受纯文本或SSML。在这个例子中，我们使用SSML，这样我们可以控制演讲的暂停持续时间，特别是对于没有以正确的标点符号结尾的段落。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="7484" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我们通过3000个字符的块来生成音频。这是<a class="ae lv" href="https://docs.aws.amazon.com/polly/latest/dg/limits.html" rel="noopener ugc nofollow" target="_blank">输入的<code class="fe ms mt mu mv b">SynthesizeSpeech</code>的最大尺寸</a></p><p id="adee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ms mt mu mv b">getLangConfigurationOrDefault</code>提供与语言相关的引擎(神经或标准)和语音Id。此配置在中定义<a class="ae lv" href="https://github.com/ziedbentahar/aws-easy-reader/blob/main/src/backend/lambdas/audio-generator/language-configuration.ts" rel="noopener ugc nofollow" target="_blank"/></p><p id="13fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个lambda函数必须有<code class="fe ms mt mu mv b">allow</code> <code class="fe ms mt mu mv b">polly:SynthesizeSpeech</code>策略。</p><p id="dbd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个λ的完整云形成模板<a class="ae lv" href="https://github.com/ziedbentahar/aws-easy-reader/blob/main/aws/cfn/easy-reader-components/generate-audio-lambda.yml" rel="noopener ugc nofollow" target="_blank">在这里</a></p><p id="0429" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3-发送成功/失败通知</strong></p><p id="aff6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">成功通知功能从内容桶请求音频文件的预先指定的URL，然后用包含成功状态和预先指定的音频URL的有效载荷通知客户端</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="18c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，句柄错误lambda只会在整个过程中出现问题时向连接的客户端发送消息</p><p id="542e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 4-构建和捆绑lambda函数</strong></p><p id="a29c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个应用程序中，我们将构建Lambda函数并将其与Webpack捆绑在一起。捆绑带来了一些优势:</p><ul class=""><li id="5be5" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated">减少了包的大小和树的抖动:因为我们不想为每个lambda复制<code class="fe ms mt mu mv b">node_modules</code>的全部内容，所以Webpack包只包含在每个lambda函数处理程序上导入的依赖项</li><li id="62d2" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">每个Lambda单独包装</li><li id="3bff" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">通过较小的部署缩短冷启动时间</li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="420f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe ms mt mu mv b"><a class="ae lv" href="https://github.com/ziedbentahar/aws-easy-reader/blob/main/src/backend/webpack.config.js" rel="noopener ugc nofollow" target="_blank">webpack.config.js</a></code>文件中，您会注意到我们忽略了<code class="fe ms mt mu mv b">canvas</code>模块。事实上，这个模块是jsdom所需要的(它是可读性的依赖项)，并且与Lambda运行时不兼容。</p><h2 id="df5b" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">配置WebSocket API</h2><p id="a9ec" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">用CloudFormation定义WebSocket Api与REST或HTTP Api没有太大区别。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="992d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，我们在ApiGateway资源上定义了到<code class="fe ms mt mu mv b">WEBSOCKET</code>的协议类型，并创建了一个路由<code class="fe ms mt mu mv b">processUrl</code>，其目标是与StartTaskLambda集成。你可以在这里找到这个WebSocket Api的完整CF模板<a class="ae lv" href="https://github.com/ziedbentahar/aws-easy-reader/blob/main/aws/cfn/easy-reader-components/websocket-api-gateway.yml" rel="noopener ugc nofollow" target="_blank"/></p><h2 id="15e7" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">测试后端部署</h2><p id="99d8" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">一旦部署了所有这些后端组件，我们将能够执行Websocket Api测试。邮递员让一切变得简单。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/e276546619bb08d10f87450537ea475d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*00_G7FgWPIPCt6aFO8Rf7A.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">在Postman中创建新的WebSocket请求</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/8066c589f16bf7616aac20b77e973f7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1O2tvaJmdgIgsuHPvGqv1w.gif"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">用postman测试WebSocket api</figcaption></figure></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="c32a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上一节中，我们着重于构建“简易阅读器”的后端，现在让我们来处理前端部分。</p><h2 id="8d5e" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">催单</h2><p id="9823" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">你可以在这里找到Github工作流程的完整报告👉<a class="ae lv" href="https://github.com/ziedbentahar/aws-easy-reader" rel="noopener ugc nofollow" target="_blank">https://github.com/ziedbentahar/aws-easy-reader</a></p><h2 id="66a7" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">构建前端</h2><p id="6759" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">在这一节中，我们将主要关注查询“Easy Reader”web socket Api和处理异步响应。</p><p id="1566" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里找到完整的React应用程序<a class="ae lv" href="https://github.com/ziedbentahar/aws-easy-reader/tree/main/src/frontend/easy-reader-front" rel="noopener ugc nofollow" target="_blank">⚛️</a></p><p id="f971" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">简易阅读器挂钩</strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="fac8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ms mt mu mv b">useEasyReader</code>接受一个URL，创建一个WebSocket连接并发送一个<code class="fe ms mt mu mv b">processArticle</code>命令，该命令将URL作为有效载荷。然后，它等待两个事件:</p><ul class=""><li id="d92f" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated">事件，其有效负载包含相对于可读文章内容的S3对象的预签名URL。</li><li id="f0d6" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated"><code class="fe ms mt mu mv b">audioGenerated</code>在有效负载上提供音频URL的事件</li></ul><p id="974c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个钩子返回一个对象，提供将在组件级使用的处理进度状态、文章内容和audioUrl。</p><p id="1822" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">反过来，<a class="ae lv" href="https://github.com/ziedbentahar/aws-easy-reader/blob/bd4ad2e39d49d54ee97129cd6f34980ee060c325/src/frontend/easy-reader-front/src/App.tsx#L103" rel="noopener ugc nofollow" target="_blank">组件</a>对进度事件做出反应，并逐步处理不同的事件类型。</p><h2 id="b9e2" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated"><strong class="ak">定义前端的基础设施</strong></h2><p id="9b14" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">如上面的架构图所示，为了在AWS上部署前端部分，我们将创建一个S3存储区，用于存储和服务捆绑的react应用程序。然后我们将把它作为一个原点附加到CloudFront发行版上。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="7473" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">S3存储桶只允许访问原始访问身份(OAI ),这是一个特殊的CloudFront用户。这样，我们只允许CloudFront访问桶，而拒绝其他任何东西。</p><h2 id="8bc8" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">关于构建/部署管道的一句话</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nn"><img src="../Images/0d48afb56c0c21253dccf07acccdff29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XnVTGzr5yV8Z3wPR1X-dWg.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">Easy reader主Github操作管道</figcaption></figure><p id="6366" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我不会深入Github操作的构建和部署管道。您可以通过<a class="ae lv" href="https://github.com/ziedbentahar/aws-easy-reader/blob/main/.github/workflows/main-pipeline.yml" rel="noopener ugc nofollow" target="_blank">链接</a>找到完整的管道工作流程。你也可以在<a class="ae lv" href="https://medium.com/@zied-ben-tahar/aws-lambda-function-urls-with-net-6-minimal-api-727b6d2087a5" rel="noopener">这篇文章</a>中找到关于设置Github动作管道的逐步指南。</p><h2 id="8380" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">🎉行动中的简易阅读器</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi no"><img src="../Images/5e53378b410a9e726cda4c8728e5dbf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*oOxkM4_I2q6lKpLT6QAfow.gif"/></div></div></figure></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h2 id="eb49" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">进一步阅读</h2><div class="np nq gp gr nr ns"><a href="https://aws.amazon.com/blogs/compute/from-poll-to-push-transform-apis-using-amazon-api-gateway-rest-apis-and-websockets/" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd ir gy z fp nx fr fs ny fu fw ip bi translated">从轮询到推送:使用Amazon API Gateway REST APIs和WebSockets转换API | Amazon Web…</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">本文由Adam west rich(AWS首席解决方案架构师和Ronan Prenty(云支持工程师)提供…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">aws.amazon.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og kv ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://aws.amazon.com/step-functions/use-cases/" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd ir gy z fp nx fr fs ny fu fw ip bi translated">AWS步骤功能使用案例|无服务器微服务编排| Amazon Web Services</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">使用AWS Step函数可以自动化什么？从下面一些最流行的用例中获得一些想法。AWS步骤…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">aws.amazon.com</p></div></div><div class="ob l"><div class="oh l od oe of ob og kv ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://aws.amazon.com/blogs/compute/node-js-16-x-runtime-now-available-in-aws-lambda/" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd ir gy z fp nx fr fs ny fu fw ip bi translated">Node.js 16.x运行时现已在AWS Lambda | Amazon Web Services中提供</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">这篇文章是由无服务器首席专家解决方案架构师Dan Fox撰写的。你现在可以开发AWS Lambda…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">aws.amazon.com</p></div></div><div class="ob l"><div class="oi l od oe of ob og kv ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://labrlearning.medium.com/a-deep-dive-into-amazon-polly-3672baf6c624" rel="noopener follow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd ir gy z fp nx fr fs ny fu fw ip bi translated">深入亚马逊波利</h2><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">labrlearning.medium.com</p></div></div><div class="ob l"><div class="oj l od oe of ob og kv ns"/></div></div></a></div></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h1 id="074c" class="ok ky iq bd kz ol om on lc oo op oq lf or os ot li ou ov ow ll ox oy oz lo pa bi translated">分级编码</h1><p id="a98c" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="3bf2" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="6074" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">📰查看<a class="ae lv" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="0a31" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">🔔关注我们:<a class="ae lv" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae lv" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae lv" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="0373" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀👉<a class="ae lv" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">将像你这样的开发人员安置在顶级创业公司和科技公司</strong> </a></p></div></div>    
</body>
</html>