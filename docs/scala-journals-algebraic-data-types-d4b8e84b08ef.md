# Scala 期刊—代数数据类型

> 原文：<https://levelup.gitconnected.com/scala-journals-algebraic-data-types-d4b8e84b08ef>

![](img/7875cb4989958b2e1ba832212d327460.png)

我提到过函数式编程是关于数据**和操作**之间非常清晰的划分。我们不把它们混在一起。一个像 OO 一样的设计，其中一个类有私有字段和作用于它们的方法，这是一个很好的例子。****

****还记得我之前提到过几次，当我想到 Scala 时，我会想到代数吗？如果不是对象(数据)和对它们的操作(函数)*，代数到底是什么？今天我将谈论数据块，确切地说是`1 + 2 = 3`中的“1”、“2”和“3”。****

# ****什么是代数数据类型(ADTs)？****

****首先，在函数式编程的上下文中 **ADT 并不意味着抽象数据类型**。我听过这个错误很多次了，正如你在这篇文章后会意识到的，这是两个独立的(讽刺的是非常相反的)概念。****

****好的。我们开始吧。直截了当地理解 ADT 非常重要，因为其背后的思想非常简单，但定义可能会非常混乱。此外，这听起来像一些疯狂的函数式编程的东西，几乎像 M 字…但相信我，它不是！****

******代数数据类型**都是关于(并且仅仅是关于)描述数据的。这都是关于拥有和是一种关系。好消息是，如果您在使用某种 ADT 之前已经使用过 case 类。****

****ADT 有两种基本类型:**总和**和**乘积**。让我们开始吧。****

# ****总和 ADT****

****可能实例数量有限的类型。把 sum 想象成一个**是一个**或**或**类型。****

****例如类型“风味”。只有一些可能的实例，并且它们是唯一被允许的(比如 enum！).****

```
**sealed trait Flavour
case object Savoury extends Flavour
case object Salty extends Flavour
case object Sweet extends Flavour
case object Sour extends Flavour**
```

****从以下方面考虑 IS-A /或零件:****

*   ****咸味是一种味道。****
*   ****长**不是**的一种味道。****
*   ****T21 有四种口味可供选择:咸、甜、酸。****
*   ****味道可以是酸的**或甜的******
*   ****味道不能同时是甜的和酸的(好吧，这是有争议的，可能不是现实生活中食物的最佳模型，但你明白了！)****

## ****为什么密封 trait 和 case 对象而不仅仅是 case 类？****

****两个主要原因:我们只需要每种价值的一个实例(为什么我们需要可口的两个实例？)并且我们想在它们上面进行模式匹配。****

****密封特征只能在定义它们的文件中扩展。我们不希望有人在某个随机文件中摇滚并扩展我们的基本特征(风味)。我们想看看我们的 ADT，确切地知道我们正在使用什么数据模型，没有隐藏的惊喜。****

****至于 case 对象:Scala 中的对象是单例的，case 类是模式匹配的梦想。人们可以猜测，case 对象从两个世界中各取一点，最终成为一个很容易进行模式匹配的单例对象。(然而，它们不仅仅如此——请务必查阅它们！)****

## ****我应该用 Sum ADT 建模什么？****

****一般来说，当你知道所有可能的值时。有点像枚举。以下是一些想法:****

*   ****帐户状态:活动、非活动、已阻止****
*   ****方向:北、南、东、西****
*   ****季节:冬天，夏天，春天，秋天****
*   ****性别:女性、男性、其他****
*   ****大陆:欧洲，亚洲，非洲，北美，南美，南极洲，澳大利亚****
*   ****取款人错误:没有足够的资金，帐户被冻结，资金不可用****

****对于最后一种错误，请记住它是单例的，所以如果您不关心错误消息，请只使用 Sum。顺便提一下:注意我们不会抛出异常，而是使用 ADTs。ADTs 在某种程度上迫使你去思考你所有的边缘案例。****

# ****产品 ADT****

****允许您创建具体实例的类型。把它想象成**有**或者**和**类型。****

```
**sealed trait Creature
case class Human(name: String, dateOfBirth: Date) extends Creature
case class Alien(name: String, spaceshipId: SpaceshipId) extends Creature
case class Animal(name: String, dateOfBirth: Date) extends Creature**
```

****显然，人类、外星人和动物有某些**特征**将他们区分开来，使他们成为不同种类的生物，但为了简单起见，我们现在忽略这一点。****

****从以下方面考虑 HAS-A / AND 部分:****

*   ****人类**有一个**名字**和**出生日期****
*   ****外星人**有一个**名字**和**一个太空飞船 Id****

## ****为什么要密封 trait 和 case 类？****

****出于和 sum 一样的原因，我们希望所有的东西都在一个地方。Case 类，因为我们希望用给定的构造函数参数实例化人类、外星人和动物，并且能够对它们进行模式匹配。****

## ****我应该使用产品 ADT 建立什么模型？****

*   ****递归结构:****

```
**sealed trait Person
case class Child(name: String, parent: Person) extends Person
case class Parent(name: String) extends Person**
```

*   ****消息错误****

```
**sealed trait Error
case class RegistrationError(msg: String) extends Error
case class LoginError(msg: String) extends Error**
```

*   ****任何其他感觉自然的产品真的！****

# ****混合 ADT****

****尽管如此，在编程中，我们并不总是有灵丹妙药和现成的解决方案。在某些情况下，混合求和与乘积可能是有意义的。阿尔文·亚历山大的一个很好的例子:****

```
**sealed trait Shape
final case class Circle(radius: Double) extends Shape
final case class Rectangle(width: Double, height: Double) extends Shape**
```

# ****为什么叫“和”和“积”？那是令人困惑的。****

****有一段时间我对命名感到困惑，可能你也是。当你对命名感到困惑的时候，想想**“我能得到的所有可能的实例列表是什么？”**。****

****对于代数**和**，你已经指定了所有的选项(实例)。如果你把所有的都加起来，你就有了所有实例的列表。对于`Creature`，你唯一的选择是:`Human`、`Alien`和`Animal`****

****对于代数**乘积**来说，可能有无限数量的实例。假设你的数据类型需要一个 Long 作为构造函数。那么你的数据可能是我的类型(1)，我的类型(23)，我的类型(235554)，我的类型(0)，我的类型(4848444)…现在想象你的数据类型接受一个 Int 和一个 String！你必须将所有可能的字符串乘以所有可能的整型数来得到所有可能的实例。所以让我们看看…我的类型(-2147483648，"")，我的类型(-2147483647，" a ")，我的类型(-2147483646，" b)"…你明白了！****

# ****但是如果 ADT 都是关于数据的，那么你怎么用它们做任何事情呢？****

****代数又来帮忙了！****

****如果 ADT 在`1 + 2 = 3`中为“1”、“2”、“3 ”,这意味着它们只是数据的表示，并且需要对它们进行操作。听起来像是**的功能**，不是吗？****

```
**sealed trait Shape
final case class Circle(radius: Double) extends Shape
final case class Rectangle(width: Double, height: Double) extends Shape

def calculateShapeArea(shape: Shape) = {
    shape match {
        case Circle(r)       => circleArea(r)
        case Rectangle(w, h) => rectangleArea(w, h)
    }
}**
```

****提醒一下我已经提到过几次的两条经验法则:****

1.  ****边复制边更新，不要变异！****
2.  ****写函数，不要写有字段和方法的类，记住——数据和函数是分开的，就像在代数中一样****

# ****摘要****

****ADT 不外乎是一种表示数据的方式。有一个 sum(带有 case 对象的密封特征)和一个 product(带有 case 类的密封特征)。有时候想出一个混血儿也是可以的！****

****(*)如果你是一名数学家，你将不得不说很多，但让我们保持简单。****