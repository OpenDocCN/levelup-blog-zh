# 不可变的对象值得努力

> 原文：<https://levelup.gitconnected.com/immutable-objects-are-worth-the-effort-7b1b582e3203>

![](img/7abe115aafd74e35007ab17af465bc43.png)

[Quino Al](https://unsplash.com/@quinoal?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](https://unsplash.com/s/photos/fired-clay?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

我以前写过关于不可变构建器是我最喜欢的编写简单代码的模式之一。这种模式既迫使您在开始构建之前考虑您正在构建的对象需要什么，也消除了对哪些构造函数可用的思考。使用像 [Lombok](https://projectlombok.org/) 或者甚至(恰当命名的)[不变的](https://immutables.github.io/)这样的工具，您可以很容易地在代码库中创建具有相同“感觉”的不可变对象和构建器。

但是有一点我在上一篇文章中没有提到，那就是从不可变对象本身获得的收益。它们和建筑工人本身一样，甚至更有价值。让我告诉你为什么。

## 首先，一个尴尬的故事

我最近在工作中处理一些代码(顺便说一下，我们正在招聘员工！)我需要有效地将一些对象“合并”在一起。我正在研究的服务实际上是一个网关，可以对需要调用的其他服务做出业务决策。每个服务都是并行调用的，每个服务的结果需要结合起来才能得到网关的最终结果。

每个服务都返回一个相同类型的对象，目标是将其中一个对象用作“基本对象”，并用返回的其他对象丰富它们。从表面上看，这似乎很简单，对吗？

嗯，我一开始没有提到的一点是，每当不需要调用服务时，我都会使用“默认”响应。因此，这个对象有时会是服务客户端第一个没有调用**的响应。这个对象也是静态分配的，并且是可变的。**

将这些响应对象合并在一起的过程的一部分主要是将值从一个对象填充到另一个对象中。起初，这似乎很好；也许有一种更好的方法，但是在主要进行数据传递和转换的服务中，迭代地图中的元素是相当标准的。

无论如何，我让我的代码工作起来，写了一些测试，事情看起来总体上是好的。然后我开始注意到似乎是一种“缓存”行为。有时，服务不应该被调用，而是返回服务的*先前的*响应。我找不到它，一直在寻找任何可以存储先前响应对象的地方，直到…

我意识到我实际上是在更新静态分配的默认响应对象的映射！因为对象是可变的，以前的响应条目**是** 总是存储在默认响应中，如果服务没有被实际调用，则返回这些条目。谢天谢地，这很容易解决。我编写了更改代码，使对象不可变，重新运行我的测试，一切都很好。

## 不变性有更强的国家保障

我讲这个故事是因为可变对象总是冒着在你不期望它们改变的时候改变的风险。不可变对象没有同样的风险。

这可能就像我的例子，没有意识到我正在更新一个现有的对象。也可能是比赛条件。或者，当一个对象在一个复杂的代码库中从一个方法移动到另一个方法时，它甚至可能误解了更改对象的含义。

当您对正在使用的对象有了不变性保证时，您就对应用程序的状态更有信心了。这种信心转化为在你的应用中检查更少的极限情况，因为有**实际上**更少的极限情况可能发生。你的代码得到了一个对象，那就是——不用担心引用被别人保存并在你脚下操纵它。

## 不可变对象更容易理解

因为不可变对象通常只有一种创建方式，并且只公开对其内部状态的访问，所以理解如何创建和使用它们变得容易得多。

部分原因是因为它们通常都很小。这对我来说可能只是轶事，但是创建不可变对象帮助我在对象之间找到更好的边界，否则最初可能会更大。

这是为什么呢？因为如果我需要改变一个状态，我不想一遍又一遍地重新创建对象。这让我更深入地思考对象之间的关系*实际上是如何在代码中工作的*，这导致了更小的对象。小通常意味着简单。

## 不变的对象迫使你提前思考

在任何带有对象的语言中，常见的做法是看到类似这样的代码:

```
MyObject m = new MyObject();
m.setSomeProperty(someValue);
m.setAnotherProperty(someFunctionThatReturnsTheValue());
if (someBooleanExpression) {
    m.setSomeConditionalProperty(conditionalValue);
}
```

有趣的是，对象是在之前**被创建的，对象需要的所有东西甚至都是被构造或已知的。**

虽然这看起来微不足道，但我的观点是它是落后的。在创建另一个对象之前，你应该知道你需要什么值来创建它！这个小小的改变带来了巨大的好处。

首先，您可以在对象构造时进行更好的验证，这样您就知道每个对象都是有效的。对于可变对象，您很难获得同样的保证。可能已经设置了所需的值，也可能没有设置。您*可以*在每个 setter 上执行正确的验证，但是如果它在一个地方，编写和维护起来会容易得多。

第二，代码更容易理解。如果在创建目标对象之前有许多事情要准备，那么您可以在构建对象之前完成所有这些工作。如果你有一些小函数，专注于构建和返回对象，比如工厂，那么这些函数的最后一行都开始返回一个新创建的对象。

## 不变性有助于编写干净的代码

[*干净代码*](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship-ebook/dp/B001GSTOAM) 最重要的规则/法则之一就是函数不应该有副作用。他们应该做一件事，把它做好，并且只做**那一件事。**

使用不可变对象使得产生副作用更加困难。回到第一点:如果你不能轻易地改变状态，那么，你也不能轻易地改变状态。你可以保证用一个不可变的对象调用一个方法不会改变它。

不可变对象的其他干净代码的好处也围绕着干净代码的故事方面。从一个起点开始，以一种可理解的方式添加人物或细节，然后展示这些片段如何共同创造一个故事，这样读起来要容易得多。不可变对象有助于讲述这个故事。

不过，不要误会我的意思。用不可变对象编码通常会产生更多的代码。如果你想改变它，你不能只设置状态。您必须创建对象的全新实例，并将该对象传播到需要更新的地方。

在某些情况下，这是不切实际的。有时创建新对象的开销不符合要求。这些情况通常会出现在诸如**故意**在各种组件之间共享状态，并且状态由一个唯一的对象非常精确地管理(想想单例)。重点不是完全避免使用可变对象。相反，只要首先选择不变性，直到您意识到某些状态需要与特定的约束和原因共享。

## 不变性的最佳用例

不可变对象的最佳情况是在倾向于反应式编程模型的应用程序中找到的。特别是流处理，不可变结构有巨大的好处。您从一个流中读取一个事件，从中创建聚合或将它写入存储，甚至丰富它并将其放在另一个流中。没有很大的理由对从流中读取的事件进行大量修改。相反，您可以创建新的对象，这些对象是根据需要存储或传递的事件创建的。

REST APIs 也有同样的好处。一旦一个不可变的对象在 API 层从请求体被反序列化，您就有信心该对象代表了请求中提交的内容。当使用带有默认可选值的补丁请求或请求体时，使用像 [Lombok](https://projectlombok.org/) 或其他代码生成器这样的工具甚至可以让您在对象创建时指定这些默认值。

总而言之，不可变对象不会解决你所有的编码问题，但是它们可以在很多方面有所帮助。一旦你掌握了诀窍，我相信它会帮助你写出更简单、更整洁的代码。

编码快乐！