<html>
<head>
<title>7 Laws That Software Engineer Must Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件工程师必须知道的7条定律</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/7-laws-that-software-engineer-must-know-40775650f824?source=collection_archive---------10-----------------------#2020-09-26">https://levelup.gitconnected.com/7-laws-that-software-engineer-must-know-40775650f824?source=collection_archive---------10-----------------------#2020-09-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5347" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这些法律背后都包含着某种原则</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/897d6e17e508c59901dfba179d9f4ce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xqElYYwIds8NChYEdGxH7Q.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">比尔·牛津在<a class="ae kv" href="https://unsplash.com/s/photos/law?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="efcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当人们谈论发展时，会讨论很多定律。大多数工程师喜欢谈论一些原则和模式，却没有意识到它们与某个法律名称相关联。有几个场合，高级工程师认为初级工程师不知道某个原理，只是因为他们不知道一个定律是什么意思。</p><p id="dd1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个列表包含了一些法律、原则和模式的解释，但是<em class="ls">并不提倡</em>任何一个。是否应该应用它们将永远是一个争论的问题，并且很大程度上取决于你正在做什么。先说最受欢迎的一个。</p><h1 id="013b" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">墨菲定律/ Sod定律</h1><p id="30dd" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Murphy%27s_law" rel="noopener ugc nofollow" target="_blank">维基百科上的墨菲定律</a></p><blockquote class="mq mr ms"><p id="daa5" class="kw kx ls ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="iq">任何可能出错的事情都会出错。</em>T11】</strong></p></blockquote><p id="6eff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与<a class="ae kv" href="https://en.wikipedia.org/wiki/Edward_A._Murphy_Jr." rel="noopener ugc nofollow" target="_blank">爱德华·a·墨菲(Edward A. Murphy，Jr)</a>，<em class="ls">墨菲定律</em>指出，如果一件事可能出错，它就会出错。</p><p id="173c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是开发人员常用的格言。有时在开发、测试甚至生产中会发生意想不到的事情。这也可能与(英国英语中更常见的)<em class="ls"> Sod定律</em>有关:</p><blockquote class="mq mr ms"><p id="cedd" class="kw kx ls ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">如果事情会出错，它会在最糟糕的时候出错。 </p></blockquote><p id="d0cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">诸如<a class="ae kv" href="https://en.wikipedia.org/wiki/Confirmation_bias" rel="noopener ugc nofollow" target="_blank"> <em class="ls">确认偏差</em> </a>和<a class="ae kv" href="https://en.wikipedia.org/wiki/Selection_bias" rel="noopener ugc nofollow" target="_blank"> <em class="ls">选择偏差</em> </a>之类的现象可能会导致人们过度强调这些规律(大多数时候，当事情成功时，它们会被忽视，然而失败却更引人注目，并引起更多的讨论)。</p><p id="0286" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管这些定律很受欢迎，而且似乎是工程师的自然理解，但人们喜欢陷入自己的假设，导致失败和失误。</p><h1 id="0c4f" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">德米特里定律</h1><p id="6119" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Law_of_Demeter" rel="noopener ugc nofollow" target="_blank">维基百科上的德米特里定律</a></p><blockquote class="mq mr ms"><p id="89ab" class="kw kx ls ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="iq">不要和陌生人说话。</em> </strong></p></blockquote><p id="ce87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">德米特法则，也称为“最少知识原则”，是软件设计的一个原则，特别是在面向对象语言中。德米特定律是<a class="ae kv" href="https://en.wikipedia.org/wiki/Loose_coupling" rel="noopener ugc nofollow" target="_blank">松耦合</a>的一个特例。</p><p id="ba2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它规定一个软件单元应该只和它的直接合作者交谈。引用了对象<code class="fe mw mx my mz b">B</code>的对象<code class="fe mw mx my mz b">A</code>可以调用它的方法，但是如果<code class="fe mw mx my mz b">B</code>引用了对象<code class="fe mw mx my mz b">C</code>，<code class="fe mw mx my mz b">A</code>不应该调用<code class="fe mw mx my mz b">C</code>的方法。所以，如果<code class="fe mw mx my mz b">C</code>有一个<code class="fe mw mx my mz b">doThing()</code>方法，<code class="fe mw mx my mz b">A</code>不应该直接调用它；<code class="fe mw mx my mz b">B.getC().doThis()</code>。</p><p id="e176" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">维基百科上LoD的规则是:</p><ul class=""><li id="c4e1" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated">每个单元应该只对其他单元有有限的了解:只有与当前单元相关的单元。</li><li id="22dc" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">每个单位应该只和自己的朋友说话；不要和陌生人说话。</li><li id="3a03" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">只和你最亲近的朋友说话。</li></ul><p id="bda5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">遵循这个原则限制了变化的范围，使它们在未来变得更容易和更安全。它还提出了一个概念，即一个给定的对象应该尽可能少地假设其他任何东西(包括其子组件)的结构或属性。</p><h1 id="6ff7" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">过早优化效应</h1><p id="1ad0" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><a class="ae kv" href="http://wiki.c2.com/?PrematureOptimization" rel="noopener ugc nofollow" target="_blank">维基百科上的过早优化</a></p><blockquote class="mq mr ms"><p id="1c36" class="kw kx ls ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="iq">过早优化是万恶之源。</em> </strong></p></blockquote><p id="ecc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Donald Knuth的论文<a class="ae kv" href="http://wiki.c2.com/?StructuredProgrammingWithGoToStatements" rel="noopener ugc nofollow" target="_blank">Structured Programming With Go To Statements</a>中，他写道:“程序员浪费了大量的时间来考虑或担心他们程序的非关键部分的速度，当考虑到调试和维护时，这些提高效率的尝试实际上会产生强烈的负面影响。我们应该忘记小的效率，比如说97%的时候:过早的优化是万恶之源。然而，我们不应该错过这关键的3%的机会。”</p><p id="0948" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，<em class="ls">过早优化</em>可以被定义为在我们知道我们需要优化之前的优化。</p><h1 id="6617" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">坎宁安定律</h1><p id="c241" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Ward_Cunningham#Cunningham's_Law" rel="noopener ugc nofollow" target="_blank">维基百科上的坎宁安定律</a></p><blockquote class="mq mr ms"><p id="e53f" class="kw kx ls ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="iq">在网上获得正确答案的最好方法不是提问，而是贴出错误答案。</em> </strong></p></blockquote><p id="a953" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">据史蒂文·麦吉迪说，沃德·坎宁安在20世纪80年代早期建议他:“在互联网上获得正确答案的最好方法不是提问，而是发布错误的答案。”麦吉迪称之为坎宁安定律，尽管坎宁安否认所有权，称其为“错误引用”。虽然最初指的是新闻组上的互动，但该法律已被用来描述其他在线社区的工作方式(如维基百科、Reddit、Twitter、脸书)。</p><h1 id="63b5" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">柯尼根定律</h1><blockquote class="mq mr ms"><p id="6e67" class="kw kx ls ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="iq">调试比一开始写代码难一倍。因此，如果你尽可能聪明地编写代码，从定义上来说，你没有足够的聪明去调试它。</em>T3】</strong></p></blockquote><p id="dfb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">柯尼根定律是以<a class="ae kv" href="https://en.wikipedia.org/wiki/Brian_Kernighan" rel="noopener ugc nofollow" target="_blank">布莱恩·柯尼根</a>的名字命名的，并引自柯尼根和普劳格尔的书<a class="ae kv" href="https://en.wikipedia.org/wiki/The_Elements_of_Programming_Style" rel="noopener ugc nofollow" target="_blank">编程风格的要素</a>:</p><blockquote class="mq mr ms"><p id="765b" class="kw kx ls ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated"><em class="iq">大家都知道，调试比一开始写程序难两倍。所以，如果你在编写它的时候尽可能的聪明，你将如何调试它呢？</em></p></blockquote><p id="a24b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然是双曲线，但Kernighan定律认为简单代码比复杂代码更好，因为调试复杂代码中出现的任何问题都可能成本高昂，甚至不可行。</p><h1 id="d377" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">莱纳斯定律</h1><p id="59a3" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Linus%27s_law" rel="noopener ugc nofollow" target="_blank">维基百科上的莱纳斯定律</a></p><blockquote class="mq mr ms"><p id="0341" class="kw kx ls ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="iq">给足了眼球，所有的bug都是浅的。</em>T15】</strong></p></blockquote><p id="2e64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这条定律简单地说明了，越多的人能够发现问题，越有可能有人已经发现并解决了这个问题，或者类似的东西。</p><p id="0bc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然它最初是用来描述项目的开源模型的价值，但是它可以被任何种类的软件项目所接受。它还可以扩展到过程——更多的代码审查、更多的静态分析和多学科测试过程将使问题更加明显和容易识别。</p><p id="0f7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更正式的说法可以是:</p><blockquote class="mq mr ms"><p id="8166" class="kw kx ls ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">如果有足够多的测试人员和合作开发人员，几乎每个问题都会很快被描述出来，并且可以由以前遇到过类似问题的人来解决。</p></blockquote><p id="fe75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这条法律是为了纪念埃里克·s·雷蒙德的书《大教堂和集市》中的莱纳斯·托瓦尔兹而命名的。</p><h1 id="6308" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">摩尔定律</h1><p id="ce16" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Moore%27s_law" rel="noopener ugc nofollow" target="_blank">维基百科上的摩尔定律</a></p><blockquote class="mq mr ms"><p id="434f" class="kw kx ls ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="iq">集成电路中的晶体管数量大约每两年翻一番。</em>T3】</strong></p></blockquote><p id="9c6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">摩尔的预测经常被用来说明半导体和芯片技术进步的绝对速度，事实证明，从20世纪70年代到21世纪初，摩尔的预测非常准确。最近几年，这一趋势略有改变，部分原因是由于<a class="ae kv" href="https://en.wikipedia.org/wiki/Quantum_tunnelling" rel="noopener ugc nofollow" target="_blank">对组件小型化程度的物理限制</a>。然而，并行化的进步，以及半导体技术和量子计算的潜在革命性变化，可能意味着摩尔定律在未来几十年可能继续适用。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="32c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你们可能知道，除了我选的这7条，还有很多其他的法律。就我个人而言，我选择这些是因为我至少一两次听到有人提到这些法律。</p><p id="511b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管遵守每一条法律不会帮助我们成为最好的工程师，但知道它的含义可以帮助我们理解在讨论或采访中何时会提到这条法律。</p><blockquote class="mq mr ms"><p id="6a74" class="kw kx ls ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">一个人的“魔术”是另一个人的工程。“超自然”是一个空词。</p></blockquote></div></div>    
</body>
</html>