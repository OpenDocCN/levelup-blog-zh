<html>
<head>
<title>Deep Dive on Stored Procedures with MySQL Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用MySQL数据库深入了解存储过程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/deep-dive-on-stored-procedure-with-mysql-database-3fa02669e2be?source=collection_archive---------0-----------------------#2021-05-01">https://levelup.gitconnected.com/deep-dive-on-stored-procedure-with-mysql-database-3fa02669e2be?source=collection_archive---------0-----------------------#2021-05-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2ca1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">存储过程</strong>是编译后的代码，您可以从SQL语句或客户端应用程序中调用它。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/33dd3283a4f0be2110257549bf1f4aac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5JkfkuVH_UCi2-QPryJS6Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图像信用—www.tutorialrepublic.com</figcaption></figure><p id="7f4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">存储过程是一组具有指定名称的结构化查询语言(SQL)语句，作为一个组存储在关系数据库管理系统(RDBMS)中，因此可以由多个程序重用和共享。</p><p id="0ce4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，如果您有一个反复编写的SQL查询，请将其保存为存储过程，然后调用它来执行它。</p><p id="89ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦存储过程运行，它就保留在内存中，因此下一个用户可以运行它，而不会产生将它加载到内存中的开销。</p><p id="37ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将讨论以下主题</p><ul class=""><li id="f302" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">什么是存储过程？它有哪些用例？</li><li id="da28" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">存储过程的优缺点</li><li id="d5d3" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如何编写一个存储过程并描述它的关键字，如输入和输出参数。</li><li id="16a2" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">在MySQL数据库中编写不同标准的存储过程。</li></ul></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="afc3" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">什么是存储过程</h1><ul class=""><li id="20d4" class="lu lv it la b lb nh le ni lh nj ll nk lp nl lt lz ma mb mc bi translated">存储过程(也称为proc、storp、sproc、StoPro、StoredProc、StoreProc、sp或SP)是访问关系数据库管理系统(RDBMS)的应用程序可用的子例程。</li><li id="56cb" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">存储过程是分组为一个逻辑单元并存储在数据库中的一批语句。存储过程接受参数并执行过程中的T-SQL语句，如果有结果集，则返回结果集。</li><li id="8842" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">这样的过程存储在数据库数据字典中。</li><li id="c130" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">存储过程是一批SQL语句，可以用几种方式执行。大多数主要的DBMS都支持存储过程；然而，并不是所有人都这样做。您将需要验证您的特定DBMS帮助文档的细节。</li><li id="9cf6" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">还可以将参数传递给存储过程，以便存储过程可以根据传递的参数值进行操作。</li></ul><h1 id="09bc" class="mp mq it bd mr ms nm mu mv mw nn my mz jz no ka nb kc np kd nd kf nq kg nf ng bi translated">使用存储过程的好处</h1><h2 id="51f9" class="nr mq it bd mr ns nt dn mv nu nv dp mz lh nw nx nb ll ny nz nd lp oa ob nf oc bi translated"><strong class="ak">很容易修改</strong></h2><ul class=""><li id="2da1" class="lu lv it la b lb nh le ni lh nj ll nk lp nl lt lz ma mb mc bi translated">我们可以轻松地修改存储过程中的代码，而无需重启或部署应用程序。</li><li id="938d" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">例如，如果SQL查询是在应用程序中编写的，并且如果我们需要更改逻辑，我们必须更改应用程序中的代码并重新部署它。</li><li id="d5f5" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">存储过程通过将代码存储在数据库中来消除这种挑战。因此，当我们想改变过程内部的逻辑时，我们可以通过简单的ALTER PROCEDURE语句来实现。</li></ul><h2 id="3977" class="nr mq it bd mr ns nt dn mv nu nv dp mz lh nw nx nb ll ny nz nd lp oa ob nf oc bi translated"><strong class="ak">表演</strong></h2><ul class=""><li id="4adb" class="lu lv it la b lb nh le ni lh nj ll nk lp nl lt lz ma mb mc bi translated">SQL Server存储过程在第一次执行时会创建一个计划并将其存储在缓冲池中，以便下次执行时可以重用该计划。</li><li id="09c9" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">使用存储过程可以减少客户端和服务器之间的网络流量，因为命令是作为一批代码执行的。这意味着只通过网络发送执行过程的调用，而不是单独发送每一行代码。</li></ul><h2 id="12b4" class="nr mq it bd mr ns nt dn mv nu nv dp mz lh nw nx nb ll ny nz nd lp oa ob nf oc bi translated"><strong class="ak">可重复使用</strong></h2><p id="a533" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh od lj lk ll oe ln lo lp of lr ls lt im bi translated">存储过程可以由多个用户或多个客户端应用程序执行，而无需重新编写代码。</p><h2 id="96b5" class="nr mq it bd mr ns nt dn mv nu nv dp mz lh nw nx nb ll ny nz nd lp oa ob nf oc bi translated"><strong class="ak">安全</strong></h2><p id="82f9" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh od lj lk ll oe ln lo lp of lr ls lt im bi translated">存储过程通过消除对表的直接访问来减少威胁。我们还可以在创建存储过程时对其进行加密，这样存储过程内部的源代码就不可见了。</p><h2 id="f7a2" class="nr mq it bd mr ns nt dn mv nu nv dp mz lh nw nx nb ll ny nz nd lp oa ob nf oc bi translated">更容易排除故障</h2><ul class=""><li id="f9ca" class="lu lv it la b lb nh le ni lh nj ll nk lp nl lt lz ma mb mc bi translated">与在图形用户界面(GUI)中嵌入查询相比，存储过程具有优势。</li><li id="35bf" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">由于存储过程是模块化的，所以当应用程序中出现问题时，更容易排除故障。</li><li id="3aa7" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">存储过程也是可调的，这样就不需要修改GUI源代码来提高性能。</li><li id="252f" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">编写存储过程比通过GUI构建查询更容易。</li></ul><h1 id="d6ba" class="mp mq it bd mr ms nm mu mv mw nn my mz jz no ka nb kc np kd nd kf nq kg nf ng bi translated">存储过程的缺点</h1><h2 id="b4a2" class="nr mq it bd mr ns nt dn mv nu nv dp mz lh nw nx nb ll ny nz nd lp oa ob nf oc bi translated">难以测试</h2><ul class=""><li id="f039" class="lu lv it la b lb nh le ni lh nj ll nk lp nl lt lz ma mb mc bi translated">首先，封装在存储过程中的业务逻辑变得非常难以测试(如果要测试的话)。</li><li id="d2f6" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">一些开发人员喜欢在存储过程之上编写一个瘦数据访问层来解决这个问题，但是即使在这种情况下，测试的范围也仅限于一些集成测试。</li><li id="6869" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">为存储过程中的任何业务逻辑编写单元测试是不可能的，因为没有办法清楚地将域逻辑与实际数据分开。嘲笑、假装或磕碰也是不可能的。</li></ul><h2 id="c6cf" class="nr mq it bd mr ns nt dn mv nu nv dp mz lh nw nx nb ll ny nz nd lp oa ob nf oc bi translated">难以调试</h2><ul class=""><li id="cc12" class="lu lv it la b lb nh le ni lh nj ll nk lp nl lt lz ma mb mc bi translated">根据数据库技术的不同，调试存储过程要么根本不可能，要么极其笨重。</li><li id="7ae1" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">一些关系数据库，如SQL Server，具有一些调试功能，而其他的则没有。</li><li id="876a" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">没有什么比使用数据库概要分析器来跟踪应用程序问题或通过打印语句调试数据库更糟糕的了。</li></ul><p id="f6eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">版本控制</strong></p><ul class=""><li id="0463" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">版本控制是存储过程不支持的另一个关键特性。</li><li id="a1c4" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">将存储过程更改放入可重新运行的脚本中，并将其放入版本控制系统中，这当然是明智的，但这并没有解决以下问题:存储过程中没有任何东西可以告诉我们存储过程处于哪个版本，以及在应用最新的脚本后是否有任何其他更改。</li></ul><p id="1a5c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">难以驾驭的历史</strong></p><ul class=""><li id="c36e" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">与版本控制类似，存储过程没有历史记录。</li><li id="4388" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">具体来说，如果业务逻辑跨越多个存储过程，那么在给定的时间点建立不同存储过程的不同版本的精确组合会非常困难。</li></ul><h2 id="601c" class="nr mq it bd mr ns nt dn mv nu nv dp mz lh nw nx nb ll ny nz nd lp oa ob nf oc bi translated">害怕变化</h2><ul class=""><li id="610d" class="lu lv it la b lb nh le ni lh nj ll nk lp nl lt lz ma mb mc bi translated">存储过程的最大缺点之一是很难区分系统的哪些部分使用它们，哪些部分不使用它们。</li><li id="f980" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">特别是如果软件被分解成多个应用程序，那么通常不可能一次找到所有的引用(或者如果开发人员没有对所有项目的读取权限，则根本不可能找到),因此可能很难确定某个变化将如何影响整个系统。</li><li id="b379" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">因此，存储过程带来了引入重大变更的巨大风险，开发团队通常会回避任何变更。有时，这可能会导致新的技术创新瘫痪。</li></ul><h1 id="498d" class="mp mq it bd mr ms nm mu mv mw nn my mz jz no ka nb kc np kd nd kf nq kg nf ng bi translated">如何编写存储过程</h1><h2 id="4d83" class="nr mq it bd mr ns nt dn mv nu nv dp mz lh nw nx nb ll ny nz nd lp oa ob nf oc bi translated">存储过程的结构</h2><p id="ac4a" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh od lj lk ll oe ln lo lp of lr ls lt im bi translated">通常，存储过程有参数。这些参数使存储过程更加有用和可重用。存储过程中的参数有三种模式:<code class="fe og oh oi oj b">IN,OUT</code>或<code class="fe og oh oi oj b">INOUT</code>。</p><p id="4d78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe og oh oi oj b"><strong class="la iu">IN</strong></code>参数<strong class="la iu">参数</strong></p><p id="e7aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe og oh oi oj b">IN</code>是默认模式。当您在存储过程中定义一个<code class="fe og oh oi oj b">IN</code>参数时，调用程序必须向存储过程传递一个参数。</p><p id="b271" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，<code class="fe og oh oi oj b">IN</code>参数的值受到保护。这意味着，即使您在存储过程中更改了参数<code class="fe og oh oi oj b">IN</code>的值，它的原始值在存储过程结束后也不会改变。换句话说，存储过程只对<code class="fe og oh oi oj b">IN</code>参数的副本起作用。</p><p id="d791" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe og oh oi oj b"><strong class="la iu">OUT</strong></code>参数<strong class="la iu">参数</strong></p><p id="0a3e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个<code class="fe og oh oi oj b">OUT</code>参数的值可以在存储过程中改变，它的新值被传递回调用程序。</p><p id="1c3d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，存储过程在启动时无法访问<code class="fe og oh oi oj b">OUT</code>参数的初始值。</p><p id="8c09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe og oh oi oj b"><strong class="la iu">INOUT</strong></code> <strong class="la iu">参数</strong></p><p id="457a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个<code class="fe og oh oi oj b">INOUT</code>参数是一个<code class="fe og oh oi oj b">IN</code>和<code class="fe og oh oi oj b">OUT</code>参数的组合。意味着调用程序可能会传递实参，存储过程可以修改<code class="fe og oh oi oj b">INOUT</code>参数，并将新值传递回调用程序。</p><p id="3940" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的数据库ER图如下所示</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/638e93705538acad7de2228a7739610e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-EVNBoN-_xwcjgwCrWjQxQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源—作者</figcaption></figure><p id="045d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，它是一个典型的博客数据库。</p><ul class=""><li id="7528" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">在用户表中，它的ID列是主键</li><li id="9f3b" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">在post表中，用户id是一个外键，来自用户表</li></ul><h2 id="095d" class="nr mq it bd mr ns nt dn mv nu nv dp mz lh nw nx nb ll ny nz nd lp oa ob nf oc bi translated">不带out参数的存储过程</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="4568" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，IN参数是emailNo，给出的响应是userId、全名、电子邮件、文章标题、描述和发布日期</p><p id="ac6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">调用过程如下所示</p><pre class="kj kk kl km gt on oj oo op aw oq bi"><span id="ff21" class="nr mq it oj b gy or os l ot ou">call blog.get_userList(‘<a class="ae ov" href="mailto:skarim@gmail.com" rel="noopener ugc nofollow" target="_blank">skarim@gmail.com</a>’);</span></pre><p id="fbbd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，输出是</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/c3873a70bf42da037c3748931cbbaffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mftc3cs3V9e-_LFDZuPXsQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源—作者</figcaption></figure><h2 id="e259" class="nr mq it bd mr ns nt dn mv nu nv dp mz lh nw nx nb ll ny nz nd lp oa ob nf oc bi translated">不带OUT参数的存储过程</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="eabb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，IN参数是emailNo，OUT参数是userId、全名、电子邮件、文章标题、描述和发布日期</p><p id="843c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">调用过程如下所示</p><pre class="kj kk kl km gt on oj oo op aw oq bi"><span id="531e" class="nr mq it oj b gy or os l ot ou">all blog.get_userList('<a class="ae ov" href="mailto:skarim@gmail.com" rel="noopener ugc nofollow" target="_blank">skarim@gmail.com</a>',<a class="ae ov" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@id</a>, <a class="ae ov" href="http://twitter.com/fullname" rel="noopener ugc nofollow" target="_blank">@fullname</a>, <a class="ae ov" href="http://twitter.com/email" rel="noopener ugc nofollow" target="_blank">@email</a>, <a class="ae ov" href="http://twitter.com/title" rel="noopener ugc nofollow" target="_blank">@title</a>,<a class="ae ov" href="http://twitter.com/description" rel="noopener ugc nofollow" target="_blank">@description</a>, <a class="ae ov" href="http://twitter.com/publishDate" rel="noopener ugc nofollow" target="_blank">@publishDate</a>);</span></pre><p id="efcd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，输出是</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/1f8a17c30f7248074e5e91a33a44b087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*URqSshyp33SnJoYNHggEFg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源—作者</figcaption></figure><h1 id="74a2" class="mp mq it bd mr ms nm mu mv mw nn my mz jz no ka nb kc np kd nd kf nq kg nf ng bi translated">结论</h1><p id="ef19" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh od lj lk ll oe ln lo lp of lr ls lt im bi translated">希望你喜欢这篇文章。快乐阅读:)</p><p id="04ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">参考文献<br/> </strong> 1。<a class="ae ov" href="https://dusted.codes/drawbacks-of-stored-procedures" rel="noopener ugc nofollow" target="_blank">https://dusted . codes/deprects-of-stored-procedures</a>2。<a class="ae ov" href="https://www.sqlshack.com/sql-server-stored-procedures-for-beginners/" rel="noopener ugc nofollow" target="_blank">https://www . SQL shack . com/SQL-server-stored-procedures-for-初学者/ </a> <br/> 3 .<a class="ae ov" href="https://www.w3schools.com/sql/sql_stored_procedures.asp" rel="noopener ugc nofollow" target="_blank">https://www.w3schools.com/sql/sql_stored_procedures.asp</a>T11】4。<a class="ae ov" href="https://searchoracle.techtarget.com/definition/stored-procedure" rel="noopener ugc nofollow" target="_blank">https://search Oracle . tech target . com/definition/stored-procedure</a></p></div></div>    
</body>
</html>