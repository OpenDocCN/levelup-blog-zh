<html>
<head>
<title>Learning C++: Sorted-Range Algorithms of the STL Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习c++:STL的排序范围算法第2部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-sorted-range-algorithms-of-the-stl-part-2-701f34396f99?source=collection_archive---------5-----------------------#2020-05-02">https://levelup.gitconnected.com/learning-c-sorted-range-algorithms-of-the-stl-part-2-701f34396f99?source=collection_archive---------5-----------------------#2020-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e56b37d541c0320717ec9d529ef9361a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L3ODnhodqZljWulM"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">约书亚·科尔曼在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="b73b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我将继续讨论标准模板库(STL)中的排序范围算法。这些算法执行诸如合并容器和执行集合运算(如并、交和差)之类的任务。</p><h1 id="6b65" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">合并容器元素</h1><p id="f7ee" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">merge</code>函数获取两个容器范围的内容，并将它们合并到一个输出迭代器中。以下是该函数的语法模板:</p><p id="d561" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">输出-迭代器合并(范围1-开始，范围1-结束，范围2-开始，范围2-结束，<br/>输出-迭代器-开始)；</em></p><p id="ba61" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的程序合并了两个排序的、随机生成的数字向量，并通过输出迭代器将它们打印到屏幕上:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="34f0" class="mu lf it mk b gy mv mw l mx my">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;algorithm&gt;<br/>#include &lt;cstdlib&gt;<br/>#include &lt;ctime&gt;<br/>#include &lt;iterator&gt;<br/>using namespace std;</span><span id="e36a" class="mu lf it mk b gy mz mw l mx my">void buildVec(vector&lt;int&gt; &amp;vec, int n) {<br/>  for (int i = 1; i &lt;= n; i++) {<br/>    vec.push_back(rand() % 100 + 1);<br/>  }<br/>}</span><span id="5e9e" class="mu lf it mk b gy mz mw l mx my">void printVec(vector&lt;int&gt; &amp;vec) {<br/>  int i = 1;<br/>  for (const int n : vec) {<br/>    cout &lt;&lt; n &lt;&lt; " ";<br/>    if (i % 10 == 0) {<br/>      cout &lt;&lt; endl;<br/>    }<br/>    i++;<br/>  }<br/>}</span><span id="2830" class="mu lf it mk b gy mz mw l mx my">int main () {<br/>  srand(time(0));<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 10);<br/>  sort(numbers.begin(), numbers.end());<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  vector&lt;int&gt; more_numbers;<br/>  buildVec(more_numbers, 10);<br/>  sort(more_numbers.begin(), more_numbers.end());<br/>  printVec(more_numbers);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  cout &lt;&lt; "Merged elements: " &lt;&lt; endl;<br/>  merge(numbers.begin(), numbers.end(),<br/>        more_numbers.begin(), more_numbers.end(),<br/>        ostream_iterator&lt;int&gt;(cout, " "));<br/>  return 0;<br/>}</span></pre><p id="9ee8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序运行一次的输出是:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="c5fd" class="mu lf it mk b gy mv mw l mx my">14 14 19 28 62 68 75 95 98 100</span><span id="dfbe" class="mu lf it mk b gy mz mw l mx my">24 25 36 46 52 68 70 71 81 97</span><span id="f8bc" class="mu lf it mk b gy mz mw l mx my">Merged elements:</span><span id="c283" class="mu lf it mk b gy mz mw l mx my">14 14 19 24 25 28 36 46 52 62 68 68 70 71 75 81 95 97 98 100</span></pre><p id="4608" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">必须对每个容器的元素进行排序，才能对合并后的集合进行排序。</p><p id="d17e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一个版本的<code class="fe mh mi mj mk b">merge</code>允许您指定不同的谓词函数用于排序，但我不会在这里讨论它。</p><h1 id="2db0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">寻找两个集合的并集</h1><p id="4181" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">set_union</code>函数是STL中的另一个排序范围函数。这个函数确实如它所说的那样—找到两个排序范围(集合)的并集，并将其写入输出迭代器。下面是<code class="fe mh mi mj mk b">set_union</code>函数的语法模板:</p><p id="4e6d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> output-iterator(范围1-start，范围1-end，范围2-start，范围2-end，output-|<br/>iterator)；</em></p><p id="78b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是显示两个集合的并集的示例:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="1307" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  srand(time(0));<br/>  vector&lt;int&gt; set1;<br/>  buildVec(set1, 10);<br/>  sort(set1.begin(), set1.end());<br/>  cout &lt;&lt; "Set 1: " &lt;&lt; endl;<br/>  printVec(set1);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  vector&lt;int&gt; set2;<br/>  buildVec(set2, 10);<br/>  sort(set2.begin(), set2.end());<br/>  cout &lt;&lt; "Set 2: " &lt;&lt; endl;<br/>  printVec(set2);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  cout &lt;&lt; "Set 1 and 2 Union: " &lt;&lt; endl;<br/>  set_union(set1.begin(), set1.end(),<br/>            set2.begin(), set2.end(),<br/>            ostream_iterator&lt;int&gt;(cout, " "));<br/>  return 0;<br/>}</span></pre><p id="c226" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个程序运行一次的输出:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="ad47" class="mu lf it mk b gy mv mw l mx my">Set 1:<br/>8 19 26 41 49 67 71 85 91 99</span><span id="0a10" class="mu lf it mk b gy mz mw l mx my"><br/>Set 2:<br/>2 8 18 24 35 46 66 70 76 98</span><span id="e270" class="mu lf it mk b gy mz mw l mx my"><br/>Set 1 and 2 Union:</span><span id="2446" class="mu lf it mk b gy mz mw l mx my">2 8 18 19 24 26 35 41 46 49 66 67 70 71 76 85 91 98 99</span></pre><p id="6ec2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，元素8在联合中只出现一次，这正是集合联合应该如何形成的。</p><p id="b04c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重要的是要记住，必须对这两个范围进行排序，该函数才能正常工作。</p><p id="e8e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一个版本的函数接受谓词函数作为最后一个参数，但我不会在这里介绍它。</p><h1 id="6042" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">寻找两个集合的交集</h1><p id="7d99" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">set_intersection</code>函数找到两个排序后的容器的交集。以防你忘记了你的集合论，两个集合的交集是在两个集合中都可以找到的元素的集合。</p><p id="be74" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个函数的synxtax模板:</p><p id="d54b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">输出-迭代器set_intersection(range1-start，range1-end，range2-start，range2- <br/> end，输出-迭代器)；</em></p><p id="f740" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个演示<code class="fe mh mi mj mk b">set_intersection</code>功能如何工作的程序:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="d4e5" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  srand(time(0));<br/>  vector&lt;int&gt; set1;<br/>  buildVec(set1, 10);<br/>  sort(set1.begin(), set1.end());<br/>  cout &lt;&lt; "Set 1: " &lt;&lt; endl;<br/>  printVec(set1);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  vector&lt;int&gt; set2;<br/>  buildVec(set2, 10);<br/>  sort(set2.begin(), set2.end());<br/>  cout &lt;&lt; "Set 2: " &lt;&lt; endl;<br/>  printVec(set2);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  cout &lt;&lt; "Set 1 and 2 Intersection: " &lt;&lt; endl;<br/>  set_intersection(set1.begin(), set1.end(),<br/>                   set2.begin(), set2.end(),<br/>                   ostream_iterator&lt;int&gt;(cout, " "));<br/>  return 0;<br/>}</span></pre><p id="9230" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个程序运行一次的输出:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="8b4d" class="mu lf it mk b gy mv mw l mx my">Set 1:<br/>20 25 27 27 58 63 65 79 94 95</span><span id="5855" class="mu lf it mk b gy mz mw l mx my"><br/>Set 2:<br/>12 29 35 54 58 58 69 77 82 94<br/></span><span id="7f4b" class="mu lf it mk b gy mz mw l mx my">Set 1 and 2 Intersection:<br/>58 94</span></pre><p id="1d92" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，有可能两个集合的交集是空集，这意味着没有元素显示为函数的输出。</p><p id="1863" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个函数还有一个重载版本，它将一个谓词函数作为最后一个参数，但我不在这里讨论它。</p><h1 id="a300" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">找出两个集合的差异</h1><p id="7831" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">set_difference</code>函数找出两个排序后的容器之间的差异。两个集合的区别在于第一个集合中的元素不在第二个集合中。</p><p id="cccd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是<code class="fe mh mi mj mk b">set_difference</code>的语法模板是:</p><p id="e53b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> output-iterator(范围1-start，范围1-end，范围2-start，范围2-end，output-<br/>iterator)；</em></p><p id="9d47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的程序展示了如何使用<code class="fe mh mi mj mk b">set_difference</code>找出两个排序区域之间的差异:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="3617" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  srand(time(0));<br/>  vector&lt;int&gt; set1;<br/>  buildVec(set1, 10);<br/>  sort(set1.begin(), set1.end());<br/>  cout &lt;&lt; "Set 1: " &lt;&lt; endl;<br/>  printVec(set1);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  vector&lt;int&gt; set2;<br/>  buildVec(set2, 10);<br/>  sort(set2.begin(), set2.end());<br/>  cout &lt;&lt; "Set 2: " &lt;&lt; endl;<br/>  printVec(set2);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  cout &lt;&lt; "Set 1 and 2 Difference: " &lt;&lt; endl;<br/>  set_difference(set1.begin(), set1.end(),<br/>                 set2.begin(), set2.end(),<br/>                 ostream_iterator&lt;int&gt;(cout, " "));<br/>  return 0;<br/>}</span></pre><p id="602c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是该程序运行一次的输出:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="7ff0" class="mu lf it mk b gy mv mw l mx my">Set 1:<br/>9 12 13 23 26 56 59 63 87 90</span><span id="4683" class="mu lf it mk b gy mz mw l mx my"><br/>Set 2:<br/>5 12 29 35 42 51 77 83 93 100</span><span id="6397" class="mu lf it mk b gy mz mw l mx my"><br/>Set 1 and 2 Difference:<br/>9 13 23 26 56 59 63 87 90</span></pre><p id="8b81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以看到第一个容器中的12没有显示在差异输出中，因为它也存在于第二个容器中。</p><p id="d07c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个函数还有一个重载版本，它将一个谓词函数作为最后一个参数，但我不在这里讨论它。</p><h1 id="e6fb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">求两个集合的对称差</h1><p id="8cd6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">两个集合的对称差是在任一集合中找到但在两个集合中都找不到的所有元素的集合。STL中执行该任务的函数是<code class="fe mh mi mj mk b">set_symmetric_difference</code>。</p><p id="3873" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该函数的语法模板:</p><p id="b8d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">输出迭代器set _ symmetric _ difference(range 1-start，range1-end，range2- <br/> start，range2-end，输出迭代器)；</em></p><p id="3af9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个程序，它找出两个容器的对称差异:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="f365" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  srand(time(0));<br/>  vector&lt;int&gt; set1;<br/>  buildVec(set1, 10);<br/>  sort(set1.begin(), set1.end());<br/>  cout &lt;&lt; "Set 1: " &lt;&lt; endl;<br/>  printVec(set1);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  vector&lt;int&gt; set2;<br/>  buildVec(set2, 10);<br/>  sort(set2.begin(), set2.end());<br/>  cout &lt;&lt; "Set 2: " &lt;&lt; endl;<br/>  printVec(set2);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  cout &lt;&lt; "Set 1 and 2 Difference: " &lt;&lt; endl;<br/>  set_symmetric_difference(set1.begin(), set1.end(),<br/>                           set2.begin(), set2.end(),<br/>                           ostream_iterator&lt;int&gt;(cout, " "));<br/>  return 0;<br/>}</span></pre><p id="d967" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个程序运行一次的输出:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="3f56" class="mu lf it mk b gy mv mw l mx my">Set 1:<br/>3 14 40 41 62 64 67 84 94 96</span><span id="4a48" class="mu lf it mk b gy mz mw l mx my"><br/>Set 2:<br/>18 23 26 26 41 48 54 63 66 84</span><span id="dfb9" class="mu lf it mk b gy mz mw l mx my"><br/>Set 1 and 2 Difference:<br/>3 14 18 23 26 26 40 48 54 62 63 64 66 67 94 96</span></pre><p id="26f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以看到41出现在两个容器中，但在构成两个容器的对称差的集合中找不到。</p><p id="e7ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">和其他函数一样，<code class="fe mh mi mj mk b">set_symmetric_difference</code>也有一个重载版本，它允许一个谓词函数，但是我不会在这里讨论这个版本。</p><h1 id="dd54" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">接下来:数字算法</h1><p id="4d3e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这就是STL的排序范围算法。在我的下一篇文章中，我将介绍STL中的数值算法。</p><p id="a519" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请给我发电子邮件提出意见和建议。</p></div></div>    
</body>
</html>