<html>
<head>
<title>Using Terraform’s try() ,can(), and input validation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Terraform的try()、can()和输入验证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-terraforms-try-can-and-input-validation-eb45037af2b2?source=collection_archive---------0-----------------------#2020-03-07">https://levelup.gitconnected.com/using-terraforms-try-can-and-input-validation-eb45037af2b2?source=collection_archive---------0-----------------------#2020-03-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ba94c65d9088e5801aa6cf4cda20824a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4U2rTUEeLAun4UgHtxELtg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">塞萨尔·卡里瓦里诺·阿拉贡在<a class="ae kf" href="https://unsplash.com/s/photos/tools?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="e57b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">HashiCorp在Terraform中增加了两个新工具。从Terraform <code class="fe le lf lg lh b">v.12.20</code>开始，消费者可以使用两种新功能<code class="fe le lf lg lh b">try()</code>和<code class="fe le lf lg lh b">can()</code>。除了这两个功能之外，还有一个实验特性可用，<code class="fe le lf lg lh b">variable_validation</code>。在本文中，我们将研究这些新功能是如何使用的以及它们是如何工作的。</p><p id="4237" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">所有代码片段都可以在</strong><a class="ae kf" href="https://github.com/karl-cardenas-coding/terraform-functions" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu">https://github.com/karl-cardenas-coding/terraform-functions</strong></a>找到</p><p id="c60c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:<em class="li">变量验证是从</em> <code class="fe le lf lg lh b"><em class="li">v12.20</em></code> <em class="li">开始的一项实验性功能，请谨慎使用，因为此时不建议用于生产用途。</em></p><blockquote class="lj lk ll"><p id="5922" class="kg kh li ki b kj kk kl km kn ko kp kq lm ks kt ku ln kw kx ky lo la lb lc ld im bi translated"><code class="fe le lf lg lh b">can</code>和<code class="fe le lf lg lh b">try()</code>函数只能捕捉和处理<em class="it">动态</em>错误，这些错误是由于访问运行时才知道的数据而产生的。它不会捕捉与表达式相关的错误，这些错误对于任何输入都是无效的，例如格式错误的资源引用。</p></blockquote></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="2921" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">可以()</h1><p id="47b6" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated"><code class="fe le lf lg lh b">can()</code>函数试图执行其内部提供的以下代码，并返回一个布尔值。<code class="fe le lf lg lh b">can()</code>功能背后的主要目的是根据官方<a class="ae kf" href="https://www.terraform.io/docs/configuration/functions/can.html" rel="noopener ugc nofollow" target="_blank">文档</a>进行输入验证。让我们来测试一下。</p><p id="aa2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要启用<code class="fe le lf lg lh b">input_validation</code>，请将以下代码块添加到您的Terraform配置中。</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="74bd" class="nh lx it lh b gy ni nj l nk nl">terraform {<br/>  experiments = [variable_validation]<br/>}</span></pre><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">向<a class="ae kf" href="https://github.com/d-henn" rel="noopener ugc nofollow" target="_blank"> @d-henn </a>喊出正则表达式的例子</figcaption></figure><p id="4ed7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，我们有一个名为“os”的变量，是“操作系统”的缩写。这个变量还利用了新的验证功能。让我们在这里分解一下。验证模块有两个组件:</p><ul class=""><li id="5f0e" class="no np it ki b kj kk kn ko kr nq kv nr kz ns ld nt nu nv nw bi translated">条件(必需)</li><li id="9613" class="no np it ki b kj nx kn ny kr nz kv oa kz ob ld nt nu nv nw bi translated">错误消息(必需)(<strong class="ki iu">不支持插值</strong>)</li></ul><p id="2119" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">条件组件是<code class="fe le lf lg lh b">can()</code>开始起作用的地方。在上面的例子中，我们使用正则表达式来确定输入值是“linux”还是“windows”。在这个场景中，<code class="fe le lf lg lh b">can()</code>函数将通过<code class="fe le lf lg lh b">regex()</code>返回一个布尔值。</p><p id="1838" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">can()</code>的语法是<code class="fe le lf lg lh b">can(logic for test, value or variable to test)</code>。在上面的例子中，变量将值“linux”硬编码为默认值。让我们将它改为另一个值，比如“z/OS ”,看看它在<code class="fe le lf lg lh b">terraform plan</code>或<code class="fe le lf lg lh b">terraform apply</code>上的表现如何</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/0d67fda342984dd11f47ae94a0c86d43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*pQPJaF8XbNO3SUYGio12RQ.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">出错信息</figcaption></figure><p id="3605" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相当整洁！由于我们有能力编写错误消息，所以它非常具有描述性。Terraform还返回文件中不正确变量值为<code class="fe le lf lg lh b">can.tf:15,3–13</code>的文件名和位置。</p><p id="d23a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="li">有趣的事实是，变量验证是固执己见的，因为它期望正确的英语语法</em>👵🏻<em class="li">。</em></p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/2e246652c33c50b9204ae274773de98e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tOkYpXgUOuYyFDOvNi7CPg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">正确的语法女士们先生们</figcaption></figure><p id="bd96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有<code class="fe le lf lg lh b">can()</code>也可以使用输入验证。在下面的代码片段中，您可以看到对变量“word”的长度进行了评估，以确定它是否大于1。该变量与随机宠物提供者相关联，并将指示在生成的单词串中有多少宠物。</p><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7402" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">HashiCorp在他们的文档中指出<code class="fe le lf lg lh b">can()</code>不应该用于错误处理，或者输入验证之外的任何上下文(尽管技术上是可能的)。对于其他场景，建议使用<code class="fe le lf lg lh b">try()</code>。因此，在这一点上，让我们继续到<code class="fe le lf lg lh b">try()</code></p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="a3c6" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">尝试()</h1><p id="a120" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated"><code class="fe le lf lg lh b">try()</code>计算所有传递给它的[ <strong class="ki iu">参数… </strong> ]表达式，它将返回第一个没有返回错误的<strong class="ki iu">的值。此时，推荐在<a class="ae kf" href="https://www.terraform.io/docs/configuration/locals.html" rel="noopener ugc nofollow" target="_blank">局部值变量</a>中使用<code class="fe le lf lg lh b">try()</code>。这一建议背后的主要原因是为了降低代码的复杂性，并且只将其用于规范化。也许未来的使用将允许消费者将资源块包装在一个<code class="fe le lf lg lh b">try()</code>中？</strong></p><p id="6a50" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们深入下面的示例代码之前，让我们从高层次上讨论一下。</p><p id="94f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">目的</strong>:查询一个端点。该查询检索AWS服务的所有公共IP。<a class="ae kf" href="https://ip-ranges.amazonaws.com/ip-ranges.json" rel="noopener ugc nofollow" target="_blank">https://ip-ranges.amazonaws.com/ip-ranges.json</a></p><p id="1366" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">如何</strong>:Terraform数据资源<code class="fe le lf lg lh b">http</code>将查询返回JSON响应的Amazon端点。</p><p id="c218" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本地人:这是我们的逻辑开始发挥作用的地方，对于我们的三个变量，<code class="fe le lf lg lh b">syncToken, services, and regions</code>。</p><p id="0641" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">原因:</strong><code class="fe le lf lg lh b">try()</code>块背后的原因是为了防止亚马逊改变JSON模式，或者服务不再公开公共IP。如果一个突破性的变化发生，那么我们可以考虑到这一点。</p><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7664" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然解释已经结束，让我们深入到<code class="fe le lf lg lh b">local</code>模块。第一个变量<code class="fe le lf lg lh b">syncToken</code>，试图对来自<code class="fe le lf lg lh b">data.http.primary-server.body</code>的响应使用<code class="fe le lf lg lh b">jsondecode</code>。</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="0003" class="nh lx it lh b gy ni nj l nk nl">syncToken = try(jsondecode(data.http.primary-server.body).syncToken,<br/>              "NO TOKEN AVAILABLE"<br/>              )</span></pre><p id="5c4f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">jsondecode</code>函数将JSON对象转换成HCL，然后允许我们通过在末尾使用点符号来访问syncToken值。如果服务器不返回syncToken，那么我们有一个“没有可用令牌”的后备值。后退值可以设置为消费者想要的任何值。如果没有<code class="fe le lf lg lh b">try()</code>函数，这将导致一个难看的错误。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/46ac18befcdec3c5aa486f8aedec0fb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JyILd3Ioiu9qQhPgCM7Iog.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">没有尝试就出错()</figcaption></figure><p id="5d2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有<code class="fe le lf lg lh b">try()</code>块，这停止了我们的地形运行。使用我们代码中的<code class="fe le lf lg lh b">try()</code>块观察下面的结果。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div class="gh gi of"><img src="../Images/4952c94b2b23f24238440b8c2ac645c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*Vh1VU8Rn5ZhXcQu-zfPmSQ.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">With try()</figcaption></figure><p id="d62b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管我们没有收到来自端点的<code class="fe le lf lg lh b">syncToken</code>,我们的回退值开始生效，我们的Terraform运行得以完成。整洁！</p><h1 id="1df1" class="lw lx it bd ly lz og mb mc md oh mf mg mh oi mj mk ml oj mn mo mp ok mr ms mt bi translated">用于()</h1><p id="e7be" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">*如果您熟悉<code class="fe le lf lg lh b">for</code>循环，请跳到结论。</p><p id="6708" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了检索所有AWS S3 IP地址的过滤列表，我们可以简单地利用Terraform <code class="fe le lf lg lh b">for</code> <a class="ae kf" href="https://www.terraform.io/docs/configuration/expressions.html#for-expressions" rel="noopener ugc nofollow" target="_blank">循环表达式</a>。如果你没有玩过<code class="fe le lf lg lh b">for</code>循环，不要被下面的代码吓倒。请允许我逐行分解:</p><ol class=""><li id="789e" class="no np it ki b kj kk kn ko kr nq kv nr kz ns ld ol nu nv nw bi translated">把它缠绕在一个<code class="fe le lf lg lh b">try()</code>上<code class="fe le lf lg lh b">#line 3</code></li><li id="11a8" class="no np it ki b kj nx kn ny kr nz kv oa kz ob ld ol nu nv nw bi translated">通过<code class="fe le lf lg lh b">distinct()</code> <code class="fe le lf lg lh b">#line 3</code>检索所有唯一值</li><li id="b702" class="no np it ki b kj nx kn ny kr nz kv oa kz ob ld ol nu nv nw bi translated">我们希望结果是列表类型的，所以让我们使用<code class="fe le lf lg lh b">[]</code>并将我们的<code class="fe le lf lg lh b">for</code>循环包装在它的<code class="fe le lf lg lh b">#line 3</code>中</li><li id="ebc9" class="no np it ki b kj nx kn ny kr nz kv oa kz ob ld ol nu nv nw bi translated">使用关键字<code class="fe le lf lg lh b">for</code>声明循环。让我们使用一个名为<code class="fe le lf lg lh b">items</code>的临时变量来保存我们遍历提供的列表时的每个唯一值。该循环中提供的列表将是来自<code class="fe le lf lg lh b">data.http.primary-server.body</code>的资源属性引用。但是，因为我们不想使用原始的JSON对象，所以让我们将它转换成HCL类型，这样我们就可以使用点符号。因此我们将列表包装在<code class="fe le lf lg lh b">jsondecode()</code>中。最后，因为我们可以使用expect点符号，所以让我们来看看对象中的<code class="fe le lf lg lh b">prefixes</code>属性。<code class="fe le lf lg lh b">#line 4</code></li><li id="b466" class="no np it ki b kj nx kn ny kr nz kv oa kz ob ld ol nu nv nw bi translated">当我们在循环中迭代时，让我们添加每个IP地址，但前提是它的服务是S3 <code class="fe le lf lg lh b">#line 5</code></li><li id="7f97" class="no np it ki b kj nx kn ny kr nz kv oa kz ob ld ol nu nv nw bi translated">让我们结束循环，如果传递给循环的列表不存在，就传递回退值。在这种情况下，我们返回一个解释问题的字符串。</li></ol><p id="044e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="li">从</em><a class="ae kf" href="https://ip-ranges.amazonaws.com/ip-ranges.json" rel="noopener ugc nofollow" target="_blank"><em class="li">https://ip-ranges.amazonaws.com/ip-ranges.json</em></a><em class="li">看JSON对象有助于更好地理解点符号。</em></p><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h1 id="a4c6" class="lw lx it bd ly lz og mb mc md oh mf mg mh oi mj mk ml oj mn mo mp ok mr ms mt bi translated">结论</h1><p id="7e4f" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated"><code class="fe le lf lg lh b">can()</code>和<code class="fe le lf lg lh b">try()</code>函数非常简洁，肯定会给消费者的配置模板增加很多价值。在开始使用这些新功能之前，请记住以下经验法则。</p><ul class=""><li id="6660" class="no np it ki b kj kk kn ko kr nq kv nr kz ns ld nt nu nv nw bi translated"><code class="fe le lf lg lh b">can()</code>用于实验特征<code class="fe le lf lg lh b">input_validation</code>，表达式必须返回一个布尔值。</li><li id="0cac" class="no np it ki b kj nx kn ny kr nz kv oa kz ob ld nt nu nv nw bi translated"><code class="fe le lf lg lh b">try()</code>应该用于与规范化相关的操作，最好是在<code class="fe le lf lg lh b">locals{}</code>代码块中。</li><li id="5799" class="no np it ki b kj nx kn ny kr nz kv oa kz ob ld nt nu nv nw bi translated">如果提供了多个参数<code class="fe le lf lg lh b">[arguments…]</code>，则<code class="fe le lf lg lh b">try()</code>将返回第一个非错误结果表达式。</li><li id="8145" class="no np it ki b kj nx kn ny kr nz kv oa kz ob ld nt nu nv nw bi translated">这两个函数都不能处理运行时才知道的数据访问导致的动态错误。</li></ul><p id="84a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望你学到了新的东西！走出去，远离clickOps，让你的生活自动化！</p></div></div>    
</body>
</html>