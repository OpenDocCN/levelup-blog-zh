<html>
<head>
<title>Two Number Sum in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">戈兰的两个数和</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/two-number-sum-in-golang-355627d6c861?source=collection_archive---------4-----------------------#2021-01-31">https://levelup.gitconnected.com/two-number-sum-in-golang-355627d6c861?source=collection_archive---------4-----------------------#2021-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="ace4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">学习如何在Go中编程，同时还要学习编码面试问题！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/6e61f201b690756c16d98f056c4f2663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_icl0bY-JaPXfUzl.jpg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">来自<a class="ae le" href="https://deepdreamgenerator.com/ddream/pubfgohk0vb" rel="noopener ugc nofollow" target="_blank"> Chinquada </a></figcaption></figure><p id="bc0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi lf translated">这里有许多学习新编程语言的方法，我最喜欢的一种是完成编码面试问题！你不仅要提高批判性思维技能，编码问题通常会迫使你利用编程语言中最重要的部分，比如数据结构、分支和循环方法。</p><p id="c745" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不仅如此，我们都知道准备编码面试的阻力。我更喜欢每天提高一点我的编码技能，而不是在工作申请的压力下临时抱佛脚几个月。通过这种方式，我可以保持对我选择的编程语言、我的问题解决技巧的敏锐，同时避免将来不必要的压力。</p><p id="e0cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好吧，那么，让我们来看看常见的两个数和问题，我们将使用我目前最喜欢的编程语言来解决，开始！作为参考，我将在这里解决LeetCode上的问题:</p><div class="lo lp gp gr lq lr"><a href="https://leetcode.com/problems/two-sum/" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd iu gy z fp lw fr fs lx fu fw is bi translated">两个总和代码</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">给定一个整数num数组和一个整数target，返回这两个数字的索引，使它们加起来等于…</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">leetcode.com</p></div></div><div class="ma l"><div class="mb l mc md me ma mf ky lr"/></div></div></a></div><p id="74ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注:</strong>本文假设了解大O符号。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="577f" class="mn mo it bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">理解问题</h1><p id="e936" class="pw-post-body-paragraph jq jr it js b jt nl jv jw jx nm jz ka kb nn kd ke kf no kh ki kj np kl km kn im bi translated">两个数和问题是这样的——给你一个名为<code class="fe nq nr ns nt b">nums</code>的整数数组。也给你一个整数<code class="fe nq nr ns nt b">target</code>，你的任务是看数组中是否有两个数加起来是<code class="fe nq nr ns nt b">target</code>。如果有，那么返回两个数的索引<em class="nu">和<code class="fe nq nr ns nt b">target</code>的数组。否则，只返回一个空数组。</em></p><p id="48ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下基本假设适用于此问题:</p><ul class=""><li id="97ed" class="nv nw it js b jt ju jx jy kb nx kf ny kj nz kn oa ob oc od bi translated">每个解只有一个解。</li><li id="1a63" class="nv nw it js b jt oe jx of kb og kf oh kj oi kn oa ob oc od bi translated">不能两次使用同一个元素。</li><li id="70b9" class="nv nw it js b jt oe jx of kb og kf oh kj oi kn oa ob oc od bi translated">可以任意顺序返回答案。</li></ul><p id="4ef5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编写问题的第一步是拿出<strong class="js iu">个例子</strong>来确认你的理解。如果给你一个数组<code class="fe nq nr ns nt b">[2,7,11,15]</code>和目标值9，你将返回数组<code class="fe nq nr ns nt b">[0,1]</code>。这个问题很简单，所以举几个例子就够了——但是随着问题变得越来越复杂，写出你的理解并说出来，让你的大脑为更困难的代码解决过程做好准备变得非常重要。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="131d" class="mn mo it bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">一个强力解决方案——O(N)时间，O(1)空间</h1><p id="a09b" class="pw-post-body-paragraph jq jr it js b jt nl jv jw jx nm jz ka kb nn kd ke kf no kh ki kj np kl km kn im bi translated">让我们想一个最简单的方法来检查数组中是否有两个数加起来是<code class="fe nq nr ns nt b">target</code>。我们可以很容易地一次检查数组的一个元素，然后检查数组的其余元素，看这两个元素是否匹配。</p><p id="2d64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我们将有两个参数，一个整数的<code class="fe nq nr ns nt b">array</code>和一个<code class="fe nq nr ns nt b">target</code>值。我们还将通过在函数参数后添加<code class="fe nq nr ns nt b">[]int</code>来返回一个整数数组。然后，我们将得到第一个for循环的当前值的值<code class="fe nq nr ns nt b">start</code>，以及第二个for循环的值<code class="fe nq nr ns nt b">end</code>。设置<code class="fe nq nr ns nt b">j=i+1</code>很重要，这样我们就不会重复计算数组中的单个值。</p><p id="0ea4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总而言之，强力解决方案可能是这样的:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="bdfd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们有一个通过数组递归的双for循环，我们将有O(N)的时间复杂度。除了变量<code class="fe nq nr ns nt b">start</code>和<code class="fe nq nr ns nt b">end</code>之外，我们也不存储任何数据，所以我们有常数空间O(1)。如果你想知道为什么双for循环有二次运行时间，这里有一个很好的关于N个自然数之和的视频例子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ol ok l"/></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="cf22" class="mn mo it bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">使用散列映射— O(N)时间，O(N)空间</h1><p id="a168" class="pw-post-body-paragraph jq jr it js b jt nl jv jw jx nm jz ka kb nn kd ke kf no kh ki kj np kl km kn im bi translated">好吧，让我们再仔细想想。双for循环解决方案的主要低效之处是什么？好吧，我们实际上在几个元素上循环了很多次，绝对超过了必要的次数。如果我们可以跟踪我们已经看到的东西，这样我们就不必重复检查数组的元素了，会怎么样？</p><p id="abc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以用一个散列图做到这一点！Go使得实现这种数据结构变得轻而易举，它如此有用的部分原因是它具有恒定的O(1)访问时间。让我们将它添加到我们的新函数尝试中。</p><p id="bbd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们新的<code class="fe nq nr ns nt b">twoSum()</code>函数中，我们首先初始化一个名为<code class="fe nq nr ns nt b">seenNums</code>的空散列映射。我们将把我们已经看到的数字存储为一个散列映射键，并将这些数字的<em class="nu">索引</em>存储为一个散列映射值。</p><p id="b607" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以使用<code class="fe nq nr ns nt b">range</code>关键字从<code class="fe nq nr ns nt b">array</code>中获取当前索引<code class="fe nq nr ns nt b">i</code>和对应的编号<code class="fe nq nr ns nt b">num</code>。对于数组的每个值，我们创建一个变量<code class="fe nq nr ns nt b">potentialMatch</code>，这个变量<em class="nu">可能是我们需要的</em>值。我们从<code class="fe nq nr ns nt b">target</code>中减去当前值<code class="fe nq nr ns nt b">num</code>来得到我们<em class="nu">需要的</em>数，并且希望在我们的<code class="fe nq nr ns nt b">seenNums</code>散列图中。因此，如果我们的目标是9，并且我们当前有值3，我们需要查看9–3 = 6是否在我们的哈希表中。</p><p id="b7c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了验证这一点，我们用散列图做了一个很好的Go一行程序。记住，我们的hash map <code class="fe nq nr ns nt b">seenNums</code>将看到的数字存储为一个键，并将该数字的索引存储为一个值。在第5行，我们得到了值(index) j和一个布尔值<code class="fe nq nr ns nt b">found</code>，它告诉我们键<code class="fe nq nr ns nt b">potentialMatch</code>是否存在于<code class="fe nq nr ns nt b">seenNums</code>中。如果<code class="fe nq nr ns nt b">found</code>为真，我们可以通过在哈希映射操作的末尾添加<code class="fe nq nr ns nt b">;</code>后直接放置它来立即检查。</p><p id="8faf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，如果所有这些都检查过了，那么我们的哈希表实际上就有了当前值<code class="fe nq nr ns nt b">num</code>的<code class="fe nq nr ns nt b">potentialMatch</code>!然后我们可以返回当前的索引<code class="fe nq nr ns nt b">i</code>和我们的索引<code class="fe nq nr ns nt b">potentialMatch</code>、<code class="fe nq nr ns nt b">j</code>。</p><p id="d39f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">不要忘记:</strong>在检查完for循环中的每个元素后，我们必须将键<code class="fe nq nr ns nt b">num</code>和值<code class="fe nq nr ns nt b">i</code>添加到我们的散列图<code class="fe nq nr ns nt b">seenNums</code>中，以跟踪我们看到了哪些数字以及它们的索引是什么。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="9043" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们只遍历数组一次，所以时间复杂度是O(N)。此外，我们可以在哈希映射中存储数组的每个元素，所以空间复杂度也是O(N)。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="88e1" class="mn mo it bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">排序和计算— O(NlogN)时间，O(1)空间</h1><p id="69fc" class="pw-post-body-paragraph jq jr it js b jt nl jv jw jx nm jz ka kb nn kd ke kf no kh ki kj np kl km kn im bi translated">是时候变得大胆了。我们使用了一个散列映射来避免过多地查看数组元素。但是，如果我们对空间要求严格，但是又想比二次时间更快呢？让我们想一想。</p><p id="d93e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们希望值等于<code class="fe nq nr ns nt b">target</code>而不是索引的情况下，我们可以跟踪当前的两个和值。如果我们对数组进行排序，那么我们可以有两个索引来表示数组开头和结尾的补码对。然后，我们将“压缩”它们，以缩小与<code class="fe nq nr ns nt b">target</code>相等的可能称赞对的范围。</p><p id="c93d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，我们的补码对可以是4和15，而<code class="fe nq nr ns nt b">target</code>值为10。我们知道4+15=19，大于10。由于数组已经排序，我们希望<em class="nu">减少</em>我们的两个和补码对，因此我们将减少最终值的索引以更接近值10。</p><p id="aaa8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Go使得数组排序变得很容易，我们可以只导入包<code class="fe nq nr ns nt b">"sort"</code>然后调用<code class="fe nq nr ns nt b">sort.Ints(array)</code>。然后，我们可以将变量<code class="fe nq nr ns nt b">start</code>和<code class="fe nq nr ns nt b">end</code>指定为从<code class="fe nq nr ns nt b">array</code>的起始和结束索引开始。</p><p id="cd3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从那里开始，如果<code class="fe nq nr ns nt b">start</code>变得大于<code class="fe nq nr ns nt b">end</code>，我们的循环将终止，因为如果发生这种情况，我们将知道我们已经查看了排序数组中的每个值，但找不到有效的两个和对。在每个循环迭代的开始，我们从当前索引的数组值中找到<code class="fe nq nr ns nt b">currentSum</code>值。</p><p id="75ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果<code class="fe nq nr ns nt b">currentSum</code>的值等于<code class="fe nq nr ns nt b">target</code>，我们找到正确的索引并相应地返回它们。如果总和小于<code class="fe nq nr ns nt b">target</code>，那么我们想要一个更大的值，因此<em class="nu">增加</em>我们计算窗口的<code class="fe nq nr ns nt b">start</code>值。最后一个<code class="fe nq nr ns nt b">else</code>条件是当当前总和大于<code class="fe nq nr ns nt b">target</code>时，我们<em class="nu">减少</em>我们的计算窗口的<code class="fe nq nr ns nt b">end</code>值。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="d7a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的for循环是O(N)，但是它需要O(NlogN)时间来排序我们的数组—所以我们的时间复杂度将是[O(N) + O(NlogN)]=O(NlogN)。虽然它比我们的hash map解决方案要慢一点，但是我们有一个额外的好处，那就是不存储任何数据结构来获得恒定的空间复杂度O(1)。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="e267" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然这个问题相当简单，但它很好地介绍了Go中的排序、数组、函数和散列映射。不仅如此，我们还找到了三种不同时间和空间复杂度的解决方案。由你和面试官来决定哪种解决方案最适合你的情况，但是最重要的是，除了你的问题解决技巧之外，你还能适应你所选择的编程语言，以便灵活地实现。</p><p id="2dc2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你喜欢这篇文章或者想看其他编程问题教程，请在下面留下评论！感谢阅读。</p></div></div>    
</body>
</html>