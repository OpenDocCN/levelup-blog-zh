<html>
<head>
<title>OOP in JavaScript: Explained using games</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的OOP:用游戏解释</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/oop-in-javascript-explained-using-games-1c3537956b9?source=collection_archive---------10-----------------------#2021-06-29">https://levelup.gitconnected.com/oop-in-javascript-explained-using-games-1c3537956b9?source=collection_archive---------10-----------------------#2021-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="79a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将讨论使用prototype和ES6类的JavaScript面向对象编程。</p><p id="6ee5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Javascript中有两种实现OOP的方法:</p><p id="810b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 1)使用函数和原型<br/> 2)使用新的</strong> <code class="fe kl km kn ko b"><strong class="jp ir">class</strong></code> <strong class="jp ir"> <em class="kp"> </em>关键字。(这是sugar在ES6–2015中引入的语法)</strong></p><h1 id="98ee" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">让我们玩一个游戏</h1><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/7923b3666fe505c046cd2047cf52d69c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ieq1DK9xP2q2Ztrv"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">马里奥游戏——OOP真实用例</figcaption></figure><p id="6516" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们来谈谈为什么要在代码中使用类。<br/>有多种用例，但最常见的可能是视频游戏。</p><p id="89cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设你想创建一个有多个相同类型的怪物和相似物品(例如硬币)的游戏。</p><p id="0679" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们的怪物将拥有相同的形象，相同的生命值，伤害，甚至相同的移动模式。这是定义一个模板(一个类)并创建多个相同类型的相同(或几乎相同)对象的最佳时机。(OOP中使用的术语是一个类的<strong class="jp ir">实例</strong></p><h2 id="da5a" class="me kr iq bd ks mf mg dn kw mh mi dp la jy mj mk le kc ml mm li kg mn mo lm mp bi translated">等等，所以你说OOP只和游戏有关？</h2><p id="4c5e" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">一点也不。在商店中，您可以拥有具有相同结构的产品(标题、描述、价格、检查可用性的功能等)。OOP有无数有效的用例。</p><p id="ca8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们写一些代码。</p><h2 id="7718" class="me kr iq bd ks mf mg dn kw mh mi dp la jy mj mk le kc ml mm li kg mn mo lm mp bi translated">1)使用功能和原型</h2><p id="1c94" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">我们需要做的:<br/> —为我们的怪物定义一个自定义结构。<br/> —生命值、src是<em class="kp"> </em> <strong class="jp ir">属性</strong>，对所有的怪物<br/>都有相同的值——速度是<strong class="jp ir">可变属性</strong>，我们将其指定为参数<br/> —攻击是<strong class="jp ir">方法</strong><em class="kp">；</em>在OOP术语中，这些函数被称为<em class="kp">方法<br/></em>——使用我们的<strong class="jp ir">构造函数</strong> <em class="kp"> ( </em>怪物函数)<br/>——创建2个怪物(<strong class="jp ir">类怪物</strong>的实例)，记录这些怪物，并查看它们的区别。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">使用原型的怪物类</figcaption></figure><p id="a6ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该注意两件事:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mx"><img src="../Images/320c8487d85f10fbae423fbac2daa8f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2MvIdUYmP7yReadA"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">怪物类的2个实例是什么样子的</figcaption></figure><p id="227f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">a)我们得到了我们所期望的。两个速度值不同的相似怪物。</p><p id="5302" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">b)我们有一个怪异的原型<em class="kp"> &lt;原型&gt; </em>尽管事实上它不是我们创造的。嗯，这是棘手的部分。JavaScript会自动为我们创建一个原型对象。</p><p id="bd2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即使对于有经验的开发人员来说，原型也是JavaScript最难的部分之一，所以如果一开始看起来像火箭科学，也不要害怕。我们会一步一步来。</p><h2 id="6764" class="me kr iq bd ks mf mg dn kw mh mi dp la jy mj mk le kc ml mm li kg mn mo lm mp bi translated">普罗托呼吸装置..什么？</h2><p id="b99e" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">看起来是这样的:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi my"><img src="../Images/95bb534b7558fec494922b72bd46a379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/0*ezadA4XnFbBE8sQo"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">一个“简单”的原型</figcaption></figure><p id="b531" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，它是巨大的:D</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/1fcc5f5c0265799baeff905c861fd153.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/0*eaatMudj5FQjy4mS"/></div></figure><p id="719a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你看到了什么？我们的原型有一个构造函数(怪物函数)和<strong class="jp ir">另一个原型？</strong></p><p id="f5f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个原型是JavaScript 中的通用类型对象，定义了所有的公共属性。</p><p id="c04a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，对于每个JavaScript对象，我们可以使用函数<strong class="jp ir"> hasOwnProperty </strong>和<strong class="jp ir"> toString </strong>，这是因为每个新的类都将继承通用对象的属性。</p><p id="4891" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是在OOP中<strong class="jp ir">继承</strong>的工作方式。子类将从父类继承特征。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">toString未按预期工作</figcaption></figure><p id="a0bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再介绍一个模糊的词，它会让你在下一次面试中听起来很聪明:<strong class="jp ir">原型链接。→ </strong>和我们之前看到的一模一样。怪物对象有一个原型，这个原型有另一个指向父类的原型。</p><p id="fdc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有一个特殊类型的monster <strong class="jp ir"> Flyingmonster </strong>，它具有来自其父类(Monster类)的所有特征——所以我们说FlyingMonster <strong class="jp ir">扩展了Monster类</strong>，Monster类<strong class="jp ir">扩展了JavaScript的通用对象类</strong>。</p><p id="8e8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">飞行怪兽→怪兽→通用物体</p><p id="36ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，FlyingMonster将生成一个原型，它包含对Monster类的原型的引用，Monster类包含对一般对象的原型的引用。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="c672" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们后退一步，谈谈重写一个方法。(简单地说，这意味着修改我们的monster从父类继承的一个方法)。</p><h2 id="fed1" class="me kr iq bd ks mf mg dn kw mh mi dp la jy mj mk le kc ml mm li kg mn mo lm mp bi translated">覆盖“toString”<em class="na">方法</em></h2><p id="d2db" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">现在，让我们为<strong class="jp ir"> toString </strong>方法实现<em class="kp">覆盖</em>并尝试一下。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">重写toString方法</figcaption></figure><p id="c6aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于原型，我们可以讨论很多事情，但目前已经足够了。对于更复杂的OOP概念，我将写一篇不同的文章。</p><h2 id="7c2f" class="me kr iq bd ks mf mg dn kw mh mi dp la jy mj mk le kc ml mm li kg mn mo lm mp bi translated">2)使用新的<em class="na">类</em>关键字。(这是sugar在ES6–2015中引入的语法)</h2><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">使用ES6 class关键字的Monster类</figcaption></figure><p id="9826" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个解决方案对开发者来说只是语法糖。ES6代码将被转移到ES5，因为旧浏览器不支持JavaScript中的所有新功能。</p><p id="57d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据transpiler的设置，代码看起来会有所不同。这是它在Internet Explorer 10中的外观。你可以看到它类似于我们的第一个实现。(用函数代替类)</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nb"><img src="../Images/641ba18c88a78d543db661837fd62089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rovnvlVQOzOcBbX4"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">巴别塔ES6代码传输到ES5</figcaption></figure><h2 id="abe5" class="me kr iq bd ks mf mg dn kw mh mi dp la jy mj mk le kc ml mm li kg mn mo lm mp bi translated">家庭作业</h2><p id="2426" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">你能使用ES6重新创建扩展Monster类的FlyingMonster类吗？一点也不难。让我给你一个提示:</p><div class="nc nd gp gr ne nf"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">类- JavaScript | MDN</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">类是创建对象的模板。他们用代码封装数据来处理这些数据。JS中的类是…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">developer.mozilla.org</p></div></div><div class="no l"><div class="np l nq nr ns no nt ly nf"/></div></div></a></div><h2 id="58da" class="me kr iq bd ks mf mg dn kw mh mi dp la jy mj mk le kc ml mm li kg mn mo lm mp bi translated"><strong class="ak">结论</strong></h2><p id="4348" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">我希望你今天能学到一些关于JavaScript的新的有趣的东西。作为回顾，我们介绍了一些OOP术语:<br/> <strong class="jp ir"> -原型<br/> -类<br/> -实例<br/> -构造器<br/> -继承<br/> -扩展类<br/> -原型链接</strong></p><p id="7112" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请在评论中告诉我你的想法，以及我是否应该继续写一篇关于JavaScript中OOP的更高级的文章。</p></div></div>    
</body>
</html>