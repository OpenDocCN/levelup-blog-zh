<html>
<head>
<title>Kubernetes Informer Internals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes内部消息</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/kubernetes-informer-internals-dfa948df8670?source=collection_archive---------3-----------------------#2022-12-01">https://levelup.gitconnected.com/kubernetes-informer-internals-dfa948df8670?source=collection_archive---------3-----------------------#2022-12-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="dea8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对其实现的直观和深入的解释，适合听说过Kubernetes Informer并希望研究其内部机制的读者。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/501753c0caea144a40403ce7f2fd30e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*XCYL8E05E61_LBdK-voi2g.jpeg"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">资料来源:maritime-executive.com</figcaption></figure><p id="a83a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最近我在官方客户端go库中挖掘了Kubernetes Informer实现(<a class="ae la" href="https://github.com/kubernetes/client-go/tree/release-1.26" rel="noopener ugc nofollow" target="_blank"> release-1.26 </a>)。我想我应该写一篇简短的博客来记录这些学习，因为Kubernetes Informer确实有一些有趣的设计模式。如果你希望获得一个简单但更具体和直观的感觉，了解它在幕后是如何工作的，这篇博文值得一读，我发现在我能找到的大多数其他在线资料中缺乏这一点。</p><p id="f794" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Kubernetes Informer本质上是客户感兴趣的Kubernetes资源的本地缓存副本。本地缓存将通过两种机制刷新:List和Watch，我们将在后面解释。但是所有这些都是异步运行的，对客户端是隐藏的。客户只需要做三件事:</p><ol class=""><li id="dad2" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn lg lh li lj bi translated">创建一个可以调用Kubernetes API的客户机对象。</li><li id="c78a" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">使用client对象实例化一个informer工厂。经过适当的配置后，informer factor实际上只是一组informer实例，每种感兴趣的资源类型一个。</li><li id="8c95" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">通过informer列出并获取，它只能返回本地缓存中可用的内容。</li></ol><p id="d632" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在某些情况下，上面的第三条可能是对告密者的警告。如果Informer没有跟上Kubernetes API中的最新修改，本地缓存将会过时。Kubernetes API中发生的新创建、更新和/或删除可能没有被同步到本地缓存，从而导致丢失的、过时的和僵死的资源被返回给客户端。因此，您需要在设计客户端时考虑最终的一致性。</p><p id="feff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个注意事项是，由于List和Get仅由本地缓存提供，因此List和Get期间的附加选择标准仅作为本地缓存资源上的内存过滤器来实现。因此，如果您用窄选择器初始化Informer，那么在后续的List和Get中任何更宽的选择都不会产生更多的资源。一个推论是，如果您计划用各种选择标准列出资源，那么您的informer需要用这些标准的超集进行初始化。</p><p id="a9b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">需要注意的一点是，本地缓存受到互斥锁的保护，因此是线程安全的。因此您可以在并发设置中使用它。事实上，建议我们使用<code class="fe lp lq lr ls b">SharedInformerFactory</code>，它具有额外的线程安全控制，以便多个线程可以使用同一个工厂和informer实例，这消除了重复Kubernetes API调用和数据存储的需要。</p><p id="d4d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从视觉上看，不同数据结构之间的关系如下所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lt"><img src="../Images/4b576ddbfdc509d868ea40f75042c6c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7KP0iWGKwzZvuPAvIW68VA.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">Kubernetes Informer数据结构</figcaption></figure><p id="31d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于客户关心的每种资源类型(Pod、Job、Service等),都有一个创建并存储在工厂中的singleton informer实例。那么在每个informer实例中，都有一个<code class="fe lp lq lr ls b">map&lt;namespace/resource_name, resource&gt;</code>存储。所有的通知器实现相同的<code class="fe lp lq lr ls b">SharedIndexInformer</code>接口，以便工厂可以统一处理它们。单个informer实例由两个函数初始化:<code class="fe lp lq lr ls b">ListFunc</code>和<code class="fe lp lq lr ls b">WatchFunc</code>，由客户端提供。informer实例将启动异步列表，并使用提供的<code class="fe lp lq lr ls b">ListFunc</code>和<code class="fe lp lq lr ls b">WatchFunc</code>在后台观察。</p><p id="e8db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们已经清楚了客户端工作流和数据结构，最重要的问题是informer如何使用提供的<code class="fe lp lq lr ls b">ListFunc</code>和<code class="fe lp lq lr ls b">WatchFunc</code>来保持本地缓存的新鲜。</p><p id="1bab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一切都存在于informer的<code class="fe lp lq lr ls b">Run</code>函数中，当客户在工厂中设置informer时，该函数被异步调用。在<code class="fe lp lq lr ls b">Run</code>函数中，通知器在每个<code class="fe lp lq lr ls b">resync</code>时间间隔调度一个列表动作。间隔持续时间可以由客户提供。推荐的<code class="fe lp lq lr ls b">resync</code>间隔是O(分钟),以避免发送垃圾Kubernetes API。列表的结果用于填充/刷新缓存中的资源。</p><p id="f901" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">列表动作中有两个有趣的部分。首先，当Kubernetes API在多个页面中返回资源时，informer有一个内置的机制来对资源进行分页。因此，每个列表动作都可以是对客户端提供的<code class="fe lp lq lr ls b">ListFunc</code>(通常是标准的Kubernetes列表API)的一系列调用，每个调用都使用从上一个调用中获得的延续标记。其次，Kubernetes API将在响应中提供一个<code class="fe lp lq lr ls b">resourceVersion</code>。这是一个不透明的字符串，但是它有效地编码了Kubernetes API中的时间戳。通知者记住了这个<code class="fe lp lq lr ls b">resourceVersion</code>，并在下一个<code class="fe lp lq lr ls b">resync</code>将其用作<code class="fe lp lq lr ls b">ListFunc</code>调用的参数。Kubernetes API支持获取不早于给定<code class="fe lp lq lr ls b">resourceVersion</code>的结果的列表语义。通过这种方式，告密者可以确保每次都能得到更新的结果。</p><p id="c702" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">拥有重复列表允许缓存在每个重新同步间隔刷新，但是客户端如何获得更及时的更新呢？这就是手表的用处。客户端通过指定<code class="fe lp lq lr ls b">WatchFunc</code>告诉通知者看什么以及如何看，这也是典型的标准Kubernetes Watch API。Watch是Kubernetes API本身支持的一种功能，客户可以“订阅”创建、更新和删除某个资源集合的事件。informer使用收到的通知来更新缓存中的资源。</p><p id="d2d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Watch API调用中，应该指定一个<code class="fe lp lq lr ls b">resourceVersion</code>参数来指示Kubernetes API返回自那个<code class="fe lp lq lr ls b">resourceVersion</code>(也就是时间戳)以来对集合所做的修改。从机械上来说，Watch API发出Get请求，Kubernetes API用一系列自指定的<code class="fe lp lq lr ls b">resourceVersion</code>以来发生的单个事件来响应。informer使用它从初始列表中获得的<code class="fe lp lq lr ls b">resourceVersion</code>，然后不断更新它从更新的API调用中获得的<code class="fe lp lq lr ls b">resourceVersion</code>。</p><p id="cf3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请参见下图中的直观图示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ly"><img src="../Images/0276f53a5c22cb96079403a2492c6845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JP-qYRBuariqaIwI2uBg3Q.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">Kubernetes内部消息</figcaption></figure><p id="f9a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，Kubernetes API只在有限的时间/修改次数内保留过去的资源版本。因此，如果Kubernetes API认为请求的<code class="fe lp lq lr ls b">resourceVersion</code>过期，它可能会响应410(消失)。在这种情况下，举报人可以发布新的新鲜列表，并使用新获得的<code class="fe lp lq lr ls b">resourceVersion</code>进行后续列表和观察。</p><p id="790a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就把我们带到了这篇博文的最后一个主题:错误处理。告密者很健壮。除非程序崩溃或通知程序被客户端停止，否则通知程序会不断重试失败的列表和观察。每隔<code class="fe lp lq lr ls b">resync</code>间隔，列表会自动重试一次。观察器打开一个持久连接来接收通知。如果失败，告密者会发现错误并立即开始新的监视。列表和/或观察的失败不会导致不一致的结果，因为在下一个列表/观察调用中使用了最新的已知<code class="fe lp lq lr ls b">resourceVersion</code>来确保结果不会比先前调用的结果旧。List和Watch在单独的Goroutines中运行，以避免阻塞。因此，如果单个实例中的List和/或Watch由于某种原因而失败，客户端将观察到的最糟糕的情况是缓存需要更长时间来刷新。</p></div></div>    
</body>
</html>