<html>
<head>
<title>Building a Serverless Backend on AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在AWS上构建无服务器后端</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-serverless-backend-on-aws-762b6f7680c7?source=collection_archive---------8-----------------------#2022-09-12">https://levelup.gitconnected.com/building-a-serverless-backend-on-aws-762b6f7680c7?source=collection_archive---------8-----------------------#2022-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6644" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用亚马逊API Gateway，AWS Lambda和亚马逊Cognito。</h2></div><p id="cd79" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是来自<a class="ae lb" href="https://www.coursera.org/learn/building-modern-java-applications-on-aws" rel="noopener ugc nofollow" target="_blank"> Coursera </a>的<strong class="kh ir"> <em class="lc">在AWS </em> </strong>上构建现代Java应用的亮点。查看课程，了解更多信息和技术细节。</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><p id="e7ca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们正在构建的应用程序使用户能够查看和添加关于龙的数据。这是通过<strong class="kh ir"> /dragons </strong>端点完成的。此端点上可用的方法有:</p><p id="60dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GET:<strong class="kh ir">API网关</strong>接受请求并使用<strong class="kh ir"> Amazon Cognito </strong>检查授权。然后它验证有效负载，并调用后端来查询数据。一个<strong class="kh ir"> AWS </strong> <strong class="kh ir"> Lambda函数</strong>将使用<strong class="kh ir"> S3选择</strong>读取数据。</p><p id="c49e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">POST:请求通过网关后，一个<strong class="kh ir"> Lambda函数</strong>将在后端进行数据验证。我们不想让用户等待响应，所以我们将使用Amazon简单通知服务(<strong class="kh ir"> SNS </strong>)在流程完成时提醒用户(请求卸载)。如果验证通过，将调用Lambda函数来添加要存储在S3中的数据。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lk"><img src="../Images/f6b346961df7e9c4e990e4845c46d32a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xcrjnPtrhNuFafBrDNU0Qg.png"/></div></div></figure><p id="4758" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据存储在<strong class="kh ir"> S3 </strong>中。我们使用亚马逊API网关安全地公开这些数据。一龙唱片的例子:</p><pre class="ll lm ln lo gt lw lx ly lz aw ma bi"><span id="d742" class="mb mc iq lx b gy md me l mf mg">{<br/>      "description_str": "From the northern fire tribe, Atlas was born from the ashes of his fallen father in combat.",<br/>      "dragon_name_str": "Atlas",<br/>      "family_str": "red",<br/>      "location_city_str": "anchorage",<br/>      "location_country_str": "usa",<br/>      "location_neighborhood_str": "w fireweed ln",<br/>      "location_state_str": "alaska"<br/>}</span></pre><p id="210d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在亚马逊API网关<strong class="kh ir">、</strong>上，我们会选择<strong class="kh ir"> REST API </strong>作为API类型。这将使我们能够验证和转换请求和响应。另一个可供选择的相关选项是HTTP API，但它意味着更简单的用例。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/fde32b2067a5455f0e048c0ffcb2b922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*D-46TkHxfaKWLtGZ6MgZig.png"/></div></figure><p id="d4b3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们为后端创建一个模拟(为方法选择集成类型<em class="lc">模拟</em>)。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi mi"><img src="../Images/60353fd67ea45b51b731e98e31c8326a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M2WwYIVfvWY4GS6dg51BfQ.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">请求和响应的流程</figcaption></figure><p id="9bd1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们根据模型验证收到的请求。<strong class="kh ir">型号</strong>定义有效载荷的结构。每种方法可以有不同的模型。验证在方法请求和方法响应中执行。只有经过验证的请求才能到达后端。</p><p id="9c50" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<strong class="kh ir">映射</strong>来转换集成请求和集成响应。在我们的GET方法中，我们可以修改集成响应来检查查询参数(使用VTL语言中的条件)。那样的话，我们就可以模拟对<em class="lc">/龙的请求了？比如dragonName=Atlas </em>。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi mn"><img src="../Images/b67b442daa9111c9b2e12285397e274c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pzbdj9NLtECZj-3_0V3iZA.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">映射示例</figcaption></figure><p id="6b95" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将API部署到一个<em class="lc">阶段</em>(对部署的命名引用)并托管API的多个版本。例如，在创建了一个名为<em class="lc">测试</em>的阶段之后，一个示例请求将会是这样的:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/1ee23f2365cbf096645a274891114a2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*PXwJK836iiSme3fQ7gz7fQ.png"/></div></figure><p id="a0f6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将使用<strong class="kh ir"> Amazon Cognito </strong>用户池向REST API添加身份验证。</p><p id="f646" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">身份验证过程如下:客户端将首先向Amazon Cognito用户池进行身份验证(可以通过托管的身份验证页面完成)。用户池将发回一个JWT令牌，它可以在向API网关发送请求时使用。API网关通过用户池验证令牌。如果通过验证，请求将被允许发送到后端。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/dc49fac8107b39a1162c86e2f426c499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*fuBtINEOFgrji9fdetl4lQ.png"/></div></figure><p id="c10c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们添加Lambda函数。这些将由API网关触发。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/e2b4a6db92209a04708de1c0e70c44e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*F7WD-lnV0pMfwG7wgHzNyQ.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">lambda函数列表龙概述</figcaption></figure><p id="0dd5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Lambda运行处理程序方法来处理事件。这是Java中的通用处理程序形式:map对象将具有事件信息(有效负载、参数等。).上下文将包含调用信息(请求ID、函数ARN等等)。</p><pre class="ll lm ln lo gt lw lx ly lz aw ma bi"><span id="8fbd" class="mb mc iq lx b gy md me l mf mg">import com.amazonaws.services.lambda.runtime.RequestHandler;<br/>...</span><span id="e056" class="mb mc iq lx b gy mr me l mf mg">public class Handler implements RequestHandler&lt;Map&lt;...&gt;, String&gt; {</span><span id="df17" class="mb mc iq lx b gy mr me l mf mg">@Override<br/>public String handleRequest(Map&lt;...&gt; event, Context context) {<br/>    // business logic<br/>    return response;<br/>}</span></pre><p id="b1b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免每次调用的引导时间，Lambda函数将尝试重用执行环境。</p><p id="289d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在日志中查看最近的调用:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/feb4b1016ef303098797be3aa50325d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*JkfV1lw5WZyymn_i0Ru9pQ.png"/></div></figure><p id="c316" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们使用<strong class="kh ir"> AWS步骤函数</strong>为POST请求创建这个工作流(当用户提交一个新的dragon时)。如果新对象有效，则添加它。结果通过使用<strong class="kh ir"> SNS </strong>(亚马逊简单通知服务)以消息形式发送。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/5c6d922c4a5db5f1ec1875def72c4365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*jShQ46IUjdnEdcCM2EJSOg.png"/></div></figure><p id="245b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以使用<strong class="kh ir"> AWS X射线查看痕迹。</strong>例如，这是对调用<em class="lc"> ListDragons </em> Lambda函数的GET请求的跟踪。这个因为冷启动慢。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi mu"><img src="../Images/9e822655dc4f4ec3c58e6b4e0bdca7e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nP054FJ4DlCgTWmcqWRwqA.png"/></div></div></figure></div></div>    
</body>
</html>