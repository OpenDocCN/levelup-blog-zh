<html>
<head>
<title>Website Performance Optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">网站性能优化</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/website-performance-optimization-cd1647498274?source=collection_archive---------5-----------------------#2020-05-20">https://levelup.gitconnected.com/website-performance-optimization-cd1647498274?source=collection_archive---------5-----------------------#2020-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/19895d9a062b02fa5e18309df84c22eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cag2urrpAcDUmDYFc1Lxhw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@traf?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Traf </a>在<a class="ae kf" href="https://unsplash.com/s/photos/speed?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="12fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">会有那些紧张的日子，你会疯狂地思考和研究如何优化你的网站的性能和速度。</p><p id="8502" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">嗯，我已经经历过了，完全理解这种痛苦，所以在这里分享所有帮助我和我的朋友的发现，并且肯定会帮助你改善你的网站的页面加载时间。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="d730" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><strong class="ak">代码拆分</strong></h1><p id="9803" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在SPAs中，您可能已经体验过主Javascript包变得如此之大(因为单个Javascript文件负责加载您的整个网站),以至于浏览器需要花费大量时间来加载、解析、编译和执行您的脚本，从而增加了页面的交互时间。</p><p id="21b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">嗯，你很幸运，c <em class="mo">颂分裂</em>是<em class="mo">的</em>来救你了。它允许您将应用程序的Javascript分成更小的块，允许您发送加载用户可见页面所需的最少代码，其余代码可以随时随地按需加载。最佳实践是将每个块的大小保持在150KB以下。即使在糟糕的网络上，该应用程序也能在5秒内变得交互式。</p><p id="a8cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有两种流行的实现代码拆分的方法，基于路由的和基于组件的。你真的需要注意如何拆分你的应用程序代码，因为这将对你的页面速度产生重大影响。</p><p id="d656" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，webpack提出了许多实现代码拆分的方法。</p><ul class=""><li id="cf25" class="mp mq it ki b kj kk kn ko kr mr kv ms kz mt ld mu mv mw mx bi translated">使用Javascript的动态导入api <code class="fe my mz na nb b">import()</code>的动态导入</li><li id="716b" class="mp mq it ki b kj nc kn nd kr ne kv nf kz ng ld mu mv mw mx bi translated">使用<code class="fe my mz na nb b">entry</code>配置分割代码，以及</li><li id="af0d" class="mp mq it ki b kj nc kn nd kr ne kv nf kz ng ld mu mv mw mx bi translated"><code class="fe my mz na nb b">SplitChunksPlugin</code></li></ul><p id="e1f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查看webpack关于代码分割的<a class="ae kf" href="https://webpack.js.org/guides/code-splitting/" rel="noopener ugc nofollow" target="_blank">文档</a>,了解更多相关信息。您可能还想检查React的<code class="fe my mz na nb b">lazy</code> <a class="ae kf" href="https://reactjs.org/docs/code-splitting.html#reactlazy" rel="noopener ugc nofollow" target="_blank"> api </a>，这有助于将动态导入渲染为常规组件。</p><p id="e0b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想在一个服务器渲染的应用中进行代码分割，检查<a class="ae kf" href="https://github.com/gregberge/loadable-components" rel="noopener ugc nofollow" target="_blank">可加载组件</a>。</p><h1 id="9929" class="ll lm it bd ln lo nh lq lr ls ni lu lv lw nj ly lz ma nk mc md me nl mg mh mi bi translated">树摇晃</h1><p id="94f1" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">摇树意味着从你的脚本中删除死代码。它提出了ECMAScript 2015对静态导入和导出的支持。因为这些是静态导入和导出，所以我们可以在编译时从包中移除未使用的导出。</p><p id="b9a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请记住，树抖动发生在编译时，而不是运行时，以防您有一些动态导入(我们不能确定代码的哪一部分将保持不使用)。</p><p id="6c0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要启用树抖动，可以使用<code class="fe my mz na nb b">package.json</code>的<code class="fe my mz na nb b">sideEffects</code>属性。如果在你的模块和代码中没有副作用，将它设置为false，在这种情况下，webpack将在编译时从包中删除未使用的代码。</p><pre class="nm nn no np gt nq nb nr ns aw nt bi"><span id="a388" class="nu lm it nb b gy nv nw l nx ny">{<br/>  "name": "project",<br/>  "sideEffects": false<br/>}</span></pre><p id="0cdb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe my mz na nb b">sideEffects</code>属性也接受一个数组，您可以在其中指定带有副作用的文件的路径，比如样式表或模块。路径可以是相对的、绝对的或全局的模式。</p><pre class="nm nn no np gt nq nb nr ns aw nt bi"><span id="7fc5" class="nu lm it nb b gy nv nw l nx ny">{<br/>  "name": "project",<br/>  "sideEffects": [<br/>    "*.css",<br/>    "./src/side-effect-file.js"<br/>  ]<br/>}</span></pre><p id="1860" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想指定每个函数的副作用(例如，在一个函数中你可能声明了没有被使用的变量)，你可以检查一个叫做<code class="fe my mz na nb b">usedExports</code>的webpack优化。你也可以在函数的顶部添加一个注释<code class="fe my mz na nb b">/*#__PURE__*/</code>。</p><p id="1443" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，webpack在生产模式下从包中删除了死代码，因此您需要在配置中将<code class="fe my mz na nb b">mode</code>设置为<code class="fe my mz na nb b">production</code>，这也将启用缩小功能。如果你问我关于<code class="fe my mz na nb b">development</code>模式的问题，那么webpack只是在未使用的代码上面添加了一个注释，提到这段代码是未使用的，但不会将其从包中移除。</p><p id="2d6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了<code class="fe my mz na nb b">mode</code>之外，你还可以使用<code class="fe my mz na nb b">--optimize-minimize</code>标志来启用Terser插件。这里需要注意的是，ModuleConcatenationPlugin是在生产模式下自动添加的，因此如果您不使用生产模式，您需要手动添加插件。</p><p id="30a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦您完成了添加sideEffects状态，继续，再次运行构建并检查死代码是否从生成的包中删除。</p><p id="a6cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查看webpack的摇树指南<a class="ae kf" href="https://webpack.js.org/guides/tree-shaking/" rel="noopener ugc nofollow" target="_blank">此处</a>了解更多详情。</p><h1 id="4ccc" class="ll lm it bd ln lo nh lq lr ls ni lu lv lw nj ly lz ma nk mc md me nl mg mh mi bi translated">惰性装载</h1><p id="96b8" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">延迟加载意味着延迟图像、视频等资源，直到它们出现在视窗中并被用户实际看到。这减少了不必要的内容权重、所需的处理并节省了内存，使您的页面性能更好。</p><p id="69b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">换句话说，这意味着在实现时，我们将只加载在视口中可见的内容，其余的内容将在它进入视口或与视口有一定距离时加载。</p><p id="c8ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以通过以下方式实现延迟加载。</p><ul class=""><li id="7b0c" class="mp mq it ki b kj kk kn ko kr mr kv ms kz mt ld mu mv mw mx bi translated">交叉点观察器API:应用最广泛。跨浏览器兼容性可能是一个问题，因为它可能不是所有的浏览器都支持。<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank">查看此处</a>。</li><li id="a427" class="mp mq it ki b kj nc kn nd kr ne kv nf kz ng ld mu mv mw mx bi translated">滚动和调整事件处理程序:性能较低，但浏览器兼容性良好。如果您更关心兼容性，并且可以使用性能较低的方法，那么您可以使用这种方法。</li><li id="eb35" class="mp mq it ki b kj nc kn nd kr ne kv nf kz ng ld mu mv mw mx bi translated">原生加载属性:在Chrome 76中，图像和iframe元素支持一个名为<code class="fe my mz na nb b">loading</code>的属性，可以根据需要延迟或提前加载这些资源。虽然不是所有的浏览器都完全支持，但是如果你想避免编写JS或者使用不同的库和API来实现延迟加载，用这个实现延迟加载真的很容易。<code class="fe my mz na nb b">&lt;img src="image.jpg" alt="Test Image" loading="lazy" /&gt;</code></li></ul><p id="cca3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请不要忘记增加<code class="fe my mz na nb b">&lt;img&gt;</code>元素的宽度和高度，以避免图片下载时的回流。下一点将让你对此有更深入的了解。</p><p id="9ae1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">视频的延迟加载</strong>取决于用户的需求，比其他的需要更多的关注。我认为你正在使用<code class="fe my mz na nb b">&lt;video&gt;</code>元素在你的页面上包含视频，这是大多数时候的情况。</p><p id="9c18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您禁用了视频的自动播放，则在用户播放视频之前，您无需预加载视频内容。<code class="fe my mz na nb b">&lt;video&gt;</code>元素带有一个<code class="fe my mz na nb b">preload</code>属性，该属性给浏览器一个提示，告诉目标用户视频内容的行为应该是什么。您应该将其值设置为<code class="fe my mz na nb b">none</code>以避免预加载任何视频数据，并提供一个<code class="fe my mz na nb b">poster</code>属性来添加占位符。</p><pre class="nm nn no np gt nq nb nr ns aw nt bi"><span id="9456" class="nu lm it nb b gy nv nw l nx ny">&lt;video controls preload="none" poster="video-placeholder.jpg"&gt;<br/>  &lt;source src="video.mp4" type="video/mp4"&gt;<br/>&lt;/video&gt;</span></pre><p id="e2d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请记住，这并不强制浏览器遵循您的定义，而是作为浏览器的一个提示。</p><p id="92fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Chrome中<code class="fe my mz na nb b">preload</code>的默认设置曾经是<code class="fe my mz na nb b">auto</code>，现在从Chrome 64开始，是<code class="fe my mz na nb b">metadata</code>。像这样，不同的浏览器在不同的条件下有不同的默认值，例如在数据保护模式下，它被设置为<code class="fe my mz na nb b">none</code>。</p><p id="8058" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在预加载并不是推迟视频内容加载的唯一方式，点击<a class="ae kf" href="https://developers.google.com/web/fundamentals/media/fast-playback-with-video-preload" rel="noopener ugc nofollow" target="_blank">这里</a>。<br/>勾选<em class="mo">链接预加载</em> <a class="ae kf" href="https://developers.google.com/web/fundamentals/media/fast-playback-with-video-preload#preload_the_first_segment" rel="noopener ugc nofollow" target="_blank">此处</a>仅预加载第一个片段，如果您启用了自动播放，这将有助于后续操作。</p><p id="5f3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">注意:</em>自动播放优先于预载。</p><h1 id="432a" class="ll lm it bd ln lo nh lq lr ls ni lu lv lw nj ly lz ma nk mc md me nl mg mh mi bi translated">指定图像尺寸</h1><p id="717f" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">重要提示:一定要定义图片的宽度和高度，以使你的页面更有表现力，并有流畅的用户体验。</p><pre class="nm nn no np gt nq nb nr ns aw nt bi"><span id="dc48" class="nu lm it nb b gy nv nw l nx ny">&lt;img src="image.jpg" width="400" height="300" /&gt;</span></pre><p id="c0f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这通过在下载图像时为页面上的图像保留适当的占位空间来避免布局偏移(jank问题)。</p><p id="2edb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，在响应式网页设计的时代，当你想让你的图片具有响应性时，你就开始使用css来调整图片的大小，比如添加</p><pre class="nm nn no np gt nq nb nr ns aw nt bi"><span id="d6fc" class="nu lm it nb b gy nv nw l nx ny">.responsive-image {<br/>  width: 100%;<br/>  height: auto;<br/>}</span></pre><p id="89ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在您的样式表和我们的解决方案中，防止jank在这里不再工作，也就是说，我们再次开始看到布局的变化，从而多次重画。</p><p id="0608" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最近，Mozilla想出了一个主意，使用图像元素中的宽度和高度属性来计算其纵横比，从而在图像完全加载之前计算图像尺寸。这可以防止加载图像时不必要的重新布局，并大大提高性能，尤其是在网速极慢的情况下。</p><p id="8d25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该支持最近已于2019年12月在Firefox 71和Chrome 79中发货。CSS属性仍处于试验阶段，以方便进一步扩展对所有元素的支持。</p><p id="e762" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查看<a class="ae kf" href="https://www.youtube.com/watch?v=4-d_SoCHeWE" rel="noopener ugc nofollow" target="_blank">这个</a>惊人的视频，了解更详细的解释。</p><h1 id="e0d0" class="ll lm it bd ln lo nh lq lr ls ni lu lv lw nj ly lz ma nk mc md me nl mg mh mi bi translated">用视频替换gif</h1><p id="8df2" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">动画gif可以大到几兆字节。幸运的是，我们可以将我们的GIF文件转换成瘦的快速视频文件，并使用<code class="fe my mz na nb b">&lt;video&gt;</code>元素来实现GIF外观行为，方法是启用自动播放并让它们无声地循环，就像</p><pre class="nm nn no np gt nq nb nr ns aw nt bi"><span id="1b4e" class="nu lm it nb b gy nv nw l nx ny">&lt;video autoplay muted loop playsinline&gt;<br/>  &lt;source src="video.mp4" type="video/mp4"&gt;<br/>&lt;/video&gt;</span></pre><p id="8f12" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这不仅意味着从你的页面中砍掉兆字节，还意味着减少CPU时间(视频比gif占用更少的CPU时间),这是除了减少文件大小以外改善页面加载时间的一个重要方面。</p><h1 id="c22e" class="ll lm it bd ln lo nh lq lr ls ni lu lv lw nj ly lz ma nk mc md me nl mg mh mi bi translated">避免文档.写</h1><p id="0bc2" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">您应该避免包含使用<code class="fe my mz na nb b">document.write</code>的脚本，因为它们可能会被解析器阻塞。此外，如果在文件加载后运行<code class="fe my mz na nb b">document.write</code>，它将再次清除文件并写入文件，从而影响您的性能。</p><p id="5cb1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，使用它并不被认为是一个好的做法，从Chrome 55继续，任何包含使用<code class="fe my mz na nb b">document.write</code>的脚本都不会被执行(如果在2G连接以及其他一些条件下)。</p><p id="f7a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您计划导入的所有第三方脚本可能都不支持异步加载，这将阻止您的页面进一步执行，直到该脚本完全下载并执行，如果该脚本使用其他脚本，可能会导致大量往返网络行程，从而大大降低您的页面速度。</p><p id="429e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您包含一些第三方代码片段，不要忘记使用async/defer异步加载它们(请检查哪种方式更适合您)。如果必须选择的话，用<code class="fe my mz na nb b">appendChild()</code>代替<code class="fe my mz na nb b">document.write</code>。</p><p id="f579" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另外，请确保您使用的第三方脚本支持异步加载，或者找到一个支持异步加载的替代方案。</p><h1 id="2da9" class="ll lm it bd ln lo nh lq lr ls ni lu lv lw nj ly lz ma nk mc md me nl mg mh mi bi translated">移除未使用的CSS</h1><p id="7687" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">相信我，这是有帮助的，因为我们总是在没有意识到的情况下，拥有大量未使用的CSS。</p><p id="7b81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">删除所有重复的css属性和不必要的覆盖。使用<a class="ae kf" href="https://github.com/css-modules/css-modules" rel="noopener ugc nofollow" target="_blank"> css-modules </a>来局部限定css选择器的范围。这将让你为每个组件拥有一个单独的css模块。因此，当你实现比如说树抖动、代码分割等时，css模块也将被抖掉，或者与它的作用域组件模块放在一个单独的包中。</p><p id="6825" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样做将消除未使用的CSS，从而在更大程度上改善页面加载时间。</p><p id="b172" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">需要记住的一点是，CSS被视为呈现阻塞资源，这意味着在CSS对象模型构建完成之前，浏览器不会呈现任何经过处理的内容。使用媒体类型和媒体查询来帮助浏览器将一些CSS资源标记为非呈现阻塞。</p><h1 id="4813" class="ll lm it bd ln lo nh lq lr ls ni lu lv lw nj ly lz ma nk mc md me nl mg mh mi bi translated">为你的选择器使用以类为中心的方法</h1><p id="7964" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">降低你使用的CSS选择器的复杂性。有时你最终会像这样使用选择器:</p><pre class="nm nn no np gt nq nb nr ns aw nt bi"><span id="1da1" class="nu lm it nb b gy nv nw l nx ny">.list:nth-last-child(n-1) .headline {<br/>  /* styles */<br/>}</span></pre><p id="0247" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了让浏览器知道将这些样式应用于哪个元素，它必须问一个类似于“这是一个具有标题类的元素吗？它的父元素是第n个子元素减去一个具有列表类的元素”。根据浏览器的不同，确定这一点可能需要很长时间，因此您应该采用以下方法:</p><pre class="nm nn no np gt nq nb nr ns aw nt bi"><span id="2bcc" class="nu lm it nb b gy nv nw l nx ny">.custom-list-headline {<br/>  /* styles */<br/>}</span></pre><p id="6b54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请不要介意类名，重点是现在浏览器可以更容易地定位和计算带有<em class="mo"> custom-list-headline </em>类的元素的样式。BEM遵循以类为中心的方法优化这种行为，还有其他有效的方法接近你的选择器。</p><h1 id="2016" class="ll lm it bd ln lo nh lq lr ls ni lu lv lw nj ly lz ma nk mc md me nl mg mh mi bi translated">减少回流</h1><p id="3e36" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">重排是一种用户阻止的操作，用于重新计算文档中元素的位置和尺寸，从而重新呈现部分或整个文档。</p><p id="b328" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你会惊讶地发现，我们是多么容易地在文档中完成大量的重排版，例如，仅仅通过改变css样式或元素的类，像<code class="fe my mz na nb b">:hover</code>这样的伪类，动画，在DOM中添加/删除/更新元素，等等。</p><p id="1161" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这会影响性能，因为更新单个元素会影响它的子元素、祖先元素和兄弟元素，导致花费更多时间来执行回流。这就是为什么总是建议减少DOM深度的原因。</p><p id="5548" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有很多关于reflow的内容，如果你感兴趣的话，我在这里找到了一些好的信息<a class="ae kf" href="https://developers.google.com/speed/docs/insights/browser-reflow" rel="noopener ugc nofollow" target="_blank">作者<em class="mo"> Lindsey Simon </em>和</a>作者<em class="mo"> Charis Theodoulou </em>。这里有一个提到的API列表<a class="ae kf" href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a" rel="noopener ugc nofollow" target="_blank">在JS中被调用时会强制一个回流。</a></p><h2 id="6d10" class="nu lm it bd ln nz oa dn lr ob oc dp lv kr od oe lz kv of og md kz oh oi mh oj bi translated">减少油漆面积</h2><p id="ca9a" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">画图通常是渲染页面管道中运行时间最长的任务，所以我们应该尽量减少画图区域并简化其复杂性。在此检查<a class="ae kf" href="https://developers.google.com/web/fundamentals/performance/rendering/simplify-paint-complexity-and-reduce-paint-areas#promote_elements_that_move_or_fade" rel="noopener ugc nofollow" target="_blank">层提升</a>以减少油漆区域。</p><h1 id="8e00" class="ll lm it bd ln lo nh lq lr ls ni lu lv lw nj ly lz ma nk mc md me nl mg mh mi bi translated">滑块</h1><p id="01ce" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在为你的网站选择滑块库的时候一定要小心，因为它们真的会降低你的页面速度，例如<code class="fe my mz na nb b">react-slick</code>会导致你的布局产生昂贵的强制回流。</p><p id="ad0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我会推荐使用<code class="fe my mz na nb b"><a class="ae kf" href="https://www.npmjs.com/package/@glidejs/glide" rel="noopener ugc nofollow" target="_blank">Glide.js</a></code>，因为它重量轻，速度快，到目前为止还没有给我们带来任何性能问题。</p><h1 id="8198" class="ll lm it bd ln lo nh lq lr ls ni lu lv lw nj ly lz ma nk mc md me nl mg mh mi bi translated">分析和优化您的产品包</h1><p id="7f52" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">使用类似<code class="fe my mz na nb b"><a class="ae kf" href="https://www.npmjs.com/package/webpack-bundle-analyzer" rel="noopener ugc nofollow" target="_blank">webpack-bundle-analyzer</a></code>的包分析器对您的包进行可视化分析，并移除不再需要的包。检查所用包的大小，如果可能的话，使用轻量级的替代品。</p><p id="d891" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在你的应用程序中运行<code class="fe my mz na nb b">npm dedupe</code>来删除npm包的副本(同一个包的不同版本)并优化你的包树。</p><p id="1f11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，迁移到最新版本的包，因为它们本身经过了一些性能优化，可能会更有效。</p><h1 id="110a" class="ll lm it bd ln lo nh lq lr ls ni lu lv lw nj ly lz ma nk mc md me nl mg mh mi bi translated">导入特定模块，而不是整个库</h1><p id="e88e" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">只导入您需要的模块，而不是导入整个库。例如:</p><p id="084a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">跟随</p><pre class="nm nn no np gt nq nb nr ns aw nt bi"><span id="f6ee" class="nu lm it nb b gy nv nw l nx ny">import get from “lodash/get”;</span></pre><p id="7899" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代替</p><pre class="nm nn no np gt nq nb nr ns aw nt bi"><span id="bf55" class="nu lm it nb b gy nv nw l nx ny">import { get } from “lodash”;</span></pre><p id="59b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第一种情况下，您只导入了模块(~2kB)，而在第二种情况下，您最终导入了整个库(~25kB)。</p><h1 id="9315" class="ll lm it bd ln lo nh lq lr ls ni lu lv lw nj ly lz ma nk mc md me nl mg mh mi bi translated">限制每个函数的行数</h1><p id="1a19" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">您应该遵循编写较小函数的习惯，限制自己每个函数不超过一定的行数。</p><p id="25ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你实现了树抖动，除了它的其他好处之外，用这种方式编写的函数将有助于消除每一小段无用的代码。</p><h1 id="42e6" class="ll lm it bd ln lo nh lq lr ls ni lu lv lw nj ly lz ma nk mc md me nl mg mh mi bi translated">贮藏</h1><p id="be35" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">缓存你的代码以最小化网络行程，你可以实现HTTP缓存，服务工作者缓存，如果使用webpack，那么检查文件名散列，cdn等。</p><p id="a6f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，你可以使用HTTP缓存，因为它很容易实现，虽然没有太大的灵活性，但它是有效的，并且在所有浏览器中都受支持。</p><p id="df03" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">缓存本身是一个广阔的领域，我不能在这里告诉你所有的内容，但是将来我一定会告诉你，包括其他几种缓存类型的细节，比如数据库缓存。</p><h1 id="ac72" class="ll lm it bd ln lo nh lq lr ls ni lu lv lw nj ly lz ma nk mc md me nl mg mh mi bi translated">优化广告加载</h1><p id="ba6e" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">如果你在页面上显示广告，你需要非常小心你是如何加载它们的。</p><p id="fe7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总是异步加载你的广告，或者在你的页面加载后加载，因为它们会长时间阻塞你的主线程，影响你的页面性能。</p><h1 id="11bd" class="ll lm it bd ln lo nh lq lr ls ni lu lv lw nj ly lz ma nk mc md me nl mg mh mi bi translated">小心处理target="_blank "</h1><p id="ae10" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">最后但同样重要的是，看看这个<a class="ae kf" href="https://medium.com/@iamgarima/performance-security-and-target-blank-7f05956d9eb5" rel="noopener">博客</a>，我已经解释了在锚标签中使用<code class="fe my mz na nb b">target</code>属性时的一点疏忽会如何影响你的应用程序的性能和安全性。</p><p id="7df4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">我已经试着把我在研究过程中发现的所有东西和帮助我优化页面速度的东西都包括进去了。希望你也觉得有用。您可以随时深入这些主题，了解更多关于它们的实现，因为现在您知道要寻找什么了。</em></p><p id="2b3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">如果你有更多关于如何优化页面速度的建议，以及什么帮助你改善了页面加载时间，我会很乐意知道的。请写在下面的回应，或者你可以直接ping我。</em></p></div></div>    
</body>
</html>