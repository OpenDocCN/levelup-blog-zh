<html>
<head>
<title>Compiling Brainf*** to WebAssembly with Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Go编译Brainf***到WebAssembly</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/compiling-brainf-to-webassembly-with-go-8838519e3c8b?source=collection_archive---------13-----------------------#2021-12-31">https://levelup.gitconnected.com/compiling-brainf-to-webassembly-with-go-8838519e3c8b?source=collection_archive---------13-----------------------#2021-12-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d138e08f0abd18b33ff73c21785edab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-GNPYxnnN8lxeMXMEBnzDA.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">Mandelbrot使用WebAssembly在网页上运行。曼德勃罗集分形浏览器。</figcaption></figure><div class=""/><div class=""><h2 id="aab6" class="pw-subtitle-paragraph kf jh ji bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dk translated">编写编译器和WebAssembly的介绍。</h2></div><p id="0447" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">Go是一种最小化的语言，与Haskell或C++等其他语言相比，它可能使得编写编译器或解释器更难概念化。今天，我想向您展示Go如何成为学习编译器编写的有效工具，此外，我们还可以通过编写自己的编译器来探索WebAssembly所提供的一些功能。</p><p id="b7b3" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">首先，理解我们的输入语言Brainfuck及其工作原理非常重要。它是最著名的深奥编程语言，1993年首次上传到Aminet，试图编写尽可能小的编译器。Brainfuck本质上是一个非常基本的图灵机，在一个被称为<em class="lt">细胞</em>或<em class="lt">磁带</em>的无限大的一维字节数组上运行。Brainfuck的8个操作移动光标，修改单元格，比较单元格值。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="86fd" class="md me ji lz b gy mf mg l mh mi">These are the 8 characters/operations of all Brainfuck programs:<br/>+     increment the cell being pointed to<br/>-     decrement the cell being pointed to<br/>&gt;     move the cursor right one cell<br/>&lt;     move the cursor left one cell<br/>.     print the cell's value as an ASCII character<br/>,     read the next character input from user into cell<br/>[     jump to matching closing bracket if cell is zero<br/>]     jump to matching opening bracket if cell is NOT zero</span><span id="fefb" class="md me ji lz b gy mj mg l mh mi">The below is a multiplication of cell 1 to cell 2 resulting in 36:<br/>++++++++ set cell 1 to 8<br/>[        jump to closing bracket if the current cell is 0<br/>  &gt;      go right to cell 2<br/>  ++++   increment four times<br/>  &lt;      go back to cell 1<br/>  -      decrement cell 1<br/>]        jump to opening bracket if the current cell is not 0<br/>&gt;        go to cell 2<br/>.        prints '$'<br/>&gt;,.      go to cell 3; read an input; print it out</span></pre><p id="4942" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">Brainfuck是第一代编译器的有力竞争者，因为它只需要很少的解析和代码生成魔法就能让事情运转起来。我们将瞄准WebAssembly (WASM)来生成可移植的和优化的Brainfuck程序，这些程序可以在web浏览器上运行。WebAssembly是现代web浏览器的一种新的二进制语言。它比JavaScript更小，执行速度更快。</p><p id="4cf5" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">WebAssembly需要JavaScript来与DOM交互。在WebAssembly中，您可以导入和导出函数、常数，甚至程序使用的内存。虽然WASM是一种二进制格式，这将是复杂的，但非常有可能直接编译成，它只是更容易修复代码生成问题，如果我们生成WebAssembly的文本等效，称为WAT，或WebAssembly文本。所以，让我们熟悉一下WAT语法，因为这是我们的Go程序将要发出的代码。</p><figure class="lu lv lw lx gt iv"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="f1d9" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这是一个简单的WebAssembly程序，导出两个函数:<em class="lt"> add </em>和<em class="lt"> mul </em>。两个函数都接受两个i32参数并返回一个i32。你可能注意到我用不同的语法编写了函数。也就是说，<em class="lt"> add </em>使用的是<a class="ae mm" href="https://webassembly.github.io/spec/core/text/instructions.html#folded-instructions" rel="noopener ugc nofollow" target="_blank"> S-expression语法</a>。两者都有效，但S表达式风格通常是首选。</p><p id="d9b1" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这是怎么回事？WebAssembly是一种类似Forth的基于堆栈的语言，其中有一个隐式的值堆栈，您可以推送和弹出这些值。在<em class="lt">的末尾添加</em>和<em class="lt"> mul </em>，这意味着我们将在堆栈上留下一个项目作为我们的返回值。我们留下的那个值是调用<code class="fe mn mo mp lz b">i32.add</code>或<code class="fe mn mo mp lz b">i32.mul</code>的结果。在我们的<em class="lt"> mul </em>函数中，我们将<code class="fe mn mo mp lz b">$a</code>的值推入堆栈，然后将<code class="fe mn mo mp lz b">$b</code>的值放在它的顶部。当我们随后调用<code class="fe mn mo mp lz b">i32.mul</code>时，它从堆栈中弹出两个参数，并推送结果；<code class="fe mn mo mp lz b">$a</code>乘以<code class="fe mn mo mp lz b">$b</code>。<em class="lt">添加</em>跟风。</p><p id="23ea" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">WebAssembly实际上不知道JavaScript或任何其他语言的存在。WebAssembly只有32位和64位整数和浮点、函数、表和连续的内存数组。为了与JavaScript共享函数或数据，您将事物标记为导入或导出。导出的项位于WebAssembly代码的本地，但可以从JavaScript访问。导出的项通常是在WebAssembly中声明的函数，您可能希望从JavaScript调用这些函数。导入的项目对于JavaScript是本地的，但从WebAssembly是可读/可写的。导入项通常是JavaScript中声明的全局变量或内存。</p><figure class="lu lv lw lx gt iv"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="6e9d" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这里我们从JavaScript导入内存(一个64KB的页面)、全局单元格指针值和IO函数。<em class="lt"> putChar </em>将接收一个Unicode字符值并打印到网页上。getChar 将返回用户输入的下一个8位字符。这两个函数是我们的WebAssembly程序对外界的唯一窗口，甚至它们也受我们如何在JavaScript中实现它们的控制。</p><p id="4bdb" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">最后，我们声明并导出我们的主函数，<em class="lt"> runBrainfuck </em>。当我们从JavaScript调用这个函数时，我们生成的Brainfuck程序将被执行。我们从JavaScript导入的内存将被用作我们的磁带。我们使用像<code class="fe mn mo mp lz b">i32.store8</code>和<code class="fe mn mo mp lz b">i32.load8_u</code>这样的函数向我们的单元写入和读取8字节的内存。</p><figure class="lu lv lw lx gt iv"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="531a" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在上面，我包含了index.html页面和main.js代码，作为WebAssembly模块的接口。在JavaScript中，我们声明了<em class="lt">内存</em>和<em class="lt"> cellptr </em>常量，并将它们包含在<em class="lt"> importObject中。我们还在那里定义了<em class="lt"> putChar </em>和<em class="lt"> getChar </em>的函数。在底部，我们获取我们的WebAssembly模块，给它我们的<em class="lt"> importObject </em>，然后调用<code class="fe mn mo mp lz b">runBrainfuck()</code>。</em></p><p id="7504" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">如果我们重温一下我们之前的WebAssembly模板，我们可以清楚地看到我们是如何从JavaScript对象中导入这些类型的:</p><figure class="lu lv lw lx gt iv"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="9432" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我希望现在我已经清楚了WebAssembly与我们的网页和JavaScript的关系。现在我们可以看看一个Brainfuck程序，以及我们期望它如何转化为WebAssembly。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="197f" class="md me ji lz b gy mf mg l mh mi">+++++++++++++ 13<br/>[&gt;+++++&lt;-]    times 5<br/>&gt;.+.+.        ABC</span></pre><p id="5ed5" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这个程序将第一个单元格的值设置为13，然后当第一个单元格不为空时，它将第二个单元格加5，并减少第一个单元格。此操作的结果是清除第一个单元，留下第二个单元，结果为13乘以5。最后，程序打印ASCII字符65，加1，打印66，加1，打印67。结果是输出“ABC”。我们将把这个程序翻译成WebAssembly，看看这些基本功能是如何工作的。</p><p id="6dbf" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">首先，如果你直接做，把13加到内存的第一个字节是很简单的:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="06c3" class="md me ji lz b gy mf mg l mh mi">(i32.const 0)<br/>(i32.store8 (i32.add (i32.load8_u 0) (i32.const 13)))</span></pre><p id="c62e" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们将想要存储的内存的字节索引压入，然后我们将常量13压入单元格0处的字节。这两个值放入堆栈后，我们调用<code class="fe mn mo mp lz b">i32.store8</code>用新值更新单元格。我们可以使用全局变量来告诉我们当前指向哪个单元格:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="e416" class="md me ji lz b gy mf mg l mh mi">(global.get $cellptr)<br/>(i32.add (i32.load8_u (global.get $cellptr) (i32.const 13)))<br/>(i32.store8)</span></pre><p id="c3b5" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我在这里展开了表达式，因为它溢出了行。</p><p id="790b" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">如果您的编译器知道重复出现的'+'和'-'应该合并成一个完整的加法或减法，那么上面的代码将会产生什么结果。换句话说，如果你让编译器优化输入程序，它会产生更少的指令。更直接的翻译应该是:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="6c06" class="md me ji lz b gy mf mg l mh mi">(global.get $cellptr)<br/>(i32.add (i32.load8_u (global.get $cellptr) (i32.const 1)))<br/>(i32.store8)</span><span id="9ed8" class="md me ji lz b gy mj mg l mh mi">(global.get $cellptr)<br/>(i32.add (i32.load8_u (global.get $cellptr) (i32.const 1)))<br/>(i32.store8)</span><span id="24cc" class="md me ji lz b gy mj mg l mh mi">(global.get $cellptr)<br/>(i32.add (i32.load8_u (global.get $cellptr) (i32.const 1)))<br/>(i32.store8)</span><span id="7405" class="md me ji lz b gy mj mg l mh mi">... ten more times</span></pre><p id="ca1c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">但是为了可读性，我们将假设我们的程序是优化的。</p><p id="fc87" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在我们需要看看循环我们的程序。在Brainfuck代码中，我们在单元格0不为空时循环。当它不为空时，我们将增加单元格指针，使其指向内存中的下一个单元格。然后加上5，回到第一个单元格，减去1，然后检查我们是否应该再次循环。我在这里实现了该行为:</p><figure class="lu lv lw lx gt iv"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="5043" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这实际上是我们实现编译器所需的每一条指令。与其他函数或全局变量一样，<code class="fe mn mo mp lz b">block</code>也有自己的标签。当你使用带有块标签的<code class="fe mn mo mp lz b">br</code>或<code class="fe mn mo mp lz b">br_if</code>语句时，它实际上将完全退出那个块。这种行为与<code class="fe mn mo mp lz b">loop</code>相反，它只会在<code class="fe mn mo mp lz b">br</code>或<code class="fe mn mo mp lz b">br_if</code>语句时重复。我用一个块包装这个循环，这样如果当前单元格是空的，它将跳过这个块。否则，循环运行一次，检查相反的条件以确定循环是否应该再次运行，等等。</p><p id="629b" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">其他新说明应该是不言自明的，但如果不是，请阅读<a class="ae mm" href="https://webassembly.github.io/spec/core/exec/index.html" rel="noopener ugc nofollow" target="_blank"> WebAssembly参考</a>。可以是技术性的，但是很得心应手！</p><figure class="lu lv lw lx gt iv"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="f0bc" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在程序的最后部分，我们在修改第一个单元格的值时调用了三次<em class="lt"> putChar </em>。外部或内部调用函数的工作方式与使用标准指令完全相同:您将作为<em class="lt">参数的值</em>推送到函数，这些值将被弹出，留在堆栈上的是返回值(如果有的话)。</p><p id="2c86" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在我们可以把这个例子编译成WASM，并在我们的浏览器中试用。您可能还记得，我之前提到过WASM是二进制格式，而WAT是文本格式。你可以从WebAssembly二进制工具包下载很多很棒的工具，但是也就是说<code class="fe mn mo mp lz b">wat2wasm</code>对于将我们的WAT文件转换成WASM特别有用。如果你想继续学习，你应该下载这个工具包并把它添加到你的路径中:<a class="ae mm" href="https://github.com/WebAssembly/wabt/releases" rel="noopener ugc nofollow" target="_blank">发布web assembly/wabt(github.com)</a></p><p id="8edd" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在收集之前的index.html和main.js文件，以及这个程序(称之为brainfuck.wat)，并把它们都放在一个目录中。打开终端中的目录，首先执行<code class="fe mn mo mp lz b">wat2wasm brainfuck.wat -o brainfuck.wasm</code>。输出文件名“brainfuck.wasm”很重要，因为这正是JavaScript要寻找的文件。现在，您应该在项目目录下启动一个web服务器。一个简单的方法是用Python: <code class="fe mn mo mp lz b">python -m http.server</code>。</p><p id="7a6b" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在假设一切顺利，你可以打开浏览器，进入<code class="fe mn mo mp lz b">localhost:8000</code>，查看Brainfuck程序的输出！所以，让我们用Go来写我们的编译器，这样我们就不用再手动翻译脑残程序了。提示:刷新网页时使用Ctrl + F5，因为这将强制刷新缓存的资源。</p><p id="3145" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">从标准设置开始:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="1694" class="md me ji lz b gy mf mg l mh mi">package main</span><span id="c494" class="md me ji lz b gy mj mg l mh mi">func main() {</span><span id="866a" class="md me ji lz b gy mj mg l mh mi">}</span></pre><p id="0df9" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们将从解析命令行参数开始，并通过将输入文件读入字符串来准备输入文件。我们的编译器将有一个单独的标志:<code class="fe mn mo mp lz b">-o </code>，它设置输出文件名。程序总是希望输入文件跟在参数后面。所以我们的用法是<code class="fe mn mo mp lz b">brainfuck2wasm [options] input_file</code>或者开发时:<code class="fe mn mo mp lz b">go run main.go [options] input_file</code>。</p><p id="07e2" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">下面是执行此操作的程序:</p><figure class="lu lv lw lx gt iv"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="dd6c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在我们需要将编译好的程序写入输出文件<code class="fe mn mo mp lz b">f</code>。首先，我们需要一个输出程序的模板。为此，我们将使用一个常数:</p><figure class="lu lv lw lx gt iv"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="6fce" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">以及生成指令的功能:</p><figure class="lu lv lw lx gt iv"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="03cb" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在可以将每个脑残角色映射到等价的WAT指令。正如我们已经讨论过如何为Brainfuck程序编写等价代码，我们可以填写简单的指令:</p><figure class="lu lv lw lx gt iv"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="6c76" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这是一个函数编译器，用于不包含循环的Brainfuck程序。循环有点棘手，因为我们为它们使用生成的标签，所以我们必须跟踪它们的标签名。对于循环，我们需要跟踪两件具体的事情:</p><ul class=""><li id="71c7" class="mq mr ji kz b la lb ld le lg ms lk mt lo mu ls mv mw mx my bi translated">下一个标签号，因为每个标签都是唯一的。$label$0，$label$1，等等。</li><li id="2611" class="mq mr ji kz b la mz ld na lg nb lk nc lo nd ls mv mw mx my bi translated">当前<em class="lt">循环深度</em>的标签号(一个索引)。因为顺序循环增加了这个索引，所以深度并不总是等于它。使用<code class="fe mn mo mp lz b">map[int]int</code>很容易解决这个问题，其中键是当前嵌套循环的循环深度，值是标签索引。</li></ul><p id="159b" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">以下代码使用上述要点实现循环:</p><figure class="lu lv lw lx gt iv"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="4939" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">当循环开始时，为块和循环创建不同的标签。我们给<code class="fe mn mo mp lz b">loopDepth</code>、<code class="fe mn mo mp lz b">labelIdx</code>(因为没有更好的名字)的<code class="fe mn mo mp lz b">loopDepthLabelIdxs</code>添加一个键、值对。对于我们正在生成的任何给定深度的循环，我们可以知道使用什么样的正确标签索引。然后，我们只是在结束之前增加标签索引和循环深度。</p><p id="0fa4" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">当一个循环被关闭时(或者确定是否再次循环)，我们递减循环深度，并生成“如果再次循环”指令。我们不需要从映射中删除键，因为在一个有效的程序中，如果一个循环已经被正确地打开，它们应该总是被覆盖。我将让读者挑战让编译器报告无效程序的错误。</p><p id="c431" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在我们有一个全功能的Brainfuck编译器，它可以生成WebAssembly文本程序。从现在开始，您基本上已经完成了这篇文章，所以我将提出一些挑战:</p><ul class=""><li id="f35c" class="mq mr ji kz b la lb ld le lg ms lk mt lo mu ls mv mw mx my bi translated">实现编译错误，让用户知道他们的程序是无效的，以及<em class="lt">为什么</em>它们是无效的。</li><li id="8748" class="mq mr ji kz b la mz ld na lg nb lk nc lo nd ls mv mw mx my bi translated">阅读一些WebAssembly规范，并使其在用户到达其内存末尾时扩展。Brainfuck只是在无限大小的内存上完成图灵，所以尽力而为很酷。</li><li id="f12b" class="mq mr ji kz b la mz ld na lg nb lk nc lo nd ls mv mw mx my bi translated">优化生成的程序。如果你不确定从哪里开始，考虑读写内存可能是最慢的。理想情况下，对内存中同一单元的多次写入应该组合成一次。当一个单元格被多次读取时，考虑保留一个变量。这里有无数的优化机会。</li></ul><p id="3f87" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">作为对你已经完成的编译器的奖励，我将加入缩进。本质上，您只需预先定义一行应该缩进多少，然后乘以嵌套深度:</p><figure class="lu lv lw lx gt iv"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="dfe7" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">谢谢你花时间了解我的最新项目。所有的代码都在GitHub上，如果你需要一些帮助或提醒，还有一个简短的自述如何使用这个项目。我鼓励你去尝试挑战！</p><p id="1af2" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">fivemoreminix/brainfuck2wasm:一个用Go编写的Brainfuck to WebAssembly编译器。(github.com)</p></div></div>    
</body>
</html>