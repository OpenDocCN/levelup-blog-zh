# 固体软件体系结构中的“我”——接口分离原则

> 原文：<https://levelup.gitconnected.com/the-i-in-solid-software-architecture-interface-segregation-principle-c1f68662f56f>

## “I”代表接口分离原则，只鼓励实施实际需要的行为。

在软件体系结构中，接口是契约，它本身没有定义行为，但是其他模块必须遵守。它们允许模块的消费者知道如何与模块对话，而不必知道它的细节。

![](img/798e552c7e269b6b86dd5704a06a1c0a.png)

使用许多小工具，而不是声称可以做任何事情的工具。(托德·夸肯布什拍摄的照片)

# 关于界面的隐喻

界面就像你脑海中电影院收银员的形象。你知道你可以告诉他们你想看什么电影，你想坐在哪里。你知道他们会问你要钱，你可以给他们钱。此外，你希望他们最终会把票给你。然而，你并不关心他们实际上是如何给你买票的(他们在电脑里输入了什么)，或者他们是否去不同的收银台取钱。现在，如果你真的去电影院，你可以期待你遇到的收银员满足你心中的所有期望，加上每个收银员提供的一些东西(例如一点点闲聊)。

收银员在你心目中的形象就是界面。实际的收银员是一个实现的类——很可能是“人”的子类。

“隔离”某物意味着将它分开、分开或隔离。与接口分离原则相关，目标是保持接口尽可能的具体和面向单一职责。如有必要，将它们分开。

或者，正如罗伯特·马丁所说:

> “客户不应被迫依赖他们不使用的界面。"

# 问题是

让我们看看下面的例子，看看不遵守这个原则会如何伤害我们。以下用于电子邮件和推送通知的事件广播器都实现了 CanBroadcast 接口，以便其他服务知道它们可以用它们发送通知:

如你所见，公共广播接口确保它们实现了 send 和 trackReads 方法。只有一个问题:PushBroadcaster 不支持这种方法，因为在我们的例子中，推送通知不支持 read 状态。

这导致了两个问题:

*   代码中存在开销。人们需要阅读实现的方法来理解它与类无关。
*   如果想改变通知跟踪的处理方式，就需要修改实际上不关心通知跟踪的代码。我在[的](https://blog.richartkeil.com/the-o-in-solid/)帖子中描述了这是一个问题的原因。

# 一个解决方案

我们可以改善以下两个棘手问题:

现在 email 和 push 通知类都实现了 CanBroadcast 接口，但是只有 email broadcaster 实现了 CanTrackReads 接口。

这样,**就不需要在运行时在不必要的方法中抛出异常**。这意味着类更容易阅读，因此更容易维护。

同样**变更可以以更高的可信度进行**，因为人们只需要接触那些实际上受到变更影响的类。

最后但同样重要的是，消费者可以使用新的结构来确保他们**只处理相关类型**——例如，允许跟踪阅读的广播公司。

# 如何发现违规行为

检测违反接口隔离原则的情况通常很容易。人们应该注意

*   类实现的单行方法只返回 null 或抛出异常
*   该架构利用了许多继承层——在这种情况下，违反原则往往是不可避免的，因为子类型化是基于[重用和修改行为，而不是仅仅扩展它](https://blog.richartkeil.com/the-l-in-solid/) (Barbara Liskov 正在观察你👀)

这个原则非常简单，在实现新特性的同时考虑这个原则肯定会增强代码的可维护性。这也很好地符合了[可靠责任原则](https://blog.richartkeil.com/the-s-in-solid/)的要求。

通过在我的博客上注册[来获得关于新帖子的电子邮件通知。](http://blog.richartkeil.com)