<html>
<head>
<title>Celery for Task Management with Flask and SQS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">芹菜与烧瓶和SQS的任务管理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/celery-for-task-management-with-flask-and-sqs-dbac64040549?source=collection_archive---------4-----------------------#2020-07-21">https://levelup.gitconnected.com/celery-for-task-management-with-flask-and-sqs-dbac64040549?source=collection_archive---------4-----------------------#2020-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/5247cbaaeace84242d9087ae98e01f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*2-9K6BsPdNTuWi8twpnU5A.jpeg"/></div></figure><h2 id="6e42" class="jx jy it bd jz ka kb dn kc kd ke dp kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">假定的背景知识</h2><p id="1fa3" class="pw-post-body-paragraph kt ku it kv b kw kx ky kz la lb lc ld kg le lf lg kk lh li lj ko lk ll lm ln im bi translated">本文假设读者熟悉Python、Flask、Celery和AWS SQS。</p><h1 id="f4e1" class="lo jy it bd jz lp lq lr kc ls lt lu kf lv lw lx kj ly lz ma kn mb mc md kr me bi translated">介绍</h1><p id="c7f2" class="pw-post-body-paragraph kt ku it kv b kw kx ky kz la lb lc ld kg le lf lg kk lh li lj ko lk ll lm ln im bi translated">在构建一个利用Celery进行异步任务管理的Flask应用程序时，需要掌握的基本知识是，除了队列和结果后端，实际上有三个部分需要考虑。它们是(Flask实例，它是您的web或微服务前端，(2)Celery实例，它向队列提供任务，以及(Celery worker，它从队列中取出任务并完成工作。Flask和Celery实例一起部署，在应用程序的界面上协同工作。Celery worker是单独部署的，独立于实例有效地工作。</p><p id="15d9" class="pw-post-body-paragraph kt ku it kv b kw mf ky kz la mg lc ld kg mh lf lg kk mi li lj ko mj ll lm ln im bi translated">乍一看，设置使用这三个组件的应用程序似乎非常简单。然而，当试图使用Flask应用程序工厂模式实现Flask实例和Celery实例时，情况变得复杂了，因为这种方法会导致循环导入问题。</p><p id="9f34" class="pw-post-body-paragraph kt ku it kv b kw mf ky kz la mg lc ld kg mh lf lg kk mi li lj ko mj ll lm ln im bi translated">本文的目的是:</p><ol class=""><li id="12eb" class="mk ml it kv b kw mf la mg kg mm kk mn ko mo ln mp mq mr ms bi translated">阐明如何初始化Flask+芹菜服务的这三个部分</li><li id="9d35" class="mk ml it kv b kw mt la mu kg mv kk mw ko mx ln mp mq mr ms bi translated">解释如何将这些服务打包以部署到生产环境中</li><li id="8062" class="mk ml it kv b kw mt la mu kg mv kk mw ko mx ln mp mq mr ms bi translated">指出最佳实践的一些注意事项</li></ol><h1 id="1fa8" class="lo jy it bd jz lp lq lr kc ls lt lu kf lv lw lx kj ly lz ma kn mb mc md kr me bi translated">设置烧瓶+芹菜服务的3个组成部分</h1><p id="ed6f" class="pw-post-body-paragraph kt ku it kv b kw kx ky kz la lb lc ld kg le lf lg kk lh li lj ko lk ll lm ln im bi translated">为了避免循环导入，我们指向“factories.celery_instance”和“tasks.data_tasks”来导入celery实例占位符。占位符将在运行时从实例工厂接收其配置。</p><p id="6c0a" class="pw-post-body-paragraph kt ku it kv b kw mf ky kz la mg lc ld kg mh lf lg kk mi li lj ko mj ll lm ln im bi translated">假设为了实现我们的解决方案，我们建立了一个结构类似于下面的项目:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="62e5" class="jx jy it nd b gy nh ni l nj nk">application.py<br/>worker.py<br/>celery_holder.py<br/>factories/<br/>   flask_instance.py<br/>   celery_instance.py<br/>blueprints/<br/>   controller.py<br/>tasks/<br/>   long_tasks.py</span></pre><p id="4c55" class="pw-post-body-paragraph kt ku it kv b kw mf ky kz la mg lc ld kg mh lf lg kk mi li lj ko mj ll lm ln im bi translated">这里的“application.py”是我们的应用程序，它初始化Flask实例和Celery实例，以提供我们与之交互的web/微服务的一部分。芹菜占位符在' celery_holder.py '中提供，芹菜工人通过' worker.py '初始化。应用程序工厂在' factories/'中提供，Flask蓝图在' blueprints/'中提供，芹菜任务在' tasks/'中提供。现在，导入模式将如下所示:</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/a88f0919c03b129bb00debedfa2ba73f.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*3l7OeHoI-mpXLMEpoHqCEA.png"/></div></figure><p id="39ac" class="pw-post-body-paragraph kt ku it kv b kw mf ky kz la mg lc ld kg mh lf lg kk mi li lj ko mj ll lm ln im bi translated">展示代码示例应该会使过程更加清晰。让我们从导入图的底部开始，展示芹菜占位符的代码。这个占位符为任务文件和芹菜工厂文件提供了芹菜实例，可以分别在decorators和芹菜类扩展中导入和引用。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="3156" class="jx jy it nd b gy nh ni l nj nk">from celery import Celery<br/><br/>celery = Celery(__name__, include=['tasks.long_tasks'])</span></pre><p id="5f69" class="pw-post-body-paragraph kt ku it kv b kw mf ky kz la mg lc ld kg mh lf lg kk mi li lj ko mj ll lm ln im bi translated">这里我们演示一个芹菜任务。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="1ae9" class="jx jy it nd b gy nh ni l nj nk">import time<br/>from celery_holder import celery<br/><br/><br/>@celery.task<br/>def celery_long_task(duration):<br/>    for i in range(duration):<br/>        print("Working... {}/{}".format(i + 1, duration))<br/>        time.sleep(2)<br/>        if i == duration - 1:<br/>            print('Completed work on {}'.format(duration))</span></pre><p id="d59d" class="pw-post-body-paragraph kt ku it kv b kw mf ky kz la mg lc ld kg mh lf lg kk mi li lj ko mj ll lm ln im bi translated">该任务在Flask蓝图中定义的端点内调用。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="ae9c" class="jx jy it nd b gy nh ni l nj nk">from flask import Blueprint<br/><br/>from tasks.long_tasks import celery_long_task<br/><br/><br/>sqs = Blueprint('sqs', __name__)<br/><br/><br/>@sqs.route('/celery/&lt;int:duration&gt;', methods=['GET'])<br/>def add_celery_task(duration):<br/>    celery_long_task.delay(duration)<br/>    return 'Task queued'</span></pre><p id="cb2f" class="pw-post-body-paragraph kt ku it kv b kw mf ky kz la mg lc ld kg mh lf lg kk mi li lj ko mj ll lm ln im bi translated">然后我们来到创建Flask实例的工厂，指定所有必要的配置。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="b123" class="jx jy it nd b gy nh ni l nj nk">from flask import Flask<br/>import os<br/>import logging<br/><br/>from blueprints.controller import sqs<br/><br/><br/>def create_app() -&gt; Flask:<br/>    app = Flask(__name__)<br/><br/>    # Always use dev config<br/>    app.config.from_object('config_dev')<br/><br/>    # Set logging<br/>    log_file = app.config['LOG_LOC'] + app.config['LOG_FILE']<br/>    logging.basicConfig(<br/>        level=app.config['LOG_LEVEL'],<br/>        format=('%(levelname)s %(asctime)s %(name)s '<br/>                'Lrn %(threadName)s: %(message)s'),<br/>        datefmt='%Y-%m-%d %H:%M:%S',<br/>        filename=log_file<br/>    )<br/><br/>    # Register blueprints<br/>    app.register_blueprint(sqs, url_prefix='/sqs')<br/><br/>    return app</span></pre><p id="ea88" class="pw-post-body-paragraph kt ku it kv b kw mf ky kz la mg lc ld kg mh lf lg kk mi li lj ko mj ll lm ln im bi translated">然后，扩展Celery类的工厂给它Flask应用程序上下文。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="06ff" class="jx jy it nd b gy nh ni l nj nk">import celery_holder</span><span id="0984" class="jx jy it nd b gy nm ni l nj nk"># Imported for type hinting<br/>from flask import Flask<br/>from celery import Celery</span><span id="b535" class="jx jy it nd b gy nm ni l nj nk">def configure_celery(app: Flask) -&gt; Celery:<br/>    """Configure celery instance using config from Flask app"""<br/>    TaskBase = celery_holder.celery.Task</span><span id="9c7c" class="jx jy it nd b gy nm ni l nj nk">    class ContextTask(TaskBase):<br/>        abstract = True<br/>        def __call__(self, *args, **kwargs):<br/>            with app.app_context():<br/>                return TaskBase.__call__(self, *args, **kwargs)</span><span id="1d7e" class="jx jy it nd b gy nm ni l nj nk">    celery_holder.celery.conf.update(app.config)<br/>    celery_holder.celery.Task = ContextTask<br/>    <br/>    return celery_holder.celery</span></pre><p id="4403" class="pw-post-body-paragraph kt ku it kv b kw mf ky kz la mg lc ld kg mh lf lg kk mi li lj ko mj ll lm ln im bi translated">最后，我们来看两个文件，它们被调用来实际运行我们的应用程序和我们的worker。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="37cb" class="jx jy it nd b gy nh ni l nj nk">from factories.flask_instance import create_app<br/>from factories.celery_instance import configure_celery<br/><br/># Imported for type hinting<br/>from flask import Flask<br/>from celery import Celery<br/><br/><br/>def create_full_app() -&gt; Flask:<br/>    app: Flask = create_app()<br/>    cel_app: Celery = configure_celery(app)<br/>    return app</span></pre><p id="eecf" class="pw-post-body-paragraph kt ku it kv b kw mf ky kz la mg lc ld kg mh lf lg kk mi li lj ko mj ll lm ln im bi translated">我们的工人。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="8e71" class="jx jy it nd b gy nh ni l nj nk">from factories.flask_instance import create_app<br/>from factories.celery_instance import configure_celery<br/><br/># Imported for type hinting<br/>from flask import Flask<br/>from celery import Celery<br/><br/>app: Flask = create_app()<br/>celery: Celery = configure_celery(app)</span></pre><p id="173c" class="pw-post-body-paragraph kt ku it kv b kw mf ky kz la mg lc ld kg mh lf lg kk mi li lj ko mj ll lm ln im bi translated">要运行Flask应用程序，请将FLASK_APP全局变量设置为application:create_full_app()。</p><p id="6c0b" class="pw-post-body-paragraph kt ku it kv b kw mf ky kz la mg lc ld kg mh lf lg kk mi li lj ko mj ll lm ln im bi translated">要运行celery worker，在“Celery worker”命令的- app=*参数中指向worker.celery。</p><h2 id="4c9b" class="jx jy it bd jz ka kb dn kc kd ke dp kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">配置</h2><p id="c70e" class="pw-post-body-paragraph kt ku it kv b kw kx ky kz la lb lc ld kg le lf lg kk lh li lj ko lk ll lm ln im bi translated">Celery实现SQS作为后台任务消息通信队列所需的最低配置。实际上，要让Celery将SQS识别为队列，您只需指定正确的BROKER_URL，并将队列的名称传递给CELERY_DEFAULT_QUEUE。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="0d6e" class="jx jy it nd b gy nh ni l nj nk">SQS_NAME = 'test'</span><span id="9b96" class="jx jy it nd b gy nm ni l nj nk"># Celery configuration<br/>BROKER_URL = 'sqs://'<em class="nn"><br/></em>BROKER_TRANSPORT_OPTIONS = <em class="nn">{<br/>     </em>'region': 'us-east-1',<br/>     'polling_interval': 5,  # number of sec to sleep between polls<br/>     'wait_time_seconds': 5<br/><em class="nn">}<br/></em>CELERY_DEFAULT_QUEUE = SQS_NAME<br/>CELERY_ENABLE_REMOTE_CONTROL = False<br/>CELERY_SEND_EVENTS = False</span></pre><h1 id="da69" class="lo jy it bd jz lp lq lr kc ls lt lu kf lv lw lx kj ly lz ma kn mb mc md kr me bi translated">容器化我们的应用程序和工作程序</h1><p id="af0c" class="pw-post-body-paragraph kt ku it kv b kw kx ky kz la lb lc ld kg le lf lg kk lh li lj ko lk ll lm ln im bi translated">利用Celery后台工作程序提供的独立可伸缩性意味着创建两个Docker映像——一个应用程序映像和一个工作程序映像。然后，每个映像都可以部署在自己的服务器上。这是通过创建“docker-compose”文件来实现的。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="e8d3" class="jx jy it nd b gy nh ni l nj nk">version: "3.3"<br/><br/>services:<br/>  web:<br/>    build:<br/>      context: .<br/>      args:<br/>        blduser: notused<br/>    image: application<br/>    # no user here because no need to run as something other than root user<br/>    command: [flask, run, --host=0.0.0.0]<br/>    ports:<br/>      - 8000:5000<br/>    # volumes below allows the developer to pass AWS credentials for local development<br/>    #  before container is moved to a server that sits behind IAM roles<br/>    volumes:<br/>      - ~/.aws/credentials:/home/celeryworker/.aws/credentials:ro<br/><br/>  worker:<br/>    build:<br/>      context: .<br/>      args:<br/>        blduser: celeryworker<br/>    image: worker<br/>    # user below sets the user of the container - removes RuntimeWarning for Celery<br/>    user: celeryworker <br/>    command: [celery, worker, --app=worker.celery, --concurrency=1, --loglevel=info]<br/>    # volumes below allows the developer to pass AWS credentials for local development<br/>    #  before container is moved to a server that sits behind IAM roles<br/>    volumes:<br/>      - ~/.aws/credentials:/home/celeryworker/.aws/credentials:ro</span></pre><p id="97a5" class="pw-post-body-paragraph kt ku it kv b kw mf ky kz la mg lc ld kg mh lf lg kk mi li lj ko mj ll lm ln im bi translated">除了使创建多个容器变得容易之外，docker-compose文件还提供了额外的优势。比如:</p><ul class=""><li id="8e79" class="mk ml it kv b kw mf la mg kg mm kk mn ko mo ln no mq mr ms bi translated">能够指定使用哪个Docker文件。甚至能够为每个服务创建单独的Docker文件。</li><li id="326b" class="mk ml it kv b kw mt la mu kg mv kk mw ko mx ln no mq mr ms bi translated">能够在`. env '文件中指定docker-compose文件自动选取的变量。</li><li id="386c" class="mk ml it kv b kw mt la mu kg mv kk mw ko mx ln no mq mr ms bi translated">很容易通过local ~/。AWS/服务凭证。有助于避免意外地将凭证签入存储库。</li></ul><p id="32e5" class="pw-post-body-paragraph kt ku it kv b kw mf ky kz la mg lc ld kg mh lf lg kk mi li lj ko mj ll lm ln im bi translated">请注意，在这个实例中，Docker文件用于指定运行Flask应用程序所需的Flask全局变量，即FLASK_APP &amp; FLASK_ENV。</p><h1 id="5ccc" class="lo jy it bd jz lp lq lr kc ls lt lu kf lv lw lx kj ly lz ma kn mb mc md kr me bi translated">一般注意事项</h1><p id="d5ee" class="pw-post-body-paragraph kt ku it kv b kw kx ky kz la lb lc ld kg le lf lg kk lh li lj ko lk ll lm ln im bi translated">默认情况下，一旦队列消息被工作人员获得，Celery就会从队列中删除一个任务。这被称为“提前承认”，通常不是我们想要的行为。假设，相反，我们希望Celery只在任务完成或出错时从队列中删除任务，我们必须通过将Celery参数‘task _ acts _ late’设置为true来更改worker以显示“延迟确认”。这需要仔细地将任务设计成幂等的，这样即使任务被多个工作者拾取，任务也只完成一次。</p><p id="c043" class="pw-post-body-paragraph kt ku it kv b kw mf ky kz la mg lc ld kg mh lf lg kk mi li lj ko mj ll lm ln im bi translated">详见<a class="ae np" href="https://blog.daftcode.pl/working-with-asynchronous-celery-tasks-lessons-learned-32bb7495586b" rel="noopener ugc nofollow" target="_blank">https://blog . daft code . pl/working-with-asynchronous-celery-tasks-learned-32bb 7495586 b</a>。</p><p id="5b62" class="pw-post-body-paragraph kt ku it kv b kw mf ky kz la mg lc ld kg mh lf lg kk mi li lj ko mj ll lm ln im bi translated">根据https://dzone.com/articles/using-sqs-with-celery<a class="ae np" href="https://dzone.com/articles/using-sqs-with-celery" rel="noopener ugc nofollow" target="_blank">的说法</a>当利用SQS作为队列后端时，有两个芹菜参数需要注意。它们是worker_send_task_events和worker_enable_remote_control。当保留默认值(true)时，Celery可能会为AWS中的每个节点创建一个新队列，这是不希望的行为。因此，这两个参数都应该设置为false。</p><h1 id="695f" class="lo jy it bd jz lp lq lr kc ls lt lu kf lv lw lx kj ly lz ma kn mb mc md kr me bi translated">代码回购</h1><p id="b406" class="pw-post-body-paragraph kt ku it kv b kw kx ky kz la lb lc ld kg le lf lg kk lh li lj ko lk ll lm ln im bi translated">本文中的代码可以在我的Github上找到，网址是<a class="ae np" href="https://github.com/clashofphish/learnFlask/tree/master/lrnflsk" rel="noopener ugc nofollow" target="_blank">https://Github . com/clashofphish/learn flash/tree/master/lrnflsk</a></p><h1 id="43e3" class="lo jy it bd jz lp lq lr kc ls lt lu kf lv lw lx kj ly lz ma kn mb mc md kr me bi translated"><strong class="ak">参考文献</strong></h1><ul class=""><li id="90ab" class="mk ml it kv b kw kx la lb kg nq kk nr ko ns ln no mq mr ms bi translated">带瓶芹菜概述:<a class="ae np" href="https://blog.miguelgrinberg.com/post/using-celery-with-flask" rel="noopener ugc nofollow" target="_blank">https://blog . miguelgrinberg . com/post/using-Celery-with-Flask</a></li><li id="1a99" class="mk ml it kv b kw mt la mu kg mv kk mw ko mx ln no mq mr ms bi translated">芹菜配SQS概述(用姜戈):<a class="ae np" href="https://dzone.com/articles/using-sqs-with-celery" rel="noopener ugc nofollow" target="_blank">https://dzone.com/articles/using-sqs-with-celery</a></li><li id="0886" class="mk ml it kv b kw mt la mu kg mv kk mw ko mx ln no mq mr ms bi translated">芹菜文档关于优化芹菜:<a class="ae np" href="https://docs.celeryproject.org/en/stable/userguide/optimizing.html" rel="noopener ugc nofollow" target="_blank">https://docs . Celery project . org/en/stable/user guide/optimizing . html</a></li><li id="8c90" class="mk ml it kv b kw mt la mu kg mv kk mw ko mx ln no mq mr ms bi translated">几个芹菜“gotchas”(芹菜参数名已经过时):<a class="ae np" href="https://wiredcraft.com/blog/3-gotchas-for-celery/" rel="noopener ugc nofollow" target="_blank">https://wiredcraft.com/blog/3-gotchas-for-celery/</a></li><li id="f3c3" class="mk ml it kv b kw mt la mu kg mv kk mw ko mx ln no mq mr ms bi translated">芹菜与烧瓶的应用工厂模式概述；</li><li id="50d3" class="mk ml it kv b kw mt la mu kg mv kk mw ko mx ln no mq mr ms bi translated">更完整描述:<a class="ae np" href="https://citizen-stig.github.io/2016/02/17/using-celery-with-flask-factories.html" rel="noopener ugc nofollow" target="_blank">https://citizen-Stig . github . io/2016/02/17/using-celery-with-flask-factories . html</a></li><li id="e7f4" class="mk ml it kv b kw mt la mu kg mv kk mw ko mx ln no mq mr ms bi translated">错过了上面描述的芹菜占位符:<a class="ae np" href="https://blog.miguelgrinberg.com/post/celery-and-the-flask-application-factory-pattern" rel="noopener ugc nofollow" target="_blank">https://blog . miguelgrinberg . com/post/Celery-and-the-flask-application-factory-pattern</a></li></ul></div></div>    
</body>
</html>