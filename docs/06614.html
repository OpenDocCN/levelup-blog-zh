<html>
<head>
<title>Timing Quicksort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计时快速排序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/timing-quicksort-c87f0c2983ce?source=collection_archive---------4-----------------------#2020-12-12">https://levelup.gitconnected.com/timing-quicksort-c87f0c2983ce?source=collection_archive---------4-----------------------#2020-12-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4ab477ab5062a81ad85b77d8c930d4e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DnEHG__OcOyhGHK334Y0Eg.png"/></div></div></figure><p id="becc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用MatPlotLib，我将教你如何制作一个图表，显示Python上不同长度的列表的快速排序的速度。</p><p id="d2b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想了解我的快速排序代码，我已经写了一篇单独的文章，但是我将解释如何把它放到一个图上，并把它与快速排序的O符号联系起来。正如您在图中看到的(这是我得到的输出图)，存在一些白噪声，特别是对于较大的数据集，这是因为排列特别好或特别差。当元素的数量变得非常小时，获得非常好的输入(因此大多数是立即排序)的机会变得非常小。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="7252" class="lf lg iq lb b gy lh li l lj lk">import random<br/>import time<br/>import matplotlib.pyplot as plt<br/><br/>Input= [i for i in range(1,100000,100)]<br/>endTimes = []<br/>def QuickSort( lists, OrderedLists,index):<br/>    if len(lists)==0:<br/>        return OrderedLists<br/>    UList = []; LList =[]<br/>    pivot = random.choice(lists)<br/>    lists.remove(pivot)<br/>    for i in lists:<br/>        if i&gt;pivot:<br/>            UList.append(i)<br/>        else:<br/>            LList.append(i)<br/>    OrderedLists[index+len(LList)]= pivot<br/>    QuickSort(UList, OrderedLists, index+len(LList)+1)<br/>    QuickSort(LList,OrderedLists,index)<br/>    return OrderedLists<br/><br/><br/>for i in Input:<br/>    Unordered = [random.randint(1,100000) for j in range(i)]<br/>    start=time.time()<br/>    QuickSort(Unordered, ['' for i in range(i)], 0)<br/>    end= time.time()<br/>    endTimes.append(end-start)<br/><br/>plt.plot(Input,endTimes)<br/>plt.show()</span></pre><h1 id="49ae" class="ll lg iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">设置</h1><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="c5fa" class="lf lg iq lb b gy lh li l lj lk">import matplotlib.pyplot as plt<br/><br/>Input= [i for i in range(1,100000,100)]<br/>endTimes = []</span></pre><p id="13c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码中只有两件主要的事情需要讨论，第一件是matoplotlib的新导入。这是我们用来绘制图形的库，plt是一个非常常见的别名。然后，我们创建一个名为input的列表，它将保存我们要在程序中尝试的所有元素编号。所以列表会是[1，101，201，301等等。]因此，我们将制作包含1个元素、101个元素、201个元素等的列表，并从中获取数据。然后，我们制作一个endTimes列表，它最初是空的，但是我们将在测试时用数据填充它。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="9233" class="lf lg iq lb b gy lh li l lj lk">for i in Input:<br/>    Unordered = [random.randint(1,100000) for j in range(i)]<br/>    start=time.time()<br/>    QuickSort(Unordered, ['' for i in range(i)], 0)<br/>    end= time.time()<br/>    endTimes.append(end-start)<br/><br/><br/>plt.plot(Input,endTimes)<br/>plt.show()</span></pre><p id="b48e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们遍历输入列表，使用每个值创建一个列表。这是在list comprehension中完成的，它生成一个长度为I(输入列表中的当前数字)的列表，值在1–100，000之间。然后，我们启动程序的计时器，该程序将为我们提供我们想要绘制的数据，time.time()方法将获取进程已经运行的总时间，我们稍后将再次使用它来获取时间差。</p><p id="7712" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注意:在我的快速排序算法中，我通过创建一个新的列表来进行排序，但是在我的快速排序算法文章中，我从一位教授计算机科学的教授那里得到了一个非常深入的评论，他说在真正的快速排序算法中，你会改变无序列表，而不是创建一个全新的有序列表。所以这意味着我的算法不会非常有效。</strong></p><p id="6260" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当列表排序后，程序将结束函数，然后我们将再次运行time.time()方法，这将给出一个新的时间，start和time之间的差值就是程序运行的时间。我将这个值添加到endTimes值中，这将自动排列这些值的索引。</p><p id="9631" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们绘制图表，我们通过运行matplotlib的绘图方法来完成，这将需要两个参数，即x坐标列表和相应的y坐标列表，您现在可以通过out Input和endTimes列表提供这些参数。这将创建一个图表，我们可以使用plt.show()显示这个图表</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2e2505ca37a123f71937f198c2918a14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxNoyEIYgcV6eO8rkN2WPQ.png"/></div></div></figure><p id="0b2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">快速排序的大O是n logn，这是我在上面画的Desmos的图。如你所见，图表趋势趋向于我们上面的线性形状。我们的图表有更多的噪声，因为大O是每个例子的最坏情况的度量，而我的测试数据不会每次都是最坏情况的例子。如果您想要一个与上面的n logn图相同的线性图，我怀疑您只需要在“for i in Input:”循环中更改列表理解，如下所示:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="b7f8" class="lf lg iq lb b gy lh li l lj lk">Unordered = [j for j in range(i)][::-1]</span></pre><p id="7310" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我没有测试过，但是这一行应该采用一个完全有序的列表，从1到列表中的元素数，然后完全反转这个有序列表，这应该是算法的最坏情况。</p><p id="8a21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是定时快速排序完成！</p></div></div>    
</body>
</html>