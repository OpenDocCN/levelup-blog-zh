<html>
<head>
<title>‘NaN’ You May Not Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你可能不知道</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/nan-you-may-not-know-199616e1a277?source=collection_archive---------17-----------------------#2022-03-28">https://levelup.gitconnected.com/nan-you-may-not-know-199616e1a277?source=collection_archive---------17-----------------------#2022-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="aca0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">JavaScript中‘南’的秘密。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6c664c17a33ff49eb4c40dd6361dc62e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qna5Kxlhmk40TFdREJpvnA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="8a15" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文将带你了解JavaScript中<code class="fe lu lv lw lx b">NaN</code>的秘密，让我们开始吧！</p><h1 id="bd3e" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">南是谁？</h1><p id="ef82" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated"><code class="fe lu lv lw lx b">NaN</code>是一个全局属性，表示<strong class="la iu">的值，而不是数字</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/6700421f249f938964bc42302a7cfaef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5bk71RIqfaKF0jumQdmeqw.png"/></div></div></figure><p id="7d4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们使用<code class="fe lu lv lw lx b">Reflect.getOwnPropertyDescriptor</code>获取<code class="fe lu lv lw lx b">NaN</code>的属性描述符时，它告诉我们<code class="fe lu lv lw lx b">NaN</code>是不可删除、不可改变、不可枚举的。所以当我们试图用<code class="fe lu lv lw lx b">Reflect.deleteProperty</code>删除它时，我们得到false。</p><h1 id="58b0" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">怎么得到南？</h1><p id="ae99" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">我们可以直接用字面<code class="fe lu lv lw lx b">NaN</code>或者<code class="fe lu lv lw lx b">Number.NaN</code>来得到<code class="fe lu lv lw lx b">NaN</code>。</p><p id="6a2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在以下情况下也可以得到<code class="fe lu lv lw lx b">NaN</code>:</p><ul class=""><li id="38de" class="mw mx it la b lb lc le lf lh my ll mz lp na lt nb nc nd ne bi translated">其中一个操作数是<code class="fe lu lv lw lx b">NaN</code>，比如<code class="fe lu lv lw lx b"><strong class="la iu">NaN + 1</strong></code></li><li id="b194" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">结果不是实数的数学运算，如<code class="fe lu lv lw lx b"><strong class="la iu">Math.sqrt(-2)</strong></code></li><li id="85a8" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">无法解析的数字，如<code class="fe lu lv lw lx b"><strong class="la iu">parseInt('str', 2)</strong></code>或<code class="fe lu lv lw lx b"><strong class="la iu">Number(undefined)</strong></code></li><li id="f4af" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">不定形式，如<code class="fe lu lv lw lx b"><strong class="la iu">undefined + 1</strong></code></li><li id="6b98" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">其中一个操作数属于字符串类型，并且不是加法运算，例如<code class="fe lu lv lw lx b"><strong class="la iu">'str' - 1</strong></code></li></ul><h1 id="dbcc" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">NaN类型</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/aa54ea15ec6cc12976a80702f2c0c5ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aUPY7PvlimUy7jOIXpQldA.png"/></div></div></figure><pre class="kj kk kl km gt nl lx nm nn aw no bi"><span id="4ef1" class="np lz it lx b gy nq nr l ns nt">console.log(typeof NaN); <strong class="lx iu">// number</strong><br/>console.log(typeof Number.NaN); <strong class="lx iu">// number</strong></span><span id="55ae" class="np lz it lx b gy nu nr l ns nt">console.log(Object.prototype.toString.call(NaN)); <strong class="lx iu">// [object Number]</strong><br/>console.log(Object.prototype.toString.call(Number.NaN)); <strong class="lx iu">// [object Number]</strong></span></pre><p id="aa6c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们用<code class="fe lu lv lw lx b">typeof</code>或<code class="fe lu lv lw lx b">Object.prototype.toString.call</code>确定<code class="fe lu lv lw lx b">NaN</code>的型号时，它会告诉我们<code class="fe lu lv lw lx b">NaN</code>是型号。</p><h1 id="a7e6" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak">楠===楠</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/0c47ef4df00b1ff9dcf83ae77da8cc1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*utiyLJHgPmsFBNhC5izbQQ.png"/></div></div></figure><pre class="kj kk kl km gt nl lx nm nn aw no bi"><span id="b485" class="np lz it lx b gy nq nr l ns nt">const test = Number(undefined); // NaN</span><span id="c5a3" class="np lz it lx b gy nu nr l ns nt">console.log(test == NaN); <strong class="lx iu">// false</strong><br/>console.log(test === NaN); <strong class="lx iu">// false</strong></span></pre><p id="0d8d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们使用<code class="fe lu lv lw lx b">==</code>、<code class="fe lu lv lw lx b">!=</code>、<code class="fe lu lv lw lx b">===</code>和<code class="fe lu lv lw lx b">!==</code>运算符检查<code class="fe lu lv lw lx b">NaN</code>是否等于<code class="fe lu lv lw lx b">NaN</code>时，我们得到false，因此这些运算符不能确定一个值是否为<code class="fe lu lv lw lx b">NaN</code>。</p><h1 id="b5e2" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak"> Object.is(NaN，NaN) </strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/7300a1f62a4add36e604c6338c27017d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TaS9GEwBC-wHckGMZvWk5A.png"/></div></div></figure><pre class="kj kk kl km gt nl lx nm nn aw no bi"><span id="b40d" class="np lz it lx b gy nq nr l ns nt">const test = Number(undefined); // NaN</span><span id="1257" class="np lz it lx b gy nu nr l ns nt">console.log(Object.is(test, NaN)); <strong class="lx iu">// true</strong></span></pre><p id="6aa7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是我们可以用<code class="fe lu lv lw lx b">Object.is</code>来确定一个值是不是<code class="fe lu lv lw lx b">NaN</code>。</p><h1 id="d763" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak">伊斯南(NaN) </strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/07813a67c2c754963b957c6faadd9733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-u6PM7K9bA7vQwzMrv0eeg.png"/></div></div></figure><pre class="kj kk kl km gt nl lx nm nn aw no bi"><span id="5ab6" class="np lz it lx b gy nq nr l ns nt">const test = Number(undefined); // NaN</span><span id="6239" class="np lz it lx b gy nu nr l ns nt">console.log(isNaN(test)); // true<br/>console.log(isNaN(123)); // false</span><span id="c8c3" class="np lz it lx b gy nu nr l ns nt">console.log(isNaN('str')); <strong class="lx iu">// true</strong></span><span id="6bd2" class="np lz it lx b gy nu nr l ns nt"><strong class="lx iu">// ❌ TypeError: Cannot convert a Symbol value to a number</strong><br/>console.log(isNaN(Symbol()));</span></pre><p id="68d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用全局提供的<code class="fe lu lv lw lx b">isNaN</code>函数，我们可以判断<code class="fe lu lv lw lx b">NaN</code>。当值为<code class="fe lu lv lw lx b">NaN</code>时，返回true。</p><blockquote class="nx"><p id="5c94" class="ny nz it bd oa ob oc od oe of og lt dk translated">当值不是<code class="fe lu lv lw lx b">NaN</code>，<strong class="ak">时，该值将被转换为数字类型，然后被判断为</strong>。</p></blockquote><p id="aedc" class="pw-post-body-paragraph ky kz it la b lb oh ju ld le oi jx lg lh oj lj lk ll ok ln lo lp ol lr ls lt im bi translated">所以你可以看到当我们调用<code class="fe lu lv lw lx b">isNaN('str')</code>时，它返回true。</p><h1 id="a49e" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak">号伊斯南(NaN) </strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/ea88ba07b4ffc81d775478113ebf5cd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0I2wgu0K_hPP7e0T7oN4YA.png"/></div></div></figure><pre class="kj kk kl km gt nl lx nm nn aw no bi"><span id="da36" class="np lz it lx b gy nq nr l ns nt">const test = Number(undefined); // NaN</span><span id="6e1b" class="np lz it lx b gy nu nr l ns nt">console.log(Number.isNaN(test)); // true<br/>console.log(Number.isNaN(123)); // false<br/>console.log(Number.isNaN('str')); // false<br/>console.log(Number.isNaN(Symbol())); // false</span></pre><p id="9797" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">Number.isNaN</code>是全球<code class="fe lu lv lw lx b">isNaN</code>的健壮版本。它是由Number的原始包装对象提供的方法。你可以看到，使用它，我们可以准确地确定一个值是否是<code class="fe lu lv lw lx b">NaN</code>。</p><h1 id="a15a" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak">array . prototype . index of vs array . prototype . includes</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/b749186b7f37ce70ea096dc5314c6106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LOg81wM0RKVSeTbZV02yZw.png"/></div></div></figure><pre class="kj kk kl km gt nl lx nm nn aw no bi"><span id="fb07" class="np lz it lx b gy nq nr l ns nt">const arr = [1, NaN, 3];</span><span id="3b27" class="np lz it lx b gy nu nr l ns nt">console.log(arr.indexOf(NaN)); <strong class="lx iu">// -1</strong><br/>console.log(arr.includes(NaN)); <strong class="lx iu">// true</strong></span></pre><p id="6d3b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们用<code class="fe lu lv lw lx b">Array.prototype.indexOf</code>或者<code class="fe lu lv lw lx b">Array.prototype.includes</code>来判断数组中是否包含<code class="fe lu lv lw lx b">NaN</code>时，那么就会有区别，<code class="fe lu lv lw lx b"><strong class="la iu">Array.prototype.indexOf</strong></code> <strong class="la iu">不识别</strong> <code class="fe lu lv lw lx b"><strong class="la iu">NaN</strong></code> <strong class="la iu">，但是</strong> <code class="fe lu lv lw lx b"><strong class="la iu">Array.prototype.includes</strong></code> <strong class="la iu">可以。</strong></p><h1 id="9b1c" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak">布尔(南)</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/d551e4ee51a13404fd2ff2163122f7e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rWWlsmlf48MMA5swEbYcHA.png"/></div></div></figure><pre class="kj kk kl km gt nl lx nm nn aw no bi"><span id="b6be" class="np lz it lx b gy nq nr l ns nt">const test = Number(undefined); // NaN</span><span id="dbbc" class="np lz it lx b gy nu nr l ns nt">console.log(Boolean(test)); <strong class="lx iu">// false</strong></span></pre><p id="f4a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们将<code class="fe lu lv lw lx b">NaN</code>转换为布尔类型时，我们将得到false。</p></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><p id="ded9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天就到这里。我是Zachary，我会继续输出与web开发相关的故事，如果你喜欢这样的故事并想支持我，请考虑成为 <a class="ae ow" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="ov">媒介成员</em> </a> <em class="ov">。每月5美元，你可以无限制地访问媒体内容。如果你通过</em> <a class="ae ow" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="ov">我的链接</em> </a> <em class="ov">报名，我会得到一点佣金。</em></p><p id="6b82" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你的支持对我来说很重要——谢谢。</p></div></div>    
</body>
</html>