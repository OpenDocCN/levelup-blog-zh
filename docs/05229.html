<html>
<head>
<title>Get Started with Stacks and Queues in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的堆栈和队列入门</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/get-started-with-stacks-and-queues-in-python-57a7ea273629?source=collection_archive---------9-----------------------#2020-08-13">https://levelup.gitconnected.com/get-started-with-stacks-and-queues-in-python-57a7ea273629?source=collection_archive---------9-----------------------#2020-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="80de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">超越Python中的lists与Stack，如LifoQueue()、Queue()和Deque()，高效地处理任务——内有工作代码示例和插图。不包括煎饼。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/23c586d1abe6b7623f999f013afc82f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oCqP382vD5x9gCyw"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@nikldn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> nikldn </a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="39bd" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">关于这个故事</h1><p id="a455" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我最近了解到一些很酷的工具，可以处理标准Python列表之外的数据，我认为它们棒极了！当然，这些主题都是老生常谈了，但我还是想分享一些例子，帮助我理解Python中的Stack()、Queue()和Deque()。</p><h1 id="1373" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">在这个故事中</h1><ol class=""><li id="9d66" class="mi mj it js b jt md jx me kb mk kf ml kj mm kn mn mo mp mq bi translated"><a class="ae le" href="https://docs.python.org/3/tutorial/introduction.html#lists" rel="noopener ugc nofollow" target="_blank">列表</a>:回顾一种在一个地方收集物品的熟悉方式</li><li id="43b0" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><a class="ae le" href="https://docs.python.org/3/library/queue.html#queue.LifoQueue" rel="noopener ugc nofollow" target="_blank">栈</a>:看起来像一个列表，但是有一个<em class="mw">后进先出</em>实现</li><li id="c188" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><a class="ae le" href="https://docs.python.org/3/library/queue.html" rel="noopener ugc nofollow" target="_blank">队列</a>:看起来像一个堆栈，但是有一个<em class="mw">先进先出</em>实现</li><li id="e90e" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><a class="ae le" href="https://docs.python.org/3/library/collections.html#collections.deque" rel="noopener ugc nofollow" target="_blank"> Deques </a>:解决列表大问题的双端队列</li></ol></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="c519" class="lf lg it bd lh li ne lk ll lm nf lo lp lq ng ls lt lu nh lw lx ly ni ma mb mc bi translated">名单</h1><p id="d43f" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在Python中，list是最通用的复合数据类型。例如，在搞清楚“你好，世界”这一点后，管理列表是我们将学习的第一件事。此外，列表是如此有用，以至于我们最终会尝试将它们用于所有事情。然而，尽管我们可以用列表做令人惊奇的事情，最终，我们需要一些其他的朋友，比如元组和集合。但是仍然有一些非常特殊的工作需要特殊的工具，这就是我们的伙伴Stack()、Queue()和Deck()发挥作用的地方。</p><h2 id="aa25" class="nj lg it bd lh nk nl dn ll nm nn dp lp kb no np lt kf nq nr lx kj ns nt mb nu bi translated">遍历一个列表</h2><p id="1659" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">有了这个列表，我们就有了一个非常容易管理的方法来组织数据。在我们能做的许多事情中，如果我们有一个盒子列表，我们可以用迭代打印一个列表。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nv"><img src="../Images/e4cf7c6e5174822c9c30a8c04d874a5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pcx1mBCSGkzi_R02Sd-fSQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">通过迭代，我们可以打印对象列表。作者的插图。</figcaption></figure><p id="f6cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如上所示，我们可以在下面的代码中使用一个简单的循环来打印带有迭代的盒子列表。重要的是要注意，对于迭代，我们从列表中的第一件事情开始，然后移动到下一件事情，直到我们到达末尾。</p><pre class="kp kq kr ks gt nw nx ny nz aw oa bi"><span id="276e" class="nj lg it nx b gy ob oc l od oe"><strong class="nx iu"># Example 1: Print a list with Iteration</strong></span><span id="6391" class="nj lg it nx b gy of oc l od oe">lst_of_stuff = ['Box A', 'Box B', 'Box C', 'Box D', 'Box E']</span><span id="fdd1" class="nj lg it nx b gy of oc l od oe">for i in lst_of_stuff:<br/>  print(i)</span><span id="20ce" class="nj lg it nx b gy of oc l od oe">'''<br/>Output:</span><span id="a5c7" class="nj lg it nx b gy of oc l od oe">Box A<br/>Box B<br/>Box C<br/>Box D<br/>Box E<br/>'''</span></pre><h2 id="4644" class="nj lg it bd lh nk nl dn ll nm nn dp lp kb no np lt kf nq nr lx kj ns nt mb nu bi translated">用Append()和Pop()操作列表</h2><p id="d442" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">除了简单的打印工作，当我们想到用<strong class="js iu"> append() </strong>和<strong class="js iu"> pop() </strong>编辑列表时，事情开始变得有趣起来。在上面的示例#1中，我们只打印了框列表中的数据，但没有编辑列表。但是，使用append()和pop()，我们可以在列表的右侧添加和移除框。</p><p id="944b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我从一些地方读到的，他们说一个<em class="mw">列表向右增长，向左收缩</em>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/7eb16f92b24b6486a52225883a9733d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cGaRAaeF8uRM-Q0GBLa4PA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">使用append()和pop()在列表右侧添加或删除数据。作者的插图。</figcaption></figure><p id="6c73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第二个例子中，就好像我们简陋的一排箱子在一个狭窄的车库里——移动东西的唯一方法是拿起排在最后的箱子。在下面的代码示例中，我们可以通过弹出框E并追加一个新的框f来看到这种类比。</p><pre class="kp kq kr ks gt nw nx ny nz aw oa bi"><span id="ab0f" class="nj lg it nx b gy ob oc l od oe"><strong class="nx iu"># Example 2: Edit a list with pop and append</strong></span><span id="107f" class="nj lg it nx b gy of oc l od oe">lst_of_stuff = ['Box A', 'Box B', 'Box C', 'Box D', 'Box E']</span><span id="9d0d" class="nj lg it nx b gy of oc l od oe"><strong class="nx iu"># pop off the last thing in the list</strong></span><span id="d28c" class="nj lg it nx b gy of oc l od oe">print(lst_of_stuff.pop())</span><span id="ac71" class="nj lg it nx b gy of oc l od oe"># &gt;&gt;&gt; Box E</span><span id="e433" class="nj lg it nx b gy of oc l od oe"><strong class="nx iu"># append something new to the end of the list</strong></span><span id="041b" class="nj lg it nx b gy of oc l od oe">lst_of_stuff.append('Box F')<br/>print(lst_of_stuff)</span><span id="083e" class="nj lg it nx b gy of oc l od oe"># &gt;&gt;&gt; ['Box A', 'Box B', 'Box C', 'Box D', 'Box F']</span></pre></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="59de" class="lf lg it bd lh li ne lk ll lm nf lo lp lq ng ls lt lu nh lw lx ly ni ma mb mc bi translated">堆栈</h1><p id="bbb3" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在了解了append()和pop()如何让列表变得简洁之后，我们感觉到列表的工作方式有一些特殊的规则。例如，当append()和pop()从列表的右侧或末端开始工作时，我们实际上是在观察堆栈的行为。换句话说，最后一个进来的盒子是第一个出去的盒子。</p><p id="5afd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在箱子类比中，考虑用起重机实际堆叠和卸载箱子是有帮助的——在任何给定的时间，只有顶部的箱子是可接近的。因此，我们有一个<strong class="js iu">后进先出实现，称为<em class="mw"> LIFO </em>。</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/bc8018dba06d388e1671a2a5321c1626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*Rst0Htf7TcRKF0jhbIU3Iw.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">使用队列类中的LifoQueue()堆栈—总是从顶部或“后进先出”作者的插图。</figcaption></figure><p id="1a9a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">这里需要注意一件重要的事情，因为它可能会引起混淆</strong>——在Python中，<strong class="js iu">堆栈是用队列类LifoQueue() </strong>实现的。对我来说，这个术语可能会引起误解，因为队列不同于堆栈，也没有称为“堆栈”的类或方法抛开困惑不谈，对<strong class="js iu">有帮助的是记住:</strong> <strong class="js iu">栈是关于LIFO生命的，所以当你看到LifoQueue()时，你真的有一个栈</strong>。</p><pre class="kp kq kr ks gt nw nx ny nz aw oa bi"><span id="3c93" class="nj lg it nx b gy ob oc l od oe"># Example 3: Stack with LifoQueue</span><span id="e72b" class="nj lg it nx b gy of oc l od oe"><strong class="nx iu"># import from queue class</strong><br/>from queue import LifoQueue </span><span id="05f9" class="nj lg it nx b gy of oc l od oe">lst_of_stuff = ['Box A', 'Box B', 'Box C', 'Box D', 'Box E']</span><span id="7c11" class="nj lg it nx b gy of oc l od oe"><strong class="nx iu"># create two empty stacks as LifoQueue objects</strong><br/>stack1 = LifoQueue()<br/>stack2 = LifoQueue()</span><span id="dd48" class="nj lg it nx b gy of oc l od oe"><strong class="nx iu"># iterate to stack a list of boxes with put()<br/># use reverse() on the list to start stacking <br/># with 'Box E' and end with 'Box A'</strong></span><span id="cc9c" class="nj lg it nx b gy of oc l od oe">for i in reversed(lst_of_stuff):<br/>  stack1.put(i)</span><span id="1ec0" class="nj lg it nx b gy of oc l od oe"><strong class="nx iu"># while the stack has boxes<br/># get the top of stack1 with .get() as 'box'<br/># build stack2 with one box at a time</strong></span><span id="667a" class="nj lg it nx b gy of oc l od oe">while not stack1.empty():<br/>  box = stack1.get()<br/>  stack2.put(box)</span></pre><p id="efcc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面和下面的示例#3代码中，我们创建了两个堆栈，并使用我们想象的起重机来移动东西。首先，颠倒盒子列表，我们从盒子E开始堆栈，并创建一个盒子A位于顶部的堆栈。当我们拆分和重新堆叠盒子时，stack2最终再次颠倒了顺序，从上到下。为了演示，我们可以用下面的while循环打印stack2。</p><pre class="kp kq kr ks gt nw nx ny nz aw oa bi"><span id="ae21" class="nj lg it nx b gy ob oc l od oe"><strong class="nx iu"># Until the stack is empty, get and print each box</strong></span><span id="2b9d" class="nj lg it nx b gy of oc l od oe">while not stack2.empty():<br/>  print(stack2.get())</span><span id="d41b" class="nj lg it nx b gy of oc l od oe">'''<br/>Output:</span><span id="2dd4" class="nj lg it nx b gy of oc l od oe">Box E<br/>Box D<br/>Box C<br/>Box B<br/>Box A<br/>'''</span></pre></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="15ae" class="lf lg it bd lh li ne lk ll lm nf lo lp lq ng ls lt lu nh lw lx ly ni ma mb mc bi translated">队列</h1><p id="bc9e" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">如果列表有点像Stack()，而Stack()实际上是LIFO queue()——什么是实际的队列？谢天谢地，事情开始有意义了。从表面上看，有了队列，我们就有了真正的队列！比如，想象一下我们的小盒子已经出厂，现在正在排队等着吃冰淇淋，可爱吧？在这种情况下，<strong class="js iu">队列中的第一个盒子先得到冰淇淋——这就是先进先出或先进先出。</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oi"><img src="../Images/537a5f8bf0192858a9e5d84f4f7f364b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RzBg1CZUvG1J9fCEnwchkw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">从堆栈到队列:后进先出(LIFO)和先进先出(FIFO)的区别。作者的插图。</figcaption></figure><p id="6f05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们继续上面例子3中的代码，将盒子从堆栈2移动到一个队列中，那么注意在每次迭代中发生了什么。我们从栈顶拿到一个盒子，然后把盒子放在排队买冰淇淋。每次我们拿到下一个盒子，它就会进入下一个位置。</p><pre class="kp kq kr ks gt nw nx ny nz aw oa bi"><span id="9b75" class="nj lg it nx b gy ob oc l od oe"><strong class="nx iu"># Example 4: From Stack to Queue </strong></span><span id="fe55" class="nj lg it nx b gy of oc l od oe"><strong class="nx iu"># import the Queue</strong><br/>from queue import Queue</span><span id="9a7b" class="nj lg it nx b gy of oc l od oe"><strong class="nx iu"># create a new empty Queue()<br/></strong>q = Queue()</span><span id="2c70" class="nj lg it nx b gy of oc l od oe"># while there are boxes in the stack<br/># get a box and place it in queue</span><span id="2684" class="nj lg it nx b gy of oc l od oe">while not stack2.empty():<br/>  box = stack2.get()<br/>  q.put(box)</span></pre><p id="4e64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了证明Box E在队列的前面，我们可以再次使用get()方法返回Box E。结果，我们看到队列中的第一个对象是第一个出来的对象。相比之下，如果队列是一个堆栈，我们将得到盒子A而不是盒子e。</p><pre class="kp kq kr ks gt nw nx ny nz aw oa bi"><span id="d33a" class="nj lg it nx b gy ob oc l od oe">print(q.get())</span><span id="bb5d" class="nj lg it nx b gy of oc l od oe"># &gt;&gt;&gt; Box E</span></pre></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="fffb" class="lf lg it bd lh li ne lk ll lm nf lo lp lq ng ls lt lu nh lw lx ly ni ma mb mc bi translated">德克(“甲板”)</h1><p id="c354" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">当学习一个编程概念的时候，那些杜撰出来的词总是让我感到害怕。问题是，一个如此抽象的概念令人担忧，以至于他们<em class="mw">不得不</em>为它造了一个词。然而，在这种情况下，我向你保证，没有理由逃跑。Deque()或者我头脑中的“deck”只是一个双面队列。</p><p id="547c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们为什么关心？</p><p id="b2d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像堆栈和队列一样，在某些特定情况下，您可能希望使用Deque()而不是list。虽然有很多方法，但是我将只提供一个技术示例来说明为什么以及什么时候deque是首选的。在这个过程中，我将向您展示一个deque是如何工作的。</p><h2 id="0ee4" class="nj lg it bd lh nk nl dn ll nm nn dp lp kb no np lt kf nq nr lx kj ns nt mb nu bi translated">回到列表</h2><p id="1c3f" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">回想一下例子#1，从列表中添加和弹出数据有一个限制——似乎我们只能从列表的右边添加或减去数据。为什么会这样呢？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/7eb16f92b24b6486a52225883a9733d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cGaRAaeF8uRM-Q0GBLa4PA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">与编辑例1中的列表作为摘要的图示相同。作者的插图。</figcaption></figure><p id="b65d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">需要说明的是，我们并不局限于只从右侧编辑列表。实际上，我们<em class="mw">希望</em>从列表的末尾添加和弹出数据，因为<strong class="js iu">在前面插入数据可能效率很低。</strong>例如，我们知道列表中的每个对象都有一个索引。在Python中，我们从第一个元素的[0]开始，并从那里递增。<strong class="js iu">如果我们在列表前面的索引0处插入()框E会发生什么？</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oj"><img src="../Images/96548c5704c2a0a8a8f2ecf34cf1a6b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bRoeakrkzrb0PEh2n-8TKw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">在索引0处将数据插入到列表的前面时出现的问题——插入后的每个对象都必须移动到索引中的一个点上。作者的插图。</figcaption></figure><p id="b071" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上图中，如果我们使用insert()为框A腾出空间，那么<strong class="js iu">我们必须将列表中的每个框移动一个索引位置</strong>。在一个非常简单的例子中，移动四个盒子来为一个盒子腾出空间很容易，而且有点烦人。但是如果有一百盒或者一万盒呢？单个插入任务不仅变得非常烦人，而且在效率方面也变得非常昂贵。</p><h2 id="065e" class="nj lg it bd lh nk nl dn ll nm nn dp lp kb no np lt kf nq nr lx kj ns nt mb nu bi translated">回到德克</h2><p id="59c0" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">有了deque，我们就不会有insert()出现的索引问题。例如，为了添加或删除数据，deque不仅提供append()和pop()，还提供了它们各自的左版本！</p><ul class=""><li id="7bab" class="mi mj it js b jt ju jx jy kb ok kf ol kj om kn on mo mp mq bi translated"><a class="ae le" href="https://docs.python.org/3/library/collections.html#collections.deque" rel="noopener ugc nofollow" target="_blank"> appendleft() </a></li><li id="062f" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn on mo mp mq bi translated"><a class="ae le" href="https://docs.python.org/3/library/collections.html#collections.deque" rel="noopener ugc nofollow" target="_blank"> popleft() </a></li><li id="4222" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn on mo mp mq bi translated"><a class="ae le" href="https://docs.python.org/3/library/collections.html#collections.deque" rel="noopener ugc nofollow" target="_blank">追加()</a></li><li id="38b6" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn on mo mp mq bi translated"><a class="ae le" href="https://docs.python.org/3/library/collections.html#collections.deque" rel="noopener ugc nofollow" target="_blank"> pop() </a></li></ul><p id="5bde" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">啊，但是等等——我们不是对列表使用append()和pop()吗？是的，我们有，这就是为什么一个<strong class="js iu">队列同时像一个双端队列和一个列表。</strong>因此，我下面的盒子和起重机插图看起来有点像队列和列表，但有一点扭曲，这并不奇怪——这是一个队列。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oo"><img src="../Images/0ed09c0f6ffafbbaa2294dbdca5c9b5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O5E7a4q2l14O775TY6tLXQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">部分列表、部分队列deque为我们提供了从集合的任意一端追加和弹出数据的有效方法。作者的插图。</figcaption></figure><h2 id="d2fe" class="nj lg it bd lh nk nl dn ll nm nn dp lp kb no np lt kf nq nr lx kj ns nt mb nu bi translated">清单五</h2><p id="3be0" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">让我们看看deque在代码中是如何工作的，同时将性能与列表进行比较。在下面的例子中，我们可以使用<strong class="js iu"> timeit </strong>来设置各种测试。</p><pre class="kp kq kr ks gt nw nx ny nz aw oa bi"><span id="438e" class="nj lg it nx b gy ob oc l od oe">import timeit</span></pre><p id="a3b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，对于insert():将10，000个数字插入到索引为0的列表中。如下所示，在运行测试5次后，该语句的计时大约为0.581秒。</p><pre class="kp kq kr ks gt nw nx ny nz aw oa bi"><span id="6043" class="nj lg it nx b gy ob oc l od oe"><strong class="nx iu"># Example 5: Insert() Test<br/># insert() at index 0<br/># statements as strings for timeit</strong></span><span id="ae12" class="nj lg it nx b gy of oc l od oe">my_setup = '''<br/>alst = []'''</span><span id="6e9d" class="nj lg it nx b gy of oc l od oe">statement = '''<br/>for i in range(10000):<br/>  alst.insert(0,i)'''</span><span id="c35f" class="nj lg it nx b gy of oc l od oe"><strong class="nx iu"># evaluate the statement with timeit</strong></span><span id="56fb" class="nj lg it nx b gy of oc l od oe">timeit.timeit(stmt=statement, setup = my_setup, number=5)</span><span id="30df" class="nj lg it nx b gy of oc l od oe"># &gt;&gt;&gt; 0.5816648300024099</span></pre><p id="f76d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相比之下，在下面的示例6中，deque的执行速度比insert()快几个数量级。使用<strong class="js iu"> timeit </strong>时，使用deque进行相同的操作只需0.0056秒。虽然测试越多，结果可能会有所不同，但我们的差距大约是100倍——这是很大的差距！</p><pre class="kp kq kr ks gt nw nx ny nz aw oa bi"><span id="2960" class="nj lg it nx b gy ob oc l od oe"><strong class="nx iu"># Example 6: Deque() Test<br/># appendleft with deque<br/># statements as strings for timeit</strong></span><span id="8d1e" class="nj lg it nx b gy of oc l od oe">my_setup = '''<br/>from collections import deque<br/>deck = deque()'''</span><span id="af02" class="nj lg it nx b gy of oc l od oe">statement = '''<br/>for i in range(10000):<br/>  deck.appendleft(i)'''</span><span id="f05d" class="nj lg it nx b gy of oc l od oe"><strong class="nx iu"># evaluate the statement with timeit</strong></span><span id="9487" class="nj lg it nx b gy of oc l od oe">timeit.timeit(stmt=statement, setup = my_setup, number=5)</span><span id="3b13" class="nj lg it nx b gy of oc l od oe"># &gt;&gt;&gt; 0.00567837600101484</span></pre></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi op"><img src="../Images/12d91bdbe5290aaf3a746bf10219a3dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8L8l3zW_nzRM3BRk"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://unsplash.com/@lamaroscu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">喇嘛罗斯库</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="5a8d" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="9ce6" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在编程中，列表是最基本的。列表帮助我们组织和管理数据。尽管有时会被过度使用和误用，但是学习和掌握列表仍然非常重要。然而，尽管列表功能多样，有时我们需要更好的工具来完成特定的工作。在这些情况下，我们需要使用堆栈、队列和队列。</p><p id="3d28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Python中，栈是用队列类中的LifoQueue实现的，队列是用队列类中的Queue实现的，队列是用集合类中的dequee实现的。</p><p id="2f24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">列表、堆栈、队列和卡片组之间的差别很小，但是它们的实现差别很大。</p><ul class=""><li id="3b67" class="mi mj it js b jt ju jx jy kb ok kf ol kj om kn on mo mp mq bi translated">对于列表，我们通常从左到右操作。我们可以用insert来打破常规；然而，这可能是昂贵的。</li><li id="5c89" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn on mo mp mq bi translated">对于堆栈，我们意识到列表实际上表现为堆栈，但令人困惑的是，堆栈是用LifoQueue而不是stack()方法实现的——堆栈是LIFO实现。</li><li id="fbcc" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn on mo mp mq bi translated">对于队列，我们发现真正的队列表现为逻辑上来自queue类的队列——队列是FIFO实现。</li><li id="afc3" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn on mo mp mq bi translated">最后，有了deques，我们可以在集合的两端高效地操作——它看起来同时像一个列表和一个队列——dequee可以有效地追加或弹出集合的任何一端。</li></ul><p id="2f64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，和往常一样，阅读官方文件以获得最准确的信息——全文提供的链接和下面的参考链接。我希望这些例子是有帮助的，我真的很感谢你的任何意见或问题！</p><div class="oq or gp gr os ot"><a href="https://www.python.org/" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">欢迎来到Python.org</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">Python编程语言的官方主页</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">www.python.org</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ky ot"/></div></div></a></div></div></div>    
</body>
</html>