<html>
<head>
<title>React 💘 localStorage: persisting state with a custom hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应💘localStorage:用自定义挂钩保持状态</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-localstorage-persisting-state-with-a-custom-hook-98f9a88ae7a9?source=collection_archive---------7-----------------------#2021-11-02">https://levelup.gitconnected.com/react-localstorage-persisting-state-with-a-custom-hook-98f9a88ae7a9?source=collection_archive---------7-----------------------#2021-11-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1d5b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这不一定很难</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d910d1536a0dc536fba4946280952004.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aUnm6qBp4jkz9EvY"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@simonmigaj?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> S Migaj </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="32d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在构建React应用程序时，您可能会遇到一些情况(比如说，黑暗模式切换),此时跨页面重新加载自动保持组件的状态会很方便——在可以采用的许多解决方案中，最容易也最实用的无疑是本地存储API。</p><h1 id="42ed" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">本地存储概述</h1><p id="08ed" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">localStorage</code>对象提供了对简单的同步键值存储的访问，其中键和值都是字符串。我们需要记住两种主要方法:</p><ul class=""><li id="45dc" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated"><code class="fe mp mq mr ms b"><strong class="ky ir">getItem</strong></code>，它接受一个<code class="fe mp mq mr ms b">keyName</code>作为其唯一的参数，并返回与该键相关联的值(如果该键不存在值，则返回<code class="fe mp mq mr ms b">null</code>)，以及</li><li id="5780" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><code class="fe mp mq mr ms b"><strong class="ky ir">setItem</strong></code>，它接受一个<code class="fe mp mq mr ms b">keyName</code>和<code class="fe mp mq mr ms b">value</code>作为它的两个参数，并且不出所料，在给定的键上存储指定的值。</li></ul><p id="63cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其他值得一提但与本文的目的无关的方法包括<code class="fe mp mq mr ms b">removeItem</code>(在给定的<code class="fe mp mq mr ms b">keyName</code>处删除一个值)和<code class="fe mp mq mr ms b">clear</code>(不接受参数并删除所有存储的值)。</p><p id="88e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果我们想存储一个不是字符串的值呢？为此，我们必须使用<code class="fe mp mq mr ms b"><strong class="ky ir">JSON.stringify</strong></code>方法将它转换成一个字符串——然后，当我们想要检索数据时，我们必须<code class="fe mp mq mr ms b"><strong class="ky ir">JSON.parse</strong></code>它来获得原始值。注意，这允许存储字符串、数字、对象、数组、布尔值和<code class="fe mp mq mr ms b">null</code>值:<code class="fe mp mq mr ms b">undefined</code>值和函数将被<code class="fe mp mq mr ms b">JSON.stringify</code>忽略，因此它们不能存储在本地存储中。</p><h1 id="c952" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">构建自定义挂钩</h1><p id="afe0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在让我们回顾一下创建自定义React挂钩的过程，以便自动将组件的状态保存到本地存储中。</p><p id="9df8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将首先创建一个<code class="fe mp mq mr ms b">usePersistedState</code>函数，它接受两个参数:</p><ul class=""><li id="a0f7" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated"><code class="fe mp mq mr ms b">defaultValue</code>，如果无法从本地存储中检索，则为初始状态，以及</li><li id="d200" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><code class="fe mp mq mr ms b">localStorageKey</code>，用于在本地存储中存储和检索状态的唯一键。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="159f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">从本地存储中检索状态</h1><p id="5f47" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在让我们编写处理基本状态检索的逻辑:正如我们提到的，我们将从本地存储中获取值，并使用<code class="fe mp mq mr ms b">JSON.parse</code>来获取原始值。我们将使用<code class="fe mp mq mr ms b">useState</code>钩子将我们的状态存储在内存中(这就是定制钩子的构建方式——通过组合像<code class="fe mp mq mr ms b">useState</code>这样的本机钩子)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0747" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在将处理几个边缘情况。即:</p><ul class=""><li id="2ab2" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">如果本地存储中没有存储任何值，我们将使用提供的默认值，并且</li><li id="64db" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">如果存储了无效的JSON，<code class="fe mp mq mr ms b">JSON.parse</code>将抛出一个错误，我们将再次使用默认值。</li></ul><p id="ddf1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在代码中，这对应于:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0bed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已成功检索初始值！现在，让我们继续每当状态改变时在本地存储中更新它。</p><h1 id="5b8b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">监听更改并更新本地存储</h1><p id="dcc9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这个更简单:每当<code class="fe mp mq mr ms b">value</code>改变时，我们就使用提供的<code class="fe mp mq mr ms b">localStorageKey</code>将它字符串化并存储回本地存储。我们将为此使用一个<code class="fe mp mq mr ms b">useEffect</code>钩子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="8ff1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在进行下一步之前，关于性能的一个注意事项:正如我们已经说过的，<code class="fe mp mq mr ms b">localStorage</code> API是同步的，这意味着它阻塞了主线程。现在，这不是简单数据的问题，但如果你在有大量复杂数据的应用程序中使用它，这可能会成为一个问题。要提高性能，您有两种选择:</p><ul class=""><li id="fcf4" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">不要在<code class="fe mp mq mr ms b">value</code>改变的时候保存，而是每隔一段时间定期保存。</li><li id="3ba1" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">或者，去抖状态更新:即，每当<code class="fe mp mq mr ms b">value</code>改变时，等待片刻，然后将状态保存到本地存储器中。这样，多次连续的状态更新只会导致一次本地存储写入。</li></ul><h1 id="13bd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">包装一切:使挂钩可用</h1><p id="0ff9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">你可能已经注意到，我们的钩子一直没有返回任何东西:我们现在将通过返回<code class="fe mp mq mr ms b">value</code>和<code class="fe mp mq mr ms b">setValue</code>来修复这个问题，就像<code class="fe mp mq mr ms b">useState</code>钩子所做的那样。所以，把所有这些放在一起，这就是我们得到的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="d63c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">瞧啊！一个简单的React挂钩，用于在本地存储中检索和保存状态。</p><h1 id="175d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最终考虑</h1><p id="2041" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们已经看到了这种方法的性能含义，所以让我们跳到其他一些考虑事项。首先，从安全的角度来看，您应该记住本地存储是以不加密的方式存储在磁盘上的，并且可以被在您的域上运行的所有JavaScript代码访问——这本身不是问题，但这意味着您需要格外小心来保护您的网站免受XSS(跨站点脚本)攻击。</p><p id="d010" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其次，应该提到的是，您可以在本地存储中存储的数据量有一个硬限制:5兆字节——超过一个字节，<code class="fe mp mq mr ms b">localStorage.setItem</code>就会抛出错误。但是，只要您没有存储极其复杂的数据(比如整个文件)，这应该不是一个问题——为此，您可能需要考虑其他解决方案，比如IndexedDB API。</p><h1 id="d3b7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">总结一下:我们学到了什么</h1><p id="ea66" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们巩固一下知识吧！在本文中，我们…</p><ul class=""><li id="a41c" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">学习了<code class="fe mp mq mr ms b">localStorage</code> API的基础知识，</li><li id="9965" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">了解了JSON解析和序列化，</li><li id="b5be" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">应用我们关于<code class="fe mp mq mr ms b">useState</code>和<code class="fe mp mq mr ms b">useEffect</code>的知识来创建一个定制的React钩子，并且</li><li id="27da" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">做了一些关于使用<code class="fe mp mq mr ms b">localStorage</code> API的考虑。</li></ul><p id="6cb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你认为你已经掌握了所有这些概念吗？如果是这样的话，我鼓励你自己练习:比如，你可以通过去抖动状态变化来尝试改进这个钩子。否则，请随时联系并要求澄清！我会去帮忙的。</p></div></div>    
</body>
</html>