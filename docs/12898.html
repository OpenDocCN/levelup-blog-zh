<html>
<head>
<title>An Introduction To NgRx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NgRx简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-introduction-to-ngrx-2d849c0baac4?source=collection_archive---------2-----------------------#2022-07-19">https://levelup.gitconnected.com/an-introduction-to-ngrx-2d849c0baac4?source=collection_archive---------2-----------------------#2022-07-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="8a0c" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/@lorenzozar/list/angular-5496c492a185" rel="noopener">角度</a></h2><div class=""/><div class=""><h2 id="65b3" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">NgRx是一个使用Redux模式的状态管理库。了解为什么以及何时使用它。</h2></div><p id="f658" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果你听说过NgRx，你可能认为它很复杂，除非你的应用程序有复杂的状态需要维护，否则你不应该使用它。</p><p id="1262" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这通常是准确的。而这也是为什么在不需要的时候要熟悉的原因。那么当你确实需要它的时候，你就有了一个好的起点。</p><p id="7574" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这是对NgRx基本概念的介绍。</p><p id="7a7c" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我将首先回答</p><ul class=""><li id="c91c" class="lk ll iq kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated">NgRx是什么？</li><li id="cd8c" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">为什么我们需要国家管理？</li></ul><p id="7d97" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在开始构建一个使用NgRx的简单应用程序之前。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/ee79d90c82735ee9830b7c2a7fdc98d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oPK-rXxr6QN2paySfqfOmA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">https://ngrx.io/<a class="ae mo" href="https://ngrx.io/" rel="noopener ugc nofollow" target="_blank">主页</a></figcaption></figure><h1 id="d14f" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">NgRx是什么？</h1><p id="d7b8" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated">NgRx是一个使用Redux模式的状态管理库。</p><h2 id="6341" class="nm mq iq bd mr nn no dn mv np nq dp mz kx nr ns nb lb nt nu nd lf nv nw nf iw bi translated">什么是国家？</h2><p id="c89e" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated">简单地说，您可以将<strong class="kq ja">状态看作一个JavaScript对象，它包含应用程序不同部分使用的数据</strong>。</p><p id="ab7f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这个想法是要有一个数据存储，其中应用程序、服务和组件的不同部分仍然可以在从存储接收它们的状态时相互交互。</p><p id="8c79" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这个<strong class="kq ja">存储是整个应用程序状态的唯一真实来源</strong>。</p><p id="524f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这个概念来自Redux。</p><h2 id="e19c" class="nm mq iq bd mr nn no dn mv np nq dp mz kx nr ns nb lb nt nu nd lf nv nw nf iw bi translated">Redux是什么？</h2><p id="7e25" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated">Redux是一种状态管理模式，也是一个在任何应用程序中实现该模式的库。</p><p id="e112" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">Redux背后的主要思想是，整个应用程序的状态存储在一个中心位置:存储。</p><p id="c542" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">把商店想象成一个JavaScript对象。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nx"><img src="../Images/8ad3627d39ec71d3667d68ab4eff7324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xLqaL2D_eIrI81_Y.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">Redux徽标</figcaption></figure><h1 id="2d9c" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">为什么我们需要国家管理？</h1><p id="0ac2" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated">到目前为止，我们说NgRx用于管理一个应用程序的状态。</p><p id="3db4" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">要不是这样，我们可以使用服务！对于小而简单的应用程序，服务足以处理应用程序状态。</p><p id="ffea" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">更具体地说，通过使用RxJS和Subjects，我们可以在不使用NgRx的情况下走得更远。</p><p id="ef6c" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">然而，有一些很好的理由使用状态管理，特别是NgRx，如果你正在使用Angular。</p><h2 id="c7c5" class="nm mq iq bd mr nn no dn mv np nq dp mz kx nr ns nb lb nt nu nd lf nv nw nf iw bi translated">使用NgRx的理由</h2><p id="c226" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated">根据<a class="ae mo" href="https://ngrx.io/guide/store/why" rel="noopener ugc nofollow" target="_blank"> ngrx.io </a>，<em class="ny">你可能会使用NgRx </em></p><ul class=""><li id="2771" class="lk ll iq kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated"><em class="ny">当您构建一个具有大量用户交互和多个数据源的应用程序时，或者</em></li><li id="a242" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated"><em class="ny">当服务中的管理状态不再足够时</em>。</li></ul><p id="ac52" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">所以，如果你的应用变得越来越大，而你的状态管理变得越来越混乱，这可能是因为缺乏适当的状态管理。</p><p id="e5cf" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">他们甚至提出了一个简便的指南来回答这个问题:我需要NgRx存储吗？</p><ul class=""><li id="b566" class="lk ll iq kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated"><strong class="kq ja">共享</strong>:被多个组件和服务访问的状态。</li><li id="d0dd" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated"><strong class="kq ja">水化</strong>:从外部存储持久化和再水化的状态。</li><li id="9900" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated"><strong class="kq ja">可用</strong>:重新输入路线时需要可用的状态。</li><li id="1513" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated"><strong class="kq ja">恢复</strong>:必须恢复的状态，有副作用。</li><li id="3600" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated"><strong class="kq ja">受影响</strong>:受其他来源行动影响的状态。</li></ul><h2 id="db62" class="nm mq iq bd mr nn no dn mv np nq dp mz kx nr ns nb lb nt nu nd lf nv nw nf iw bi translated">为什么服务还不够？</h2><p id="2e0e" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated">首先，使用服务来处理大型复杂的应用程序可能会令人困惑，并且您可能会失去唯一的事实来源。</p><p id="e87a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">此外:</p><ul class=""><li id="fe17" class="lk ll iq kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated">使用RxJS和Subjects时，Angular可能无法检测嵌套在对象中的属性的值更改。在JavaScript中，改变一个对象的属性不会改变整个对象。</li><li id="ab9b" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">你需要一个清晰和结构化的模式来更新应用程序中的数据</li></ul><p id="f5ca" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">话虽如此，请记住"<em class="ny"> NgRx Store附带了一些权衡[…]。这并不意味着是编写代码的最短或最快的方法。它还鼓励使用许多文件</em>、<a class="ae mo" href="https://ngrx.io/guide/store/why" rel="noopener ugc nofollow" target="_blank"> ngrx.io </a>。</p><h2 id="415f" class="nm mq iq bd mr nn no dn mv np nq dp mz kx nr ns nb lb nt nu nd lf nv nw nf iw bi translated">为什么是NgRx而不是Redux？</h2><p id="3bd5" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated">简而言之，NgRx与Angular集成得更好。此外，它使用可注入服务、<a class="ae mo" href="https://www.vitainbeta.org/2022/04/30/rxjs-primer/" rel="noopener ugc nofollow" target="_blank"> RxJs </a>和TypeScript。</p><p id="1d77" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">NgRx在副作用上固执己见，而Redux则有不同的做法。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="f81e" class="mp mq iq bd mr ms og mu mv mw oh my mz kf oi kg nb ki oj kj nd kl ok km nf ng bi translated">使用NgRx构建一个简单的应用程序:概述和理论</h1><p id="9488" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated">我们将创建一个简单的计数器应用程序来探索NgRx的基础知识。</p><p id="9eeb" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这个应用程序松散地遵循了ngrx.io 上提供的t <a class="ae mo" href="https://ngrx.io/guide/store#tutorial" rel="noopener ugc nofollow" target="_blank"> utorial。然而，我添加了一些解释，可能对第一次接触NgRx和Redux模式的开发人员有所帮助。</a></p><p id="bd5e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们首先在AppComponent中创建一个计数器特性。CSS基本上被省略了，但是你可以在GitHub上找到完整的代码。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/f26cda8e8b81323ee78cf9dff9550c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*ecnOuMs2EH_2e4UALzxv0Q.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">计数器应用程序</figcaption></figure><p id="a82a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">app.component.html的代码是</p><pre class="lz ma mb mc gt om on oo op aw oq bi"><span id="de0b" class="nm mq iq on b gy or os l ot ou">&lt;p&gt;Current Count&lt;/p&gt;<br/>&lt;h2&gt;{{ count }}&lt;/h2&gt;</span><span id="1377" class="nm mq iq on b gy ov os l ot ou">&lt;button (click)="increment()"&gt;+&lt;/button&gt;<br/>&lt;button (click)="decrement()"&gt;-&lt;/button&gt;<br/>&lt;button (click)="reset()"&gt;Reset&lt;/button&gt;</span></pre><p id="961e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">app.component.ts中的代码是</p><pre class="lz ma mb mc gt om on oo op aw oq bi"><span id="ce04" class="nm mq iq on b gy or os l ot ou">...</span><span id="c42a" class="nm mq iq on b gy ov os l ot ou">export class AppComponent {<br/>  title = 'ngrx';<br/>  count: number = 0;</span><span id="2247" class="nm mq iq on b gy ov os l ot ou">  increment() { this.count++; }</span><span id="0824" class="nm mq iq on b gy ov os l ot ou">  decrement() { this.count--; }</span><span id="f159" class="nm mq iq on b gy ov os l ot ou">  reset() { this.count = 0; }<br/>}</span></pre><h2 id="2fdb" class="nm mq iq bd mr nn no dn mv np nq dp mz kx nr ns nb lb nt nu nd lf nv nw nf iw bi translated">本地状态生命周期</h2><p id="9376" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated">目前，AppComponent有一个本地状态。它是名为<code class="fe ow ox oy on b">counter</code>的变量，存储计数器的值。</p><p id="b95b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们快速浏览一下AppComponent中的状态生命周期</p><p id="ca98" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">从模板开始:</p><ol class=""><li id="4e2d" class="lk ll iq kq b kr ks ku kv kx lm lb ln lf lo lj oz lq lr ls bi translated">点击一个按钮触发一个点击事件</li><li id="6c88" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj oz lq lr ls bi translated">点击事件执行一种方法</li><li id="d7b4" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj oz lq lr ls bi translated">该方法更新类中<code class="fe ow ox oy on b">counter</code>的值</li><li id="3c74" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj oz lq lr ls bi translated">最后，由于字符串插值，模板反映了更新的值</li></ol><p id="c47a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">NgRx中应用程序状态的总体流程非常复杂，但是有些元素与我上面描述的相似。</p><h2 id="d2c4" class="nm mq iq bd mr nn no dn mv np nq dp mz kx nr ns nb lb nt nu nd lf nv nw nf iw bi translated">全局状态生命周期</h2><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi pa"><img src="../Images/4ee4a8596f830c56ff2f99cd48b9870c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hcFRzKNb60sAG2fE.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">NgRx 中应用状态的一般<a class="ae mo" href="https://ngrx.io/guide/store" rel="noopener ugc nofollow" target="_blank">流程</a></figcaption></figure><p id="e1a7" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在NgRx中，组件不存储状态，也不管理发生的变化。</p><p id="26a5" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">状态现在存储在存储中，而不是组件中。</p><p id="5f8f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们从模板开始，看看状态生命周期是如何变化的:</p><ol class=""><li id="9424" class="lk ll iq kq b kr ks ku kv kx lm lb ln lf lo lj oz lq lr ls bi translated">点击一个按钮触发一个点击事件</li><li id="b603" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj oz lq lr ls bi translated">点击事件执行一种方法</li><li id="0158" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj oz lq lr ls bi translated">该方法将动作分派给缩减器</li><li id="0690" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj oz lq lr ls bi translated">缩减器执行逻辑来更新存储器中的值<code class="fe ow ox oy on b">counter</code></li><li id="517d" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj oz lq lr ls bi translated">最后，由于字符串插值，模板反映了更新的值</li></ol><p id="301f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们可以进一步分解这个逻辑。</p><ol class=""><li id="ccfd" class="lk ll iq kq b kr ks ku kv kx lm lb ln lf lo lj oz lq lr ls bi translated"><strong class="kq ja">更新状态</strong>。前四个步骤更新存储中的状态值。</li><li id="a615" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj oz lq lr ls bi translated"><strong class="kq ja">拉动状态</strong>。最后一步从存储中提取状态值。</li></ol><p id="6f88" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">接下来，我们开始按照这两个部分构建应用程序。</p><h1 id="9752" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">使用NgRx: Code构建一个简单的应用程序</h1><p id="6709" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated">首先，安装NgRx</p><pre class="lz ma mb mc gt om on oo op aw oq bi"><span id="42b9" class="nm mq iq on b gy or os l ot ou">npm install @ngrx/store --save</span></pre><p id="5d83" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">然后，让我们在第1部分中更新商店中的状态值。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi pb"><img src="../Images/169f9de05e27b4151a717726973386fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wrWIiD-_ERrMyXqek45frA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">专注于更新商店的状态</figcaption></figure><h2 id="77b7" class="nm mq iq bd mr nn no dn mv np nq dp mz kx nr ns nb lb nt nu nd lf nv nw nf iw bi translated">第1部分:更新状态</h2><p id="fa49" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated">我将从创建代码来更新存储中的状态开始，因此只关注前四个步骤。</p><p id="a937" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">前两步是相同的，但是第三步引入了两个新概念:动作和减少器。</p><ul class=""><li id="2562" class="lk ll iq kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated"><strong class="kq ja">动作</strong>:动作代表应用程序中发生的唯一事件。例如，递增计数器。</li><li id="3141" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated"><strong class="kq ja">还原器</strong>:还原器检测动作，修改当前状态，并将新状态存储在存储器中。我们通常为应用程序中的每个功能提供一个缩减器。一个缩减器可以处理多个动作，比如递增、递减和重置计数器。</li></ul><p id="b564" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们给减速器分派一个动作。</p><h2 id="30f8" class="nm mq iq bd mr nn no dn mv np nq dp mz kx nr ns nb lb nt nu nd lf nv nw nf iw bi translated">创建一个操作</h2><p id="bfe6" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated">我创建了一个状态文件夹，其中包含了与状态管理相关的所有内容。在state文件夹中，我创建了一个名为counter.actions.ts的文件。</p><p id="d4d5" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我创建了一个递增计数器的操作:</p><pre class="lz ma mb mc gt om on oo op aw oq bi"><span id="4186" class="nm mq iq on b gy or os l ot ou">//  counter.actions.ts</span><span id="8318" class="nm mq iq on b gy ov os l ot ou">import { createAction } from '@ngrx/store';</span><span id="9e22" class="nm mq iq on b gy ov os l ot ou">export const increment = createAction('[App Component] Increment');</span></pre><p id="88fa" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">要创建一个动作，我们只需将动作的名称传递给<code class="fe ow ox oy on b">createAction</code>方法。动作的名称是一个字符串，通常表示动作的来源，在方括号中，后面跟着动作是什么。</p><p id="5bea" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这是我们的第一个行动。现在我们需要创建一个接收动作并处理它的reducer。</p><h2 id="08dd" class="nm mq iq bd mr nn no dn mv np nq dp mz kx nr ns nb lb nt nu nd lf nv nw nf iw bi translated">创建一个减速器</h2><p id="bf46" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated">在state文件夹中，我创建了一个名为counter.reducer.ts的文件。</p><pre class="lz ma mb mc gt om on oo op aw oq bi"><span id="11e0" class="nm mq iq on b gy or os l ot ou">//  counter.reducer.ts<br/></span><span id="5ed0" class="nm mq iq on b gy ov os l ot ou">import { createReducer, on } from '<a class="ae mo" href="http://twitter.com/ngrx/store" rel="noopener ugc nofollow" target="_blank">@ngrx/store</a>';<br/>import { increment } from './counter.actions';</span><span id="dc2b" class="nm mq iq on b gy ov os l ot ou">export const initialState = 0;</span><span id="ac2a" class="nm mq iq on b gy ov os l ot ou">export const counterReducer = createReducer(<br/>  initialState,<br/>  on(increment, (state) =&gt; state + 1),<br/>);</span></pre><p id="7fb3" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">请注意，<code class="fe ow ox oy on b">initialState</code>将是应用程序在任何动作被调度之前的初始状态。在这个简单的应用程序中，<code class="fe ow ox oy on b">initialState</code>是一个数字，它将是AppComponent中<code class="fe ow ox oy on b">counter</code>的值。</p><p id="e8cb" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">为了创建一个减速器，我们使用<code class="fe ow ox oy on b">createReducer</code>方法。</p><p id="a114" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">第一个参数取最初分配给<code class="fe ow ox oy on b">counter</code>的值。这个值可以是一个对象，它存储应用程序或功能的初始状态。</p><p id="0385" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">第二个参数采用<code class="fe ow ox oy on b">on</code>方法来处理特定的动作。因此，在我们的例子中，当调度<code class="fe ow ox oy on b">increment</code>动作时，我们获取当前状态并返回一个新状态。</p><h2 id="edc9" class="nm mq iq bd mr nn no dn mv np nq dp mz kx nr ns nb lb nt nu nd lf nv nw nf iw bi translated">在AppModule中导入NgRx</h2><p id="ecb7" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated">由于我们没有使用<a class="ae mo" href="https://ngrx.io/guide/store/install#installing-with-ng-add" rel="noopener ugc nofollow" target="_blank"> Angular CLI添加NgRx </a>，所以需要手动添加。</p><p id="272e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在AppModule中，我们导入:</p><pre class="lz ma mb mc gt om on oo op aw oq bi"><span id="a6db" class="nm mq iq on b gy or os l ot ou">// app.module.ts</span><span id="b8b0" class="nm mq iq on b gy ov os l ot ou">import { StoreModule } from '<a class="ae mo" href="http://twitter.com/ngrx/store" rel="noopener ugc nofollow" target="_blank">@ngrx/store</a>';<br/>import { counterReducer } from './state/counter.reducer';</span><span id="3c0e" class="nm mq iq on b gy ov os l ot ou"><a class="ae mo" href="http://twitter.com/NgModule" rel="noopener ugc nofollow" target="_blank">@NgModule</a>({<br/>  declarations: [AppComponent],<br/>  imports: [BrowserModule, StoreModule.forRoot({ count: counterReducer })],<br/>  providers: [],<br/>  bootstrap: [AppComponent],<br/>})<br/>export class AppModule {}</span></pre><p id="0cec" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">请注意"<em class="ny"> StoreModule.forRoot()方法如何注册在整个应用程序中访问存储所需的全局提供者"，ngrx.io </em>。</p><p id="c1ae" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">StoreModule.forRoot函数接受一个包含<code class="fe ow ox oy on b">count</code>和counterReducer方法的对象，我们用它来管理计数器的状态。</p><h2 id="c967" class="nm mq iq bd mr nn no dn mv np nq dp mz kx nr ns nb lb nt nu nd lf nv nw nf iw bi translated">向减速器分派动作</h2><p id="219b" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated">现在我们有了一个动作(增量)和一个减速器(反减速器)。让我们最终调度我们的第一个行动。</p><p id="ad2b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如上所述，该方法将一个动作分派给reducer，因此让我们更新app.component.ts中的代码来分派动作。</p><pre class="lz ma mb mc gt om on oo op aw oq bi"><span id="7504" class="nm mq iq on b gy or os l ot ou">import { Component } from '<a class="ae mo" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>';<br/>import { Store } from '<a class="ae mo" href="http://twitter.com/ngrx/store" rel="noopener ugc nofollow" target="_blank">@ngrx/store</a>';<br/>import { increment } from './state/counter.actions';</span><span id="ea28" class="nm mq iq on b gy ov os l ot ou">...<br/>export class AppComponent {<br/>  title = 'ngrx';<br/>  count: number = 0;</span><span id="6e7f" class="nm mq iq on b gy ov os l ot ou">  constructor(private store: Store) {}</span><span id="612b" class="nm mq iq on b gy ov os l ot ou">  increment() { <br/>    this.store.dispatch(increment());  <br/>  }</span><span id="195e" class="nm mq iq on b gy ov os l ot ou">  decrement() { this.count--; }<br/>  reset() { this.count = 0; }<br/>}</span></pre><p id="965b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">注意，我们需要导入<code class="fe ow ox oy on b">Store</code>和<code class="fe ow ox oy on b">increment</code>。然后我们在构造函数中注入<code class="fe ow ox oy on b">store</code>，最后，我们更新<code class="fe ow ox oy on b">increment</code>方法:</p><pre class="lz ma mb mc gt om on oo op aw oq bi"><span id="3629" class="nm mq iq on b gy or os l ot ou">increment() { <br/>  this.store.dispatch(increment());  <br/>}</span></pre><p id="876f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在，如果您单击应用程序中的<code class="fe ow ox oy on b">+</code>按钮，您将看到什么也没有发生。</p><p id="c400" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">但是，逻辑是正确的。我们向reducer发送一个动作，reducer更新状态。</p><p id="328c" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">您可以使用Angular DevTools来检查这一点。见下图截图。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi pc"><img src="../Images/8c4d2f03bfaed8a6d7c14cfd5d3f86f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*JvSLiJrmlsEji3-NqTm6Zw.png"/></div></div></figure><p id="6a71" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">从Angular DevTools中，我们看到三个属性:计数、存储和标题。</p><ul class=""><li id="d355" class="lk ll iq kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated"><strong class="kq ja">计数</strong>。count的值为0。这是有意义的，因为我们在AppComponent中将<code class="fe ow ox oy on b">count</code>初始化为0。自从我们将<code class="fe ow ox oy on b">increment</code>方法改为使用调度程序后，就再也不会改变<code class="fe ow ox oy on b">count</code>的值了。</li><li id="7908" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated"><strong class="kq ja">店铺</strong>。当我们查看store/source/_value/count的值时，我们看到它是6。那是店里状态下的count值！我点击了六次<code class="fe ow ox oy on b">+</code>按钮，结果如下！</li><li id="ecad" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated"><strong class="kq ja">书名</strong>。就是字符串“ngrx”</li></ul><p id="664e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">因此，状态得到了更新，这就结束了第1部分:更新状态。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi pd"><img src="../Images/fe5b6dda114c5f8a9688b74fd14725af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ijvuROX04s-QyvrfFTqHdA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">状态得到更新</figcaption></figure><p id="a4c1" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">为什么我们在UI中看不到呢？因为模板是从app.component.ts中的<code class="fe ow ox oy on b">count</code>获取其值，而不是从store中获取！这就是第二部分:拉动国家。</p><p id="92ad" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">顺便提一下，有一个<a class="ae mo" href="https://github.com/reduxjs/redux-devtools" rel="noopener ugc nofollow" target="_blank"> Redux扩展</a>，它让您对NgRx状态管理有了更多的了解。</p><h2 id="b43b" class="nm mq iq bd mr nn no dn mv np nq dp mz kx nr ns nb lb nt nu nd lf nv nw nf iw bi translated">第2部分:拉动状态</h2><p id="4ba9" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated">正如我们上面所说的，第五步将状态的值从存储中拉入到类中。然后，我们可以使用新值来更新UI。</p><p id="226e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">为了从存储中获取数据，我们使用了一个选择器，<code class="fe ow ox oy on b">select</code>方法，它返回当前状态的流。</p><ul class=""><li id="8938" class="lk ll iq kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated"><strong class="kq ja">选择器</strong>:选择器将状态从商店拉进需要它的组件或服务中。重要的是要记住"<em class="ny">选择器是用于获得存储状态</em>、<a class="ae mo" href="https://ngrx.io/guide/store/selectors" rel="noopener ugc nofollow" target="_blank"> ngrx.io </a>的片的纯函数</li></ul><p id="aac3" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">app.component.ts中的代码演变为:</p><pre class="lz ma mb mc gt om on oo op aw oq bi"><span id="4e29" class="nm mq iq on b gy or os l ot ou">...<br/>import { Observable } from 'rxjs';</span><span id="d8d2" class="nm mq iq on b gy ov os l ot ou">...<br/>export class AppComponent {<br/>  title = 'ngrx';<br/>  count: number = 0;  // remove once all methods dispatch actions<br/>  count$: Observable&lt;number&gt;;</span><span id="7fae" class="nm mq iq on b gy ov os l ot ou">  constructor(private store: Store&lt;{ count: number }&gt;) {<br/>    this.count$ = this.store.select('count');<br/>  }</span><span id="d573" class="nm mq iq on b gy ov os l ot ou">  ...<br/>}</span></pre><p id="f4f6" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">注意<code class="fe ow ox oy on b">count$</code>指的是可观测的流。我们在构造函数中初始化<code class="fe ow ox oy on b">count$</code>的值。</p><p id="ea7e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">最后，我们可以使用<a class="ae mo" href="https://betterprogramming.pub/go-reactive-with-angular-async-pipe-b290988f4000" rel="noopener ugc nofollow" target="_blank">异步管道</a>来订阅更改，并在更改发生时立即呈现它们。</p><p id="5ea6" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">因此，app.component.html变成了:</p><pre class="lz ma mb mc gt om on oo op aw oq bi"><span id="70f5" class="nm mq iq on b gy or os l ot ou">...</span><span id="d519" class="nm mq iq on b gy ov os l ot ou">&lt;h2&gt;{{ count$ | async }}&lt;/h2&gt;</span><span id="896e" class="nm mq iq on b gy ov os l ot ou">...</span></pre><p id="a687" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在UI应该在你每次点击<code class="fe ow ox oy on b">+</code>时更新。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi pe"><img src="../Images/a0c57f2aee4c48be0eacedac2a679b51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UPLvakqTl75dSNZe3xsZYw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">状态中的值反映在用户界面中</figcaption></figure><p id="d0ac" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">其他按钮不会产生任何效果。有必要</p><ul class=""><li id="f8c9" class="lk ll iq kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated">创建一个动作，</li><li id="5d93" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">更新减速器，</li><li id="b17b" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">将动作分派给减速器</li></ul><p id="ac1d" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">对于每个按钮。</p><p id="d566" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">你可以自己尝试或者在GitHub上找到代码。</p><h1 id="677b" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">最终考虑</h1><p id="8333" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated">这只是对NgRx的介绍，并不探究效果。</p><p id="4ef3" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果您需要将NgRx用于异步操作，您应该看看效果，否则您可能会得到不希望的行为。</p><p id="1a33" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">尽管有这些限制，我希望这篇文章能帮助你加强对NgRx的理解。</p><h1 id="b7e5" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">关键概念</h1><ul class=""><li id="8048" class="lk ll iq kq b kr nh ku ni kx pf lb pg lf ph lj lp lq lr ls bi translated">NgRx是一个使用Redux模式的状态管理库</li><li id="09bc" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">状态是包含应用程序中使用的数据的JavaScript对象</li><li id="254c" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">Redux是一种状态管理模式，提倡将应用程序的状态存储在一个中心位置:商店</li><li id="d484" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">要更新状态，您需要创建一个动作，更新reducer，并将该动作分派给reducer。</li><li id="0533" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">要从状态中提取数据，您需要使用select方法。</li></ul></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="cc59" class="mp mq iq bd mr ms og mu mv mw oh my mz kf oi kg nb ki oj kj nd kl ok km nf ng bi translated">分级编码</h1><p id="0569" class="pw-post-body-paragraph ko kp iq kq b kr nh ka kt ku ni kd kw kx nj kz la lb nk ld le lf nl lh li lj ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="5527" class="lk ll iq kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="e5a3" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">📰查看<a class="ae mo" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">级别提升编码</a>中的更多内容</li><li id="598a" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">🔔关注我们:<a class="ae mo" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae mo" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae mo" href="https://www.getrevue.co/profile/lvlup" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li><li id="c121" class="lk ll iq kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">🚀👉<a class="ae mo" href="https://jobs.levelup.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq ja">软件工程师的热门职位</strong> </a></li></ul></div></div>    
</body>
</html>