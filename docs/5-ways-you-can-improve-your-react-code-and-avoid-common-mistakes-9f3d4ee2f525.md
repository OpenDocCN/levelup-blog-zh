# 改进 React 代码和避免常见错误的 5 种方法

> 原文：<https://levelup.gitconnected.com/5-ways-you-can-improve-your-react-code-and-avoid-common-mistakes-9f3d4ee2f525>

## 如何解耦组件并更好地利用钩子

![](img/5bb74f4874368613e88ea5431d3f0535.png)

由 [Pakata Goh](https://unsplash.com/@pakata) 在 [Unsplash](https://unsplash.com/photos/EJMTKCZ00I0) 上拍摄的照片

## 不要写大量的组件

![](img/86a529137c37c529b4b7d09a7741f80c.png)

想象我们有一个这样的屏幕。我放的 5 个箭头是不同的数据块，不应该都在一个大文件中。

相反，每个数据块都应该是一个单独的组件，我们应该有一个父组件，它将适当的属性传递给子组件，如下所示:

(这只是为了演示，不会渲染任何东西)。

但这个想法是，屏幕上的每一个可以真正成为独立软件并具有不同行为的部分都应该是一个独立的组件，这将防止你拥有一个难以通读的庞大组件。

## 避免嵌套组件

上面的代码是合法的，并且可以工作，但是我们已经把子组件放到了父组件中，我们不需要使用 props 来调用 onClick 函数。

这样做的问题是，每次重新呈现父组件时，它也会重新定义子组件，这可能会导致一些不必要的行为和奇怪的性能。

解决这个问题的方法可以是完全删除子组件，或者从父组件中提取子组件。

## 要避免的常见状态错误

为了保持连续性，让我们继续同一个例子。看着这段代码，你可能会认为当我们单击按钮时，计数会增加 2，但实际上它只会增加 1。

这是因为 setState 是异步的，当我们向两个 setCounts 传递相同的值时，反过来我们的计数只增加 1。

解决这个问题非常简单。

我们可以将一个函数传递给 setCount，它将始终获取当前值，因此即使两个调用是异步的，先启动的调用将增加该值，第二个调用可以使用更新后的值进一步增加我们的计数。

## 开始使用 useMemo

这样做的问题是，在计算函数运行后，我们更新 setUser 状态，例如，这将重新呈现整个组件，迫使 invoiceCalculations 函数再次运行，如果它是一个具有大量逻辑的大型函数，可能会占用很少的资源。更不用说我们希望它只在发票状态发生变化时被调用，而不是其他情况。

然而，如果我们使用 useMemo 钩子，它将记住 invoiceInfo 的最后一个值，并且只有在依赖关系(invoice)被更新时，它才会再次运行计算。

## 不要给你的孩子传递一打道具

如果你的用户对象有很多属性，你真的不想把它们一个一个传递给你的子组件。而是将用户作为一个整体传递。

[](https://medium.com/@ivan.zstoev/membership) [## 通过我的推荐链接加入 Medium-Ivan Stoev

### 作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…

medium.com](https://medium.com/@ivan.zstoev/membership)