<html>
<head>
<title>Polymorphism in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的多态性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/polymorphism-in-swift-b03def92fa26?source=collection_archive---------6-----------------------#2020-05-18">https://levelup.gitconnected.com/polymorphism-in-swift-b03def92fa26?source=collection_archive---------6-----------------------#2020-05-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="5ba6" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">高级主题</h2><div class=""/><div class=""><h2 id="ec18" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">如何在Swift中实现多态性</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/45e353762bcfc60c7957459a58fa7ed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tx3yPYtyRKXSIJVoyUH5Gg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">通过使用协议实现横向增长</figcaption></figure><p id="50bb" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">面向对象编程已经统治编程世界很多年了。一些编程语言(比如Java)被设计成对OOP原则的本地支持，而一些较老的编程语言(比如C++)被修改成对OOP爱好者的支持。尽管这些年来出现了新的方法，OOP仍然是几乎任何一种不同规模和不同团队技能的软件项目的最佳方法之一。尽管如此受欢迎，这篇文章并不是关于OOP的，而是关于如何一起学习如何使用Swift协议和传统的OOP方法来实现<strong class="lg ja">多态性</strong>。</p><h1 id="b4c7" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">什么是多态性</h1><p id="9cc6" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">据<a class="ae mx" href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" rel="noopener ugc nofollow" target="_blank">维基百科</a></p><blockquote class="my"><p id="8044" class="mz na iq bd nb nc nd ne nf ng nh lz dk translated"><strong class="ak"> <em class="ni">多态性</em> </strong> <em class="ni">是关于为不同类型的实体提供单一接口</em>。</p></blockquote><p id="79ee" class="pw-post-body-paragraph le lf iq lg b lh nj ka lj lk nk kd lm ln nl lp lq lr nm lt lu lv nn lx ly lz ij bi translated">虽然它通常被低估，但它是软件工程中最强大的概念之一，它允许您为不同的对象定义不同的行为，同时您仍然可以在它们之间使用一个共享的接口。如果你仍然不清楚，不要担心，让我们快速回顾一下它是如何工作的。</p><h1 id="c925" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">如何使用多态性</h1><p id="2d92" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">假设我们被要求开发一个简单的动物园应用程序，该应用程序可以包含不同类型的动物，但是为了简单起见，让我们假设只有3种动物:狮子、蛇和鹰。为了简单起见，我们被要求只关注这些类型的单个行为，<em class="no">移动</em></p><p id="e0d1" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们想到的第一种方法是将3个对象定义为狮子、蛇、鹰，然后为它们定义不同的属性和行为。虽然一开始这看起来不是一个坏的设计，但是如果我们被要求添加更多相同类别的动物，比如鹈鹕或老虎，我们就会面临问题。<strong class="lg ja">我们看到的是，我们逐渐对所有新动物重复同样的行为。</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi np"><img src="../Images/7f3321af2efd6d9fcdada198ebac42cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GEaA9_quDN0woq8OfLv0Qw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">基本对象</figcaption></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="cbf1" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这是一个我们可以获得<em class="no">多态性</em>来做出更好设计的例子。</p><h1 id="78d4" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">OOP方式</h1><p id="a471" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">在OOP中，多态性是由另一个OOP原则实现的，<strong class="lg ja">继承</strong>。我们所要做的就是将所有对象定义为父类型，并用子对象初始化它们。然后，调用父函数将执行子函数被覆盖的函数。神奇！</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ns"><img src="../Images/65cc1cb6efba036576ee36c8c9cf7e62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WuseeSKtoP66rjcGXBnoUQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">简单继承</figcaption></figure><h1 id="d2d6" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">协议</h1><p id="2e0b" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">记住同一个例子，让我们看看如何使用Swift中的协议解决这个问题。<strong class="lg ja">协议</strong>是最强大的Swift概念之一，使得编程比以前更加容易。在这里，我们将学习它们如何对多态性的实现有用，多态性是一种没有任何继承的<strong class="lg ja">多态性。</strong></p><p id="58f1" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">为了解决我们例子中的设计问题，我们首先需要定义适当的协议。<strong class="lg ja">这可能是设计你的架构最重要的一步，决定你想设计什么</strong>。在我们的例子中，我们可以把不同的类别看作不同的协议。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nt"><img src="../Images/b1ab882be742cf137c6603a4577255b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SDxZXs-o4fQ9SPnRJuvctw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Birds协议一致性</figcaption></figure><h1 id="0338" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">再走一步</h1><p id="698a" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">我们有一个适当的多态实现，没有任何继承，只使用协议。现在，让我们看看我们如何能走得更远，做得更好。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nu"><img src="../Images/6d605a25974e19e3fa4e7d840445c544.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7zhDlzSeWnnYbsVxu92S3g.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">动物协议一致性</figcaption></figure><h1 id="2b49" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">POP还是OOP？</h1><p id="95a2" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">到目前为止，我们已经看到了如何用面向对象和面向协议的方法实现多态性。但是你更喜欢哪一个？各有什么优点？</p><p id="0de9" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">虽然多态性是OOP原则，但我个人更喜欢使用协议来实现它，尤其是对于大型项目。让我们快速看一下当前动物园项目的一个更复杂的层次。</p><p id="6413" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">想象一下，现在我们被要求为不同的动物类别添加与任何其他类别都没有共同点的特定行为。例如，我们现在知道大型猫科动物是天生的攻击者，所以我们想记录它们的攻击性反应。这种行为是所有大型猫科动物共有的，但对于鸟类等其他动物来说并不成立。</p><p id="1761" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">现在我们必须决定我们更愿意使用哪种方法。</p><h2 id="e0da" class="nv mb iq bd mc nw nx dn mg ny nz dp mk ln oa ob mm lr oc od mo lv oe of mq iw bi translated">面向对象的程序设计(Object Oriented Programming)</h2><p id="c859" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">对于OOP，我们需要提出一个反映我们现实世界问题的分层继承设计。在这种情况下，我们需要再添加一个包含我们需要的函数的父对象。因为在大多数现代OOP语言中不可能有多重继承，所以中间父代也必须从另一个父代继承。因为现在这可能有点混乱，所以让我们检查一下代码。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/7ccc1b5d9497ac3d20413096e82b20f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZToNQPF9enVX1dU9X_yaA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">OOP复杂继承</figcaption></figure><h2 id="6816" class="nv mb iq bd mc nw nx dn mg ny nz dp mk ln oa ob mm lr oc od mo lv oe of mq iw bi translated">购买凭证（proof of purchase）</h2><p id="c3b8" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">对于协议，您不需要有任何继承(尽管您可以继承您的协议)。Swift中的任何对象都可以同时符合多个协议，这意味着它可以同时持有不同的行为，而无需任何额外的继承。查看下面的代码来了解这个想法。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/45e353762bcfc60c7957459a58fa7ed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tx3yPYtyRKXSIJVoyUH5Gg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">POP复杂一致性</figcaption></figure><h1 id="893f" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">结论</h1><p id="832f" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">正如您到目前为止所看到的，多态性是一个非常强大的概念，它让您能够以可伸缩的方式设计对象之间的复杂关系。由于OOP和POP都提供了各自的优势，作为一名软件工程师，选择水平增长(POP)还是垂直增长(OOP)最终取决于您。就我个人而言，我宁愿选择POP，因为它适用于Swift structs类型，由于性能的提高，通常建议不要使用类。</p><p id="7097" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">还有许多文章可以帮助您组合不同的特性，以获得更好的设计决策，最终您将获得更易于阅读、维护和扩展的代码。</p></div></div>    
</body>
</html>