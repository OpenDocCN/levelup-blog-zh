<html>
<head>
<title>The Coin Toss Paradox</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">抛硬币悖论</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-coin-toss-paradox-16a3689749d5?source=collection_archive---------11-----------------------#2021-08-10">https://levelup.gitconnected.com/the-coin-toss-paradox-16a3689749d5?source=collection_archive---------11-----------------------#2021-08-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1a25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我最近开始阅读这本来自《量子》杂志的奇妙的书，书名为<a class="ae kl" href="https://www.amazon.com/The-Prime-Number-Conspiracy-audiobook/dp/B07SXBR9Y3/ref=sr_1_1?dchild=1&amp;keywords=the+prime+number+conspiracy&amp;qid=1628598851&amp;sr=8-1" rel="noopener ugc nofollow" target="_blank">“素数阴谋”</a>，它涵盖了现代数学中一些最大的问题，又一次被一个数学问题<a class="ae kl" href="https://xkcd.com/356/" rel="noopener ugc nofollow" target="_blank">的书呆子狙击</a>。</p><p id="3471" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这本书解释说，如果爱丽丝正在抛硬币寻找前两个连续的头，她将在平均六次翻转后找到它。如果Bob翻转寻找正面和反面的第一个实例，他将在四次翻转后平均找到它。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/4aa97d1565b491b7f7432e94e13436d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HGVfxDOsl2ev0OnSUFAENg.jpeg"/></div></div></figure><p id="0b40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">什么鬼东西！？<br/>HH出现的几率和HT出现的几率是一样的。它们是独立的概率！它们怎么会导致如此不同的预期结果呢？</p><p id="e172" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">证据并不明显，首先让我们看一下HH案例的证据。</p><p id="c278" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们有这个递推关系，由这个马尔可夫链给出，其中</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/a6d750fce61f03dd7693526c66a3c42c.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*JEmyf2qYyT1bBfSkY5CPcQ.png"/></div></figure><p id="77b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么这意味着什么呢？我选择的术语顺序很有启发性。看，四分之一的时间我们在前两次翻转中得到HH，一半的时间我们得到一个tails并不得不重新开始(产生1+x次翻转)，四分之一的时间我们得到HT并不得不重新开始(产生2+x次翻转)。</p><p id="6d37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你解决这个循环，你会发现x=6。但结果是HT的递归有点不同。它实际上是这样的:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/a0ec8ef9a5f508bbff6c9e004fd64bc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*KdHj38GXOBWyA66VhT3Xig.png"/></div></figure><p id="1bff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在这里发现了这个，它有一个很好的解释，但是我想我应该补充一下我的意见。从里到外解释可能更容易，所以让我们定义我们的y项，它代表我们得到t必须做的翻转次数。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi la"><img src="../Images/36ca223122319ec392fe076832bf8b43.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*jmgiz4dGSyPKaBs4SThCHA.png"/></div></figure><p id="a490" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">换句话说，如果我们只想知道我们平均需要翻转多少次才能得到1的反面，那就是这个，也就是2。</p><p id="808f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我发现这是一个很有启发性的想法，为了得到序列HT，我们需要两个片段，我们需要一个H和一个T，所以不管怎样，每个以HT结尾的序列都有这样的形式{一定数量的T，至少零} {一定数量的H，至少一个} {正好一个T}。</p><p id="655c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以在第一次翻转时，有一半的时间我们得到了T，必须重新开始，这就是1/2(1+x)项。一旦我们找到了第一个H，有一半的时间我们会得到另一个无用的H，并且必须再次翻转，这就是1/2(1+y)项。</p><p id="f109" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你解决了这个问题，你就会得到4。</p><p id="81e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我还有一个贡献要补充，那就是一个实验测试。如果你不相信我，你可以自己试试，我甚至包括了一个理智检查，表明我们平均要翻两次才能得到正面(或反面):</p><pre class="kn ko kp kq gt lb lc ld le aw lf bi"><span id="ee14" class="lg lh iq lc b gy li lj l lk ll">import scala.util.Random<br/><br/>val random = new Random()<br/><br/>def flipCoin(): Char = { if (random.nextBoolean()) 'H' else 'T' }<br/><br/>def flipUntilSequence(seq: String, history: String): Int = {<br/>  if(history.endsWith(seq))<br/>      history.length<br/>  else<br/>      flipUntilSequence(seq, history + flipCoin())<br/>}<br/><br/>val hh_es= for (i &lt;- <em class="lm">Range</em>(1, 1000000)) yield flipUntilSequence("HH", "")<br/>val ht_es = for (i &lt;- <em class="lm">Range</em>(1, 1000000)) yield flipUntilSequence("HT", "")<br/>val h_es = for (i &lt;- <em class="lm">Range</em>(1, 1000000)) yield flipUntilSequence("H", "")<br/><br/><em class="lm">println</em>(s"Average number of flips to get a heads: <strong class="lc ir">$</strong>{h_es.sum.toDouble / h_es.length}")<br/><br/><em class="lm">println</em>(s"Average number of flips to get HH <strong class="lc ir">$</strong>{hh_es.sum.toDouble / hh_es.length}")<br/><em class="lm">println</em>(s"Average number of flips to get HT <strong class="lc ir">$</strong>{ht_es.sum.toDouble / ht_es.length}")</span></pre><p id="1052" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上，我最近一次跑步的结果是:</p><pre class="kn ko kp kq gt lb lc ld le aw lf bi"><span id="2744" class="lg lh iq lc b gy li lj l lk ll">Average number of flips to get a heads: 2.0016590016590015</span><span id="8956" class="lg lh iq lc b gy ln lj l lk ll">Average number of flips to get HH 6.001767001767002<br/>Average number of flips to get HT 3.9996059996059996</span></pre><p id="c0a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，有没有简单明了的英语解释来解释为什么会这样呢？嗯，我发现<a class="ae kl" href="https://math.stackexchange.com/questions/521130/expected-value-of-flips-until-ht-consecutively" rel="noopener ugc nofollow" target="_blank">这个堆栈溢出线程</a>中的许多帖子非常有用，但特别是 e上的<a class="ae kl" href="https://math.stackexchange.com/a/947339" rel="noopener ugc nofollow" target="_blank">这个。简单地说，在HT情况下，我们可以无限期地停留在状态H_中，任何时候我们遇到T，我们就完成了，在HH情况下，每次我们抛出T，我们都必须重新开始，直到下一次抛出H。顺序在这里非常重要。</a></p></div></div>    
</body>
</html>