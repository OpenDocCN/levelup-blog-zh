<html>
<head>
<title>Serving an Image Classification Model with Tensorflow Serving</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用张量流服务来服务图像分类模型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/serving-an-image-classification-model-with-tensorflow-serving-c4657584d73d?source=collection_archive---------9-----------------------#2022-03-07">https://levelup.gitconnected.com/serving-an-image-classification-model-with-tensorflow-serving-c4657584d73d?source=collection_archive---------9-----------------------#2022-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8961" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">学习利用Tensorflow服务来创建web服务，以服务于您的Tensorflow模型</h2></div><p id="890b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是博客系列的第二部分，将涵盖Tensorflow模型训练、Tensorflow服务及其性能。<a class="ae lb" href="https://medium.com/@erdememekligil/an-object-oriented-approach-to-training-an-image-classifier-with-tensorflow-3bcaa7a7864e" rel="noopener">在之前的文章</a>中，我们采用了面向对象的方法来训练图像分类器模型，并将其导出为SavedModel。我建议在这篇文章之前看一下，因为我们将使用相同的模型。您可以在这里找到博客系列的完整应用程序代码:</p><div class="lc ld gp gr le lf"><a href="https://github.com/erdememekligil/oop-tensorflow-serving" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab fo"><div class="lh ab li cl cj lj"><h2 class="bd ir gy z fp lk fr fs ll fu fw ip bi translated">GitHub-erdememekligil/oop-tensor flow-serving:一种面向对象(OOP)的方法来训练…</h2><div class="lm l"><h3 class="bd b gy z fp lk fr fs ll fu fw dk translated">一种面向对象(OOP)的方法，用于训练张量流模型并使用张量流服务为其提供服务。OOP很好(在…</h3></div><div class="ln l"><p class="bd b dl z fp lk fr fs ll fu fw dk translated">github.com</p></div></div><div class="lo l"><div class="lp l lq lr ls lo lt lu lf"/></div></div></a></div></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h2 id="e6fe" class="mc md iq bd me mf mg dn mh mi mj dp mk ko ml mm mn ks mo mp mq kw mr ms mt mu bi translated">Tensorflow提供的是什么？</h2><p id="3ca3" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">在应用程序中使用张量流模型有许多替代方法。最简单的一种是将Tensorflow与Flask、Django、Fastapi等一起使用。创建基于python的web应用程序的框架。如果需要用其他语言开发，可以使用像ML.NET或deeplearning4j这样的框架。Tensorflow Lite、Pytorch Live和CoreML是用于移动应用程序的框架。但是，在分层架构和微服务中，让机器学习模型成为独立的应用程序是一个很好的做法。这个概念叫做<em class="na">模型服务</em>，将模型作为服务有很多好处。例如，模型可以在不停机的情况下在生产中更新，或者可以由许多不同的客户端应用程序使用。要实现模型服务，可以使用Tensorflow Serving、TorchServe、Triton、KFServing等应用程序。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nb"><img src="../Images/2111f71d945be699aa7e53ebc85fd47f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Te7ykyBZsZ8ZZkpP5BuZug.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">图片由<a class="ae lb" href="https://www.linkedin.com/in/emre-sar%C4%B1g%C3%BCl-7064aa92/" rel="noopener ugc nofollow" target="_blank">Emre sargül</a>拍摄</figcaption></figure><p id="7651" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Tensorflow服务允许我们将Tensorflow模型作为web服务提供，而无需额外的应用程序。它支持通过gRPC和REST协议为多个模型的多个版本提供服务。但是，它要求模型采用Tensorflow的SavedModel格式。SavedModels可以在培训后进行微调和一些修改，特别是如果它们是使用Keras构建的。可以向SavedModels添加额外的函数和签名，然后使用TFServing提供服务。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h2 id="8382" class="mc md iq bd me mf mg dn mh mi mj dp mk ko ml mm mn ks mo mp mq kw mr ms mt mu bi translated">检查保存的模型</h2><p id="9b7b" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">我们在<a class="ae lb" href="https://medium.com/@erdememekligil/an-object-oriented-approach-to-training-an-image-classifier-with-tensorflow-3bcaa7a7864e" rel="noopener">之前的媒体帖子</a>中训练了一个ResNet50模型，并将其保存为SaveModel格式。我们可以使用这个命令来显示Tensorflow服务的模型签名:<code class="fe nq nr ns nt b">saved_model_cli show --all --dir model_path</code></p><pre class="nc nd ne nf gt nu nt nv nw aw nx bi"><span id="8b92" class="mc md iq nt b gy ny nz l oa ob">signature_def['serving_bytes']:<br/>  The given SavedModel SignatureDef contains the following input(s):<br/>    inputs['image_bytes_string'] tensor_info:<br/>        dtype: DT_STRING<br/>        shape: unknown_rank<br/>        name: serving_bytes_image_bytes_string:0<br/>  The given SavedModel SignatureDef contains the following output(s):<br/>    outputs['output_0'] tensor_info:<br/>        dtype: DT_FLOAT<br/>        shape: (1, 10)<br/>        name: StatefulPartitionedCall:0<br/>  Method name is: tensorflow/serving/predict<br/><br/>signature_def['serving_default']:<br/>  The given SavedModel SignatureDef contains the following input(s):<br/>    inputs['input_tensor'] tensor_info:<br/>        dtype: DT_FLOAT<br/>        shape: (-1, -1, -1, 3)<br/>        name: serving_default_input_tensor:0<br/>  The given SavedModel SignatureDef contains the following output(s):<br/>    outputs['output_0'] tensor_info:<br/>        dtype: DT_FLOAT<br/>        shape: (-1, 10)<br/>        name: StatefulPartitionedCall_1:0<br/>  Method name is: tensorflow/serving/predict</span></pre><p id="0796" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以从输出中看到，签名<code class="fe nq nr ns nt b">serving_default</code>接受4d数组输入，而<code class="fe nq nr ns nt b">serving_bytes</code>接受base64编码的数组(作为字符串)输入。两个签名都输出具有10个数字(概率)的数组，因为该模型是在MNIST上训练的，并且具有10个类别。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h2 id="7e7f" class="mc md iq bd me mf mg dn mh mi mj dp mk ko ml mm mn ks mo mp mq kw mr ms mt mu bi translated">运行Tensorflow服务</h2><p id="5108" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">Tensorflow <a class="ae lb" href="https://www.tensorflow.org/tfx/serving/setup" rel="noopener ugc nofollow" target="_blank">建议</a>使用Docker image进行Tensorflow服务，因为这是在GPU支持下使用Tensorflow服务的最简单方式。如果您没有docker并且想要手动安装Tensorflow Serving，请遵循此<a class="ae lb" href="https://www.tensorflow.org/tfx/serving/setup" rel="noopener ugc nofollow" target="_blank">链接</a>中的说明。</p><p id="9b2d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下脚本使用给定的模型创建并运行Tensorflow服务容器。端口8500用于gRPC API，8501用于REST API。这个脚本将主机中的模型目录绑定到容器，并从那里读取模型。然而，在生产环境中使用Tensorflow服务时，更好的做法是将模型放在Docker映像中，而不是使用绑定。</p><pre class="nc nd ne nf gt nu nt nv nw aw nx bi"><span id="5aee" class="mc md iq nt b gy ny nz l oa ob">docker run -p 8500:8500 -p 8501:8501 -d --name resnet_serving \<br/>  -v /directory/on/host/models:/models \<br/>  -e MODEL_NAME=ResnetModel tensorflow/serving:2.8.0-gpu</span></pre><p id="e1af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要检查它是否正常运行，请在网络浏览器中访问以下地址:<code class="fe nq nr ns nt b">http://hostname:8501/v1/models/ResnetModel</code>。如果工作正常，它会返回如下json:</p><pre class="nc nd ne nf gt nu nt nv nw aw nx bi"><span id="4da6" class="mc md iq nt b gy ny nz l oa ob">{<br/> "model_version_status": [<br/>  {<br/>   "version": "1",<br/>   "state": "AVAILABLE",<br/>   "status": {<br/>    "error_code": "OK",<br/>    "error_message": ""<br/>   }<br/>  }<br/> ]<br/>}</span></pre></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h2 id="cf05" class="mc md iq bd me mf mg dn mh mi mj dp mk ko ml mm mn ks mo mp mq kw mr ms mt mu bi translated">消费REST服务</h2><p id="74dd" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">REST和gRPC协议都有其优点和缺点。可能最重要的一点是REST协议更常见。</p><p id="903d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用REST API调用模型，向<code class="fe nq nr ns nt b">http://hostname:8501/v1/models/ResnetModel:predict</code>发送一个POST请求，请求体如下:</p><pre class="nc nd ne nf gt nu nt nv nw aw nx bi"><span id="d2d1" class="mc md iq nt b gy ny nz l oa ob">{<br/>  "signature_name": "serving_bytes", <br/>  "instances": [{"b64": "fill_with_base64_encoded_image_bytes"}]<br/>}</span></pre><p id="ea0a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于该模型是在包含从0到9的手写数字的MNIST数据集上训练的，因此该服务返回10个类别没有应用softmax的激活。在下面的示例中，模型的预测将是具有最高激活值的类，即第3个索引(属于编号2):</p><pre class="nc nd ne nf gt nu nt nv nw aw nx bi"><span id="36ca" class="mc md iq nt b gy ny nz l oa ob">{"predictions": [[-14.9772987, -6.99252939, 13.5781298, -8.89471, -6.88773823, -4.63609457, 0.168618962, -9.86182785, -2.09211802, -1.32305372]]}</span></pre><p id="4dee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用RGB像素值调用<code class="fe nq nr ns nt b">serving_default</code>签名可以得到相同的结果。该签名支持同时处理多个图像，因为它具有4d输入(<em class="na">批次、高度、宽度、通道):</em></p><pre class="nc nd ne nf gt nu nt nv nw aw nx bi"><span id="b3cd" class="mc md iq nt b gy ny nz l oa ob">{<br/>  "signature_name": "serving_default", <br/>  "instances": <!-- -->[[[[0, 0, 0], [0, 0, 0], [255, 255, 255], ...]<br/>}</span></pre><p id="b5ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于REST API，当发送高分辨率图像时，这个签名比<code class="fe nq nr ns nt b">serving_bytes</code>慢，因为整数数组在转换为字符串时会消耗更多的内存。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h2 id="5858" class="mc md iq bd me mf mg dn mh mi mj dp mk ko ml mm mn ks mo mp mq kw mr ms mt mu bi translated">使用gRPC服务</h2><p id="ff33" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">消费gRPC Tensorflow服务API只有Python的<a class="ae lb" href="https://pypi.org/project/tensorflow-serving-api/" rel="noopener ugc nofollow" target="_blank">官方支持</a>。有一些针对其他语言的<a class="ae lb" href="https://github.com/figroc/tensorflow-serving-client" rel="noopener ugc nofollow" target="_blank">开源客户端</a>，但它们可能无法用于Tensorflow服务的最新版本。对于python，必须安装tensor flow-serving-API:<code class="fe nq nr ns nt b">pip install tensorflow-serving-api</code>。具有不安全连接的服务存根(此处<a class="ae lb" href="https://grpc.io/docs/languages/python/alts/" rel="noopener ugc nofollow" target="_blank">检查</a>以获得安全连接)创建如下:</p><figure class="nc nd ne nf gt ng"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="f87f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以使用上面定义的存根对<code class="fe nq nr ns nt b">serving_default</code>签名进行预测:</p><figure class="nc nd ne nf gt ng"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="8977" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nq nr ns nt b">tf.make_tensor_proto</code>和<code class="fe nq nr ns nt b">tf.make_ndarray</code>方法用于numpy数组与张量之间的转换。可以在同一个<code class="fe nq nr ns nt b">serving_default</code>请求中发送多个图像，以获得更快的结果。对于相对较大的图像(例如600x600px)，可使用<code class="fe nq nr ns nt b">serving_bytes</code>签名获得更快的结果:</p><figure class="nc nd ne nf gt ng"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h2 id="66da" class="mc md iq bd me mf mg dn mh mi mj dp mk ko ml mm mn ks mo mp mq kw mr ms mt mu bi translated">结论</h2><p id="4f10" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">我们使用Tensorflow为我们的图像分类模型的两个签名创建REST和gRPC APIs。REST API易于使用，并且在使用base64字节数组而不是整数数组时速度更快。必须使用外部框架来消费gRPC API。但是，当以numpy数组的形式发送多个图像时，速度会更快。</p><p id="202e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请检查GitHub <a class="ae lb" href="https://github.com/erdememekligil/oop-tensorflow-serving" rel="noopener ugc nofollow" target="_blank">库</a>中的完整代码。欢迎在评论中提问。在下一篇文章中，我们将测量Tensorflow服务的性能，并讨论如何提高其性能。</p></div></div>    
</body>
</html>