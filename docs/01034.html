<html>
<head>
<title>How to Upload Files with React and Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用React和Node.js上传文件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-upload-files-with-react-and-node-js-a622b4594bb9?source=collection_archive---------1-----------------------#2019-10-25">https://levelup.gitconnected.com/how-to-upload-files-with-react-and-node-js-a622b4594bb9?source=collection_archive---------1-----------------------#2019-10-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d72f70026e66b13c03e6e0d7706fd42e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yf3d9yQ-7ieayccxxUzXlw.png"/></div></div></figure><p id="84f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">文件上传是web应用程序的常见操作。在Node.js中，使用Express web框架和Multer库，将文件上传功能添加到您的应用程序非常容易。</p><p id="ec1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要将文件上传功能添加到您的应用程序中，首先您需要一个类型为<code class="fe kz la lb lc b">file</code>的输入字段。默认情况下，这种类型的输入呈现为一个很难设计样式的按钮。用户点击对话框，如果您给它附加了一个<code class="fe kz la lb lc b">onChange</code>处理程序，那么您就可以使用JavaScript访问file对象。<code class="fe kz la lb lc b">onChange</code>处理程序接受一个参数，这个参数就是<code class="fe kz la lb lc b">event</code>对象。对象在<code class="fe kz la lb lc b">target.files</code>属性下有文件。一旦你有了它，你就可以用<code class="fe kz la lb lc b">append</code>函数把它添加到<code class="fe kz la lb lc b">FormData</code>对象中，并把它附加到表单提交中。</p><p id="f230" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我们将制作一个照片管理器应用程序，让用户输入姓名、描述，并上传带有文本的照片。</p><p id="ffd8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将用React表示前端，用Multer表示后端。</p><h1 id="1ae0" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">后端:用于文件上传的Node.js</h1><p id="253b" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">我们从构建后端开始。我们创建项目文件夹和项目文件夹中的一个<code class="fe kz la lb lc b">backend</code>文件夹。然后进入<code class="fe kz la lb lc b">backend</code>文件夹，运行<code class="fe kz la lb lc b">npx express-generator</code>为我们的后端应用程序生成代码文件。</p><p id="bf76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们运行<code class="fe kz la lb lc b">npm i</code>来安装生成器为我们的后端提供的包。我们还需要Babel能够使用<code class="fe kz la lb lc b">import</code>语法、用于跨域通信的CORS包、用于Express文件上传的Multer、作为ORM的Sequelize和作为数据库的SQLite3。为了简单起见，我们将使用SQLite。</p><p id="a68e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要安装所有的包，运行<code class="fe kz la lb lc b">npm i @babel/cli @babel/core @babel/node @babel/preset-env cors multer sequelize sqlite3</code>，然后在<code class="fe kz la lb lc b">backend</code>文件夹的根目录下创建一个名为<code class="fe kz la lb lc b">.babelrc</code>的文件，并添加:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="95c5" class="mo le it lc b gy mp mq l mr ms">{<br/>    "presets": [<br/>        "<a class="ae mt" href="http://twitter.com/babel/preset-env" rel="noopener ugc nofollow" target="_blank">@babel/preset-env</a>"<br/>    ]<br/>}</span></pre><p id="d8d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后在<code class="fe kz la lb lc b">package.json</code>的<code class="fe kz la lb lc b">scripts</code>部分，我们添加:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="e8ce" class="mo le it lc b gy mp mq l mr ms">"start": "nodemon --exec npm run babel-node --  ./bin/www",<br/>"babel-node": "babel-node"</span></pre><p id="5319" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这让我们可以用Babel而不是常规的节点运行时来运行我们的应用程序。我们还应该安装<code class="fe kz la lb lc b">nodemon</code>来观察文件的变化，并重启应用程序。通过运行<code class="fe kz la lb lc b">npm i -g nodemon</code>进行全局安装。</p><p id="cf18" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们运行<code class="fe kz la lb lc b">backend</code>文件夹中的<code class="fe kz la lb lc b">npx sequelize-cli init</code>来创建有序的ORM代码，让我们可以进行迁移。</p><p id="a3c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">完成之后，我们应该创建一个<code class="fe kz la lb lc b">config.js</code>。在那里，将现有代码替换为:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="02fe" class="mo le it lc b gy mp mq l mr ms">{<br/>  "development": {<br/>    "dialect": "sqlite",<br/>    "storage": "development.db"<br/>  },<br/>  "test": {<br/>    "dialect": "sqlite",<br/>    "storage": "test.db"<br/>  },<br/>  "production": {<br/>    "dialect": "sqlite",<br/>    "storage": "production.db"<br/>  }<br/>}</span></pre><p id="124c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这指定SQLite作为我们的数据库。</p><p id="9858" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们使用模型创建一个迁移:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="cbef" class="mo le it lc b gy mp mq l mr ms">npx sequelize-cli model:create --name Photo --attributes name:string,description:string,photoPath:string</span></pre><p id="3898" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，我们在<code class="fe kz la lb lc b">attributes</code>标志后的逗号之间没有空格。</p><p id="4209" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">运行<code class="fe kz la lb lc b">npx sequelize-cli db:migrate</code>来创建数据库。</p><p id="0320" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">之后，我们创建处理照片的路径。在<code class="fe kz la lb lc b">routes</code>文件夹中，创建<code class="fe kz la lb lc b">photos.js</code>并添加:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="309b" class="mo le it lc b gy mp mq l mr ms">var express = require("express");<br/>var multer = require("multer");<br/>var router = express.Router();<br/>const models = require("../models");<br/>const storage = multer.diskStorage({<br/>  destination: (req, file, cb) =&gt; {<br/>    cb(null, "./uploads");<br/>  },<br/>  filename: (req, file, cb) =&gt; {<br/>    cb(null, `${file.fieldname}_${+new Date()}.jpg`);<br/>  }<br/>});</span><span id="f3e9" class="mo le it lc b gy mu mq l mr ms">const upload = multer({<br/>  storage<br/>});</span><span id="1cd1" class="mo le it lc b gy mu mq l mr ms">/* GET users listing. */<br/>router.get("/", async (req, res, next) =&gt; {<br/>  const photos = await models.Photo.findAll();<br/>  res.json(photos);<br/>});</span><span id="8d41" class="mo le it lc b gy mu mq l mr ms">router.post("/add", upload.single("photo"), async (req, res, next) =&gt; {<br/>  try {<br/>    const path = req.file.path;<br/>    const { name, description } = req.body;<br/>    const entry = await models.Photo.create({<br/>      name,<br/>      description,<br/>      photoPath: path<br/>    });<br/>    res.json(entry);<br/>  } catch (ex) {<br/>    res.status(400).send({ error: ex });<br/>  }<br/>});</span><span id="b804" class="mo le it lc b gy mu mq l mr ms">router.put("/edit", upload.single("photo"), async (req, res, next) =&gt; {<br/>  try {<br/>    const path = req.file &amp;&amp; req.file.path;<br/>    const { id, name, description } = req.body;<br/>    let params = {};<br/>    if (path) {<br/>      params = {<br/>        name,<br/>        description,<br/>        photoPath: path<br/>      };<br/>    } else {<br/>      params = {<br/>        name,<br/>        description<br/>      };<br/>    }<br/>    const photo = await models.Photo.update(params, {<br/>      where: {<br/>        id<br/>      }<br/>    });<br/>    res.json(photo);<br/>  } catch (ex) {<br/>    res.status(400).send({ error: ex });<br/>  }<br/>});</span><span id="1b51" class="mo le it lc b gy mu mq l mr ms">router.delete("/delete/:id", async (req, res, next) =&gt; {<br/>  const { id } = req.params;<br/>  await models.Photo.destroy({<br/>    where: {<br/>      id<br/>    }<br/>  });<br/>  res.json({ deleted: id });<br/>});</span><span id="c026" class="mo le it lc b gy mu mq l mr ms">module.exports = router;</span></pre><p id="5bc0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些都是操纵照片的路线。<code class="fe kz la lb lc b">models</code>文件是由Sequelize CLI创建的，它包含模型对象，我们操纵这些对象将数据保存到Photos表中。我们有一个用<code class="fe kz la lb lc b">findAll</code>获取照片的GET路径，一个用<code class="fe kz la lb lc b">create</code>保存<code class="fe kz la lb lc b">Photo</code>的POST路径，一个用<code class="fe kz la lb lc b">update</code>更新模型的PUT路径，一个用<code class="fe kz la lb lc b">destroy</code>删除照片的DELETE路径。</p><p id="11c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了添加文件上传，我们使用之前安装的<code class="fe kz la lb lc b">multer</code>包。添加起来很简单。我们只需指定要上传文件的文件名和文件夹，如下面的代码块所示:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="bdbc" class="mo le it lc b gy mp mq l mr ms">const storage = multer.diskStorage({<br/>  destination: (req, file, cb) =&gt; {<br/>    cb(null, "./uploads");<br/>  },<br/>  filename: (req, file, cb) =&gt; {<br/>    cb(null, `${file.fieldname}_${+new Date()}.jpg`);<br/>  }<br/>});</span><span id="e906" class="mo le it lc b gy mu mq l mr ms">const upload = multer({<br/>  storage<br/>});</span></pre><p id="314e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在<code class="fe kz la lb lc b">multer</code>中间件中加入了我们想要访问文件的路径，如下所示:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="03f1" class="mo le it lc b gy mp mq l mr ms">upload.single("photo")</span></pre><p id="4968" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这指定我们让前端上传一个带有<code class="fe kz la lb lc b">photo</code>字段的文件到<code class="fe kz la lb lc b">FormData</code>中。</p><p id="cb6d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们可以通过使用<code class="fe kz la lb lc b">req.file.path</code>将路径保存到我们的数据库中来访问路径中保存文件的文件路径。</p><p id="0798" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要在<code class="fe kz la lb lc b">backend</code>文件夹中创建一个<code class="fe kz la lb lc b">uploads</code>文件夹来保存文件。</p><p id="402f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来在<code class="fe kz la lb lc b">app.js</code>中，我们将现有代码替换为:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="f2e2" class="mo le it lc b gy mp mq l mr ms">var createError = require("http-errors");<br/>var express = require("express");<br/>var path = require("path");<br/>var cookieParser = require("cookie-parser");<br/>var logger = require("morgan");<br/>var cors = require("cors");</span><span id="d225" class="mo le it lc b gy mu mq l mr ms">var indexRouter = require("./routes/index");<br/>var photosRouter = require("./routes/photos");</span><span id="9d60" class="mo le it lc b gy mu mq l mr ms">var app = express();</span><span id="1609" class="mo le it lc b gy mu mq l mr ms">// view engine setup<br/>app.set("views", path.join(__dirname, "views"));<br/>app.set("view engine", "jade");<br/>app.use(cors());</span><span id="2a78" class="mo le it lc b gy mu mq l mr ms">app.use(logger("dev"));<br/>app.use(express.json());<br/>app.use(express.urlencoded({ extended: false }));<br/>app.use(cookieParser());<br/>app.use(express.static(path.join(__dirname, "public")));<br/>app.use(express.static(path.join(__dirname, "uploads")));</span><span id="c36c" class="mo le it lc b gy mu mq l mr ms">app.use("/", indexRouter);<br/>app.use("/photos", photosRouter);</span><span id="8599" class="mo le it lc b gy mu mq l mr ms">// catch 404 and forward to error handler<br/>app.use(function(req, res, next) {<br/>  next(createError(404));<br/>});</span><span id="ecc2" class="mo le it lc b gy mu mq l mr ms">// error handler<br/>app.use(function(err, req, res, next) {<br/>  // set locals, only providing error in development<br/>  res.locals.message = err.message;<br/>  res.locals.error = req.app.get("env") === "development" ? err : {};</span><span id="40c4" class="mo le it lc b gy mu mq l mr ms">// render the error page<br/>  res.status(err.status || 500);<br/>  res.render("error");<br/>});</span><span id="1691" class="mo le it lc b gy mu mq l mr ms">module.exports = app;</span></pre><p id="0e20" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个文件中，我们添加了<code class="fe kz la lb lc b">app.use(cors());</code>来支持前端跨域请求到后端。我们用下面的代码将<code class="fe kz la lb lc b">photos</code>路由暴露给前端:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="875d" class="mo le it lc b gy mp mq l mr ms">var photosRouter = require(“./routes/photos”);<br/>app.use("/photos", photosRouter);</span></pre><p id="158c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加了一个静态路径路由来访问文件:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="34dd" class="mo le it lc b gy mp mq l mr ms">app.use(express.static(path.join(__dirname, "uploads")));</span></pre><p id="ed32" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">既然后端已经完成，我们可以继续进行前端。</p><h1 id="28e4" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">前端:用React上传文件</h1><p id="8b71" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">我们将使用React构建带有MobX的前端，用于简单的状态管理。为了创建框架代码，我们运行<code class="fe kz la lb lc b">npx create-react-app frontend</code>。</p><p id="4457" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们必须安装一些软件包。我们将安装MobX，用于样式化的Bootstrap，用于路由的React Router，分别用于表单值处理和表单验证的Formik和Yup，以及用于发出HTTP请求的Axios。</p><p id="7ca5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为此，运行<code class="fe kz la lb lc b">npm i axios bootstrap formik mobx mobx-react react-bootstrap react-router-dom yup</code>来安装所有的包。</p><p id="71bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">安装好所有的包后，我们就可以开始写代码了。首先，我们用以下代码替换<code class="fe kz la lb lc b">App.js</code>中的现有代码:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="f070" class="mo le it lc b gy mp mq l mr ms">import React from "react";<br/>import { Router, Route, Link } from "react-router-dom";<br/>import HomePage from "./HomePage";<br/>import TopBar from "./TopBar";<br/>import { createBrowserHistory as createHistory } from "history";<br/>import { photosStore } from "./store";<br/>const history = createHistory();</span><span id="029e" class="mo le it lc b gy mu mq l mr ms">function App() {<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;Router history={history}&gt;<br/>        &lt;TopBar /&gt;<br/>        &lt;Route<br/>          path="/"<br/>          exact<br/>          component={props =&gt; (<br/>            &lt;HomePage {...props} photosStore={photosStore} /&gt;<br/>          )}<br/>        /&gt;<br/>      &lt;/Router&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="8487" class="mo le it lc b gy mu mq l mr ms">export default App;</span></pre><p id="4998" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将添加一个顶栏，我们接下来将创建它，我们定义路由，以便当我们转到已定义的URL时，可以看到主页和地址生成器页面。</p><p id="7013" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来为我们的主页在<code class="fe kz la lb lc b">src</code>中创建<code class="fe kz la lb lc b">HomePage.js</code>。在其中，我们将显示条目表，其中包含名称、描述、照片以及用于打开添加/编辑照片表单和删除条目的按钮。</p><p id="c5aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在文件中，我们添加了:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="ce97" class="mo le it lc b gy mp mq l mr ms">import React, { useState, useEffect } from "react";<br/>import * as yup from "yup";<br/>import "./HomePage.css";<br/>import Modal from "react-bootstrap/Modal";<br/>import PhotoForm from "./PhotoForm";<br/>import Button from "react-bootstrap/Button";<br/>import Table from "react-bootstrap/Table";<br/>import { observer } from "mobx-react";<br/>import { getPhotos, deletePhoto, APIURL } from "./requests";</span><span id="efc3" class="mo le it lc b gy mu mq l mr ms">function HomePage({ photosStore }) {<br/>  const [show, setShow] = useState(false);<br/>  const [showEdit, setShowEdit] = useState(false);<br/>  const [initialized, setInitialized] = useState(false);<br/>  const [selectedPhoto, setSelectedPhoto] = useState({});<br/>  const handleClose = () =&gt; setShow(false);<br/>  const handleShow = () =&gt; setShow(true);</span><span id="47ff" class="mo le it lc b gy mu mq l mr ms">  const handleEditClose = () =&gt; setShowEdit(false);<br/>  const handleEditShow = photo =&gt; {<br/>    setSelectedPhoto(photo);<br/>    setShowEdit(true);<br/>  };</span><span id="2a72" class="mo le it lc b gy mu mq l mr ms">  const getAllPhotos = async () =&gt; {<br/>    const response = await getPhotos();<br/>    photosStore.setPhotos(response.data);<br/>  };</span><span id="8c64" class="mo le it lc b gy mu mq l mr ms">  const deletePhotoById = async id =&gt; {<br/>    await deletePhoto(id);<br/>    await getAllPhotos();<br/>  };</span><span id="67eb" class="mo le it lc b gy mu mq l mr ms">  const onSave = () =&gt; {<br/>    setShow(false);<br/>    setShowEdit(false);<br/>  };</span><span id="6bf0" class="mo le it lc b gy mu mq l mr ms">  useEffect(() =&gt; {<br/>    if (!initialized) {<br/>      getAllPhotos();<br/>      setInitialized(true);<br/>    }<br/>  });</span><span id="cc45" class="mo le it lc b gy mu mq l mr ms">  return (<br/>    &lt;div className="home-page"&gt;<br/>      &lt;h1&gt;Photos&lt;/h1&gt;<br/>      &lt;Button variant="primary" onClick={handleShow}&gt;<br/>        Add Photo<br/>      &lt;/Button&gt;</span><span id="9d2e" class="mo le it lc b gy mu mq l mr ms">      &lt;Table striped bordered hover style={{ marginTop: 10 }}&gt;<br/>        &lt;thead&gt;<br/>          &lt;tr&gt;<br/>            &lt;th&gt;Name&lt;/th&gt;<br/>            &lt;th&gt;Description&lt;/th&gt;<br/>            &lt;th&gt;Photo&lt;/th&gt;<br/>            &lt;th&gt;&lt;/th&gt;<br/>            &lt;th&gt;&lt;/th&gt;<br/>          &lt;/tr&gt;<br/>        &lt;/thead&gt;<br/>        &lt;tbody&gt;<br/>          {photosStore.photos.map((p, i) =&gt; {<br/>            const splitPath = p.photoPath.split("\\");<br/>            const path = splitPath[splitPath.length - 1];<br/>            return (<br/>              &lt;tr key={i}&gt;<br/>                &lt;td&gt;{p.name}&lt;/td&gt;<br/>                &lt;td&gt;{p.description}&lt;/td&gt;<br/>                &lt;td&gt;<br/>                  &lt;img src={`${APIURL}/${path}`} style={{ width: 200 }} /&gt;<br/>                &lt;/td&gt;<br/>                &lt;td&gt;<br/>                  &lt;Button onClick={handleEditShow.bind(this, p)}&gt;Edit&lt;/Button&gt;<br/>                &lt;/td&gt;<br/>                &lt;td&gt;<br/>                  &lt;Button onClick={deletePhotoById.bind(this, p.id)}&gt;<br/>                    Delete<br/>                  &lt;/Button&gt;<br/>                &lt;/td&gt;<br/>              &lt;/tr&gt;<br/>            );<br/>          })}<br/>        &lt;/tbody&gt;<br/>      &lt;/Table&gt;</span><span id="cf81" class="mo le it lc b gy mu mq l mr ms">      &lt;Modal show={show} onHide={handleClose}&gt;<br/>        &lt;Modal.Header closeButton&gt;<br/>          &lt;Modal.Title&gt;Add Photo&lt;/Modal.Title&gt;<br/>        &lt;/Modal.Header&gt;</span><span id="adc8" class="mo le it lc b gy mu mq l mr ms">        &lt;Modal.Body&gt;<br/>          &lt;PhotoForm<br/>            edit={false}<br/>            photosStore={photosStore}<br/>            onSave={onSave.bind(this)}<br/>          /&gt;<br/>        &lt;/Modal.Body&gt;<br/>      &lt;/Modal&gt;</span><span id="01ae" class="mo le it lc b gy mu mq l mr ms">     &lt;Modal show={showEdit} onHide={handleEditClose}&gt;<br/>        &lt;Modal.Header closeButton&gt;<br/>          &lt;Modal.Title&gt;Edit Photo&lt;/Modal.Title&gt;<br/>        &lt;/Modal.Header&gt;</span><span id="652e" class="mo le it lc b gy mu mq l mr ms">        &lt;Modal.Body&gt;<br/>          &lt;PhotoForm<br/>            edit={true}<br/>            photosStore={photosStore}<br/>            selectedPhoto={selectedPhoto}<br/>            onSave={onSave.bind(this)}<br/>          /&gt;<br/>        &lt;/Modal.Body&gt;<br/>      &lt;/Modal&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="1301" class="mo le it lc b gy mu mq l mr ms">export default observer(HomePage);</span></pre><p id="ff6d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">Table</code>由React Bootstrap提供。我们只是在自己的行中显示每个条目。条目由我们将要创建的MobX商店提供。模态包含<code class="fe kz la lb lc b">PhotoForm</code>，它有所有用于操作照片的输入。我们将使用它进行添加和编辑，所以我们需要传入<code class="fe kz la lb lc b">edit</code>属性来区分添加和编辑。我们还传入了一个<code class="fe kz la lb lc b">onSave</code>函数，这样我们就可以关闭模态。如果选择了一个条目进行编辑，我们还会传入<code class="fe kz la lb lc b">selectedPhoto</code> prop，它包含用户正在编辑的条目。</p><p id="66ac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们构建照片表单。在<code class="fe kz la lb lc b">src</code>文件夹中创建一个名为<code class="fe kz la lb lc b">PhotoForm.js</code>的文件，并添加:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="d834" class="mo le it lc b gy mp mq l mr ms">import React from "react";<br/>import { useEffect, useState } from "react";<br/>import { Formik } from "formik";<br/>import Form from "react-bootstrap/Form";<br/>import Col from "react-bootstrap/Col";<br/>import Button from "react-bootstrap/Button";<br/>import * as yup from "yup";<br/>import "./PhotoForm.css";<br/>import { getPhotos, addPhoto, editPhoto } from "./requests";<br/>import { observer } from "mobx-react";</span><span id="9ce5" class="mo le it lc b gy mu mq l mr ms">const schema = yup.object({<br/>  name: yup.string().required("Name is required"),<br/>  description: yup.string().required("Description is required")<br/>});</span><span id="0eaa" class="mo le it lc b gy mu mq l mr ms">function PhotoForm({ photosStore, edit, selectedPhoto, onSave }) {<br/>  const fileUpload = React.createRef();<br/>  const [photo, setPhoto] = useState(null);<br/>  const [fileName, setFileName] = useState("");<br/>  const getAllPhotos = async () =&gt; {<br/>    const response = await getPhotos();<br/>    photosStore.setPhotos(response.data);<br/>  };</span><span id="6bcc" class="mo le it lc b gy mu mq l mr ms">  const handleSubmit = async evt =&gt; {<br/>    const isValid = await schema.validate(evt);<br/>    if (!isValid) {<br/>      return;<br/>    }<br/>    try {<br/>      let bodyFormData = new FormData();<br/>      if (!edit) {<br/>        bodyFormData.set("name", evt.name);<br/>        bodyFormData.set("description", evt.description);<br/>        bodyFormData.append("photo", photo);<br/>        await addPhoto(bodyFormData);<br/>      } else {<br/>        bodyFormData.set("id", selectedPhoto.id);<br/>        bodyFormData.set("name", evt.name);<br/>        bodyFormData.set("description", evt.description);<br/>        if (photo) {<br/>          bodyFormData.append("photo", photo);<br/>        }<br/>        await editPhoto(bodyFormData);<br/>      }<br/>    } catch (error) {<br/>      alert("Upload must be an image");<br/>    }</span><span id="8aef" class="mo le it lc b gy mu mq l mr ms">  await getAllPhotos();<br/>    onSave();<br/>  };</span><span id="744e" class="mo le it lc b gy mu mq l mr ms">  const setFile = evt =&gt; {<br/>    setPhoto(evt.target.files[0]);<br/>    setFileName(evt.target.files[0].name);<br/>  };</span><span id="6ee5" class="mo le it lc b gy mu mq l mr ms">  const openUploadDialog = () =&gt; {<br/>    fileUpload.current.click();<br/>  };</span><span id="361d" class="mo le it lc b gy mu mq l mr ms">  return (<br/>    &lt;div&gt;<br/>      &lt;Formik<br/>        validationSchema={schema}<br/>        onSubmit={handleSubmit}<br/>        initialValues={edit ? selectedPhoto : {}}<br/>      &gt;<br/>        {({<br/>          handleSubmit,<br/>          handleChange,<br/>          handleBlur,<br/>          values,<br/>          touched,<br/>          isInvalid,<br/>          errors<br/>        }) =&gt; (<br/>          &lt;Form noValidate onSubmit={handleSubmit}&gt;<br/>            &lt;Form.Row&gt;<br/>              &lt;Form.Group as={Col} md="12" controlId="name"&gt;<br/>                &lt;Form.Label&gt;Name&lt;/Form.Label&gt;<br/>                &lt;Form.Control<br/>                  type="text"<br/>                  name="name"<br/>                  placeholder="Name"<br/>                  value={values.name || ""}<br/>                  onChange={handleChange}<br/>                  isInvalid={touched.name &amp;&amp; errors.name}<br/>                /&gt;<br/>                &lt;Form.Control.Feedback type="invalid"&gt;<br/>                  {errors.name}<br/>                &lt;/Form.Control.Feedback&gt;<br/>              &lt;/Form.Group&gt;<br/>              &lt;Form.Group as={Col} md="12" controlId="description"&gt;<br/>                &lt;Form.Label&gt;Description&lt;/Form.Label&gt;<br/>                &lt;Form.Control<br/>                  type="text"<br/>                  name="description"<br/>                  placeholder="Description"<br/>                  value={values.description || ""}<br/>                  onChange={handleChange}<br/>                  isInvalid={touched.description &amp;&amp; errors.description}<br/>                /&gt;</span><span id="7fe0" class="mo le it lc b gy mu mq l mr ms">&lt;Form.Control.Feedback type="invalid"&gt;<br/>                  {errors.description}<br/>                &lt;/Form.Control.Feedback&gt;<br/>              &lt;/Form.Group&gt;<br/>            &lt;/Form.Row&gt;<br/>            &lt;Form.Row&gt;<br/>              &lt;Form.Group as={Col} md="12" controlId="photo"&gt;<br/>                &lt;input<br/>                  type="file"<br/>                  ref={fileUpload}<br/>                  name="photo"<br/>                  style={{ display: "none" }}<br/>                  onChange={setFile}<br/>                /&gt;<br/>                &lt;div className="file-box"&gt;<br/>                  &lt;Button type="button" onClick={openUploadDialog}&gt;<br/>                    Upload Photo<br/>                  &lt;/Button&gt;<br/>                  &lt;span style={{ paddingLeft: "10px", marginTop: "5px" }}&gt;<br/>                    {fileName}<br/>                  &lt;/span&gt;<br/>                &lt;/div&gt;<br/>              &lt;/Form.Group&gt;<br/>            &lt;/Form.Row&gt;<br/>            &lt;Button type="submit" style={{ marginRight: "10px" }}&gt;<br/>              Save<br/>            &lt;/Button&gt;<br/>          &lt;/Form&gt;<br/>        )}<br/>      &lt;/Formik&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="9241" class="mo le it lc b gy mu mq l mr ms">export default observer(PhotoForm);</span></pre><p id="da93" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个文件中，我们有用于获取照片文件的文件输入和用于名称和描述的表单字段。为了获取文件，我们将<code class="fe kz la lb lc b">setFile</code>函数传递到文件输入的<code class="fe kz la lb lc b">onChange</code>属性中，在这里我们通过使用<code class="fe kz la lb lc b">ev.target.files[0]</code>来获取文件对象。<code class="fe kz la lb lc b">[0]</code>表示我们只想要第一个文件。</p><p id="e34d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将React Boostrap表单包装在<code class="fe kz la lb lc b">Formik</code>组件中，以自动处理表单值，这将在<code class="fe kz la lb lc b">handleSubmit</code>函数的参数中可用。在该函数中，我们用<code class="fe kz la lb lc b">schema.validation</code>函数验证文本输入。然后我们将文本数据和文件添加到<code class="fe kz la lb lc b">FormData</code>对象中。添加完所有内容后，我们通过HTTP将<code class="fe kz la lb lc b">FormData</code>对象提交给我们的后端。</p><p id="f718" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">之后，我们调用<code class="fe kz la lb lc b">getAllPhotos</code>来获取最新的数据，并在我们的MobX存储中设置新的数据。然后我们调用从<code class="fe kz la lb lc b">HomePage</code>传入的<code class="fe kz la lb lc b">onSave</code>函数，这样我们就可以在一切完成后关闭对话框。</p><p id="e3a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来创建<code class="fe kz la lb lc b">PhotoForm.css</code>并添加:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="7094" class="mo le it lc b gy mp mq l mr ms">.file-box {<br/>  display: flex;<br/>}</span></pre><p id="bb2a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后在<code class="fe kz la lb lc b">src</code>文件夹中创建<code class="fe kz la lb lc b">requests.js</code>，并添加:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="3eef" class="mo le it lc b gy mp mq l mr ms">const axios = require("axios");<br/>export const APIURL = "<a class="ae mt" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a>";</span><span id="3ce5" class="mo le it lc b gy mu mq l mr ms">export const getPhotos = () =&gt; axios.get(`${APIURL}/photos`);</span><span id="73ba" class="mo le it lc b gy mu mq l mr ms">export const addPhoto = data =&gt;<br/>  axios({<br/>    method: "post",<br/>    url: `${APIURL}/photos/add`,<br/>    data,<br/>    config: { headers: { "Content-Type": "multipart/form-data" } }<br/>  });</span><span id="eaa7" class="mo le it lc b gy mu mq l mr ms">export const editPhoto = data =&gt;<br/>  axios({<br/>    method: "put",<br/>    url: `${APIURL}/photos/edit`,<br/>    data,<br/>    config: { headers: { "Content-Type": "multipart/form-data" } }<br/>  });</span><span id="1019" class="mo le it lc b gy mu mq l mr ms">export const deletePhoto = id =&gt; axios.delete(`${APIURL}/photos/delete/${id}`);</span></pre><p id="9d44" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要这些函数将请求发送到后端。注意，我们在post中使用了<code class="fe kz la lb lc b">config: { headers: { “Content-Type”: “multipart/form-data” } }</code>,因此我们将表单数据而不是默认的JSON发送到后端。表单数据可以包含文件，但JSON不能。</p><p id="2c9c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们创建MobX商店。创建一个名为<code class="fe kz la lb lc b">store.js</code>的文件，并添加:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="6980" class="mo le it lc b gy mp mq l mr ms">import { observable, action, decorate } from "mobx";</span><span id="3a88" class="mo le it lc b gy mu mq l mr ms">class PhotosStore {<br/>  photos = [];</span><span id="0556" class="mo le it lc b gy mu mq l mr ms">  setPhotos(photos) {<br/>    this.photos = photos;<br/>  }<br/>}</span><span id="1230" class="mo le it lc b gy mu mq l mr ms">PhotosStore = decorate(PhotosStore, {<br/>  photos: observable,<br/>  setPhotos: action<br/>});</span><span id="bc30" class="mo le it lc b gy mu mq l mr ms">const photosStore = new PhotosStore();</span><span id="c012" class="mo le it lc b gy mu mq l mr ms">export { photosStore };</span></pre><p id="25dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有函数<code class="fe kz la lb lc b">setPhotos</code>将照片数据放入存储中，我们在<code class="fe kz la lb lc b">HomePage</code>和<code class="fe kz la lb lc b">PhotoForm</code>中使用了这个函数，我们在导出之前对它进行了实例化，这样我们只需在一个地方完成它。</p><p id="3c5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们通过在<code class="fe kz la lb lc b">src</code>文件夹中创建一个<code class="fe kz la lb lc b">TopBar.js</code>文件来创建顶栏，并添加:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="2600" class="mo le it lc b gy mp mq l mr ms">import React from "react";<br/>import Navbar from "react-bootstrap/Navbar";<br/>import Nav from "react-bootstrap/Nav";<br/>import { withRouter } from "react-router-dom";</span><span id="5475" class="mo le it lc b gy mu mq l mr ms">function TopBar({ location }) {<br/>  const { pathname } = location;</span><span id="df89" class="mo le it lc b gy mu mq l mr ms">  return (<br/>    &lt;Navbar bg="primary" expand="lg" variant="dark"&gt;<br/>      &lt;Navbar.Brand href="#home"&gt;Photo App&lt;/Navbar.Brand&gt;<br/>      &lt;Navbar.Toggle aria-controls="basic-navbar-nav" /&gt;<br/>      &lt;Navbar.Collapse id="basic-navbar-nav"&gt;<br/>        &lt;Nav className="mr-auto"&gt;<br/>          &lt;Nav.Link href="/" active={pathname == "/"}&gt;<br/>            Home<br/>          &lt;/Nav.Link&gt;<br/>        &lt;/Nav&gt;<br/>      &lt;/Navbar.Collapse&gt;<br/>    &lt;/Navbar&gt;<br/>  );<br/>}</span><span id="d4d2" class="mo le it lc b gy mu mq l mr ms">export default withRouter(TopBar);</span></pre><p id="f629" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这包含了React引导程序<code class="fe kz la lb lc b">Navbar</code>来显示一个带有主页链接和应用程序名称的顶栏。</p><p id="fb52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，在<code class="fe kz la lb lc b">index.html</code>中，我们将现有代码替换为:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="2b81" class="mo le it lc b gy mp mq l mr ms">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="utf-8" /&gt;<br/>    &lt;link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" /&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;<br/>    &lt;meta name="theme-color" content="#000000" /&gt;<br/>    &lt;meta<br/>      name="description"<br/>      content="Web site created using create-react-app"<br/>    /&gt;<br/>    &lt;link rel="apple-touch-icon" href="logo192.png" /&gt;<br/>    &lt;!--<br/>      manifest.json provides metadata used when your web app is installed on a<br/>      user's mobile device or desktop. See <a class="ae mt" href="https://developers.google.com/web/fundamentals/web-app-manifest/" rel="noopener ugc nofollow" target="_blank">https://developers.google.com/web/fundamentals/web-app-manifest/</a><br/>    --&gt;<br/>    &lt;link rel="manifest" href="%PUBLIC_URL%/manifest.json" /&gt;<br/>    &lt;!--<br/>      Notice the use of %PUBLIC_URL% in the tags above.<br/>      It will be replaced with the URL of the `public` folder during the build.<br/>      Only files inside the `public` folder can be referenced from the HTML.</span><span id="753f" class="mo le it lc b gy mu mq l mr ms">Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will<br/>      work correctly both with client-side routing and a non-root public URL.<br/>      Learn how to configure a non-root public URL by running `npm run build`.<br/>    --&gt;<br/>    &lt;title&gt;Photo App&lt;/title&gt;<br/>    &lt;link<br/>      rel="stylesheet"<br/>      href="<a class="ae mt" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="noopener ugc nofollow" target="_blank">https://maxcdn.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css</a>"<br/>      integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T"<br/>      crossorigin="anonymous"<br/>    /&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;<br/>    &lt;div id="root"&gt;&lt;/div&gt;<br/>    &lt;!--<br/>      This HTML file is a template.<br/>      If you open it directly in the browser, you will see an empty page.</span><span id="9f93" class="mo le it lc b gy mu mq l mr ms">You can add webfonts, meta tags, or analytics to this file.<br/>      The build step will place the bundled scripts into the &lt;body&gt; tag.</span><span id="f9a2" class="mo le it lc b gy mu mq l mr ms">To begin the development, run `npm start` or `yarn start`.<br/>      To create a production bundle, use `npm run build` or `yarn build`.<br/>    --&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="258d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将在<code class="fe kz la lb lc b">link</code>标签中添加引导CSS文件，并更改应用程序的标题。</p><p id="f6ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">写完所有代码后，我们就可以运行我们的应用程序了。首先通过运行<code class="fe kz la lb lc b">backend</code>文件夹中的<code class="fe kz la lb lc b">npm start</code>和<code class="fe kz la lb lc b">frontend</code>文件夹中的<code class="fe kz la lb lc b">npm start</code>来启动后端，然后如果要求您从不同的端口运行它，请选择<code class="fe kz la lb lc b">‘yes’</code>。</p><p id="d229" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后你会得到:</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d72f70026e66b13c03e6e0d7706fd42e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yf3d9yQ-7ieayccxxUzXlw.png"/></div></div></figure><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/0bf80fdd0c6a72e9c83ec5fe23a1fa9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BaiJ8JH_TTiD0k6w2wj-mg.png"/></div></div></figure><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7ee77b42ba01134f9693ec4cb85756e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JDP1oHB1C9mc_LMsc5u_dg.png"/></div></div></figure></div></div>    
</body>
</html>