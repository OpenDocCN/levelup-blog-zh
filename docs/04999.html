<html>
<head>
<title>Patterns in Algorithm Design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法设计中的模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/patterns-in-algorithm-design-17b327167c5e?source=collection_archive---------3-----------------------#2020-07-29">https://levelup.gitconnected.com/patterns-in-algorithm-design-17b327167c5e?source=collection_archive---------3-----------------------#2020-07-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="528c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">焦躁不可，因有</em> <strong class="jp ir"> <em class="kl">韵&amp;故</em> </strong> <em class="kl">以此癫狂！</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/7c3d0d69f7b440ae7286b2ceee679887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/0*vKoM9piAMvTuXdFv.jpg"/></div></figure><p id="ab90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为面试和你在实现算法上的虔诚而感到紧张？别担心，我是来给你新希望的。</p><p id="8a4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">算法是我们这个世界的面包和黄油，在技术面试中，它们非常重要！事实上，如果你没有很好地掌握数据结构和算法，你就不能指望在技术面试中走得远。许多人认为他们是招聘过程中不必要的祸害，并认为这些技能不能转化为实际的软件开发。虽然算法确实没有包含软件工程的所有内容，但我把它们视为我技能组合中的另一个工具。当你需要应用算法分析来设计系统和扩展它们时，这个工具就变得必要了。这并不总是意味着采用某种复杂的方式编写代码，而是要意识到，如果可以在O(n)时间内完成，那么嵌套的for循环可能不是从100，000个元素的列表中获取信息的最佳方式。这些权衡对你的代码的性能有真正的影响。从我的经验来看，在广泛研究算法(从破解编码面试到Leetcode的一切)之后，我发现我的代码更加简洁明了。我在解决问题的时候，也会花很多时间去阅读和理解别人的解决方案。在这个过程中，我可能已经从数百种其他人的编码风格中挑选了最好的部分。</p><p id="e01f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然我已经解释了为什么学习数据结构和算法是重要的，我想用这篇文章的剩余部分来谈论一些算法模式和实例，在这些算法模式和实例中，我个人能够解决问题是因为我在头脑中开发了这些模式。让我们从解决问题时可以利用的一些基本模式开始:</p><ol class=""><li id="22c2" class="ku kv iq jp b jq jr ju jv jy kw kc kx kg ky kk kz la lb lc bi translated"><strong class="jp ir">频率计数模式</strong> —您可以使用一个对象/贴图来收集一个值及其频率，这对于比较多条数据的算法非常有用。这种模式让我们在处理字符串/数组时避免了O(n)时间复杂度。</li><li id="f200" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated"><strong class="jp ir">多指针模式</strong> —你可以保存指向数组不同部分的变量。拥有多个指针有助于避免O(n)时间复杂度，例如，如果你想从一个有序数组中的一对数字计算一个目标和。你可以在数组的开头和结尾都有一个指针，你可以在每次迭代时移动指针。这将把时间复杂度降低到O(n)。</li><li id="d60f" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated"><strong class="jp ir">滑动窗口模式</strong> —包括从一个位置到另一个位置从一个数组或数字创建一个窗口。根据特定条件，车窗将增大或减小车窗。这对于跟踪数据子集很有用。</li><li id="8077" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated"><strong class="jp ir">分而治之</strong> —你取一个较大的数据集，比如一个数组，把它分成较小的块，然后重复这个过程。使用这种技术的最流行的算法之一是二分搜索法，在每次迭代中你将数据集减半。然而，二分搜索法只处理一组经过排序的数据。时间复杂度是O(logN ),因为你每次都减半(<em class="kl"> log in Big O表示法同意以2为基数)。</em></li></ol><p id="9bdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将讨论三个例子，在这些例子中，我能够使用我在头脑中建立的模式来快速识别和解决问题。</p><p id="c8a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我遇到的第一个例子是Leetcode六月每日挑战中的一个问题:随机选择权重。这个问题给了我一种“代码的味道”,这是理所当然的，因为我最近在CodeForces上用同样的技术做了另一个问题:二分搜索法！</p><p id="37eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CodeForces问题如下:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi li"><img src="../Images/a1ce466e26eaec2d67ba6a37200d2a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CvoV-YHCa5eOErvNv2bCdw.png"/></div></div></figure><p id="ae82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您意识到单个蠕虫的索引是按顺序排列的，因此是“排序的”时，这个问题就变得简单了。一旦你意识到这一点，你可以调整你的二分搜索法来检查它在搜索中的索引范围。我的解决方案的代码如下:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ln"><img src="../Images/1d3d20ffd006ff86c7a0efae021559b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y3W2e1cu2rPLmo1YppDadQ.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">原谅var，Codeforces已经过时了:)</figcaption></figure><p id="9659" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Leetcode问题如下:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ls"><img src="../Images/8af6bedb0e3d94f81d7f17f78b49d874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ufYpAakKXWUNkTS_ljtk_Q.png"/></div></div></figure><p id="51f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用math . floor(math . random()* arr . length)来创建一个从列表中返回随机元素的函数非常简单。然而，在加权方面的加入使问题变得更加困难。我开始意识到，类似于蠕虫问题，我可以用范围来表示各个元素的权重，并使用二分搜索法！利用这些知识，我能够很快想出一个解决方案。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi lt"><img src="../Images/d87bd8784ee26de2f09d4ebf08caa013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nT0wd37xBiNaLsguueRyZw.png"/></div></div></figure><p id="3170" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我注意到一个模式的第二个例子是最近在彭博的一次面试(没有得到工作机会🙁，但我通过了所有技术轮次)。在这个问题上，我的面试官说:“我向你保证，这个字符串中的所有括号都是平衡的。”这立即引起了我的注意，我的蜘蛛感官尖叫着“栈！堆栈！堆栈！”这个问题有点类似于我最近做的一个问题，我应该根据括号返回一个字符串是否有效:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi lu"><img src="../Images/51e19efd9a39ee65b73b0014bf696141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ueHuOyWCWztx-wrJPwPELA.png"/></div></div></figure><p id="bdf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在面试中遇到的问题会给出类似的输入/输出</p><p id="48e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl"> input = "he{co(d)e}s "，output = 'd' </em> </strong></p><p id="34e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我遇到的问题要求我在“最深层次”返回字符串最深层是嵌套括号的最深层。我为这种方法提出的解决方案是基于我不必担心不平衡的括号。这意味着我可以使用堆栈来跟踪左括号和右括号，并在遍历字符串时记录不同级别的字符串(将它们存储在map中)。如果我没有在面试一开始就意识到这一点，我可能不会这么快就想出一个解决方案。</p><p id="58e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第三个例子是我今天实际做的一个问题，我成功地发现了一个模式(可能是这个问题最终让我站起来写了这个主题)。问题如下:</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><p id="69a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">冬天来了！你在比赛期间的第一项工作是设计一个标准的加热器，具有固定的取暖半径，为所有的房子供暖。现在，给你房子和加热器在一条水平线上的位置，找出加热器的最小半径，这样所有的房子都可以被这些加热器覆盖。因此，您的输入将分别是房屋和加热器的位置，而您的预期输出将是加热器的最小半径标准。</p><p id="c3aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注:</strong></p><ol class=""><li id="7d60" class="ku kv iq jp b jq jr ju jv jy kw kc kx kg ky kk kz la lb lc bi translated">给你的房子和加热器的数量是非负数，不会超过25000。</li><li id="6f2b" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">给你的房子和取暖器的位置是非负的，不会超过10⁹.</li><li id="4205" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">只要房子在加热器的温暖半径范围内，它就能被加热。</li><li id="1db9" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">所有的加热器都遵循你的半径标准，温暖的半径是一样的。</li></ol><p id="9d32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例一:</strong></p><pre class="kn ko kp kq gt mc md me mf aw mg bi"><span id="e960" class="mh mi iq md b gy mj mk l ml mm">Input: [1,2,3],[2]<br/>Output: 1<br/>Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.</span></pre><p id="a9cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例2: </strong></p><pre class="kn ko kp kq gt mc md me mf aw mg bi"><span id="8286" class="mh mi iq md b gy mj mk l ml mm">Input: [1,2,3,4],[1,4]<br/>Output: 1<br/>Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.</span></pre></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><p id="bb57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个问题让我想起了我在CodeForces上做过的一个问题，你必须根据街道上灯笼发出的光的半径来确保街道得到适当的照明。问题如下:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi mn"><img src="../Images/a712500e1f40925a0d3e9387dbbedbdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RqFivPNmSMF0qy1Ak2B8mg.png"/></div></div></figure><p id="b7cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">加热器问题基本上与提灯问题相同，因为它们具有相同的基本要求(获得最小半径，以便加热所有房屋/照亮整条街道)。您可以在下面看到上述问题的相应解决方案:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi mo"><img src="../Images/8dcabfc3ed2cfe2aca0bcc5c41d8f57c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sHDg-Rv956doNNAPqHGA6A.png"/></div></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi mp"><img src="../Images/51175e596ce5ea7b1575280ba27b5d66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2EUTtJ5ZllLLXXHy-ekxyQ.png"/></div></div></figure><p id="9a62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目前就这些，如果你一直对自己的进步感到怀疑/绝望，我希望这篇文章能帮助激励你。如果你学习和练习基于不同类别的算法，如排序、动态规划、字符串、图形、设计等。，你会发现你提高的更快。此外，使用本文中的技术将为您解决问题打下良好的基础。请继续学习，并意识到隧道尽头有光！</p><p id="251f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">敬请关注数据结构&amp;算法系列的后续文章！</em></p><p id="8695" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">(还有，我在找工作！有工程师职位空缺吗？请联系https://www.linkedin.com/in/hassan-b-malik/</em><a class="ae mq" href="https://www.linkedin.com/in/hassan-b-malik/" rel="noopener ugc nofollow" target="_blank"><em class="kl"/></a><em class="kl">)</em></p></div></div>    
</body>
</html>