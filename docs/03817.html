<html>
<head>
<title>Middlewares for Golang web apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang web应用程序的中间件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/middlewares-for-golang-web-apps-8742e28eef6e?source=collection_archive---------4-----------------------#2020-05-28">https://levelup.gitconnected.com/middlewares-for-golang-web-apps-8742e28eef6e?source=collection_archive---------4-----------------------#2020-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9304" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建处理请求的管道</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/162f2724c198e66423167a1b5f7f2c15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X8uYT6upQLVbxnj5"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@gieling?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">雷米·卢多·吉林</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="344f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用web应用程序时，如web API、网站或任何公开web服务器并处理请求的应用程序，最常见的行为是以不同的方式处理每个URL。返回不同的网页，将数据保存在存储器中，以JSON的形式获取和返回数据，等等。</p><p id="f357" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，一些任务需要被执行，而不管你以一种通用的方式接收到的请求。复制和粘贴代码或者调用一个单独的函数，虽然是一种选择，但不是解决这个问题的最佳方式。这种方法的一个问题是代码重复，另一个问题是人为错误。也许一些开发人员忘记添加对为给定URL收集指标的函数的调用，或者记录错误。那以后会引起一些头痛。大时代。作为解决这个问题的另一种方法，我们可以使用<em class="lv">中间件。</em></p><p id="5428" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用中间件的主要区别在于，您创建了一段通用代码，并将其注册到HTTP执行管道中。这样，您不必担心在您创建的每个处理程序中调用通用代码，也不会有代码重复。听起来很有希望，不是吗？</p><p id="ce1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个概念并不是<strong class="lb iu"> golang </strong>，<strong class="lb iu">ASP.NET</strong>使用完全相同的概念。因此，学习这项技术不仅对go开发人员有用，而且对任何使用web应用程序的人都有用。</p><h2 id="6375" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">了解HTTP执行管道</h2><p id="7164" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">在golang中，HTTP请求处理逻辑像管道一样工作。在最基本的场景中，您将为每个想要处理的URL创建一个函数。在这些情况下，至少会发生两件事:</p><ol class=""><li id="8362" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">将从请求中提取url，并与您注册处理的所有url模式进行匹配；</li><li id="2ab9" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">将执行与匹配模式相关联的功能；</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">代码摘自我的<a class="ae ky" href="https://medium.com/swlh/hedged-requests-tackling-tail-latency-9cea0a05f577" rel="noopener">对冲请求</a>文章</figcaption></figure><p id="07f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个简单的例子，这个服务器收到的每个请求将执行上面的步骤1，当请求上的URL是<code class="fe nk nl nm nn b">/ishealthy</code>时，函数(在这个例子中是匿名的)将被执行(步骤2)。</p><p id="2a85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于一个简单的服务器来说，这很好，但是在现实世界的应用程序中，甚至在执行函数之前，就需要发生一些普通的事情。您可能希望添加到所有请求(或一组请求)中的一般内容有:授权、日志记录、指标收集、HTTP头操作等等。实现这一点的一种方法是使用中间件。包<a class="ae ky" href="https://github.com/gorilla/mux" rel="noopener ugc nofollow" target="_blank"> gorrila mux </a>非常明确地使用了这种技术。这就是为什么我要用它来实现这些例子。但是，如果您愿意，也可以只使用带有<code class="fe nk nl nm nn b">http.Handler</code>函数的标准包来手动创建执行管道。</p><h2 id="b91e" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">中间件</h2><p id="1c9c" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">中间件和整个HTTP执行管道背后的模式是创建一个接收下一个处理程序作为参数的<code class="fe nk nl nm nn b">http.Handler</code>。就像装饰图案一样。因此，<code class="fe nk nl nm nn b">MiddlewareFunc</code>的签名是<code class="fe nk nl nm nn b">type MiddlewareFunc func(http.Handler) http.Handler</code>。这意味着在您的中间件内部，您不需要知道下一个要执行的是哪个处理程序，您只需要在完成工作后执行它。这是一个非常好的关注点的抽象和隔离。注册你想要使用的中间件的方法是从路由器调用函数<code class="fe nk nl nm nn b">Use</code>。</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="ffaa" class="lw lx it nn b gy ns nt l nu nv">router := mux.NewRouter()<br/>router.Use(middleware)</span></pre><p id="2163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注册中间件的顺序就是它们将要执行的顺序(在到达URL模式的处理程序之前)。每个中间件的代码通常由一个闭包组成，这个闭包对作为参数传递给它的<code class="fe nk nl nm nn b">http.ResponseWriter</code>和<code class="fe nk nl nm nn b">http.Request</code>做一些事情，然后调用管道上的下一个处理程序。这里有一个简单中间件的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="9676" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nn b">loggingMiddleware</code>函数是中间件实现。正如我们所看到的，这个中间件记录了所请求的URL(第25行)，执行下一个处理程序(第26行)，并记录请求在此之后已经完成。这就是这种技术如此强大的原因，您可以完全控制想要执行什么以及何时执行。在这种情况下，管道上所有剩余的处理程序将在到达第27行之前执行。中间件注册在<code class="fe nk nl nm nn b">main</code>函数上(第12行)。如果我们在本地执行这段代码并请求<code class="fe nk nl nm nn b">/ishealthy</code> URL，我们会在控制台上看到如下内容:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="8e98" class="lw lx it nn b gy ns nt l nu nv">2020/05/26 14:56:29 Url requested: /ishealthy<br/>2020/05/26 14:56:29 Returning 200 - Healthy<br/>2020/05/26 14:56:29 Request finished</span></pre><p id="a2d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">中间件功能的签名是非常有限的，在真实的场景中，你可能需要注入一些东西来使它更有用，为此，我写了一篇文章来解释一个非常简单却非常强大的技术，用于go 中的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/dependency-injection-in-go-using-receiver-functions-d76b7e541ecd">依赖注入。</a></p><h2 id="5424" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">子路由器的中间件</h2><p id="a56c" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">gorila mux的一个非常好的特性是能够基于路径前缀创建子路由器，并向它们注册中间件。这意味着，如果您愿意，您可以拥有稍微不同的HTTP执行管道。同时，你也可以共享一些通用的中间件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="5abf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个例子，我们添加了两个新的URL<code class="fe nk nl nm nn b">/sub/a</code>和<code class="fe nk nl nm nn b">/sub/b</code>，每个都有自己的处理函数。为了处理这些URL，我们添加了一个子路由器(第16行),并且我们创建了另一个叫做<code class="fe nk nl nm nn b">subMiddleware</code>的中间件，你可以在第41行找到它。这个中间件只为子路由器注册(第17行)。这意味着只有由子路由器处理的URL将执行<code class="fe nk nl nm nn b">subMiddleware</code>。然而，由于<code class="fe nk nl nm nn b">loggingMiddleware</code>是在主路由器上注册的，子路由器将继承该配置。让我们调用这些URL来看看不同之处。</p><p id="d528" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用<code class="fe nk nl nm nn b">/ishealthy</code>在控制台上打印以下内容:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="a84c" class="lw lx it nn b gy ns nt l nu nv">2020/05/26 16:31:33 Url requested: /ishealthy<br/>2020/05/26 16:31:33 Returning 200 - Healthy<br/>2020/05/26 16:31:33 Request finished</span></pre><p id="cae1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里没有什么新东西，这个URL的HTTP执行没有改变。意思是HTTP执行管道看起来像<code class="fe nk nl nm nn b">loggingMiddleware</code> - &gt; <code class="fe nk nl nm nn b">handleIsHelthy</code>。</p><p id="05f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用<code class="fe nk nl nm nn b">/sub/a</code>打印如下:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="80c8" class="lw lx it nn b gy ns nt l nu nv">2020/05/26 16:32:42 Url requested: /sub/a<br/><strong class="nn iu">2020/05/26 16:32:42 Another middleware</strong><br/>2020/05/26 16:32:42 Returning 200 - Healthy a<br/>2020/05/26 16:32:42 Request finished</span></pre><p id="3bad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这次我们可以看到<code class="fe nk nl nm nn b">subMiddleware</code>是在<code class="fe nk nl nm nn b">loggingMiddleware</code>之后被调用的。意思是HTTP执行管道看起来像<code class="fe nk nl nm nn b">loggingMiddleware</code>-&gt;-<code class="fe nk nl nm nn b">subMiddleware</code>-&gt;-<code class="fe nk nl nm nn b">handleIsHealthyA</code>。</p><p id="e3ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后调用<code class="fe nk nl nm nn b">/sub/b</code>打印以下内容:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="4410" class="lw lx it nn b gy ns nt l nu nv">2020/05/26 16:32:50 Url requested: /sub/b<br/><strong class="nn iu">2020/05/26 16:32:50 Another middleware</strong><br/>2020/05/26 16:32:50 Returning 200 - Healthy b<br/>2020/05/26 16:32:50 Request finished</span></pre><p id="a40b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与之前的行为相同，本例中的管道是<code class="fe nk nl nm nn b">loggingMiddleware</code>-&gt;-<code class="fe nk nl nm nn b">subMiddleware</code>-&gt;-<code class="fe nk nl nm nn b">handleIsHealthyB</code>。</p><p id="4d56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用中间件创建了两个不同的执行管道。例如，在我们的web应用程序中有私有和公共部分的情况下，这是很常见的。为了解决这个问题，我们可以有一个子路由器，它封装了处理授权的逻辑，所有这些都非常明确和独立，并且只应用于我们应用程序的私有部分。我希望你会发现这种技术对你的下一个项目有用！</p></div></div>    
</body>
</html>