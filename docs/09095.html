<html>
<head>
<title>Object orientated programming in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中的面向对象编程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/object-orientated-programming-in-c-27bcd58bbf5b?source=collection_archive---------17-----------------------#2021-07-05">https://levelup.gitconnected.com/object-orientated-programming-in-c-27bcd58bbf5b?source=collection_archive---------17-----------------------#2021-07-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3c2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像其他语言一样，C++让你在编写代码时可以选择使用不同的编程范例，而面向对象编程恰好是这些范例之一。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/dc3c7a09dc697fa7a84f8cb05f0a1005.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ma6FI1l-JPuYu_SP"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">克里希纳·潘迪在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="bd31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了帮助传达一些在面向对象编程中使用的概念，我将从为一个视频游戏开发一个敌人/玩家系统的角度来介绍它们。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="84cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，让我们假设你正在开发一个游戏，你的角色必须从一个建筑中逃出来，同时必须隐藏起来躲避敌人。你需要做的第一件事是开发一个基类，你可以从这个基类派生出你的玩家和敌人。</p><pre class="km kn ko kp gt lj lk ll lm aw ln bi"><span id="e4a9" class="lo lp iq lk b gy lq lr l ls lt">class base<br/>{<br/>private:<br/>    int m_x = 0;<br/>    int m_y = 0;<br/>    int m_floor = 0;<br/>    <br/>    unsigned int m_speed = 0;<br/>    unsigned int m_sprint_speed = 0;<br/>    unsigned int m_max_stamina = 0;<br/>}</span></pre><p id="912d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们可以从这个基类中派生出我们的敌人和玩家。这是多态性的一个例子。但是，因为它只继承公共变量和方法，所以我们必须在派生类中包含所有这些变量。</p><pre class="km kn ko kp gt lj lk ll lm aw ln bi"><span id="1048" class="lo lp iq lk b gy lq lr l ls lt">class enemy : public base<br/>{<br/>private:<br/>    int m_x = 0;<br/>    int m_y = 0;<br/>    int m_floor = 0;<br/>    <br/>    unsigned int m_speed = 0;<br/>    unsigned int m_sprint_speed = 0;<br/>    unsigned int m_max_stamina = 0;<br/>};</span><span id="d09a" class="lo lp iq lk b gy lu lr l ls lt">class player : public base<br/>{<br/>private:<br/>    int m_x = 0;<br/>    int m_y = 0;<br/>    int m_floor = 0;<br/>    <br/>    unsigned int m_speed = 0;<br/>    unsigned int m_sprint_speed = 0;<br/>    unsigned int m_max_stamina = 0;<br/>};</span></pre><p id="2935" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然让玩家在建筑物周围漫无目的地游荡会让游戏变得更容易，但我们确实需要给他们一点帮助，所以我们引入了导演这个职业。导演类将需要访问玩家和敌人类中的私有数据，所以我们将使它成为基础类、敌人类和玩家类的朋友</p><pre class="km kn ko kp gt lj lk ll lm aw ln bi"><span id="0d70" class="lo lp iq lk b gy lq lr l ls lt">#include "Director.h"</span><span id="a7a7" class="lo lp iq lk b gy lu lr l ls lt">class base<br/>{<br/>    friend class Director<br/>private:<br/>    int m_x = 0;<br/>    int m_y = 0;<br/>    int m_floor = 0;<br/>    <br/>    unsigned int m_speed = 0;<br/>    unsigned int m_sprint_speed = 0;<br/>    unsigned int m_max_stamina = 0; <br/>}</span></pre><p id="6406" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你在你的代码中初始化类的时候，你可以做两件事之一:使用C++内置的默认构造函数或者写你自己的构造函数，我们将做后者。当我们这样做的时候，我们也可以添加析构函数，当你删除一个对象的时候会用到它们</p><p id="c303" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基类目前并不真正需要一个定制的构造函数，所以我们将只使用一个空白的构造函数</p><pre class="km kn ko kp gt lj lk ll lm aw ln bi"><span id="76c0" class="lo lp iq lk b gy lq lr l ls lt">#include "Director.h"</span><span id="0b8b" class="lo lp iq lk b gy lu lr l ls lt">class base<br/>{<br/>    friend class Director<br/>private:<br/>    int m_x = 0;<br/>    int m_y = 0;<br/>    int m_floor = 0;<br/>    <br/>    unsigned int m_speed = 0;<br/>    unsigned int m_sprint_speed = 0;<br/>    unsigned int m_max_stamina = 0;<br/>public:<br/>    base(); //This is a constructor<br/>    ~base(); //This is a destructor</span><span id="2608" class="lo lp iq lk b gy lu lr l ls lt">}</span></pre><p id="af0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于玩家类，我们希望能够设置他们的:最大耐力，冲刺速度和步行速度，这就是为什么我们使用自定义构造函数。</p><pre class="km kn ko kp gt lj lk ll lm aw ln bi"><span id="4154" class="lo lp iq lk b gy lq lr l ls lt">class Player : public base<br/>{<br/>    friend class Director;<br/>private:<br/>    int m_x = 0;<br/>    int m_y = 0;<br/>    int m_floor = 0;<br/>    <br/>    unsigned int m_speed = 0;<br/>    unsigned int m_sprint_speed = 0;<br/>    unsigned int m_max_stamina = 0;<br/>public:<br/>    Player(unsigned int min_speed, unsigned int max_speed, unsigned int max_stamina);<br/>    ~Player();</span><span id="7534" class="lo lp iq lk b gy lu lr l ls lt">};</span></pre><p id="4213" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们打算在敌人的职业中做同样的事情</p><pre class="km kn ko kp gt lj lk ll lm aw ln bi"><span id="15df" class="lo lp iq lk b gy lq lr l ls lt">class enemy : public base<br/>{<br/>    friend class Director;<br/>private:<br/>    int m_x = 0;<br/>    int m_y = 0;<br/>    int m_floor = 0;<br/>    <br/>    unsigned int m_speed = 0;<br/>    unsigned int m_sprint_speed = 0;<br/>    unsigned int m_max_stamina = 0;<br/>public:<br/>    enemy(unsigned int min_speed, unsigned int max_speed, unsigned int max_stamina);<br/>    ~enemy();</span><span id="459a" class="lo lp iq lk b gy lu lr l ls lt">};</span></pre><p id="bf15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像基类一样，director也可以有一个空的构造函数。</p><p id="9243" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们已经在头文件中声明了构造函数，我们需要写构造函数在cpp文件中做什么。</p><pre class="km kn ko kp gt lj lk ll lm aw ln bi"><span id="4ff4" class="lo lp iq lk b gy lq lr l ls lt">Player(unsigned int min_speed, unsigned int max_speed, unsigned int max_stamina)<br/>    :m_speed(min_speed),m_sprint_speed(max_speed),m_max_stamina(max_stamina)<br/>{<br/>}</span></pre><p id="a352" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">敌人职业的构造器几乎是一样的。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="c4dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我之前提到过指挥者职业会帮助敌人职业找到你，所以让我们来实现它，为此我们要使用方法。方法是我们在类中找到的函数。</p><p id="55bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们要写的第一个方法将更新玩家的位置</p><pre class="km kn ko kp gt lj lk ll lm aw ln bi"><span id="dd52" class="lo lp iq lk b gy lq lr l ls lt">#pragma once //This means only include this header file once<br/>#include "base.h"</span><span id="5847" class="lo lp iq lk b gy lu lr l ls lt">class Director<br/>{<br/>private:<br/>    int player_x = 0;<br/>    int player_y = 0;<br/>    int player_level = 0;<br/>public:<br/>    void update_player_location(Player&amp; player); <br/>};</span></pre><ul class=""><li id="d8e2" class="lv lw iq jp b jq jr ju jv jy lx kc ly kg lz kk ma mb mc md bi translated">Player&amp;本质上意味着该函数需要一个对Player对象的引用</li></ul><pre class="km kn ko kp gt lj lk ll lm aw ln bi"><span id="bbb2" class="lo lp iq lk b gy lq lr l ls lt">#include "Director.h"</span><span id="16a9" class="lo lp iq lk b gy lu lr l ls lt">void Director::update_player_location(Player&amp; player)<br/>{<br/>    player_x = player.m_x;<br/>    player_y = player.m_y;<br/>    player_level = player.m_level;<br/>}</span></pre><p id="ca8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果需要的话，导演也会给敌人的人工智能提供玩家位置的信息。</p><pre class="km kn ko kp gt lj lk ll lm aw ln bi"><span id="fce6" class="lo lp iq lk b gy lq lr l ls lt">class enemy : public base<br/>{<br/>    friend class Director;<br/>private:<br/>    int m_x = 0;<br/>    int m_y = 0;<br/>    int m_floor = 0;</span><span id="8922" class="lo lp iq lk b gy lu lr l ls lt">    //last known<br/>    int player_x = 0;<br/>    int player_y = 0;<br/>    int player_level = 0;        <br/>    <br/>    unsigned int m_speed = 0;<br/>    unsigned int m_sprint_speed = 0;<br/>    unsigned int m_max_stamina = 0</span><span id="f9c2" class="lo lp iq lk b gy lu lr l ls lt">    enum help<br/>    {<br/>        dont_need = 0, need_some, lost<br/>    };<br/>    help status = dont_need;<br/>private:<br/>    void update_help();</span><span id="a4a0" class="lo lp iq lk b gy lu lr l ls lt">public:<br/>    enemy(unsigned int min_speed, unsigned int max_speed, unsigned int max_stamina);<br/>    ~enemy();</span><span id="5a87" class="lo lp iq lk b gy lu lr l ls lt">};</span></pre><p id="c1c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不打算写一个函数来决定敌人的ai是否需要来自指挥者的信息，但是本质上它将会查看自从它最后一次看见玩家已经有多长时间了。</p><pre class="km kn ko kp gt lj lk ll lm aw ln bi"><span id="4c48" class="lo lp iq lk b gy lq lr l ls lt">#pragma once //This means only include this header file once<br/>#include "base.h"</span><span id="753b" class="lo lp iq lk b gy lu lr l ls lt">class Director<br/>{<br/>private:<br/>    int player_x = 0;<br/>    int player_y = 0;<br/>    int player_level = 0;<br/>public:<br/>    void update_player_location(Player&amp; player);<br/>    void update_enemy(enemy&amp; npc);<br/>};</span><span id="c9a2" class="lo lp iq lk b gy lu lr l ls lt">----------------------------------<br/>#include "Director.h"</span><span id="37e5" class="lo lp iq lk b gy lu lr l ls lt">void Director::update_player_location(Player&amp; player)<br/>{<br/>    player_x = player.m_x;<br/>    player_y = player.m_y;<br/>    player_level = player.m_level;<br/>}</span><span id="35f5" class="lo lp iq lk b gy lu lr l ls lt">void Director::update_enemy(enemy&amp; npc)<br/>{<br/>    switch (npc.status)<br/>    {<br/>    case 0:<br/>        break;<br/>    case 1:<br/>         npc.player_level = player_level;<br/>         break;<br/>    case 2:<br/>         npc.player_level = player_level;<br/>         npc.player_x = player_x;<br/>         npc.player_y = player_y;<br/>         break;<br/>   default:<br/>         break;<br/>}</span></pre><p id="e873" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要添加的最后一个方法是动作方法，对玩家来说这是隐藏，对敌人ai来说这是攻击。</p><pre class="km kn ko kp gt lj lk ll lm aw ln bi"><span id="8bb0" class="lo lp iq lk b gy lq lr l ls lt">#include "Director.h"</span><span id="a547" class="lo lp iq lk b gy lu lr l ls lt">class base<br/>{<br/>    friend class Director<br/>private:<br/>    int m_x = 0;<br/>    int m_y = 0;<br/>    int m_floor = 0;<br/>    <br/>    unsigned int m_speed = 0;<br/>    unsigned int m_sprint_speed = 0;<br/>    unsigned int m_max_stamina = 0;<br/>public:<br/>    base(); //This is a constructor<br/>    ~base(); //This is a destructor</span><span id="c840" class="lo lp iq lk b gy lu lr l ls lt">    virtual void action();<br/>}</span><span id="de97" class="lo lp iq lk b gy lu lr l ls lt">---------------------------<br/>class enemy : public base<br/>{<br/>    friend class Director;<br/>private:<br/>    int m_x = 0;<br/>    int m_y = 0;<br/>    int m_floor = 0;</span><span id="ec98" class="lo lp iq lk b gy lu lr l ls lt">//last known<br/>    int player_x = 0;<br/>    int player_y = 0;<br/>    int player_level = 0;        <br/>    <br/>    unsigned int m_speed = 0;<br/>    unsigned int m_sprint_speed = 0;<br/>    unsigned int m_max_stamina = 0</span><span id="c899" class="lo lp iq lk b gy lu lr l ls lt">enum help<br/>    {<br/>        dont_need = 0, need_some, lost<br/>    };<br/>    help status = dont_need;<br/>private:<br/>    void update_help();</span><span id="9f72" class="lo lp iq lk b gy lu lr l ls lt">public:<br/>    enemy(unsigned int min_speed, unsigned int max_speed, unsigned int max_stamina);<br/>    ~enemy();</span><span id="4a64" class="lo lp iq lk b gy lu lr l ls lt">    void action();<br/>};</span><span id="19af" class="lo lp iq lk b gy lu lr l ls lt">--------------------------</span><span id="24f6" class="lo lp iq lk b gy lu lr l ls lt">class Player : public base<br/>{<br/>    friend class Director;<br/>private:<br/>    int m_x = 0;<br/>    int m_y = 0;<br/>    int m_floor = 0;<br/>    <br/>    unsigned int m_speed = 0;<br/>    unsigned int m_sprint_speed = 0;<br/>    unsigned int m_max_stamina = 0;<br/>public:<br/>    Player(unsigned int min_speed, unsigned int max_speed, unsigned int max_stamina);<br/>    ~Player();</span><span id="08d1" class="lo lp iq lk b gy lu lr l ls lt">    void action();</span><span id="7cc6" class="lo lp iq lk b gy lu lr l ls lt">};</span><span id="b667" class="lo lp iq lk b gy lu lr l ls lt"><br/>---------------------------</span><span id="1bea" class="lo lp iq lk b gy lu lr l ls lt">void base::action()<br/>{<br/>};</span><span id="7c9e" class="lo lp iq lk b gy lu lr l ls lt">void enemy::action()<br/>{<br/>    //attack player<br/>};</span><span id="82a6" class="lo lp iq lk b gy lu lr l ls lt">void Player::action()<br/>{<br/>    //hide<br/>};</span></pre><p id="f590" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个虚函数的例子，它允许一个函数被写在基类中，但在子类中被修改，并且允许正确的函数被调用，否则如果它不是虚函数，修改它会导致错误。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="6b15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">面向对象编程比范例有好处，比如写起来更快，而且通常会使代码更容易调试。然而，一旦出现问题，它就有可能变得非常糟糕。</p><p id="6cca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这篇文章已经讨论了你在C++中进行面向对象编程时需要知道的大部分内容，最后，C++中的OOP非常有用，应该在可能和有益的地方使用它。</p></div></div>    
</body>
</html>