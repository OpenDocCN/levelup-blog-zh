<html>
<head>
<title>What to expect when you’re expecting: Playing with processes in Erlang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当你期待时，期待什么:在Erlang中使用进程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-to-expect-when-youre-expecting-playing-with-processes-in-erlang-ede0fa4ecaf0?source=collection_archive---------10-----------------------#2020-03-12">https://levelup.gitconnected.com/what-to-expect-when-youre-expecting-playing-with-processes-in-erlang-ede0fa4ecaf0?source=collection_archive---------10-----------------------#2020-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/c0c5aa3e3e36b58739a35fdc4118053b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HgABqg_iqfinJyDo"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">克里斯托夫·高尔在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="46b8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">rlang的关键组织概念是流程，一个发送和接收消息的独立组件(由功能构建而成)。程序被部署为相互通信的进程集。Erlang并发是基于进程的。这些小型的独立虚拟机可以评估Erlang函数。</p><p id="4a0e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Erlang中:</p><ul class=""><li id="2223" class="lk ll jg kf b kg kh kk kl ko lm ks ln kw lo la lp lq lr ls bi translated">创建和销毁进程的速度非常快。</li><li id="a4d2" class="lk ll jg kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">在进程之间发送消息非常快。</li><li id="8b56" class="lk ll jg kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">在所有操作系统上，进程的行为都是一样的。</li><li id="04bb" class="lk ll jg kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">我们可以有非常多的进程。</li><li id="42c0" class="lk ll jg kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">进程不共享内存，完全独立。</li><li id="5f92" class="lk ll jg kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">流程交互的唯一方式是通过消息传递。</li></ul><p id="ea52" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于这些原因，Erlang有时被称为纯粹的消息传递语言。</p><h1 id="55d1" class="ly lz jg bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">使用流程</h1><p id="416f" class="pw-post-body-paragraph kd ke jg kf b kg mw ki kj kk mx km kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">我们所知道的关于顺序编程的一切对于并发编程仍然是正确的。我们所要做的就是添加以下原语:</p><h2 id="3e79" class="nb lz jg bd ma nc nd dn me ne nf dp mi ko ng nh mm ks ni nj mq kw nk nl mu nm bi translated">创建流程</h2><p id="59d4" class="pw-post-body-paragraph kd ke jg kf b kg mw ki kj kk mx km kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">您可以使用<strong class="kf jh"> <em class="nn"> spawn </em> </strong>功能创建一个新流程:</p><pre class="no np nq nr gt ns nt nu nv aw nw bi"><span id="cd0a" class="nb lz jg nt b gy nx ny l nz oa">Pid = spawn(Mod, Func, Args)</span></pre><p id="8343" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">新进程与调用者并行运行。<strong class="kf jh"> <em class="nn"> spawn </em> </strong>返回一个<strong class="kf jh"> <em class="nn"> Pid </em> </strong>(进程标识符的简称)。您可以使用一个<strong class="kf jh"> <em class="nn"> Pid </em> </strong>向流程发送消息。<br/>注意，函数<strong class="kf jh"> <em class="nn"> Func </em> </strong>带arity<strong class="kf jh"><em class="nn">length(Args)</em></strong>必须从模块<strong class="kf jh"> <em class="nn"> Mod中导出。</em> </strong>创建新流程时，使用定义代码的模块的最新版本。</p><pre class="no np nq nr gt ns nt nu nv aw nw bi"><span id="72ce" class="nb lz jg nt b gy nx ny l nz oa">Pid = spawn(Fun)</span></pre><p id="e1a0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个评估<strong class="kf jh"> <em class="nn"> Fun() </em> </strong>的新并发进程。这种形式的<strong class="kf jh"> <em class="nn"> spawn </em> </strong>总是使用正在评估的乐趣的当前值，而这个乐趣并不一定要从模块中导出。两种形式的<strong class="kf jh"> <em class="nn"> spawn </em> </strong>的本质区别在于动态代码升级。</p><h2 id="839d" class="nb lz jg bd ma nc nd dn me ne nf dp mi ko ng nh mm ks ni nj mq kw nk nl mu nm bi translated">发送消息</h2><p id="8c0c" class="pw-post-body-paragraph kd ke jg kf b kg mw ki kj kk mx km kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">消息发送是异步的。发送方不会等待，而是继续做它正在做的事情。要使用以下语法向进程发送消息:</p><pre class="no np nq nr gt ns nt nu nv aw nw bi"><span id="ded8" class="nb lz jg nt b gy nx ny l nz oa">Pid ! Message</span></pre><p id="d120" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这会将<code class="fe ob oc od nt b"><strong class="kf jh"><em class="nn">Message</em></strong></code>发送给标识符为<code class="fe ob oc od nt b"><strong class="kf jh"><em class="nn">Pid</em></strong></code>的进程。<code class="fe ob oc od nt b"><strong class="kf jh"><em class="nn">!</em></strong></code> <strong class="kf jh"> <em class="nn"> </em> </strong>被称为寄符。</p><h2 id="f5df" class="nb lz jg bd ma nc nd dn me ne nf dp mi ko ng nh mm ks ni nj mq kw nk nl mu nm bi translated">接收消息</h2><p id="c5f0" class="pw-post-body-paragraph kd ke jg kf b kg mw ki kj kk mx km kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">当消息到达流程时，系统会尝试使用模式匹配来匹配它。要在流程中接收消息，请使用以下语法:</p><pre class="no np nq nr gt ns nt nu nv aw nw bi"><span id="0872" class="nb lz jg nt b gy nx ny l nz oa">receive<br/>    Pattern1 [when Guard1] -&gt;<br/>        Expressions1;<br/>    Pattern2 [when Guard2] -&gt;<br/>        Expressions2;<br/>    ...<br/>end</span></pre><p id="7f29" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh"> <em class="nn">接收… end </em> </strong>接收已经发送给流程的消息。在上面的示例中，系统尝试将消息与<strong class="kf jh"> <em class="nn">模式1 </em> </strong>(与可能的守卫<strong class="kf jh"> <em class="nn">守卫1 </em> </strong>)进行匹配；如果成功，它将对<strong class="kf jh"> <em class="nn">表达式1 </em> </strong>求值。如果第一个模式不匹配，则尝试<strong class="kf jh"> <em class="nn">模式2 </em> </strong>，以此类推。如果没有匹配的模式，则保存该消息供以后处理，并且该过程等待下一条消息。</p><p id="755a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样。你不需要线程、锁、信号量和人工控制。</p><h1 id="ae39" class="ly lz jg bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">外壳是一个进程</h1><p id="74fb" class="pw-post-body-paragraph kd ke jg kf b kg mw ki kj kk mx km kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">shell  是一个容易发送和接收消息的地方(至少对于测试来说)。首先要探究的是进程标识符，通常称为<strong class="kf jh"> <em class="nn"> pid </em> </strong>。最容易得到的<strong class="kf jh"> <em class="nn"> pid </em> </strong>就是你自己。在shell中，您可以运行self()函数:</p><pre class="no np nq nr gt ns nt nu nv aw nw bi"><span id="00b5" class="nb lz jg nt b gy nx ny l nz oa">mep@mep:~$ erl<br/>Erlang/OTP 22 [erts-10.4.4] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1]</span><span id="ffa7" class="nb lz jg nt b gy oe ny l nz oa">Eshell V10.4.4  (abort with ^G)<br/>1&gt; self().<br/>&lt;0.78.0&gt;<br/></span></pre><h2 id="6acb" class="nb lz jg bd ma nc nd dn me ne nf dp mi ko ng nh mm ks ni nj mq kw nk nl mu nm bi translated">在外壳中发送消息</h2><p id="2e71" class="pw-post-body-paragraph kd ke jg kf b kg mw ki kj kk mx km kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">第1行将shell的pid赋给一个名为<strong class="kf jh"><em class="nn"/></strong>的变量，这个Pid是用<strong class="kf jh"> <em class="nn"> self() </em> </strong>函数获取的，然后第2行使用这个<strong class="kf jh"> <em class="nn"> Pid </em> </strong>变量发送一个包含原子<strong class="kf jh"> <em class="nn"> testMessage </em> </strong>的消息。</p><pre class="no np nq nr gt ns nt nu nv aw nw bi"><span id="303e" class="nb lz jg nt b gy nx ny l nz oa">Eshell V10.4.4 (abort with ^G)<br/>1&gt; Pid = self().<br/>&lt;0.78.0&gt;<br/>2&gt; Pid ! testMessage.<br/>testMessage<br/>3&gt;</span></pre><h2 id="20a5" class="nb lz jg bd ma nc nd dn me ne nf dp mi ko ng nh mm ks ni nj mq kw nk nl mu nm bi translated">在shell中接收消息</h2><p id="9c90" class="pw-post-body-paragraph kd ke jg kf b kg mw ki kj kk mx km kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">让我们使用<strong class="kf jh"> <em class="nn"> receive … end将我们在sell中收到的金额翻倍。</em> </strong>语法</p><pre class="no np nq nr gt ns nt nu nv aw nw bi"><span id="d959" class="nb lz jg nt b gy nx ny l nz oa">Eshell V10.4.4 (abort with ^G)<br/>1&gt; Pid = self().<br/>&lt;0.78.0&gt;<br/>2&gt; Pid ! 71. <br/>71<br/>3&gt; receive X-&gt;X*2 end. <br/>142</span></pre><h1 id="161c" class="ly lz jg bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">让我们打乒乓球吧</h1><p id="b344" class="pw-post-body-paragraph kd ke jg kf b kg mw ki kj kk mx km kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">为了演示我们到目前为止所学的内容，我们来玩一些关于流程的乒乓游戏。首先用下面的代码创建两个名为ping (ping.erl文件)和pong (pong.erl文件)的模块:</p><figure class="no np nq nr gt is"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">用于乒乓操作的乒乓模块</figcaption></figure><p id="975f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，在shell中，运行以下命令(编译您的模块):</p><pre class="no np nq nr gt ns nt nu nv aw nw bi"><span id="b471" class="nb lz jg nt b gy nx ny l nz oa">Eshell V10.4.4  (abort with ^G)<br/>1&gt; c(ping).<br/>{ok,ping}<br/>2&gt; c(pong). <br/>{ok,pong}<br/>3&gt;</span></pre><p id="5fa8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，您可以使用<strong class="kf jh"> <em class="nn">启动</em> </strong>功能从任意一侧进行乒乓操作:</p><pre class="no np nq nr gt ns nt nu nv aw nw bi"><span id="4968" class="nb lz jg nt b gy nx ny l nz oa">3&gt; ping:start(7).<br/>ping pong ping pong ping pong ping pong ping pong ping pong ping pong ok</span></pre><p id="277d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来源:</p><p id="fa39" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae jd" href="https://www.erlang.org/docs" rel="noopener ugc nofollow" target="_blank"> Erlang文档</a></p></div></div>    
</body>
</html>