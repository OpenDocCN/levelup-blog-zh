<html>
<head>
<title>‘Factory Method’ Pattern in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的“工厂方法”模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/factory-method-pattern-in-swift-1f1b73488072?source=collection_archive---------3-----------------------#2020-06-14">https://levelup.gitconnected.com/factory-method-pattern-in-swift-1f1b73488072?source=collection_archive---------3-----------------------#2020-06-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/78e1dd9d01691c3542ba62dc0bc94f66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NY0f8bY6ZyBgZF5KWv4gug.jpeg"/></div></div></figure><h1 id="8511" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">定义</h1><p id="a90e" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">“工厂方法”模式<strong class="lb iu"> </strong>是一种创造性的设计模式，它抽象了实例化过程。创建模式控制谁创建一个对象，以及什么/如何/何时创建它。</p><p id="1a5e" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">“工厂方法”模式定义了创建对象的接口，并将对象创建委托给子类。</strong></p><h1 id="478f" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">我们什么时候应该使用这种模式？</h1><h2 id="f673" class="mc kc it bd kd md me dn kh mf mg dp kl lk mh mi kp lo mj mk kt ls ml mm kx mn bi translated">提供创建对象的接口</h2><p id="d8c2" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">当我们有很多以不同方式使用的不同对象时，应该使用这种模式。它们的实例化可能很复杂，需要计算才能创建它们。“工厂方法”模式封装了它们的实例，以便简化它们在不同地方的创建。</p><h2 id="4484" class="mc kc it bd kd md me dn kh mf mg dp kl lk mh mi kp lo mj mk kt ls ml mm kx mn bi translated">为实例化定义单个位置</h2><p id="0090" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">当一个类不能预测它需要create️.的对象类型时，应该使用这种模式如果我们有一个已经在做我们需要的事情的对象，我们必须在代码中的某个地方重用和实例化它。将这些实例化从客户端类转移到一个接口，使类依赖抽象而不依赖底层组件(<em class="mo">依赖倒置原则)。这个接口叫做工厂方法，它有逻辑来决定我们需要实例化哪种类型的对象。此外，将创建逻辑委托给子类可以避免代码重复，并提供一个单独的维护位置。</em></p><h2 id="b3e4" class="mc kc it bd kd md me dn kh mf mg dp kl lk mh mi kp lo mj mk kt ls ml mm kx mn bi translated">将对象的实现与其使用分离</h2><p id="de65" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">当客户机完成创建逻辑和实例化时，应该使用这种模式。如果一个对象的类型在它的类中被使用，那么这个客户端就是与这个对象紧密耦合的。通过移动子类中对象的逻辑和实例化，我们保护代码免受API变化的影响。如果对一个具体的类及其API进行一些修改，客户端代码不会受到它不关心的变化的影响。通过实现一个接口，工厂方法返回一个抽象而不是一个具体的类型，所以我们保护代码不受实现细节的影响。</p><h1 id="21fe" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">我们应该如何使用这种模式？</h1><p id="1381" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">让我们从这种模式的一种常见方法开始。在这个例子中，我们正在开发一个移动应用程序，我们想要创建一个负责创建UI组件的工厂方法。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="6e1d" class="mc kc it mu b gy my mz l na nb"><strong class="mu iu">class</strong> ComponentFactory {<br/>    <strong class="mu iu">private</strong> <strong class="mu iu">init</strong>() {}</span><span id="3c1b" class="mc kc it mu b gy nc mz l na nb"><strong class="mu iu">    static</strong> <strong class="mu iu">func</strong> createView(component: ComponentType) -&gt; UIView {       <br/>        <strong class="mu iu">switch</strong> component {<br/>        <strong class="mu iu">case</strong> .textfield:<br/>            <strong class="mu iu">let</strong> textfield = UITextField()<br/>            // textfield customatization...<br/>            <strong class="mu iu">return</strong> textfield</span><span id="128d" class="mc kc it mu b gy nc mz l na nb"><strong class="mu iu">        case</strong> .switch:<br/>            <strong class="mu iu">let</strong> `switch` = UISwitch()<br/>            // `switch` customatization...<br/>            <strong class="mu iu">return</strong> `switch`</span><span id="e74f" class="mc kc it mu b gy nc mz l na nb"><strong class="mu iu">        case</strong> .button:<br/>            <strong class="mu iu">let</strong> button = UIButton()<br/>            // button customatization...<br/>            <strong class="mu iu">return</strong> button</span><span id="071e" class="mc kc it mu b gy nc mz l na nb"><strong class="mu iu">        case</strong> .label:<br/>            <strong class="mu iu">let</strong> label = UILabel()<br/>            // label customatization...<br/>            <strong class="mu iu">return</strong> label</span><span id="2877" class="mc kc it mu b gy nc mz l na nb"><strong class="mu iu">        case</strong> .image:<br/>            <strong class="mu iu">let</strong> image = UIImageView()<br/>            // image customatization...<br/>            <strong class="mu iu">return</strong> image<br/>        }<br/>    }<br/>}</span></pre><p id="1f26" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">第一种方法通过一个接口抽象出详细的实现。createView方法是工厂方法，它采用一个参数来标识要创建的对象的类型。所有创建的对象共享一个公共的UIView界面。</p><p id="b3c1" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">然而，这段代码只关心对象的创建，而不关心如何管理它。这意味着我们不能继承和改变createView方法的行为。这段代码不是“工厂方法”模式的实现，而是简单/静态工厂的实现。</p><h1 id="ca3f" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">履行</h1><h2 id="cde0" class="mc kc it bd kd md me dn kh mf mg dp kl lk mh mi kp lo mj mk kt ls ml mm kx mn bi translated">工厂方法</h2><p id="cfc9" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">比方说，在我们的移动应用程序中，根据播放器主题设置，我们有不同的外观组件。</p><p id="2d93" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">为了创建createView方法的不同行为，我们需要创建一个接口，这样就可以创建许多具有所需行为的工厂方法。让我们创建一个抽象层来实现子类。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="82d5" class="mc kc it mu b gy my mz l na nb"><strong class="mu iu">protocol</strong> ComponentFactory {<br/>    <strong class="mu iu">func</strong> createView(component: ComponentType) -&gt; UIView<br/>}</span></pre><p id="81e5" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在其设置中，玩家选择显示迪士尼世界主题的组件。让我们构建一个负责创建这些组件的工厂方法。为此，我们需要定义一个符合该接口的类:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="65ac" class="mc kc it mu b gy my mz l na nb"><strong class="mu iu">class</strong> DisneyComponentFactory: ComponentFactory {<br/>    <strong class="mu iu">func</strong> createView(component: ComponentType) -&gt; UIView {<br/>        <strong class="mu iu">switch</strong> component {<br/>        <strong class="mu iu">case</strong> .textfield: <strong class="mu iu">return</strong> DisneyTextField()<br/>        <strong class="mu iu">case</strong> .switch: <strong class="mu iu">return</strong> DisneySwitch()<br/>        <strong class="mu iu">case</strong> .button: <strong class="mu iu">return</strong> DisneyButton()<br/>        <strong class="mu iu">case</strong> .label: <strong class="mu iu">return</strong> DisneyLabel()<br/>        <strong class="mu iu">case</strong> .image: <strong class="mu iu">return</strong> DisneyImageView()<br/>        }<br/>    }<br/>}</span></pre><h2 id="eb8c" class="mc kc it bd kd md me dn kh mf mg dp kl lk mh mi kp lo mj mk kt ls ml mm kx mn bi translated">“工厂方法”UML图</h2><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/4fc2bafa2767835c66dcf1a59c5c404b.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*8N6e9KgPUYfcWxtZGrqptA.png"/></div></figure><p id="42ba" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">该图中的关键元素是ComponentFactory和UIView抽象。为了创建组件，客户必须对它们进行子类化。在我们的示例中，我们创建DisneyComponentFactory子类，它负责创建迪士尼特定的组件。“工厂方法”模式允许客户端只知道一个接口，但是它实例化了具体的类。因此，客户机并不决定它需要创建的对象，而是由工厂方法来决定。</p><h2 id="4f88" class="mc kc it bd kd md me dn kh mf mg dp kl lk mh mi kp lo mj mk kt ls ml mm kx mn bi translated">在操场上运行代码</h2><p id="5317" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这里有一个<a class="ae ne" href="http://online.swiftplayground.run/" rel="noopener ugc nofollow" target="_blank">在线Swift游乐场</a>，因此不必创建Xcode游乐场来测试“工厂方法”模式的实现。然后，复制下面的代码，该代码对应于我们带有迪士尼组件的移动应用程序的“工厂方法”模式的完整实现。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="ae07" class="mc kc it mu b gy my mz l na nb"><strong class="mu iu">// </strong>‼️ This online playground is platform agnostic, so we need to declare a UIView interface and its subclasses.<strong class="mu iu"><br/>protocol</strong> UIView {}<br/><strong class="mu iu">class</strong> UITextField: UIView {}<br/><strong class="mu iu">class</strong> UISwitch: UIView {}<br/><strong class="mu iu">class</strong> UIButton: UIView {}<br/><strong class="mu iu">class</strong> UILabel: UIView {}<br/><strong class="mu iu">class</strong> UIImageView: UIView {}</span><span id="9b4d" class="mc kc it mu b gy nc mz l na nb"><strong class="mu iu">class</strong> DisneyTextField: UITextField {}<br/><strong class="mu iu">class</strong> DisneySwitch: UISwitch {}<br/><strong class="mu iu">class</strong> DisneyButton: UIButton {}<br/><strong class="mu iu">class</strong> DisneyLabel: UILabel {}<br/><strong class="mu iu">class</strong> DisneyImageView: UIImageView {}</span><span id="1f32" class="mc kc it mu b gy nc mz l na nb"><strong class="mu iu">enum</strong> ComponentType {<br/>    <strong class="mu iu">case</strong> textfield<br/>    <strong class="mu iu">case</strong> `switch`<br/>    <strong class="mu iu">case</strong> button<br/>    <strong class="mu iu">case</strong> label<br/>    <strong class="mu iu">case</strong> image<br/>}</span><span id="79e6" class="mc kc it mu b gy nc mz l na nb"><strong class="mu iu">protocol</strong> ComponentFactory {<br/>    <strong class="mu iu">func</strong> createView(component: ComponentType) -&gt; UIView<br/>}</span><span id="a93e" class="mc kc it mu b gy nc mz l na nb"><strong class="mu iu">class</strong> DisneyComponentFactory: ComponentFactory {<br/>    <strong class="mu iu">func</strong> createView(component: ComponentType) -&gt; UIView {<br/>        <strong class="mu iu">switch</strong> component {<br/>        <strong class="mu iu">case</strong> .textfield:<br/>            print("DisneyTextField created")<br/>            <strong class="mu iu">return</strong> DisneyTextField()</span><span id="028b" class="mc kc it mu b gy nc mz l na nb"><strong class="mu iu">        case</strong> .switch:<br/>            print("DisneySwitch created")<br/>            <strong class="mu iu">return</strong> DisneySwitch()</span><span id="9947" class="mc kc it mu b gy nc mz l na nb"><strong class="mu iu">        case</strong> .button:<br/>            print("DisneyButton created")<br/>            <strong class="mu iu">return</strong> DisneyButton()</span><span id="d083" class="mc kc it mu b gy nc mz l na nb"><strong class="mu iu">        case</strong> .label:<br/>            print("DisneyLabel created")<br/>            <strong class="mu iu">return</strong> DisneyLabel()</span><span id="8de0" class="mc kc it mu b gy nc mz l na nb"><strong class="mu iu">        case</strong> .image:<br/>            print("DisneyImageView created")<br/>            <strong class="mu iu">return</strong> DisneyImageView()<br/>        }<br/>    }<br/>}</span><span id="5d99" class="mc kc it mu b gy nc mz l na nb">// Client<br/><strong class="mu iu">let</strong> disneyFactory = DisneyComponentFactory()<br/>disneyFactory.createView(component: .label)</span></pre><p id="fac3" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">最后，粘贴并运行代码。</p></div></div>    
</body>
</html>