<html>
<head>
<title>Testing GraphQL subscription</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试GraphQL订阅</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/testing-graphql-subscription-8bb8b4dfd8e9?source=collection_archive---------4-----------------------#2022-11-27">https://levelup.gitconnected.com/testing-graphql-subscription-8bb8b4dfd8e9?source=collection_archive---------4-----------------------#2022-11-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/87b6d1015ccc56a9d32873ba6c28068e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8VwTnJIXV6EbM8vjBexRHw.jpeg"/></div></div></figure><div class=""/><p id="d6ec" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本帖是我上一篇关于测试Gql <a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/how-i-save-a-few-hours-each-week-on-testing-graphql-in-nest-js-typescript-1afd8ceeacf7">的帖子的延续https://level up . git connected . com/how-I-save-a-number-hours-week-on-Testing-graph QL-in-nest-js-typescript-1 AFD 8 CEE ACF 7</a>。</p><p id="38ad" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在链接的文章中，我首先创建了一个用Nestjs编写的小型graphql服务器。今天，我将对我之前的例子进行扩展，所以如果您之前没有阅读过，那么在深入研究这个例子之前先看一看。</p><h2 id="1185" class="la lb je bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">问题是</h2><p id="9075" class="pw-post-body-paragraph kb kc je kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">在我的上一篇文章中，我们发现了如何自动化与样板代码相关的工作，这是编写GraphQL查询和变异所必需的。</p><p id="88c7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是！GraphQL还提供了一种使用订阅与客户端实时通信的方式。以前的代码不支持这种通信方式。</p><p id="0b94" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Websockets，因为这是用于订阅的传输协议，所以与HTTP调用完全不同。等待响应要困难得多，因为通常的响应只是某个其他操作之后的事件，有时是由不同的用户发起的。</p><p id="414c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要采取其他方式，而不仅仅是使用承诺。</p><h2 id="fbf9" class="la lb je bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">这个例子</h2><p id="2753" class="pw-post-body-paragraph kb kc je kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">首先，我们看一下当我们在解析器中声明订阅时，前面的代码会生成什么。在我们推出自动化订阅的解决方案之前，这一点非常重要。</p><p id="cedd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我将从安装所需的包开始，以允许我们的服务器使用订阅。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="eb10" class="la lb je md b gy mh mi l mj mk">yarn add graphql-subscriptions graphql-ws ws</span></pre><p id="f4e1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二步是通过编辑GraphQLModule声明来配置服务器。</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="60e5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要使用订阅，我们需要声明PubSub。传输层，在这种情况下，我们将使用由<strong class="kd jf">提供的内存中的graphql-subscriptions </strong>包和订阅标识符。多亏了它们，我们可以确定哪个消息与哪个订阅相关。</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="c867" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，在创建了设置订阅所需的所有内容之后，我可以声明一个:</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="3402" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了检查订阅是否有效，我需要发布一条消息，就像订阅名称所说的那样，在创建一个用户之后。为此，我将对以前的实现稍作修改:</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="01a9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在是检验它是否有效的时候了。我可以用操场做，但是我会跳过这一步。我想通过运行测试用例来测试我们的订阅是否自动工作！</p><h2 id="ee5c" class="la lb je bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">上一篇文章之后的可用资源</h2><p id="d73a" class="pw-post-body-paragraph kb kc je kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">正如我们之前决定的那样，首先我们将看看<code class="fe mn mo mp md b">gqlq</code>会产生什么。为此，首先我需要运行前一篇文章中的脚本:<code class="fe mn mo mp md b">test:generate-quries</code>。</p><p id="0e11" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">结果，我收到了两件重要的东西。第一次打字在<code class="fe mn mo mp md b">test/gql/queries.ts</code>中可用。在函数<code class="fe mn mo mp md b">getSdk</code>中，我订阅了<code class="fe mn mo mp md b">userCreated</code>，参数看起来有希望，但返回类型是承诺！所以不会有太大帮助。但是拥有一个可以使用的类型化参数是一个很好的标志！</p><p id="8bcb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个文件在<code class="fe mn mo mp md b">test/qgl/subscriptions/userCreated.gql</code>中。这里我有我们的查询定义，如果我在任何GraphQL客户端传递它，我们只需单击run并等待来自服务器的数据。</p><p id="7b93" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了这两样东西，我就可以用泛型来变魔术，把响应转换成回调。为什么回调？我们可以很容易地传递一个spy，检查调用了哪些参数，并对正确的结果做出预期。</p><h2 id="38c2" class="la lb je bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">解决方案</h2><p id="500b" class="pw-post-body-paragraph kb kc je kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">在花了一些时间尝试确定SDK中的哪个方法是订阅后，我发现了一个有点不同的解决方案。使用预先测试脚本，我将<code class="fe mn mo mp md b">test/gql/subscriptions</code>中可用的<code class="fe mn mo mp md b">index.js</code>文件转换为typescript，其中生成的代码导出所有可用的订阅查询，稍后使用<code class="fe mn mo mp md b">keyof typeof</code>我得到了一个不错的订阅方法列表。</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">/scripts/generate-subscriptions-query-type . js</figcaption></figure><p id="af86" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">并在package.json中注册它:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="3576" class="la lb je md b gy mh mi l mj mk">"test:generate-subscriptions-as-ts": "node scripts/generate-subscriptions-queries-type.js test/gql/subscriptions",<br/>"test:generate-queries": "gqlg --schemaFilePath ./src/schema.gql --destDirPath ./test/gql &amp;&amp; yarn test:generate-subscriptions-as-ts &amp;&amp; graphql-codegen --config codegen.yml"</span></pre><p id="df91" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，当我们运行<code class="fe mn mo mp md b">test:generate-queries</code>时，我们也得到了一个带有GraphQL查询的typescript文件。</p><p id="a39a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一步是将现有生成的SDK类型解析到我们自己的订阅接口。这是由下面的代码完成的。我将跳过细节，如果你对它如何工作感兴趣，你可以查看一些关于泛型类型的好文章或者在评论中询问。</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="2241" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，当你进入我们的测试文件时，你会看到一个有点不同的订阅界面，可能在SessionFactory中有一个错误，因为我们还没有完成这个界面；)</p><p id="24b1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以在下一步，我们将实现它！</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="cfc3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简而言之，我使用<code class="fe mn mo mp md b">ws</code>实现创建了一个GraphQL客户端，以便有机会传递消息头。一些无聊的配置和接下来等待的事件<code class="fe mn mo mp md b">connected</code>。当事件发生时，代码准备向服务器发送订阅请求。</p><p id="476e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我只是基于查询和先前创建的客户端实现了一个先前声明的接口。</p><p id="b6df" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以深入细节，有问题可以在评论里问，但也就这些了！我们准备测试了！</p><h2 id="ee7b" class="la lb je bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">试验</h2><p id="5908" class="pw-post-body-paragraph kb kc je kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">现在我可以添加一些测试用例。此外，我声明了<code class="fe mn mo mp md b">sleep</code>函数，以确保在测试用例结束之前接收到来自服务器的响应。</p><figure class="ly lz ma mb gt iv"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="105e" class="la lb je bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">摘要</h2><p id="4e69" class="pw-post-body-paragraph kb kc je kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">如您所见，您可以使用现有的解决方案创建许多有用的东西！相信对你的日常工作会有一点帮助，下期文章再见！</p><p id="cde9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">资源库:<a class="ae kz" href="https://github.com/adziok/nestjs-graphql-testing/tree/gql-subscription" rel="noopener ugc nofollow" target="_blank">https://github . com/adziok/nestjs-graph QL-testing/tree/gql-subscription</a></p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="21ac" class="nb lb je bd lc nc nd ne lf nf ng nh li ni nj nk ll nl nm nn lo no np nq lr nr bi translated">分级编码</h1><p id="122e" class="pw-post-body-paragraph kb kc je kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="1a0d" class="ns nt je kd b ke kf ki kj km nu kq nv ku nw ky nx ny nz oa bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="9b6f" class="ns nt je kd b ke ob ki oc km od kq oe ku of ky nx ny nz oa bi translated">📰更多内容请查看<a class="ae kz" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码刊物</a></li><li id="3ee4" class="ns nt je kd b ke ob ki oc km od kq oe ku of ky nx ny nz oa bi translated">🔔关注我们:<a class="ae kz" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae kz" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae kz" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="7492" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">🚀👉<a class="ae kz" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kd jf">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>