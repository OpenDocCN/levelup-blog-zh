<html>
<head>
<title>Differences between a Promise and an Observable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">承诺和可观察到的区别</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/differences-between-a-promise-and-an-observable-22448f116430?source=collection_archive---------11-----------------------#2021-04-25">https://levelup.gitconnected.com/differences-between-a-promise-and-an-observable-22448f116430?source=collection_archive---------11-----------------------#2021-04-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ac52af4aabc6227158cb202629d6c6c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0BE5GyWNT06S9tRdGxix1Q.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@jdent?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杰森·登特</a>在<a class="ae kf" href="https://unsplash.com/s/photos/comparison?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="7b1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我概述了我所学到的一些关于可观察事物的基本概念，以及它与承诺的不同之处。</p><p id="3034" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在讨论可观察到的和承诺的区别之前，我们先来谈谈它们的共同点。可观测量和承诺都是生产和消费数据的框架。它们遵循推送协议，这意味着生产者确定何时将数据发送给消费者。相比之下，在拉协议中，生产者只在消费者要求时才产生数据。</p><p id="e656" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在承诺中，使用者是在构造承诺时传递给构造函数的解析回调，生产者是异步调用回调来传递数据的承诺本身。例如，在下面的代码片段中，一旦承诺(生产者)在一秒钟后完成，它就调用回调(消费者)并传递字符串“工作在承诺上完成”(数据)。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="1891" class="ln lo it lj b gy lp lq l lr ls">const executor = (resolve, reject) =&gt; {<br/>  // perform some work<br/>  console.log("Work started on Promise");<br/>  setTimeout(() =&gt; resolve("Work is done on Promise."), 1000);<br/>};<br/><br/>const aPromise = new Promise(executor);<br/>aPromise.then(value =&gt; console.log(value));</span></pre><p id="4cff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在可观察对象中，生产者是被观察对象，观察者是消费者。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="61ba" class="ln lo it lj b gy lp lq l lr ls">// Producer<br/>const anObservable = new Observable(subscriber =&gt; {<br/>  console.log("Work started on Observable");<br/>  setTimeout(() =&gt; {<br/>    subscriber.next("Work is done on Observable");<br/>    subscriber.complete();<br/>  }, 1000);<br/>});<br/>// Consumer<br/>anObservable.subscribe(<br/>  value =&gt; console.log(value)<br/>);</span></pre><p id="c269" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然你可以使用一个可观察的或一个承诺来产生和接收数据，但是一个可观察的和一个承诺在设计和功能上是相当不同的，我们将在后面的章节中讨论。</p><h1 id="20aa" class="lt lo it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">多用途与单用途</h1><p id="eded" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">可观察对象和承诺之间的第一个根本区别是<em class="mv">可观察对象可以发出多个值，而承诺只能发出一个值</em>。</p><p id="5501" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的代码片段中，观察者发出两个值，然后完成。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="5bd4" class="ln lo it lj b gy lp lq l lr ls">const anObservable = new Observable(subscriber =&gt; {<br/>  console.log("Observable started");<br/>  subscriber.next(1);<br/>  subscriber.next(2);<br/>  subscriber.complete();<br/>});<br/><br/>anObservable.subscribe(<br/>  value =&gt; console.log(value),<br/>  err =&gt; console.log(err),<br/>  () =&gt; console.log("Observable completed")<br/>);</span></pre><p id="3962" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是控制台中的输出:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="2b08" class="ln lo it lj b gy lp lq l lr ls">Observable started<br/>1<br/>2<br/>Observable completed</span></pre><p id="bde8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与可观察值不同，承诺只能发出一个值，如下面的示例片段所示。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="4b40" class="ln lo it lj b gy lp lq l lr ls">const aPromise = new Promise((resolve, reject) =&gt; {<br/>  console.log("Promise started");<br/>  resolve(1);<br/>  resolve(2);<br/>});<br/>aPromise.then(value =&gt; console.log(value));</span></pre><p id="5fff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当promise第一次调用resolve回调时，消费者通过<code class="fe mw mx my lj b">then()</code>子句接收第一个值。但是，第二次调用没有效果，因为您可以看到输出中只显示了第一个值。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="2f06" class="ln lo it lj b gy lp lq l lr ls">Promise started <br/>1</span></pre><h1 id="6e4e" class="lt lo it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">渴望vs懒惰</h1><p id="7b27" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">可观察的人和承诺之间的另一个区别是，可观察的人懒惰，而承诺的人渴望。</p><p id="ae8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个承诺是热切的，因为执行是立即开始的，不需要等待消费者。例如，在下面的代码片段中，在实例化承诺时，尽管没有消费者对承诺采取行动(通过调用<code class="fe mw mx my lj b">then()</code>子句), console.log()还是会执行。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="bbbe" class="ln lo it lj b gy lp lq l lr ls">const aPromise = new Promise((resolve, reject) =&gt; {<br/>  // The line below gets executed right away<br/>  console.log("Promise started");<br/>  // The resolve() only gets call when the consumer wants the data (via the then() clause). <br/>  resolve(1);<br/>});</span></pre><p id="82c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是控制台的输出:<code class="fe mw mx my lj b">Promise started</code></p><p id="bb8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，一个可观察对象是懒惰的，因为直到第一个观察者订阅它，它才开始工作。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="1fa5" class="ln lo it lj b gy lp lq l lr ls">const anObservable = new Observable(subscriber =&gt; {<br/>  // The line below does not get called until a subscriber subscribes to the observable. <br/>  console.log("Observable started");<br/>  subscriber.next(1);<br/>  subscriber.complete();<br/>});<br/><br/>// anObservable.subscribe(value =&gt; console.log(value));</span></pre><p id="9e81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要查看输出，取消最后一行代码的注释以订阅可观察对象。</p><p id="ec85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是输出:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="acd7" class="ln lo it lj b gy lp lq l lr ls">Observable started <br/>1</span></pre><h1 id="a4d2" class="lt lo it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">可取消与不可取消。</h1><p id="c83b" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">下一个区别是<em class="mv">一个可观察的是可取消的，而一个承诺不是</em>。</p><p id="31da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为一个承诺是急切的，而且只用于一次，所以它不支持取消，至少本机不支持。为了进行演示，请考虑下面的代码片段:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="485c" class="ln lo it lj b gy lp lq l lr ls">const aPromise = new Promise((resolve, reject) =&gt; {<br/>  console.log("Promise started");<br/>  var counter = 1;<br/>  const intervalId = setInterval(() =&gt; {<br/>    console.log(counter++);<br/>    if (counter &gt; 10) {<br/>      clearInterval(intervalId);<br/>      resolve("Promise finished");<br/>    }<br/>  }, 1000);<br/>});</span></pre><p id="c888" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码模拟了一个需要10秒钟才能完成的长时间运行的操作，它每秒钟输出一次计数器变量的值。当执行正在运行时，如果调用者决定取消，调用者没有办法取消。承诺会一直执行，直到完成。你需要自己构建取消或者使用第三方库。</p><p id="18c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是输出:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="90a2" class="ln lo it lj b gy lp lq l lr ls">Promise started<br/>1<br/>2<br/>3<br/>4<br/>5</span></pre><p id="d2a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，可观察对象本身支持取消。让我们修改上面的例子来使用Observables，看看我们如何在操作完成之前取消它。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="ce34" class="ln lo it lj b gy lp lq l lr ls">import { interval, Observable, Subscription } from "rxjs";<br/><br/>const anObservable = new Observable(subscriber =&gt; {<br/>  console.log("Observable started");<br/>  var counter = 1;<br/>  const intervalId = setInterval(() =&gt; {<br/>    if (subscriber.closed) {<br/>      console.log("Received cancellation");<br/>      clearInterval(intervalId);<br/>      subscriber.complete();<br/>    }<br/>    subscriber.next(counter++);<br/>    if (counter &gt; 10) {<br/>      subscriber.complete();<br/>    }<br/>  }, 1000);<br/>});<br/>// subscribe to receive values from the observable.<br/>const subscription: Subscription = anObservable.subscribe(value =&gt;<br/>  console.log(value)<br/>);<br/>// cancel the subscription after 2 seconds<br/>setInterval(() =&gt; subscription.unsubscribe(), 2000);</span></pre><p id="f338" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码片段中，消费者通过调用订阅的unsubscribe()方法向生产者发出取消信号。如果您不熟悉订阅，它基本上公开了管理和清理与订阅observables相关的资源的方法。对于生产者，它可以通过检查变量<code class="fe mw mx my lj b">closed</code>来检查取消请求。以下是输出:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="20e6" class="ln lo it lj b gy lp lq l lr ls">Observable started<br/>1<br/>2<br/>Received cancellation</span></pre><h1 id="c2ab" class="lt lo it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">多播与单播</h1><p id="df78" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">承诺和可观察对象之间的另一个区别是<em class="mv">可观察对象可以向多个观察者多播数据，而承诺只运行一次，并将数据返回给其唯一的消费者。</em></p><p id="0722" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了进行演示，请考虑下面的代码片段:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="ff98" class="ln lo it lj b gy lp lq l lr ls">const aPromise = new Promise((resolve, reject) =&gt; {<br/>  console.log("Promise started");<br/>  setTimeout(() =&gt; resolve(1), 1000);<br/>  setTimeout(() =&gt; resolve(2), 2000);<br/>});<br/>aPromise.then(value =&gt; console.log(value));<br/>aPromise.then(value =&gt; console.log(value));</span></pre><p id="fb2f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二次调用<code class="fe mw mx my lj b">then()</code>方法不会使承诺再次执行，因为承诺已经完成。事实上，一旦promise完成，它就会缓存结果并为所有后续的<code class="fe mw mx my lj b">then()</code>方法调用返回缓存的值，如下面的输出所示。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="d943" class="ln lo it lj b gy lp lq l lr ls">Promise started<br/>1<br/>1</span></pre><p id="5dd3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们看一个例子，一个可观察对象是如何组播的，这意味着它们可以向多个用户广播数据。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="33c6" class="ln lo it lj b gy lp lq l lr ls">const anObservable = new Observable(subscriber =&gt; {<br/>  console.log('Observable started.');<br/>  setTimeout(() =&gt; subscriber.next(1), 1000);<br/>  setTimeout(() =&gt; subscriber.next(2), 2000);<br/>});<br/>// each call to subscribe() results in a new Subscription<br/>const subscription: Subscription = anObservable.subscribe(value =&gt; console.log(value));<br/>const anotherSubscription: Subscription = anObservable.subscribe(value =&gt; console.log(value));</span></pre><p id="283b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码片段中，每个subscribe()调用返回一个新的订阅，我们可以从输出中看到observables运行两次，每个订阅一次，同时返回两个订阅者的数据。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="0c98" class="ln lo it lj b gy lp lq l lr ls">Observable started.<br/>Observable started.<br/>1<br/>1<br/>2<br/>2</span></pre><h1 id="790a" class="lt lo it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">同步和异步</h1><p id="2290" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">最后，虽然承诺在本质上是异步的，但是可观察的可以是同步的也可以是异步的。</p><p id="2863" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">承诺是异步的，这意味着在实例化承诺时，执行不会立即发生，而是在下一个事件循环中发生。另一方面，一旦实例化并订阅了一个可观察对象，该可观察对象就会立即运行。这样，一个可观察的可以提供更好的性能。</p><p id="60ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如下面的代码片段和输出所示，即使我们在可观察的结果之前声明了承诺，可观察的结果也在承诺的结果之前显示。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="faa8" class="ln lo it lj b gy lp lq l lr ls">import { interval, Observable, Subscription } from "rxjs";<br/><br/>const aPromise = new Promise((resolve, reject) =&gt; {<br/>  resolve('Hi there. I\'m a Promise ');<br/>});<br/>aPromise.then(value =&gt; console.log(value));<br/>const anObservable = new Observable((subscriber) =&gt; {<br/>  subscriber.next('Hi there. I\'m an Observable');<br/>})<br/>anObservable.subscribe(value =&gt; console.log(value));</span></pre><p id="cda8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是输出:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="3b78" class="ln lo it lj b gy lp lq l lr ls">Hi there. I'm an Observable<br/>Hi there. I'm a Promise</span></pre><p id="33a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可观察对象也可以是异步的。例如，我们可以包装。next()调用setTimeout()之类的异步函数，让observables异步发出值。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="acad" class="ln lo it lj b gy lp lq l lr ls">import { interval, Observable, Subscription } from "rxjs";<br/><br/>const aPromise = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; resolve('Hi there. I\'m a Promise '), 500);<br/>});<br/>aPromise.then(value =&gt; console.log(value));<br/>const anObservable = new Observable((subscriber) =&gt; {<br/>  setTimeout(() =&gt; subscriber.next('Hi there. I\'m an Observable'), 500);<br/>})<br/>anObservable.subscribe(value =&gt; console.log(value));</span></pre><p id="f55e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是输出:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="1ed4" class="ln lo it lj b gy lp lq l lr ls">Hi there. I'm a Promise <br/>Hi there. I'm an Observable</span></pre><p id="23c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为承诺和可观察对象都异步运行，并且因为我们首先声明承诺，所以来自承诺的输出在控制台中出现在来自可观察对象的输出之前，这是意料之中的。</p><h1 id="88a2" class="lt lo it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="6ea9" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">在这篇文章中，我展示了承诺和可观察之间的一些区别。两者都是生产和消费数据的伟大框架。然而，根据我的理解，一个可观察的人可以做承诺所能做的事情，甚至更多。此外，可观察的提供了比承诺更大的灵活性，因为它是多播和可取消的；默认情况下，这两个特征在承诺中都是缺失的。因此，你应该尽可能地用可观察的来代替承诺。</p><h1 id="e49a" class="lt lo it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">参考</h1><p id="fdd2" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated"><a class="ae kf" href="https://rxjs-dev.firebaseapp.com/guide/observable" rel="noopener ugc nofollow" target="_blank">可观察的</a></p><p id="68db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://javascript.plainenglish.io/canceling-promises-in-javascript-31f4b8524dcd" rel="noopener ugc nofollow" target="_blank">取消JavaScript中的承诺</a></p><p id="85cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://www.pluralsight.com/courses/ng-conf-2020-session-36" rel="noopener ugc nofollow" target="_blank">研讨会:RxJS第1天的反应基础</a></p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="5190" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mv">原载于2021年4月25日https://www.taithienbo.com</em><em class="mv"/><a class="ae kf" href="https://www.taithienbo.com/differences-between-a-promise-and-an-observable/" rel="noopener ugc nofollow" target="_blank"><em class="mv">。</em></a></p></div></div>    
</body>
</html>