<html>
<head>
<title>Man In The Middle Attack (MITM) Part 2 — Packet Sniffer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中间人攻击(MITM)第2部分—数据包嗅探器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/man-in-the-middle-attack-mitm-part-2-packet-sniffer-82f0a121c58d?source=collection_archive---------5-----------------------#2020-08-13">https://levelup.gitconnected.com/man-in-the-middle-attack-mitm-part-2-packet-sniffer-82f0a121c58d?source=collection_archive---------5-----------------------#2020-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="8d30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用Python构建数据包嗅探器🐍提取访问过的URL和用户凭证。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/421a19601d2b4d2592ba6d05834300ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vyDEtK2L28GK1XGGW4JkVw.jpeg"/></div></div></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><blockquote class="lh li lj"><p id="04d3" class="jq jr lk js b jt ju jv jw jx jy jz ka ll kc kd ke lm kg kh ki ln kk kl km kn im bi translated">这是中间人(MITM)攻击的第二部分。如果你还没有阅读第1部分，那么我强烈建议你在阅读第2部分之前先阅读第1部分。您可以在下一节找到第1部分的链接。</p></blockquote></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="13f7" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">什么是数据包嗅探器？</h1><p id="d6e6" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">数据包嗅探器是一种用于监控网络和诊断任何网络问题的工具。网络技术人员常用。黑客经常利用这一点来窥探用户的网络流量和提取密码。</p><p id="b657" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">数据包嗅探器在他们可以访问的网络<strong class="js iu">接口</strong>上记录网络流量。它可以看到流入和流出接口的每个<a class="ae mr" href="https://computer.howstuffworks.com/question525.htm#pt0" rel="noopener ugc nofollow" target="_blank">数据包</a>。</p><p id="d9ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能想知道我们正在设计一个数据包嗅探器，但是标题说的是中间人攻击。这是因为在<a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/man-in-the-middle-attack-part-1-arp-spoofing-6f5b174dec59"> Part 1 </a>中我们写了一个Python脚本(ARP欺骗)让我们成为中间人。数据包嗅探器的目的是捕获受害者(使用ARP欺骗攻击的用户)的网络流量，并提取访问过的URL和凭据。</p><div class="ms mt gp gr mu mv"><a rel="noopener  ugc nofollow" target="_blank" href="/man-in-the-middle-attack-part-1-arp-spoofing-6f5b174dec59"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">中间人攻击(MITM)第1部分— ARP欺骗</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">学习构建一个工具来执行中间人(MITM)攻击——使用Python在目标机器上进行ARP欺骗。</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ky mv"/></div></div></a></div></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="2558" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">使用的模块:</h1><ol class=""><li id="f4bc" class="nk nl it js b jt mm jx mn kb nm kf nn kj no kn np nq nr ns bi translated"><a class="ae mr" href="https://docs.python.org/3.4/library/subprocess.html" rel="noopener ugc nofollow" target="_blank"> argparse </a>:要理解这是什么，请在这里阅读我的第一篇文章<a class="ae mr" href="https://medium.com/@dharmilch18/changing-mac-address-using-python-8a16fc4a3563" rel="noopener"/>。</li><li id="f39e" class="nk nl it js b jt nt jx nu kb nv kf nw kj nx kn np nq nr ns bi translated"><a class="ae mr" href="https://scapy.readthedocs.io/en/latest/extending.html" rel="noopener ugc nofollow" target="_blank"> Scapy </a>:使用户能够发送、嗅探、解析和伪造网络数据包。这种能力允许开发能够探测、扫描或攻击网络的工具。它可以伪造或解码大量协议的数据包，通过网络发送它们，捕获它们，匹配请求和回复，等等。它可以轻松处理大多数任务，如扫描、跟踪路由、探测、单元测试、攻击或网络发现。</li><li id="4d2a" class="nk nl it js b jt nt jx nu kb nv kf nw kj nx kn np nq nr ns bi translated"><a class="ae mr" href="https://docs.python.org/3/library/time.html" rel="noopener ugc nofollow" target="_blank">时间</a>:我们只使用时间模块产生2秒的延迟。要了解本模块的更多信息，请阅读文档。</li></ol></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="3892" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">Python有什么功能🐍剧本必须有？</h1><ul class=""><li id="1823" class="nk nl it js b jt mm jx mn kb nm kf nn kj no kn ny nq nr ns bi translated"><code class="fe nz oa ob oc b">get_args()</code> —获取命令行参数的函数。在这种情况下，我们需要用户为接口<strong class="js iu">提供一个输入值，我们希望在这个接口上嗅探数据包。</strong></li><li id="5c3d" class="nk nl it js b jt nt jx nu kb nv kf nw kj nx kn ny nq nr ns bi translated"><code class="fe nz oa ob oc b">sniffer(interface)</code> —一个将<strong class="js iu">接口</strong>值作为输入并在该接口上嗅探数据包的函数。</li><li id="c465" class="nk nl it js b jt nt jx nu kb nv kf nw kj nx kn ny nq nr ns bi translated"><code class="fe nz oa ob oc b">process_packet(packet)</code> —由<code class="fe nz oa ob oc b">sniffer</code>函数为每个被嗅探的新数据包调用的函数。这将检查数据包是否属于<code class="fe nz oa ob oc b">HTTP Request</code>类型。对于这个用例，我们只需要<code class="fe nz oa ob oc b">HTTP Request</code>类型的数据包，因为我们想要的信息就是在这个数据包中发送的。然后使用<code class="fe nz oa ob oc b">get_url(packet)</code>和<code class="fe nz oa ob oc b">get_credentials(packet)</code>功能。</li><li id="d886" class="nk nl it js b jt nt jx nu kb nv kf nw kj nx kn ny nq nr ns bi translated"><code class="fe nz oa ob oc b">get_url(packet)</code> —从传递给它的<code class="fe nz oa ob oc b">packet</code>中提取URL的函数。</li><li id="d3e3" class="nk nl it js b jt nt jx nu kb nv kf nw kj nx kn ny nq nr ns bi translated"><code class="fe nz oa ob oc b">get_credentials(packet)</code> —也以<code class="fe nz oa ob oc b">packet</code>为输入并提取用户名和密码等凭证的函数。</li></ul><p id="fe35" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事不宜迟，让我们开始用Python编写脚本。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="0da3" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">用于数据包嗅探器的Python脚本</h1><p id="6e88" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">在本节中，我们将逐步构建脚本。我会解释每一步的所有内容，所以请仔细阅读。</p><p id="6795" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第一步:导入必要的模块</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated"><strong class="ak">导入模块</strong></figcaption></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="a8be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第二步:编写</strong> <code class="fe nz oa ob oc b">get_args()</code> <strong class="js iu">函数</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated"><strong class="ak">函数— get_args() </strong></figcaption></figure><p id="eb82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上述函数增加了允许用户将用户输入值作为命令行参数传递的功能。添加上述代码后，用户将能够在用于运行脚本的同一条指令中传递<code class="fe nz oa ob oc b">interface</code>的名称，数据包将在该名称上被嗅探。举个例子，</p><pre class="kp kq kr ks gt oj oc ok ol aw om bi"><span id="5162" class="on lp it oc b gy oo op l oq or">root@kali:~# python3 sniffer.py -i interface_name</span></pre><p id="11fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运筹学</p><pre class="kp kq kr ks gt oj oc ok ol aw om bi"><span id="912a" class="on lp it oc b gy oo op l oq or">root@kali:~# python3 sniffer.py --interface interface_name</span></pre><p id="4e45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要了解这个函数是如何工作的，请阅读关于如何<a class="ae mr" href="https://medium.com/@dharmilch18/changing-mac-address-using-python-8a16fc4a3563" rel="noopener">更改设备的MAC地址</a>的文章中的整个<strong class="js iu">步骤2 </strong>。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="0ff6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第三步:编写</strong> <code class="fe nz oa ob oc b">sniffer(interface)</code> <strong class="js iu">函数</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated"><strong class="ak">功能—嗅探器(接口)</strong></figcaption></figure><p id="ca1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以上要点包含了<code class="fe nz oa ob oc b">sniffer(interface)</code>函数的定义。它接受一个接口名称作为内部使用的输入。它使用由scapy模块提供的一个名为<code class="fe nz oa ob oc b">sniff</code>的方法。方法<code class="fe nz oa ob oc b">sniff </code>需要一个接口名<code class="fe nz oa ob oc b">iface</code>作为输入。下一个参数，<code class="fe nz oa ob oc b">store</code>告诉scapy是否将数据包存储在内存中。<code class="fe nz oa ob oc b">store = False</code>告诉scapy不要存储数据包。最后一个参数是<code class="fe nz oa ob oc b">prn</code>，它告诉scapy每次嗅探一个新包时要调用哪个函数。在这种情况下，每个新的包都调用<code class="fe nz oa ob oc b">process_packet</code>函数。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="29be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第四步:编写</strong> <code class="fe nz oa ob oc b">process_packet(packet)</code> <strong class="js iu">函数</strong></p><p id="d801" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在进入这个函数之前，让我们看一下scapy包是什么样子的。</p><pre class="kp kq kr ks gt oj oc ok ol aw om bi"><span id="5552" class="on lp it oc b gy oo op l oq or">###[ Ethernet ]###<br/>dst       = 52:54:00:12:35:00<br/>src       = 08:00:27:35:21:2e<br/>type      = IPv4<br/>###[ IP ]###<br/>version   = 4<br/>ihl       = 5<br/>tos       = 0x0<br/>len       = 441<br/>id        = 22651<br/>flags     = DF<br/>frag      = 0<br/>ttl       = 64<br/>proto     = tcp<br/>chksum    = 0xf1f9<br/>src       = 10.0.2.9<br/>dst       = 176.28.50.165<br/>\options   \<br/>###[ TCP ]###<br/>sport     = 48556<br/>dport     = http<br/>seq       = 790303956<br/>ack       = 327206<br/>dataofs   = 5<br/>reserved  = 0<br/>flags     = PA<br/>window    = 64240<br/>chksum    = 0xf075<br/>urgptr    = 0<br/>options   = []<br/>###[ HTTP 1 ]###<br/>###[ HTTP Request ]###<br/>Method    = 'GET'<br/>Path      = '/login.php'<br/>Http_Version= 'HTTP/1.1'<br/>A_IM      = None<br/>Accept    = 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'<br/>Accept_Charset= None<br/>Accept_Datetime= None<br/>Accept_Encoding= 'gzip, deflate'<br/>Accept_Language= 'en-US,en;q=0.5'<br/>Access_Control_Request_Headers= None<br/>Access_Control_Request_Method= None<br/>Authorization= None<br/>Cache_Control= 'max-age=0'<br/>Connection= 'keep-alive'<br/>Content_Length= None<br/>Content_MD5= None<br/>Content_Type= None<br/>Cookie    = None<br/>DNT       = None<br/>Date      = None<br/>Expect    = None<br/>Forwarded = None<br/>From      = Non<br/>Front_End_Https= None<br/>HTTP2_Settings= None<br/>Host      = 'testphp.vulnweb.com'<br/>If_Match  = None<br/>If_Modified_Since= None<br/>If_None_Match= None<br/>If_Range  = None<br/>If_Unmodified_Since= None<br/>Keep_Alive= None<br/>Max_Forwards= None<br/>Origin    = None<br/>Permanent = None<br/>Pragma    = None<br/>Proxy_Authorization= None<br/>Proxy_Connection= None<br/>Range     = None<br/>Referer   = '<a class="ae mr" href="http://testphp.vulnweb.com/login.php'" rel="noopener ugc nofollow" target="_blank">http://testphp.vulnweb.com/login.php</a></span></pre><p id="f6d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的块显示了包的内容。以<code class="fe nz oa ob oc b">###[text]###</code>开头的线称为<code class="fe nz oa ob oc b">layer</code>。其后的行是该<code class="fe nz oa ob oc b">layer</code>下的字段，直到遇到下一个<code class="fe nz oa ob oc b">layer</code>。例如，在上面的块中，<code class="fe nz oa ob oc b">###[ Ethernet ]###</code>是一个<code class="fe nz oa ob oc b">layer</code>，下面的行是以太网下的字段。这些字段包含有关以太网的信息。同理，<code class="fe nz oa ob oc b">###[ TCP ]###</code>，<code class="fe nz oa ob oc b">###[ HTTP Request ]###</code>等。都是<code class="fe nz oa ob oc b">layer</code>。现在，让我们跳到<strong class="js iu"> process_packet </strong>函数。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated"><strong class="ak">功能—进程_数据包(数据包)</strong></figcaption></figure><p id="1d1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个函数需要嗅探到的数据包作为输入。在这个函数中，我们首先检查数据包是否有一个<code class="fe nz oa ob oc b">HTTP Request</code>层。这是通过使用scapy提供的名为<code class="fe nz oa ob oc b">haslayer()</code>的方法来完成的。如果数据包没有该层，则不会对其进行处理。</p><p id="5b6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果它有<code class="fe nz oa ob oc b">HTTP Request</code>层，那么我们执行两个操作:</p><ol class=""><li id="3ebd" class="nk nl it js b jt ju jx jy kb os kf ot kj ou kn np nq nr ns bi translated">调用<code class="fe nz oa ob oc b">get_url(packet)</code>函数从数据包中提取URL。它将<code class="fe nz oa ob oc b">packet</code>作为输入。这个函数返回一个URL，我们将它存储在一个名为<code class="fe nz oa ob oc b">url</code>的变量中，然后打印出<code class="fe nz oa ob oc b">url</code>的值。</li><li id="5e7a" class="nk nl it js b jt nt jx nu kb nv kf nw kj nx kn np nq nr ns bi translated">然后我们调用另一个叫做<code class="fe nz oa ob oc b">get_credentials(packet)</code>的函数。它也将<code class="fe nz oa ob oc b">packet</code>作为输入。它检查数据包中可能的凭证，如果找到任何凭证，则返回这些凭证。我们将它存储在一个名为<code class="fe nz oa ob oc b">cred</code>的变量中，然后打印它的值。</li></ol><blockquote class="lh li lj"><p id="7c74" class="jq jr lk js b jt ju jv jw jx jy jz ka ll kc kd ke lm kg kh ki ln kk kl km kn im bi translated">我将在后面的步骤中解释<code class="fe nz oa ob oc b">get_url(packet)</code>和<code class="fe nz oa ob oc b">get_credentials(packet)</code>功能。</p></blockquote></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="eb74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第五步:编写</strong> <code class="fe nz oa ob oc b">get_url(packet)</code> <strong class="js iu">函数</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated"><strong class="ak">功能—获取url(数据包)</strong></figcaption></figure><p id="5fc7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nz oa ob oc b">get_url(packet)</code>函数也需要一个包作为输入来提取包中的URL。该功能提取数据包<code class="fe nz oa ob oc b">HTTPRequest</code>层的<code class="fe nz oa ob oc b">Host</code>和<code class="fe nz oa ob oc b">Path</code>子字段的内容。然后，我们将这两部分连接起来，并返回从数据包中提取的URL。以下是出现在<code class="fe nz oa ob oc b">Host</code>和<code class="fe nz oa ob oc b">Path</code>子字段中的内容示例。</p><pre class="kp kq kr ks gt oj oc ok ol aw om bi"><span id="12e0" class="on lp it oc b gy oo op l oq or">Path      = '/login.php'<br/>Host      = 'testphp.vulnweb.com'</span></pre><p id="5e96" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码<code class="fe nz oa ob oc b">packet[http.HTTPRequest]</code>允许我们访问这些层，由于Scapy，这是可能的。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="e0a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第六步:编写</strong> <code class="fe nz oa ob oc b">get_credentials(packet)</code> <strong class="js iu">函数</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated"><strong class="ak">功能—获取_凭证(数据包)</strong></figcaption></figure><p id="b7f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的代码中，可以看到一个名为<code class="fe nz oa ob oc b">keywords</code>的Python元组。在理解为什么需要它之前，让我们先理解函数本身。</p><p id="37a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个函数也需要一个包来处理。现在，当我们在第4步开始时查看数据包的内容时，并没有称为<code class="fe nz oa ob oc b">Raw</code>的层。这一层对于我们试图实现的目标至关重要，因为凭证等附加信息被添加到了<code class="fe nz oa ob oc b">Raw</code>层。下面的代码块显示了<code class="fe nz oa ob oc b">Raw</code>层。它还显示凭证存储在名为<code class="fe nz oa ob oc b">load</code>的子字段中。</p><pre class="kp kq kr ks gt oj oc ok ol aw om bi"><span id="4ba7" class="on lp it oc b gy oo op l oq or">###[ Raw ]###<br/>load = 'uname=hdhd&amp;pass=hshs'</span></pre><p id="2d6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在回到函数。首先，该函数检查数据包是否具有<code class="fe nz oa ob oc b">Raw</code>层。如果数据包具有该层，则它提取<code class="fe nz oa ob oc b">load</code>子字段的值，并将其存储在名为<strong class="js iu"> field_load </strong>的变量中。</p><p id="a7c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一步是使用for循环遍历我们前面讨论过的元组。元组包含关键字，这些关键字是在制作HTML表单时使用的表单字段的潜在名称。这些关键字是通过猜测用于设计HTML注册和登录表单的HTML表单元素的常用名称得到的。</p><p id="7c33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">for循环遍历元组中的每个元素，并检查是否有任何关键字出现在<strong class="js iu"> field_load </strong>变量中。如果任何关键字匹配，那么<strong class="js iu"> field_load </strong>返回到<code class="fe nz oa ob oc b">process_packet(packet)</code>函数以显示潜在的凭证。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="0328" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第7步:最后一步</strong></p><p id="be66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，剩下要做的就是调用<code class="fe nz oa ob oc b">get_args()</code>和<code class="fe nz oa ob oc b">sniffer(interface)</code>函数。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated"><strong class="ak">调用嗅探函数</strong></figcaption></figure><p id="27a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样，我们就完成了整个脚本，剩下要做的就是测试它。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="468a" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">整个脚本</h1><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated"><strong class="ak">整个脚本</strong></figcaption></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="9b36" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">工作演示</h1><p id="8ab9" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">好了，在开始用Python写代码之前，我要告诉你我的设置:我目前在Windows 10上，我有两个虚拟机运行<a class="ae mr" href="https://www.virtualbox.org/" rel="noopener ugc nofollow" target="_blank">Virtualbox</a>( 1。Kali Linux和2。Windows 10)。我将在我的Kali Linux机器上执行我们在第1部分中制作的python脚本——ARP欺骗，并攻击我的Windows 10虚拟机以成为中间人。然后，我将在我的Kali Linux机器上执行这一部分的数据包嗅探器脚本。之后，我将登录到一个网站，看看嗅探器脚本是否能够提取凭证。</p><p id="0da0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:虚拟机在Virtualbox中被配置为使用<strong class="js iu"> NatNetwork </strong>。当虚拟机设置为使用<strong class="js iu"> NatNetwork时，</strong>虚拟机认为主机是路由器(接入点)。要了解更多关于NatNetwork以及如何配置VM来使用它，请阅读<a class="ae mr" href="https://www.techrepublic.com/article/how-to-create-multiple-nat-networks-in-virtualbox/" rel="noopener ugc nofollow" target="_blank">这篇</a>。</p><p id="993f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:数据包嗅探器仅适用于使用HTTP协议的网站。这在HTTPS行不通。要测试，使用这个网站— <a class="ae mr" href="http://testphp.vulnweb.com/login.php" rel="noopener ugc nofollow" target="_blank">测试Vuln登录</a>。</p><h2 id="36f2" class="on lp it bd lq ov ow dn lu ox oy dp ly kb oz pa mc kf pb pc mg kj pd pe mk pf bi translated">Kali Linux机器</h2><ul class=""><li id="73c9" class="nk nl it js b jt mm jx mn kb nm kf nn kj no kn ny nq nr ns bi translated">IP地址= <strong class="js iu"> 10.0.2.9 </strong></li><li id="4a1f" class="nk nl it js b jt nt jx nu kb nv kf nw kj nx kn ny nq nr ns bi translated">MAC地址= <strong class="js iu"> 08:00:27:35:21:2e </strong></li></ul><h2 id="b3f1" class="on lp it bd lq ov ow dn lu ox oy dp ly kb oz pa mc kf pb pc mg kj pd pe mk pf bi translated">Windows 10</h2><ul class=""><li id="ddad" class="nk nl it js b jt mm jx mn kb nm kf nn kj no kn ny nq nr ns bi translated">IP地址= <strong class="js iu"> 10.0.2.15 </strong></li><li id="40fc" class="nk nl it js b jt nt jx nu kb nv kf nw kj nx kn ny nq nr ns bi translated">MAC地址= <strong class="js iu"> 08:00:27:e6:e5:59 </strong></li></ul><h2 id="5163" class="on lp it bd lq ov ow dn lu ox oy dp ly kb oz pa mc kf pb pc mg kj pd pe mk pf bi translated">接入点或默认网关</h2><ul class=""><li id="a534" class="nk nl it js b jt mm jx mn kb nm kf nn kj no kn ny nq nr ns bi translated">IP地址= <strong class="js iu"> 10.0.2.1 </strong></li><li id="a6b1" class="nk nl it js b jt nt jx nu kb nv kf nw kj nx kn ny nq nr ns bi translated">MAC地址= <strong class="js iu"> 52:54:00:12:35:00 </strong></li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pg"><img src="../Images/3365d6c9e82e86d98fa4263c03c01310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MhXoV7VA7Q2Xu5CvbEnkvw.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated"><strong class="bd lq">利用ARP欺骗成为中间人</strong></figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ph"><img src="../Images/ea17e3e730971d7b51c1e26b17b7e7d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DJ9TmYiF-82G3fu2WR4FUA.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated"><strong class="bd lq">证明我们是MITM </strong></figcaption></figure><p id="a2af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">MITM——中间的人</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/6f0e0ce5949f32c0930bae217325605f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*OyWMAQm_Q21HX-wwZfcUbQ.png"/></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated"><strong class="bd lq">执行数据包嗅探器脚本</strong></figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pj"><img src="../Images/ea222a2d00254cad84ff8063dfd95fc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9UVcQytOQvBuZauigh8jFg.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated"><strong class="bd lq">测试表格</strong></figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pk"><img src="../Images/86d4722f7911a8d51e6498834f15dfda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5UcVFqtMFSVFeAGufbW8mA.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated"><strong class="bd lq">凭证测试表</strong></figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pl"><img src="../Images/5217acfe72ee60c1041af0e77831efb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Exhwo9fgveHL1hJG8zS-w.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated"><strong class="bd lq">提取的网址</strong></figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pm"><img src="../Images/5eb7aac8306b07a34f818a6375a1c0b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ruKdfc3R8sd-6XtMbtTIvA.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated"><strong class="bd lq">提取凭证</strong></figcaption></figure><p id="43f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上图中，您可以看到我们已经从被嗅探的数据包中提取了捕获的用户名和密码。在测试表单中，我们输入了<code class="fe nz oa ob oc b">username = test_user</code>和<code class="fe nz oa ob oc b">password = test_user123</code>，在上图中，您可以看到我们在输出中获得了相同的用户名和密码值。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="5969" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结论</h1><p id="8ed2" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">我们成功地编写了一个Python🐍捕获数据包的脚本。我们还测试了中间人攻击——ARP欺骗。剧本如我们所愿完美地发挥了作用。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="fca4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以在我的<a class="ae mr" href="https://github.com/dharmil18/Packet-Sniffer" rel="noopener ugc nofollow" target="_blank"> Github库</a>上找到完整的脚本。谢谢你😃为了阅读。</p></div></div>    
</body>
</html>