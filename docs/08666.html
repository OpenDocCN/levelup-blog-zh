<html>
<head>
<title>10 Robustness and Resiliency Design Patterns to Learn Today</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">今天要学习的10个健壮性和弹性设计模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/10-robustness-and-resiliency-design-patterns-to-learn-today-c03776f73936?source=collection_archive---------4-----------------------#2021-05-23">https://levelup.gitconnected.com/10-robustness-and-resiliency-design-patterns-to-learn-today-c03776f73936?source=collection_archive---------4-----------------------#2021-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b98e922d22d2f75acc57c26cc5d040a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zA11UjCaC9Cm0_1-.jpg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://pixabay.com/users/wokandapix-614097/" rel="noopener ugc nofollow" target="_blank">workandpix</a>在<a class="ae kf" href="https://pixabay.com/photos/resilient-resiliency-resilience-4899283/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的图像</figcaption></figure><p id="ac8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果软件按照规定运行，它就是正确的。如果它能承受高负载直到停机，那么它就是健壮的。如果软件在中断后可以恢复正常，那么它就是有弹性的。中断可能是断电、临时网络中断、磁盘已满或暂时无法访问的web服务。有一些模式可以处理这些问题。学习它们，使用它们！</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="0bbf" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">1.撤退</h1><p id="c5c1" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">你可能知道:当连接中断时，你正在通勤，在智能手机上阅读你最喜欢的文章。你输入你最喜欢的博客网址——我希望是martin-thoma.com——但是你只知道你失去了互联网连接:</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/af379f1c1a3f451aae445f706a860384.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SZo74jQC-xHDwwqWI_6sgQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">截图由马丁·托马斯拍摄</figcaption></figure><p id="cf47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果没有连接，您的浏览器无法从互联网上获取任何信息。很明显。但是它能做什么呢？</p><p id="eea9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谷歌浏览器向你展示了一个迷你游戏。它试图告诉你你可以做些什么来修复它，你可以选择和恐龙一起玩。恐龙游戏不是你想要的，而是一个巧妙的退路。</p><p id="9199" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在其他情况下，回退被称为“故障保险”。火车上的<a class="ae kf" href="https://en.wikipedia.org/wiki/Dead_man%27s_switch" rel="noopener ugc nofollow" target="_blank">安全开关</a>就是一个具体的例子。火车司机必须每隔一段时间踩一次踏板，以显示他没事，而且注意力集中。如果列车驾驶员没有按下安全开关，列车将执行紧急停车。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="f597" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">2.重试</h1><p id="1722" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">当你在玩迷你游戏的时候，浏览器仍然可以访问这个网站。也许你的连接不稳定。这意味着你偶尔会有联系。浏览器可以尝试在后台获取你需要的内容，在你想回去的时候支持你离线阅读。不理想，但一个很好的退路。比迷你游戏好多了。</p><p id="6bf7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了获得这种改进的回退，浏览器必须重试访问网站。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/cb8f4fe4b0350245f23f3b39d93a817a.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/0*vc3gDjlRzdESb5LO.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片来自<a class="ae kf" href="https://commons.wikimedia.org/wiki/File:Screen_Shot_06-11-19_at_09.58_AM.png" rel="noopener ugc nofollow" target="_blank">维基共享</a></figcaption></figure><p id="323f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是的，这是一种模式。一个微不足道的，但却是重要的。我在发送网络请求时用过它。如果收到错误，请重试。Python <code class="fe mu mv mw mx b">requests</code>库对于一些错误情况有一个内置的<a class="ae kf" href="https://docs.python-requests.org/en/latest/api/?highlight=max_retries#requests.adapters.HTTPAdapter" rel="noopener ugc nofollow" target="_blank"> max_retries </a>参数。</p><p id="1a8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在某些情况下，您需要处理不断变化的状态。现在变得棘手了。也许你真的不知道之前的请求是否失败？你能冒险执行请求两次吗？你想要的性质是<strong class="ki iu">幂等</strong> : f(x) = f(f(x))。应用该函数两次会产生与应用一次相同的结果。</p><p id="f2b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">举个例子，如果你有一笔类似“马丁给安娜汇了50欧元”的转账，那就不是幂等的。如果你有“执行交易XYZ，如果没有执行之前”，这是。然而，现在您需要确保您有一个锁定机制，并且所有事务都有唯一的id。</p><p id="dfc8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重试连接到失败的服务会带来自身的问题。你可能会让服务更难恢复正常。出于这个原因，你可能要考虑<strong class="ki iu">限制指数补偿</strong>:</p><pre class="mp mq mr ms gt my mx mz na aw nb bi"><span id="28ea" class="nc lm it mx b gy nd ne l nf ng">max_sleep = 300 seconds<br/>base_sleep = 2 seconds<br/>sleep_time = min(max_sleep, base**attempts)</span></pre><p id="a9ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了防止多个服务同时发生，您可以添加抖动:</p><pre class="mp mq mr ms gt my mx mz na aw nb bi"><span id="9d2a" class="nc lm it mx b gy nd ne l nf ng">max_sleep = 300 seconds<br/>base_sleep = 2 seconds<br/>jitter = random(0s, 5s)</span><span id="034e" class="nc lm it mx b gy nh ne l nf ng">sleep_time = min(max_sleep, base**attempts) + jitter</span></pre><h1 id="c5d5" class="ll lm it bd ln lo ni lq lr ls nj lu lv lw nk ly lz ma nl mc md me nm mg mh mi bi translated">3.超时和其他资源限制</h1><p id="5034" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在某些时候，你需要接受某些东西坏掉了。但是你什么时候这样做呢？常见的默认情况是等待来自web服务的响应30秒。那真的很长。在许多情况下，您希望更快地暂停。超时基本上意味着你接受了出错的事实。超时后，您可以重试或使用回退。</p><p id="bb39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">限制一个函数、进程或程序的可能执行时间在其他情况下也是有利的。谷歌代码卡突然出现在我的脑海里。这是一个公开的竞赛，开发者提交代码来完成谷歌给出的任务。这些解决方案可能会有导致无限循环的缺陷。这意味着如果谷歌执行这些解决方案，他们需要限制潜在的执行时间。</p><p id="ec45" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看门狗可以监控整个系统的响应性，并在系统没有响应时重新启动一切。例如，Web服务通常有一个<code class="fe mu mv mw mx b">/health</code>端点，它用一些琐碎的东西来响应，例如常量字符串<code class="fe mu mv mw mx b">"healthy"</code>或当前系统时间。如果没有响应或响应时间过长，系统将被标记为“不健康”。如果太长时间不健康，Docker容器会重新启动。</p><p id="63ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能想要限制的另一个资源是内存和磁盘。想想想要检查ZIP存档的反病毒软件。存档可能是一个ZIP炸弹:</p><div class="nn no gp gr np nq"><a href="https://infosecwriteups.com/zip-bombs-30337a1b0112" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">拉链炸弹💣😈</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">让您的存储爆炸💥</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">infosecwriteups.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe jz nq"/></div></div></a></div><p id="caf4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过限制这两种资源，你可以确保自己不会受到这个问题的影响。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="7b00" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">4.断路器</h1><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div class="gh gi of"><img src="../Images/7471386e1bb4e3c55ca0d800a20e5140.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/0*QJlGl6Oslr7t1xeh.JPG"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://commons.wikimedia.org/wiki/User:Dmitry_G" rel="noopener ugc nofollow" target="_blank"> Dmitry G </a>拍摄的<a class="ae kf" href="https://commons.wikimedia.org/wiki/File:TDM_2-pole_circuit_breaker_16A.JPG" rel="noopener ugc nofollow" target="_blank"> Wikimedia Commons </a>上的双极断路器照片</figcaption></figure><p id="184f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你家一个房间的电力出了问题，比如某个部分短路或耗电过多，你希望其他所有部分都还能正常工作。</p><p id="65d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在软件的例子中，你可能会想到使用web服务B的web服务A，现在A注意到B开始变得越来越慢。现在，A可以将所有请求发送给B，并处理潜在的超时。然而，它也可以注意到B有问题。a停止向B发送正常请求，给B时间恢复。这意味着需要有一种机制来检查B是否再次健康。这可能只是一个健康终点。或者它可以是自动测量响应时间的节流模式。</p><p id="d42d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">断路器模式略微超出了抖动的上限指数回退。它跟踪来自多个来源的请求。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="5d15" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">5.限速</h1><p id="0d09" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我们已经讨论了具有指数补偿上限的重试模式和断路器模式，作为成为“好邻居”的方式，试图保护他们使用的服务。</p><p id="979f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，并不是每个用户都是这样的好邻居。他们可能不会故意伤害你，但是可能开发人员没有意识到他们正在使用一个会导致大量工作的端点。您可能希望能够限制API的使用方式——尤其是当它是公共的时候。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="d3f7" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">6.裁员</h1><p id="7f41" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">由于<a class="ae kf" href="https://www.datacenterdynamics.com/en/news/google-and-seagate-use-ai-to-predict-hard-drive-failures/" rel="noopener ugc nofollow" target="_blank">硬件</a>、<a class="ae kf" href="https://www.datacenterdynamics.com/en/news/texas-power-outages-bring-austin-city-data-center-offline/" rel="noopener ugc nofollow" target="_blank">停电</a>、<a class="ae kf" href="https://www.reuters.com/article/us-france-ovh-fire-idUSKBN2B20NU" rel="noopener ugc nofollow" target="_blank">数据中心失火</a>，或者由于施工造成的网络中断，服务器可能会出现故障，这只是其中的几个原因。有了冗余，系统对那些罕见的事件会更加健壮。</p><p id="cc88" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于硬盘，我们有不同的RAID级别<a class="ae kf" href="https://en.wikipedia.org/wiki/Standard_RAID_levels" rel="noopener ugc nofollow" target="_blank"/>。对于API，我们可以启动多个实例并进行循环负载平衡。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/46700bf622a014cfa83542fb4c6dc05a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*46FG93CzACdXJiDQptl5CQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片作者:马丁·托马斯</figcaption></figure><p id="aead" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设每台服务器都有99.0%的可用性。这意味着它每年下降3.65天。如果您有一个服务器并行运行的冗余系统，如上所述，当至少有一个服务器运行时，服务仍然运行。这意味着可用性增加到1-(1-p)^n，其中n是服务器的数量，p是一台服务器的可用性。让我们看看这些数字是如何随n变化的:</p><ul class=""><li id="7bd1" class="oh oi it ki b kj kk kn ko kr oj kv ok kz ol ld om on oo op bi translated">n=1:服务的可用性为99.0%。这相当于每年3.65天的停机时间。</li><li id="35f9" class="oh oi it ki b kj oq kn or kr os kv ot kz ou ld om on oo op bi translated">n=2:服务99.99%(“四个九”)可用。这相当于每年停机52分钟。</li><li id="2c16" class="oh oi it ki b kj oq kn or kr os kv ot kz ou ld om on oo op bi translated">n=3:服务是99.9999%(“六个九”)可用的。这相当于每年31秒的停机时间。</li></ul><p id="cdb0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是假设一台服务器停机不会损害其他服务器—这不太可能，因为负载会增加。</p><p id="8a14" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您还应该注意，这是针对并行运行并且可以相互替换的服务的。如果你有互相依赖的服务，这个公式就变成了p^n:</p><ul class=""><li id="c8be" class="oh oi it ki b kj kk kn ko kr oj kv ok kz ol ld om on oo op bi translated">n=1:服务的可用性为99.0%。这相当于每年3.65天的停机时间。</li><li id="2291" class="oh oi it ki b kj oq kn or kr os kv ot kz ou ld om on oo op bi translated">n=2:服务的可用性为98.01%。也就是说每年有7.27天的停机时间。</li><li id="487c" class="oh oi it ki b kj oq kn or kr os kv ot kz ou ld om on oo op bi translated">n=3:服务的可用性为97.03%。这相当于每年10.8天的停机时间。</li></ul><p id="9c20" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您不需要存储或修改状态，那么启动这样的并行机是很容易的。对于数据库来说要困难得多。</p><p id="1f6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我在这里主要写的是服务器，但是你也可以想到<strong class="ki iu">纠错码</strong>在网络通信和存储的情况下也是冗余模式。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="aee8" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">7.防水壁</h1><p id="aa11" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">隔板提供了故障不会传播的边界。例如，想想YouTube。用户可以上传视频，视频会被重新编码。在单独的机器上执行该任务可以保证磁盘空间、内存使用、CPU使用以及所用库中的潜在漏洞不会影响系统的其余部分。让软件在单独的机器上运行是沙盒的一种形式。我们可以通过这种强隔离来保证这个单一特性不会影响到其他特性。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="5a4b" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">8.贮藏</h1><p id="025f" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我对缓存又爱又恨。一方面，缓存大大降低了服务器的负载。它们也提供了一个很好的退路。另一方面，您需要处理缓存引入的不一致。也许您需要显式地使缓存无效。</p><p id="ca00" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ov ow ep" href="https://medium.com/u/a8fba86a184d?source=post_page-----c03776f73936--------------------------------" rel="noopener" target="_blank"> Adrian Hornsby </a>写了一篇关于弹性缓存的好文章:</p><div class="nn no gp gr np nq"><a href="https://medium.com/the-cloud-architect/patterns-for-resilient-architecture-part-4-85afa66d6341" rel="noopener follow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">弹性架构的模式——第4部分</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">弹性缓存</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">medium.com</p></div></div><div class="nz l"><div class="ox l ob oc od nz oe jz nq"/></div></div></a></div></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="3d52" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">9.边界验证</h1><p id="03c6" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">您希望确保服务的输入按照预期的方式构建，并且您提供了承诺的输出。你可以使用像<a class="ae kf" href="https://pypi.org/project/pydantic/" rel="noopener ugc nofollow" target="_blank"> pydantic </a>这样的库来清楚地定义你期望作为输入的模型。检查参数很重要。如果事情不像预期的那样，你应该早点失败。如果一个外部API已经改变了它的响应类型，比如从浮点到字符串，你应该尽早知道。最好的情况下，你甚至可以自动转换。如果您收到一个复杂的字典，并且服务在很大程度上改变了响应的结构，拥有清晰的模型会有很大帮助。</p><p id="90de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于外部系统，您希望清楚地将输入模型与其余部分分开。这至少应该是它自己的模块或类。如果是更大的东西，甚至可能是它自己的库或包装外部服务的内部服务。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="3f08" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">10.卷回</h1><p id="4f6e" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">并不总是外部世界让我们的软件失败。我们开发人员引入的编程错误也有其公平的份额。事实上，我认为没有一个重要的系统是没有错误的。有些错误是可以接受的，有些则不然。而且有些bug问题很大，需要尽快修复。</p><p id="5838" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是回滚发挥作用的地方。回滚意味着跳回到稳定的系统状态。我从两个方面了解它们:一个是像git这样的版本控制系统，在这个系统中恢复了以前的版本。或者从系统的角度来看，例如使用<a class="ae kf" href="https://en.wikipedia.org/wiki/OpenShift" rel="noopener ugc nofollow" target="_blank"> OpenShift容器平台</a>。每个服务都运行在Docker容器中。更新服务意味着添加新的图像并更改<code class="fe mu mv mw mx b">service:latest</code>标签。如果服务从未正常运行，则使用最后一个已知的正常映像。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="cb2a" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">摘要</h1><p id="8cec" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">呈现的设计模式可以分为:</p><ul class=""><li id="d136" class="oh oi it ki b kj kk kn ko kr oj kv ok kz ol ld om on oo op bi translated"><strong class="ki iu">检测</strong>:得知有问题。<code class="fe mu mv mw mx b">Timeouts</code>和<code class="fe mu mv mw mx b">Checksums</code>都属于这一类。</li><li id="06f0" class="oh oi it ki b kj oq kn or kr os kv ot kz ou ld om on oo op bi translated"><strong class="ki iu">遏制</strong>:确保错误不影响其他系统，限制对用户的影响。这一类的模式有<code class="fe mu mv mw mx b">Fallback</code>、<code class="fe mu mv mw mx b">Resource Limitation</code>、<code class="fe mu mv mw mx b">Circuit Breaker</code>、<code class="fe mu mv mw mx b">Bulkhead</code>、<code class="fe mu mv mw mx b">Caching</code></li><li id="5026" class="oh oi it ki b kj oq kn or kr os kv ot kz ou ld om on oo op bi translated">恢复:重新站起来。<code class="fe mu mv mw mx b">Retry</code>和<code class="fe mu mv mw mx b">Rollback</code>都属于这一类</li><li id="a62f" class="oh oi it ki b kj oq kn or kr os kv ot kz ou ld om on oo op bi translated"><strong class="ki iu">预防</strong>:首先避免陷入困境。<code class="fe mu mv mw mx b">Rate Limiting</code>、<code class="fe mu mv mw mx b">Redundancy</code>、<code class="fe mu mv mw mx b">Caching</code>、<code class="fe mu mv mw mx b">Boundary Validation</code>这样做。</li></ul><p id="e3aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望这对你有帮助！</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="a14a" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">资源</h1><ul class=""><li id="76bf" class="oh oi it ki b kj mj kn mk kr oy kv oz kz pa ld om on oo op bi translated"><a class="ov ow ep" href="https://medium.com/u/936659f5f641?source=post_page-----c03776f73936--------------------------------" rel="noopener" target="_blank">saz zad his sain Khan</a>:<a class="ae kf" href="https://medium.com/@hissain.khan/distinguishing-system-robustness-resilience-stability-flexibility-and-performance-f509e87bcc49" rel="noopener">区分系统健壮性、弹性、稳定性、灵活性和性能</a>，2019。</li><li id="9720" class="oh oi it ki b kj oq kn or kr os kv ot kz ou ld om on oo op bi translated">Saurabh Hukerikar，Christian Engel Mann:“<a class="ae kf" href="https://www.osti.gov/servlets/purl/1407767" rel="noopener ugc nofollow" target="_blank">弹性设计模式:在极端规模下弹性的结构化方法</a>”</li></ul></div></div>    
</body>
</html>