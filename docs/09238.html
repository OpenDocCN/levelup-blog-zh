<html>
<head>
<title>5 Ways to Mock DateTime.Now for Unit Testing in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模仿日期时间的5种方法。现在用C#进行单元测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-ways-to-mock-datetime-now-for-unit-testing-in-c-bf0438eab032?source=collection_archive---------0-----------------------#2021-07-20">https://levelup.gitconnected.com/5-ways-to-mock-datetime-now-for-unit-testing-in-c-bf0438eab032?source=collection_archive---------0-----------------------#2021-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5ac4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">各有利弊。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/48102c9300f88e8405f3b40775255bfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4OxD0GdpMf88MRcZ"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@lukechesser?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢克·切瑟</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="13b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<code class="fe lv lw lx ly b">DateTime.Now</code>属性中抽象出应用程序逻辑是开发人员进行单元测试的常见任务。</p><p id="0519" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe lv lw lx ly b">DateTime</code>被硬编码成逻辑时，单元测试将不可靠。</p><p id="233a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的示例中，单元测试只有在非常快的机器上执行时才能通过:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="674b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用逻辑中使用的<code class="fe lv lw lx ly b">DateTime.Now</code>实例通常与测试用例断言中使用的<code class="fe lv lw lx ly b">DateTime.Now</code>具有不同的毫秒/节拍数。</p><p id="143a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至少有5种方法可以解决单元测试中的<code class="fe lv lw lx ly b">DateTime.Now</code>问题，并使它们可预测地运行。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="01da" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">1.IDateTimeProvider接口</h1><p id="c15c" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">最常见的方法之一是引入应用程序逻辑将使用的接口，而不是直接使用<code class="fe lv lw lx ly b">DateTime.Now</code>属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h2 id="7b67" class="nf mj it bd mk ng nh dn mo ni nj dp ms li nk nl mu lm nm nn mw lq no np my nq bi translated">优点:</h2><ul class=""><li id="e112" class="nr ns it lb b lc na lf nb li nt lm nu lq nv lu nw nx ny nz bi translated"><code class="fe lv lw lx ly b">IDateTimeProvider</code>依赖关系是显式的。要了解一个特定的类是否能与<code class="fe lv lw lx ly b">IDateTimeProvider</code>一起工作，开发人员只需要看看这个类的构造函数。没有必要分析类逻辑的其余部分。</li><li id="7212" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">拥有一个返回当前<code class="fe lv lw lx ly b">DateTime</code>的方法比拥有一个属性更自然。通常，当C#开发人员多次调用同一个属性时，他们期望获得相同的值。</li></ul><h2 id="ad7a" class="nf mj it bd mk ng nh dn mo ni nj dp ms li nk nl mu lm nm nn mw lq no np my nq bi translated">缺点:</h2><ul class=""><li id="0c3c" class="nr ns it lb b lc na lf nb li nt lm nu lq nv lu nw nx ny nz bi translated">所有代码库中的许多类构造函数在列表中都有一个额外的<code class="fe lv lw lx ly b">IDateTimeProvider</code>参数，这会污染代码。</li><li id="7a59" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">有必要在DI容器中注册接口和实现。</li><li id="ddfb" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">没有什么可以阻止开发人员直接使用<code class="fe lv lw lx ly b">DateTime</code>类型，绕过<code class="fe lv lw lx ly b">IDateTimeProvider</code>实现。</li></ul></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="d984" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">2.单一DateTimeProvider类</h1><p id="5ad6" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">前面的例子可以简化。接口<code class="fe lv lw lx ly b">IDateTimeProvider</code>及其两个实现可以合并成一个<code class="fe lv lw lx ly b">DateTimeProvider</code>类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h2 id="ba0c" class="nf mj it bd mk ng nh dn mo ni nj dp ms li nk nl mu lm nm nn mw lq no np my nq bi translated">优点:</h2><ul class=""><li id="07f2" class="nr ns it lb b lc na lf nb li nt lm nu lq nv lu nw nx ny nz bi translated"><code class="fe lv lw lx ly b">DateTimeProvider</code>是一个显式依赖，因为它被注入到构造函数中。</li><li id="823f" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">解决方案很简单，因为它只有一个类。</li></ul><h2 id="1a96" class="nf mj it bd mk ng nh dn mo ni nj dp ms li nk nl mu lm nm nn mw lq no np my nq bi translated">缺点:</h2><ul class=""><li id="a090" class="nr ns it lb b lc na lf nb li nt lm nu lq nv lu nw nx ny nz bi translated">同样，没有什么可以阻止开发人员直接使用<code class="fe lv lw lx ly b">DateTime</code>类型。</li><li id="9b21" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">需要在DI容器中进行额外注册。</li></ul></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="adc6" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">3.周围环境模式</h1><p id="b1ec" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">有一种方法可以使用环境上下文模式实现为<code class="fe lv lw lx ly b">DateTime</code>提供一个全局访问点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h2 id="40a3" class="nf mj it bd mk ng nh dn mo ni nj dp ms li nk nl mu lm nm nn mw lq no np my nq bi translated">优点:</h2><ul class=""><li id="8396" class="nr ns it lb b lc na lf nb li nt lm nu lq nv lu nw nx ny nz bi translated">使用<code class="fe lv lw lx ly b">DateTimeProvider</code>与使用<code class="fe lv lw lx ly b">DateTime</code>类非常相似。</li><li id="9e56" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">不需要做DI注册。</li></ul><h2 id="e054" class="nf mj it bd mk ng nh dn mo ni nj dp ms li nk nl mu lm nm nn mw lq no np my nq bi translated">缺点:</h2><ul class=""><li id="e20b" class="nr ns it lb b lc na lf nb li nt lm nu lq nv lu nw nx ny nz bi translated">因为<code class="fe lv lw lx ly b">DateTimeProvider</code>的实现是基于一个共享的静态属性，所以测试不能并行运行。</li><li id="db5d" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe lv lw lx ly b">DateTimeProvider</code>的依赖是隐式的，因为不需要将它注入到构造函数中来使用它。开发人员应该检查该类的整个实现，看它是否在那里被使用。</li><li id="0de3" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">同样，没有什么可以阻止开发人员直接使用<code class="fe lv lw lx ly b">DateTime</code>类型。</li></ul></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="fc36" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">4.单行包装</h1><p id="17ba" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">下面的实现为<code class="fe lv lw lx ly b">DateTime.Now</code>属性提供了一个简单的包装器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h2 id="6302" class="nf mj it bd mk ng nh dn mo ni nj dp ms li nk nl mu lm nm nn mw lq no np my nq bi translated">优点:</h2><ul class=""><li id="f400" class="nr ns it lb b lc na lf nb li nt lm nu lq nv lu nw nx ny nz bi translated"><code class="fe lv lw lx ly b">DateTimeProvider</code>是一个单行实现。</li><li id="a224" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe lv lw lx ly b">DateTimeProvider</code>依赖关系是显式的。</li></ul><h2 id="fbdc" class="nf mj it bd mk ng nh dn mo ni nj dp ms li nk nl mu lm nm nn mw lq no np my nq bi translated">缺点:</h2><ul class=""><li id="1bd8" class="nr ns it lb b lc na lf nb li nt lm nu lq nv lu nw nx ny nz bi translated">属性<code class="fe lv lw lx ly b">Now</code>必须是虚拟的。否则，Moq框架将无法在模仿类型上创建包装。我们用仅用于单元测试目的的东西污染了应用程序逻辑。</li><li id="9f9c" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">需要对<code class="fe lv lw lx ly b">DateTimeProvider</code>进行DI注册。</li><li id="7b3a" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">同样，没有什么可以阻止开发人员直接使用<code class="fe lv lw lx ly b">DateTime</code>类型。</li></ul></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="5519" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">5.姿势库</h1><p id="e6ce" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">最后一种方法是保持应用程序逻辑不变，使用<a class="ae ky" href="https://github.com/tonerdo/pose" rel="noopener ugc nofollow" target="_blank"> Pose </a>库，它允许您用自己的委托替换任何属性或方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h2 id="2eb7" class="nf mj it bd mk ng nh dn mo ni nj dp ms li nk nl mu lm nm nn mw lq no np my nq bi translated">优点:</h2><ul class=""><li id="8622" class="nr ns it lb b lc na lf nb li nt lm nu lq nv lu nw nx ny nz bi translated">无需更改应用程序逻辑。</li><li id="5c7f" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">开发者唯一的选择就是<code class="fe lv lw lx ly b">DateTime</code>类型。</li></ul><h2 id="426f" class="nf mj it bd mk ng nh dn mo ni nj dp ms li nk nl mu lm nm nn mw lq no np my nq bi translated">缺点:</h2><ul class=""><li id="73a9" class="nr ns it lb b lc na lf nb li nt lm nu lq nv lu nw nx ny nz bi translated">嘲笑你不拥有的类型通常是一种不好的做法。</li><li id="7a6d" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">第三方库可能包含错误，需要额外的维护工作等。</li><li id="dfb7" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe lv lw lx ly b">DateTime</code>类型将在应用程序逻辑中隐式使用。</li></ul></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><p id="4c5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经看到了实现相同目标的5种不同方法，各有利弊。</p><p id="c235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p><p id="e47a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑订阅我的电报频道<a class="ae ky" href="https://t.me/sd_daily" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">软件开发日报</strong> </a>从我这里获取更多内容。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h2 id="6a81" class="nf mj it bd mk ng nh dn mo ni nj dp ms li nk nl mu lm nm nn mw lq no np my nq bi translated">我的其他文章</h2><div class="of og gp gr oh oi"><a rel="noopener  ugc nofollow" target="_blank" href="/static-classes-and-methods-are-they-terrible-c9c611a921b3"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">静态类和方法——它们很糟糕吗？</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">从设计角度探索C#静态类和方法。</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ks oi"/></div></div></a></div><div class="of og gp gr oh oi"><a rel="noopener  ugc nofollow" target="_blank" href="/50-software-engineering-best-practices-for-technical-leaders-and-seniors-cfcdf6a17e44"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">面向技术领导者和资深人士的50个软件工程最佳实践</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">最佳工程师的最佳实践。</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow ks oi"/></div></div></a></div><div class="of og gp gr oh oi"><a rel="noopener  ugc nofollow" target="_blank" href="/5-asp-net-core-open-source-projects-to-gain-practical-knowledge-24fbf9164230"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">5个ASP.NET核心开源项目，获取实用知识</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">在实践中学习。</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="or l"><div class="oy l ot ou ov or ow ks oi"/></div></div></a></div></div></div>    
</body>
</html>