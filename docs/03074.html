<html>
<head>
<title>Using RocksDB with Spring Boot and Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Spring Boot和Java使用RocksDB</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-rocksdb-with-spring-boot-and-java-99cb1c43a834?source=collection_archive---------0-----------------------#2020-04-18">https://levelup.gitconnected.com/using-rocksdb-with-spring-boot-and-java-99cb1c43a834?source=collection_archive---------0-----------------------#2020-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6eec74252cdedc310919e5975cd50e9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uKk2beL5neN8ls2T"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@arstyy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">奥斯汀·尼尔</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="55eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://rocksdb.org/" rel="noopener ugc nofollow" target="_blank"> RocksDB </a>是脸书的嵌入式键值存储，是Google的<a class="ae kc" href="https://github.com/google/leveldb" rel="noopener ugc nofollow" target="_blank"> LevelDB </a>的分支。它被用作多个数据库的存储层，例如<a class="ae kc" href="https://www.cockroachlabs.com/" rel="noopener ugc nofollow" target="_blank">cocroach db</a>。您可以将它用作嵌入式存储、缓存(而不是Redis)、您自己的定制数据库、文件系统或存储解决方案的存储层等。</p><blockquote class="lb lc ld"><p id="e84f" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><em class="iq">TL；博士:这里是</em> <a class="ae kc" href="https://github.com/ukchukx/rocksdb-example" rel="noopener ugc nofollow" target="_blank"> <em class="iq">代号</em> </a> <em class="iq">。</em></p></blockquote><p id="8132" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在pom.xml中，添加以下依赖项以引入RocksDB:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="ad28" class="lr ls iq ln b gy lt lu l lv lw">&lt;dependency&gt;                           <br/>    &lt;groupId&gt;org.rocksdb&lt;/groupId&gt; <br/>    &lt;artifactId&gt;rocksdbjni&lt;/artifactId&gt;  <br/>    &lt;version&gt;6.6.4&lt;/version&gt;   <br/>&lt;/dependency&gt;</span></pre><p id="06fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你用格雷德…你就要自己照顾自己了，我很抱歉。\_(ツ)_/</p><p id="3e66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为参考，可以看看我自己的<a class="ae kc" href="https://github.com/ukchukx/rocksdb-example/blob/master/pom.xml" rel="noopener ugc nofollow" target="_blank"> pom.xml </a>。</p><p id="a2e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之后，我们想要描述一个存储库接口，通过它我们的应用程序可以与一般的存储服务，尤其是RocksDB进行交互。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="4168" class="lr ls iq ln b gy lt lu l lv lw">import java.util.Optional;</span><span id="7277" class="lr ls iq ln b gy lx lu l lv lw">public interface KVRepository&lt;K, V&gt; {<br/>  boolean save(K key, V value);<br/>  Optional&lt;V&gt; find(K key);<br/>  boolean delete(K key);<br/>}</span></pre><p id="85fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">保存、查找和删除是我们对任何键值存储的基本要求，所以我们定义了这些。有了这个接口，我们可以使用任何键值存储，而无需改变应用程序的其他部分，这是一个很好的设计。<br/>接下来，我们创建我们的RocksDB存储库作为这个接口的实现:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="0ac6" class="lr ls iq ln b gy lt lu l lv lw">import lombok.extern.slf4j.Slf4j;<br/>import org.rocksdb.Options;<br/>import org.rocksdb.RocksDB;<br/>import org.rocksdb.RocksDBException;<br/>import org.springframework.stereotype.Repository;<br/>import org.springframework.util.SerializationUtils;</span><span id="bdc3" class="lr ls iq ln b gy lx lu l lv lw">import javax.annotation.PostConstruct;<br/>import java.io.File;<br/>import java.io.IOException;<br/>import java.nio.file.Files;<br/>import java.util.Optional;</span><span id="1743" class="lr ls iq ln b gy lx lu l lv lw">@Slf4j<br/>@Repository<br/>public class RocksDBRepository implements KVRepository&lt;String, Object&gt; {<br/>  private final static String FILE_NAME = "spring-boot-db";<br/>  File baseDir;<br/>  RocksDB db;</span><span id="80e2" class="lr ls iq ln b gy lx lu l lv lw">  @PostConstruct // execute after the application starts.<br/>  void initialize() {<br/>    RocksDB.loadLibrary();<br/>    final Options options = new Options();<br/>    options.setCreateIfMissing(true);<br/>    baseDir = new File("/tmp/rocks", FILE_NAME);</span><span id="a658" class="lr ls iq ln b gy lx lu l lv lw">    try {<br/>      Files.createDirectories(baseDir.getParentFile().toPath());<br/>      Files.createDirectories(baseDir.getAbsoluteFile().toPath());<br/>      db = RocksDB.open(options, baseDir.getAbsolutePath());</span><span id="3909" class="lr ls iq ln b gy lx lu l lv lw">      log.info("RocksDB initialized");<br/>    } catch(IOException | RocksDBException e) {<br/>      log.error("Error initializng RocksDB. Exception: '{}', message: '{}'", e.getCause(), e.getMessage(), e);<br/>    }<br/>  }</span><span id="12a2" class="lr ls iq ln b gy lx lu l lv lw">  @Override<br/>  public synchronized boolean save(String key, Object value) {<br/>    log.info("saving value '{}' with key '{}'", value, key);</span><span id="22a7" class="lr ls iq ln b gy lx lu l lv lw">    try {<br/>      db.put(key.getBytes(), SerializationUtils.serialize(value));<br/>    } catch (RocksDBException e) {<br/>      log.error("Error saving entry. Cause: '{}', message: '{}'", e.getCause(), e.getMessage());</span><span id="c218" class="lr ls iq ln b gy lx lu l lv lw">      return false;<br/>    }</span><span id="1398" class="lr ls iq ln b gy lx lu l lv lw">    return true;<br/>  }</span><span id="b463" class="lr ls iq ln b gy lx lu l lv lw">  @Override<br/>  public synchronized Optional&lt;Object&gt; find(String key) {<br/>    Object value = null;</span><span id="fa65" class="lr ls iq ln b gy lx lu l lv lw">    try {<br/>      byte[] bytes = db.get(key.getBytes());<br/>      if (bytes != null) value = SerializationUtils.deserialize(bytes);<br/>    } catch (RocksDBException e) {<br/>      log.error(<br/>        "Error retrieving the entry with key: {}, cause: {}, message: {}", <br/>        key, <br/>        e.getCause(), <br/>        e.getMessage()<br/>      );<br/>    }</span><span id="7be9" class="lr ls iq ln b gy lx lu l lv lw">    log.info("finding key '{}' returns '{}'", key, value);</span><span id="54e5" class="lr ls iq ln b gy lx lu l lv lw">    return value != null ? Optional.of(value) : Optional.empty();<br/>  }</span><span id="b2e2" class="lr ls iq ln b gy lx lu l lv lw">  @Override<br/>  public synchronized boolean delete(String key) {<br/>    log.info("deleting key '{}'", key);</span><span id="49a9" class="lr ls iq ln b gy lx lu l lv lw">    try {<br/>      db.delete(key.getBytes());<br/>    } catch (RocksDBException e) {<br/>      log.error("Error deleting entry, cause: '{}', message: '{}'", e.getCause(), e.getMessage());</span><span id="89d1" class="lr ls iq ln b gy lx lu l lv lw">      return false;<br/>    }</span><span id="c6ee" class="lr ls iq ln b gy lx lu l lv lw">    return true;<br/>  }<br/>}</span></pre><p id="edff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当应用程序在<code class="fe ly lz ma ln b">initialize()</code>启动时，我们初始化我们的数据库。RocksDB是一个低级存储，所以在与它在<code class="fe ly lz ma ln b">save()</code>、<code class="fe ly lz ma ln b">find()</code>和<code class="fe ly lz ma ln b">delete()</code>中交互之前，我们需要将我们的键值对序列化为字节。</p><p id="260c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是全部…真的。</p><p id="f215" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个阶段，我们的存储库已经完成，但还不太可用。让我们添加一个控制器，使我们能够与存储库进行交互:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="7165" class="lr ls iq ln b gy lt lu l lv lw">import com.ukchukx.rocksdbexample.repository.KVRepository;<br/>import lombok.extern.slf4j.Slf4j;<br/>import org.springframework.http.MediaType;<br/>import org.springframework.http.ResponseEntity;<br/>import org.springframework.http.HttpStatus;<br/>import org.springframework.web.bind.annotation.DeleteMapping;<br/>import org.springframework.web.bind.annotation.GetMapping;<br/>import org.springframework.web.bind.annotation.PathVariable;<br/>import org.springframework.web.bind.annotation.PostMapping;<br/>import org.springframework.web.bind.annotation.RequestBody;<br/>import org.springframework.web.bind.annotation.RequestMapping;<br/>import org.springframework.web.bind.annotation.RestController;</span><span id="df22" class="lr ls iq ln b gy lx lu l lv lw">import java.util.Optional;</span><span id="8777" class="lr ls iq ln b gy lx lu l lv lw">@Slf4j<br/>@RestController<br/>@RequestMapping("/api")<br/>public class Api {<br/>  private final KVRepository&lt;String, Object&gt; repository;</span><span id="61b4" class="lr ls iq ln b gy lx lu l lv lw">  public Api(KVRepository&lt;String, Object&gt; repository) {<br/>    this.repository = repository;<br/>  }</span><span id="085f" class="lr ls iq ln b gy lx lu l lv lw">  // curl -iv -X POST -H "Content-Type: application/json" -d '{"bar":"baz"}' http://localhost:8080/api/foo<br/>  @PostMapping(value = "/{key}", <br/>              consumes = MediaType.APPLICATION_JSON_VALUE, <br/>              produces = MediaType.APPLICATION_JSON_VALUE)<br/>  public ResponseEntity&lt;Object&gt; save(@PathVariable("key") String key, @RequestBody Object value) {<br/>    return repository.save(key, value) <br/>      ? ResponseEntity.ok(value) <br/>      : ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();<br/>  }</span><span id="fd9b" class="lr ls iq ln b gy lx lu l lv lw">  // curl -iv -X GET -H "Content-Type: application/json" http://localhost:8080/api/foo<br/>  @GetMapping(value = "/{key}", produces = MediaType.APPLICATION_JSON_VALUE)<br/>  public ResponseEntity&lt;Object&gt; find(@PathVariable("key") String key) {<br/>    return ResponseEntity.of(repository.find(key));<br/>  }</span><span id="a816" class="lr ls iq ln b gy lx lu l lv lw">  // curl -iv -X DELETE -H "Content-Type: application/json" http://localhost:8080/api/foo<br/>  @DeleteMapping(value = "/{key}", produces = MediaType.APPLICATION_JSON_VALUE)<br/>  public ResponseEntity&lt;Object&gt; delete(@PathVariable("key") String key) {<br/>    return repository.delete(key) <br/>      ? ResponseEntity.noContent().build() <br/>      : ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();<br/>  }<br/>}</span></pre><p id="0ac9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们声明了一个简单的REST控制器，它公开了保存、查找和删除端点。这就是全部了。</p><p id="a208" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">继续使用cURL或Postman保存、查找和删除项目。</p></div></div>    
</body>
</html>