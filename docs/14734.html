<html>
<head>
<title>Compiler-Friendly Code: Sealed Keyword in .NET C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编译器友好代码:在。NET C#</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/compiler-friendly-code-sealed-keyword-in-net-c-b363fbcd1e35?source=collection_archive---------5-----------------------#2022-12-20">https://levelup.gitconnected.com/compiler-friendly-code-sealed-keyword-in-net-c-b363fbcd1e35?source=collection_archive---------5-----------------------#2022-12-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5c79" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">最佳实践</h2><div class=""/><div class=""><h2 id="eb37" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">Why &amp; When Sealed关键字可以提高。NET C#</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/3a7cb53c739b02c90aec537ea272e7d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EchwmSbm_KFBdB7z6_fO8A.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">编译器友好代码:在。NET C# </strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="55fb" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">编写编译器友好的代码意味着什么？</p><p id="0238" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">任何。NET代码经过一个以上的阶段，直到最后到达机器码。由于在这个过程中涉及到许多因素，当我们第一次编写代码时，可能会错过许多细节。</p><p id="d77a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然而，我们写的代码越清晰和确定，编译器就越能帮助我们并生成优化的机器码。</p><p id="4600" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在本文中，我们将讨论一个帮助编译器优化代码的例子。这种方式是；使用<strong class="ll jd">密封关键字</strong>。</p><p id="1912" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">说够了，让我们来看一个例子…</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mf"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure><div class="mg mh gp gr mi mj"><a href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener follow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd jd gy z fp mo fr fs mp fu fw jc bi translated">🔥订阅艾哈迈德的时事通讯🔥</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">订阅艾哈迈德的时事通讯📰直接获得最佳实践、教程、提示、技巧和许多其他很酷的东西…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">medium.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx lb mj"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mf"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure><h1 id="a48a" class="my mz it bd lh na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">背景调查</h1><p id="653f" class="pw-post-body-paragraph lj lk it ll b lm np kd lo lp nq kg lr ls nr lu lv lw ns ly lz ma nt mc md me im bi translated">如果您是. NET开发人员，甚至是初学者，您现在应该知道在。名为<code class="fe nu nv nw nx b">sealed</code>的. NET框架。</p><p id="8857" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这个关键字可以用在<strong class="ll jd">类定义</strong>中，这意味着该类不能被任何其他类继承。看起来是这样的:</p><pre class="ks kt ku kv gt ny nx nz bn oa ob bi"><span id="281b" class="oc mz it nx b be od oe l of og">public sealed class MyClass {}</span></pre><p id="ef2a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">或者甚至在<strong class="ll jd">方法声明</strong>中，这意味着该方法不能被子类中的任何其他方法覆盖。换句话说，它在使用它的级别打破了方法重写系列。看起来是这样的:</p><pre class="ks kt ku kv gt ny nx nz bn oa ob bi"><span id="aaad" class="oc mz it nx b be od oe l of og">public sealed override void MyMethod() {}</span></pre><p id="6180" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">因此，我们由此可以理解的是，当我们使用<code class="fe nu nv nw nx b">sealed</code>关键字时，我们实际上是在向编译器承诺，我们没有任何继承一个类或重写一个方法的意图。</p><p id="768f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">说到这里，现在让我们看看这对编译器有什么意义。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mf"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/80dd409ae3499fe5e0a0ffe8c9a2b3ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z1h1piWaMmSjiXVxVbVpOg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">基本代码</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>提供</figcaption></figure><p id="8cfd" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们从整个解释中使用的一些基本代码开始。</p><h2 id="7b1a" class="oi mz it bd lh oj ok dn nd ol om dp nh ls on oo nj lw op oq nl ma or os nn iz bi translated">基类</h2><pre class="ks kt ku kv gt ny nx nz bn oa ob bi"><span id="9518" class="oc mz it nx b be od oe l of og">public class BaseClass<br/>{<br/>    public virtual void DoSomething()<br/>    {<br/>    }<br/><br/>    public void DoSomethingElse()<br/>    {<br/>    }<br/>}</span></pre><p id="f007" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这是我们将用作顶级父类的基类。</p><p id="b89c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在这个类中，我们定义了以下成员:</p><ul class=""><li id="348b" class="ot ou it ll b lm ln lp lq ls ov lw ow ma ox me oy oz pa pb bi translated"><code class="fe nu nv nw nx b">public virtual void DoSomething()</code>法。</li><li id="6000" class="ot ou it ll b lm pc lp pd ls pe lw pf ma pg me oy oz pa pb bi translated"><code class="fe nu nv nw nx b">public void DoSomethingElse()</code>方法。</li></ul></div><div class="ab cl ph pi hx pj" role="separator"><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm"/></div><div class="im in io ip iq"><h2 id="4e31" class="oi mz it bd lh oj ok dn nd ol om dp nh ls on oo nj lw op oq nl ma or os nn iz bi translated">我的班级</h2><pre class="ks kt ku kv gt ny nx nz bn oa ob bi"><span id="b95b" class="oc mz it nx b be od oe l of og">public class MyClass : BaseClass<br/>{<br/>    public override void DoSomething()<br/>    {<br/>    }<br/>}</span></pre><p id="e3bc" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这是从<code class="fe nu nv nw nx b">BaseClass</code>继承的类，但是在定义中没有使用<code class="fe nu nv nw nx b">sealed</code>关键字。</p><p id="cfba" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在这个类中，我们覆盖了从父类<code class="fe nu nv nw nx b">BaseClass</code>继承的<code class="fe nu nv nw nx b">DoSomething</code>方法。</p></div><div class="ab cl ph pi hx pj" role="separator"><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm"/></div><div class="im in io ip iq"><h2 id="1266" class="oi mz it bd lh oj ok dn nd ol om dp nh ls on oo nj lw op oq nl ma or os nn iz bi translated">MySealedClass</h2><pre class="ks kt ku kv gt ny nx nz bn oa ob bi"><span id="f249" class="oc mz it nx b be od oe l of og">public sealed class MySealedClass : BaseClass<br/>{<br/>    public override void DoSomething()<br/>    {<br/>    }<br/>}</span></pre><p id="a4b9" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这是从<code class="fe nu nv nw nx b">BaseClass</code>继承的类，但是这次我们在定义中使用了<code class="fe nu nv nw nx b">sealed</code>关键字。</p><p id="7583" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在这个类中，我们覆盖了从父类<code class="fe nu nv nw nx b">BaseClass</code>继承的<code class="fe nu nv nw nx b">DoSomething</code>方法。</p></div><div class="ab cl ph pi hx pj" role="separator"><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm"/></div><div class="im in io ip iq"><p id="0886" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在，让我们来看看使用<code class="fe nu nv nw nx b">MyClass</code>和<code class="fe nu nv nw nx b">MySealedClass</code>类之间是否有任何不同——从编译器的角度来看。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mf"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/0c9a829dd2e666dbd74940012421e1dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H_ptpuOMvRA5Qit4E6fQIg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">调用虚拟方法</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><h2 id="78f0" class="oi mz it bd lh oj ok dn nd ol om dp nh ls on oo nj lw op oq nl ma or os nn iz bi translated">调用虚拟方法</h2><p id="4fa6" class="pw-post-body-paragraph lj lk it ll b lm np kd lo lp nq kg lr ls nr lu lv lw ns ly lz ma nt mc md me im bi translated">从编译器的角度来看，为了验证在<code class="fe nu nv nw nx b">MyClass</code>和<code class="fe nu nv nw nx b">MySealedClass</code>类上调用虚拟方法的<strong class="ll jd">之间是否有任何不同，我们将创建一个<strong class="ll jd">基准</strong>项目。</strong></p><pre class="ks kt ku kv gt ny nx nz bn oa ob bi"><span id="5488" class="oc mz it nx b be od oe l of og">[MemoryDiagnoser(false)]<br/>public class Benchmarking<br/>{<br/>    private readonly int NumberOfTrials = 10;<br/>    private MyClass _myClassObject = new MyClass();<br/>    private MySealedClass _mySealedClassObject = new MySealedClass();<br/><br/>    [Benchmark]<br/>    public void CallingVirtualMethodOnMyClass()<br/>    {<br/>        for (var i = 0; i &lt; NumberOfTrials; i++)<br/>        {<br/>            _myClassObject.DoSomething();<br/>        }<br/>    }<br/><br/>    [Benchmark]<br/>    public void CallingVirtualMethodOnMySealedClass()<br/>    {<br/>        for (var i = 0; i &lt; NumberOfTrials; i++)<br/>        {<br/>            _mySealedClassObject.DoSomething();<br/>        }<br/>    }<br/>}</span></pre><p id="8ae2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在，运行这个<strong class="ll jd">基准</strong>项目，我们会得到以下结果。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi po"><img src="../Images/a3e61ec784da6aa4f914d88770a4aa1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uYXnWT5uOwSH8G-MAFS6YA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">调用虚拟方法结果</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="7dfd" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">正如我们在这里可以注意到的，在密封类上调用虚方法的性能要比在非密封类上调用它好得多。</p><p id="5460" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">但是为什么呢？！！！让我告诉你。</p></div><div class="ab cl ph pi hx pj" role="separator"><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm"/></div><div class="im in io ip iq"><p id="9f12" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jd">非密封类上</strong></p><p id="d6ef" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在调用从<code class="fe nu nv nw nx b">MyClass</code>类创建的对象上的虚拟方法时，此时编译器不知道是否有一些代码用<code class="fe nu nv nw nx b">MyClass</code>类的子类的新实例重新初始化了<code class="fe nu nv nw nx b">_myClassObject</code>对象。这个假设是有效的，因为<code class="fe nu nv nw nx b">MyClass</code>类不是密封的，这意味着它可以被继承。</p><p id="17a2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">基于这样的假设，编译器不能在编译时决定<code class="fe nu nv nw nx b">DoSomething</code>方法的实际实现是由<code class="fe nu nv nw nx b">MyClass</code>类还是它的任何其他子类提供的。</p><p id="72ac" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">因此，编译器将编写一些指令——在运行时执行——在执行<code class="fe nu nv nw nx b">DoSomething</code>方法时检查哪个实现是正确的。<strong class="ll jd">这肯定会花费更多的处理和时间</strong>。</p><p id="1aa0" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi pp translated">注意:正如你注意到的，编译器会怀疑某些代码可能会重新初始化对象。您可能认为将字段标记为<code class="fe nu nv nw nx b">readonly</code>会解决问题，但实际上不会，因为对象仍然可以在构造函数中重新初始化。</p></div><div class="ab cl ph pi hx pj" role="separator"><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm"/></div><div class="im in io ip iq"><p id="bec3" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jd">在密封类上</strong></p><p id="6bdf" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在调用从<code class="fe nu nv nw nx b">MySealedClass</code>类创建的对象上的虚拟方法时，编译器不知道是否有一些代码用新的实例重新初始化了<code class="fe nu nv nw nx b">_mySealedClassObject</code>对象。然而，编译器确信，即使发生了这种情况，实例仍然是<code class="fe nu nv nw nx b">MySealedClass</code>类，因为它是<code class="fe nu nv nw nx b">sealed</code>，这意味着它永远不会有任何子类。</p><p id="f7fb" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">基于此，编译器将在编译时决定<code class="fe nu nv nw nx b">DoSomething</code>方法的实际实现。<strong class="ll jd">这肯定比等待运行时间</strong>要快得多。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mf"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/9e8650ae965360ee15a3613bafe37d57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kx8eMXK52sGfalqMqhVZHQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">调用非虚拟方法</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><h2 id="2b53" class="oi mz it bd lh oj ok dn nd ol om dp nh ls on oo nj lw op oq nl ma or os nn iz bi translated">调用非虚拟方法</h2><p id="bdef" class="pw-post-body-paragraph lj lk it ll b lm np kd lo lp nq kg lr ls nr lu lv lw ns ly lz ma nt mc md me im bi translated">从编译器的角度来看，为了验证在<code class="fe nu nv nw nx b">MyClass</code>和<code class="fe nu nv nw nx b">MySealedClass</code>类上调用非虚方法是否有任何不同，我们将创建一个<strong class="ll jd">基准</strong>项目。</p><pre class="ks kt ku kv gt ny nx nz bn oa ob bi"><span id="afa2" class="oc mz it nx b be od oe l of og">[MemoryDiagnoser(false)]<br/>public class Benchmarking<br/>{<br/>    private readonly int NumberOfTrials = 10;<br/>    private BaseClass _baseClassObject = new BaseClass();<br/>    private MyClass _myClassObject = new MyClass();<br/>    private MySealedClass _mySealedClassObject = new MySealedClass();<br/>    private MyClass[] _myClassObjectsArray = new MyClass[1];<br/>    private MySealedClass[] _mySealedClassObjectsArray = new MySealedClass[1];<br/><br/>    [Benchmark]<br/>    public void CallingNonVirtualMethodOnMyClass()<br/>    {<br/>        for (var i = 0; i &lt; NumberOfTrials; i++)<br/>        {<br/>            _myClassObject.DoSomethingElse();<br/>        }<br/>    }<br/><br/>    [Benchmark]<br/>    public void CallingNonVirtualMethodOnMySealedClass()<br/>    {<br/>        for (var i = 0; i &lt; NumberOfTrials; i++)<br/>        {<br/>            _mySealedClassObject.DoSomethingElse();<br/>        }<br/>    }<br/>}</span></pre><p id="d071" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在，运行这个<strong class="ll jd">基准</strong>项目，我们会得到下面的结果。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi po"><img src="../Images/04d6753339683c27082b109e1d04041f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9kIe8QB6R9H6P1-ToGkbw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">调用非虚方法结果</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="2004" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">正如我们在这里可以注意到的，在密封类上调用非虚方法的性能比在非密封类上调用要好。</p><p id="b5b4" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然而，没有科学证据说明为什么会发生这种情况，实际上再次运行相同的基准项目可能会得到相反的结果。</p><p id="0c9f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">因此，这种差异很可能是由基准框架本身造成的，因为差异太小，可以忽略不计。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mf"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/e2e20d68190364afffdeb315168a1481.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LPYOADiwxCL0yTyfNOkMuw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">型式检查</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><h2 id="eb95" class="oi mz it bd lh oj ok dn nd ol om dp nh ls on oo nj lw op oq nl ma or os nn iz bi translated">类型检查</h2><p id="e746" class="pw-post-body-paragraph lj lk it ll b lm np kd lo lp nq kg lr ls nr lu lv lw ns ly lz ma nt mc md me im bi translated">从编译器的角度来看，为了验证在<code class="fe nu nv nw nx b">MyClass</code>和<code class="fe nu nv nw nx b">MySealedClass</code>类上使用 <code class="fe nu nv nw nx b"><strong class="ll jd">is</strong></code> <strong class="ll jd">操作符</strong>检查对象类型的<strong class="ll jd">之间是否有任何区别，我们将创建一个<strong class="ll jd">基准</strong>项目。</strong></p><pre class="ks kt ku kv gt ny nx nz bn oa ob bi"><span id="afb1" class="oc mz it nx b be od oe l of og">[MemoryDiagnoser(false)]<br/>public class Benchmarking<br/>{<br/>    private readonly int NumberOfTrials = 10;<br/>    private BaseClass _baseClassObject = new BaseClass();<br/>    <br/>    [Benchmark]<br/>    public bool ObjectTypeIsMyClass()<br/>    {<br/>        for (var i = 0; i &lt; NumberOfTrials; i++)<br/>        {<br/>            var x = _baseClassObject is MyClass;<br/>        }<br/><br/>        return true;<br/>    }<br/><br/>    [Benchmark]<br/>    public bool ObjectTypeIsMySealedClass()<br/>    {<br/>        for (var i = 0; i &lt; NumberOfTrials; i++)<br/>        {<br/>            var x = _baseClassObject is MySealedClass;<br/>        }<br/><br/>        return true;<br/>    }<br/>}</span></pre><p id="e675" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在，运行这个<strong class="ll jd">基准</strong>项目，我们会得到下面的结果。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi po"><img src="../Images/f4b7f3cb2c7465c4da3dd4f53f138d2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t22ctonL6pgnxdzUl5_Z_A.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">型式检验结果</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a></figcaption></figure><p id="fcde" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">正如我们在这里可以注意到的，在密封类上检查对象类型的性能比在非密封类上调用它要好。</p><p id="8df7" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">但是为什么呢？！！！让我告诉你。</p></div><div class="ab cl ph pi hx pj" role="separator"><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm"/></div><div class="im in io ip iq"><p id="4e72" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jd">非密封类上</strong></p><p id="29e5" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在检查对象的类型是否为<code class="fe nu nv nw nx b">MyClass</code>类时，编译器需要检查对象的类型是否为<code class="fe nu nv nw nx b">MyClass</code>类或其任何子类。</p><p id="7256" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">因此，这导致更多的指令和更多的处理和时间。</p></div><div class="ab cl ph pi hx pj" role="separator"><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm"/></div><div class="im in io ip iq"><p id="acf3" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jd">上密封类</strong></p><p id="b635" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在检查对象的类型是否是<code class="fe nu nv nw nx b">MySealedClass</code>类时，编译器需要检查对象是否只是类型<code class="fe nu nv nw nx b">MySealedClass</code>类，而不是其他。这是因为<code class="fe nu nv nw nx b">MySealedClass</code>类是密封的，这意味着它永远不会有任何子类。</p><p id="cb0b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">因此，这导致更少的指令和更少的处理和时间。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mf"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/96bba758d6adec2a7e576c8deeb1acdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IGXLgRQ6Dy0NvveRNOe5Rw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">型铸造</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><h2 id="c4e1" class="oi mz it bd lh oj ok dn nd ol om dp nh ls on oo nj lw op oq nl ma or os nn iz bi translated">铅字铸造</h2><p id="edae" class="pw-post-body-paragraph lj lk it ll b lm np kd lo lp nq kg lr ls nr lu lv lw ns ly lz ma nt mc md me im bi translated">从编译器的角度来看，为了验证在<code class="fe nu nv nw nx b">MyClass</code>和<code class="fe nu nv nw nx b">MySealedClass</code>类上使用 <code class="fe nu nv nw nx b"><strong class="ll jd">as</strong></code> <strong class="ll jd">操作符</strong>对一个对象进行<strong class="ll jd">转换是否有任何不同，我们将创建一个<strong class="ll jd">基准</strong>项目。</strong></p><pre class="ks kt ku kv gt ny nx nz bn oa ob bi"><span id="f47d" class="oc mz it nx b be od oe l of og">[MemoryDiagnoser(false)]<br/>public class Benchmarking<br/>{<br/>    private readonly int NumberOfTrials = 10;<br/>    private BaseClass _baseClassObject = new BaseClass();<br/>    <br/>    [Benchmark]<br/>    public void ObjectTypeAsMyClass()<br/>    {<br/>        for (var i = 0; i &lt; NumberOfTrials; i++)<br/>        {<br/>            var x = _baseClassObject as MyClass;<br/>        }<br/>    }<br/><br/>    [Benchmark]<br/>    public void ObjectTypeAsMySealedClass()<br/>    {<br/>        for (var i = 0; i &lt; NumberOfTrials; i++)<br/>        {<br/>            var x = _baseClassObject as MySealedClass;<br/>        }<br/>    }<br/>}</span></pre><p id="81a1" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在，运行这个<strong class="ll jd">基准</strong>项目，我们会得到下面的结果。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi po"><img src="../Images/d0752ec08f8477e988cbae1df119b23f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yGUqV3AkwdhpOkyy_I9D_g.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">型铸造结果</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a></figcaption></figure><p id="179f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">正如我们在这里注意到的，在密封类上转换对象的性能比在非密封类上调用它要好。</p><p id="e133" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">但是为什么呢？！！！让我告诉你。</p></div><div class="ab cl ph pi hx pj" role="separator"><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm"/></div><div class="im in io ip iq"><p id="cb5f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jd">非密封类上</strong></p><p id="1841" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在将对象转换为<code class="fe nu nv nw nx b">MyClass</code>类时，编译器需要检查对象是属于类型<code class="fe nu nv nw nx b">MyClass</code>类还是它的任何子类。</p><p id="2a23" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">因此，这导致更多的指令和更多的处理和时间。</p></div><div class="ab cl ph pi hx pj" role="separator"><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm"/></div><div class="im in io ip iq"><p id="f91a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jd">在密封类上</strong></p><p id="3d0a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在将对象转换为<code class="fe nu nv nw nx b">MySealedClass</code>类时，编译器需要检查对象是否只是类型<code class="fe nu nv nw nx b">MySealedClass</code>类，而不是其他。这是因为<code class="fe nu nv nw nx b">MySealedClass</code>类是密封的，这意味着它永远不会有任何子类。</p><p id="ebfd" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">因此，这导致更少的指令和更少的处理和时间。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mf"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/ededa6569888dae03c37a2413e242dbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y5sLCaQnhmJODMXcbZF-3A.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">将对象存储在数组</strong>中。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><h2 id="e00a" class="oi mz it bd lh oj ok dn nd ol om dp nh ls on oo nj lw op oq nl ma or os nn iz bi translated">将对象存储在数组中</h2><p id="291c" class="pw-post-body-paragraph lj lk it ll b lm np kd lo lp nq kg lr ls nr lu lv lw ns ly lz ma nt mc md me im bi translated">为了验证在<code class="fe nu nv nw nx b">MyClass</code>和<code class="fe nu nv nw nx b">MySealedClass</code>类上<strong class="ll jd">在数组</strong>中存储一个对象是否有任何不同，我们将创建一个<strong class="ll jd">基准</strong>项目。</p><pre class="ks kt ku kv gt ny nx nz bn oa ob bi"><span id="7d26" class="oc mz it nx b be od oe l of og">[MemoryDiagnoser(false)]<br/>public class Benchmarking<br/>{<br/>    private readonly int NumberOfTrials = 10;<br/>    private MyClass _myClassObject = new MyClass();<br/>    private MySealedClass _mySealedClassObject = new MySealedClass();<br/>    private MyClass[] _myClassObjectsArray = new MyClass[1];<br/>    private MySealedClass[] _mySealedClassObjectsArray = new MySealedClass[1];<br/><br/>    [Benchmark]<br/>    public void StoringValuesInMyClassArray()<br/>    {<br/>        for (var i = 0; i &lt; NumberOfTrials; i++)<br/>        {<br/>            _myClassObjectsArray[0] = _myClassObject;<br/>        }<br/>    }<br/><br/>    [Benchmark]<br/>    public void StoringValuesInMySealedClassArray()<br/>    {<br/>        for (var i = 0; i &lt; NumberOfTrials; i++)<br/>        {<br/>            _mySealedClassObjectsArray[0] = _mySealedClassObject;<br/>        }<br/>    }<br/>}</span></pre><p id="4be3" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在，运行这个<strong class="ll jd">基准</strong>项目，我们会得到下面的结果。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi po"><img src="../Images/a783f500e5d5f5066341d7980fcf7e48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B3B_2Ckt0ifQZTZwRktfRQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">将对象存储在数组结果中</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="ab06" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">正如我们在这里可以注意到的，将对象存储在密封类的数组中比在非密封类中调用它的性能要好。</p><p id="42a6" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">但是为什么呢？！！！让我告诉你。</p></div><div class="ab cl ph pi hx pj" role="separator"><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm"/></div><div class="im in io ip iq"><p id="d2d4" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在进入细节之前，让我首先提醒你一个重要的观点；<strong class="ll jd">数组</strong>是<strong class="ll jd">协变</strong>。</p><p id="c77c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这意味着如果我们定义了以下类:</p><pre class="ks kt ku kv gt ny nx nz bn oa ob bi"><span id="7972" class="oc mz it nx b be od oe l of og">public class A {}<br/>public class B : A {}</span></pre><p id="0f0b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">那么下面的代码将是有效的:</p><pre class="ks kt ku kv gt ny nx nz bn oa ob bi"><span id="430f" class="oc mz it nx b be od oe l of og">A[] arrayOfA = new B[5];</span></pre><p id="df64" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">此外，我们可以将<code class="fe nu nv nw nx b">arrayOfA</code>中的一个项目设置为<code class="fe nu nv nw nx b">B</code>的一个实例，如下所示:</p><pre class="ks kt ku kv gt ny nx nz bn oa ob bi"><span id="4fd0" class="oc mz it nx b be od oe l of og">arrayOfA[0] = new B();</span></pre><p id="ba60" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">说到这里，让我们继续我们的主题。</p></div><div class="ab cl ph pi hx pj" role="separator"><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm"/></div><div class="im in io ip iq"><p id="4e11" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jd">非密封类上</strong></p><p id="73fe" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在<code class="fe nu nv nw nx b">_myClassObjectsArray</code>数组中设置一个项目时，编译器需要检查我们正在使用的实例<code class="fe nu nv nw nx b">_myClassObject</code>是属于类型<code class="fe nu nv nw nx b">MyClass</code>类还是它的任何子类。</p><p id="dee2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">因此，这导致更多的指令和更多的处理和时间。</p></div><div class="ab cl ph pi hx pj" role="separator"><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm"/></div><div class="im in io ip iq"><p id="9012" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jd">上封类</strong></p><p id="0470" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当在<code class="fe nu nv nw nx b">_mySealedClassObjectsArray</code>数组中设置一个项目时，编译器需要检查我们正在使用的实例<code class="fe nu nv nw nx b">_mySealedClassObject</code>是否仅仅属于类型<code class="fe nu nv nw nx b">MySealedClass</code>类，而不是其他。这是因为<code class="fe nu nv nw nx b">MySealedClass</code>类是密封的，这意味着它永远不会有任何子类。</p><p id="0770" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">因此，这导致更少的指令和更少的处理和时间。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mf"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/68dc36eb0fb4166ff60c84f58c46fa6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i7xhUsMLAwcP0hX0qh1n2A.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">早期故障检测</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><h2 id="3624" class="oi mz it bd lh oj ok dn nd ol om dp nh ls on oo nj lw op oq nl ma or os nn iz bi translated">早期故障检测</h2><p id="d979" class="pw-post-body-paragraph lj lk it ll b lm np kd lo lp nq kg lr ls nr lu lv lw ns ly lz ma nt mc md me im bi translated">除了通过使用<code class="fe nu nv nw nx b">sealed</code>关键字可以获得性能提升之外，我们还可以避免一些运行时故障。让我给你看一个例子。</p><p id="a26f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果我们编写以下代码:</p><pre class="ks kt ku kv gt ny nx nz bn oa ob bi"><span id="399a" class="oc mz it nx b be od oe l of og">public void Run(MyClass obj)<br/>{<br/>    _ = _baseClassObject as IMyInterface;<br/>}</span></pre><p id="27c6" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">编译器——在设计时——不会显示任何警告或错误，因为实际上<code class="fe nu nv nw nx b">obj</code>可以是类型<code class="fe nu nv nw nx b">MyClass</code>类或它的任何子类。因此，编译器需要等待运行时进行最终检查。</p><p id="aaea" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当然，如果在运行时<code class="fe nu nv nw nx b">obj</code>的真实类型没有实现<code class="fe nu nv nw nx b">IMyInterface</code>，这将导致运行时异常。</p></div><div class="ab cl ph pi hx pj" role="separator"><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm"/></div><div class="im in io ip iq"><p id="3692" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">但是，如果我们编写以下代码:</p><pre class="ks kt ku kv gt ny nx nz bn oa ob bi"><span id="bcef" class="oc mz it nx b be od oe l of og">public void Run(MySealedClass obj)<br/>{<br/>    _ = _baseClassObject as IMyInterface;<br/>}</span></pre><p id="7fa1" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">编译器会在设计时显示一个错误(CS0039 ),因为<code class="fe nu nv nw nx b">obj</code>只能是类型<code class="fe nu nv nw nx b">MySealedClass</code>类，不能是其他类型。因此，编译器可以立即检查<code class="fe nu nv nw nx b">MySealedClass</code>类是否实现了<code class="fe nu nv nw nx b">IMyInterface</code>。</p><p id="0d8b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">因此，这意味着使用sealed关键字使编译器能够在设计时执行适当的静态更改。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mf"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi py"><img src="../Images/f9b214ad96409ebf23edba3c3d22a29f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OlUeEFrFJE_GcJdFLZIPsQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">最终想法</strong>。照片由<a class="ae li" href="https://unsplash.com/@neonbrand?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">肯尼·埃利亚松</a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔雷克</a>调整</figcaption></figure><h1 id="de7e" class="my mz it bd lh na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">最后的想法</h1><p id="4763" class="pw-post-body-paragraph lj lk it ll b lm np kd lo lp nq kg lr ls nr lu lv lw ns ly lz ma nt mc md me im bi translated">我总是建议尽可能使用sealed关键字。</p><p id="db0f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这不仅是为了您可能获得的性能提升，也是因为从设计的角度来看，这是一个最佳实践，因为微软实际上正在考虑让所有的类默认密封。</p><p id="61af" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">最后，我希望你喜欢读这篇文章，就像我喜欢写它一样。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mf"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure><h1 id="19b9" class="my mz it bd lh na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">希望这些内容对你有用。如果您想支持:</h1><p id="bd8b" class="pw-post-body-paragraph lj lk it ll b lm np kd lo lp nq kg lr ls nr lu lv lw ns ly lz ma nt mc md me im bi translated">如果您还不是<strong class="ll jd">中型</strong>会员，您可以使用<a class="ae li" href="https://medium.com/@eng_ahmed.tarek/membership" rel="noopener"> <strong class="ll jd">我的推荐链接</strong> </a>，这样我就可以从<strong class="ll jd">中型</strong>中获得您的一部分费用，您无需支付任何额外费用。订阅<br/><a class="ae li" href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener"><strong class="ll jd">我的简讯</strong> </a>将最佳实践、教程、提示、技巧和许多其他很酷的东西直接发送到您的收件箱。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mf"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure><h1 id="bb73" class="my mz it bd lh na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">其他资源</h1><p id="6dcd" class="pw-post-body-paragraph lj lk it ll b lm np kd lo lp nq kg lr ls nr lu lv lw ns ly lz ma nt mc md me im bi translated">这些是你可能会发现有用的其他资源。</p><div class="mg mh gp gr mi mj"><a rel="noopener  ugc nofollow" target="_blank" href="/why-split-large-methods-into-smaller-ones-7b71f26f8745"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd jd gy z fp mo fr fs mp fu fw jc bi translated">为什么要把大方法分成小方法呢？！</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">学习何时将大方法分解成小方法，让不可能变成可能。</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ms l"><div class="pz l mu mv mw ms mx lb mj"/></div></div></a></div><div class="mg mh gp gr mi mj"><a rel="noopener  ugc nofollow" target="_blank" href="/template-method-design-pattern-in-net-c-73d0be82571e"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd jd gy z fp mo fr fs mp fu fw jc bi translated">中模板方法设计模式的分析。NET C#</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">中学习模板方法设计模式。NET C#并探索不同的可能性。</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ms l"><div class="qa l mu mv mw ms mx lb mj"/></div></div></a></div><div class="mg mh gp gr mi mj"><a rel="noopener  ugc nofollow" target="_blank" href="/unit-testing-best-practices-in-net-c-3117ea4010b9"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd jd gy z fp mo fr fs mp fu fw jc bi translated">中的单元测试最佳实践。NET C#</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">中单元测试的提示、技巧和最佳实践。NET C#使用NUnit和Moq</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ms l"><div class="qb l mu mv mw ms mx lb mj"/></div></div></a></div><div class="mg mh gp gr mi mj"><a rel="noopener  ugc nofollow" target="_blank" href="/mistakes-made-by-developers-79af38b070b7"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd jd gy z fp mo fr fs mp fu fw jc bi translated">开发人员犯的错误</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">这些是开发人员最常犯的错误。</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ms l"><div class="qc l mu mv mw ms mx lb mj"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mf"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure></div></div>    
</body>
</html>