<html>
<head>
<title>How To Simulate and Visualize The Birthday Paradox Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python模拟和可视化生日悖论</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-simulate-and-visualize-the-birthday-paradox-using-python-528d304f215b?source=collection_archive---------8-----------------------#2022-05-26">https://levelup.gitconnected.com/how-to-simulate-and-visualize-the-birthday-paradox-using-python-528d304f215b?source=collection_archive---------8-----------------------#2022-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="eceb" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">一堂5分钟的Python课:</h2><div class=""/><div class=""><h2 id="3ab0" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">通过编码提高你对概率的理解</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/73968bc4af9606fd6227cf5ff196a3e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ifhgyYrCqDxpTzw9"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">豪尔赫·依班娜在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="77c0" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">什么是生日悖论？</h1><p id="e7bd" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">有一天在工作中，我的一个同事带着礼物进来庆祝他的生日。当我们都聚集在他的办公桌旁吃零食和聊天时，有人提到公司的另一个人也是同一天生日。这让我想到了老T4的生日悖论，它提出了一个问题:</p><blockquote class="mw"><p id="9ce6" class="mx my it bd mz na nb nc nd ne nf mv dk translated"><strong class="ak">在一群人中，两个人同一天生日的可能性有多大？</strong></p></blockquote><p id="010e" class="pw-post-body-paragraph ma mb it mc b md ng kd mf mg nh kg mi mj ni ml mm mn nj mp mq mr nk mt mu mv im bi translated">我知道我们都想在自己特别的日子里感到特别，但数学显示，在一个只有23人的团体中，大约有50/50的机会有人同一天过生日。在一个70人的团体中，有99.9%的机会是同一天生日。由于我在一家雇用数百人的公司工作，我想知道是否有人真的和我同一天生日？🤔</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nl"><img src="../Images/8294e015e8271a1463d1ab3992fb5ea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A0xwwl25MBszyO1k"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@fochrist1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗伯特·安德森</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="32ae" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">使用Python探索问题</h1><p id="2078" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在深入研究公式之前，让我们首先剖析这个问题，并编写一个强力示例，输出组大小为N的随机生日，这样我们就可以尝试对这个问题有一些直觉。当然，我们首先假设每个出生日期发生的可能性相同。</p><p id="ed59" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj no ml mm mn np mp mq mr nq mt mu mv im bi translated">请记住，我们不需要担心年份，只需要担心月份和日期，因此我们可以简单地提供一个开始日期，并随机添加N次日期来生成生日列表。使用<a class="ae lh" href="https://docs.python.org/3/library/datetime.html" rel="noopener ugc nofollow" target="_blank"> <strong class="mc jd"> datetime </strong>库</a>，我们可以生成2020年1月1日的开始日期。然后使用<a class="ae lh" href="https://docs.python.org/3/library/datetime.html#timedelta-objects" rel="noopener ugc nofollow" target="_blank"><strong class="mc jd"/></a><strong class="mc jd"/>从库中，通过0到366之间的随机整数值修改开始日期(因为2020年有闰日)。</p><p id="c1ed" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj no ml mm mn np mp mq mr nq mt mu mv im bi translated">创建一个名为<strong class="mc jd"> generate_birthdays </strong>的函数，它接受一个<strong class="mc jd">int</strong>value<strong class="mc jd"><em class="nr">group _ size</em></strong>。也导入所需的依赖项:</p><pre class="ks kt ku kv gt ns nt nu nv aw nw bi"><span id="8997" class="nx lj it nt b gy ny nz l oa ob">from datetime import datetime, timedelta<br/>import random</span><span id="84b8" class="nx lj it nt b gy oc nz l oa ob">def generate_birthdays(group_size):</span></pre><p id="8ec9" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj no ml mm mn np mp mq mr nq mt mu mv im bi translated">然后通过为2020年1月1日创建一个日期时间对象来添加<strong class="mc jd"> jan_first </strong>变量:</p><pre class="ks kt ku kv gt ns nt nu nv aw nw bi"><span id="024a" class="nx lj it nt b gy ny nz l oa ob">def generate_birthdays(group_size):<br/>    jan_first = datetime(2020, 1, 1)</span></pre><p id="cb96" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj no ml mm mn np mp mq mr nq mt mu mv im bi translated">从这里，我们可以使用<a class="ae lh" href="https://towardsdatascience.com/my-trick-to-learning-list-comprehensions-in-python-8a54e66d98b" rel="noopener" target="_blank">列表理解</a>来制作一个随机生日列表:</p><pre class="ks kt ku kv gt ns nt nu nv aw nw bi"><span id="7dae" class="nx lj it nt b gy ny nz l oa ob">def generate_birthdays(group_size):<br/>    jan_first = datetime(2020, 1, 1)<br/>    birthday_list = [(jan_first + timedelta(days=random.randint(0, 366))).strftime("%m/%d/%Y") for i in range(group_size)]</span></pre><p id="5b28" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj no ml mm mn np mp mq mr nq mt mu mv im bi translated">注意，我将<a class="ae lh" href="https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior" rel="noopener ugc nofollow" target="_blank"> strftime("%m/%d/%Y") </a>追加到datetime值，以便将对象输出为字符串，使其更易于阅读。</p><p id="e79a" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj no ml mm mn np mp mq mr nq mt mu mv im bi translated">最后，返回一个排序后的生日列表，这样我们就可以很容易地发现重复的出生日期。下面是完整的函数:</p><pre class="ks kt ku kv gt ns nt nu nv aw nw bi"><span id="1b04" class="nx lj it nt b gy ny nz l oa ob">def generate_birthdays(group_size):<br/>    jan_first = datetime(2020, 1, 1)<br/>    birthday_list = [(jan_first + timedelta(days=random.randint(0, 366))).strftime("%m/%d/%Y") for i in range(group_size)]<br/>    return sorted(birthday_list)</span></pre><p id="e5e1" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj no ml mm mn np mp mq mr nq mt mu mv im bi translated">使用<em class="nr"> group_size </em> = 23运行函数，因为我们想要检查给定一组23个人，是否真的有50/50的机会共享生日。请记住，由于日期是随机的，所以您的输出不会与我的相匹配。</p><pre class="ks kt ku kv gt ns nt nu nv aw nw bi"><span id="be3e" class="nx lj it nt b gy ny nz l oa ob">generate_birthdays(23)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi od"><img src="../Images/ddecf655415ae1e605ba680f712ee23a.png" data-original-src="https://miro.medium.com/v2/resize:fit:302/format:webp/1*h7OnT14WFltRLATBio336w.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">generate_birthdays的输出(23)</figcaption></figure><p id="4e9f" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj no ml mm mn np mp mq mr nq mt mu mv im bi translated">正如我们在示例输出中看到的，我们的生日列表包含一个副本！现在，如果我们想深入了解共同生日发生的概率，我们可以运行这个函数X次并记录我们的结果。当然有可能，但手工操作也很繁琐。幸运的是，我们可以通过编写更多的函数来告诉我们该列表是否包含重复项，从而让Python来为我们完成这项繁琐的工作:</p><pre class="ks kt ku kv gt ns nt nu nv aw nw bi"><span id="9771" class="nx lj it nt b gy ny nz l oa ob">def shared_bday(group_size):<br/>    birthdays = random_birthdays(group_size)<br/>    #print(birthdays)<br/>    for a, birthdayA in enumerate(birthdays):<br/>        for b, birthdayB in enumerate(birthdays[a + 1 :]):<br/>            if birthdayA == birthdayB:<br/>                return True</span></pre><p id="ff55" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj no ml mm mn np mp mq mr nq mt mu mv im bi translated">该函数接受<em class="nr"> group_size </em>并生成一个生日列表。然后，它遍历生日列表，将每个生日与列表中的其他生日进行比较。如果两个生日匹配，该函数返回True。</p><p id="be24" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj no ml mm mn np mp mq mr nq mt mu mv im bi translated">由于我们不想手动统计输出，我们可以编写最后一个函数来运行X次试验的<strong class="mc jd"> shared_bday </strong>，然后返回shared_bday为真的次数之和除以X次试验，以获得0到1之间的概率值:</p><pre class="ks kt ku kv gt ns nt nu nv aw nw bi"><span id="53be" class="nx lj it nt b gy ny nz l oa ob">def generate_trials(group_size, trials):<br/>    counts = []<br/>    for i in range(trials):<br/>        if shared_bday(group_size) == True:<br/>            counts.append(1)<br/>    return sum(counts)/trials</span></pre><p id="3b46" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj no ml mm mn np mp mq mr nq mt mu mv im bi translated">使用<em class="nr"> group_size </em> = 23和<em class="nr"> trials </em> = 10000运行该功能。请注意，返回值始终为~0.50，这表明在10，000次试验中，大约有50%的情况下，一组23个人中至少有两个生日共享同一天。</p><h1 id="76df" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">一个更简单的解决方案和可视化的概率</h1><p id="a9f5" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">虽然我们的强力解决方案给了我们一个答案，但有一个更简单的方法来计算概率，并且使可视化概率变得轻而易举。与其试图计算同一天生日的概率，不如计算没有同一天生日的概率，并从1:</p><p id="a63f" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj no ml mm mn np mp mq mr nq mt mu mv im bi translated"><em class="nr"> P </em> ( <em class="nr">共享生日</em>)= 1<em class="nr">P</em>(<em class="nr">无共享生日</em>)</p><h2 id="e1fb" class="nx lj it bd lk oe of dn lo og oh dp ls mj oi oj lu mn ok ol lw mr om on ly iz bi translated">找不到共享生日</h2><p id="572a" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">为了使数学更容易解释，让我们假设我们有一个5人小组。人A必须有生日，并且是366天中的一天。人b的生日也是366天中的一天……我们可以简单地写成366⁵，而不是366 x 366 x 366 x 366 x 366</p><p id="d851" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj no ml mm mn np mp mq mr nq mt mu mv im bi translated">因为生日不能共享，所以人A有366个可能的日子，但是人B只有365个，而人C只有364个…等等。使用Python，我们可以为一个5人小组求解如下等式:</p><pre class="ks kt ku kv gt ns nt nu nv aw nw bi"><span id="6043" class="nx lj it nt b gy ny nz l oa ob">1 - (366 * 365 *364 * 363 * 362) / 366**5<br/>=.027</span></pre><p id="d613" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj no ml mm mn np mp mq mr nq mt mu mv im bi translated">使用循环的<em class="nr">,我们可以生成一系列群体大小的概率，创建一个字典，并将群体大小和概率加载到<a class="ae lh" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html" rel="noopener ugc nofollow" target="_blank">熊猫数据帧</a>中。一旦进入数据帧，我们可以使用<a class="ae lh" href="https://plotly.com/python/line-charts/" rel="noopener ugc nofollow" target="_blank"> Plotly express </a>创建一个交互式图形:</em></p><pre class="ks kt ku kv gt ns nt nu nv aw nw bi"><span id="1ba3" class="nx lj it nt b gy ny nz l oa ob">#import dependencies<br/>import pandas as pd<br/>import plotly.express as px</span><span id="0307" class="nx lj it nt b gy oc nz l oa ob">#set number of days in a year<br/>numerator = 366<br/>denominator = 366</span><span id="3e55" class="nx lj it nt b gy oc nz l oa ob">#create empty list to store dictionary<br/>probabilities = []</span><span id="99da" class="nx lj it nt b gy oc nz l oa ob">#for loop to generate probabilities<br/>for i in range(2, 100):<br/>    numerator = numerator * (366 + 1 - i)<br/>    denominator = denominator * 366<br/>    probabilities.append({'group_size':i, 'probability':round(1 - (numerator / denominator), 3)})<br/>    #print(round(probabilities, 3))</span><span id="a827" class="nx lj it nt b gy oc nz l oa ob">#load dataframe<br/>df = pd.DataFrame(probabilities)</span><span id="8465" class="nx lj it nt b gy oc nz l oa ob">#graph probabilities<br/>fig = px.line(df, x='group_size', y='probability', title='Probability of Sharing B-Day')<br/>fig.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oo"><img src="../Images/68b9aef91edd526a4a8ff63b578aaddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I35EuUs43HsAZO-0KcnZXw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">概率图(作者图片)</figcaption></figure><p id="2daa" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj no ml mm mn np mp mq mr nq mt mu mv im bi translated">正如我们再次看到的，23人的组返回0.506的概率。Plotly图形是交互式的，可以很容易地看到沿着绘制线的任何group_size值的概率。</p><h1 id="8c95" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">结束语</h1><p id="7b81" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">生日悖论是一个大问题，因为它揭示了指数的非直观性。使用Python探索这个问题允许我们用不同的方法解决它。通过理解问题和解决方案，它有助于训练大脑从不同的角度看待问题，因为不用暴力解决生日悖论的技巧是首先计算在小组内共享生日的可能性有多大。</p><h1 id="96f8" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">谢谢大家！</h1><ul class=""><li id="0506" class="op oq it mc b md me mg mh mj or mn os mr ot mv ou ov ow ox bi translated"><em class="nr">如果你喜欢这个，</em> <a class="ae lh" href="https://medium.com/@erickleppen" rel="noopener"> <em class="nr">关注我的Medium </em> </a> <em class="nr">了解更多</em></li><li id="f12a" class="op oq it mc b md oy mg oz mj pa mn pb mr pc mv ou ov ow ox bi translated"><a class="ae lh" href="https://erickleppen.medium.com/membership" rel="noopener"> <em class="nr">通过订阅</em> </a>获得完全访问权限并帮助支持我的内容</li><li id="8963" class="op oq it mc b md oy mg oz mj pa mn pb mr pc mv ou ov ow ox bi translated"><em class="nr">我们连线上</em><a class="ae lh" href="https://www.linkedin.com/in/erickleppen01/" rel="noopener ugc nofollow" target="_blank"><em class="nr">LinkedIn</em></a></li><li id="5e45" class="op oq it mc b md oy mg oz mj pa mn pb mr pc mv ou ov ow ox bi translated"><em class="nr">用Python分析数据？查看我的</em> <a class="ae lh" href="https://pythondashboards.com/" rel="noopener ugc nofollow" target="_blank"> <em class="nr">网站</em> </a></li></ul><p id="5d61" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj no ml mm mn np mp mq mr nq mt mu mv im bi translated"><a class="ae lh" href="http://pythondashboards.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="mc jd"> —埃里克·克莱本</strong> </a></p></div></div>    
</body>
</html>