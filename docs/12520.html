<html>
<head>
<title>How to Break Down a “Hard” SQL Interview Question</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何分解一个“难”的SQL面试问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-break-down-a-hard-sql-interview-question-7325d561857b?source=collection_archive---------7-----------------------#2022-06-16">https://levelup.gitconnected.com/how-to-break-down-a-hard-sql-interview-question-7325d561857b?source=collection_archive---------7-----------------------#2022-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="57e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中我一步一步地回答了一个被StrataScratch标记为“难”的Yelp SQL面试问题</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/2cbdeb59ac0813e364fe066067fd3a7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M23_OyuYFy-N-81j"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@linkedinsalesnavigator?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> LinkedIn销售解决方案</a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="b472" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">介绍</h1><p id="0e13" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><a class="ae lb" href="https://www.stratascratch.com/" rel="noopener ugc nofollow" target="_blank"> StrataScratch </a>是一个练习真实面试问题的平台，这些问题来自Meta、网飞、微软等公司。在本文中，我将一步一步地回答在线目录和评论出版商Yelp的一个SQL面试问题。</p><p id="f40f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你是一名实践型学习者，你可以注册一个免费账户，然后在这里按照编码步骤<a class="ae lb" href="https://platform.stratascratch.com/coding/10046-top-5-states-with-5-star-businesses?code_type=3" rel="noopener ugc nofollow" target="_blank">进行操作</a>。请注意，虽然我喜欢StrataScratch练习SQL问题，但我与该公司没有任何个人或专业联系！</p><p id="5559" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文假设您对SQL基础知识有基本的了解，比如SELECT、FROM和WHERE。最终查询中更多中级函数的文档将在介绍时提供。</p><h1 id="6ded" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">这个问题</h1><p id="a088" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><strong class="jp ir">标题:</strong>拥有5家星级企业的前5个州</p><p id="5fd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">描述:</strong>查找5星商家最多的前5个州。输出州名以及五星级企业数量，并按五星级企业数量降序排列订单记录。如果业务数量有关联，则返回所有唯一的状态。如果两个州的结果相同，按字母顺序排序。</p><p id="ece2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">数据模式:</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/55bc9a0e2cd8df56f165c11fc15a3206.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*h22HNcE5iGIjYzSLBE-hTw.png"/></div></figure><h2 id="d035" class="mg ld iq bd le mh mi dn li mj mk dp lm jy ml mm lq kc mn mo lu kg mp mq ly mr bi translated">步骤1:确定可交付成果</h2><p id="ffb6" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">也许您可以学习的最重要的SQL技能之一是快速解析业务问题的能力，这些问题将最终出现在您的最终SQL查询中。在现实世界中，利益相关者很少会告诉你“输出”什么与你的模式完全匹配，但是上面的描述仍然需要被解析并翻译成SQL。</p><p id="9625" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们编写任何SQL之前——甚至可能在查看数据模式之前——我们必须确保我们理解所询问的内容。所以用最简单的话来说，Yelp要求的是什么？</p><ul class=""><li id="d446" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk mx my mz na bi translated">州名</li><li id="26e8" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated">每个州五星级企业的数量</li></ul><p id="8ded" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样。是的，答案必须只包括前5个州，记录必须以某种方式排序，但那是交付，而不是可交付的。现在我们知道了我们的可交付结果，我们可以开始编写我们的查询了。</p><h2 id="c47e" class="mg ld iq bd le mh mi dn li mj mk dp lm jy ml mm lq kc mn mo lu kg mp mq ly mr bi translated">步骤2:想象一个完美的世界</h2><p id="ed83" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们知道我们的查询将有一个SELECT和FROM语句。数据必须来自某个地方(一个表)，即使我们想要那个表中的每个字段，我们仍然必须选择所有的字段(使用*)。</p><p id="7d4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只有一个表，<code class="fe ng nh ni nj b">yelp_business</code>，所以我们知道数据是从那里来的。我们也知道我们要选择什么，这要感谢我们事先确定了可交付成果。</p><p id="a85f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一步，我们将通过想象一个完美的世界来建立基础:</p><pre class="km kn ko kp gt nk nj nl nm aw nn bi"><span id="2b95" class="mg ld iq nj b gy no np l nq nr">SELECT state, num_businesses <br/>FROM yelp_business;</span></pre><p id="e2de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您跟随或仔细研究了数据模式，您会知道这是一个“完美的世界”,因为查询会返回一个错误。这是因为<em class="ns">num _ business</em>不是数据中已经存在的字段。这是我们最终想要的，但它还不存在。我们必须创造它。</p><h2 id="e9a1" class="mg ld iq bd le mh mi dn li mj mk dp lm jy ml mm lq kc mn mo lu kg mp mq ly mr bi translated">第三步:分解逻辑</h2><p id="8d3c" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">第1步和第2步至关重要，但第3步是概念与执行的结合。从现在开始我们要慢慢来。</p><p id="50c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ns">num _ business</em>有三个逻辑组件:</p><ol class=""><li id="63a5" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk nt my mz na bi translated">这是一个计数的东西</li><li id="0586" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk nt my mz na bi translated">这是五星级企业</li><li id="e943" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk nt my mz na bi translated">我们需要按状态统计<strong class="jp ir">(或者更专业地说，在状态级别上汇总)</strong></li></ol><p id="62d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些组件中的每一个都被分解到查询中的不同位置。让我们一个一个地看一下:</p><ol class=""><li id="e66c" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk nt my mz na bi translated">对某物的计数。我们可以通过在SELECT语句中添加<code class="fe ng nh ni nj b">COUNT(*)</code>来返回记录的数量</li><li id="b826" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk nt my mz na bi translated"><strong class="jp ir">五星级企业。</strong>每项业务的星级可在<em class="ns">星级</em>字段中找到。我们可以使用WHERE子句:<code class="fe ng nh ni nj b">WHERE stars = 5</code>只筛选具有五星评级的企业</li><li id="a6ba" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk nt my mz na bi translated"><strong class="jp ir">按州汇总计数。</strong>要指示SQL按状态聚集(或分组)计数，我们只需要一个GROUP BY子句:<code class="fe ng nh ni nj b">GROUP BY state</code></li></ol><p id="4661" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">放在一起，看起来是这样的:</p><pre class="km kn ko kp gt nk nj nl nm aw nn bi"><span id="4a9e" class="mg ld iq nj b gy no np l nq nr">SELECT state, COUNT(*) AS num_businesses<br/>FROM yelp_business<br/>WHERE stars = 5<br/>GROUP BY state; </span></pre><p id="da9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我将我们的计数别名为<em class="ns">num _ business</em>。这不仅仅是为了可读性，尽管这本身就是一个足够好的理由；混叠在后面会很重要。</p><p id="6d14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何决定接下来会发生什么？嗯，这取决于偏好。我喜欢把简单的东西扔掉。在克服了具有挑战性的部分后，很容易忘记小而简单的细节。</p><p id="85e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">描述告诉我们按照五星级企业的数量(<em class="ns">num _ business</em>)降序排列查询结果，即从最多到最少。它还告诉我们，在出现平局的情况下，结果应该按照<em class="ns">状态</em>的字母顺序排列。</p><p id="97ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以在查询的末尾使用ORDER BY子句来实现这一点。并且由于<em class="ns">状态</em>的字母排序只发生在平局的情况下，<em class="ns">num _ business</em>将出现在<em class="ns">状态:</em>之前</p><pre class="km kn ko kp gt nk nj nl nm aw nn bi"><span id="ff95" class="mg ld iq nj b gy no np l nq nr">SELECT state, COUNT(*) AS num_businesses<br/>FROM yelp_business<br/>WHERE stars = 5<br/>GROUP BY state<br/>ORDER BY num_businesses DESC, state</span></pre><p id="44d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来是棘手的部分。好的一面是，我们已经将许多业务逻辑翻译成了SQL。我们现在只需要它再做一件事:只返回拥有最多五星级企业的前5个州。</p><p id="db4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个诱人的陷阱。起初很容易想到:<em class="ns">好吧，简单。因为结果已经根据五星级企业的数量进行了排序，所以我只需添加</em> <code class="fe ng nh ni nj b">LIMIT 5</code> <em class="ns">，查询将只返回前5个州。</em></p><p id="7fef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们运行这个查询，答案将是不正确的。那是因为描述中的这个参数:</p><blockquote class="nu nv nw"><p id="16a7" class="jn jo ns jp b jq jr js jt ju jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj kk ij bi translated">"如果企业数量有关联，则返回所有唯一的状态."</p></blockquote><p id="7704" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这表明各州之间可能有联系。对此进行调查后，发现第四名有一个三人平手(要查看这一点，请将您的<code class="fe ng nh ni nj b">LIMIT</code>设置为6)。当我们将结果限制为仅前5条记录时，查询忽略了与第4名并列的第3个州。</p><p id="efb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们如何得到第三种状态？有几种不同的方法。您的决定将再次部分取决于您的偏好，还可能取决于您正在使用的SQL语言。(我用的是MySQL。)</p><p id="de5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但让我们先从逻辑上思考一下，因为这里更大的挑战是真正理解这个问题。当在现实世界中与利益相关者一起工作时，你会发现他们表达要求的方式和他们真正要求的东西之间有时会有差距。即使在最好的情况下，他们也很可能不知道如何用SQL术语来表达——如果他们知道，他们就不必来找你了。</p><p id="dc39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题是根据<strong class="jp ir">各州在五星级企业数量中的排名</strong>来询问排名靠前的州。因此，我们真正需要的是对各州进行排名的能力，然后根据排名进行过滤。</p><p id="131d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我将使用CTE或公共表表达式。也可以在FROM语句中使用子查询来达到同样的效果。</p><p id="8f1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">旁注:我认为cte<em class="ns">对初学者来说听起来更吓人，尽管它们本质上只是将子查询赋给变量的一种方式(通常使代码更容易阅读)。)学习资源也倾向于在cte之前教授子查询，这表明后者更难。再次，这归结为一个偏好问题，但是我认为cte本质上并不比子查询更困难或更复杂。</em></p><p id="99e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是为什么我们需要使用这些东西呢？因为如果您仅仅停留在使用RANK()函数添加排名，您将无法对其进行过滤。让我告诉你我的意思。</p><pre class="km kn ko kp gt nk nj nl nm aw nn bi"><span id="d67e" class="mg ld iq nj b gy no np l nq nr">SELECT state, COUNT(*) AS num_businesses, RANK() OVER(ORDER BY COUNT(*) DESC) AS state_rank<br/>FROM yelp_business<br/>WHERE stars = 5<br/>GROUP BY state<br/>ORDER BY num_businesses DESC, state</span></pre><p id="9ac9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个查询确实让我们更进一步，但问题是我不能在WHERE语句中添加一个<code class="fe ng nh ni nj b">AND state_rank &lt;= 5</code>。这是因为WHERE语句不识别我们的计算字段——如果我们试图根据<em class="ns">num _ business</em>进行过滤，它将返回相同的错误。</p><p id="5226" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要做的是“展平”state_rank字段，以便WHERE语句可以对其进行操作。我们可以通过将上面的查询放在CTE中来实现这一点。</p><p id="3dc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RANK()和cte的内部工作原理各有自己的文章，因此稍微超出了本文的范围。要了解更多信息，请阅读此处的<a class="ae lb" href="https://medium.com/towards-data-science/how-to-use-sql-rank-and-dense-rank-functions-7c3ebf84b4e8" rel="noopener">关于RANK()和窗口函数的</a>，以及此处的<a class="ae lb" href="https://medium.com/towards-data-science/take-your-sql-from-good-to-great-part-1-3ae61539e92a" rel="noopener">关于CTEs的</a>。</p><p id="9f66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们运行以下查询时，SQL将首先在内存中临时存储CTE的结果，允许其余代码对该数据<strong class="jp ir">执行，就像它是数据库</strong>中自己的表一样。</p><p id="c18e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，这里的CTE最终只不过是上述查询的<strong class="jp ir">结果。它位于下面代码的顶部:</strong></p><pre class="km kn ko kp gt nk nj nl nm aw nn bi"><span id="e8b8" class="mg ld iq nj b gy no np l nq nr">WITH states_with_ranks AS<br/>(SELECT state, COUNT(*) AS num_businesses, RANK() OVER(ORDER BY COUNT(*) DESC) AS state_rank<br/>FROM yelp_business<br/>WHERE stars = 5<br/>GROUP BY state)</span><span id="db1e" class="mg ld iq nj b gy oa np l nq nr">SELECT state_rank, state, num_businesses<br/>FROM states_with_ranks<br/>WHERE state_rank &lt;= 5<br/>ORDER BY num_businesses DESC, state<br/>;</span></pre><p id="4c72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从<code class="fe ng nh ni nj b">WITH</code>到<code class="fe ng nh ni nj b">GROUP BY state)</code>之后的一切都是CTE。它下面的所有内容都是我们的查询。看看我们查询中的FROM语句是如何引用CTE的名字<code class="fe ng nh ni nj b">states_with_ranks</code>，而不是<code class="fe ng nh ni nj b">yelp_business</code>？</p><p id="899e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CTE通过将计算结果临时存储在内存中，有效地“展平”了计算字段。然后，我们可以只按名称选择<em class="ns"> state_rank </em>和<em class="ns">num _ business</em>字段。最重要的是，WHERE语句将它们识别为可以过滤的字段。</p><p id="ac6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您无法理解CTE部分，但理解子查询是如何工作的，那么查看上面CTE的<em class="ns">精确代码</em>在FROM语句内的子查询中的重新定位可能会有所帮助:</p><pre class="km kn ko kp gt nk nj nl nm aw nn bi"><span id="2b8c" class="mg ld iq nj b gy no np l nq nr">SELECT state_rank, state, num_businesses<br/>FROM<br/>    (SELECT state, COUNT(*) AS num_businesses, RANK() OVER(ORDER BY COUNT(*) DESC) AS state_rank<br/>    FROM yelp_business<br/>    WHERE stars = 5<br/>    GROUP BY state<br/>    ORDER BY state, num_businesses) AS states_with_ranks<br/>WHERE state_rank &lt;= 5<br/>ORDER BY num_businesses DESC, state<br/>;</span></pre><p id="0ca8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还要注意，在任何一种情况下，<code class="fe ng nh ni nj b">ORDER BY</code>子句都被移动到最末尾。这确保了结果被正确排序。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ob"><img src="../Images/61c1c8152d132d4efa2257f06dcd27cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ootzc_yhKP4uzSNw"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">Sebastian Herrmann 在Unsplash 上拍摄的照片。谢了，塞巴斯蒂安！</figcaption></figure><h1 id="8e77" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="ebbd" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">像其他任何事情一样，将业务逻辑翻译成SQL越多，就越擅长。这当然在面试中很有用，但在你获得工作后，这一点无疑更加重要。</p><p id="c183" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有些<a class="ae lb" href="https://counting.substack.com/p/we-should-phase-the-sql-interview?utm_campaign=Data_Elixir&amp;utm_source=Data_Elixir_390&amp;s=r" rel="noopener ugc nofollow" target="_blank">认为SQL面试应该被淘汰</a>，也许他们是对的。但这不太可能很快发生，无论你使用什么语言，学习如何将问题分解成各个组成部分都是一项无价的技能。</p><p id="e2a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有问题吗？请在评论中告诉我。你也可以在LinkedIn 上和我联系<a class="ae lb" href="https://www.linkedin.com/in/dakotaleesmith/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="e825" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哦，如果你有一个SQL面试，祝你好运！</p></div></div>    
</body>
</html>