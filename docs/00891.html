<html>
<head>
<title>Organising Your React Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">组织React应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/enterprise-size-react-application-directory-structure-90b0ebc60d59?source=collection_archive---------0-----------------------#2019-09-05">https://levelup.gitconnected.com/enterprise-size-react-application-directory-structure-90b0ebc60d59?source=collection_archive---------0-----------------------#2019-09-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9596" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当你开始编写一个新的应用程序时，如何组织它总是一个大问题。我将向您描述理想的文件结构和最佳实践，它几乎可以在任何场景中使用，并且易于使用。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/a4168f6e7a65a5506660834672446e1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fTd1Z6TaHXA_2EsM"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://i1.wp.com/www.interestingonly.com/wp-content/uploads/0-986.jpg" rel="noopener ugc nofollow" target="_blank">https://i1 . WP . com/www . interesting only . com/WP-content/uploads/0-986 . jpg</a></figcaption></figure><h1 id="13fa" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">项目结构的优势是什么？</h1><ol class=""><li id="6530" class="md me it js b jt mf jx mg kb mh kf mi kj mj kn mk ml mm mn bi translated">团队成员不必争论在哪里放置特定的功能</li><li id="5144" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated">可以描述，这样你就不用每次都给新人解释了</li><li id="5bec" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated">随着更多的前端项目具有相同的结构，很容易交换团队成员</li><li id="bc44" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated">您可以专注于功能，而不是考虑结构</li></ol><h1 id="89fb" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">一个好的结构应该实现什么？</h1><ol class=""><li id="86de" class="md me it js b jt mf jx mg kb mh kf mi kj mj kn mk ml mm mn bi translated">容易</li><li id="fb36" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated">灵活性</li><li id="a309" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated">复用性</li><li id="b0b4" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated">提高生产率</li></ol><h1 id="1e46" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">组件使用的最佳实践</h1><h2 id="dc90" class="mt lg it bd lh mu mv dn ll mw mx dp lp kb my mz lt kf na nb lx kj nc nd mb ne bi translated">组件文件命名</h2><ul class=""><li id="a655" class="md me it js b jt mf jx mg kb mh kf mi kj mj kn nf ml mm mn bi translated">组件目录名<strong class="js iu"> PascalCase </strong></li><li id="26d5" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn nf ml mm mn bi translated">组件文件名<strong class="js iu"> PascalCase </strong></li><li id="eecc" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn nf ml mm mn bi translated">不要重复父母的名字</li><li id="08e6" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn nf ml mm mn bi translated"><strong class="js iu">坏:</strong><em class="ng">src/Banners edit/Banners editform . tsx</em></li><li id="f62c" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn nf ml mm mn bi translated"><strong class="js iu">好:</strong><em class="ng">src/Banners/Edit/form . tsx</em></li></ul><h2 id="bf59" class="mt lg it bd lh mu mv dn ll mw mx dp lp kb my mz lt kf na nb lx kj nc nd mb ne bi translated">组件命名</h2><p id="c716" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb nh kd ke kf ni kh ki kj nj kl km kn im bi translated">组件的名称应该复制组件的路径，例如</p><ol class=""><li id="6f11" class="md me it js b jt ju jx jy kb nk kf nl kj nm kn mk ml mm mn bi translated"><em class="ng">src/pages/log in/index . tsx</em>是<strong class="js iu"> &lt; Login / &gt; </strong></li><li id="ffa8" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated"><em class="ng">src/pages/log in/form . tsx</em>是<strong class="js iu"> &lt; LoginForm / &gt; </strong></li></ol><p id="439b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将保证所有组件都有唯一的名称。</p><h2 id="c714" class="mt lg it bd lh mu mv dn ll mw mx dp lp kb my mz lt kf na nb lx kj nc nd mb ne bi translated">容器组件命名</h2><p id="0c08" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb nh kd ke kf ni kh ki kj nj kl km kn im bi translated">如果您想通过<em class="ng"> React.memo() </em>或<em class="ng"> compose()，</em>将<strong class="js iu"> <em class="ng">组件</em> </strong>后缀添加到您的类定义中，并导出一个名称不带后缀的<em class="ng"> const </em>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="685e" class="mt lg it bd lh mu mv dn ll mw mx dp lp kb my mz lt kf na nb lx kj nc nd mb ne bi translated">避免创建依赖于属性状态的组件——初始值除外</h2><p id="66ce" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb nh kd ke kf ni kh ki kj nj kl km kn im bi translated">你需要遵循真理的单一来源原则，这意味着将数据从道具复制到状态不是解决方案，因为道具可以改变。你可以根据属性初始化状态，但是只能在构造函数中。在任何其他生命周期方法中这样做是不可接受的，因为您将使用<em class="ng">。setState() </em>触发重新渲染。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="ca98" class="mt lg it bd lh mu mv dn ll mw mx dp lp kb my mz lt kf na nb lx kj nc nd mb ne bi translated">反应组件— setState()</h2><blockquote class="np nq nr"><p id="ea9b" class="jq jr ng js b jt ju jv jw jx jy jz ka ns kc kd ke nt kg kh ki nu kk kl km kn im bi translated">setState()将始终导致重新呈现，除非shouldComponentUpdate()返回false</p></blockquote><p id="9b73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着你应该使用<em class="ng"> setState() </em>来改变组件状态，而不要直接改变状态。我们还需要知道，当我们使用复合类型时，我们是在共享引用。</p><p id="ebbb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="53f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们直接在state中修改<code class="fe nv nw nx ny b">propertyOne</code>的属性。</p><p id="a995" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">没有新库的解决方案:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="0a23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ng">延伸阅读:</em></p><ul class=""><li id="b1cd" class="md me it js b jt ju jx jy kb nk kf nl kj nm kn nf ml mm mn bi translated"><a class="ae le" href="https://medium.freecodecamp.org/handling-state-in-react-four-immutable-approaches-to-consider-d1f5c00249d5" rel="noopener ugc nofollow" target="_blank"><em class="ng">https://medium . freecodecamp . org/handling-state-in-react-four-immutable-approachs-to-consider-d1f5c 00249 D5</em></a></li><li id="9834" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn nf ml mm mn bi translated"><a class="ae le" href="https://itnext.io/updating-properties-of-an-object-in-react-state-af6260d8e9f5" rel="noopener ugc nofollow" target="_blank"><em class="ng">https://it next . io/updating-properties-of-an-object-in-react-state-af 6260 D8 e9 f 5</em></a></li></ul><h2 id="a511" class="mt lg it bd lh mu mv dn ll mw mx dp lp kb my mz lt kf na nb lx kj nc nd mb ne bi translated">避免在render()中创建新的引用—使用处理函数</h2><p id="8488" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb nh kd ke kf ni kh ki kj nj kl km kn im bi translated">示例—创建一个新对象和一个匿名函数，并将它们作为道具传递:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d454" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将导致每次当<code class="fe nv nw nx ny b">ParentComponent </code>重新渲染时，<code class="fe nv nw nx ny b">ChildComponent </code>也重新渲染。</p><p id="c333" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">为什么？这是因为在<code class="fe nv nw nx ny b">ParentComponent</code>的每一个渲染周期中，我们都有一个新的对象和函数创建，而你将这些新创建的实体传递下去，所以道具引用总是变化的。</strong></p><h2 id="0156" class="mt lg it bd lh mu mv dn ll mw mx dp lp kb my mz lt kf na nb lx kj nc nd mb ne bi translated">如何编写事件处理函数以避免新的引用</h2><p id="d500" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb nh kd ke kf ni kh ki kj nj kl km kn im bi translated">在我们喜欢只使用一个原始值的情况下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="3d80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们喜欢使用非原始值(对象、数组)的情况下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="d8b3" class="mt lg it bd lh mu mv dn ll mw mx dp lp kb my mz lt kf na nb lx kj nc nd mb ne bi translated">使用React。PureComponent和React.memo</h2><p id="0f33" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb nh kd ke kf ni kh ki kj nj kl km kn im bi translated"><strong class="js iu">为什么？</strong>这是因为<code class="fe nv nw nx ny b">React.PureComponent</code>和<code class="fe nv nw nx ny b">React.memo</code>默认实现浅道具和状态比较。<code class="fe nv nw nx ny b">React.memo</code>是功能组件<code class="fe nv nw nx ny b">React.PureComponent</code>的版本。<strong class="js iu">浅比较</strong>是指道具和状态(变化前和变化后)只在0级上比较。对于基本类型，比较它们的值，对于非基本类型，如对象或数组，只比较它们的引用。</p><p id="1a6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用法:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="07f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ng">文档链接:</em></p><ul class=""><li id="ca30" class="md me it js b jt ju jx jy kb nk kf nl kj nm kn nf ml mm mn bi translated"><em class="ng">做出反应。pure component</em><a class="ae le" href="https://reactjs.org/docs/react-api.html#reactpurecomponent" rel="noopener ugc nofollow" target="_blank"><em class="ng">https://reactjs.org/docs/react-api.html#reactpurecomponent</em></a></li><li id="270c" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn nf ml mm mn bi translated"><em class="ng">react . memo</em>T33】T34】https://reactjs.org/docs/react-api.html#reactmemoT36】</li></ul><h2 id="fa70" class="mt lg it bd lh mu mv dn ll mw mx dp lp kb my mz lt kf na nb lx kj nc nd mb ne bi translated">避免默认导出</h2><p id="6ae9" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb nh kd ke kf ni kh ki kj nj kl km kn im bi translated">违约出口很快变得一团糟。在大量实体被重新导出的大型项目中，没有办法维护默认导出。</p><h2 id="f40a" class="mt lg it bd lh mu mv dn ll mw mx dp lp kb my mz lt kf na nb lx kj nc nd mb ne bi translated">使用索引文件重新导出组件</h2><p id="b86c" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb nh kd ke kf ni kh ki kj nj kl km kn im bi translated">在组件目录中，使用索引文件来重新导出组件。这是有帮助的，因为当你想导入它时，你不必写</p><pre class="kp kq kr ks gt nz ny oa ob aw oc bi"><span id="d872" class="mt lg it ny b gy od oe l of og">import { MyComponent } from './components/MyComponent/MyComponent';</span></pre><p id="8a37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是写出来就够了</p><pre class="kp kq kr ks gt nz ny oa ob aw oc bi"><span id="2726" class="mt lg it ny b gy od oe l of og">import { MyComponent } from './components/MyComponent';</span></pre></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="0d5c" class="lf lg it bd lh li oo lk ll lm op lo lp lq oq ls lt lu or lw lx ly os ma mb mc bi translated">期待已久的结构</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ot"><img src="../Images/ea5d46ab60fb3642bd021a2d89624876.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5I1kJhoMCMVTqzUg.jpg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://thumbor.forbes.com/thumbor/960x0/https%3A%2F%2Fblogs-images.forbes.com%2Frajatbhageria%2Ffiles%2F2017%2F09%2Fcode-copy-1200x1200.jpg" rel="noopener ugc nofollow" target="_blank">https://thumb or . Forbes . com/thumb or/960 x0/https % 3A % 2F % 2Fblogs-images . Forbes . com % 2 frajatbhageria % 2f files % 2f 2017% 2f 09% 2f code-copy-1200 x 1200 . jpg</a></figcaption></figure><p id="e47a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将用例子来描述每个目录。你可以在文章末尾找到整个结构。</p><blockquote class="np nq nr"><p id="a475" class="jq jr ng js b jt ju jv jw jx jy jz ka ns kc kd ke nt kg kh ki nu kk kl km kn im bi translated">在示例中，粗体文本代表我们的特殊目录或文件。其他示例文件或目录用方括号括起来。</p></blockquote><h1 id="2c9e" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">1.核心</h1><pre class="kp kq kr ks gt nz ny oa ob aw oc bi"><span id="1a51" class="mt lg it ny b gy od oe l of og"><strong class="ny iu">src</strong><br/>|<strong class="ny iu">__core</strong><br/>   |__[contextConfig].ts<br/>   |__[httpClient].ts<br/>   |__[...]</span></pre><p id="58f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">包括第三方库的配置文件。它可以是你的http客户端的配置，可能是Axios，或者是用于设置Jest这样的测试框架。</p><h1 id="840f" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">2.共享组件</h1><pre class="kp kq kr ks gt nz ny oa ob aw oc bi"><span id="4c65" class="mt lg it ny b gy od oe l of og"><strong class="ny iu">src</strong><br/>|<strong class="ny iu">__sharedComponents</strong><br/>   |__[header]<br/>   |  |__[Menu.tsx]<br/>   |  |__[UserPanel.tsx]<br/>   |  |__[Header.tsx]<br/>   |  |<strong class="ny iu">__index.ts</strong> -&gt; re-exports needed components<br/>   |  |__[...]<br/>   |<br/>   |__[form<br/>   |  |__[Button.tsx]<br/>   |  |__[Form.tsx]<br/>   |  |__[Input.tsx]<br/>   |  |<strong class="ny iu">__index.ts</strong> -&gt; re-exports needed components<br/>   |  |__[...]<br/>   |<br/>   |__[Sidebar.tsx]<br/>   |__[...]</span></pre><p id="25d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">顾名思义，这里是你共享组件的地方，在你的页面之间共享。请记住，这里只允许使用<strong class="js iu">表示性的</strong>组件。那些没有副作用或者内部状态巨大的。当我说巨大的内部状态时，我指的是来自后端等的数据。如果你保存选择框的状态，无论它是打开还是关闭，都没问题。这就是我不谈论无状态组件的原因。</p><h1 id="ddec" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">3.主索引. tsx</h1><pre class="kp kq kr ks gt nz ny oa ob aw oc bi"><span id="ea0f" class="mt lg it ny b gy od oe l of og"><strong class="ny iu">src</strong><br/>|<strong class="ny iu">__index.tsx</strong></span></pre><p id="7e66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">按照习惯，在<strong class="js iu"> <em class="ng"> index.tsx </em> </strong>中，你应该将你的主要组件呈现给DOM。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="8e5e" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">3.页</h1><pre class="kp kq kr ks gt nz ny oa ob aw oc bi"><span id="f32e" class="mt lg it ny b gy od oe l of og"><strong class="ny iu">src</strong><br/>|<strong class="ny iu">__pages</strong><br/>   |__[login]<br/>   |  |<strong class="ny iu">__store</strong><br/>   |  |  |<strong class="ny iu">__reducers.ts</strong><br/>   |  |  |<strong class="ny iu">__actions.ts</strong><br/>   |  |  |<strong class="ny iu">__selectors.ts</strong><br/>   |  |  |<strong class="ny iu">__effects.ts</strong><br/>   |  |  |<strong class="ny iu">__types.ts</strong><br/>   |  |<br/>   |  |<strong class="ny iu">__queries</strong><br/>   |  |  |__[withUser.ts]<br/>   |  |  |__[withUserType.ts]<br/>   |  |  |__[...]<br/>   |  |<br/>   |  |<strong class="ny iu">__context</strong><br/>   |  |  |__[withUser.ts<br/>   |  |  |__[withUserType.ts<br/>   |  |  |__[...]<br/>   |  |<br/>   |  |<strong class="ny iu">__utils</strong><br/>   |  |  |__[emailValidator.ts<br/>   |  |  |__[...]<br/>   |  |<br/>   |  |<strong class="ny iu">__constants</strong><br/>   |  |  |__[userTypes.ts<br/>   |  |  |__[...]<br/>   |  |<br/>   |  |<strong class="ny iu">__services</strong><br/>   |  |  |__[loginService].ts<br/>   |  |  |__[...]<br/>   |  |<br/>   |  |__[Login].tsx<br/>   |  |__[Box].tsx<br/>   |  |<strong class="ny iu">__index.ts</strong><br/>   |  |__[...]<br/>   |<br/>   |__[products]<br/>   |  |__[list]<br/>   |  |  |__[<em class="ng">helper directories</em>]<br/>   |  |  |__[<em class="ng">state management directories</em>]<br/>   |  |  |__[List].tsx<br/>   |  |  |__[Item].tsx<br/>   |  |  |__[BaseInfo].tsx<br/>   |  |  |<strong class="ny iu">__index.ts</strong><br/>   |  |  |__[...]<br/>   |  |<br/>   |  |__[detail]<br/>   |  |  |__[<em class="ng">helper directories</em>]<br/>   |  |  |__[<em class="ng">state management directories</em>]<br/>   |  |  |__[<em class="ng">component directories/files</em>]<br/>   |  |<br/>   |  |__[...]<br/>   |<br/>   |<strong class="ny iu">__routes.tsx</strong><br/>   |__[...]</span></pre><ul class=""><li id="7dd9" class="md me it js b jt ju jx jy kb nk kf nl kj nm kn nf ml mm mn bi translated">该目录代表您的web应用页面，例如<strong class="js iu"> <em class="ng">页面/产品</em>或<em class="ng">页面/产品/列表</em> </strong></li><li id="1055" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn nf ml mm mn bi translated">每个子目录都有自己的react组件，只在页面上使用</li><li id="543a" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn nf ml mm mn bi translated">它们是相互独立的，所以如果您需要编辑用户页面，只需要在<strong class="js iu"> <em class="ng">【用户】</em> </strong>目录树中进行修改</li><li id="95a5" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn nf ml mm mn bi translated">使用<strong class="js iu"><em class="ng">shared components</em></strong>目录可以在两个页面之间实现组件共享</li><li id="16e5" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn nf ml mm mn bi translated"><strong class="js iu"> <em class="ng"> routes.tsx </em> </strong>是你app中主路由器的位置，这是你页面的入口点</li></ul><h1 id="8e0c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">3.1.状态管理目录</h1><blockquote class="np nq nr"><p id="f58c" class="jq jr ng js b jt ju jv jw jx jy jz ka ns kc kd ke nt kg kh ki nu kk kl km kn im bi translated">以下示例主要使用高阶组件。如果你喜欢更多的React挂钩，你可以有相同的结构，但带有自定义挂钩。</p></blockquote><blockquote class="ou"><p id="8e0e" class="ov ow it bd ox oy oz pa pb pc pd kn dk translated">唯一的规则是每个页面都应该有自己独立的状态</p></blockquote><h2 id="3dd4" class="mt lg it bd lh mu pe dn ll mw pf dp lp kb pg mz lt kf ph nb lx kj pi nd mb ne bi translated">[商店]</h2><pre class="kp kq kr ks gt nz ny oa ob aw oc bi"><span id="3d22" class="mt lg it ny b gy od oe l of og"><strong class="ny iu">store<br/>  |__reducers.ts<br/>  |__actions.ts<br/>  |__selectors.ts<br/>  |__effects.ts<br/>  |__types.ts</strong></span></pre><p id="6bdc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将它命名为<strong class="js iu"> <em class="ng"> store </em> </strong>是因为用于存储管理的库可以因项目而异。为了给你一个例子，我将描述一下<strong class="js iu"> Redux的结构。</strong></p><p id="d373" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">T33】actions . tsT35】</strong></p><ul class=""><li id="c2be" class="md me it js b jt ju jx jy kb nk kf nl kj nm kn nf ml mm mn bi translated">包含纯函数，它接收准备按原样保存到存储区的数据</li><li id="bdba" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn nf ml mm mn bi translated">这里不做任何数据修改</li></ul><p id="d720" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">T37】effects . tsT39】</strong></p><ul class=""><li id="de69" class="md me it js b jt ju jx jy kb nk kf nl kj nm kn nf ml mm mn bi translated">包含sagas或thunk函数或observables，取决于你将使用什么库的副作用-如果你不使用任何，有没有这个文件的需要</li><li id="f736" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn nf ml mm mn bi translated">商店(动作)的所有数据准备都在这里完成</li></ul><p id="1231" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"><em class="ng">reducers . ts</em>T3】</strong></p><ul class=""><li id="2268" class="md me it js b jt ju jx jy kb nk kf nl kj nm kn nf ml mm mn bi translated">包含带有减速器的存储结构</li><li id="8312" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn nf ml mm mn bi translated">接收准备好的数据进行保存</li><li id="e283" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn nf ml mm mn bi translated">这里不做任何数据修改</li></ul><p id="2d1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ng">选择器. ts </em> </strong></p><ul class=""><li id="17d4" class="md me it js b jt ju jx jy kb nk kf nl kj nm kn nf ml mm mn bi translated">包含接收存储状态作为参数并返回所需数据的函数</li><li id="6f6c" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn nf ml mm mn bi translated">这里可以进行任何组合或数据修改，以获得进一步工作所需的数据结构</li><li id="41f9" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn nf ml mm mn bi translated">使用一些像<strong class="js iu">重新选择</strong>这样的库来记忆是很好的</li></ul><p id="4bb8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">T11】types . tsT13】</strong></p><ul class=""><li id="8e2e" class="md me it js b jt ju jx jy kb nk kf nl kj nm kn nf ml mm mn bi translated">仅包含常量的定义，它代表操作类型</li></ul><p id="b5f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，如果你不喜欢上面例子中的普通名称，你可以用特定的名称作为前缀，例如<strong class="js iu"><em class="ng">user selectors . ts</em></strong><em class="ng">，</em><strong class="js iu"><em class="ng">user reducers . ts</em></strong>等。</p><h2 id="5b08" class="mt lg it bd lh mu mv dn ll mw mx dp lp kb my mz lt kf na nb lx kj nc nd mb ne bi translated">[查询]</h2><pre class="kp kq kr ks gt nz ny oa ob aw oc bi"><span id="e57d" class="mt lg it ny b gy od oe l of og"><strong class="ny iu">queries</strong><br/>  |__[withUser].ts<br/>  |__[withUserType].ts<br/>  |__[...]</span></pre><p id="73ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于使用graphQL的人来说，这是查询和变异的目录。</p><ul class=""><li id="a63e" class="md me it js b jt ju jx jy kb nk kf nl kj nm kn nf ml mm mn bi translated"><strong class="js iu"> <em class="ng">同【QueryName】。ts </em> </strong> —查询专用</li><li id="0aac" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn nf ml mm mn bi translated"><strong class="js iu"> <em class="ng">带【QueryName】突变. ts </em> </strong> — HOC为突变</li></ul><p id="feed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于这个例子，我使用的是<strong class="js iu"> react-apollo。</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="7c08" class="mt lg it bd lh mu mv dn ll mw mx dp lp kb my mz lt kf na nb lx kj nc nd mb ne bi translated">[背景]</h2><pre class="kp kq kr ks gt nz ny oa ob aw oc bi"><span id="7191" class="mt lg it ny b gy od oe l of og"><strong class="ny iu">context</strong><br/>  |__[withUser].ts<br/>  |__[withUserType].ts<br/>  |__[...]</span></pre><p id="d9cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你更好地使用React Context API，这是你可以放置文件的地方。</p><ul class=""><li id="a620" class="md me it js b jt ju jx jy kb nk kf nl kj nm kn nf ml mm mn bi translated"><strong class="js iu"> <em class="ng">同【HocName】。tsx</em>T37】</strong></li></ul><p id="58f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">特设示例:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="9f6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">之后，您可以使用以下助手功能。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><ul class=""><li id="c9d9" class="md me it js b jt ju jx jy kb nk kf nl kj nm kn nf ml mm mn bi translated"><strong class="js iu"> withProviders() — </strong>用上下文提供者包装你的组件</li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><ul class=""><li id="1e97" class="md me it js b jt ju jx jy kb nk kf nl kj nm kn nf ml mm mn bi translated"><strong class="js iu"> withConsumers() — </strong>将所需消费者的所有价值映射到您的组件属性</li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="f355" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">3.2.助手目录</h1><pre class="kp kq kr ks gt nz ny oa ob aw oc bi"><span id="1779" class="mt lg it ny b gy od oe l of og">[login]<br/>  |<strong class="ny iu">__utils</strong><br/>  |  |__[emailValidator].ts<br/>  |  |__[...]<br/>  |<br/>  |<strong class="ny iu">__constants</strong><br/>  |  |__[userTypes].ts<br/>  |  |__[...]<br/>  |<br/>  |<strong class="ny iu">__services</strong><br/>     |__[loginService].ts<br/>     |__[...]</span></pre><h2 id="c99a" class="mt lg it bd lh mu mv dn ll mw mx dp lp kb my mz lt kf na nb lx kj nc nd mb ne bi translated">常数</h2><ul class=""><li id="dcb3" class="md me it js b jt mf jx mg kb mh kf mi kj mj kn nf ml mm mn bi translated">你应该在这里输入你正在使用的所有常量和枚举</li><li id="8fb2" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn nf ml mm mn bi translated">文件应该以描述性的方式命名，例如<strong class="js iu"> <em class="ng">【登录页面URL】。ts</em>T45】</strong></li><li id="b6aa" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn nf ml mm mn bi translated">不要把所有的常量放在一个文件中，把它们分开</li></ul><h2 id="98d8" class="mt lg it bd lh mu mv dn ll mw mx dp lp kb my mz lt kf na nb lx kj nc nd mb ne bi translated">实用工具</h2><ul class=""><li id="b5f3" class="md me it js b jt mf jx mg kb mh kf mi kj mj kn nf ml mm mn bi translated">包括分离到文件和目录的函数/类</li><li id="eed9" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn nf ml mm mn bi translated"><strong class="js iu"> <em class="ng">【实用程序名|实用程序组名】。ts </em> </strong> <em class="ng"> — </em>代表一个功能或一组功能</li><li id="2771" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn nf ml mm mn bi translated">例如<em class="ng"> myValidator.ts </em></li><li id="8968" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn nf ml mm mn bi translated">例如<em class="ng">validators/my validator . ts</em></li></ul><h2 id="7652" class="mt lg it bd lh mu mv dn ll mw mx dp lp kb my mz lt kf na nb lx kj nc nd mb ne bi translated">服务</h2><ul class=""><li id="1ccd" class="md me it js b jt mf jx mg kb mh kf mi kj mj kn nf ml mm mn bi translated">主要是API调用、基本HTTP请求(使用axios、fetch等。)</li><li id="ca81" class="md me it js b jt mo jx mp kb mq kf mr kj ms kn nf ml mm mn bi translated"><strong class="js iu"> <em class="ng">服务/【服务名】。ts</em>T59】</strong></li></ul><p id="a5c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一个例子显示了如何配置<strong class="js iu"> axios </strong>。它还包括来自浏览器cookie的访问令牌初始化。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="2417" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用户服务定义示例:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="b720" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">3.3.反应组分</h1><pre class="kp kq kr ks gt nz ny oa ob aw oc bi"><span id="6188" class="mt lg it ny b gy od oe l of og">[products]<br/>   |__[Login].tsx<br/>   |__[Box].tsx<br/>   |__[ComponentComposedWithSmallComponents]<br/>   |  |__[Component1].tsx<br/>   |  |__[Component2].tsx<br/>   |  |__[Component3].tsx<br/>   |  |<strong class="ny iu">__index.ts</strong><br/>   |<br/>   |__[...]</span></pre><p id="3417" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当特定的pages目录由于内部组件过多而失去可读性时，请将这些组件分离到不同的目录中。然后<strong class="js iu"> <em class="ng"> index.ts </em> </strong>文件重新导出你的组件。在这种情况下，您需要将您的组件视为构建块。它们只公开了一个可以从外部使用的组件，但是对于外部世界来说，它是一个黑盒。</p><h1 id="ae8d" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">一起</h1><pre class="kp kq kr ks gt nz ny oa ob aw oc bi"><span id="3e3f" class="mt lg it ny b gy od oe l of og">src<br/>|__core<br/>|  |__context.ts<br/>|  |__httpClient.ts<br/>|  |__[...]<br/>|<br/>|__sharedComponents<br/>|  |__header<br/>|  |  |__Menu.tsx<br/>|  |  |__UserPanel.tsx<br/>|  |  |__Header.tsx<br/>|  |  |__index.ts<br/>|  |  |__[...]<br/>|  |<br/>|  |__form<br/>|  |  |__Button.tsx<br/>|  |  |__Form.tsx<br/>|  |  |__Input.tsx<br/>|  |  |__index.ts<br/>|  |  |__[...]<br/>|  |<br/>|  |__Sidebar.tsx<br/>|  |__[...]<br/>|<br/>|__pages<br/>|  |__login<br/>|  |  |__store<br/>|  |  |  |__reducers.ts<br/>|  |  |  |__actions.ts<br/>|  |  |  |__selectors.ts<br/>|  |  |  |__effects.ts<br/>|  |  |  |__types.ts<br/>|  |  |<br/>|  |  |__queries<br/>|  |  |  |__withUser.ts<br/>|  |  |  |__withUserType.ts<br/>|  |  |  |__[...]<br/>|  |  |<br/>|  |  |__context<br/>|  |  |  |__withUser.ts<br/>|  |  |  |__withUserType.ts<br/>|  |  |  |__[...]<br/>|  |  |<br/>|  |  |__utils<br/>|  |  |  |__emailValidator.ts<br/>|  |  |  |__[...]<br/>|  |  |<br/>|  |  |__constants<br/>|  |  |  |__userTypes.ts<br/>|  |  |  |__[...]<br/>|  |  |<br/>|  |  |__services<br/>|  |  |  |__loginService.ts<br/>|  |  |  |__[...]<br/>|  |  |<br/>|  |  |__Login.tsx -&gt; &lt;Login /&gt;<br/>|  |  |__Box.tsx -&gt; &lt;LoginBox /&gt;<br/>|  |  |__index.ts -&gt; re-exports the specific page component<br/>|  |  |__[...]<br/>|  |<br/>|  |__products<br/>|  |  |__list<br/>|  |  |  |__[<em class="ng">helper directories</em>]<br/>|  |  |  |__[<em class="ng">state management directories</em>]<br/>|  |  |  |__List.tsx -&gt; &lt;ProductsList /&gt;<br/>|  |  |  |__Item.tsx -&gt; &lt;ProductsItem /&gt;<br/>|  |  |  |__BaseInfo.tsx -&gt; &lt;ProductsBaseInfo /&gt;<br/>|  |  |  |__index.ts -&gt; re-exports the specific page component<br/>|  |  |  |__[...]<br/>|  |  |<br/>|  |  |__detail<br/>|  |     |__[<em class="ng">helper directories</em>]<br/>|  |     |__[<em class="ng">state management directories</em>]<br/>|  |     |__[<em class="ng">component directories/files</em>]<br/>|  |     |__[...]<br/>|  |<br/>|  |__routes.tsx<br/>|  |<br/>|__index.ts</span></pre></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="d0a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">非常感谢你的阅读！</p></div></div>    
</body>
</html>