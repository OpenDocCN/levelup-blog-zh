<html>
<head>
<title>Typescript Classes — From Zero to Hero</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型脚本类——从零到英雄</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-classes-from-zero-to-hero-a429a3c96189?source=collection_archive---------1-----------------------#2022-11-05">https://levelup.gitconnected.com/typescript-classes-from-zero-to-hero-a429a3c96189?source=collection_archive---------1-----------------------#2022-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9247" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文旨在演示和解释以下问题/概念:</p><ul class=""><li id="262e" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">Typescript中的基本类概念及其语法</li><li id="ba19" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">类中的数据修饰符</li><li id="243f" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">Typescript中的类继承(子类)</li><li id="56cc" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">Typescript类中的接口</li></ul><p id="e761" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们开始之前，如果你只是一个打字初学者。以下是一些有助于您开始的好资源:</p><ul class=""><li id="0cbd" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">打字稿官方手册(阅读材料)</li><li id="ae0e" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://www.youtube.com/watch?v=BCg4U1FzODs" rel="noopener ugc nofollow" target="_blank">打字稿速成班</a>(视频资料)</li></ul><p id="1e3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">TL；DR代码报告<a class="ae lc" href="https://github.com/caopengau/typescript-class-demo" rel="noopener ugc nofollow" target="_blank">此处</a>。让我们开始吧…</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/594a04e65926d1a2cdf7ef7f6704b9ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*je-xdAIHJQGAnw1KbqQxDg.png"/></div></div></figure><h1 id="0fc9" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">Typescript中的基本概念及其语法</h1><h2 id="bdee" class="mn lq it bd lr mo mp dn lv mq mr dp lz kb ms mt md kf mu mv mh kj mw mx ml my bi translated">阶级的基本概念</h2><p id="e1e8" class="pw-post-body-paragraph jq jr it js b jt mz jv jw jx na jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">类就像对象的蓝图。它们用于定义对象的形状和创建新对象。一个类可以有属性和方法。它们主要用于面向对象的编程语言，如C#、Java和C++。您可能已经使用了JavaScript或其他语言的类。类是在ES6 (ECMAScript 2015)中引入的，在Typescript中也可用。</p><h2 id="82dc" class="mn lq it bd lr mo mp dn lv mq mr dp lz kb ms mt md kf mu mv mh kj mw mx ml my bi translated">语法和用法</h2><p id="5184" class="pw-post-body-paragraph jq jr it js b jt mz jv jw jx na jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">现在我们可以在文件<code class="fe ne nf ng nh b">Animal.ts</code>中创建一个名为<code class="fe ne nf ng nh b">Animal</code>的基类。Typescript中的类需要有一些属性，以便我们以后可以使用它们。让我们也<code class="fe ne nf ng nh b">export</code>我们的类，这样它可以被其他脚本使用。</p><pre class="le lf lg lh gt ni nh nj nk aw nl bi"><span id="e3c5" class="mn lq it nh b gy nm nn l no np">export class Animal {<br/>  name: string;<br/>  age: number;<br/>  species: string;<br/>  <!-- -->move: Function = () =&gt; { console.log("moving") }; // default a move function for all animal<br/>  alive: boolean;<br/>}<!-- --> </span></pre><p id="4ca4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您可能在访问这个类时遇到了错误</p><pre class="le lf lg lh gt ni nh nj nk aw nl bi"><span id="4c9d" class="mn lq it nh b gy nm nn l no np">Animal.ts:2:3 - error TS2564: Property '...' has no initializer and is not definitely assigned in the constructor.</span></pre><p id="ee2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们定义构造函数</p><pre class="le lf lg lh gt ni nh nj nk aw nl bi"><span id="69b4" class="mn lq it nh b gy nm nn l no np">export class Animal {<br/>  name: string;<br/>  age: number;<br/>  species: string;<br/>  move: Function = () =&gt; {<br/>    console.log("running");<br/>  };<br/>  alive: boolean = true;<br/>  constructor(<br/>    name: string,<br/>    age: number,<br/>    species: string,<br/>    alive: boolean,<br/>    move?: Function<br/>  ) {<br/>  }<br/>}</span></pre><p id="4862" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">之后，我们需要设置我们的属性值。我们可以通过使用<code class="fe ne nf ng nh b">this</code>关键字来做到这一点。</p><pre class="le lf lg lh gt ni nh nj nk aw nl bi"><span id="f0d4" class="mn lq it nh b gy nm nn l no np">export class Animal {<br/>  name: string;<br/>  age: number;<br/>  species: string;<br/>  move: Function = () =&gt; {<br/>    console.log("running");<br/>  };<br/>  alive: boolean = true;<br/>  constructor(<br/>    name: string,<br/>    age: number,<br/>    species: string,<br/>    alive: boolean,<br/>    move?: Function<br/>  ) {<br/>    this.name = name;<br/>    this.age = age;<br/>    this.species = species;<br/>    this.alive = alive;<br/>    if (move) this.move = move;<br/>  }<br/>}</span></pre><p id="2a8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ne nf ng nh b">this</code>关键字用于在构造函数中设置我们类的属性值。</p><p id="5875" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建类后，我们可以创建它的一个新实例。我们可以通过创建一个名为<code class="fe ne nf ng nh b">animal</code>的新常量或变量，并将其赋给我们类的一个新实例来实现。您可以通过使用<code class="fe ne nf ng nh b">new</code>关键字来创建我们的类的新实例。</p><p id="2f6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，您需要传入在构造函数中传递的相同参数。创建一个文件<code class="fe ne nf ng nh b">main.ts</code>并尝试用animal类创建一个<code class="fe ne nf ng nh b">pet</code>。</p><pre class="le lf lg lh gt ni nh nj nk aw nl bi"><span id="2abb" class="mn lq it nh b gy nm nn l no np">import { Animal } from "./Animal";</span><span id="3527" class="mn lq it nh b gy nq nn l no np">const dogMove = () =&gt; {<br/>  console.log("gallopping");<br/>};<br/>const pet = new Animal("Fido", 3, "dog", true, dogMove)</span></pre><blockquote class="nr ns nt"><p id="92bc" class="jq jr nu js b jt ju jv jw jx jy jz ka nv kc kd ke nw kg kh ki nx kk kl km kn im bi translated"><strong class="js iu"> <em class="it">注意:</em> </strong> <em class="it">当你创建一个我们类的新实例的时候会调用构造函数。</em></p></blockquote><p id="3385" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们试着打印出我们类的值。</p><pre class="le lf lg lh gt ni nh nj nk aw nl bi"><span id="e3c2" class="mn lq it nh b gy nm nn l no np">import { Animal } from "./Animal";</span><span id="4e9e" class="mn lq it nh b gy nq nn l no np">const dogMove = () =&gt; {<br/>  console.log("gallopping");<br/>};</span><span id="4eed" class="mn lq it nh b gy nq nn l no np">const pet = new Animal("Fido", 3, "dog", true, dogMove)<br/>console.log(pet)</span><span id="96d7" class="mn lq it nh b gy nq nn l no np">Output:</span><span id="0635" class="mn lq it nh b gy nq nn l no np">Animal {<br/>  name: 'Fido',<br/>  age: 3,<br/>  species: 'dog',<br/>  alive: true,<br/>  move: [Function (anonymous)]<br/>}</span></pre><p id="f47a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您也可以选择要打印的值。</p><pre class="le lf lg lh gt ni nh nj nk aw nl bi"><span id="cd33" class="mn lq it nh b gy nm nn l no np">console.log(pet.name); // Output: Fido</span><span id="ac8e" class="mn lq it nh b gy nq nn l no np">console.log(pet.age); // Output: 3</span><span id="e9ce" class="mn lq it nh b gy nq nn l no np">console.log(pet.species); // Output: dog</span><span id="3114" class="mn lq it nh b gy nq nn l no np">console.log(pet.alive); // Output: true</span><span id="1f66" class="mn lq it nh b gy nq nn l no np">console.log(pet.move); // Output: [Function (anonymous)]</span><span id="3c26" class="mn lq it nh b gy nq nn l no np">pet.move(); // Output: gallopping</span></pre><h1 id="757e" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">类中的数据修饰符</h1><p id="5548" class="pw-post-body-paragraph jq jr it js b jt mz jv jw jx na jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">数据修饰符用于定义类属性的访问级别。我们可以将类的属性定义为<code class="fe ne nf ng nh b">public</code>、<code class="fe ne nf ng nh b">private</code>或<code class="fe ne nf ng nh b">protected</code>。</p><pre class="le lf lg lh gt ni nh nj nk aw nl bi"><span id="0dbd" class="mn lq it nh b gy nm nn l no np">export class Animal {<br/>  public name: string; // default access level.<br/>  private age: number; // private access level.<br/>  protected species: string; // protected access level.<br/>  move: Function = () =&gt; {  // default access level.<br/>    console.log("running");<br/>  };<br/>  alive: boolean = true;  // default access level.<br/>  constructor(<br/>    name: string,<br/>    age: number,<br/>    species: string,<br/>    alive: boolean,<br/>    move?: Function<br/>  ) {<br/>    this.name = name;<br/>    this.age = age;<br/>    this.species = species;<br/>    this.alive = alive;<br/>    if (move) {<br/>      this.move = move;<br/>    }<br/>  }<br/>}</span></pre><ul class=""><li id="f88d" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated"><code class="fe ne nf ng nh b">public</code>:这是默认的访问级别。这意味着可以从代码中的任何地方访问属性/方法。</li><li id="bbd9" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><code class="fe ne nf ng nh b">private</code>:这意味着属性/方法只能从类内部访问。</li><li id="04a2" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><code class="fe ne nf ng nh b">protected</code>:这意味着属性/方法只能从类及其子类中访问。我们将在下一节学习子类。</li></ul><h1 id="a413" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">类继承(子类)</h1><p id="52fa" class="pw-post-body-paragraph jq jr it js b jt mz jv jw jx na jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">子类用于扩展我们的类的功能。我们可以创建一个扩展(继承)现有类的新类。现在我们可以创建一个继承自<code class="fe ne nf ng nh b">Animal</code>类的子类<code class="fe ne nf ng nh b">Dog</code>。</p><pre class="le lf lg lh gt ni nh nj nk aw nl bi"><span id="7e5b" class="mn lq it nh b gy nm nn l no np">export class Animal {<br/>  public name: string; // default access level.<br/>  private age: number; // private access level.<br/>  protected species: string; // protected access level.<br/>  move: Function = () =&gt; {  // default access level.<br/>    console.log("running");<br/>  };<br/>  alive: boolean = true;  // default access level.<br/>  constructor(<br/>    name: string,<br/>    age: number,<br/>    species: string,<br/>    alive: boolean,<br/>    move?: Function<br/>  ) {<br/>    this.name = name;<br/>    this.age = age;<br/>    this.species = species;<br/>    this.alive = alive;<br/>    if (move) {<br/>      this.move = move;<br/>    }<br/>  }<br/>}</span><span id="1135" class="mn lq it nh b gy nq nn l no np">// `Dog` class inherits from `Animal` class.<br/>export class Dog extends Animal {<br/>  breed: string; // `breed` an extra property to the `Dog` class.<br/>  constructor(<br/>    name: string,<br/>    age: number,<br/>    species: string,<br/>    alive: boolean,<br/>    breed: string,<br/>    move?: Function<br/>  ) {<br/>    // `super` keyword is used to call the constructor parameters of the parent class.<br/>    super(name, age, species, alive, move);<br/>    // `breed` property is set to the value of `breed` parameter.<br/>    this.breed = breed;<br/>  }<br/>}</span></pre><p id="9041" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我解释一下这里发生了什么。首先，我们创建一个名为<code class="fe ne nf ng nh b">Dog</code>的新类，它扩展了<code class="fe ne nf ng nh b">Animal</code>类。然后我们为<code class="fe ne nf ng nh b">Dog</code>创建一个构造函数，它调用<code class="fe ne nf ng nh b">Animal</code>类的构造函数。然后我们向<code class="fe ne nf ng nh b">Dog</code>类添加一个新的属性<code class="fe ne nf ng nh b">breed</code>。</p><p id="03f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，我们不需要在<code class="fe ne nf ng nh b">Dog</code>类中定义<code class="fe ne nf ng nh b">Animal</code>的任何属性。这是因为<code class="fe ne nf ng nh b">Dog</code>类通过关键字<code class="fe ne nf ng nh b">super</code>从<code class="fe ne nf ng nh b">Animal</code>类继承了那些属性。这是一个关键字，用于调用父类的构造函数参数。我们可以使用<code class="fe ne nf ng nh b">super</code>从<code class="fe ne nf ng nh b">Animal</code>类中获取<code class="fe ne nf ng nh b">name</code>、<code class="fe ne nf ng nh b">age</code>和<code class="fe ne nf ng nh b">species</code>属性的值。</p><p id="6796" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以为我们的Dog类创建一个新实例。</p><pre class="le lf lg lh gt ni nh nj nk aw nl bi"><span id="ef16" class="mn lq it nh b gy nm nn l no np">const dog = new Dog("Fido", 3, "dog", true, "Labrador", dogMove);</span><span id="d6b1" class="mn lq it nh b gy nq nn l no np">console.log(dog);</span><span id="2d35" class="mn lq it nh b gy nq nn l no np">Output:</span><span id="773d" class="mn lq it nh b gy nq nn l no np">Dog {<br/>  move: [Function: dogMove],<br/>  alive: true,<br/>  name: 'Fido',<br/>  age: 3,<br/>  species: 'dog',<br/>  breed: 'Labrador'<br/>}</span></pre><h1 id="1733" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">阶级遗产</h1><p id="6e4c" class="pw-post-body-paragraph jq jr it js b jt mz jv jw jx na jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">在TypeScript中，一个类可以实现接口来执行特定的契约(类似于Java和C#这样的语言)。创建一个<code class="fe ne nf ng nh b">Task.ts</code>文件</p><pre class="le lf lg lh gt ni nh nj nk aw nl bi"><span id="389a" class="mn lq it nh b gy nm nn l no np">// Task.ts<br/>interface Task{<br/>    name: String; //property<br/>    run(arg: any):void; //method<br/>}<br/><br/>class MyTask implements Task{<br/>    name: String;<br/>    constructor(name: String) {<br/>        this.name = name;<br/>    }<br/><br/>    run(arg: any): void {<br/>        console.log(`running: ${this.name}, arg: ${arg}`);<br/>    }<br/>}</span><span id="d58e" class="mn lq it nh b gy nq nn l no np">// main.ts</span><span id="d702" class="mn lq it nh b gy nq nn l no np">import { MyTask, Task } from "./Task";</span><span id="537b" class="mn lq it nh b gy nq nn l no np">let myTask: Task = new MyTask('someTask');<br/>myTask.run("test");</span><span id="34ae" class="mn lq it nh b gy nq nn l no np">// Output: running: someTask, arg: test</span></pre><h1 id="c4f9" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">重写类的toString方法</h1><pre class="le lf lg lh gt ni nh nj nk aw nl bi"><span id="9bdb" class="mn lq it nh b gy nm nn l no np">class Animal {<br/>  ...<br/>  toString(): string {<br/>    return `${this.name} is a ${this.species} and is ${this.age} years old.`;<br/>  };<br/>  <!-- -->...<br/>};</span><span id="5134" class="mn lq it nh b gy nq nn l no np">const pet = new Animal("Fido", 3, "dog", true, dogMove);</span><span id="95dd" class="mn lq it nh b gy nq nn l no np">// To string will be called when concatenating strings<br/>// console.log(pet) will not work as expected</span><span id="5822" class="mn lq it nh b gy nq nn l no np">console.log(`${pet}`) // Output: Fido is a dog and is 3 years old.</span></pre><h1 id="a370" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="951d" class="pw-post-body-paragraph jq jr it js b jt mz jv jw jx na jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">现在您已经了解了Typescript中类的基础知识。您可以使用类做许多其他事情，因此您可以到官方文档中了解更多信息。这里可以找到<a class="ae lc" href="https://www.typescriptlang.org/docs/handbook/2/classes.html" rel="noopener ugc nofollow" target="_blank">。如果你忘记了什么，你可以随时回到这篇文章。我建议在你的主项目或副项目中使用类。我希望你喜欢这篇文章！</a></p><h2 id="23d7" class="mn lq it bd lr mo mp dn lv mq mr dp lz kb ms mt md kf mu mv mh kj mw mx ml my bi translated">应该用类代替函数吗？</h2><p id="35ca" class="pw-post-body-paragraph jq jr it js b jt mz jv jw jx na jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">这是一个在社区中经常被问到的问题，很难找到一个好的答案。我个人认为类更加灵活和易于维护，但是它们需要一些额外的复杂性来设置。我会在更重要的项目中使用类，但是在较小的项目中，函数是一个很好的选择。</p><h2 id="d96e" class="mn lq it bd lr mo mp dn lv mq mr dp lz kb ms mt md kf mu mv mh kj mw mx ml my bi translated">延伸阅读:</h2><ul class=""><li id="41b8" class="ko kp it js b jt mz jx na kb ny kf nz kj oa kn kt ku kv kw bi translated"><a class="ae lc" rel="noopener ugc nofollow" target="_blank" href="/typescript-must-know-fundamentals-for-your-next-tech-interview-or-project-255ae70df0a3"> TypeScript必备基础——类型别名和接口</a></li><li id="6067" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" rel="noopener ugc nofollow" target="_blank" href="/use-typescript-keyof-like-a-pro-56f3a3d06b73">像专家一样使用打字键盘</a></li><li id="c559" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" rel="noopener ugc nofollow" target="_blank" href="/next-level-your-typescript-runtime-type-validation-using-class-and-decorators-ddd2ce3c86f3">使用类和装饰器的下一级Typescript运行时类型验证</a></li><li id="68aa" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" rel="noopener ugc nofollow" target="_blank" href="/mastering-typescript-generics-the-ultimate-guide-3a62afeff44">掌握类型脚本泛型:终极指南</a></li><li id="c096" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://bootcamp.uxdesign.cc/typescript-tricks-and-tips-become-a-pro-in-no-time-5390aba151be" rel="noopener" target="_blank">打字技巧和提示:立即成为专业人员</a></li><li id="f813" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" rel="noopener ugc nofollow" target="_blank" href="/generics-in-typescript-must-know-fundamentals-stupidly-simplified-e7b4d7ffc0e3">TypeScript中的泛型——愚蠢简化的基础知识</a></li><li id="c0f9" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" rel="noopener ugc nofollow" target="_blank" href="/typescript-missed-this-but-you-shouldnt-runtime-type-validation-aa8a81ce4289"> Typescript遗漏了这一点，但你不应该—运行时类型验证</a></li><li id="ff23" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" rel="noopener ugc nofollow" target="_blank" href="/typescript-enum-pitfalls-and-solutions-must-know-bb971cb0f7d2"> Typescript枚举陷阱和解决方案必须知道</a></li><li id="27e6" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://bootcamp.uxdesign.cc/mastering-typescript-generics-the-ultimate-guide-essential-interface-techniques-86e793cf1fc" rel="noopener" target="_blank">掌握类型脚本泛型—终极指南—基本接口技术</a></li><li id="0a9f" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">Javascript开发者经常错过的Typescript特性</li><li id="bc34" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" rel="noopener ugc nofollow" target="_blank" href="/mastering-intersection-and-union-types-in-typescript-the-ultimate-guide-essential-techniques-49aa9f6a188a">掌握TypeScript中的交集和并集类型:终极指南和基本技术</a></li></ul></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="bb11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你觉得这个指南有帮助，请鼓掌并跟我来。通过<a class="ae lc" href="https://medium.com/@caopengau/membership" rel="noopener">这个链接</a>加入medium，访问我和所有其他优秀作家在medium上的所有优质文章。</p></div></div>    
</body>
</html>