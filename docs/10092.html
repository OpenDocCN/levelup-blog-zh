<html>
<head>
<title>Federating Prometheus Effectively</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有效地联合普罗米修斯</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/federating-prometheus-effectively-4ccd51b2767b?source=collection_archive---------1-----------------------#2021-10-26">https://levelup.gitconnected.com/federating-prometheus-effectively-4ccd51b2767b?source=collection_archive---------1-----------------------#2021-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="511b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">效率和专注是成功的关键</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2ec7ed3126363735ec85c15dcdb435b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n4yrBHfhSW-C8Yf9xf48pg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片由:<a class="ae kv" href="https://www.shutterstock.com/g/AlekseiBezrodniy" rel="noopener ugc nofollow" target="_blank"> AIexVector </a></figcaption></figure><p id="d54b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">联合允许一个Prometheus服务器从另一个Prometheus服务器抓取选定的时间序列。Prometheus federation可用于扩展到数百个集群，或将相关指标从一个服务的Prometheus拉入另一个服务。它支持<em class="ls">分层</em>和<em class="ls">跨服务</em>联盟，在<a class="ae kv" href="https://prometheus.io/docs/prometheus/latest/federation/#federation" rel="noopener ugc nofollow" target="_blank">官方文档</a>中有更详细的解释。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h2 id="b056" class="ma mb iq bd mc md me dn mf mg mh dp mi lf mj mk ml lj mm mn mo ln mp mq mr ms bi translated">用简单的方法配置联盟</h2><p id="6c34" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated"><code class="fe my mz na nb b">/federate</code>端点允许在任何给定的Prometheus服务器上检索该服务器中一组选定时间序列的当前值。假设您需要编写一个联邦作业来收集其他Prometheus服务器的时间序列。在互联网上查找“普罗米修斯联邦配置示例”时，您经常会遇到如下配置示例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">普罗米修斯为联邦工作的简单例子</figcaption></figure><p id="30c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个配置示例很糟糕，如果您的<code class="fe my mz na nb b">child-prometheus1:31090</code>实例中有大约100K或更多的时间序列，您可能会遇到联合问题。为什么这个配置不好，你很快就知道了。</p><h2 id="7605" class="ma mb iq bd mc md me dn mf mg mh dp mi lf mj mk ml lj mm mn mo ln mp mq mr ms bi translated">你会有什么问题？</h2><p id="f97e" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">如果您曾经在Prometheus服务器的日志中收到过以下错误信息，那么这个主题肯定会让您感兴趣。</p><pre class="kg kh ki kj gt ne nb nf ng aw nh bi"><span id="f041" class="ma mb iq nb b gy ni nj l nk nl">level=error ts=2021-09-21T11:30:33.163676493Z caller=federate.go:163 component=web msg="federation failed" err="write tcp 192.168.22.145:9090-&gt;10.0.0.12:31090: write: broken pipe"</span></pre><p id="29ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如在<a class="ae kv" href="https://groups.google.com/g/prometheus-users/c/xlKc_fp4r3k/m/o-k7ErdYBAAJ" rel="noopener ugc nofollow" target="_blank">中所讨论的，prometheus-users邮件列表联盟中的这个</a>对话线程并不打算拉无限数量的时间序列或数据复制。当大量数据被联合时，就会出现上面提到的错误消息，然后调用方的<code class="fe my mz na nb b">scrape_timeout</code>被超过，导致调用方挂起。当连接关闭时，客户端遇到一个写错误——管道断开——因为另一端断开了连接。</p><p id="fde8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些工程师说，当收集超过10K时间序列时，联合不是一个好主意，但我想以我们的实践为例，我们在生产中有一个具有许多端点的分层联合，其中我们平均从每个端点收集多达40万个时间序列。需要注意的是，时间序列的数量也取决于<code class="fe my mz na nb b">scrape_interval</code>和<code class="fe my mz na nb b">scrape_timeout</code>的值。根据它们的不同，摄取的数据量可能会有所不同。也许你会问，我们是如何实现的？</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h2 id="7b00" class="ma mb iq bd mc md me dn mf mg mh dp mi lf mj mk ml lj mm mn mo ln mp mq mr ms bi translated">使用高级方式配置联盟</h2><p id="6ad1" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">正如我们上面所说的关于<em class="ls">简单联合</em>作业的短语<em class="ls">糟糕的配置</em>，让我们一步一步地理解它为什么如此糟糕。</p><p id="21ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">主要原因是<code class="fe my mz na nb b">match[]</code>部分下的<code class="fe my mz na nb b">{__name__=~".+"}</code>表达式，这意味着Prometheus服务器将从<code class="fe my mz na nb b">child-prometheus1:31090</code>实例收集<strong class="ky ir">所有</strong>时间序列。你必须确定，你需要你的孩子普罗米修斯实例的所有时间序列吗？也许收集所有的时间序列没有意义。这是联邦的另一个例子，它的配置比前一个更先进。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">普罗米修斯为联邦工作的先进范例</figcaption></figure><p id="91c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里需要重点关注两点。第一个是<code class="fe my mz na nb b">match[]</code>参数。正如您已经猜到的那样，您的Prometheus将只收集指标名称带有<code class="fe my mz na nb b">kube_</code>、<code class="fe my mz na nb b">node_</code>或<code class="fe my mz na nb b">container_</code>前缀的时间序列。它假设您避免收集不必要的时间序列，而是只保留您需要的时间序列。<code class="fe my mz na nb b">match[]</code> param下的查询表达式选择器可以接受您拥有的任何标签，如<code class="fe my mz na nb b">job</code>、<code class="fe my mz na nb b">id</code>等。</p><p id="ba8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个重点是<code class="fe my mz na nb b"><a class="ae kv" href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs" rel="noopener ugc nofollow" target="_blank">metric_relabel_configs</a></code>。总的来说，这是工作配置中很好的一部分。根据这个例子，您将删除具有<code class="fe my mz na nb b">id="static-agent"</code>键值对的时间序列。有时，它可以解决重复数据删除等问题(例如，如果您的时间序列具有相同的指标名称)。</p><blockquote class="nm nn no"><p id="3403" class="kw kx ls ky b kz la jr lb lc ld ju le np lg lh li nq lk ll lm nr lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="iq">知道重要。</em><br/></strong><code class="fe my mz na nb b">metric_relabel_configs</code>的用法并不保证时间序列注射量少。您应该记得Prometheus服务器收集所有与<code class="fe my mz na nb b">match[]</code>查询参数匹配的时间序列。这意味着Prometheus仅在Prometheus服务器收集了与regex关键字相匹配的时间序列后，才丢弃它们，之后，序列的其余部分存储在TSDB持久性存储中。</p></blockquote></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h2 id="66f5" class="ma mb iq bd mc md me dn mf mg mh dp mi lf mj mk ml lj mm mn mo ln mp mq mr ms bi translated">一些最佳实践。</h2><p id="79f0" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">为了避免通过联合注入大量数据，有一些解决方案可以用你在这个故事中学到的技巧来应用。解决方案是关于数据分离的。数据分离可以按作业级别或数据库级别进行。让我们看看什么是数据分离？</p><p id="90bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">作业级数据分离。<br/> </strong>当我们谈到作业级数据分离时，这意味着您可以为同一个端点编写多个联合作业，这将确保从每个端点注入唯一的数据。最好使<code class="fe my mz na nb b">scrape_interval</code>和<code class="fe my mz na nb b">scrape_timeout</code>具有相同的值。请参见下面的示例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">作业级别分离的Prometheus federation作业示例</figcaption></figure><p id="7cc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们只是将<code class="fe my mz na nb b">advanced-federation</code>任务分成两个独立的任务，分别命名为<code class="fe my mz na nb b">advanced-federation1</code>和<code class="fe my mz na nb b">advanced-federation2</code>。</p><p id="5fa9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">数据库级分离。</strong></p><p id="2ca4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您的<code class="fe my mz na nb b">child-prometheus1</code>实例正在Kubernetes集群上运行，那么您可以轻松地添加一个新的部署对象，例如名称为<code class="fe my mz na nb b">child-prometheus2</code>、<em class="ls">、</em>的对象，它们的不同之处仅在于其配置图。在这种情况下，您需要将一些作业从<code class="fe my mz na nb b">child-prometheus1</code>实例转移到<code class="fe my mz na nb b">child-prometheus2</code>。这样，Prometheus服务器将从两个端点收集数据，如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">数据库级分离的Prometheus federation作业示例</figcaption></figure><h2 id="8dd8" class="ma mb iq bd mc md me dn mf mg mh dp mi lf mj mk ml lj mm mn mo ln mp mq mr ms bi translated">结论。</h2><p id="900a" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">最后两个例子工作得很好，但是我的建议是使用<strong class="ky ir"> <em class="ls">作业级数据分离</em> </strong>而不是<strong class="ky ir"> <em class="ls">数据库级数据分离</em> </strong>，因为你避免了在你的基础设施中有一个额外的端点。显然，第一种方法更容易、更实用、也更专业。</p><p id="1da2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。我希望这个故事是有帮助的。如果你有兴趣，可以看看<a class="ae kv" href="https://hayk96.medium.com" rel="noopener">我的其他媒体文章</a>。</p></div></div>    
</body>
</html>