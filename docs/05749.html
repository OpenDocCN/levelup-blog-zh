<html>
<head>
<title>How to Build Tailored AMIs To Level Up your Infrastructure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建定制的ami来提升您的基础设施</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-tailored-amis-to-level-up-your-infrastructure-5129878dbccd?source=collection_archive---------2-----------------------#2020-09-27">https://levelup.gitconnected.com/how-to-build-tailored-amis-to-level-up-your-infrastructure-5129878dbccd?source=collection_archive---------2-----------------------#2020-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ad431578f83cb90c5dcedce2f0f63540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2i7hghN55a3nc61k"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">戴维·莱夫克在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ae28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在每个人的基础设施之旅中，总有一天你必须构建自己的AWS AMIs。您不必在每次调配实例时都进行配置，而是创建一个预加载了以下内容的映像:</p><ul class=""><li id="49c9" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">所需的应用程序/工具/脚本</li><li id="12a6" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">用所有最新的软件包打补丁</li><li id="5001" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">操作系统的安全强化</li><li id="8b6a" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">关于您的环境的信息，以便它可以联机并立即开始工作。</li><li id="eae1" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">等等…</li></ul><p id="6589" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我不认为我必须向任何人推销为什么以上所有的东西都很好。它还可以节省您的时间和精力，因为它只在创建映像本身时执行一次，而不是针对每个实例。</p><p id="33ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">自定义图像的另一个好处是“宠物”与“羊”的概念。当您的映像预加载了您需要的所有内容后，您可以根据需要销毁和重建您的服务器。您的服务器变成了绵羊，可以根据需要更换。相比之下，服务器每次构建时都需要重新配置。不要在需要的时候摧毁服务器/宠物，你必须照顾好它们以及随之而来的所有困难(例如，不断地打补丁、更新、出于安全原因的加固等等)</p><p id="1f5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">平心而论，您可以通过使用诸如Puppet、Nomad或Ansible之类的东西来减少普通图像的痛苦。这种方法的问题是这些工具在构建时运行。因此，当服务器启动时，这些工具将需要10–20分钟来配置它。相比之下，定制映像可以立即使用，或者需要一两分钟才能使用。</p><p id="9db5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经了解了一些问题和好处，我们需要设计如何构建我们的自定义映像。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="e974" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在构建自定义映像时，就像任何自动化一样，我们希望确保做出明智的决策。我们需要生产这样的东西:</p><ul class=""><li id="37df" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">使用方便</li><li id="e1f7" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">能够自动化</li><li id="f46b" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">可攀登的</li><li id="3539" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">易于更新</li><li id="32fb" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">安全的</li><li id="df20" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">DRY —减少/消除复制和粘贴代码的需要</li></ul><p id="387f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于我们的自定义图像，这是外观的轮廓:</p><ul class=""><li id="7362" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">我们将创建一个基础映像，其中包含所有服务器类型所需的所有一般依赖项(例如修补、监控工具、操作系统强化)。</li><li id="f54f" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">所有其他映像将使用基础映像作为起点，然后添加特定功能映像所需的任何其他工具/应用程序/配置(例如bastion服务器、Kubernetes节点)。</li><li id="62ac" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">所有图像/ami将由一个中央AWS帐户托管。从中央帐户，图像将与我们的其他AWS帐户共享。这使我们能够从单个帐户管理映像，减少了配置时间，有助于保持干燥，并且总体上使该设置更易于使用/管理。</li><li id="8479" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">打包程序将用于创建图像</li><li id="a7e2" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">Ansible将用于配置图像</li><li id="fdbd" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">Terraform将在构建时引导从映像创建的实例。</li><li id="2e25" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">图像将不包含任何秘密/API密钥/密码。这些将由Terraform作为引导过程的一部分提供。这更安全，也使图像更具可扩展性。</li></ul><p id="d266" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Packer、Ansible和Terraform将在各自的专门章节中进行解释。我还将在“让我们开始构建吧！”中包含代码或参考资料，可以帮助您开始使用自定义图像部分。</p><h1 id="d197" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">包装工人</h1><p id="ca6c" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">对于那些不熟悉的人来说，<a class="ae kf" href="https://www.packer.io/" rel="noopener ugc nofollow" target="_blank"> Packer </a>是Hashicorp家族的一员(所以你知道这将会很神奇)。它通过以下方式自动创建机器映像:</p><ul class=""><li id="172f" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">创建临时实例</li><li id="d894" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">根据您提供的说明配置临时实例</li><li id="ed5a" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">从临时实例创建映像</li><li id="f65d" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">终止临时实例</li></ul><p id="7e8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">注</strong>:从Packer 1 . 5 . 0开始，Packer中增加了对HCL的支持。下面所有的例子都是在HCL中。如果您有一个较旧版本的Packer，并且不想升级，那么您需要将示例转换成相关的JSON。<a class="ae kf" href="https://www.packer.io/guides/hcl/from-json-v1" rel="noopener ugc nofollow" target="_blank">这个文档可以帮助你从JSON过渡到HCL </a>。</p><h1 id="ff82" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">Ansible</h1><p id="c8b0" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">Ansible是一个服务器配置工具。想想像木偶，木偶螺栓，厨师，盐等工具…你会在同一个球场。它允许您使用代码配置您的服务器。“封隔器”部分的要点之一是:</p><blockquote class="nc nd ne"><p id="bf0d" class="kg kh nf ki b kj kk kl km kn ko kp kq ng ks kt ku nh kw kx ky ni la lb lc ld im bi translated">根据您提供的说明配置临时实例</p></blockquote><p id="76b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当通过Packer配置您的映像时，您可以使用所谓的置备程序。看一下Packer的文档，您会发现有许多选项:</p><figure class="nk nl nm nn gt ju gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/6d7341d1097adf928ba6d46b6bc4a807.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*rOqaU_23O2rq8eQAaBMmuA.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">包装供应商</figcaption></figure><p id="1843" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们选择使用“Ansible ”,因为我们已经有一个Ansible代码库来配置/维护我们现有的“pet”。如果你已经在使用厨师、木偶、盐等等，我强烈建议你使用相关的供应器。这将允许您重用现有的代码，并利用您已经拥有的技能。</p><p id="71b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">唯一的警告是，我建议避免任何像“Shell”或“Windows Shell”这样的提供程序。虽然编写一个快速的bash脚本或等效程序可能很诱人，但它就是不可伸缩，并且最终会变得太复杂而难以管理。</p><p id="0ab3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">举个例子，我可以通过使用<a class="ae kf" href="https://github.com/dev-sec/ansible-os-hardening" rel="noopener ugc nofollow" target="_blank">这个角色</a>来强化我的图像。想象一下，管理同样的事情需要多少行bash代码？此外，即使您编写了bash来匹配这个角色，您也必须维护所有这些脚本，以确保它们符合最佳实践。使用Ansible角色只需要5分钟，由供应商维护。bash脚本可能需要几个小时，然后增加了额外的开销，因为我必须维护它们。</p><p id="ca89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您将在下面的示例代码中看到的，我们还使用了“Inspec”。这个置备程序允许我们验证我们的映像是否得到了适当的强化。向您的自动化添加验证测试总是一件好事。在这种情况下，你的秘密小组会很感激。</p><h1 id="e32c" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">将（行星）地球化（以适合人类居住）</h1><p id="1540" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">如前所述，我们不打算在映像中存储任何秘密/密码/API密钥。这出于几个原因是可取的，即安全性和可配置性。尽管有了这个需求，我们还是需要一些东西来提供服务器的秘密/配置。因为Terraform负责支撑我们的服务器，所以在构建时使用它来提供必要的信息是有意义的。</p><p id="7cc1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然Terraform在这一过程中发挥了非常重要的作用，但它的作用相当小而且非常明显。当您准备一个实例时，AWS和其他提供者让您能够指定“用户数据”。</p><blockquote class="nc nd ne"><p id="9db0" class="kg kh nf ki b kj kk kl km kn ko kp kq ng ks kt ku nh kw kx ky ni la lb lc ld im bi translated"><a class="ae kf" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html" rel="noopener ugc nofollow" target="_blank">当您在Amazon EC2中启动一个实例时，您可以选择将用户数据传递给该实例，该实例可用于执行常见的自动化配置任务，甚至在实例启动后运行脚本。</a></p></blockquote><p id="91a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用这种机制，我们计划让Terraform做两件简单的事情:</p><ul class=""><li id="4c38" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">创建一个包含服务器所需的所有配置/秘密的bash脚本</li><li id="d65b" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">执行将加载机密并配置服务器的安装脚本。</li></ul><p id="680f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经检查了设计和所有主要组件，我们可以开始了！</p><h1 id="0b1a" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">让我们开始建造吧！</h1><p id="db22" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">首先，我们将创建一个“packer”目录，以及两个名为“base-image”和“assets”的子目录。</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="e8a4" class="nt ma it np b gy nu nv l nw nx">mkdir -p packer/{assets,base-image}</span></pre><p id="3e2f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将来，当我们创建更多图像时，它们将被简单地添加到它们自己的文件夹中。“assets”目录将用于存储依赖项，如我们的Ansible代码。这种结构将使组织我们的文件变得容易，也使通过CI/CD实现自动化变得非常容易。</p><p id="5c6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe ny nz oa np b">base-image</code>目录中，我们将创建两个文件:</p><ul class=""><li id="c5c7" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">variables.pkr.hcl —正如您可以推断的那样，这将存储我们的变量</li><li id="d2cf" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">base.pkr.hcl —这是我们定义如何构建映像的文件。</li></ul><p id="27ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:这些文件的名称对Packer来说无关紧要，但是它们使我们更容易组织我们的内容。</p><h2 id="e4e6" class="nt ma it bd mb ob oc dn mf od oe dp mj kr of og mn kv oh oi mr kz oj ok mv ol bi translated">变量. pkr.hcl</h2><p id="4578" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">在Packer中使用变量很容易。我们的变量文件如下所示:</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="2fe2" class="nt ma it np b gy nu nv l nw nx">variable "ami-description" {<br/>  type = string<br/>  default = "My custom Ubuntu Image"<br/>}</span><span id="ee89" class="nt ma it np b gy om nv l nw nx">variable "aws_access_key" {<br/>  type = string<br/>  default = ""<br/>}</span><span id="062d" class="nt ma it np b gy om nv l nw nx">variable "aws_secret_key" {<br/>  type = string<br/>  default = ""<br/>}</span><span id="4075" class="nt ma it np b gy om nv l nw nx">variable "aws_profile" {<br/>  type = string<br/>  default = "myAWSProfile"<br/>}</span><span id="16bc" class="nt ma it np b gy om nv l nw nx">variable "aws_acct_list" {<br/>  type = list(string)<br/>  default = [<br/>    #acctA<br/>    "000000000000",<br/>    #acctB<br/>    "111111111111"<br/>}</span><span id="86e4" class="nt ma it np b gy om nv l nw nx">variable "destination_regions" {<br/>  type = list(string)<br/>  default = [<br/>    "us-west-1",<br/>    "us-west-2"]<br/>}</span><span id="bdbd" class="nt ma it np b gy om nv l nw nx">variable "fmttime" {<br/>  type = string<br/>  default = "{{isotime \"2006-01-02-150405\"}}"<br/>}</span><span id="677d" class="nt ma it np b gy om nv l nw nx">variable "source_image_name" {<br/>  type = string<br/>  default = "ubuntu/images/hvm-ssd/ubuntu-bionic-18.04-amd64-server-"<br/>}</span><span id="7927" class="nt ma it np b gy om nv l nw nx">variable "ssh_user" {<br/>  type = string<br/>  default = "ubuntu"<br/>}</span></pre><p id="d84a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦定义，变量可以很容易地在Packer中使用格式<code class="fe ny nz oa np b">${varnamehere}</code>引用。在这个特殊的例子中，我想指出几件事:</p><ul class=""><li id="c232" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">我们正在定义一个aws_profile。密钥和访问密钥被有意定义为空白。此配置将使用您的AWS配置文件进行身份验证。如果您想使用访问/密钥，请省略profile变量。</li><li id="1d07" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">“aws_acct_list”变量将用于告诉Packer我们的映像应该共享的所有帐户。</li><li id="c140" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">“destination_regions”列表将告诉Packer我的图像应该出现在哪些区域。</li></ul><p id="04ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如前所述，以上所有内容将允许我们从一个集中的AWS帐户控制我们的图像，同时提供从我们的子帐户的访问。</p><h2 id="9255" class="nt ma it bd mb ob oc dn mf od oe dp mj kr of og mn kv oh oi mr kz oj ok mv ol bi translated">base . pkr . HCl-源部分</h2><p id="0f4e" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">base.pkr.hcl文件将定义我们想要构建的映像以及我们想要如何配置它。</p><p id="f4bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们通过指定一个<code class="fe ny nz oa np b">source</code>部分来开始我们的文件。本节将包含创建临时实例所需的所有信息。这个文件的第二个也是最后一个部分是<code class="fe ny nz oa np b">build</code>部分。这部分代码将让Packer知道应该如何定制临时映像。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="fb6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是完整的源代码部分。如果你能看到整个画面，我们的目标会更容易实现</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="1258" class="nt ma it np b gy nu nv l nw nx">source "amazon-ebs" "example" {<br/>  ami_name = "custom/ubuntu-${var.fmttime}"<br/>  ami_description = "${var.ami-description}"<br/>  ami_users = "${var.aws_acct_list}"<br/>  access_key = "${var.aws_access_key}"<br/>  secret_key = "${var.aws_secret_key}"<br/>  profile = "${var.aws_profile}"<br/>  region = "us-west-1"<br/>  instance_type = "t3.small"<br/>  ami_regions = "${var.destination_regions}"<br/>  associate_public_ip_address = true<br/>  communicator = "ssh"<br/>  ssh_username = "${var.ssh_user}"</span><span id="beff" class="nt ma it np b gy om nv l nw nx">vpc_filter {<br/>    filters = {<br/>      "tag:Name": "myVPC",<br/>      "isDefault": "false"<br/>    }<br/>  }<br/>  subnet_filter {<br/>    filters = {<br/>      "state": "available",<br/>      "tag:Name": "*public*"<br/>    }<br/>    random = true<br/>  }</span><span id="a42b" class="nt ma it np b gy om nv l nw nx">source_ami_filter {<br/>    filters = {<br/>      name = "${var.source_image_name}*"<br/>      virtualization-type = "hvm"<br/>      root-device-type = "ebs"<br/>    }<br/>    owners = [<br/>      "099720109477"]<br/>    most_recent = true<br/>  }</span><span id="5c8d" class="nt ma it np b gy om nv l nw nx">run_tags = {<br/>    OS_Version = "Ubuntu"<br/>  }</span><span id="eb5d" class="nt ma it np b gy om nv l nw nx">tags = {<br/>    OS_Version = "Ubuntu"<br/>    Name = "custom/ubuntu-${var.fmttime}"<br/>  }</span><span id="0a94" class="nt ma it np b gy om nv l nw nx">}</span></pre><p id="7d7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数这些设置都是不言自明的。我们正在为图像命名、提供描述、定义标签等。图像名称将包含时间戳，看起来类似于<code class="fe ny nz oa np b">custom/ubuntu-2020-01-20-185613</code>。这种命名约定将确保所有图像都是唯一的，并使它们可排序。</p><p id="9e0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该扩展一些设置:</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="ca82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ny nz oa np b">ami_users</code>用于告诉Packer哪些AWS帐户应该可以访问您的自定义映像。这与我们之前定义的<code class="fe ny nz oa np b">aws_acct_list</code>变量有关。</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="e280" class="nt ma it np b gy nu nv l nw nx">variable "aws_acct_list" {<br/>  type = list(string)<br/>  default = [<br/>    #acctA<br/>    "000000000000",<br/>    #acctB<br/>    "111111111111"<br/>}</span></pre><p id="241f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您只有一个AWS帐户，可以忽略此设置。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="64a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ny nz oa np b">aws_regions</code>决定结果AMI应复制到哪个区域。如果只在单个区域中操作，可以省略该变量。即使您在一个地区，我仍然建议您保持这种状态，以便在灾难恢复场景中，您的映像已经准备好并在等待。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="3925" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">VPC和子网过滤器用于确定将在其中创建临时实例的VPC和子网。这些值可以是硬编码的，也可以创建一个过滤器来动态查找它们。如果您在AWS中有一个“默认”VPC，也可以省略这一部分。我们选择使用过滤器，以防我们重新调配我们的VPC:</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="92b4" class="nt ma it np b gy nu nv l nw nx">vpc_filter {<br/>  filters = {<br/>    "tag:Name": "myVPC",<br/>    "isDefault": "false"<br/>  }<br/>}<br/>subnet_filter {<br/>  filters = {<br/>    "state": "available",<br/>    "tag:Name": "*public*"<br/>  }<br/>  random = true<br/>}</span></pre><p id="317c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将为VPC和子网匹配AWS“Name”标记。<strong class="ki iu">注意</strong>:您需要SSH访问临时实例，所以确保您相应地定义了您的VPC/子网。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="fdc1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">源AMI是临时实例启动时使用的映像。我们想确保我们有最新的Ubuntu映像可用，使用source_ami_filter允许我们这样做。</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="a136" class="nt ma it np b gy nu nv l nw nx">source_ami_filter {<br/>  filters = {<br/>    name = "${var.source_image_name}*"<br/>    virtualization-type = "hvm"<br/>    root-device-type = "ebs"<br/>  }<br/>  owners = [<br/>    "099720109477"]<br/>  most_recent = true<br/>}</span></pre><p id="f390" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们正在寻找一个以<code class="fe ny nz oa np b">ubuntu/images/hvm-ssd/ubuntu-bionic-18.04-amd64-server-</code>开头的图像，我们想要最新的图像，并且这个图像必须来自Ubuntu的AWS帐户(account #: <code class="fe ny nz oa np b">099720109477</code>)。</p><p id="6bd0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用这种方法，任何时候Ubuntu发布一个新的映像，我们的构建过程都会自动使用它。</p><h2 id="d889" class="nt ma it bd mb ob oc dn mf od oe dp mj kr of og mn kv oh oi mr kz oj ok mv ol bi translated">base . pkr . HCl-构建部分</h2><p id="018d" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">一旦使用来自<code class="fe ny nz oa np b">source</code>部分的信息构建了临时实例，打包程序将使用<code class="fe ny nz oa np b">build</code>部分提供的步骤配置实例。</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="1a59" class="nt ma it np b gy nu nv l nw nx">build {<br/>  sources = [<br/>    "source.amazon-ebs.example"<br/>  ]</span><span id="0a07" class="nt ma it np b gy om nv l nw nx">provisioner "ansible" {<br/>    user = "${var.ssh_user}"<br/>    playbook_file = "../assets/ansible/provision-base-server.yml"<br/>    extra_arguments = [ "--extra-vars", "os_ignore_users: [\"${var.ssh_user}\"] os_filesystem_whitelist: [\"squashfs\"]" ]<br/>  }</span><span id="fbd8" class="nt ma it np b gy om nv l nw nx">//  provisioner "inspec" {<br/>//    inspec_env_vars = [ "CHEF_LICENSE=accept"]<br/>//    profile = "https://github.com/dev-sec/linux-baseline"<br/>//  }<br/>}</span></pre><p id="7f4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们的大部分配置来自Ansible，所以我们的构建部分非常简单。我们告诉Packer启动我们的Ansible剧本。我还包括了Inspec provisioner的代码以供参考，但没有对它进行注释。提醒一下，Inspec将验证您的映像是否已经过加固。这与我们用来加固服务器的<a class="ae kf" href="https://github.com/dev-sec/ansible-os-hardening" rel="noopener ugc nofollow" target="_blank"> ansible-role </a>协同工作。我们把它注释掉了，因为我们的自定义设置导致普通验证失败，所以它将在未来的迭代中被调整。</p><p id="0795" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是你在打包机端需要的全部。</p><h1 id="beb7" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">Ansible</h1><p id="6d30" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">如前所述，Ansible允许您以自动化的方式配置服务器。我不会过多地进入这一部分，因为自定义图像根据其定义必须适合您的用例。我确实想强调几个重要的模式，并向您介绍我的方法，您可以从它开始。Packer的剧本大概是这样的:</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="ca8b" class="nt ma it np b gy nu nv l nw nx">- hosts: all<br/>  become: yes<br/>  become_user: root<br/>  become_method: sudo</span><span id="40c8" class="nt ma it np b gy om nv l nw nx">roles:<br/>    - { role: update-pkgs, tags: ["updatepkgs"] }<br/>    - { role: install-monitoring, tags: ["monitoring"] }<br/>    - { role: aws-inspector, tags: ["inspector"] }<br/>    - { role: install-secops-tool, tags: ["secops"] }<br/>    - { role: dev-sec.os-hardening, tags: ["os-hardening"]}<br/>    - { role: haveged, tags: ["haveged"] }<br/>    - { role: post-provisioner, tags: ["post"] }</span></pre><p id="aa05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们正在更新服务器上的包，安装监控/安全工具，强化映像，并安装“haveged”来在服务器上生成熵(也是一件安全的事情)。</p><p id="5dcb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你不熟悉Ansible或者想知道我在这些角色中做什么，这里有一个例子。</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="c128" class="nt ma it np b gy nu nv l nw nx">---<br/>- name: Ubuntu | Upgrade all current packages<br/>  apt:<br/>    update_cache: true<br/>    upgrade: dist<br/>    allow_unauthenticated: true<br/>  when: ansible_os_family in ['Debian', 'Ubuntu']</span><span id="2edd" class="nt ma it np b gy om nv l nw nx">- name: Ubuntu | Install Unattended-upgrades<br/>  apt:<br/>    update_cache: true<br/>    name: unattended-upgrades<br/>    state: present<br/>  when: ansible_os_family in ['Debian', 'Ubuntu']</span><span id="1969" class="nt ma it np b gy om nv l nw nx">- name: Ubuntu | Configure Unattended-upgrades<br/>  copy:<br/>    src: 50unattended-upgrades.conf<br/>    dest: /etc/apt/apt.conf.d/50unattended-upgrades<br/>    owner: root<br/>    group: root<br/>    mode: 0644<br/>  when: ansible_os_family in ['Debian', 'Ubuntu']</span><span id="e8d9" class="nt ma it np b gy om nv l nw nx">- name: Ubuntu | Configure Unattended-upgrades Timing<br/>  copy:<br/>    src: 20auto-upgrades.conf<br/>    dest: /etc/apt/apt.conf.d/20auto-upgrades<br/>    owner: root<br/>    group: root<br/>    mode: 0644<br/>  when: ansible_os_family in ['Debian', 'Ubuntu']</span></pre><p id="80a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此示例来自更新包角色。它本质上使用apt-get来确保所有的包都是最新的。然后，我们还会安装和配置“无人值守升级”,这样服务器就会定期自动更新。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="e7a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Ansible中，我主要想关注的是“后置备者”角色。如前所述，我们不想在这些图像上存储任何敏感信息。后供应器是一种允许Terraform在构建时注入秘密并引导我们的服务器的机制。</p><p id="7b58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当创建这个角色时，我们不想将地形与我们的图像紧密结合。这意味着Terraform不必知道配置image Y所需的20个脚本，或者配置image X所需的10个脚本，相反，Terraform只需启动一个脚本，其余的将自动发生。</p><p id="6f94" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个脚本就是我们的<code class="fe ny nz oa np b">install.sh</code>:</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="a942" class="nt ma it np b gy nu nv l nw nx"><strong class="np iu">#!/usr/bin/env bash</strong></span><span id="d0f6" class="nt ma it np b gy om nv l nw nx">for f in /opt/custom/postbuild-scripts/*<br/>do<br/>  if [ ! -d "$f" ]; then<br/>   echo "Executing - $f"<br/>    ${f}<br/>  fi<br/>done</span></pre><p id="dd70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，该脚本非常简单，它将遍历<code class="fe ny nz oa np b">/opt/custom/postbuild-scripts/*</code>目录中的所有脚本并执行它们。如果我们愿意，我们还可以在这个脚本中添加额外的检查/逻辑/工具(这是拥有集中式脚本的另一个好处)。</p><p id="e7c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">发布置备程序负责将安装和发布置备脚本复制到映像中。这种方法的美妙之处在于，当您从基本映像构建新映像时，您可以向该目录添加额外的脚本。也许你的基础映像有5个脚本，然后你的堡垒映像又增加了5个。Terraform只执行单个脚本，并不关心是否有10个、20个或1000个脚本。</p><p id="8de6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">postbuild-scripts目录中的脚本也相当简单，因为Ansible已经做了大量的工作。</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="5760" class="nt ma it np b gy nu nv l nw nx"><strong class="np iu">#!/usr/bin/env bash<br/></strong>set -euo pipefail<br/>source /opt/custom/vars.sh</span><span id="547b" class="nt ma it np b gy om nv l nw nx">sed -i "s/ENTERLICENSEKEY/${monitoring_license_key}/" /etc/monitoring.yml</span><span id="2b59" class="nt ma it np b gy om nv l nw nx">systemctl restart monitoring-agent</span></pre><p id="9381" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们所有的脚本都来源于一个<code class="fe ny nz oa np b">vars.sh</code>脚本，它包含了配置服务器所需的所有信息。该脚本由Terraform在运行<code class="fe ny nz oa np b">install.sh</code>之前创建。我们将很快介绍该文件是如何创建的。</p><h2 id="ac0f" class="nt ma it bd mb ob oc dn mf od oe dp mj kr of og mn kv oh oi mr kz oj ok mv ol bi translated">建立形象</h2><p id="e874" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">有了Ansible和Packer，您就可以正式构建您的第一个映像了！这部分很简单。从基本映像目录中，您可以运行<code class="fe ny nz oa np b">packer build .</code>。构建过程需要一些时间来完成它的工作。至少你可以期待10-15分钟，它可能会更长，取决于你在你的服务器上做什么。</p><p id="f745" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您正式拥有了自定义图像！</p><h2 id="0fd7" class="nt ma it bd mb ob oc dn mf od oe dp mj kr of og mn kv oh oi mr kz oj ok mv ol bi translated">将（行星）地球化（以适合人类居住）</h2><p id="5912" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">我们已经完成了99%,现在我们只需要用我们的新映像启动和引导一个实例。</p><p id="ffab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到现在为止，你应该已经意识到，如果可以避免的话，我不喜欢硬编码。Terraform的第一步是创建一个数据资源，它将为我查找AMI ID。</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="02ef" class="nt ma it np b gy nu nv l nw nx">data "aws_ami" "base_ami" {<br/>  most_recent      = true<br/>  owners           = ["111111111111"]</span><span id="27d9" class="nt ma it np b gy om nv l nw nx">filter {<br/>    name   = "name"<br/>    values = [var.base_image_name]<br/>  }<br/>}</span></pre><p id="26bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ny nz oa np b">owners</code>字段应该用您的图片所在的AWS账号进行更新。接下来，我们创建一个用户模板，传递我们需要的秘密。</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="4906" class="nt ma it np b gy nu nv l nw nx">data "template_file" "base_user_data" {<br/>  template = file("${path.module}/templates/base.userdata.sh.tpl")<br/>  vars = {<br/>    tool1_base_dn          = var.tool1_base_dn<br/>    tool1_bind_user        = var.tool1_bind_user<br/>    tool1_bind_passwd      = var.tool1_bind_passwd<br/>    tool1_api_key          = var.tool1_api_key<br/>    hostname               = "${var.cluster_name}-bastion"<br/>    monitoring_license_key = var.monitoring_key<br/>  }<br/>}</span></pre><p id="fcef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面提到的模板是我们创建<code class="fe ny nz oa np b">vars.sh</code>和开始<code class="fe ny nz oa np b">install.sh</code>的地方。</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="3dda" class="nt ma it np b gy nu nv l nw nx">#!/bin/bash<br/>set -euo pipefail</span><span id="91d1" class="nt ma it np b gy om nv l nw nx"># pull all the tf passed in vars and put into a file for other scripts to source<br/>cat &gt; /opt/custom/vars.sh &lt;&lt;'EOF'<br/>#!/bin/bash<br/>export tool1_base_dn="${tool1_base_dn}"<br/>export tool1_bind_user="${tool1_bind_user}"<br/>export tool1_bind_passwd="${tool1_bind_passwd}"<br/>export tool1_api_key="${tool1_api_key}"<br/>export hostname="${hostname}"<br/>export monitoring_license_key="${monitoring_license_key}"<br/>EOF</span><span id="9a4f" class="nt ma it np b gy om nv l nw nx">/opt/custom/install.sh</span></pre><p id="6984" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，在定义实例时，传入user_data，就大功告成了！</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="b85a" class="nt ma it np b gy nu nv l nw nx">resource "aws_instance" "example" {<br/>  ami           =  data.aws_ami.base_ami.id<br/>  instance_type = "t3.small"<br/>  key_name      = var.base_ssh_key<br/>  subnet_id     = aws_subnet.public_a.id<br/>  vpc_security_group_ids = [<br/>  aws_security_group.example.id]</span><span id="6bf2" class="nt ma it np b gy om nv l nw nx">user_data =  base64encode(data.template_file.base_user_data.rendered)<br/>}</span></pre><h1 id="fe40" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">结论</h1><p id="121b" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">如前所述，使用自定义图像有很多好处，但前提是您能够自动化并充分利用它们。如果你经历了整个过程，你应该有一个坚实的起点来开始你的旅程。接下来的步骤是将它添加到您的CI/CD中，并开始创建使用基本映像作为其源的其他映像。事情正在好转，前途无量！</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="c979" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了获得无限的故事，你还可以考虑注册<a class="ae kf" href="https://blog.rhel.solutions/membership" rel="noopener ugc nofollow" target="_blank"><em class="nf"/></a><em class="nf">成为中等会员，只需5美元。如果您使用</em> <a class="ae kf" href="https://blog.rhel.solutions/membership" rel="noopener ugc nofollow" target="_blank"> <em class="nf">我的链接</em> </a> <em class="nf">注册，我会收到一小笔佣金(无需您额外付费)。</em></p></div></div>    
</body>
</html>