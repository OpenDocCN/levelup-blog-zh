<html>
<head>
<title>Next.js + serverless personal webpage in a couple of hours — Pull Medium posts with Serverless Function (Part 6)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Next.js +几个小时后的无服务器个人网页——用无服务器功能拉中型帖子(六)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/next-js-serverless-personal-webpage-in-a-couple-of-hours-pull-medium-posts-w-serverless-func-6-65855599509d?source=collection_archive---------28-----------------------#2021-02-22">https://levelup.gitconnected.com/next-js-serverless-personal-webpage-in-a-couple-of-hours-pull-medium-posts-w-serverless-func-6-65855599509d?source=collection_archive---------28-----------------------#2021-02-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e935" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想实现的是，当用户点击我网页上的“博客”按钮时，提供更无缝的体验。我想在我的网页上显示我最近在Medium上发表的文章列表，并让它们自动更新。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/f2b4b7cab0f5b4fc28a461f0ba71bd32.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*lmUZqTDqsDhkQOhK1antgw.png"/></div></figure><p id="b62d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我为记录我在一个晚上建立个人网页的旅程而写的系列文章的第6部分:</p><p id="f318" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kt" href="https://jeremy-chan.medium.com/creating-a-personal-webpage-from-scratch-in-2021-development-environment-part-1-b0b45396da00" rel="noopener">第1部分:开发环境设置</a> <br/> <a class="ae kt" href="https://jeremy-chan.medium.com/creating-a-personal-webpage-from-scratch-in-a-couple-of-hours-getting-a-domain-name-and-email-73a462a4c183" rel="noopener">第2部分:购买自己的域名并设置邮件转发<br/> </a> <a class="ae kt" href="https://jeremy-chan.medium.com/next-js-serverless-personal-webpage-in-a-couple-of-hours-bootstrapping-the-app-with-next-js-b87d468f9cdc" rel="noopener">第3部分:用Next.js <br/> </a> <a class="ae kt" href="https://jeremy-chan.medium.com/next-js-serverless-personal-webpage-in-a-couple-of-hours-deploying-to-production-with-vercel-b35fe5daeaa7" rel="noopener">引导应用程序第4部分:用Vercel </a> <a class="ae kt" href="https://jeremy-chan.medium.com/next-js-serverless-personal-webpage-in-a-couple-of-hours-deploying-to-production-with-vercel-b35fe5daeaa7" rel="noopener"> <br/> </a> <a class="ae kt" href="https://jeremy-chan.medium.com/next-js-serverless-personal-webpage-in-a-couple-of-hours-create-contact-form-with-formspree-5-cb6419f86917" rel="noopener">部署到生产第5部分:将您的联系人表单与Formspree <br/> </a> <a class="ae kt" href="https://jeremy-chan.medium.com/next-js-serverless-personal-webpage-in-a-couple-of-hours-pull-medium-posts-w-serverless-func-6-65855599509d" rel="noopener">集成第6部分:用无服务器功能从媒体中提取博客文章</a>(📍你在这里)</p><h1 id="bfbb" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">从媒体的RSS源提取数据(120分钟)</strong></h1><p id="d1e5" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">一种自然的方法是从媒体中提取数据，即使用他们的REST API。经过一些研究，我得出结论，Medium的API只提供创建发布的接口，不提供获取发布的接口。你可能会问为什么，但我猜一个显而易见的答案是，他们希望读者从他们的平台上阅读，而不是消费第三方服务的内容。</p><p id="69c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，Medium确实提供了一个RSS提要，其中包含作者在https://medium.com/feed/@author-handle<a class="ae kt" href="https://medium.com/feed/@author-handle" rel="noopener"><em class="lx"/></a><em class="lx">发表的文章的摘录。</em>这可以工作——我们只需要解析RSS提要(XML格式)并用JavaScript格式化数据，对吗？。</p><p id="b5f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> CORS问题</strong></p><p id="6116" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能想从客户端使用JavaScript发出一个XHR请求，从Medium的RSS端点检索数据。不幸的是，这将失败，因为来自中等RSS端点的响应不包括<code class="fe ly lz ma mb b">Access-Control-Allow-Origin</code>头。所有现代的浏览器都尊重CORS政策，拒绝让JavaScript代码访问这些响应。</p><p id="3bc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">有什么解决办法吗？</strong></p><p id="6efa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一种选择是使用免费/公开的CORS代理<a class="ae kt" href="https://nordicapis.com/10-free-to-use-cors-proxies/" rel="noopener ugc nofollow" target="_blank">作为中间人，并将<code class="fe ly lz ma mb b">Access-Control-Allow-Origin</code>添加到响应中。这种方法对代理提供商非常信任，你的网页现在也依赖于它的可用性。cors-anywhere曾经是Heroku上的一个开放代理。</a><a class="ae kt" href="https://github.com/Rob--W/cors-anywhere/issues/301" rel="noopener ugc nofollow" target="_blank">从2021年1月起不再是这种情况</a>。</p><p id="e5d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这给我们带来了两个选择:</p><ol class=""><li id="186a" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated">运行我们自己的CORS代理</li><li id="4bca" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">使用无服务器功能设置API网关</li></ol><p id="f1a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在基础设施和成本方面，运行我们自己的CORS代理更加复杂。我选择第二个选项。对于无服务器功能，有几种选择，AWS lambda是最流行的。然而，由于我们的部署已经存在于Vercel生态系统中，使用Vercel提供的无服务器功能也是有意义的。</p><p id="f0d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">让我们从hello world功能</strong>开始</p><p id="4497" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你用<code class="fe ly lz ma mb b">create-next-app</code>创建你的应用时，它已经在项目根目录的<code class="fe ly lz ma mb b">/api</code>文件夹中给了你一个hello world函数的例子。默认情况下，<code class="fe ly lz ma mb b">/api</code>下的任何函数都由Vercel自动托管并通过HTTP端点公开。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="277c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导航到<a class="ae kt" href="https://yourdomain.com/api/hello," rel="noopener ugc nofollow" target="_blank">https://yourdomain.com/api/hello,</a>你应该会看到JSON的响应。</p><p id="fa99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Vercel上，导航到您的部署并转到Functions。它显示无服务器功能的实时日志。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/5259f7acaed860f281aedb5cb7c9eefa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JJi3DHqzEbdGXpZkmu6TXw.png"/></div></div></figure><p id="7ce5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">本地测试您的功能</strong></p><p id="573d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然在Vercel上部署和测试很快。如果我们在开发时能够在本地测试无服务器功能，速度会更快。Vercel CLI通过在Vercel上复制生产环境来提供此功能。通过运行以下命令安装CLI:</p><pre class="km kn ko kp gt mx mb my mz aw na bi"><span id="e833" class="nb kv iq mb b gy nc nd l ne nf">npm i vercel</span></pre><p id="1e12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，通过以下方式启动本地开发服务器，而不是<code class="fe ly lz ma mb b">npm run dev</code>:</p><pre class="km kn ko kp gt mx mb my mz aw na bi"><span id="c6cc" class="nb kv iq mb b gy nc nd l ne nf">npx vercel dev</span></pre><p id="b103" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它还使用<code class="fe ly lz ma mb b">next dev</code>来监视项目目录中的变化，但是您现在也可以通过转到<a class="ae kt" href="http://localhost:3001/api/hello" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API/hello</a>来调用您的函数</p><p id="428b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">在我们的函数中转储媒体RSS提要</strong></p><p id="20e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们通过创建一个为我的账户<a class="ae kt" href="https://medium.com/feed/@jeremy-chan" rel="noopener">https://medium.com/feed/@jeremy-chan</a>转储整个RSS提要的函数来做一个概念验证</p><p id="3674" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要一些http客户端来触发来自无服务器功能的请求。我们将使用<code class="fe ly lz ma mb b">axios</code>:</p><pre class="km kn ko kp gt mx mb my mz aw na bi"><span id="1973" class="nb kv iq mb b gy nc nd l ne nf">npm i --save axios</span></pre><p id="c6b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Vercel将自动在<code class="fe ly lz ma mb b">package.json</code>中为您的无服务器功能安装依赖项。</p><p id="8d83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们编写一些代码来转储来自RSS提要的数据:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="9e21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导航到<a class="ae kt" href="http://localhost:3001/api/medium" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API/medium</a>，您应该看到XML的内容被转储到JSON响应的<code class="fe ly lz ma mb b">text</code>字段中。</p><p id="2087" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尝试在Vercel上部署它，并观看它的实况。</p><p id="5dfe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">将XML转换成JSON </strong></p><p id="3d02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用xml2js包将XML响应转换成JSON。</p><pre class="km kn ko kp gt mx mb my mz aw na bi"><span id="d54c" class="nb kv iq mb b gy nc nd l ne nf">npm i --save xml2js</span></pre><p id="9d50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">修改上面的代码，将XML转换为JSON，并在响应中返回。我们还从转换后的JSON中有选择地提取我们需要的信息，以保持我们的响应简洁明了。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="0ad6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再次点击您的API，您应该会看到RSS提要被转换成JSON格式，如下所示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="1af6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">显示网页内容</strong></p><p id="3288" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用同一个域名下的API代理中等RSS XML并返回一个不错的JSON，我们只需要将这些片段粘在一起，并使用API响应在我们的UI中呈现“Blog”组件。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="60dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，我们在组件的<code class="fe ly lz ma mb b">useEffect</code>函数中调用API。我们传递一个空数组<code class="fe ly lz ma mb b">[]</code>作为函数的依赖，所以<code class="fe ly lz ma mb b">useEffect</code>只在组件被渲染时运行一次。我们将从API获取的帖子保存到一个本地状态，并将其呈现到一个列表<code class="fe ly lz ma mb b">&lt;div&gt;</code>中。</p><p id="ba96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终结果是这样的。有了无服务器功能，无论何时发布新帖子，网页都会保持同步。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/d164c01c6676f800ca4835154b0276ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*osrUiU9M9lHemTOQBEWQ6Q.png"/></div></figure><p id="b9e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">结论</strong></p><p id="4be1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个系列到此结束。我对自己在一个晚上学到的东西和取得的成就感到满意。我还对Next.js和Vercel为部署静态网页提供的愉快的开发人员体验印象深刻。</p><p id="6f96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总花费时间:~4小时<br/>总费用:10 <br/>卡顿次数:0</p><p id="b0a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kt" href="https://jeremy-chan.medium.com/creating-a-personal-webpage-from-scratch-in-2021-development-environment-part-1-b0b45396da00" rel="noopener">第1部分:开发环境设置</a> <br/> <a class="ae kt" href="https://jeremy-chan.medium.com/creating-a-personal-webpage-from-scratch-in-a-couple-of-hours-getting-a-domain-name-and-email-73a462a4c183" rel="noopener">第2部分:购买自己的域名并设置邮件转发<br/> </a> <a class="ae kt" href="https://jeremy-chan.medium.com/next-js-serverless-personal-webpage-in-a-couple-of-hours-bootstrapping-the-app-with-next-js-b87d468f9cdc" rel="noopener">第3部分:用Next.js <br/> </a> <a class="ae kt" href="https://jeremy-chan.medium.com/next-js-serverless-personal-webpage-in-a-couple-of-hours-deploying-to-production-with-vercel-b35fe5daeaa7" rel="noopener">引导应用程序第4部分:用Vercel </a> <br/> <a class="ae kt" href="https://jeremy-chan.medium.com/next-js-serverless-personal-webpage-in-a-couple-of-hours-create-contact-form-with-formspree-5-cb6419f86917" rel="noopener">部署到产品第5部分:将您的联系人表单与Formspree <br/> </a> <a class="ae kt" href="https://jeremy-chan.medium.com/next-js-serverless-personal-webpage-in-a-couple-of-hours-pull-medium-posts-w-serverless-func-6-65855599509d" rel="noopener">集成第6部分:用无服务器功能从媒体中提取博客文章</a></p></div></div>    
</body>
</html>