# 介绍 Gretchen:在 TypeScript 中实现 Fetch

> 原文：<https://levelup.gitconnected.com/introducing-gretchen-making-fetch-happen-in-typescript-87ab0bd66027>

![](img/31abaa0b0f920b25319618731b58e5ad.png)

> 这篇文章最初发表在我们的工程博客上。另外，我们正在招聘。

我们在 Truework 使用 TypeScript，并且非常依赖前端(React)和后端(Django)之间的异步通信。`[gretchen](https://github.com/truework/gretchen)`诞生于对现代`fetch`抽象的需求，这种抽象与打字稿配合得很好。与大多数代码一样，有几种方法可以做到这一点，并且许多现有的解决方案很可能已经进行了改进，以解决我们现在和未来的用例。然而，改造对我们来说就像是一个不完美且复杂的解决方案，解决了一个相当简单的问题:以类型安全的方式使用`fetch`。

我们还需要解决现代 web 应用程序中的其他一些常见问题:

## 🔨带提取的奇偶校验

`fetch`应用广泛，大部分 dev 都很熟悉。我们在现有的代码库中非常依赖它，所以我们希望我们的解决方案保留大部分相同的人体工程学，以实现向后兼容性和熟悉性。

## 👷‍♀️弹性

我们很早就知道，我们的解决方案需要能够适应网络错误和从遗留 API 端点返回的不一致响应等情况。`gretchen`通过超时处理、可配置的重试逻辑和错误规范化内置了这些问题的解决方案。

## ⚙️浏览器支持

许多用户仍然依赖 IE11 进行日常工作。我们没有像一些库建议的那样移植另一个现有的解决方案，而是希望从一开始就构建一个考虑到旧浏览器的解决方案。

# 走向类型安全提取

大多数现代请求抽象都假设不成功(non `2xx`或`3xx`)响应是异常，应该抛出异常。因此，大多数文档会使用`async/await`语法给出涉及`Promise.catch`或`try/catch`的例子。

然而，抛出的异常很难安全地类型化，并且在许多不成功的情况下，我们通常已经知道我们的错误将会是什么形状。

第一个最常见的选择是返回可以在其上进行断言的类型化数据结构，从而允许 TypeScript 编译器理解我们正在处理什么。

这很好，但是它需要一些额外的样板文件和所有可能的错误类型的内部知识。在 Truework，我们致力于错误响应形状的标准化，因此在几乎所有情况下，我们都知道我们将得到一个`SomeError`类型，并且不想每次都检查它。

第二个最常见的选项很简单:**不要抛出异常。**

这实际上是默认情况下`fetch`的工作方式，不抛出错误也能很好地处理 TypeScript。对于给定的端点，我们希望能够概述我们对成功(`2xx`)和错误(`>= 400`)响应的期望。如果我们不抛出异常，这个断言可以被抽象出来并自动完成。

这实际上是函数式语言中的一种常见模式，通常使用`Either`类型。在 TypeScript 中，这被称为*区分联合*。我们实际上实现了自己的版本`Either`一段时间，并取得了成功。它看起来有点像这样。

虽然我们喜欢这种模式的稳定性，但对于新人来说，它仍然引入了我们认为可以简化的新范式。我们意识到我们可以提炼出一个更简单的模式，在没有异常的情况下仍然保持类型安全。

我们使用另一种常见的模式(类似于 Go 错误处理)而不是返回一个带有方法的对象来检查被区分的并集的类型，并且简单地将并集的两半作为单独的属性返回:

# 格雷奇是新来的

使用`gretchen`看起来很像使用原生`fetch`。而不是像这样:

你可以这样做:

非`GET`请求也应该看起来很熟悉:

在内部，`gretchen`处理`fetch`通常需要的大部分样板文件。对我们来说，它被证明是满足我们需求的适量抽象。我们获得了最大的灵活性以及一些细微之处，例如:

## 👉配置 JSON 主体

`gretchen`当然支持一个`body`属性，但是如果你正在发送 JSON，它通过`json`属性提供一个简写，如上所示。这将字符串化您传递的对象，并配置用于发送 JSON 的`Content-Type`头。

## 👉自动重试一些失败的请求

请求经常由于网络问题或服务器负载等原因而失败。默认情况下，`gretchen`将重试两次返回`408`、`413`或`429`的`GET`请求。您可以使用 options 对象配置重试次数，以及触发重试的请求方法和状态代码。如果你的服务器返回一个`Retry-After`头，`gretchen`也会考虑这个延迟。

## 👉处理请求超时

默认情况下，`gretchen`会自动将一个请求超时 10 秒，如果它满足您指定的`retry`标准，就会重试。你也可以配置超时，比如说，允许上传一个大文件。

## 👉解析响应正文

`gretchen`在所有体接口方法之上提供一个接口:`arrayBuffer`、`blob`、`formData`、`json`和`text`。例如，代替这个:

您可以这样做:

## 👉捕捉异常

`gretchen`不为失败的 HTTP 请求抛出异常，但也不会为其他常见的 API 问题抛出异常，比如端点返回无效的 JSON。在这样的边缘情况下，`gretchen`将保留成功请求的状态，但是用发生的解析异常填充`error`属性。

## 👉提供全局可配置性

除了传递请求级别选项覆盖之外，`gretchen`还导出了一个`create`工厂，您可以在其中提供默认选项，如头文件。这也是利用`gretchen`的*钩子*概念的好地方，钩子在请求生命周期的不同部分触发。这些使得为应用程序中的每个请求提供错误记录和调试代码变得容易。

# 格雷琴+打字稿= 🥰

在 TypeScript 项目中键入响应和错误对象很简单，只需告诉`gretch`您所期望的。

因为`gretchen`返回一个`error`或`data`，所以您需要做一个检查来提示 TypeScript 编译器您正在使用哪个对象:

键入错误响应同样简单，只需将错误类型作为第二个类型参数传递:

总的来说，用法如下:

# 包扎

已经有很多很棒的`fetch`实现了，所以请允许我用这个来总结这篇文章:`gretchen`对我们有用，也可能对你有用。它为最大的灵活性提供了最小的抽象，同时实现了其弹性和浏览器支持的目标。但是你应该使用你觉得舒服的或者最适合你的项目的东西。

`gretchen`也处于早期阶段。我们正在 Truework 的生产中使用它——大约每月 600 万次请求——但是随着它的成熟，有些事情可能会改变。

如果你想试用或投稿，请访问我们的 [Github 页面](https://github.com/truework/gretchen)。我们希望收到您的来信:)

**附:我们正在招聘！查看我们的[职业页面](https://www.truework.com/careers/)。**