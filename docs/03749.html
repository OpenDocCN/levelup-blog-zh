<html>
<head>
<title>JavaScript Best Practices — Generators and Rest/Spread Spacing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—生成器和静止/展开间距</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-generators-and-rest-spread-spacing-c004c6b0f593?source=collection_archive---------15-----------------------#2020-05-25">https://levelup.gitconnected.com/javascript-best-practices-generators-and-rest-spread-spacing-c004c6b0f593?source=collection_archive---------15-----------------------#2020-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/65027e8daf01bc3baa4c0194cb9511dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j91frl1a-dOOvFp8"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">弗农·雷内尔·森松在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3df2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="b99a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将着眼于防止使用无用的生成器和间隔休息和传播操作。</p><h1 id="1b41" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">总是添加<code class="fe mc md me mf b">yield Statements to G</code>生成器功能</h1><p id="3551" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">生成器函数的要点在于，当调用生成器来创建返回这些值的生成器时，它会顺序返回一系列值。</p><p id="d0c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了返回值，我们必须使用<code class="fe mc md me mf b">yield</code>关键字来返回项目。</p><p id="2b7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们只是在不使用<code class="fe mc md me mf b">yield</code>语句的情况下返回项目，那么我们可以使用一个常规函数来完成。</p><p id="56d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，以下不应该是生成器函数:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="e0a8" class="mt lf it mf b gy mu mv l mw mx">function* foo() {<br/>  return 1;<br/>}</span></pre><p id="9b9f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为要从中获得返回值，我们必须编写以下代码:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="b4d3" class="mt lf it mf b gy mu mv l mw mx">const {<br/>  value: val<br/>} = foo().next();</span></pre><p id="0e42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们调用了<code class="fe mc md me mf b">foo</code>生成器来返回一个生成器，然后我们必须调用<code class="fe mc md me mf b">next</code>来获得返回值。</p><p id="fdd1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">返回的对象有<code class="fe mc md me mf b">value</code>和<code class="fe mc md me mf b">done</code>属性，前者是返回值1，后者是<code class="fe mc md me mf b">true</code>，因为它所做的只是返回生成器函数中的值。</p><p id="9f1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，当我们可以直接用一个常规函数返回值时，这是一个非常迂回的方法。</p><p id="ae81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="d468" class="mt lf it mf b gy mu mv l mw mx">const foo = () =&gt; 1;</span></pre><p id="0b54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建返回1的常规函数。</p><p id="4ad8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果我们要定义一个生成器函数，我们应该确保返回一系列带有<code class="fe mc md me mf b">yield</code>关键字的值。</p><p id="55c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写以下代码来实现这一点:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="6e4c" class="mt lf it mf b gy mu mv l mw mx">function* foo() {<br/>  yield 1;<br/>  yield 2;<br/>}</span></pre><p id="95fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mc md me mf b">yield</code>关键字，我们返回值并暂停生成器。然后当我们再次调用<code class="fe mc md me mf b">next</code>时，我们恢复生成器并返回下一个值。</p><p id="8c11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以通过调用<code class="fe mc md me mf b">foo</code>来创建一个生成器，并如下循环遍历这些值:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="02a2" class="mt lf it mf b gy mu mv l mw mx">for (const f of foo()) {<br/>  console.log(f);<br/>}</span></pre><h1 id="6168" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Rest算子和Spread算子之间的间距及其表达式</h1><p id="fb09" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">rest和spread运算符都用<code class="fe mc md me mf b">...</code>表示。虽然它们由相同的符号表示，但它们的用法不同。</p><p id="70f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">rest运算符用于将被调用的参数中尚未赋值的参数放入数组。</p><p id="a57f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还用于将没有被析构到变量中的数组条目放入数组中。</p><p id="be83" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果rest操作符被用来析构对象，那么没有被析构的对象条目被存储在rest操作符所应用的变量中。</p><p id="243f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">spread操作符用于创建数组和对象的浅表副本，还可以将多个数组和对象合并在一起。</p><p id="3c28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，当spread运算符用于函数的参数时，它可以用于将数组扩展到参数中。</p><p id="6f19" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们都在操作数之前。通常，当操作符是rest或spread操作符时，操作符和操作数之间没有任何空格。</p><p id="97db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们通常编写如下内容:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="3a84" class="mt lf it mf b gy mu mv l mw mx">const a = {<br/>  foo: 1<br/>};<br/>const b = {<br/>  bar: 2<br/>};<br/>const c = {<br/>  baz: 3<br/>};<br/>const merged = {<br/>  ...a,<br/>  ...b,<br/>  ...c<br/>};</span></pre><p id="fdb9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上面的代码中我们可以看到，在spread操作符和<code class="fe mc md me mf b">a</code>之间没有任何空格。同样，我们与物体<code class="fe mc md me mf b">b</code>和<code class="fe mc md me mf b">c</code>有相同的间距。</p><p id="023c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于数组，我们有相同的间距，因此我们编写如下代码:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="a7a7" class="mt lf it mf b gy mu mv l mw mx">const a = [1, 2];<br/>const b = [3, 4, 5];<br/>const merged = [...a, ...b];</span></pre><p id="aa5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们在spread操作符和<code class="fe mc md me mf b">a</code>之间也没有任何空格。<code class="fe mc md me mf b">b</code>也是如此。</p><p id="de5c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在调用一个带有参数数组的函数时使用spread运算符，我们写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="f558" class="mt lf it mf b gy mu mv l mw mx">const add = (a, b) =&gt; a + b;<br/>const sum = add(...[1, 2, 3]);</span></pre><p id="c96f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也没有在操作符和操作数之间添加任何空格。此外，我们没有任何空格在括号内的任何地方。</p><p id="39bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果我们把它和其他参数一起使用，那么我们需要在参数之间留一些间距。例如，我们编写以下内容:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="ec45" class="mt lf it mf b gy mu mv l mw mx">const add = (a, b) =&gt; a + b;<br/>const sum = add(1, ...[2, 3]);</span></pre><p id="a503" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们在逗号之后和spread运算符之前有一个空格字符。</p><p id="6b1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，对于rest操作符，我们编写以下代码。如果我们在一个函数上使用它，那么我们写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="39c1" class="mt lf it mf b gy mu mv l mw mx">const add = (...args) =&gt; args.reduce((a, b) =&gt; a + b, 0);</span></pre><p id="c4ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">括号里没有空格。这与我们使用spread操作符的前一个例子是一致的。</p><p id="12c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果在rest参数之前有其他参数，那么我们需要一些间距。例如，我们可以定义一个函数如下:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="8c7b" class="mt lf it mf b gy mu mv l mw mx">const add = (a, ...args) =&gt; a + args.reduce((a, b) =&gt; a + b, 0);</span></pre><p id="e196" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，逗号后面有一个空格。</p><p id="522a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于析构，我们编写如下代码:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="869c" class="mt lf it mf b gy mu mv l mw mx">const [a, ...b] = [1, 2, 3];<br/>const {<br/>  c,<br/>  ...rest<br/>} = {<br/>  c: 1,<br/>  d: 2,<br/>  e: 3<br/>}</span></pre><p id="bf2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">间距与其他示例一致，除了对象析构，为了清楚起见，我们将每个变量放在它们自己的行上。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/3611966edf50c13ea270078a19a4391c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Djb88E70wZBskZoj"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@lucabravo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢卡·布拉沃</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="defe" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="b52a" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">JavaScript生成器函数中应该有<code class="fe mc md me mf b">yield</code>语句来暂停和恢复返回的生成器。否则，我们应该只定义一个正则函数。</p><p id="facb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">rest和spread运算符相对于其他实体的间距是标准的，一些参数或变量之间有一个空格。如果没有其他参数或变量，则不需要空格。</p><p id="613b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">rest和spread运算符和它的操作数之间肯定没有空格。</p></div></div>    
</body>
</html>