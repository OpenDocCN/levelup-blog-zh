<html>
<head>
<title>Simple API using Flask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Flask的简单API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/simple-api-using-flask-bc1b7486af88?source=collection_archive---------1-----------------------#2020-03-07">https://levelup.gitconnected.com/simple-api-using-flask-bc1b7486af88?source=collection_archive---------1-----------------------#2020-03-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="13ba" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Flask在Python中创建简单API的简单步骤</h2></div><p id="2022" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将了解什么是Rest API，以及如何使用Flask在Python中创建一个简单的API。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/8320f6e6c644e972f32a40f2eca54dcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nvtdCw77Al6LgV8wt_ma6Q.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated"><a class="ae lu" href="https://flask.palletsprojects.com/en/1.1.x/api/" rel="noopener ugc nofollow" target="_blank">https://flask.palletsprojects.com/en/1.1.x/api/</a></figcaption></figure><h2 id="a9fa" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">什么是REST API？</h2><p id="c575" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated"><a class="ae lu" href="https://restfulapi.net/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">休息</strong>代表<strong class="kk iu"> RE </strong>表象<strong class="kk iu"> S </strong>状态<strong class="kk iu"> T </strong>转移</a>，罗伊·菲尔丁于2000年提出的一种建筑风格。<strong class="kk iu">REST中信息的关键抽象是资源</strong>。REST使用这个资源标识符在两个组件之间进行交互。</p><p id="6f11" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">API是一个应用程序接口，它是一组允许程序相互通信的规则。REST也是开发人员创建API时遵循的一组规则。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/2218e2416952cf09f275ff5bd61ddb8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*8KRtTAch9b1XydMZdfBXdw.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">客户端和服务器之间的请求和响应</figcaption></figure><p id="f760" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你在浏览器中输入<a class="ae lu" href="http://www.medium.com" rel="noopener">www.medium.com</a>时，你就是客户端，你的请求将被发送到托管网站的服务器。服务器用包含具有不同文章的网页的响应来响应。来自不同作者的文章可以被认为是资源。</p><p id="452e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">请求包含</strong></p><ul class=""><li id="2b9a" class="mu mv it kk b kl km ko kp kr mw kv mx kz my ld mz na nb nc bi translated"><strong class="kk iu">端点</strong>:API可以用来访问资源的位置。www.medium.com是访问各种主题文章的端点。</li><li id="cd91" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated"><strong class="kk iu">方法</strong>:客户端可以向服务器发送不同的请求。这些方法是GET、PUT、POST、PATCH、DELETE。GET就像一个read。它从各种资源请求数据，PUT和POST请求用于插入或更新资源。</li><li id="febe" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated"><strong class="kk iu">头</strong>:包含客户端可以发送给服务器的信息，也包含客户端将从服务器接受的信息。身份验证、编码细节等信息。标头信息在属性-值对中。</li><li id="a618" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated"><strong class="kk iu"> Body </strong>:包含客户端要发送给服务器的信息。</li></ul><p id="cab5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">响应代码</strong></p><p id="bd3e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">HTTP定义了40种标准状态代码，可以用来传递客户端请求的结果。</p><p id="b279" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">状态代码分为五类</p><ul class=""><li id="ae03" class="mu mv it kk b kl km ko kp kr mw kv mx kz my ld mz na nb nc bi translated"><strong class="kk iu"> 1XX-信息</strong>:客户应该继续他们的请求</li><li id="9fdf" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated"><strong class="kk iu"> 2XX- Success </strong>:表示客户端请求被成功接受。状态代码200表示客户端请求的操作已成功执行。</li><li id="48d2" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated"><strong class="kk iu">3XX-重定向</strong>:表示需要采取进一步的行动。301表示API被分配了一个新的永久URI。</li><li id="9d07" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated"><strong class="kk iu">4XX-客户端错误</strong>:向客户端指示发生了错误。404向客户端指示所请求的资源当前没有找到，但是将来可能可用。</li><li id="d729" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated"><strong class="kk iu"> 5XX —服务器错误</strong>:表示服务器知道请求出错或无法执行请求</li></ul><h2 id="7fb7" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">烧瓶是什么？</h2><p id="715e" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">Flask是一个轻量级web服务器网关接口(WSGI)，它是web应用程序和web服务器之间的接口，允许我们开发Web富应用程序。</p><p id="7193" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">什么是Flask-RESTful？</p><ul class=""><li id="e36f" class="mu mv it kk b kl km ko kp kr mw kv mx kz my ld mz na nb nc bi translated">Flask RESTful是Flask的扩展，增加了对快速构建REST APIs的支持。</li><li id="0699" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated">一个轻量级的抽象，可用于现有的对象关系映射(ORM)/库。</li><li id="7ba5" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated">资源是Flask-RESTful提供的主要构件</li></ul><p id="7ae1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">了解了REST API之后，我们现在将创建一个简单的API，使用POST方法接受一个字符串并将其存储在一个变量中。我们还将实现GET方法。GET方法将向服务器发送一条带有name参数的JSON消息。</p><h2 id="7cdd" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">安装烧瓶</h2><p id="b57e" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">Flask和flask-restful可以使用pip命令安装</p><pre class="lf lg lh li gt ni nj nk nl aw nm bi"><span id="a0af" class="lv lw it nj b gy nn no l np nq"><strong class="nj iu">pip install flask<br/>pip install flask-restful</strong></span></pre><h2 id="6217" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">使用Flask实现API</h2><p id="f9c4" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我们首先需要导入Flask、jsonify和request库，jsonify函数将JSON输出变成一个响应对象。请求库有助于在请求期间跟踪请求级别的数据。</p><pre class="lf lg lh li gt ni nj nk nl aw nm bi"><span id="8411" class="lv lw it nj b gy nn no l np nq"><strong class="nj iu">from flask import Flask, jsonify, request</strong></span></pre><p id="abdc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们通过创建Flask的一个实例来创建一个应用程序对象，我们将一个预定义的变量“__name__”传递给它，该变量被设置为使用它的模块的名称。</p><pre class="lf lg lh li gt ni nj nk nl aw nm bi"><span id="56b9" class="lv lw it nj b gy nn no l np nq"># initialize our Flask application<br/><strong class="nj iu">app= Flask(__name__)</strong></span></pre><p id="d70b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们使用routes为GET和POST请求创建要执行的功能。路由是客户端用来呼叫服务器的URL模式。</p><p id="8b05" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">@app.route decorator告诉我们的app，每当有客户端用POST方法用URL<a class="ae lu" href="http://127.0.0.1:5000/name" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:5000/name</a>调用我们的网站，那么就执行方法setName()。</p><p id="fb58" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在方法setName()中，我们检查调用是否是使用POST方法进行的，然后我们提取在主体中传递的变量“data”中的JSON信息</p><pre class="lf lg lh li gt ni nj nk nl aw nm bi"><span id="66a4" class="lv lw it nj b gy nn no l np nq"><a class="ae lu" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank"><strong class="nj iu">@app</strong></a><strong class="nj iu">.route("/name", methods=["POST"])</strong><br/><strong class="nj iu">def setName():<br/>    if request.method=='POST':<br/>        posted_data = request.get_json()<br/>        data = posted_data['data']<br/>        return jsonify(str("Successfully stored  " + str(data)))</strong></span></pre><p id="166f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当客户端使用URL 127 . 0 . 0 . 1:5000/name发送POST请求时，将执行下面的代码，如下所示。我已经使用了<a class="ae lu" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>来测试代码</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nr"><img src="../Images/24eb23a19194d559c05eb5ffc7b90e26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NP7Skq5NYi0UHyjlInDyZQ.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">对URL的post请求，在请求体中设置数据，并获得状态代码为200的响应</figcaption></figure><p id="60fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们为GET请求编写了另一个方法</p><pre class="lf lg lh li gt ni nj nk nl aw nm bi"><span id="7ae6" class="lv lw it nj b gy nn no l np nq"><a class="ae lu" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank"><strong class="nj iu">@app</strong></a><strong class="nj iu">.route("/message", methods=["GET"])<br/>def message():<br/>    posted_data = request.get_json()<br/>    name = posted_data['name']<br/>    return jsonify(" Hope you are having a good time " +  name + "!!!")</strong></span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi ns"><img src="../Images/051373189f30e2c52ab721940af2e407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xkmle2iTAWsQJ234StEp5g.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">对URL的get请求，在请求体中设置数据，并获得状态代码为200的响应</figcaption></figure><p id="8100" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后在调试模式下运行代码。</p><p id="2b42" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">__name__是我们模块的名称，python将我们模块的名称赋给__main__，因此它运行。<strong class="kk iu"> app.run()运行应用服务器。</strong></p><p id="b11b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果调试模式设置为真，那么我们将看到请求格式错误的错误，如果调试模式没有设置为真，那么我们将只看到一个通用消息“坏网关”</p><pre class="lf lg lh li gt ni nj nk nl aw nm bi"><span id="aad0" class="lv lw it nj b gy nn no l np nq">#  main thread of execution to start the server<br/><strong class="nj iu">if __name__=='__main__':<br/>   app.run(debug=True)</strong></span></pre><p id="15d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将完整的代码保存在test_app.py中，如下所示</p><pre class="lf lg lh li gt ni nj nk nl aw nm bi"><span id="86d5" class="lv lw it nj b gy nn no l np nq"><strong class="nj iu">from flask import Flask, jsonify, request</strong></span><span id="eeed" class="lv lw it nj b gy nt no l np nq"># initialize our Flask application<br/><strong class="nj iu">app= Flask(__name__)</strong></span><span id="dd22" class="lv lw it nj b gy nt no l np nq"><a class="ae lu" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank"><strong class="nj iu">@app</strong></a><strong class="nj iu">.route("/name", methods=["POST"])<br/>def setName():<br/>    if request.method=='POST':<br/>        posted_data = request.get_json()<br/>        data = posted_data['data']<br/>        return jsonify(str("Successfully stored  " + str(data)))</strong></span><span id="e8dc" class="lv lw it nj b gy nt no l np nq"><a class="ae lu" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank"><strong class="nj iu">@app</strong></a><strong class="nj iu">.route("/message", methods=["GET"])<br/>def message():<br/>    posted_data = request.get_json()<br/>    name = posted_data['name']<br/>    return jsonify(" Hope you are having a good time " +  name + "!!!")</strong></span><span id="996f" class="lv lw it nj b gy nt no l np nq">#  main thread of execution to start the server<br/><strong class="nj iu">if __name__=='__main__':<br/>    app.run(debug=True)</strong></span></pre><h2 id="e6c4" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">运行API</h2><p id="c26d" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">要执行代码，请转到命令提示符并输入python test_app.py。该命令将在127.0.0.1和端口5000上启动web服务器</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nu"><img src="../Images/3b2987079fd92691ddf0595455bd1c2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h4Xez1O5cBYvJjuFO29dTQ.png"/></div></div></figure><p id="18e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以进入Postman并输入URL来测试我们的API。</p><p id="3eba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">结论:</strong> Flask是一个轻量级web服务器网关接口(WSGI ),用于创建Web应用程序之间的快速接口</p><h2 id="a450" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">参考资料:</h2><div class="nv nw gp gr nx ny"><a href="https://flask-restful.readthedocs.io/en/latest/" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">Flask-RESTful—Flask-RESTful 0 . 3 . 8文档</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">Flask-RESTful是Flask的扩展，增加了对快速构建REST APIs的支持。这是一个轻量级的…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">flask-restful.readthedocs.io</p></div></div></div></a></div><p id="210e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">【https://flask.palletsprojects.com/en/1.1.x/api/ T4】</p><p id="034b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae lu" href="https://blog.keras.io/building-a-simple-keras-deep-learning-rest-api.html" rel="noopener ugc nofollow" target="_blank">https://blog . keras . io/building-a-simple-keras-deep-learning-rest-API . html</a></p></div></div>    
</body>
</html>