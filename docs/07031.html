<html>
<head>
<title>Mutables in a Set: Python vs Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">集合中的可变元素:Python与Java</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/mutables-in-a-set-python-vs-java-e1293536abe9?source=collection_archive---------22-----------------------#2021-01-19">https://levelup.gitconnected.com/mutables-in-a-set-python-vs-java-e1293536abe9?source=collection_archive---------22-----------------------#2021-01-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2854" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Java中在集合中使用可变变量的副作用以及Python对此加以限制的原因</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0650a680be94586dfe705aebd2a1724f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qZFTNBtnZ4d7ThIdjVKXjg.jpeg"/></div></div></figure><p id="7d57" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Set是Python和Java中都有的内置数据类型，但是这两种语言对set中的元素的处理方式不同。<br/>尽管set的底层实现在两种语言中是相同的，<strong class="kt ir"> <em class="ln"> Java允许你添加可变的对象，比如一个列表到set中，而Python不允许。</em> </strong></p><h1 id="c362" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">Python限制向集合中添加列表</h1><p id="f258" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在python中，当您尝试将整个列表添加到集合中时，编译器会抛出一个错误:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/54d907071ace9daf7204cec70cf85946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wfx4YjaE-ktgFTK6BXKyBQ.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">Python限制向集合中添加列表</figcaption></figure><p id="daf7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Python限制向集合中添加列表，因为<em class="ln">‘list’</em>是一个<em class="ln">不可销毁的类型。</em>为了更好地理解这一点，我们先来谈谈<em class="ln">哈希值</em>和<em class="ln">哈希表</em>。</p><h2 id="96bf" class="mq lp iq bd lq mr ms dn lu mt mu dp ly la mv mw ma le mx my mc li mz na me nb bi translated">散列值</h2><p id="04af" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">哈希是使用哈希函数分配给对象的唯一值。如果两个对象相等，那么它们的散列将是相同的，反之亦然。您可以通过以下方式检查python中任何对象的哈希:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/9f93657e5e39b36e69f02bb2318164b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TL6YspPFfreNVIUIEZoPPQ.png"/></div></div></figure><h2 id="f539" class="mq lp iq bd lq mr ms dn lu mt mu dp ly la mv mw ma le mx my mc li mz na me nb bi translated">哈希表</h2><p id="1bbf" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">哈希表是存储键值对的数据结构。对于任何键-值对，hashtable使用hash函数计算键的<em class="ln">散列，并使用那个<em class="ln">散列值作为存储地址</em>来存储数据。在通过关键字查找数据的过程中，<em class="ln">关键字被散列</em>，并且得到的散列值指示相应数据存储的位置。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/8e07a3c9d360a4d2457a60dfd1ec574c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k98j243sa8mXMFY61Dakpg.jpeg"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">通过计算关键字的哈希值将数据存储在哈希表中</figcaption></figure><p id="9065" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个<strong class="kt ir"> <em class="ln">集合使用一个散列表</em> </strong> <em class="ln"> </em>作为其底层数据结构，并将我们添加到集合中的元素存储为一个键-值对，将<strong class="kt ir"> <em class="ln">键</em>作为集合元素</strong>，将<strong class="kt ir"> <em class="ln">值</em>作为某个空值</strong>。计算添加到集合中的元素键的散列，并将数据存储在哈希表中的这个内存地址。</p><h2 id="06f0" class="mq lp iq bd lq mr ms dn lu mt mu dp ly la mv mw ma le mx my mc li mz na me nb bi translated">只有不可变的对象可以被散列</h2><p id="c057" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">Python有两种数据类型:<em class="ln">可变</em>和<em class="ln">不可变</em>。可变对象可以改变它的内容，而不可变对象不能。</p><blockquote class="ne nf ng"><p id="af94" class="kr ks ln kt b ku kv jr kw kx ky ju kz nh lb lc ld ni lf lg lh nj lj lk ll lm ij bi translated"><strong class="kt ir">可变类型:</strong> <em class="iq">列表、字典、集合、字节数组</em></p><p id="d682" class="kr ks ln kt b ku kv jr kw kx ky ju kz nh lb lc ld ni lf lg lh nj lj lk ll lm ij bi translated"><strong class="kt ir">不可变类型:</strong> <em class="iq"> int，float，complex，string，tuple，冻结集，bytes </em></p></blockquote><p id="f529" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在python中，对象拥有哈希值有一个条件:</p><blockquote class="ne nf ng"><p id="e2e2" class="kr ks ln kt b ku kv jr kw kx ky ju kz nh lb lc ld ni lf lg lh nj lj lk ll lm ij bi translated">对于一个可散列的对象，它必须是不可变的。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/032b9341a6646c4c2d87fe5d98730033.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o0ElT0vMBv7fQXALPTY-1g.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">一个可变的列表不能被散列。</figcaption></figure><p id="7361" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是因为，一旦对象的散列被计算出来，它应该在其整个生命周期中保持不变。但是如果一个对象的值可以改变，也就是说，如果它是<em class="ln">可变的</em>，那么当值改变时，散列也会改变，并且会导致意外的行为。因此，python只允许不可变对象的哈希值。</p><h2 id="1979" class="mq lp iq bd lq mr ms dn lu mt mu dp ly la mv mw ma le mx my mc li mz na me nb bi translated">如果可变对象可以被散列并添加到集合中，会出现什么意外行为？</h2><p id="366d" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">假设我们将一个列表添加到一个集合中，并假设我们可以计算这个可变列表的哈希。下图描述了修改添加到集合中的列表将如何破坏哈希表的实现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/090a7e0d4882e0557dc8e6c9db450329.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1WXNrqZQyWU49lFyZu8rcA.jpeg"/></div></div></figure><p id="f6da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，如果<em class="ln">集合</em>中的值是可变的，那么当对象被修改或更新时，内存位置地址和散列将会不匹配。<strong class="kt ir"> <em class="ln">因此，在python中，只有不可变的对象，如整数、字符串或元组，才可以被散列，并可以用作集合中的元素或字典的键，即使集合或字典本身是可变的。</em> </strong></p><h1 id="672f" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">Java里会发生什么？</h1><p id="b8df" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">尽管Java在内部使用hashmaps来存储HashSet，但核心实现与Python中的基本相同。但是和Python的情况一样，Java <strong class="kt ir">不限制</strong>向集合中添加可变对象，并且<strong class="kt ir">可变对象也可以有一个哈希值</strong>。</p><p id="4690" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，如果您将一个可变对象添加到集合中，并且如果该对象改变了它的状态，那么集合实现可能会导致一些混乱的行为。如果您遍历该集合，该对象将仍然存在，但是如果您使用<strong class="kt ir"> contains() </strong>方法查询该集合，它可能看起来不存在。下面的代码演示了这一点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/87bc47522ed86723f013e2c663f60739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TOW3NLslZZF4pzmfv7rizg.jpeg"/></div></div></figure><p id="5daa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当将一个类的对象添加到一个集合中时，如果您更改该类中任何字段的值，将会产生相同的副作用，这有助于该类的hash code()(在该类使用<em class="ln">身份哈希代码</em>而不是hashCode()的任何重写实现的情况下，不会遇到这种情况)。<strong class="kt ir"> <em class="ln">因此，在Java中，如果修改后的元素对其hashCode()有贡献，那么在修改后移除并重新插入集合中的元素总是更安全的。</em>T19】</strong></p></div></div>    
</body>
</html>