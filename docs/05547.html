<html>
<head>
<title>Learning C++: Overloading the Input and Output Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习C++:重载输入和输出操作符</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-overloading-the-input-and-output-operators-807564b33e62?source=collection_archive---------1-----------------------#2020-09-08">https://levelup.gitconnected.com/learning-c-overloading-the-input-and-output-operators-807564b33e62?source=collection_archive---------1-----------------------#2020-09-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8c73e693f1329286202446ea4362a2bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nrabXSJnDVsrGCv_"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@museumsvictoria?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">维多利亚博物馆</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="0967" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你在设计和实现一个类的时候，你要做的第一件事就是确定将数据放入你的类对象的方法和将数据从你的对象中取出的方法。有时成员函数很适合这种情况，但在其他时候，您可能希望使用输入和输出操作符，就像您对内置数据类型使用的操作符一样。</p><p id="bb5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我将向你展示如何重载输入操作符(<code class="fe le lf lg lh b">&gt;&gt;</code>)和输出操作符(<code class="fe le lf lg lh b">&lt;&lt;</code>)，这样你就可以在你的类对象中使用它们。</p><h1 id="333a" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">关于运算符重载的几点说明</h1><p id="6726" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">C++是少数允许运算符重载的语言之一。重载操作符对类很有用，因为有时候你想用一个操作符来处理一个类对象，而这个操作符不能识别这个对象。这对于所有用户定义的类型(类)都是如此。</p><p id="91d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">举个例子，考虑一个叫做<code class="fe le lf lg lh b">IntData</code>的类。这个类是整数的包装类，包括(假设)一些int类型本身没有的功能。如果我想把两个<code class="fe le lf lg lh b">IntData</code>对象加在一起，在没有操作符重载的情况下，我必须提供一个成员函数来做这件事。下面是一个代码片段示例:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="1406" class="mt lj it lh b gy mu mv l mw mx">IntData d1(1);<br/>IntData d2(2);<br/>IntData d3 = d1.add(d2);</span></pre><p id="93bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我更想做的是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="bb28" class="mt lj it lh b gy mu mv l mw mx">IntData d1(1);<br/>IntData s2(2);<br/>IntData d3 = d1 + d2;</span></pre><p id="dfa6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果没有操作符重载，我无法做到这一点，因为<code class="fe le lf lg lh b">+</code>操作符没有被定义为与我的<code class="fe le lf lg lh b">IntData</code>对象一起工作。另一方面，通过操作符重载，我可以让<code class="fe le lf lg lh b">+</code>操作符识别我的<code class="fe le lf lg lh b">IntData</code>对象并执行结果加法。这使得运算符重载成为许多类定义的重要部分。</p><p id="ef96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也适用于输入和输出等操作。我不能简单地写这个来显示一个<code class="fe le lf lg lh b">IntData</code>对象的内容:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6101" class="mt lj it lh b gy mu mv l mw mx">cout &lt;&lt; d1 &lt;&lt; endl;</span></pre><p id="e7ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">操作符不知道我的类定义。我也不能使用输入操作符将数据放入<code class="fe le lf lg lh b">IntData</code>对象:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="79a5" class="mt lj it lh b gy mu mv l mw mx">cin &gt;&gt; d2;</span></pre><p id="68bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了让这些操作能够工作，以便我的类的用户可以像使用原始数据类型一样使用这些对象，我需要重载输入和输出操作符来识别<code class="fe le lf lg lh b">IntData</code>对象。</p><h1 id="d796" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">重载初步:友元函数</h1><p id="9754" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">为了正确地重载操作符来处理类，必须将重载操作符的函数定义为一个<em class="my">友元函数</em>。友元函数是可以访问类的私有成员变量的函数。该函数不被视为类的一部分；它只是访问类的私有成员变量来执行它的功能。</p><p id="b7e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个简单的例子，使用了我上面讨论的<code class="fe le lf lg lh b">IntData </code>类的定义。为了更真实地演示友元函数是如何工作的，我需要将类的声明从类的定义中分离出来，尽管为了可读性起见，我将它们放在同一个文件中。下面是<code class="fe le lf lg lh b">IntData</code>类的声明和定义:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="205a" class="mt lj it lh b gy mu mv l mw mx">class IntData {<br/>private:<br/>  int data;</span><span id="f678" class="mt lj it lh b gy mz mv l mw mx">public:<br/>  IntData(int);<br/>  friend void print(const IntData &amp;);<br/>};</span><span id="6c55" class="mt lj it lh b gy mz mv l mw mx">IntData::IntData(int d) {<br/>  data = d;<br/>}</span><span id="f49a" class="mt lj it lh b gy mz mv l mw mx">void print(const IntData &amp;d) {<br/>  cout &lt;&lt; d.data;<br/>}</span></pre><p id="91a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以看到<code class="fe le lf lg lh b">print</code>函数是在类定义中定义的，但它并不是类的一部分。我不能使用点操作符从一个<code class="fe le lf lg lh b">IntData</code>对象中访问它。如果我尝试，我会得到一个错误。相反，我像使用常规函数一样使用它，并向它传递一个<code class="fe le lf lg lh b">IntData</code>对象。下面是一个演示如何使用friend函数的示例程序:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9366" class="mt lj it lh b gy mu mv l mw mx">int main ()<br/>{<br/>  IntData d1(12);<br/>  print(d1); // displays 12<br/>  return 0;<br/>}</span></pre><p id="5ba6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，友元函数比我在这里展示的要多，但是这足以让你看完这篇关于操作符重载的文章。我将在另一篇文章中详细介绍友元函数和友元类。</p><h1 id="602c" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">重载输出运算符</h1><p id="a718" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我将通过重载输出操作符(<code class="fe le lf lg lh b">&lt;&lt;</code>)来使用我定义的<code class="fe le lf lg lh b">Point</code>类，从而开始我的重载演示。下面是<code class="fe le lf lg lh b">Point</code>的简单类定义:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="e445" class="mt lj it lh b gy mu mv l mw mx">class Point {<br/>private:<br/>  int x, y;<br/>public:<br/>  Point(int, int);<br/>};</span></pre><p id="c78a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们来讨论输出操作符是如何重载的。重载运算符涉及到创建一个函数定义，该函数定义扩展了运算符可以处理的数据类型的定义。该函数看起来像一个常规函数。它有一个返回类型、一个名称(操作符本身)、一个参数列表、一个函数体和一个返回值。</p><p id="647c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重载函数被定义为接受数据的类的友元函数。这是为了让我们可以将所需的类的私有成员变量直接传递给函数，即使重载的操作符函数在类定义之外。</p><p id="19d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是重载输出操作符以输出<code class="fe le lf lg lh b">Point</code>对象成员变量的函数定义签名行:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c2b9" class="mt lj it lh b gy mu mv l mw mx">ostream &amp;operator &lt;&lt; (ostream &amp;strm, const Point &amp;p)</span></pre><p id="eff6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数的返回类型是<code class="fe le lf lg lh b">ostream</code>，表示输出流。接下来是输出操作符名称，它被定义为一个引用对象，这样您就可以将多个输出操作符链接在一起。参数列表由一个<code class="fe le lf lg lh b">ostream</code>对象引用和一个常量<code class="fe le lf lg lh b">Point</code>对象引用组成，其中<code class="fe le lf lg lh b">ostream</code>对象引用是<code class="fe le lf lg lh b">Point</code>数据将要流向的对象，因此数据不会在函数中被修改。为了提高效率，这些参数也通过引用传递。</p><p id="e696" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们看看函数体:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="e099" class="mt lj it lh b gy mu mv l mw mx">{<br/>  strm &lt;&lt; "x:" &lt;&lt; x &lt;&lt; ", y:" &lt;&lt; y;<br/>  return strm;<br/>}</span></pre><p id="8866" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数将x和y坐标的标签以及成员变量本身传输到<code class="fe le lf lg lh b">strm</code>对象，该对象由函数返回。</p><p id="eebe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是如何在类声明部分声明该函数:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6109" class="mt lj it lh b gy mu mv l mw mx">friend ostream &amp;operator &lt;&lt; (ostream &amp;, const Point &amp;);</span></pre><p id="891a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是完整的类声明和定义代码，以及一个测试程序:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="cee2" class="mt lj it lh b gy mu mv l mw mx">class Point {<br/>private:<br/>  int x, y;<br/>public:<br/>  Point(int, int);<br/>  friend ostream &amp;operator &lt;&lt; (ostream &amp;, const Point &amp;);<br/>};</span><span id="3362" class="mt lj it lh b gy mz mv l mw mx">Point::Point(int newx, int newy) {<br/>  x = newx;<br/>  y = newy;<br/>}</span><span id="efc4" class="mt lj it lh b gy mz mv l mw mx">ostream &amp;operator &lt;&lt; (ostream &amp;strm, const Point &amp;p) {<br/>  strm &lt;&lt; "x:" &lt;&lt; p.x &lt;&lt; ", y:" &lt;&lt; p.y;<br/>  return strm;<br/>}</span><span id="5b6a" class="mt lj it lh b gy mz mv l mw mx">int main ()<br/>{<br/>  Point p1(1,2);<br/>  cout &lt;&lt; p1 &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="16f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7bf8" class="mt lj it lh b gy mu mv l mw mx">x:1, y:2</span></pre><h1 id="c8b2" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">重载输入运算符</h1><p id="7ad5" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">重载输入操作符所需的代码类似于输出操作符的代码，除了明显地使用了一个<code class="fe le lf lg lh b">istream</code>对象而不是一个<code class="fe le lf lg lh b">ostream</code>对象。重载函数需要在类声明部分声明为友元，并在类外定义，就像我们对重载输出操作符所做的那样。</p><p id="f2d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是<code class="fe le lf lg lh b">Point</code>类的重载输入操作符的函数声明和函数定义:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="94fb" class="mt lj it lh b gy mu mv l mw mx">friend istream &amp;operator &gt;&gt; (istream &amp;, Point &amp;);</span><span id="5530" class="mt lj it lh b gy mz mv l mw mx">istream &amp;operator &gt;&gt; (istream &amp;strm, Point &amp;p) {<br/>  cout &lt;&lt; "x coordinate: ";<br/>  strm &gt;&gt; p.x;<br/>  cout &lt;&lt; "y coordinate: ";<br/>  strm &gt;&gt; p.y;<br/>  return strm;<br/>}</span></pre><p id="ccde" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，<code class="fe le lf lg lh b">Point</code>对象是一个常量参数，因为我们希望函数修改对象的成员变量。我还在函数定义中提供了一些提示信息，这些信息并不是绝对必要的，但是可以使操作者更加用户友好。</p><p id="25cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个测试输入操作符和输出操作符的程序:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="1ba3" class="mt lj it lh b gy mu mv l mw mx">int main ()<br/>{<br/>  Point p1;<br/>  cout &lt;&lt; "Enter a point: " &lt;&lt; endl;<br/>  cin &gt;&gt; p1;<br/>  cout &lt;&lt; p1 &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="3186" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="de7f" class="mt lj it lh b gy mu mv l mw mx">Enter a point:<br/>x coordinate: 5<br/>y coordinate: 8<br/>x:5, y:8</span></pre><h1 id="eba4" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">前方有更多超载</h1><p id="4012" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">这两个操作符只是我们在类定义服务中可以重载的许多操作符中的第一个。在我的下一篇文章中，我将讨论如何重载赋值操作符以及递增和递减操作符。</p><p id="00b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请给我发电子邮件，地址是<a class="ae kf" href="mailto:mmmcmillan1@att.net" rel="noopener ugc nofollow" target="_blank">mmmcmillan1@att.net</a>，并提出意见和建议。如果你对我的在线编程课程感兴趣，请访问<a class="ae kf" href="https://learningcpp.teachable.com" rel="noopener ugc nofollow" target="_blank">https://learningcpp.teachable.com</a>。</p></div></div>    
</body>
</html>