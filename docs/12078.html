<html>
<head>
<title>Your First Angular Microfrontend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你的第一个角形微前端</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/your-first-angular-microfrontend-58950768a465?source=collection_archive---------0-----------------------#2022-05-13">https://levelup.gitconnected.com/your-first-angular-microfrontend-58950768a465?source=collection_archive---------0-----------------------#2022-05-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0795" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这是一个关于如何创建一个在运行时使用另一个应用程序模块的简单的angular应用程序的逐步指南。但是首先让我们讨论一下微前端和模块联合是怎么回事。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e5a70546a3261d2f8e98dd0e34ea8541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p-ArC7CbZZzg6tXe9Gsh-Q.jpeg"/></div></div></figure><h1 id="2754" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">介绍</h1><p id="fae6" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">大多数人会告诉你，微前端就像微服务，但这个概念并不仅仅是在后端完成，而是通过将某些模块/组件/页面封装到独立的部分中并动态地使用它们来转移到前端完成。这意味着您可以让一个应用程序运行在端口5000上，而在另一个运行在端口3000上的应用程序中，您可以使用其他应用程序中的模块，而无需在端口3000上的应用程序中实现它们。</p><p id="2f8f" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这都是真的，但是我认为有更多的事情使微前端变得有趣。</p><h2 id="5edf" class="mk ks iq bd kt ml mm dn kx mn mo dp lb ls mp mq ld lw mr ms lf ma mt mu lh mv bi translated">为什么应该使用微前端？</h2><p id="8d0b" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">简短声明:不是每个人——实际上是大多数人——都不应该使用微前端，因为它们会使事情变得更复杂。过度工程从来都不是好事，但是如果你看到以下原因之一适用于你的情况，微前端可能会很有趣。</p><ol class=""><li id="eb2e" class="mw mx iq ll b lm mf lp mg ls my lw mz ma na me nb nc nd ne bi translated">你有许多前端团队在开发不同的特性。在这种情况下，微前端架构与其说是技术决策，不如说是商业决策，因为它将允许团队真正独立工作。否则，使用monolith有时会很困难，因为你永远不知道你的改变是否会以某种方式影响另一个团队。</li><li id="0508" class="mw mx iq ll b lm nf lp ng ls nh lw ni ma nj me nb nc nd ne bi translated">你的应用程序太大了。如果您发现自己不知道在哪里放置模型、组件、模块……因为您的项目结构非常庞大，那么microfrontends将帮助您创建一个更好的关注点分离。通过使用Nx monorepository和创建共享库，你不得不更加仔细地考虑架构，草率行事将更加困难。</li><li id="0ce4" class="mw mx iq ll b lm nf lp ng ls nh lw ni ma nj me nb nc nd ne bi translated">如果你想独立部署。您可以只对其中一个微前端进行微小的更改，然后不需要重新部署整个应用程序，而是只部署已经更改的那个微前端。</li></ol><p id="c355" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">最后，我甚至会把我提到的微前端的理由简化为一行代码:</p><blockquote class="nk nl nm"><p id="73da" class="lj lk nn ll b lm mf jr lo lp mg ju lr no mh lu lv np mi ly lz nq mj mc md me ij bi translated">如果你有一个<strong class="ll ir">大的组织</strong>或者一个<strong class="ll ir">大的应用</strong>，微前端是有趣的。</p></blockquote><h2 id="fe6f" class="mk ks iq bd kt ml mm dn kx mn mo dp lb ls mp mq ld lw mr ms lf ma mt mu lh mv bi translated">什么是单库？</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/55f5b06ee88967276fdf5d1718909c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ioqn3hQNAzNW1ugxGfM6cw.png"/></div></div></figure><p id="cbe5" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我提到我们的应用程序将存在于单个存储库中——这意味着它们都在同一个工作空间/存储库中。Monorepositories有许多不同的吸引力，但我认为最大的吸引力是它们解决了许多版本冲突，因为我们不需要将库发布到npm中，而是直接在项目之外使用它们。这也意味着我们只有一个angular.json和一个package.json，这样我们在每个项目中都有相同的包版本。根据这一规则，不可能有不同的角度版本或任何其他变化的包装版本。在本教程中，我们将使用Nx来创建一个工作空间，它基本上就是这样一个单存储库，我们可以在其中存储多个应用程序和库。我们甚至可以在这个工作空间中混合不同框架的项目。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="9c6b" class="kr ks iq bd kt ku nz kw kx ky oa la lb jw ob jx ld jz oc ka lf kc od kd lh li bi translated">逐步指南</h1><h2 id="8d79" class="mk ks iq bd kt ml mm dn kx mn mo dp lb ls mp mq ld lw mr ms lf ma mt mu lh mv bi translated">设置</h2><ol class=""><li id="aed6" class="mw mx iq ll b lm ln lp lq ls oe lw of ma og me nb nc nd ne bi translated"><strong class="ll ir">创建一个Nx工作区。</strong></li></ol><pre class="kg kh ki kj gt oh oi oj ok aw ol bi"><span id="846e" class="mk ks iq oi b gy om on l oo op">npx create-nx-workspace@latest</span></pre><ul class=""><li id="1cf4" class="mw mx iq ll b lm mf lp mg ls my lw mz ma na me oq nc nd ne bi translated">它将提示您指定工作区和第一个应用程序的名称。您已经可以选择Angular并为您的应用程序命名——但是如果您从一个空的工作区开始，这不会有问题，因为我们将添加另一个项目。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/ac591da2990183f358a020cece6b4c4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zF-F_5n5mbr1Uev4F1dSWw.png"/></div></div></figure><p id="d856" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">2 <strong class="ll ir">。安装Nx </strong></p><pre class="kg kh ki kj gt oh oi oj ok aw ol bi"><span id="e54d" class="mk ks iq oi b gy om on l oo op">npm install -g nx</span></pre><p id="184a" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">3.<strong class="ll ir">创建一个角度应用程序(远程)</strong></p><pre class="kg kh ki kj gt oh oi oj ok aw ol bi"><span id="7ecf" class="mk ks iq oi b gy om on l oo op">nx generate <a class="ae os" href="http://twitter.com/nrwl/angular" rel="noopener ugc nofollow" target="_blank">@nrwl/angular</a>:application remote</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/375f9302e81b7c69c6327b6c9f1e7b65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YSleuerGBws0vlFD7bGdyw.png"/></div></div></figure><p id="51a6" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">4.<strong class="ll ir">将模块联合插件添加到两个应用程序中</strong></p><pre class="kg kh ki kj gt oh oi oj ok aw ol bi"><span id="60d0" class="mk ks iq oi b gy om on l oo op">ng add <a class="ae os" href="http://twitter.com/angular" rel="noopener ugc nofollow" target="_blank">@angular</a>-architects/module-federation --project=remote</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/0dcc6be84b26c1fcb49d94fa81403904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6nbtB_ZBTXqO3T8hTltnhg.png"/></div></div></figure><pre class="kg kh ki kj gt oh oi oj ok aw ol bi"><span id="362b" class="mk ks iq oi b gy om on l oo op">ng add <a class="ae os" href="http://twitter.com/angular" rel="noopener ugc nofollow" target="_blank">@angular</a>-architects/module-federation --project=shell</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/ede391eddcfed435748bf421432c255e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uOArxBbsxhSstgSXWuwnNQ.png"/></div></div></figure><h2 id="eae6" class="mk ks iq bd kt ml mm dn kx mn mo dp lb ls mp mq ld lw mr ms lf ma mt mu lh mv bi translated">远程应用</h2><p id="708c" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">所以现在我们将创建一个简单的<em class="nn"> AbcModule </em>，它只路由到空白的Abc组件。然后我们通过调整<em class="nn"> webpack.config.js </em>来公开这个模块。</p><p id="bfc4" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">1.<strong class="ll ir">创建ABC模块+路由</strong></p><pre class="kg kh ki kj gt oh oi oj ok aw ol bi"><span id="c2b4" class="mk ks iq oi b gy om on l oo op">ng generate module abc --project=remote --routing</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/7604c475b32ec2e55fdb28cf35e6b464.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y5KySBG4izwdzE-UzH8TVA.png"/></div></div><figcaption class="ox oy gj gh gi oz pa bd b be z dk translated">创建Abc组件</figcaption></figure><p id="35a2" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">2.<strong class="ll ir">创建Abc组件</strong></p><pre class="kg kh ki kj gt oh oi oj ok aw ol bi"><span id="5bd2" class="mk ks iq oi b gy om on l oo op">ng generate component abc --project=remote</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/8ce602de0debd5e4dc6f03d66effc10c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*944hZkduu3RiqzUE7DyZLg.png"/></div></div></figure><p id="4b56" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">3.<strong class="ll ir">配置abc-routing.module.ts </strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="cb1b" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">4.<strong class="ll ir">用路由配置app . module . ts</strong></p><p id="f5a3" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><em class="nn">(这对微前端来说不是必须的，只是为了让微前端也能独立工作)</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="dfc7" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><strong class="ll ir"> 5。暴露webpack.config.js中的ABC module</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="0c46" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><em class="nn"> remoteEntry.js </em>文件是自动生成的，并且需要向包含webpackconfig配置的外部应用程序发出指令。它公开了哪些映射应该共享，以及它公开了哪些内容。如果您运行远程应用程序，您也可以通过将该文件添加到url来查看它，如下所示:<em class="nn">https://localhost:4201/remote entry . js</em></p><h2 id="c3e5" class="mk ks iq bd kt ml mm dn kx mn mo dp lb ls mp mq ld lw mr ms lf ma mt mu lh mv bi translated">外壳应用程序</h2><p id="f0c9" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">现在唯一剩下的就是微前端的实际消耗。基本上有两种方法:静态和动态。</p><p id="e023" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">进行静态操作时，我们必须在webpack.config.json中定义远程模块，并声明模块以告诉typescript不要担心它无法编译的远程模块。这有点乏味，而且动态更好，因为理论上我们甚至可以从后端加载微前端配置。</p><ol class=""><li id="2067" class="mw mx iq ll b lm mf lp mg ls my lw mz ma na me nb nc nd ne bi translated"><strong class="ll ir">在webpack.config.js中调整和配置遥控器</strong></li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="1f26" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">2.<strong class="ll ir">路由激活时延迟加载微前端</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="d054" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">loadRemoteModule是在webpack.config.json中静态定义模块并在路由中引用它们的替代方法。这样，我们只需在路由中指定配置，我们也可以从其他来源动态加载它。</p><p id="27c1" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><em class="nn">不要忘记在AppModule中导入AppModule)</em></p><p id="2019" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">3.<strong class="ll ir">改造app.component.html，使其拥有一个路由器出口和一个路由器链路</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pc pd l"/></div></figure><h2 id="0dca" class="mk ks iq bd kt ml mm dn kx mn mo dp lb ls mp mq ld lw mr ms lf ma mt mu lh mv bi translated">我们走吧！</h2><p id="b3aa" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">一切都设置为现在运行，应该工作。让我们启动这两个应用程序，但是记住我们应该在shell之前启动微前端。</p><pre class="kg kh ki kj gt oh oi oj ok aw ol bi"><span id="31b4" class="mk ks iq oi b gy om on l oo op">nx serve remote</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/99a67a050ae7e3beb6559e09eb424cef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wF8R5DRihhC7FaMNSYjCmw.png"/></div></div></figure><pre class="kg kh ki kj gt oh oi oj ok aw ol bi"><span id="e785" class="mk ks iq oi b gy om on l oo op">nx serve shell</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/b5c65aec48c85ef5457675c5a5c6575f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aBq-abtzoQe-GXc5BB_JHA.png"/></div></div></figure><p id="1f8a" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这不是很疯狂吗？我们使用的模块甚至不存在于我们的应用程序中，而是运行在它自己的应用程序中。当进行动态加载时，我们可以在后端管理微前端，并决定在某一天引用某些模块，而在第二天引用其他模块。</p><h1 id="47f0" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">结论</h1><p id="85b5" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我认为微前端和模块联盟真的很有趣，尽管我也相信不是每个公司都使用它是件好事。它帮助我让我的前端变得更有条理，并迫使我花更多的时间去思考最终导致更好软件的架构。将monolith移动到Nx monorepository并提供库和微前端花费了很多时间，但最终对我来说还是值得的。</p><p id="514e" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">模块联合还有更有趣的场景。一种情况是，如果您试图将一个遗留的AngularJs应用程序迁移到Angular。通过使用微前端，你可以逐渐转移到一个新的框架。谁知道呢，也许将来Angular会消亡，我们希望迁移到一个全新的框架——micro frontends让我们了解了这一点。</p><p id="423b" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我也强烈推荐你去看看Manfred Steyer的内容，他是这方面的专家。例如，我没有试图解释为什么需要webpack.config.js，因为我无法像Manfred那样描述它，所以看看他是怎么说的:</p><div class="pf pg gp gr ph pi"><a href="https://www.angulararchitects.io/" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd ir gy z fp pn fr fs po fu fw ip bi translated">软件建筑| Angular-Schulungen von Insidern</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">安格尔-库兹与曼弗雷德·施泰尔和⭐团队在德国、德国和瑞士⭐和英国⭐发现…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">www.angulararchitects.io</p></div></div><div class="pr l"><div class="ps l pt pu pv pr pw kp pi"/></div></div></a></div><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="px pd l"/></div></figure><p id="62db" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">如果你想在Medium上阅读无限量的文章并支持我，请使用我的推荐链接:</p><p id="0eb5" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><a class="ae os" href="https://medium.com/@stefan.haas.privat/membership" rel="noopener">https://medium.com/@stefan.haas.privat/membership</a></p></div></div>    
</body>
</html>