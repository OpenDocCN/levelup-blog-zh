<html>
<head>
<title>Untethering your WebApps with Observables and RxJS — Zartis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Observables和RxJS解开您的web应用程序——zart is</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/untethering-your-webapps-with-observables-and-rxjs-zartis-bca73df12d67?source=collection_archive---------26-----------------------#2020-06-16">https://levelup.gitconnected.com/untethering-your-webapps-with-observables-and-rxjs-zartis-bca73df12d67?source=collection_archive---------26-----------------------#2020-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/50f5469b1dc86be3c0d180785080c81b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8yLVtJ3c5Rm0CLHeXo9DiA.png"/></div></div></figure><p id="38dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你是一名开发人员，并且喜欢掌握全局，那么你现在可能已经听说过术语“<a class="ae kz" href="https://rxjs-dev.firebaseapp.com/guide/observable" rel="noopener ugc nofollow" target="_blank"> Observables </a>”。如果你没有，不客气，这是给你的。如果你已经很熟悉了，那么这篇文章可能会给他们一个新的解释。</p><p id="67e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我想说明的是，我对可观测量的看法是基于我自己的奋斗和经历。我宁愿像希望别人告诉我的那样告诉他们，而不是逐字逐句地给你学术上的废话。</p><p id="dc38" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我的附加价值，但它带有公平的警告:并不是这篇文章中描述的所有术语和方法都与官方文件一一对应。在可能有分歧的地方，我会代表读者尽量指出来，以避免混淆。</p><h1 id="84b6" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是可观测量？</h1><p id="3ff2" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">想象一下，你在给定的范围内有一组事件，就像你阅读这篇文章时秒秒滴答。如果你是一个普通读者，这一系列滴答作响的事件将会发生有限的次数，通常是几百次左右，每秒钟一个事件。如果你是一个非常慢的读者，并且永远以萨特式的方式被这篇文章所吸引，它们在时间上也可以是开放式的。你也可能速度无限快，让时钟只滴答一次，或者你可能根本没有读它，也没有任何事件发生。但真正的问题是，谁在听滴答声？可能没有人，可能只有一个听众，也可能有多个听众。此外，当每个侦听器订阅流时，将确定它们接收什么事件。</p><p id="f25d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">ReactiveX和它的JS实现RxJS提供了一个整体的工具集来处理这些概念性的场景，并带有可观察的内容。这里事件的范围发生在一个可观察的实例内。换句话说，一个可观察的是一系列事件发生的竞技场，所以我们也可以把它想象成“溪流”、“通道”或“管道”。此外，一个可观察的实例公开了一个subscribe方法，该方法可用于通知每个发生的事件。</p><h1 id="5ee7" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">创造可观的</h1><h2 id="1de3" class="md lb it bd lc me mf dn lg mg mh dp lk km mi mj lo kq mk ml ls ku mm mn lw mo bi translated">用手</h2><p id="5b47" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">可观察的(手动)实现的最简单的例子是:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="2bf2" class="md lb it mu b gy my mz l na nb"><strong class="mu iu">const</strong> stuff$ = <strong class="mu iu">new</strong> Observable(subscriber =&gt; {<br/>  subscriber.next(<strong class="mu iu">1</strong>);<br/>  subscriber.next(<strong class="mu iu">2</strong>);<br/>  subscriber.next(<strong class="mu iu">3</strong>);<br/>  subscriber.complete();<br/>});<br/><br/>stuff$.subscribe(num =&gt; {<br/>  console.log(num);<br/>});</span></pre><p id="9e2a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">例1a </em></p><p id="dabf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意这里的<a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/index/class/Subscriber" rel="noopener ugc nofollow" target="_blank">订户</a>参数。这是一个可观察的关键组成部分之一(以及<a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/index/class/Subscription" rel="noopener ugc nofollow" target="_blank">订阅</a>)。另外，请注意complete()方法，它关闭了可观察对象并发出一个完成事件。最后，请注意我是如何在包含可观察变量的名称后面附加一个美元符号的:这是一个常见的约定。你也可以创建一个可观察的接口——实现<a class="ae kz" href="https://rxjs-dev.firebaseapp.com/guide/subject" rel="noopener ugc nofollow" target="_blank">主题</a>:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="9545" class="md lb it mu b gy my mz l na nb"><strong class="mu iu">const</strong> stuff$ = <strong class="mu iu">new</strong> Subject();<br/>stuff$.subscribe(num =&gt; {<br/>  console.log(num);<br/>});<br/>stuff$.next(<strong class="mu iu">1</strong>);<br/>stuff$.next(<strong class="mu iu">2</strong>);<br/>stuff$.next(<strong class="mu iu">3</strong>);<br/>stuff$.complete();</span></pre><p id="9e80" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">例1b </em></p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="a1d6" class="md lb it mu b gy my mz l na nb">/* Output of either: 1a and 1b*/<br/>// 1<br/>// 2<br/>// 3 (complete)</span></pre><h2 id="1064" class="md lb it bd lc me mf dn lg mg mh dp lk km mi mj lo kq mk ml ls ku mm mn lw mo bi translated"><em class="nd">带助手功能</em></h2><p id="4314" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">手动实例化一个可观察对象并不常见。相反，我们通常依赖于助手方法(技术上来说是<a class="ae kz" href="https://www.learnrxjs.io/operators/creation/" rel="noopener ugc nofollow" target="_blank">创建操作符</a>——我们将在下一节中讨论更多)，如:of、from、defer等，它们返回一个可观察的实例。让我们看看它们是如何工作的，以及它们帮助你创造了什么类型的可观测量。</p><ul class=""><li id="411f" class="ne nf it kd b ke kf ki kj km ng kq nh ku ni ky nj nk nl nm bi translated"><a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/index/function/of" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> <em class="nc">(共</em> </strong> </a>):将在subscribe上按顺序发出任何传递的参数(这使得它“冷”)，然后将完成。<br/>举例:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="4e34" class="md lb it mu b gy my mz l na nb">of(<strong class="mu iu">1</strong>, <strong class="mu iu">2</strong>, <strong class="mu iu">3</strong>); // same as example 1</span></pre><p id="3fa7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">例二</em></p><ul class=""><li id="c119" class="ne nf it kd b ke kf ki kj km ng kq nh ku ni ky nj nk nl nm bi translated"><a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/index/function/from" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"><em class="nc">from</em></strong></a>:同上，但只接受一个参数，它解析这个参数。最常用于从承诺转换。在这种情况下，即使承诺已经解决，可观察对象也会发出。<br/>举例:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="8505" class="md lb it mu b gy my mz l na nb">from([<strong class="mu iu">1</strong>, <strong class="mu iu">2</strong>, <strong class="mu iu">3</strong>]); // same as example 1</span></pre><p id="1700" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">例3a </em></p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="17e4" class="md lb it mu b gy my mz l na nb">from(<strong class="mu iu">new</strong> Promise(resolve =&gt; resolve(<strong class="mu iu">1</strong>));<br/>// outputs 1 and completes</span></pre><p id="ce4f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">例3b </em></p><ul class=""><li id="d2c1" class="ne nf it kd b ke kf ki kj km ng kq nh ku ni ky nj nk nl nm bi translated"><a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/index/function/defer" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"><em class="nc">defer</em></strong></a>:取一个返回可观察值的函数，在每次订阅时调用。这是一个典型的“冷”可观察的例子。<br/>举例:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="9153" class="md lb it mu b gy my mz l na nb">defer(() =&gt; of(<strong class="mu iu">1</strong>, <strong class="mu iu">2</strong>, <strong class="mu iu">3</strong>)); // same as example 1</span></pre><p id="78b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">例4a </em></p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="8b31" class="md lb it mu b gy my mz l na nb">defer(() =&gt; from(asyncApiCall()));<br/>// Will make call *on (each) subscription*</span></pre><p id="17fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">例4b </em></p><ul class=""><li id="d918" class="ne nf it kd b ke kf ki kj km ng kq nh ku ni ky nj nk nl nm bi translated"><a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/index/function/fromEvent" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"><em class="nc">from event</em></strong></a>:将创建的可观察对象附加到DOM或NodeJS事件的发射上。第一个参数是发射目标，第二个参数是要转发的事件的名称。这是一个典型的“热”可观察的例子。示例:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="d26e" class="md lb it mu b gy my mz l na nb">fromEvent(document, 'click'); // emits on every click</span></pre><p id="5ad6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">例5 </em></p><ul class=""><li id="c38d" class="ne nf it kd b ke kf ki kj km ng kq nh ku ni ky nj nk nl nm bi translated"><a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/index/function/interval" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> <em class="nc">间隔</em> </strong> </a>:这将创建一个可观察对象，它将按照传入参数定义的节奏(以毫秒为单位)无限触发。输出等同于示例7。示例:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="5ea2" class="md lb it mu b gy my mz l na nb">interval(<strong class="mu iu">1000</strong>); // emits an incrementing, zero-offset counter</span></pre><p id="e31c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">例6 </em></p><h1 id="f37a" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">订阅Observables</h1><p id="8fe3" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">每次您订阅一个可观察对象，就会创建一个<a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/index/class/Subscription" rel="noopener ugc nofollow" target="_blank">订阅</a>，并保持开放状态(在内存中)，直到被取消订阅或可观察对象关闭(自动取消订阅)。当不再需要订阅时(例如，从一个已卸载/销毁的组件)，对未完成的可观测量取消订阅的重要性怎么强调都不为过。让我们来看看这个更复杂的例子:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="2b6b" class="md lb it mu b gy my mz l na nb"><strong class="mu iu">const</strong> timer$ = <strong class="mu iu">new</strong> Observable(subscriber =&gt; {<br/><strong class="mu iu">  let</strong> i = <strong class="mu iu">0</strong>;<br/><strong class="mu iu">  const</strong> timer = () =&gt; subscriber.next(i++);<br/>  setInterval(timer, <strong class="mu iu">1000</strong>);<br/><strong class="mu iu">  return</strong> () =&gt; {<br/>    clearInterval(timer)<br/>    subscriber.complete();<br/>  };<br/>});</span><span id="f70a" class="md lb it mu b gy nn mz l na nb"><strong class="mu iu">const</strong> timerSubscription = timer$.subscribe(num =&gt; {<br/>  console.log(num);<br/>});</span><span id="15d3" class="md lb it mu b gy nn mz l na nb">/* Output */<br/>// (wait 1 second...)<br/>// 0<br/>// 1<br/>// 2<br/>// … until<br/>timerSubscription.unsubscribe();</span></pre><p id="6bd2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">例7 </em></p><h1 id="9215" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">处理错误和完成事件</h1><p id="f6ef" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">到目前为止，我们只提到了常规事件，但是可观测量也可能发出两种其他类型的事件:出错时，如果可观测量的源发生错误，以及完成时，当可观测量关闭。<a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/index/class/Observable#example" rel="noopener ugc nofollow" target="_blank">要订阅这两个参数</a>,您可以向subscribe方法传递一个<a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/index/type-alias/PartialObserver" rel="noopener ugc nofollow" target="_blank"> PartialObserver </a>类型，或者第二个(错误处理程序)和第三个(完成处理程序)参数。让我们看两个例子:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="1aae" class="md lb it mu b gy my mz l na nb">from(apiCall()).subscribe(<br/>  response =&gt; console.log(response),<br/>  error =&gt; <strong class="mu iu">throw</strong> error,<br/>  () =&gt; console.log('Observable closed')<br/>);<br/>// same as...<br/>from(apiCall()).subscribe({<br/>  next: response =&gt; console.log(response),<br/>  error: error =&gt; <strong class="mu iu">throw</strong> error,<br/>  complete: () =&gt; console.log('Observable closed')<br/>});</span></pre><p id="cb55" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">例8 </em></p><h1 id="4ed0" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">可观察的类型</h1><p id="10c7" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">所以我们已经确定，每个可观测的事物都是一系列事件的封装。但这里有一个转折:可观察到的东西可能有也可能没有点火钥匙。这意味着，您可以将可观察对象连接到现有的事件源(如开放的websocket连接、DOM事件流、用户事件等)。)，可观察对象只是多个订阅者可以随时收听的“事件管道”,或者，这是有趣的部分，您可以增强这个“管道”,以点燃订阅的事件源。我们分别称这两种概念类型为“热”和“冷”:</p><ul class=""><li id="b2f2" class="ne nf it kd b ke kf ki kj km ng kq nh ku ni ky nj nk nl nm bi translated"><strong class="kd iu">【热】可观察物</strong>:它们“代理”来自独立来源的事件，这些事件可能(也可能没有)在任何给定订阅的时间开始(甚至停止)触发。示例:一个MouseEvents流，无论我们是否已经将它“附加”到一个可观察对象，或者在我们这样做之前，它都将存在并可能被激发(参见示例5)。注意:这些可观测量通常是多播给多个观察者的。</li><li id="168c" class="ne nf it kd b ke no ki np km nq kq nr ku ns ky nj nk nl nm bi translated"><strong class="kd iu">“冷”可见物</strong>:它们是完整的包装。他们在订阅上打开事件源的点火。示例:我们可能希望在每次订阅一个可观察对象时执行一个网络请求(参见示例4)。注意:这些可观测量通常是单播给一个观察者的。</li></ul><p id="1da0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有时，你会听说第三种类型的可观测量，称为<strong class="kd iu">“温暖”可观测量</strong>。从名字上看，你可能已经猜到它们代表了以上两种类型的混合。实际上，对于第一个订阅者来说，它们是冷的可观察对象(因此事件源在初始订阅时启动),而对于后续订阅者来说，它们是热的可观察对象。<br/>一个典型的应用是当订阅者计数(称为<a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/operators/refCount" rel="noopener ugc nofollow" target="_blank"> refCount </a>)下降到零时重置可观察值，并在新的第一个订阅上重新启动事件发射源的一个新实例。</p><h1 id="9195" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">生态系统</h1><h1 id="f676" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">经营者</h1><p id="e500" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我们在创建可观测量时已经看到了一些操作符，然而真正的操作符是那些反应和/或转换可观测量吞吐量的操作符。您可以在Observable的pipe方法中使用这些方法，并且可以连接任意多的方法。它们将按顺序被调用，并转发转换后的值，这与承诺中的情况非常相似。让我们来看一些典型的例子:</p><h2 id="069b" class="md lb it bd lc me mf dn lg mg mh dp lk km mi mj lo kq mk ml ls ku mm mn lw mo bi translated">简单运算符:</h2><ul class=""><li id="2b77" class="ne nf it kd b ke ly ki lz km nt kq nu ku nv ky nj nk nl nm bi translated"><a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/operators/map" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> <em class="nc"> map </em> </strong> </a>:非常像Array.map，允许你处理每个事件，并将其转换为给定的返回值。示例:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="b0cd" class="md lb it mu b gy my mz l na nb">of(<strong class="mu iu">1</strong>, <strong class="mu iu">2</strong>, <strong class="mu iu">3</strong>)<br/>  .pipe(map(e =&gt; e + <strong class="mu iu">1</strong>))<br/>  .subscribe(e =&gt; console.log(e))<br/>/* Output: */<br/>// 2<br/>// 3<br/>// 4 (complete)</span></pre><p id="b619" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">例9 </em></p><ul class=""><li id="f9fa" class="ne nf it kd b ke kf ki kj km ng kq nh ku ni ky nj nk nl nm bi translated"><a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/operators/tap" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> <em class="nc">点击</em> </strong> </a>:与map相同，但返回被忽略，吞吐量不变。将此方法用于每个事件的副作用或日志记录/调试目的。<br/> reduce:类似于Array.reduce，根据处理函数进行累加，并在完成时返回累加器。类似于运算符扫描，它在每个事件上都返回累加器。示例:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="eb29" class="md lb it mu b gy my mz l na nb">of(<strong class="mu iu">1</strong>, <strong class="mu iu">2</strong>, <strong class="mu iu">3</strong>)<br/>  .pipe(reduce((acc, e) =&gt; `${acc}${e}`, ''))<br/>  .subscribe(e =&gt; console.log(e));<br/>/* Output: */<br/>// "123" (complete)</span></pre><p id="5e63" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">例10 </em></p><ul class=""><li id="1014" class="ne nf it kd b ke kf ki kj km ng kq nh ku ni ky nj nk nl nm bi translated"><a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/operators/take" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> <em class="nc">取</em> </strong> </a>:只取指定数量的事件，之后完成(或当可观察关闭时)。<br/>举例:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="6096" class="md lb it mu b gy my mz l na nb">of(<strong class="mu iu">1</strong>, <strong class="mu iu">2</strong>, <strong class="mu iu">3</strong>)<br/>  .pipe(take(<strong class="mu iu">2</strong>))<br/>  .subscribe(e =&gt; console.log(e));<br/>/* Output: */<br/>// 1<br/>// 2 (complete)</span></pre><p id="ad0c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">例11 </em></p><ul class=""><li id="2eec" class="ne nf it kd b ke kf ki kj km ng kq nh ku ni ky nj nk nl nm bi translated"><a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/operators/first" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> <em class="nc">第一个</em> </strong> </a>:和take(1)一样，但是如果可观察对象在发射前关闭会发射错误。<br/>举例:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="3f3f" class="md lb it mu b gy my mz l na nb">EMPTY // rxjs.EMPTY creates an observable that immediately closes<br/>  .pipe(first())<br/>  .subscribe(<br/>    e =&gt; console.log(e),<br/>    error =&gt; console.log(`Error: ${error.message}`),<br/>    () =&gt; console.log('Complete!'),<br/>  );<br/>/* Output: */<br/>// Error: no elements in sequence</span></pre><p id="1c64" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">实施例12 </em></p><h2 id="ef99" class="md lb it bd lc me mf dn lg mg mh dp lk km mi mj lo kq mk ml ls ku mm mn lw mo bi translated">高级操作员:</h2><ul class=""><li id="1b6d" class="ne nf it kd b ke ly ki lz km nt kq nu ku nv ky nj nk nl nm bi translated"><a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/operators/switchMap" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"><em class="nc">switch map</em></strong></a>，<a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/operators/mergeMap" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"><em class="nc">merge map</em></strong></a>，<a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/operators/concatMap" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"><em class="nc">concat map</em></strong></a>，<a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/operators/exhaustMap" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"><em class="nc">outlet map</em></strong></a>:将源(又称“外层”)可观测的发射映射到嵌套(又称“内层”)可观测的发射上。示例:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="4522" class="md lb it mu b gy my mz l na nb">interval(<strong class="mu iu">1000</strong>)<br/>  .pipe(switchMap(e =&gt; apiCall(e)))<br/>  .subscribe(e =&gt; console.log(e));<br/>/* Output: */<br/>// Result of apiCall(1)<br/>// Result of apiCall(2)<br/>// ...</span></pre><p id="be3b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">例13 </em></p><p id="11fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="nc">注</em> : </strong>这三类“组合”运算符的区别在于如何通过可观测量解决重叠或补全。我全心全意地推荐<a class="ae kz" href="https://rxmarbles.com/" rel="noopener ugc nofollow" target="_blank"> RxMarbles </a>的例子，直观地比较三者。</p><ul class=""><li id="3c03" class="ne nf it kd b ke kf ki kj km ng kq nh ku ni ky nj nk nl nm bi translated"><a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/operators/forkJoin" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"><em class="nc">fork join</em></strong></a>:在概念上非常类似于Promise.all。它将可观察值作为参数、数组或可观察值的对象图，并等待它们全部完成，然后返回结果的数组(前两种情况)或对象图(第三种情况)。示例:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="7c4e" class="md lb it mu b gy my mz l na nb">forkJoin({<br/>  foo: apiCall('foo'),<br/>  bar: apiCall('bar'),<br/>  baz: apiCall('baz')<br/>}).subscribe(<br/>  apiResponses =&gt; {<br/>    // do something with apiResponse.foo, apiResponse.bar or apiResponse.baz<br/>  },<br/>  error =&gt; console.log('One of the requests failed:', error)<br/>);</span></pre><p id="927e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">例14 </em></p><p id="9fec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="nc">注:</em> </strong> <em class="nc">这个运算符实际上是一个创建运算符。</em></p><p id="1f4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="nc">注2: </em> </strong> <em class="nc"> </em>如果您想单独处理错误，而不是在单个请求失败时组合操作失败，您需要在每个请求上使用catch操作符</p><ul class=""><li id="bb2d" class="ne nf it kd b ke kf ki kj km ng kq nh ku ni ky nj nk nl nm bi translated"><a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/index/function/combineLatest" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"><em class="nc">combine test</em></strong></a>:类似于forkJoin，但每次输入观察值都发出(一旦所有输入观察值都产生了至少一个值)。这意味着它可能有无限个值，并且可能不完整，输入可观察值在产生值之前不必完整。示例:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="47ce" class="md lb it mu b gy my mz l na nb">combineLatest(<br/>  apiCall('foo'),<br/>  apiCall('bar'),<br/>  apiCall('baz')<br/>).subscribe(([foo, bar, baz]) =&gt; console.log(<br/>  `API-Call Foo Latest: ${baz},<br/>  API-Call Bar Latest: ${bar},<br/>  API-Call Baz Latest: ${baz}`<br/>));</span></pre><p id="4e06" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">例15 </em></p><p id="a654" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="nc">注意</em> : </strong>这个运算符其实是一个创建运算符。</p><ul class=""><li id="5d9d" class="ne nf it kd b ke kf ki kj km ng kq nh ku ni ky nj nk nl nm bi translated"><a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/operators/debounce" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"><em class="nc"/></strong></a><a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/operators/audit" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"><em class="nc">审计</em></strong></a><a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/operators/sample" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"><em class="nc">采样</em></strong></a><a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/operators/throttle" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"><em class="nc">节流</em></strong></a><a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/operators/buffer" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"><em class="nc">缓冲</em></strong></a><a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/operators/window" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"><em class="nc">窗口</em> </strong> </a>:我们您可能熟悉lodash等库中的一些概念。</li></ul><h1 id="3163" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">常见使用案例</h1><h2 id="d0ee" class="md lb it bd lc me mf dn lg mg mh dp lk km mi mj lo kq mk ml ls ku mm mn lw mo bi translated">使用异步调用(又名承诺)</h2><p id="c75d" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我们已经在例3b中学习了如何从一个承诺创造一个可观察的，但是相反的也很简单。请参见以下示例:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="23cf" class="md lb it mu b gy my mz l na nb"><strong class="mu iu">const</strong> resultPromise = timer(<strong class="mu iu">3000</strong>).toPromise();<br/>resultPromise.then(result =&gt; console.log(result));</span></pre><p id="c2aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">例16a </em></p><p id="d1c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">或者，如果您在异步上下文中:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="648b" class="md lb it mu b gy my mz l na nb"><strong class="mu iu">const</strong> result = async timer(<strong class="mu iu">3000</strong>).toPromise();<br/>console.log(result);</span></pre><p id="6e4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">例16b </em></p><p id="3f55" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">[js]/*两者的输出*/ <br/> //(等待3秒)<br/> // 0(完成)[/js]</p><h2 id="9e65" class="md lb it bd lc me mf dn lg mg mh dp lk km mi mj lo kq mk ml ls ku mm mn lw mo bi translated">使用DOM事件</h2><p id="bfd3" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">通常，您会发现自己有一系列需要过滤、去抖或抑制的鼠标事件。一个典型的场景是手动检测双击。这个例子善意地借用了<a class="ae kz" href="https://www.learnrxjs.io/operators/transformation/buffer.html" rel="noopener ugc nofollow" target="_blank"> learnrxjs </a>:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="ded9" class="md lb it mu b gy my mz l na nb"><strong class="mu iu">const</strong> clicks$ = fromEvent(document, 'click')<br/>clicks$.pipe(<br/>  buffer(clicks$.pipe(throttleTime(<strong class="mu iu">250</strong>))),<br/>  // if array is greater than 1, double click occured<br/>  filter(clickArray =&gt; clickArray.length &gt; <strong class="mu iu">1</strong>)<br/>).subscribe(() =&gt; console.log('Double Click!'));</span></pre><p id="b3f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">实施例17 </em></p><h1 id="cf63" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">解开绳索的场景</h1><h2 id="901e" class="md lb it bd lc me mf dn lg mg mh dp lk km mi mj lo kq mk ml ls ku mm mn lw mo bi translated">WebAPI调用和热观察</h2><p id="f596" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我已经简单地提到了“温暖的”可观测量是第三种可观测量。这就是它们派上用场的地方。想象一个典型的场景，其中有多个组件请求WebAPI数据。如果它们发生的时间相对接近，您可能希望避免每个事件导致一个单独的调用，以便最小化WebAPI服务器的网络流量。这相对容易用可观测量来实现:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="ed89" class="md lb it mu b gy my mz l na nb"><strong class="mu iu">function</strong> performNetworkRequest(): Observable {<br/><strong class="mu iu">  return</strong> defer(() =&gt; from(asyncApiCall()));<br/>}<br/><br/><strong class="mu iu">let</strong> bufferedRequest$;<br/><strong class="mu iu">function</strong> getBufferedNetworkRequest() {<br/>  bufferedRequest$ = bufferedRequest$ || performNetworkRequest()<br/>  .pipe(<br/>    shareReplay(),<br/>    finalize(() =&gt; { bufferedRequest$ = <strong class="mu iu">undefined</strong>; })<br/>  );<br/><strong class="mu iu">  return</strong> bufferedRequest;<br/>}</span></pre><p id="1e65" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">实施例18 </em></p><p id="99fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在示例18中，第一个订阅将触发networkRequest。当网络请求“进行中”时发生的所有订阅将等待网络请求解决(通过<a class="ae kz" href="https://rxjs-dev.firebaseapp.com/api/operators/shareReplay" rel="noopener ugc nofollow" target="_blank"> shareReplay </a>实现)，然后通知所有订阅者并关闭。使用操作符，我们可以在源完成时清除bufferedRequest$变量，这样新的调用将重新触发网络请求。我们可以通过设置基于时间的缓存策略来改进这一点，但是这超出了本文的范围。</p><h2 id="a5ed" class="md lb it bd lc me mf dn lg mg mh dp lk km mi mj lo kq mk ml ls ku mm mn lw mo bi translated">使用实现RxJS的库</h2><p id="4892" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">随着时间的推移，越来越多的库开始实现反应模式。其中一些内置了RxJS，例如，这允许它们的内部使用，以及它们的外部使用，以允许更好的优化。</p><p id="cae6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Angular的API的一个例子是它的<a class="ae kz" href="https://angular.io/guide/http" rel="noopener ugc nofollow" target="_blank"> httpClient服务</a>，它将在执行网络请求时方便地返回可观察到的内容，以及<a class="ae kz" href="https://angular.io/guide/reactive-forms" rel="noopener ugc nofollow" target="_blank">表单控件</a>，它允许轻松订阅表单值的变化(valueChanges)和反应验证。</p><h1 id="4d3b" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">继续敲！</h1><p id="9876" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我接触过的每一个使用过高级RxJS模式的同事，每次都说这个库和它的模式让他们大吃一惊。这也发生在我身上。我已经经历了几次“哇，现在我明白了”到“哇，现在我真的明白了”的时刻，我相信以后还会有更多。</p><p id="4ef6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我还必须说，尽管由于RxJS，我的工作效率得到了普遍的提高，但我有时还是会在试图理解官方文档(一定要检查<a class="ae kz" href="https://www.learnrxjs.io/" rel="noopener ugc nofollow" target="_blank"> learnrxjs.io </a>，这是一个救命程序)时，或者只是通过调试事件没有“通过”或“丢失”的问题，而这最终源于我自己的一些愚蠢错误(例如，没有关闭forkJoin上的源代码)。记住在操作符之间使用tap操作符进行调试！</p><p id="f55f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于时间原因，还有许多其他方面的可观察性我没有涉及，比如主题的类型(例如行为主题、回放主题)或测试(用弹珠)。我鼓励你自己去旅行，如果你希望我们将来写任何相关的话题，请随时给我们在sayhello@zartis.com写信。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="a670" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">最初发表于</em><a class="ae kz" href="https://www.zartis.com/untethering-webapps-with-observables-rxjs/" rel="noopener ugc nofollow" target="_blank"><em class="nc">https://www.zartis.com</em></a><em class="nc">。</em></p><p id="f148" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nc">作者</em>:</p><div class="od oe gp gr of og"><a href="https://www.linkedin.com/in/filiptc/" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">Philip Thomas Casado-UI Lead-zart is | LinkedIn</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">在全球最大的职业社区LinkedIn上查看菲利普·托马斯·卡萨多的个人资料。菲利普列出了6项工作…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">www.linkedin.com</p></div></div><div class="op l"><div class="oq l or os ot op ou jz og"/></div></div></a></div></div></div>    
</body>
</html>