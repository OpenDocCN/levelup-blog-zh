<html>
<head>
<title>Creating Reactive Restful APIs with Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Spring Boot创建反应式Restful APIs</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-a-reactive-restful-api-with-spring-boot-e706954f0633?source=collection_archive---------0-----------------------#2020-10-02">https://levelup.gitconnected.com/creating-a-reactive-restful-api-with-spring-boot-e706954f0633?source=collection_archive---------0-----------------------#2020-10-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cdda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个故事中，我们想用Spring Webflux构建一个反应式API</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/935b9a5f2a654a971168327e1cea399b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yJVqBfOx_Rlv-8iZ"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">马克西米利安·魏斯贝克尔在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="90c6" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">概观</h1><p id="12b9" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在这篇文章中，我想展示用Spring Boot创建一个反应式REST API是多么容易。我想用一个简单的用例来展示用Spring Boot创建一个“主动的”非阻塞REST API有多快。</p><p id="e7ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在过去的几个月和几个星期里，我一直在开发两个不同的现代移动应用/网络应用。我很快意识到，如果你不得不一直从客户端询问API是否有变化，这会非常不方便。你肯定知道你可以通过投票来做到这一点。但是我觉得这样不太雅观。也造成了很多不必要的流量。</p><p id="f730" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个技术上更好的解决方案是，如果API的消费者可以订阅一个端点，这个端点将通知客户端有关更改的信息。</p><p id="8fc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我想使用所谓的服务器发送事件(简称:SSE)。服务器发送事件是一种HTTP标准。它允许应用程序处理单向事件流，并在服务器发送数据时接收更新。在这里，我想简单解释一下为什么我选择SSE而不是WebSockets。WebSockets提供客户端和服务器之间的双向通信，SSE提供单向通信。然而，WebSockets不是HTTP协议，不像SSE那样提供错误处理标准。</p><h1 id="5acc" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">方案</h1><p id="699c" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在我目前自己的项目中，涉及训练者和锻炼平台的实现，我已经实现了一个负责训练课程的微服务。从这个服务中，我以一个场景为例。要考虑的场景非常简单明了。</p><p id="05b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个想法是，<em class="mf">用户A </em>可以创建一个新的课程，而<em class="mf">用户B </em>将在不重新加载页面的情况下获得可用课程的更新列表。客户端组件不应该经常轮询服务。</p><p id="ffdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们需要提供以下端点:客户端可以在其中创建新课程的端点(POST)，允许客户端检索所有现有课程的端点(GET)。当然，最有趣的是:已经讨论过的SSE端点，它允许消费者流式传输事件。</p><blockquote class="mg mh mi"><p id="9758" class="jn jo mf jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated">HTTP GET/course<br/>HTTP GET/course/SSE<br/>HTTP POST/course</p></blockquote><p id="8872" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对我来说同样重要的是，我们可以用任何数据库实现这个场景。在另一个服务中，我使用了一个MongoDB，它已经通过<em class="mf"> ReactiveMongoRepository </em>提供了一个反应流实现。这意味着库已经返回了<em class="mf">Mono&lt;T&gt;T3】或<em class="mf">Flux&lt;T&gt;T5】而不是<em class="mf"> T </em>或<em class="mf">List&lt;T&gt;T9】。我将在另一篇文章中报告我使用<em class="mf">react memo repository</em>的经历。</em></em></em></p><p id="185e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在目前的服务中，我希望能够使用任何关系数据库，如MySQL、SQL Server或PostgreSQL。在我目前的项目中，我使用PostgreSQL数据库和嵌入式H2数据库进行测试。为了简单起见，在这个例子中我使用了一个嵌入式H2内存数据库。但是如前所述，数据库技术不应该在这里发挥作用。基本上任何SQL数据库都可以使用。</p><p id="f886" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们想更深入地了解如何使用Spring WebFlux让RestController发布反应流。</p><h1 id="f977" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">准备项目</h1><p id="9f1c" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">本文的整个项目可以在<a class="ae lb" href="https://github.com/bluvolve-dev/reactive-course-service" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><p id="395d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使用Publisher实现— <em class="mf"> Flux </em>和<em class="mf"> Mono </em>，我们需要为Spring WebFlux添加依赖项。这个框架在内部使用项目反应器。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="7d23" class="mr ld iq mn b gy ms mt l mu mv">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="b6f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它支持两种编程模型“基于注释的反应式组件”和“功能路由和处理”。</p><p id="9099" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从依赖spring-boot-starter-webflux开始，它包括了所有其他必要的依赖。</p><p id="6039" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还在项目中使用了以下Spring Boot入门包:</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="9545" class="mr ld iq mn b gy ms mt l mu mv">spring-boot-starter-web<br/>spring-boot-starter-validation<br/>spring-boot-starter-data-jpa</span></pre><p id="b889" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以及以下依赖关系:</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="eb0a" class="mr ld iq mn b gy ms mt l mu mv">&lt;dependency&gt;<br/>  &lt;groupId&gt;com.h2database&lt;/groupId&gt;<br/>  &lt;artifactId&gt;h2&lt;/artifactId&gt;<br/>  &lt;scope&gt;runtime&lt;/scope&gt;<br/>  &lt;version&gt;1.4.199&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.modelmapper&lt;/groupId&gt;<br/>  &lt;artifactId&gt;modelmapper&lt;/artifactId&gt;<br/>  &lt;version&gt;2.3.8&lt;/version&gt;<br/>&lt;/dependency&gt;<br/> &lt;dependency&gt;<br/>    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br/>    &lt;artifactId&gt;lombok&lt;/artifactId&gt;<br/>    &lt;optional&gt;true&lt;/optional&gt;<br/>&lt;/dependency&gt;</span></pre><p id="1aba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，项目应该已经基本准备就绪，可以运行了。</p><p id="aba2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在项目结构中，我喜欢遵循领域驱动设计的原则。这意味着项目的结构应该由领域驱动，而不是由技术方面驱动。如上所述，我们希望在这个微服务中，或者如用例中所描述的那样，关注聚合<em class="mf">过程</em>。这意味着我们需要一揽子“课程”。</p><p id="d85e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我为什么要这么做？嗯，我把“课程”包看作是一个集合。这些包中的所有实体、值对象和域服务都是具有精心设计的一致性边界的集合。</p><p id="9183" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我不会在这里用<em class="mf">领域驱动设计</em>来深入领域驱动项目结构的话题。我将为这个主题专门写一篇文章。</p><p id="fd6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以让我们创建一个新包“course”和一个名为“CourseController”的RestController。</p><p id="519e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们实现一个简单的测试端点，它给我们一个字符串来检查应用程序是否正在运行。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="d5aa" class="mr ld iq mn b gy ms mt l mu mv">@RestController<br/>public class CourseController {<br/>    @GetMapping("/")<br/>    public ResponseEntity&lt;String&gt; get(){<br/>        return ResponseEntity.<em class="mf">ok</em>().body("Course Service is running.");<br/>    }<br/>}</span></pre><p id="a968" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在启动服务。默认情况下，它运行在端口8080上。curl命令应该返回字符串“课程服务正在运行”。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="53c2" class="mr ld iq mn b gy ms mt l mu mv">curl http://localhost:8080</span></pre><h1 id="94a4" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">实施课程汇总</h1><p id="468b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">现在，让我们首先为课程聚合创建所有必要的实体和域服务。我们需要一个课程实体，包含几个属性，如标题，描述，持续时间等。每门课程必须归入一个类别。因此我们也需要范畴实体。领域服务提供方法并封装对知识库的访问，包含领域逻辑，例如如何创建课程实体的知识。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/65af9642604c307a4ec2f1cc68c51223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*rbwsKF0j5kwNtpXJ1S1WPA.jpeg"/></div></figure><p id="89d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们最终开始编码。在包<em class="mf"> course </em>中创建一个Java类“Category”和相应的JpaRepository接口，如下例所示。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">类别实体和持久性作为课程聚合的一部分。</figcaption></figure><p id="28fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">…然后当然是在同一个包中的Java类“课程”和相应的存储库。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">作为课程集合一部分的课程实体和持久性。</figcaption></figure><p id="d62e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将创建实体，并通过JpaRepositories澄清数据的持久性。现在让我们来关注一下域服务，它基本上包含了关于实体的知识，并且是逻辑层次上的一部分。</p><p id="bfb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们希望创建CategoryService。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ba6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个服务实现包含两个方法。通过目录的ID返回目录实例的人。另一个以dto的形式返回所有类别的列表。第一个是我们稍后从CreateCourse命令创建新课程时需要的。</p><p id="cb0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为在创建课程时必须指定类别，所以我们现在负责创建初始类别。我们在应用程序准备就绪时这样做，并用<em class="mf"> ApplicationListener </em>对事件<em class="mf"> ApplicationReadyEvent </em>做出反应。</p><p id="09c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只有在不存在条目的情况下，我们才会这样做。因此，我们创建了一个实现<em class="mf"> CategoryInitializer </em>，我将它放在一个名为<em class="mf"> utils </em>的新包中。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4dad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们现在启动应用程序，如果还不存在条目，那么在启动时会自动创建条目。在当前使用嵌入式H2 In-Mem DB的配置中，每次重新运行应用程序时都会发生这种情况。</p><p id="dc1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们创建<em class="mf"> CourseService </em>，它包含一个创建新课程的方法。在我们的例子中，这个方法本身并不引人注意。接受<em class="mf"> CreateCourse </em>命令，创建并保存一个新的课程实例。为了将给定的命令转换成实体，我使用了一个映射器来保持代码的干净和清晰，并避免在方法中使用许多<em class="mf">设置器</em>。映射器的实现(不是很壮观)可以在<a class="ae lb" href="https://github.com/bluvolve-dev/reactive-course-service" rel="noopener ugc nofollow" target="_blank"> GitHub </a>库中看到。<br/>有趣的是第33行，这里使用<em class="mf">application event publisher</em>创建并发布了一个名为<em class="mf"> CourseCreated </em>的<em class="mf"> ApplicationEvent </em>。作为源对象，我用even persisted <em class="mf"> Course </em>对象初始化事件。此时，也可以只添加<em class="mf">课程</em> ID，稍后在监听器实现中检索对象。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">课程服务实现—创建课程发布应用程序事件</figcaption></figure><p id="b125" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了保持聚合的清晰，我通常在聚合中构造一些东西。对于命令、事件、事件处理程序和处理器，我在聚合中创建自己的包。命令是通常由客户端通过外部边界(即REST控制器)发送的数据类。该类的名称总是遵循相同的语法，例如CreateCourse。对象本身包含客户端发送创建实体的请求所需的所有信息。</p><p id="8bf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在创建我们的第一个命令。为此，我们在package course中创建另一个命令包，并在里面创建一个新的命令类<em class="mf"> CreateCourse </em>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e146" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如<em class="mf"> CourseService </em>实现所示，方法<em class="mf"> createCourse </em>接收并处理命令。如果处理成功，则创建并发布一个事件。</p><p id="18e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里<em class="mf">课程的实现创建了</em>。事件的命名也遵循定义的语法。对于事件，我在课程聚合下面创建了一个名为<em class="mf"> events </em>的新包。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="206b" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">创建静止控制器</h1><p id="71bd" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在包课程中，我们现在创建我们的端点，这允许客户端从外部访问我们的域。从技术上来说，我们认为这是REST控制器。控制器提供不同的HTTP操作。请注意，没有域对象越过此边界。输出数据对象被映射到所谓的数据传输对象(简称:d to)。这些都是没有逻辑的简单对象，它们只包含数据，从REST的角度来看基本上代表资源。现在我们使用那篇文章开头已经创建的控制器<em class="mf"> CourseController </em>。<br/>我们添加了一个新的POST操作，它提供了新课程的创建:</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="f844" class="mr ld iq mn b gy ms mt l mu mv">@CrossOrigin<br/>@PostMapping("/course")<br/>ResponseEntity&lt;UUID&gt; addCourse(@RequestBody @Valid CreateCourse command){<br/>    <em class="mf">log</em>.info("Create new course request received. [title: {}]", command.getTitle());<br/><br/>    try{<br/>        Course course = this.courseService.createCourse(command);<br/>        return ResponseEntity.<em class="mf">created</em>(URI.<em class="mf">create</em>("/course/" + course.getId().toString())).body(course.getId());<br/>    }catch(Exception e){<br/>        <em class="mf">log</em>.error(e.getMessage());<br/>        return new ResponseEntity&lt;&gt;(HttpStatus.<em class="mf">INTERNAL_SERVER_ERROR</em>);<br/>    }<br/>}</span></pre><p id="198d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个端点接受一个与CreateCourse命令中定义的结构相匹配的JSON。</p><p id="0f99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">{ <br/> "title": "Outdoor Bootcamp "、<br/> "description ":"高强度户外体重训练"、<br/>" categoryId ":" d443c 190-dc4b-47e 8–8490-c 8011844 C7 aa "、<br/>" createdByUserId ":" 02065 d66–8f 85–4892-af53-a 09163 a 466 a 6 "、<br/> "duration": 60</p><p id="7330" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试这个命令，可以使用cURL完成下面的调用，例如。当然你也可以使用像<a class="ae lb" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>这样的UI工具。</p><p id="2ceb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">$ curl-H " Content-Type:application/JSON "-X POST-d ' { " title ":" Outdoor boot camp "，" description": "My description "，" categoryId ":" 17d 928 Fe-ac2c-4817–84fd-0830766 fefb 1 "，" createdByUserId ":" 02065d 66–8f 85–4892-af53-a 09163 a 466 a6 "，" duration": 60 }' <a class="ae lb" href="http://localhost:4500/course" rel="noopener ugc nofollow" target="_blank"> http</a></p><p id="4ef4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一篇文章中，我们将在Next.js客户机中使用这个API。</p><p id="a0e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，回复正文中提供的类别ID必须确实存在于可以创建课程的数据库中。<br/>要么从应用程序日志中复制ID。我们记得我们在启动时创建类别。或者为控制器提供另一个类别GET端点。您可以在本文的<a class="ae lb" href="https://github.com/bluvolve-dev/reactive-course-service" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>中找到这个端点的代码。</p><p id="3657" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们简要总结一下我们迄今为止所做的工作。我们已经构建了课程集合，实现了域对象和持久性，以及端点作为我们的域的入口点。<br/>我们现在可以使用REST API创建新的课程，如果成功，我们的服务实现将发布一个应用程序事件。</p><p id="dfc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么我们还遗漏了什么？正确！事件监听器和SSE端点的实现允许客户端订阅课程事件流。</p><h1 id="a5dc" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">实现服务器发送的事件端点</h1><p id="ae29" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们需要一个处理器来接收和处理<em class="mf"> CourseCreated </em>事件。为此我们创建了一个名为<em class="mf">CourseCreatedEventProcessor</em>的类，它实现了<em class="mf">application listener&lt;T&gt;、</em>和<em class="mf">Consumer&lt;flux sink&lt;T&gt;&gt;</em>。<em class="mf"> ApplicationListener </em>要求实现ApplicationEvent 上的方法<em class="mf">。消费者需要实现<em class="mf"> accept() </em>方法，该方法执行注入的执行器。</em></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0246" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，我们已经在开始时添加了依赖关系<em class="mf">spring-boot-starter-web flux</em>，我们现在将使用它。</p><p id="9d76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将与通量一起工作。我们使用<em class="mf"> create() </em>方法创建一个非阻塞流。create方法接受一个<em class="mf">flux sink&lt;T&gt;T3】消费者。每个用户现在接收一个<em class="mf"> FluxSink </em>的实例来发射元素。这意味着，只要调用了<em class="mf"> sink.next() </em>，就会发出一个新元素。</em></p><p id="db13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看控制器的实现。Flux.create()初始化是控制器构造函数的一部分。我们还需要注入一个用于创建Flux实例的<em class="mf"> CourseCreatedEventProcessor，</em>实例。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="a16a" class="mr ld iq mn b gy ms mt l mu mv">private final Flux&lt;CourseCreated&gt; events;<br/><br/>public CourseController(CourseService courseService,<br/>                        CategoryService categoryService,<br/>                        CourseCreatedEventProcessor processor,<br/>                        CourseMapper mapper) {<br/><br/>   <br/>    this.events = Flux.<em class="mf">create</em>(processor).share();<br/>    ...</span><span id="3a4b" class="mr ld iq mn b gy mz mt l mu mv">}</span></pre><p id="1180" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="mf">CourseCreatedEventProcessor</em>中，当接收到<em class="mf"> CourseCreated </em>事件时，监听器的<em class="mf"> accept() </em>方法的调用被启动。处理器实现本身负责将事件推送到调用<em class="mf">接收器</em>的流。<em class="mf">下一个()</em>。</p><p id="2f69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">唯一缺少的是我们的服务器发送的事件端点。在这里。</p><p id="c606" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们唯一要做的就是使用映射器将CourseCreated event映射到DTO。如果您愿意，也可以将事件发送给客户端，而不是DTO。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="8520" class="mr ld iq mn b gy ms mt l mu mv">@CrossOrigin()<br/>@GetMapping(value = "/course/sse", produces = "text/event-stream;charset=UTF-8")<br/>public Flux&lt;CourseDto&gt; stream() {<br/>    <em class="mf">log</em>.info("Start listening to the course collection.");<br/>    return this.events.map(event -&gt; {<br/>        CourseDto dto = this.mapper.entityToDto((Course) event.getSource());<br/>        return dto;<br/>    });<br/>}</span></pre><p id="459a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，订阅客户端能够在新数据可用时立即对通知做出反应，而不会造成阻塞。</p><p id="6423" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试它现在是如何工作的，必须执行服务。<br/>打开两个端子。其中一个将调用端点<a class="ae lb" href="http://localhost:8080/course/sse" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/course/SSE</a>。现在客户端基本上已经订阅了流。<br/>如果在第二个控制台中发出上面显示的创建新课程的命令，输出将在第一个控制台中。</p><p id="df0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也可以看演示短片。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="na my l"/></div></figure><p id="2467" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽情体验吧！</p><p id="1a8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一期，我将把这个API连接到Next.js UI客户机。那么从用户的角度来看，该效果将是可见的。</p><p id="98c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请同时阅读如何在SSR Next.js 页面上使用<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/reactive-spring-boot-api-with-next-js-client-b08147ae5712">该端点。</a></p><p id="c3ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在GitHub上找到完整的项目。欢迎反馈！</p></div></div>    
</body>
</html>