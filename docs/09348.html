<html>
<head>
<title>How to Make Changes to Past Git Commits</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何对过去的Git提交进行更改</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-make-changes-to-past-git-commits-96a2532c6184?source=collection_archive---------2-----------------------#2021-07-30">https://levelup.gitconnected.com/how-to-make-changes-to-past-git-commits-96a2532c6184?source=collection_archive---------2-----------------------#2021-07-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4caa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你不必总是承诺你的承诺</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8e937e004b7ff0075683ce773cbb818a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JVZm5B9-Yb-IAr-IUzi_zw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@ilumire" rel="noopener ugc nofollow" target="_blank"> @ilumire </a>在<a class="ae ky" href="https://unsplash.com/photos/kabtmcdcAbk" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的基础图片</figcaption></figure><p id="096f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Git是软件开发人员最重要的工具之一。它提供了一个清晰的、可追溯的代码随时间演变的历史。Git对于代码审查也是必不可少的，因为它提供了代码变更的清晰视图。保持git提交最少、清晰和简洁有助于更好地跟踪变更，并使代码审查更容易。</p><p id="57cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们的开发人员经常搞砸我们的提交，这是非常诱人的回去改变他们。在这里，我们将看一堆这样的场景，并讨论如何处理它们。</p><h2 id="e403" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">合理的警告</h2><p id="61a9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">本文中的很多例子都是关于更改提交历史的。请注意，如果您在进行这些更改之前已经推送至远程服务器，那么远程服务器将拒绝您的下一次推送。</p><p id="fe3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，您可以使用<code class="fe mt mu mv mw b">git push -f origin/branch-name</code>进行强制推送。但是，你必须确定在用力推之前没有人已经拉你的树枝。这会给他们带来问题。如果您已经将分支推送到远程服务器，那么最好再提交一次。这适用于这里的所有例子。</p><p id="ffbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想更多地了解压力会导致什么问题以及替代方法，这里的是马修·格罗夫斯<a class="mx my ep" href="https://medium.com/u/f96aa4ea1a98?source=post_page-----96a2532c6184--------------------------------" rel="noopener" target="_blank">写的一篇短小精悍的文章。</a></p><div class="mz na gp gr nb nc"><a href="https://matthew-b-groves.medium.com/matts-tidbits-23-why-to-avoid-force-pushing-691d3abbab48" rel="noopener follow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">马特的趣闻# 23——为什么要避免强迫</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">上一次，我写了一个管理活动请求代码的简便方法。本周，我想分享一些注意事项…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">matthew-b-groves.medium.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq ks nc"/></div></div></a></div><h1 id="c15d" class="nr lw it bd lx ns nt nu ma nv nw nx md jz ny ka mg kc nz kd mj kf oa kg mm ob bi translated">我在最后一次提交时遗漏了一些东西</h1><p id="4594" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我经常发现自己在最后一次提交时打错了字，或者忘记在提交消息中添加一些重要信息。类似地，我也遇到过忘记在最后一次提交时添加/存放文件的情况。</p><p id="edd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你发现自己处于类似的情况，那么你可以使用命令<code class="fe mt mu mv mw b">git commit --amend</code>。这就像一个普通的提交，除了这将修改或添加新的更改，而不是创建一个新的。</p><p id="441f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是两个需要更改上次提交的常见示例:</p><h2 id="b164" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">我在最后一条提交消息中打错了一个字</h2><p id="26ef" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，让我们看一下我们所有的提交。</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="b3b9" class="lv lw it mw b gy og oh l oi oj">&gt; git log --format=oneline<br/>025d473ccd5cbde8894f83aeb8e78a59c37fee4d (HEAD -&gt; main) commit 5<br/>97ae8ee86d41d7610634722bea4c5500d07e5545 commit 3<br/>3d6215f53c01a95e09f21707f02f9ad29d8156b6 commit 2<br/>ecec4946e855fe26bc88dc8e1e66bd0a26d81b9b commit 1</span></pre><p id="aa5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的最后一次提交，<code class="fe mt mu mv mw b">commit 5</code>实际上应该是<code class="fe mt mu mv mw b">commit 4</code>。我们可以使用下面的命令来解决这个问题。</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="7d4d" class="lv lw it mw b gy og oh l oi oj">&gt; git commit --amend -m 'commit 4'</span></pre><p id="ea73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们查看日志，我们可以看到提交消息已经被更改。</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="957c" class="lv lw it mw b gy og oh l oi oj">&gt; git log --format=oneline<br/>d62d1512c53e78763860a04a54a2491590392ded (HEAD -&gt; main) commit 4<br/>97ae8ee86d41d7610634722bea4c5500d07e5545 commit 3<br/>3d6215f53c01a95e09f21707f02f9ad29d8156b6 commit 2<br/>ecec4946e855fe26bc88dc8e1e66bd0a26d81b9b commit 1</span></pre><h2 id="482c" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">我在最后一次提交时错过了一个更改</h2><p id="2960" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，添加/暂存更改，就像您对新提交所做的那样。</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="1b45" class="lv lw it mw b gy og oh l oi oj">git add file-you-missed</span></pre><p id="87f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，提交更改，但是添加<code class="fe mt mu mv mw b">--amend</code>标志。</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="d4e2" class="lv lw it mw b gy og oh l oi oj">git commit --amend</span></pre><p id="d7a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将把您的更改添加到上次提交中，而不是创建一个新的。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h1 id="0ce4" class="nr lw it bd lx ns or nu ma nv os nx md jz ot ka mg kc ou kd mj kf ov kg mm ob bi translated">我需要撤销上一次提交</h1><p id="9bc4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我也发现自己完全需要撤销上一次犯下的错误。有时提交没有意义，有时我只是将事情提交到错误的分支。</p><p id="d001" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我在一个未提交工作的分支上工作，并且需要切换到另一个分支时，我也有意地使用它。在切换到另一个分支之前，我在当前分支上执行<code class="fe mt mu mv mw b">git commit -m "temp commit"</code>来保存我的工作。是的，我可以用<code class="fe mt mu mv mw b">git stash</code>来做这个，但是我发现这样更方便，因为这样的话变更就在同一个分支中了。</p><p id="05f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种情况下的提交历史如下所示:</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="1511" class="lv lw it mw b gy og oh l oi oj">&gt; git log --format=oneline<br/>66863cbd1d0bdf7644656b7cd30ba5093889ea48 (HEAD -&gt; feature-branch) temp commit<br/>d62d1512c53e78763860a04a54a2491590392ded commit 4<br/>97ae8ee86d41d7610634722bea4c5500d07e5545 commit 3<br/>3d6215f53c01a95e09f21707f02f9ad29d8156b6 commit 2<br/>ecec4946e855fe26bc88dc8e1e66bd0a26d81b9b commit 1</span></pre><p id="f6b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我稍后回到分支时，我显然需要删除该提交。我使用下面的命令来撤销之前的提交。</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="d259" class="lv lw it mw b gy og oh l oi oj">&gt; git reset HEAD~</span></pre><p id="8d73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们查看日志，我们可以看到提交已被撤消。</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="75c7" class="lv lw it mw b gy og oh l oi oj">&gt; git log --format=oneline<br/>d62d1512c53e78763860a04a54a2491590392ded (HEAD -&gt; feature-branch) commit 4<br/>97ae8ee86d41d7610634722bea4c5500d07e5545 commit 3<br/>3d6215f53c01a95e09f21707f02f9ad29d8156b6 commit 2<br/>ecec4946e855fe26bc88dc8e1e66bd0a26d81b9b commit 1</span></pre><p id="a62f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，<code class="fe mt mu mv mw b">HEAD</code>指的是你当前分支的尖端。这个命令告诉git重置<code class="fe mt mu mv mw b">HEAD</code>提交，这是当前分支末端的提交。</p><p id="07d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这并没有删除我在最后一次提交中所做的更改，而是从提交中删除了它们，这样我就可以继续处理它们。这在我描述的需要切换分支的场景中非常有用。</p><p id="f208" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想完全删除更改，可以使用以下命令:</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="674d" class="lv lw it mw b gy og oh l oi oj">&gt; git reset --hard HEAD~</span></pre><h2 id="f094" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">我需要撤销多个提交</h2><p id="52c5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">您也可以通过在波浪符号(<code class="fe mt mu mv mw b">~</code>)后添加要撤销的提交数量来撤销多个提交。这告诉git从当前分支的<code class="fe mt mu mv mw b">HEAD</code>或tip中删除那么多提交。</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="4f07" class="lv lw it mw b gy og oh l oi oj">git reset HEAD~1 // Undoes last commit<br/>git reset HEAD~2 // Undoes last 2 commits<br/>git reset HEAD~3 // Undoes last 3 commits. You get the idea</span></pre></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h1 id="50c4" class="nr lw it bd lx ns or nu ma nv os nx md jz ot ka mg kc ou kd mj kf ov kg mm ob bi translated">我想删除我的本地更改并同步到远程分支</h1><p id="d7e4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">有时，我在本地分支上进行多次提交，然后意识到我需要删除我的更改，只需同步回远程服务器上的内容。如果您也发现自己处于这种情况，您可以使用以下命令:</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="2564" class="lv lw it mw b gy og oh l oi oj">git reset --hard origin/branch-name</span></pre><p id="bc9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这会将本地分支重置为远程服务器上的版本。注意这一点，因为您将丢失在远程服务器上最后一次提交后所做的本地更改。</p><p id="3f9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在您忘记从主分支分支并向主分支本身添加提交的情况下尤其方便。我经常遇到这种情况。</p><p id="f203" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，您可以<code class="fe mt mu mv mw b">git branch new-branch</code>在新的分支中获得您的提交，然后<code class="fe mt mu mv mw b">git reset --hard origin/main</code>将主分支重置为remote/origin上的版本。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h1 id="715c" class="nr lw it bd lx ns or nu ma nv os nx md jz ot ka mg kc ou kd mj kf ov kg mm ob bi translated">我想恢复重置</h1><p id="f940" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">所以，你听从了我的建议，硬重置到一个远程分支，但你意识到你实际上需要那些提交回来？</p><p id="f15d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有这个提交历史。</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="a59f" class="lv lw it mw b gy og oh l oi oj">&gt; git log --format=oneline<br/>d62d1512c53e78763860a04a54a2491590392ded (HEAD -&gt; main) commit 4<br/>97ae8ee86d41d7610634722bea4c5500d07e5545 commit 3<br/>3d6215f53c01a95e09f21707f02f9ad29d8156b6 commit 2<br/>ecec4946e855fe26bc88dc8e1e66bd0a26d81b9b commit 1</span></pre><p id="b3e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们将分支重置为原点上的版本。</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="f3f4" class="lv lw it mw b gy og oh l oi oj">&gt; git reset --hard origin/main<br/>HEAD is now at 97ae8ee commit 3</span><span id="5859" class="lv lw it mw b gy ow oh l oi oj">&gt; git log --format=oneline<br/>97ae8ee86d41d7610634722bea4c5500d07e5545 (HEAD -&gt; main) commit 3<br/>3d6215f53c01a95e09f21707f02f9ad29d8156b6 commit 2<br/>ecec4946e855fe26bc88dc8e1e66bd0a26d81b9b commit 1</span></pre><p id="2939" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们意识到我们实际上在<code class="fe mt mu mv mw b">commit 4</code>有一些代码可以使用。</p><p id="5e0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，这也有一个解决方案！用<code class="fe mt mu mv mw b">git reflog</code>就行了。这个命令将给出<code class="fe mt mu mv mw b">HEAD</code>改变的时间列表。<code class="fe mt mu mv mw b">HEAD</code>创建和恢复提交和签出分支时的变化。</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="dec4" class="lv lw it mw b gy og oh l oi oj">&gt; git reflog<br/>97ae8ee (HEAD -&gt; main) HEAD@{0}: reset: moving to HEAD~<br/>d62d151 HEAD@{1}: commit: commit 4<br/>...</span></pre><p id="d3bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以运行<code class="fe mt mu mv mw b">get reset --hard &lt;hash_from_reflog_list&gt;</code>回到过去。在这个特殊的例子中，我们需要使用散列值<code class="fe mt mu mv mw b">d62d151</code>返回到<code class="fe mt mu mv mw b">commit 4</code>。这就是我们如何回到那个状态。</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="d8d1" class="lv lw it mw b gy og oh l oi oj">&gt; git reset --hard d62d151<br/>HEAD is now at d62d151 commit 4</span></pre><p id="e3eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们查看日志，我们可以看到我们又回到了提交状态。</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="22aa" class="lv lw it mw b gy og oh l oi oj">&gt; git log --format=oneline<br/>d62d1512c53e78763860a04a54a2491590392ded (HEAD -&gt; main) commit 4<br/>97ae8ee86d41d7610634722bea4c5500d07e5545 commit 3<br/>3d6215f53c01a95e09f21707f02f9ad29d8156b6 commit 2<br/>ecec4946e855fe26bc88dc8e1e66bd0a26d81b9b commit 1</span></pre><p id="75ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">reflog可用于恢复对<code class="fe mt mu mv mw b">HEAD</code>所做的几乎所有本地更改。但是，git会定期清除这个日志。所以，不要依靠这个回到过去的状态。此外，这仅适用于局部更改。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h1 id="d71b" class="nr lw it bd lx ns or nu ma nv os nx md jz ot ka mg kc ou kd mj kf ov kg mm ob bi translated">我在过去的提交中遗漏了一些东西</h1><p id="8d5a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们已经了解了如何使用<code class="fe mt mu mv mw b">git commit --amend</code>来更改提交消息或者将丢失的文件添加到最后一次提交中。然而，也有这样的情况，我们可以在提交之前添加一些东西或者使用不同的消息。</p><p id="f84d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是两个需要这样做的常见例子:</p><h2 id="ea84" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">我在过去的提交消息中打错了一个字</h2><p id="ab6f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这可能会有点复杂，所以让我们把它分成几个步骤。</p><p id="53ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.确定要重命名的提交</p><p id="2c66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们查看日志，以确定哪个提交需要重命名。</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="3b1d" class="lv lw it mw b gy og oh l oi oj">&gt; git log --format=oneline<br/>d62d1512c53e78763860a04a54a2491590392ded (HEAD -&gt; main, branch2) commit 4<br/>97ae8ee86d41d7610634722bea4c5500d07e5545 commit 3<br/>3d6215f53c01a95e09f21707f02f9ad29d8156b6 commit 2<br/>ecec4946e855fe26bc88dc8e1e66bd0a26d81b9b commit 1</span></pre><p id="f098" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经确定，出于某种原因，我们希望将<code class="fe mt mu mv mw b">commit 2</code>重命名为<code class="fe mt mu mv mw b">commit 2 changed</code>。为此，我们需要在<code class="fe mt mu mv mw b">commit 2</code>之前获得一些提交的散列。在这种情况下，那就是<code class="fe mt mu mv mw b">commit 1</code>。</p><p id="07f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.开始一个交互式的rebase</p><p id="151b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们需要运行<code class="fe mt mu mv mw b">git rebase -i &lt;hash_of_commit_1&gt;</code>。这将打开一个编辑器，其中包含我们所针对的提交之后的所有提交。编辑器的内容会是这样的:</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="9275" class="lv lw it mw b gy og oh l oi oj">pick 3d6215f commit 2<br/>pick 97ae8ee commit 3<br/>pick d62d151 commit 4</span></pre><p id="7920" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正常的rebase标识了我们当前分支和我们指定的目标提交或分支之间的共同祖先。在这个例子中，共同的祖先是<code class="fe mt mu mv mw b">commit 1</code>本身。然后，它在该提交之上重新应用来自当前分支的所有进一步的提交。</p><p id="5f73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rebases通常与分支一起使用。然而，我们也可以将<code class="fe mt mu mv mw b">rebase</code>直接用于提交散列。</p><p id="cd54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们使用来自我们所在的同一个分支的提交来重新确定基础时，它将简单地重新应用目标提交之后的所有提交。这与<code class="fe mt mu mv mw b">-i</code>标志相结合，使得在当前分支中修改过去的提交成为可能。</p><p id="9025" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mt mu mv mw b">-i</code>标志将开始一个交互式的重置基础。交互式rebase允许我们重新安排受rebase影响的提交，甚至选择对每个提交执行的操作。其中一项行动是<code class="fe mt mu mv mw b">reword</code>。</p><p id="16be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.告诉git您想要改写提交消息</p><p id="0c98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们需要把<code class="fe mt mu mv mw b"><em class="ox">pick</em> 3d6215f commit 2</code>改成<code class="fe mt mu mv mw b"><em class="ox">reword</em> 3d6215f commit 2</code>。不，在这里更改提交消息将不起作用。这里的消息只是为了让用户更容易识别提交。在我们将所有想要重命名的提交的<code class="fe mt mu mv mw b">pick</code>更改为<code class="fe mt mu mv mw b">reword</code>之后，我们需要保存文件并退出。</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="fb5e" class="lv lw it mw b gy og oh l oi oj">reword 3d6215f commit 2<br/>pick 97ae8ee commit 3<br/>pick d62d151 commit 4</span></pre><p id="354e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.更改提交消息</p><p id="56ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Git将为我们运行所有的提交，当它到达任何有命令<code class="fe mt mu mv mw b">reword</code>的提交时，它将给我们一个机会来更改提交消息。重定基础过程完成后，我们可以查看日志来查看更改。</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="006e" class="lv lw it mw b gy og oh l oi oj">&gt; git log --format=oneline<br/>201238ccd35d33dc481031bc935245cc367d0133 (HEAD -&gt; main) commit 4<br/>13bfa0c56b59b87a40fc2d87b17c9511bf070539 commit 3<br/>e021011d384ddaca6562e16328888304797fa6ef commit 2 changed<br/>ecec4946e855fe26bc88dc8e1e66bd0a26d81b9b commit 1</span></pre><h2 id="5357" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">我错过了过去提交中的更改</h2><p id="46a2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这几乎和更改提交的名称一样复杂。所以，让我们再一次把它分成几个步骤:</p><p id="62d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.标识要添加更改的提交</p><p id="6021" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们查看日志，以确定需要添加哪个提交。</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="2877" class="lv lw it mw b gy og oh l oi oj">&gt; git log --format=oneline<br/>201238ccd35d33dc481031bc935245cc367d0133 (HEAD -&gt; main) commit 4<br/>13bfa0c56b59b87a40fc2d87b17c9511bf070539 commit 3<br/>e021011d384ddaca6562e16328888304797fa6ef commit 2 changed<br/>ecec4946e855fe26bc88dc8e1e66bd0a26d81b9b commit 1</span></pre><p id="973a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想将丢失的文件提交给<code class="fe mt mu mv mw b">commit 2 changed</code>。</p><p id="0fb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.使用<code class="fe mt mu mv mw b">--squash</code>提交丢失的文件</p><p id="9ddd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在必须使用<code class="fe mt mu mv mw b">git commit --squash &lt;commit-to-amend-changes-to&gt;</code>提交我们的更改。在这种情况下，我们必须使用<code class="fe mt mu mv mw b">commit 2 changed</code>的hash。这将创建一个新的提交。</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="6bfa" class="lv lw it mw b gy og oh l oi oj">&gt; git add missed-change-file</span><span id="3bf1" class="lv lw it mw b gy ow oh l oi oj">&gt; git commit --squash e021011d384ddaca6562e16328888304797fa6ef<br/>[main 51874fe] squash! commit 2 changed<br/> 1 file changed, 1 insertion(+)<br/> create mode 100644 missed-change-file</span></pre><p id="201f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看日志应该会向我们展示在顶部创建的新提交。</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="db09" class="lv lw it mw b gy og oh l oi oj">&gt; git log --format=oneline<br/>51874fe7a64856c2fa0dbd6327649ccb414ce7fb (HEAD -&gt; main) squash! commit 2 changed<br/>201238ccd35d33dc481031bc935245cc367d0133 commit 4<br/>13bfa0c56b59b87a40fc2d87b17c9511bf070539 commit 3<br/>e021011d384ddaca6562e16328888304797fa6ef commit 2 changed<br/>ecec4946e855fe26bc88dc8e1e66bd0a26d81b9b commit 1</span></pre><p id="eead" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，这并没有增加我们的目标承诺，但我们将在下一步中做到这一点。</p><p id="27b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.用目标提交挤压新提交</p><p id="c6b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要做的是将新的提交移到<code class="fe mt mu mv mw b">commit 2 changed</code>之后，然后将这两个提交放在一起。挤压就是将两次提交合并为一次提交的行为。</p><p id="3f98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，git可以自动为我们完成这项工作，因为我们使用<code class="fe mt mu mv mw b">commit --squash</code>标记了自动压缩的提交。我们首先需要在<code class="fe mt mu mv mw b">commit 2 changed</code>之前获得一些提交的散列。在我们的例子中，我们可以使用<code class="fe mt mu mv mw b">commit 1</code>。然后我们可以运行<code class="fe mt mu mv mw b">git rebase --autosquash -i &lt;hash_of_commit_1&gt;</code>。</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="5ba0" class="lv lw it mw b gy og oh l oi oj">git rebase --autosquash -i ecec4946e855fe26bc88dc8e1e66bd0a26d81b9b</span></pre><p id="569c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将打开一个编辑器，我们的新提交被移动到<code class="fe mt mu mv mw b">commit 2</code>附近，而不是原来的位置。这就是我们使用<code class="fe mt mu mv mw b">--autosquash</code>的原因。</p><pre class="kj kk kl km gt oc mw od oe aw of bi"><span id="71b9" class="lv lw it mw b gy og oh l oi oj">pick e021011 commit 2 changed<br/>squash 51874fe squash! commit 2 changed<br/>pick 13bfa0c commit 3<br/>pick 201238c commit 4</span></pre><p id="1a62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们没有指定<code class="fe mt mu mv mw b">--autosquash</code>标志，提交的顺序会有所不同。我们现在可以简单地保存并关闭编辑器。</p><p id="eb05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过使用交互式rebase ( <code class="fe mt mu mv mw b">-i</code>)而不使用<code class="fe mt mu mv mw b">--autosquash</code>来手动完成，然后移动提交。不过，<code class="fe mt mu mv mw b">--autosquash</code>只是更方便而已。</p><p id="1db4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.让提交发生</p><p id="a26a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Git现在将遍历列表中的所有提交。当它到达我们挤压的提交时，它将提示我们输入一个提交消息。如果需要，我们可以在这里更改提交消息。</p><p id="458b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们希望保留原始的提交消息，并且不被提示输入，那么我们可以在步骤2中使用<code class="fe mt mu mv mw b">--fixup</code>而不是squash。不过，<code class="fe mt mu mv mw b">rebase</code>还是会用<code class="fe mt mu mv mw b">--autosquash</code>。这对挤压和修正都有效。没有叫<code class="fe mt mu mv mw b">--autofixup</code>的旗。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h1 id="3e88" class="nr lw it bd lx ns or nu ma nv os nx md jz ot ka mg kc ou kd mj kf ov kg mm ob bi translated">参考资料:</h1><ul class=""><li id="7ae9" class="oy oz it lb b lc mo lf mp li pa lm pb lq pc lu pd pe pf pg bi translated">Git Rebase文档:<a class="ae ky" href="https://git-scm.com/docs/git-rebase" rel="noopener ugc nofollow" target="_blank">https://git-scm.com/docs/git-rebase</a></li><li id="1998" class="oy oz it lb b lc ph lf pi li pj lm pk lq pl lu pd pe pf pg bi translated">Git提交文档:<a class="ae ky" href="https://git-scm.com/docs/git-commit" rel="noopener ugc nofollow" target="_blank">https://git-scm.com/docs/git-commit</a></li><li id="3b03" class="oy oz it lb b lc ph lf pi li pj lm pk lq pl lu pd pe pf pg bi translated">Git Reflog文档:<a class="ae ky" href="https://git-scm.com/docs/git-reflog" rel="noopener ugc nofollow" target="_blank">https://git-scm.com/docs/git-reflog</a></li></ul></div></div>    
</body>
</html>