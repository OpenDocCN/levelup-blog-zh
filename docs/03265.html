<html>
<head>
<title>JavaScript Closures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript闭包</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-closures-eb6961375bbd?source=collection_archive---------12-----------------------#2020-04-28">https://levelup.gitconnected.com/javascript-closures-eb6961375bbd?source=collection_archive---------12-----------------------#2020-04-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a19c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个秘密的魔术袋</h2></div><p id="bd23" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript闭包的概念可能有点难以理解。当一个函数返回另一个函数时，通常使用闭包。它们背后的神奇之处在于，即使返回了一个函数，从而消除了调用函数和它的局部变量，返回的函数仍然保留了被删除环境的“记忆”,包括被破坏的局部变量，并且可以像它们仍然存在一样使用它们🤯</p><p id="bf83" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们通过分解下面的代码来揭开闭包的神秘面纱:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="530d" class="lk ll iq lg b gy lm ln l lo lp">1:  var add = (function () {<br/>2:    var counter = 0;<br/>3:    return function () {counter += 1; return counter}<br/>4:  })();<br/>5:  const increment1 = add();<br/>6:  const increment2 = add();<br/>7:  const increment3 = add();<br/>8:  console.log('increments: ', increment1, increment2, increment3); // output -&gt; increments:  1 2 3</span></pre><p id="5034" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lq">代码取自</em> <a class="ae lr" href="https://www.w3schools.com/js/js_function_closures.asp" rel="noopener ugc nofollow" target="_blank"> <em class="lq"> w3schools的JavaScript闭包</em> </a> <em class="lq">页面，修改后增加了一个</em> <code class="fe ls lt lu lg b">console.log</code></p><p id="28b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在运行任何脚本之前，全局执行上下文(GEC)被推入<a class="ae lr" href="https://medium.com/swlh/javascript-execution-order-e1bebc3976ca" rel="noopener">调用堆栈</a>。</p><figure class="lb lc ld le gt lw gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/d7eab677a2c4f53dd4072ae1bfc5b6fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*q4ziUf4ne1lr6qRqQo_syA.png"/></div></figure><p id="375f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">脚本运行，在GEC中创建变量<code class="fe ls lt lu lg b">add</code>及其函数表达式。注意，分配给<code class="fe ls lt lu lg b">add</code>的函数是一个立即调用的函数表达式(IIFE ),它返回一个匿名函数:<code class="fe ls lt lu lg b">function() {counter += 1; return counter}</code></p><figure class="lb lc ld le gt lw gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/93ca5dd7c2b90d98d3bc2ab611af27e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*XLhdU018la4k_HNC6Wawiw.png"/></div></figure><p id="d3de" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lq">有意思…为什么要这样写函数？嗯……为什么不直接把</em> <code class="fe ls lt lu lg b">add</code> <em class="lq">设置成等于一个定义为</em> <code class="fe ls lt lu lg b">counter += 1; return counter</code> <em class="lq">的函数，而不是让它等于一个返回那个函数的生命。事实上，你可以在函数之外定义</em> <code class="fe ls lt lu lg b">counter</code> <em class="lq">并像这样重写函数，输出也是一样的。</em></p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="7ae8" class="lk ll iq lg b gy lm ln l lo lp">var counter = 0;<br/>var add = function() {<br/>  counter += 1;<br/>  return counter;<br/>};</span></pre><p id="c8ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">敏锐的观察力侦探。让我们继续沿着黄砖路走下去，看看这次冒险还会把我们带到哪里。</p><p id="5ddf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，在这一点上，更多的JavaScript魔法出现了。生命，顾名思义，一旦被定义，就会被调用。这意味着<code class="fe ls lt lu lg b">var add</code>现在实际上等于<code class="fe ls lt lu lg b">function() {counter =+ 1; return counter}</code>。噗，就这样，生命消失了…哦，有意思…但是现在也消失了。</p><figure class="lb lc ld le gt lw gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/fc9159f2c15148da4c21be55fc835ca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*DN8clxW37A91kqUPUa825w.png"/></div></figure><p id="0dc9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，当我们可以像前面提到的那样写出函数的时候，为什么还要钻牛角尖呢？</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="2873" class="lk ll iq lg b gy lm ln l lo lp">var counter = 0;<br/>var add = function() {<br/>  counter += 1;<br/>  return counter;<br/>};</span></pre><p id="3707" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lq">这个简单多了，也更容易理解。另外，对于life，</em> <code class="fe ls lt lu lg b"><em class="lq">counter</em></code> <em class="lq">看起来好像从来没有声明过。它如何执行而不导致错误呢？</em></p><p id="92a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两个伟大的问题。是的，像这样重写代码会更容易理解，而且它仍然会产生预期的结果。但是声明<code class="fe ls lt lu lg b">counter</code>的方式使它成为一个全局变量。我们只希望它可以被<code class="fe ls lt lu lg b">add</code>函数访问。以这种方式重写它会污染全局范围，并使其他函数无法访问和修改它。我们试图避免这两种情况。</p><p id="c12b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，这个怎么样？</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b1b3" class="lk ll iq lg b gy lm ln l lo lp">var add = function() {<br/>  var counter = 0;<br/>  counter += 1;<br/>  return counter;<br/>}</span></pre><p id="2957" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lq">哦等等，那会在每次调用的时候把</em> <code class="fe ls lt lu lg b">counter</code> <em class="lq">重置为</em> <code class="fe ls lt lu lg b">0</code> <em class="lq">。好吧，我看到了缺点，所以告诉我更多关于这里发生了什么… </em></p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="d69a" class="lk ll iq lg b gy lm ln l lo lp">var add = function() {<br/>  counter += 1;<br/>  return counter<br/>};</span></pre><p id="487a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了，所以IIFE执行并返回一个函数，这个函数将<code class="fe ls lt lu lg b">counter</code>增加<code class="fe ls lt lu lg b">1</code>，然后返回它。生命不再存在，它的局部变量也不再存在，或者看起来如此。返回函数的神奇之处在于，即使在它被销毁之后，它还记得它的环境，包括局部变量，并且可以继续使用它们。因此，在我们的例子中，<code class="fe ls lt lu lg b">counter</code>在生命的身体中被宣告，一旦被执行，宣告就消失了。然而，返回的函数会记住<code class="fe ls lt lu lg b">counter</code>的声明，即使它已经不在全局执行上下文中。通常，当一个函数触发并需要找到它所操作的变量的值时，它会首先检查它的局部作用域，然后是它的父作用域，然后是它的祖父作用域……一直到它到达全局作用域。这被称为作用域链。然而当<code class="fe ls lt lu lg b">add</code>触发时，在检查它的局部范围之前，它将首先检查它的<em class="lq">秘密锦囊</em>。果然，它会在里面找到<code class="fe ls lt lu lg b">counter</code>。</p><p id="9127" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当第5行调用<code class="fe ls lt lu lg b">add</code>时，会看到<code class="fe ls lt lu lg b">counter</code>最初被赋给了<code class="fe ls lt lu lg b">0</code>。然后将<code class="fe ls lt lu lg b">counter</code>的值增加<code class="fe ls lt lu lg b">1</code>，并在设置<code class="fe ls lt lu lg b">increment1 = 1</code>时返回其值。</p><p id="929c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当它在第6行被调用时，它将再次检查它的<em class="lq">锦囊</em>并看到<code class="fe ls lt lu lg b">counter</code>现在是<code class="fe ls lt lu lg b">1</code>，增加并再次返回它，并分配<code class="fe ls lt lu lg b">increment2 = 2</code> …</p><p id="afae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…下一行依此类推。所有的<code class="fe ls lt lu lg b">add</code>函数都已执行并从堆栈中弹出。<code class="fe ls lt lu lg b">console.log</code>运行并最终输出<code class="fe ls lt lu lg b">increments: 1 2 3</code>。</p><p id="98a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以通过使用Chrome浏览器开发工具中的控制台来查看你的<em class="lq">锦囊</em>，也称为<em class="lq">闭包范围</em>。只需将闭包传递给console.dir()并展开[[Scopes]]属性。</p><figure class="lb lc ld le gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lz"><img src="../Images/a95d3a0ceeb005a05e8f1599c71f1097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j73okazE_QNM7eu_78_toA.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">眼见为实</figcaption></figure><p id="6a6a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lq">关闭功能</em>拥有魔法能力。它们能够封装从堆栈中弹出的数据，将它们保存在比普通函数更深的层次上，并且独占地使用它们，而不用担心它们已经被任何其他函数✨触及💫✨</p></div></div>    
</body>
</html>