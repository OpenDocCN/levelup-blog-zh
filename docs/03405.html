<html>
<head>
<title>Lessons in Ruby OOP: Protected Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby OOP课程:受保护的方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lessons-in-ruby-oop-protected-methods-d469bbf03b60?source=collection_archive---------11-----------------------#2020-05-06">https://levelup.gitconnected.com/lessons-in-ruby-oop-protected-methods-d469bbf03b60?source=collection_archive---------11-----------------------#2020-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e06b1606311c4ab1caea9865a1bb68f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tk-5hD6WJubrHwqftJss4A.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@bonniekdesign?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Bonnie Kittle </a>在<a class="ae kf" href="https://unsplash.com/s/photos/fence?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a7f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我之前在说过的<a class="ae kf" href="https://medium.com/@callie_buruchara/lessons-in-ruby-oop-duck-typing-2ced1809ca76" rel="noopener">，涉水通过</a><a class="ae kf" href="https://launchschool.com/" rel="noopener ugc nofollow" target="_blank">启动学校</a>的RB120和面向对象编程范式是同时压倒一切和大开眼界。我意识到我们必须首先“艰难地”学习RB101中的一切，但获得OOP如此荣耀地提供的所有工具和更好地为我的大脑组织也是非常美妙的。</p><p id="b25e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管如此，这仍然是一个很大的飞跃。当我在为RB129评估学习时，我一直停留在受保护的方法上。我理解私有方法的需要和公共方法的使用；但是这个明显必要的中间地带的目的是什么呢？</p><p id="84fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们明确讨论受保护的方法之前，先讨论一下方法访问控制的目的是有帮助的。</p><p id="f405" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">封装是OOP编码范例的众多好处之一，它允许我们，代码的作者，隐藏代码功能的某些部分，然后只暴露我们有意选择的部分。方法访问控制——使用公共、私有或受保护的方法——是我们用来实现意图的工具。</p><p id="3081" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们首先展示过程化编程是如何缺乏这种封装的(对比是清晰之母！).看看下面的代码:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">特别感谢我的朋友Stephen用这种方式向我解释了封装！(显然是从<a class="ae kf" href="https://medium.com/@mattdjohnston92/towards-a-conceptual-model-of-object-oriented-programming-118eb971659f" rel="noopener">马特</a>那里学来的！所以谢谢你，马特！)</figcaption></figure><p id="07dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe lk ll lm ln b">line 1</code>时刻，我们初始化局部变量<code class="fe lk ll lm ln b">person</code>，并将其赋给<code class="fe lk ll lm ln b">'Sally'</code>。我们可以立即在<code class="fe lk ll lm ln b">line 2</code>上输出它——也就是说，没有任何东西保护它或阻止我们访问它。在<code class="fe lk ll lm ln b">line 5</code>上，我们看到我们甚至可以改变变量的值。同样，没有任何东西可以保护这个局部变量不被访问或操纵。对于一个更复杂的程序，我们会遇到作用域问题，这可能会阻止我们操作变量，但这更多的是初始化位置的结果，而不是有意的保护。</p><p id="4bbc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想保护<code class="fe lk ll lm ln b">person</code>呢？如果我们想使用它的功能，但不让任何人直接看到它，或者至少不改变它，会怎么样？</p><p id="0426" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">进入OOP！(提示英雄音乐)</p><p id="c801" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">封装允许我们有意隐藏或暴露代码的功能。我们可以做出有意识的选择，而不是让一切暴露和脆弱。</p><p id="dc2f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们在代码中引入类，就会发生这种情况:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="e53d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的<code class="fe lk ll lm ln b">Person</code>类中，我们使用我们的构造函数(<code class="fe lk ll lm ln b">initialize</code>)来接收一个参数，并将其分配给新的<code class="fe lk ll lm ln b">Person</code>对象的<code class="fe lk ll lm ln b">@name</code>实例变量。现在，如果我们想要访问那个<code class="fe lk ll lm ln b">name</code>，我们必须有意识地创建一个这样做的方法。我们还没有，所以<code class="fe lk ll lm ln b">line 8</code>没有给我们名字。但是如果我们这样做:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="a812" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe lk ll lm ln b">line 2</code>上，我们用<code class="fe lk ll lm ln b">attr_reader</code>创建了一个getter方法。我们现在可以访问我们的<code class="fe lk ll lm ln b">Person</code>对象的名称，因为我们有意地为我们创建了一个这样做的方法。太好了！</p><p id="2b61" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是假设我们有一个更复杂的例子。我们有想在实例方法中使用的代码，但是我们不希望它被代码库的其余部分访问。例如:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="2350" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们有一个<code class="fe lk ll lm ln b">Dog</code>类，它有一个<code class="fe lk ll lm ln b">older?</code>实例方法来比较两个对象的年龄。这段代码运行良好！</p><p id="b26f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果我们不想让世界知道<code class="fe lk ll lm ln b">sadie</code>的年龄呢？她长大了，她是一个自我意识很强的人，所以我们想尊重她的隐私。我们仍然想知道她是否比另一只狗大，但是我们不需要知道她的确切年龄。我们可以把那部分留给神秘。</p><p id="b586" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们想要隐私，我们可能会尝试使用<code class="fe lk ll lm ln b">private</code>关键字。然而，如果我们这样做，我们将无法在<code class="fe lk ll lm ln b">line 8</code>上调用<code class="fe lk ll lm ln b">other</code>上的<code class="fe lk ll lm ln b">age</code>。为什么？因为使用<code class="fe lk ll lm ln b">private</code>方法，你不能在一个显式调用者上使用它们(其中<code class="fe lk ll lm ln b">other</code>正试图成为一个显式调用者)。因此，既然我们(a)想在一个显式调用者的类内部使用<code class="fe lk ll lm ln b">age</code> getter方法，并且(b)不想在类外部使用<code class="fe lk ll lm ln b">age</code> getter方法，我们可以使用……<code class="fe lk ll lm ln b">protected</code>方法！</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="a8fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以随心所欲了。</p><p id="8f71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总之，<code class="fe lk ll lm ln b">protected</code>方法是封装的一部分，它们允许你像在类中使用<code class="fe lk ll lm ln b">public</code>方法一样使用方法(可以在显式调用者中使用它们，等等)。)，它们将限制访问，并被视为类外的<code class="fe lk ll lm ln b">private</code>方法。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><p id="e15d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望这有所帮助！。如果你是<a class="ae kf" href="http://launchschool.com" rel="noopener ugc nofollow" target="_blank"> Launch School </a>的学生，并且想讨论这些概念或者OOP中的任何东西，请随时联系我！向前向上，同学们。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><p id="fb9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[1]从Ruby 2.7开始，你可以在一个显式的接收者上调用私有方法，但前提是那个接收者是<code class="fe lk ll lm ln b">self</code>…但那是另一篇文章了</p></div></div>    
</body>
</html>