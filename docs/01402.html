<html>
<head>
<title>Quirks in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript中的怪癖</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/comparison-in-javascript-25e7569f7417?source=collection_archive---------2-----------------------#2019-12-23">https://levelup.gitconnected.com/comparison-in-javascript-25e7569f7417?source=collection_archive---------2-----------------------#2019-12-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fe91" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">语言中的一些怪癖，以及如何理解它们</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bbbab6fc99628470add15052bb51d73c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-25KB7EbSHjv70HXrdl6w.png"/></div></div></figure><p id="7cfb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在过去的一周里，我一直在学习Javascript，并且遇到了许多在开始时似乎没有意义的事情，但是一旦你理解了Javascript在幕后是如何工作的，以后就明白了。我在这里列出了其中的一些，以及我自己对正在发生的事情的解释，以帮助你更好地理解。我们将讨论使用<code class="fe ln lo lp lq b">==</code>和<code class="fe ln lo lp lq b">===</code>的宽松与严格比较。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">啊！所以，这就是Javascript的工作方式…</figcaption></figure><h1 id="fbf9" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">比较数值</h1><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="994c" class="mt ly iq lq b gy mu mv l mw mx">let a = '2';<br/>let b = 1;</span><span id="4ac1" class="mt ly iq lq b gy my mv l mw mx">console.log(a &gt; b); // this prints true</span></pre><p id="b8d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从上面的例子中，我们可以看到我们正在比较两个不同数据类型的变量，一个字符串“2”和一个数字1。但是，JS仍然能够计算出2大于1，并将结果返回为<em class="mz"> true </em>。这是因为在比较不同类型的值时，JS会将值转换为数字，然后进行比较。在上面的例子中，字符串“2”首先被转换为数字2，然后与数字1进行比较。这导致语句返回<em class="mz">真值</em>。</p><h1 id="ee31" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">比较布尔值</h1><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="18a6" class="mt ly iq lq b gy mu mv l mw mx">console.log(true == 1); // this prints true</span><span id="353e" class="mt ly iq lq b gy my mv l mw mx">console.log(false == 0); // this prints true</span></pre><p id="9d2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，<em class="mz">真</em>等于1，<em class="mz">假</em>等于0，在它们各自的数字转换中。一个很好的经验法则是记住所有真值都转换为数字1，所有假值都转换为数字0。</p><p id="5689" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们来看看上面两个例子的一个有趣的结果。考虑下面的代码</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="14c8" class="mt ly iq lq b gy mu mv l mw mx">let a = 0;<br/>let b = "0";</span><span id="5711" class="mt ly iq lq b gy my mv l mw mx">console.log(Boolean(a) == Boolean(b)); // this prints false<br/>console.log(a == b); // but this prints true</span></pre><p id="4122" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">布尔(a) =布尔(0)，这等同于<em class="mz">假</em>，因为0是一个假值。Boolean(b) = Boolean("0 ")，这等同于<em class="mz"> true </em>，因为任何非空字符串都是真值。</p><p id="807e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，(Boolean(a) == Boolean(b)返回<em class="mz">假</em>。</p><p id="4e91" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，a == b返回<em class="mz"> true </em>，因为b的“0”值被转换为数字0，然后与a的0值进行比较</p><h1 id="ef97" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">严格等式问题</h1><p id="ed77" class="pw-post-body-paragraph kr ks iq kt b ku na jr kw kx nb ju kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">比较几个值时使用<code class="fe ln lo lp lq b">==</code>有一个问题。</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="1999" class="mt ly iq lq b gy mu mv l mw mx">console.log(false == 0); // this prints true<br/>console.log(false == ''); // this prints true</span></pre><p id="998e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，<code class="fe ln lo lp lq b">==</code>运算符无法区分<em class="mz">假</em>和0，因为它们都是假值，并且在数字转换中等于0。同样适用于<em class="mz">假</em>和空串。</p><p id="12ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的难题可以通过使用三重等于(<code class="fe ln lo lp lq b">===</code>)运算符来解决。三重等于和二重等于运算符之间的区别在于，前者在比较之前不进行任何隐式类型转换。换句话说，</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="7626" class="mt ly iq lq b gy mu mv l mw mx">console.log(false == 0); // this prints true<br/>console.log(false === 0); // this prints false</span></pre><p id="1e6e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的例子中，第二条语句将<em class="mz"> false </em>直接与0进行比较。因此，语句的结果打印为<em class="mz">假</em>。</p><p id="c7f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当使用<code class="fe ln lo lp lq b">===</code>操作符时，不同数据类型的值之间的任何比较默认返回false。这同样适用于<code class="fe ln lo lp lq b">!==</code>。</p><h1 id="417a" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">比较null和undefined</h1><p id="4838" class="pw-post-body-paragraph kr ks iq kt b ku na jr kw kx nb ju kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">在Javascript中，<em class="mz"> null </em>和<em class="mz"> undefined </em>有一种怪异的关系。我猜这是由于Javascript在早期的构建方式。然而，让我指出一些可能让初学者感到困惑的差异。考虑下面的代码</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="a6b8" class="mt ly iq lq b gy mu mv l mw mx">console.log(null === undefined); // this prints false<br/>console.log(null == undefined); // this prints true</span></pre><p id="5cb3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mz"> null </em>和<em class="mz"> undefined </em>在Javascript中是不同的数据类型，因此第一条语句输出false。但是，我们可以看到第二条语句打印的是<em class="mz"> true </em>。根据我们在本文前面讨论的，当使用<code class="fe ln lo lp lq b">==</code>操作符比较两个值时，Javascript首先尝试将值转换成它们的数字表示。<em class="mz">空</em>变为0<em class="mz">未定义</em>变为<em class="mz"> NaN </em>。虽然0不等于<em class="mz"> NaN </em>，但是我们发现<code class="fe ln lo lp lq b">null == undefined</code>仍然返回为true。这是一个特殊的规则(或者也许是错误？)允许在<em class="mz"> null </em>和<em class="mz"> undefined </em>之间存在这样的关系。</p><p id="fa29" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，这只适用于<code class="fe ln lo lp lq b">==</code>操作员。当比较null和undefined时，所有其他运算符都返回false。</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="1a42" class="mt ly iq lq b gy mu mv l mw mx">console.log(null &gt; undefined); // this prints false<br/>console.log(null &lt; undefined); // this prints false<br/>console.log(null &gt;= undefined); // this prints false<br/>console.log(null &lt;= undefined); // this prints false</span></pre><h1 id="5447" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">10 &gt; 9可由&lt; “9”</h1><p id="738b" class="pw-post-body-paragraph kr ks iq kt b ku na jr kw kx nb ju kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">When comparing numbers in Javascript, the logic differs on whether we are comparing their <em class="mz">数字</em>或<em class="mz">字符串</em>表示。以<em class="mz">号</em>为例，逻辑和现实生活中差不多。</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="53d8" class="mt ly iq lq b gy mu mv l mw mx">10 &gt; 9; // this returns true;<br/>"10" &gt; "9"; // this returns false;</span></pre><p id="7a6c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，当使用<em class="mz">字符串</em>版本时，我们注意到了一些不同。“10”不大于“9”。这样做的原因是，当Javascript比较字符串时，它会将它们转换为ASCII表示，并比较它们的值。您可以使用<em class="mz"> charCodeAt() </em>函数查看“10”和“9”的ASCII码。</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="64ad" class="mt ly iq lq b gy mu mv l mw mx">"10".charCodeAt(0); // this returns 49<br/>"9".charCodeAt(0); // this returns 57</span></pre><p id="07a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于ASCII码“10”是49，小于ASCII码“9”的57，因此它被认为是较小的值。</p><p id="92e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">附言:我会在这篇文章中更新我遇到的其他怪癖。到那时，快乐的编码！</p></div></div>    
</body>
</html>