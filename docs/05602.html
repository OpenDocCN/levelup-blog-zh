<html>
<head>
<title>Understanding setTimeout()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解setTimeout()</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-settimeout-15c7de9e5fd6?source=collection_archive---------3-----------------------#2020-09-14">https://levelup.gitconnected.com/understanding-settimeout-15c7de9e5fd6?source=collection_archive---------3-----------------------#2020-09-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="959e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如果您不了解setTimeout()的工作原理，它可能会产生意想不到的结果。让我们了解一下，成为setTimeout()忍者。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c666309b11b9b1ad0c1cba99d5838eb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d1toPrJw7r997SR0s8AHhA.png"/></div></div></figure><h2 id="4620" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">setTimeout()</h2><p id="7a4e" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">它是JavaScript中延迟代码执行的函数。</p><h2 id="6a4b" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">setTimeout()的组成部分:</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/f577ed9ed60fbaa6b4b49ebab611d583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lGFOQJA-saE2QzsP3UMxlw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">setTimeout()的组成部分</figcaption></figure><p id="212f" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly ld mq ma mb lh mr md me ll ms mg mh mi im bi translated">SetTimeout有3个部分:</p><ul class=""><li id="9e83" class="mt mu it ls b lt mo lw mp ld mv lh mw ll mx mi my mz na nb bi translated">回收</li><li id="82e2" class="mt mu it ls b lt nc lw nd ld ne lh nf ll ng mi my mz na nb bi translated">要在回调内部执行的语句</li><li id="f819" class="mt mu it ls b lt nc lw nd ld ne lh nf ll ng mi my mz na nb bi translated">以毫秒计的时间(延迟时间)</li></ul><p id="d2c9" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly ld mq ma mb lh mr md me ll ms mg mh mi im bi translated">上面的代码在1秒(1000ms = 1s)后在终端中打印“Hello”和“Bye”。</p><p id="d2ef" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly ld mq ma mb lh mr md me ll ms mg mh mi im bi translated">似乎很容易吧！但是如果我们不知道setTimeout()在幕后的行为，我们可能会得到一些意想不到的行为。</p><h2 id="8fca" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">例1 </strong>:单次setTimeout()</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="ff1b" class="ku kv it nk b gy no np l nq nr"><strong class="nk iu">Output</strong>:</span><span id="82e5" class="ku kv it nk b gy ns np l nq nr">Sum = 3<br/>1 2</span></pre><p id="b42a" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly ld mq ma mb lh mr md me ll ms mg mh mi im bi translated"><strong class="ls iu">解释</strong>:在上面的例子中setTimeout()有1秒的延迟。因此，我们首先得到总和，1秒钟后得到变量“a”和“b”的值。</p><h2 id="00fe" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">示例2:阻塞与非阻塞</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="f97a" class="ku kv it nk b gy no np l nq nr"><strong class="nk iu">Output</strong>:</span><span id="7427" class="ku kv it nk b gy ns np l nq nr">We are learning setTimeout<br/>10<br/>20<br/>30<br/>Statements outside are blocking<br/>After 1 second<br/>3<br/>Statements inside are non-blocking</span></pre><p id="a81a" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly ld mq ma mb lh mr md me ll ms mg mh mi im bi translated"><strong class="ls iu">解释</strong> : setTimeout()是<strong class="ls iu">非阻塞</strong>，这意味着它将在它之外的语句执行后运行，一秒钟后执行。不属于setTimeout()的所有其他语句都被<strong class="ls iu">阻塞</strong>，这意味着在当前语句结束之前不会执行任何其他语句。下图显示了阻塞和非阻塞语句。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/67e6ee0466a2b649bb9d26a89be56c58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0dW1776NTheoaMpSvnSvvQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">阻塞语句与非阻塞语句</figcaption></figure><p id="55b5" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly ld mq ma mb lh mr md me ll ms mg mh mi im bi translated">为了真正理解阻塞和非阻塞语句是如何工作的，我们需要了解调用堆栈、事件循环和事件队列。</p><h2 id="671a" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">调用堆栈</strong></h2><p id="a503" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">处理所有阻塞语句和来自事件队列的语句。</p><h2 id="8ba1" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">事件循环</strong></h2><p id="1866" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">处理所有延迟的语句，如setTimeout()、setInterval()、事件、网络调用、承诺和所有其他异步操作。当setTimeout的计时器达到0时，语句从事件循环中出来，进入事件队列。</p><h2 id="ae31" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">事件队列</strong></h2><p id="8097" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">等待来自事件循环的语句的区域，当所有阻塞代码被调用栈执行时，这些语句被发送到调用栈执行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/cfa7ca378cf959af932d18457387ef2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T3KKdwf8ETHsE3-CUPhOIg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">调用堆栈、事件循环和事件队列</figcaption></figure><p id="9f4c" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly ld mq ma mb lh mr md me ll ms mg mh mi im bi translated">那么，让我们看看例2是如何执行的。</p><p id="c2b1" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly ld mq ma mb lh mr md me ll ms mg mh mi im bi translated"><strong class="ls iu">步骤1 </strong>:我们把阻塞语句和非阻塞语句分开。</p><p id="3c82" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly ld mq ma mb lh mr md me ll ms mg mh mi im bi translated"><strong class="ls iu">注意</strong>:调用栈一次执行一条语句。为了简单起见，所有阻塞语句都被一次放入调用堆栈。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/39518faed2c7b1f0d045080f41c11b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XIjlEX3l_5hr_eBL-BXb4Q.png"/></div></div></figure><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="f0a8" class="ku kv it nk b gy no np l nq nr"><strong class="nk iu">Output</strong>: &lt;empty&gt;</span></pre><p id="860f" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly ld mq ma mb lh mr md me ll ms mg mh mi im bi translated"><strong class="ls iu">第二步</strong>:当setTimeout()等待时，调用栈中的所有阻塞语句都被顺序执行。当setTimeout()已经等待了1秒钟时，它移动到事件队列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/dfd5f90ae1318753750cdef2764b00ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-McirDh_ZxbHEzbC2YpB8w.png"/></div></div></figure><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="9ca0" class="ku kv it nk b gy no np l nq nr"><strong class="nk iu">Output</strong>:</span><span id="7c13" class="ku kv it nk b gy ns np l nq nr">We are learning setTimeout<br/>10<br/>20<br/>30<br/>Statements outside are blocking</span></pre><p id="702d" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly ld mq ma mb lh mr md me ll ms mg mh mi im bi translated"><strong class="ls iu"> Step3 </strong>:只有当调用栈中的所有阻塞代码都执行完并且调用栈为空时，语句才从事件队列中出来，进入调用栈。然后执行setTimeout()中的语句，因此我们得到了输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/bd6f014e4dc145ba1646e73c517d6475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8kO6edcQeEak2Nl23QUhvA.png"/></div></div></figure><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="d463" class="ku kv it nk b gy no np l nq nr"><strong class="nk iu">Output</strong>:</span><span id="98e8" class="ku kv it nk b gy ns np l nq nr">We are learning setTimeout<br/>10<br/>20<br/>30<br/>Statements outside are blocking<br/>After 1 second<br/>3<br/>Statements inside are non-blocking</span></pre><p id="9291" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly ld mq ma mb lh mr md me ll ms mg mh mi im bi translated">现在我们对setTimeout()的工作原理有了一些了解。让我们再看一些例子。</p><h2 id="aedd" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">示例3:多重setTimeout()</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="9528" class="ku kv it nk b gy no np l nq nr"><strong class="nk iu">Output</strong>:</span><span id="3e23" class="ku kv it nk b gy ns np l nq nr">a = 10<br/>b = 20<br/>c = 30<br/>After 0 seconds<br/>After 1 seconds<br/>After 2 seconds<br/>After 3 seconds</span></pre><p id="f0c7" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly ld mq ma mb lh mr md me ll ms mg mh mi im bi translated"><strong class="ls iu">解释</strong>:上面的例子很简单。请记住，所有阻塞语句都是先执行的，而所有超时都在事件循环中等待。然后，当因为0s具有最低的计时器，所以首先执行，然后1s setTimeout()执行，然后2s setTimeout()执行，最后3s setTimeout()执行时，每个都逐一进入事件队列。</p><p id="c3a7" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly ld mq ma mb lh mr md me ll ms mg mh mi im bi translated">它看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/f79f0e3776cd7babdc3ced036066cbf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D8ulQ3XkD4-JKwbE-4EAGA.png"/></div></div></figure><p id="6a63" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly ld mq ma mb lh mr md me ll ms mg mh mi im bi translated">当第一个、第二个、第三个和第四个超时值从事件循环中出来进入调用堆栈时，它们将按顺序执行。</p><h2 id="eb58" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">示例4:嵌套的setTimeout()</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="cbc6" class="ku kv it nk b gy no np l nq nr"><strong class="nk iu">Output:</strong></span><span id="8fc6" class="ku kv it nk b gy ns np l nq nr">zero<br/>six<br/>one<br/>two<br/>five<br/>three<br/>four</span></pre><p id="8453" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly ld mq ma mb lh mr md me ll ms mg mh mi im bi translated"><strong class="ls iu">解释</strong>:在上面的例子中，阻塞代码首先被执行，所以我们在开始时得到“0”和“6”作为我们的输出，外部setTimeout在事件循环中等待1秒，然后它进入事件队列，然后出来执行，现在“1”和“2”被打印出来。但是我们看到“五”也是印刷的。<em class="nu">为什么？</em>因为JS编译器一读取内部setTimeout()(非阻塞语句)，就将其发送到事件循环，在那里等待2秒。当内部的setTimeout()在等待时，外部的setTimeout()执行它自己内部的所有阻塞语句。于是，就印出了“五”。然后，当内部setTimeout()等待时，它会进入事件队列并执行，这就是我们如何获得“3”和“4”作为输出的。</p><p id="adeb" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly ld mq ma mb lh mr md me ll ms mg mh mi im bi translated">下图显示了上述代码的工作原理:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/72b7894a36a56675fec7afa5d6c6f616.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BfW5U8QbfINZPaSOz406lg.png"/></div></div></figure><h2 id="63c9" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">例5</strong>:0和1ms的怪异行为。</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="2429" class="ku kv it nk b gy no np l nq nr"><strong class="nk iu">Output:<br/></strong>one<br/>zero</span></pre><p id="d221" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly ld mq ma mb lh mr md me ll ms mg mh mi im bi translated"><strong class="ls iu">解释</strong>:我们的输出应该是“0”和“1”，因为0毫秒小于1毫秒。但取而代之的是“一”和“零”。原因是因为1毫秒是如此短的一段时间，基本上相当于0毫秒，因此它立即从事件循环进入事件队列，并通过调用堆栈首先执行。</p><h2 id="11d9" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">例6 </strong>:超时溢出</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="faaf" class="ku kv it nk b gy no np l nq nr"><strong class="nk iu">Output:</strong></span><span id="008b" class="ku kv it nk b gy ns np l nq nr">TimeoutOverflowWarning: 2147483648 does not fit into a 32-bit signed integer.<br/>Timeout duration was set to 1.<br/>one<br/>zero</span></pre><p id="c872" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly ld mq ma mb lh mr md me ll ms mg mh mi im bi translated"><strong class="ls iu">说明</strong>:任何大于2 ⁰的时间值都不适合32位有符号整数。因此，编译器抛出TimeoutOverflowWarning，并自动将时间值设置为1。而且从前面的例子来看既然1ms基本等同于0ms。它首先执行，然后0ms setTimeout()执行。</p><h2 id="4f2e" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">示例7:设置超时和循环</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="c9ba" class="ku kv it nk b gy no np l nq nr"><strong class="nk iu">Output:</strong></span><span id="ae99" class="ku kv it nk b gy ns np l nq nr">3<br/>3<br/>3</span></pre><p id="87f0" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly ld mq ma mb lh mr md me ll ms mg mh mi im bi translated"><strong class="ls iu">解释</strong>:for循环是一个阻塞语句，所以而setTimeout()是非阻塞的。该循环创建3个setTimeouts，这些setTimeouts转到事件循环，然后转到事件队列。当所有setTimeouts都在事件队列中等待时，调用堆栈中的值“I”已经更改为3。并且setTimeouts打印“I”的当前值。</p><p id="188e" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly ld mq ma mb lh mr md me ll ms mg mh mi im bi translated">上述问题的一个解决方案是使用let而不是var，这会创建一个块范围。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="2775" class="ku kv it nk b gy no np l nq nr"><strong class="nk iu">Output:</strong></span><span id="7c2a" class="ku kv it nk b gy ns np l nq nr">0<br/>1<br/>2</span></pre><p id="ee6f" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly ld mq ma mb lh mr md me ll ms mg mh mi im bi translated">另一个解决方案是在setTimeout之外创建一个函数作用域，由此setTimeout可以访问“I”的正确值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="4bb5" class="ku kv it nk b gy no np l nq nr"><strong class="nk iu">Output:</strong></span><span id="bac3" class="ku kv it nk b gy ns np l nq nr">0<br/>1<br/>2</span></pre></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h1 id="2b89" class="od kv it bd kw oe of og kz oh oi oj lc jz ok ka lg kc ol kd lk kf om kg lo on bi translated">分级编码</h1><p id="659c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">感谢您成为我们社区的一员！<a class="ae oo" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> <strong class="ls iu">订阅我们的YouTube频道</strong> </a>或者加入<a class="ae oo" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="ls iu"> Skilled.dev编码面试课程</strong> </a>。</p><div class="op oq gp gr or os"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">编写面试问题</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">掌握编码面试的过程</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">技术开发</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div></div></div>    
</body>
</html>