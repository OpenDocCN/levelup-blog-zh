<html>
<head>
<title>Unit Testing in Go with Real-World Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的单元测试与现实世界的例子</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/unit-testing-in-go-205ada2b9d7c?source=collection_archive---------1-----------------------#2019-06-19">https://levelup.gitconnected.com/unit-testing-in-go-205ada2b9d7c?source=collection_archive---------1-----------------------#2019-06-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c68b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有许多文章展示了如何在Go中进行单元测试，但是其中许多文章只涉及基本单元测试的简单情况。对更深层次的概念没有什么透彻的了解。在本文中，我希望涵盖更复杂和真实的单元测试示例。我们将测试一个与数据库交互的API端点。</p><p id="d98d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于大多数关于Go单元测试的现有文章只关注一个简单的例子，所以没有嘲讽，没有存根，没有复杂的数据类型，没有接口。对我来说，能够为我的代码编写有用的单元测试是一件非常痛苦的事情。我的目标是通过提供我的经验和见解来帮助其他初学者节省一些时间。</p><h1 id="f33e" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak">我们将从本文中学到什么</strong></h1><p id="6e83" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我们将测试一个REST API处理函数，它简单地绑定输入请求负载并将数据存储到MySQL数据库中。我将使用Gin框架，但是结果可以应用于任何API库。</p><p id="d5ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将看看我最初编写的一些紧密耦合(不正确)的代码。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="24ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们大致了解一下代码的作用。</p><p id="ecc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lv lw lx ly b">NewAdmin</code>函数接受一个类型为<code class="fe lv lw lx ly b">*gin.Context</code>的参数，该参数包含与请求和响应相关的所有细节。</p><p id="e0e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lv lw lx ly b">ShouldBindJSON</code>将请求与<code class="fe lv lw lx ly b">AdminDetailsStruct</code>对象绑定，并填充作为请求一部分的细节。如果与结构细节有任何不匹配，它将返回一个错误。</p><p id="ec7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们形成一个<code class="fe lv lw lx ly b">query</code>和<code class="fe lv lw lx ly b">Exec</code> <strong class="jp ir"> </strong>将执行查询。<strong class="jp ir"> </strong> <code class="fe lv lw lx ly b">connection.SQLConn</code>属于<code class="fe lv lw lx ly b"><strong class="jp ir">*</strong>mysql.Db</code> <strong class="jp ir">类型。</strong></p><p id="ce2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在您已经对代码做了简要的概述，我们现在讨论如何实际测试。</p><h2 id="2f3a" class="lz km iq bd kn ma mb dn kr mc md dp kv jy me mf kz kc mg mh ld kg mi mj lh mk bi translated">上述代码中的错误</h2><p id="f0db" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我写的初始代码中有一些错误，使得单元测试变得困难:</p><ul class=""><li id="67c3" class="ml mm iq jp b jq jr ju jv jy mn kc mo kg mp kk mq mr ms mt bi translated">函数参数与特定类型紧密耦合</li><li id="c824" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">模仿一个外部包的功能(<code class="fe lv lw lx ly b">connection.SQLConn.Exec</code>)。很多文章建议使用monkey补丁和接口。我个人反对猴子打补丁，使用接口需要开发人员真正擅长编写可测试的代码。</li></ul><h2 id="4057" class="lz km iq bd kn ma mb dn kr mc md dp kv jy me mf kz kc mg mh ld kg mi mj lh mk bi translated">重构和构建应用程序</h2><p id="5e26" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">所以第一件事就是重构代码，使之松散耦合。重构后的项目结构如下。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mz"><img src="../Images/565a965290e59cd6858803d0d4540380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*196XLyj7tMIzDr_j5sYdWg.png"/></div></div></figure><p id="3978" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lv lw lx ly b">connection</code> - &gt; <code class="fe lv lw lx ly b">main.go</code>这将在服务器启动时打开一个连接并初始化一次。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="d706" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lv lw lx ly b">interfaces</code>-&gt;-<code class="fe lv lw lx ly b">main.go</code>为<code class="fe lv lw lx ly b">*gin.Context</code>定义了一个接口。<code class="fe lv lw lx ly b">*gin.Context</code>有很多方法，但是对于我们的用例来说，这两种方法已经足够好了</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="9d96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lv lw lx ly b">create</code>-&gt;-<code class="fe lv lw lx ly b">createNewAdmin.go</code></p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="b728" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lv lw lx ly b">create</code>-&gt;-T7】</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="f86a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lv lw lx ly b">create</code>-&gt;-<code class="fe lv lw lx ly b">structs.go</code></p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="23e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要担心代码，我们一会儿将逐行讨论。</p><p id="a9f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你注意到了不同，我们做了两个改变:</p><ul class=""><li id="11a8" class="ml mm iq jp b jq jr ju jv jy mn kc mo kg mp kk mq mr ms mt bi translated">我没有接受<code class="fe lv lw lx ly b">*gin.Context</code>作为函数参数，而是将其改为包含<code class="fe lv lw lx ly b">JSON</code>和<code class="fe lv lw lx ly b">ShouldBindJSON</code>方法的接口。所以任何实现这两个函数的结构都可以作为函数参数传递。</li><li id="2b94" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">我们已经将<code class="fe lv lw lx ly b">connection.SQLConn.Exec</code>赋给了一个变量。我们这样做的原因是，它给了我们在运行时通过其他函数改变变量的灵活性。任何改变这个变量的函数都必须分配一个具有相同fn参数类型和返回值的函数。</li></ul><h2 id="a392" class="lz km iq bd kn ma mb dn kr mc md dp kv jy me mf kz kc mg mh ld kg mi mj lh mk bi translated">编写单元测试的步骤</h2><ul class=""><li id="0557" class="ml mm iq jp b jq lj ju lk jy ng kc nh kg ni kk mq mr ms mt bi translated">步骤1:创建一个实现<code class="fe lv lw lx ly b">JSON</code>和<code class="fe lv lw lx ly b">ShouldBindJSON</code>方法的结构(<code class="fe lv lw lx ly b">ginContext</code>是这个结构)。</li><li id="4e24" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">步骤2:创建一个类型为<code class="fe lv lw lx ly b">ginContext</code>的变量，并将其作为参数传递给<code class="fe lv lw lx ly b">NewAdmin</code>。<strong class="jp ir"> </strong>每当<code class="fe lv lw lx ly b">JSON</code>或<code class="fe lv lw lx ly b">ShouldBindJSON</code>函数触发时，不调用Gin的方法，而是调用测试函数传递的struct的方法。</li><li id="9413" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">第三步:将保存<code class="fe lv lw lx ly b">connection.SQLConn.Exec</code>的<code class="fe lv lw lx ly b">Exec</code>变量赋给一个虚拟变量，并将一个模拟函数赋给<code class="fe lv lw lx ly b">Exec</code>。所以每当调用<code class="fe lv lw lx ly b">Exec()</code>而不是调用实际的MySQL <code class="fe lv lw lx ly b">Exec()</code>时，它调用测试文件<code class="fe lv lw lx ly b">Exec()</code>。</li><li id="d883" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">步骤4:测试功能执行完成后，将<code class="fe lv lw lx ly b">Exec</code>赋值为初始值。这确保了其他的测试不会受到这个变化的影响。</li></ul><blockquote class="nj nk nl"><p id="6887" class="jn jo nm jp b jq jr js jt ju jv jw jx nn jz ka kb no kd ke kf np kh ki kj kk ij bi translated"><strong class="jp ir">注意:当你做这样的事情时，永远不要并行运行测试。由于比赛条件，这可能会导致一些恶劣的影响。</strong></p></blockquote><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="e372" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lv lw lx ly b">ShouldBindJSON</code>中写的代码绑定虚拟数据。你现在不需要担心。</p><p id="66ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们需要测试我们的测试覆盖的代码量。</p><pre class="lo lp lq lr gt nq ly nr ns aw nt bi"><span id="b4aa" class="lz km iq ly b gy nu nv l nw nx">go test -coverprofile=c.out &amp;&amp; go tool cover -html=c.out</span></pre><p id="fdb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只需运行这个命令，您就会在系统的默认浏览器中看到覆盖率报告</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi ny"><img src="../Images/dd1f38f1a4fcfc363d76a0d812704419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s4IER2rCD5GwJNNcW9kN9A.png"/></div></div></figure><p id="bca9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我写的第一篇关于Medium的文章，所以任何建议或改进都会被欣然接受。T3】</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><div class="lo lp lq lr gt og"><a href="https://gitconnected.com/learn/golang" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">学习围棋-最佳围棋教程(2019) | gitconnected</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">22大围棋教程-免费学习围棋。课程由开发者提交和投票，使您能够找到…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">gitconnected.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ne og"/></div></div></a></div></div></div>    
</body>
</html>