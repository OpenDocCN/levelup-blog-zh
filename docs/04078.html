<html>
<head>
<title>Hacking the Redis Protocol to use as an HTTP API alternative with Asyncio in Python.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python中的Asyncio破解Redis协议，作为HTTP API的替代。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/hacking-the-redis-protocol-as-an-http-api-alternative-using-asyncio-in-python-7e57ba65dce3?source=collection_archive---------21-----------------------#2020-06-08">https://levelup.gitconnected.com/hacking-the-redis-protocol-as-an-http-api-alternative-using-asyncio-in-python-7e57ba65dce3?source=collection_archive---------21-----------------------#2020-06-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6b0eac64fdfe9c10bb98fa1bfe3d6957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W9CglENywg4TUWYRWrQw1w.png"/></div></div></figure><p id="5036" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常当你想到API的时候，你会直接想到HTTP。虽然该协议占主导地位是有充分理由的，但它主要是为web构建的，并且可能不适用于服务器到服务器的API，在这种API中，长期的和经过身份验证的连接是常见的。HTTP2解决了多路复用、报头压缩等一些问题，但是这些增加的功能使协议变得笨拙。至少应该考虑一个替代方案。</p><h2 id="1aae" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">为什么是Redis协议？</h2><p id="0d32" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">很难找到像Redis一样用这么多种语言编写的请求-响应协议。几乎每种语言都有一个客户端，无论是否得到官方支持，协议非常简单，一个基本的客户端可以在一个小时内编写完成。使用RESP作为API的一些潜在好处包括:</p><ul class=""><li id="f633" class="lu lv iq ka b kb kc kf kg kj lw kn lx kr ly kv lz ma mb mc bi translated">长期的联系。</li><li id="ea34" class="lu lv iq ka b kb md kf me kj mf kn mg kr mh kv lz ma mb mc bi translated">不需要对每个请求进行重新认证。这包括发送头和检查存储或处理jwt中的API键。</li><li id="4a56" class="lu lv iq ka b kb md kf me kj mf kn mg kr mh kv lz ma mb mc bi translated">客户端已经过实战测试，专为高性能而编写，并且支持大多数语言。</li><li id="f432" class="lu lv iq ka b kb md kf me kj mf kn mg kr mh kv lz ma mb mc bi translated">客户端内置了授权和SSL。</li><li id="ebb0" class="lu lv iq ka b kb md kf me kj mf kn mg kr mh kv lz ma mb mc bi translated">简单协议。HTTP2的协议非常复杂，涉及到状态机，并且实现起来杂乱无章。RESP很简单，可以在网上直接阅读原文。</li><li id="3b55" class="lu lv iq ka b kb md kf me kj mf kn mg kr mh kv lz ma mb mc bi translated">对于生产中使用的最多产的存储器之一来说已经足够好了。</li></ul></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="20a8" class="mp kx iq bd ky mq mr ms lb mt mu mv le mw mx my lh mz na nb lk nc nd ne ln nf bi translated">构建服务器</h1><p id="ba2e" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated"><a class="ae ng" href="https://redis.io/topics/protocol" rel="noopener ugc nofollow" target="_blank"> Redis协议</a>由5种类型组成。这些类型以一个字节为前缀，表示后续字节所代表的内容。Redis文档简洁地描述了对象的头字节。</p><ul class=""><li id="1ba5" class="lu lv iq ka b kb kc kf kg kj lw kn lx kr ly kv lz ma mb mc bi translated">对于简单的字符串，回复的第一个字节是“+”</li><li id="0636" class="lu lv iq ka b kb md kf me kj mf kn mg kr mh kv lz ma mb mc bi translated">对于<strong class="ka ir">错误</strong>，回复的第一个字节是“-”</li><li id="d74a" class="lu lv iq ka b kb md kf me kj mf kn mg kr mh kv lz ma mb mc bi translated">对于整数<strong class="ka ir">回复的第一个字节是“:”</strong></li><li id="e4ae" class="lu lv iq ka b kb md kf me kj mf kn mg kr mh kv lz ma mb mc bi translated">对于<strong class="ka ir">批量字符串</strong>，回复的第一个字节是“$”</li><li id="dd45" class="lu lv iq ka b kb md kf me kj mf kn mg kr mh kv lz ma mb mc bi translated">对于<strong class="ka ir">数组</strong>，回复的第一个字节是“*”</li></ul><p id="4eea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种简单性使得Redis响应很容易用字节格式构造，如:<code class="fe nh ni nj nk b">b"-ERROR %b\r\n" % err_text</code>(这是一个序列化错误)。</p><p id="08d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的紧凑服务器是通过一个简单的技巧实现的:由于Redis命令被编码为数组，客户端可以接收数组作为响应，因此客户端的解析器与服务器的解析器完全相同。</p><p id="d2e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实现<code class="fe nh ni nj nk b">QUIT</code>命令的最小Redis服务器如下所示:</p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="95ff" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">我们API服务器的亮点</h2><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e8aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Python不建议您直接使用StreamReader，而是使用<code class="fe nh ni nj nk b">loop.start_server</code>。然而，aioredis实现了自己的StreamReader，直接解析来自套接字的redis对象。为了使用它，复制了部分<code class="fe nh ni nj nk b"><a class="ae ng" href="https://github.com/python/cpython/blob/master/Lib/asyncio/streams.py#L58" rel="noopener ugc nofollow" target="_blank">start_server</a></code>函数并注入了aioredis的StreamReader。</p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ac64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是连接的主循环。它无限循环地解析一个Redis对象，并为每个对服务器的调用调用<code class="fe nh ni nj nk b">process_command</code>。</p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e747" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的业务逻辑被隔离到<code class="fe nh ni nj nk b">process_command</code>功能。循环需要返回的唯一信息是是否中断和关闭连接。</p><h2 id="ad98" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">实施命令</h2><p id="09a0" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">Redis命令以二进制字符串数组的形式出现。您可以使用JSON轻松地编码和解码您的参数，以生成提供丰富功能的命令:</p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="96ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以通过启动Redis客户机并手动执行它们来使用这些命令。将这些命令包装在一个客户端类中可以清理和划分事物。</p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="1672" class="mp kx iq bd ky mq nr ms lb mt ns mv le mw nt my lh mz nu nb lk nc nv ne ln nf bi translated">最后的想法</h1><p id="f986" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">由于我们使用Redis客户端解析器，如果我们安装<code class="fe nh ni nj nk b">hiredis-py</code>，我们的服务器将自动开始使用用c编写的更快的解析器。另一个性能改进是使用<a class="ae ng" href="https://msgpack.org/index.html" rel="noopener ugc nofollow" target="_blank"> msgpack </a>进行序列化，以获得额外的性能优势。因为Redis客户端通常支持TLS，所以我们可以尝试将它放在一个带有SSL的负载平衡器后面，看看这个实现的生产就绪程度如何。还应该考虑解析器的安全性，以确保不可能通过发送大字符串来实例化DDOS攻击。</p><p id="fdc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">性能应该很不错。所有的代码都是相当低级的，对象是直接从网络上解析的。如果能以uvicorn或其他HTTP框架为基准进行测试，那就太好了。</p><p id="7e30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总的来说，asyncio提供的紧凑实现给我留下了非常深刻的印象，它只用50行代码就创建了一个非常健壮的服务器。这种创建API的方法看起来很有前途，我期待着进一步研究它。</p></div></div>    
</body>
</html>