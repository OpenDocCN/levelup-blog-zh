<html>
<head>
<title>Things I wish I knew before testing React (Native)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我希望在测试反应之前知道的事情(原生)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/things-i-wish-i-knew-before-testing-react-native-3916736dd0bc?source=collection_archive---------14-----------------------#2020-07-21">https://levelup.gitconnected.com/things-i-wish-i-knew-before-testing-react-native-3916736dd0bc?source=collection_archive---------14-----------------------#2020-07-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/43787d1046ef0a37316bc9985c6e7566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HOt5ixklC8lHgwqF"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">诺亚·多米尼克·西尔维奥在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="2ee7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对我来说，编写测试一直是开发过程中具有挑战性的一部分。总是有新的案例来找出测试或模仿的方法。我一直在开发一些React本机应用程序，并遇到了一些这样的问题。当然，我花了一些时间后设法解决了它们，它们并不容易解决。但是现在我回头看，它们在我看来非常明显！所以，我决定分享这些经历，这样下一个人就不用再经历这些事情了。</p><h1 id="6160" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">命名组件</h1><p id="df20" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">避免导出没有名称的组件。例如<code class="fe me mf mg mh b">export default () =&gt; {}</code>或<code class="fe me mf mg mh b">export default function() {}</code>。如果出现问题，并且您正在导出没有名称的组件，您的控制台将显示如下内容:</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/fd5f6d8a959b647daaae34d318004778.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bCB5gip0QzgAil5Hi0cUnA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">没有名称的默认导出元件的Jest日志</figcaption></figure><p id="c25b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，没有办法找出哪个组件引发了错误，因为它们都是<code class="fe me mf mg mh b">_default</code>。现在看一下具有正确组件名称的相同情况:</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/15b33fb9d40086923554c6daf8030adf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gv3coWpnsH_ikc2131GLBw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">名为的默认导出元件的Jest日志</figcaption></figure><h1 id="b8f6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">测试<code class="fe me mf mg mh b">useEffect</code></h1><p id="a566" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">使用<code class="fe me mf mg mh b">useEffect</code>钩子获取数据并使用该数据更新组件的状态是非常常见的。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="e8e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为该组件编写快照测试的一种非常常见的简单方法是:</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="7adb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个测试将会通过，但并非没有抱怨:</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/6a9e9d228de5444e9ed2cee51ba1eeac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b1tb1_X8b0UEbU26cIxSlA.png"/></div></div></figure><p id="e46f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原因是组件状态的更新正在<code class="fe me mf mg mh b">useEffect</code>中发生。为了测试，对组件状态的每次更新都应该包装在一个<code class="fe me mf mg mh b">act</code>回调中。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="c1e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是在<code class="fe me mf mg mh b">useEffect</code>中测试异步状态更新的正确方法。我们还可以模仿<code class="fe me mf mg mh b">fetchText</code>函数来使测试变得更容易(稍后会详细介绍)。</p><h1 id="8c40" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">发现漏洞</h1><p id="3d15" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果运行测试的持续时间不一致，可能会有一些松散的IO操作，例如http请求或超时。检测这些漏洞的最佳方式是使用<code class="fe me mf mg mh b">—-detectOpenHandles</code>选项。Jest还会警告你使用这个选项，以防它检测到松散的结尾。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/19342fd43b82d8313393a4b42d0587d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vX_Az9dFOoMz4nTmSJgs4A.png"/></div></div></figure><h1 id="0ecf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">重新思考测试设计</h1><p id="8b13" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对于单元测试的正确方法，只关注当前文件中的功能是非常重要的。所有进口的东西都应该被嘲笑。重新思考组件最初的设计方式总是一个好的做法。通过做一些小的重构，可能会使编写测试变得容易得多。让我们考虑以下组件:</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="1dd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个组件将在几个<code class="fe me mf mg mh b">randomDelay</code>毫秒后揭示一个秘密。为了测试这个组件，我们必须使用<code class="fe me mf mg mh b">jest.useFakeTimers</code>方法。对此的完整测试将是延迟前后的测试。让我们试试这个:</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="a713" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，我们可以模仿<code class="fe me mf mg mh b">Math</code>中的<code class="fe me mf mg mh b">random</code>方法，每次都返回一个常数(这是以后的事)，但我们正在寻找一个更好、更简单的解决方案。如果我们将<code class="fe me mf mg mh b">delay</code>作为<code class="fe me mf mg mh b">props</code>传递给<code class="fe me mf mg mh b">Reveal</code>组件会怎么样。这将使<code class="fe me mf mg mh b">Reveal</code>组件更简单，更容易测试。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="ddbb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记住这一点也将导致你考虑分离关注点的方式的转变。假设我们有一个组件处理一些数据并调用一个API。如果我们在同一个组件文件中实现它，测试将会更加困难，而不是将它移到一个单独的<code class="fe me mf mg mh b">service</code>文件中。那么在测试组件时，服务文件中的所有内容都可以被模仿。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="89db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了测试<code class="fe me mf mg mh b">Enhappy</code>组件内部的<code class="fe me mf mg mh b">enhappy</code>功能，我们应该:1)触发按钮上的<code class="fe me mf mg mh b">onPress</code>，2)模拟<code class="fe me mf mg mh b">fetchText</code>，3)通过<code class="fe me mf mg mh b">tree.root.findByType(Text).props.children</code>检查<code class="fe me mf mg mh b">text</code>。然而，如果我们将<code class="fe me mf mg mh b">enhappy</code>方法移动到一个单独的文件中，进行适当的单元测试将会容易得多。</p><h1 id="3513" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">嘲弄的</h1><p id="b031" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><strong class="kf ir">嘲讽外来进口</strong></p><p id="5bd6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常推荐的简单方法是在包含<code class="fe me mf mg mh b">jest.mock("module", () =&gt; { ...</code>的<code class="fe me mf mg mh b">__mocks__</code>目录中创建一个同名文件。如果这不起作用，我们可能需要用以下方法之一来模拟它:</p><ul class=""><li id="f4b4" class="mp mq iq kf b kg kh kk kl ko mr ks ms kw mt la mu mv mw mx bi translated">模拟测试文件中的模块</li></ul><p id="037b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以给每个测试块单独添加一个模拟部件，或者在<code class="fe me mf mg mh b">beforeAll</code>块内部进行。例如嘲弄<code class="fe me mf mg mh b">react-native-camera</code>:</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><ul class=""><li id="5bf2" class="mp mq iq kf b kg kh kk kl ko mr ks ms kw mt la mu mv mw mx bi translated">使用安装文件</li></ul><p id="d683" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时候不仅仅是这样。比如嘲讽<code class="fe me mf mg mh b">react-native-fs</code>就不会这样。在这些情况下，我们必须模拟<code class="fe me mf mg mh b">setupFiles</code>中的模块。在jest config中，如果该部分不存在，则添加它(如果存在，只需将条目添加到数组中):</p><pre class="mj mk ml mm gt my mh mz na aw nb bi"><span id="fe41" class="nc lc iq mh b gy nd ne l nf ng">"setupFiles": [<br/>  "&lt;rootDir&gt;/path/to/jest-mocks.ts"<br/>],</span></pre><p id="b7a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe me mf mg mh b">jest-mocks.ts</code>中，将所有不起作用的模拟放到<code class="fe me mf mg mh b">__mocks__</code>目录或之前的方法中:</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="4e2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">嘲讽全局</strong></p><p id="c876" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于这一节，我考虑过嘲笑<code class="fe me mf mg mh b">Date</code>构造函数。以下函数将以字符串形式返回当前日期:</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="a641" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了测试这一点，我们需要模拟全局<code class="fe me mf mg mh b">Date</code>对象来控制它的输出。使用<code class="fe me mf mg mh b">jest.spyOn</code>方法模仿全局<code class="fe me mf mg mh b">Date</code>非常容易。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="c0cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也有可能窥探一个对象的特定方法。例如，嘲笑<code class="fe me mf mg mh b">Date.now</code>就像<code class="fe me mf mg mh b">jest.spyOn(Date, "now")</code>。</p><p id="4dee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">嘲讽内部进口</strong></p><p id="5668" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了模拟内部模块，需要导入整个文件，然后我们可以模拟方法、类或常量。对于这一部分，我们将模拟以下模块中的方法:</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="d460" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个测试函数的多个参数的快速技巧。为了测试<code class="fe me mf mg mh b">enhappy</code>功能，通常的方法是:</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="4e25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，对于每个新的测试，我们必须写完整行。对于这个具体的例子来说，这看起来并不难，但是相信我，在有些情况下，这并不容易。然而，如果我们创建一个新的测试数据结构，这可以通过一个简单的for循环来完成:</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="9822" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们回到嘲讽的部分。该模块有两个导出方法:默认导出和命名导出。对于模拟部分，我们必须将该模块作为<code class="fe me mf mg mh b">import * as happy from "../rel/path/to/happy.ts"</code>导入，然后我们可以模拟每个方法:</p><pre class="mj mk ml mm gt my mh mz na aw nb bi"><span id="9c8d" class="nc lc iq mh b gy nd ne l nf ng">// mocking default export<br/>happy.default = jest.fn()</span><span id="adfe" class="nc lc iq mh b gy nh ne l nf ng">// mocking named export<br/>happy.enhappyNoMatterTheCase = jest.fn()</span></pre><p id="5985" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看单元测试<code class="fe me mf mg mh b">Enhappy</code>组件的操作:</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="6350" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个测试中，我还提到了测试命名的导出并在一个<code class="fe me mf mg mh b">Button</code>上触发<code class="fe me mf mg mh b">onPress</code>事件。</p><h1 id="9f0f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">其他有用的选项</h1><p id="8416" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有两个有用的选项可以为您节省大量时间:</p><ol class=""><li id="0410" class="mp mq iq kf b kg kh kk kl ko mr ks ms kw mt la ni mv mw mx bi translated"><code class="fe me mf mg mh b">--showConfig</code>这将显示用于运行测试的最终配置对象。如果您想调试为什么自定义更改没有生效，这是非常方便的。</li><li id="3faa" class="mp mq iq kf b kg nj kk nk ko nl ks nm kw nn la ni mv mw mx bi translated">当您运行测试时，您可能会看到意想不到的行为(虽然不经常，但还是会发生)。没有意义的事情，那么你就知道是时候清空缓存了。</li></ol><h1 id="95b4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">快乐测试；)</h1><p id="1843" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><em class="no">如果我做错了什么，或者有更好的方法，</em> <strong class="kf ir"> <em class="no">请</em> </strong> <em class="no">告诉我！</em></p></div></div>    
</body>
</html>