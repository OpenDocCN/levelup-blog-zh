<html>
<head>
<title>React Native Authentication Flow, the Simplest and Most Efficient Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React本机认证流程，最简单有效的方式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-native-authentication-flow-the-simplest-and-most-efficient-way-3aa13e80af61?source=collection_archive---------0-----------------------#2021-04-04">https://levelup.gitconnected.com/react-native-authentication-flow-the-simplest-and-most-efficient-way-3aa13e80af61?source=collection_archive---------0-----------------------#2021-04-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7e09" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">与API连接，保存数据，并在将来的会话中恢复它们</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/52660434fadc3beddd5f044ba38e809a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3MxP2HBeglCk--kbnyBXpQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">克里斯·帕纳斯在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="32d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几乎所有的应用程序都需要认证流程，因为它们包含只有授权用户才能访问的内容。</p><p id="a90b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文将解释如何创建一个React本机身份验证流，该流连接到API，持久保存要在未来会话中恢复的数据，并为整个应用程序提供一种订阅身份验证状态更改的有效方式。</p><p id="905f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的重点是为上述流程构建整个结构，而不是从头开始创建应用程序。但是你可以在这里 访问完整的代码<a class="ae kv" href="https://github.com/LucasGarcez/react-native-auth-flow" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">库。</strong></a></p><h2 id="c859" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">经过验证和未经验证的用户</h2><p id="551f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在React Native中，区分这些用户的一种常见方法是创建不同的“组”屏幕。一个用于未经身份验证的用户，包含登录和注册等屏幕，另一个用于经过身份验证的用户，包含主页、设置和所有其他与用户内容相关的屏幕。</p><p id="46db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://reactnavigation.org/docs/getting-started" rel="noopener ugc nofollow" target="_blank"> react-navigation </a>库将帮助创建这些组，更具体地说，<strong class="ky ir"> createStackNavigator </strong>函数。第一组<strong class="ky ir"> AppStack </strong>将包含<a class="ae kv" href="https://github.com/LucasGarcez/react-native-auth-flow/blob/master/src/screens/HomeScreen.tsx" rel="noopener ugc nofollow" target="_blank">主屏幕</a>，而<strong class="ky ir"> AuthStack </strong>将包含<a class="ae kv" href="https://github.com/LucasGarcez/react-native-auth-flow/blob/master/src/screens/SignInScreen.tsx" rel="noopener ugc nofollow" target="_blank">标志屏幕。</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="a715" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个<strong class="ky ir">路由器</strong>组件，负责根据用户是否通过身份验证来选择显示哪个堆栈。堆栈需要在<strong class="ky ir"> NavigationContainer </strong>中，这是react-navigation的一个组件，用于管理导航树和导航状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="7a4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> authData </strong>表示用户认证状态，换句话说，是否有认证用户。<strong class="ky ir"> authData </strong>不能是来自<strong class="ky ir">路由器</strong>的简单属性，因为其他组件可以从应用程序中的不同位置更新它，所以需要另一个解决方案。一个很好的解决方法是使用<a class="ae kv" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React上下文</a>。</p><blockquote class="ms mt mu"><p id="d0c8" class="kw kx mv ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated">上下文提供了一种通过组件树传递数据的方法，而不必在每一层手动向下传递属性，树中的任何组件都可以“监听”上下文的变化。</p></blockquote><h2 id="f887" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">使用React上下文来提供authData</h2><p id="b1a5" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">上下文需要提供<strong class="ky ir"> authData </strong>本身、登录函数、退出函数和加载状态。登录函数将与API连接，并根据响应更新<strong class="ky ir"> authData </strong>。注销功能将清理数据，在某些情况下，与API连接以使令牌或类似的东西无效。加载状态是必需的，因为身份验证过程是一个异步任务，通过API作为本地持久连接。因此，数据形状可以是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="c0b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这些<strong class="ky ir">类型</strong>来定位，我们就可以创建由<strong class="ky ir"> AuthContext、</strong>调用的上下文和由<strong class="ky ir"> AuthProvide调用的相关提供者。</strong></p><p id="bbd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码稍微长一点，但是我们可以从上到下阅读。每一部分都有一个注释，解释什么是什么和意图是什么。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="e82e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于任何组件监听器认证状态的改变和调用sing-in或sing-out函数，<strong class="ky ir"> App </strong>根组件<strong class="ky ir"> </strong>要用<strong class="ky ir"> AuthProvider </strong>封装<strong class="ky ir">路由器</strong>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="6412" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了方便对<strong class="ky ir"> AuthContext </strong>的访问，我们可以创建一个简单的<a class="ae kv" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank"> React钩子</a>来抽象上下文连接逻辑。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="2561" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">路由器</strong>组件将使用<strong class="ky ir"> useAuth </strong>钩子来决定显示哪个正确的堆栈，如果数据未准备好，则显示一个<a class="ae kv" href="https://github.com/LucasGarcez/react-native-auth-flow/blob/master/src/components/Loading.tsx" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">加载</strong> </a>组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="cf2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">屏幕，也可以使用挂钩来登录和退出。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="3384" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">持久化数据</h2><p id="ccf6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">最后要解决的问题是持久性。到目前为止，当App关闭和打开时，所有数据都会丢失，因为上下文只存在于App的内存中。<a class="ae kv" href="https://react-native-async-storage.github.io/async-storage/" rel="noopener ugc nofollow" target="_blank">@ react-native-async-storage/async-storage</a>库将对此进行处理并保存数据。由于<strong class="ky ir"> AppProvider </strong>集中了身份验证状态的变化，所以这是放置持久性逻辑的最合适的位置。</p><ul class=""><li id="3c92" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated">App启动时:检查存储；如果有数据，更新<strong class="ky ir"> authData </strong>状态。</li><li id="5ca5" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">当用户登录时:将来自API的<strong class="ky ir"> authData </strong>保存在存储器中。</li><li id="53a4" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">当用户退出时:从存储器中删除<strong class="ky ir"> authData </strong>。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="427d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就这些了，伙计们！现在您有了一个完整的身份验证流程，具有良好分离的职责、持久性和API连接。同样，您可以在GitHub <a class="ae kv" href="https://github.com/LucasGarcez/react-native-auth-flow" rel="noopener ugc nofollow" target="_blank">库</a>访问这个项目的全部代码。</p><p id="9cd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢来到这里；如果有任何问题，请留下评论，我将很乐意帮助您。</p></div></div>    
</body>
</html>