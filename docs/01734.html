<html>
<head>
<title>Refactoring React Class Components with Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重构用钩子反应类组件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/refactoring-react-class-components-with-hooks-d15abb7fe71a?source=collection_archive---------6-----------------------#2020-01-26">https://levelup.gitconnected.com/refactoring-react-class-components-with-hooks-d15abb7fe71a?source=collection_archive---------6-----------------------#2020-01-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="12c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你像我一样，你被告知功能组件更有效、更干净，或者“更好”，你应该尝试使用钩子。但你一直在逃避。因为你非常习惯使用<code class="fe kl km kn ko b">setState()</code>和生命周期方法，而且它正在工作…</p><p id="e798" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是今天，伙计们。我们要去做了。因为我最终尝试了它，而且它非常容易重构，结果是令人耳目一新的干净和易于遵循的代码。我打算用一种非常简单的方式把所有东西都摆出来，这样就不会有什么损失了。</p><p id="8e4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以系紧鞋带，别抱怨了，我们走吧。</p></div><div class="ab cl kp kq hu kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ij ik il im in"><h1 id="14b0" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">首先，简单介绍一下背景…</h1><h2 id="79c7" class="lu kx iq bd ky lv lw dn lc lx ly dp lg jy lz ma lk kc mb mc lo kg md me ls mf bi translated">类别组件与功能组件</h2><p id="8b36" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">React类组件是程序员喜欢称之为ES6带来的“语法糖”，它允许我们自动使用方便的东西，如状态和生命周期方法，如<code class="fe kl km kn ko b">componentDidMount()</code>和<code class="fe kl km kn ko b">componentDidUpdate()</code>。类组件<em class="ml">扩展了</em>React组件，并被声明和使用如下:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mm"><img src="../Images/5731f1b6efeee14b224eb7c986706635.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Yn5jt1VZatgx8q9uz8zJA.png"/></div></div></figure><p id="6592" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，React组件也可以声明为简单的函数(就像JavaScript中的其他东西一样)。与上面相同的组件将被声明为:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi my"><img src="../Images/a55d6bfaaf38c98b68467c89233f1d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-JBLVtfLu_6daUJCRsZ1Wg.png"/></div></div></figure><p id="cf0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">功能组件在转换后会产生更干净、更精简的代码，并且通常更容易跟踪、测试和使用，因为它们只是普通的旧JavaScript函数。但是，从历史上看，使用功能组件意味着我们不能使用像状态或生命周期方法这样对React组件如此方便的东西。所以我们会用一个功能组件来表示那些只需要道具，通常只是渲染一些东西的组件。然而，随着钩子的引入，事情发生了一些变化，我们现在可以为任何组件使用功能组件。</p><h2 id="badc" class="lu kx iq bd ky lv lw dn lc lx ly dp lg jy lz ma lk kc mb mc lo kg md me ls mf bi translated">但是国家呢…</h2><p id="3972" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">如果我们需要使用状态，这怎么可能呢？介绍一下<strong class="jp ir"> useState() </strong>钩子！使用状态允许您定义一个状态变量、该变量的setter方法，并一次性初始化值。查看<a class="ae mz" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank"> useState文档</a>以获得更深入的解释，但是用法看起来像这样:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi na"><img src="../Images/3ec004d53aef7ee2bb08c679fe385e18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0y5Na5hx-vuCYKLZ4jKBmg.png"/></div></div></figure><p id="8e98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它取代了初始化状态，并在类组件中使用<code class="fe kl km kn ko b">setState()</code>:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/e224eb7e2093782e22ee70941e3b07f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*JYyqRZf5oJrEezBrYA9oyQ.png"/></div></figure><h2 id="f118" class="lu kx iq bd ky lv lw dn lc lx ly dp lg jy lz ma lk kc mb mc lo kg md me ls mf bi translated">和生命周期方法？</h2><p id="28bc" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">您会问，在组件的整个生命周期中需要发生的事情呢？在整个生命周期中，我们可以使用各种各样的钩子，其中一些有助于使代码更快更有效，但最常见的是<strong class="jp ir"> useEffect() </strong>。默认情况下，在组件更新的任何时候运行回调函数，但是您也可以通过传递第二个参数作为依赖变量的数组，将它与特定依赖项的变化联系起来。</p><p id="c56a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，<code class="fe kl km kn ko b">useEffect</code>可以用来代替<code class="fe kl km kn ko b">componentDidMount</code>和<code class="fe kl km kn ko b">componentDidUpdate</code>，还可以进一步定制，使其只在特定的场合触发。你可以查看文档，但这里有一些例子:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/01a2d3aca0f20b453f0c003053b47cbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*hlEKX68F_K9-5BHNhYhJxw.png"/></div></figure><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/aa8168e7820a445c7c0e5e90f39d12d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*6xmqzJayZADdhVblrTvuGg.png"/></div></figure><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi ne"><img src="../Images/c455e5c6808345f73f06357937e16148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zyvixzpNhziiHqrrPHWQgA.png"/></div></div></figure></div><div class="ab cl kp kq hu kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ij ik il im in"><h1 id="e7c6" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">好吧，让我们来举个例子</h1><p id="9f03" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">有了这些背景知识，我发现钻研某件事最简单的方法就是开始做。</p><p id="cfce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个非常基本的组件示例。我设置它从props中读取一个值，使用受控表单的状态，并使用componentDidMount进行初始API获取。出于这个例子的目的，让我们忽略当我们进行初始调用或提交表单时会发生什么，而把注意力集中在其余的语法上。</p><p id="66ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们将要使用的类组件:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="f9b9" class="lu kx iq bd ky lv lw dn lc lx ly dp lg jy lz ma lk kc mb mc lo kg md me ls mf bi translated">从哪里开始？</h2><p id="e6af" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">这看起来像是很多工作，但是如果你把它分解，它会变得非常有条理和简单。我会按照以下步骤将它转换成一个功能组件:</p><ol class=""><li id="9968" class="nh ni iq jp b jq jr ju jv jy nj kc nk kg nl kk nm nn no np bi translated">更改我们的React import语句</li><li id="0b71" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated">用函数语法替换声明</li><li id="e750" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated">将最初的国家声明替换为<code class="fe kl km kn ko b">useState</code>的实施</li><li id="64ba" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated">用步骤2中创建的设置器替换setState用法。</li><li id="4ad0" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated">将<code class="fe kl km kn ko b">componentDidMount</code>替换为<code class="fe kl km kn ko b">useEffect</code>。</li><li id="094c" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated">去掉“<code class="fe kl km kn ko b">render()</code>功能</li><li id="c18b" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated">将“const”放在所有函数声明之前</li><li id="081d" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated">去掉所有变量前面的this.state</li><li id="703b" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated">在其他地方(在函数调用前)去掉“this”</li></ol><p id="f89b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我们开始吧。下面，我将执行每一步，为了清楚起见，旧的类版本被直接注释掉了。</p><h2 id="06e9" class="lu kx iq bd ky lv lw dn lc lx ly dp lg jy lz ma lk kc mb mc lo kg md me ls mf bi translated">更改React的导入。</h2><p id="98a5" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">我们不再需要组件。相反，我们需要导入<code class="fe kl km kn ko b">useState</code>和<code class="fe kl km kn ko b">useEffect</code>:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nv"><img src="../Images/a1d950d88502d9d4ac705552b6680194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nLjjfvkPuF1-75M0zfTtrg.png"/></div></div></figure><h2 id="2e00" class="lu kx iq bd ky lv lw dn lc lx ly dp lg jy lz ma lk kc mb mc lo kg md me ls mf bi translated">2.更改声明语法。</h2><p id="72dd" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">这只是一个简单的语法调整。你知道这个…</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nw"><img src="../Images/42644fe8b3ae702b04c4ff18f2787510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LBmddRXuYozGdbTL65po7Q.png"/></div></div></figure><h2 id="727e" class="lu kx iq bd ky lv lw dn lc lx ly dp lg jy lz ma lk kc mb mc lo kg md me ls mf bi translated">3.用useState的实现替换初始状态声明。</h2><p id="ab83" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">这里，我们在一个数组中创建变量及其setter(通常是“set”+“Variable name”)，然后为变量提供一个初始值作为参数给<code class="fe kl km kn ko b">useState</code>:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nx"><img src="../Images/500104aeb1c43dcb20ad6d791132a339.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EZiRfSAAw0ZcIR0vyeNQAg.png"/></div></div></figure><h2 id="efad" class="lu kx iq bd ky lv lw dn lc lx ly dp lg jy lz ma lk kc mb mc lo kg md me ls mf bi translated">4.用步骤2中创建的设置器替换setState用法。</h2><p id="a727" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">现在，只需遍历和任何时候this.setState出现，只需使用适当的getter！这里有两个提示。一，用CTRL+F找到setState！第二，对于受控表单，我们可以完全去掉<code class="fe kl km kn ko b">handleChange</code>函数，只在表单上使用内嵌的setters:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi ny"><img src="../Images/4ec9df416f00aa208b9230b228d14cfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rhv1V4Ob17DhaaM3XfVq6w.png"/></div></div></figure><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nz"><img src="../Images/474c83271c4a773849ff937d7685ff82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kbFpB-eDBossIu0EPRlrvg.png"/></div></div></figure><h2 id="d462" class="lu kx iq bd ky lv lw dn lc lx ly dp lg jy lz ma lk kc mb mc lo kg md me ls mf bi translated">5.将componentDidMount替换为useEffect。</h2><p id="4b58" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">在这里，我们使用完全相同的函数体(禁止任何这种用法。或者this.state)作为传递给<code class="fe kl km kn ko b">useEffect</code>的回调的主体。我们传递一个空数组作为第二个参数，使用Effect来表示我们希望这个函数只在初始挂载时运行。</p><p id="50dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ml">记住，我们可以在这里不传递任何东西来指示它应该在组件更新的任何时候运行，或者传递一个依赖变量的数组，我们希望它的变化触发函数</em></p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi oa"><img src="../Images/24f8f6c009f4aaf32d8a8e497aedfa32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*394y8i4QCKuU60pVECJ16g.png"/></div></div></figure><h2 id="1c52" class="lu kx iq bd ky lv lw dn lc lx ly dp lg jy lz ma lk kc mb mc lo kg md me ls mf bi translated">6.去掉“render()”函数</h2><p id="e148" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">这就像注释掉一行一样简单…</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi ob"><img src="../Images/eaa685c1dded75bf823780fdcaa03993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EMshTfhiWhsgtGPDv0imfQ.png"/></div></div></figure><h2 id="d34a" class="lu kx iq bd ky lv lw dn lc lx ly dp lg jy lz ma lk kc mb mc lo kg md me ls mf bi translated">7.将“const”放在所有函数声明之前</h2><p id="35c5" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">我不认为你需要一个直观的例子！</p><h2 id="e752" class="lu kx iq bd ky lv lw dn lc lx ly dp lg jy lz ma lk kc mb mc lo kg md me ls mf bi translated">8.去掉所有变量前面的this.state</h2><h2 id="ceef" class="lu kx iq bd ky lv lw dn lc lx ly dp lg jy lz ma lk kc mb mc lo kg md me ls mf bi translated">和</h2><h2 id="c48b" class="lu kx iq bd ky lv lw dn lc lx ly dp lg jy lz ma lk kc mb mc lo kg md me ls mf bi translated">9.在其他地方(在函数调用前)去掉“this”</h2><p id="b035" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">还是那句话，在这里用你的朋友CTRL+F！</p><p id="927b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有维奥拉。您有一个利用状态和生命周期方法的功能组件！</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="3e41" class="lu kx iq bd ky lv lw dn lc lx ly dp lg jy lz ma lk kc mb mc lo kg md me ls mf bi translated">那又怎样？</h2><p id="78d1" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">那我们为什么要经历这一切？首先，它使代码更干净、更短、更简单。功能组件是54行代码，类组件是67行。更重要的是，如果你通过一个<a class="ae mz" href="https://babeljs.io/en/repl" rel="noopener ugc nofollow" target="_blank"> JS编译器</a>运行每一个，类组件是121行，函数组件是85行长！但是除了代码行之外，跟踪功能组件更容易。变量设置器将状态更新为(甚至比以前更多)普通英语。我们还可以完全控制何时以及为什么运行我们的<code class="fe kl km kn ko b">useEffect</code>回调函数，并且我们可以优化组件的效率。</p><p id="867e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，我们处理的是一个非常简单的组件，所以我们甚至还没有开始接触钩子有多动态和漂亮。但是这几乎涵盖了开始将类组件转换成功能组件所需了解的一切。当你这样做时，你可以潜入其他钩子如<code class="fe kl km kn ko b">useCallback</code>和<code class="fe kl km kn ko b">useMemo</code>来使你的组件更加有效，但是如果你只是从一步一步开始(就像我们上面做的那样)，你很快就会开始烹饪。</p><p id="042c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽情享受吧！</p></div></div>    
</body>
</html>