<html>
<head>
<title>Fully Automated NextJS Builds/Deployments (GitHub, AWS ECR, Fargate Service, ECS)- Part 2/4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">完全自动化的NextJS构建/部署(GitHub、AWS ECR、Fargate Service、ECS)——第2/4部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/fully-automated-nextjs-builds-deployments-github-aws-ecr-fargate-service-ecs-part-2-4-36caa082676a?source=collection_archive---------1-----------------------#2022-05-05">https://levelup.gitconnected.com/fully-automated-nextjs-builds-deployments-github-aws-ecr-fargate-service-ecs-part-2-4-36caa082676a?source=collection_archive---------1-----------------------#2022-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9dfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如在我的DevOps/ AWS部署教程的第一部分中所宣布的，这一次将是关于GitHub工作流/动作和用于从GitHub到AWS的认证的OIDC令牌。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/bb17143d728d241df31ac21092e4f7d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RqzLm7sGUwyUAjMWWIqy_A.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图片来源:stock.adobe.com</figcaption></figure><p id="2b1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的上一篇文章中，我们进入了典型的DevOps主题，并开始考虑在AWS上部署一个NextJS应用程序。在这一点上，我想马上重申，我认为作为一名开发人员，能够将服务从第一行代码一直带到产品中是现代软件开发的一个基本部分。</p><h1 id="6878" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">教程的内容</h1><p id="3192" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated"><a class="ae me" rel="noopener ugc nofollow" target="_blank" href="/fully-automated-nextjs-builds-deployments-github-aws-ecr-fargate-service-ecs-part-1-4-6216e58dcb89">第一部分— Docker图像/ ECR平台部署&amp;推送图像。</a></p><p id="d0ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第二部分—完全GitHub集成&amp; TF后端AWS/S3 </strong></p><p id="0ec5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第三部分—在AWS上部署Fargate Terraform(基础设施即代码)</p><p id="e6f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第四部分—为生产优化Dockerfile</p><h1 id="0d57" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">一些想法…</h1><p id="456c" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">在决定选择技术和框架时，考虑操作，当然还有安全性和稳定性是很重要的。如果程序只在自己的机器上运行，那么再漂亮的程序也是无用的。从过去的过程方法来看，我记得人们经常编码，而没有想到在某个时候必须有人运行应用程序。“<em class="mf">让我们在最后</em>做吧”，这是人们常说的话。为首次展示构建管道通常是一个下游步骤。然而，根据我的经验和知识，部署必须是项目开始的第一步。毕竟，我想确切地知道我的应用程序将如何以及在哪里运行，并且能够持续地监视和呈现结果和中间状态。</p><p id="6e28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在开始时设置CI/CD管道也没有错。我们有一切必要的工具来做到这一点。GitHub、Azure DevOps或Gitlab让我们很容易做到这一点。</p><p id="0bd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本教程中，我将使用GitHub在AWS <em class="mf">弹性容器服务</em>上启动web应用程序，作为<em class="mf"> Fargate </em>服务。</p><h1 id="50a3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">打开ID连接</h1><p id="dbec" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我见过数百个CI/CD管道，其中存储了访问云资源的凭证。显然，这不是一个好主意。即使GitHub机密在保存后不再可读，如果您不想每天更改它们，凭证至少必须有更长的有效期。或者创建永久有效的凭证，但我认为从安全角度来看这是有问题的。通常，为此会引入一种技术用户<em class="mf"/>,用于在云提供商的指导下从管道获得授权。总之，不是好办法。</p><p id="8130" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，一段时间以来，GitHub一直提供OpenID Connect来验证AWS。设置非常简单。我们首先需要在AWS控制台中设置一些东西。</p><p id="255c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，在AWS控制台的身份和访问管理(IAM)下，如果GitHub没有身份提供者，我们需要创建一个身份提供者。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mg"><img src="../Images/0d253f75e0c2b72286183c3b1716044e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y0ugRJtXqd0IPamWb-Iagw.png"/></div></div></figure><p id="26d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">提供者URL是https://token.actions.githubusercontent.com的<a class="ae me" href="https://token.actions.githubusercontent.com" rel="noopener ugc nofollow" target="_blank">，受众是sts.amazonaws.com的<em class="mf">。还需要使用“获取指纹”按钮来获取指纹。</em></a></p><p id="6e6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦创建了提供者，我们就可以创建必要的IAM角色，这将允许我们从GitHub操作访问AWS资源。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mh"><img src="../Images/1d7485aae3b1261afb8339f1c3679e21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MbTIjJw-aDdXdZ3IhzpLwA.png"/></div></div></figure><p id="e8ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">可信实体类型</strong>是<strong class="jp ir">网络身份</strong>。身份提供者必须选择为<em class="mf">token.actions.githubusercontent.com</em>。这是我们刚刚创建的提供者。在观众选择列表中，您应该只能看到条目<em class="mf">sts.amazonaws.com</em>，该条目也必须被选中。</p><p id="c59e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是分配权限。这可以是非常具体的或完全的访问。当然，创建精确的策略是可能的。在我们的例子中，我们让它更开放一点，并赋予角色完全的访问权限。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mi"><img src="../Images/d7f6e7feb55b88223708bd34f21323aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aD5DWqdmApqHg62Ea7L0gw.png"/></div></div></figure><p id="3db4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在最后一步中，我们必须分配角色的名称，例如<em class="mf"> github-role </em>。</p><p id="bf9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建角色后，我们需要再次打开角色进行编辑，以调整<strong class="jp ir">信任关系</strong>。在这里，我们必须纠正这种情况。key<em class="mf">token . actions . githubusercontent . com:sub</em>必须获取所需的GitHub存储库作为值，参见下面的代码示例。</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="d049" class="mo lc iq mk b gy mp mq l mr ms">"Condition": {<br/>                "StringLike": {<br/>                    "token.actions.githubusercontent.com:sub": "repo:&lt;your-github-org&gt;/&lt;your-repo&gt;:*",<br/>                    "token.actions.githubusercontent.com:aud": "sts.amazonaws.com"<br/>                }<br/>            }</span></pre><p id="5aac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，角色就准备好了，可以在GitHub工作流中使用。</p><h1 id="ca7f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">GitHub工作流程</h1><p id="df0f" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">为了集成工作流，我们现在需要在项目中创建以下新文件夹。</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="fac1" class="mo lc iq mk b gy mp mq l mr ms">$ mkdir .github<br/>$ cd .github &amp;&amp; mkdir workflows<br/>$ cd workflows</span></pre><p id="d532" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在。github/workflows 文件夹，然后我们需要一个包含我们动作的文件。</p><p id="e329" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mt mu mv mk b">$ touch ci-cd-pipeline.yml</code></p><p id="fe53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们应该有如下的项目结构。</p><p id="e426" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mt mu mv mk b">.<br/>|-- .github<br/>| `-- workflows<br/>|-- pages<br/>| `-- api<br/>|-- public<br/>|-- styles<br/>`-- terraform<br/> `-- registry</code></p><p id="d8ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一步，我将下面的代码添加到<em class="mf"> ci-cd-pipeline.yml </em>中。</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="c591" class="mo lc iq mk b gy mp mq l mr ms">name: CI/CD Pipeline</span><span id="d0f1" class="mo lc iq mk b gy mw mq l mr ms">on:<br/>  push:<br/>    branches: [ main ]</span><span id="d404" class="mo lc iq mk b gy mw mq l mr ms">permissions:<br/>  id-token: write<br/>  contents: read</span><span id="9959" class="mo lc iq mk b gy mw mq l mr ms">env:<br/>  AWS_REGION: eu-central-1</span></pre><p id="d0cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">管道的名称可以自由选择，并且是可选的。然而，为了在GitHub操作中看到它是哪个管道，使用名称是有意义的。</p><p id="9915" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">新的分区权限很重要。“id-token”写入条目允许请求OIDC JWT ID令牌。如果没有此设置，就无法使用上一章中描述的身份验证方法。</p><p id="3f79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“内容:读取”权限也是使用“签出”操作所必需的。</p><p id="8756" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="mf"> env </em>下，我已经设置了一个AWS_REGION，应该在这里创建资源。</p><p id="47f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们记得在教程的第一部分，我们已经创建了一个Terraform脚本来创建一个弹性容器注册表(ECR)。我们已经在本地运行了它，以便在AWS上创建资源。为此，我们向终端添加了AWS凭证。如前所述，OIDC提供者现在将避免使用凭证。我们已经在GitHub存储库和AWS之间建立了信任，现在希望在使用GitHub工作流中的一个步骤创建ECR时利用这一点。</p><p id="06d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们使用如下的<strong class="jp ir">AWS-actions/configure-AWS-credentials @ v1</strong>操作:</p><p id="025c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mt mu mv mk b">jobs:<br/> registry:<br/> runs-on: ubuntu-20.04<br/> steps:<br/> - name: Check Out<br/> uses: actions/checkout@v2<br/> - name: Configure AWS Credentials<br/> uses: aws-actions/configure-aws-credentials@v1<br/> with:<br/> role-to-assume: arn:aws:iam::&lt;your-account-id&gt;:oidc-provider/token.actions.githubusercontent.com<br/> aws-region: ${{ env.AWS_REGION }}<br/> - name: Create Registry<br/> id: create-registry<br/> run: |<br/> ...</code></p><p id="3e56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个操作，我们需要输入AWS角色的ARN，带有:<strong class="jp ir"> role-to-assume </strong>和aws-region。</p><p id="a660" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原则上，我们现在可以像这样使用管道，因为我们已经使用OIDC令牌进行了身份验证。</p><p id="be0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是别说了。如果我们不再单独在本地使用我们的Terraform脚本，我们必须确保Terraform状态是集中可用的，并且在执行时被锁定。</p><p id="07c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们需要一个所谓的后端配置。</p><h1 id="bb62" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">地形状态</h1><p id="107b" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">为了使Terraform状态在一个<em class="mf">多用户</em>环境中保持不变，我们首先需要在我们的<em class="mf">/terraform/registry/main . TF</em>中将下面一行添加到资源“terra form”中。</p><p id="ac60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mt mu mv mk b">backend "s3" { /* See the backend config in config/backend-config.tf */ }</code></p><p id="1bfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您已经看到的，我们将需要一个S3桶来存储状态。</p><p id="0bd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们将在文件夹<em class="mf"> /terraform/registry </em>中创建一个名为<em class="mf"> backend-config.tf </em>的新文件。这将得到所有必要的设置，见下面的例子。</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="756d" class="mo lc iq mk b gy mp mq l mr ms">bucket                      = "terraform-states"<br/>key                         = "ci-cd-example.tfstate"<br/>region                      = "eu-central-1"<br/>encrypt                     = true<br/>dynamodb_table              = "terraform-locks"</span></pre><p id="0a12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重要。在执行之前，S3存储桶和DynamoDB必须存在。基本上，可以为AWS上的多个管道创建一次。每个管道的密钥必须是唯一的，这一点非常重要。</p><p id="37d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于DynamoDB表，需要一个名为“LockID”的分区键。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mx"><img src="../Images/8e05c771567949e828b4742b7f9d270f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mtjh1BQK93DaC0WZE5KqDQ.png"/></div></div></figure><p id="7014" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在剩下的工作是添加一个步骤来执行Terraform命令:</p><p id="e35c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mt mu mv mk b">- name: Create Registry<br/> id: create-registry<br/> run: |<br/> cd terraform/registry/</code></p><p id="e3d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mt mu mv mk b">terraform init \<br/> -backend-config=config/backend-config.tf \<br/> -reconfigure \<br/> -input=false<br/> <br/> terraform apply \<br/> -var-file=vars.tfvars \<br/> -input=false \<br/> -auto-approve</code></p><p id="f4cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至此，我们基本上已经准备好使用GitHub Pipeline推出ECR了。让我们再来看看我们到目前为止创建的GitHub工作流。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi my"><img src="../Images/7b418e4b69b7878f4d6088f717434cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*R_JktX3s7KKzfJBBjKhLyg.png"/></div></figure><p id="3c3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过存储库的Git <em class="mf">提交</em> &amp; <em class="mf">推送</em>，管道被自动执行，资源在AWS上被创建。如你所见，我将AWS GitHub OIDC角色的ARN外包给了GitHub secret，并且只在工作流中引用它。这当然增加了安全性。</p><p id="2a02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的。目标实现。ECR现在是使用管道创建的。Terraform状态被安全地集中管理，并在执行时被锁定。</p><h1 id="3c71" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Docker构建和推送</h1><p id="f63d" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">现在让我们在第二个工作流作业中流水线化Docker构建，并自动化它。</p><p id="7afb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在教程的第一部分，我们已经深入研究了各个必要的步骤。现在我们只需要将代码转移到工作流作业中。此外，我们仍然需要适当的标签，我想从Git提交散列中获得这些标签。这在以后是很重要的，这样<em class="mf"> Fargate </em>服务/任务就能识别出一个新的镜像版本可用，容器也被更新。此外，我不喜欢固定存储库的名称，而是希望从Terraform输出中获取它。</p><p id="df29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经在<em class="mf">/terraform/registry/main . TF .</em>中定义了terra form输出</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="75e6" class="mo lc iq mk b gy mp mq l mr ms">output "repository_name" {<br/>  description = "The name of the repository."<br/>  value = aws_ecr_repository.repository.name<br/>}</span></pre><p id="f85e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们只需要将它转移到下一个工作流作业。为此，GitHub提供了指定作业输出的可能性。为此，需要对ECR创建的第一步进行补充:</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="832f" class="mo lc iq mk b gy mp mq l mr ms">jobs:<br/>  registry:<br/>    runs-on: ubuntu-20.04<br/>    outputs:<br/>      repository-name: ${{ steps.create-registry.outputs.repository-name }}</span></pre><p id="015c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在create-registry步骤中，必须在末尾添加以下行，以将Terraform输出映射到步骤/作业输出。</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="24b1" class="mo lc iq mk b gy mp mq l mr ms">export REPOSITORY_NAME=$(terraform output --raw repository_name)<br/><br/>echo "::set-output name=repository-name::$REPOSITORY_NAME"</span></pre><p id="3c9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这允许在下一个作业中重用作业输出。</p><p id="c29c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是时候创建工作流中的下一个作业了。仅当ECR创建成功时，才应执行此作业。GitHub Actions知道它的需求属性。这表明成功执行相应的指定是执行作业所必需的。</p><p id="567c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，作业“registry”是必需的。</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="094a" class="mo lc iq mk b gy mp mq l mr ms">docker-build:<br/>    runs-on: ubuntu-20.04<br/>    needs: [registry]</span></pre><p id="c176" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还希望使用注册表作业的输出来复制尽可能少的变量。环境变量REPOSITORY_NAME是从注册表作业的输出中获得的，如下所示。</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="106a" class="mo lc iq mk b gy mp mq l mr ms">docker-build:<br/>    runs-on: ubuntu-20.04<br/>    needs: [registry]<br/>    env:<br/>      REPOSITORY_NAME: ${{ needs.registry.outputs.repository-name }}<br/>      ACCOUNT_ID: {{ secrets.ACCOUNT_ID }}</span></pre><p id="4487" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Docker构建作业中的运行步骤如下所示。</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="6c83" class="mo lc iq mk b gy mp mq l mr ms">- name: Image build and push<br/>        id: docker-build<br/>        run: |<br/>          export IMAGE_TAG=$(git rev-parse --short HEAD)<br/><br/>          export ACCOUNT_ID=$(aws sts get-caller-identity | jq -r .Account)<br/>          aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com<br/>          export REPOSITORY_URL=${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${REPOSITORY_NAME}<br/>          <br/>          docker build --platform linux/amd64 -t ${REPOSITORY_NAME}:${IMAGE_TAG} .<br/>          docker tag ${REPOSITORY_NAME}:${IMAGE_TAG} ${REPOSITORY_URL}:${IMAGE_TAG}<br/>          docker push ${REPOSITORY_URL}:${IMAGE_TAG}</span></pre><p id="67e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这包括登录ECR和Docker命令build、tag和push，如前一集所述。</p><p id="c6ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在从Git提交散列中动态创建image标签，以便稍后在<em class="mf"> Fargate </em>上启动容器更新。</p><p id="3f4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据当前设置，我们现在可以运行工作流，完全自动地创建ECR和Docker映像。将主分支推送到GitHub时会自动发生这种情况。</p><p id="420f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，在下一集，我们将看看如何使用Terraform和GitHub workflow在AWS上创建一个<em class="mf"> Fargate </em>服务。</p><p id="2148" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mf">快乐编码！</em></p><p id="e89d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和往常一样，你可以在<a class="ae me" href="https://github.com/codewithrico/cicd-tutorial-part-2" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到所有代码。</p></div></div>    
</body>
</html>