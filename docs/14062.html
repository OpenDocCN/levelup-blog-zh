<html>
<head>
<title>Transaction Management in Golang via Closures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang中通过闭包的事务管理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/transaction-management-in-golang-via-closures-dd964108a1bc?source=collection_archive---------2-----------------------#2022-10-29">https://levelup.gitconnected.com/transaction-management-in-golang-via-closures-dd964108a1bc?source=collection_archive---------2-----------------------#2022-10-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7847" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据库管理中最熟悉和最重要的主题之一是原子性。这是数据库的一个属性，它保证要么执行所有指令，要么不执行任何指令。</p><p id="7359" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果是一个简单的SQL查询，它可以表示为</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="f7ce" class="ku kv iq kq b gy kw kx l ky kz">begin transaction;</span><span id="1500" class="ku kv iq kq b gy la kx l ky kz">// Sequence of queries </span><span id="8926" class="ku kv iq kq b gy la kx l ky kz">commit; or rollback;</span></pre><p id="3861" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">交易有两种类型</p><ul class=""><li id="95e7" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">一组不包含任何业务逻辑的SQL查询，可以驻留在数据库层。</li><li id="c2eb" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">我们需要将事务管理转移到服务层的情况。在这种情况下，我们运行一个查询并执行一些业务逻辑，根据业务逻辑的结果，我们决定是否需要提交或回滚我们在前面的查询中所做的更改。</li></ul><p id="42ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">案例2的示例:</p><ul class=""><li id="62c1" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">在Indmoney，我们发送一批100名用户进行Demat(交易账户)创建，并在状态轮询中执行以下一组操作</li><li id="a16f" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">更新批处理的状态(成功|失败)</li><li id="14f1" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">针对作为批处理一部分的每个用户更新帐户创建的状态(100 DB调用)。我们需要确保批处理状态&amp;所有100个网络调用成功或全部失败，以便我们可以重试。</li></ul><p id="3e95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于第二种情况，我们显然不能将业务逻辑放在数据库层中，因为DB层不理解如何解析批处理的响应，如何考虑批处理的状态是成功还是失败，如何考虑用户的交易帐户创建状态是已创建还是失败等。</p><p id="eb93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如何解决这个问题</strong>？</p><p id="65c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们提出的第一个解决方案有点容易出错，也有点粗糙，它将<code class="fe lp lq lr kq b">BeginTransaction</code>、<code class="fe lp lq lr kq b">Commit</code>和<code class="fe lp lq lr kq b">Rollback</code>操作暴露给服务层，并使用Go的命名Returns + Defer函数来拯救。代码如下所示。</p><figure class="kl km kn ko gt ls"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="15ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你看上面的代码，我们打开一个事务，我们做一组操作，如果任何操作中途失败，我们返回一个错误。在defer块中，我们使用golang的命名返回功能，并检查在执行操作时是否存在应用程序错误。</p><ul class=""><li id="1667" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">如果是，回滚未完成的事务。</li><li id="c54e" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">如果否，提交打开的事务。</li></ul><p id="0a23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这其中的主要缺陷是</p><ul class=""><li id="b244" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">我有20个这样的地方，我需要在我的代码库中执行事务，我需要有20个地方，我需要在我的服务层中编写提交和回滚逻辑，在理想情况下，服务层不应该对此负责。</li><li id="8596" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">数据库层需要信任服务层提交或回滚打开的事务。否则会造成泄漏。</li></ul><p id="ad5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">封杀来了</strong>。让我们看看使用闭包的代码是什么样子的。</p><p id="e55b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">服务层</strong></p><figure class="kl km kn ko gt ls"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="c2e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">数据库层</strong></p><figure class="kl km kn ko gt ls"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="6aa9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在使用闭包的第二种方法中，服务层只需要知道从代码的哪一部分到代码的哪一部分必须是原子性的。它只需要将整个业务逻辑包装在原子接口中，而不必再处理事务管理。</p><p id="b304" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据库层公开了一个名为<code class="fe lp lq lr kq b">Atomic</code>的功能，它是一个高阶函数，接受实现DAO对象的函数。</p><p id="3683" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">调用者将业务逻辑包装在原子接口中，一旦被调用，数据库层就将一个新的连接传递给params中接受的函数，该函数将用于执行所有DB操作。</p><p id="14a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">调用者必须使用这个<code class="fe lp lq lr kq b">store</code>对象来执行所有应该是原子的操作，如果在处理任何操作时出现错误，它必须返回。一旦执行完所有操作，如果函数返回一个错误，就由数据库层决定是提交还是回滚。这样，我们不会在数据库层之外的任何地方公开事务，服务层只负责执行业务逻辑。</p><p id="d448" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">— — — — — — — — — — — — — — — — — — 0 — — — — — — — — — — — — — — — — — — —</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><p id="0cbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="9241" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="9453" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">📰更多内容请查看<a class="ae mc" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码刊物</a></li><li id="1aa0" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">🔔关注我们:<a class="ae mc" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae mc" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae mc" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="855c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀👉<a class="ae mc" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">将像你这样的开发人员安置在顶级创业公司和科技公司</strong> </a></p></div></div>    
</body>
</html>