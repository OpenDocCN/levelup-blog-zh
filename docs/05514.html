<html>
<head>
<title>Dog Breed Classifier With PyTorch Using Transfer Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于迁移学习的PyTorch犬种分类器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dog-breed-classifier-with-pytorch-using-transfer-learning-8f15af6f9010?source=collection_archive---------2-----------------------#2020-09-05">https://levelup.gitconnected.com/dog-breed-classifier-with-pytorch-using-transfer-learning-8f15af6f9010?source=collection_archive---------2-----------------------#2020-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e0e6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一步一步的指南来创建自己的狗品种分类器。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/42f819cf0e614e085065bba3d0ce8526.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vWY12J5GhavUwwUJwNlHug.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://theblissfuldog.com/search?type=article&amp;q=Kathy%20Dannel%20Vitcak" rel="noopener ugc nofollow" target="_blank">凯西·庄小昆·维特卡创作</a></figcaption></figure><p id="7bd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么你以前听过深度学习这个词吗？还是刚开始学？</p><p id="ad92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将指导你建立自己的狗品种分类器。在这个项目结束时，</p><ul class=""><li id="d200" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">您的代码将接受任何用户提供的图像作为输入。</li><li id="2e62" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果在图像中检测到狗，它将提供狗的品种的估计。</li><li id="35bd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果检测到人类，它将提供一个最相似的狗品种的估计。</li></ul><p id="e075" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我会让它尽可能简单，而不会让你不知所措。</p><h1 id="38d5" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">前方的路</h1><ul class=""><li id="e170" class="ls lt iq ky b kz my lc mz lf na lj nb ln nc lr lx ly lz ma bi translated">步骤0:导入数据集</li><li id="8d01" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">步骤1:图像预处理</li><li id="80d7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">第二步:选择迁移学习的模式</li><li id="b832" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">步骤3:更改预训练模型的分类器</li><li id="154f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">步骤4:编写训练算法</li><li id="3e8f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">第五步:训练模型</li><li id="bd1a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">步骤6:测试模型</li><li id="30f2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">步骤7:在你自己的图片上测试</li></ul><p id="d70b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你兴奋吗？？？让我们开始吧！</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="82a2" class="mg mh iq bd mi mj nk ml mm mn nl mp mq jw nm jx ms jz nn ka mu kc no kd mw mx bi translated">步骤0:导入数据集</h1><p id="d1a0" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">你可以从Kaggle下载你自己的数据集，访问这个<a class="ae kv" href="https://www.kaggle.com/c/dog-breed-identification" rel="noopener ugc nofollow" target="_blank">网站</a>。或者，你可以从<a class="ae kv" href="https://drive.google.com/file/d/1K57UHSJsCsjQCTi5yutgUtyzKJK36U86/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">这里</a>下载。</p><p id="f083" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后只需解压zip文件！</p><p id="88a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于在本地机器上处理图像需要大量的时间和资源，因此我将使用colab的GPU来训练我的模型。因此，如果你没有自己的GPU，确保你切换到colab跟随。</p><p id="8d9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将必要的库<strong class="ky ir">导入到笔记本的第一个块中总是一个好的做法。所以我们会在这里做。</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">导入库</figcaption></figure><p id="92a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在glob括号的双引号内输入dog_images的路径。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">将图像导入笔记本</figcaption></figure><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="8bd9" class="nz mh iq nv b gy oa ob l oc od">Output : There are 8351 total dog images.</span></pre><h1 id="ac3f" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">步骤1:图像预处理</h1><p id="9858" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">首先，您需要将train、validation和test文件夹加载到一些变量中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="e2ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，您需要对加载的图像进行一些转换。这被称为数据的<strong class="ky ir">预处理。</strong></p><h2 id="473c" class="nz mh iq bd mi oe of dn mm og oh dp mq lf oi oj ms lj ok ol mu ln om on mw oo bi translated">为什么有必要？</h2><ul class=""><li id="8a7c" class="ls lt iq ky b kz my lc mz lf na lj nb ln nc lr lx ly lz ma bi translated">您的图像必须与网络的输入大小相匹配。如果您需要调整图像的大小以匹配网络，则可以将数据重新缩放或裁剪到所需的大小。</li><li id="983d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">增强</strong>也能让你训练网络对图像数据的失真保持不变。为此，我会随机裁剪和调整图像的大小</li><li id="e04d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">数据标准化是</strong>一个重要的步骤，它确保每个输入参数(本例中为像素)具有相似的<strong class="ky ir">数据</strong>分布。这使得收敛更快，同时训练网络。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="6008" class="nz mh iq bd mi oe of dn mm og oh dp mq lf oi oj ms lj ok ol mu ln om on mw oo bi translated">将图像存储到数据加载器中</h2><p id="05f5" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">现在我们需要将train、valid和test目录加载到数据加载器中。这将使我们能够把数据分成小批量。</p><p id="84bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我会将加载器作为键值对存储到字典中，这将有助于以后调用它们。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h1 id="01e6" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">第二步:选择迁移学习的模式</h1><h2 id="21e0" class="nz mh iq bd mi oe of dn mm og oh dp mq lf oi oj ms lj ok ol mu ln om on mw oo bi translated">什么是预训练模型，我们为什么要使用它？</h2><p id="6d99" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">预训练模型是由其他人创建的用于解决类似问题的模型。</p><ul class=""><li id="26d6" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">你不是从零开始建立一个模型来解决一个类似的问题，而是将这个模型作为一个起点。</li><li id="2546" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">一个预先训练好的模型在你的应用中可能不是100%准确，但是它节省了重新发明轮子所需的巨大努力。</li><li id="3dfd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">迁移学习</strong>包括利用在一个问题上学到的特点，并在一个新的类似问题上利用它们。例如，已经学会识别浣熊的模型的特征可能有助于启动旨在识别塔努基的模型。</li></ul><p id="252d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有几种预先训练好的模型可供您选择进行模型训练。例如Densenet、Resnet、VGG模型。我会用VGG-16进行模型训练。你可以在pytorch <a class="ae kv" href="https://pytorch.org/docs/stable/torchvision/models.html" rel="noopener ugc nofollow" target="_blank">这里</a>阅读其他型号。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h1 id="6410" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">步骤3:更改预训练模型的分类器</h1><p id="e2dc" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">将采取以下步骤来改变预训练的分类器:</p><ol class=""><li id="a1eb" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr op ly lz ma bi translated">从先前训练的模型中提取图层。</li><li id="0673" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr op ly lz ma bi translated">冻结它们，以避免在未来的训练中破坏它们所包含的任何信息。</li><li id="681d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr op ly lz ma bi translated">在冻结层上添加一些新的可训练层。他们将学习将旧要素转化为新数据集的预测。</li><li id="9b8d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr op ly lz ma bi translated">在数据集上训练新图层。</li></ol><p id="55f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于特征已经被预训练的模型学习，所以在对狗图像的训练期间将它们冻结。我们只会改变分类器的维度，只会训练它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/97b3d15ce28af285f26b648faf37d2e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*KgzfO6kdsHl73PqC5srNwQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">原始分类器层</figcaption></figure><p id="377a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原始分类器层有25088个维度，但是为了匹配我们预处理过的图像大小，我们需要把它改为4096。</p><p id="ac26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了在GPU上训练模型，我们需要使用以下命令将它移动到GPU-RAM空间中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="7532" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们需要选择一个损失函数和优化器。</p><p id="23c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">损失函数将计算我们的模型预测和实际图像之间的误差。如果你的预测完全错误，你的<strong class="ky ir">损失函数</strong>将输出一个更高的数字。如果他们很好，它会输出一个较低的数字。我将使用<strong class="ky ir">交叉熵损失</strong>。</p><p id="30bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">优化器是用来改变你的<strong class="ky ir">神经网络</strong>的属性的算法或方法，比如权重和<strong class="ky ir">学习速率</strong>，以减少损失。我会使用<strong class="ky ir"> SGD优化器</strong>。</p><p id="57f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">0.001的学习率有利于训练。但是你也可以尝试其他的学习速度。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h1 id="a895" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">步骤4:编写训练算法</h1><p id="f58f" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">现在到了激动人心的部分，我们将编写训练函数。我已经用代码写了注释。因为这个函数中的一切都是不言自明的。</p><p id="4ec5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经用它写了验证代码行。因此，在训练模型时，我们会同时受到两种损失。</p><p id="c1be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每次损失减少时，我也会存储模型。这样我就不必在以后每次打开新实例时都训练它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h1 id="487b" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">第五步:训练模型</h1><p id="d6d2" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">现在，我将通过在函数中提供参数来开始训练模型。我会训练它10个纪元。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="3ab3" class="nz mh iq nv b gy oa ob l oc od">OUTPUT:</span><span id="b848" class="nz mh iq nv b gy or ob l oc od">Epoch: 1 	Training Loss: 2.443815 	Validation Loss: 0.801671<br/>Validation loss decreased (inf --&gt; 0.801671).  Saving model ...<br/>Epoch: 2 	Training Loss: 1.440627 	Validation Loss: 0.591050<br/>Validation loss decreased (0.801671 --&gt; 0.591050).  Saving model ...<br/>Epoch: 3 	Training Loss: 1.310158 	Validation Loss: 0.560950<br/>Validation loss decreased (0.591050 --&gt; 0.560950).  Saving model ...<br/>Epoch: 4 	Training Loss: 1.200572 	Validation Loss: 0.566340<br/>Epoch: 5 	Training Loss: 1.160727 	Validation Loss: 0.530196<br/>Validation loss decreased (0.560950 --&gt; 0.530196).  Saving model ...<br/>Epoch: 6 	Training Loss: 1.088659 	Validation Loss: 0.560774<br/>Epoch: 7 	Training Loss: 1.060936 	Validation Loss: 0.503829<br/>Validation loss decreased (0.530196 --&gt; 0.503829).  Saving model ...<br/>Epoch: 8 	Training Loss: 1.010044 	Validation Loss: 0.500608<br/>Validation loss decreased (0.503829 --&gt; 0.500608).  Saving model ...<br/>Epoch: 9 	Training Loss: 1.054875 	Validation Loss: 0.497319<br/>Validation loss decreased (0.500608 --&gt; 0.497319).  Saving model ...<br/>Epoch: 10 	Training Loss: 1.000547 	Validation Loss: 0.545735</span><span id="502a" class="nz mh iq nv b gy or ob l oc od">&lt;All keys matched successfully&gt;</span></pre><h1 id="e067" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">步骤6:测试模型</h1><p id="3a70" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">现在，我将在模型以前没有见过的新图像上测试模型，并计算验证准确性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="eafb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经训练了10个纪元，获得了83%的准确率。并且，得到了下面的输出！</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="4beb" class="nz mh iq nv b gy oa ob l oc od">Output:<br/>Test Loss: 0.542430 Test Accuracy: 83% (700/836)</span></pre><h2 id="c616" class="nz mh iq bd mi oe of dn mm og oh dp mq lf oi oj ms lj ok ol mu ln om on mw oo bi translated">如何提高这个模型的准确性？</h2><ul class=""><li id="3959" class="ls lt iq ky b kz my lc mz lf na lj nb ln nc lr lx ly lz ma bi translated">通过对其进行更多时期的训练(比较训练和验证损失)</li><li id="fe8f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">通过改变学习率(如0.01，0.05，0.1)</li><li id="25b6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">通过改变预先训练的模型(类似密集网络，但需要更多的训练时间)</li><li id="b4c6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">通过进一步预处理图像</li></ul><h1 id="ce49" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">步骤7:测试你自己的图像</h1><p id="4065" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">现在您已经训练并测试了您的模型。现在是最激动人心的部分。你能走到这一步，我向你致敬。</p><ol class=""><li id="f987" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr op ly lz ma bi translated">将您想要测试的新图像和保存的模型加载到内存中</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="88b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.现在，我们必须对图像进行预处理，并通过将其测试到我们训练好的模型中来预测类别</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1210" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.现在，通过将图像路径作为参数传递给这个函数，我们可以预测狗的名字。</p><p id="f191" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经传递了下面的图像，并获得了这个名称作为输出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/6b5ec1c39f10796f28953c46b1c5d403.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*ve5wXWk5frK5OGItPCk62A.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Meme Doge <a class="ae kv" href="https://knowyourmeme.com/memes/doge" rel="noopener ugc nofollow" target="_blank"> Credits </a></figcaption></figure><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="5861" class="nz mh iq nv b gy oa ob l oc od">Output:<br/>Norwegian buhund</span></pre><p id="e91a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">挪威的布洪看起来很像我们的模因·多吉·:D</p><p id="2b69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结论</p><p id="c30d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这只是一个开始，你可以用这个模型做更多的事情。你可以通过在某个地方部署它来创建一个应用程序。我尝试过在不使用迁移学习的情况下从零开始创建自己的模型，但测试精度不能超过13%。你也可以试试，因为这有助于理解概念。</p><p id="e097" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请随时在<a class="ae kv" href="https://www.linkedin.com/in/ahmadshaikhk/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上与我联系。</p><h1 id="e10e" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">参考</h1><p id="3458" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">这个项目是我的Udacity的<a class="ae kv" href="https://www.udacity.com/course/deep-learning-nanodegree--nd101" rel="noopener ugc nofollow" target="_blank">深度学习</a>纳米学位的一部分。这是我为这个项目设计的Github <a class="ae kv" href="https://github.com/Ahmad-shaikh575/dog-breed-classifier/" rel="noopener ugc nofollow" target="_blank">库</a>。</p><p id="c728" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">预先训练好的VGG模型<a class="ae kv" href="https://arxiv.org/abs/1409.1556" rel="noopener ugc nofollow" target="_blank">研究论文</a>。</p><p id="8cd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">PyTorch官方<a class="ae kv" href="https://pytorch.org/docs/stable/index.html" rel="noopener ugc nofollow" target="_blank">网站</a>。</p></div></div>    
</body>
</html>