<html>
<head>
<title>Handle API lifecycle with React, Axios and Redux Toolkit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用React、Axios和Redux工具包处理API生命周期</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/handle-api-lifecycle-with-react-axios-and-redux-toolkit-1212645a6a06?source=collection_archive---------1-----------------------#2022-03-17">https://levelup.gitconnected.com/handle-api-lifecycle-with-react-axios-and-redux-toolkit-1212645a6a06?source=collection_archive---------1-----------------------#2022-03-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9a0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大家好，这一次我想和大家分享一下我在React项目中处理API请求的方法，并获得反馈。</p><p id="4f4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上下文是一个用<a class="ae kl" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">类型脚本</a>编写的<a class="ae kl" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>项目，其中我们有一个使用<a class="ae kl" href="https://redux-toolkit.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux工具包</a>处理的商店和由<a class="ae kl" href="https://axios-http.com/" rel="noopener ugc nofollow" target="_blank"> Axios </a>管理的API请求。根据当前组件，我们必须根据检索到的数据执行不同的操作，并定义一个公共接口来访问交换的数据。</p><blockquote class="km kn ko"><p id="5724" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">如果你想要一个更“捆绑”的解决方案，Redux Toolkit已经提供了<a class="ae kl" href="https://redux-toolkit.js.org/tutorials/rtk-query" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> RTK查询</strong> </a>实用程序。</p></blockquote></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><p id="482f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很好，现在我们可以开始编码了。我们知道每个请求可能处于四种状态:</p><ol class=""><li id="a335" class="la lb iq jp b jq jr ju jv jy lc kc ld kg le kk lf lg lh li bi translated"><strong class="jp ir">空闲:</strong>请求未发送，因此我们没有数据和错误</li><li id="a939" class="la lb iq jp b jq lj ju lk jy ll kc lm kg ln kk lf lg lh li bi translated"><strong class="jp ir">待定:</strong>请求已发送，但我们还没有数据和错误。</li><li id="6f0f" class="la lb iq jp b jq lj ju lk jy ll kc lm kg ln kk lf lg lh li bi translated"><strong class="jp ir">已完成:</strong>请求已发送，我们已收到数据。</li><li id="ae44" class="la lb iq jp b jq lj ju lk jy ll kc lm kg ln kk lf lg lh li bi translated"><strong class="jp ir">拒绝:</strong>请求已发送，但出现问题。</li></ol><p id="14bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是知道如果请求被拒绝，如何处理错误。也许我们可以有一条消息和一个代码来标识错误类型。</p><p id="d460" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这两个步骤，我们就有了处理所有请求的通用结构:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/64dc36fc7fbdde649a2dd9bf322e0749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YbULjJ6fof8MLVgXAJ641w.png"/></div></div></figure><p id="4429" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们必须使用拦截器设置至少一个axios实例，以正确处理数据。对于这个例子，我们将创建一个没有自定义头或奇怪逻辑的通用实例。如果请求失败时服务器返回一个已定义的响应(如APIError类型),这将非常有用。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ma"><img src="../Images/73db86f7d5a62e8486b715b665a4df00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XQff34EZR8ymv5kQM2QgkQ.png"/></div></div></figure><blockquote class="km kn ko"><p id="00b8" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">如果一个请求在没有任何有效主体的情况下失败，就会引入<em class="iq">内部错误</em>。</p></blockquote><p id="99ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，我们可以构建redux部分来处理请求及其响应。因此，我们必须定义状态、减速器和动作:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mb"><img src="../Images/b83b576d37e87b09e56f2e600b8a5745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G9L5d1aP-BZEugdEJW7_hQ.png"/></div></div></figure><p id="84b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">函数<em class="kp"> getExceptionPayload </em>将异常转换为APIError类型。如果异常是由axios抛出的，我们可以读取API响应，否则，如果异常是由我们的逻辑引起的，我们可以设置一个自定义错误。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mc"><img src="../Images/47d68048989f129283055b918a3a66eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mj4OQg_67TPUTsZGpN1bbg.png"/></div></div></figure><p id="e8c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在有了所有的工具来分派动作、处理结果，并将数据分布到连接到商店的所有组件上。但是..如何在组件内部管理它？</p><p id="0dcf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一种方法可以是处理<a class="ae kl" href="https://it.reactjs.org/docs/hooks-reference.html#useeffect" rel="noopener ugc nofollow" target="_blank"> useEffect </a>钩子中的数据(一次全部处理，或者每个状态一个钩子，其中有逻辑要执行)</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi md"><img src="../Images/bc50536b03ebd79096a1890b823ed36c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aRTuYYstsALT2eHPL2WIDg.png"/></div></div></figure><p id="07de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二种方法是创建一个自定义挂钩，以降低检查每个状态和处理所有相关类型的代码复杂性:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi me"><img src="../Images/ab086d250cf2cb643b40757bc0ad8701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-jKrFZIR9AOXZFWEIPaXxg.png"/></div></div></figure><p id="c9f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的钩子保留了API中定义的类型，并为每个状态直接提供了可用的数据。第一个参数是使用的APIData对象，第二个参数是我们可以为每个状态定义回调的对象(如果现在有commons logics，我们可以直接在多个API中重用同一个回调)。</p><blockquote class="km kn ko"><p id="a107" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">如果第二个参数对象是在我们的组件中内联定义的，我们需要将它包装在<a class="ae kl" href="https://it.reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank"> useMemo </a>回调中，否则，对于每个渲染周期，<a class="ae kl" href="https://javascript.info/object-copy" rel="noopener ugc nofollow" target="_blank">对象将改变</a>再次触发事件。</p></blockquote><p id="25a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的代码与之前使用的逻辑相同，但带有<em class="kp"> useAPIData挂钩</em>:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ca"><img src="../Images/50c9b682b3a1274aea1dabb16aab220e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c8VOx9Inxdcd-OdMK1xXCg.png"/></div></div></figure><p id="b6ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，我将对象内联以显示useMemo hook的用法，但是，如果不依赖于其他组件的变量，最好在组件外部定义它。</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><p id="e97c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就这样，我跳过了一些关于hook，redux和axios的概念，但是我在这篇文章中链接了所有这些的网站或文档:)</p><p id="967e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谢谢你，并祝你有一个可怕的编码之旅！</p></div></div>    
</body>
</html>