<html>
<head>
<title>Make Web Development Fun Again</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让Web开发再次充满乐趣</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/2020-018-make-web-development-fun-again-5d226b77482d?source=collection_archive---------12-----------------------#2020-07-19">https://levelup.gitconnected.com/2020-018-make-web-development-fun-again-5d226b77482d?source=collection_archive---------12-----------------------#2020-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="87e1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们如何积累了如此多的垃圾，以及我们如何简化我们的工作流程以获得更干净、更高效的结果</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/13a9e089aa1ddc2f9c72fd70c5481706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f1IZAbBukPqxXYK_t9SmsA.png"/></div></div></figure><p id="b423" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你是一名前端web开发人员，你可能在过去的一年中不止一次地更新了工具。HTML、CSS和JavaScript的新进展意味着改进旧的做事方式的新机会。这很好。我们欢迎这些变化。</p><p id="3a1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是这些变化要求我们重新思考如何开展工作。我们通过反复试验，艰难地学到的教训，必须从头再来。</p><p id="71f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同时，开源项目和工具供应商不断发布他们软件的新版本。整个生态系统疯狂地工作，以跟上底层技术的进步。因此，对于我们这些从事代码工作的人来说，保持与前端堆栈及其工作流工具的同步不仅仅是一项兼职工作。</p><p id="1f9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是等等。还记得没这么复杂的时候吗？当时没有预处理器、传输器和打包器将我们新奇的代码转换成最小公分母的输出。当我们不需要任务运行器和流水线工作流来保持理智的时候。当我们不需要为了使用调试器而生成源地图，而不需要破坏代码的时候。当我们使用的框架没有以多语言的方式将所有东西混合在一起时。回到事情还很简单的时候。</p><p id="6deb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还记得那时候多有趣吗？</p><p id="d0e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最近，我对网络开发很感兴趣。那是因为我学会了简化我的工作流程。</p><p id="5b19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这都是关于切断cruft。现在我花更少的时间在开销上，更多的时间在创意上。请允许我分享一下我是如何走到这一步的。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="a7be" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">黄金时代</h1><p id="31d6" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们都知道在短时间内发生了很多事情。因此，我们如何走到今天这一步的历史在我们的集体记忆中记忆犹新。尽管如此，这仍然是我关于简化和去除赘肉的核心论点。所以回顾一下会有助于讲述这个故事。</p><p id="4ff4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一切都始于HTML——没有CSS，没有JavaScript——只是一个简短的标签列表，用于结构化布局、强调单词和文档之间的超链接。</p><p id="01a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，CSS和JavaScript相继出现。他们为我们提供了解决问题不同部分的方法。<em class="lq">分离顾虑</em>成了我们的宣言:</p><ul class=""><li id="d61a" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">语义和内容的HTML</li><li id="9f25" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">布局和装饰的CSS</li><li id="6e8b" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">用于动态交互的JavaScript</li></ul><p id="8818" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但这不是一个完美的世界。我们不得不努力解决浏览器不兼容的问题。有一段时间，我们忽略了这些差异，只是在每一页的底部贴上“用Internet Explorer浏览效果最佳”,让访问者自己去解决。</p><p id="3d24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如今，这三项技术构成了我们所做一切的基础，每个前端开发人员都必须掌握它们。但是我们了解到，有时供应商在规范遵循方面落后了，需要一点帮助。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="5680" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">图书馆时代</h1><p id="3fb1" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">当我们开始认真使用JavaScript时，事情开始变得混乱。浏览器不兼容给我们带来了无尽的麻烦。在自学如何进行AJAX调用时，我们在异步和同步的学习曲线中跌跌撞撞。我们不得不在一无所有的情况下完成这一切。然后我们发现了JQuery，再也没有回头。</p><p id="54b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当JQuery到来时，它把我们从浏览器不兼容的战争中拯救了出来。它给了我们一个统一的界面，掩盖了主要的浏览器差异。第一次，我们可以部署我们的代码，并合理地期望访问者会喜欢我们为他们设计的体验。</p><p id="201e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">今天，我们一想到使用JQuery就不寒而栗，但在那个时候，它是必要的。值得注意的是，JQuery的崛起并不是必然的。只有在与MooTools、Dojo和YUI等开源库激烈竞争后，它才能进入名人堂。</p><p id="aa05" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这三个库每个都打包了通用助手功能和用户界面设计决策的混合物——在一个一体化库中包含了您需要的一切。相比之下，JQuery保持专注。</p><p id="0350" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JQuery以一个引人注目的特性开始:扩展由<code class="fe nj nk nl nm b">document.getElementById()</code>提供的非常有限的能力。然后，它将其利用到一组包装器函数中，消除浏览器DOM的不一致性。最重要的是，它使得<code class="fe nj nk nl nm b">XMLHttpRequest</code>易于使用，让无数开发者接触到异步编程的新世界。</p><p id="82a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">突然，简单的<code class="fe nj nk nl nm b">onclick</code>回调不再足够好。交互性成了热门的新事物。用户蜂拥至提供动态内容的网站。因此，新生的<code class="fe nj nk nl nm b">&lt;noscript&gt;</code>运动未能获得牵引力，标语<em class="lq">不引人注目的JavaScript </em>和<em class="lq">优雅的退化</em>很快就失宠了。使用HTML的DOM不再是可选的。它成了我们工作中越来越重要的一部分。</p><p id="a289" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JQuery现在被认为是传统的，原因很简单:它最初的“引人注目的特性”已经以T5的形式直接集成到DOM中。此外，它的第二个最受欢迎的特性<code class="fe nj nk nl nm b">$.ajax()</code>函数已经被基于标准的Fetch API完全取代。在JQuery中可以完成的任何事情，现在都可以用相同数量的普通JavaScript来完成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/b8bbfaddfc053bd02a0fd849cafd780e.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*U-yR3aD6xiSnGxI0ao5OUA.png"/></div></figure><p id="2501" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">今天我们不再需要JQuery，任何新项目都不应该考虑使用它。尽管如此，从这次经历中，我们学会了接受第三方库作为我们工作的必要部分。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="c04d" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">预处理器时代</h1><p id="ba8e" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在HTML和DOM成熟的同时，我们的客户对复杂样式的需求也在增长。有一段时间，我们满足这种欲望所需要的只是一种互动的感觉。Adobe Flash帮助我们满足了这一需求，为我们提供了一种在客户主页上添加亮点的方法。</p><p id="297e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是很快CSS标准化了两个最好的Flash特性:过渡和动画。然后，随着HTML5中新的<code class="fe nj nk nl nm b">&lt;canvas&gt;</code>、<code class="fe nj nk nl nm b">&lt;audio&gt;</code>和<code class="fe nj nk nl nm b">&lt;video&gt;</code>标签的出现，专有Flash功能集的其余部分似乎是多余的，其不安全的核心迫使其消亡。</p><p id="8acc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们玩渐变背景、圆角和阴影时，CSS成了我们最好的朋友。我们开始写越来越多的CSS——为了布局，为了装饰，为了排版——直到它失去控制，我们需要帮助。</p><p id="f0a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着时间的推移，我们发现在CSS中需要变量声明。例如，我们需要一种方法来在一个地方调整主题的颜色和尺寸，并将这些调整反映到所有的样式表中。所以我们开始使用Less和Sass这样的预处理器来实现这一点。</p><p id="0673" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着样式表变得越来越复杂，我们学会了将规则组织到自包含文件中，以隔离上下文并减少命名冲突。我们开始依赖预处理器<code class="fe nj nk nl nm b">@import</code>语句将它们集合在一起。当我们这样做时，我们学会了接受预处理程序作为我们工作的必要部分。</p><p id="fc67" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个看似无害的预处理步骤让我们走上了这条路。我们再也不能简单地将浏览器指向一个URL，然后点击刷新按钮。现在，我们第一次不得不<em class="lq">建立</em>我们的网站。</p><p id="0eb4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是W3C标准已经发展，现在已经超越了Less和Sass提供的大部分内容:</p><ul class=""><li id="9ed4" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">CSS允许我们声明和使用变量，比如<code class="fe nj nk nl nm b">--width:40rem</code>。</li><li id="611c" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">CSS允许我们计算维度，比如<code class="fe nj nk nl nm b">calc(var(--width)+2rem)</code>。</li><li id="dca3" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">CSS允许我们用<code class="fe nj nk nl nm b">:host</code>和<code class="fe nj nk nl nm b">::slotted</code>选择器隔离上下文并防止组件内的命名冲突。</li><li id="faa5" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">CSS允许我们用<code class="fe nj nk nl nm b">@import</code>组织规则。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/4a0f7c0810fe6621b86cfcf187979e12.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*0voivImNvDYq2tJuKxH-dg.png"/></div></figure><p id="340c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有这些都不需要预处理程序。一切都基于标准，经得起未来考验。</p><p id="084c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">今天，新项目应该仔细评估Less和Sass是否值得麻烦。将它们从我们的工具链中去除，允许我们以最纯粹的形式声明我们需要的确切的规则集——而不需要任何额外的工具。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="eac8" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">标准时代</h1><p id="f1d7" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在这一切当中，我们开始以不同的方式看待网站。网站不再是提供信息的静态网页集合，而是变成了基于云的应用程序，可以访问用户特定的数据。</p><p id="e524" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在此期间，苹果、Mozilla和Opera认为在竞争泡沫中继续创新是徒劳的。相反，他们开始在新的网络超文本应用技术工作组(WHATWG)下合作开发标准。不久之后，微软和谷歌也加入了这项共同努力。他们一起工作产生了HTML5规范。</p><p id="120f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">到目前为止，标准的发展进展缓慢。CSS2花了很长时间才问世，并且只为该技术提供了适度的进步。HTML4花了更长的时间，带来了严格、过渡和框架集变体的大杂烩。</p><p id="9008" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">浏览器制造商明智地知道，任何解决他们分歧的成功努力都必须与他们的集体创新保持同步。拖延同意前进的道路将会破坏一切。</p><p id="2fb5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">WHATWG以一种全新的方式拥抱创新和标准。他们把他们的工作称为生活标准。这意味着不再是一个涵盖所有内容的单一规范，而是涵盖特定领域的独立文档。所以我们随便提到的HTML5标准，实际上是标准的集合。<em class="lq"> HTML5 &amp; Friends </em>包含了HTML的核心以及调试、DOM、fetch、流、存储、web sockets、web workers等等。</p><p id="7a93" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">生活标准方法是成功的。以至于它后来被万维网联盟(W3C)及其CSS标准工作所采用。这导致了大量的CSS3“模块”,包括:颜色、字体、选择器、背景和边框、多栏布局、媒体查询、分页媒体等。每个人都设定了自己的标准流程进度。</p><p id="c932" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，ECMA International在ECMA-262(JavaScript背后的标准)的工作中采用了同样的方法。其雄心勃勃的语言升级计划被用“和谐”的方法重新制定。这意味着随着时间的推移，新的功能会不断增加。因此，自2015年以来，我们每年都享受到源源不断的新语言能力。</p><p id="bad7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在所有这些过程中，新方法没有落后于创新，仅仅记录已经存在的东西，而是将标准制定过程本身确立为创新的先锋。这消除了我们以前不得不忍受的许多混乱，并给了我们一条有序的前进道路。</p><p id="195e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有这些重要的标准工作都发生在公众的视野之内。结果，我们前往的<em class="lq">方向</em>众所周知。</p><p id="e219" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此时，每个月都会发布HTML、CSS和JavaScript的新特性。它刺激了我们食欲。我们喜欢我们所听到的，我们希望它尽快。事实上，我们希望它比浏览器制造商实现它的速度更快。这就是事情开始变得复杂的地方。</p><p id="dd86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了走在曲线的前面，我们开始在代码库中使用特征检测和聚合填充。使用这种技术，我们可以确定哪些特性是浏览器支持的，哪些需要通过提供一个虚假的解决方案来模仿。这就是所谓的<em class="lq">渐进增强</em>理念:调整复杂程度以匹配浏览器的限制。但是这种方法只适用于有限的几件事情。</p><p id="3675" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相反，现实世界的项目开始使用transpilers，Babel成了我们新的最好的朋友。它允许我们使用nextgen语法的便利来编写我们的应用程序，而不用担心浏览器版本。所以我们在构建过程中添加了transpilers。</p><p id="2a28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，经过这么多年的动荡，JavaScript新特性的全盛时期终于要结束了。我们所见证的新“必备”功能的稳步发展正接近尾声。我们现在有了一个现代的多范例语言，包括模块、类、迭代器、生成器、箭头函数、二进制数据、映射和集合、承诺、模板文字、析构、异步/等待、rest/spread等等。</p><p id="2c7f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对我们许多人来说，最大的生产率提高是超越了深度嵌套的闭包。有了原生承诺和async/await语法，JavaScript现在完全支持异步编程。它的程序式流程看起来很简单。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/25da15e41be524475e04f27b7f2c011d.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*vz0s4oXIKujlJfg2-H6fsA.png"/></div></figure><p id="3977" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如今，对transpilers的需求已经基本消失。我们需要编写干净代码的每一个语言特性都是本地可用的。我们可以使用多种范例进行编写:函数式编程、面向对象编程和命令式编程都是可能的，而无需求助于编译器。</p><p id="bbf0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">(在继续之前，关于transpilers还有最后一点需要注意。当我们首选的语言是TypeScript时，我们仍然可以从我们的管道中删除Babel，但是我们需要保留<code class="fe nj nk nl nm b">tsc</code>以便将我们的源代码转换成浏览器兼容的JavaScript。)</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="d7de" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">模块时代</h1><p id="287d" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">所有这一切的最后一个坚持是模块。随着我们的静态网站成长为基于云的应用程序，我们创建的大量功能给我们带来了麻烦。简单地说，我们有一个范围问题。给事物命名使它们不冲突变得越来越困难。</p><p id="4d4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">众所周知，解决方案以<code class="fe nj nk nl nm b">require</code>和<code class="fe nj nk nl nm b">module.exports</code>的形式出现。以RequireJS和Browserify为首的几个开源解决方案是可用的，但不幸的是它们并不兼容。因此，库开发人员必须选择为他们的代码库使用哪种语法(AMD或CommonJS)，应用程序开发人员必须遵循他们的领导，或者使用UMD(通用模块定义)来解决差异。</p><p id="7324" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当ECMA技术委员会(TC39)介入时，这种令人遗憾的状况似乎终于有所好转。TC39详细研究了这个问题，并为JavaScript语言提出了新的关键字。他们的模块加载器将使用新定义的<code class="fe nj nk nl nm b">import</code>和<code class="fe nj nk nl nm b">export</code>语法，这最终被称为ESNext。</p><p id="ffad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实证明，加载模块并不容易。正确管理依赖关系、处理循环依赖关系以及处理异步加载都是不小的问题。让它在Node.js中工作是一回事，但让它在浏览器中工作要困难得多。</p><p id="d239" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">前端开发者不能等待浏览器制造商解决所有这些问题。我们急需模块。幸运的是，有一个现成的解决方案——让开发人员使用新的ESNext语法编写代码，并使用Babel将其转换回CommonJS语法。这种方法效果很好。</p><p id="4d2c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而今天，这已经没有必要了。对ESNext标准的浏览器支持现已普遍可用。对于许多项目来说，不需要transpilers。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="612c" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">邦德勒时代</h1><p id="1512" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">对于许多前端项目来说，我们为自己构建的工具链已经变得越来越复杂。所以为了简化我们的工作流程，我们使用了<em class="lq">任务运行器</em>如Gulp和Grunt，以及<em class="lq">捆绑器</em>如Browserify、Rollup和Webpack。正确配置后，它们会监控我们文件的变化，并触发必要的转换过程:</p><ul class=""><li id="42d4" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">Sass及以下预处理成CSS。</li><li id="e745" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">现代JavaScript语法向下转换到了ES5。</li><li id="d162" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">ESNext模块被重新打包为CommonJS模块。</li><li id="2fa5" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">运行Linters是为了检查我们代码中的常见错误。</li><li id="203f" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">注释和空白用缩小器删除。</li><li id="a12a" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">生成调试源映射是为了将损坏的代码链接到源代码。</li><li id="60fe" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">所有东西都被连接成一个包，以实现高效的HTTP/1.1传输。</li><li id="300f" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">捆绑包被分成粒度捆绑包，以实现最佳网络缓存。</li></ul><p id="dc31" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种方法已经成为我们工作流程中不可或缺的一部分，以至于我们大多数人都无法想象不这样做。但是请仔细检查这个列表，并将其与我们已经了解的内容进行比较。</p><ul class=""><li id="98ae" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">当我们使用最新的CSS特性时，可以去掉预处理程序。</li><li id="71b0" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">浏览器支持现代JavaScript，无需传输文件。</li><li id="8e68" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">ESNext模块可以本机使用，无需模块加载器。</li><li id="a217" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">标准的HTTP缓存使得捆绑包分割变得没有必要。<strong class="kw iu"> * </strong></li><li id="44c7" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">通过HTTP/2持久连接传输文件比捆绑器更快。<strong class="kw iu"> * </strong></li></ul><p id="cec0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">*(不幸的是，当我们的服务器使用HTTP/1.1时，捆绑包仍然比多个小文件快。因此，为了获得最大的好处，切换到具有持久连接和缓存的新服务器，如<a class="ae no" href="https://rwserve.readwritetools.com/?utm_term=MakeWebDevelopmentFunAgain" rel="noopener ugc nofollow" target="_blank">读写工具HTTP/2服务器</a>，对于非捆绑场景的执行是非常重要的。)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/cb3647ded6865b6c9c786d58e739d1d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*y5ubhySf0wGK90OecgUGUQ.png"/></div></figure><p id="539c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们最初的清单上只剩下棉绒和迷你棉绒。由于我们不需要在每次测试小的变化时调用它们，我们可以将它们的使用委托给我们的最终部署脚本。当这种快乐的情况出现时，我们可以摆脱我们一直使用的捆绑器。</p><p id="2573" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">瞧啊。我们已经将整个工作流程简化到只有一个编辑器和一个浏览器。进行更改，按下刷新按钮，这就是您的新代码。这下有趣了。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="d4ec" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">框架时代</h1><p id="e675" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">这种前端编码的新方法实际上是回归我们的根本——HTML、CSS、Javascript和<em class="lq">关注点分离</em>哲学。但是它经得起真实网站的考验吗？</p><p id="668c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">目前，答案取决于您项目的架构。</p><p id="54b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当前对框架的迷恋使得这种新方法对于许多项目来说遥不可及。基于云的应用程序开发的最新趋势受到了一些知名框架的严重影响。Angular、React、Vue和Svelte等软件包已经成为许多新前端项目事实上的起点。</p><p id="4eec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React框架使用<em class="lq">虚拟DOM </em>试图使编程成为一种声明性的练习。事件处理、属性操作和DOM交互不由开发人员直接处理，而是由后台转换例程处理。为了以声明方式使用React，大多数开发人员使用JSX语言编写语句，这是JavaScript和XML的混合体。由于浏览器对JSX一无所知，所以必须使用Babel将它转换成JavaScript。</p><p id="a8a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一方面，Angular框架不像JSX那样使用任何东西，但是它<em class="lq">使用模板文字。这些模板是使用HTML加上特定于库的属性和嵌入式花括号表达式编写的。在发送到浏览器之前，角度模板需要用<code class="fe nj nk nl nm b">ng build</code> CLI编译成<em class="lq">增量DOM </em>语句。</em></p><p id="cdf0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Vue框架也使用模板文字来编写内嵌花括号表达式的HTML。同样，这些需要被编译成可供浏览器使用的东西。大多数项目要么使用<code class="fe nj nk nl nm b">vue-template-compiler</code>要么使用它的Webpack包装器<code class="fe nj nk nl nm b">vue-loader</code>。</p><p id="5709" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并且Svelte框架使用的模板文字看起来与Vue模板非常相似。它还将编译步骤从运行时转移到构建时。大多数项目要么使用<code class="fe nj nk nl nm b">svelte.compile</code>要么使用其Webpack包装器<code class="fe nj nk nl nm b">svelte-loader</code>。</p><p id="e3b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，使用React、Angular、Vue或Svelte的项目将无法将他们的工作流程一直简化到上面概述的极简主义视图。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="1927" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">组件时代</h1><p id="7ef9" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">另一方面，WHATWG <em class="lq">引发的组件革命</em>可以充分利用以上所涵盖的一切。当我们使用基于W3C标准的方法开发组件时，我们获得了前面列举的所有好处。</p><p id="23a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于那些对这种新的web开发方法感兴趣的人来说，需要学习的关键技术是:</p><ul class=""><li id="b32d" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">自定义元素</li><li id="ba27" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">阴影DOM</li><li id="b7ed" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">HTML模板</li></ul><p id="deef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有这些都有标准支持。此外，好消息是，使用这些标准的组件可以被其他人编写、测试和使用，而不会有任何我们努力消除的额外缺陷。简单，干净，有趣！</p><p id="a93f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了证明这种方法有效，看看<a class="ae no" href="https://fiddle.blue/?utm_term=MakeWebDevelopmentFunAgain" rel="noopener ugc nofollow" target="_blank">蓝色小提琴</a>网站是如何处理这一切的。这是一个访问后端服务器API的专业应用程序，只用IDE、<a class="ae no" href="https://bluephrase.com/?utm_term=MakeWebDevelopmentFunAgain" rel="noopener ugc nofollow" target="_blank"> BLUEPHRASE </a>模板语言和Chrome DevTools创建。</p><p id="9c74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你在那里的时候，一定要仔细检查——你会看到清晰的代码，读起来简单，写起来有趣。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/242a03d667f8a5822b6aec627ffc7066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*-kg6s6iVBaFLsKYPJLO2Dg.png"/></div></figure></div></div>    
</body>
</html>