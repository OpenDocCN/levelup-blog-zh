<html>
<head>
<title>Building a microservice for image super-scaling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为图像超大规模扩展构建微服务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-microservice-for-image-super-scaling-a2d9a8848c5f?source=collection_archive---------6-----------------------#2020-10-02">https://levelup.gitconnected.com/building-a-microservice-for-image-super-scaling-a2d9a8848c5f?source=collection_archive---------6-----------------------#2020-10-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/66dc10eb16bc01e751a3300f6954dcdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6b9oWQCvWVGrszVv-f20_Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">左—双三次插值，右—图像超分辨率</figcaption></figure><p id="f22b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">超大规模、神经增强、超分辨率、人工智能升级——代表同一个想法的各种术语。您可以使用人工神经网络来放大图像，而不是常规的双线性/双三次算法。但是，这并不是这篇文章真正要说的…</p><div class="la lb lc ld gt ab cb"><figure class="le jr lf lg lh li lj paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/4085091900367addd436485d7b2d80a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*H2VeOHEpczhtdohaNtyZgQ.jpeg"/></div></figure><figure class="le jr lf lg lh li lj paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/f54764916a59b6ea4086e1f80f9b3f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*24LV0anMzMzIuokg_R_ABg.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk lk di ll lm translated">左—双三次插值，右—图像超分辨率</figcaption></figure></div><p id="26d4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">本教程旨在提供一个例子，说明如何将任何与人工智能相关的解决方案(需要您坚持使用Python)包装在一个方便的无状态服务中，该服务可以在您的架构中的任何地方轻松部署、扩展和使用。</p><p id="c1c0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们今天将构建什么:</p><ol class=""><li id="2fa5" class="ln lo iq ke b kf kg kj kk kn lp kr lq kv lr kz ls lt lu lv bi translated">基于Python的微服务，带有<a class="ae lw" href="https://flask.palletsprojects.com" rel="noopener ugc nofollow" target="_blank"> Flask </a>框架</li><li id="08ee" class="ln lo iq ke b kf lx kj ly kn lz kr ma kv mb kz ls lt lu lv bi translated">通过ISR包(<a class="ae lw" href="https://github.com/idealo/image-super-resolution" rel="noopener ugc nofollow" target="_blank"> ISR GitHub </a>)进行图像升级的端点</li><li id="d18b" class="ln lo iq ke b kf lx kj ly kn lz kr ma kv mb kz ls lt lu lv bi translated">我们微服务的Docker图像</li><li id="595e" class="ln lo iq ke b kf lx kj ly kn lz kr ma kv mb kz ls lt lu lv bi translated">Java中的REST API客户端与我们的微服务进行通信</li></ol><p id="e70f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一如既往——本教程的最终代码和示例图像可以通过本文末尾的链接在我的GitHub repo中找到。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="fd62" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">第1部分—基本烧瓶应用程序</h1><p id="700a" class="pw-post-body-paragraph kc kd iq ke b kf nh kh ki kj ni kl km kn nj kp kq kr nk kt ku kv nl kx ky kz ij bi translated">让我们从制作一个简单的Flask应用程序开始，这是Python中的一个基本微服务，其中有一个<code class="fe nm nn no np b">ping</code>端点。</p><p id="9d18" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，我们需要一个JSON对象<code class="fe nm nn no np b">message_protocol/ping_output.py</code>从这个端点返回数据</p><pre class="la lb lc ld gt nq np nr ns aw nt bi"><span id="4880" class="nu mk iq np b gy nv nw l nx ny"><strong class="np ir">import </strong>json<br/><br/><strong class="np ir">class </strong>PingOutput:<br/>    <strong class="np ir">def </strong>__init__(self, success: bool):<br/>        self.success = success<br/><br/>    <strong class="np ir">def </strong>toJSON(self):<br/>        <strong class="np ir">return </strong>json.dumps(self, default=<strong class="np ir">lambda </strong>o: o.__dict__, sort_keys=<strong class="np ir">True</strong>, indent=4)</span></pre><p id="1e69" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，让我们让端点逻辑有自己的类，并把它放在<code class="fe nm nn no np b">resource_ping.py</code>中，我知道，看起来有点过分，但相信我，当这些端点中有一些真正的工作负载时，这是值得的。</p><pre class="la lb lc ld gt nq np nr ns aw nt bi"><span id="db5f" class="nu mk iq np b gy nv nw l nx ny"><strong class="np ir">from </strong>message_protocol.ping_output <strong class="np ir">import </strong>PingOutput<br/><br/><strong class="np ir">class </strong>ResourcePing:<br/>    <strong class="np ir">def </strong>main(self) -&gt; PingOutput:<br/>        <strong class="np ir">return </strong>PingOutput(<strong class="np ir">True</strong>)</span></pre><p id="d10e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过添加一个单独的脚本<code class="fe nm nn no np b">resources.py</code>，确保资源只被实例化一次(在应用程序启动时)</p><pre class="la lb lc ld gt nq np nr ns aw nt bi"><span id="5cf2" class="nu mk iq np b gy nv nw l nx ny"><em class="nz"># Make sure all resources are instantiated here<br/></em><strong class="np ir">from </strong>resource_ping <strong class="np ir">import </strong>ResourcePing<br/>resourcePing = ResourcePing()</span></pre><p id="34fe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在是主要部分——一个Flask应用程序，它将<code class="fe nm nn no np b">/ping</code> URL映射到我们的资源中。姑且称之为<code class="fe nm nn no np b">flask_app.py</code></p><pre class="la lb lc ld gt nq np nr ns aw nt bi"><span id="c120" class="nu mk iq np b gy nv nw l nx ny"><strong class="np ir">from </strong>flask <strong class="np ir">import </strong>Flask<br/><strong class="np ir">from </strong>flask <strong class="np ir">import </strong>request<br/><strong class="np ir">from </strong>flask <strong class="np ir">import </strong>Response<br/><strong class="np ir">from </strong>resources <strong class="np ir">import </strong>resourcePing</span><span id="96dc" class="nu mk iq np b gy oa nw l nx ny">app = Flask(__name__)<br/><br/>@app.route(<strong class="np ir">'/ping'</strong>, methods=[<strong class="np ir">'GET'</strong>])<br/><strong class="np ir">def </strong>ping():<br/>    output = resourcePing.main()<br/>    json = output.toJSON()<br/>    <strong class="np ir">return </strong>Response(json, mimetype=<strong class="np ir">'application/json'</strong>)</span></pre><p id="4324" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有了它，你就可以通过</p><pre class="la lb lc ld gt nq np nr ns aw nt bi"><span id="8951" class="nu mk iq np b gy nv nw l nx ny">export FLASK_APP=flask_app.py<br/>flask run --host=0.0.0.0 --port=7777</span></pre><p id="9d8b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">并通过执行<code class="fe nm nn no np b">GET http://localhost:7777/ping</code>来测试响应</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/f52aed655b0dde8c4a9090c8662a1f7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HepaBfP7m6Od1FNf8t33jw.png"/></div></div></figure><p id="ebfc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的Python微服务的主干现已完成，我们可以用类似的方式添加新资源。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="aabd" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">第2部分—整合ISR</h1><p id="b10b" class="pw-post-body-paragraph kc kd iq ke b kf nh kh ki kj ni kl km kn nj kp kq kr nk kt ku kv nl kx ky kz ij bi translated">随着基本Flask应用程序的启动和运行，我们可以添加一个端点来进行图像放大，但首先让我们通过在Flask应用程序之外做一个快速测试来看看<a class="ae lw" href="https://github.com/idealo/image-super-resolution" rel="noopener ugc nofollow" target="_blank">图像超分辨率</a>是如何工作的。您可以在他们的<a class="ae lw" href="https://github.com/idealo/image-super-resolution" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到更详细的ISR使用示例，我将简单介绍一下我们的案例。我们将在本教程中使用<strong class="ke ir">人工取消GANS模型</strong>。</p><pre class="la lb lc ld gt nq np nr ns aw nt bi"><span id="c647" class="nu mk iq np b gy nv nw l nx ny"><strong class="np ir">import </strong>numpy <strong class="np ir">as </strong>np<br/><strong class="np ir">from </strong>PIL <strong class="np ir">import </strong>Image<br/><strong class="np ir">from </strong>ISR.models <strong class="np ir">import </strong>RDN</span><span id="5441" class="nu mk iq np b gy oa nw l nx ny">inputPath = <strong class="np ir">'../../sample-images/t4.jpg'<br/></strong>outputPath = <strong class="np ir">'../../sample-images/t4_up.jpg'<br/></strong>imagePil = Image.open(inputPath)<br/>imageNumpy = np.array(imagePil)<br/>model = RDN(weights=<strong class="np ir">'noise-cancel'</strong>)<br/>scaledNumpy = model.predict(imageNumpy)<br/>scaledPil = Image.fromarray(scaledNumpy)<br/>scaledPil.save(outputPath)</span></pre><div class="la lb lc ld gt ab cb"><figure class="le jr lf lg lh li lj paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/aa5b6f53a44c8607208a110c7c7536c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*X_5Hazp3M5Ubu7U5x_oLzg.jpeg"/></div></figure><figure class="le jr lf lg lh li lj paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/53e8bb24c37383b34bb8c72bba61b239.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*QV9R0CCUoVtZQaGxLuw7Zg.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk lk di ll lm translated">左—双三次插值，右—图像超分辨率</figcaption></figure></div><div class="ab cb"><figure class="le jr lf lg lh li lj paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/5c27698cbef13e90c9924c96b10310e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*vmnI5LKMSRZX5zD7sRNTdA.jpeg"/></div></figure><figure class="le jr lf lg lh li lj paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/f196e5139f9f7438b4c0f5610fb3c574.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*sZzF5qw-KwdFyq5jsoeDBw.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk lk di ll lm translated">左—双三次插值，右—图像超分辨率</figcaption></figure></div><p id="645d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，让我们将这种扩展放到一个新的资源中。为了在JSON对象中传递图像，我将使用base64字符串图像编码，这简化了本教程，但是对于现实世界的应用程序来说，更合理的方法是只传递图像的URL。</p><p id="e1ec" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将定义输入/输出JSON对象(虽然它们的内容是相同的，但我将在这里使用两个不同的对象，因为在实际应用程序中，我们可能希望在其中传递额外的数据)</p><pre class="la lb lc ld gt nq np nr ns aw nt bi"><span id="d388" class="nu mk iq np b gy nv nw l nx ny"><strong class="np ir">import </strong>json<br/><br/><strong class="np ir">class </strong>UpscaleInput:<br/>    <strong class="np ir">def </strong>__init__(self, imageBase64: str):<br/>        self.imageBase64 = imageBase64<br/><br/>    <strong class="np ir">def </strong>toJSON(self):<br/>        <strong class="np ir">return </strong>json.dumps(self, default=<strong class="np ir">lambda </strong>o: o.__dict__, sort_keys=<strong class="np ir">False</strong>, indent=4)<br/><br/><strong class="np ir">def </strong>parseUpscaleInput(dictionary) -&gt; UpscaleInput:<br/>    imageBase64 = dictionary[<strong class="np ir">'imageBase64'</strong>]<br/>    <strong class="np ir">return </strong>UpscaleInput(imageBase64)</span><span id="49cd" class="nu mk iq np b gy oa nw l nx ny"><strong class="np ir">class </strong>UpscaleOutput:<br/>    <strong class="np ir">def </strong>__init__(self, imageBase64: str):<br/>        self.imageBase64 = imageBase64<br/><br/>    <strong class="np ir">def </strong>toJSON(self):<br/>        <strong class="np ir">return </strong>json.dumps(self, default=<strong class="np ir">lambda </strong>o: o.__dict__, sort_keys=<strong class="np ir">False</strong>, indent=4)<br/><br/><strong class="np ir">def </strong>parseUpscaleOutput(dictionary) -&gt; UpscaleOutput:<br/>    imageBase64 = dictionary[<strong class="np ir">'imageBase64'</strong>]<br/>    <strong class="np ir">return </strong>UpscaleOutput(imageBase64)</span></pre><p id="8fc5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">而现在资源本身，<code class="fe nm nn no np b">resource_upscale.py</code></p><pre class="la lb lc ld gt nq np nr ns aw nt bi"><span id="89e0" class="nu mk iq np b gy nv nw l nx ny"><strong class="np ir">import </strong>io<br/><strong class="np ir">import </strong>base64<br/><strong class="np ir">import </strong>numpy <strong class="np ir">as </strong>np<br/><strong class="np ir">from </strong>PIL <strong class="np ir">import </strong>Image<br/><strong class="np ir">from </strong>ISR.models <strong class="np ir">import </strong>RDN<br/><strong class="np ir">from </strong>message_protocol.upscale_input <strong class="np ir">import </strong>UpscaleInput<br/><strong class="np ir">from </strong>message_protocol.upscale_output <strong class="np ir">import </strong>UpscaleOutput<br/><br/>MODEL = RDN(weights=<strong class="np ir">'noise-cancel'</strong>)<br/><br/><strong class="np ir">class </strong>ResourceUpscale:<br/>    <strong class="np ir">def </strong>main(self, upscaleInput: UpscaleInput) -&gt; UpscaleOutput:<br/>        <em class="nz"># Parse base64 string into bytes array<br/>        </em>inputImageBytesArray = base64.b64decode(upscaleInput.imageBase64)<br/><br/>        <em class="nz"># Open the image<br/>        </em>imagePil = Image.open(io.BytesIO(inputImageBytesArray))<br/>        imageNumpy = np.array(imagePil)<br/><br/>        <em class="nz"># Scale the image<br/>        </em>scaledNumpy = MODEL.predict(imageNumpy)<br/>        scaledPil = Image.fromarray(scaledNumpy)<br/><br/>        <em class="nz"># Write scaled image as bytes array<br/>        </em>outputImageBytesArrayIO = io.BytesIO()<br/>        scaledPil.save(outputImageBytesArrayIO, format=imagePil.format, quality=100)<br/>        outputImageBytesArray = outputImageBytesArrayIO.getvalue()<br/><br/>        <em class="nz"># Convert back to base64 string<br/>        </em>outputImageBase64 = base64.b64encode(outputImageBytesArray).decode(<strong class="np ir">'utf-8'</strong>)<br/>        <strong class="np ir">return </strong>UpscaleOutput(outputImageBase64)</span></pre><p id="60ea" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">别忘了在<code class="fe nm nn no np b">resources.py</code>中实例化它</p><pre class="la lb lc ld gt nq np nr ns aw nt bi"><span id="f733" class="nu mk iq np b gy nv nw l nx ny"><em class="nz"># Make sure all resources are instantiated here<br/></em><strong class="np ir">from </strong>resource_ping <strong class="np ir">import </strong>ResourcePing<br/><strong class="np ir">from </strong>resource_upscale <strong class="np ir">import </strong>ResourceUpscale<br/>resourcePing = ResourcePing()<br/>resourceUpscale = ResourceUpscale()</span></pre><p id="8f73" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">并将<code class="fe nm nn no np b">/upscale</code>的网址映射到<code class="fe nm nn no np b">flask_app.py</code></p><pre class="la lb lc ld gt nq np nr ns aw nt bi"><span id="d8eb" class="nu mk iq np b gy nv nw l nx ny"><strong class="np ir">from </strong>flask <strong class="np ir">import </strong>Flask<br/><strong class="np ir">from </strong>flask <strong class="np ir">import </strong>request<br/><strong class="np ir">from </strong>flask <strong class="np ir">import </strong>Response<br/><strong class="np ir">from </strong>resources <strong class="np ir">import </strong>resourcePing, resourceUpscale<br/><strong class="np ir">from </strong>message_protocol.upscale_input <strong class="np ir">import </strong>parseUpscaleInput<br/><br/>app = Flask(__name__)<br/><br/>@app.route(<strong class="np ir">'/ping'</strong>, methods=[<strong class="np ir">'GET'</strong>])<br/><strong class="np ir">def </strong>ping():<br/>    output = resourcePing.main()<br/>    json = output.toJSON()<br/>    <strong class="np ir">return </strong>Response(json, mimetype=<strong class="np ir">'application/json'</strong>)<br/><br/>@app.route(<strong class="np ir">'/upscale'</strong>, methods=[<strong class="np ir">'POST'</strong>])<br/><strong class="np ir">def </strong>upscale():<br/>    input = parseUpscaleInput(request.json)<br/>    output = resourceUpscale.main(input)<br/>    json = output.toJSON()<br/>    <strong class="np ir">return </strong>Response(json, mimetype=<strong class="np ir">'application/json'</strong>)</span></pre><p id="9ac1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这个阶段，让我们离开Python这一边，转而构建我们的环境和客户机，以便正确地运行这个服务并与之通信。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="739c" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">第3部分— Docker图像</h1><p id="6e9b" class="pw-post-body-paragraph kc kd iq ke b kf nh kh ki kj ni kl km kn nj kp kq kr nk kt ku kv nl kx ky kz ij bi translated">我们的Docker映像非常简单，我们将从一个基本的Ubuntu映像开始，安装Python、PIP和在容器中运行该服务所需的所有依赖项，复制源代码并在容器启动时运行该服务。所以<code class="fe nm nn no np b">Dockerfile</code>最终看起来像这样:</p><pre class="la lb lc ld gt nq np nr ns aw nt bi"><span id="94f5" class="nu mk iq np b gy nv nw l nx ny"><strong class="np ir">FROM </strong>ubuntu:20.04<br/><br/><em class="nz"># Initial setup &amp; install system utils<br/></em><strong class="np ir">RUN </strong>apt-get update <strong class="np ir">&amp;&amp; </strong>apt-get upgrade <strong class="np ir">-</strong>y<br/><strong class="np ir">RUN </strong>apt-get install <strong class="np ir">-</strong>y apt-utils software-properties-common<br/><strong class="np ir">RUN </strong>apt-get install <strong class="np ir">-</strong>y vim wget git<br/><br/><em class="nz"># Install Python 3.8 &amp; Pip 3<br/></em><strong class="np ir">WORKDIR /<br/>RUN </strong>add-apt-repository <strong class="np ir">-</strong>y ppa:deadsnakes<strong class="np ir">/</strong>ppa<br/><strong class="np ir">RUN </strong>apt-get install <strong class="np ir">-</strong>y python3.8<br/><strong class="np ir">RUN </strong>echo <strong class="np ir">"alias python='python3.8'" &gt;&gt; </strong>~<strong class="np ir">/</strong>.bashrc<br/><strong class="np ir">RUN </strong>echo <strong class="np ir">"alias python3='python3.8'" &gt;&gt; </strong>~<strong class="np ir">/</strong>.bashrc<br/><strong class="np ir">RUN </strong>apt-get install <strong class="np ir">-</strong>y python3-pip<br/><strong class="np ir">RUN </strong>echo <strong class="np ir">"alias pip='pip3'" &gt;&gt; </strong>~<strong class="np ir">/</strong>.bashrc<br/><br/><em class="nz"># Install Python dependencies<br/></em><strong class="np ir">RUN </strong>pip3 install flask<br/><strong class="np ir">RUN </strong>pip3 install numpy<br/><strong class="np ir">RUN </strong>pip3 install tensorflow<br/><strong class="np ir">RUN </strong>pip3 install ISR <strong class="np ir">--</strong>ignore-installed tensorflow<br/><br/><em class="nz"># Copy source code<br/></em><strong class="np ir">RUN </strong>mkdir <strong class="np ir">/</strong>python-service<br/><strong class="np ir">COPY </strong>. <strong class="np ir">/</strong>python-service<br/><strong class="np ir">WORKDIR /</strong>python-service<br/><strong class="np ir">RUN </strong>chmod a<strong class="np ir">+</strong>x run.sh<br/><br/><em class="nz"># Run<br/></em><strong class="np ir">CMD './run.sh'</strong></span></pre><p id="c3fc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">至于<code class="fe nm nn no np b">run.sh</code>剧本</p><pre class="la lb lc ld gt nq np nr ns aw nt bi"><span id="899c" class="nu mk iq np b gy nv nw l nx ny"><strong class="np ir">#!/bin/sh<br/></strong>export FLASK_APP=flask_app.py<br/>flask run --host=0.0.0.0 --port=7777</span></pre><p id="7583" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，您可以从终端构建并运行Docker容器</p><pre class="la lb lc ld gt nq np nr ns aw nt bi"><span id="93a5" class="nu mk iq np b gy nv nw l nx ny">docker build -t service-ai-image . &amp;&amp; docker run --rm -ti -p 7777:7777 --name service-ai-container service-ai-image</span></pre><p id="5afb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">并通过执行<code class="fe nm nn no np b">GET <a class="ae lw" href="http://localhost:7777/ping" rel="noopener ugc nofollow" target="_blank">http://localhost:7777/ping</a></code>来测试它是否在doing</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="5756" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">第4部分— Java客户端</h1><p id="ba58" class="pw-post-body-paragraph kc kd iq ke b kf nh kh ki kj ni kl km kn nj kp kq kr nk kt ku kv nl kx ky kz ij bi translated">这可能是本教程中最简单的部分——我们现在需要构建一个与我们的服务通信的REST API客户端。我用Java编写这个代码，但是这一部分在你喜欢的任何其他语言中都是可行的。我将使用<a class="ae lw" href="https://projectlombok.org/setup/maven" rel="noopener ugc nofollow" target="_blank"> Lombok </a>注释来加速并减少样板代码，使用<a class="ae lw" href="https://github.com/google/gson" rel="noopener ugc nofollow" target="_blank"> Gson </a>来简化JSON映射，使用<a class="ae lw" href="https://hc.apache.org/httpcomponents-client-ga/" rel="noopener ugc nofollow" target="_blank"> Apache HTTP客户端</a>来调用服务。然后当然是<a class="ae lw" href="https://junit.org/junit4/" rel="noopener ugc nofollow" target="_blank"> JUnit </a>进行测试。</p><p id="fcc4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">JSON对象应该是这样的</p><pre class="la lb lc ld gt nq np nr ns aw nt bi"><span id="77b4" class="nu mk iq np b gy nv nw l nx ny"><strong class="np ir">public interface </strong>JsonSerializable <strong class="np ir">extends </strong>Serializable {<br/>    <strong class="np ir">default </strong>String toJson() {<br/>        <strong class="np ir">return new </strong>GsonBuilder().create().toJson(<strong class="np ir">this</strong>);<br/>    }<br/>}</span><span id="b983" class="nu mk iq np b gy oa nw l nx ny">@Getter @AllArgsConstructor @NoArgsConstructor @ToString @EqualsAndHashCode<br/><strong class="np ir">public class </strong>PingOutput <strong class="np ir">implements </strong>JsonSerializable {<br/>    <strong class="np ir">private boolean success</strong>;<br/>}</span><span id="6502" class="nu mk iq np b gy oa nw l nx ny">@Getter @AllArgsConstructor @NoArgsConstructor @ToString @EqualsAndHashCode<br/><strong class="np ir">public class </strong>UpscaleInput <strong class="np ir">implements </strong>JsonSerializable {<br/>    <strong class="np ir">private </strong>String <strong class="np ir">imageBase64</strong>;<br/><br/>    <strong class="np ir">public </strong>UpscaleInput(<strong class="np ir">byte</strong>[] imageBytesArray) {<br/>        <strong class="np ir">this</strong>(Base64.<em class="nz">getEncoder</em>().encodeToString(imageBytesArray));<br/>    }<br/><br/>    <strong class="np ir">public </strong>UpscaleInput(File imageFile) <strong class="np ir">throws </strong>IOException {<br/>        <strong class="np ir">this</strong>(Files.<em class="nz">readAllBytes</em>(imageFile.toPath()));<br/>    }<br/>}</span><span id="c69a" class="nu mk iq np b gy oa nw l nx ny">@Getter @AllArgsConstructor @NoArgsConstructor @ToString @EqualsAndHashCode<br/><strong class="np ir">public class </strong>UpscaleOutput <strong class="np ir">implements </strong>JsonSerializable {<br/>    <strong class="np ir">private </strong>String <strong class="np ir">imageBase64</strong>;<br/><br/>    <strong class="np ir">public byte</strong>[] toBytesArray() {<br/>        <strong class="np ir">return </strong>Base64.<em class="nz">getDecoder</em>().decode(<strong class="np ir">imageBase64</strong>);<br/>    }<br/>}</span></pre><p id="18cf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们还需要一个helper类，它具有一些处理HTTP请求的逻辑(在现实世界的应用程序中，您可能希望这里有更多的try-catch块，一些不错的错误处理逻辑，但是这对于我们的情况来说很好)</p><pre class="la lb lc ld gt nq np nr ns aw nt bi"><span id="7bcd" class="nu mk iq np b gy nv nw l nx ny"><strong class="np ir">public class </strong>ClientUtils {<br/>    <strong class="np ir">private static </strong>String getJsonResponse(HttpResponse httpResponse) <strong class="np ir">throws </strong>Exception {<br/>        <strong class="np ir">if </strong>(httpResponse.getStatusLine().getStatusCode() == 200) {<br/>            HttpEntity httpEntity = httpResponse.getEntity();<br/>            <strong class="np ir">return </strong>EntityUtils.<em class="nz">toString</em>(httpEntity);<br/>        } <strong class="np ir">else </strong>{<br/>            <strong class="np ir">throw new </strong>IllegalStateException(<strong class="np ir">"Http response status code is invalid: " </strong>+ httpResponse.getStatusLine().getStatusCode() + <strong class="np ir">", " </strong>+ EntityUtils.<em class="nz">toString</em>(httpResponse.getEntity()));<br/>        }<br/>    }<br/><br/>    <strong class="np ir">public static </strong>&lt;M&gt; M parseJsonResponse(String jsonResponse, Type responseResultType) <strong class="np ir">throws </strong>Exception {<br/>        <strong class="np ir">return new </strong>GsonBuilder().create().fromJson(jsonResponse, responseResultType);<br/>    }<br/><br/>    <strong class="np ir">public static </strong>String doGet(String url) <strong class="np ir">throws </strong>Exception {<br/>        HttpClient httpClient = HttpClientBuilder.<em class="nz">create</em>().build();<br/>        HttpGet httpGet = <strong class="np ir">new </strong>HttpGet(url);<br/>        httpGet.setHeader(<strong class="np ir">"Accept"</strong>, <strong class="np ir">"application/json"</strong>);<br/>        <strong class="np ir">return </strong><em class="nz">getJsonResponse</em>(httpClient.execute(httpGet));<br/>    }<br/><br/>    <strong class="np ir">public static </strong>String doPost(String url, String jsonPayload) <strong class="np ir">throws </strong>Exception {<br/>        HttpClient httpClient = HttpClientBuilder.<em class="nz">create</em>().build();<br/>        HttpPost httpPost = <strong class="np ir">new </strong>HttpPost(url);<br/>        httpPost.setEntity(<strong class="np ir">new </strong>StringEntity(jsonPayload, ContentType.<strong class="np ir"><em class="nz">APPLICATION_JSON</em></strong>));<br/>        httpPost.setHeader(<strong class="np ir">"Accept"</strong>, <strong class="np ir">"application/json"</strong>);<br/>        httpPost.setHeader(<strong class="np ir">"Content-type"</strong>, <strong class="np ir">"application/json"</strong>);<br/>        <strong class="np ir">return </strong><em class="nz">getJsonResponse</em>(httpClient.execute(httpPost));<br/>    }<br/>}</span></pre><p id="e7e7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我们终于可以用两种方法来编写主客户端本身了— <code class="fe nm nn no np b">ping</code>和<code class="fe nm nn no np b">upscale</code>。</p><pre class="la lb lc ld gt nq np nr ns aw nt bi"><span id="0419" class="nu mk iq np b gy nv nw l nx ny"><strong class="np ir">public class </strong>Client {<br/>    <strong class="np ir">private static </strong>String <em class="nz">BASE_URL </em>= <strong class="np ir">"http://localhost:7777"</strong>;<br/><br/>    <strong class="np ir">public static </strong>PingOutput ping() <strong class="np ir">throws </strong>Exception {<br/>        String url = <em class="nz">BASE_URL </em>+ <strong class="np ir">"/ping"</strong>;<br/>        String response = ClientUtils.<em class="nz">doGet</em>(url);<br/>        <strong class="np ir">return </strong>ClientUtils.<em class="nz">parseJsonResponse</em>(response, PingOutput.<strong class="np ir">class</strong>);<br/>    }<br/><br/>    <strong class="np ir">public static </strong>UpscaleOutput upscale(UpscaleInput input) <strong class="np ir">throws </strong>Exception {<br/>        String url = <em class="nz">BASE_URL </em>+ <strong class="np ir">"/upscale"</strong>;<br/>        String response = ClientUtils.<em class="nz">doPost</em>(url, input.toJson());<br/>        <strong class="np ir">return </strong>ClientUtils.<em class="nz">parseJsonResponse</em>(response, UpscaleOutput.<strong class="np ir">class</strong>);<br/>    }<br/>}</span></pre><p id="2354" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">是时候一起测试整个拼图了！确保服务正在Docker中运行，并启动这些测试</p><pre class="la lb lc ld gt nq np nr ns aw nt bi"><span id="1c00" class="nu mk iq np b gy nv nw l nx ny">@Ignore<br/><strong class="np ir">public class </strong>ClientTest {<br/>    @Test<br/>    <strong class="np ir">public void </strong>ping() <strong class="np ir">throws </strong>Exception {<br/>        PingOutput output = Client.<em class="nz">ping</em>();<br/>        <em class="nz">assertNotNull</em>(output);<br/>        <em class="nz">assertTrue</em>(output.isSuccess());<br/>    }<br/><br/>    @Test<br/>    <strong class="np ir">public void </strong>upscale() <strong class="np ir">throws </strong>Exception {<br/>        String inputFilePath = <strong class="np ir">"../sample-images/t7.jpg"</strong>;<br/>        String outputFilePath = <strong class="np ir">"./sample-images/t7_up.jpg"</strong>;<br/>        File inputFile = <strong class="np ir">new </strong>File(inputFilePath);<br/>        UpscaleInput input = <strong class="np ir">new </strong>UpscaleInput(inputFile);<br/>        UpscaleOutput output = Client.<em class="nz">upscale</em>(input);<br/>        <em class="nz">assertNotNull</em>(output);<br/>        <em class="nz">assertFalse</em>(output.getImageBase64().isEmpty());<br/>        File outputFile = <strong class="np ir">new </strong>File(outputFilePath);<br/>        FileUtils.<em class="nz">writeByteArrayToFile</em>(outputFile, output.toBytesArray());<br/>    }<br/>}</span></pre><p id="64fe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果一切顺利，你应该有一个缩放图像保存在你的驱动器上</p><div class="la lb lc ld gt ab cb"><figure class="le jr lf lg lh li lj paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/ca16b52b472b1005b2f484e8966708de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*fUW2UMvU5ksHG6qmDYScUA.jpeg"/></div></figure><figure class="le jr lf lg lh li lj paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/5ca5b0943490b0e704894ce5c4fd7ee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*_9FSYPWF92VFqULtkaKDfA.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk lk di ll lm translated">左—双三次插值，右—图像超分辨率</figcaption></figure></div><div class="ab cb"><figure class="le jr lf lg lh li lj paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/64a6d7359998278e0a651f0fed6094aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*ZJ4SR9DSurIriFQBjoCg_Q.jpeg"/></div></figure><figure class="le jr lf lg lh li lj paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/3ada1483b0881b524f2781ced0738a6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*F_YLK6ig1NhIs1nr4Mkovw.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk lk di ll lm translated">左—双三次插值，右—图像超分辨率</figcaption></figure></div></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><p id="44e3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">就是这样！感谢您完成本教程，并在我们继续之前快速回顾一下——我们简要检查了图像超缩放，用Python构建了一个AI微服务作为Flask应用程序，将其包装在Docker容器中，并通过Java中的REST API客户端进行了测试。我希望这篇文章是有帮助的，我设法向您展示了如何在您的项目中集成Python AI服务。</p><p id="cbe9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">带有源代码的GitHub repo:</p><div class="oc od gp gr oe of"><a href="https://github.com/JPLeoRX/image-super-scaling-service" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">JPLeoRX/image-超级缩放-服务</h2><div class="om l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">github.com</p></div></div><div class="on l"><div class="oo l op oq or on os jw of"/></div></div></a></div></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><p id="e953" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你想查看我的其他作品或联系我:</p><ul class=""><li id="095f" class="ln lo iq ke b kf kg kj kk kn lp kr lq kv lr kz ot lt lu lv bi translated"><a class="ae lw" href="https://tekleo.net/" rel="noopener ugc nofollow" target="_blank">个人网站</a></li><li id="e913" class="ln lo iq ke b kf lx kj ly kn lz kr ma kv mb kz ot lt lu lv bi translated"><a class="ae lw" href="https://github.com/jpleorx" rel="noopener ugc nofollow" target="_blank"> GitHub </a></li><li id="3a58" class="ln lo iq ke b kf lx kj ly kn lz kr ma kv mb kz ot lt lu lv bi translated"><a class="ae lw" href="https://pypi.org/user/JPLeoRX/" rel="noopener ugc nofollow" target="_blank"> PyPI </a></li><li id="b67b" class="ln lo iq ke b kf lx kj ly kn lz kr ma kv mb kz ot lt lu lv bi translated"><a class="ae lw" href="https://hub.docker.com/u/jpleorx" rel="noopener ugc nofollow" target="_blank"> DockerHub </a></li><li id="9a08" class="ln lo iq ke b kf lx kj ly kn lz kr ma kv mb kz ot lt lu lv bi translated"><a class="ae lw" href="https://tekleo.net/blog/" rel="noopener ugc nofollow" target="_blank">博客</a></li><li id="c490" class="ln lo iq ke b kf lx kj ly kn lz kr ma kv mb kz ot lt lu lv bi translated"><a class="ae lw" href="https://www.linkedin.com/in/leo-ertuna-14b539187/" rel="noopener ugc nofollow" target="_blank"> LinkedIn(随意连接)</a></li></ul></div></div>    
</body>
</html>