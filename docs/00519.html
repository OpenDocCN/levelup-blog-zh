<html>
<head>
<title>Anonymous Functions and Closures in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的匿名函数和闭包</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/anonymous-functions-and-closures-in-go-e53ccccad352?source=collection_archive---------2-----------------------#2019-04-07">https://levelup.gitconnected.com/anonymous-functions-and-closures-in-go-e53ccccad352?source=collection_archive---------2-----------------------#2019-04-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/d1758f5d84d32073b2c52435a9d42642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*3Huif4E43KHDro3vv7szTQ.png"/></div></figure><div class=""/><p id="1c78" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在围棋中，函数是一等公民。因此，Go支持将函数作为参数传递，从其他函数返回函数，以及将函数赋给变量。在下面的教程中，我们将看看匿名函数和闭包。</p><h2 id="85c0" class="ks kt ix bd ku kv kw dn kx ky kz dp la kf lb lc ld kj le lf lg kn lh li lj lk bi translated">匿名函数</h2><p id="fdfe" class="pw-post-body-paragraph ju jv ix jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">一个<a class="ae lq" href="https://en.wikipedia.org/wiki/Anonymous_function" rel="noopener ugc nofollow" target="_blank">匿名函数</a>是一个不依赖于标识符的函数定义。例如，我们可以定义一个匿名函数，并立即调用它，如下所示:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="1990" class="ks kt ix lw b gy ma mb l mc md">func() {<br/>    fmt.Println("Hello!")<br/>}()  // Prints "Hello!"</span></pre><p id="0986" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此外，我们可以给一个变量分配一个匿名函数，然后使用该变量的标识符调用该函数。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="6d9c" class="ks kt ix lw b gy ma mb l mc md">var foo func() = func() {<br/>    fmt.Println("Hello!")<br/>}<br/>foo()  // Prints "Hello!"</span></pre><p id="69f1" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了简洁起见，我们应该允许从变量被赋给的类型来推断变量的类型。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="6c75" class="ks kt ix lw b gy ma mb l mc md">var foo = func() { ...</span></pre><p id="e2be" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">事实上，这允许我们在运行时给一个变量分配不同的函数。例如，我们可能希望根据用户输入给函数分配不同的值。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="f3a8" class="ks kt ix lw b gy ma mb l mc md">var foo func()<br/>​<br/>var input int<br/>fmt.Scan(&amp;input) // 2<br/>​<br/>switch input {<br/>case 1:<br/>    foo = func() {<br/>        fmt.Println("Hello!")<br/>    }<br/>case 2:<br/>    foo = func() {<br/>        fmt.Println("Goodbye!")<br/>    }<br/>default:<br/>    foo = func() {<br/>        fmt.Println("???")<br/>    }<br/>}<br/>​<br/>foo() // Prints "Goodbye!"</span></pre><p id="2324" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">注意，用标识符声明的函数也可以赋给相同类型的变量。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="4eeb" class="ks kt ix lw b gy ma mb l mc md">func foo() {<br/>    fmt.Println("Hello!")<br/>}<br/>​<br/>func main() {<br/>​<br/>    var bar func()<br/>    bar = foo<br/>    bar() // Prints "Hello!"<br/>}</span></pre><h2 id="cd16" class="ks kt ix bd ku kv kw dn kx ky kz dp la kf lb lc ld kj le lf lg kn lh li lj lk bi translated">关闭</h2><p id="f988" class="pw-post-body-paragraph ju jv ix jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">一个<a class="ae lq" href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" rel="noopener ugc nofollow" target="_blank">闭包</a>是一个匿名函数，它引用了在其自身声明之外声明的变量。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="5688" class="ks kt ix lw b gy ma mb l mc md">i := 0<br/>foo := func() int {<br/>    i += 10<br/>    return i<br/>}<br/>​<br/>fmt.Println(foo())  // Prints 10<br/>fmt.Println(foo())  // Prints 20</span></pre><p id="beb6" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">闭包也可以由函数返回。这里返回的函数被称为“关闭”变量<code class="fe me mf mg lw b">i</code>。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="18ee" class="ks kt ix lw b gy ma mb l mc md">func foo() func(int) int {<br/>    i := 0<br/>    return func(j int) int {<br/>        i += j<br/>        return i<br/>    }<br/>}<br/>​<br/>func main() {<br/>    bar := foo()<br/>​<br/>    fmt.Println(bar(10)) // Prints 10<br/>    fmt.Println(bar(10)) // Prints 20<br/>}</span></pre><h2 id="7364" class="ks kt ix bd ku kv kw dn kx ky kz dp la kf lb lc ld kj le lf lg kn lh li lj lk bi translated">额外资源</h2><ul class=""><li id="9f4c" class="mh mi ix jw b jx ll kb lm kf mj kj mk kn ml kr mm mn mo mp bi translated"><a class="ae lq" href="https://www.calhoun.io/5-useful-ways-to-use-closures-in-go/" rel="noopener ugc nofollow" target="_blank">在Go中使用闭包的5种有用方法</a></li></ul></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><div class="lr ls lt lu gt mx"><a href="https://gitconnected.com/learn/golang" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iy gy z fp nc fr fs nd fu fw iw bi translated">学习围棋-最佳围棋教程(2019) | gitconnected</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">22大围棋教程-免费学习围棋。课程由开发者提交和投票，使您能够找到…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">gitconnected.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl it mx"/></div></div></a></div></div></div>    
</body>
</html>