<html>
<head>
<title>CPU Scheduling Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CPU调度算法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/cpu-scheduling-algorithms-497e6992aa86?source=collection_archive---------12-----------------------#2021-07-25">https://levelup.gitconnected.com/cpu-scheduling-algorithms-497e6992aa86?source=collection_archive---------12-----------------------#2021-07-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d571" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个过程来统治他们所有人</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/88346a569dc0d10fc61f962a674fc75c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EuYr2QbBiKiL5Ata"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">安娜·杜德科娃在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="85af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们进入正题之前，让我们问问自己</p><blockquote class="lv"><p id="d365" class="lw lx it bd ly lz ma mb mc md me lu dk translated">什么是CPU调度，我们为什么需要它？</p></blockquote><p id="7dc7" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">真的吗？很好。现在继续(糟糕的笑话)。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="b69f" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">什么&amp;为什么</h1><p id="4bb0" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">CPU调度是确定哪个进程下一个应该获得CPU并开始或继续执行的“行为”。</p><p id="0e90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调度程序本身是一个进程，它根据我们将要讨论的不同参数来控制其他进程何时开始运行。</p><p id="e3e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于“为什么”,我相信在理解了什么是CPU调度程序之后，没有它几乎不可能工作。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="530b" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">两种类型</h1><p id="6fe0" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">有两种主要类型的调度程序—抢占式和非抢占式调度程序。<br/>如果一个调度程序是抢占式的，它可能在某个时候决定进程A现在有足够的CPU，并决定把它交给另一个进程。<br/>非抢占式调度程序不支持这种行为，当一个进程终止或该进程正在等待一些I/O操作并同时处于睡眠状态时，CPU会让出。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="05f7" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">我们如何衡量调度程序</h1><p id="f478" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们将关注几个主要指标，但在此之前，让我们尝试给出一个调度器的示例</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/de1f3b53c987537401f04f49b63e8310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KMZ5-T0g41hVNq7yhWLs_w.png"/></div></div></figure><p id="6999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上图中，您可以看到我们的机器有3个内核。数字表示到达的顺序。<br/>第一个任务来了，要求为3个时间单位提供1个内核，然后第二个任务来了，要求为5个时间单位提供2个内核，依此类推。</p><h2 id="480e" class="np ms it bd mt nq nr dn mx ns nt dp nb li nu nv nd lm nw nx nf lq ny nz nh oa bi translated">利用</h2><p id="f308" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">利用率由CPU繁忙时间的百分比来定义。<br/>在上面的案例中，我们有18个可用块，但其中只有16个正在使用，这意味着这里的利用率是0.888 (88.8%)。</p><h2 id="2e63" class="np ms it bd mt nq nr dn mx ns nt dp nb li nu nv nd lm nw nx nf lq ny nz nh oa bi translated">吞吐量</h2><p id="b037" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">吞吐量是指单位时间内完成的工作量。在我们的例子中，3个进程以6个时间单位完成它们的执行，这意味着我们的吞吐量是0.5。</p><h2 id="0118" class="np ms it bd mt nq nr dn mx ns nt dp nb li nu nv nd lm nw nx nf lq ny nz nh oa bi translated">等待时间</h2><p id="cd29" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">等待时间是由作业提交时间和实际开始运行时间之间的差值定义的。<br/>在我们的例子中，假设作业3可以在时间单元2中提交，但是此时，作业1和2占用了所有资源，这使得作业3等待，直到它有足够的资源开始运行。</p><h2 id="0507" class="np ms it bd mt nq nr dn mx ns nt dp nb li nu nv nd lm nw nx nf lq ny nz nh oa bi translated">响应时间</h2><p id="a719" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">响应时间由作业提交时间和终止时间之间的差异来定义。<br/>假设任务3在时间单元2提交，在时间单元6终止，这意味着该任务的响应时间为4。</p><blockquote class="lv"><p id="a899" class="lw lx it bd ly lz ma mb mc md me lu dk translated">我们希望最大化利用率和吞吐量，最小化等待和响应时间</p></blockquote></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="f5ea" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">先来先服务</h1><p id="c8df" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">这个名字很容易理解——作业是根据它们的到达时间来安排的。如果有足够的空闲核心，一个到达的作业将立即开始运行。<br/>否则，它会一直等待，直到有足够的内核被释放。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/b62b8d630ec459d3d96d60850b3c11fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*L1TPrOpfTFMNTPA_C58ZiA.png"/></div></figure><p id="88ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图展示了FCFS是如何工作的，我们可以立即看到我们可以优化它。<br/>如我们所见，作业4只需要两个内核用于一个时间单元，并且可以在未利用的内核上进行调度。</p><p id="af05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">优点:</p><ul class=""><li id="31b4" class="oc od it lb b lc ld lf lg li oe lm of lq og lu oh oi oj ok bi translated">易于实施——FIFO等待队列</li><li id="a7ea" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">被认为是最公平的</li></ul><p id="9149" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缺点:</p><ul class=""><li id="9867" class="oc od it lb b lc ld lf lg li oe lm of lq og lu oh oi oj ok bi translated">产生碎片——未利用的内核</li><li id="9925" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">小型或短期工作可能会等待很长时间</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="d36d" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">带回填的FCFS</h1><p id="f119" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">FCFS的这种变化减少了未利用的核心数量。<br/>每当一个任务到达或终止时，我们试图启动等待队列的头部——就像我们在最初的FCFS中所做的那样。<br/>然后，迭代等待的作业，并尝试回填它们。</p><p id="4884" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个短暂的等待作业可以“跳过”等待队列的头部而不延迟其开始时间时，就会发生回填。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/5d22caddacb2de9bd4e4631974b26d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*9ssIkIVY3HEzn3CgEvzN2g.png"/></div></figure><p id="f834" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，作业3没有被延迟，但是我们可以让作业4跳过它并在作业3等待足够的资源时执行。</p><p id="f1be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">优点:</p><ul class=""><li id="890e" class="oc od it lb b lc ld lf lg li oe lm of lq og lu oh oi oj ok bi translated">碎片更少—利用率更高</li></ul><p id="bee9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缺点:</p><ul class=""><li id="92b0" class="oc od it lb b lc ld lf lg li oe lm of lq og lu oh oi oj ok bi translated">必须提前知道运行时间，以便计算“洞”的大小，并知道哪些候选人可以回填。</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="2b32" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">最短作业优先(SJF)</h1><p id="05e6" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">与FCFS不同，我们不是根据任务的到达时间来排序任务，而是根据任务的预计运行时间来排序时间。<br/>该算法在平均等待时间的度量上是最优的，让我们尝试得到一些直觉为什么。</p><p id="1921" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设执行FCFS导致了这一点</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/4c38f7a7185cdd37bd7a09c569ffd031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*doWDqDwLuxi-mrnXOw6iAg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">FirstCome</figcaption></figure><p id="f5f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试着想想SJF的情况会有什么不同，并计算各自的平均等待时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/294ef3adb3d52ce46a430dc6f9da9a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*tCCjz7cKS_PFBDhw6QEDSQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">SJF</figcaption></figure><p id="38aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于FCFS调度程序(第一个图示):</p><ul class=""><li id="2bd7" class="oc od it lb b lc ld lf lg li oe lm of lq og lu oh oi oj ok bi translated">作业1等待0个时间单位</li><li id="9c5c" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">作业2等待3个时间单位</li><li id="852c" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">作业3等待4个时间单位</li></ul><p id="935a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，平均等待时间是(0+3+4)/3 = 7/3</p><p id="e20d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为SJF调度程序做同样的事情(第二个例子):</p><ul class=""><li id="7a95" class="oc od it lb b lc ld lf lg li oe lm of lq og lu oh oi oj ok bi translated">作业1等待2个时间单位</li><li id="7890" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">作业2等待0时间单位</li><li id="7db9" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">作业3等待1个时间单位</li></ul><p id="3171" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，平均等待时间是(2+0+1)/3 = 1</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="4acb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有很多调度算法，我将在以后介绍。我们甚至还没有谈到抢占式调度器，所以还有很多东西要讨论，但是现在让我们休息一下。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="de1f" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">最后一句话</h1><p id="2eb7" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">本周我刚刚开通了我的个人博客，在那里你可以找到更多像这样的故事，所以希望，如果你读得很好，我会在那里看到你。</p></div></div>    
</body>
</html>