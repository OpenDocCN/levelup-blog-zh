<html>
<head>
<title>File and Directory Backup, Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">文件和目录备份，第2部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/file-and-directory-backup-part-2-9397dc8b885e?source=collection_archive---------22-----------------------#2021-01-25">https://levelup.gitconnected.com/file-and-directory-backup-part-2-9397dc8b885e?source=collection_archive---------22-----------------------#2021-01-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5b25" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Python和PyQt5</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/07ee1bc1b026f425580c589e96a4b6f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vwgDhuaTIaJDypMZvYKrsQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">来自Unsplash的Jan Antonin Kolar的照片</figcaption></figure><p id="0c5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在项目的<a class="ae kv" href="https://zenndogg-52643.medium.com/file-and-directory-backup-part-1-5be98cd7441e" rel="noopener">第一部分</a>中，我们使用<em class="ls"> Robocopy </em>作为实际的文件传输引擎编写了主备份程序。对于一个基本的文件传输脚本来说，它工作得很好，但是正如我们在第1部分中提到的，我们如何判断传输何时完成或者程序是否正在运行？该项目可从以下网址下载:</p><p id="7a81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/zazen000/File-and-Directory-Backup" rel="noopener ugc nofollow" target="_blank">https://github.com/zazen000/File-and-Directory-Backup</a></p><p id="fb2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想要某种视觉指示器向用户显示程序确实在运行。这意味着将GUI集成到我们的备份程序中。我选择的GUI模块？PyQt5。</p><p id="e823" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们继续之前，我想解释一下我对PyQt5的使用。我的大部分图形用户界面都是在我的个人电脑桌面上使用的。我有一种特定的“风格”用于我所有的项目；黑底蓝字，无标题。我们稍后会看到为什么这很重要。</p><p id="6384" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，我在开始的时候试着把它写成一个文件。我不能让它正常工作。要么指示器会显示，但备份不会工作，要么备份会工作，但指示器不会显示。我最近了解到这是一个被称为“阻塞”的问题。我的解决方案是专门为指示器创建第二个文件。</p><p id="b25a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从进口开始。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="f397" class="ly lz iq lu b gy ma mb l mc md">import sys, os<br/>from PyQt5.QtGui import QFont, QMovie<br/>from PyQt5.QtCore import Qt, QFileSystemWatcher<br/>from PyQt5.QtWidgets import QApplication, QLabel, QWidget</span></pre><p id="0c89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于将这个项目分成两部分，我意识到需要有一种方法让备份脚本告诉GUI脚本它已经完成并关闭。我以前曾使用临时文件在脚本间传输数据，并决定用这个来试试。我把那个文件命名为<em class="ls"> oo.txt </em>。下一条语句初始化该文件的路径。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="3f80" class="ly lz iq lu b gy ma mb l mc md">path = “C:/Users/mount/source/repos/MyDashboard/oo.txt”</span></pre><p id="904e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在PyQt5中的gui是一个类。下一节将对gui进行初始化、调整大小和定位。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="7fd8" class="ly lz iq lu b gy ma mb l mc md">class Spinner<em class="ls">(</em>QWidget<em class="ls">)</em>:<br/> <br/>    def __init__<em class="ls">(</em>self<em class="ls">)</em>:<br/>        super<em class="ls">()</em>.__init__<em class="ls">()</em><br/>        self.left   = 315<br/>        self.top    = 1<br/>        self.width  = 20<br/>        self.height = 23</span></pre><p id="9fc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从高度和宽度可以看出，实际的gui相当小。这是我不想要窗口标题栏的一个原因。另外，你可以看到我选择了一个. gif文件，而不是一个显示“正在工作”的标签。我们的下一步是设置一些变量。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="048a" class="ly lz iq lu b gy ma mb l mc md">def qblack<em class="ls">(</em>self<em class="ls">)</em>:<br/>    self.setWindowFlags<em class="ls">(</em>Qt.FramelessWindowHint<em class="ls">)</em><br/>    self.setGeometry<em class="ls">(</em>self.left,self.top,self.width,self.height<em class="ls">)</em><br/>    self.setAutoFillBackground<em class="ls">(</em>True<em class="ls">)</em><br/>    p = self.palette<em class="ls">()</em><br/>    p.setColor<em class="ls">(</em>self.backgroundRole<em class="ls">()</em>, Qt.black<em class="ls">)</em><br/>    self.setPalette<em class="ls">(</em>p<em class="ls">)</em></span><span id="27e0" class="ly lz iq lu b gy me mb l mc md">def qlabel<em class="ls">(</em>self<em class="ls">)</em>:<br/>    return “QLabel {color: rgba(80,130,255,255); background-color: black;}”</span></pre><p id="4e82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls"> qblack </em>是一个用我想要的参数构建窗口的函数。</p><p id="ba8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">qlabel是一个PyQt5 QLabel样式表，带有我想要的参数，我总是将它赋给一个变量。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="93a1" class="ly lz iq lu b gy ma mb l mc md">qblack<em class="ls">(</em>self<em class="ls">)<br/></em>center = Qt.AlignCenter<em class="ls"> <br/></em>canda_8 = QFont<em class="ls">(</em>‘Candalara’, 8<em class="ls">)<br/></em>q_label = qlabel<em class="ls">( </em>self <em class="ls">)</em></span></pre><p id="e7b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们设置. gif文件的实际显示。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="64d6" class="ly lz iq lu b gy ma mb l mc md">self.gif = QMovie<em class="ls">(</em>r’blu_circ.gif’<em class="ls">)</em><br/>self.lbl = QLabel<em class="ls">(</em>self<em class="ls">)</em><br/>self.lbl.setStyleSheet<em class="ls">(</em>q_label<em class="ls">)</em><br/>self.lbl.setAlignment<em class="ls">(</em>center<em class="ls">)</em><br/>self.lbl.setGeometry<em class="ls">(</em>0, 0, 25, 23<em class="ls">)</em><br/>self.lbl.setMovie<em class="ls">(</em>self.gif<em class="ls">)</em><br/>self.gif.start<em class="ls">()</em></span></pre><p id="5807" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第一行中，微调文件通过<em class="ls"> QMovie </em>调用，并分配给<em class="ls"> self.gif. </em></p><p id="de98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一行调用<em class="ls"> QLabel </em>，接下来的四行设置了所需的参数。</p><p id="4e4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">。gif </em>被分配给标签，然后开始播放。这是微调器的样子(放大)。</p><p id="dcba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们需要一种在适当的时候关闭程序的方法，所以我写了一个退出例程。但是首先，我们需要第一部分中的一个函数:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="90a5" class="ly lz iq lu b gy ma mb l mc md">def write_txt_file<em class="ls">(</em>filename=’’, txt=’’, option=”a”<em class="ls">)</em>:<br/>    with open<em class="ls">(</em>filename, option<em class="ls">) </em>as file:<br/>    file.write<em class="ls">(</em>‘\n’<em class="ls">)</em><br/>    file.write<em class="ls">(</em>txt<em class="ls">)</em></span></pre><p id="8857" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将它用于以下功能</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="e814" class="ly lz iq lu b gy ma mb l mc md">def xit<em class="ls">(</em>self<em class="ls">)</em>:<br/>    write_txt_file<em class="ls">(</em>‘oo.txt’, ‘’, “w”<em class="ls">)</em><br/>    self.close<em class="ls">()</em></span></pre><p id="5671" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当备份程序停止时，它会在我们的文本文件中写入一个空行。</p><p id="b9ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，回忆一下第1部分:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="2830" class="ly lz iq lu b gy ma mb l mc md">     count = 0<br/>     logg = log_directory<em class="ls">()</em><br/>     lenn = len<em class="ls">(</em>dirs<em class="ls">)</em></span><span id="de1c" class="ly lz iq lu b gy me mb l mc md">     count += 1</span><span id="494f" class="ly lz iq lu b gy me mb l mc md">     if status == False:<br/> <br/>         ensure_directory<em class="ls">( </em>dst <em class="ls">)</em><br/>         compare_directories<em class="ls">( </em>src, dst <em class="ls">)</em><br/>         cmnd = f’robocopy <em class="ls">{</em>src<em class="ls">} {</em>dst<em class="ls">} {</em>swt<em class="ls">}</em>’<br/>         copi = subprocess.Popen<em class="ls">( </em>cmnd, shell=False <em class="ls">)</em><br/>         code = copi.wait<em class="ls">()</em><br/> <br/>     codes = range(0, 9)<br/> <br/>     if count == lenn and code in codes:<br/>         write_txt_file<em class="ls">( </em>‘oo.txt’, ‘this file has changed!’ <em class="ls">)</em><br/> <br/> sys.exit<em class="ls">()</em></span></pre><p id="f39c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将在这里解释第1部分(backup.py)中剩余的代码。在使用<em class="ls">子进程</em>之前，我是用<em class="ls"> os.system </em>调用<em class="ls"> robocopy </em>。当备份脚本完成时，它会写入到<em class="ls"> oo.txt </em>。x <em class="ls"> it() </em>用于清除<em class="ls"> oo.txt </em>并关闭文件。</p><p id="e0c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这很有效，但不是我想要的方式。时机不对。文本文件是在python文件关闭时写入的，而不是在<em class="ls"> robocopy </em>完成时。那是不行的。我点燃了互联网，开始寻找答案。经过几个小时的研究和几天的无所事事，我的意思是实验，我想出了解决办法；<em class="ls">子流程. Popen. </em></p><p id="76e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">子流程。Popen </em>不仅打开<em class="ls"> os </em>文件，它还使用<em class="ls"> wait() </em>等待完成代码。太棒了。我运行了备份，得到代码=2。如果语句为，则<em class="ls">的版本1；<em class="ls">如果代码= 2: </em>。</em></p><p id="ec08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我运行过一次。成功了！我又运行了一次。成功了！我又运行了一次。失败了！</p><p id="0078" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">猜猜我学到了什么？还有更多代码。</p><p id="1069" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于我真的不在乎代码是什么，所以只返回了那个代码。答案是:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="a56b" class="ly lz iq lu b gy ma mb l mc md">codes = range(0, 9)</span></pre><p id="ac77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并且:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="7e2f" class="ly lz iq lu b gy ma mb l mc md">if code in codes:</span></pre><p id="4d99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，一切顺利。但是每隔一段时间，在这个过程中会返回一个代码，而不是之后。我认为这与dirs被迭代的方式有关。</p><p id="d7c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我需要别的东西。我的解决方案是计算迭代次数，将这个数字与我的目录列表的长度进行比较。当两者匹配并返回代码时，文本文件被写入。</p><p id="a9a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哈利路亚！我们完了。</p><p id="65a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不完全是。</p><p id="2240" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经让备份程序在正确的时间写入我们的文本文件，但是<em class="ls"> Spinner() </em>如何知道该文件何时发生了变化？</p><p id="da05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不知道。</p><p id="102a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在StackOverflow上发布了这个问题，一个名叫musicmante的响应者建议<em class="ls"> QFileSystemWatcher </em>。一个建议把一切都联系在了一起。这是Spinner类的最后一部分。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="3208" class="ly lz iq lu b gy ma mb l mc md">if __name__ == ‘__main__’:<br/>    watcher = QFileSystemWatcher<em class="ls">()</em><br/>    watcher.addPath<em class="ls">(</em>path<em class="ls">)</em><br/>    app = QApplication<em class="ls">([])</em><br/>    e = Spinner<em class="ls">()</em><br/>    e.show<em class="ls">()</em><br/>    watcher.fileChanged.connect<em class="ls">(</em>e.xit<em class="ls">)</em><br/>    sys.exit<em class="ls">(</em>app.exec_<em class="ls">())</em></span></pre><p id="0904" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们分配观察器和要观察的路径(和文件)。路径已在前面指定。</p><p id="9d70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当备份程序写到<em class="ls"> oo.txt </em>时，那就是对文件的改变。Watcher检测到这一变化，调用<em class="ls"> xit() </em>清理文件并关闭微调器。</p><p id="bdcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">找到了。现在我是一个快乐的露营者。</p><p id="ed65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我用一个“交通警察”程序来打开备份文件和微调文件。完整的代码如下。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="425d" class="ly lz iq lu b gy ma mb l mc md">import os<br/> <br/>os.system<em class="ls">(</em>r”start /min python backup.py”<em class="ls">)</em><br/>os.system<em class="ls">(</em>r”start /min python backup_main.py”<em class="ls">)</em></span></pre><p id="d2b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是Spinner的完整代码。请注意:我是从我写的一个PyQt5支持模块中导入<em class="ls"> qblack、qlabel </em>和<em class="ls"> write_text_file </em>的。您可以选择做同样的事情，或者将这些功能合并到下面的脚本中。</p><p id="f0de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你喜欢阅读这样的故事，并想支持我成为一名作家，可以考虑每月5美元订阅Medium。作为会员，你可以无限制地访问媒体上的故事。如果你用我的<a class="ae kv" href="https://zenndogg-52643-medium.com/membership" rel="noopener ugc nofollow">链接</a>注册，我会赚一小笔佣金。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="2970" class="ly lz iq lu b gy ma mb l mc md">import sys, os, subprocess<br/>from qtpy_cfg import qblack, qlabel, write_text_file<br/>from PyQt5.QtGui import QFont, QMovie<br/>from PyQt5.QtCore import Qt, QFileSystemWatcher<br/>from PyQt5.QtWidgets import QApplication, QLabel, QWidget<br/> <br/> <br/>path = “C:/Users/mount/source/repos/MyDashboard/oo.txt”<br/> <br/>class Spinner<em class="ls">( </em>QWidget <em class="ls">)</em>:<br/><em class="ls">‘’’</em><br/> <br/> <em class="ls">Creates a window for blu_circ.gif, a spinning indicator</em><br/> <em class="ls">that shows the backup operation is being performed</em><br/> <br/><em class="ls">‘’’</em><br/> <br/>    def __init__<em class="ls">(</em>self<em class="ls">)</em>:<br/>        super<em class="ls">()</em>.__init__<em class="ls">()</em><br/>        self.left = 315<br/>        self.top = 1<br/>        self.width = 20<br/>        self.height = 23<br/> <br/>        qblack<em class="ls">( </em>self <em class="ls">)      </em># PyQt5 window initialization function<br/>        center = Qt.AlignCenter<br/>        canda_8 = QFont<em class="ls">(</em>‘Candalara’, 8<em class="ls">)</em><br/>        q_label = qlabel<em class="ls">( </em>self <em class="ls">) </em># PyQt5 label stylesheet function<br/> <br/>        self.gif = QMovie<em class="ls">( </em>r’blu_circ.gif’ <em class="ls">)</em><br/>        self.lbl = QLabel<em class="ls">( </em>self <em class="ls">)</em><br/>        self.lbl.setStyleSheet<em class="ls">( </em>q_label <em class="ls">)</em><br/>        self.lbl.setAlignment<em class="ls">( </em>center <em class="ls">)</em><br/>        self.lbl.setFont<em class="ls">( </em>canda_8 <em class="ls">)</em><br/>        self.lbl.setGeometry<em class="ls">( </em>0, 0, 25, 23 <em class="ls">)</em><br/>        self.lbl.setMovie<em class="ls">( </em>self.gif <em class="ls">)</em><br/>        self.gif.start<em class="ls">()</em><br/> <br/> <br/>    def xit<em class="ls">(</em>self<em class="ls">)</em>:<br/>    <em class="ls">‘’’</em><br/> <br/>    <em class="ls">Resets the status-check file ‘oo.txt’</em><br/>    <em class="ls">to a blank file and closes the spinner</em><br/> <br/>    '<em class="ls">’’</em><br/>        write_txt_file<em class="ls">(</em>‘oo.txt’, ‘’, “w”<em class="ls">)</em><br/>        self.close<em class="ls">()</em><br/> <br/> <br/> if __name__ == ‘__main__’:<br/> watcher = QFileSystemWatcher<em class="ls">()</em><br/> watcher.addPath<em class="ls">( </em>path <em class="ls">) </em># Path to the watched file<br/> app = QApplication<em class="ls">( [] )</em><br/> e = Spinner<em class="ls">()</em><br/> e.show<em class="ls">()</em><br/> watcher.fileChanged.connect<em class="ls">( </em>e.xit <em class="ls">)</em><br/> sys.exit<em class="ls">( </em>app.exec_<em class="ls">() )</em></span></pre><p id="92ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">backup.py的代码是:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="6e83" class="ly lz iq lu b gy ma mb l mc md">import os<br/>import sys<br/>import time<br/>import filecmp<br/>import subprocess<br/> <br/> <br/> dirs = <em class="ls">(</em><br/>     <em class="ls">(</em>r”C:\Users\mount\source\repos”, r”M:\_BACKUP\REPOS”<em class="ls">)</em>,<br/>     <em class="ls">(</em>r”D:\mount\Downloads”, r”M:\_BACKUP\DOWNLOADS”<em class="ls">)</em>,<br/>     <em class="ls">(</em>r”D:\mount\Documents”, r”M:\_BACKUP\DOCUMENTS”<em class="ls">)</em>,<br/>     <em class="ls">(</em>r”D:\Internet-Marketing”, r”M:\_BACKUP\IM”<em class="ls">)</em>,<br/>     <em class="ls">(</em>r”D:\_HOLOSYNC”, r”M:\_BACKUP\HOLOSYNC”<em class="ls">)</em>,<br/>     <em class="ls">(</em>r”D:\mount\Music”, r”M:\_BACKUP\MUSIC”<em class="ls">)</em>,<br/>     <em class="ls">(</em>r”D:\_BIZ”, r”M:\_BACKUP\BIZ”<em class="ls">)</em>,<br/>     <em class="ls">(</em>r”D:\_PWA”, r”M:\_BACKUP\PWA”<em class="ls">)</em>,<br/>     <em class="ls">(</em>r”C:\data\db”, r”M:\_BACKUP\DB”<em class="ls">)</em>,<br/>     <em class="ls">(</em>r”C:\ProgramData\MongoDB”, r”M:\_BACKUP\MONGODB “<em class="ls">)</em>,<br/> <em class="ls">)</em><br/> <br/> <br/> def ensure_directory<em class="ls">( </em>dst <em class="ls">)</em>:<br/> <em class="ls">‘’’</em><br/> <br/> <em class="ls">If the destination folder doesn’t exist, create it</em><br/> <br/> <em class="ls">‘’’</em><br/> <br/>     directory = os.path.dirname<em class="ls">( </em>dst <em class="ls">)</em><br/>     if not os.path.exists<em class="ls">( </em>directory <em class="ls">)</em>:<br/>         os.makedirs<em class="ls">( </em>directory <em class="ls">)</em><br/> <br/> <br/> <br/> def compare_directories<em class="ls">( </em>src, dst <em class="ls">)</em>:<br/> <em class="ls">‘’’</em><br/> <br/> <em class="ls">Compares the source and destination directories.</em><br/> <em class="ls">Returns False if not the same.</em><br/> <em class="ls">True means both directories and files match and no backup is required.</em><br/> <br/> <em class="ls">‘’’</em><br/> <br/>     try:<br/>         comp = filecmp.dircmp<em class="ls">( </em>src, dst <em class="ls">)</em><br/>         common = sorted<em class="ls">( </em>comp.common <em class="ls">)</em><br/>     except:<br/>         return False<br/> <br/>     left = sorted<em class="ls">( </em>comp.left_list <em class="ls">)</em><br/>     right = sorted<em class="ls">( </em>comp.right_list <em class="ls">)</em><br/>     if left != common or right != common:<br/>         return False<br/> <br/>     if len<em class="ls">( </em>comp.diff_files <em class="ls">)</em>:<br/>         return False<br/> <br/>     for subdir in comp.common_dirs:<br/>     left_subdir = os.path.join<em class="ls">( </em>src, subdir <em class="ls">)</em><br/>     right_subdir = os.path.join<em class="ls">( </em>dst, subdir <em class="ls">)</em><br/>     return compare_directories<em class="ls">( </em>left_subdir, right_subdir <em class="ls">)</em><br/> <br/> return True<br/> <br/> <br/> def log_directory<em class="ls">()</em>:<br/> <em class="ls">‘’’</em><br/> <br/> <em class="ls">Creates a LOG directory, if it does not exist</em><br/> <em class="ls">then creates a sub-directory named for date and</em><br/> <em class="ls">time for the backup log</em><br/> <br/> <em class="ls">‘’’</em><br/>     now = time.strftime<em class="ls">(</em>“%Y-%m-%d___%H-%M”<em class="ls">)</em><br/>     direct = os.path.dirname<em class="ls">(</em>“C:\\Users\\mount\\source\\repos\\MyDashboard\\LOG\\”<em class="ls">)</em><br/>     directory = direct + ‘\\’ + now + ‘\\’<br/>     if not os.path.exists<em class="ls">( </em>directory <em class="ls">)</em>:<br/>         os.makedirs<em class="ls">( </em>directory <em class="ls">)</em><br/> return directory<br/> <br/> <br/> count = 0<br/> logg = log_directory<em class="ls">()</em><br/> lenn = len<em class="ls">(</em>dirs<em class="ls">)</em><br/> <br/> for dir in dirs:<br/> '''<br/> src = source directory<br/> dst = destination directory<br/> swt = switches for robocopy:<br/> /xo = only newer versions of file,<br/> /s = all occupied sub-directories,<br/> /MT:nn = # of threads (maximum=128, default=8)<br/> /xx = copy source file even when destination file does not exist<br/> /LOG+ = a log is created for every dir in dirs. /LOG+ appends all logs to one file<br/> /r:n = number of times to retry, default = 1,000,000 ### you WILL want to use this switch<br/> /w:nn = number of seconds to wait before retrying, default is 30<br/> '''</span><span id="e42e" class="ly lz iq lu b gy me mb l mc md">     count += 1<br/>     src, dst, swt = dir<em class="ls">[</em>0<em class="ls">]</em>, dir<em class="ls">[</em>1<em class="ls">]</em>, f”/XX /r:2 /xo /s /w:5 /MT:128 /LOG+:<em class="ls">{</em>logg<em class="ls">}</em>_BACKUP.log”<br/>     status = <em class="ls">(</em>compare_directories<em class="ls">(</em>src, dst<em class="ls">))</em><br/> <br/> <br/>     if status == False:<br/> <br/>         ensure_directory<em class="ls">( </em>dst <em class="ls">)</em><br/>         compare_directories<em class="ls">( </em>src, dst <em class="ls">)</em><br/>         cmnd = f’robocopy <em class="ls">{</em>src<em class="ls">} {</em>dst<em class="ls">} {</em>swt<em class="ls">}</em>’<br/>         copi = subprocess.Popen<em class="ls">( </em>cmnd, shell=False <em class="ls">)</em><br/>        code = copi.wait<em class="ls">()</em><br/> <br/>     codes = range<em class="ls">(</em>0, 9<em class="ls">)</em><br/> <br/>     if count == lenn and code in codes:<br/>         write_txt_file<em class="ls">( </em>‘oo.txt’, ‘this file has changed!’ <em class="ls">)</em><br/> <br/> sys.exit<em class="ls">()</em></span></pre></div></div>    
</body>
</html>