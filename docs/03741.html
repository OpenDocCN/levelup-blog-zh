<html>
<head>
<title>Understanding why a database deadlock occurs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解数据库死锁发生的原因</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-why-a-database-deadlock-occurs-8bbd32be8026?source=collection_archive---------7-----------------------#2020-05-25">https://levelup.gitconnected.com/understanding-why-a-database-deadlock-occurs-8bbd32be8026?source=collection_archive---------7-----------------------#2020-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/48db98850db819de2617e28a7e05bd2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_u9DVXa89MGK57qy"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@josenothose?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">何塞·丰塔诺</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><div class=""/><figure class="gl gn kh ki kj iv gh gi paragraph-image"><div class="gh gi kg"><img src="../Images/3d43790189c7ba8216eaa3cb229d9183.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*5fAlgCSLLbV3ByPQrtgbgQ.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">数据库死锁</figcaption></figure><h1 id="423f" class="kk kl jj bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">议程</h1><p id="5c61" class="pw-post-body-paragraph li lj jj lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">这篇文章试图解释什么是数据库死锁以及为什么会发生死锁。</p><p id="8f3f" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">我们将编写SQL语句，故意造成死锁，并讨论如何缓解死锁。</p><p id="f77e" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">我们将使用PostgreSQL作为我们的数据库。</p><h1 id="dc90" class="kk kl jj bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">设置</h1><p id="3701" class="pw-post-body-paragraph li lj jj lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">让我们启动一个PostgreSQL shell并创建一个名为accounts的表。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="d989" class="mu kl jj mq b gy mv mw l mx my">akshar=# create table accounts (acct_id integer, amount integer); CREATE TABLE</span></pre><p id="6612" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">让我们在这个表中插入两行。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="3098" class="mu kl jj mq b gy mv mw l mx my">akshar=# insert into accounts values (1, 500);<br/>INSERT 0 1<br/>akshar=# insert into accounts values (2, 300);<br/>INSERT 0 1</span></pre><p id="629f" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">让我们验证是否插入了行。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="b416" class="mu kl jj mq b gy mv mw l mx my">akshar=# select * from accounts;<br/>acct_id | amount<br/>---------+--------<br/>1 | 500<br/>2 | 300<br/>(2 rows)</span></pre><h1 id="c2b2" class="kk kl jj bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">交易</h1><p id="1aaf" class="pw-post-body-paragraph li lj jj lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">要正确理解死锁，对事务有一个基本的了解是很重要的。</p><p id="f794" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">事务是DBMS的一个特性，它使数据库保持一致和可靠的状态。维基百科将交易定义为:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="d75f" class="mu kl jj mq b gy mv mw l mx my">A database transaction symbolizes a unit of work performed within a database management system against a database, and treated in a coherent and reliable way independent of other transactions.</span></pre><p id="68f9" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">交易保证ACID合规性。阅读<a class="ae jg" href="https://en.wikipedia.org/wiki/ACID" rel="noopener ugc nofollow" target="_blank">以了解ACID </a>。</p><p id="a96d" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">银行转帐是理解数据库事务的经典案例。假设我们的应用程序提供了从账户A向账户b转账的功能。</p><p id="e6da" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">在转账过程中，账户A应被借记，账户B应被贷记。借方和贷方形成一个单一的工作单元。要么两个操作都应该发生，要么都不应该发生。这就是为什么这两个语句应该是单个事务的一部分。</p><p id="9881" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">让我们启动一个<code class="fe mz na nb mq b">psql</code> shell，进行一个交易，将钱从一个帐户转移到另一个帐户。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="acfc" class="mu kl jj mq b gy mv mw l mx my">akshar=# begin transaction;<br/>BEGIN<br/>akshar=# update accounts set amount=amount-10 where acct_id=1; UPDATE 1<br/>akshar=# update accounts set amount=amount+10 where acct_id=2; UPDATE 1<br/>akshar=# commit;<br/>COMMIT</span></pre><p id="cc20" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">让我们核对一下两个账户的金额。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="c0ab" class="mu kl jj mq b gy mv mw l mx my">akshar=# select * from accounts;<br/>acct_id | amount<br/>---------+--------<br/>1 | 490<br/>2 | 310<br/>(2 rows)</span></pre><p id="163e" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">这表明转账成功完成，我们的交易代码是正确的。</p><h1 id="838b" class="kk kl jj bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">导致死锁</h1><p id="3b5a" class="pw-post-body-paragraph li lj jj lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">我们现在就故意制造僵局。</p><p id="e2fc" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">任何生产就绪的DBMS都能够同时服务于多个进程。我们将通过运行两个<code class="fe mz na nb mq b">psql</code>shell来模拟两个同时发生的传输量。</p><p id="9fd9" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">首先，shell将模拟一个从帐户1向帐户2转账的过程。第二个shell将模拟一个从帐户2到帐户1的转帐过程。</p><p id="faa2" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">账户1想要将金额10转移到账户2。我们将在第一个shell上这样做。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="2b35" class="mu kl jj mq b gy mv mw l mx my">akshar=# begin transaction;<br/>BEGIN<br/>akshar=# update accounts set amount=amount-10 where acct_id=1; UPDATE 1</span></pre><p id="0202" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">同时，即在第一笔交易完成之前，账户2决定将金额20转移到账户1。我们将在第二个shell上这样做</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="0226" class="mu kl jj mq b gy mv mw l mx my">akshar=# begin transaction;<br/>BEGIN<br/>akshar=# update accounts set amount=amount-20 where acct_id=2; UPDATE 1</span></pre><p id="683f" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">让我们假设DBMS给了第一个进程下一次运行的机会。因此，让我们通过在第一个shell上贷记account 2来模拟一下。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="24b7" class="mu kl jj mq b gy mv mw l mx my">akshar=# update accounts set amount=amount+10 where acct_id=2;</span></pre><p id="e2a0" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">您应该注意到，数据库不会返回成功消息，而是被阻塞，您不会得到任何响应。</p><p id="f3e1" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">这是因为acct_id=2的行当前是<code class="fe mz na nb mq b">locked</code>，因为进程2对该行进行了更新。在进程2释放该锁之前，进程1无法获得它。</p><p id="097f" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">数据库现在会给进程2一个运行的机会。因此，让我们通过在第二个shell上贷记帐户1来模拟这种情况。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="2715" class="mu kl jj mq b gy mv mw l mx my">akshar=# update accounts set amount=amount+20 where acct_id=1;</span></pre><p id="b466" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">数据库会返回一个<code class="fe mz na nb mq b">ERROR: deadlock detected</code>。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="fc1f" class="mu kl jj mq b gy mv mw l mx my">ERROR: deadlock detected<br/>DETAIL: Process 77716 waits for ShareLock on transaction 173312; blocked by process 76034.<br/>Process 76034 waits for ShareLock on transaction 173313; blocked by process 77716.<br/>HINT: See server log for query details. CONTEXT: while updating tuple (0,3) in relation "accounts"</span></pre><p id="6a37" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">当进程1从帐户1中借记金额10时，它已经锁定了acct_id=1的db行。现在进程2试图对同一行进行更新，这一步需要锁。只有当进程1释放锁时，进程2才能获得锁。但是进程1被阻塞，等待进程2释放acct_id=2上的锁。实际上，进程1正在等待进程2释放锁，而进程2正在等待进程1释放锁。这是一个僵局。</p><p id="b9fb" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">数据库足够智能，可以检测到死锁。</p><p id="2e99" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">数据库将在进程2外壳中引发此死锁错误。一旦出现死锁错误，该进程持有的所有锁都将被释放。这也给了进程1一个获得所需锁的机会。</p><p id="920a" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">检查进程1外壳，被阻止的命令将返回，金额10将被记入帐户2。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="015f" class="mu kl jj mq b gy mv mw l mx my">akshar=# update accounts set amount=amount+10 where acct_id=2; UPDATE 1</span></pre><p id="311c" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">尝试在进程2 shell上发出一个<code class="fe mz na nb mq b">commit</code>。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="adf2" class="mu kl jj mq b gy mv mw l mx my">akshar=# commit;<br/>ROLLBACK</span></pre><p id="2483" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">由于检测到死锁，这意味着命令不会成功，因此提交会导致数据库进入不一致和不可靠的状态。DBMS很聪明地意识到这一点，因此即使发出一个<code class="fe mz na nb mq b">commit</code>也会导致一个<code class="fe mz na nb mq b">rollback</code>。</p><p id="ed7e" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">但是既然进程1的命令执行成功，那么<code class="fe mz na nb mq b">commit</code>就可以在进程1上发出shell。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="365e" class="mu kl jj mq b gy mv mw l mx my">akshar=# commit;<br/>COMMIT</span></pre><p id="a641" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">您应该能够验证账户1的借方金额为10，账户2的贷方金额为10。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="6d3d" class="mu kl jj mq b gy mv mw l mx my">akshar=# select * from accounts;<br/>acct_id | amount<br/>---------+--------<br/>1 | 480<br/>2 | 320<br/>(2 rows)</span></pre><h1 id="596c" class="kk kl jj bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">处理死锁</h1><p id="ff8d" class="pw-post-body-paragraph li lj jj lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">并发是一个现实，是不可避免的。很有可能多个进程同时尝试更新同一组行，却被彼此阻塞。在这种情况下，僵局是不可避免的。</p><p id="56e4" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">在这种情况下，应该在应用程序级别处理死锁。必须有异常处理代码来捕捉死锁错误并重试失败的事务。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="8665" class="pw-post-body-paragraph li lj jj lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">请继续关注我们下一篇关于在Django web应用程序中处理死锁的文章。</p></div></div>    
</body>
</html>