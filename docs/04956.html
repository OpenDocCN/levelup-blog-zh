<html>
<head>
<title>Breadth-First Search Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">广度优先搜索算法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/breadth-first-search-algorithms-e0910d35c434?source=collection_archive---------9-----------------------#2020-07-26">https://levelup.gitconnected.com/breadth-first-search-algorithms-e0910d35c434?source=collection_archive---------9-----------------------#2020-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e822" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">遍历节点树</h2></div><p id="a378" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最常见和最有用的算法之一是广度优先搜索算法。该算法涉及遍历或搜索树或图数据结构中的节点或数据点。这些算法经常出现在技术面试中，是理解更高级问题的垫脚石。广度优先搜索的优秀之处在于它适用于各种不涉及树或图的问题，例如对数组排序、查找数字组合的最大和以及查找图中两个节点之间的最短距离。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi le"><img src="../Images/11720d106e4765750151e989eff04032.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*gSS7yRdNFeSBXVPuOoXK3A.gif"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">搜索</figcaption></figure><h2 id="831f" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated">广度优先搜索</h2><p id="2e44" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">面包优先搜索是一种控制从树或图中的一个节点移动到另一个节点的算法。搜索的顺序是根据树的深度。换句话说，搜索算法从顶层根节点开始，然后移动到第二层，搜索那里的每个节点。然后，该算法进行到下一个较低的级别，并重复直到它到达最深的节点。下图是主要思路。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/6daf399d1c506f284d18722a7ddd1be4.png" data-original-src="https://miro.medium.com/v2/resize:fit:374/1*on5z7UjsKdnc7Ujn4aqRHQ.gif"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">该算法通过深度进行搜索</figcaption></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="dc36" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上面看，我们可以看到算法从根节点开始。根节点是图中链接到所有其他节点的第一个节点。在这种情况下，标记为“a”的节点是根节点。从这里开始，我们从一个节点移动到另一个节点，探索树的每一层。因此，顺序是:<br/>a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f-&gt;g-&gt;h</p><p id="53f5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们如何在实践中做到这一点？首先，让我们用伪代码来布局算法，为我们提供一个基本的轮廓。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><ol class=""><li id="1ec0" class="mw mx it kk b kl km ko kp kr my kv mz kz na ld nb nc nd ne bi translated">创建队列(FIFO)</li><li id="6d62" class="mw mx it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">将第一个节点或根排入队列</li><li id="6494" class="mw mx it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">当队列不为空时出列</li><li id="7c20" class="mw mx it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">当每个节点出队时，它被标记为已访问</li><li id="0da5" class="mw mx it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">对于标记为已访问的每个节点，将它的所有子节点</li><li id="56de" class="mw mx it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">继续，直到树达到它的目标，但是，定义。</li></ol><p id="e2ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们通过看一个具体的例子来更详细地讨论这在解决一个问题时意味着什么。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="9984" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">问题:给定一个包含整数的节点树。求节点中偶数的总数。</p><p id="7901" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输入:整数树的根节点</p><p id="9a25" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出:树的所有节点中偶数的数量。</p><p id="7623" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们以下面的树作为输入:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nk"><img src="../Images/205adc33cf054de296ec60d2fd1bee7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xg0fIRtNNtjx0MsvQ9TLsg.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">整数存储在节点中的树</figcaption></figure><p id="5a3f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看上面的树，我们可以看到这棵树有四层，总共15个节点。这个问题要求我们按顺序访问每个节点，通过层次或层次顺序遍历向树的更深处移动。当算法遍历树时，它应该计算访问的偶数的数量，并在最后返回该数量。</p><h2 id="9fbf" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated">长队</h2><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi np"><img src="../Images/c5ba06de43b9425bc42e83b9ea8684ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*lT2w7XDxkRblvgHV0OvE2w.gif"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">队列(先进先出)</figcaption></figure><p id="a23a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了进一步理解这个过程是如何工作的，我们必须在我们的系统中引入另一个元素:队列。队列是一组有序的数据，通过在其末端添加一个元素并从另一端移除一个元素来改变。简单来说，队列是FIFO(先进先出)结构。添加到队列一端的项目是“入队”；而从另一端移除的元素是“出列”</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/05c7d5c7ce34b24462ed410fffc85fbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*sDUsYpYs4VwIdE-N7bhBSg.png"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">队列数据结构</figcaption></figure><p id="35b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们将这些要素结合起来，一步一步地讨论如何解决这个问题。下图显示了节点树以及在BFS算法中节点需要被访问的顺序。在上面的算法中被访问可能意味着许多不同的事情，这取决于具体的问题。我们可以寻找特定的数据点，或者从许多不同的节点收集数据。在跟踪路径的情况下，我们可能需要将一个节点标记为已访问，以确保同一个节点不会被覆盖两次。无论哪种方式，目标都是按顺序访问所有节点，并提取必要的信息来解决问题。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nr"><img src="../Images/a0371fb072824984219ccd1ff1f9f756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0W5lgJDURzBwcVhqLb2hdA.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">整数节点树以及BFS算法访问它们的顺序。</figcaption></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="8d34" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解决问题的基本伪代码如下。</p><ol class=""><li id="142f" class="mw mx it kk b kl km ko kp kr my kv mz kz na ld nb nc nd ne bi translated">过程find evens<br/>a . number of evens = 0<br/>b .创建空队列<br/> C .入队根节点<br/> D .循环-当队列不为空时<br/> i .出队节点<br/> ii .如果节点中的数字是偶数，计数器<br/> iii加1。将节点<br/>的所有子节点排队，返回事件总数</li></ol><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi ns"><img src="../Images/319dea48a8473131f719e5efca01102d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OZup2YWzwXMjXB05RPmmAA.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">该图显示了算法遍历树时队列中节点的顺序</figcaption></figure><p id="39c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为该算法在逐层遍历树时检查每个节点。如果数字是偶数，算法将递增计数器变量。当循环最终因队列为空而退出时，该函数返回' numberofevens '变量，即…9。</p><h2 id="7def" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated">时间和空间复杂性</h2><p id="be21" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">广度优先搜索算法的时间和空间复杂度比你想象的更简单。由于空间的复杂性，我们需要的内存包括树本身和队列。因此，所需的总内存与节点数量成正比。因此，空间复杂度为O(n)。</p><p id="993c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">时间复杂度取决于访问了多少个节点以及每个节点被访问了多少次。对于这种类型的问题，最好的情况是算法在第一个节点O(1)中找到所需的元素。在最坏的情况下，算法访问每个节点:O(n)；平均案例场景:O(n/2)。综上，时间和空间复杂度是线性的，与树中的节点数成正比:O(n)。</p><h2 id="1c54" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated">结论</h2><p id="b870" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">本文是对广度优先搜索算法的简短概述和介绍。这篇文章绝不是这种算法的许多应用和变体的详尽细节。对于进一步的研究，我推荐以下资源:</p><p id="064d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae nt" href="https://www.khanacademy.org/computing/computer-science/algorithms/breadth-first-search/a/the-breadth-first-search-algorithm" rel="noopener ugc nofollow" target="_blank">可汗学院</a></p><p id="7393" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae nt" href="https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/" rel="noopener ugc nofollow" target="_blank"> GeeksforGeeks </a></p><p id="0acd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae nt" href="https://www.tutorialspoint.com/data_structures_algorithms/breadth_first_traversal.htm" rel="noopener ugc nofollow" target="_blank">教程要点</a></p><p id="1e4f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae nt" href="https://www.cs.usfca.edu/~galles/visualization/BFS.html" rel="noopener ugc nofollow" target="_blank"> USFCA </a></p></div></div>    
</body>
</html>