<html>
<head>
<title>Coding Challenge: First Missing Positive 🔥🔥🔥</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码挑战:第一个缺失的正数🔥🔥🔥</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/coding-challenge-first-missing-positive-6316efd84558?source=collection_archive---------12-----------------------#2021-12-27">https://levelup.gitconnected.com/coding-challenge-first-missing-positive-6316efd84558?source=collection_archive---------12-----------------------#2021-12-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/54e4b67565841fbb76ce38bca8e13334.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sXw0Dcz5tzWcuH7v1jgtnA.png"/></div></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="4a4f" class="ki kj it bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">问题:</h1><blockquote class="lg lh li"><p id="eda9" class="lj lk ll lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">给定一个未排序的整数数组<code class="fe mi mj mk ml b">nums</code>，返回最小的缺失正整数。您必须实现一个在<code class="fe mi mj mk ml b">O(n)</code>时间内运行并使用恒定额外空间的算法。</p></blockquote><p id="a957" class="pw-post-body-paragraph lj lk it lm b ln lo lp lq lr ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mh im bi translated"><strong class="lm iu">例一:</strong></p><pre class="mp mq mr ms gt mt ml mu mv aw mw bi"><span id="ba5e" class="mx kj it ml b gy my mz l na nb"><strong class="ml iu">Input:</strong> nums = [1, 2, 0]<br/><strong class="ml iu">Output:</strong> 3</span></pre><p id="812f" class="pw-post-body-paragraph lj lk it lm b ln lo lp lq lr ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mh im bi translated"><strong class="lm iu">例二:</strong></p><pre class="mp mq mr ms gt mt ml mu mv aw mw bi"><span id="8b56" class="mx kj it ml b gy my mz l na nb"><strong class="ml iu">Input:</strong> nums = [3, 4, -1, 1]<br/><strong class="ml iu">Output:</strong> 2</span></pre><p id="2307" class="pw-post-body-paragraph lj lk it lm b ln lo lp lq lr ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mh im bi translated"><strong class="lm iu">例3: </strong></p><pre class="mp mq mr ms gt mt ml mu mv aw mw bi"><span id="4d6f" class="mx kj it ml b gy my mz l na nb"><strong class="ml iu">Input:</strong> nums = [7, 8, 9, 11, 12]<br/><strong class="ml iu">Output:</strong> 1</span></pre><p id="6c2c" class="pw-post-body-paragraph lj lk it lm b ln lo lp lq lr ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mh im bi translated"><strong class="lm iu">例4: </strong></p><pre class="mp mq mr ms gt mt ml mu mv aw mw bi"><span id="51f0" class="mx kj it ml b gy my mz l na nb"><strong class="ml iu">Input:</strong> nums = [1, 2, 4, 6, 3, 7, 8]<br/><strong class="ml iu">Output:</strong> 5</span></pre><p id="4940" class="pw-post-body-paragraph lj lk it lm b ln lo lp lq lr ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mh im bi translated"><strong class="lm iu">约束:</strong></p><ul class=""><li id="10f3" class="nc nd it lm b ln lo lr ls mm ne mn nf mo ng mh nh ni nj nk bi translated">1 ≤ nums .长度≤ 5 * 10⁵</li><li id="a3ae" class="nc nd it lm b ln nl lr nm mm nn mn no mo np mh nh ni nj nk bi translated">-2 ≤ nums[I] ≤ 2 -1</li></ul><h1 id="ecee" class="ki kj it bd kk kl nq kn ko kp nr kr ks kt ns kv kw kx nt kz la lb nu ld le lf bi translated">说明</h1><ul class=""><li id="3c2f" class="nc nd it lm b ln nv lr nw mm nx mn ny mo nz mh nh ni nj nk bi translated">我们希望在正整数数组中找到最小的缺失正整数，或者我们可以理解为，在一个包含<strong class="lm iu"> n个元素</strong>的数组中，找到不在数组中的<strong class="lm iu">【0】</strong>和<strong class="lm iu">【n-1】</strong>之间的最小元素。如果数组包含所有这些，则解是数组大小<strong class="lm iu"> n </strong>。</li><li id="a2a2" class="nc nd it lm b ln nl lr nm mm nn mn no mo np mh nh ni nj nk bi translated">我们有一个来自<strong class="lm iu"> [1】的<strong class="lm iu"> n </strong>的数组..100，000] </strong>元素，这些是我们的参数。数组的元素是[-2 …2 -1]中的一个整数</li></ul><h1 id="98f1" class="ki kj it bd kk kl nq kn ko kp nr kr ks kt ns kv kw kx nt kz la lb nu ld le lf bi translated">方法1 | O (n)</h1><p id="5c55" class="pw-post-body-paragraph lj lk it lm b ln nv lp lq lr nw lt lu mm oa lx ly mn ob mb mc mo oc mf mg mh im bi translated">解决这个问题的传统方法是在给定的数组中从1开始搜索所有正整数。我们可能在给定的数组中得到<strong class="lm iu"> (n+1) </strong>个数字，所以这在最坏的情况下需要O(n)。</p><h1 id="9b20" class="ki kj it bd kk kl nq kn ko kp nr kr ks kt ns kv kw kx nt kz la lb nu ld le lf bi translated">方法2:使用排序数组| O (N log N)</h1><ul class=""><li id="1d71" class="nc nd it lm b ln nv lr nw mm nx mn ny mo nz mh nh ni nj nk bi translated">我们可以先用<strong class="lm iu">排序</strong>以较小的时间复杂度求解。如你所知，当排序时会花费O(N log N)的时间。一旦对数组进行了排序，我们需要做的就是对数组进行线性扫描，所以这需要O (N log N + n)的时间，也就是O (N log N)</li><li id="8798" class="nc nd it lm b ln nl lr nm mm nn mn no mo np mh nh ni nj nk bi translated">这意味着我们有线性复杂度，即O (N log N)，N是输入的长度。</li></ul><figure class="mp mq mr ms gt ju"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/faecb69cbd1df3464a7bd15668a5b1fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0EB1VBv8AErf_MXUGKpmKQ.png"/></div></div></figure><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/507b962b6d048bd02deae4c9893ce4aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lfIHmJG3r9RrQegp_dCrjA.png"/></div></div></figure><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/d05c0ec0dc0cd8027561b06444fcf0af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0UPLvMfsh3pgmQZylRh0yg.png"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">内存(KB)</figcaption></figure><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/f4c43df9f9a36567ef92b85cae70be9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ylq4DBq2oHcsNf1yY55vAQ.png"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">运行时间(毫秒)</figcaption></figure><h1 id="2d86" class="ki kj it bd kk kl nq kn ko kp nr kr ks kt ns kv kw kx nt kz la lb nu ld le lf bi translated">方法3:使用标志| O (n)</h1><ul class=""><li id="6a2f" class="nc nd it lm b ln nv lr nw mm nx mn ny mo nz mh nh ni nj nk bi translated">在这个问题中，我们创建了一个boolean <strong class="lm iu"> false </strong>值的列表，其大小为给定数组的max()值。每当我们在原始数组中遇到任何正值时，我们将<strong class="lm iu"> false </strong>值更改为<strong class="lm iu"> true，</strong>在我们完成后，我们简单地遍历修改后的列表，我们遇到的第一个0，就是(index + 1)应该是我们的答案，因为索引从0开始</li><li id="e761" class="nc nd it lm b ln nl lr nm mm nn mn no mo np mh nh ni nj nk bi translated"><em class="ll">对于输入数组中匹配布尔数组索引的每个整数，我们将对应的值设置为</em> <strong class="lm iu"> <em class="ll">真</em> </strong> <em class="ll">。</em></li><li id="2a17" class="nc nd it lm b ln nl lr nm mm nn mn no mo np mh nh ni nj nk bi translated"><em class="ll">我们的标志数组为输入数组中出现的每个整数保存</em> <strong class="lm iu"> <em class="ll">真</em> </strong> <em class="ll">，否则保存</em> <strong class="lm iu"> <em class="ll">假</em> </strong> <em class="ll">。我们可以遍历flags数组并返回第一个包含false的索引。如果没有，我们返回数组长度。</em></li></ul><p id="8290" class="pw-post-body-paragraph lj lk it lm b ln lo lp lq lr ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mh im bi translated"><strong class="lm iu"> <em class="ll">更清楚:</em> </strong></p><ul class=""><li id="e084" class="nc nd it lm b ln lo lr ls mm ne mn nf mo ng mh nh ni nj nk bi translated">数字<strong class="lm iu"> 1，2，…，n + 1 </strong>中至少有一个不在数组中。让我们创建一个大小为<strong class="lm iu"> (n+ 1) </strong>的布尔数组<strong class="lm iu"> B </strong>来存储这些数字是否存在。</li><li id="68c1" class="nc nd it lm b ln nl lr nm mm nn mn no mo np mh nh ni nj nk bi translated">我们找到从1到n + 1的数字，我们在<strong class="lm iu"> B中标记相应的条目。</strong>如果我们看到的数字不符合这些界限，就跳过它，继续下一个。</li><li id="ddae" class="nc nd it lm b ln nl lr nm mm nn mn no mo np mh nh ni nj nk bi translated">在处理完输入之后，我们可以在布尔数组<strong class="lm iu"> B </strong>中找到第一个未标记的条目</li></ul><figure class="mp mq mr ms gt ju"><div class="bz fp l di"><div class="od oe l"/></div></figure><ul class=""><li id="66a3" class="nc nd it lm b ln lo lr ls mm ne mn nf mo ng mh nh ni nj nk bi translated">对于<strong class="lm iu">时间复杂度，</strong>我们不对输入进行排序，我们只遍历两个大小相同的数组，这意味着我们的时间复杂度应该是<strong class="lm iu"> O(2n) </strong>或者简化为<strong class="lm iu"> O(n) </strong></li><li id="d822" class="nc nd it lm b ln nl lr nm mm nn mn no mo np mh nh ni nj nk bi translated">对于<strong class="lm iu">空间复杂度</strong>，我们创建与输入大小相同的第二个数组，这意味着我们有<strong class="lm iu"> O(n) </strong>空间复杂度。</li></ul><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi on"><img src="../Images/28f4235401ffcca9080f6606a802ecd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8P2xiIVMS39FrFjiZk6xCw.png"/></div></div></figure><h1 id="d667" class="ki kj it bd kk kl nq kn ko kp nr kr ks kt ns kv kw kx nt kz la lb nu ld le lf bi translated">参考</h1><ul class=""><li id="bfec" class="nc nd it lm b ln nv lr nw mm nx mn ny mo nz mh nh ni nj nk bi translated"><a class="ae oo" href="https://leetcode.com/problems/first-missing-positive/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/first-missing-positive/</a></li><li id="f138" class="nc nd it lm b ln nl lr nm mm nn mn no mo np mh nh ni nj nk bi translated"><a class="ae oo" href="https://github.com/nphau/leetcode.solution" rel="noopener ugc nofollow" target="_blank">https://github.com/nphau/leetcode.solution</a></li></ul></div></div>    
</body>
</html>