<html>
<head>
<title>Learning C++: Lambdas and the STL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习C++: Lambdas和STL</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-lambdas-and-the-stl-1a48e18033a?source=collection_archive---------9-----------------------#2020-04-02">https://levelup.gitconnected.com/learning-c-lambdas-and-the-stl-1a48e18033a?source=collection_archive---------9-----------------------#2020-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/37891e0e7b8acadcfaa4a1c1d21d379e.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*4PM8lOTMOwWCxtUY1_1rcQ.png"/></div></figure><p id="70aa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">lambda(也称为匿名函数)是一个没有名字的函数。lambda可以在任何需要语句或表达式的地方调用。你可以在任何需要命名函数的地方使用lambda。</p><h1 id="8ea9" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">第一个简单的例子</h1><p id="be94" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">让我们通过写经典的“你好，世界！”来开始我们对lambda的探索使用lambda的示例。我们使用lambda的第一种方法是将它赋给一个变量:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="f1b7" class="mh kw it md b gy mi mj l mk ml">auto hw = []() { cout &lt;&lt; "Hello, world!"; };<br/>hw(); // Hello, world! is displayed</span></pre><p id="f807" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">看第一行代码，lambda在赋值操作符的右边。我们将马上解释所有的语法。但是现在，注意我们使用了<code class="fe mm mn mo md b">auto</code>关键字，所以编译器将推断出lambda的类型。如果我们试图为变量提供我们自己的类型，比如void，编译器会产生一个错误。</p><p id="bb44" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">通过将变量名与函数调用操作符<code class="fe mm mn mo md b">()</code>结合起来调用函数。这里，对<code class="fe mm mn mo md b">hw</code>的调用类似于对void函数的调用，执行lambda块中定义的语句。</p><p id="a193" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">使用这个函数的第二种方法是定义它并在同一个语句中调用它。我们是这样做的:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="393c" class="mh kw it md b gy mi mj l mk ml">[]() { std::cout &lt;&lt; "Hello, world!"; }();<br/>// displays Hello, world!</span></pre><p id="692e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">lambda与函数调用操作符相结合，以立即执行lambda的主体。如上所述，该语句的行为就像调用void函数一样。</p><h1 id="2520" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">Lambda语法解释</h1><p id="e349" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">编写lambda时遇到的第一个语法元素是一对方括号(<code class="fe mm mn mo md b">[]</code>)，称为<em class="mp"> lambda引入符</em>。该元素用于捕获外部值，以便在lambda中使用。让我们看一个简单的例子，扩展我们的“你好，世界！”λ:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="a74a" class="mh kw it md b gy mi mj l mk ml">string name = "Dennis";<br/>auto hw = [name] () { std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "!"; };<br/>hw(); // displays Hello, Dennis!</span></pre><p id="2412" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们将字符串变量名放在lambda导入器中，这样我们就可以在lambda中使用它的值。变量通过值传递给lambda，就像值参数传递给常规函数一样。</p><p id="bc5b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在lambda引入程序之后，您可以为lambda指定参数。现在，我们将只演示如何向lambda传递一个简单的值:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="6ae3" class="mh kw it md b gy mi mj l mk ml">auto hw = [] (const std::string &amp;name ) { std::cout &lt;&lt; "Hello, "<br/>                                          &lt;&lt; name &lt;&lt; "!"; };<br/>hw("Dennis"); // displays Hello, Dennis!</span></pre><p id="624d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这个例子中，我们为函数指定一个常量字符串引用参数，然后用一个字符串文字调用函数。稍后，我们将演示在这个地方可以使用的其他参数。</p><h1 id="38f4" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">Lambdas可以返回值</h1><p id="2b39" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">当然，lambdas不一定要表现为void函数。lambda也可以返回值。例如:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="73c5" class="mh kw it md b gy mi mj l mk ml">auto r = [] (int num) { return num * num; };<br/>std::cout &lt;&lt; r(2) &lt;&lt; std::endl; // displays 4</span></pre><p id="f9ed" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">由于在lambda中没有指定返回类型，编译器将从返回值中推导出类型:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="51cb" class="mh kw it md b gy mi mj l mk ml">auto d = [] (double val) { return val * 1.1; };<br/>auto dr = d(3.14159);<br/>std::cout &lt;&lt; typeid(dr).name(); // displays d for double</span></pre><p id="4d96" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这个例子中，我们使用<code class="fe mm mn mo md b">typeinfo </code>头来显示变量<code class="fe mm mn mo md b">dr</code>的数据类型。</p><p id="4be2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">还可以使用以下语法指定lambda的返回类型:</p><p id="bf0c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="mp"> [ ] () - &gt;数据类型{ lambda语句体；};</em></p><p id="1f74" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">以下是使用此语法的示例:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="c792" class="mh kw it md b gy mi mj l mk ml">auto d = [](int i) -&gt; double { return i * i; };<br/>std::cout &lt;&lt; typeid(d(2.2)).name(); // displays d for double</span></pre><h1 id="c249" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">通过引用或值传递外部范围</h1><p id="4aef" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">在lambda引入程序内部，您可以指定如何将程序的外部范围传递给lambda。通过值来指定，你写<code class="fe mm mn mo md b">[=] </code>，通过引用来指定，你写<code class="fe mm mn mo md b">[&amp;]</code>。例如，下面的程序使用lambda来执行变量交换:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="cbd7" class="mh kw it md b gy mi mj l mk ml">int x = 1, y = 2;<br/>std::cout &lt;&lt; "Before the lambda call: " &lt;&lt; std::endl;<br/>std::cout &lt;&lt; "x: " &lt;&lt; x &lt;&lt; ", y: " &lt;&lt; y &lt;&lt; std::endl;<br/>[&amp;] () { int temp = x; x = y; y = temp; }();<br/>std:: cout &lt;&lt; std::endl &lt;&lt; "After the lambda call: " &lt;&lt; std::endl;<br/>std::cout &lt;&lt; "x: " &lt;&lt; x &lt;&lt; ", y: " &lt;&lt; y &lt;&lt; std::endl;</span></pre><p id="013c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个程序的输出是:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="9021" class="mh kw it md b gy mi mj l mk ml">Before the lambda call:<br/>x: 1, y: 2</span><span id="6d5e" class="mh kw it md b gy mq mj l mk ml">After the lambda call:<br/>x: 2, y: 1</span></pre><p id="f9fe" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这段代码之所以有效，是因为我们告诉编译器通过引用传递外部作用域中引用的变量，这给了我们对<code class="fe mm mn mo md b">x</code>和<code class="fe mm mn mo md b">y</code>的写访问权限，这样我们就可以更改它们的值。然而，如果我们试图使用<code class="fe mm mn mo md b">[=] </code>作为lambda引入者来运行这段代码，或者只是让它为空，编译器会返回一个错误，因为它检测到我们试图修改我们只有读取权限的变量的值。</p><p id="04d3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您可以通过在参数列表后添加关键字mutable来修改lambda中的这种行为。这使您可以对lambda内部的对象进行写访问，但不能对lambda外部的对象进行写访问。我们可以重写上面的<code class="fe mm mn mo md b">swap</code> lambda程序，允许变量值在lambda内部交换，如下所示:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="c1a1" class="mh kw it md b gy mi mj l mk ml">int x = 1, y = 2;<br/>std::cout &lt;&lt; "Before the lambda call: " &lt;&lt; std::endl;<br/>std::cout &lt;&lt; "x: " &lt;&lt; x &lt;&lt; ", y: " &lt;&lt; y &lt;&lt; std::endl &lt;&lt; std::endl;<br/>[x,y] () mutable { int temp = x; x = y; y = temp; std::cout<br/>  &lt;&lt; "Inside the lambda: " &lt;&lt; "x: " &lt;&lt; x &lt;&lt; " ,y: " &lt;&lt; y<br/>  &lt;&lt; std::endl;}();<br/>std:: cout &lt;&lt; std::endl &lt;&lt; "After the lambda call: " &lt;&lt; std::endl;<br/>std::cout &lt;&lt; "x: " &lt;&lt; x &lt;&lt; ", y: " &lt;&lt; y &lt;&lt; std::endl;</span></pre><p id="839a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这段代码的输出是:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="d714" class="mh kw it md b gy mi mj l mk ml">Before the lambda call:<br/>x: 1, y: 2</span><span id="9ef5" class="mh kw it md b gy mq mj l mk ml">Inside the lambda: <br/>x: 2 , y: 1</span><span id="059a" class="mh kw it md b gy mq mj l mk ml">After the lambda call:<br/>x: 1, y: 2</span></pre><p id="0006" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意，我们必须将<code class="fe mm mn mo md b">x</code>和<code class="fe mm mn mo md b">y</code>放在lambda导入器中来捕获变量的值，当我们告诉编译器通过引用来捕获外部范围时，我们不必这样做。</p><h1 id="5740" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">使用Lambdas —一个实际例子</h1><p id="dd94" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">如上例所示，Lambdas通常不单独使用。相反，当与STL中的算法结合使用时，lambdas被证明是最有用的。我将用两个使用STL算法的例子来演示这一点。</p><p id="51c8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">第一个例子演示了如何使用带有<code class="fe mm mn mo md b">sor</code> t函数的lambda。这个函数将把一个容器中的内容(在这个例子中是一个向量)排序。默认顺序是升序。以下程序演示了<code class="fe mm mn mo md b">sort </code>功能的工作原理:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="7ee7" class="mh kw it md b gy mi mj l mk ml">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;algorithm&gt;</span><span id="fc32" class="mh kw it md b gy mq mj l mk ml">template &lt;typename T&gt;<br/>void print_vector(std::vector&lt;T&gt; vec) {<br/>  for (T element : vec) {<br/>    std::cout &lt;&lt; element &lt;&lt; " ";<br/>  }<br/>}</span><span id="1a23" class="mh kw it md b gy mq mj l mk ml">int main()<br/>{<br/>  std::vector&lt;int&gt; numbers {3,1,2,5,4};<br/>  print_vector(numbers);<br/>  std::cout &lt;&lt; std::endl;<br/>  sort(numbers.begin(), numbers.end());<br/>  std::cout &lt;&lt; std::endl;<br/>  print_vector(numbers);<br/>  return 0;<br/>}</span></pre><p id="5589" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个程序的输出是:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="cb88" class="mh kw it md b gy mi mj l mk ml">3 1 2 5 4</span><span id="141f" class="mh kw it md b gy mq mj l mk ml">1 2 3 4 5</span></pre><p id="2e1d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但是如果我们想对向量进行降序排序呢？原来,<code class="fe mm mn mo md b">sort</code>函数带有一个可选的第三个参数，它可以是一个函数对象，或者对于我们的目的来说，是一个lambda。我们可以用它来改变排序的顺序，这样排序就是降序而不是升序。</p><p id="8d03" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">下面是对带有lambda的<code class="fe mm mn mo md b">sort</code>函数的调用，用于按降序排序:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="69e2" class="mh kw it md b gy mi mj l mk ml">sort(numbers.begin(), numbers.end(),<br/>  [](int a, int b){ return a &gt; b; });</span></pre><p id="79b2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">要将排序顺序从升序改为降序，我们只需要测试大于条件而不是小于条件，这也是<code class="fe mm mn mo md b">sort</code>函数的默认行为。</p><p id="bd6e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果我们用上面的新函数调用替换原来的<code class="fe mm mn mo md b">sort</code>函数调用，我们会得到以下输出:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="064a" class="mh kw it md b gy mi mj l mk ml">3 1 2 5 4</span><span id="403a" class="mh kw it md b gy mq mj l mk ml">5 4 3 2 1</span></pre><p id="033e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">另一个经常使用的STL函数是<code class="fe mm mn mo md b">for_each</code>。这个函数获取容器中的一系列数据，并对该范围内的每个元素执行一些任务。让我们使用这个函数来显示上面例子中的矢量数据。</p><p id="80cf" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">首先，我们将开发函数调用。我们需要一个lambda来获取范围内的每个元素，并将其写出到标准输出中。这是lambda的样子:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="a9c7" class="mh kw it md b gy mi mj l mk ml">[] (auto &amp;element) { std::cout &lt;&lt; element &lt;&lt; " "; };</span></pre><p id="af43" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我通过使用<code class="fe mm mn mo md b">auto</code>声明来自外部的元素的类型，并通过传递元素作为引用，使这个lambda更加通用，这样我们就不会意外地复制大量数据。</p><p id="7f6f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">下面是lambda在函数调用中的样子:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="6820" class="mh kw it md b gy mi mj l mk ml">for_each(numbers.begin(), numbers.end(),<br/>  [](auto &amp;element) { std::cout &lt;&lt; element &lt;&lt; " ";});</span></pre><p id="bc13" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">下面是使用函数调用的代码片段:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="aadb" class="mh kw it md b gy mi mj l mk ml">std::vector&lt;int&gt; numbers {3,1,2,5,4};<br/>sort(numbers.begin(), numbers.end(),]<br/>  [](int a, int b){ return a &gt; b; });<br/>for_each(numbers.begin(), numbers.end(),<br/>  [](auto &amp;element) { std::cout &lt;&lt; element &lt;&lt; " ";});</span></pre><p id="ce65" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">输出是:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="4105" class="mh kw it md b gy mi mj l mk ml">5 4 3 2 1</span></pre><h1 id="3045" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">兰姆达斯很有用</h1><p id="70cf" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">当您需要在函数调用中使用局部函数时，Lambdas是很好的工具。这些通常是“一次性的”,因此如果您只打算进行一次函数调用，那么创建一个单独的函数是没有意义的。</p><p id="9076" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">感谢您阅读这篇文章，请给我发电子邮件，提出您的意见和建议。</p></div></div>    
</body>
</html>