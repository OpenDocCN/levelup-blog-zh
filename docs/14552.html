<html>
<head>
<title>Media Queries in JS/TS Done Right</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS/TS中的媒体查询完成正确</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/media-queries-in-js-ts-done-right-3bd598dca9df?source=collection_archive---------18-----------------------#2022-12-06">https://levelup.gitconnected.com/media-queries-in-js-ts-done-right-3bd598dca9df?source=collection_archive---------18-----------------------#2022-12-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/abd413b449b5f33531336e6951c6f984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KwjULomPLiCDJT1fDy9epg.png"/></div></div></figure><p id="0dd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近，我遇到了一个情况，涉及到监听一个应用程序的屏幕宽度。有很多方法可以实现这一点，但我想要一些简单的、可重用的、不会对性能产生太大影响的通用方法。</p><p id="4f58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我认为在<code class="fe kw kx ky kz b">window</code>上监听<code class="fe kw kx ky kz b">resize</code>事件并检查<code class="fe kw kx ky kz b">innerWidth</code>太慢了，尤其是因为所有与布局相关的事情都迫使<a class="ae la" href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a" rel="noopener ugc nofollow" target="_blank">回流</a>。</p><p id="f8d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在搜索解决方案时，我很快发现了<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia" rel="noopener ugc nofollow" target="_blank">window . match media()</a>API，这似乎是最好的解决方案(所有主流浏览器都支持它)。</p><p id="cefd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">剩下唯一要做的就是实现一个简单的可重用的通用解决方案，在底层使用它。这里有一个帮助我起步的<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Testing_media_queries" rel="noopener ugc nofollow" target="_blank"> MDN链接</a>。</p><p id="7328" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想要的是能够<code class="fe kw kx ky kz b">subscribe</code>响应来自应用程序不同组件的不同媒体查询，而不需要创建新的监听器。</p><p id="6eb5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想到的解决方案是创建一个<code class="fe kw kx ky kz b">static class</code>(嗯，一个带有<code class="fe kw kx ky kz b">static</code>方法和变量的<code class="fe kw kx ky kz b">class</code>，它将保存一个查询列表和这些查询的订阅列表(以及一个侦听器引用列表，这样就可以很容易地清理它)。</p><pre class="lb lc ld le gt lf kz lg bn lh li bi"><span id="a2a0" class="lj lk iq kz b be ll lm l ln lo">export interface IQueryList {<br/>    [key: string]: {<br/>        query: MediaQueryList;<br/>        subscribers: Array&lt;(matchesQuery: boolean) =&gt; void&gt;;<br/>    };<br/>}<br/><br/>interface IEventListener {<br/>    [key: string]: (event: MediaQueryListEvent) =&gt; void;<br/>}<br/><br/>export class MediaQueryListener {<br/>    private static _subscribers: IQueryList = {};<br/>    private static _eventListenersRefs: IEventListener = {};<br/><br/>    static subscribe() {<br/>        //...<br/>    }<br/>    static unsubscribe() {<br/>        //...<br/>    }<br/>}</span></pre><p id="fe9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个类将公开两个公共方法:<code class="fe kw kx ky kz b">subscribe</code>和<code class="fe kw kx ky kz b">unsubscribe</code>。</p><p id="7369" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">subscribe</code>方法接受一个回调函数，该函数接收一个表示查询是否匹配的<code class="fe kw kx ky kz b">boolean</code>参数，以及一个字符串格式的实际查询(例如:<code class="fe kw kx ky kz b">'(max-width: 768px)'</code>)。<br/>然后，它检查是否已经从某个其他地方对此查询进行了订阅:</p><ul class=""><li id="19c1" class="lp lq iq ka b kb kc kf kg kj lr kn ls kr lt kv lu lv lw lx bi translated">如果是，它只将回调添加到该查询的订阅者列表中。</li><li id="ca35" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">如果不是，它将查询添加到列表中，唯一的订阅者是传递的回调，然后它开始监听新创建的查询的更改。</li></ul><p id="ed15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论采用哪种方式，它都会使用当前的查询匹配立即调用回调。</p><pre class="lb lc ld le gt lf kz lg bn lh li bi"><span id="20ce" class="lj lk iq kz b be ll lm l ln lo">static subscribe = (cb: (matchesQuery: boolean) =&gt; void, query: string) =&gt; {<br/>    if (!this._subscribers[query]) {<br/>        this._subscribers[query] = {<br/>            query: window.matchMedia(query),<br/>            subscribers: [ cb ],<br/>        };<br/><br/>        // keep the refs so we can remove the listeners in unsubscribe<br/>        this._eventListenersRefs[query] = event =&gt; {<br/>            this._subscribers[query]<br/>                .subscribers<br/>                .forEach(subscriber =&gt; subscriber(event.matches));<br/>        };<br/><br/>        // create the listener only on first subscription for the query<br/>        this._subscribers[query]<br/>            .query<br/>            .addEventListener('change', this._eventListenersRefs[query]);<br/>    } else {<br/>        this._subscribers[query].subscribers.push(cb);<br/>    }<br/><br/>    // Call the callback with the current value of the media query<br/>    cb(window.matchMedia(query).matches);<br/>};</span></pre><p id="8777" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">unsubscribe</code>方法接收相同的回调函数和字符串格式的查询，并从该查询的订阅者中移除回调。它还检查是否没有剩余的订阅者，并删除媒体查询侦听器，以便没有剩余的挂起侦听器。</p><pre class="lb lc ld le gt lf kz lg bn lh li bi"><span id="f9b7" class="lj lk iq kz b be ll lm l ln lo">static unsubscribe = (cb: (matchesQuery: boolean) =&gt; void, query: string) =&gt; {<br/>    if (!this._subscribers[query]) {<br/>        return;<br/>    }<br/><br/>    this._subscribers[query].subscribers = this._subscribers[query].subscribers.filter(subscriber =&gt; subscriber !== cb);<br/>    <br/>    if (this._subscribers[query].subscribers.length === 0) {<br/>        this._subscribers[query].query.removeEventListener('change', this._eventListenersRefs[query]);<br/>        <br/>        delete this._subscribers[query];<br/>        delete this._eventListenersRefs[query];<br/>    }<br/>};</span></pre><p id="376d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我所说的，它是一个在<code class="fe kw kx ky kz b">matchMedia</code> API之上的基本包装器。可能有多个包以这样或那样的方式实现了同样的事情，在创建我的解决方案之前，我没有专门研究这些包，因为我喜欢编写一个解决方案的想法。</p><p id="ce5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您阅读文章！</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="b2d1" class="mk lk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">分级编码</h1><p id="71c2" class="pw-post-body-paragraph jy jz iq ka b kb nh kd ke kf ni kh ki kj nj kl km kn nk kp kq kr nl kt ku kv ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="8f50" class="lp lq iq ka b kb kc kf kg kj lr kn ls kr lt kv lu lv lw lx bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="0309" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">📰更多内容请查看<a class="ae la" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码刊物</a></li><li id="d7b3" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">🔔关注我们:<a class="ae la" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae la" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae la" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="8a15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">🚀👉<a class="ae la" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>