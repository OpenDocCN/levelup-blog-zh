<html>
<head>
<title>A comparison of Server Side Rendering in React and Angular applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React和Angular应用程序中服务器端渲染的比较</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-comparison-of-server-side-rendering-in-react-and-angular-applications-fb95285fb716?source=collection_archive---------0-----------------------#2018-09-26">https://levelup.gitconnected.com/a-comparison-of-server-side-rendering-in-react-and-angular-applications-fb95285fb716?source=collection_archive---------0-----------------------#2018-09-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/46b22f4e39db475802e9b6b0a631214c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*mUkVy9Z2jk0NVC9m82i06w.png"/></div></figure><p id="c452" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在本文中，我们将讨论什么是服务器端渲染(SSR ),并讨论如何在React和Angular应用程序中实现服务器端渲染(SSR)。最后，我们还将简单比较一下启用SSR的容易程度和我们需要采取的方法。</p><p id="5ac1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了理解这两个框架中的SSR，我们将创建一个包含一些基本路由的示例应用程序，并进行一个API调用来模拟一个真实的场景。然后，我们将为每个示例应用程序启用SSR，同时讨论实现我们的预期结果所需的任何变通方法。</p><p id="7eb3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">本文不比较框架本身，而是比较实现一个结果所需的更改，在本例中是服务器端呈现。</p></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><h1 id="4237" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">什么是服务器端渲染(SSR)？</h1><p id="72e3" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">随着单页应用程序(spa)的出现，硬编码到模板上的内容数量已经很少，一个网页被分割成许多不同的组件和/或模板。这些组件是使用所有主流框架中都有的定制<code class="fe mc md me mf b">routers</code>来路由和加载的。</p><p id="0e17" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">搜索引擎(也称为网络爬虫)有时会尝试访问我们应用程序中的嵌套路由，但有时并不成功，因为爬虫无法在不下载和执行JavaScript包(它理解并执行我们的路由逻辑)的情况下访问路由。虽然一些爬虫可以下载和执行JavaScript，但是更好的是更好地控制我们所提供的服务。</p><p id="30d1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">另一个用例是当我们希望尽可能完整地呈现页面以适应较慢的互联网速度时(即下载预呈现的<code class="fe mc md me mf b">index.html</code>文件，而不是下载CSS和JS以在客户端呈现它)，或者只是在fold 之上加载更快的<a class="ae mg" href="https://www.optimizely.com/optimization-glossary/above-the-fold/" rel="noopener ugc nofollow" target="_blank">，以在我们的应用程序中获得更好的交互时间。</a></p><p id="ae14" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">服务器端呈现帮助我们将部分极其动态的web应用程序转换成静态的web应用程序，我们在服务器端创建并呈现所请求的<code class="fe mc md me mf b">route</code>的内容。这个静态页面作为一个占位符，而应用程序的其余部分(CSS，JS等。)下载并在后台引导。</p><p id="e91e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，当客户端在后台下载和呈现实际的应用程序时，SSR'ed页面充当我们的应用程序的“闪屏”。因此，有时我们可以看到页面，但无法与之交互，因为页面仍在后台加载。</p><h1 id="3589" class="kz la iq bd lb lc mh le lf lg mi li lj lk mj lm ln lo mk lq lr ls ml lu lv lw bi translated">何时使用SSR？</h1><p id="7f63" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">了解SSR什么时候有价值，什么时候没有价值是有好处的。</p><p id="6905" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果我们同意随着项目的进展进行更改以支持SSR，那么从项目的第一天开始实施SSR是非常容易的(正如我们将在下面的示例中看到的)，但是如果现有的应用程序非常复杂，请在实施之前评估对SSR的需求。以下是我通常使用的一些快速规则:</p><ol class=""><li id="b4a4" class="mm mn iq jw b jx jy kb kc kf mo kj mp kn mq kr mr ms mt mu bi translated">整个应用程序隐藏在身份验证之后吗？如果是的话，为了搜索引擎优化(SEO)而做SSR是没有意义的。然而，为了使应用程序加载更快，一些人仍然选择进行SSR，但我更喜欢依靠服务人员(取决于用例)来缓存和增强页面加载。</li><li id="03bd" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated">内容可以静态化吗？例如，如果我们有一个演示页面，我们希望由网络爬虫索引，内容可以硬编码到模板中吗？可以不使用路由器直接访问这些模板吗？我们能试着预加载这些资源吗？</li><li id="84f6" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated">还有一些缺点需要考虑，例如应用程序的复杂性增加、初始页面大小增加、服务器响应变慢(因为它不再返回在客户端构建的精简HTML页面)。</li></ol><p id="056a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦我们讨论了上面列出的一些(或更多)场景，我们就可以更好地理解我们希望用户如何与我们的应用程序交互，SEO将有多重要，以及我们如何使用SSR来增强整体体验。</p><h1 id="0d70" class="kz la iq bd lb lc mh le lf lg mi li lj lk mj lm ln lo mk lq lr ls ml lu lv lw bi translated">角度应用中的SSR</h1><p id="9f0e" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">在角度应用中，可以使用<a class="ae mg" href="https://github.com/angular/universal" rel="noopener ugc nofollow" target="_blank">角度通用</a>启用服务器端渲染。</p><p id="149b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在开始编写代码之前，让我们快速地看一下常规应用程序结构中需要改变的地方，以及当我们试图在Angular应用程序中使用SSR时需要注意的地方。</p><ol class=""><li id="9199" class="mm mn iq jw b jx jy kb kc kf mo kj mp kn mq kr mr ms mt mu bi translated">我们现在需要一个服务器——我们现在将使用一个服务器(本例中为NodeJS/Express)来启用SSR，而不是使用类似NGINX的东西来服务我们的<code class="fe mc md me mf b">dist</code>文件夹。</li><li id="89fd" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated">我们需要两个主要模块—一个用于客户端，一个用于服务器</li><li id="8f87" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated">我们需要用绝对URL而不是相对URL进行API调用</li><li id="5714" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated">缓存API调用以避免在SSR期间重新加载数据</li><li id="c9b8" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated">这里还有一些其他的问题<a class="ae mg" href="https://github.com/angular/universal/blob/master/docs/gotchas.md#universal-gotchas" rel="noopener ugc nofollow" target="_blank"/>。</li></ol><p id="8f3c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这样一来，我们现在就可以动手了。</p></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><h2 id="0464" class="na la iq bd lb nb nc dn lf nd ne dp lj kf nf ng ln kj nh ni lr kn nj nk lv nl bi translated"><strong class="ak">基本应用程序设置</strong></h2><p id="d18d" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">首先，使用<code class="fe mc md me mf b">@angular/cli</code> <code class="fe mc md me mf b">npm</code>包创建一个角度应用程序。</p><pre class="nm nn no np gt nq mf nr ns aw nt bi"><span id="1f2c" class="na la iq mf b gy nu nv l nw nx">ng new ng-ssr</span><span id="6d80" class="na la iq mf b gy ny nv l nw nx">cd ng-ssr</span></pre><p id="4562" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，创建一些我们将在应用程序中路由到的基本组件:</p><pre class="nm nn no np gt nq mf nr ns aw nt bi"><span id="2907" class="na la iq mf b gy nu nv l nw nx">ng generate component home<br/>ng generate component about<br/>ng generate component settings</span></pre><p id="d7a7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，在<code class="fe mc md me mf b">src/app</code>文件夹中创建一个名为<code class="fe mc md me mf b">app.routing.ts</code>的文件，并设置到达这些组件所需的基本路由，如下所示:</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="8845" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，将新创建的<code class="fe mc md me mf b">AppRoutingModule</code>包含在<code class="fe mc md me mf b">BrowserModule</code>之后的<code class="fe mc md me mf b">imports</code>部分下的<code class="fe mc md me mf b">app.module.ts</code>中找到的主应用模块中。还可以在我们的<code class="fe mc md me mf b">app.component.html</code>中添加链接，根据路线定义导航到这些组件。</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="c7db" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有了中的这些变化，我们的基本应用程序就可以启动了。从项目的根目录运行命令<code class="fe mc md me mf b">npm start</code>并导航到<a class="ae mg" href="http://localhost:4200" rel="noopener ugc nofollow" target="_blank"> http://localhost:4200 </a>来查看您的应用程序运行情况。</p></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><h2 id="b98a" class="na la iq bd lb nb nc dn lf nd ne dp lj kf nf ng ln kj nh ni lr kn nj nk lv nl bi translated"><strong class="ak">服务器端渲染设置</strong></h2><p id="a0bf" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">SSR设置可以分为3个高级阶段:</p><ol class=""><li id="95ac" class="mm mn iq jw b jx jy kb kc kf mo kj mp kn mq kr mr ms mt mu bi translated">使应用程序SSR兼容</li><li id="237c" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated">生成可以在SSR和非SSR模式下工作的应用程序包</li><li id="969a" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated">服务器端逻辑提供SSR模板。</li></ol><p id="0625" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">使应用程序SSR兼容</strong></p><p id="5bd0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在第一阶段，我们需要安装所有必要的依赖项来启用SSR，如下所示:</p><pre class="nm nn no np gt nq mf nr ns aw nt bi"><span id="6582" class="na la iq mf b gy nu nv l nw nx">npm i -S @angular/platform-server @nguniversal/express-engine @nguniversal/module-map-ngfactory-loader </span></pre><p id="f120" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，让我们创建服务器模块，它是应用程序模块的包装器。到目前为止，我们仅使用AppModule在客户端引导我们的应用程序:</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="5184" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这个阶段，我们只导入<code class="fe mc md me mf b">ServerModule</code>和<code class="fe mc md me mf b">ModuleMapLoaderModule</code>并定义引导哪个组件。当我们试图在服务器上访问和呈现应用程序时，这两个导入的模块都很有用。</p><p id="13e9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因为我们已经导入了<code class="fe mc md me mf b">AppModule</code>，其中<code class="fe mc md me mf b">imports</code> / <code class="fe mc md me mf b">declares</code> / <code class="fe mc md me mf b">exports</code> / <code class="fe mc md me mf b">provides</code>是我们的应用程序需要的所有其他东西，所以我们只<code class="fe mc md me mf b">provide</code>了这个模块中的服务，基于它们对服务器端渲染的需要。</p><p id="1c7d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当我们的应用程序在客户端启动时，它通常会经历下面的初始化步骤，如<code class="fe mc md me mf b">main.ts</code>中所定义的</p><pre class="nm nn no np gt nq mf nr ns aw nt bi"><span id="27cb" class="na la iq mf b gy nu nv l nw nx">platformBrowserDynamic().bootstrapModule(AppModule)</span><span id="e57a" class="na la iq mf b gy ny nv l nw nx">.catch(err =&gt; console.error(err));</span></pre><p id="e01a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因为我们希望事情的处理方式有所不同，所以在服务器上进行渲染时，我们需要执行我们的服务器模块。为了方便起见，我们在<code class="fe mc md me mf b">main.ts</code>旁边创建一个<code class="fe mc md me mf b">main.server.ts</code>，然后从中导出我们的新<code class="fe mc md me mf b">AppServerModule</code>。这主要是为了使SSR的更改尽可能与客户端保持一致。</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="1a38" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，我们需要一种方法来告诉Angular如何编译和使用这些更改。我们可以通过扩展现有的<code class="fe mc md me mf b">tsconfig.json</code>文件并只覆盖<code class="fe mc md me mf b">entryModule</code>来指向我们新的服务器模块。</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="c0c5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后但同样重要的是，我们需要告诉客户端主模块，它必须使用<code class="fe mc md me mf b">AppModule</code>中的以下更改从服务器端呈现的应用程序转换到客户端呈现的应用程序:</p><pre class="nm nn no np gt nq mf nr ns aw nt bi"><span id="f7b2" class="na la iq mf b gy nu nv l nw nx">BrowserModule.withServerTransition({ appId: ‘ng-ssr’ }),</span></pre><p id="95b4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们现在不像以前那样只提供<code class="fe mc md me mf b">BrowserModule</code>，而是称它为<code class="fe mc md me mf b">withServerTransition</code>，并传递一个唯一的应用程序id来指示它是什么应用程序(这需要与下面列出的<code class="fe mc md me mf b">angular.json</code>文件中的项目名称相匹配)。一旦客户端启动应用程序，这将从页面中删除在服务器端呈现期间应用的所有CSS。</p><p id="23f2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">通过中的这些更改，我们的代码现在可以用于客户端和服务器端设置。现在，我们已经准备好编译并生成合适的发行包，这些发行包可以从我们的新服务器上提供。</p><p id="ebd9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">生成应用捆绑包</strong></p><p id="b609" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在下一阶段，我们将不得不对当前的应用程序配置进行一点调整，以适应我们在前一阶段创建的新文件。目前，当我们运行build命令时，所有打包的文件都直接放在<code class="fe mc md me mf b">dist</code>文件夹中。</p><p id="453e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是，我们现在需要为客户端和服务器端入口模块分别持久化最终的应用程序包。我们这样做是因为我们的服务器端捆绑包有一个不同的入口点，并且比客户端更精简，因为与客户端相比，它只需要一小部分功能。</p><p id="574e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了进行这一更改，我们需要查看我们的<code class="fe mc md me mf b">angular.json</code>文件，该文件包含应用程序的所有配置模式。在<code class="fe mc md me mf b">angular.json</code>中，我们有一个名为<code class="fe mc md me mf b">projects</code>的条目(是的，Angular 6+支持同一个存储库中的多个项目)，其中包含一个针对<code class="fe mc md me mf b">ng-ssr</code>项目的条目。</p><p id="8d3b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我们的<code class="fe mc md me mf b">ng-ssr</code>项目中，我们可以理所当然地看到，基于我们可以执行的操作，有不同的目标可用。其中之一是<code class="fe mc md me mf b">build</code>，我们将首先修改它，以确保生成的分发代码位于<code class="fe mc md me mf b">/dist/browser</code>下，而不是它的默认位置。要进行此更改，请更新<code class="fe mc md me mf b">build.options</code>下的<code class="fe mc md me mf b">outputPath</code>。</p><pre class="nm nn no np gt nq mf nr ns aw nt bi"><span id="6549" class="na la iq mf b gy nu nv l nw nx">"architect": {</span><span id="c8b0" class="na la iq mf b gy ny nv l nw nx">    "build": {</span><span id="7a34" class="na la iq mf b gy ny nv l nw nx">     …</span><span id="f90f" class="na la iq mf b gy ny nv l nw nx">         "options": {</span><span id="adf7" class="na la iq mf b gy ny nv l nw nx">            "outputPath": "dist/browser",</span><span id="e8cb" class="na la iq mf b gy ny nv l nw nx">            …</span></pre><p id="1cdf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这确保了当我们运行常规的<code class="fe mc md me mf b">ng build</code>命令时，生成的包在<code class="fe mc md me mf b">dist/browser</code>文件夹下。</p><p id="7b9a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了在服务器上运行支持SSR的代码，我们需要用我们的服务器模块作为入口点来生成我们的分发包。为此，我们需要在<code class="fe mc md me mf b">ng-ssr</code>项目中列出的其他目标旁边添加一个名为<code class="fe mc md me mf b">server</code>的新目标。</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="0d5a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在选项下，我们列出了指向我们之前创建的文件的<code class="fe mc md me mf b">tsConfig</code>和我们希望编译后的代码驻留的新的<code class="fe mc md me mf b">outputPath</code>。我们还用<code class="fe mc md me mf b">main</code>属性列出了需要在服务器端执行的主文件的路径。</p><p id="d684" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要生成特定于客户端的<code class="fe mc md me mf b">dist</code>文件夹，我们可以简单地运行<code class="fe mc md me mf b">ng build --prod</code>命令，该命令现在将放在我们定义的新路径下。为了编译在服务器上执行的代码，我们需要使用我们希望它使用的特定目标来运行<code class="fe mc md me mf b">ng run</code>命令。在这种情况下，它将是<code class="fe mc md me mf b">ng run ng-ssr:server</code>。</p><blockquote class="ob oc od"><p id="bdd5" class="ju jv oe jw b jx jy jz ka kb kc kd ke of kg kh ki og kk kl km oh ko kp kq kr ij bi translated">需要注意的一点是，由于Angular 6.x的所有内容都是基于Angular的原理图，Angular CLI运行这些原理图，除了一些默认原理图，如<code class="fe mc md me mf b">build</code>、<code class="fe mc md me mf b">test</code>、<code class="fe mc md me mf b">serve</code>等。所有的原理图都需要通过传递额外的参数来调用ng run命令，如上所示。而这就是@angular-devkit/build-angular在上面指定的构建器中的作用。</p></blockquote><p id="a704" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为客户端构建生成的代码与为服务器构建生成的代码之间的一个重要区别是，不再需要大量特定于客户端的代码例如，基本index.html文件、聚合填充都可以忽略，因为现在我们只在服务器上直接呈现应用程序，然后在返回之前将其修补到视图上。</p><figure class="nm nn no np gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi oi"><img src="../Images/6c042af05eff299e63b0b5693b62331b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-oZyne7bAfH87UXhLNPMAQ.png"/></div></div></figure><p id="e95c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了简化，我们可以用一个新的脚本更新我们的<code class="fe mc md me mf b">package.json</code>文件，以便在必要时生成<code class="fe mc md me mf b">dist</code>文件:</p><pre class="nm nn no np gt nq mf nr ns aw nt bi"><span id="8671" class="na la iq mf b gy nu nv l nw nx">"build:ssr": "npm run build:client &amp;&amp; npm run build:server",</span><span id="a800" class="na la iq mf b gy ny nv l nw nx">"build:client": "ng build --prod",</span><span id="c3d2" class="na la iq mf b gy ny nv l nw nx">"build:server": "ng run ng-ssr:server",</span></pre><p id="ec03" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">服务器端逻辑</strong></p><p id="78d1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后一个阶段，阶段3，是我们编写我们的<code class="fe mc md me mf b">Express</code>服务器来呈现和提供来自我们的发行包的文件的阶段。我们也将使用<code class="fe mc md me mf b">TypeScript</code>对这个文件进行编码，因此为了编译它，我们需要一个单独的迷你webpack配置文件，为了简洁起见，我将跳过这个文件。我们服务器的第一次迭代与通用渲染相关的<a class="ae mg" href="https://angular.io/guide/universal#universal-web-server" rel="noopener ugc nofollow" target="_blank">角度文档</a>相似。将此文件放在项目的根目录下。</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="d1f5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该文件最重要的部分是在第27–32行设置应用程序引擎。以下是Angular文档的摘录，解释了相同的内容:</p><blockquote class="ob oc od"><p id="b7ed" class="ju jv oe jw b jx jy jz ka kb kc kd ke of kg kh ki og kk kl km oh ko kp kq kr ij bi translated"><code class="fe mc md me mf b">ngExpressEngine</code>是通用的<code class="fe mc md me mf b"><a class="ae mg" href="https://angular.io/api/platform-server/renderModuleFactory" rel="noopener ugc nofollow" target="_blank">renderModuleFactory</a></code>函数的包装器，它将客户机的请求转换成服务器呈现的HTML页面。您将在适合您的服务器堆栈的<em class="iq">模板引擎</em>中调用该函数。</p><p id="5edc" class="ju jv oe jw b jx jy jz ka kb kc kd ke of kg kh ki og kk kl km oh ko kp kq kr ij bi translated">第一个参数是<code class="fe mc md me mf b">AppServerModule</code>。它是通用服务器端呈现器和您的应用程序之间的桥梁。</p><p id="03a4" class="ju jv oe jw b jx jy jz ka kb kc kd ke of kg kh ki og kk kl km oh ko kp kq kr ij bi translated">第二个参数是<code class="fe mc md me mf b">extraProviders</code>。它是一个可选的角度依赖注入提供程序，适用于在此服务器上运行时。</p><p id="d32c" class="ju jv oe jw b jx jy jz ka kb kc kd ke of kg kh ki og kk kl km oh ko kp kq kr ij bi translated">当您的应用程序需要只能由当前运行的服务器实例决定的信息时，您提供<code class="fe mc md me mf b">extraProviders</code>。</p></blockquote><p id="b937" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们在服务器模块中包含的两个模块有助于提供<code class="fe mc md me mf b">AppServerModuleNgFactory</code>——这是我们模块的机器可理解的翻译，以及<code class="fe mc md me mf b">LAZY_MODULE_MAP</code>——这实质上是在初始化时而不是运行时提供所有懒惰加载的模块。点击查看更多详情<a class="ae mg" href="https://github.com/angular/universal/tree/master/modules/module-map-ngfactory-loader#module-map-ngfactory-loader" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="65c7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，我们已经准备好编译和提供我们的应用程序中的更改，并提供完整的服务器端渲染支持。但在此之前，让我们也添加一个API调用，从API服务器获取数据并呈现到我们的模板上。</p></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><h2 id="f27b" class="na la iq bd lb nb nc dn lf nd ne dp lj kf nf ng ln kj nh ni lr kn nj nk lv nl bi translated">用SSR处理API调用</h2><p id="170a" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">由于没有api调用的应用程序是不完整的，我们也将实现一个示例API调用来从<a class="ae mg" href="https://jsonplaceholder.typicode.com/posts" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/posts</a>获取数据并在UI上显示它。这也有助于我们理解如何在服务器端进行API调用，并在将响应返回给客户端之前将它们呈现给模板。</p><p id="d998" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了启用HTTP调用，我们首先需要在<code class="fe mc md me mf b">AppModule</code>中导入<code class="fe mc md me mf b">HttpClientModule</code>，这样我们就可以进行API调用。然后，我们将<code class="fe mc md me mf b">HttpClient</code>包含在我们选择的组件中，以分派实际的API请求。</p><p id="cb5a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">非SSR模式下的Http调用</strong></p><p id="983e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这在本地开发期间尤其有用。因为我们是向第三方服务器发出请求，所以我们可以通过代理很容易地做到这一点，只需添加一个代理配置就可以在Angular中启用代理。由于api服务器的调用没有前缀<code class="fe mc md me mf b">/api</code>，我们将临时添加它，并在代理之前删除它，这样我们就可以区分API调用和UI状态变化(为了SSR和非SSR模式之间的一致性)。</p><p id="d5dd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于代理配置，我们在项目的根目录下创建一个JSON文件，如下所示:</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="20d9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请注意上面的<code class="fe mc md me mf b">pathRewrite</code>选项，它表明我们正在去掉添加到请求中的前缀<code class="fe mc md me mf b">/api</code>。</p><p id="b52b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了启用代理，我们需要将<code class="fe mc md me mf b">package.json</code>中的<code class="fe mc md me mf b">start</code>脚本修改为:</p><pre class="nm nn no np gt nq mf nr ns aw nt bi"><span id="0681" class="na la iq mf b gy nu nv l nw nx">"start": "ng serve --proxy-config proxy.conf.json",</span></pre><p id="e86a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们现在可以在任何组件中添加我们的逻辑来获取数据，下面是<code class="fe mc md me mf b">HomeComponent</code>的一个例子:</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="c11f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要在模板上显示这些帖子:</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="edb3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">SSR模式下的Http调用</strong></p><p id="f61a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在SSR模式下，API调用以两种方式触发:</p><ol class=""><li id="0945" class="mm mn iq jw b jx jy kb kc kf mo kj mp kn mq kr mr ms mt mu bi translated">当模板最初在服务器上呈现时，即组件被加载时</li><li id="a7e5" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated">当模板在客户机上呈现时(即，当从服务器呈现的模板中转移出来时)</li></ol><p id="5d91" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上面列出的两种方法之间的唯一区别是如何触发和处理API调用。</p><p id="55e9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因为我们直接从服务器上的模板进行API调用，所以我们需要在发出请求时提供一个绝对URL。</p><p id="97cf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在下一阶段，由于我们的模板从客户端进行API调用，我们可以在web服务器上捕获请求，并将其代理到API服务器，从而绕过CORS限制。</p><p id="00de" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于#1，直接从服务器进行API调用，我们需要更新应用程序以能够直接与API服务器通信，我们可以通过在服务器模块中传递一个新的提供者<code class="fe mc md me mf b">APP_BASE_HREF</code>来实现，该提供者具有我们的API服务器的基本URL值，然后在我们的API调用中使用它，如下所示:</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="5b10" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后我们可以在我们的<code class="fe mc md me mf b">HomeComponent</code>中注入和使用它，如下所示:</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="dfab" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们正在检查我们是否有一个仅用于日志语句的<code class="fe mc md me mf b">PLATFORM_ID</code>,如果需要的话，可以删除它。</p><p id="a49a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上面的URL结构就是奇迹发生的地方。在服务器上，当我们直接从模板中发出请求时，我们跳过<code class="fe mc md me mf b">/api</code>前缀，当我们从客户端发出请求时，我们添加它，并让我们的<code class="fe mc md me mf b">Express</code>服务器为我们捕获、修改和代理请求。</p><blockquote class="ob oc od"><p id="b24c" class="ju jv oe jw b jx jy jz ka kb kc kd ke of kg kh ki og kk kl km oh ko kp kq kr ij bi translated">由于API调用将在客户机和服务器上间隔几秒钟进行，所以强烈建议您实现某种形式的缓存以使API加载更快，或者使用状态存储，如<a class="ae mg" href="https://ngrx.github.io/" rel="noopener ugc nofollow" target="_blank"> ngrx </a>。</p></blockquote><p id="4824" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于#2，当服务器端呈现的模板被客户端版本转换出来时，我们需要更新服务器的工作方式。我们现在需要将请求从web服务器代理到外部API服务器。为了实现这一点，我们可以<code class="fe mc md me mf b">pipe</code>那些<code class="fe mc md me mf b">Express</code>允许的请求。我们可以使用任何HTTP请求库(比如本例中的<code class="fe mc md me mf b">request</code>)来简化管道:</p><pre class="nm nn no np gt nq mf nr ns aw nt bi"><span id="5ef1" class="na la iq mf b gy nu nv l nw nx">npm i -S request</span></pre><p id="f38a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后我们替换现有的API逻辑，如下面的<code class="fe mc md me mf b">server.ts</code>文件所示:</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="00c5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这将捕获所有以前缀<code class="fe mc md me mf b">/api</code>开头的请求，然后在将请求转发到我们的API服务器之前将其从URL中删除。</p><h2 id="2bd3" class="na la iq bd lb nb nc dn lf nd ne dp lj kf nf ng ln kj nh ni lr kn nj nk lv nl bi translated">构建并运行</h2><p id="8e98" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">在启动我们的服务器之前，最后要做的事情是编译它(因为我们已经用typescript编写了它)。所有更改合并后，<code class="fe mc md me mf b">package.json</code>文件的<code class="fe mc md me mf b">scripts</code>部分的最终状态如下:</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="d938" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要立即构建和服务项目，请运行以下命令:</p><pre class="nm nn no np gt nq mf nr ns aw nt bi"><span id="d46d" class="na la iq mf b gy nu nv l nw nx">npm run build:ssr</span><span id="cfe5" class="na la iq mf b gy ny nv l nw nx">npm run serve:ssr</span></pre><p id="9365" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由于我们已经添加了日志语句，我们应该能够在服务器上看到如下所示的日志:</p><figure class="nm nn no np gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi on"><img src="../Images/50d81e44c5696972083856451dd7923e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*amhHPZJzuMdMoePimJmzXg.png"/></div></div></figure><p id="69bb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在浏览器上:</p><figure class="nm nn no np gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi oo"><img src="../Images/1e740cb3b9bde63a88692625a4f31ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CRlFHjdaGVWeFfw7MY6maQ.png"/></div></div></figure><p id="e746" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以看到，在模板呈现并返回给客户端一秒钟后，客户端从SSR提供的模板转换到常规应用程序，并重新呈现路线。</p><p id="14fe" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">路线之间的任何和所有后续导航都将在客户端中执行，并且只有在执行完整页面重新加载时才会在服务器上呈现。</p><p id="d6b9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该项目的全部代码可以在<a class="ae mg" href="https://github.com/40x/ng-ssr" rel="noopener ugc nofollow" target="_blank">这里</a>找到，具体到SSR的变化可以在<a class="ae mg" href="https://github.com/40x/ng-ssr/commit/7e9c0b145b906e05cae194969040413b2a569b37" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="7ca0" class="kz la iq bd lb lc mh le lf lg mi li lj lk mj lm ln lo mk lq lr ls ml lu lv lw bi translated">React应用中的SSR</h1><p id="3744" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">在React应用程序中，对于简单的项目，设置非常简单。然而，棘手的部分是处理我们可能在项目中最终使用的多个库。如果我们希望在服务器端呈现一个使用不兼容库的路由，我们可能会遇到潜在的问题。幸运的是，大多数常见和常用的库都提供了SSR功能，所以在大多数情况下我们应该没问题。为了简单起见，我们不会在下面的示例应用程序中包含很多库。</p><p id="dbcc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">类似于角度部分，让我们列出我们必须引入的更改，以便我们的应用程序与SSR兼容:</p><ol class=""><li id="cdd1" class="mm mn iq jw b jx jy kb kc kf mo kj mp kn mq kr mr ms mt mu bi translated">我们现在需要一个服务器——我们现在将使用一个服务器(本例中为NodeJS/Express)来启用SSR，而不是使用类似NGINX的东西来服务我们的<code class="fe mc md me mf b">build</code>文件夹。</li><li id="23c3" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated">如果我们想显示经过SSR的API数据，必须使用Redux(或类似的东西)</li><li id="5d27" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated">条件检查以避免重新加载在SSR期间在服务器上加载并在存储中更新的数据</li><li id="f88c" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated">组件上API调用的静态声明有助于SSR</li></ol><h2 id="d073" class="na la iq bd lb nb nc dn lf nd ne dp lj kf nf ng ln kj nh ni lr kn nj nk lv nl bi translated">基本应用程序设置</h2><p id="e761" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">与Angular应用程序类似，我们首先使用由几条基本路线组成的<code class="fe mc md me mf b">create-react-app</code>创建react应用程序。</p><p id="e3d0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将使用create-react-app来创建应用程序。让我们开始吧:</p><pre class="nm nn no np gt nq mf nr ns aw nt bi"><span id="2517" class="na la iq mf b gy nu nv l nw nx">create-react-app react-ssr<br/>cd react-ssr</span></pre><p id="2460" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们添加必要的库来启用路由</p><pre class="nm nn no np gt nq mf nr ns aw nt bi"><span id="f499" class="na la iq mf b gy nu nv l nw nx">npm i -S react-router react-router-dom</span></pre><p id="97ff" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，让我们设置我们希望每条路线加载的基本组件，在此阶段，它们看起来都很相似，如下所示:</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="9de3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们也创建一个路由文件，我们可以在位于<code class="fe mc md me mf b">App.js</code>的基础组件上读取和显示。这个文件也可以是我们提供额外信息的地方，以防我们使用像<a class="ae mg" href="https://github.com/nfl/react-helmet#readme" rel="noopener ugc nofollow" target="_blank"> react-helmet </a>这样的东西。</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="ba94" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">更新<code class="fe mc md me mf b">App.js</code>以显示上面列出的路线:</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="89ec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在可以启动应用程序，我们可以导航到上面定义的所有路线。</p><h2 id="94d2" class="na la iq bd lb nb nc dn lf nd ne dp lj kf nf ng ln kj nh ni lr kn nj nk lv nl bi translated">服务器端渲染设置</h2><p id="a085" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">与Angular相比，使应用程序SSR就绪所需的设置在React中相当简单(至少在没有API调用时)。让应用程序在服务器上呈现不需要额外的代码或任何特殊的技巧。</p><p id="d083" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们真正需要的是一个服务器(本例中为<code class="fe mc md me mf b">Express</code>)，它可以提供静态文件并理解用户试图访问的路径，将该路径设置为应用程序位置，然后呈现应用程序。我们也可以以静态上下文的形式传递<a class="ae mg" href="https://reacttraining.com/react-router/web/example/static-router" rel="noopener ugc nofollow" target="_blank">附加上下文</a>以备不时之需。所有这些都是由<code class="fe mc md me mf b">react-router</code>库以<code class="fe mc md me mf b">StaticRouter</code>的形式提供的，而不是通常在客户端使用的<code class="fe mc md me mf b">BrowserRouter</code>。</p><p id="6679" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们创建文件夹<code class="fe mc md me mf b">server</code>并将下面的<code class="fe mc md me mf b">server.js</code>文件添加到其中，该文件包含3个不同的中间件，用于加载静态资源和处理我们的路由逻辑:</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="b658" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由于涉及到一些JSX，我们将安装并使用<code class="fe mc md me mf b">@babel/core</code>、<code class="fe mc md me mf b">@babel/cli</code>、<code class="fe mc md me mf b">@babel/preset-env</code>和<code class="fe mc md me mf b">@babel/preset-react</code>，以便节点能够理解我们的<code class="fe mc md me mf b">server.js</code>文件:</p><pre class="nm nn no np gt nq mf nr ns aw nt bi"><span id="1670" class="na la iq mf b gy nu nv l nw nx">npm i -S express <!-- -->@babel/core @babel/cli @babel/preset-env @babel/preset-react</span></pre><p id="c888" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后为了编译这个<code class="fe mc md me mf b">server.js</code>文件，我们可以调用一个小的内联babel脚本，如下所示:</p><pre class="nm nn no np gt nq mf nr ns aw nt bi"><span id="704d" class="na la iq mf b gy nu nv l nw nx">babel server/server.js --out-file server/index.js --presets=@babel/env,@babel/react</span></pre><p id="9534" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦服务器编译成功，我们就可以运行我们的应用程序了。但是在我们这样做之前，当在服务器端呈现我们的模板时，我们需要忽略组件的样式，但是样式将从生成的<code class="fe mc md me mf b">main.css</code>文件中应用，并作为我们创建的最终发行版的一部分放在<code class="fe mc md me mf b">build</code>文件夹中。要忽略这些风格，我们可以使用<code class="fe mc md me mf b">ignore-styles</code> npm插件。</p><blockquote class="ob oc od"><p id="a953" class="ju jv oe jw b jx jy jz ka kb kc kd ke of kg kh ki og kk kl km oh ko kp kq kr ij bi translated">忽略样式将意味着当服务器最初返回我们的模板时，它将不会被样式化，这将导致页面在客户端呈现时闪烁，现在，我们将忽略这个问题，但它可以通过使用webpack和<a class="ae mg" href="https://github.com/kriasoft/isomorphic-style-loader" rel="noopener ugc nofollow" target="_blank">同构样式加载器</a>来解决，这可以从这个非常简单的<a class="ae mg" href="https://github.com/kriasoft/isomorphic-style-loader#react-component-example" rel="noopener ugc nofollow" target="_blank">示例</a>中看出。</p></blockquote><p id="8ebf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由于我们编译的服务器文件仍在尝试访问应用程序模块，我们需要编译可以使用<code class="fe mc md me mf b">@babel/register</code>插件的代码，并提供必要的预置以在运行时编译。</p><p id="ca34" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将这些放在一起，启动服务器。我们可以在项目的根目录下使用下面标有<code class="fe mc md me mf b">start.js</code>的脚本。</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="0729" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们现在可以将这个调用添加到脚本下的<code class="fe mc md me mf b">package.json</code>中，这样对我们来说就更容易了。</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="5458" class="na la iq bd lb nb nc dn lf nd ne dp lj kf nf ng ln kj nh ni lr kn nj nk lv nl bi translated">用SSR处理API调用</h2><p id="70bc" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">在我们运行和测试我们的更改之前，让我们也添加一个简单的API调用，它从<a class="ae mg" href="http://jsonplaceholder.typicode.com/posts" rel="noopener ugc nofollow" target="_blank">http://jsonplaceholder.typicode.com/posts</a>中检索数据，就像我们之前在Angular示例中所做的那样。</p><p id="22d3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了进行API调用，我们将使用<code class="fe mc md me mf b">Axios</code> npm包。通常，在UI上呈现API响应。一旦使用<code class="fe mc md me mf b">componentDidMount</code>生命周期钩子挂载了组件，我们将进行API调用，然后调用<code class="fe mc md me mf b">setState</code>将API调用的响应存储到组件状态中。这个<code class="fe mc md me mf b">setState</code>调用再次触发render方法，该方法现在可以访问更新后的状态。</p><p id="54bd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因为我们在服务器上编译我们的组件，而不是真正把它挂载到一个实际的DOM，我们不能使用前面讨论的方法，因为它不会触发服务器端的<code class="fe mc md me mf b">componentDidMount</code>生命周期。然而，<code class="fe mc md me mf b">componentWillMount</code>在服务器端和客户端都会被触发。不幸的是，这不能使用，因为它是一个反模式，不会在<code class="fe mc md me mf b">componentWillMount</code>生命周期挂钩中引起任何副作用。</p><p id="5264" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个问题最简单的解决方案是使用像Redux这样的状态存储。</p><p id="e12d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们先来谈谈它在客户端是如何工作的:</p><ol class=""><li id="2e37" class="mm mn iq jw b jx jy kb kc kf mo kj mp kn mq kr mr ms mt mu bi translated">组件加载和调用<code class="fe mc md me mf b">componentDidMount</code></li><li id="62da" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated">我们检查数据是否已经存在于存储中，如果不存在，则进行API调用并更新存储</li><li id="1e29" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated">渲染组件</li></ol><p id="1d90" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">服务器端的相同流程会有所不同:</p><ol class=""><li id="5e28" class="mm mn iq jw b jx jy kb kc kf mo kj mp kn mq kr mr ms mt mu bi translated">确定用户正在加载的路线</li><li id="8b36" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated">确定与此路线相关联的组件</li><li id="5e38" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated">如果有附加的静态数据获取方法来检索数据，那么就这样做。</li><li id="ddc7" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated">用检索到的数据更新存储</li><li id="0374" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated">用商店数据呈现模板</li><li id="f076" class="mm mn iq jw b jx mv kb mw kf mx kj my kn mz kr mr ms mt mu bi translated">返回模板和已经在服务器上创建的存储。</li></ol><p id="9ab2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我们进行任何代码更改之前，让我们添加所有必要的库。</p><pre class="nm nn no np gt nq mf nr ns aw nt bi"><span id="6914" class="na la iq mf b gy nu nv l nw nx">npm i -S axios redux redux-thunk request</span></pre><p id="f6b7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">非SSR模式下的Http调用</strong></p><p id="0f49" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因为我们希望我们的应用程序既可以在SSR模式(生产)下运行，也可以在非SSR模式(本地开发)下运行。我们可以简单地向我们的<code class="fe mc md me mf b">package.json</code>文件添加一个代理来代理我们的请求(类似于Angular应用程序)，如下所示:</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="8a0b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们现在可以在<code class="fe mc md me mf b">componentDidMount</code>生命周期钩子中为我们选择的任何组件进行API调用。</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="c0c4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这在仅客户端模式下运行良好。因为我们还需要考虑SSR模式，所以我们必须修改组件以使用Redux store来保存可以在服务器和浏览器上使用的<code class="fe mc md me mf b">posts</code>。</p><p id="232c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了方便起见，我们需要首先创建我们的Redux存储，在本例中它非常精简，如下所示:</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="a10a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在上面的例子中，为了可读性，动作、reducers和API调用都在同一个文件中，但是你可能希望在你的项目中把它们分开。</p><p id="b4a5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们现在可以从<code class="fe mc md me mf b">Home</code>组件中调用<code class="fe mc md me mf b">fetchPosts</code>方法。</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="35b4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个文件中唯一奇特的地方是API方法对类的静态声明，我们将在下一节讨论这一点的必要性。</p><blockquote class="ob oc od"><p id="9df5" class="ju jv oe jw b jx jy jz ka kb kc kd ke of kg kh ki og kk kl km oh ko kp kq kr ij bi translated">另一个奇怪的地方是，我们不能像往常一样在根元素定义<code class="fe mc md me mf b">state</code>:</p></blockquote><pre class="nm nn no np gt nq mf nr ns aw nt bi"><span id="4da4" class="na la iq mf b gy nu nv l nw nx">state = {<br/>    something: ''<br/>};</span></pre><blockquote class="ob oc od"><p id="8c7c" class="ju jv oe jw b jx jy jz ka kb kc kd ke of kg kh ki og kk kl km oh ko kp kq kr ij bi translated">这给出了一个运行时错误，要求我们安装<code class="fe mc md me mf b">@babel/plugin-proposal-class-properties</code>。相反，我们需要将它包装在我们的构造函数中，如下所示:</p></blockquote><pre class="nm nn no np gt nq mf nr ns aw nt bi"><span id="a41f" class="na la iq mf b gy nu nv l nw nx">constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>        something: ''<br/>    };<br/>}</span></pre><p id="d7db" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将所有这些联系在一起的最后一项更改是当应用程序在浏览器上呈现时创建商店:</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="c048" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">SSR模式下的Http调用</strong></p><p id="3469" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了在服务器上启用API调用，我们可以很容易地在为客户端设置的更改的基础上进行构建。唯一需要的修改是当应用程序在客户机上呈现时，将有效的默认状态(即加载到服务器上的数据)传递给存储。</p><p id="cefd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了计算服务器端存储的准确状态，我们需要首先确定需要调度的操作(可以用必要的数据更新我们的存储)。更改后的服务器将如下所示:</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="1c1e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我们的例子中，我们用一个API调用来水合我们的主模板。如果我们有多个，我们可以简单地将所有请求添加到<code class="fe mc md me mf b">serverSideFetch</code>方法中，这将确保在呈现模板之前所有数据都被加载到存储中。</p><p id="ce33" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">还有一点需要注意的是，在最后，当我们渲染模板时，我们也将商店的当前状态添加到<code class="fe mc md me mf b">window.REDUX_DATA</code>。这样，当应用程序在客户端初始化时，我们可以简单地读取<code class="fe mc md me mf b">window</code>对象上的值，并将其传递到我们的存储创建中。这样，我们可以避免对服务器上呈现的相同数据重复调用<code class="fe mc md me mf b">client</code>。</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="89e0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此外，我们需要修改public文件夹中的基本<code class="fe mc md me mf b">index.html</code>文件，为我们将在服务器上替换的<code class="fe mc md me mf b">REDUX_DATA</code>添加占位符:</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="101b" class="na la iq bd lb nb nc dn lf nd ne dp lj kf nf ng ln kj nh ni lr kn nj nk lv nl bi translated">构建并运行</h2><p id="9a9e" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">有了这些变化，我们现在可以使用<code class="fe mc md me mf b">package.json</code>中定义的脚本运行我们的应用程序了。</p><pre class="nm nn no np gt nq mf nr ns aw nt bi"><span id="c254" class="na la iq mf b gy nu nv l nw nx">npm run build:ssr</span><span id="a6e5" class="na la iq mf b gy ny nv l nw nx">npm run serve:ssr</span></pre><figure class="nm nn no np gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi op"><img src="../Images/09617e26da3c783997ef4de2236cb6de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BXsXl0eotIG95UkVoNmc9A.png"/></div></div></figure><p id="bdf5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在客户机上，我们可以看到我们触发的初始请求与加载到服务器上的数据一起返回。在服务器上，我们看到日志语句按预期打印出来。</p><figure class="nm nn no np gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi oq"><img src="../Images/6f7753d5ab0fd3d551f8d6ab08ba4e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H98-KJu14-Jp5K5pLqxQyw.png"/></div></div></figure><p id="fd43" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以上示例的完整代码可在<a class="ae mg" href="https://github.com/40x/react-ssr" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><h1 id="729e" class="kz la iq bd lb lc mh le lf lg mi li lj lk mj lm ln lo mk lq lr ls ml lu lv lw bi translated">比较和结论</h1><p id="a389" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">尽管React和Angular在核心原则和构建块方面有很大的不同，但它们之间有一个共同点，那就是启用SSR是一项简单的任务。</p><p id="5132" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">与React相比，Angular应用程序中要添加的boiler plate代码量更多，因为添加封装浏览器主模块的服务器特定模块来自几个不同的文件。</p><p id="d766" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">SSR的服务器端逻辑在Angular和React上都非常相似，这要感谢Angular包装了<code class="fe mc md me mf b">Express</code>并为我们提供了<code class="fe mc md me mf b">ExpressEngine</code>，它公开了易于使用的方法(至少对于基于NodeJS的后端是如此)。</p><p id="bcc7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在Angular和React应用程序中，我们都需要在服务器端进行编译，虽然如果我们使用普通JavaScript而不是TypeScript，在Angular中可以绕过这一步，但对于React应用程序，我们最终使用了<code class="fe mc md me mf b">babel</code>，因为我们在服务器端代码中引入了JSX。</p><p id="e003" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因为React中的许多功能来自附加库(<code class="fe mc md me mf b">router</code>、<code class="fe mc md me mf b">redux</code>等)。)，我们需要在服务器端显式地集成它们，而Angular应用程序只需要访问编译好的主模块工厂。</p><p id="8037" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在Angular和React应用程序中，进行API调用的复杂性几乎相同。但是，只有在我们的React应用程序非常简单的情况下才是正确的，大多数项目最终都需要某种形式的状态存储，并且复杂性不断增加，因此在这种情况下使用Redux绝对不是一个缺点。</p><p id="ba66" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上面显示的两个例子的代码库都可以在这里找到:<a class="ae mg" href="https://github.com/40x/ng-ssr" rel="noopener ugc nofollow" target="_blank"> Angular </a>，<a class="ae mg" href="https://github.com/40x/react-ssr" rel="noopener ugc nofollow" target="_blank"> React </a></p></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><p id="3d7c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="oe">如果你喜欢这个博客，一定要为它鼓掌，</em> <a class="ae mg" href="https://medium.com/@kashyap.mukkamala" rel="noopener"> <em class="oe">阅读更多</em> </a> <em class="oe">或者关注我的</em><a class="ae mg" href="https://www.linkedin.com/in/kashyap-mukkamala/" rel="noopener ugc nofollow" target="_blank"><em class="oe">LinkedIn</em></a><em class="oe">。</em></p></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><figure class="nm nn no np gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi or"><img src="../Images/d9fe9ae1a34de6a28338eae427dd6438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E8lHUzxrIT5VDhu7fUS6gg.png"/></div></a></figure><div class="os ot gp gr ou ov"><a href="https://gitconnected.com/learn/angular" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd ir gy z fp pa fr fs pb fu fw ip bi translated">学习角度-最佳角度教程(2019) | gitconnected</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">47大角度教程。课程由开发人员提交并投票，使您能够找到最佳角度…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">gitconnected.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj js ov"/></div></div></a></div><div class="os ot gp gr ou ov"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd ir gy z fp pa fr fs pb fu fw ip bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">前45名React教程。课程由开发人员提交并投票，使您能够找到最佳反应…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">gitconnected.com</p></div></div><div class="pe l"><div class="pk l pg ph pi pe pj js ov"/></div></div></a></div></div></div>    
</body>
</html>