<html>
<head>
<title>How to Improve .Net Applications with AOP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何提高。使用AOP的. Net应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/aop-dotnet-applications-67c6d94c08b0?source=collection_archive---------3-----------------------#2020-03-03">https://levelup.gitconnected.com/aop-dotnet-applications-67c6d94c08b0?source=collection_archive---------3-----------------------#2020-03-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f51f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何配置依赖注入，使事情按设计发生</h2></div><p id="e7df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不写代码完成任务是任何一个开发者的梦想。在本文中，我们将学习一种无需编写一行代码就能让事情发生的模式。哲学就是AOP(面向方面编程)。这种技术在Java中广泛使用，有助于保持高质量的标准。今天我们将学习如何使用它。没有痛苦的网络核心项目。在简单的理论解释之后，你会发现两个例子(所有的代码都在我的GitHub档案中)。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/e9d959a4b90619b9ffe82de2b352fc64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XGCTfBhROGHOYYh9clRIiw.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">ASP.NET核心中的AOP:用更少的代码做更多的事情</figcaption></figure><h1 id="8f78" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">什么是AOP</h1><p id="c4da" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">让我们从维基百科的定义开始:</p><blockquote class="mr ms mt"><p id="2fb8" class="ki kj mu kk b kl km ju kn ko kp jx kq mv ks kt ku mw kw kx ky mx la lb lc ld im bi translated">在计算中，面向方面编程(AOP)是一种编程范式，旨在通过允许分离横切关注点来增加模块化。它通过在不修改代码本身的情况下向现有代码添加额外的行为(建议)来做到这一点[…]这允许将对业务逻辑不重要的行为(如日志记录)添加到程序中，而不会弄乱作为功能核心的代码。<a class="ae my" href="https://en.wikipedia.org/wiki/Aspect-oriented_programming" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Aspect-oriented_programming</a></p></blockquote><p id="f9c0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">概念简单，可以用一句话概括。</p><blockquote class="mz"><p id="297f" class="na nb it bd nc nd ne nf ng nh ni ld dk translated">不用写代码就能让事情发生。</p></blockquote><p id="d8ea" class="pw-post-body-paragraph ki kj it kk b kl nj ju kn ko nk jx kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">这适用于所有需要的代码，但不引入任何业务逻辑。</p><p id="c178" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是AOP如何改变我们代码的一些例子。第一个是关于日志。</p><pre class="lf lg lh li gt no np nq nr aw ns bi"><span id="36bf" class="nt lv it np b gy nu nv l nw nx">public void SaveData(InputClass input)<br/>{</span><span id="1b17" class="nt lv it np b gy ny nv l nw nx">Stopwatch timer= new Stopwatch();<br/>  timer.Start();<br/>  logger.Info("enterd SaveData method");<br/>  if(logger.LogLevel==LoggingLeve.Debug)<br/>  {<br/>      logger.Debug(MyJsonTool.ConvertToJson(input);<br/>  }</span><span id="3cf3" class="nt lv it np b gy ny nv l nw nx">dataRepositoryInstance.Save(input);</span><span id="9151" class="nt lv it np b gy ny nv l nw nx"> logger.Info($"enterd SaveData method in {timer.ElapsedMilliseconds}ms");</span><span id="f5dc" class="nt lv it np b gy ny nv l nw nx">}</span></pre><p id="b31b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我告诉你，所有这些代码都可以产生相同的输出，只要写这个就行了，会怎么样？</p><pre class="lf lg lh li gt no np nq nr aw ns bi"><span id="9333" class="nt lv it np b gy nu nv l nw nx">public virtual void SaveData(InputClass input)<br/>{<br/>  dataRepositoryInstance.Save(input);<br/>}</span></pre><p id="abfa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，所有的工作只是添加一个虚拟关键字的方法，这是伟大的！我们稍后再回到虚拟关键字来理解它与AOP的关系。</p><p id="d956" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您不相信AOP的强大功能，只需看看如何将数据获取的代码简化如下:</p><pre class="lf lg lh li gt no np nq nr aw ns bi"><span id="5336" class="nt lv it np b gy nu nv l nw nx">[Fetch("SELECT * FROM customers WHERE name=?")]<br/>public List&lt;MyDTO&gt; GetByName(string name);</span></pre><p id="fe1b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望您现在已经非常确信AOP可以在许多场景中提供帮助，并且可以成为一个强大的盟友。让我们看看它是如何工作的，以及如何将它集成到一个. net核心应用程序中。</p><p id="fee5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文包含两个示例:</p><ol class=""><li id="ac30" class="nz oa it kk b kl km ko kp kr ob kv oc kz od ld oe of og oh bi translated">使用DinamyProxy和Autofact截取日志的简单例子。</li><li id="a738" class="nz oa it kk b kl oi ko oj kr ok kv ol kz om ld oe of og oh bi translated">这是一篇非常好的关于AOP技术的深度文章，展示了如何实现AOP引擎。</li></ol><h1 id="8cf1" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">示例1:自动控制器日志记录</h1><p id="f9dc" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">在这个示例中，我们将配置一个拦截器来记录所有传入的请求。这可以扩展到我们应用程序的所有其他层，就当是概念验证。</p><p id="1edc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">拦截者</strong></p><p id="d8fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">拦截器的结构非常简单。在方法执行前后记录它。在这个示例中，我使用一个GUID来一起引用事件日志，但是还可以进行许多改进。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="10b5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以讨论到明天，关于如何愚蠢地将数据转储到日志中，或者我们可以改进这个系统，使用一个更好的日志系统和一个聪明的方法来跟踪输入、计时和输出。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi op"><img src="../Images/3433e538bb60f66c718fc6e74a5e30e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JRgseCuWXBYoPdOpj1AIhg.png"/></div></div></figure><p id="1732" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，有一个方法执行的痕迹，带有计时。想象一下，在您的Asp.net Web API应用程序的所有控制器上，或者在业务逻辑的每个服务方法中。好看吗？它节省了大量代码。</p><h1 id="bb45" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">示例2:低代码查询实现</h1><p id="c732" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">这个例子展示了如何通过添加一些注释来为方法添加默认行为。这个例子是从头开始实现的，没有使用任何库，以突出它是如何工作的。</p><p id="de6b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要创建的基类是DispatcherProxy。此类实现泛型类型的代理，该代理截获方法调用并返回自定义对象。这就是我们需要用一个有效的方法替换一个空方法。</p><p id="c6ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无论如何，要实现一个通用引擎，我们需要更多的东西。我创建了一个通用属性，叫做AOPAttribute，有很多幻想。继承它的每个注释都需要实现执行。使用这种模式，所有的实现都委托给属性，我们的代理引擎与许多实现完全解耦。</p><p id="8163" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以在下面的代码片段中查看相关的代码部分。仅仅使用几行代码，我们就能够实现一个非常强大的引擎，但这只是一个例子。你可以尽情想象能为你解决多少用例。</p><p id="8ac7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我告诉你太快了吗？一步一步开始就好。</p><h2 id="47ea" class="nt lv it bd lw oq or dn ma os ot dp me kr ou ov mg kv ow ox mi kz oy oz mk pa bi translated">第一步:我们想要什么</h2><p id="b2bb" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">首先，我们希望实现一种允许自动实现方法的机制。在C#中，我们不能在类上使用DispatcherProxy，而只能在接口上使用，所以我们需要总是从一个具有所有方法声明的接口开始。无论如何，我们也想手动实现一些方法，所以我们也需要一个具体的类。现在有一个棘手的问题。如果我们让类从接口继承，这是逻辑，我们将被迫实现所有方法，因为这是编译器的要求。我采用的技巧是简单地忘记继承。类和接口之间的关系将在以后的DI中定义</p><p id="cf7f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是水果仓库的片段。该接口包含自动实现的方法和手动实现的InitDB。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="b61a" class="nt lv it bd lw oq or dn ma os ot dp me kr ou ov mg kv ow ox mi kz oy oz mk pa bi translated">第二步:代理</h2><p id="d43f" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">我们现在需要的是创建一个代理，它将维护接口和实现的类之间的关系，提供基于注释的方法。代码非常简单，参见下面的代码片段。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="d728" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用法非常简单，使用常规的。净核心依赖注入。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="7010" class="nt lv it bd lw oq or dn ma os ot dp me kr ou ov mg kv ow ox mi kz oy oz mk pa bi translated">第三步:注释</h2><p id="c108" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">所有这些的基础注释是AOPAnnotation。这是一个抽象类，包含一个Execute方法，它取代了通常的方法体。然后我们有了查询注释，在我们的例子中，它使用从开发人员那里传来的查询模板来获取数据。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="ed90" class="nt lv it bd lw oq or dn ma os ot dp me kr ou ov mg kv ow ox mi kz oy oz mk pa bi translated">第四步:实际观察</h2><p id="df55" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">将所有这些放在一起非常简单。只需使用我们手动编写的存储库。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="on oo l"/></div></figure><h1 id="d376" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">带什么回家</h1><p id="ec67" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">AOP是一个非常有趣的模式，因为它自动化了代码编写。它非常强大，但是有两个弱点:</p><ol class=""><li id="d083" class="nz oa it kk b kl km ko kp kr ob kv oc kz od ld oe of og oh bi translated">性能:深入使用反射和精化阶段的额外步骤，可能会增加计算时间。</li><li id="2c44" class="nz oa it kk b kl oi ko oj kr ok kv ol kz om ld oe of og oh bi translated">失控:系统为你做得越多，你就越不知道如何解决。</li></ol><p id="9d63" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现代工具和框架有助于在不使用代码的情况下减少代码，因此并不总是必要的。无论如何，当你在设计一个框架或大型基础设施时，了解它是非常重要的，因为它可能是赢得战争的正确武器。例如，当我设计开源无头CMS的架构时，这是一个很好的联盟。</p><p id="131a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于性能或者稳定性，只要记住Java Spring框架就可以了。它将It作为一切的基础，并且现在是企业应用程序的最佳选择之一。</p><p id="5848" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae my" href="https://github.com/zeppaman/csharp-aop" rel="noopener ugc nofollow" target="_blank">所有的源代码都在那里，在我的GitHub简介上</a></p><h2 id="d691" class="nt lv it bd lw oq or dn ma os ot dp me kr ou ov mg kv ow ox mi kz oy oz mk pa bi translated">参考</h2><ul class=""><li id="1b50" class="nz oa it kk b kl mm ko mn kr pb kv pc kz pd ld pe of og oh bi translated">AOP的用例[【https://github.com/arduosoft/RawCMS】T4</li><li id="a1d0" class="nz oa it kk b kl oi ko oj kr ok kv ol kz om ld pe of og oh bi translated">一篇关于。net AOP[<a class="ae my" href="https://medium.com/@nik96a/using-di-with-dispatchproxy-based-decorators-in-c-net-core-ac02f02c5fe5" rel="noopener">https://medium . com/@ nik96a/using-di-with-dispatch proxy-based-decorators-in-c-net-core-AC 02 f 02 C5 Fe 5</a>]</li><li id="d3fb" class="nz oa it kk b kl oi ko oj kr ok kv ol kz om ld pe of og oh bi translated">维基百科上的AOP定义[<a class="ae my" href="https://en.wikipedia.org/wiki/Aspect-oriented_programming" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Aspect-oriented_programming</a>]</li><li id="7bc9" class="nz oa it kk b kl oi ko oj kr ok kv ol kz om ld pe of og oh bi translated">本文的源代码<a class="ae my" href="https://github.com/zeppaman/csharp-aop" rel="noopener ugc nofollow" target="_blank">https://github.com/zeppaman/csharp-aop</a></li></ul></div></div>    
</body>
</html>