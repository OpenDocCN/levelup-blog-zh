# 为什么我从 Rust 转向后端

> 原文：<https://levelup.gitconnected.com/why-i-switched-from-rust-to-go-on-the-backend-28bda21dbee9>

## 一个单后端开发者的冷门故事。

![](img/25cbde339ee4b8f390a3093339348bf8.png)

我两个最好的朋友。

请放下干草叉！你一点击这篇文章，我就感觉到了你的愤怒。我不反对 Rust——我更喜欢它的各种使用情况。所有的编程语言都是达到目的的手段。在我的例子中，Rust 根本没有删除它，我不得不删除这个项目并用 Golang 重写它。

该项目是一个简单的后端 webhook 服务。如果您不熟悉 Hasura，它是一个 Postgres 数据库的包装器，为您提供了一个即时的 GraphQL API。对于像我这样独自开发激情项目的人来说，这非常方便:写出每个 REST 端点或 GQL 解析器需要大量时间，而且在每个模型上几乎都是相同的 CRUD 操作。当您需要一些更复杂的逻辑时，这种方法就失效了——为此，Hasura 允许您将一个 GQL 请求映射到一个定制的 webhook。举几个例子，我用这个来上传 S3 文件或者认证。

## 问题一:依赖注入的困境

Rust 依赖注入的故事很有趣。一旦你要求一个具体的类型，即

```
fn do_stuff(db: &Database) {  
    db.create(Stuff);  
    db.read(Stuff);
}
```

你必须将一个`Database`的实例传递给`do_stuff`；没有例外！`Database`你不能“子类化”(子类在 Rust 中字面上不是一个概念)。所以，如果你是一个不测试他们代码的程序员，那么这完全没问题；实际上，您真的会有一个数据库的实现，所以没有理由让这个函数采用除了`Database`之外的任何东西。

而我们测试者呢？我们必须重写函数签名。`Database`需要成为一个特征，然后我们获取这个特征，并在我们的模拟对象上实现它。好吧，那也没*那么*糟糕。事实上，我在 Golang 做着同样的事情。那么，这实际上是从哪里开始瓦解的呢？

## 问题二:异步特征

在 Rust 中，你有简单的异步，你有简单的特征，但是有异步特征有点困难。我在 Rust of async traits 中发现的大多数例子都使用了`async_trait`宏。这是非常有用的，我正在使用它，是一个快乐的露营者。

以下是我迄今为止的旅程总结:

1.  编写一个结构；开心点。
2.  写一个测试；意识到你不能依赖注入。伤心吧。
3.  将该结构转换为特征；开心点。
4.  依赖注入我的心田。
5.  使用`mockall`板条箱自动生成模型。要非常非常开心！
6.  我需要进行一个异步 http 调用。
7.  实现异步特征需要一个特殊的宏。
8.  意识到宏不能很好地与 Mockall 一起工作。
9.  伤心吧:/。

事后看来，这个[问题有了解决方案](https://docs.rs/mockall/latest/mockall/#async-traits)。也许在我决定离开之前，我应该再试一次，但是此时我已经有点沮丧了…到下一点。

## 问题三:棺材(容器)里的钉子(编译时间)

废话废话铁锈有糟糕的编译时间。我们已经听过一千遍了；你不可能有一种无所不能又没有缺点的语言。这是不可能的——Rust 的缺点是很难理解它的寿命和编译时间。

我有一台漂亮、结实的笔记本电脑——M1 Mac 是一台老爷车。在我的 Mac 上编译 rust 绝对没有问题。通常，当我编写服务器时，我在本地开发，并确保每次我做出更改时，在我提交真正的单元测试之前，我会快速地重新加载本地服务器并测试特性。这需要在两次试验之间进行大量的编译；这很好。同样，在我的 Mac 上编译 Rust 没有问题。

但是在一个容器里？别提了。

对我来说，最简单的方法是移植许多本地服务，而不必担心在每个服务中运行`npm run`( Hasura，web hooks，mock s3，mock oauth server..)就是有一个`docker-compose.yaml`来运行所有这些东西。这意味着，通常，它是一个`docker-compose.dev.yaml`，因为我实际上并不使用 docker compose 来部署。只能在当地发展。不过，这也有副作用，我的 Rust 代码需要在容器中编译——因为:

1.  关于自动热重装没有商量余地。
2.  在容器内开发是没有商量余地的。

我有两个选择:要么通过旋转一个巨大的图像让 Rust 编译来节流我的整个计算机，要么处理 3 分钟以上的编译时间。我的开发周期停滞不前，我感到难以置信的低效。我试图改变我的工作流程，在手动测试之前编写代码和测试，或者不使用自动热重装，但是我感觉受到了束缚。我就是做不到。

我终于咬紧牙关，改走了。我们会想念你的，Rust:我非常喜欢写 Rust 代码。我觉得它美丽而富有表现力，实用而优雅。

如果我正在编写本地助手库、性能敏感代码、任何我不需要在容器中运行的后端服务…铁锈是第一选择。尤其是在我不需要说服别人使用它的情况下。

如果有人对我的问题有任何解决方法，尤其是最后一个，请告诉我。我很想让 Rust 回到这个项目中，并愿意回到旧版本，使它达到同等水平。

感谢阅读！

# 分级编码

感谢您成为我们社区的一员！在你离开之前:

*   👏为故事鼓掌，跟着作者走👉
*   📰查看[级编码出版物](https://levelup.gitconnected.com/?utm_source=pub&utm_medium=post)中的更多内容
*   🔔关注我们:[推特](https://twitter.com/gitconnected) | [LinkedIn](https://www.linkedin.com/company/gitconnected) | [时事通讯](https://newsletter.levelup.dev)

🚀👉 [**加入升级人才集体，找到一份惊艳的工作**](https://jobs.levelup.dev/talent/welcome?referral=true)