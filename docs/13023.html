<html>
<head>
<title>The Generic Way to Implement a Heap in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Golang中实现堆的一般方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-generic-way-to-implement-a-heap-in-golang-8de25b37efc2?source=collection_archive---------2-----------------------#2022-08-01">https://levelup.gitconnected.com/the-generic-way-to-implement-a-heap-in-golang-8de25b37efc2?source=collection_archive---------2-----------------------#2022-08-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7751" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用泛型实现堆数据结构</h2></div><p id="af18" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">堆是计算机科学中的一种基本数据结构。这篇文章展示了如何在Golang中使用泛型从头开始实现heap。</p><p id="43bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完整的代码是<a class="ae le" href="https://github.com/jerryan999/gostruct/blob/main/maxheap.go" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><h1 id="43c3" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">什么是堆</h1><p id="cc65" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">Heap通常用一个数组来实现，我们可以把它看作一棵近乎完整的二叉树。</p><p id="0fbe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">树的每个节点对应于数组的一个元素。该树在除了最低层之外的所有层上被填充，从左向上填充到一个点。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/eb1d56fdd2f626cdd7e5fbbee1efd77f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lkbw-no8MhWGeD7P_0pLnQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">Minheap与Maxheap</figcaption></figure><p id="939a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有两种二进制堆:最大堆和最小堆。它们分别具有不同的堆属性。</p><p id="e28c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，max-heap属性如下所示:</p><ul class=""><li id="d9c2" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated">节点的值最多是其父节点的值。</li><li id="2dcf" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">存储在树根处的最大元素</li></ul><h1 id="1ef6" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">连接到其他节点</h1><p id="167e" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">给定一个节点的索引<em class="ng"> i </em>，我们可以快速计算它的父节点、左节点和右节点的索引。</p><ul class=""><li id="1ab2" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated">左侧子索引:<em class="ng"> 2i + 1 </em></li><li id="1ccb" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">右子索引:<em class="ng"> 2i +2 </em></li><li id="2e62" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">母指数:<em class="ng">楼层((i-1)/2) </em></li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nh"><img src="../Images/5a39ec7cbb8da74e7c8fb9733be15c12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ypYzt8fH3qMWOgMG24PBNQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">堆中左侧和右侧父级的索引</figcaption></figure><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="59da" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">主数据结构</h1><p id="75da" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我们使用下面的struct类型来表示堆，以便于重用和类型安全。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ni nj l"/></div></figure><ul class=""><li id="7eaf" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated">底层切片<code class="fe nk nl nm nn b">data</code>存储实际值</li><li id="e4d3" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">函数<code class="fe nk nl nm nn b">comp</code>比较两个值，如果a小于b，则返回<code class="fe nk nl nm nn b">true</code></li><li id="949a" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">函数<code class="fe nk nl nm nn b">NewHeap</code>返回一个新的堆给定比较函数</li></ul><p id="293e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在深入研究堆实现之前，需要提到三个基本函数。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ni nj l"/></div></figure><ul class=""><li id="649e" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated"><code class="fe nk nl nm nn b">swap</code>函数交换堆中数据片的索引I和j处的值</li><li id="ae88" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated"><code class="fe nk nl nm nn b">Peek</code>返回堆的顶部值，但不删除它</li><li id="787c" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated"><code class="fe nk nl nm nn b">Size</code>返回元素的总数</li></ul><h1 id="9dc5" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">推送项目</h1><p id="61e7" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">对于一个数据结构，插入和删除是两个基本操作。当我们将一个项目推入堆中时，我们需要为堆结构维护堆属性。</p><p id="47f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们首先实现max-heap的插入操作</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="55f3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe nk nl nm nn b">Push</code>函数中，我们首先将新值附加到数据片的末尾，然后使用<code class="fe nk nl nm nn b">heapifyUp</code>来维护堆属性。</p><p id="5a70" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nk nl nm nn b">heapifyUp</code>将索引<code class="fe nk nl nm nn b">i</code>处的值向上移动到其正确位置。请记住，它假设除了I之外，其他值已经处于正确的位置。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi no"><img src="../Images/487dff52011314294d3a26088e5e7b99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JjHDVkp_PUAm-XJFOLSH_Q.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">将项目推入堆中</figcaption></figure><h1 id="4601" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">流行项目</h1><p id="2334" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">现在，是时候实现堆的移除操作了。</p><p id="5a00" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，我们有两个主要功能:</p><ul class=""><li id="84ed" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated">函数<code class="fe nk nl nm nn b">Pop</code>从堆中移除顶值并返回它</li><li id="e987" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">函数<code class="fe nk nl nm nn b">heapifyDown</code>将索引<code class="fe nk nl nm nn b">i</code>处的值向下移动到堆中正确的位置</li></ul><p id="519d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请记住，<code class="fe nk nl nm nn b">heapifyDown(i int)</code>假设以左(I)和右(I)为根的左右二叉树都是最大堆。</p><p id="d8f5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是索引<code class="fe nk nl nm nn b">i</code>处的值可能小于其子级，因此违反了max-heap属性。维护财产是<code class="fe nk nl nm nn b">heapifyDown</code>的工作。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi np"><img src="../Images/8da02372a7b2449f9679e5ba28a151fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4PpSsRuQdMuaolwbAbM1qQ.png"/></div></div></figure><p id="4bae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是代码。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="bb14" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">测试</h1><p id="2c9a" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">这里我列出了堆应用程序的三个测试案例。有空可以去看看。</p><ol class=""><li id="557e" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld nq my mz na bi translated"><a class="ae le" href="https://gist.github.com/jerryan999/a0ed9688c7f3d7ed25444f89d9809063?file=testing_int.go" rel="noopener ugc nofollow" target="_blank">测试int堆</a></li><li id="e3d5" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld nq my mz na bi translated"><a class="ae le" href="https://gist.github.com/jerryan999/a0ed9688c7f3d7ed25444f89d9809063?file=testing_custom.go" rel="noopener ugc nofollow" target="_blank">测试自定义结构堆</a></li><li id="83e1" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld nq my mz na bi translated"><a class="ae le" href="https://gist.github.com/jerryan999/a0ed9688c7f3d7ed25444f89d9809063?file=testing_minheap.go" rel="noopener ugc nofollow" target="_blank">测试最小堆</a></li></ol></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="6d39" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望你喜欢读这篇文章。如果你愿意支持我成为一名作家，可以考虑注册<a class="ae le" href="https://jerryan.medium.com/membership" rel="noopener">成为一名媒体成员</a>。你还可以无限制地访问媒体上的每个故事。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="385a" class="lf lg it bd lh li ny lk ll lm nz lo lp jz oa ka lr kc ob kd lt kf oc kg lv lw bi translated">分级编码</h1><p id="e44e" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="daf9" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="0775" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">📰查看<a class="ae le" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="c9e2" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">🔔关注我们:<a class="ae le" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae le" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae le" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="9b3e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">🚀👉<a class="ae le" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>