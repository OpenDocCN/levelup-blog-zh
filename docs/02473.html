<html>
<head>
<title>Learning Go: Arrays and Two Array Processing Templates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习Go:数组和两个数组处理模板</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-go-arrays-and-two-array-processing-templates-65a33afb577b?source=collection_archive---------13-----------------------#2020-03-15">https://levelup.gitconnected.com/learning-go-arrays-and-two-array-processing-templates-65a33afb577b?source=collection_archive---------13-----------------------#2020-03-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f8998d0e24f3d75efd6d1b4c12ad299c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yIv6E-6yHzcTh1Jf"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kf" href="https://unsplash.com/@m47h4r?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Mazhar Zandsalimi </a>拍摄的照片</figcaption></figure><p id="956b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我将讨论如何在Go中使用数组。数组不是大多数Go程序员选择的数据结构；切片是。但是为了理解如何使用切片，我们必须理解如何使用数组，所以本文将演示如何创建和使用数组。</p><p id="3ec4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同时，我将向您展示两个与数组相关的编程模板— <em class="le">填充数组</em>和<em class="le">处理数组</em>的每个元素。</p><h1 id="39f8" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">声明Go数组</h1><p id="3df3" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">像大多数其他编程语言中的数组一样，Go数组是相同类型的固定长度数据序列。使用下标符号访问数组元素，Go数组的索引从0开始，经过比数组长度小1的位置。</p><p id="cd8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Go中的数组使用以下语法模板声明:</p><p id="6f24" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">var array-name[number-of-elements]data-type<br/>var array-name[number-of-elements]data-type { initializer-list }<br/>var array-name[…]data-type { initializer-list }</em></p><p id="8cea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一个语法模板表明，当你使用初始化列表时，你可以在括号中放一个省略号，编译器将通过计算初始化列表中的元素来决定数组的大小。</p><p id="1907" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一些声明数组的代码示例:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="8509" class="mr lg it mn b gy ms mt l mu mv">var numbers[10] int<br/>var floats[20] float64<br/>var names[…] string{"Cynthia", "Jonathan", "Danny", "Raymond"}<br/>grades[3] := int{81, 77, 92}</span></pre><h1 id="bcd4" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用填充数组模板填充数组</h1><p id="8cc2" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">如果数组没有用初始化列表声明，你必须用数据填充数组。<em class="le">填充数组</em>模板可以帮助完成这项任务。以下是模板:</p><p id="123a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">将数组索引变量设置为0 <br/>当有更多输入时，执行以下操作:<br/>读取一个值<br/>将该值存储在索引数组位置<br/>将索引变量增加1 </em></p><p id="e3bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">填充一个数组最简单的方法是用一个初始化列表，就像我在上一节中展示的那样。但是，对于大量的数据或者如果您希望交互式地输入数据，这是不切实际的。让我们首先看看如何通过用户输入来填充数组。</p><p id="1e64" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个程序，它声明一个由5个整数组成的数组，并提示用户输入数组元素:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="9670" class="mr lg it mn b gy ms mt l mu mv">func main() {<br/>  const size = 5<br/>  var numbers[size] int<br/>  var num int<br/>  for i := 0; i &lt; size; i++ {<br/>    fmt.Print("Enter number: ")<br/>    fmt.Scan(&amp;num)<br/>    numbers[i] = num<br/>  }<br/>}</span></pre><p id="1135" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我喜欢用数据填充数组的方法之一是使用随机数。这比手动输入数据要容易得多，尤其是当数组元素只是测试程序其他部分所需的虚拟值时。</p><p id="c710" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是填充数组的另一个示例，这次使用随机数生成:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="f0bd" class="mr lg it mn b gy ms mt l mu mv">func main() {<br/>  const size = 5<br/>  var numbers[size] int<br/>  seed := rand.NewSource(time.Now().Unix())<br/>  rng := rand.New(seed)<br/>  for i := 0; i &lt; size; i++ {<br/>    numbers[i] = rng.Intn(100)<br/>  }<br/>  fmt.Print(numbers)<br/>}</span></pre><p id="47f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一行演示了我最喜欢的Go特性之一——打印数组而不遍历它的能力，就像在Python和JavaScript等语言中一样。</p><h1 id="e54d" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">处理一维数组的每个元素</h1><p id="1380" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">一旦用数据填充了数组，就可以在执行某些操作时访问元素了。最常见的方法是使用一个<code class="fe mw mx my mn b">for</code>循环，通过索引访问每个数组元素。</p><p id="90bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该模板的伪代码如下所示:</p><p id="3d2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">用于将索引设置为0；在最后一个元素处停止；将index增加1: <br/>对数组元素[index]做些什么</em></p><p id="fbf3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个程序，它创建一个由10个整数(随机生成)组成的数组，然后对数组元素求和，计算并显示数组元素的平均值:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="d586" class="mr lg it mn b gy ms mt l mu mv">func main() {<br/>  const size = 10<br/>  var numbers[size] int<br/>  seed := rand.NewSource(time.Now().Unix())<br/>  rng := rand.New(seed)<br/>  for i := 0; i &lt; size; i++ {<br/>    numbers[i] = rng.Intn(100)<br/>  }<br/>  fmt.Println(numbers)<br/>  var total int<br/>  for i := 0; i &lt; size; i++ {<br/>    total += numbers[i]<br/>  }<br/>  average := float64(total) / float64(size)<br/>  fmt.Printf("The average value is %.2f.", average)<br/>}</span></pre><p id="3e20" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用基于索引的循环的问题是，您可能会意外地超出数组的界限，这将导致go中出现混乱(错误)。对此的解决方案是使用一个<code class="fe mw mx my mn b">range for</code>循环来访问数组元素。</p><p id="3c08" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们讨论这种循环类型之前，让我们检查一下带有范围类型循环的模板的伪代码:</p><p id="3439" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">对于数组的每个元素:<br/>对元素做一些事情</em></p><p id="4f8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mn b">range for</code>循环用于迭代一定范围的值，比如一个数组的所有元素，这样就不会意外地试图访问数组末尾以外的值。<code class="fe mw mx my mn b">range for</code>循环的语法模板如下所示:</p><p id="af44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">对于索引值，变量:=范围数据结构{ <br/>语句<br/> } </em></p><p id="e3fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您会注意到<code class="fe mw mx my mn b">range for</code>循环返回两个值，每个数组元素的索引和数组元素本身。如果需要，可以使用索引值，但通常不需要，所以可以使用下划线字符将该值丢弃。</p><p id="0134" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们修改上面的程序，使用一个<code class="fe mw mx my mn b">range for</code>循环来访问数组元素。代码如下:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="1eaf" class="mr lg it mn b gy ms mt l mu mv">func main() {<br/>  const size = 10<br/>  var numbers[size] int<br/>  seed := rand.NewSource(time.Now().Unix())<br/>  rng := rand.New(seed)<br/>  for i := 0; i &lt; size; i++ {<br/>    numbers[i] = rng.Intn(100)<br/>  }<br/>  fmt.Println(numbers)<br/>  var total int<br/>  for _, number := range numbers {<br/>    total += number<br/>  }<br/>  average := float64(total) / float64(size)<br/>  fmt.Printf("The average value is %.2f.", average)<br/>}</span></pre><p id="175f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Go中的<code class="fe mw mx my mn b">range for</code>就像C++中的<code class="fe mw mx my mn b">range for </code>和JavaScript中的<code class="fe mw mx my mn b">for-of</code>循环。大多数编程专家现在建议，除非有某种原因需要使用索引<code class="fe mw mx my mn b">for</code>循环来访问数组，否则应该使用<code class="fe mw mx my mn b">range for</code>循环来访问数组，以避免程序中出现越界错误。</p><h1 id="a404" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">处理数组所有元素的建议</h1><p id="7c27" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">我已经展示了两个模板和两种处理数组所有元素的技术。我还提到使用一个<code class="fe mw mx my mn b">range for</code>循环来处理一个数组的所有元素是实现这个模板的首选方法。在他的书《有效的Java》中，Joshua Bloch建议他的读者避免使用索引循环。他演示了在一个典型的索引<code class="fe mw mx my mn b"> for</code>循环中，索引变量是如何被多次使用的，每次都有出错的机会。他还提到了索引变量是如何弄乱你的代码的。另一方面,<code class="fe mw mx my mn b">range for</code>循环清理了混乱，消除了出错的可能性，因为根本没有使用索引变量。</p><p id="1c3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们都应该听从布洛赫的建议，当<code class="fe mw mx my mn b">range for</code>循环同样有效时，停止使用索引<code class="fe mw mx my mn b">for </code>循环。</p><p id="2f3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您阅读这篇文章，如果您有任何意见或建议，请发邮件给我。</p></div></div>    
</body>
</html>