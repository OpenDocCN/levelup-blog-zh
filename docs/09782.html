<html>
<head>
<title>How to Build a Min/Max Heap in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Go中构建最小/最大堆</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-a-min-max-heap-in-go-5090617a3142?source=collection_archive---------1-----------------------#2021-09-13">https://levelup.gitconnected.com/how-to-build-a-min-max-heap-in-go-5090617a3142?source=collection_archive---------1-----------------------#2021-09-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0c97" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">包括一个单元测试的示例面试问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/40918d8c7b2294a84bde8f6b7fa7799b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hc9-Mq0bbhuJDE_e"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">从<a class="ae ky" href="https://images.unsplash.com/photo-1547637589-f54c34f5d7a4?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1650&amp;q=80" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="31c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">对于任何软件工程师来说，EAP都是一个基本的数据结构。不一定是因为你会在工作中用到它，更有可能是因为你需要知道它，以便<em class="me">得到</em>一份工作。玩笑归玩笑，我认为对软件工程师来说，熟悉常见的数据结构和算法是很重要的。它们让你思维敏捷，让你成为一个全面的问题解决者。</p><blockquote class="mf mg mh"><p id="c354" class="kz la me lb b lc ld ju le lf lg jx lh mi lj lk ll mj ln lo lp mk lr ls lt lu im bi translated">学习DS &amp; Algorithms与物理学家或数学家转型成为一名真正优秀的程序员有着相同的好处——不同类型的问题解决技能总是会相互补充！</p></blockquote><p id="a012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">话虽如此，让我们深入了解一下Go中的最小/最大堆。我们将首先通过构造一个堆来理解堆。然后我们会看到为什么堆可以帮助我们用<strong class="lb iu"> K个最接近原点的点</strong>面试问题来最优地解决某些问题。我们开始吧！</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="f19b" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">在Go中创建最小/最大堆</h1><p id="efac" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">堆是一种数据结构，基本上是二叉树的一种特殊形式。一个重要的行为是堆可以在树的根处维护对象列表<em class="me">的最小值或最大值。堆可以通过您自己声明的节点对象来表示，或者在数组中表示。这是一个巨大的好处，因为我们可以在没有任何额外内存的情况下执行常见的堆操作。</em></p><h2 id="a197" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">heapify算法</h2><p id="aadc" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">heapify操作接受一个随机排序的数组，并给它一个堆的结构。这是什么意思？记住，堆可以被形象地想象成一棵二叉树。我们用索引来表示树中每个节点的左右子节点。下面是我们对每个节点使用的公式:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="bf2c" class="np mt it oc b gy og oh l oi oj"><strong class="oc iu">Root</strong> is at index 0 of the array.<br/><strong class="oc iu">Left child</strong> of index i is at (2*i + 1).<br/><strong class="oc iu">Right child</strong> of index i is at (2*i + 2).<br/><strong class="oc iu">Parent</strong> of index i is at (i-1)/2.</span><span id="9b89" class="np mt it oc b gy ok oh l oi oj"><strong class="oc iu">Example</strong>:<br/>Input: []int{4, 12, 3, 6, 5}<br/>Max-Heap: []int{12,6,3,4,5}<br/>        12<br/>       /  \<br/>      6    3<br/>     / \<br/>    4   5</span></pre><p id="57fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们实际上并没有对数组进行排序，但是我们给了数组一个堆的属性。<strong class="lb iu">这也不是唯一的堆</strong>，因为我们可以有不同的排序，只要每个父堆的值大于其子堆的值。</p><p id="4cd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以转到heapify算法。Heapify会递归地将数组组织成一个堆结构。像对待递归一样，最重要的是关注规则和条件— <em class="me">尽管画出递归栈对理解也非常有用。</em></p><p id="f1fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子是一个最小堆。Heapify将接受一个指向数组的指针。我们传递一个对数组的引用，因为如果我们不这样做，Go将在递归堆栈中创建本地副本，我们希望对输入数组的稳定状态进行操作。第二个参数<code class="fe ol om on oc b">i</code>将是我们想要填充的当前索引。</p><p id="e53e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将一个新变量<code class="fe ol om on oc b">smallest</code>赋给当前索引，同时根据堆公式分配我们的左右子节点。然后，我们有条件地检查左边的子元素是否在堆的边界内。如果是这样，我们有额外的条件来检查左边孩子的值是否小于<code class="fe ol om on oc b">smallest</code>的值。如果是，我们设置<code class="fe ol om on oc b">smallest</code>等于左边的孩子。</p><p id="4688" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们对正确的孩子重复同样的过程。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="8a93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们发现需要对数组进行<code class="fe ol om on oc b">heapify</code>操作，例如<code class="fe ol om on oc b">smallest != i</code>，那么我们交换数组元素<code class="fe ol om on oc b">smallest</code>和当前索引<code class="fe ol om on oc b">i</code>。最后，我们将递归调用<code class="fe ol om on oc b">heapify</code>，为<code class="fe ol om on oc b">smallest</code>传递新值。</p><blockquote class="mf mg mh"><p id="75de" class="kz la me lb b lc ld ju le lf lg jx lh mi lj lk ll mj ln lo lp mk lr ls lt lu im bi translated">每个heapify操作需要O(logN)时间，因为我们必须在最坏的情况下筛选树的高度。根据您调用heapify的方式，您可以从O(NlogN)或O(N)时间复杂度的数组构建一个堆，我们将在下面看到。</p></blockquote><p id="6518" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这仍然令人困惑，这里有一个有用的视频。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq op l"/></div></figure><h2 id="d926" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">从数组构建堆</h2><p id="83ec" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">现在我们有了heapify算法，我们必须构建一个helper方法来调用我们的输入数组。有两种方法可以堆一个数组。要么从堆的根(数组的开头)开始，一直到叶节点，要么从叶节点(数组的结尾)开始，一直到根。</p><p id="3817" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，基于数组的堆的最后一个非叶节点是堆的长度除以2减1，这是我们设置的startIdx。我们从这里开始，因为叶节点不违反堆的属性，它们隐式地大于/小于它们不存在的子节点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="f8a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">以这种方式堆化保证我们堆化数组的时间复杂度为O(N)</strong>,而不是O(NlogN)。如需进一步解释，请查看以下StackOverflow帖子:</p><div class="or os gp gr ot ou"><a href="https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">构建一个堆怎么可能是O(n)时间复杂度？</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">我认为这个主题中埋藏了几个问题:如何实现buildHeap，使其在O(n)时间内运行？怎么…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">stackoverflow.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ks ou"/></div></div></a></div><h2 id="b464" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">从堆中弹出最小/最大元素</h2><p id="7fc7" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">我们可以在堆上执行额外的操作，但是我将只解释pop函数，因为我们将在示例编码问题中使用它。从堆中弹出将根据你拥有的是最小堆还是最大堆，给出数组中最小或最大的元素。</p><p id="c4b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只需要确保在得到根元素后，我们把它从数组中移除并重新填充。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="06ec" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">一个示例面试问题+单元测试</h1><p id="f16b" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">现在我们已经有了如何给定一个数组构造一个堆的基础，让我们把它应用到一个编码面试问题中。最常见的K个问题非常普遍，被大多数面试准备网站标记为中等难度。</p><h2 id="a062" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">k个离原点最近的点</h2><p id="b57f" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">给定一个点的2D数组，求每个点的欧几里德距离，并返回k个离原点最近的点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/61177b00d2617a2f5bbfb809ddcbb446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6uB3F84aCptMf3sI5lh3ZQ.png"/></div></div></figure><p id="8ad0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到几何学，你可以用公式<code class="fe ol om on oc b">dist = sqrt((x2-x1)² + (y2-y1)²)</code>求出两点之间的距离。</p><p id="af5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们在寻找离原点的距离，x1和y1都是零。此外，我们只能得到整数，并保证没有两点到原点的距离是相同的。考虑到这些条件，我们只要利用简化的公式<code class="fe ol om on oc b">dist = x² + y²</code>就可以求出各点的距离。</p><p id="8565" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们为解决这个问题而调整的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><h2 id="db65" class="np mt it bd mu nq nr dn my ns nt dp nc li nu nv ne lm nw nx ng lq ny nz ni oa bi translated">单元测试</h2><p id="ce95" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">为了更好地理解这篇文章，让我们添加一些简单的单元测试。总是知道如何测试你的代码和试图破坏它的例子是很重要的。只有三个测试，这远远不够详尽，所以试着自己想出几个测试用例吧！这些测试是在我非常喜欢的Go中以表格驱动的测试格式构建的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="51a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你做到了这一步，为你提高了编码技能并为下一次技术面试做了更好的准备而感到欣慰。如果您有任何问题，请在下面留下您的评论，非常感谢您的阅读！</p></div></div>    
</body>
</html>