<html>
<head>
<title>How to Write Data Processing Application in FS2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用FS2编写数据处理应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-write-data-processing-application-in-fs2-2b6f84e3939c?source=collection_archive---------14-----------------------#2020-06-04">https://levelup.gitconnected.com/how-to-write-data-processing-application-in-fs2-2b6f84e3939c?source=collection_archive---------14-----------------------#2020-06-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/21a876d29089c650746a8decf8ed5733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8hsvVOyVx0u8frRI"/></div></div></figure><p id="13b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我之前的<a class="ae kw" href="https://edward-huang.com/akka/scala/programming/functional-programming/reactive/2020/05/30/how-to-write-a-simple-data-processing-application-with-akka-actors/" rel="noopener ugc nofollow" target="_blank">文章</a>中，我讨论了如何用经典的Akka actors编写数据处理应用程序。</p><p id="c9f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我想换一种方式，使用函数式编程流库FS2来处理CSV文件中的HTTP日志，以获得日志文件中HTTP状态的数量。</p><p id="08d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我发现学习FS2，总的来说，有点难，尤其是从一个你从未听说过流的背景开始。因此，在我们开始深入代码库之前，我想先定义一个流，以及FS2中一些必要的流处理。</p><p id="0774" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意:我将在下面的代码中对效果类型cats.effect IO使用FS2。如果你有兴趣了解更多关于cats.effect <code class="fe kx ky kz la b">IO</code>的信息，请查看他们的<a class="ae kw" href="https://typelevel.org/cats-effect/datatypes/io.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h1 id="9980" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是溪流？</h1><p id="8680" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">在维基百科中，Stream的意思是某种东西的连续流动，从单一来源变成液体、空气或气体。在计算中，它说它在互联网上传输或接收(数据)是一个稳定、连续的流。</p><p id="6001" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我能想到的简单术语是迭代器，但它是类固醇。这意味着您将需要迭代无限数量的容器。在OOP中，你可以把它想象成一个迭代器，它将迭代有限或无限数量的数组。当你遍历所有这些元素时，你可以做任何疯狂的事情，并与外界互动。</p><p id="20b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">stream有很多List没有的有用特性。</p><p id="f8c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，流中的每一个元素都是延迟求值的，这意味着在编写代码时，它不会被<em class="me">急切地</em>调用，直到您命令执行它们。这个特性很重要，因为它支持加载、转换和写入大数据集，而不会破坏堆。</p><p id="f003" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二，流不会像List那样改变数据。如果你想将一个元素<code class="fe kx ky kz la b">A</code>映射到一个元素<code class="fe kx ky kz la b">B</code>，它不会改变<code class="fe kx ky kz la b">A</code>的初始值。如果您在并发环境中操作大数据集和文件，这会很有帮助。</p><p id="40d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，你可以在数据流中做很多操作，比如在中间处理器中把它和另一个数据流结合起来做IO。</p><h1 id="1146" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">基本流操作</h1><p id="2192" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">FS2有一个类型:<code class="fe kx ky kz la b">Stream[F[_], O]</code>。这意味着你得到了一个发出<code class="fe kx ky kz la b">O</code>类型的价值流。<code class="fe kx ky kz la b">F[_]</code>是效果型的。效果类型意味着，如果你与外界有某种交互，写数据库或做IO。通常，这是一个<code class="fe kx ky kz la b">IO</code>型。如果你没有任何影响，一个只影响你CPU的基本计算往往是<code class="fe kx ky kz la b">Pure</code>型。</p><p id="4039" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以像编写<code class="fe kx ky kz la b">List</code>一样编写一个流:</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="9391" class="mn lc iq la b gy mo mp l mq mr">Stream(1,2,3)</span></pre><p id="024c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您创建上面的<code class="fe kx ky kz la b">Stream</code>时，它只创建了一个流的<code class="fe kx ky kz la b">Pure</code>类型构造函数。它还没有运行程序；您正在描述您的应用程序。这意味着你需要显式地执行它，要么通过做<code class="fe kx ky kz la b">Stream(1,2,3).toList</code>把它转换成一个列表。</p><h1 id="414f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建一个有效的流</h1><p id="91a5" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">您可以创建一个包含效果的流并执行它:</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="713b" class="mn lc iq la b gy mo mp l mq mr">Stream(1,2,3).covary[IO].compile.toList.unsafeRunSync()</span></pre><p id="815d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码描述了你将这个流提升到一个<code class="fe kx ky kz la b">IO</code>效果类型。然后，您想通过调用<code class="fe kx ky kz la b">compile</code>将流执行成一个效果类型。然后，我们通过运行<code class="fe kx ky kz la b">toList</code>将效果转换为<code class="fe kx ky kz la b">List</code>。到那时，流的性质就是<code class="fe kx ky kz la b">IO(List(1,2,3))</code>。我们仍然需要通过运行<code class="fe kx ky kz la b">unsafeRunSync</code>来提升IO，以获得<code class="fe kx ky kz la b">List(1,2,3)</code>。</p><h1 id="ede5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">资源安全</h1><p id="cb5b" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">FS2提供了<code class="fe kx ky kz la b">brackets</code>或<code class="fe kx ky kz la b">resources</code>与文件交互。这些类似于<a class="ae kw" href="https://typelevel.org/cats-effect/datatypes/resource.html" rel="noopener ugc nofollow" target="_blank"> cats effect </a> <code class="fe kx ky kz la b">IO</code>，可以分配资源，然后释放资源，而不管分配过程中发生了什么问题。</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="d7d1" class="mn lc iq la b gy mo mp l mq mr">Stream.brackets {<br/>  IO {<br/>    new BufferedReader(new FileReader(new File("yourfile.txt")))<br/>  }<br/>}(f =&gt; IO(f.close()))</span></pre><p id="f3e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码描述了如何获取资源并随后释放它们的操作。</p><h1 id="dc67" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">处理无限流</h1><p id="e9b5" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">创造无限量的恒定流<code class="fe kx ky kz la b">constant</code>。为了限制<code class="fe kx ky kz la b">chunks</code>的数量或价值，我们要从源头上拉起，<code class="fe kx ky kz la b">take</code>:</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="3365" class="mn lc iq la b gy mo mp l mq mr">Stream.constant(42).take(5).toList<br/> <em class="me">// res0: List(42,42,42,42,42)</em></span></pre><p id="1e0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它将从一个无限纯净的流中获取五种元素，该流发出42。</p><h1 id="3d94" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">并行处理</h1><p id="fc82" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">要创建多个并发处理，我们可以使用<code class="fe kx ky kz la b">parEvalMap(nWorker:Int)(f:A =&gt; F[A1])</code>。对于熟悉Akka stream <code class="fe kx ky kz la b">mapAsync</code>的人也有相同的语法。</p><p id="90cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它创建<code class="fe kx ky kz la b">nWorker</code>线程并处理流。<code class="fe kx ky kz la b">parEvalMap</code>将按顺序返回下游。在底层，它使用<code class="fe kx ky kz la b">fs2.concurrent.Queue</code>并发执行和维护对下游的请求。</p><p id="a151" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在FS2中，您可以使用更多的操作。如果你有兴趣，可以看看这个<a class="ae kw" href="https://fs2.io/documentation.html" rel="noopener ugc nofollow" target="_blank">指南</a>。</p><p id="fb42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以使用FS2处理数据了。</p><h1 id="3eec" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">思维过程</h1><p id="bffe" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">我们想从<code class="fe kx ky kz la b">weblog.csv</code>获取数据。我们对传入的数据进行了净化，过滤掉了所有无效的IP。然后，我们想把它发送给工人并处理数据，把它转换成一个<code class="fe kx ky kz la b">Log</code>实例。最后，我们统计日志中的HTTP状态，并将其写入<code class="fe kx ky kz la b">out.txt</code>文件。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/a96a35d03105aaa23459434c94b385c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bXjjbBfm6d7fc8os.png"/></div></div></figure><h1 id="038e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">执行</h1><p id="68df" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">让我们从上到下开始。下面是主要功能:</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="6bcc" class="mn lc iq la b gy mo mp l mq mr">object Main extends IOApp with Processor {<br/><br/>  def run(args: List[String]): IO[ExitCode] = {<br/><br/>    processData("/weblog.csv", "/out.txt", 100).compile.drain.map(_ =&gt; ExitCode.Success)<br/>  }<br/>}</span></pre><p id="b2ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">processData</code>将提供一个<code class="fe kx ky kz la b">source</code>文件，<code class="fe kx ky kz la b">/weblog.csv</code>，而<code class="fe kx ky kz la b">sink</code>文件，<code class="fe kx ky kz la b">/out.txt</code>带有它将生成的parallelisms的数目。然后，在描述了函数<code class="fe kx ky kz la b">processData</code>之后，我们将需要通过调用<code class="fe kx ky kz la b">compile.drain</code>来执行它。</p><p id="3f8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">drain</code>从流中删除所有值并执行它。一旦所有的数量都从流中发出，我们将在结果中得到一个单独的<code class="fe kx ky kz la b">Unit</code>，因为我们将把它写到<code class="fe kx ky kz la b">processData</code>函数中的<code class="fe kx ky kz la b">out.txt</code>中。</p><p id="78b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用<code class="fe kx ky kz la b">Stream.resource</code>来获取和释放资源:</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="eb11" class="mn lc iq la b gy mo mp l mq mr">Stream.resource(Blocker[IO]).flatMap {  blocker =&gt;<br/>  val inResource = getClass.getResource(in)<br/>  val outResource = getClass.getResource(out)<br/>  io.file<br/>    .readAll[IO](Paths.get(inResource.toURI), blocker, 4096)<br/>    .through(text.utf8Decode)<br/>    .through(text.lines)<br/>    ..... <em class="me">// our processing logic here</em><br/>    .through(text.utf8Encode)<br/>    .through(io.file.writeAll(Paths.get(outResource.toURI), blocker))<br/>  <br/>}</span></pre><p id="7d5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码创建了一个<code class="fe kx ky kz la b">inResource and </code> outResource <code class="fe kx ky kz la b"> to read and write data to the file. It reads the data from the file line by line, by first decoding the bytes to UTF8, and then encoding it again to UTF8 and writes incrementally to </code> out.txt`。</p><p id="8a05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一行日志的样子:</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="d768" class="mn lc iq la b gy mo mp l mq mr">10.128.2.1,[29/Nov/2017:06:58:55,GET /login.php HTTP/1.1,200</span></pre><p id="9f6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有一个<code class="fe kx ky kz la b">...</code>,我们将在思考过程中填写所有的操作。</p><p id="df72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在此之前，这是每个工人将转换成的<code class="fe kx ky kz la b">Log</code>和<code class="fe kx ky kz la b">Date</code>模型:</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="d6df" class="mn lc iq la b gy mo mp l mq mr">case class Log(ip: String, time: Date, url: String, status: String)<br/>  case class Date(year: Int, month: String, date: Int, time: String)</span></pre><h1 id="1126" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">处理逻辑</h1><h2 id="3b45" class="mn lc iq bd ld mt mu dn lh mv mw dp ll kj mx my lp kn mz na lt kr nb nc lx nd bi translated">过滤无效IP</h2><p id="9009" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">一旦我们从文件中得到每一行，我们将过滤掉无效的IP地址:</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="fd4f" class="mn lc iq la b gy mo mp l mq mr">filter(isValidIp) <em class="me">// filter out valid IP</em></span></pre><p id="b87f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">isValidIp</code>该函数如下所示:</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="4c29" class="mn lc iq la b gy mo mp l mq mr">def isValidIp(line: String): Boolean = {<br/>    val ipRegex: Regex = """.*?(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3}).*""".r<br/>    ipRegex.pattern.matcher(line.split(",")(0)).matches()<br/>  }</span></pre><h2 id="f1f9" class="mn lc iq bd ld mt mu dn lh mv mw dp ll kj mx my lp kn mz na lt kr nb nc lx nd bi translated">向员工发送行</h2><p id="e8a1" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">我们将过滤后的每一行发送给工人，这样他们就可以将它们转换成<code class="fe kx ky kz la b">Log</code>模型。</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="95ff" class="mn lc iq la b gy mo mp l mq mr">.parEvalMapUnordered(parallelism)(convertToLog)</span></pre><p id="1eae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">convertToLog</code>该函数如下所示:</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="113a" class="mn lc iq la b gy mo mp l mq mr">def convertToLog(line: String): IO[Log] = line.split(",").toList match {<br/>    case ip :: time :: url :: status :: _ =&gt;<br/>      IO(Log(ip, convertToDate(time), url, status))<br/>  }</span></pre><h2 id="f7a8" class="mn lc iq bd ld mt mu dn lh mv mw dp ll kj mx my lp kn mz na lt kr nb nc lx nd bi translated">计数HTTP状态代码</h2><p id="1a95" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">一旦工人完成转换成日志，它将通过折叠阶段。在折叠阶段，我们用<code class="fe kx ky kz la b">status -&gt; number of status</code>将HTTP状态的数量分组到一个映射中。</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="d14f" class="mn lc iq la b gy mo mp l mq mr">flatMap { m =&gt;<br/>          Stream.fromIterator[IO](m.keys.map { key =&gt;<br/>            s"Status : ${key} has a total of ${m(key)} amount "<br/>          }.iterator)<br/>        }</span></pre><h2 id="45db" class="mn lc iq bd ld mt mu dn lh mv mw dp ll kj mx my lp kn mz na lt kr nb nc lx nd bi translated">一起</h2><p id="cfc1" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">总而言之，如果我们把所有的逻辑放在一起，就会变成这样的东西:</p><pre class="mf mg mh mi gt mj la mk ml aw mm bi"><span id="fa73" class="mn lc iq la b gy mo mp l mq mr">io.file<br/>        .readAll[IO](Paths.get(inResource.toURI), blocker, 4096)<br/>        .through(text.utf8Decode)<br/>        .through(text.lines)<br/>        .filter(isValidIp)<br/>        .parEvalMapUnordered(parallelism)(convertToLog)<br/>        .fold(Map.empty[String, Int]) { (map, currLog) =&gt;<br/>          val updatedStatus = map.getOrElse(currLog.status, 0) + 1<br/>          map + (currLog.status -&gt; updatedStatus)<br/>        }<br/>        .flatMap { m =&gt;<br/>          Stream.fromIterator[IO](m.keys.map { key =&gt;<br/>            s"Status : ${key} has a total of ${m(key)} amount "<br/>          }.iterator)<br/>        }<br/>        .through(text.utf8Encode)<br/>        .through(io.file.writeAll(Paths.get(outResource.toURI), blocker))</span></pre><p id="3df8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也可以在流的外部进行折叠，然后写入<code class="fe kx ky kz la b">out.txt</code>文件。从这个意义上说，我们需要为writeAll操作获取和释放资源。</p><h1 id="80e5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">摘要</h1><p id="d4c1" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">在这些文章中，我们会涉及到复杂的流处理库FS2。</p><p id="b1b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们讨论什么是流，以及它与列表有何不同。我们还讨论了流的基本操作。然后，我们深入探讨如何用FS2创建数据处理应用程序。</p><p id="a68e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里是完整的源代码<a class="ae kw" href="https://github.com/edwardGunawan/Data-Processing/blob/master/dataprocessingfs2/src/main/scala/com/notetoself/example/Processor.scala" rel="noopener ugc nofollow" target="_blank">代码</a>。</p><p id="7454" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您有兴趣了解有关FS2的更多信息，请查看以下资源:</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="6977" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="me">原载于</em><a class="ae kw" href="https://edward-huang.com/functional-programming/etl/scala/2020/06/02/how-to-write-data-processing-application-in-fs2/" rel="noopener ugc nofollow" target="_blank"><em class="me">https://edward-huang.com</em></a><em class="me">。</em></p></div></div>    
</body>
</html>