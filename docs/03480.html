<html>
<head>
<title>JavaScript Best Practices for Writing More Robust Code — Async Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更健壮代码的JavaScript最佳实践——异步代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-for-writing-more-robust-code-async-code-258086a1a237?source=collection_archive---------15-----------------------#2020-05-11">https://levelup.gitconnected.com/javascript-best-practices-for-writing-more-robust-code-async-code-258086a1a237?source=collection_archive---------15-----------------------#2020-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/782be2da41f2efdb62795706cce1a44e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ug823xy_HqsKb6kj"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Lionel HESRY 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="b2d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种简单易学的编程语言。编写运行并执行某些操作的程序很容易。然而，很难考虑所有的用例并编写健壮的JavaScript代码。</p><p id="f010" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究用Javascript编写异步代码的最佳实践。</p><h1 id="ba0a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用承诺</h1><p id="efa6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">承诺对于用JavaScript编写异步代码非常有用，因为我们可以将多段异步代码链接在一起，而无需嵌套多个异步回调。</p><p id="b26b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不能嵌套太多的异步回调，因为它很难阅读和理解。因此，很容易产生bug，做出改变也会很慢。</p><p id="f43c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了承诺，我们可以将多个承诺链接在一起，让编写一系列异步代码变得非常容易。</p><p id="085c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写以下代码将多个承诺链接在一起，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="aaf2" class="mq lf it mm b gy mr ms l mt mu">Promise.resolve(1)<br/>  .then(val =&gt; Promise.resolve(val * 2))<br/>  .then(val =&gt; Promise.resolve(val * 3))</span></pre><p id="b6ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们调用了<code class="fe mv mw mx mm b">Promise.resolve</code>，它是异步的，返回一个承诺。每个<code class="fe mv mw mx mm b">Promise.resolve</code>调用都在事件循环的末尾排队，并在JavaScript主执行线程没有任何排队任务时运行。</p><p id="7fd8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们上面做的链接比嵌套回调要干净得多。<code class="fe mv mw mx mm b">val</code>只是从之前解决的承诺中获取价值。</p><p id="1c7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，我们还可以从之前解决的承诺中获取价值，并利用它做一些事情。这是嵌套回调很难做到的，因为我们必须做3层嵌套来做同样的事情。</p><p id="1395" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了捕捉执行任何承诺时发生的错误，我们可以使用回调函数调用<code class="fe mv mw mx mm b">catch</code>,如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e354" class="mq lf it mm b gy mr ms l mt mu">Promise.resolve(1)<br/>  .then(val =&gt; Promise.resolve(val * 2))<br/>  .then(val =&gt; Promise.reject('fail'))<br/>  .catch(err =&gt; console.log(err))</span></pre><p id="7598" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们调用了<code class="fe mv mw mx mm b">Promise.reject</code>，这将导致承诺链失败。<code class="fe mv mw mx mm b">Promise.reject</code>获取失败的原因，该原因将在<code class="fe mv mw mx mm b">catch</code>回调中的<code class="fe mv mw mx mm b">err</code>对象中提供。</p><p id="b177" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们将看到从承诺回调记录的<code class="fe mv mw mx mm b">'fail'</code>。</p><p id="8284" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当第一个失败的承诺运行时，承诺停止运行，因此我们在承诺链中只能有一个<code class="fe mv mw mx mm b">catch</code>调用。</p><p id="f1ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">错误处理也是嵌套异步回调所不具备的，除非接受回调的代码显式返回一个错误作为回调中的参数。</p><p id="8f1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们必须做更多的嵌套来处理嵌套异步回调中的错误，这意味着阅读代码更加困难，并产生更多的错误。</p><p id="a1df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了使承诺更短，我们可以使用<code class="fe mv mw mx mm b">async</code>和<code class="fe mv mw mx mm b">await</code>语法来链接承诺。</p><p id="b442" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写下面的代码来使用<code class="fe mv mw mx mm b">async</code>和<code class="fe mv mw mx mm b">await</code>，这样我们就可以删除<code class="fe mv mw mx mm b">then</code>和回调，但是做和以前一样的事情:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f713" class="mq lf it mm b gy mr ms l mt mu">(async () =&gt; {<br/>  const val1 = await Promise.resolve(1);<br/>  const val2 = await Promise.resolve(val1 * 2);<br/>  const val3 = await Promise.resolve(val2 * 3);<br/>})()</span></pre><p id="d7ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这比使用<code class="fe mv mw mx mm b">then</code>和回调更干净，因为现在我们的代码中没有回调，只有3行代码。此外，代码的可读性不会因为使用它而变差。</p><p id="db80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">val1</code>、<code class="fe mv mw mx mm b">val2</code>和<code class="fe mv mw mx mm b">val3</code>与<code class="fe mv mw mx mm b">then</code>回调中的参数值相同，都是解析后的值。</p><p id="d667" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了在承诺链中的承诺失败时捕捉错误，我们可以像处理同步代码一样使用<code class="fe mv mw mx mm b">try...catch</code>。</p><p id="d2e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写以下代码来捕捉带有<code class="fe mv mw mx mm b">async</code>和<code class="fe mv mw mx mm b">await</code>的承诺:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c64c" class="mq lf it mm b gy mr ms l mt mu">(async () =&gt; {<br/>  try {<br/>    const val1 = await Promise.resolve(1);<br/>    const val2 = await Promise.resolve(val1 * 2);<br/>    await Promise.reject('fail')<br/>  } catch (err) {<br/>    console.log(err)<br/>  }<br/>})()</span></pre><p id="1734" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们在promise代码周围包装了一个<code class="fe mv mw mx mm b">try...catch</code>块，这样我们就可以捕捉promise链中的错误。当承诺失败时，它停止运行，因此一个catch块将完成所有工作。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/87f83ebfb99c3b6d2c2f5d58fbcc5e47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZJr2q9JOLhR-xQpl"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">你好，我是尼克🍌上<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">下</a></figcaption></figure><h1 id="9f08" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将不相关的承诺与Promise并行运行</h1><p id="e6ef" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该使用<code class="fe mv mw mx mm b">Promise.all</code>并行运行不相关的承诺。这样，我们就不必在运行另一个不必要的承诺之前等待一个承诺的解决，从而加速我们的代码。</p><p id="a923" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">Promise.all</code>接受一个承诺数组，并返回一个包含已解析值数组的承诺。</p><p id="ef1b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写以下代码来使用<code class="fe mv mw mx mm b">Promise.all</code>:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="14ee" class="mq lf it mm b gy mr ms l mt mu">Promise.all([<br/>    Promise.resolve(1),<br/>    Promise.resolve(2),<br/>    Promise.resolve(3),<br/>  ])<br/>  .then(([val1, val2, val3]) =&gt; {<br/>    console.log(val1, val2, val3);<br/>  })</span></pre><p id="4aab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们在一个数组中有3个带有<code class="fe mv mw mx mm b">Promise.resolve</code>的承诺。然后我们用它来调用<code class="fe mv mw mx mm b">Promise.all</code>来并行解决它们。然后我们在回调中获取解析的值并记录它们。</p><p id="e948" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mv mw mx mm b">async</code>和<code class="fe mv mw mx mm b">await</code>语法，我们可以编写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a29c" class="mq lf it mm b gy mr ms l mt mu">(async () =&gt; {<br/>  const [val1, val2, val3] = await Promise.all([<br/>    Promise.resolve(1),<br/>    Promise.resolve(2),<br/>    Promise.resolve(3),<br/>  ])<br/>  console.log(val1, val2, val3);<br/>})();</span></pre><p id="8d87" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">Promise.all</code>既然一诺千金。</p><h1 id="b17b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="ba10" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当用JavaScript编写异步代码时，我们应该使用承诺。这样，它们可以很容易地链接起来，我们也可以用<code class="fe mv mw mx mm b">Promise.all</code>并行运行它们。</p><p id="f60e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">移除嵌套大大增加了可读性，因此不太可能出错。此外，错误处理是标准的，因为我们可以调用<code class="fe mv mw mx mm b">catch</code>来捕捉错误。</p><p id="8f57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">async</code>和<code class="fe mv mw mx mm b">await</code>语法缩短了链接承诺的时间。同样，我们可以用<code class="fe mv mw mx mm b">try...catch</code>来捕捉错误。</p></div></div>    
</body>
</html>