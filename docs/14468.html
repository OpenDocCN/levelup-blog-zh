<html>
<head>
<title>Use recursion cautiously</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谨慎使用递归</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/use-recursion-cautiously-5482342b9903?source=collection_archive---------10-----------------------#2022-11-29">https://levelup.gitconnected.com/use-recursion-cautiously-5482342b9903?source=collection_archive---------10-----------------------#2022-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/17f7dd506d60e61c82bfc42e636dfa6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FswJId91eSdTENCjhxM_iw.png"/></div></div></figure><p id="5b7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设你要写一个函数，把嵌套数组的每个元素都乘以一个整数。快速实现是这样的:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="e6b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的解决方案利用了函数递归技术。不管怎样，<strong class="ka ir">大多数现代编程语言和编译器都不支持递归函数调用</strong>。此外，像<em class="lc"> JavaScript </em>这样的语言取消了对函数自身调用次数的人为限制。为什么会这样呢？答案是一叠。<em class="lc">栈</em>是一个特定的内存位置(<em class="lc"> RAM </em>)，保存所有的参数和函数调用链。它在尺寸上有限制。函数递归方法过度使用堆栈内存，导致在运行大量输入时出现堆栈溢出异常。</p><p id="0443" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在需要大量输入数据的生产环境中，应该使用循环或其他替代技术重新考虑具有函数递归的位置，以尽可能避免堆栈溢出异常。</p><p id="5179" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有趣的是，一些有意设计来支持函数递归的函数语言不允许显式地应用它。例如，在<em class="lc"> Clojure </em> ( <em class="lc"> LISP </em>方言为<em class="lc"> JVM </em>)中，使用了一个名为<em class="lc">recurve</em>的特定操作符，而不是递归函数调用。操作员向解释程序发出指令，应用内部优化，避免超出堆栈内存。</p><p id="c160" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们回到第一个列表，将嵌套数组乘以一个因子，并将这段代码重写为<em class="lc"> LISP/Clojure </em>:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="f73f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看起来更简洁。尽管如此，它仍然包含一个对<em class="lc">嵌套列表</em>函数的直接递归函数调用，该函数不能更改为<em class="lc">递归</em>，因为<em class="lc">递归</em>只能位于尾部位置，而不能位于map的函数参数内。不便的限制。在这种情况下，需要递归，因为它处理递归数据结构。</p><p id="06a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，有些情况下使用<em class="lc">recurve</em>可能会有好处。例如，如果您需要在不使用内置的<em class="lc"> map </em>函数的情况下实现map功能，代码将如下所示:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="3160" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以通过将<em class="lc">自定义映射</em>调用改为<em class="lc">循环</em>来改进该代码:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="7b29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与直接调用<em class="lc">自定义映射</em>函数相比，该代码可更好地使用堆栈内存，即有可能在不超出堆栈限制的情况下处理更长的映射。</p></div></div>    
</body>
</html>