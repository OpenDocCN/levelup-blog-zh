<html>
<head>
<title>Negative Cache with Nginx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Nginx的负缓存</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/negative-cache-with-nginx-e3af193718fe?source=collection_archive---------3-----------------------#2021-02-04">https://levelup.gitconnected.com/negative-cache-with-nginx-e3af193718fe?source=collection_archive---------3-----------------------#2021-02-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="faec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而不使用单独的子系统</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/0ade65a9cb459f4cb87d2c51e84f64dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N_ZMUg9rxs_co-PI"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://unsplash.com/@5tep5?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚历山大·波波夫</a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="33f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">非人类的bot客户端可能会严重滥用REST API调用，这些调用用于在允许操作完成之前检查某些东西的状态。通常，对于REST API，响应状态将通知调用服务动作是否可以完成或已经成功完成。2xx范围内的肯定响应代码通常与让动作继续相关联。否定响应代码通常在4xx范围内，但也可能在5xx范围内，表示阻止操作或操作失败。系统可能会因端点上的请求而降级或在高负载下经历中断，这些请求指示某个操作无法完成或不成功，并且该状态与事务无关，而是与系统的某个其他方面有关。</p><p id="4b79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">示例</strong> <br/>这种API调用的一个很好的例子是库存可用性检查，以确定将产品添加到购物车的操作是否可以完成。如果一个电子商务网站有一种低库存、高需求的产品，点击将产品添加到购物车API的bot流量的增加将导致商业系统的购物车服务和库存系统的沉重负担。当高需求产品尚未上市或已售完时，这种情况就会发生，这是这种产品的典型情况。在疯狂销售后进入售罄状态的产品将继续在某些端点上以高比率抛出错误，即使他们没有任何产品可供销售。<strong class="jp ir">运营团队可能</strong> <strong class="jp ir">对这种高流量影响束手无策</strong>，因为他们知道在产品销售一空之前什么也做不了，因为他们看着自己的系统遭受损失。</p><p id="6ba8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在有可用库存之前，该产品的状态不会改变，因此，<strong class="jp ir">缓存这些调用的否定响应</strong>或者使用短生存时间(TTL)触发该调用的请求资源可能是一个好主意，以减轻后端系统上不必要的负载。在负面响应上设置缓存可以让负担过重的上游恢复。毫不奇怪，这被称为<strong class="jp ir">负缓存</strong>。</p><blockquote class="lc ld le"><p id="eab2" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">注意:本文将重点关注使用nginx-plus处理负缓存，但是开源nginx或openresty应该仍然能够以相同的方式工作。此外，如果nginx前面有CDN，如Akamai或Fastly，如果对实现有意义并且可能做到，则应该将此逻辑移到该层。在某些情况下，在边缘和原点有一个负缓存层可能是有意义的，只要记住TTLs可能会堆叠。</p></blockquote><h1 id="662b" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">意外错误</h1><blockquote class="mh"><p id="03b7" class="mi mj iq bd mk ml mm mn mo mp mq kk dk translated">场景:营销部门推出了一个新产品，当产品页面被激活时，唤醒了经销商机器人，即使该产品在推出前没有库存。繁忙的交通导致站点出现重大错误，从而触发事件响应。支持技术人员团结起来解决问题。</p></blockquote><p id="83a4" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">库存系统通常会提供可用性检查URI，当请求将产品添加到用户的包中时会调用该功能。当经销商机器人在网站上活跃时，通常它会完成一系列请求:</p><ol class=""><li id="193e" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated">创建会话</li><li id="2e4e" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">通过向袋子中添加任何产品来创建购物车</li><li id="532a" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">重复将所需产品添加到袋子中，直到添加到袋子请求成功</li><li id="2c2d" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">从袋子中取出购物车创建产品(步骤2)</li><li id="a0d8" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">添加运输/账单信息</li><li id="acec" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">添加付款</li><li id="6606" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">提交订单</li></ol><p id="f8cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">许多机器人代理将在各种云提供商之间被激活，以便在想要的产品上线时尽可能多地获取产品。添加到购物车活动将增加系统的负荷，即使还没有产品可用。添加到购物车可用性检查是放置负缓存以减少开销的好地方。</p><blockquote class="lc ld le"><p id="d8c3" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">注意:为时间敏感的端点添加一个short可以带来巨大的好处，但是必须对其进行监控和调整，以满足系统的需求。</p></blockquote><h1 id="3902" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">PII / PCI-DSS和可缓存性</h1><p id="f247" class="pw-post-body-paragraph jn jo iq jp b jq nk js jt ju nl jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">在启用任何缓存之前，应该针对PII或PCI-DSS数据评估正在缓存的响应。如果响应有效负载具有任何可能允许客户端接收导致来自另一个客户端的数据被公开的信息的头或主体数据，则必须在缓存该有效负载之前对其进行修改，以排除那些头或主体数据。</p><p id="b4e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理想情况下，可缓存资源不应该有任何与客户端会话相关的响应数据，也不应该有任何会干扰缓存响应的数据。</p><blockquote class="lc ld le"><p id="94a4" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">注意:如果响应中有Set-Cookie头或Vary头，默认情况下不会被缓存。为系统缓存响应可能还有其他考虑，但这些是最重要的。有关缓存这些类型的响应的详细信息，请参见proxy_hide_header和proxy_ignore_headers指令。</p></blockquote><h1 id="d566" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">负缓存</h1><p id="02b8" class="pw-post-body-paragraph jn jo iq jp b jq nk js jt ju nl jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">在本例中，对于缺货响应，产品可用性请求将获得一个短暂的负缓存。</p><blockquote class="lc ld le"><p id="74b0" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">注意:根据系统架构，可用性检查可能是将产品添加到行李功能的一部分，并且可能涉及更多内容。根据架构的不同，将产品添加到包资源也是放置缓存的好地方。</p></blockquote><h2 id="6c4f" class="np lk iq bd ll nq nr dn lp ns nt dp lt jy nu nv lx kc nw nx mb kg ny nz mf oa bi translated">可用性URI</h2><p id="b775" class="pw-post-body-paragraph jn jo iq jp b jq nk js jt ju nl jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">让我们定义一个没有库存的基本可用性请求和响应:</p><p id="c2e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请求:<br/>获取/API/产品/检查可用性/{产品编号}</p><p id="8b2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回复:<br/> { "数量_可用"，数量}</p><p id="3f07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">响应状态代码为:<br/> * 200如果产品可用，10个以上<br/> * 201如果产品缺货，小于10个<br/> * 400如果产品编号无效<br/> * 500。</p><h2 id="c701" class="np lk iq bd ll nq nr dn lp ns nt dp lt jy nu nv lx kc nw nx mb kg ny nz mf oa bi translated">缓存键</h2><p id="df17" class="pw-post-body-paragraph jn jo iq jp b jq nk js jt ju nl jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">为了缓存项目的可用性调用，我们需要创建一个对项目有意义的缓存键。在这种情况下，我们将使用nginx映射将URI中的产品编号分离到一个变量中:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="467d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于nginx映射只有在使用时才会被评估，所以这是一种为缓存键捕获产品号的有效方法。它只在我们需要的地方被评估:在处理可用性呼叫的位置块中。</p><h2 id="778d" class="np lk iq bd ll nq nr dn lp ns nt dp lt jy nu nv lx kc nw nx mb kg ny nz mf oa bi translated">缓存配置</h2><p id="41e2" class="pw-post-body-paragraph jn jo iq jp b jq nk js jt ju nl jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">要为此调用配置缓存，需要在http{}块中配置proxy_cache_path指令。应该为此配置一些proxy_cache_*设置，这些设置将在location块中设置。下面是负缓存的代理模块配置:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ob oc l"/></div></figure><ul class=""><li id="5814" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk od nc nd ne bi translated">如果5分钟的非活动TTL未过期，并且后端出现问题，并且响应状态代码为500、502、503或504，则此配置将从缓存提供服务。</li><li id="adfe" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk od nc nd ne bi translated">Nginx将在出现错误、超时或请求更新缓存时从缓存中提供服务。</li><li id="b10b" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk od nc nd ne bi translated">如果缓存在代理到后端服务器进行响应之前正在更新，对同一缓存键的重复请求将等待5s。</li></ul><p id="e3f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些指令记录在nginx代理模块文档中<a class="ae lb" href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_path" rel="noopener ugc nofollow" target="_blank">这里</a>:<br/><a class="ae lb" href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_path" rel="noopener ugc nofollow" target="_blank">http://nginx.org/en/docs/http/ngx_http_proxy_module.html</a></p><p id="ed58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在产品可用性位置{}块中，以下指令将完成不同缓存的配置:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ob oc l"/></div></figure><ul class=""><li id="6431" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk od nc nd ne bi translated">这将在活动缓存中缓存状态为400的响应1分钟，非活动缓存TTL为5分钟。</li><li id="5edf" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk od nc nd ne bi translated">如果请求方法是POST，则需要取消对proxy_cache_methods指令的注释。</li></ul><h1 id="3241" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">结论</h1><p id="e666" class="pw-post-body-paragraph jn jo iq jp b jq nk js jt ju nl jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">请记住从缓存的响应中删除任何可能导致问题的头，如Set-Cookie、Vary或任何可能暴露PII / PCI-DSS数据的头。</p><p id="59fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将可能以“失败”状态为目标的请求URIs上的负缓存高速放置，以减少后端影响。</p><p id="87f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>