<html>
<head>
<title>Download files and zip them in your browsers using Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Javascript下载文件并在浏览器中压缩它们</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/download-files-and-zip-them-in-your-browsers-using-javascript-cc2143262ea9?source=collection_archive---------15-----------------------#2020-06-22">https://levelup.gitconnected.com/download-files-and-zip-them-in-your-browsers-using-javascript-cc2143262ea9?source=collection_archive---------15-----------------------#2020-06-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c244" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">与其生成zip文件并从您的服务器传输，为什么不下载数据并在您的浏览器中压缩它们呢？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6daeae08299890162e691a714005f1e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JWRaxcQh150O3uIJnNwjGw.jpeg"/></div></div></figure><p id="54c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我最近在做一个副业项目，它可以根据用户的请求生成报告。对于每个请求，我们的后端将生成一个报告，上传到亚马逊S3存储，并将其URL返回给客户端。由于生成报告需要一段时间，所以输出文件被存储起来，服务器通过请求参数缓存它们的URL。如果用户订购相同的东西，后端将返回现有文件的URL。</p><p id="b136" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">前几天，我有了新的要求。我需要下载包含数百份报告的zip文件，而不是单个文件。我想到的第一个解决方案是:</p><ul class=""><li id="f4c9" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">在服务器上准备zip文件</li><li id="26d8" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">将其上传到存储器</li><li id="3b3e" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">给客户端一个下载它的URL</li></ul><p id="ce09" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是这种解决方案有一些缺点:</p><ul class=""><li id="8d7d" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">生成zip文件的逻辑相当复杂。我需要考虑为每个请求生成所有文件，或者在重用现有文件和生成新文件之间进行组合。这两种方法似乎都很复杂。它们需要时间来处理，并且需要大量的编码、测试和后期维护工作。</li><li id="b0b6" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">它不能利用我已经建立的功能。尽管Zip文件是不同的报告集，但是很可能大多数单独的报告都是由先前的请求生成的。因此，虽然Zip文件本身不太可能重用，但单个文件可以。使用上面的方法，我需要一直重做整个事情，这不是很有效率。</li><li id="1a03" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">生成zip文件需要很长时间。由于我的后端是一个单线程进程，这个操作可能会阻塞其他请求一段时间，并且在这段时间内可能会超时。</li><li id="a2fb" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">在客户端很难跟踪流程。我喜欢在网站上放一个进度条。如果一切都在后端处理，我需要找到一个额外的方法向前端报告状态。这并不容易。</li><li id="75d4" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">我想为我的基础设施节省成本。如果我们可以将一些计算转移到前端，并降低基础架构的成本，那就太好了。我的客户不会介意他们多等几秒钟，或者在他们的笔记本电脑上多花一些内存。</li></ul><p id="9f5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我想到的最终解决方案是:将所有文件下载到浏览器并压缩到那里。在这篇文章中，我将介绍我是如何做到的。</p><p id="cf9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="me">免责声明</em> </strong> <em class="me">:在这篇文章中，我假设你已经对</em><a class="ae mf" href="https://javascript.info/" rel="noopener ugc nofollow" target="_blank"><em class="me">Javascript</em></a><em class="me">和</em><a class="ae mf" href="https://web.dev/promises/" rel="noopener ugc nofollow" target="_blank"><em class="me">Promise</em></a><em class="me">有了基本的了解。如果你没有，我会建议你先了解他们，然后再来这里:)</em></p><h1 id="8580" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">下载单个文件</h1><p id="8a0a" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">在应用新的解决方案之前，我的系统允许下载单个报告文件。有许多方法可以做到这一点。后端可以通过HTTP请求直接响应原始文件内容，或将文件上传到另一个存储并返回文件URL。我选择第二种方法，因为我想缓存所有生成的文件。</p><p id="6c19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我有了一个文件URL，客户端的工作就非常简单了:在一个新标签中打开这个URL。浏览器将完成下载文件的其余工作。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="1639" class="ni mh it ne b gy nj nk l nl nm"><br/>const downloadViaBrowser = url =&gt; {<br/> window.open(url, ‘_blank’);<br/>}</span></pre><h1 id="bc45" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">下载多个文件并存储在内存中</h1><p id="c5ae" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">当下载和压缩多个文件时，我们不能再使用上面的简单方法了。</p><ul class=""><li id="f678" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">如果一个JS脚本试图同时打开许多链接，浏览器会怀疑这是否是一个威胁，并警告用户阻止这些操作。虽然用户可以确认继续，但这不是一个好的体验</li><li id="b156" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">您无法控制下载的文件。浏览器管理文件内容和位置</li></ul><p id="26fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一种处理方式是使用<code class="fe nn no np ne b">fetch</code>下载文件并将数据作为<a class="ae mf" href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" rel="noopener ugc nofollow" target="_blank"> Blob </a>存储在内存中。然后，我们可以将其写入文件或将这些blob数据合并到一个zip文件中。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="0c6d" class="ni mh it ne b gy nj nk l nl nm">const download = url =&gt; {<br/>  return fetch(url).then(resp =&gt; resp.blob());<br/>};</span></pre><p id="aaee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该函数返回一个将被解析为blob的承诺。我们可以结合一个<code class="fe nn no np ne b">Promise.all()</code>来下载多个文件。<code class="fe nn no np ne b">Promise.all()</code>将一次完成所有的承诺，如果所有的子承诺都已解决或其中一个出现错误，则进行解决。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="708e" class="ni mh it ne b gy nj nk l nl nm">const downloadMany = urls =&gt; {<br/>  return Promise.all(urls.map(url =&gt; download(url))<br/>}</span></pre><h1 id="d1f0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">按X个文件分组下载</h1><p id="98db" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">但是如果我们需要一次下载大量的文件会怎么样呢？比如说1000个文件？使用<code class="fe nn no np ne b">Promise.all()</code>可能不再是一个好主意。您的代码将一次发送一千个请求。这种方法存在许多问题:</p><ul class=""><li id="522f" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">操作系统和浏览器支持的并发连接数是有限的。因此，浏览器一次只能处理几个请求。其他请求被放入队列，并进行超时计数。结果是，您的大多数请求甚至在发送之前就会超时。</li><li id="6afe" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">一次发送大量的请求也会使后端过载</li></ul><p id="cd41" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我考虑的解决方案是将文件分成多个组。比方说，我有1000个文件要下载。我将每次下载5个文件，而不是用<code class="fe nn no np ne b">Promise.all()</code>一次下载所有文件。做完那5个，我再开始另一包。总共我会下载250包。</p><p id="f4f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了实现这一点，我们可以做一个自定义逻辑。或者我可以建议的一个更简单的方法是利用第三方库<a class="ae mf" href="http://bluebirdjs.com/" rel="noopener ugc nofollow" target="_blank"> bluebirdjs </a>。该库实现了许多有用的promise函数。对于这个用例，我将使用<a class="ae mf" href="http://bluebirdjs.com/docs/api/promise.map.html" rel="noopener ugc nofollow" target="_blank"> Promise.map() </a>。注意这里的<code class="fe nn no np ne b">Promise</code>是库提供的自定义承诺，而不是内置承诺。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="bc0c" class="ni mh it ne b gy nj nk l nl nm">import Promise from 'bluebird';</span><span id="73b4" class="ni mh it ne b gy nq nk l nl nm">const downloadByGroup = (urls, files_per_group=5) =&gt; {<br/>  return Promise.map(<br/>    urls, <br/>    async url =&gt; {<br/>      return await download(url);<br/>    },<br/>    {concurrency: files_per_group}<br/>  );<br/>}</span></pre><p id="c0b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过上面的实现，该函数将接收一个URL数组，并开始下载所有URL，每次最多下载<code class="fe nn no np ne b">files_per_group</code>。该函数返回一个承诺，当所有的URL都被下载时，该承诺将被解析，如果其中任何一个失败，该承诺将被拒绝。</p><h1 id="3ca2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">创建zip文件</h1><p id="255f" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">现在我已经把所有东西都下载到内存里了。正如我上面提到的，下载的内容存储为Blob。下一步是使用这些Blob数据创建一个zip文件。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="17d4" class="ni mh it ne b gy nj nk l nl nm">import JsZip from 'jszip';<br/>import FileSaver from 'file-saver';</span><span id="51a3" class="ni mh it ne b gy nq nk l nl nm">const exportZip = blobs =&gt; {<br/>  const zip = JsZip();<br/>  blobs.forEach((blob, i) =&gt; {<br/>    zip.file(`file-${i}.csv`, blob);<br/>  });<br/>  zip.generateAsync({type: 'blob'}).then(zipFile =&gt; {<br/>    const currentDate = new Date().getTime();<br/>    const fileName = `combined-${currentDate}.zip`;<br/>    return FileSaver.saveAs(zipFile, fileName);<br/>  });<br/>}</span></pre><h1 id="609a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">最终代码</h1><p id="ae08" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">让我们在这里完成我为此所做的所有代码。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="4b24" class="ni mh it ne b gy nj nk l nl nm">import Promise from 'bluebird';<br/>import JsZip from 'jszip';<br/>import FileSaver from 'file-saver';</span><span id="44bc" class="ni mh it ne b gy nq nk l nl nm">const download = url =&gt; {<br/>  return fetch(url).then(resp =&gt; resp.blob());<br/>};</span><span id="f896" class="ni mh it ne b gy nq nk l nl nm">const downloadByGroup = (urls, files_per_group=5) =&gt; {<br/>  return Promise.map(<br/>    urls, <br/>    async url =&gt; {<br/>      return await download(url);<br/>    },<br/>    {concurrency: files_per_group}<br/>  );<br/>}</span><span id="d669" class="ni mh it ne b gy nq nk l nl nm">const exportZip = blobs =&gt; {<br/>  const zip = JsZip();<br/>  blobs.forEach((blob, i) =&gt; {<br/>    zip.file(`file-${i}.csv`, blob);<br/>  });<br/>  zip.generateAsync({type: 'blob'}).then(zipFile =&gt; {<br/>    const currentDate = new Date().getTime();<br/>    const fileName = `combined-${currentDate}.zip`;<br/>    return FileSaver.saveAs(zipFile, fileName);<br/>  });<br/>}</span><span id="4eed" class="ni mh it ne b gy nq nk l nl nm">const downloadAndZip = urls =&gt; {<br/>  return downloadByGroup(urls, 5).then(exportZip);<br/>}</span></pre><h1 id="962f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><ul class=""><li id="11bd" class="lq lr it kw b kx my la mz ld nr lh ns ll nt lp lv lw lx ly bi translated">利用客户端的能力有时对于减少后端的工作量和复杂性非常有用</li><li id="5d4a" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">不要一次发送大量的请求。你可以在前端和后端都遇到麻烦。而是把作品分成小块。</li><li id="1f85" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">介绍一些第三方库<a class="ae mf" href="http://bluebirdjs.com/" rel="noopener ugc nofollow" target="_blank">蓝鸟</a>、<a class="ae mf" href="https://www.npmjs.com/package/jszip" rel="noopener ugc nofollow" target="_blank"> jszip </a>、<a class="ae mf" href="https://github.com/eligrey/FileSaver.js" rel="noopener ugc nofollow" target="_blank">文件保存器</a>。它们对我很有用，也可能对你有帮助:)</li></ul></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="579c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="me">原发布于</em><a class="ae mf" href="https://huynvk.dev/blog/download-files-and-zip-them-in-your-browsers-using-javascript" rel="noopener ugc nofollow" target="_blank"><em class="me">https://huynvk . dev</em></a><em class="me">。</em></p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><div class="kj kk kl km gt ob"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">编写面试问题</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">技术开发</p></div></div><div class="ok l"><div class="ol l om on oo ok op ks ob"/></div></div></a></div></div></div>    
</body>
</html>