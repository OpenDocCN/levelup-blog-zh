<html>
<head>
<title>3 Ways to Run Code Once at Application Startup in ASP.NET Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在应用程序启动时在ASP.NET核心中运行一次代码的3种方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/3-ways-to-run-code-once-at-application-startup-in-asp-net-core-bcf45a6b6605?source=collection_archive---------0-----------------------#2021-10-31">https://levelup.gitconnected.com/3-ways-to-run-code-once-at-application-startup-in-asp-net-core-bcf45a6b6605?source=collection_archive---------0-----------------------#2021-10-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e1a7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">开发人员应该将初始化内存缓存的代码放在哪里？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e165fdc273c74342eb7b2fb6b5fad192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5CnBgPK-4UmgCJfC"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由克莱门斯·范·雷在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a1d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员可能会发现，在ASP.NET核心应用程序启动时，某些代码只需执行一次。例如，开发人员可能需要填充内存中的缓存、运行后台任务、从一些外部源读取配置、发布应用程序成功启动的事件等。</p><p id="2537" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ASP。NET Core为开发人员提供了几种不同的方法来实现这一目标，但它们并不等同，开发人员在做出最终选择之前应该仔细分析。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fd4b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">直接从程序或启动类运行代码</h1><p id="6bcf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在应用程序启动时只执行一次一段代码的最明显和直接的方法可能是将这段代码直接放入<code class="fe mz na nb nc b">Program</code>类的<code class="fe mz na nb nc b">Main</code>方法，或者<code class="fe mz na nb nc b">Startup</code>类的<code class="fe mz na nb nc b">Configure</code>方法。ASP.NET核心确保这些方法以及其中的代码只在应用程序启动时执行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="dfc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员可以根据具体情况选择两种方式来放置启动逻辑。例如，如果启动逻辑应该只在配置了请求处理管道之后运行，开发人员应该将它放在<code class="fe mz na nb nc b">Configure</code>方法的末尾，而不是在<code class="fe mz na nb nc b">IHost</code>对象创建之后。</p><p id="a490" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将逻辑放在main中(或在极少数情况下放在Configure方法中)的主要优点是，启动逻辑可以在应用程序开始处理web请求之前执行，这对于初始化内存缓存或读取配置等任务非常重要。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="00a6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">从托管服务运行代码</h1><p id="2c8e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">ASP。NET Core为开发人员提供了一个<code class="fe mz na nb nc b">IHostedService</code>接口，该接口具有在应用程序启动和停止时执行的<code class="fe mz na nb nc b">StartAsync</code>和<code class="fe mz na nb nc b">StopAsync</code>方法。该接口通常用于触发长时间运行的后台任务，但是<code class="fe mz na nb nc b">StartAsync</code>本身必须快速返回，以免阻塞其他托管服务(如果有的话)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="021f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，最好知道在配置应用程序的请求管道之前(在执行<code class="fe mz na nb nc b">Configure</code>方法之前)运行了<code class="fe mz na nb nc b">StartAsync</code>方法。当启动逻辑只需要在应用程序的请求管道配置完成后运行时，这可能是一个问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b2f9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><code class="fe mz na nb nc b">Subscribe to </code> IHostApplicationLifetime事件</h1><p id="0775" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">另一个ASP.NET核心接口<code class="fe mz na nb nc b">IHostApplicationLifetime</code>允许开发人员为其处理程序订阅应用启动、应用停止和应用停止事件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d5b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的是要注意，<code class="fe mz na nb nc b">OnStarted</code>事件只有在应用程序主机完全启动之后才会发布，也就是说，在服务和请求处理管道已经配置好并且应用程序已经开始为web请求提供服务之后。这意味着，如果在应用程序开始为web请求提供服务之前需要执行一些启动逻辑，那么就不应该选择生存期事件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b000" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><ul class=""><li id="7b42" class="nf ng it lb b lc mu lf mv li nh lm ni lq nj lu nk nl nm nn bi translated">在应用程序开始处理web请求之前，所有类型的启动任务都可以直接从程序或启动类中执行。</li><li id="e135" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">长期运行的后台任务应该由托管服务启动和停止。</li><li id="1c24" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">开发者可以使用<code class="fe mz na nb nc b">IHostApplicationLifetime</code>接口订阅<code class="fe mz na nb nc b">OnStarted</code>事件，该事件在应用主机完全配置并启动后发布。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="5c73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。如果你喜欢你所读到的，看看下面这个故事:</p><div class="nt nu gp gr nv nw"><a rel="noopener  ugc nofollow" target="_blank" href="/top-misconceptions-about-dependency-injection-in-asp-net-core-c6a7afd14eb4"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">ASP.NET核心中关于依赖注入的主要误解</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">这甚至会导致错误。</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok ks nw"/></div></div></a></div></div></div>    
</body>
</html>