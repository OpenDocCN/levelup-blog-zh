<html>
<head>
<title>Speed up your React developer workflow with code generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用代码生成器加快React开发人员的工作流程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/speed-up-your-react-developer-workflow-with-code-generators-f8181eced241?source=collection_archive---------9-----------------------#2020-11-05">https://levelup.gitconnected.com/speed-up-your-react-developer-workflow-with-code-generators-f8181eced241?source=collection_archive---------9-----------------------#2020-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/051544998348f2e94403cba0b343da98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QqRVN4zH2tCsQWYJDACm1Q.jpeg"/></div></figure><p id="b187" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">作为React开发人员，我们经常需要设置新的组件，将它们与现有的基础设施连接起来，或者搭建应用程序。这需要大量重复的手动工作，尽管不经常发生，但可能会非常乏味，坦率地说，非常无聊。好消息是它可以很容易地用代码生成器自动化。这些生成器也可以与其他开发人员共享，增加团队内部的代码一致性。</p><p id="642d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这篇文章中，我们将使用<a class="ae kv" href="https://github.com/amwmedia/plop" rel="noopener ugc nofollow" target="_blank"> plop </a>包来设置生成器，这些生成器将从头开始创建React组件文件夹，或者向已经存在的文件夹添加一个新组件。最终代码可在<a class="ae kv" href="https://github.com/Clarity-89/react-generator/tree/react-generator" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。</p><p id="d802" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">假设你已经有了一个React app设置(我个人更喜欢<a class="ae kv" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>来加速这个过程)，我们就从安装扑通开始。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="cb2c" class="lf lg it lb b gy lh li l lj lk">npm i -D plop</span></pre><p id="1890" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe ll lm ln lb b">-D</code>这里是<code class="fe ll lm ln lb b">--save-dev</code>的快捷方式。同时，让我们将<code class="fe ll lm ln lb b">generate</code>脚本添加到我们的package.json中</p><figure class="kw kx ky kz gt ju"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="b83b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果全局安装plop(带— <code class="fe ll lm ln lb b">g</code>前缀)，可以用<code class="fe ll lm ln lb b">plop</code>命令代替<code class="fe ll lm ln lb b">./node_modules/.bin/plop</code>。</p><p id="2b6c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">基础结构是用create-react-app制作的应用程序的典型结构。此外，每个组件都有一个包含组件文件和<code class="fe ll lm ln lb b">index.js</code>的文件夹，所有组件都从这里导出。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="4f20" class="lf lg it lb b gy lh li l lj lk">mysite/<br/>    src/<br/>        components/<br/>            Component1/<br/>                Component1.js<br/>                index.js<br/>        App.js<br/>        App.css<br/>        index.js<br/>        index.css</span></pre><p id="1dbb" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在我们将在<code class="fe ll lm ln lb b">src</code>目录下创建<code class="fe ll lm ln lb b">scripts</code>文件夹，在其中我们将添加<code class="fe ll lm ln lb b">generator</code>文件夹。在生成器内部，让我们添加<code class="fe ll lm ln lb b">index.js</code>，在这里我们设置生成器本身，命名为“组件”。</p><figure class="kw kx ky kz gt ju"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="f97d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们仍然需要添加生成器的配置，这是我们设置的主要部分。为此，让我们创建<code class="fe ll lm ln lb b">config.js</code>并开始充实它。</p><p id="7c69" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果我们查看扑通<a class="ae kv" href="https://github.com/amwmedia/plop#setgenerator" rel="noopener ugc nofollow" target="_blank">文档</a>，发电机配置对象有3个属性:</p><ul class=""><li id="71ba" class="lq lr it jz b ka kb ke kf ki ls km lt kq lu ku lv lw lx ly bi translated"><code class="fe ll lm ln lb b">description</code> -该生成器功能的简短描述</li><li id="83e3" class="lq lr it jz b ka lz ke ma ki mb km mc kq md ku lv lw lx ly bi translated"><code class="fe ll lm ln lb b">prompt</code> -收集用户意见的问题</li><li id="09b7" class="lq lr it jz b ka lz ke ma ki mb km mc kq md ku lv lw lx ly bi translated"><code class="fe ll lm ln lb b">action</code> -根据输入执行的动作</li></ul><p id="1edb" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们从添加描述开始。</p><figure class="kw kx ky kz gt ju"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="c1c9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">嗯，那很简单。现在让我们来定义提示，它基本上是从用户那里获得输入的方法。</p><figure class="kw kx ky kz gt ju"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="55f9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe ll lm ln lb b">prompts</code>数组中每个对象的主要属性是<code class="fe ll lm ln lb b">type</code>、<code class="fe ll lm ln lb b">name</code>和<code class="fe ll lm ln lb b">message</code>。如果提示的类型是<code class="fe ll lm ln lb b">list</code>，我们需要为它提供一个选择列表。Plop使用<a class="ae kv" href="https://github.com/SBoudrias/Inquirer.js#examples" rel="noopener ugc nofollow" target="_blank"> inquirer.js </a>进行提示，因此如果您想更深入地了解可用的提示类型，请查看它们的存储库。</p><p id="88bc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">提示的工作方式是在收集了用户的输入后，作为提示方法的参数的一个属性。例如，在上面的第一个提示中，我们提供了一组选项供选择。用户选择一个选项后，它的<code class="fe ll lm ln lb b">value</code>将在数据对象的<code class="fe ll lm ln lb b">action</code>属性上可用，因为我们将提示的<code class="fe ll lm ln lb b">name</code>指定为<code class="fe ll lm ln lb b">action</code>。然后在下一个提示对象中，我们可以在<code class="fe ll lm ln lb b">when</code>方法中访问这个值:<code class="fe ll lm ln lb b">when: answer =&gt; answer.action === "add"</code>。<code class="fe ll lm ln lb b">when</code>属性主要检查当前提示是否应该显示给用户。所以在这种情况下，如果用户选择了<code class="fe ll lm ln lb b">add</code>动作，下一个提示将要求指定一个应该添加组件的目录。</p><p id="0acc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您会注意到这里使用了<code class="fe ll lm ln lb b">listComponents</code>实用函数来获取<code class="fe ll lm ln lb b">components</code>目录中的组件名数组。</p><figure class="kw kx ky kz gt ju"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="9b22" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">此外，我们使用<code class="fe ll lm ln lb b">validate</code>来确保用户确实指定了组件的名称。在最后一个提示中，我们要求选择要创建的组件的类型，默认提供functional component选项，因为它可能是最常用的。</p><p id="077a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在是发电机最有趣的部分——它的动作。动作可以是要执行的命令列表，也可以是返回该列表的函数。在这个例子中，我们将使用函数形式，因为我们需要做相当多的检查和条件返回。</p><p id="0a8f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但是在此之前，让我们在文件的顶部添加一个常量，<code class="fe ll lm ln lb b">componentsPath</code>，这将省去我们在多个地方更新路径字符串的麻烦，以防我们决定将配置移动到其他地方。</p><figure class="kw kx ky kz gt ju"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="4022" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe ll lm ln lb b">actions</code>方法以一个数据对象作为参数，该数据对象包含提示收集的所有数据。该方法需要返回操作对象的数组。最重要的属性是:</p><ul class=""><li id="bfcf" class="lq lr it jz b ka kb ke kf ki ls km lt kq lu ku lv lw lx ly bi translated"><code class="fe ll lm ln lb b">type</code> -该动作将执行何种操作。这里我们有一些动作，将创建一个名为<code class="fe ll lm ln lb b">add,</code>的新文件，或者通过<code class="fe ll lm ln lb b">append</code>修改现有文件。</li><li id="0f71" class="lq lr it jz b ka lz ke ma ki mb km mc kq md ku lv lw lx ly bi translated"><code class="fe ll lm ln lb b">path</code> -创建或修改组件的位置。</li><li id="7fd5" class="lq lr it jz b ka lz ke ma ki mb km mc kq md ku lv lw lx ly bi translated"><code class="fe ll lm ln lb b">templateFile</code> -一个用于创建或修改文件的车把路径模板。或者，可以使用一个<code class="fe ll lm ln lb b">template</code>属性，这对于需要放在单独文件中的短把手模板来说很方便。</li></ul><p id="f29f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">首先，我们用默认操作填充数组，这将在从下拉列表中选择的目录中创建一个新的组件，或者如果是一个新的组件文件夹，则在具有该名称的文件夹中创建一个新的组件。接下来有两个路径——当创建新的组件文件夹时，我们向文件夹添加一个<code class="fe ll lm ln lb b">index.js</code>文件；如果它是一个新的组件文件，我们将用新的导出修改<code class="fe ll lm ln lb b">index.js</code>。扑通有几个方便的内置文本转换器，我们在这里使用，即<code class="fe ll lm ln lb b">properCase</code>，这将改变文本到这一点。我们也可以使用handlebars语法来定义文件的路径。这些字符串可以访问来自prompt的数据，例如通过执行<code class="fe ll lm ln lb b">{{properCase name}}</code>我们可以访问用户在prompt中输入的组件名称。结合这一点与ES6字符串插值提供了一个强大的方式来配置我们的路径。</p><p id="13c8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在让我们看看用来生成和修改文件的模板。</p><figure class="kw kx ky kz gt ju"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="8caa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们使用格式<code class="fe ll lm ln lb b">filename.js.hbs</code>来显示目标的文件类型。模板非常简单，它们基本上是缺少组件名称的各个文件的存根。值得注意的是，模板中还提供了plop的helper方法，这对于定制输出非常方便。</p><p id="eaf7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在让我们试着运行我们的发电机，以验证它是否真的工作。</p><figure class="kw kx ky kz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi me"><img src="../Images/46314a42b85c1ac1a47d3013a220972c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-j_QeZ7oD0IGlEXb.gif"/></div></div></figure><p id="efb3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">厉害！生成新组件现在只需一个命令。这是一个非常简单的例子，但是它很好地展示了代码生成器的强大功能。它可以很容易地扩展，对于有很多样板文件的组件来说甚至更有用。例如，如果每个组件都有一些翻译设置或大量导入列表。</p><p id="f164" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对这篇文章有任何问题/评论或其他类型的反馈吗？请在评论中或在<a class="ae kv" href="https://mobile.twitter.com/Clarity_89" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上告诉我。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="fb02" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="mq">原载于</em><a class="ae kv" href="https://claritydev.net/blog/speed-up-your-react-developer-workflow-with-code-g/" rel="noopener ugc nofollow" target="_blank"><em class="mq">https://claritydev.net</em></a><em class="mq">。</em></p></div></div>    
</body>
</html>