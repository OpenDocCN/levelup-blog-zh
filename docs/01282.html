<html>
<head>
<title>React is a state manager too, ya know!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应也是一个国家经理，你知道！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-is-a-state-manager-too-ya-know-ff3a7b357eeb?source=collection_archive---------1-----------------------#2019-12-11">https://levelup.gitconnected.com/react-is-a-state-manager-too-ya-know-ff3a7b357eeb?source=collection_archive---------1-----------------------#2019-12-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="93db" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你可能不需要Redux…或者上下文。使用React的内部组件状态，而不是复杂的第三方解决方案。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4dd72d258143b1591c530349ff813f57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jJwS-TXnLoXiujzH.jpg"/></div></div></figure><div class="ku kv gp gr kw kx"><a href="https://gitconnected.com/portfolio-api" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd iu gy z fp lc fr fs ld fu fw is bi translated">组合API -轻松发展您的编码事业| gitconnected</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">消除在每个单独位置手动更新您的详细信息的痛苦。只需在您的中更改一次数据…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">gitconnected.com</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll ks kx"/></div></div></a></div><p id="259c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo iu">向React内部状态的简单致敬</strong></p><p id="b52a" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我写React已经快两年了，毫无疑问，它是我在web开发领域最喜欢使用的工具。就像整个软件行业一样，React也在不断发展，特别是在它管理状态的方式上。从16.8版本开始，React推出了一个<a class="ae mi" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">的新hooks API </a>，它实际上颠覆了生态系统。</p><p id="4380" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我目前的目标不是专门关注这些API的变化，而是它们对我们在React应用程序中管理状态的方式的影响。React最大的优点之一是它在配置、工具和实现方面是多么的独立。然而，当谈到应用程序范围的状态管理时，第三方库通常是事实上的选择，React本身被认为不如处理大规模不可变状态对象。</p><p id="0888" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我希望从使用React应用程序的第一步开始，就反对将这种思维模式作为默认选择。当然，我承认肯定会有一些场景，通常与规模相关，这些外部工具使我们作为开发人员的生活变得更容易。</p><p id="4a0a" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这不是一篇劝阻你不要使用Redux的博客文章——我个人真的很喜欢使用它，并发现在适当的情况下它非常强大。然而，你的Todo应用或个人网站绝对不需要<a class="ae mi" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>或最近更流行的状态管理变体<a class="ae mi" href="https://reactjs.org/docs/context.html#contextprovider" rel="noopener ugc nofollow" target="_blank"> React Context </a>。在这篇文章的结尾，希望我至少能让你在下一个React项目中使用这些工具之前三思。</p><p id="4457" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">所以让我们开始吧。</p><p id="d742" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><em class="mj">免责声明:React的所有实现，无论状态管理方法如何，都将包括纯粹的钩子实现。如果你不熟悉钩子，我建议你在继续之前先看看上面的链接。</em></p><h1 id="b6b2" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">道具钻井…唉</h1><p id="acd4" class="pw-post-body-paragraph lm ln it lo b lp nc ju lr ls nd jx lu lv ne lx ly lz nf mb mc md ng mf mg mh im bi translated">我看到React开发人员使用像Redux这样的第三方库或者定制的上下文实现的最常见原因是为了避免<a class="ae mi" href="https://kentcdodds.com/blog/prop-drilling" rel="noopener ugc nofollow" target="_blank">道具训练</a>。当子组件需要某个特定的状态，但包含该状态的父组件在组件树中比它高几个级别时，就会发生适当的钻取。当然，中间组件不关心这种状态，所以像Redux和Context这样的解决方案旨在从本质上省去中间人。</p><p id="6db9" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这里有一个基本的Redux设置的常见例子，以避免道具钻孔(记住，这是一个很小的例子，所以<em class="mj">钻孔</em>将相当浅):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="6497" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Redux store由一个<code class="fe nj nk nl nm b">search</code>字符串、一个<code class="fe nj nk nl nm b">episodes</code>数组(感谢可爱的<a class="ae mi" href="https://rickandmortyapi.com/" rel="noopener ugc nofollow" target="_blank"> Rick和Morty API </a>)和一个<code class="fe nj nk nl nm b">error</code>对象组成。我敦促你们思考的第一个问题是，为什么这些东西需要在商店里，或者换句话说，全球状态。尤其是像搜索字符串这样短暂的东西。</p><p id="35e5" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这里有一个使用React上下文的类似版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="595e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这两种方法都解决了道具钻探的问题，但是我强烈建议你考虑一下它们可能会在应用程序的生命周期中引入的问题或错误。我承认这不是一个真正的<em class="mj">应用</em>，考虑到它获取一个端点并呈现一些字符串，但我认为这是大多数应用的开始，尤其是我们的副业项目。我们没有预料到我们想要做的所有事情，我们想要添加的功能，以及这些功能是否会从这样一个僵化的系统中受益。</p><p id="c06a" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">更进一步，我们的应用程序如何从全球状态的<code class="fe nj nk nl nm b">episodes</code>中获益？作为前端工程师，通过以这种方式存储剧集，我们基本上创建了一个客户端数据库，我们必须不断地与我们的实际数据库进行比较(当然，假设有一个数据库)。</p><p id="f5fc" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们失去了唯一的真理来源，仅仅是为了避免一个(或两个)额外的请求。这是为了什么？有些人可能会说，它允许更容易地过滤或查询客户端数据，以避免“不必要的”后端请求，但我认为，与应用程序前端和后端之间可能发生的数据停滞相关的潜在错误相比，你在前端感受到的便利性优势毫无意义。</p><p id="de41" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">顺便说一下，有些人可能认为如果他们没有后端，这可能不适合他们，但我想让这些人更进一步，并问为什么，如果他们那么小，甚至有一个外部状态管理器。</p><h1 id="2b0a" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">错误处理</h1><p id="e304" class="pw-post-body-paragraph lm ln it lo b lp nc ju lr ls nd jx lu lv ne lx ly lz nf mb mc md ng mf mg mh im bi translated">与使用Redux或Context这样的状态管理工具相关的一个常见思维模式是要么全有，要么全无。换句话说，如果你要用它，就用它来做所有的事情。<strong class="lo iu"> </strong>我曾经这样想。然而，我已经改变了我的论调，现在以相反的心态接近Redux。现在，我坚信你应该只在绝对必要的时候给你的商店添加一些东西。我可以自信地说，这种情况比您想象的要少得多，尤其是在处理应用程序中的错误时。</p><p id="e021" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">请注意，在上述每种方法中，我都在全局存储中加入了一个错误状态。这是我在Redux和其他状态管理系统中看到的常见做法。目标大概是以某种方式裁剪给定的错误消息，在特定的视图中给出它的上下文(当然与React上下文无关)。</p><p id="6328" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这引入了一个相当麻烦的范例，因为每次我们设置错误状态时，我们都必须清除它。我在大规模Redux代码库中一次又一次地遇到这个令人头痛的问题，作为开发人员，几乎你创建的每个动作都必须有一个相反的，或者“清理”的动作来清除产生的状态——因为它是<strong class="lo iu">短暂的</strong>。</p><blockquote class="nn no np"><p id="4bbf" class="lm ln mj lo b lp lq ju lr ls lt jx lu nq lw lx ly nr ma mb mc ns me mf mg mh im bi translated">对短暂的状态使用React，这种状态对应用程序没有全局影响，并且不会以复杂的方式变异。—丹·阿布拉莫夫在一期<a class="ae mi" href="https://github.com/reduxjs/redux/issues/1287#issuecomment-175351978" rel="noopener ugc nofollow" target="_blank"> Redux Github </a>中</p></blockquote><p id="d103" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我几乎可以向您保证，您的应用程序中包含的短暂状态比您想象的要多。</p><h1 id="bb52" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">生态系统压力</h1><p id="8452" class="pw-post-body-paragraph lm ln it lo b lp nc ju lr ls nd jx lu lv ne lx ly lz nf mb mc md ng mf mg mh im bi translated">作为React开发人员，有大量说教的观点不断掩盖我们所做的工作和我们如何构建应用程序，有很多次我加入Redux只是因为它是一个受欢迎的工具，我可以把它添加到我的简历中。但是，它真的有益于我们的应用程序吗？</p><p id="b482" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在，如果你谷歌“反应状态管理”，你的结果将是全面的。“上下文让Redux过时了！！!"、“MobX为状态管理提供了突破性的新观察者范式”、“新的Redux hooks API带来了对React状态管理的全面改进！”(以上均为杜撰标题)。当我早些时候提到React的一个我最喜欢的部分是它的非个人化，这当然不适用于React生态系统，这是2019年末React开发人员更令人沮丧的痛点之一。</p><p id="dfa9" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果有任何一点我可以理解的话，那就是如果学习反应是一个线性的路径，它应该采取<em class="mj">大致</em>这种形式:</p><ol class=""><li id="e1f8" class="nt nu it lo b lp lq ls lt lv nv lz nw md nx mh ny nz oa ob bi translated"><strong class="lo iu">学习JavaScript </strong></li><li id="1151" class="nt nu it lo b lp oc ls od lv oe lz of md og mh ny nz oa ob bi translated">不，真的，我的意思是学习JavaScript</li><li id="2e70" class="nt nu it lo b lp oc ls od lv oe lz of md og mh ny nz oa ob bi translated"><strong class="lo iu">学习反应</strong></li><li id="0391" class="nt nu it lo b lp oc ls od lv oe lz of md og mh ny nz oa ob bi translated"><strong class="lo iu">在React中构建项目</strong>(没有外部状态管理器)</li><li id="80da" class="nt nu it lo b lp oc ls od lv oe lz of md og mh ny nz oa ob bi translated"><strong class="lo iu">一旦你经历了没有全局状态的痛点</strong>，学习Redux或另一个第三方状态管理器</li></ol><p id="1662" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">更多的时候，恐怕路径是1的25%，然后3，然后5。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/cfb373fd079a87cbb6568f1b1fa3401d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WDTlop3bqAaCYNfA.jpg"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">花了5分钟/ JS和30分钟/ React尝试学习Redux的开发人员</figcaption></figure><p id="32ac" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">重申一下，我不是说你不应该学习Redux，或者你的应用程序不需要Redux。Redux在需要它的环境中非常出色。我只是鼓励你去思考你正在构建的是什么，如果引入像Redux这样的外部工具或者使用你自己的定制状态管理器(danger ⚠️)来增强它，它是否真的会更好。</p><p id="905e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">具体来说，Context是管理React状态的一个当前流行的解决方案，我曾经是宣传列车上的<a class="ae mi" rel="noopener ugc nofollow" target="_blank" href="/implementing-redux-style-state-management-with-reacts-usecontext-usereducer-hooks-c1c5596d9619">乘客。但是后来我把这个系统整合到了几个生产应用程序中。在讨论有争议的<em class="mj"> Redux vs Context </em>辩论时，我认为有一个类比是合适的，那就是将Redux比作豪华奔驰，将Context比作1975年的福特Pinto </a>。这两种方法都会把你带到你需要去的地方，这只是你想要或需要多安全才能到达那里的问题。</p><p id="2e80" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">似乎有赞成(或反对)的论点？)上下文围绕Redux在幕后使用<code class="fe nj nk nl nm b">React.Context</code>这一事实。然而，上下文API本身并没有考虑状态管理。相反，它只是一个解决方案，使数据在组件树中从一个组件到另一个更深的组件可用。不管这种立场的意图是什么，Redux有许多Context没有的内置性能增强器、渲染救助等。以上面的汽车为例，将一个代码库从Redux转换成纯粹的上下文实际上是从你的汽车中取出安全气囊和安全带。是的，它还能开，但是不太安全了。</p><h1 id="d0b5" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">哦嘿，反应过来</h1><p id="6e11" class="pw-post-body-paragraph lm ln it lo b lp nc ju lr ls nd jx lu lv ne lx ly lz nf mb mc md ng mf mg mh im bi translated">让我们用一个使用React的类似例子来回顾一下前面两个使用Redux和Context的设置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3ce8" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">您应该注意到这里有一些不同之处。首先，代码一般来说更轻，我们也放弃了我们的<code class="fe nj nk nl nm b">reducer</code>。<code class="fe nj nk nl nm b">Search</code>组件不再管理自己的状态——它从其父<code class="fe nj nk nl nm b">Content</code>组件接收自己的状态和状态设置器。这就是通常所说的“<a class="ae mi" href="https://reactjs.org/docs/lifting-state-up.html" rel="noopener ugc nofollow" target="_blank">提升状态上升</a>”。</p><p id="db8b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">此外，由于这种父子重组，我们可以免费获得实时搜索过滤的额外好处。我的意思是，如果你搜索一集，你可以立即看到基于你的搜索结果，而不是基于你点击搜索按钮。</p><p id="97f8" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">看起来不错，对吧？我们到底要换多少才能到这里？我们所做的就是删除任何与之前的Redux或上下文示例相关的样板文件，并将一些道具从父母传递给孩子。请注意，在这个场景中，父子道具关系是如何以一种非常令人满意的方式发生的。我们的父组件<code class="fe nj nk nl nm b">Content</code>管理我们应用程序的所有必要状态。</p><p id="2ef8" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">同样，我将说明这是一个非常简单的应用程序，并不真正类似于我们在围绕状态管理做出这些架构决策时通常要处理的内容，但我恳请您考虑将这种方法扩展到您可能遇到的任何问题。详细地说，我的意思是仅仅因为有几个组件可能关心一个特定的状态块<strong class="lo iu">并不意味着</strong>那个状态块需要是<em class="mj">全局的</em>。您组合组件的方式可以很容易地治疗您可能归因于正确的训练的这种疾病。</p><p id="0485" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我甚至更进一步，认为Redux会让我们这些React开发人员变得懒惰。当任何状态可以与任何组件连接时，不管它在组件树中的位置如何，内聚的组件组合通常是事后才想到的。</p><p id="83dc" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><a class="om on ep" href="https://medium.com/u/7f9567e0d71c?source=post_page-----ff3a7b357eeb--------------------------------" rel="noopener" target="_blank">迈克尔杰克逊</a>、<a class="ae mi" href="https://reacttraining.com/" rel="noopener ugc nofollow" target="_blank"> React培训</a>的联合创始人、<a class="ae mi" href="https://egghead.io/podcasts/react-router-with-michael-jackson" rel="noopener ugc nofollow" target="_blank"> React-Router </a>的联合创始人最近发表了一个关于组件合成的力量的优秀的<a class="ae mi" href="https://www.youtube.com/watch?v=3XaXKiXtNjw&amp;feature=youtu.be" rel="noopener ugc nofollow" target="_blank">、<strong class="lo iu">短视频</strong>、</a>在这里我就不尝试复制了。然而，我鼓励你去看看，因为这是一个特殊的补救措施，可以解决我们作为React devs在传递道具和试图管理全局状态时所经历的大部分困难。</p><h1 id="55ed" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">向前迈进，用开放的心态去创造！</h1><p id="8be2" class="pw-post-body-paragraph lm ln it lo b lp nc ju lr ls nd jx lu lv ne lx ly lz nf mb mc md ng mf mg mh im bi translated">在我的开发生涯中，我尝试过几种不同的技术，但是很少有像React这样让我兴奋的。现在比以往任何时候都更是一个成为React开发人员的绝佳时机，因为前端和完整堆栈之间的界限越来越模糊，老实说，这可以保证一篇属于自己的博客文章。</p><p id="c8fa" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">React <a class="ae mi" href="https://reactjs.org/docs/concurrent-mode-suspense.html" rel="noopener ugc nofollow" target="_blank">悬念</a>和<a class="ae mi" href="https://reactjs.org/docs/concurrent-mode-reference.html" rel="noopener ugc nofollow" target="_blank">并发</a>模式是另外两个突破性的API，该团队可能会在明年年初发布，增加代码分割和非阻塞渲染等核心功能，这将从根本上改变React的工作方式，并显著增强开发人员和用户的体验。</p><p id="8160" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">仅仅因为开源项目在Reddit上得到了很多支持，并不意味着你必须使用TypeScript、Redux、GraphQL、Apollo Client等等。<strong class="lo iu">预优化是万恶之源</strong>。从简单开始，根据复杂性需要添加工具。React的内部状态完全有能力处理你的大多数普通应用，尤其是刚刚起步的宠物项目(往往最终会在你的回购收集中落灰)。</p><p id="424d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Redux和其他内部状态管理器可以成为添加到React工具包中的不可思议的工具，我只是鼓励您更加注意何时以及如何使用它们。</p><p id="7ea3" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">感谢您的倾听👋🏻</p><p id="938a" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">与我联系<a class="ae mi" href="https://www.tuckerblackwell.com/" rel="noopener ugc nofollow" target="_blank">这里</a></p></div></div>    
</body>
</html>