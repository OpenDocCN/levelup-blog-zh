<html>
<head>
<title>Implementation of a File Splitter Using Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js实现文件拆分器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementation-of-a-file-splitter-using-node-js-c9373c5dd9af?source=collection_archive---------3-----------------------#2022-05-13">https://levelup.gitconnected.com/implementation-of-a-file-splitter-using-node-js-c9373c5dd9af?source=collection_archive---------3-----------------------#2022-05-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e56d5b8248e5bc058e1be70587cfa835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rpcqymD43rwvGa0M"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@drew_beamer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上绘制的光束器</a></figcaption></figure><p id="fb13" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我将向您展示我使用Node.js实现的文件拆分器。这个文件拆分器可以获取一个大的csv文件，并根据指定的块大小将其拆分为许多较小的文件。块大小将是每个文件中包含的记录数。有许多不同的原因可以让你拆分一个大文件。这些原因可能包括希望将大量数据加载到数据库实例中，将数据发送给同事，加载到网站或FTP服务器，或者将数据下载到机器上。在所有这些情况下，处理较小的数据块可能比一次性处理单个大规模数据集更容易。另一个原因甚至可能包括安全目的。</p><p id="0718" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">出于安全原因，您可能希望将数据分布在多个位置，从而使数据更难被破坏。既然我们已经理解了为什么我们可能想要使用文件拆分器的一些原因，那么让我们检查一下源代码中的实现。我们将在这个例子中查看的代码库可以在这里找到:<a class="ae kf" href="https://github.com/mwiginton/file-splitter" rel="noopener ugc nofollow" target="_blank">https://github.com/mwiginton/file-splitter</a></p><p id="0d63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这段代码的逻辑驻留在我们的<code class="fe le lf lg lh b">index.js file</code>中。让我们从文件的最顶端开始，在这里我们将导入本例中使用的所有包:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="61b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们列出的第一个进口产品是<code class="fe le lf lg lh b">fs</code>包。这是一个包，我们将使用它从源文件(大文件，我们希望将它分割成小块)中读取数据，以及向小文件块中写入数据。我们将看到的下一个进口是<code class="fe le lf lg lh b">csv-parser</code>包。这个包可以将CSV数据转换成JSON对象。拥有包含CSV数据的JSON对象对于将原始文件中的大数据分割成较小文件的小数据块非常重要。最后导入的包是<code class="fe le lf lg lh b">fast-csv</code>包。这个包将帮助我们获取较小的JSON数据块，并将每个数据块写入它自己的较小文件中。</p><p id="a38b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然我们已经介绍了完成这项工作所需的所有包，那么让我们进入这个脚本的逻辑。让我们跳到我们的<code class="fe le lf lg lh b">index.js</code>文件的第83行，在那里我们看到有一个对我们的<code class="fe le lf lg lh b">driver()</code>函数的函数调用。这是我们脚本的入口点。让我们进入我们的<code class="fe le lf lg lh b">driver()</code>函数，我们可以看到执行的第一步是获取一个由我们的<code class="fe le lf lg lh b">createList()</code>函数返回的数组<code class="fe le lf lg lh b">fileLines</code>。这个函数负责读取我们的初始大文件(在我们的例子中是GitHub存储库中包含的‘100000 Sales records . CSV ’),并返回一个列表，其中包含我们的原始文件的每一行，表示为一个JSON对象。现在让我们进入<code class="fe le lf lg lh b">index.js</code>文件第5行的函数，检查它的行为。</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="a911" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们做的第一件事是初始化一个名为<code class="fe le lf lg lh b">processedJson</code>的空数组。这将是包含我们的原始CSV数据(表示为JSON对象)的每一行的数组。我们要做的下一件事是利用我们的<code class="fe le lf lg lh b">fs</code>包为我们正在处理的文件打开一个可读的流。然后，我们使用<code class="fe le lf lg lh b">pipe</code>方法来传输我们的csv对象，该对象将监听我们指定为事件链中的下一步的数据事件。在这种情况下，每次读取新的一行数据时，我们将获取当前行，并将其推送到包含JSON对象的数组中。这个逻辑全部储存在一个叫<code class="fe le lf lg lh b">csvToJsonParsing</code>的承诺里。我们等待这个承诺得到解决，然后我们将返回包含JSON对象和CSV数据的最终数组。这就结束了我们的<code class="fe le lf lg lh b">createList()</code>函数的逻辑。</p><p id="d0ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们跳出<code class="fe le lf lg lh b">createList()</code>函数，进入<code class="fe le lf lg lh b">driver()</code>函数的下一步，你会看到我们正在调用一个<code class="fe le lf lg lh b">fileSplitter()</code>方法，在这里我们传递JSON对象的数组。这个方法负责获取这个JSON数组，将它分成更小的块，并将每个更小的块写入它们自己的文件。让我们进入这个函数调用并检查它的行为。</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="86e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们从函数的最开始说起。我们从声明和初始化分割文件所需的所有变量开始。<br/>第一个变量<code class="fe le lf lg lh b">startingPoint</code>将是我们原始JSON数组的索引，我们将从这里开始写入当前较小的文件。下一个变量<code class="fe le lf lg lh b">linesWritten</code>将记录我们已经写入较小文件的总行数(在我们的例子中，我们总共有100k条记录正在写入)。为了简单起见，我们的<code class="fe le lf lg lh b">chunkSize</code>变量被硬编码为5000。此变量表示每个文件中的记录数。因此对于我们的演示，每个小文件将包含5000条记录。我们将使用的最后一个变量是<code class="fe le lf lg lh b">numChunks</code>变量。一旦我们的脚本运行完毕，这就是最终我们将拥有的较小文件的总数。为了得到这个数字，我们将记录的总数(100k)除以我们的<code class="fe le lf lg lh b">chunkSize</code> (5k)，得到总共20个更小的文件。既然我们已经讨论了这个练习中要用到的所有变量。让我们继续探索分割文件的逻辑。</p><p id="0784" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将从一个外部for循环开始，在这里我们将从0迭代到<code class="fe le lf lg lh b">numChunks</code>(我们正在写入的较小文件的总数)。在这个循环中，我们首先要检查我们写的总行数是否大于或等于我们正在处理的总行数。如果是这种情况，我们已经将所有的行写入一个较小的文件，我们可以结束这个过程。如果这个条件不满足，我们可以继续我们的文件分割过程。我们将声明一个数组<code class="fe le lf lg lh b">jsonChunk</code>,它将包含要写入当前较小文件的记录。</p><p id="07d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的下一步将是建立一个内部for循环，它将从我们当前的<code class="fe le lf lg lh b">startingPoint</code>值开始迭代，直到我们达到当前的<code class="fe le lf lg lh b">startingPoint</code>值和<code class="fe le lf lg lh b">chunkSize</code>的和。一旦进入循环，我们将首先把当前的JSON记录推到我们的<code class="fe le lf lg lh b">jsonChunk</code>数组中。接下来，我们将检查当前索引是否小于JSON对象的总数。如果满足这个条件，我们将增加<code class="fe le lf lg lh b">linesWritten</code>变量，这样我们就可以跟踪我们写的所有行。我们将遇到的下一个条件是检查我们当前的索引是否等于我们当前的<code class="fe le lf lg lh b">startingPoint</code>和<code class="fe le lf lg lh b">chunkSize — 1</code>之和(因为我们的外循环中的零索引)。一旦满足这个条件，我们就达到了该文件的5k块大小，然后我们需要为下一个文件更新我们的<code class="fe le lf lg lh b">startingPoint</code>为当前索引+ 1或<code class="fe le lf lg lh b">j + 1</code>(因为在外部循环中索引为零)。</p><p id="2e4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们更新我们的<code class="fe le lf lg lh b">startingPoint</code>之后，我们准备开始写入我们当前的文件。我们通过使用<code class="fe le lf lg lh b">fs</code>包来打开一个写流，并设置我们想要写入的文件的名称。我们使用标准的<code class="fe le lf lg lh b">‘file-’+ i +’.csv’</code>,因此每个文件都是根据我们的<code class="fe le lf lg lh b">numChunks</code>变量的外部循环中的当前索引来命名的。然后，我们使用<code class="fe le lf lg lh b">fastcsv</code>包来编写更小的<code class="fe le lf lg lh b">jsonChunk</code>数组，并将该信息传输到<code class="fe le lf lg lh b">writeStream</code>。一旦我们完成了对当前较小文件的写入，我们就可以重复这个过程，直到我们所有的原始JSON对象都被写入它们各自的较小文件。这就结束了我们的文件分割的逻辑行为。为了测试和运行这个脚本，您可以简单地克隆存储库，并且从您的项目目录中，简单地运行命令<code class="fe le lf lg lh b">node index.js</code>。</p><p id="7d33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想做的最后一点说明是，在这个例子中，为了简单起见，有些东西是硬编码的，比如将我们的<code class="fe le lf lg lh b">chunkSize</code>设置为5000以及文件名。如果我们想进一步改进这段代码，我们可以考虑删除这些硬编码的值，并在运行脚本时将它们作为命令行参数传递，以便使这个工具更具动态性。如果您也想用您自己的文件进行测试，您可以随时用您选择的文件删除我们在这个存储库中的示例文件。</p><p id="b3d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于那些花时间从头到尾阅读这篇文章的人，我非常感谢您的时间。如果你有任何建设性的反馈，请随时告诉我。我欢迎任何和所有的反馈。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><p id="b5d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lv">如果你喜欢阅读这篇文章，请考虑使用</em> <a class="ae kf" href="https://medium.com/@michelle.wiginton00/membership" rel="noopener"> <em class="lv">我的推荐链接</em> </a> <em class="lv">注册Medium。这种订阅保证了可以无限制地访问我的文章以及其他许多学科的数千名天才作家的文章。</em></p></div></div>    
</body>
</html>