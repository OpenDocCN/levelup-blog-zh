<html>
<head>
<title>JavaScript Function Construction (Part 6)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript函数构造(第6部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-function-construction-part-6-72cfd6b18a7c?source=collection_archive---------12-----------------------#2020-04-26">https://levelup.gitconnected.com/javascript-function-construction-part-6-72cfd6b18a7c?source=collection_archive---------12-----------------------#2020-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7347" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">ES6和立即调用的函数构造函数</h2></div><p id="30e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/function-construction-whats-your-function-5a282b81fc62">第1部分</a> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/function-construction-part-2-f6a711075b11">第2部分</a> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-3-d673ff247541">第3部分</a> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-4-d532f0a5e4af">第4部分</a> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-5-90733a0e6369">第5部分</a> | <strong class="kk iu">第6部分</strong> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-7-17c5661e6ea7">第7部分</a></p><p id="142a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在写完我上一篇关于JavaScript函数构造函数的博客后，我想我终于结束了这个话题。</p><p id="405b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是当我在用React构建一个项目时，我注意到一些事情让我停下来，我意识到我还没有完成。</p><p id="17ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“哦，是啊…班级…ES6…我可能应该在ES6上写一篇博客…”</p><p id="784b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在接下来的一周里，这种意识变成了我脑海中的一个声音，每次我想睡觉的时候，这个声音都变得越来越大。</p><p id="32d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“ES6…类…构造函数…”一个声音一直在说。</p><p id="a454" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我来了。你在这里。再来说一些<code class="fe lf lg lh li b">Class</code>的ES6。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h2 id="e29a" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated">ES101:课程简介</h2><p id="311d" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">JavaScript在技术上不是面向对象的编程语言。</p><p id="e741" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lf lg lh li b">Class</code>关键字来自JavaScript的ES6(或EcmaScript2015)修订版，作为对这个“问题”的回答。从技术上来说，JavaScript仍然不是面向对象的编程语言，但是关键字<code class="fe lf lg lh li b">Class</code>提供了一个选项，在技术上来说，它可以是面向对象的编程语言。</p><p id="6c88" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">技术上。</em></p><p id="ff79" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lf lg lh li b">Class</code>关键字提供了用预定义的属性和方法创建对象的蓝图。类也是用<code class="fe lf lg lh li b">new</code>关键字创建的，这类似于我们如何创建<code class="fe lf lg lh li b">Object</code>，以及如何在<code class="fe lf lg lh li b">getTime.js</code>中调用<code class="fe lf lg lh li b"> init()</code>函数。</p><p id="dd1b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类也有一个叫做<code class="fe lf lg lh li b">constructor()</code>的东西。<code class="fe lf lg lh li b">constructor()</code>函数是一个特殊的函数，每当它所绑定的<code class="fe lf lg lh li b">Class</code>被实例化时就会被执行。这对我们非常重要，它将取代我们在<code class="fe lf lg lh li b">getTime.js</code>中创建和调用的<code class="fe lf lg lh li b">init()</code>函数。</p><p id="e061" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你不知道<code class="fe lf lg lh li b">getTime.js</code>是什么，不用担心。您很快就会知道了(这是一个我们从本系列第1部分开始就一直在构建的小型库)。</p><p id="eeaf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以为我们的类创建实例方法，这些方法与我们为<code class="fe lf lg lh li b">getTime.js</code>创建的原型方法非常相似。这也将取代我们在<code class="fe lf lg lh li b">getTime.js</code>中创建和操作<code class="fe lf lg lh li b">prototype</code>对象的需求。</p><p id="0569" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果需要，我们也可以通过使用<code class="fe lf lg lh li b">static</code>关键字来添加类方法。一个类方法提供了与<code class="fe lf lg lh li b">Class</code>相关的功能，比如一个实用程序或帮助器方法，但并不特定于<code class="fe lf lg lh li b">Class</code>的每个实例。</p><p id="583a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于我们将在<code class="fe lf lg lh li b">getTime.js</code>中重构的每个方法都需要是可调用的，类方法现在对我们来说没什么用。很简单，足够小，我们不需要任何实用函数，所以我们今天不会写任何类方法。</p><p id="2954" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么一辆ES6 <code class="fe lf lg lh li b">Class</code>长什么样呢？</p><p id="11d3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个非常基本的例子:</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2c07" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有了一个新的<code class="fe lf lg lh li b">Person</code>类，它的<code class="fe lf lg lh li b">constructor()</code>函数用两个属性实例化:<code class="fe lf lg lh li b">firstName</code>和<code class="fe lf lg lh li b">lastName</code>。</p><p id="d34b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还有一个实例方法，它返回两个属性的字符串连接。我们可以使用<code class="fe lf lg lh li b">new</code>关键字创建一个<code class="fe lf lg lh li b">Person</code> <code class="fe lf lg lh li b">Class</code>的新实例，并将其调用设置为一个变量:</p><pre class="mp mq mr ms gt mw li mx my aw mz bi"><span id="c616" class="lq lr it li b gy na nb l nc nd">var person = new Person(‘John’, ‘Smith’)</span></pre><p id="2873" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们<code class="fe lf lg lh li b">console.log(person)</code>，我们将得到<code class="fe lf lg lh li b">Person</code> <code class="fe lf lg lh li b">Class</code>和我们传递给它的两个属性。如果我们<code class="fe lf lg lh li b">console.log(person.fullName())</code>，我们得到我们的字符串连接:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/d0576d2fb9a78cea852b395e11978d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*XSgQ-dqzzNGNKHx9adwpvg.jpeg"/></div></figure><p id="30a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是我们在第1部分中使用的同一个例子的比较，没有使用<code class="fe lf lg lh li b">Class</code>关键字:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/0e074058502e4744d077c1ff2d6ccbc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*JVvPqyvv59Qs78P4qplBOw.jpeg"/></div></figure><p id="a194" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有一些小差异，但不多。所有的东西都以相似的方式编写，并且操作几乎相同。甚至语法都很相似。</p><p id="3ef8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而在这个小例子中，不会有太多的不同。当我们将关键字<code class="fe lf lg lh li b">Class</code>的应用扩展到<code class="fe lf lg lh li b">getTime.js</code>时，我们会看到这些微小的差异会产生更大的影响。</p><p id="64b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们扩大项目规模越多，它们就越有用。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h2 id="d886" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated">小队目标</h2><p id="acc3" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">今天我们要用ES6的糖衣来重构我们旧的笨重的库。<code class="fe lf lg lh li b">getTime.js</code>的执行不会有任何不同，但在引擎盖下有足够的变化来保证一些解释。我们仍然希望通过函数调用返回我们添加到<code class="fe lf lg lh li b">getTime.js</code>中的方法，并坚持传入一个字符串参数来指定我们想要执行的方法。我们的函数构造函数仍将接受我们传递的参数并返回正确的调用，但也会利用ES6和它提供的甜蜜语法。</p><p id="0c26" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后，我们将把新重构的IIFC导入React，以确保一切正常。</p><p id="5cf8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果一切按计划进行，除了导入的文件名之外，我们不需要对React中编写的任何内容做任何修改。</p><p id="a5d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些变化都不是面向客户的。</p><p id="2a5b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最终，我们将拥有一个可读性更好的<code class="fe lf lg lh li b">getTime.js</code>版本，并节省大约4行代码。</p><p id="d0cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">哇哦！</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h2 id="0fff" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated">给我看看你在做什么</h2><p id="adc4" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">和以前一样，我们的文件结构将会很简单。我们在根目录下有<code class="fe lf lg lh li b">index.html</code>，在子目录下有<code class="fe lf lg lh li b">main.js</code>和<code class="fe lf lg lh li b">getTime.js</code>(现在是<code class="fe lf lg lh li b">getTimeES6.js</code>):</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/501339c961ba47984472a947bf52eacb.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*pWF3MXDnFzbXOATeG680dw.jpeg"/></div></figure><p id="b626" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lf lg lh li b">main.js</code>的目的是调用并执行<code class="fe lf lg lh li b">getTimeES6.js</code>。这是为了确保<code class="fe lf lg lh li b">getTimeES6.js</code>被正确地导出到任何其他需要它的JavaScript文件中，并且不管执行上下文如何都能正常工作。这使我们能够在需要的时候，在需要的地方使用它。<code class="fe lf lg lh li b">main.js</code>也将保持不变，除了重命名我们需要的文件。</p><p id="33f1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在main.js: </em></p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="c901" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lf lg lh li b">index.html</code>也将保持不变，加载<code class="fe lf lg lh li b">main.js</code>和<code class="fe lf lg lh li b">getTimeES6.js</code>以便我们可以在chrome中查看。它有一个名为<code class="fe lf lg lh li b">time</code>的<code class="fe lf lg lh li b">div</code>，所以我们可以用从<code class="fe lf lg lh li b">getTimeES6.js</code>调用的任何方法的返回值替换它的<code class="fe lf lg lh li b">innerHTML</code>。</p><p id="a3df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在index.html中:</em></p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="d82f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了我们的文件结构，我们就可以把<code class="fe lf lg lh li b">getTime.js</code>分解成我们的生命框架。我们将更换所有内部部件，但目前，让我们从一个相对干净的石板开始:</p><p id="a915" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在getTimeES6.js: </em></p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="46e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以开始用一些美味的ES6甜味重建<code class="fe lf lg lh li b">getTimeES6.js</code>。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h2 id="4097" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated">我们可以重建他…我们有技术</h2><p id="06aa" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我们要做的第一件事是替换我们最初拥有的<code class="fe lf lg lh li b">getTime</code>变量。<code class="fe lf lg lh li b">getTime</code>变量是一个函数，它创建了一个新的<code class="fe lf lg lh li b">getTime.init()</code>对象，并返回与我们传递给它的关键字相匹配的方法调用。</p><p id="9243" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它看起来像这样:</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="9213" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将用以下内容替换它:</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="713c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了<code class="fe lf lg lh li b">Class</code>关键字和我们接下来要写的内容的帮助，我们不需要创建一个单独的<code class="fe lf lg lh li b">getTime</code>函数构造器。我们仍然需要将<code class="fe lf lg lh li b">init</code>附加到全局执行上下文，然后返回我们正在调用的方法。多亏了ES6，我们可以省去一个步骤，让<code class="fe lf lg lh li b">init</code>返回一个匿名函数来创建一个新的<code class="fe lf lg lh li b">Class</code>。</p><p id="7aeb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，让我们开始建造我们的<code class="fe lf lg lh li b">getTime</code> <code class="fe lf lg lh li b">Class</code>。这将是<code class="fe lf lg lh li b">init</code>将要返回并附加到全局执行上下文的内容。</p><p id="124e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在getTimeES6.js: </em></p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="07e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们在<code class="fe lf lg lh li b">Person</code>示例中看到的，我们可以使用<code class="fe lf lg lh li b">constructor()</code>方法实例化<code class="fe lf lg lh li b">Class</code>。在<code class="fe lf lg lh li b">getTimeES6.js</code>的例子中，<code class="fe lf lg lh li b">constructor()</code>方法取代了我们的<code class="fe lf lg lh li b">getTime.init()</code>函数。它们将以完全相同的方式运行，但是我们新的<code class="fe lf lg lh li b">constructor()</code>方法将有一些看起来更简洁的语法:</p><p id="26d4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原来，<code class="fe lf lg lh li b">getTime.init()</code>长这样:</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="1b01" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用<code class="fe lf lg lh li b">constructor()</code>方法将其重构为:</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="5269" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简单。</p><p id="39b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们最初在<code class="fe lf lg lh li b">getTime.prototype</code>对象中写的东西呢？</p><p id="5431" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">事实证明，我们可以摆脱旧的原型对象:</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="5a42" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并把我们所有的函数写成我们<code class="fe lf lg lh li b">getTime</code> <code class="fe lf lg lh li b">Class</code>的实例方法:</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="66ad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是的。它也是如此简单。这对我来说更难理解，但最终，它真的很简单。</p><p id="ce3c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要做的最后一件事是将我们的<code class="fe lf lg lh li b">getTime</code> <code class="fe lf lg lh li b">Class</code>附加到全局执行上下文，对于React，在一个模块中导出它。</p><p id="f0f8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之前，<code class="fe lf lg lh li b">getTime.init.prototype</code>不得不纯粹通过引用继承<code class="fe lf lg lh li b">getTime.prototype</code>来建立一个原型链:</p><p id="6b43" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在getTime.js: </em></p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="fedc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是由于我们不需要处理原型对象，也不需要通过引用来重新赋值，我们可以只附加<code class="fe lf lg lh li b">init</code>函数的返回值，并用<code class="fe lf lg lh li b">init</code>变量替换<code class="fe lf lg lh li b">getTime</code>，因为<code class="fe lf lg lh li b">init</code>正在返回<code class="fe lf lg lh li b">getTime</code>T5本身:</p><p id="fcda" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在getTimeES6.js中:</em></p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="c0ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们结束了。</p><p id="2638" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是的，真的很简单。</p><p id="4324" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了确保一切仍然正常工作，让我们从<code class="fe lf lg lh li b">getTimeES6.js</code>内部<code class="fe lf lg lh li b">console.log()</code>我们所有的方法:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/5f06ca7448a5622399e0163e73f330e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*Eex0vgFVAKDcTON1x9cPMg.jpeg"/></div></figure><p id="af8c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太好了。</p><p id="e4c5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们从<code class="fe lf lg lh li b">main.js</code>和<code class="fe lf lg lh li b">console.log()</code>开始做同样的事情，我们所有的方法都要确保所有东西都被正确导出:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/bd4b561b3add6ea32e02a7ab5348d416.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*x3hjzGrlAuT2pvUpNjPdPw.jpeg"/></div></figure><p id="f2e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太棒了。</p><p id="04bf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们检查chrome，以确保我们有限的跨平台兼容性仍然有效:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nl"><img src="../Images/df8b80e5e096e34969ed198e65598c13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pNohlGV7kijb1BHleDgkXA.jpeg"/></div></div></figure><p id="35a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">惊人的。</p><p id="05aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们返回的所有内容都与之前在<code class="fe lf lg lh li b">getTime.js</code>中的内容相同，我们在React中需要重构的只是导入的名称:</p><p id="9ddd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在App.js中:</em></p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0264" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，让我们开始检查chrome，看看我们的React时钟是否还像以前一样工作，然后称这个博客任务完成:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nq"><img src="../Images/7b41178d61426e5bf8309c547d100c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_C7pmiPdfqJxpMV6Hs4iVg.gif"/></div></div></figure><p id="5fc1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">咻。</p><p id="3864" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我以为那会比实际困难得多。</p><p id="a4bd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是最后一次看<code class="fe lf lg lh li b">getTimeES6.js</code>:</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h2 id="765e" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated">任务完成</h2><p id="595c" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">那么这一切的目的是什么呢？为什么我没有以ES6和<code class="fe lf lg lh li b">Class</code>这个关键词开始这个博客系列，并到此为止呢？既然有更简单的方法，为什么要花5篇博客来解释像原型继承或作用域链这样的概念呢？</p><p id="7806" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我告诉你为什么。</p><p id="e221" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">理解JavaScript如何运行比记忆语法更重要。对于ES6和类，你没有太多的机会去了解在那些语法规则下实际发生了什么。</p><p id="f22e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就像学长除法一样。首先你要学习艰难的道路，然后你要学习捷径。这样做的好处是物有所值的。</p><p id="f72c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当涉及到调试错误或找出解决问题的最有效算法时，你从先做困难的事情中获得的知识和理解将引导你找到解决方案。</p><p id="2f88" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也就是说，我计划写最后一篇关于JavaScript函数构造器的博客。我仍然想将我们在React中为获取请求编写的IIFC转换成一个<code class="fe lf lg lh li b">Class</code>。</p><p id="a74f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我保证，我会告别JavaScript的函数构造器，走向更绿的牧场(也许)。</p><p id="e82e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在那之前:保持健康，继续为正义而战。</p><p id="c8cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="327c" class="nr lr it bd ls ns nt nu lv nv nw nx ly jz ny ka mb kc nz kd me kf oa kg mh ob bi translated">JavaScript函数构造</h1><p id="af5b" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/function-construction-whats-your-function-5a282b81fc62">第1部分</a> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/function-construction-part-2-f6a711075b11">第2部分</a> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-3-d673ff247541">第3部分</a> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-4-d532f0a5e4af">第4部分</a> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-5-90733a0e6369">第5部分</a> | <strong class="kk iu">第6部分</strong> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-7-17c5661e6ea7">第7部分</a></p></div></div>    
</body>
</html>