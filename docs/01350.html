<html>
<head>
<title>Map ⇄ Filter ⇄ Reduce</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">地图⇄滤波⇄减少</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/map-filter-reduce-da6bba6ea2eb?source=collection_archive---------5-----------------------#2019-12-16">https://levelup.gitconnected.com/map-filter-reduce-da6bba6ea2eb?source=collection_archive---------5-----------------------#2019-12-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4edc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">for循环很乱！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8167adaae4a29cbe9b447c4bb8431713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VBJZTQnKaJiPi4Ap"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@tine999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tine ivani</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><blockquote class="kw kx ky"><p id="d6aa" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><a class="ae kv" href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fwww.linkedin.com%2Fpulse%2Fmapfilterreduce-ashay-mandwarya%2F%3Fpublished%3Dt" rel="noopener ugc nofollow" target="_blank">分享到LinkedIn上！</a></p></blockquote><p id="1450" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><code class="fe lz ma mb mc b">for</code>循环是混乱的，这就是我们引入这三个高阶<em class="lb"> </em>函数的原因🗺️ <code class="fe lz ma mb mc b">map</code>，🥅 <code class="fe lz ma mb mc b">filter</code>，✂️ <code class="fe lz ma mb mc b">reduce</code>。所有这三个函数都是<code class="fe lz ma mb mc b">Array</code>原型的一部分，并对数组的内容进行操作。</p><p id="f65e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">但是在进入函数之前，让我们先明确一下什么是高阶函数和函数式编程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi md"><img src="../Images/4b7d42c0b7ca2172ce7503fdec68b44e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d2XhewvEZJ5Vfrtk"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@roman_lazygeek?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗马魔术师</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="15a2" class="me mf iq bd mg mh mi dn mj mk ml dp mm lw mn mo mp lx mq mr ms ly mt mu mv mw bi translated">函数式编程？</h2><p id="3554" class="pw-post-body-paragraph kz la iq lc b ld mx jr lf lg my ju li lw mz ll lm lx na lp lq ly nb lt lu lv ij bi translated">函数式编程是一种编程范式——一种构建计算机程序的结构和元素的风格——将计算视为数学函数的评估，并避免改变状态和可变数据— <a class="ae kv" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">维基百科</a></p><h2 id="ddcc" class="me mf iq bd mg mh mi dn mj mk ml dp mm lw mn mo mp lx mq mr ms ly mt mu mv mw bi translated">高阶函数</h2><p id="e8e2" class="pw-post-body-paragraph kz la iq lc b ld mx jr lf lg my ju li lw mz ll lm lx na lp lq ly nb lt lu lv ij bi translated">高阶函数是将其他函数作为参数或从另一个函数返回一个函数的函数。</p><h1 id="76ef" class="nc mf iq bd mg nd ne nf mj ng nh ni mm jw nj jx mp jz nk ka ms kc nl kd mv nm bi translated">Array.prototype.map() || map() ||🗺️</h1><p id="8ff6" class="pw-post-body-paragraph kz la iq lc b ld mx jr lf lg my ju li lw mz ll lm lx na lp lq ly nb lt lu lv ij bi translated"><code class="fe lz ma mb mc b"><strong class="lc ir">map()</strong></code>方法创建一个新数组，其结果是对调用数组中的每个元素调用一个提供的函数——MDN</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/8e73d1ef4715c3fab77af27c34c4a5b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AqSSL50daD3C9X3W"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@dead____artist?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">捕捉人心。</a>上<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">下</a></figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/2b5af14f0b079d654ee3de1639095a1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*NCltU_KCXLxlnuo0eO71pQ.png"/></div></figure><pre class="kg kh ki kj gt np mc nq nr aw ns bi"><span id="83b7" class="me mf iq mc b gy nt nu l nv nw">var arr = [5, 7, 4, 12];<br/>let map = arr.map(x =&gt; x * 7);<br/>console.log(map);</span></pre><p id="aacc" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">上面的代码接受数组中的每个元素，乘以7，然后放入一个新的数组中(由<code class="fe lz ma mb mc b">map</code>在内部完成)。</p><p id="79d2" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">下面的操作和上面的一样，但是有一个<code class="fe lz ma mb mc b">for</code>循环。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/4013c357131013cc876a82ad8b3452c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*af4G5TO0OAoRLPdDhT9BUA.png"/></div></figure><pre class="kg kh ki kj gt np mc nq nr aw ns bi"><span id="b55e" class="me mf iq mc b gy nt nu l nv nw">var arr = [5, 7, 4, 12];<br/>var newArr = [];<br/>var i = 0;<br/>for(i=0;i&lt;arr.length;i++) <br/>{<br/>  newArr.push(arr[i]*7)<br/>}<br/>console.log(newArr);</span></pre><p id="e975" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">使用了for循环一半的代码行，使我们的代码更加简洁。</p><p id="f636" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><code class="fe lz ma mb mc b">map</code>对数组中的每个元素执行提供的<code class="fe lz ma mb mc b">callback</code>函数，并根据结果构建一个新的数组。<code class="fe lz ma mb mc b">callback</code>只对数组包含值的索引调用。</p><p id="44d1" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><code class="fe lz ma mb mc b">map</code>构建一个新的数组，从不改变/变异旧的数组。</p><p id="af70" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们来解剖一下:</p><p id="7c95" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><strong class="lc ir">参数:</strong><code class="fe lz ma mb mc b">map</code>函数取的参数是一个回调函数，它依次取参数<code class="fe lz ma mb mc b">currentValue</code>、<code class="fe lz ma mb mc b">index</code>，原来的<code class="fe lz ma mb mc b">array</code>。</p><ul class=""><li id="738d" class="ny nz iq lc b ld le lg lh lw oa lx ob ly oc lv od oe of og bi translated"><strong class="lc ir">当前值</strong> →映射到回调函数处理的当前元素。</li><li id="34d7" class="ny nz iq lc b ld oh lg oi lw oj lx ok ly ol lv od oe of og bi translated"><strong class="lc ir"> index | </strong> <em class="lb">可选</em> →数组中正在处理的当前元素的索引。</li><li id="53a6" class="ny nz iq lc b ld oh lg oi lw oj lx ok ly ol lv od oe of og bi translated"><strong class="lc ir">数组| </strong> <em class="lb">可选</em> →调用<code class="fe lz ma mb mc b">map</code>的原点数组。</li></ul><p id="a9b3" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><strong class="lc ir"> Return: </strong> <code class="fe lz ma mb mc b">map</code>返回一个新数组，数组中的值由回调函数处理。</p></div><div class="ab cl om on hu oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ij ik il im in"><h1 id="933b" class="nc mf iq bd mg nd ot nf mj ng ou ni mm jw ov jx mp jz ow ka ms kc ox kd mv nm bi translated">array . prototype . filter()| | filter()| |🥅</h1><p id="8f1a" class="pw-post-body-paragraph kz la iq lc b ld mx jr lf lg my ju li lw mz ll lm lx na lp lq ly nb lt lu lv ij bi translated"><code class="fe lz ma mb mc b"><strong class="lc ir">filter()</strong></code>方法创建一个新数组，其中所有元素都通过了由所提供的函数MDN实现的测试</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/81b8eab8e6b50cd67d9ac94f8a617c4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UhEgOf8r4uPdv82s"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@wadeaustinellis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">韦德·奥斯汀·埃利斯</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/ddde1990e4550bd16679182bde697692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*04VV6YgSw_U3On3GaIysQQ.png"/></div></figure><pre class="kg kh ki kj gt np mc nq nr aw ns bi"><span id="5b3f" class="me mf iq mc b gy nt nu l nv nw">const cars  = ['Mclaren','Lamborghini','Ferrari','Porsche','Mercedes','Corvette'];</span><span id="2fb4" class="me mf iq mc b gy pa nu l nv nw">const car = cars.filter(e =&gt; e.length &gt; 7);<br/>console.log(car);</span></pre><p id="4559" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">上面的代码接收数组中的每个元素，检查元素长度是否大于7，并将其放入一个新的数组中(由<code class="fe lz ma mb mc b">filter </code>内部完成)。</p><p id="3913" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">功能相同，但有一个<code class="fe lz ma mb mc b">for</code>回路。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/41c587598e0999f8f43585d59c0b78c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gIj2tSUsz3PcP5NrjtYz7A.png"/></div></div></figure><pre class="kg kh ki kj gt np mc nq nr aw ns bi"><span id="6ea1" class="me mf iq mc b gy nt nu l nv nw">const cars = ['Mclaren','Lamborghini','Ferrari','Porsche','Mercedes','Corvette'];</span><span id="6ac2" class="me mf iq mc b gy pa nu l nv nw">const car=[]</span><span id="9014" class="me mf iq mc b gy pa nu l nv nw">for(let i=0;i&lt;cars.length;i++)<br/>{<br/>  if(cars[i].length&gt;7)<br/>    car.push(cars[i]);<br/>}<br/>console.log(car);</span></pre><p id="80cf" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">从3行到8行。</p><p id="9142" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><code class="fe lz ma mb mc b">filter</code>对数组中的每个元素调用提供的<code class="fe lz ma mb mc b">callback</code>函数，并根据结果构造一个新的数组。<code class="fe lz ma mb mc b">callback</code>仅返回满足条件的值，换句话说，返回导致回调评估为真的值。<code class="fe lz ma mb mc b">callback</code>只对数组中包含值的索引调用。</p><p id="2b6c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><code class="fe lz ma mb mc b">filter</code>构建一个新数组，从不改变/变异旧数组，它只是迭代旧数组。</p><p id="9389" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们来解剖一下:</p><p id="341b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><strong class="lc ir">参数:</strong><code class="fe lz ma mb mc b">filter</code>函数取的参数是一个回调函数，它依次取参数<code class="fe lz ma mb mc b">currentValue</code> <strong class="lc ir">、</strong> <code class="fe lz ma mb mc b">index</code>、<strong class="lc ir">、</strong>和原来的<code class="fe lz ma mb mc b">array</code> <strong class="lc ir">。</strong></p><ul class=""><li id="1797" class="ny nz iq lc b ld le lg lh lw oa lx ob ly oc lv od oe of og bi translated"><strong class="lc ir">当前值</strong> →由<code class="fe lz ma mb mc b">filter</code>处理的当前元素。</li><li id="4415" class="ny nz iq lc b ld oh lg oi lw oj lx ok ly ol lv od oe of og bi translated"><strong class="lc ir"> index | </strong> <em class="lb">可选</em> →数组中正在处理的当前元素的索引。</li><li id="8405" class="ny nz iq lc b ld oh lg oi lw oj lx ok ly ol lv od oe of og bi translated"><strong class="lc ir">数组| </strong> <em class="lb">可选</em> →调用<code class="fe lz ma mb mc b">filter</code>的原始数组。</li></ul><p id="c0d6" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><strong class="lc ir"> Return: </strong> <code class="fe lz ma mb mc b">filter</code>返回一个新数组，数组中的<code class="fe lz ma mb mc b">true</code>值由回调函数处理。</p></div><div class="ab cl om on hu oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ij ik il im in"><h1 id="1039" class="nc mf iq bd mg nd ot nf mj ng ou ni mm jw ov jx mp jz ow ka ms kc ox kd mv nm bi translated">array . prototype . reduce()| | reduce()| |✂️</h1><p id="3a6b" class="pw-post-body-paragraph kz la iq lc b ld mx jr lf lg my ju li lw mz ll lm lx na lp lq ly nb lt lu lv ij bi translated"><code class="fe lz ma mb mc b"><strong class="lc ir">reduce()</strong></code>方法对数组的每个成员执行<strong class="lc ir">缩减器</strong>函数(您提供的),产生一个输出值——MDN</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/fb153996efc308813160c7657fd9536e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WUJSH-vq5VYLet5p"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@plushdesignstudio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">毛绒设计工作室</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/5e443733d191b9f38b140bc67bea46af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*LH4P2pBNNOrmx0kqjW5gMg.png"/></div></figure><pre class="kg kh ki kj gt np mc nq nr aw ns bi"><span id="76ab" class="me mf iq mc b gy nt nu l nv nw">const arr = [3, 4, 2, 9];<br/>const reduce=(accumulator, currentValue)=&gt;accumulator+currentValue;<br/>console.log(arr.reduce(reduce));<br/>console.log(arr.reduce(reduce, 7));</span></pre><p id="d2ff" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在上面的代码中，我们创建了一个reduce函数，它将作为回调传递给<code class="fe lz ma mb mc b">reduce()</code>函数。该函数返回数组中所有元素的和。<code class="fe lz ma mb mc b">accumulator</code>存储每次迭代后元素的总和，而<code class="fe lz ma mb mc b">currentValue</code>表示当前正在处理的值。累加器的默认值为0，也可由用户定义，如第二个<code class="fe lz ma mb mc b">console.log</code>中的7。累加器作为最终结果返回。</p><p id="19a5" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">一个<code class="fe lz ma mb mc b">for</code>循环的相同功能。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/16a3c73511c4af0b71ebbf41c6c98b0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*ZgQ2ginULywqJGpb858RpA.png"/></div></figure><pre class="kg kh ki kj gt np mc nq nr aw ns bi"><span id="12cd" class="me mf iq mc b gy nt nu l nv nw">const arr = [3, 4, 2, 9];<br/>let a=0;<br/>for(let i=0;i&lt;arr.length;i++)<br/>{<br/>  a+=arr[i];<br/>}<br/>console.log(a);</span></pre><p id="784f" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们从3行增加到7行。</p><p id="f979" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><code class="fe lz ma mb mc b">reduce</code>对数组中的每个元素调用提供的<code class="fe lz ma mb mc b">callback</code>函数，并且只对数组包含值的索引调用。</p><p id="413a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><code class="fe lz ma mb mc b">callback</code>有4个参数:</p><ul class=""><li id="e8a7" class="ny nz iq lc b ld le lg lh lw oa lx ob ly oc lv od oe of og bi translated"><code class="fe lz ma mb mc b">accumulator</code></li><li id="ded1" class="ny nz iq lc b ld oh lg oi lw oj lx ok ly ol lv od oe of og bi translated"><code class="fe lz ma mb mc b">currentValue</code></li><li id="ffdf" class="ny nz iq lc b ld oh lg oi lw oj lx ok ly ol lv od oe of og bi translated"><code class="fe lz ma mb mc b">currentIndex</code></li><li id="9508" class="ny nz iq lc b ld oh lg oi lw oj lx ok ly ol lv od oe of og bi translated"><code class="fe lz ma mb mc b">array</code></li></ul><p id="953b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在处理第一个值之前第一次调用<code class="fe lz ma mb mc b">callback</code>时，<code class="fe lz ma mb mc b">currentValue</code>将是数组中的第一个元素，而<code class="fe lz ma mb mc b">accumulator</code>将具有数组中第一个元素的值或用户在<code class="fe lz ma mb mc b">reduce</code>函数中指定的值。</p><p id="96e6" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">如果累加器被提供一个值，那么<code class="fe lz ma mb mc b">reduce</code>将从索引1开始<code class="fe lz ma mb mc b">callback</code>并跳过第一个索引，因为<code class="fe lz ma mb mc b">accumulator</code>已经具有第一个索引的值。如果初始值由<code class="fe lz ma mb mc b">callback</code>提供，它将从第一个索引开始。</p><p id="f601" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">第一次调用回调时，<code class="fe lz ma mb mc b">accumulator</code>和<code class="fe lz ma mb mc b">currentValue</code>可以是两个值中的一个。如果在对<code class="fe lz ma mb mc b">reduce()</code>的调用中提供了<code class="fe lz ma mb mc b">initialValue</code>，那么<code class="fe lz ma mb mc b">accumulator</code>将等于<code class="fe lz ma mb mc b">initialValue</code>，而<code class="fe lz ma mb mc b">currentValue</code>将等于数组中的第一个值。如果没有提供<code class="fe lz ma mb mc b">initialValue</code>，那么<code class="fe lz ma mb mc b">accumulator</code>将等于数组中的第一个值，而<code class="fe lz ma mb mc b">currentValue</code>将等于第二个值。</p><p id="c1b5" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">如果数组为空并且没有给<code class="fe lz ma mb mc b">accumulator</code>初始值，则抛出<code class="fe lz ma mb mc b">TypeError</code>。</p><p id="55da" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">提供初始值通常更安全，因为没有<code class="fe lz ma mb mc b">initialValue</code>有三种可能的输出，如下例所示。</p><p id="2df8" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们来解剖一下:</p><p id="1be2" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><strong class="lc ir">参数:</strong><code class="fe lz ma mb mc b">reduce</code>函数取的参数是一个回调函数，也是可选的(但推荐)<code class="fe lz ma mb mc b">initialValue</code>。回调依次带参数<code class="fe lz ma mb mc b">accumulator</code>、<code class="fe lz ma mb mc b">currentValue</code>、<code class="fe lz ma mb mc b">index</code>和原<code class="fe lz ma mb mc b">array</code>。</p><ul class=""><li id="6135" class="ny nz iq lc b ld le lg lh lw oa lx ob ly oc lv od oe of og bi translated"><strong class="lc ir">累加器</strong> —累加器累加回调的返回值。它是上次调用回调时返回的累积值，或者是<code class="fe lz ma mb mc b">initialValue</code>(如果提供了的话)。</li><li id="409e" class="ny nz iq lc b ld oh lg oi lw oj lx ok ly ol lv od oe of og bi translated"><strong class="lc ir">当前值</strong> — <strong class="lc ir"> </strong>由<code class="fe lz ma mb mc b">reduce</code>处理的是当前元素。</li><li id="f019" class="ny nz iq lc b ld oh lg oi lw oj lx ok ly ol lv od oe of og bi translated"><strong class="lc ir"> index | </strong> <em class="lb">可选— </em>数组中正在处理的当前元素的索引。</li><li id="0371" class="ny nz iq lc b ld oh lg oi lw oj lx ok ly ol lv od oe of og bi translated"><strong class="lc ir"> array | </strong> <em class="lb">可选— </em>调用<code class="fe lz ma mb mc b">reduce</code>的数组。</li></ul><p id="fcd2" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><strong class="lc ir"> Return: </strong> <code class="fe lz ma mb mc b">reduce</code>返回每个元素处理后剩下的值(<code class="fe lz ma mb mc b">accumulator</code>的最终值)。</p></div><div class="ab cl om on hu oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ij ik il im in"><h1 id="dd96" class="nc mf iq bd mg nd ot nf mj ng ou ni mm jw ov jx mp jz ow ka ms kc ox kd mv nm bi translated">链接。map()，。reduce()和。过滤器()||🗺️🥅✂️</h1><p id="00de" class="pw-post-body-paragraph kz la iq lc b ld mx jr lf lg my ju li lw mz ll lm lx na lp lq ly nb lt lu lv ij bi translated">正如我们所见，<code class="fe lz ma mb mc b">reduce</code>、<code class="fe lz ma mb mc b">filter</code>和<code class="fe lz ma mb mc b">map</code>本身就非常强大，但是最棒的是它们都在数组上工作，因此可以链接在一起。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pf"><img src="../Images/4988450c6ea1020c00854becab4707f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nuVmwaCyX-mOEGkv"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">凯瑟琳·切斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="efb0" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">让我们举个例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/6976feec2fda7be0f1ff708eb74cdf5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*ZifpWwwP-io6P710qRhVoQ.png"/></div></figure><pre class="kg kh ki kj gt np mc nq nr aw ns bi"><span id="eb5b" class="me mf iq mc b gy nt nu l nv nw">var cars = [{<br/>name: "Lamborghini",<br/>maxSpeed:320,<br/>beauty:99<br/>},{<br/>name: "Lamborghini",<br/>maxSpeed:340,<br/>beauty:99<br/>},{<br/>name: "Ferrari",<br/>maxSpeed:310,<br/>beauty:99<br/>},{<br/>name: "Porsche",<br/>maxSpeed:330,<br/>beauty:99<br/>},{<br/>name: "Lamborghini",<br/>maxSpeed:300,<br/>beauty:99<br/>}];</span></pre><p id="d8e9" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">以上是我们将要处理的数据。我们必须找出所有兰博基尼的总分。</p><p id="4706" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这是一行程序:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/f05ec6eeb8f91c631fcebdee7101d4af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HNe1mMLv7Jgb2eztqeBmQQ.png"/></div></div></figure><p id="7e4b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">结果:1243</p><p id="4760" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">对于一个<code class="fe lz ma mb mc b">for</code>循环，我们不得不创建3个循环，这将是相当混乱的。</p><p id="9f38" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">代码的工作方式如下:</p><ul class=""><li id="0afb" class="ny nz iq lc b ld le lg lh lw oa lx ob ly oc lv od oe of og bi translated"><code class="fe lz ma mb mc b">filter</code>过滤器找到名字为<strong class="lc ir">兰博基尼的所有汽车。</strong></li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/f6972b49b115a427b789fd9059ce3755.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*TuG09kRgsmvvAXmk9RFObQ.png"/></div></figure><ul class=""><li id="967c" class="ny nz iq lc b ld le lg lh lw oa lx ob ly oc lv od oe of og bi translated"><code class="fe lz ma mb mc b">map</code> <em class="lb"> </em>贴图对过滤器返回的数组进行处理，并对美景和top_speed属性进行汇总。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/0966b30a19552cfe92779161afdf08c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:248/format:webp/1*laz3UKF7jIk8xzFtEDxYrw.png"/></div></figure><ul class=""><li id="3cca" class="ny nz iq lc b ld le lg lh lw oa lx ob ly oc lv od oe of og bi translated"><code class="fe lz ma mb mc b">reduce</code> <em class="lb"> </em>该函数获取地图返回的数组，并对所有值求和，返回所有兰博基尼的总和。1243</li></ul><h1 id="a14e" class="nc mf iq bd mg nd ne nf mj ng nh ni mm jw nj jx mp jz nk ka ms kc nl kd mv nm bi translated">结论</h1><p id="ffbc" class="pw-post-body-paragraph kz la iq lc b ld mx jr lf lg my ju li lw mz ll lm lx na lp lq ly nb lt lu lv ij bi translated">我希望我让这些函数更容易理解。将所有3个函数链接在一起会使这成为一个庞然大物，因为我们在编写长度小且易于调试的干净代码时会得到我们的结果。</p><p id="7d3e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">拍手&amp; <a class="ae kv" href="https://medium.com/@ashaymurceilago" rel="noopener">跟着</a>走。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl pk"><img src="../Images/195595f82362016f757ecfef24b22d4d.png" data-original-src="https://miro.medium.com/v2/1*puO9QPsENQ5ww1QKNuf6tw.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">谷歌</figcaption></figure></div></div>    
</body>
</html>