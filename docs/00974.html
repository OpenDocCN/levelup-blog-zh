<html>
<head>
<title>Use Go Channels as Promises and Async/Await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Go通道作为承诺和异步/等待</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/use-go-channels-as-promises-and-async-await-ee62d93078ec?source=collection_archive---------0-----------------------#2019-10-04">https://levelup.gitconnected.com/use-go-channels-as-promises-and-async-await-ee62d93078ec?source=collection_archive---------0-----------------------#2019-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/541d0ab9fe05d60578820d656a6418df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kwRlZtjKU4x8Lk4VzbNK5g.jpeg"/></div></div></figure><div class=""/><p id="1af7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你曾经用<em class="kw"> Javascript </em>编程，你肯定知道<code class="fe kx ky kz la b">Promise</code>和<code class="fe kx ky kz la b">async</code> / <code class="fe kx ky kz la b">await</code>。<em class="kw"> C# </em>、<em class="kw"> Java、【Python】、</em>等一些编程语言都应用了同样的模式，只是用了其他的名字比如<code class="fe kx ky kz la b">Task</code>或者<code class="fe kx ky kz la b">Future</code>。</p><p id="6203" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相反，围棋完全不按套路出牌。而是引入了<code class="fe kx ky kz la b">goroutines</code>和<code class="fe kx ky kz la b">channels</code>。然而，用<code class="fe kx ky kz la b">goroutines</code>和<code class="fe kx ky kz la b">channels</code>复制模式并不难。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="642e" class="li lj jb bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">单一异步/等待</h1><p id="e31c" class="pw-post-body-paragraph jy jz jb ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">首先，让我们试验一个简单的用例:<code class="fe kx ky kz la b">await</code>来自<code class="fe kx ky kz la b">async</code>函数的结果。</p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">Javascript与Golang中的单异步/等待</figcaption></figure><p id="4560" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要在Go中声明一个“异步”函数:</p><ul class=""><li id="7b02" class="mv mw jb ka b kb kc kf kg kj mx kn my kr mz kv na nb nc nd bi translated">返回类型为<code class="fe kx ky kz la b">&lt;-chan ReturnType</code>。</li><li id="b6e2" class="mv mw jb ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">在函数内，通过<code class="fe kx ky kz la b">make(chan ReturnType)</code>创建一个通道，并在函数结束时返回创建的通道。</li><li id="c84d" class="mv mw jb ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">通过<code class="fe kx ky kz la b">go func() {...}</code>启动一个匿名goroutine，并在该匿名函数中实现函数的逻辑。</li><li id="e792" class="mv mw jb ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">通过将值发送到通道来返回结果。</li><li id="22c4" class="mv mw jb ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">在匿名函数的开头，添加<code class="fe kx ky kz la b">defer close(r)</code>来关闭通道。</li></ul><p id="c405" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要“等待”结果，只需通过<code class="fe kx ky kz la b">v := &lt;- fn()</code>从通道读取值。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="1a00" class="li lj jb bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">Promise.all()</h1><p id="edae" class="pw-post-body-paragraph jy jz jb ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">我们开始多个异步任务，然后等待它们全部完成并收集它们的结果，这是很常见的。在Javascript和Golang中做到这一点非常简单。</p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="786d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们必须用2行代码完成它，并引入3个变量，但是它足够干净简单。</p><p id="a218" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以不做<code class="fe kx ky kz la b">&lt;-longRun(), &lt;-longRun(), &lt;-longRun()</code>，它会一个接一个的做<code class="fe kx ky kz la b">longRun()</code>而不是一次全做。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="7cfa" class="li lj jb bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">承诺.竞赛()</h1><p id="ee07" class="pw-post-body-paragraph jy jz jb ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">有时，可以从几个来源接收一条数据以避免高延迟，或者存在这样的情况，即生成多个结果，但它们是等效的，并且只消耗第一个响应。因此，这种先反应后胜利的模式很受欢迎。在Javascript和Go中实现这一点非常简单。</p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="089c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">select-case</code>是Go专为赛车频道运营设计的模式。我们甚至可以在每个案例中做更多的事情，但是我们只关注结果，所以我们让它们都为空。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="89d5" class="li lj jb bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">Promise.then()和Promise.catch()</h1><p id="9deb" class="pw-post-body-paragraph jy jz jb ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">因为Go的错误传播模型与Javascript非常不同，所以有任何干净的方法来复制<code class="fe kx ky kz la b">Promise.then()</code>和<code class="fe kx ky kz la b">Promise.catch()</code>。在Go中，错误与返回值一起返回，而不是作为异常抛出。因此，如果您的函数可能失败，您可以考虑将您的返回<code class="fe kx ky kz la b">&lt;-chan ReturnType</code>更改为<code class="fe kx ky kz la b">&lt;-chan ReturnAndErrorType</code>，这是一个保存结果和错误的结构。</p></div></div>    
</body>
</html>