<html>
<head>
<title>Bellman–Ford</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">行李员–福特</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/bellman-ford-6bd907c6c4c0?source=collection_archive---------15-----------------------#2022-09-27">https://levelup.gitconnected.com/bellman-ford-6bd907c6c4c0?source=collection_archive---------15-----------------------#2022-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b43a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">贝尔曼-福特算法类似于Dijkstra它有助于找到连接到源节点的所有顶点的最短路径。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/95e7d532ede19384e060c37c6b9e910d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uts95AFoaPpVhKzCUIrh1g.png"/></div></div></figure><p id="2a47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">它的工作原理是跟踪最短路径</strong>中从原点到前一个节点的权重距离，在边/连接上循环n次(n是节点/顶点的数量)，并更新到目的地的最快路径。与Dijkstra相反，它可以处理负权重，甚至检测负圆圈，但速度较慢(效率较低)。</p><p id="62fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了使它更简单，让我们定义两个简单的数据结构，首先描述一个加权连接和前面的路径。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="8c37" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">加权连接包含源索引、目标索引和权重。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="37a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">加权前一路径跟踪前一顶点/节点索引和从源到当前节点的总权重。</p><p id="9c3a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">我们来深究一下算法</strong>；代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="f254" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个函数需要接收:源节点的索引、图中的节点数和所有连接。</p><p id="ff14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们创建包含结果的数组；默认情况下，我们将总权重初始化为Int.maximum(从纯数学的角度来说，我们应该使用Infinity，但是没有Int。swift中的无穷大)没有先前的。我们将源节点本身设置为previous，总权重为0(从源节点到源节点的开销为0)。</p><p id="e9d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们将对所有连接进行n次迭代(其中n是节点数)。</p><p id="ed74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后对于每个连接，如果连接源总权重加上这个连接权重小于实际目的地总权重，我们就替换它。</p><p id="5095" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用hasUpdatedWeights标志进行一些优化；如果在所有连接的一次迭代中没有权重变化，这意味着不会再有了，那么我们可以停止外部循环。</p><p id="6143" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于最后一次运行循环(当索引等于nodesCount — 1时)，应该不会再有变化；如果有，这意味着我们正处于一个消极的循环中。</p><p id="2718" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> Bellman-Ford算法比Dijkstra算法更直接，对负数也有效，但这是有代价的，因为我们对n(节点数)迭代所有连接c，时间复杂度为O(c*n) </strong></p><p id="29ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是如何使用它的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="ac73" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lz" href="https://medium.com/@jbstevenard/dijkstra-62356e584680" rel="noopener"> &lt; &lt; Dijkstra </a> | <a class="ae lz" href="https://medium.com/@jbstevenard/learn-data-structures-and-algorithms-with-swift-5-6-d9f36a4027dd" rel="noopener">本书</a> | <a class="ae lz" href="https://medium.com/@jbstevenard/bit-manipulation-2bb98208832e" rel="noopener">钻头操纵&gt; &gt; </a></p><div class="ma mb gp gr mc md"><a href="https://medium.com/@jbstevenard/membership" rel="noopener follow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd iu gy z fp mi fr fs mj fu fw is bi translated">通过我的推荐链接加入Medium—JB stevenard</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">阅读jb stevenard的每一个故事(以及媒体上成千上万的其他作家)。你的会员费直接支持jb…</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">medium.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr ks md"/></div></div></a></div></div></div>    
</body>
</html>