<html>
<head>
<title>Writing Tests for a Foolproof Django Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为一个简单的Django项目编写测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/writing-tests-for-a-foolproof-django-project-3c5527bd602d?source=collection_archive---------7-----------------------#2022-05-17">https://levelup.gitconnected.com/writing-tests-for-a-foolproof-django-project-3c5527bd602d?source=collection_archive---------7-----------------------#2022-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c27d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何用Django编写多层测试实现100%的测试覆盖率</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/293381560459d4ca0d344cb4e3561e85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EY4Khm83Zf06n0eZeWQ44g.png"/></div></figure><p id="ffb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从回答一个问题开始，当你在写代码的时候，你有多在乎写测试？嗯，我想这真的取决于你目前正在做什么样的项目，以及你需要做多少工作来完成这个项目。</p><p id="3257" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我看来，如果我们有这么紧的截止日期和很多事情要做，我们会忘记写测试，并产生一个无测试的代码。但是如果你不写测试，那么测试就不会失败，对吗？😁</p><p id="f30a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果没有测试，那么每当我们改变一些东西或者重构代码的时候，我们都需要手工检查我们的代码。这当然不是一件好事，我要说这是一个非常糟糕的项目设计。</p><p id="3817" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就像雅各布·卡普兰-莫斯<em class="kt">(Django web框架的核心开发者之一)</em>说的……</p><blockquote class="ku kv kw"><p id="d0e8" class="jn jo kt jp b jq jr js jt ju jv jw jx kx jz ka kb ky kd ke kf kz kh ki kj kk ij bi translated"><em class="iq">“没有测试的代码被设计破坏了。”</em></p></blockquote><p id="c299" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">了解了这一点，这篇文章将带你编写一个经过全面测试的待办事项应用程序，希望它能万无一失。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="e218" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">先决条件</h1><p id="0847" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">在继续之前，虽然本文将带您构建一个完全测试过的项目，但我假设您已经对Django有了一些基本的了解，因为我倾向于忽略实际的代码，而倾向于编写测试代码。然而，我仍然会给出实际的代码，并给出一些简要的解释。</p><p id="a150" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一点免责声明，因为会有很多测试用例，所以我只为每一层提供一个片段，但你可以在这里获得完整的代码(实际和测试代码):</p><div class="mk ml gp gr mm mn"><a href="https://github.com/agusrichard/django-workbook/tree/master/todo-live-tests" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd ir gy z fp ms fr fs mt fu fw ip bi translated">django-workbook/todo-live-master agusrichard的测试/django-workbook</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">该项目作为媒体文章的编码材料。文章本身谈到了多层测试在…</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">github.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb kr mn"/></div></div></a></div><p id="68d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从建立我们的Django项目开始。</p><p id="d5d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过运行以下命令创建一个Python虚拟环境:</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="376c" class="nh li iq nd b gy ni nj l nk nl">python -m venv venv</span></pre><p id="4133" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">激活虚拟环境:</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="0891" class="nh li iq nd b gy ni nj l nk nl"># Mac OS / Linux<br/>source /bin/activate</span><span id="1dac" class="nh li iq nd b gy nm nj l nk nl"># Windows<br/>venv\Scripts\activate</span></pre><p id="185e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装依赖项:</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="15b0" class="nh li iq nd b gy ni nj l nk nl">pip install django coverage selenium</span></pre><p id="f766" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为这个应用程序相当简单，所以我们只需要三个主要的依赖项。我们需要<code class="fe nn no np nd b">coverage</code>来了解我们的测试覆盖范围，需要<code class="fe nn no np nd b">selenium</code>来运行功能测试。</p><p id="0a36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建Django项目和Todo应用程序</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="6c40" class="nh li iq nd b gy ni nj l nk nl"># Create Django project<br/>django-admin startproject core .</span><span id="6dec" class="nh li iq nd b gy nm nj l nk nl"># Create Todo Application<br/>python manage.py startapp todo</span></pre><p id="f5c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们已经建立了我们的项目。在下一节中，我们将从<code class="fe nn no np nd b">models</code>开始，一步一步地研究多层单元代码。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="18d5" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">模型</h1><h2 id="5dd4" class="nh li iq bd lj nq nr dn ln ns nt dp lr jy nu nv lv kc nw nx lz kg ny nz md oa bi translated">实际代码</h2><p id="87be" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">进入<code class="fe nn no np nd b">todo</code>文件夹，打开<code class="fe nn no np nd b">models.py</code>。将这段代码放在这里:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="d50d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它只是一个基本的Todo模型，由标题、描述、已完成、created_at和用户组成。请注意，我使用的是默认的用户模型。您当然可以使用自己的定制用户模型。</p><p id="a2b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想要运行服务器，您需要首先创建迁移脚本并进行迁移。</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="c538" class="nh li iq nd b gy ni nj l nk nl"># Make migration script<br/>python manage.py makemigrations</span><span id="6a23" class="nh li iq nd b gy nm nj l nk nl"># Migrate<br/>python manage.py migrate</span><span id="1ddd" class="nh li iq nd b gy nm nj l nk nl"># Run server<br/>python manage.py runserver</span></pre><p id="00e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目前，我们还没有<code class="fe nn no np nd b">views</code>，所以我们无法与我们的应用程序交互。稍后我们将创建<code class="fe nn no np nd b">views</code>。</p><h2 id="df91" class="nh li iq bd lj nq nr dn ln ns nt dp lr jy nu nv lv kc nw nx lz kg ny nz md oa bi translated">试验码</h2><p id="da9a" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">我们将在这一小节中编写我们的第一个测试。因为对于这个项目，我们将编写多层测试，所以最好有一个专门的文件夹来存储所有这些测试。首先，我们需要在<code class="fe nn no np nd b">todo</code>文件夹中新建一个名为<code class="fe nn no np nd b">tests</code>的文件夹。注意，还有其他方法来组织测试代码，但是在这种情况下，我将使用一种方法，即每个Django应用程序都有自己的测试文件夹。</p><p id="17f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个名为<code class="fe nn no np nd b">test_models.py</code>的文件，并将初始代码放在那里:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="fd84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们的第一个测试函数。在上面，我们创建了一个继承了<code class="fe nn no np nd b">unittest.TestCase</code>的测试类。这个类将作为模型的所有测试用例的套件/模块。</p><p id="4a95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nn no np nd b">setUp</code>方法将负责用户初始化，所以我们不需要在每个测试函数中创建一个新用户。注意，t <code class="fe nn no np nd b">setUp</code>方法将在每个测试函数之前运行，如果你需要在每个测试函数之后做一些清理，你可以使用<code class="fe nn no np nd b">tearDown</code>方法。</p><p id="835c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你可能已经猜到的，我们将有正面和负面的测试用例，因为如果我们想要构建一个万无一失的项目，我确信必须覆盖整个范围的用户输入和行为肯定会使我们的项目健壮。这正是我们在这里要做的。</p><p id="95bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们来看看其他测试用例:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="a3a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，我们有13个测试只针对Todo模型。</p><p id="25ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我看来，在编写测试时有两件事很重要，第一件是确保避免假阳性测试。您可以做的一件事是更改断言条件，从断言等于改为断言不等于。如果在一个条件下测试通过，那么在另一个条件下，测试肯定不会通过。这是一个我们经常忘记的重要的理智检查。</p><p id="02d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一件重要的事情是，当你想让你的项目万无一失时，你需要考虑许多可能的输入排列。如果您有很多输入，那么要包含的测试数量将会激增。所以，这又回到了编写测试的时间和及时完成任务之间的权衡。</p><p id="d880" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一点提醒，每个测试总是由三个步骤组成，它们是安排-行动-断言。以上面的代码为例，首先我们创建一个将创建todo的用户，然后创建todo，然后断言该todo是否确实是我们所期望的。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="a600" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">形式</h1><h2 id="28f3" class="nh li iq bd lj nq nr dn ln ns nt dp lr jy nu nv lv kc nw nx lz kg ny nz md oa bi translated">实际代码</h2><p id="0e3c" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">现在，我们将工作在不同的层，<code class="fe nn no np nd b">forms</code>层。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="1d8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单明了，对吗？</p><h2 id="18b4" class="nh li iq bd lj nq nr dn ln ns nt dp lr jy nu nv lv kc nw nx lz kg ny nz md oa bi translated">试验码</h2><p id="4d6f" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">与<code class="fe nn no np nd b">models</code>的测试代码相比，这里，我们将重点放在<code class="fe nn no np nd b">UserForm</code>和<code class="fe nn no np nd b">TodoForm</code>上</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="02dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码只是<code class="fe nn no np nd b">forms</code>整个测试代码的一个片段。您可以在本文的代码资源中直接查看其余部分。</p><p id="1f59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">非常类似于<code class="fe nn no np nd b">models</code>的测试代码。我们有<code class="fe nn no np nd b">setUp</code>方法来初始化用户数据(我们需要它来创建一个有效的todo)。然后将新创建的用户分配给<code class="fe nn no np nd b">self.user</code>，这样我们就可以在每个测试功能中访问这个用户。</p><p id="c83d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用<code class="fe nn no np nd b">form.is_valid()</code>来检查用户的输入是否有效，并且我们可以通过访问<code class="fe nn no np nd b">form.errors[“field_name”]</code>来断言表单的错误信息。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="5cf5" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">视图</h1><h2 id="8a50" class="nh li iq bd lj nq nr dn ln ns nt dp lr jy nu nv lv kc nw nx lz kg ny nz md oa bi translated">实际代码</h2><p id="6126" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">下面是<code class="fe nn no np nd b">view.py</code>文件的内容</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="0078" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们有八个视图函数，其中三个与认证相关，其余的与Todo CRUD操作相关。为了正确运行这个服务器，我们需要创建所有的模板。但是我选择忽略这件事，你可以在这里得到HTML模板<a class="ae od" href="https://github.com/agusrichard/django-workbook/tree/master/todo-live-tests/templates/todo" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="2dab" class="nh li iq bd lj nq nr dn ln ns nt dp lr jy nu nv lv kc nw nx lz kg ny nz md oa bi translated">试验码</h2><p id="dfb0" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">我们可以通过使用测试客户端来测试<code class="fe nn no np nd b">views</code>。首先，我们需要从<code class="fe nn no np nd b">django.test</code>导入<code class="fe nn no np nd b">Client</code>并在<code class="fe nn no np nd b">setUp</code>方法中初始化它。之后，我们可以在每个测试函数中使用它。以下是<code class="fe nn no np nd b">views</code>的测试代码</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="d400" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就像以前一样，这里只有代码片段，您可以在编码材料中找到其余部分。</p><p id="593c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们以注册用户为例。首先，在<code class="fe nn no np nd b">setUp</code>方法中，我们初始化测试客户端，现在来看看测试函数<code class="fe nn no np nd b">test_register_user_GET</code>。这里，我们调用注册URL并断言它的响应，比如它的状态代码和用于呈现注册页面的模板。</p><p id="88ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再举一个测试函数<code class="fe nn no np nd b">test_negative_home_user_not_logged_in</code>内部的例子。这里，我们还检查了<code class="fe nn no np nd b">context</code>字典中的值。基本上，这是一个注入到Django模板中的字典，我们可以检查这个<code class="fe nn no np nd b">context</code>字典中的值。在上面的代码中，我检查了用户是否已经登录(如果<code class="fe nn no np nd b">is_authenticated</code>为真，则用户已经登录)。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="343d" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">资源定位符</h1><h2 id="ccbc" class="nh li iq bd lj nq nr dn ln ns nt dp lr jy nu nv lv kc nw nx lz kg ny nz md oa bi translated">实际代码</h2><p id="c822" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">这里是我们注册<code class="fe nn no np nd b">views</code>到<code class="fe nn no np nd b">urls</code>的地方。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="3777" class="nh li iq bd lj nq nr dn ln ns nt dp lr jy nu nv lv kc nw nx lz kg ny nz md oa bi translated">试验码</h2><p id="96ac" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">与测试其他层相比，测试<code class="fe nn no np nd b">urls</code>被认为不是那么重要。因为当我们测试<code class="fe nn no np nd b">views</code>时，我们实际上同时也在测试<code class="fe nn no np nd b">urls</code>。为了完整性，我选择提供这些测试。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ob oc l"/></div></figure></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="0cc0" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">功能测试</h1><p id="d39a" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">现在，我们到达了最终的测试代码。在继续之前，您需要下载基于您的Chrome版本的Selenium。然后，您可以将<code class="fe nn no np nd b">chromedriver</code>放在项目根文件夹中名为<code class="fe nn no np nd b">driver</code>的文件夹中。</p><p id="3ac0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后添加新的附加变量到<code class="fe nn no np nd b">settings.py</code></p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="3b79" class="nh li iq nd b gy ni nj l nk nl"># For Windows<br/>WEB_DRIVER_PATH = os.path.join(BASE_DIR, "driver", "chromedriver.exe")</span><span id="b94f" class="nh li iq nd b gy nm nj l nk nl"># Running functional tests without opening up a chrome window<br/>WEB_DRIVER_HEADLESS = True</span></pre><p id="08e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是测试代码的片段。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="8b3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，对于功能测试，我们实际上没有继承<code class="fe nn no np nd b">unittest.TestCase</code>，相反，测试类继承了<code class="fe nn no np nd b">StaticLiveServerTestCase</code>。</p><p id="344f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，我们在<code class="fe nn no np nd b">setUp</code>方法中设置Selenium web驱动程序，并在<code class="fe nn no np nd b">tearDown</code>方法中退出web驱动程序。对于测试代码的其余部分，我们遵循排列-动作-断言原则。找到我们想要与之交互的元素，对其进行操作(比如点击或输入)并断言行为和结果。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="1e1d" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">新闻报道</h1><p id="fe2b" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">我们已经为所有的层编写了所有的测试，但是我向你保证的100%的测试覆盖率怎么样呢？我们现在就谈这个！</p><p id="ed64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，创建<code class="fe nn no np nd b">.coveragerc</code>来存储测试覆盖设置。我们将省略<code class="fe nn no np nd b">manage.py</code>和<code class="fe nn no np nd b">venv</code>中的所有文件:</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="479e" class="nh li iq nd b gy ni nj l nk nl">[run]<br/>omit =<br/>  */manage.py<br/>  ./venv/*</span></pre><p id="6f41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过运行以下命令来了解测试覆盖率:</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="d3e9" class="nh li iq nd b gy ni nj l nk nl">coverage run ./manage.py test</span></pre><p id="507f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过运行上面的命令，我们创建了一个名为<code class="fe nn no np nd b">.coverage</code>的文件。我们将从这个文件中得到报告。</p><p id="effd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">获取测试覆盖报告:</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="a31d" class="nh li iq nd b gy ni nj l nk nl">coverage report</span></pre><p id="0938" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过运行以下命令获得漂亮的HTML报告:</p><pre class="km kn ko kp gt nc nd ne nf aw ng bi"><span id="4833" class="nh li iq nd b gy ni nj l nk nl">coverage html</span></pre><p id="dda3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以上命令将创建<code class="fe nn no np nd b">htmlcov</code>文件夹。然后，您可以打开<code class="fe nn no np nd b">index.html</code>来查看测试覆盖率。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="of og di oh bf oi"><div class="gh gi oe"><img src="../Images/b0c3c3b7c207bbb33e2a4562f479fbd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rE7xkQMY5_67vs5qm7Uc4g.png"/></div></div><figcaption class="oj ok gj gh gi ol om bd b be z dk translated">作者形象</figcaption></figure><p id="fdb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">瞧，我们实现了100%的测试覆盖率…祝贺你！</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="83b7" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="6b21" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">在本文中，我们学习了如何为典型的Django项目中的每一层编写测试。我们涵盖了如何编写模型、表单、视图、URL和功能测试。</p><p id="5790" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我强烈建议您查看编码材料中的最终代码，因为我倾向于忽略实际的代码，而只给出整个测试代码的片段。因为我不想让你因为不得不列出所有的测试用例而感到厌烦。</p><p id="7dd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总之，我相信编写测试代码和实际代码一样重要，因为测试给了我们可预测性，至少给了我们高度的可预测性。我们不希望我们的代码出现不可预测的行为，并且发现到处潜伏着未被注意到的错误。此外，看着这些绿色的“OK”或“PASSED”单词对我来说总是一种有趣的体验，对吗？</p><p id="0018" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文的编码材料:</p><div class="mk ml gp gr mm mn"><a href="https://github.com/agusrichard/django-workbook/tree/master/todo-live-tests" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd ir gy z fp ms fr fs mt fu fw ip bi translated">django-workbook/todo-live-master agusrichard的测试/django-workbook</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">该项目作为媒体文章的编码材料。文章本身谈到了多层测试在…</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">github.com</p></div></div><div class="mw l"><div class="on l my mz na mw nb kr mn"/></div></div></a></div><p id="9220" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢您的阅读和快乐编码！</p></div></div>    
</body>
</html>