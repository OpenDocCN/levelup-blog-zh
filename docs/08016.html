<html>
<head>
<title>Features Java 16 Brings to Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 16带给开发者的特性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/features-java-16-brings-to-developers-b0edd1a1ed28?source=collection_archive---------20-----------------------#2021-03-28">https://levelup.gitconnected.com/features-java-16-brings-to-developers-b0edd1a1ed28?source=collection_archive---------20-----------------------#2021-03-28</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="d451" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">了解模式匹配、密封类和更多新的Java特性。</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/75c79a6116e8c24b7e5e0ba8da8499bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5KUlVuW1VBTTOi5w"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://www.pexels.com/@divinetechygirl?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">克里斯蒂娜·莫里洛</a>从<a class="ae kz" href="https://www.pexels.com/photo/person-using-macbook-pro-on-person-s-lap-1181298/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄</figcaption></figure><p id="79de" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Java无需介绍。这是一种已经有多年历史的编程语言。最近的更新为该语言带来了几个新特性:密封类、模式匹配和附加的安全措施。</p><h1 id="80ca" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">密封类</h1><p id="4477" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated"><a class="ae kz" href="https://openjdk.java.net/jeps/397" rel="noopener ugc nofollow" target="_blank"> JEP-397 </a></p><p id="5234" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe mt mu mv mw b">sealed</code>背后的动机是限制具体的类。限制具体的类，将控制实现，并为模式匹配提供支持。</p><pre class="kk kl km kn gu mx mw my mz aw na bi"><span id="d70e" class="nb lx iu mw b gz nc nd l ne nf">// keyword here is sealed which enables permits <br/>// permits lists classes that can extend sealed class</span><span id="a0cb" class="nb lx iu mw b gz ng nd l ne nf">public abstract sealed class Shape<br/>    permits Circle, Rectangle, Square { ... }</span></pre><p id="f220" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有了基本的接口，你就得不到反射。你不知道具体实现的有限集合。</p><p id="da63" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有了密封类，你就有了这种反射行为。你知道类型的<em class="nh">种类</em>，你可以在你的领域中拥有。</p><p id="e209" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">枚举告诉我们有限的一组值。密封类告诉我们有限数量的值类型。</p><pre class="kk kl km kn gu mx mw my mz aw na bi"><span id="a8f4" class="nb lx iu mw b gz nc nd l ne nf">sealed interface Celestial <br/>    permits Planet, Star, Comet { ... }<br/><br/>final class Planet implements Celestial { ... }<br/>final class Star   implements Celestial { ... }<br/>final class Comet  implements Celestial { ... }</span></pre><blockquote class="ni nj nk"><p id="3d55" class="la lb nh lc b ld le jv lf lg lh jy li nl lk ll lm nm lo lp lq nn ls lt lu lv in bi translated">然而，这种层次结构并没有反映出重要的领域知识，即在我们的模型中只有三种天体。在这些情况下，限制子类或子接口的集合可以简化建模。JEP-397</p></blockquote></div><div class="ab cl no np hy nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="in io ip iq ir"><h1 id="22a3" class="lw lx iu bd ly lz nv mb mc md nw mf mg ka nx kb mi kd ny ke mk kg nz kh mm mn bi translated">基于值的类的警告</h1><p id="8783" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated"><a class="ae kz" href="https://openjdk.java.net/jeps/390" rel="noopener ugc nofollow" target="_blank"> JEP-390 </a></p><p id="a36c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">原始包装类是基于值的类。基于值的类的例子有:<code class="fe mt mu mv mw b">Byte</code>、<code class="fe mt mu mv mw b">Short</code>、<code class="fe mt mu mv mw b">Integer</code>、<code class="fe mt mu mv mw b">Long</code>、<code class="fe mt mu mv mw b">Float</code>、<code class="fe mt mu mv mw b">Double</code>、<code class="fe mt mu mv mw b">Boolean</code>和<code class="fe mt mu mv mw b">Character</code>。更多基于价值的课程可以在找到。</p><p id="840d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因为它们是不可变的对象，所以使用构造函数是没有意义的。</p><p id="ded9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了防止误用，有了新的注释。这将在每次编译器找到基于值的类构造函数时发出警告。</p><p id="8926" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe mt mu mv mw b">@jdk.internal.ValueBased</code></p></div><div class="ab cl no np hy nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="in io ip iq ir"><h1 id="5c3b" class="lw lx iu bd ly lz nv mb mc md nw mf mg ka nx kb mi kd ny ke mk kg nz kh mm mn bi translated">默认情况下，JDK内部构件的封装被移除</h1><p id="1d6f" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated"><a class="ae kz" href="https://openjdk.java.net/jeps/396" rel="noopener ugc nofollow" target="_blank"> JEP-396 </a></p><p id="f83a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是为了鼓励用户使用标准的Java API。不过，您可以选择宽松的封装。如果需要，但尽量避免。</p><p id="f30b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您需要将道具添加到JVM的启动器中。下面你可以看到可能的参数，你可以传入。更多关于争论的信息可以在<a class="ae kz" href="https://openjdk.java.net/jeps/396#Description" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><pre class="kk kl km kn gu mx mw my mz aw na bi"><span id="da5f" class="nb lx iu mw b gz nc nd l ne nf">--illegal-access= permit | deny | debug | warn</span></pre><p id="6373" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然这在JDK 16中被接受，但你可能会面临早期<a class="ae kz" href="https://stackoverflow.com/questions/53790182/get-the-current-value-of-illegal-access-setting-in-java" rel="noopener ugc nofollow" target="_blank">版本</a>的问题。这一改变是在JDK 9 <a class="ae kz" href="https://jaxenter.com/jdk-9-replace-permit-illegal-access-134180.html" rel="noopener ugc nofollow" target="_blank">发布</a>后提出的。</p><blockquote class="ni nj nk"><p id="b736" class="la lb nh lc b ld le jv lf lg lh jy li nl lk ll lm nm lo lp lq nn ls lt lu lv in bi translated">即使在今天，例如Java &gt;=9，某些构建工具在构建Java项目时会打印出<a class="ae kz" href="https://issues.apache.org/jira/browse/GROOVY-8339" rel="noopener ugc nofollow" target="_blank">“反射访问”——警告</a>，这只是“感觉还没有准备好”，即使构建很好。— <a class="ae kz" href="https://www.marcobehler.com/guides/a-guide-to-java-versions-and-features" rel="noopener ugc nofollow" target="_blank">来源</a></p></blockquote></div><div class="ab cl no np hy nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="in io ip iq ir"><h1 id="51fb" class="lw lx iu bd ly lz nv mb mc md nw mf mg ka nx kb mi kd ny ke mk kg nz kh mm mn bi translated">模式匹配</h1><p id="dc5a" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated"><a class="ae kz" href="https://openjdk.java.net/jeps/394" rel="noopener ugc nofollow" target="_blank"> JEP-394 </a></p><p id="ba60" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">模式匹配存在很长时间了。你可以在灵药中找到它。</p><p id="b3a9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在Java中，有很多<code class="fe mt mu mv mw b">instanceof</code>条件。减少操作的动机导致模式匹配。</p><blockquote class="ni nj nk"><p id="78f6" class="la lb nh lc b ld le jv lf lg lh jy li nl lk ll lm nm lo lp lq nn ls lt lu lv in bi translated">模式匹配允许一个对象的期望“形状”被简洁地表达出来(模式<em class="iu">模式</em>)，并允许各种语句和表达式根据它们的输入来测试该“形状”(<em class="iu">匹配</em>)。JEP-394</p></blockquote><pre class="kk kl km kn gu mx mw my mz aw na bi"><span id="e4ef" class="nb lx iu mw b gz nc nd l ne nf">// a lot of boiler plate code</span><span id="9daf" class="nb lx iu mw b gz ng nd l ne nf">if (obj instanceof String) {<br/>    String s = (String) obj;    // grr...<br/>    ...<br/>}</span></pre><p id="6627" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过模式匹配，我们可以得到这个代码。减少样板文件，进行转换，并声明变量。</p><pre class="kk kl km kn gu mx mw my mz aw na bi"><span id="dd5e" class="nb lx iu mw b gz nc nd l ne nf">if (obj instanceof String s) {<br/>    // Let pattern matching do the work!<br/>    ...<br/>}</span></pre><p id="ba46" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">模式变量在其匹配的范围内。因此，这样的代码是有效的。</p><pre class="kk kl km kn gu mx mw my mz aw na bi"><span id="0898" class="nb lx iu mw b gz nc nd l ne nf">if (a instanceof Point p) {<br/>    // p is in scope<br/>    ...<br/>}<br/>// p not in scope here<br/>if (b instanceof Point p) {     // Sure!<br/>        ...<!-- --> <br/>}</span></pre><p id="dbab" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你现在再也不用担心名字了。如果作用域不同，重用现有名称是可能的。</p><p id="cd15" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="nh">模式匹配有什么改善？</em></p><p id="e21b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">减少显式强制转换。这在等式方法中给出了更可读的代码。</p><pre class="kk kl km kn gu mx mw my mz aw na bi"><span id="c739" class="nb lx iu mw b gz nc nd l ne nf">return (o instanceof CaseInsensitiveString) &amp;&amp;<br/>        ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);</span><span id="e76f" class="nb lx iu mw b gz ng nd l ne nf">// to this </span><span id="6128" class="nb lx iu mw b gz ng nd l ne nf">return (o instanceof CaseInsensitiveString cis) &amp;&amp;<br/>        cis.s.equalsIgnoreCase(s);</span></pre><p id="69f6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">看下一个例子。如果这个条件<code class="fe mt mu mv mw b">o instanceof String s</code>评估为真，<code class="fe mt mu mv mw b">s</code>被赋值。相反，如果模式匹配失败，<code class="fe mt mu mv mw b">s</code>没有任何值。</p><p id="4f96" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这样这段代码就可以正常完成了。你没有<a class="ae kz" href="https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.22" rel="noopener ugc nofollow" target="_blank">一个无法到达的代码</a>。如果条件通过，则<code class="fe mt mu mv mw b">s</code>获得赋值，否则<code class="fe mt mu mv mw b">s</code>被安全丢弃。</p><pre class="kk kl km kn gu mx mw my mz aw na bi"><span id="c727" class="nb lx iu mw b gz nc nd l ne nf">public void onlyForStrings(Object o) throws MyException {<br/>    if (!(o instanceof String s))<br/>        throw new MyException();</span><span id="d39f" class="nb lx iu mw b gz ng nd l ne nf">    // s has value at this point<br/>    System.out.println(s);<br/>    ...<br/>}</span></pre></div><div class="ab cl no np hy nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="in io ip iq ir"><h1 id="a2f3" class="lw lx iu bd ly lz nv mb mc md nw mf mg ka nx kb mi kd ny ke mk kg nz kh mm mn bi translated">结论</h1><p id="ff4e" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">Java正在发展。导致了很多突破性的变化。导致很多<a class="ae kz" href="https://medium.com/dev-genius/8-problems-every-java-developer-knows-4f65339e0c00" rel="noopener">问题</a>。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oa"><img src="../Images/b088e15c83759352c9f2a9c11b04168c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MzIcNjgSR9uVS3yb.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">【Java不断更新</figcaption></figure><p id="acd4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">即便如此，我们确实需要调整。使用新功能，让我们创造更好的软件。</p><p id="2d0f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是几个特征，我会拿走。你可以在下面的部分了解更多。</p></div><div class="ab cl no np hy nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="in io ip iq ir"><h1 id="474c" class="lw lx iu bd ly lz nv mb mc md nw mf mg ka nx kb mi kd ny ke mk kg nz kh mm mn bi translated">资源</h1><div class="ob oc gq gs od oe"><a href="https://openjdk.java.net/jeps/8213076" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fp"><div class="og ab oh cl cj oi"><h2 class="bd iv gz z fq oj fs ft ok fv fx it bi translated">JEP草案:开关的模式匹配(预览)</h2><div class="ol l"><h3 class="bd b gz z fq oj fs ft ok fv fx dk translated">用switch表达式和语句的模式匹配增强Java编程语言，以及…</h3></div><div class="om l"><p class="bd b dl z fq oj fs ft ok fv fx dk translated">openjdk.java.net</p></div></div></div></a></div><div class="ob oc gq gs od oe"><a href="https://www.infoworld.com/article/3569150/jdk-16-the-new-features-in-java-16.html" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fp"><div class="og ab oh cl cj oi"><h2 class="bd iv gz z fq oj fs ft ok fv fx it bi translated">JDK 16:Java 16的新特性</h2><div class="ol l"><h3 class="bd b gz z fq oj fs ft ok fv fx dk translated">自3月16日起，Oracle Java开发套件(JDK) 16现已推出量产版。中的新功能…</h3></div><div class="om l"><p class="bd b dl z fq oj fs ft ok fv fx dk translated">www.infoworld.com</p></div></div><div class="on l"><div class="oo l op oq or on os kt oe"/></div></div></a></div></div></div>    
</body>
</html>