<html>
<head>
<title>Trigger Events at a Specific Timestamp</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在特定时间戳触发事件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/trigger-events-at-a-specific-timestamp-2527f9336128?source=collection_archive---------10-----------------------#2021-08-31">https://levelup.gitconnected.com/trigger-events-at-a-specific-timestamp-2527f9336128?source=collection_archive---------10-----------------------#2021-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="04c9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用AWS步骤函数、API网关和Lambda，调度事件在特定的时间戳执行，而不需要进行任何轮询——根本不需要轮询！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0bcd91818db1054ce3be9ebcf184ad5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_cFc1ztMFDXBLyOnZAtLug.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">长期预定事件的AWS步骤功能</figcaption></figure><p id="e448" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于许多应用程序来说，一个极其常见的用例是需要预定事件。主要有两种调度事件——一种作为CRON作业运行，另一种需要在特定时间触发。</p><p id="a6db" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">CRON作业是在固定时间、日期或间隔定期运行的软件实用程序(通常是命令或shell脚本)。它们可以是一次性的，也可以是重复性的。另一方面，预定触发器是需要在非常特定的时间被激发的事件，该时间通常是动态的或基于输入可配置的。</p><p id="13a9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">解决预定触发问题最常见的方法是通过轮询。轮询是指每隔x个时间单位触发一次作业，并检查执行时间是当前时间还是已经过去。虽然这可能适用于更简单、更小的用例，但极难扩展。很明显，这个作业的精度取决于它被调用的时间间隔。差距越小，函数触发的时间越准确，越接近预定时间。但是这本身带来了浪费资源和计算能力的问题，并且如果涉及到数据库，从数据库中进行不必要的读取会非常频繁。</p><p id="86bb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们需要一种方法，无论何时我们收到一个带有未来执行时间戳的事件，它都会自动进入一个<code class="fe lr ls lt lu b">WAITING</code>状态，并在时间戳出现时被触发，而无需我们的干预。幸运的是，这正是在云中创建Step函数(也称为状态机)的确切用例。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/b437e5602afa59ffd4ebc93751a48bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*LY3PE1WBvDAgi26FaTMKGg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">状态机</figcaption></figure><blockquote class="lw lx ly"><p id="38ae" class="kv kw lz kx b ky kz jr la lb lc ju ld ma lf lg lh mb lj lk ll mc ln lo lp lq ij bi translated">AWS Step Functions是一个低代码可视化工作流服务，用于编排AWS服务、自动化业务流程和构建无服务器应用程序。工作流管理失败、重试、并行化、服务集成和可观察性，因此开发人员可以专注于更高价值的业务逻辑。</p></blockquote><p id="3031" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个例子中，我们将学习如何创建一个Step函数，它通过API网关接收事件，一直等到执行时间，然后触发Lambda函数来执行任务。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi md"><img src="../Images/0f63dfb0af14af0aefec1b319baf2103.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*_SUtwFcQlbAQ9PMvEB2piw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">解决方案的架构图</figcaption></figure><p id="6137" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本教程使用Node.js和无服务器框架，为了继续学习，您需要在系统上安装Node.js和NPM。除此之外，确保你已经在全球范围内安装了<code class="fe lr ls lt lu b">serverless</code> NPM软件包。如果没有，运行下面的命令，并使用<a class="ae me" href="https://www.serverless.com/framework/docs/providers/aws/guide/credentials/" rel="noopener ugc nofollow" target="_blank">这个</a>链接设置您的AWS概要文件</p><pre class="kg kh ki kj gt mf lu mg mh aw mi bi"><span id="0da3" class="mj mk iq lu b gy ml mm l mn mo">npm install -g serverless</span></pre><p id="fb4e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您过去使用Node.js使用过Lambda函数和AWS，那么您可能对设置和代码库的初始部分很熟悉。我们只是要扩展标准的Lambda函数模板，以包含对阶跃函数的支持。</p><p id="98e4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了开始，我们需要安装步骤函数的依赖项—</p><pre class="kg kh ki kj gt mf lu mg mh aw mi bi"><span id="958d" class="mj mk iq lu b gy ml mm l mn mo">npm i --save-dev serverless-step-functions</span></pre><p id="9642" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个包允许我们在我们的<code class="fe lr ls lt lu b">serverless.yml</code>中使用<code class="fe lr ls lt lu b">stepFunctions</code>关键字，在所有的配置完成后看起来像这样。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="38c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们浏览一下<code class="fe lr ls lt lu b">serverless.yml</code>文件中的各个部分</p><ul class=""><li id="3554" class="mr ms iq kx b ky kz lb lc le mt li mu lm mv lq mw mx my mz bi translated"><em class="lz"> provider </em> —它保存了关于部署区域、云提供商、运行时细节、阶段等的所有配置。</li><li id="b3f2" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated"><em class="lz"> package </em> —这一部分包括关于我们的代码应该如何打包和构建的信息，并包括在您有多个函数的情况下单独打包的选项，包括/排除选项等。</li><li id="1116" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated"><em class="lz">功能</em> —</li></ul><p id="bd11" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的Lambda函数的定义在这里。它需要<code class="fe lr ls lt lu b">handler</code>值来指向我们目录中的文件。还有额外的选项，如内存、超时、重试，允许进一步定制我们的Lambda函数。</p><ul class=""><li id="145d" class="mr ms iq kx b ky kz lb lc le mt li mu lm mv lq mw mx my mz bi translated"><em class="lz">步进功能</em> —</li></ul><p id="268f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个自定义属性，因为我们之前安装了包，所以我们能够使用它。这是我们在YAML写的阶梯函数的定义。<code class="fe lr ls lt lu b">events</code>对象为我们的步骤函数定义了触发器，在我们的例子中是一个HTTP POST请求。</p><p id="ef24" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">阶跃函数的<code class="fe lr ls lt lu b">definition</code>保存阶跃函数的不同状态和连接。这来自Amazon States Language (ASL ),它是一种类似JSON的语言，Amazon使用它来定义Step函数。详细资料和可用状态及选择可在<a class="ae me" href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-amazon-states-language.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。最近，亚马逊推出了<a class="ae me" href="https://docs.aws.amazon.com/step-functions/latest/dg/workflow-studio.html" rel="noopener ugc nofollow" target="_blank"> Workflow Studio </a>，这是一个用于创建Step函数的拖放界面，使得创建Step函数的过程比以前容易许多倍。</p><ul class=""><li id="d385" class="mr ms iq kx b ky kz lb lc le mt li mu lm mv lq mw mx my mz bi translated"><em class="lz">插件</em> —本节包含有助于简化或包含/扩展无服务器框架功能的包</li></ul><p id="119e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我们的解决方案是使用POST请求触发的，所以只要我们向API Gateway端点发送一个包含所需数据的POST请求，API Gateway就会将该数据转发给Step函数。然后，Step函数将进入START状态，并很快转换到WAITING状态，并一直保持到POST请求主体中接收到的时间戳到达。一旦到达时间戳，Step函数就进入下一个状态，称为ACTION，在这里我们的Lambda函数被触发，之后Step函数进入END状态，从而完成执行周期。这里我们的Step函数依赖于请求体中一个名为<code class="fe lr ls lt lu b">dueDate</code>的特定参数，这个参数必须在POST请求中与我们可能需要的任何其他数据一起传递。</p><pre class="kg kh ki kj gt mf lu mg mh aw mi bi"><span id="5842" class="mj mk iq lu b gy ml mm l mn mo">curl --location --request POST 'https://...../execute' \<br/>--header 'Content-Type: application/json' \<br/>--data-raw '{ <br/>"dueDate": "2021-08-28T15:00:00Z", <br/>"data": { .... }<br/>}'</span></pre><blockquote class="lw lx ly"><p id="b494" class="kv kw lz kx b ky kz jr la lb lc ju ld ma lf lg lh mb lj lk ll mc ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">dueDate</code>参数采用UTC时间戳格式，包含事件的日期和时间</p></blockquote><p id="3b95" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要部署所有这些服务，只需从终端运行— <code class="fe lr ls lt lu b">serverless deploy</code>即可！您的应用程序现在已经部署好了，一旦部署完成，您将在控制台输出中看到<code class="fe lr ls lt lu b">POST</code>端点。</p><p id="1cbc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽管这是一个很好的解决方案，但这种方法也有局限性，在AWS大师崔琰的博客文章中，这些局限性和有用的度量标准都得到了很好的强调</p><div class="nf ng gp gr nh ni"><a href="https://theburningmonk.com/2019/06/step-functions-as-an-ad-hoc-scheduling-mechanism/" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">单步执行作为一种特别的调度机制| theburningmonk.com</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">我们之前讨论过如何使用DynamoDB TTL和CloudWatch实现一个临时调度系统…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">theburningmonk.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw kp ni"/></div></div></a></div><p id="b91a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，这是成品代码库的链接—</p><div class="nf ng gp gr nh ni"><a href="https://github.com/RyanDsilva/aws-step-functions" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">GitHub-RyanDsilva/AWS-step-Functions:使用Step函数在特定的…</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">使用Step函数在特定的时间戳触发事件</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="nx l nt nu nv nr nw kp ni"/></div></div></a></div><p id="cd0a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">非常感谢您的阅读和理解。我希望这能帮助到需要帮助的人，如果是的话，一定要帮助别人！干杯！</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><h1 id="251d" class="of mk iq bd og oh oi oj ok ol om on oo jw op jx oq jz or ka os kc ot kd ou ov bi translated">参考</h1><p id="650d" class="pw-post-body-paragraph kv kw iq kx b ky ow jr la lb ox ju ld le oy lg lh li oz lk ll lm pa lo lp lq ij bi translated">[1] AWS阶跃函数——https://aws.amazon.com/step-functions/?step-functions<a class="ae me" href="https://aws.amazon.com/step-functions/?step-functions&amp;step-functions.sort-by=item.additionalFields.postDateTime&amp;step-functions.sort-order=desc" rel="noopener ugc nofollow" target="_blank">阶跃函数&amp;</a></p><p id="3652" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[2]无服务器事件调度—<a class="ae me" href="https://medium.com/serverless-transformation/serverless-event-scheduling-using-aws-step-functions-b4f24997c8e2" rel="noopener">https://medium . com/server less-transformation/server less-Event-Scheduling-using-AWS-step-functions-b4f 24997 c8e 2</a></p><p id="1187" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[3]无服务器充当临时调度机制—<a class="ae me" href="https://blog.smirnov.la/step-functions-as-an-ad-hoc-scheduling-mechanism-ed1787e44bb1" rel="noopener ugc nofollow" target="_blank">https://blog . Smirnov . la/step-Functions-as-an-ad-hoc-scheduling-mechanism-ed 1787 e 44 bb 1</a></p><p id="221c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[4]从AWS Lambda调用步骤函数—<a class="ae me" href="https://iamnoah1.medium.com/invoke-aws-step-function-from-aws-lambda-using-the-serverless-framework-21b7fde38a42" rel="noopener">https://iam Noah 1 . medium . com/Invoke-AWS-Step-Function-from-AWS-Lambda-using-the-server less-framework-21 b 7 FDE 38 a 42</a></p></div></div>    
</body>
</html>