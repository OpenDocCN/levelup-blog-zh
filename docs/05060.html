<html>
<head>
<title>A Crash Course on Object-Oriented Programming in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python面向对象编程速成班</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-crash-course-on-object-oriented-programming-in-python-a243b35054c0?source=collection_archive---------1-----------------------#2020-08-01">https://levelup.gitconnected.com/a-crash-course-on-object-oriented-programming-in-python-a243b35054c0?source=collection_archive---------1-----------------------#2020-08-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="84a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">抽象、继承、UML图等等！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/e41b8af01015b068ffd4f7a4cc1accd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l4sd_pXEArYQ6ZYN.jpg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图片来自<a class="ae le" href="https://pixabay.com/photos/solar-system-sun-mercury-venus-439046/" rel="noopener ugc nofollow" target="_blank">com break on pix abay</a></figcaption></figure><p id="9948" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文介绍了理解面向对象编程(OOP)的基础知识所需的一切，包括继承和封装等概念，最后给出了Python代码示例。建议对Python编程语言有一个基本的了解。重点将放在以下方面:</p><ul class=""><li id="b4f0" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">为什么要面向对象编程？</li><li id="9b89" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">松散耦合和紧密结合</li><li id="3704" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">抽象、封装、继承和多态</li><li id="aa20" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">统一建模语言(UML)图表</li><li id="3fe1" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">Python演示</li><li id="d25f" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">设计模式</li></ul><p id="fe70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们开始吧。</p><h1 id="1cd1" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated"><strong class="ak">为什么要面向对象编程？</strong></h1><p id="962d" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">大约在1966年，<a class="ae le" href="https://en.wikipedia.org/wiki/Alan_Kay" rel="noopener ugc nofollow" target="_blank">艾伦·凯</a>首次创造了术语面向对象编程。虽然名字可能看起来模糊，但是OOP范例仅仅意味着使用对象来组织数据和功能。让我们看一个简单的例子。</p><p id="4b41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设您正在构建一个程序来跟踪宠物店的库存(包括宠物本身)。使用标准编程，您可以通过使用数组来组织关于宠物的基本信息。</p><pre class="kp kq kr ks gt mw mx my mz aw na bi"><span id="873e" class="nb lu it mx b gy nc nd l ne nf">pet_names = ["Tommy", "Daisy", "Bernard"]<br/>pet_type = ["Dog", "Cat", "Lizard"]<br/>pet_breed = ["Border Collie", "Persian", "Bearded Dragon"]<br/>pet_weight = ["35.0", "8.2", "0.75"] # weight in pounds</span></pre><p id="2b6f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我只列出了每只宠物的四个描述，尽管只有三只宠物，我们已经有了相当多的代码。这种标准编码方法的真正问题是适应变化。如果我们卖一只宠物呢？让一只新的乌龟(这是一件事)加入宠物名单？我们需要非常小心地调整我们的数组，因为如果只有一个元素移动了位置或者一个索引不正确，我们所有的宠物都会有不匹配的信息！</p><p id="ab54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们的宠物店发展壮大，拥有数百甚至数千只宠物，这种类型的设计规模会非常大。这就是OOP来拯救我们的地方！我们可以创建一个存储相关信息的宠物对象，而不是用数组硬编码宠物信息。但是首先，让我们继续建立对OOP背后的关键原则的理解。</p><h1 id="cfff" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated"><strong class="ak">松耦合&amp;紧衔接</strong></h1><p id="8eac" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">我相信你非常渴望代码示例，但是理解OOP背后的思想将使本文末尾的代码示例更有意义。继续，耦合和内聚是两个经常被认为过于复杂的术语，但是它们实际上非常简单，并且对OOP的目的有很大贡献。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ng"><img src="../Images/387b9ed32e9426e42f04b0354e8c6354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*97hzs04WTlcNrqnPahrE8Q.png"/></div></div></figure><p id="ed0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你对<a class="ae le" href="https://docs.python.org/3/tutorial/modules.html" rel="noopener ugc nofollow" target="_blank"> Python模块</a>不熟悉，就把上面的每个模块当作一些带有函数A、B、C等的Python文件。包括在内。耦合是一个模块和另一个模块之间的交互，而内聚可以被看作是单个模块能做多少事情。</p><p id="d040" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">松(低)耦合良好。</strong>这意味着你的模块是相互独立的。高耦合不好！如果你调用一个函数来添加一个新的宠物到我们的商店，你不希望这个函数在多个文件和多个位置有逻辑。调试起来会非常困难！模块中的功能应该集中在完成单个操作上，而不是分散在代码库中。</p><p id="0971" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">我们想要一个具有高度凝聚力的系统。</strong>一个具有发送电子邮件、更新商店信息以及报税功能的模块很少关注它能做什么。因此，它的内聚力很低。一个高度内聚的模块将专注于格式化电子邮件、发送电子邮件和组织客户联系信息。</p><h1 id="44d3" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated"><strong class="ak">面向对象的四大原则</strong></h1><p id="c1ed" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">抽象是隐藏看似简单动作的所有可怕细节的概念。想象一下，当你用手机发送短信时，你所要做的就是选择一个联系人，输入你的信息，然后点击发送。然而，在幕后有很多事情在进行。手机有一个专用于发送信息的存储器，它将你的文本发送到卫星或手机信号塔等。有了抽象，你希望技术细节隐藏在简单的动作之外。</p><p id="35d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">封装</strong>给系统增加了一层验证。假设您编写了一个将文本文档解析为字典的程序。如果您想要一致的结果，您不希望能够在任何时间点访问该字典。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ni"><img src="../Images/424655db68c575f7dc86d9fe608eaafe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6SFfuUXC2TomreY6YImVSQ.png"/></div></div></figure><p id="9e34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可能需要一个函数来控制对字典的访问，并给出多种可能的返回结果，比如None或声明字典仍在处理中。公共方法允许您访问私有数据和方法，因为它们添加了协议和条件检查，以确保您没有访问敏感或不稳定的信息。</p><p id="250b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">继承</strong>是更容易理解的OOP概念之一。想想一种特殊的动物，比如说鸭子。鸭子游泳游得很好，因为它继承了鸭科的蹼足，鸭科包括天鹅或鹅等水禽。所有这些动物也是鸟类，这意味着它们都有羽毛。继承描述了基于某种等级系统的某些特征。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nj"><img src="../Images/8927735d5dc1460fa77b8067ecbe5fc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_kmiFzxXyMzXanuO1CebQA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">类层次结构图</figcaption></figure><p id="95c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，<strong class="js iu">多态性</strong>代表改变的能力。看我们上面的图，树的底部叶子(猫，鸭子，等等。)尽管它们都是动物，但彼此都有差异。遗传是从父母那里获得性状，但多态性是子代之间可能发生的变异。</p><p id="2e70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">统一建模语言(UML)图表</strong></p><p id="1854" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">UML图是一种显示系统如何协同工作的可视化工具，包括主要角色是什么、数据如何移动以及总体架构和设计。目前，本文将只关注基础知识。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nk"><img src="../Images/327eebc25508b0b5dda7e00bac0f0ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vgMxuQj3ENyRAG1mXmNryA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">UML图符号的基础</figcaption></figure><p id="16cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">蓝框是你描述一个类的方式。一个类就像一个对象应该是什么样的蓝图。它在第二个框中给出了描述诸如数组的最大长度、要连接的数据库的名称或存储信息的文件的位置等内容的属性。底部显示的方法是属于类的一部分的函数。在UML图中，您可以使用(+)符号指定方法或属性是公共的，还是使用(-)符号指定是私有的。简单地说，任何其他类都可以访问公共方法，但是只有特殊类可以访问私有方法。</p><p id="5459" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这六条线代表了我们在UML图中将类相互连接的不同方式。</p><p id="c947" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关联意味着一个类与另一个类有某种类型的基本交互。</p><p id="7733" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">实现</strong>显示一个类正在创建一个接口指定的函数。一个接口本身就是一种契约形式，它将指定<em class="nh">需要由另一个类实现的功能列表。</em></p><p id="f6c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">继承</strong>表示一个类正在获得另一个类的特征和方法。<em class="nh">继承特征的类成为父类；例如，Animal类是Duck类的父类。</em></p><p id="b23f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">依赖</strong>表示一个类依赖于另一个类，例如，一个执行数据处理的类可能需要另一个类从数据库中获取数据。</p><p id="be90" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">聚合</strong>表示即使父类不存在，子类也可以存在。例如，一组学生可能注册了一个班级，但是如果该班级从计划中删除，这些学生仍然可以存在。</p><p id="e7fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Composition </strong>基本上与aggregation相反，因为它表示两个类之间的关系——但是父类必须存在，子类才能存在。例如，没有房子，一个房间就不可能存在。</p><h1 id="78f1" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated"><strong class="ak"> Python演示</strong></h1><p id="1b5f" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">让我们用一个使用Python的例子来总结一下我们到目前为止学到的东西。现在我们将保持简单，创建三个类，分别叫做猫、狗和宠物。这是他们的UML类图:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nl"><img src="../Images/12d435563cc5c8cae31fce8574d2fdcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WFHKFFrP4oTsnCCJs6pB_Q.jpeg"/></div></div></figure><p id="5b69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们引入了一个稍微不同的类图，叫做接口。接口是需要由另一个类实现的属性和方法<em class="nh">的列表。我们不能实例化宠物类，因为宠物到底是什么？pet是由Dog和Cat类继承的父类，它们可以被实例化。</em></p><p id="b9bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是一个类被实例化意味着什么呢？</p><p id="023b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">记住，一个类就像我们想要创建的任何对象的蓝图。<em class="nh">一个类的实例化</em>就是你实际创建那个对象的时候。下面是Python中Dog类的一个示例:</p><pre class="kp kq kr ks gt mw mx my mz aw na bi"><span id="d55c" class="nb lu it mx b gy nc nd l ne nf">class Dog:<br/>    def __init__(self, assigned_name, assigned_age):<br/>        self.name = assigned_name<br/>        self.age = assigned_age</span><span id="c84d" class="nb lu it mx b gy nm nd l ne nf">    def speak(self):<br/>        print("Woof!")</span><span id="1156" class="nb lu it mx b gy nm nd l ne nf">    def get_age(self):<br/>        return self.age</span><span id="c069" class="nb lu it mx b gy nm nd l ne nf">my_dog = Dog("Boomer", 3)</span></pre><p id="8a2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，Dog类有三个方法，包括__init__、speak和get_age，稍后会详细介绍这些方法。在代码的最后一行，我们<em class="nh">通过创建对象my_dog来实例化</em>该类，该对象是通过将名称“Boomer”和年龄3传递给dog类来创建的。这就是为什么我们保留Pet类作为一个接口，因为只有一些“宠物”是没有意义的，我们将它定义为一只狗或猫，它继承了Pet类的特征。</p><p id="6da6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">继续，speak()方法很简单，因为它只是输出“Woof！”。但是里面讲的参数呢，<em class="nh"> self </em>？所有方法中的self参数是Python语言用来引用类本身的<em class="nh">实例化</em>的语法。在get_age(self)方法中，我们返回<em class="nh"> self.age </em>，即类实例化本身的年龄。您可以将参数self重命名为您喜欢的任何名称，但是self是当前的Python标准。此外，类方法的第一个参数引用了类实例化。</p><p id="6b69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，__init__方法有一个特殊的名字，因为它负责类的初始构造。请注意，除了self参数之外，我们还传递了一个指定的姓名和年龄。然后通过self.age=assigned_age和self.name=assigned_name将这些传递的参数分配给类的实例化。因此，参数“Boomer”和3被分配给Dog类my_dog的实例化。</p><p id="9297" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">界面呢？一个类如何继承它？</strong></p><p id="ad3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Python与其他语言略有不同，因为您经常需要导入一个额外的库来获得额外的OOP功能。一个流行的库叫做ABC，代表抽象基类。Python没有专门的接口类，而是使用了一种叫做抽象类的东西。在我们的例子中，这达到了完全相同的目的，因为它定义了Dog和Cat类可以实例化，而Pet类不能实例化的约束。为此，我们让Pet类继承ABC库，然后将speak()方法定义为由Dog和Cat子类实现的抽象方法。</p><p id="4b0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码如下:</p><pre class="kp kq kr ks gt mw mx my mz aw na bi"><span id="eec3" class="nb lu it mx b gy nc nd l ne nf">from abc import ABC, abstractmethod<br/># A Python class can inherit from another class by passing it as an # argument, e.g. Pet(ABC)</span><span id="e557" class="nb lu it mx b gy nm nd l ne nf">class Pet(ABC):<br/>    def __init__(self, name, age):<br/>        self.name = name<br/>        self.age = age</span><span id="d2d2" class="nb lu it mx b gy nm nd l ne nf">    # the below line enforces the speak() method to be implemented <br/>    # by another class. Always put pass in the method body of an<br/>    # abstract method.<br/>    @abstractmethod<br/>    def speak(self):<br/>        pass</span><span id="7380" class="nb lu it mx b gy nm nd l ne nf"># The Dog and Cat class inherit from the Pet class<br/>class Dog(Pet):<br/>    def __init__(self, name, age):<br/>        # the super() method references the parent Pet class<br/>        super().__init__(name, age) <br/>  <br/>    def speak(self):<br/>        print("Woof!")</span><span id="d306" class="nb lu it mx b gy nm nd l ne nf">    def get_age(self):<br/>        return self.get_age</span><span id="a455" class="nb lu it mx b gy nm nd l ne nf">class Cat(Pet):<br/>    def __init__(self, name, age):<br/>        super().__init__(name, age)</span><span id="7000" class="nb lu it mx b gy nm nd l ne nf">    def speak(self):<br/>        print("Meow!")</span><span id="7ecf" class="nb lu it mx b gy nm nd l ne nf">    def get_age(self):<br/>        return self.get_age</span><span id="dae4" class="nb lu it mx b gy nm nd l ne nf">my_dog = Dog("Boomer", 3)<br/>my_dog.speak()</span><span id="650f" class="nb lu it mx b gy nm nd l ne nf">my_cat = Cat("Daisy", 4)<br/>my_cat.speak()</span></pre><p id="8a1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意我们是如何在Dog和Cat类之间以不同的方式实现speak()方法的，这就是多态的作用！狗和猫从Pet类继承，然后可以调用Pet __init__方法将传递的名称和年龄分配给我们的猫或狗。这是一个OOP如何允许我们只需要在Pet类中编写指定名字和年龄的代码，而不是子类Dog和Cat的例子。模块化致胜！</p><h1 id="21b4" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated"><strong class="ak">设计模式</strong></h1><p id="b20a" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">既然我们已经理解了OOP的基础，包括UML类图，以及如何使用Python来构造类和实例化它们，我们就准备看看一个强大的新工具——<strong class="js iu">设计模式。</strong></p><p id="a847" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">设计模式允许我们组织我们的代码库，以便在特定情况下充分利用OOP范例。有几十种设计模式，但这里有一些最常见的。</p><p id="632a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">观察者模式:</strong>这种模式适用于基于发布者到订阅者的系统。媒介本身可以使用这种模式！一个作家可以是一个出版商，而观察者可以是其他追随该作家的媒体成员。这是UML图:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/34245a189de96091564fc638973c40a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/0*o35oD3Xox_84sCN3.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">重构大师<a class="ae le" href="https://refactoring.guru/design-patterns/observer" rel="noopener ugc nofollow" target="_blank">的观察者模式UML图</a></figcaption></figure><p id="740e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该图在灰色框中包含了一些伪代码，但是我们可以从中央Publisher类中看到，我们有两个私有属性——订阅者数组和mainState，它们跟踪系统的当前状态。Publisher类还包含四个管理订阅或通知观察者的公共方法。</p><p id="575e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，通过添加订阅者并通知他们，发布者类与订阅者类相关联。Subscriber类还与发布者有一个<em class="nh">聚合</em>关系，这意味着即使某个发布者不存在，订阅者也可以存在。</p><p id="ca88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们有接口订阅者，它必须由具体的订阅者实现。同样，一个接口就像一个契约；它并不关心一个类是如何实现public update()方法的，但是从Subscriber继承的每个类都必须有一些update()方法的功能。就Medium而言，从您关注的作者处获取更新和从您关注的订阅处获取更新之间可能存在差异，例如更新的频率或您获取的信息量。要点是订户接口<em class="nh">强制</em>每个子类拥有一个标准的update()方法来遵守观察者模式。</p><p id="5536" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其他非常有用和常见的模式包括策略、工厂、单例模式等等。Derek Banas 有一个很棒的YouTube频道，涵盖了从UML图开始的几十种模式，尽管他用Java做代码演示。他的设计模式视频教程播放列表如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="a03c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">恭喜你，你已经理解了Python面向对象的基础知识！！！</strong></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="a0a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你有进一步的问题或者想要关于OOP任何方面的额外信息，请在这篇文章上发表评论，我会很乐意在我有时间的时候添加到这篇文章中。感谢阅读！</p></div></div>    
</body>
</html>