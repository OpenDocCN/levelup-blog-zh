<html>
<head>
<title>Choosing the Right Data Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">选择正确的数据类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/choosing-the-right-data-types-c28427e67f3b?source=collection_archive---------37-----------------------#2020-06-08">https://levelup.gitconnected.com/choosing-the-right-data-types-c28427e67f3b?source=collection_archive---------37-----------------------#2020-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="750a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这不仅仅是关于需求的最佳匹配</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b419f9073a3e6d720b3253abc21ee1a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7uzHftTsCApwl4FKtby8xA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@siora18?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Siora摄影</a>在<a class="ae ky" href="https://unsplash.com/s/photos/variety?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="c65a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当我们创建一个新的数据结构时，我们必须决定使用哪种数据类型。通常，决定很简单:文本很可能会变成<code class="fe lv lw lx ly b">String</code>，非浮点数会变成<code class="fe lv lw lx ly b">int</code>，以此类推。</p><p id="22a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数时候，这些几乎是下意识做出的决定就足够了。但是为了设计经得起未来考验的数据结构，我们必须多考虑选择正确的数据类型。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="71fa" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">选择正确的数据类型</h1><p id="ad8d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">尽管“<em class="nd"> right </em>的定义非常主观，但正确的数据类型取决于4个不同的、相互关联的因素:</p><ul class=""><li id="dc6f" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><strong class="lb iu"> <em class="nd">有哪些要求</em> </strong>？</li><li id="3b8f" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">是<strong class="lb iu"> <em class="nd">防未来</em> </strong>？</li><li id="ce05" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">提供了多少<strong class="lb iu"> <em class="nd">便利</em> </strong>？</li><li id="3348" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">会影响<strong class="lb iu"> <em class="nd">性能或者</em> </strong>内存消耗吗？</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/8b25f2fe191ddbedacdd2cfa7108d961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bUd3QzV2UTW_P-A5-6wO3Q.png"/></div></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a9c0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">“实际”需求</h1><p id="c5cd" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">选择特定数据类型的主要原因始于<em class="nd">需求</em>。我们定义了自己想要什么和需要什么，并不得不做出相应的选择。</p><p id="41ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是通常，需求太模糊，不能代表实际的需求。或者它们不符合技术现实。因此，第一步是找到“实际的”需求，并将它们转化为技术上的对应。</p><h2 id="9a75" class="nt mh it bd mi nu nv dn mm nw nx dp mq li ny nz ms lm oa ob mu lq oc od mw oe bi translated">存储用户的年龄</h2><p id="0f5d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们想象的需求声明我们需要用户在注册时的年龄。根据目标受众的不同，我们需要1到3位数来存储这些信息。</p><p id="4892" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者我们想要实际年龄，而不仅仅是数据输入时捕获的年龄？需要一个额外的数字来保存出生年份。</p><p id="4945" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，我们可能还想更确切地说，祝贺他们的生日？现在我们应该使用基于日期的数据类型，而不是数字类型。</p><p id="492a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果需求太模糊，许多用例最初是看不到的。数据通常可以用不同精度的不同数据类型来表示。这就是为什么将不精确或模糊的需求转化为它们的技术对应物是至关重要的</p><p id="b87e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这并不意味着我们应该总是存储尽可能多的信息，没有一个好的理由。永远记住<a class="ae ky" href="https://gdpr-info.eu/art-5-gdpr/" rel="noopener ugc nofollow" target="_blank"> <em class="nd">数据回避和最小化</em> </a>的原理。</p><h2 id="0b22" class="nt mh it bd mi nu nv dn mm nw nx dp mq li ny nz ms lm oa ob mu lq oc od mw oe bi translated">复合值和冗余</h2><p id="4bae" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">boolean</code>数据类型通常是一种非常明显的数据类型，看起来很合适，但光靠它自己是不够的。</p><p id="622c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一个内容管理系统(CMS)。内容可能在某一天被删除，我们希望存储删除日期。一个简单的方法是添加一个<code class="fe lv lw lx ly b">boolean</code>来指示文档被删除，并添加另一个<code class="fe lv lw lx ly b">datetime</code>来存储删除日期。</p><p id="66cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我所说的<em class="nd">复合值</em>。它们本身就有意义，但它们是相互联系的，以代表我们想要表达的实际状态。这种设计会导致多种一致性问题:</p><ul class=""><li id="1efe" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><code class="fe lv lw lx ly b">deleted == true &amp;&amp; timeDeleted == null</code> <br/>数据明明删除了，可是什么时候？</li><li id="b6dd" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><code class="fe lv lw lx ly b">deleted == false &amp;&amp; timeDeleted != null</code> <br/>是删除了吗？还是被还原了？删除时间代表什么？</li></ul><p id="2931" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要额外的验证和逻辑来确保两个值之间的一致性，这可能会引入比<em class="nd">所需的</em>更多的错误。如果我们想存储所有可能的不同状态，我们需要添加更多的值，需要更多的逻辑和验证。</p><p id="718c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与其使用<em class="nd">复合值</em>来表示删除状态，为什么不选择一个单一的数据类型，比如<code class="fe lv lw lx ly b">datetime</code>呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="d200" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们就有了和以前一样的信息。而且我们还消除了<code class="fe lv lw lx ly b">boolean</code>和互连导致的任何不一致问题。</p><p id="454d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果可以，我们应该避免互连类型，因为它会导致值之间的粘连。数据本身应该是一致的，我们需要确保它的逻辑和验证越少越好。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="966f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">经得起未来考验的</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/985b477cc8fa25aeac2cb8d2b3e3426d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dikmGpTu4Dq2BrylooZ8VA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@aronvisuals?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Aron视觉效果</a>在<a class="ae ky" href="https://unsplash.com/s/photos/time?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="5da9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在找到我们的数据类型的实际技术需求后，我们应该考虑它的<em class="nd">持久性</em>。</p><p id="e5b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着时间的推移，没有多少需求会保持不变，从可扩展类型开始比以后完全替换它更容易。</p><h2 id="638e" class="nt mh it bd mi nu nv dn mm nw nx dp mq li ny nz ms lm oa ob mu lq oc od mw oe bi translated">时间的尽头</h2><p id="6952" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Unix_time" rel="noopener ugc nofollow" target="_blank"> <em class="nd"> Unix时间</em> </a>是(至少事后看来)选择非未来数据类型的一个例子。在2038年，1月19日星期二，03:14:07，32位整数将溢出。时间戳将变为负值，程序可能会将下一秒解释为1901年12月13日星期五的20:45:52。</p><p id="122f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然，在<a class="ae ky" href="https://en.wikipedia.org/wiki/Unix_time" rel="noopener ugc nofollow" target="_blank"> <em class="nd"> Unix时间</em> </a>的情况下，这很可能不是一个疏忽。找到另一个解决方案的时间框架是未来的68年。在过去，位是非常珍贵的，所以更小的数据类型非常有意义，本质上也不是一个错误的决定。</p><h2 id="3c23" class="nt mh it bd mi nu nv dn mm nw nx dp mq li ny nz ms lm oa ob mu lq oc od mw oe bi translated">单身状态不会持续太久</h2><p id="02df" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们想象中的CMS现在需要管理员用户。为了满足技术需求，我们可以添加一个<code class="fe lv lw lx ly b">boolean</code>来表示用户是管理员。但这在未来很可能会成为一个问题。</p><p id="7799" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们需要另一种类型的用户，例如一个<em class="nd">编辑</em>该怎么办？我们可以只添加另一个<code class="fe lv lw lx ly b">boolean</code>字段。并更改所有处理用户类型的代码。</p><p id="a69a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我们应该选择一种信息密度大于T2的数据类型。通过使用代表不同用户类型的<code class="fe lv lw lx ly b">enum</code>，我们仍然只需要处理一个值。但是它可以描述各种状态，并且如果需要的话可以很容易地扩展。如果我们同时需要多个状态，我们可以依靠一些<code class="fe lv lw lx ly b">OptionSet</code> ( <a class="ae ky" href="https://developer.apple.com/documentation/swift/optionset" rel="noopener ugc nofollow" target="_blank"> Swift </a>)、<code class="fe lv lw lx ly b">EnumSet</code> ( <a class="ae ky" href="https://eddmann.com/posts/using-bit-flags-and-enumsets-in-java/" rel="noopener ugc nofollow" target="_blank"> Java </a>)或者普通的<a class="ae ky" href="https://en.wikipedia.org/wiki/Bitwise_operation" rel="noopener ugc nofollow" target="_blank">位操作</a>来实现我们的目标。</p><div class="oi oj gp gr ok ol"><a href="https://medium.com/better-programming/dont-use-boolean-arguments-use-enums-c7cd7ab1876a" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">不要使用布尔参数，使用枚举</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">在代码中避免标志值的情况</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cbaf" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">便利</h1><p id="c283" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">并非所有数据类型都是平等的。有些用起来更方便，有些则不然。这可能是从技术的角度，或者仅仅是我们对不同数据类型的个人经验。</p><h2 id="47fd" class="nt mh it bd mi nu nv dn mm nw nx dp mq li ny nz ms lm oa ob mu lq oc od mw oe bi translated">如何(不)保存日期</h2><p id="f1e8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">很久以前，我在做一个小项目，根据日期显示“<a class="ae ky" href="https://en.wikipedia.org/wiki/Japanese_era_name" rel="noopener ugc nofollow" target="_blank">日本时代名称</a>”。我决定将两个日期编码成一个32位整数，并用<a class="ae ky" href="https://en.wikipedia.org/wiki/Bitwise_operation" rel="noopener ugc nofollow" target="_blank">位操作</a>提取值，而不是将一个时代的开始和结束保存在不同的字段中。</p><p id="bb7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一种非常有效的方法，至少在比特数方面是如此。但是我必须引入一个抽象层来处理实际值。数据库中的数据不是人类可读的，这使得调试变得复杂。</p><p id="05e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">date</code>值而不是单个<code class="fe lv lw lx ly b">integer</code>值会是一个更好的决定。那会让我多花点钱。但是产生的开销引入了bug，使得代码比实际需要的更难推理。</p><h2 id="6205" class="nt mh it bd mi nu nv dn mm nw nx dp mq li ny nz ms lm oa ob mu lq oc od mw oe bi translated">使用颜色</h2><p id="507f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这样的例子几乎可以找到任何一种价值。</p><p id="3624" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">存储<a class="ae ky" href="https://en.wikipedia.org/wiki/RGB_color_model" rel="noopener ugc nofollow" target="_blank"> RGB </a>值在技术上需要256个不同的值。它适合8位，或1字节，像<code class="fe lv lw lx ly b">(unsigned) char</code>。</p><p id="b554" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是使用一个<code class="fe lv lw lx ly b">integer</code>可能是一个更好的解决方案，因为将一个数值与一个<code class="fe lv lw lx ly b">char</code>相关联可能不是首先想到的事情。此外，一些编程语言不会隐式转换值，这使得代码<a class="ae ky" href="https://codeburst.io/signal-to-noise-ratio-a45ae45c3545" rel="noopener" target="_blank"><em class="nd"/></a>更加嘈杂。我们无论如何都应该验证这些值，所以为什么不使用比<code class="fe lv lw lx ly b">char</code>更数字的<em class="nd">数据类型呢。</em></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1768" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">性能影响和内存消耗</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bb53d257d6f838bc1309fea59159b05d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2VFS3wB4PrPkOgb2YeKicA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jonassvidras?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Jonas Svidras </a>在<a class="ae ky" href="https://unsplash.com/s/photos/processor?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="2a06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我忽略的一个方面是对性能和内存需求的影响。</p><p id="8369" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天的计算机系统有大量的内存和CPU周期。但它们仍然不是免费的，而且供应有限。我们通常不会花太多时间考虑特定的数据类型会对性能产生什么影响，而且大多数时候，这实际上并没有多大关系。</p><p id="492d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些情况下，每一位都很重要，但并不是所有人都要处理“高频交易”或嵌入式软件开发的硬件限制等问题。</p><p id="8d67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅仅因为性能原因而选择数据类型实际上是<a class="ae ky" href="http://wiki.c2.com/?PrematureOptimization" rel="noopener ugc nofollow" target="_blank">过早的优化</a>，应该避免。这并不意味着我们可以忽略数据类型在内存消耗和性能需求方面的差异。但是我们需要明白什么时候重要，什么时候不重要。</p><h2 id="bbeb" class="nt mh it bd mi nu nv dn mm nw nx dp mq li ny nz ms lm oa ob mu lq oc od mw oe bi translated">铅字铸造</h2><p id="6edb" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Java有<a class="ae ky" href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html" rel="noopener ugc nofollow" target="_blank"> <em class="nd">原语包装类型</em> </a>，所以原语可以用在只允许<em class="nd">对象类型</em>的地方，例如泛型。它们可以互换，并将隐式转换为相应的类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="c662" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译器将进行变量转换的实际工作。这确实很方便，但也给我们的代码带来了不可见的开销。</p><p id="4765" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果编译器由于优化而无法移除类型强制转换，则实际类型强制转换会转化为3个<a class="ae ky" href="https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings" rel="noopener ugc nofollow" target="_blank">操作码</a>。</p><p id="e098" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nd"> Java虚拟机(JVM) </em>有许多针对不同原语类型的优化的<a class="ae ky" href="https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings" rel="noopener ugc nofollow" target="_blank">操作码</a>，以减少开销。但是并不是所有的基本类型都有相同种类的操作码。<code class="fe lv lw lx ly b">integer</code>处理比<code class="fe lv lw lx ly b">char</code>有更多的<a class="ae ky" href="https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings" rel="noopener ugc nofollow" target="_blank">操作码</a>。而<code class="fe lv lw lx ly b">boolean</code>类型在<a class="ae ky" href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.3.4" rel="noopener ugc nofollow" target="_blank"> <em class="nd"> JVM规格</em> </a>中也只是模糊定义。</p><h2 id="84de" class="nt mh it bd mi nu nv dn mm nw nx dp mq li ny nz ms lm oa ob mu lq oc od mw oe bi translated">了解您的运行时</h2><p id="fb79" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">理论上，一个<code class="fe lv lw lx ly b">boolean</code>只需要一个比特来表示它的当前值。但这并不是许多计算机体系结构的工作原理。实际上，在大多数情况下，<code class="fe lv lw lx ly b"><a class="ae ky" href="https://en.wikipedia.org/wiki/Byte" rel="noopener ugc nofollow" target="_blank">byte</a></code>是最小的可寻址内存量。</p><p id="8637" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种行为之上的是我们的运行时如何在内部处理内存。例如，<em class="nd"> Java虚拟机</em>使用32位插槽，因此与<code class="fe lv lw lx ly b">integer</code>相比，任何更小的数据类型都可能导致损失。不管怎样，它都会被存储在一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://en.wikipedia.org/wiki/Byte" rel="noopener ugc nofollow" target="_blank">byte</a></code>中。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0996" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="b5bf" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">要下意识地选择<em class="nd">右</em>数据类型，我们需要有知识和经验，究竟什么是<em class="nd">右</em>。这是非常主观的，但是我们仍然可以努力达到最好的结果。</p><p id="ef60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使所需的范围可能小到足以适合一种数据类型，我们也需要考虑如何在代码中处理它。创建值时的<em class="nd">右</em>数据类型可能不是稍后将如何使用的<em class="nd">右</em>数据类型。而且每次强制转换都会增加额外的开销。任何额外的逻辑都可能引入错误。</p><p id="3440" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">性能和内存影响是一个值得关注的问题，但如果不是绝对必要的话，不应该成为我们决策的主要驱动因素。特定的运行时如何将内存映射到不同的数据类型取决于实际的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/the-jdk-ecosystem-adeaec20b3a9">实现</a>、底层硬件(x86与x64)等。所以它总是对我们环境的记忆设计有所帮助。</p></div></div>    
</body>
</html>