<html>
<head>
<title>Expressible Dynamic Phantom Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可表达的动态幻象类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/expressible-dynamic-phantom-types-513091b63f04?source=collection_archive---------9-----------------------#2022-10-19">https://levelup.gitconnected.com/expressible-dynamic-phantom-types-513091b63f04?source=collection_archive---------9-----------------------#2022-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/79747d03caae926a2d7b8b5ca9b7b9ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JobvFlkFw_c_1fketmXhMw.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">由<a class="ae jd" href="https://unsplash.com/@tandemxvisuals?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">串联X视觉效果</a>在<a class="ae jd" href="https://unsplash.com/s/photos/ghost?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><p id="bfb6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">虚拟类型</strong>是定制类型，具有一个或多个<em class="lb">未使用的</em>类型参数。</p><p id="5ebe" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最简单的例子是:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="3e09" class="ll lm jg lh b gy ln lo l lp lq"><strong class="lh jh">struct</strong> Phantom&lt;Context, WrappedValue&gt; {<br/>  <strong class="lh jh">let</strong> wrappedValue: WrappedValue<br/>}</span></pre><p id="b892" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这为什么有用？这有助于我们确保开发人员不会意外地在字段中放入意外的值，例如在<code class="fe lr ls lt lh b">lastName</code>字段中放入<code class="fe lr ls lt lh b">firstName</code>可能会受到这样的限制…</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="8516" class="ll lm jg lh b gy ln lo l lp lq"><strong class="lh jh">enum</strong> PhantomTypes {<br/>  <strong class="lh jh">enum</strong> FirstName {}<br/>  <strong class="lh jh">enum</strong> LastName {}<br/>}</span><span id="7a90" class="ll lm jg lh b gy lu lo l lp lq"><strong class="lh jh">typealias</strong> FirstName = Phantom&lt;PhantomTypes.FirstName, String&gt;<br/><strong class="lh jh">typealias</strong> LastName = Phantom&lt;PhantomTypes.LastName, String&gt;</span><span id="a8bc" class="ll lm jg lh b gy lu lo l lp lq"><strong class="lh jh">struct</strong> Client {<br/>  <strong class="lh jh">let</strong> firstName: FirstName<br/>  <strong class="lh jh">let</strong> lastName: LastName<br/>}</span></pre><h1 id="95fc" class="lv lm jg bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">类型安全</h1><p id="d6d1" class="pw-post-body-paragraph kd ke jg kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">所以现在开发人员实际上不能在编译器不抛出类型不匹配错误的情况下执行<code class="fe lr ls lt lh b">firstName = lastName</code>。</p><p id="7d3c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有两个具有<code class="fe lr ls lt lh b">firstName</code>属性的实体会怎么样？有什么能阻止我把客户的<code class="fe lr ls lt lh b">firstName</code>设置成制片人的<code class="fe lr ls lt lh b">firstName</code>？我们可以在第一个未使用的属性上引入幻影类型的嵌套。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="6263" class="ll lm jg lh b gy ln lo l lp lq"><strong class="lh jh">enum</strong> PhantomTypes {<br/>  <strong class="lh jh">enum</strong> FirstName {}<br/>  <strong class="lh jh">enum</strong> LastName {}<br/>}</span><span id="f39b" class="ll lm jg lh b gy lu lo l lp lq"><strong class="lh jh">protocol</strong> FirstNameHaving {}<br/><strong class="lh jh">extension</strong> FirstNameHaving {<br/>  <strong class="lh jh">typealias</strong> FirstName = Phantom&lt;Phantom&lt;Self, FirstName&gt;, String&gt;<br/>}</span><span id="4b92" class="ll lm jg lh b gy lu lo l lp lq"><strong class="lh jh">struct</strong> Client: FirstNameHaving {<br/>  <strong class="lh jh">let</strong> firstName: FirstName<br/>}</span><span id="d4c8" class="ll lm jg lh b gy lu lo l lp lq"><strong class="lh jh">struct</strong> Producer: FirstNameHaving {<br/>  <strong class="lh jh">let</strong> firstName: FirstName<br/>}</span><span id="0857" class="ll lm jg lh b gy lu lo l lp lq">client.firstName = producer.firstName <strong class="lh jh">// type-mismatch</strong></span></pre><p id="acaf" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这太棒了！我们可以确保在编译时正确设置我们的值，而不必编写任何值映射器的测试。</p><p id="4ece" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，这些仍然有点笨重。如果你想在上面创建一个<code class="fe lr ls lt lh b">Producer</code>，你必须写:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="155b" class="ll lm jg lh b gy ln lo l lp lq">Producer(firstName: FirstName("firstName"))</span></pre><p id="aa34" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果有一种方法可以隐藏我们正在使用的自定义类型，并且只向<code class="fe lr ls lt lh b">firstName</code>属性提供内容就好了...</p><h1 id="85ca" class="lv lm jg bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">expressable by…Literal</h1><p id="e6a4" class="pw-post-body-paragraph kd ke jg kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">谢天谢地，有！这里有一个<code class="fe lr ls lt lh b">ExpressibleByStringLiteral</code>的例子。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="e1a8" class="ll lm jg lh b gy ln lo l lp lq"><strong class="lh jh">extension</strong> Phantom: ExpressibleByStringLiteral <strong class="lh jh">where</strong> WrappedValue: ExpressibleByStringLiteral {<br/>  <strong class="lh jh">init</strong>(stringLiteral value: StringLiteralType) {<br/>    <strong class="lh jh">self</strong> = <strong class="lh jh">Self</strong>(WrappedValue(stringLiteral: value <strong class="lh jh">as</strong>! WrappedValue.StringLiteralType))<br/>  }<br/>}</span></pre><p id="258c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以这样写上面的初始化式:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="072b" class="ll lm jg lh b gy ln lo l lp lq">Producer(firstName: "firstName")</span></pre><blockquote class="mx my mz"><p id="b106" class="kd ke lb kf b kg kh ki kj kk kl km kn na kp kq kr nb kt ku kv nc kx ky kz la ij bi translated">注意:它仍然是一个<code class="fe lr ls lt lh b">FirstName</code>，你仍然可以传入一个<code class="fe lr ls lt lh b">FirstName</code>对象。</p></blockquote><p id="63d9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一个缺点，如果我们想检查<code class="fe lr ls lt lh b">firstName</code>是否不为空(举例来说),我们必须编写如下代码:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="87da" class="ll lm jg lh b gy ln lo l lp lq">producer.firstName.wrappedValue.isEmpty</span></pre><p id="bc62" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们能去掉那个<code class="fe lr ls lt lh b">wrappedValue</code>就太好了，这样我们对幻影类型的使用就透明了…</p><h1 id="e7ab" class="lv lm jg bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">@ dynamicMemberLookup</h1><p id="59b6" class="pw-post-body-paragraph kd ke jg kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">语法糖完成了拼图的最后一块，下面是我们如何将它添加到我们的<code class="fe lr ls lt lh b">Phantom</code>结构中:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="aa2f" class="ll lm jg lh b gy ln lo l lp lq"><strong class="lh jh">@dynamicMemberLookup<br/>struct</strong> Phantom&lt;Context, WrappedValue&gt; {<br/>  <strong class="lh jh">var</strong> wrappedValue: WrappedValue<br/>  <strong class="lh jh">init</strong>(_ wrappedValue: WrappedValue) {<br/>    <strong class="lh jh">self</strong>.wrappedValue = wrappedValue<br/>  }</span><span id="e275" class="ll lm jg lh b gy lu lo l lp lq"><strong class="lh jh">  subscript</strong>&lt;T&gt;(dynamicMember member: KeyPath&lt;WrappedValue, T&gt;) -&gt; T {<br/>    <strong class="lh jh">get</strong> { <strong class="lh jh">return</strong> wrappedValue[keyPath: member] }<br/>  }<br/>}</span></pre><p id="fd37" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这允许我们直接从<code class="fe lr ls lt lh b">Phantom</code>类型访问<code class="fe lr ls lt lh b">WrappedValue</code>的属性，例如:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="6fd0" class="ll lm jg lh b gy ln lo l lp lq">producer.firstName.isEmpty</span></pre><h1 id="7f3d" class="lv lm jg bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">@属性包装器</h1><p id="e1fd" class="pw-post-body-paragraph kd ke jg kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">我们可以通过引入带<code class="fe lr ls lt lh b">WrappedType</code>的<code class="fe lr ls lt lh b">@propertyWrappers</code>来更进一步。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="51ed" class="ll lm jg lh b gy ln lo l lp lq"><strong class="lh jh">struct</strong> Producer: FirstNameHaving {<br/>  <strong class="lh jh">@Truncated</strong>(maxLength: 10) <br/>  <strong class="lh jh">var</strong> firstName: FirstName<br/>}</span><span id="fbec" class="ll lm jg lh b gy lu lo l lp lq">producer.firstName = "Christopher"<br/>print(producer.firstName) // "Christophe"</span></pre><p id="3ad6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读！</p><p id="4217" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经创建了一个Swift包，其中包含上述内容以及更多的协议一致性，请查看……<a class="ae jd" href="https://github.com/cjnevin/PhantomTypes" rel="noopener ugc nofollow" target="_blank">https://github.com/cjnevin/PhantomTypes</a></p></div></div>    
</body>
</html>