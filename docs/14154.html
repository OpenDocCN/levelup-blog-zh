<html>
<head>
<title>Monorepo Architecture: With simple example.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Monorepo架构:简单的例子。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/monorepo-architecture-with-simple-example-484ca725bf2c?source=collection_archive---------4-----------------------#2022-11-06">https://levelup.gitconnected.com/monorepo-architecture-with-simple-example-484ca725bf2c?source=collection_archive---------4-----------------------#2022-11-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="30d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天，我们将学习单边回购，以及如何设置单边回购和一些基础知识。听起来很棒，对吧？好吧！让我们直接开始吧。</p><h2 id="5490" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">什么是Monorepo或单存储库架构？</h2><p id="f33b" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">单库(Mono-Repository)是管理代码的一个架构概念。这个架构的目的是将你所有的项目或者项目的所有部分放在一个单一的存储库中。这些项目或代码可以是相关的，也可以是独立的，可以归不同的团队所有。因此，我们的想法是，我们不想为所有的项目管理多个存储库，而是只管理一个真实的来源。我们来讲一个例子，让大家更清楚。比方说，我们开发了一个web应用程序。它有一个将在浏览器中运行的前端应用程序，有一个将在服务器上运行的后端应用程序。对于这两个项目，我们在github中有如下的独立存储库:<br/><em class="lj"><br/>https://github.com/user/be-project<br/></em>现在，如果我们想使用monorepo架构，这意味着，我们有一个github repo，如:<br/><em class="lj">【https://github.com/user/our-project<br/></em>，这个repo将包含我们所有的前端和后端代码，如下所示:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/df8f1978df6ac1743f68eb0ee8fcc752.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*9TV8RGGa6l0QKq_X4AYsQw.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">图1: Monorepo架构图</figcaption></figure><h2 id="3771" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">这种架构的优势:</h2><p id="308a" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">让我们来谈谈这种架构的几个好处。<br/> 1。在单个package.json文件中管理所有项目依赖项。<br/> 2。使npm包发布更容易。<br/> 3。在独立的包中共享代码。<br/> 4。单一CI/CD工作流，因为它是单一存储库。<br/> 5。它使得为所有项目定义通用规则成为可能。<br/> 6。易于重构代码。<br/> 7。使团队协作更好。</p><h2 id="b4f3" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">单一回购的缺点:</h2><p id="aaa2" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">我们在这个架构中可能面临的问题是。限制访问的限制。<br/> 2。如果在大规模项目上工作，Git表现很差。<br/> 3。构建时间变得更长。<br/> 4。新开发人员的学习曲线更高。</p><h2 id="59af" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">到底该不该用Monorepo？</h2><p id="4614" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">这取决于我们的用例以及我们想要如何构建我们的项目。如果为正确的场景选择了Monorepo架构，就可以正确地利用它。除此之外，为了获得动力，我们可以看看使用monorepo架构的大公司。</p><ul class=""><li id="970c" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated"><strong class="jp ir">谷歌</strong>用的是单边回购。不相信我？见<a class="ae mf" href="https://blog.bitsrc.io/why-go-monorepo-413dac00ce7d" rel="noopener ugc nofollow" target="_blank">本</a>。</li><li id="5f14" class="lw lx iq jp b jq mg ju mh jy mi kc mj kg mk kk mb mc md me bi translated">现代前端框架像<strong class="jp ir">反应</strong>、<strong class="jp ir">流星</strong>、<strong class="jp ir">余烬</strong>等。使用monorepo。</li><li id="1894" class="lw lx iq jp b jq mg ju mh jy mi kc mj kg mk kk mb mc md me bi translated">Babel是一种流行的JavaScript语言transpiler，它使用monorepo来保存它的代码和所有插件。</li><li id="7544" class="lw lx iq jp b jq mg ju mh jy mi kc mj kg mk kk mb mc md me bi translated"><a class="ae mf" href="https://laravel.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> Laravel，</strong> </a>这是一个用于Web后端开发的PHP框架，使用monorepo。</li><li id="a7a2" class="lw lx iq jp b jq mg ju mh jy mi kc mj kg mk kk mb mc md me bi translated"><a class="ae mf" href="https://github.com/NixOS/nixpkgs/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> NixOS </strong> </a>，一款流行的linux发行版。它使用monorepo来发布包。</li><li id="39fd" class="lw lx iq jp b jq mg ju mh jy mi kc mj kg mk kk mb mc md me bi translated"><a class="ae mf" href="https://symfony.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> Symfony </strong> </a>，一个用PHP写的MVC框架，用的是monorepo。</li></ul><p id="2b04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们会发现越来越多的公司在软件开发工作流程中使用monorepo。</p><h1 id="b0f0" class="ml km iq bd kn mm mn mo kq mp mq mr kt ms mt mu kw mv mw mx kz my mz na lc nb bi translated">让我们创建一个monorepo:</h1><p id="15c9" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">对于这个例子，我们将创建一个包含两个项目(一个React项目和一个Express项目)的monorepo。此外，我们将看到基础知识。</p><h2 id="5b58" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">工具作业</h2><p id="3ebe" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">我们将使用<a class="ae mf" href="https://lerna.js.org/" rel="noopener ugc nofollow" target="_blank"> Lerna </a>来创建和管理monorepo，我们还需要node和npm/yarn。</p><h2 id="f903" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">步骤01</h2><p id="9d18" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">首先，我们需要在我们的计算机上安装node &amp; npm。通过在terminal/cmd中给出以下命令来检查这一点。</p><pre class="ll lm ln lo gt nc nd ne nf aw ng bi"><span id="4551" class="kl km iq nd b gy nh ni l nj nk">node -v &amp;&amp; npm -v</span></pre><p id="fc60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果已经安装了，您将获得这些版本。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/bf05bdbf158e3b967c933e384db30e85.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/1*Ud8bW2k6jvlD7CEVC4SgJQ.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">图2:节点和npm版本检查。</figcaption></figure><h2 id="0495" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">步骤02</h2><p id="4414" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">我们需要通过发出以下命令来全局安装Lerna:</p><pre class="ll lm ln lo gt nc nd ne nf aw ng bi"><span id="d5a0" class="kl km iq nd b gy nh ni l nj nk">npm install -g lerna</span></pre><h2 id="c431" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">步骤03</h2><p id="39da" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">现在，我们将创建一个本地git存储库，然后在存储库中启动lerna。它将搭建样板代码，并在根目录下的package.json文件中添加一些包。在终端中发出以下命令</p><pre class="ll lm ln lo gt nc nd ne nf aw ng bi"><span id="0646" class="kl km iq nd b gy nh ni l nj nk">git init monorepo-example &amp;&amp; cd monorepo-example<br/>lerna init</span></pre><h2 id="d70b" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">步骤04</h2><p id="8762" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">此时，我们需要创建一个远程git存储库，并将其链接到本地存储库。此外，我们将添加一个. gitignore文件，以避免在node_modules文件夹中查找更改。最后，我们需要安装软件包。</p><pre class="ll lm ln lo gt nc nd ne nf aw ng bi"><span id="a4b4" class="kl km iq nd b gy nh ni l nj nk">git remote add origin https://github.com/Shadab420/monorepo-example.git</span><span id="5fd3" class="kl km iq nd b gy nm ni l nj nk">touch .gitignore<br/>npm install</span></pre><p id="85d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意</strong>同时在根目录下创建一个空的<strong class="jp ir"> LICENSE.md </strong>文件，以避免与许可证相关的错误。</p><p id="9139" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成所有这些步骤后，我们的项目结构将如下所示:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/72715b0fd67b12ec24f4ae9a5b452f52.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*DHcdaOPbsIBuVSQKx4ksxg.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">图3:使用Lerna(样板)的项目结构。</figcaption></figure><p id="be51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将深入这个结构的细节，但在此之前，让我们做第一次提交和推送代码。</p><pre class="ll lm ln lo gt nc nd ne nf aw ng bi"><span id="499f" class="kl km iq nd b gy nh ni l nj nk">git add .<br/>git commit -m "Scaffolded project."<br/>git push -u origin main</span></pre><h2 id="e8d6" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">关于项目结构:</h2><ol class=""><li id="d3c2" class="lw lx iq jp b jq le ju lf jy no kc np kg nq kk nr mc md me bi translated"><strong class="jp ir"> Packages- </strong>该文件夹实际上负责保存我们希望成为此回购一部分的所有项目/代码。当然，我们可以给它重新命名。</li><li id="db01" class="lw lx iq jp b jq mg ju mh jy mi kc mj kg mk kk nr mc md me bi translated">这个文件包含了这个monorepo的所有必要配置。我们可以指定项目路径。此外，我们可以定义这些项目是否将独立版本化。在我们的例子中，我们的配置如下:</li></ol><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/eddd36f526510db708cbe9c9e1961fee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*iGNU0p5kOt4H9d3N0pDqMw.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">图4: lerna配置文件。</figcaption></figure><p id="af65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.根目录中的package.json将如下所示:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/8c6256258178b4312c312f12d4e71179.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*Y5Y79cmkIrpxxcTR1JWVfw.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">图5:根目录中的Package.json。</figcaption></figure><h2 id="22b6" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">创建或添加项目/包:</h2><p id="4377" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">我们可以直接将现有的项目复制粘贴到packages文件夹中，或者使用“lerna create”命令创建一个新的包。它会问一些问题，我们必须回答，该项目将被添加。</p><p id="dc1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将首先创建React(前端)项目。</p><pre class="ll lm ln lo gt nc nd ne nf aw ng bi"><span id="b0fc" class="kl km iq nd b gy nh ni l nj nk">lerna create react-frontend</span></pre><p id="5c58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的前端项目文件夹已经创建，如下图所示:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi nu"><img src="../Images/198b764a9d623a45c9311d4c6b02852f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7oED4J2xjpX5MipdhRmO7w.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">图6:使用lerna命令创建项目。</figcaption></figure><p id="0e96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是IMO最简单的方法是使用命令行进入packages文件夹，并使用它们自己的命令创建各自的项目。例如，我们可以使用create-react-app创建一个React项目。所以让我们做以下事情:</p><pre class="ll lm ln lo gt nc nd ne nf aw ng bi"><span id="fa4a" class="kl km iq nd b gy nh ni l nj nk">cd packages<br/>npx create-react-app react-frontend</span></pre><p id="203d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于这不是一个反应教程，我不会去详细。但是现在我们的React应用程序已经准备好并正在运行。</p><p id="87e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，我们将为后端创建一个快速项目。现在我们有两个项目准备好了。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/e0e10bc726e6436c6766621531f13a7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*b2rB11EwWJWj0rBLVPgTzA.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">图6:项目就绪。</figcaption></figure><h2 id="06fb" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">处理项目相关性:</h2><p id="3a30" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">现在，看看魔法吧！如果我们打开这两个项目，我们可能看不到node_modules文件夹，或者可能看到它带有一些缓存。这是为什么呢？因为如果我们转到根文件夹并打开node_modules文件夹，我们会发现前端和后端应用程序的所有依赖项都安装在这里。Lerna已经承担了处理所有依赖项的责任。</p><h2 id="4ce4" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">从存储库根目录管理项目:</h2><p id="efe1" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">因为这是一个monorepo，我们可以从根文件夹管理所有的项目。例如，我们可以通过编写一些脚本，从root package.json文件中逐个或同时并行运行这些项目。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi oa"><img src="../Images/8e99faf2968b9e3386fce43b7487f539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Jj3NhKDU763SyDSeEHvow.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">图7:管理项目</figcaption></figure><p id="e79b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，我们的react和express项目都是从回购的根开始运行的。我们不需要在项目之间切换并运行它们。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/36e4ac7630fe32008408ff7fe4ed438d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*CVR3V3CrPWcs-jq8lfKV_w.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">图8:从根存储库管理项目。</figcaption></figure><p id="9b9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用monorepo做更多的事情，我们将在以后的文章中学习。在本文中，我们试图理解这种架构。</p><p id="ef4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回购环节:<a class="ae mf" href="https://github.com/Shadab420/monorepo-example" rel="noopener ugc nofollow" target="_blank">https://github.com/Shadab420/monorepo-example</a></p><h2 id="7850" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">结论</h2><p id="6e84" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">Monorepo只是一种在同一间房子里整理东西的策略。本文的重点是介绍这些体系结构，并给你一些信心，这样你就可以开始使用这些体系结构，并开始在你即将到来的项目中使用它。</p></div></div>    
</body>
</html>