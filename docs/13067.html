<html>
<head>
<title>How to Validate Your Data with Custom Validators of Pydantic Models in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Python中的Pydantic模型的自定义验证器来验证数据</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-validate-your-data-with-custom-validators-of-pydantic-models-743561a4ab53?source=collection_archive---------0-----------------------#2022-08-04">https://levelup.gitconnected.com/how-to-validate-your-data-with-custom-validators-of-pydantic-models-743561a4ab53?source=collection_archive---------0-----------------------#2022-08-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="822a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习使用Pydantic以灵活的方式验证数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1a7a78bf15afaa5dfbc0ee46c611a08d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*X_eEQak8DFvIaWx1.jpg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://pixabay.com/photos/tampons-authorisation-validation-1143489/" rel="noopener ugc nofollow" target="_blank">图片由jackmac34在Pixabay </a></figcaption></figure><p id="6ff5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> Pydantic </em>是一个流行的Python库，用于使用类型注释进行<a class="ae ky" href="https://lynn-kwong.medium.com/python-typing-and-validation-with-mypy-and-pydantic-a2563d67e6d" rel="noopener">数据验证</a>和<a class="ae ky" href="https://lynn-kwong.medium.com/how-to-use-pydantic-to-read-environment-variables-and-secret-files-in-python-8a6b8c56381c" rel="noopener">设置管理</a>。与对Python代码进行静态类型检查的<a class="ae ky" href="http://mypy-lang.org/" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> mypy </em> </a>不同，<a class="ae ky" href="https://pydantic-docs.helpmanual.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> pydantic </em> </a>在运行时强制执行类型提示，并在数据无效时提供用户友好的错误。当适当地添加类型注释时，<em class="lv"> pydantic </em>通常可以很好地完成开箱即用的数据验证。然而，有时使用默认的验证器是不够的，您需要创建自定义的验证器来实现一些特殊的数据逻辑进行数据验证。在本帖中，我们将用简单的例子介绍一些常用的自定义验证器，它们可以扩展以解决复杂的实际问题。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="adca" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">创建一个基本的pydantic模型</h2><p id="9311" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">首先，让我们创建一个标准的<em class="lv"> pydantic </em>模型，并使用默认的验证器来验证和规范化我们的数据。一个<em class="lv"> pydantic </em>模型只是一个从<em class="lv"> pydantic </em>的<code class="fe nb nc nd ne b">BaseModel</code>继承而来的类。模型的属性是用类型注释声明的，这些注释将用于数据验证和转换。注意你需要先用pip 安装<em class="lv">活塞</em>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="3ff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，在这篇文章中使用了Python 3.10，这就是为什么我们可以使用内置的<code class="fe nb nc nd ne b">list</code>而不是来自<code class="fe nb nc nd ne b">typing</code>库的<code class="fe nb nc nd ne b">List</code>来注释一个列表。如果本地没有安装Python 3.10，可以使用<a class="ae ky" href="https://lynn-kwong.medium.com/how-to-create-virtual-environments-with-venv-and-conda-in-python-31814c0a8ec2" rel="noopener"><strong class="lb iu"><em class="lv">conda</em></strong></a>安装在虚拟环境中。</p><p id="6bfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建的<em class="lv"> pydantic </em>模型非常简单，包含三个带有类型注释的属性。正如所演示的，类型注释不仅用于类型提示，如果可能的话，它们还用于强制类型。例如，任何东西都可以转换成字符串。但是，只有一些特定的类型(字符串、浮点数、十进制数、布尔值等)可以转换为整数。如果一个属性的类型不能被强制，将会产生一个<code class="fe nb nc nd ne b">ValidationError</code>和一些有用的错误信息，这些信息对调试非常有帮助。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="2dd2" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">创建自定义验证器来验证单个字段</h2><p id="c9e2" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">现在让我们创建一个自定义验证器来验证<code class="fe nb nc nd ne b">storage_type</code>字段。实际上，这种类型的简单验证可以用一个<a class="ae ky" href="https://lynn-kwong.medium.com/stop-using-magical-numbers-in-your-python-code-try-to-use-enum-like-a-pro-e1278c35b5ba" rel="noopener">枚举</a>或一个<a class="ae ky" href="https://peps.python.org/pep-0586/" rel="noopener ugc nofollow" target="_blank">文字类型</a>来实现。然而，让我们在这里把重点放在基本语法上。一旦你知道了语法，你就可以用它来解决更复杂的问题。我们假设存储类型只能是“SSD”或者“HDD”。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="0098" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建一个定制的验证器，我们需要导入<code class="fe nb nc nd ne b">validator</code>函数，它像<a class="ae ky" href="https://lynn-kwong.medium.com/understand-and-master-the-decorator-in-python-481aa444933f" rel="noopener">装饰器</a>一样工作，并且装饰这个类的一些方法。修饰的方法将用于验证指定的字段。在这种情况下，要验证的字段是<code class="fe nb nc nd ne b">storage_type</code>字段。注意，验证器像类方法一样工作，我们不需要为修饰方法添加<code class="fe nb nc nd ne b"><a class="ae ky" href="https://betterprogramming.pub/how-to-use-the-magical-staticmethod-classmethod-and-property-decorators-in-python-e42dd74e51e7" rel="noopener ugc nofollow" target="_blank">@classmethod</a></code>。不过，遗漏的<code class="fe nb nc nd ne b">@classmethod</code>可能会被警告一些像<a class="ae ky" href="https://lynn-kwong.medium.com/use-black-mypy-and-pylint-to-make-your-python-code-more-professional-b594512f4362" rel="noopener"> <em class="lv"> pylint </em> </a>这样的短毛。在这种情况下，您只需添加<code class="fe nb nc nd ne b">@classmethod</code>，定制验证器仍将正常工作。</p><p id="7aab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于验证器作为<a class="ae ky" href="https://betterprogramming.pub/how-to-use-the-magical-staticmethod-classmethod-and-property-decorators-in-python-e42dd74e51e7" rel="noopener ugc nofollow" target="_blank">类方法</a>工作，第一个参数是按照惯例命名为<code class="fe nb nc nd ne b">cls</code>的类。第二个参数是被验证的字段的值，可以随意命名。让我们使用<code class="fe nb nc nd ne b">value</code>而不是<code class="fe nb nc nd ne b">v</code>，linters不喜欢它，因为它太短，不符合命名惯例。当值无效时，我们应该抛出一个<code class="fe nb nc nd ne b">ValueError</code>或<code class="fe nb nc nd ne b">TypeError</code>，而不是<code class="fe nb nc nd ne b">ValidatorError</code>。我们用一个简单的例子来看看。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="e7d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，当字段的值无效时，错误类型和错误消息会打印在控制台中。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="2430" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">在同一个验证器中验证多个字段</h2><p id="2776" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">上面我们已经看到了如何验证单个字段，我们也可以在同一个验证器中验证多个字段。我们可以使用<code class="fe nb nc nd ne b">"*"</code>来指定所有的字段，或者将它们明确地指定为单独的位置参数，而不是在列表或元组中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="51ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的是，我们使用<code class="fe nb nc nd ne b">pre</code>参数来指定当前验证器应该在其他验证之前还是之后被调用。这样，我们可以处理原始数据，然后将转换后的数据存储在相同的字段中。在这个例子中，<code class="fe nb nc nd ne b">uppercase_strings</code>验证器将在<code class="fe nb nc nd ne b">check_storage_type</code>验证器之前被调用，因此我们可以传递一个小写字符串(“ssd”和“hdd”)，它仍然可以被正确验证，因为所有的字符串都被<code class="fe nb nc nd ne b">uppercase_strings</code>验证器转换为大写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5ab3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它显示所有的字符串字段都被我们的验证器转换成了大写。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="fa46" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">检查以前验证过的字段</h2><p id="fb30" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">我们可以使用<code class="fe nb nc nd ne b">values</code>位置参数来检查之前验证过的字段。<code class="fe nb nc nd ne b">values</code>是包含已经验证的字段的键/值对的字典。让我们假设所有的苹果电脑应该只有SDD磁盘:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="2126" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在类中首先声明的字段将首先被验证。在这个例子中，<code class="fe nb nc nd ne b">brand</code>字段在<code class="fe nb nc nd ne b">storage_type</code>字段之前被验证。注意，如果有些字段有类型注释，而有些没有，那么验证顺序可能会非常混乱。作为最佳实践，建议总是向所有字段添加类型注释，即使它们有默认值。有关字段排序的更多详情，请点击<a class="ae ky" href="https://pydantic-docs.helpmanual.io/usage/models/#field-ordering" rel="noopener ugc nofollow" target="_blank"> <em class="lv">此处</em> </a>。</p><p id="556e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在把“硬盘”传给苹果电脑，就会出现一个<code class="fe nb nc nd ne b">ValidationError</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="6704" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">用默认值验证字段</h2><p id="7715" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">默认情况下，当一个字段有默认值时，它不会被<em class="lv"> pydantic </em>验证。我们可以将<code class="fe nb nc nd ne b">always</code>参数设置为<code class="fe nb nc nd ne b">True</code>,以强制验证具有默认值的字段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="8231" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">验证数组字段的每一项</h2><p id="3e93" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">当字段是包含多个值的列表时，您可以将<code class="fe nb nc nd ne b">each_item</code>设置为<code class="fe nb nc nd ne b">True</code>，而不是手动循环列表中的每一项，这样它们就可以自动循环。让我们给<code class="fe nb nc nd ne b">ratings</code>字段添加一个验证器，它是一个整数列表。验证程序要求等级应该在1到5之间:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="b22e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，数组字段的每个元素都是独立检查的。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="50ed" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">使用根验证器来验证所有字段</h2><p id="780b" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">默认情况下，验证器的<code class="fe nb nc nd ne b">values</code>参数只存储已经验证过的字段。哪些字段在<code class="fe nb nc nd ne b">values</code>中可用取决于它们在模型中声明的顺序。如果我们想访问<code class="fe nb nc nd ne b">values</code>参数中的所有字段，并且不关心序列，我们可以使用根验证器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="edbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，第二个参数是<code class="fe nb nc nd ne b">values</code>而不是<code class="fe nb nc nd ne b">value</code>，因为使用根验证器时，所有的字段都被一起验证。另外，请注意，我们需要将<code class="fe nb nc nd ne b">skip_on_failure</code>设置为<code class="fe nb nc nd ne b">True</code>，否则，即使某些字段无效，根验证器也会被调用。在这种情况下会有一个<code class="fe nb nc nd ne b">KeyError</code>，我们定义的验证器将不能正常工作。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="7775" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">为多个模型重用同一个验证器</h2><p id="e4c5" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">当我们有同一个验证器可以应用的多个模型时。我们可以将<code class="fe nb nc nd ne b">allow_reuse</code>设置为<code class="fe nb nc nd ne b">True</code>，这样同一个验证器可以在多个验证器中使用。这种用法要求您对装饰器在Python中的工作原理有一些基本的了解。如果你想快速更新，这篇文章会很有帮助。您至少应该知道，装饰器只是一个函数的语法糖，它接受另一个函数作为输入，并返回一个经过装饰的函数作为输出。</p><p id="c244" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为属性创建一个新模型，并对其应用相同的大写验证器。我们将创建一个独立的函数来进行转换，并在每个模型中使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="e963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，验证器装饰器的<code class="fe nb nc nd ne b">@</code>语法糖被移除了。从技术上讲，<em class="lv"> pydantic </em>验证器是一个装饰器工厂，<code class="fe nb nc nd ne b">validator(“*”, pre=True, allow_reuse=True)</code>返回实际的装饰器。底层装饰器是一个函数，它将助手函数<code class="fe nb nc nd ne b">uppercase_strings</code>作为输入，并将装饰后的函数作为输出返回，输出存储在属性<code class="fe nb nc nd ne b">_uppercase_strings</code>中。函数在Python中是一个<a class="ae ky" href="https://en.wikipedia.org/wiki/First-class_citizen" rel="noopener ugc nofollow" target="_blank">一级公民</a>，可以用作任何其他数据类型。因此，它可以作为另一个函数的输入和输出来传递。</p><p id="3173" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们向<code class="fe nb nc nd ne b">Computer</code>和<code class="fe nb nc nd ne b">Attribute</code>模型传递一些小写字符串，它们将被验证器转换成大写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="3fe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当有许多模型需要应用相同类型的验证时，我们需要在所有的模型中指定<code class="fe nb nc nd ne b">allow_reuse</code>，这有点麻烦。程序员很懒，我们想尽可能避免代码重复。为了解决这个问题，我们可以创建另一个帮助函数来处理参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="be7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新后的模型应该与上面显示的完全一样。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="c844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们介绍了如何为Pydantic模型创建定制验证器。当您想要用一些默认验证器无法实现的规则来清理数据时，自定义验证器会非常有用。使用简单的代码片段给出了一系列涵盖不同用例的示例，这些代码片段很容易理解。我们不需要记住所有的方法，但是应该知道哪些是可用的，哪些可以用于我们的实际问题。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="8a42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相关文章:</p><ul class=""><li id="66b0" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated"><a class="ae ky" href="https://lynn-kwong.medium.com/python-typing-and-validation-with-mypy-and-pydantic-a2563d67e6d" rel="noopener">用mypy和pydantic进行Python分型和验证</a></li><li id="0748" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><a class="ae ky" href="https://lynn-kwong.medium.com/understand-and-master-the-decorator-in-python-481aa444933f" rel="noopener">了解并掌握Python中的装饰器</a></li></ul></div></div>    
</body>
</html>