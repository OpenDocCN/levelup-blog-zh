<html>
<head>
<title>Conquering Recursive Functions To Be A Better Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">征服递归函数成为更好的开发者</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/conquering-recursive-functions-to-be-a-better-developer-7f00e6151346?source=collection_archive---------28-----------------------#2020-05-26">https://levelup.gitconnected.com/conquering-recursive-functions-to-be-a-better-developer-7f00e6151346?source=collection_archive---------28-----------------------#2020-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b32e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">理解这么多开发者在纠结什么。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/0e27a07b7b02811c4bbedcc3d48b5240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dsPb0g_KUFJmCzzqIjhHcA.png"/></div></div></figure><p id="5399" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你真的应该关心学习递归吗？答案是“<em class="la">是</em>”。<strong class="js iu">因为到处都是老老实实</strong>。如果你写JavaScript，那么<code class="fe lb lc ld le b">JSON.parse()</code>或者<code class="fe lb lc ld le b">JSON.stringify()</code>就用它。所以DOM遍历算法和<code class="fe lb lc ld le b">getElementById()</code>。是编码面试中突然冒出来的东西。</p><p id="6a72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我甚至没有提到更复杂的数据结构，或者它如何简化一些循环操作。</p><p id="eb42" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">术语<em class="la">递归，或者</em>也许<em class="la">递归函数</em>你可能听起来很熟悉。这是计算机科学课上突然出现的编码策略之一。或者甚至是一些围绕网络的挑战。</p><p id="fefa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个棘手的概念。但是我保证<strong class="js iu">一旦你真正理解它，它就会变成你的第二天性。</strong></p><h2 id="a91a" class="lg lh it bd li lj lk dn ll lm ln dp lo kb lp lq lr kf ls lt lu kj lv lw lx ly bi translated"><strong class="ak">什么是递归？</strong></h2><p id="9d07" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">让我们先从递归解决一个问题的<em class="la">的表面来分析一下递归。</em></p><blockquote class="me mf mg"><p id="ef9d" class="jq jr la js b jt ju jv jw jx jy jz ka mh kc kd ke mi kg kh ki mj kk kl km kn im bi translated">“递归地面对一个问题意味着一遍又一遍地执行同一套动作，直到满足一个特定的条件”。</p></blockquote><p id="abe2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们改写这句话来定义一个<em class="la">递归函数。你编写函数来执行独立的任务。有点像这样:</em></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="01e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你的函数总是执行相同的任务。但是，输出会根据您提供给它们的参数而有所不同。像上面例子中的<code class="fe lb lc ld le b">num</code>。为了递归地编写这个函数<em class="la">和</em>，你必须一遍又一遍地执行相同的动作，直到满足一个条件。</p><p id="a424" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，在这种情况下你应该执行什么样的动作？</p><ul class=""><li id="45b6" class="mm mn it js b jt ju jx jy kb mo kf mp kj mq kn mr ms mt mu bi translated">嗯，这很简单，你只需要从传入的正数中减去<code class="fe lb lc ld le b">1</code>。</li><li id="f7f1" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated">直到什么？直到那个数字变成<code class="fe lb lc ld le b">1</code>本身。</li></ul><p id="66f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以你有要执行的动作和停止执行它们的条件。你是如何一遍又一遍地表演它们的？这实际上是最简单的部分。<strong class="js iu">就让函数自己调用:</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="2636" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一开始可能会让你头疼。但是记住你在上面读到的。要递归地编写这个函数<em class="la">，</em>，你只需要输入之前建立的代码。</p><ul class=""><li id="d6e7" class="mm mn it js b jt ju jx jy kb mo kf mp kj mq kn mr ms mt mu bi translated"><strong class="js iu">反复执行相同的动作</strong>:对于每个传入的数字，减去<code class="fe lb lc ld le b">1.</code>，在我们的例子中是<code class="fe lb lc ld le b">num--;</code>。然后通过调用<code class="fe lb lc ld le b">countDown(num)</code>再次执行这个操作</li><li id="dd56" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated"><strong class="js iu">让我们这样做，直到什么</strong>？直到num实际上是<code class="fe lb lc ld le b">1</code>。这就是我们函数<code class="fe lb lc ld le b">if (num === 1) return num;</code>开始时条件的需要</li></ul><h2 id="1eb9" class="lg lh it bd li lj lk dn ll lm ln dp lo kb lp lq lr kf ls lt lu kj lv lw lx ly bi translated">幕后发生了什么？</h2><p id="172c" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">要真正掌握这个概念，你必须掌握Javascript中的<em class="la">调用栈</em>是什么。为什么？因为这使得<em class="la">递归</em>成为可能<em class="la">。</em></p><p id="3706" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">几乎每种编程语言背后，都有一个<em class="la">数据结构</em>来管理被调用的函数调用。那是因为函数调用必须被组织起来。它们不是随机发生的。如果一个函数正在调用另一个函数，而那个函数也在调用一个新的函数，那该怎么办？<em class="la">调用栈</em>负责管理JavaScript中的这种机制。</p><p id="b30d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就像一堆盘子。每次调用一个函数，它都被放在<em class="la">调用栈的顶部。就像你会把最后一个洗干净的盘子放在一堆盘子上。</em></p><p id="dea9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当<code class="fe lb lc ld le b">return</code>发生在一个函数中，或者当一个函数结束时，编译器将从堆栈中移除顶部的项目。有点像一堆盘子，对吧？如果你把它们一个叠在另一个上面，你第一个拿出来吃的就是上面的那个。这种机制被称为“<a class="ae lf" href="https://it.wikipedia.org/wiki/LIFO" rel="noopener ugc nofollow" target="_blank"> <em class="la">后进先出</em> </a>”。</p><p id="1e45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是这种情况的一个演示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="c45c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事情是这样的:</p><ol class=""><li id="df40" class="mm mn it js b jt ju jx jy kb mo kf mp kj mq kn na ms mt mu bi translated">我们第一次调用<code class="fe lb lc ld le b">first()</code>，它的调用首先被放入调用栈。目前，这个电话是唯一的项目。</li><li id="018a" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn na ms mt mu bi translated">现在我们调用<code class="fe lb lc ld le b">second()</code>，它被放在调用堆栈的顶部。以上<code class="fe lb lc ld le b">first()</code>。</li><li id="29b2" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn na ms mt mu bi translated">当<code class="fe lb lc ld le b">second()</code>调用<code class="fe lb lc ld le b">intruder()</code>时也是如此。我们现在在调用堆栈中有三个项目，其中<code class="fe lb lc ld le b">intruder()</code>位于顶部。</li><li id="4933" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn na ms mt mu bi translated"><code class="fe lb lc ld le b">intruder()</code>返回，所以它只是弹出调用堆栈。现在我们处于和列表中第二点相同的状态。</li><li id="55ac" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn na ms mt mu bi translated">现在<code class="fe lb lc ld le b">second()</code>也返回了，从调用堆栈中弹出，让我们回到与第一点相同的状态——列表中只有一项。</li><li id="48d4" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn na ms mt mu bi translated"><code class="fe lb lc ld le b">third()</code>最后被调用，一个新的项被放在调用栈上，一旦<code class="fe lb lc ld le b">third()</code>返回，它立即被弹出，<code class="fe lb lc ld le b">first()</code> one也返回。导致相同的效果发生在堆栈中的项目上。</li></ol><p id="6f34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">请注意:</strong>在Chrome developer的工具里面，你会发现，在执行代码和放置断点的时候，有一个叫做Call-Stack的部分。它将直观地呈现刚才所说的内容。</p><h2 id="2f03" class="lg lh it bd li lj lk dn ll lm ln dp lo kb lp lq lr kf ls lt lu kj lv lw lx ly bi translated">将调用堆栈逻辑应用到我们的示例中</h2><p id="ab37" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">这需要解释吗？因为现在你可以以一种更低层次的方式理解，在我们的<code class="fe lb lc ld le b">countDown()</code>例子中发生了什么。每当我们一次又一次地调用这个函数时，一个新的调用就被放在栈顶。一旦我们在<code class="fe lb lc ld le b">num === 1</code>时点击return，调用栈将弹出其中的每个调用。产生了我们的最终结果。</p><pre class="kp kq kr ks gt nb le nc nd aw ne bi"><span id="5f1d" class="lg lh it le b gy nf ng l nh ni">countDown(3)is called              ---------&gt; +1 call on the stack<br/>countDown(3) returns countDown(2)  ---------&gt; +1 call on the stack countDown(2) returns countDown(1)  ---------&gt; +1 call on the stack<br/>countDown(1) returns countDown(0)  ---------&gt; +1 call on the stack</span><span id="e239" class="lg lh it le b gy nj ng l nh ni">Base condition is hit. Functions will return from inner to outer<br/>For every return we see a -1 on the call stack.</span></pre><h2 id="ef24" class="lg lh it bd li lj lk dn ll lm ln dp lo kb lp lq lr kf ls lt lu kj lv lw lx ly bi translated">写递归函数的时候应该记住什么？</h2><p id="c503" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">你已经完全准备好在下一个编码问题中应用<em class="la">递归</em>。但是请记住，要编写正确的<em class="la">递归函数</em>，需要遵循一些严格的规则。或者更好，他们要求的两个强制性特征。</p><ul class=""><li id="eb9c" class="mm mn it js b jt ju jx jy kb mo kf mp kj mq kn mr ms mt mu bi translated">用不同的输入调用自身:没有对自身的调用，你的函数就不是递归的。用相同的参数调用自身会导致堆栈溢出错误。这意味着<em class="la">调用栈</em>已经耗尽了函数调用的空间。</li><li id="a509" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated">基本条件:这是结束<em class="la">递归循环</em>的条件。如果你没有，那么你永远不会离开这个函数，所以会出现一个无限循环。</li></ul><p id="64eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回顾如何避免常见陷阱或<em class="la">递归陷阱:</em></p><ul class=""><li id="dee4" class="mm mn it js b jt ju jx jy kb mo kf mp kj mq kn mr ms mt mu bi translated">你是否有一个终止递归循环的基本条件？</li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mk ml l"/></div></figure><ul class=""><li id="44ea" class="mm mn it js b jt ju jx jy kb mo kf mp kj mq kn mr ms mt mu bi translated">当你的函数调用自己时，你总是传递不同的参数吗？</li><li id="f07f" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated">你是否从你的电话中回复了一些东西，这是正确的数据吗？</li></ul><p id="8e04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果是这样，那么你可以走了。</p><h2 id="d5fa" class="lg lh it bd li lj lk dn ll lm ln dp lo kb lp lq lr kf ls lt lu kj lv lw lx ly bi translated">常见的递归问题</h2><p id="e0b6" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">倒数到1是一个简单的例子，我用来展示递归是如何工作的。使用递归可能解决的其他常见问题有</p><ul class=""><li id="a1e8" class="mm mn it js b jt ju jx jy kb mo kf mp kj mq kn mr ms mt mu bi translated"><strong class="js iu">阶乘计算</strong></li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mk ml l"/></div></figure><ul class=""><li id="7890" class="mm mn it js b jt ju jx jy kb mo kf mp kj mq kn mr ms mt mu bi translated"><strong class="js iu">字符串反转</strong></li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="fe16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还可以用于查找最短路径、确定模式匹配、查找单词组合等。</p><h2 id="febd" class="lg lh it bd li lj lk dn ll lm ln dp lo kb lp lq lr kf ls lt lu kj lv lw lx ly bi translated"><strong class="ak">现在怎么办？</strong></h2><p id="fe31" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">一旦你学会了解决问题的新方法，新的大门就会在你的脑海中打开。这并不意味着你必须处处使用递归T21。但是如果你真的理解了它，当你面对挑战时，你的脑海中会有一个小小的回声。</p><ul class=""><li id="92a1" class="mm mn it js b jt ju jx jy kb mo kf mp kj mq kn mr ms mt mu bi translated">"试试递归方法怎么样？"</li><li id="3a6a" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated">“这会让这个循环更容易吗？这代码多简洁？”</li></ul><p id="a513" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你觉得有必要练习，可以在很多网站上找到递归挑战:</p><ul class=""><li id="8180" class="mm mn it js b jt ju jx jy kb mo kf mp kj mq kn mr ms mt mu bi translated"><a class="ae lf" href="https://skilled.dev/course/recursion" rel="noopener ugc nofollow" target="_blank">技术开发</a></li><li id="d802" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated">代码大战。</li><li id="c4cf" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated"><a class="ae lf" href="https://www.codechef.com/tags/problems/recursion" rel="noopener ugc nofollow" target="_blank">主厨</a>。</li><li id="c687" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated"><a class="ae lf" href="https://www.codingame.com/learn/recursion" rel="noopener ugc nofollow" target="_blank">编码游戏</a>。</li><li id="e526" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated"><a class="ae lf" href="https://www.byte-by-byte.com/12-recursion-questions/" rel="noopener ugc nofollow" target="_blank">常见递归面试问题</a>。</li></ul><h2 id="4c14" class="lg lh it bd li lj lk dn ll lm ln dp lo kb lp lq lr kf ls lt lu kj lv lw lx ly bi translated">结论</h2><p id="625b" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">如何解决问题的新窗口已经打开。您现在已经了解了递归机制及其好处。这将真正有助于你的下一次面试、代码挑战，甚至日常编程任务。</p><p id="82ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">— <em class="la">皮耶罗</em></p><h2 id="c40e" class="lg lh it bd li lj lk dn ll lm ln dp lo kb lp lq lr kf ls lt lu kj lv lw lx ly bi translated">资源</h2><ul class=""><li id="d349" class="mm mn it js b jt lz jx ma kb nk kf nl kj nm kn mr ms mt mu bi translated"><a class="ae lf" href="https://www.codewars.com/collections/recursion-1" rel="noopener ugc nofollow" target="_blank"> CodeWars递归挑战</a>。</li><li id="bd17" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated"><a class="ae lf" href="https://skilled.dev/course/recursion" rel="noopener ugc nofollow" target="_blank">编码面试的递归</a>。</li><li id="6d07" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated"><a class="ae lf" href="https://it.wikipedia.org/wiki/LIFO" rel="noopener ugc nofollow" target="_blank">后进先出</a>。</li><li id="2d96" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated"><a class="ae lf" href="https://icons8.it/" rel="noopener ugc nofollow" target="_blank">美丽图标8中的所有图标。</a></li><li id="bd25" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated"><a class="ae lf" href="https://umaar.com/dev-tips/23-debugger-shortcuts/" rel="noopener ugc nofollow" target="_blank">从Chrome开发者工具调用堆栈</a>。</li><li id="e9ac" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated"><a class="ae lf" href="https://www.codechef.com/tags/problems/recursion" rel="noopener ugc nofollow" target="_blank">厨师长</a>。</li><li id="67b2" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated">编码名。</li><li id="6764" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated"><a class="ae lf" href="https://www.byte-by-byte.com/12-recursion-questions/" rel="noopener ugc nofollow" target="_blank">常见递归面试问题</a>。</li></ul></div></div>    
</body>
</html>