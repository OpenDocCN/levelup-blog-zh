<html>
<head>
<title>Building Chat Service in Golang and Websockets Backed by Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Redis构建Golang和Websockets聊天服务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-chat-service-in-golang-and-websockets-backed-by-redis-b42a8784636c?source=collection_archive---------0-----------------------#2020-05-24">https://levelup.gitconnected.com/building-chat-service-in-golang-and-websockets-backed-by-redis-b42a8784636c?source=collection_archive---------0-----------------------#2020-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c537249d70478034cdf43bbffb446160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PqIOluZ3QdiNrdwpLzsfrA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">高层建筑的解决方案</figcaption></figure></div><div class="ab cl kf kg hx kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="im in io ip iq"><p id="de14" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">这是Redis系列的第六篇帖子。</p><p id="86d7" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated"><a class="ae lk" href="https://medium.com/swlh/install-redis-inside-a-ubuntu-vm-d5022d42d8cc" rel="noopener"> <strong class="ko iu">第一部分</strong>:在Ubuntu VM内部安装Redis<br/></a><a class="ae lk" href="https://medium.com/@mhewedy_46874/redis-persistence-by-example-167aacf3a028" rel="noopener"><strong class="ko iu">第二部分:</strong> Redis持久化实例</a> <br/> <a class="ae lk" href="https://medium.com/@mhewedy_46874/implement-game-scoring-using-redis-75660f739760" rel="noopener"> <strong class="ko iu">第三部分</strong>:使用Redis实现游戏排行榜</a> <br/> <a class="ae lk" href="https://medium.com/@mhewedy_46874/implement-job-queue-in-redis-9f0f8d394561" rel="noopener"> <strong class="ko iu">第四部分</strong>:使用Redis实现作业队列</a> <br/> <a class="ae lk" href="https://medium.com/@mhewedy_46874/building-rest-api-backed-by-redis-ae8ff4818460" rel="noopener"> <strong class="ko iu">第五部分</strong>:构建由Redis支持的REST API</a><br/>👈<br/> <a class="ae lk" href="https://medium.com/@mhewedy_46874/redis-cluster-configurations-by-example-5480a178e884" rel="noopener"> <strong class="ko iu">第七部分</strong> : <strong class="ko iu"> </strong> Redis集群配置示例</a> <br/> <a class="ae lk" href="https://medium.com/@mhewedy_46874/redis-geospatial-by-example-f5505a0962ef" rel="noopener"> <strong class="ko iu">第八部分</strong> : Redis地理空间示例</a></p></div><div class="ab cl kf kg hx kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="im in io ip iq"><p id="b143" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">在这篇文章中，我们将看到如何使用Redis作为一个发布订阅来实现一个水平可伸缩的聊天服务:</p><p id="af8a" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">💎什么是Pub-sub？<br/>💎设计决策<br/>💎让我们编码(最无聊的部分🔥，敬请期待)<br/>💎正在运行的聊天服务<br/>💎测试水平可伸缩性</p></div><div class="ab cl kf kg hx kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="im in io ip iq"><p id="8969" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">在这篇文章中，我们将使用安装在虚拟机上的<a class="ae lk" href="https://medium.com/swlh/install-redis-inside-a-ubuntu-vm-d5022d42d8cc" rel="noopener"> Redis，使用<strong class="ko iu">害虫</strong>，智能虚拟机管理器，和一个</a><a class="ae lk" href="https://medium.com/@mhewedy_46874/vermin-a-modern-cli-for-vagrant-b115c9e97989" rel="noopener">现代CLI的流浪者</a>。</p><p id="4610" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">你可以从Github页面了解更多关于<strong class="ko iu">害虫</strong>的信息。</p><div class="ll lm gp gr ln lo"><a href="https://github.com/mhewedy/vermin" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab fo"><div class="lq ab lr cl cj ls"><h2 class="bd iu gy z fp lt fr fs lu fu fw is bi translated">mhewedy/害虫</h2><div class="lv l"><h3 class="bd b gy z fp lt fr fs lu fu fw dk translated">目录:害虫是一个智能，简单和强大的命令行工具，用于Linux，Windows和macOS。它被设计成…</h3></div><div class="lw l"><p class="bd b dl z fp lt fr fs lu fu fw dk translated">github.com</p></div></div><div class="lx l"><div class="ly l lz ma mb lx mc jz lo"/></div></div></a></div></div><div class="ab cl kf kg hx kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="im in io ip iq"><h1 id="603a" class="md me it bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">什么是Pub-sub？</h1><p id="7148" class="pw-post-body-paragraph km kn it ko b kp nb kr ks kt nc kv kw kx nd kz la lb ne ld le lf nf lh li lj im bi translated">在本系列的文章“<a class="ae lk" href="https://medium.com/@mhewedy_46874/implement-job-queue-in-redis-9f0f8d394561" rel="noopener">使用Redis </a>实现作业队列”中，我们已经看到了如何使用<code class="fe ng nh ni nj b">list</code>操作及其<code class="fe ng nh ni nj b">BLPOP</code>从列表中弹出并阻塞，直到新元素出现。在本帖中，我们将看到在Redis中拥有一流支持的发布-订阅模式。</p><h2 id="ec77" class="nk me it bd mf nl nm dn mj nn no dp mn kx np nq mr lb nr ns mv lf nt nu mz nv bi translated">那么什么是公共订阅呢？</h2><p id="c5c5" class="pw-post-body-paragraph km kn it ko b kp nb kr ks kt nc kv kw kx nd kz la lb ne ld le lf nf lh li lj im bi translated">发布-订阅模式允许称为<em class="nw">发布者</em>的消息发送者通过一个通道向称为<em class="nw">订阅者</em>的接收者发布消息，而不知道存在哪些订阅者——如果有的话。所有订阅者在收到消息时都可以同时收到消息。</p><p id="9341" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">与<strong class="ko iu">消息队列</strong>不同，后者在消息的<em class="nw">发送方</em>和<em class="nw">接收方</em>之间提供异步通信协议，因此它们不需要同时与消息队列交互。放入队列中的消息将被存储，直到收件人检索到它们。</p><p id="948e" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">这是一个在发布订阅合同中检索消息的回执，所有活动订阅者都将在发布订阅合同中接收消息。此外，在发布订阅中，如果没有活跃的订户，消息将会丢失。</p></div><div class="ab cl kf kg hx kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="im in io ip iq"><h1 id="8dba" class="md me it bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">设计决策</h1><ol class=""><li id="6320" class="nx ny it ko b kp nb kt nc kx nz lb oa lf ob lj oc od oe of bi translated">聊天服务允许用户订阅多个频道。(可用于实现直接聊天)</li><li id="8996" class="nx ny it ko b kp og kt oh kx oi lb oj lf ok lj oc od oe of bi translated">这个聊天服务被设计成<em class="nw">水平可伸缩的</em>。它是一个无状态服务(<em class="nw">状态仅在WebSocket连接打开时保存，用户可以建立到多个服务器的多个连接</em>)。我们可以根据Reids水平扩展聊天服务，而不用担心WebSocket协议的状态本质。</li><li id="c36a" class="nx ny it ko b kp og kt oh kx oi lb oj lf ok lj oc od oe of bi translated">Redis客户端为每个订阅打开一个TCP连接，这需要打开太多从聊天服务到Redis的连接，如果我们为用户订阅的每个频道打开一个连接。<br/>为了避免这种情况，每当用户订阅新的频道，我都要取消旧的订阅，一次性订阅所有用户频道。(Redis允许同时订阅多个频道)</li><li id="5f86" class="nx ny it ko b kp og kt oh kx oi lb oj lf ok lj oc od oe of bi translated">默认情况下，聊天服务在两个通道中注册所有连接的用户“<em class="nw">通用</em>和“<em class="nw">随机</em>”(遵循松弛约定)。用户可以在任何时间订阅任何任意频道，并且只有订阅了这些频道的用户才能看到消息。</li><li id="a1a8" class="nx ny it ko b kp og kt oh kx oi lb oj lf ok lj oc od oe of bi translated">我使用WebSockets来处理JavaScript客户机和聊天服务之间的通信。(我喜欢)</li><li id="20a6" class="nx ny it ko b kp og kt oh kx oi lb oj lf ok lj oc od oe of bi translated">javascript客户端用JSON向Websocket API发送消息，该API使用下面的结构<code class="fe ng nh ni nj b">{"command": &lt;0=Subscribe, 1=Unsubscribe or 2=Chat&gt;, "channel": "channel name", "content": "content text"}</code></li><li id="0ed6" class="nx ny it ko b kp og kt oh kx oi lb oj lf ok lj oc od oe of bi translated">该服务提供了几个REST APIs来获取用户和特定用户订阅的频道。(将有助于在服务之上构建GUI)</li><li id="401f" class="nx ny it ko b kp og kt oh kx oi lb oj lf ok lj oc od oe of bi translated">聊天服务不处理用户管理或认证方面的问题。</li></ol></div><div class="ab cl kf kg hx kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="im in io ip iq"><h1 id="349b" class="md me it bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">让我们编码🚀🚀🚀</h1><p id="bdac" class="pw-post-body-paragraph km kn it ko b kp nb kr ks kt nc kv kw kx nd kz la lb ne ld le lf nf lh li lj im bi translated">在这一(长)部分，我们将浏览最重要的代码片段，然而，完整的源代码是托管在https://github.com/mhewedy-playground/Chat的Github上</p><h2 id="fcc0" class="nk me it bd mf nl nm dn mj nn no dp mn kx np nq mr lb nr ns mv lf nt nu mz nv bi translated">聊天服务的高级拱门</h2><figure class="om on oo op gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/25e53662ff2d3a81292f7746fb2e5c88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qjJ984G3CS8S9ivRKzvWBA.jpeg"/></div></div></figure><h2 id="30b8" class="nk me it bd mf nl nm dn mj nn no dp mn kx np nq mr lb nr ns mv lf nt nu mz nv bi translated">用户组件:</h2><p id="3342" class="pw-post-body-paragraph km kn it ko b kp nb kr ks kt nc kv kw kx nd kz la lb ne ld le lf nf lh li lj im bi translated">让我们从结构定义开始:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="78e6" class="nk me it nj b gy ou ov l ow ox"><strong class="nj iu">type </strong>User <strong class="nj iu">struct </strong>{<br/>   name            string<br/>   channelsHandler *redis.PubSub</span><span id="9674" class="nk me it nj b gy oy ov l ow ox">   stopListenerChan <strong class="nj iu">chan struct</strong>{}<br/>   listening        bool</span><span id="0051" class="nk me it nj b gy oy ov l ow ox">   MessageChan <strong class="nj iu">chan </strong>redis.Message<br/>}</span></pre><p id="a999" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated"><code class="fe ng nh ni nj b"><strong class="ko iu">name</strong></code>:用户的名字</p><p id="6f24" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated"><code class="fe ng nh ni nj b"><strong class="ko iu">channelsHandler</strong></code>:Redis subscribe命令连接的处理程序。因此，每次用户订阅一个新频道时，我们使用该处理程序来结束当前订阅，然后开始对新频道列表(旧频道+新频道)的新订阅，然后通过subscribe函数返回的值来更新该引用。</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="f6b0" class="nk me it nj b gy ou ov l ow ox">// cancel current subscritpion<br/>u.channelsHandler.Unsubscribe()<br/>u.channelsHandler.Close()</span><span id="d227" class="nk me it nj b gy oy ov l ow ox">// start a new subscritpion on the new channels list (old channels list + the new channel user ask to subscribe to)<br/>pubSub := rdb.Subscribe(channels...)<br/>u.channelsHandler = pubSub</span></pre><p id="64e1" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated"><code class="fe ng nh ni nj b"><strong class="ko iu">stopListenerChan</strong></code> : Golang通道，用于停止当前用于处理当前订阅的goroutine。它与<code class="fe ng nh ni nj b"><strong class="ko iu">channelsHandler</strong></code> <strong class="ko iu"> </strong>有关。</p><p id="e097" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated"><code class="fe ng nh ni nj b"><strong class="ko iu">MessageChan</strong></code> <strong class="ko iu"> : </strong>在Reids订阅goroutine和Websocket发送方goroutine之间进行通信的Golang通道。因此，每当一条新消息到达Redis中的一个通道时，我们会立即将其发布到web socket连接。</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="0322" class="nk me it nj b gy ou ov l ow ox"><em class="nw">// The Listener Goroutine:<br/></em><strong class="nj iu">go func</strong>() {<br/>   u.listening = <strong class="nj iu"><em class="nw">true<br/>   </em></strong>fmt.Println(<strong class="nj iu">"starting the listener for user:"</strong>, u.name, <strong class="nj iu">"on channels:"</strong>, channels)<br/>   <strong class="nj iu">for </strong>{<br/>      <strong class="nj iu">select </strong>{<br/>      <strong class="nj iu">case </strong>msg, ok := &lt;-pubSub.Channel():<br/>         <strong class="nj iu">if </strong>!ok {<br/>            <strong class="nj iu">break<br/>         </strong>}<br/>         u.MessageChan &lt;- *msg</span><span id="59b2" class="nk me it nj b gy oy ov l ow ox">      <strong class="nj iu">case </strong>&lt;-u.stopListenerChan:<br/>         <strong class="nj iu">break<br/>      </strong>}<br/>   }<br/>}()</span></pre><p id="3421" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">下面是用户类型的<code class="fe ng nh ni nj b"><strong class="ko iu">Connect</strong></code>、<code class="fe ng nh ni nj b">Subscribe</code>和<code class="fe ng nh ni nj b">Unsubscribe</code>方法的实现，简单明了:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="f300" class="nk me it nj b gy ou ov l ow ox"><em class="nw">//Connect connect user to user channels on redis<br/></em><strong class="nj iu">func </strong>Connect(rdb *redis.Client, name string) (*User, error) {<br/>   <strong class="nj iu">if </strong>_, err := rdb.SAdd(<strong class="nj iu"><em class="nw">usersKey</em></strong>, name).Result(); err != nil {<br/>      <strong class="nj iu">return </strong>nil, err<br/>   }</span><span id="6f26" class="nk me it nj b gy oy ov l ow ox">   u := &amp;User{<br/>      name:             name,<br/>      stopListenerChan: make(<strong class="nj iu">chan struct</strong>{}),<br/>      MessageChan:      make(<strong class="nj iu">chan </strong>redis.Message),<br/>   }</span><span id="74b5" class="nk me it nj b gy oy ov l ow ox">   <strong class="nj iu">if </strong>err := u.connect(rdb); err != nil {<br/>      <strong class="nj iu">return </strong>nil, err<br/>   }</span><span id="2e01" class="nk me it nj b gy oy ov l ow ox">   <strong class="nj iu">return </strong>u, nil<br/>}</span><span id="13c6" class="nk me it nj b gy oy ov l ow ox"><strong class="nj iu">func </strong>(u *User) Subscribe(rdb *redis.Client, channel string) error {</span><span id="a467" class="nk me it nj b gy oy ov l ow ox">   userChannelsKey := fmt.Sprintf(<strong class="nj iu"><em class="nw">userChannelFmt</em></strong>, u.name)</span><span id="a74f" class="nk me it nj b gy oy ov l ow ox">   <strong class="nj iu">if </strong>rdb.SIsMember(userChannelsKey, channel).Val() {<br/>      <strong class="nj iu">return </strong>nil<br/>   }<br/>   <strong class="nj iu">if </strong>err := rdb.SAdd(userChannelsKey, channel).Err(); err != nil {<br/>      <strong class="nj iu">return </strong>err<br/>   }</span><span id="b692" class="nk me it nj b gy oy ov l ow ox">   <strong class="nj iu">return </strong>u.connect(rdb)<br/>}</span><span id="418b" class="nk me it nj b gy oy ov l ow ox"><strong class="nj iu">func </strong>(u *User) Unsubscribe(rdb *redis.Client, channel string) error {</span><span id="a2c4" class="nk me it nj b gy oy ov l ow ox">   userChannelsKey := fmt.Sprintf(<strong class="nj iu"><em class="nw">userChannelFmt</em></strong>, u.name)</span><span id="866b" class="nk me it nj b gy oy ov l ow ox">   <strong class="nj iu">if </strong>!rdb.SIsMember(userChannelsKey, channel).Val() {<br/>      <strong class="nj iu">return </strong>nil<br/>   }<br/>   <strong class="nj iu">if </strong>err := rdb.SRem(userChannelsKey, channel).Err(); err != nil {<br/>      <strong class="nj iu">return </strong>err<br/>   }</span><span id="3131" class="nk me it nj b gy oy ov l ow ox">   <strong class="nj iu">return </strong>u.connect(rdb)<br/>}</span></pre><p id="932a" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">简单直接地说，我们从Redis中检索频道，并通过订阅/取消订阅操作保持频道更新。然后调用订阅用户拥有的频道列表的<code class="fe ng nh ni nj b">connect</code>方法。</p><p id="8524" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">下面是<code class="fe ng nh ni nj b">connect</code>方法的实现:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="21c3" class="nk me it nj b gy ou ov l ow ox"><strong class="nj iu">func </strong>(u *User) connect(rdb *redis.Client) error {<br/><br/>   <strong class="nj iu">var </strong>c []string<br/><br/>   c1, err := rdb.SMembers(<strong class="nj iu"><em class="nw">ChannelsKey</em></strong>).Result()<br/>   <strong class="nj iu">if </strong>err != nil {<br/>      <strong class="nj iu">return </strong>err<br/>   }<br/>   c = append(c, c1...)<br/><br/>   <em class="nw">// get all user channels (from DB) and start subscribe<br/>   </em>c2, err := rdb.SMembers(fmt.Sprintf(<strong class="nj iu"><em class="nw">userChannelFmt</em></strong>, u.name)).Result()<br/>   <strong class="nj iu">if </strong>err != nil {<br/>      <strong class="nj iu">return </strong>err<br/>   }<br/>   c = append(c, c2...)<br/><br/>   <strong class="nj iu">if </strong>len(c) == 0 {<br/>      fmt.Println(<strong class="nj iu">"no channels to connect to for user: "</strong>, u.name)<br/>      <strong class="nj iu">return </strong>nil<br/>   }<br/><br/>   <strong class="nj iu">if </strong>u.channelsHandler != nil {<br/>      <strong class="nj iu">if </strong>err := u.channelsHandler.Unsubscribe(); err != nil {<br/>         <strong class="nj iu">return </strong>err<br/>      }<br/>      <strong class="nj iu">if </strong>err := u.channelsHandler.Close(); err != nil {<br/>         <strong class="nj iu">return </strong>err<br/>      }<br/>   }<br/>   <strong class="nj iu">if </strong>u.listening {<br/>      u.stopListenerChan &lt;- <strong class="nj iu">struct</strong>{}{}<br/>   }<br/><br/>   <strong class="nj iu">return </strong>u.doConnect(rdb, c...)<br/>}<br/><br/><strong class="nj iu">func </strong>(u *User) doConnect(rdb *redis.Client, channels ...string) error {<br/>   <em class="nw">// subscribe all channels in one request<br/>   </em>pubSub := rdb.Subscribe(channels...)<br/>   <em class="nw">// keep channel handler to be used in unsubscribe<br/>   </em>u.channelsHandler = pubSub<br/><br/>   <em class="nw">// The Listener<br/>   </em><strong class="nj iu">go func</strong>() {<br/>      u.listening = <strong class="nj iu"><em class="nw">true<br/>      </em></strong>fmt.Println(<strong class="nj iu">"starting the listener for user:"</strong>, u.name, <strong class="nj iu">"on channels:"</strong>, channels)<br/>   <strong class="nj iu">loop</strong>:<br/>      <strong class="nj iu">for </strong>{<br/>         <strong class="nj iu">select </strong>{<br/>         <strong class="nj iu">case </strong>msg, ok := &lt;-pubSub.Channel():<br/>            <strong class="nj iu">if </strong>!ok {<br/>               <strong class="nj iu">break loop<br/>            </strong>}<br/>            u.MessageChan &lt;- *msg<br/><br/>         <strong class="nj iu">case </strong>&lt;-u.stopListenerChan:<br/>            fmt.Println(<strong class="nj iu">"stopping the listener for user:"</strong>, u.name)<br/>            <strong class="nj iu">break loop<br/>         </strong>}<br/>      }<br/>   }()<br/>   <strong class="nj iu">return </strong>nil<br/>}</span></pre><p id="eaba" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">我们基本上检索用户的频道列表，然后清除旧状态(使用<code class="fe ng nh ni nj b">channelsHandler</code>关闭任何现有的TCP连接，使用<code class="fe ng nh ni nj b">stopListener</code>关闭正在运行的Goroutines，如果有的话)</p><p id="63ea" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">然后我们调用订阅频道列表的<code class="fe ng nh ni nj b">doConnect</code>。<code class="fe ng nh ni nj b">doConnect</code> <em class="nw">(这是迄今为止最重要的方法)</em>做如下工作:</p><ol class=""><li id="74f2" class="nx ny it ko b kp kq kt ku kx oz lb pa lf pb lj oc od oe of bi translated">通过为一个连接中的所有频道列表打开一个TCP连接来订阅频道列表</li><li id="8077" class="nx ny it ko b kp og kt oh kx oi lb oj lf ok lj oc od oe of bi translated">捕获对TCP连接的引用(<code class="fe ng nh ni nj b">u.channelsHandler = pubSub</code>)</li><li id="569a" class="nx ny it ko b kp og kt oh kx oi lb oj lf ok lj oc od oe of bi translated">启动一个goroutine，它将处理我们在任何订阅的频道上从Redis收到的消息。(同样，我们可以通过关闭Golang通道<code class="fe ng nh ni nj b">stopListener</code>来停止goroutine)</li><li id="7427" class="nx ny it ko b kp og kt oh kx oi lb oj lf ok lj oc od oe of bi translated">将从Redis收到的消息发送到Golang频道<code class="fe ng nh ni nj b">u.MessageChan</code>。这个Golang通道正在被迭代，任何新消息都将被推送到WebSocket客户端。</li></ol><p id="cbbb" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">此外，还有一种<code class="fe ng nh ni nj b">Disconnect</code>方法，基本上与<code class="fe ng nh ni nj b">connect</code>方法类似(通过清理资源)，但它不订阅新的频道列表，而且它关闭了<code class="fe ng nh ni nj b">MessageChan</code> Golang频道Redis和WebSockets之间的通信——因为它不再需要。</p><p id="c25e" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">最后一个方法<code class="fe ng nh ni nj b">Chat</code>，简单如下:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="071e" class="nk me it nj b gy ou ov l ow ox"><strong class="nj iu">func </strong>Chat(rdb *redis.Client, channel string, content string) error {<br/>   <strong class="nj iu">return </strong>rdb.Publish(channel, content).Err()<br/>}</span></pre><p id="204d" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">它只是将消息发布到一个通道。</p><h2 id="1e23" class="nk me it bd mf nl nm dn mj nn no dp mn kx np nq mr lb nr ns mv lf nt nu mz nv bi translated">WebSocket聊天处理方法:</h2><pre class="om on oo op gt oq nj or os aw ot bi"><span id="b379" class="nk me it nj b gy ou ov l ow ox"><strong class="nj iu">func </strong>ChatWebSocketHandler(w http.ResponseWriter, r *http.Request, rdb *redis.Client) {</span><span id="950c" class="nk me it nj b gy oy ov l ow ox">   conn, err := upgrader.Upgrade(w, r, nil)<br/>   <strong class="nj iu">if </strong>err != nil {<br/>      handleWSError(err, conn)<br/>      <strong class="nj iu">return<br/>   </strong>}</span><span id="8bf6" class="nk me it nj b gy oy ov l ow ox">   err = onConnect(r, conn, rdb)<br/>   <strong class="nj iu">if </strong>err != nil {<br/>      handleWSError(err, conn)<br/>      <strong class="nj iu">return<br/>   </strong>}</span><span id="5c54" class="nk me it nj b gy oy ov l ow ox">   closeCh := onDisconnect(r, conn, rdb)</span><span id="e9ce" class="nk me it nj b gy oy ov l ow ox">   // on recieve message from redis channels<br/>   onChannelMessage(conn, r)</span><span id="67c8" class="nk me it nj b gy oy ov l ow ox"><strong class="nj iu">loop</strong>:<br/>   <strong class="nj iu">for </strong>{<br/>      <strong class="nj iu">select </strong>{<br/>      <strong class="nj iu">case </strong>&lt;-closeCh:<br/>         <strong class="nj iu">break loop<br/>      default</strong>:<br/>         onUserMessage(conn, r, rdb)<br/>      }<br/>   }<br/>}</span></pre><ol class=""><li id="e4f5" class="nx ny it ko b kp kq kt ku kx oz lb pa lf pb lj oc od oe of bi translated">我们升级连接(使用Gorilla Toolkit WebSocket实现)</li><li id="a51c" class="nx ny it ko b kp og kt oh kx oi lb oj lf ok lj oc od oe of bi translated">调用<code class="fe ng nh ni nj b">onConnect</code>来检索URL的用户名，并调用<code class="fe ng nh ni nj b">user.Connect</code>方法来建立到用户订阅的频道的连接，并将用户添加到<strong class="ko iu"><em class="nw">connected users</em></strong><code class="fe ng nh ni nj b">map</code>。</li><li id="b4f9" class="nx ny it ko b kp og kt oh kx oi lb oj lf ok lj oc od oe of bi translated">调用<code class="fe ng nh ni nj b">onDiscounnect</code>它注册一个调用<code class="fe ng nh ni nj b">user.Disconnect</code>的WebSocket关闭处理程序，并将用户从<strong class="ko iu"><em class="nw">connected users</em></strong><code class="fe ng nh ni nj b">map</code>中移除，最后，它返回一个Golang通道，该通道用于中断WebSocket循环，我们将在到达该方法的and时看到。</li><li id="a9bd" class="nx ny it ko b kp og kt oh kx oi lb oj lf ok lj oc od oe of bi translated">叫<code class="fe ng nh ni nj b">onChannelMessage</code>那样子:</li></ol><pre class="om on oo op gt oq nj or os aw ot bi"><span id="d3d1" class="nk me it nj b gy ou ov l ow ox">u := connectedUsers[username]</span><span id="32e1" class="nk me it nj b gy oy ov l ow ox"><strong class="nj iu">go func</strong>() {<br/>   <strong class="nj iu">for </strong>m := <strong class="nj iu">range </strong>u.MessageChan {</span><span id="0e84" class="nk me it nj b gy oy ov l ow ox">      msg := msg{<br/>         Content: m.Payload,<br/>         Channel: m.Channel,<br/>         Command: 0,<br/>      }</span><span id="178c" class="nk me it nj b gy oy ov l ow ox">      <strong class="nj iu">if </strong>err := conn.WriteJSON(msg); err != nil {<br/>         fmt.Println(err)<br/>      }<br/>   }</span><span id="833d" class="nk me it nj b gy oy ov l ow ox">}()</span></pre><p id="e629" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">它从<strong class="ko iu"><em class="nw">connected users</em></strong>映射中检索用户，并启动一个goroutine，该goroutine将从订阅Reids通道的go routine正在编写的<code class="fe ng nh ni nj b">u.MssageChan</code>中进行读取。然后，它将WebSocket连接的消息写回客户端。</p><p id="2791" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">5.WebSocket循环:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="3b57" class="nk me it nj b gy ou ov l ow ox"><strong class="nj iu">loop</strong>:<br/>   <strong class="nj iu">for </strong>{<br/>      <strong class="nj iu">select </strong>{<br/>      <strong class="nj iu">case </strong>&lt;-closeCh:<br/>         <strong class="nj iu">break loop<br/>      default</strong>:<br/>         onUserMessage(conn, r, rdb)<br/>      }<br/>   }</span></pre><p id="faee" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">它基本上永远循环下去，直到一个<code class="fe ng nh ni nj b">closeCh</code>(从上面#3中的<code class="fe ng nh ni nj b">onDisconnect</code>方法返回)调用<code class="fe ng nh ni nj b">onUserMessage</code>方法，该方法解析来自WebSocket连接的消息并根据命令类型采取行动。实现如下:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="2009" class="nk me it nj b gy ou ov l ow ox"><strong class="nj iu">type </strong>msg <strong class="nj iu">struct </strong>{<br/>   Content string <strong class="nj iu">`json:"content,omitempty"`<br/>   </strong>Channel string <strong class="nj iu">`json:"channel,omitempty"`<br/>   </strong>Command int    <strong class="nj iu">`json:"command,omitempty"`<br/>   </strong>Err     string <strong class="nj iu">`json:"err,omitempty"`<br/></strong>}</span><span id="86c9" class="nk me it nj b gy oy ov l ow ox"><strong class="nj iu">const </strong>(<br/>   <strong class="nj iu"><em class="nw">commandSubscribe </em></strong>= <strong class="nj iu"><em class="nw">iota<br/>   commandUnsubscribe<br/>   commandChat<br/></em></strong>)</span><span id="9e04" class="nk me it nj b gy oy ov l ow ox"><strong class="nj iu">func </strong>onUserMessage(conn *websocket.Conn, r *http.Request, rdb *redis.Client) {</span><span id="59a8" class="nk me it nj b gy oy ov l ow ox">   <strong class="nj iu">var </strong>msg msg</span><span id="a6c6" class="nk me it nj b gy oy ov l ow ox">   <strong class="nj iu">if </strong>err := conn.ReadJSON(&amp;msg); err != nil {<br/>      handleWSError(err, conn)<br/>      <strong class="nj iu">return<br/>   </strong>}</span><span id="2d76" class="nk me it nj b gy oy ov l ow ox">   username := r.URL.Query()[<strong class="nj iu">"username"</strong>][0]<br/>   u := connectedUsers[username]</span><span id="3f48" class="nk me it nj b gy oy ov l ow ox">   <strong class="nj iu">switch </strong>msg.Command {<br/>   <strong class="nj iu">case <em class="nw">commandSubscribe</em></strong>:<br/>      <strong class="nj iu">if </strong>err := u.Subscribe(rdb, msg.Channel); err != nil {<br/>         handleWSError(err, conn)<br/>      }<br/>   <strong class="nj iu">case <em class="nw">commandUnsubscribe</em></strong>:<br/>      <strong class="nj iu">if </strong>err := u.Unsubscribe(rdb, msg.Channel); err != nil {<br/>         handleWSError(err, conn)<br/>      }<br/>   <strong class="nj iu">case <em class="nw">commandChat</em></strong>:<br/>      <strong class="nj iu">if </strong>err := user.Chat(rdb, msg.Channel, msg.Content); err != nil {<br/>         handleWSError(err, conn)<br/>      }<br/>   }<br/>}</span></pre><p id="7059" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">它基本上读取来自Javascript Websocket客户端的JSON，然后从<strong class="ko iu"><em class="nw">connected users</em></strong><code class="fe ng nh ni nj b">map</code>检索用户，然后切换消息本身的<code class="fe ng nh ni nj b">Command</code>字段，该字段可能是以下之一:</p><ul class=""><li id="da60" class="nx ny it ko b kp kq kt ku kx oz lb pa lf pb lj pc od oe of bi translated"><code class="fe ng nh ni nj b"><strong class="ko iu">commandSubscribe</strong></code>:接受用户的频道名称，并为用户订阅该频道(通过调用<code class="fe ng nh ni nj b">u.Subscribe</code></li><li id="9074" class="nx ny it ko b kp og kt oh kx oi lb oj lf ok lj pc od oe of bi translated"><code class="fe ng nh ni nj b"><strong class="ko iu">commandUnsubscribe</strong></code>:接受用户的频道名称，取消用户对该频道的订阅(通过调用<code class="fe ng nh ni nj b">u.Subscribe</code>)</li><li id="e9d8" class="nx ny it ko b kp og kt oh kx oi lb oj lf ok lj pc od oe of bi translated"><code class="fe ng nh ni nj b"><strong class="ko iu">commandChat</strong></code>:该命令调用<code class="fe ng nh ni nj b">user.Chat</code>向频道发送文本消息。</li></ul><h2 id="6129" class="nk me it bd mf nl nm dn mj nn no dp mn kx np nq mr lb nr ns mv lf nt nu mz nv bi translated">API处理程序</h2><p id="c806" class="pw-post-body-paragraph km kn it ko b kp nb kr ks kt nc kv kw kx nd kz la lb ne ld le lf nf lh li lj im bi translated">除了用户和Websocket聊天组件之外，我们还有最后一个代表API的组件:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="039b" class="nk me it nj b gy ou ov l ow ox">r.Path(<strong class="nj iu">"/chat"</strong>).Methods(<strong class="nj iu">"GET"</strong>).HandlerFunc(api.<strong class="nj iu"><em class="nw">ChatWebSocketHandler</em></strong>)r.Path(<strong class="nj iu">"/users"</strong>).Methods(<strong class="nj iu">"GET"</strong>).HandlerFunc(api.<strong class="nj iu"><em class="nw">UsersHandler</em></strong>)<br/>r.Path(<strong class="nj iu">"/user/{user}/channels"</strong>).Methods(<strong class="nj iu">"GET"</strong>).HandlerFunc(api.<strong class="nj iu"><em class="nw">UserChannelsHandler</em></strong>)</span></pre><p id="8011" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">我们在上一节已经检查了函数<strong class="ko iu"><em class="nw">ChatWebSocketHandler</em></strong><em class="nw">，我们来看看UserHandler和userchandler:</em>的实现</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="88b5" class="nk me it nj b gy ou ov l ow ox"><strong class="nj iu">func </strong>UserChannelsHandler(w http.ResponseWriter, r *http.Request, rdb *redis.Client) {<br/>   username := mux.Vars(r)[<strong class="nj iu">"user"</strong>]</span><span id="e3b6" class="nk me it nj b gy oy ov l ow ox">   list, err := user.GetChannels(rdb, username)<br/>   <strong class="nj iu">if </strong>err != nil {<br/>      handleError(err, w)<br/>      <strong class="nj iu">return<br/>   </strong>}<br/>   err = json.NewEncoder(w).Encode(list)<br/>   <strong class="nj iu">if </strong>err != nil {<br/>      handleError(err, w)<br/>      <strong class="nj iu">return<br/>   </strong>}</span><span id="a5bf" class="nk me it nj b gy oy ov l ow ox">}</span><span id="4b5d" class="nk me it nj b gy oy ov l ow ox"><strong class="nj iu">func </strong>UsersHandler(w http.ResponseWriter, r *http.Request, rdb *redis.Client) {</span><span id="8414" class="nk me it nj b gy oy ov l ow ox">   list, err := user.List(rdb)<br/>   <strong class="nj iu">if </strong>err != nil {<br/>      handleError(err, w)<br/>      <strong class="nj iu">return<br/>   </strong>}<br/>   err = json.NewEncoder(w).Encode(list)<br/>   <strong class="nj iu">if </strong>err != nil {<br/>      handleError(err, w)<br/>      <strong class="nj iu">return<br/>   </strong>}<br/>}</span></pre><p id="9170" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">这就是编码部分的全部内容。你可以在Github<a class="ae lk" href="https://github.com/mhewedy-playground/Chat" rel="noopener ugc nofollow" target="_blank">https://github.com/mhewedy-playground/Chat</a>看看整个实现</p><p id="6abe" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">在下一节中，我们将看到聊天服务的运行。</p></div><div class="ab cl kf kg hx kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="im in io ip iq"><h1 id="b7f9" class="md me it bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">聊天服务正在运行</h1><p id="2463" class="pw-post-body-paragraph km kn it ko b kp nb kr ks kt nc kv kw kx nd kz la lb ne ld le lf nf lh li lj im bi translated">让我们像下面这样并排打开两个chrome窗口，这样测试就容易了:</p><figure class="om on oo op gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pd"><img src="../Images/3f9a35623ad5bd7acd00b8f5c6f3f39b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XoztHPhcHYib9RB9hbmLlQ.png"/></div></div></figure><blockquote class="pe pf pg"><p id="f207" class="km kn nw ko b kp kq kr ks kt ku kv kw ph ky kz la pi lc ld le pj lg lh li lj im bi translated">你需要首先启动Golang聊天服务，并确保它连接到Redis服务器，你可能会发现本系列的第一篇文章有助于在几分钟内安装和配置Ubuntu VM中的Redis。</p></blockquote><h2 id="abfb" class="nk me it bd mf nl nm dn mj nn no dp mn kx np nq mr lb nr ns mv lf nt nu mz nv bi translated">连接和订阅:</h2><p id="810f" class="pw-post-body-paragraph km kn it ko b kp nb kr ks kt nc kv kw kx nd kz la lb ne ld le lf nf lh li lj im bi translated">首先，我们需要启动聊天服务:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="7cc8" class="nk me it nj b gy ou ov l ow ox">$ go build; ./chat</span></pre><p id="e89b" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">让我们在它们的每个选项卡上启动WebSocket客户端，在左侧选项卡上键入:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="6835" class="nk me it nj b gy ou ov l ow ox">let socket = new WebSocket("ws://localhost:8080/chat?username=<strong class="nj iu">wael</strong>");<br/>socket.onmessage = function(event) {<br/>  console.log(`[message] Data received from server: ${event.data}`);<br/>};</span></pre><p id="5e68" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">在右边的标签上写下:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="c158" class="nk me it nj b gy ou ov l ow ox">let socket = new WebSocket("ws://localhost:8080/chat?username=<strong class="nj iu">mazen</strong>");<br/>socket.onmessage = function(event) {<br/>  console.log(`[message] Data received from server: ${event.data}`);<br/>};</span></pre><p id="1357" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">请注意聊天服务日志:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="b4ff" class="nk me it nj b gy ou ov l ow ox">connected from: [::1]:55471 user: wael<br/>starting the listener for user: wael on channels: [general random]<br/>connected from: [::1]:55490 user: mazen<br/>starting the listener for user: mazen on channels: [general random]</span></pre><p id="6afd" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">让我们注意一下使用<code class="fe ng nh ni nj b">redis-cli</code>的Redis客户端:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="5f61" class="nk me it nj b gy ou ov l ow ox">127.0.0.1:6379&gt; <strong class="nj iu">client list</strong><br/>id=325 addr=127.0.0.1:58944 fd=9 name= age=98745 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client<br/>id=852 addr=127.0.0.1:60006 fd=8 name= age=107 idle=104 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=smembers<br/>id=853 addr=127.0.0.1:60008 fd=10 name= age=107 idle=17 flags=P db=0 sub=2 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=ping<br/>id=854 addr=127.0.0.1:60010 fd=11 name= age=104 idle=14 flags=P db=0 sub=2 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=ping</span></pre><p id="5266" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">注意，我们有4个客户端连接到Redis:第一个是<code class="fe ng nh ni nj b">redis-cli</code>本身。第二个是Redis命令在服务内部使用的连接(<code class="fe ng nh ni nj b">publish</code>、<code class="fe ng nh ni nj b">smembers</code>、<code class="fe ng nh ni nj b">sadd</code>...等等)。最后两个是两个客户端(左标签客户端和右标签客户端)的订阅功能的连接。</p><blockquote class="pe pf pg"><p id="ed80" class="km kn nw ko b kp kq kr ks kt ku kv kw ph ky kz la pi lc ld le pj lg lh li lj im bi translated">注意，每个客户端只有一个到它监听的所有频道的打开的连接。</p></blockquote><p id="9dcb" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">现在，让我们向左侧选项卡客户端添加另外3个通道，并重新检查命令。在左侧选项卡中键入:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="aaec" class="nk me it nj b gy ou ov l ow ox">socket.send('{"command": 0, "channel": "new_channel1"}')<br/>socket.send('{"command": 0, "channel": "new_channel2"}')<br/>socket.send('{"command": 0, "channel": "new_channel3"}')</span></pre><blockquote class="pe pf pg"><p id="4947" class="km kn nw ko b kp kq kr ks kt ku kv kw ph ky kz la pi lc ld le pj lg lh li lj im bi translated">同样，命令=0表示订阅，命令=1表示取消订阅，命令=2表示发送聊天消息。</p></blockquote><p id="f04c" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">请注意聊天服务日志:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="f423" class="nk me it nj b gy ou ov l ow ox">starting the listener for user: wael on channels: [general random new_channel1]<br/>starting the listener for user: wael on channels: [general random new_channel2 new_channel1]<br/>starting the listener for user: wael on channels: [general random new_channel3 new_channel2 new_channel1]</span></pre><p id="4a66" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">它指示使用“wael”(左边的用户)现在正在收听总共5个房间，但是让我们检查到Redis的TCP连接，以确保我们没有过多地使用它们:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="5c7f" class="nk me it nj b gy ou ov l ow ox">127.0.0.1:6379&gt; client list<br/>id=325 addr=127.0.0.1:58944 fd=9 name= age=99646 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client<br/>id=882 addr=127.0.0.1:60066 fd=8 name= age=99 idle=83 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=smembers<br/>id=884 addr=127.0.0.1:60070 fd=11 name= age=93 idle=3 flags=P db=0 sub=2 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=ping<br/>id=887 addr=127.0.0.1:60076 fd=10 name= age=83 idle=23 flags=P db=0 sub=5 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=ping</span></pre><p id="b331" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">很好，我们仍然使用4个通道，你可能会注意到连接的<code class="fe ng nh ni nj b">id</code>已经改变。</p><h2 id="8f23" class="nk me it bd mf nl nm dn mj nn no dp mn kx np nq mr lb nr ns mv lf nt nu mz nv bi translated">发送消息:</h2><p id="3826" class="pw-post-body-paragraph km kn it ko b kp nb kr ks kt nc kv kw kx nd kz la lb ne ld le lf nf lh li lj im bi translated">现在让我们从左边的<strong class="ko iu"> <em class="nw">客户端发送消息</em> </strong>到“通用”频道:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="a378" class="nk me it nj b gy ou ov l ow ox">socket.send('{"command": 2, "channel": "general", "content": "some general content"}')</span></pre><p id="2422" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">消息将被发布到<strong class="ko iu"><em class="nw">【general】</em></strong>通道，然后它将被两个客户端接收并被推送到两个客户端上的WebSocket:</p><figure class="om on oo op gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pk"><img src="../Images/67f8ed718b03dd6751175787c12d4e2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LEgTLeWSUoSVb_cu0xHjmA.png"/></div></div></figure><p id="c064" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">现在，如果我们尝试将消息推送到左侧客户端独占的频道之一(例如“<strong class="ko iu"><em class="nw">【new _ channel 1】</em></strong>),它将不会出现在右侧客户端。</p><p id="0c1b" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">让我们来看看Redis的数据结构:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="9b28" class="nk me it nj b gy ou ov l ow ox">127.0.0.1:6379&gt; keys *<br/>1) "users"<br/>2) "user:wael:channels"<br/>3) "channels"<br/>127.0.0.1:6379&gt; smembers users<br/>1) "mazen"<br/>2) "wael"<br/>127.0.0.1:6379&gt; smembers channels<br/>1) "general"<br/>2) "random"<br/>127.0.0.1:6379&gt; smembers user:wael:channels<br/>1) "new_channel3"<br/>2) "new_channel2"<br/>3) "new_channel1"</span></pre><p id="e1f2" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">我们注意到，与我们的聊天服务相关的所有数据都保存在Redis中，这有助于聊天服务在水平方向<strong class="ko iu"> <em class="nw">扩展</em> </strong>。</p><blockquote class="pe pf pg"><p id="17c6" class="km kn nw ko b kp kq kr ks kt ku kv kw ph ky kz la pi lc ld le pj lg lh li lj im bi translated">我们可以依赖Redis使用<code class="fe ng nh ni nj b">INCR</code>命令提供的原子性，并用惟一的ID标记每条聊天消息，以确保客户端收到的每条消息都是一致的。</p></blockquote><h2 id="c677" class="nk me it bd mf nl nm dn mj nn no dp mn kx np nq mr lb nr ns mv lf nt nu mz nv bi translated">断开连接:</h2><p id="2196" class="pw-post-body-paragraph km kn it ko b kp nb kr ks kt nc kv kw kx nd kz la lb ne ld le lf nf lh li lj im bi translated">让我们试着将<strong class="ko iu"> <em class="nw">右边的</em> </strong>客户端断开，并再次检查<code class="fe ng nh ni nj b">users</code>的Redis设置。在chrome issue的右侧选项卡上:</p><p id="7f63" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">我们有一个API来列出我们拥有的用户:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="042e" class="nk me it nj b gy ou ov l ow ox">watch curl -s <a class="ae lk" href="http://localhost:8080/users" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/users</a></span></pre><p id="1693" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">在我的案例中显示:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="518e" class="nk me it nj b gy ou ov l ow ox">Every 2.0s: curl -s <a class="ae lk" href="http://localhost" rel="noopener ugc nofollow" target="_blank">http://localhost</a>...  Muhammads-MacBook-Pro.local: Sun May 24 11:21:29 2020</span><span id="716a" class="nk me it nj b gy oy ov l ow ox">["mazen","wael"]</span></pre><p id="5597" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">现在让我们转到chrome的右边标签，关闭连接:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="c2dc" class="nk me it nj b gy ou ov l ow ox">socket.close()</span></pre><p id="87ed" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">您会注意到curl watch命令的结果发生了变化:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="c718" class="nk me it nj b gy ou ov l ow ox">Every 2.0s: curl -s <a class="ae lk" href="http://localhost" rel="noopener ugc nofollow" target="_blank">http://localhost</a>...  Muhammads-MacBook-Pro.local: Sun May 24 11:22:16 2020</span><span id="4973" class="nk me it nj b gy oy ov l ow ox">["wael"]</span></pre><p id="6f62" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">让我们看看Redis:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="7949" class="nk me it nj b gy ou ov l ow ox">127.0.0.1:6379&gt; smembers users<br/>1) "wael"</span></pre><h1 id="452e" class="md me it bd mf mg pl mi mj mk pm mm mn mo pn mq mr ms po mu mv mw pp my mz na bi">👏👏👏</h1><blockquote class="pe pf pg"><p id="02e1" class="km kn nw ko b kp kq kr ks kt ku kv kw ph ky kz la pi lc ld le pj lg lh li lj im bi translated">我用来调试发送给Redis的命令的一个方便的命令是<code class="fe ng nh ni nj b"><em class="it">MONITOR</em></code>,它用来打印Redis服务器收到的每一个命令。</p></blockquote></div><div class="ab cl kf kg hx kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="im in io ip iq"><h1 id="47e0" class="md me it bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">测试水平可伸缩性</h1><p id="b875" class="pw-post-body-paragraph km kn it ko b kp nb kr ks kt nc kv kw kx nd kz la lb ne ld le lf nf lh li lj im bi translated">接下来，让我们启动两个聊天服务，并将每个客户端连接到其中一个:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="71ef" class="nk me it nj b gy ou ov l ow ox">$ go build; PORT=8080 ./chat &amp; PORT=8081 ./chat &amp;<br/>[1] 51535<br/>[2] 51536</span></pre><p id="ddf3" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">现在让我们打开chrome，将左侧客户端指向8080服务，将右侧客户端指向8081服务:</p><p id="a41a" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">在左侧的选项卡上，粘贴:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="1b86" class="nk me it nj b gy ou ov l ow ox">let socket = new WebSocket("ws://localhost:<strong class="nj iu">8080</strong>/chat?username=<strong class="nj iu">wael</strong>");<br/>socket.onmessage = function(event) {<br/>  console.log(`[message] Data received from server: ${event.data}`);<br/>};</span></pre><p id="6ea3" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">在右边的选项卡上，粘贴:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="7887" class="nk me it nj b gy ou ov l ow ox">let socket = new WebSocket("ws://localhost:<strong class="nj iu">8081</strong>/chat?username=<strong class="nj iu">mazen</strong>");<br/>socket.onmessage = function(event) {<br/>  console.log(`[message] Data received from server: ${event.data}`);<br/>};</span></pre><p id="70f5" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">在左侧的选项卡上，我们向双方都应该订阅的“通用”频道发送一条消息:</p><pre class="om on oo op gt oq nj or os aw ot bi"><span id="5050" class="nk me it nj b gy ou ov l ow ox">socket.send('{"command": 2, "channel": "general", "content": "some general content"}')</span></pre><p id="442e" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">是的，它正在工作:</p><figure class="om on oo op gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pq"><img src="../Images/61a335ff9b5b9e8b985b6dbcb8ac2fed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LAaHU3mRO3Dfk0o2m4gGeg.png"/></div></div></figure><h1 id="5d5a" class="md me it bd mf mg pl mi mj mk pm mm mn mo pn mq mr ms po mu mv mw pp my mz na bi">👏👏👏 🎉🎉🎉🎉🎉</h1></div><div class="ab cl kf kg hx kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="im in io ip iq"><p id="64ee" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">我们已经看到了如何使用Redis和Golang强大的goroutines和使用WebSocket编译的通道，使用强大的库Gorilla Toolkit WebSocket和Go-Redis来构建一个<strong class="ko iu"><em class="nw"/></strong><strong class="ko iu"><em class="nw">多通道</em> </strong>聊天服务。</p><p id="072b" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">请注意，该代码不是最好的，也不是生产级的，它是作为概念验证编写的。</p><p id="e0e0" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">同样，你可以在Github找到源代码:<a class="ae lk" href="https://github.com/mhewedy-playground/Chat" rel="noopener ugc nofollow" target="_blank">https://github.com/mhewedy-playground/Chat</a></p></div><div class="ab cl kf kg hx kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="im in io ip iq"><p id="a1a4" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">参考资料:</p><div class="ll lm gp gr ln lo"><a href="https://redis.io/topics/pubsub" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab fo"><div class="lq ab lr cl cj ls"><h2 class="bd iu gy z fp lt fr fs lu fu fw is bi translated">发布/订阅Redis</h2><div class="lv l"><h3 class="bd b gy z fp lt fr fs lu fu fw dk translated">订阅、取消订阅和发布实现发布/订阅消息传递范式，其中(引用维基百科)发送者…</h3></div><div class="lw l"><p class="bd b dl z fp lt fr fs lu fu fw dk translated">redis.io</p></div></div><div class="lx l"><div class="pr l lz ma mb lx mc jz lo"/></div></div></a></div><div class="ll lm gp gr ln lo"><a href="https://www.wikiwand.com/en/Publish%E2%80%93subscribe_pattern" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab fo"><div class="lq ab lr cl cj ls"><h2 class="bd iu gy z fp lt fr fs lu fu fw is bi translated">发布-订阅模式|维基网</h2><div class="lv l"><h3 class="bd b gy z fp lt fr fs lu fu fw dk translated">在软件架构中，发布-订阅是一种消息传递模式，消息的发送者(称为发布者)不…</h3></div><div class="lw l"><p class="bd b dl z fp lt fr fs lu fu fw dk translated">www.wikiwand.com</p></div></div><div class="lx l"><div class="ps l lz ma mb lx mc jz lo"/></div></div></a></div><div class="ll lm gp gr ln lo"><a href="https://github.com/gorilla/websocket" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab fo"><div class="lq ab lr cl cj ls"><h2 class="bd iu gy z fp lt fr fs lu fu fw is bi translated">大猩猩/网络插座</h2><div class="lv l"><h3 class="bd b gy z fp lt fr fs lu fu fw dk translated">Gorilla WebSocket是WebSocket协议的Go实现。Gorilla WebSocket包提供了一个完整的…</h3></div><div class="lw l"><p class="bd b dl z fp lt fr fs lu fu fw dk translated">github.com</p></div></div><div class="lx l"><div class="pt l lz ma mb lx mc jz lo"/></div></div></a></div><div class="ll lm gp gr ln lo"><a href="https://github.com/go-redis/redis" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab fo"><div class="lq ab lr cl cj ls"><h2 class="bd iu gy z fp lt fr fs lu fu fw is bi translated">go-redis/redis</h2><div class="lv l"><h3 class="bd b gy z fp lt fr fs lu fu fw dk translated">支持:API文档:https://pkg.go.dev/github.com/go-redis/redis/v8?tab=doc.示例…</h3></div><div class="lw l"><p class="bd b dl z fp lt fr fs lu fu fw dk translated">github.com</p></div></div><div class="lx l"><div class="pu l lz ma mb lx mc jz lo"/></div></div></a></div></div></div>    
</body>
</html>