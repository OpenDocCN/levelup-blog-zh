# Swift 中的断言

> 原文：<https://levelup.gitconnected.com/assertions-in-swift-a0ef807f6c25>

## 何时、何地以及如何使用它们

![](img/ecb3188ce6a4ce9a234b1aa5c5ae2bcc.png)

克里斯多夫·伯恩斯在 [Unsplash](https://unsplash.com/s/photos/digital?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

第一个真正的 IDE 于 1991 年问世。它是微软 Visual Basic 平台的一部分。苹果在 2003 年用了十几年才赶上 Xcode。当然，集成开发环境的标准或者一些人会争论集成调试环境。调试是程序员至少要花一半时间去做的事情。当然，也有人说程序员可以花多达 50%的时间来编写程序——尽管我很难相信这个事实，此外，如果两者都是真的，什么时候会没有时间来编码呢？

基于这种想法，一个叫詹姆斯·高斯林(Java 编程语言的发明者)的人提出了一个想法，用一个叫做 assert 的语句将两个相当耗时的任务结合起来。断言是一段代码，它既是测试的手段，也是记录的手段。这是一个肯定会被复制到 Swift 中的语言特性。

## 断言

在这两种语言中，断言都是最基本的形式，它们不仅测试一个值，而且与“if 语句”不同，有效地记录了关于它的假设。不仅如此，在 XCode 环境中，它们被视为注释。只在调试模式下编译时包含在二进制文件中，而不会包含在生产代码中——尽管这还不是全部。与我一起了解更多信息。

## 基本语法

在这个例子中，你有一个启动游戏的视图，它在第十行有一个断言，声明当调用 returnMembers 方法时，至少应该返回两个玩家，但正如你在这里看到的，情况并非如此。

理解这一点很重要，这不是一个 if 语句，而是一个断言。一个不会被编译成产品代码的断言**。所以你应该把它发布到应用商店。在调试模式下，这段代码将停止您的应用程序，因此您可以修复它。在生产中它什么都不会。**

## 下一级语法

断言联盟中的下一个是这个，我认为它需要在编码学校中教授。继续游戏主题，我的代码要求返回等级值。因为我确信你知道 switch 语句必须覆盖所有可能的值，所以即使知道你四级不能存在，它也坚持某些东西必须在缺省下。那么，还有什么比断言这个值是不可能的更好的呢？代码将再次进入调试版本，但不是生产。

## 终端语法

调试库中的最终断言如下所示。同样，记住这只在调试模式下有效，所以调用 stopEverything 在你的生产应用程序中什么也不做，显然只在调试时使用。

## 新语法

但是 swift 中的故事并没有就此结束，因为设计者希望类似的东西**能够进入产品代码**，所以他们提出了两个原语，做了和我刚才举例说明的最后两个断言相同的事情。

*   前提条件就像断言，但是只有当你确定某事为真时，它才会进入你的产品构建
*   预处理失败意味着总是让你的代码崩溃，即使是在产品中——这对于在正常情况下不应该发生的情况是有利的。

## 最后

你得到的这个会使调试和生产代码崩溃。据我所知，其背后的想法是，你将使用它作为最后手段，以保护一些资源的完整性，否则将被破坏，所以你有效地迫使崩溃。

*   无论发生什么，fatal error(“foo”)总是会崩溃

但是对于最后一种情况有一个警告—当您在代码中调用 fatalError 时，出于调试目的，您的可执行文件的路径会被复制到二进制文件本身中。您可能不希望在生产环境中广泛宣传这条路径。