<html>
<head>
<title>Google Interview Question: Two Sum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌面试问题:两个总和</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/google-interview-question-two-sum-c3eb0ce3dc2f?source=collection_archive---------9-----------------------#2021-08-22">https://levelup.gitconnected.com/google-interview-question-two-sum-c3eb0ce3dc2f?source=collection_archive---------9-----------------------#2021-08-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="36ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个非常受欢迎的面试问题，测试你在编写高效代码方面的知识。理想情况下，有两种方法可以解决这个流行的问题。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/444a1ec6144a8836a01a0fe50e00e265.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uJji6pEVY-Z5DfekNP4xcw.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">来源:凯via【Unsplash.com】</figcaption></figure><p id="6d5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们得到了一个数字列表以及目标数字，我们需要计算出哪两个数字加到了目标数字上。数字的组合可能存在，也可能不存在。</p><p id="bebc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个问题可以这样组织:</p><p id="5a8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“假设我们有一个整数数组。我们必须返回两个整数的索引，这样，如果我们把它们加起来，我们将达到一个给定的特定目标。这里我们将做一个假设，即数组中总是有一个唯一的解，因此不会有相同目标的两组索引。</p><p id="7514" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">比如，假设数组像A = [2，8，12，15]，目标和是20。然后它将返回索引1和2，作为A[1] + A[2] = 20。"</p><h1 id="96c1" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">方法一:蛮力</h1><p id="c2b4" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">理想情况下，这是我们穷尽所有选择来检查组合是否存在的最简单的方法。</p><p id="ad9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用两个指针；一个指向列表的第一项，另一个遍历列表。</p><p id="502d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以一个指针将指向2，这是列表中的第一项，也是遍历列表的第二项。我们将检查2和2的组合，其总和不等于20，因此我们继续。</p><p id="8886" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一个组合是2和8，产生10，但不是真的，我们继续2和12，产生14，假的。</p><p id="4e93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们继续下一个项目，我们测试2和15，得到17，我们寻找20，我们返回False，我们已经用尽了2的所有组合，我们继续8。</p><p id="2585" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们检查8和2的组合，得到10，然后继续检查8和8的组合，得到16，8和12的组合得到20。我们已经找到了我们的匹配，并将返回True。</p><p id="5e4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这相当耗费精力，想象一下，如果我们不得不在一个巨大的数据集上循环多次，而条目却在列表的末尾，会怎么样？因此，该方法返回非常慢的大O(n)的时间复杂度。</p><p id="de8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的一面是，我们没有利用内存，我们的空间复杂度是O(1)。</p><p id="483b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管如此，让我们编写我们的解决方案:</p><pre class="kn ko kp kq gt mg mh mi mj aw mk bi"><span id="1f5b" class="ml le iq mh b gy mm mn l mo mp">def twoSum(nums,target):<br/>    for i in range(len(nums)):<br/>        for j in range(i + 1, len(nums)):<br/>            if nums[i] + nums [j] == target:<br/>                return[i,j]</span></pre><p id="ecd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有人把这个解决方案扔给我，我不会觉得有趣或印象深刻，事实上我会非常失望。效率非常重要，尤其是在大型科技公司。我宁愿选择更优化的解决方案。</p><h1 id="1d54" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">方法2</h1><p id="290a" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">对于第二种方法，我们只需要一个指针，因为我们将寻求一组数据结构的帮助。</p><p id="3d70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样的规则也适用于我们搜索两个数字的组合，这两个数字加起来就是目标，在我们的例子中是20。</p><p id="c11d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的集合将保存所有我们“见过”的组合器项目，这将跟踪我们的检查。</p><p id="d6c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将从2开始，因为这是我们的第一个项目，我们知道我们需要18来达到20的总和。然后，我们将在集合中保存18个。移动到下一个项目8，我们需要12来得到20的总数，因此我们将在我们的集合中保存12。</p><p id="17ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一项是12，但是我们的集合中已经有12个了，我们的条件已经满足，我们将返回True。</p><p id="dca6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们编写我们的解决方案:</p><pre class="kn ko kp kq gt mg mh mi mj aw mk bi"><span id="f0d1" class="ml le iq mh b gy mm mn l mo mp">def twoSum(nums,target):<br/>    combinators = {}<br/>    for i in range(len(nums)):<br/>        if target - nums[i] in combinators:<br/>            return True<br/>        else:<br/>            combinators[nums[i]] = i<br/>    test_list = [2,8,12,15]<br/>    print(twoSum(test_list,20))</span></pre><p id="a145" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们只在链表中循环一次，所以我们的时间复杂度是Big O(n ),但是记住我们使用了一个集合，这将把我们的空间复杂度变成BigO(n)。</p><h1 id="ebb2" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">额外资源</h1><div class="mq mr gp gr ms mt"><a href="https://colab.research.google.com/drive/1JnZ1l_s7CjWPAsVD_OsABaG_cVMGkDA9?usp=sharing" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">谷歌联合实验室</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">编辑描述</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">colab.research.google.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh kw mt"/></div></div></a></div></div></div>    
</body>
</html>