<html>
<head>
<title>RxJS Terms You MUST know in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你必须知道的角度术语</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rxjs-terms-you-must-know-in-angular-8265309c8f94?source=collection_archive---------7-----------------------#2020-05-18">https://levelup.gitconnected.com/rxjs-terms-you-must-know-in-angular-8265309c8f94?source=collection_archive---------7-----------------------#2020-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="d066" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">有角的</h2><div class=""/><div class=""><h2 id="e2e7" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">理解RxJS术语:observables、operators、observer、subscription、subject和scheduler，在Angular应用程序中使用简单的解释。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/c14f7260f88857318659e86db3913772.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kiz9V-noKpoSaIAdYyzWNA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@hannynaibaho?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">刘汉宁内巴霍</a>在<a class="ae lh" href="https://unsplash.com/s/photos/coffee?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="24ff" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在反应式编程中，有6个流行术语是:</p><ul class=""><li id="2aa3" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">可观察量</li><li id="c78b" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">经营者</li><li id="7fc8" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">观察者</li><li id="f136" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">签署</li><li id="8300" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">科目</li><li id="4b71" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">调度程序</li></ul><p id="6207" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这个故事中，我将介绍这些术语作为新手开始学习反应式编程的基础知识。</p><p id="0892" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="ms">更多类似内容，请查看</em><a class="ae lh" href="https://betterfullstack.com" rel="noopener ugc nofollow" target="_blank"><em class="ms">https://betterfullstack.com</em></a></p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="44b4" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated"><strong class="ak">可观察的</strong></h1><p id="e464" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated"><em class="ms">可观察的是可以随时间到达的数据流或数据源。</em></p><p id="ecfc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在Angular应用程序中，您可以从两种主要情况创建数据源:</p><p id="f211" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">HTTP请求:</p><pre class="ks kt ku kv gt nx ny nz oa aw ob bi"><span id="47cd" class="oc nb it ny b gy od oe l of og">import { ajax } from "rxjs/ajax";</span><span id="7cb4" class="oc nb it ny b gy oh oe l of og">const URL = "https://jsonplaceholder.typicode.com/posts";<br/>const posts$ = ajax.getJSON(URL);</span></pre><p id="abb4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">用户界面事件:</p><pre class="ks kt ku kv gt nx ny nz oa aw ob bi"><span id="4289" class="oc nb it ny b gy od oe l of og">import { fromEvent } from 'rxjs';</span><span id="1829" class="oc nb it ny b gy oh oe l of og">const searchBtn = document.getElementById('search-user');<br/>const searchUser$ = fromEvent(searchBtn, 'click');</span></pre><blockquote class="oi oj ok"><p id="b7d6" class="li lj ms lk b ll lm kd ln lo lp kg lq ol ls lt lu om lw lx ly on ma mb mc md im bi translated">在<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/components-in-reactive-programming-365c7bd9d271">反应式编程的组件</a>中阅读更多关于一般概念的内容。</p></blockquote><p id="ac56" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="ms">An</em><strong class="lk jd"><em class="ms">RxJS Subject</em></strong><em class="ms">是一种特殊类型的可观察对象，允许将值多播给许多观察者。</em></p><p id="af6d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以把一个主题想象成类似于EventEmitter的Angular。查看更多关于我的另一个故事<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/rxjs-subjects-explained-with-examples-78ae7b9edfc"> RxJS主题的详细信息，并举例说明</a>。</p><p id="9394" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意:可观测量是单播的。这意味着每个订阅的观察者拥有可观察对象的独立执行。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="f7a2" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated"><strong class="ak">订阅</strong></h1><p id="a50e" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated"><em class="ms">订阅是代表可支配资源的对象，通常是可观察的执行。</em></p><p id="bbac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每当你观察到一个物体，它就会被创造出来。你提供的功能是一个<strong class="lk jd">观察者</strong>，在那里我们决定如何对发生的每一个事件做出反应。</p><p id="13d4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个<strong class="lk jd">观察器</strong>有三个主要功能:<code class="fe oo op oq ny b">next()</code>、<code class="fe oo op oq ny b">error()</code>和<code class="fe oo op oq ny b">complete()</code>。</p><pre class="ks kt ku kv gt nx ny nz oa aw ob bi"><span id="06c8" class="oc nb it ny b gy od oe l of og">import { fromEvent } from 'rxjs';</span><span id="072a" class="oc nb it ny b gy oh oe l of og">const searchBtn = document.getElementById('search-user');<br/>const searchUser$ = fromEvent(searchBtn, 'click');</span><span id="0c12" class="oc nb it ny b gy oh oe l of og">const subscription = searchUser$.subscribe(event =&gt; console.log(event));</span></pre><p id="ae16" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">重要提示:</strong>一旦调用<code class="fe oo op oq ny b">subscribe</code>，它将创建一个订阅，在组件生命周期结束时，您需要删除它以避免内存泄漏。</p><p id="1a31" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">观察器</strong>在反应式编程中使用默认的<strong class="lk jd">调度器</strong>，反应式编程在观察器开始发出任何通知之前执行。</p><p id="6932" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以定制自己的调度程序，并将其应用于您的可观察对象。你可以认为<strong class="lk jd">调度器</strong>是控制并发性的集中式调度器，允许我们在计算发生在<code class="fe oo op oq ny b">setTimeout</code>或<code class="fe oo op oq ny b">requestAnimationFrame</code>或其他上时进行协调。这将使您的web应用程序具有更好的性能。</p><p id="d14b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">更简单地说，<strong class="lk jd">调度器</strong>是一种“安排”一个动作在未来发生的机制。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="8181" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated"><strong class="ak">操作员</strong></h1><p id="c6a3" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated"><em class="ms">运算符提供了一种处理来自源的值的方法，返回转换值的可观察值。</em></p><p id="022d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简单来说，你可以认为运算符是<strong class="lk jd">函数</strong>。</p><p id="f655" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有两种运算符:</p><ul class=""><li id="09e2" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">可管道化操作符<br/> <em class="ms">可管道化操作符是一个函数，它将一个可观察对象作为其输入，并返回另一个可观察对象。这是一个纯粹的操作:之前的可观察值保持不变。<br/> </em>你可以认为这类运算符是我们可以应用函数式编程的地方，就像管道函数或者compose函数一样。</li><li id="d4ee" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">创建操作符<br/> <em class="ms">创建操作符是一种可以作为独立函数调用来创建新的可观察对象的操作符。<br/> </em>你可以认为这种运算符会帮助你创建一个新的可观察对象。</li></ul><pre class="ks kt ku kv gt nx ny nz oa aw ob bi"><span id="d545" class="oc nb it ny b gy od oe l of og">import { of } from 'rxjs';<br/>import { map } from 'rxjs/operators';</span><span id="d1db" class="oc nb it ny b gy oh oe l of og">const dataSource = of(1, 2, 3, 4, 5); // of(...) is creation operators which create new observable</span><span id="6528" class="oc nb it ny b gy oh oe l of og">const subscription = dataSource<br/>.pipe(map(value =&gt; value + 1))<br/>.subscribe(value =&gt; console.log(value)); // map(...) is Pipeable operator</span></pre></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="1be6" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">摘要</h1><p id="015f" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">这个故事帮助你理解反应式编程中的6个流行术语。当你理解了基本原理，RxJS是非常容易实现的。</p><p id="8def" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望这篇文章对你有用！可以跟着我上<a class="ae lh" href="https://medium.com/@transonhoang?source=post_page---------------------------" rel="noopener">媒</a>。我也在推特上。欢迎在下面的评论中留下任何问题。我很乐意帮忙！</p><h1 id="b600" class="na nb it bd nc nd or nf ng nh os nj nk ki ot kj nm kl ou km no ko ov kp nq nr bi translated">资源/参考资料</h1><p id="f1e3" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">[1]:反应文件<a class="ae lh" href="https://rxjs-dev.firebaseapp.com/guide/overview" rel="noopener ugc nofollow" target="_blank">https://rxjs-dev.firebaseapp.com/guide/subject</a></p><p id="b929" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以在这里阅读更多关于rxjs的高级故事:</p><div class="ow ox gp gr oy oz"><a rel="noopener  ugc nofollow" target="_blank" href="/approach-reactive-programming-in-modern-web-application-b20f59b7699d"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd jd gy z fp pe fr fs pf fu fw jc bi translated">现代Web应用程序中的反应式编程</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">了解如何在现代web应用中处理异步代码，以及我们如何管理它——从回调和承诺到RxJS</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pi l"><div class="pj l pk pl pm pi pn lb oz"/></div></div></a></div><div class="ow ox gp gr oy oz"><a rel="noopener  ugc nofollow" target="_blank" href="/angular-and-rxjs-patterns-use-reactive-programming-to-compose-and-manage-data-in-angular-apps-2e0c4ce7a39c"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd jd gy z fp pe fr fs pf fu fw jc bi translated">Angular和RxJS模式—使用反应式编程在Angular应用程序中编写和管理数据</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">通过rxjs创建数据流、创建可组合流、创建动作和进行缓存的指南。</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pi l"><div class="po l pk pl pm pi pn lb oz"/></div></div></a></div><div class="ow ox gp gr oy oz"><a rel="noopener  ugc nofollow" target="_blank" href="/handle-multiple-api-requests-in-angular-using-mergemap-and-forkjoin-to-avoid-nested-subscriptions-a20fb5040d0c"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd jd gy z fp pe fr fs pf fu fw jc bi translated">使用mergeMap和forkJoin在Angular中处理多个API请求，以避免嵌套订阅</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">指导如何在调用多个API时使用mergeMap和forkJoin避免嵌套订阅。</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pi l"><div class="pp l pk pl pm pi pn lb oz"/></div></div></a></div></div></div>    
</body>
</html>