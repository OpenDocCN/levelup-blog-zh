# 各个击破和二分搜索法

> 原文：<https://levelup.gitconnected.com/divide-conquer-and-binary-search-f3645e43f05d>

![](img/4490d347e228399e591d3145962de96d.png)

Aditya Chinchure 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

分而治之是一些常见编程问题中的一种方法。一种这样的情况是寻找最长的公共前缀，这涉及开发一种在字符串数组中寻找最长的公共前缀字符串的解决方案。

```
["international", "interstellar", "interruption"]inter
```

然而，我们不会在本文中深入解决这个问题。我们将探索解决这个问题的方法；分而治之，用算法；二分搜索法来说明它是如何工作的。

**进场**

分而治之是一种将一个问题分解成更简单、更容易解决的问题，然后组合这些解决方案来解决原始问题的技术。

我们来看一个问题，比如安排两副牌。在和一个朋友玩了一场猫捉老鼠的游戏后，是时候把你的两副牌分牌了。为了快速地整理卡片，你和你的朋友把一堆卡片分开，然后你们两个人一起整理。在这种情况下，原始问题是排列一堆卡片，而更简单的问题是在玩家之间排列更小的卡片堆。

分而治之通常被描述为涉及步骤。

分步骤，把一个问题分解成更简单的问题。

征服步骤，解决通常被称为子问题的简单问题。在这一步中，我们重复解决问题的过程，直到满足一个条件，这个条件被称为基本情况。

组合步骤，包括将解决的子问题放在一起。

这种方法的一个变体是*减少和征服。在这个变体中，原始问题被分解成一个更简单的问题。*

假设你在文章的这一点上安排好了你的牌，你想给你的朋友看你最喜欢的牌。拿着这副牌，你可以从最上面的第一张牌开始向任何方向寻找你最喜欢的牌。这是可行的，但是如果你必须检查所有的卡，这将是非常低效的。这是线性搜索。你会怎样做得更好？

如果你最喜欢的牌是七张黑桃。你可以把牌分成两半，看看你现在的位置。如果一面的牌少于 7 张，你可以继续在另一副牌上搜索。重复这个过程最终会让你用更少的步骤找到你的卡片。前提是你的牌没有和之前的牌混在一起或者丢失！这是二分搜索法。

**算法**

> 二分搜索法是一种在有序集合中搜索目标的算法。它的工作原理是将目标与集合中的中间元素进行比较。如果目标大于中间的元素，则左边的元素将被丢弃。如果目标小于中间的元素，则右边的元素将被丢弃。重复该过程，直到中间元素等于目标元素，并且如果不能进行进一步的分割。列表中不存在该目标。

在子问题中重复相同算法的过程通常被称为递归。

假设我们从一个流行的序列中收集了一些元素。目标是 21。我们将按如下所示分割集合。

```
+---------------------------------+--------------+---------+
| Collection                      | Middle Index | Element |
+---------------------------------+--------------+---------+
| 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 | 4            | 3       |
+---------------------------------+--------------+---------+
| 5, 8,13,21,34                   | 2            | 13      |
+---------------------------------+--------------+---------+
| 21,34                           | 1            | 21      |
+---------------------------------+--------------+---------+
```

你会注意到当我们分割一个奇数时，我们把它四舍五入。为了消除边上的元素，我们改变了索引的位置。这样想吧，如果我们的目标在小于部分，结束索引应该在中间位置的前面一个位置。在前面，因为我们想忽略当前位置后面的所有元素，并且我们已经知道中间位置不等于目标位置。当目标在大于分割中时，同样的逻辑适用，我们将开始索引放在中间位置之前的一个位置。

**代码**

二分搜索法可以在迭代方法或递归方法中实现。

迭代二分搜索法

递归二分搜索法

**声望**

分而治之是一种将问题分解成子问题并组合解决方案的方法。在二分搜索法中，在一个排序的数字阵列上，我们划分(减少)数字阵列(搜索空间)，通过递归地寻找目标的中间点来征服子问题，并且分裂直到我们找到我们的目标基本情况条件。

注意二分搜索法处理元素的有序集合。这意味着当丢失的数据被排序时，它的性能是好的，否则它的性能是糟糕的。让我们以一些复杂性分析来结束。

在我们从一副牌中检索我们最喜欢的牌的例子中，我们减少了每次拆分牌时必须搜索的牌的数量。在一副标准的 52 张牌中，在第一次拆分时，我们将这副牌减少到 26 张。在我们的第二次拆分中，我们将卡片减少到 13 张，并继续进行下一次拆分，直到找到我们想要的卡片。最多需要六(6)次分裂才能找到我们的卡。

如果我们使用我们最初的两副牌的情况，我们有 104 张牌，假设这些牌被分类为一副牌。我们还需要一个步骤来让我们的牌变成 52 张并继续下去，最多七(7)张。每次我们加倍我们的卡片(搜索空间),我们增加多一个分裂。很可爱。

**糖衣**

这种模式和情况可以用数学来表示。对于元素的集合 *n* ，我们需要 *m* 次分裂来达到我们的目标。因此，我们的集合 2 *n* 中的 double 导致了 *m+* 1 的分裂。

代表这种变化的数学函数是对数，如果你需要更多的解释，我推荐这个视频。

为了看得更清楚，如果你有一个 2 的幂的元素集合，即 1，2，4，8，16。使用以 2 为底的对数函数的结果等于*m。*因此 *m* +1 是找到目标所需的最大分裂数。准备好吃樱桃了。

```
+----+--------------+
| n  | log base 2 n |
+----+--------------+
| 1  | 0            |
+----+--------------+
| 2  | 1            |
+----+--------------+
| 4  | 2            |
+----+--------------+
| 8  | 3            |
+----+--------------+
| 16 | 4            |
+----+--------------+
```

**樱桃**

为了计算二分搜索法的时间复杂度，我们可以应用我们在这个例子中看到的知识。因此，在最坏的情况下，二分搜索法最坏的时间复杂度是 O(log n)。

尽情享受吧！

# 分级编码

感谢您成为我们社区的一员！ [**订阅我们的 YouTube 频道**](https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1) 或者加入 [**Skilled.dev 编码面试课程**](https://skilled.dev/) 。

[](https://skilled.dev) [## 编写面试问题

### 掌握编码面试的过程

技术开发](https://skilled.dev)