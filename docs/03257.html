<html>
<head>
<title>Orchestrating Web Workers with Apollo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Apollo编排Web工人</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/orchestrating-web-workers-with-apollo-ee206e65d098?source=collection_archive---------4-----------------------#2020-04-28">https://levelup.gitconnected.com/orchestrating-web-workers-with-apollo-ee206e65d098?source=collection_archive---------4-----------------------#2020-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="fc0d" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">介绍</h1><p id="2c2d" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一些人认为我们应该总是使用网络工作者，而另一些人认为T2我们应该只在特定的情况下使用他们。总的来说，人们一致认为网络工作者对于处理大量数据是有价值的。</p><p id="0ec7" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">不久前，我在用Apollo GraphQL后端开发React.js项目，该项目有一个很好的web workers用例，我想出了一个实验来尝试:如果我们用Apollo编排web workers会怎么样？</p><h1 id="347f" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">使用Apollo的本地解析器🚀</h1><p id="3ac9" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">GraphQL使用解析函数来获取客户机请求的数据。这些解析器可以从多个来源提取数据:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/4f793bba7cd3b191a0726bffe07f2cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VEl6VOiu5CL8330M7DqZqA.png"/></div></div></figure><p id="bae3" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">消费者只有一个真实的来源，并不关心原始数据来自哪里。</p><p id="15e2" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">Apollo客户端在本地使用GraphQL来执行查询，也可以使用本地解析器来与数据交互:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi me"><img src="../Images/b6ab0bdfcf9c6a2637363ef13ed0865a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xuiCzXDpxnYH08azMcZBAQ.png"/></div></div></figure><h1 id="7cd6" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">阿波罗的网络工作者</h1><p id="057e" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Web workers使用起来有点棘手，对于习惯了传统单线程思维方式的许多JavaScript开发人员来说并不太直观。<a class="ae lm" href="https://github.com/GoogleChromeLabs/comlink" rel="noopener ugc nofollow" target="_blank"> Comlink </a>是一个库，它包装了一个函数，在一个web worker中运行它，并返回一个带有结果的承诺。这是我安排网络工作者最简单的方法。</p><p id="167f" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">因为Apollo解析器可以返回承诺，所以我们可以使用comlink包装的函数来解析数据，并使用GraphQL查询获得结果:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">演示如何使用Apollo客户端和comlink编排web工作人员</figcaption></figure><p id="b1d1" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">虽然上面的例子非常简单地展示了这个概念，但它也可以应用于需要很长时间来处理和返回数据列表供用户查看的计算。</p><p id="de5b" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">comlink相对于普通web workers的一个缺点是不再能够用进度条向用户显示一段时间内的进度，也不能在计算时显示数据。使用Apollo编排web workers允许我们构建一种方法来计算数据块，类似于应用程序可能使用分页来获取数据块。</p><h1 id="a13f" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Apollo编排的web工人的好处</h1><p id="e8b8" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用Apollo来编排web workers将提供一种与所有数据交互的一致方式。不需要组件使用任何额外的钩子或代码来使用web workers。从web worker获取结果与从远程API获取结果是一样的。</p><p id="fd64" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">来自web workers的任何结果都将利用Apollo的缓存，无需任何额外的设置。如果将来需要运行相同的计算，缓存的结果将立即返回。</p><p id="53a1" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">这种一致的数据交互方式有助于维护。React.js现在的趋势很高和<a class="ae lm" href="https://2019.stateofjs.com/data-layer/" rel="noopener ugc nofollow" target="_blank">阿波罗</a>也是如此；许多开发人员一起使用这一对。通过使用这些工具与web工作者进行交互，随着时间的推移，许多开发人员会发现很容易掌握和构建，甚至初级开发人员也是如此。</p><h1 id="010e" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">最终结果</h1><p id="e0e1" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我最初的目标是尝试使用Apollo来编排web workers，我发现设置的简单性和小巧性带来了很大的好处。</p><p id="8cd9" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">感谢您的阅读！希望这能启发你寻找与网络工作者<a class="ae lm" href="https://blog.axlight.com/posts/how-i-developed-react-hooks-for-web-workers/" rel="noopener ugc nofollow" target="_blank">互动的其他方式，比如Daishi Kato的hook</a>，并找到Apollo本地解析器的其他用途。</p></div></div>    
</body>
</html>