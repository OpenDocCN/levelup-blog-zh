<html>
<head>
<title>useTypescript — A Complete Guide to React Hooks and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用类型脚本——反应钩子和类型脚本的完整指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/usetypescript-a-complete-guide-to-react-hooks-and-typescript-db1858d1fb9c?source=collection_archive---------0-----------------------#2019-03-05">https://levelup.gitconnected.com/usetypescript-a-complete-guide-to-react-hooks-and-typescript-db1858d1fb9c?source=collection_archive---------0-----------------------#2019-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e60eb3c8f38113b371e21f1866677064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f-AYKcm1pM7kQe7vwoZNLw.jpeg"/></div></div></figure><p id="bbbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React v16.8引入了钩子，它提供了将状态和React生命周期提取到函数中的能力，这些函数可以在应用程序中的组件之间使用，这使得共享逻辑变得很容易。钩子令人兴奋并被迅速采用，React团队甚至想象它们最终会取代类组件。</p><p id="251b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之前在React中，共享逻辑的方式是通过<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/understanding-react-higher-order-components-by-example-95e8c47c8006">高阶组件</a>和<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/understanding-react-render-props-by-example-71f2162fd0f2">渲染道具</a>。钩子提供了一种更简单的方法来重用代码，并使我们的组件变得干燥。</p><p id="a403" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">本文将展示TypeScript与React集成的变化，以及如何将类型添加到钩子和您自己的定制钩子中。</strong></p><blockquote class="kx ky kz"><p id="c98d" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">类型定义来自于<a class="ae kw" href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react" rel="noopener ugc nofollow" target="_blank"> @types/react </a>。有些例子是从<a class="ae kw" href="https://github.com/sw-yx/react-typescript-cheatsheet" rel="noopener ugc nofollow" target="_blank">react-typescript-cheat sheet</a>中派生出来的，所以请参考它以获得React和TypeScript的全面概述。其他示例和挂钩的定义摘自<a class="ae kw" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p></blockquote><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi le"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure><p id="c0da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我建了一个课程帮你<a class="ae kw" href="https://skilled.dev" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">掌握编码面试&gt; </strong> </a></p><div class="lj lk gp gr ll lm"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="ln ab fo"><div class="lo ab lp cl cj lq"><h2 class="bd ir gy z fp lr fr fs ls fu fw ip bi translated">编写面试问题</h2><div class="lt l"><h3 class="bd b gy z fp lr fr fs ls fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="lu l"><p class="bd b dl z fp lr fr fs ls fu fw dk translated">技术开发</p></div></div><div class="lv l"><div class="lw l lx ly lz lv ma jw lm"/></div></div></a></div><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi le"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure><h1 id="ce13" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">使用TypeScript更改功能组件</h1><p id="a9f5" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">以前React中的函数组件被称为“无状态函数组件”，这意味着它们是纯函数。随着钩子的引入，功能组件现在可以包含状态并访问React生命周期。为了适应这一变化，我们现在将组件输入为<code class="fe ne nf ng nh b">React.FC</code>或<code class="fe ne nf ng nh b">React.FunctionComponent</code>，而不是<code class="fe ne nf ng nh b">React.SFC</code>。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="49a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过将组件类型化为<code class="fe ne nf ng nh b">FC</code>，React类型脚本类型允许我们正确处理<code class="fe ne nf ng nh b">children</code>和<code class="fe ne nf ng nh b">defaultProps</code>。此外，还提供了<code class="fe ne nf ng nh b">context</code>、<code class="fe ne nf ng nh b">propTypes</code>、<code class="fe ne nf ng nh b">contextTypes</code>、<code class="fe ne nf ng nh b">defaultProps</code>、<code class="fe ne nf ng nh b">displayName</code>的类型。</p><p id="c352" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对应<code class="fe ne nf ng nh b">FC</code> / <code class="fe ne nf ng nh b">FunctionComponent</code>的这些道具:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="kx ky kz"><p id="428a" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><strong class="ka ir">注:</strong>React团队正在讨论<a class="ae kw" href="https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md#deprecate-defaultprops-on-function-components" rel="noopener ugc nofollow" target="_blank">从功能组件</a>中移除 <code class="fe ne nf ng nh b"><a class="ae kw" href="https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md#deprecate-defaultprops-on-function-components" rel="noopener ugc nofollow" target="_blank">defaultProps</a></code> <a class="ae kw" href="https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md#deprecate-defaultprops-on-function-components" rel="noopener ugc nofollow" target="_blank">。这增加了不必要的复杂性，因为默认函数参数也同样有效，不需要引入标准JavaScript之外的新概念。</a></p></blockquote><h1 id="8c82" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">钩子快速入门</h1><p id="4d9b" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">钩子只是允许我们管理状态、利用React生命周期和连接到React内部(如上下文)的函数。钩子是从<code class="fe ne nf ng nh b">react</code>库中导入的，只能在函数组件中使用:</p><pre class="lf lg lh li gt nk nh nl nm aw nn bi"><span id="f928" class="no mc iq nh b gy np nq l nr ns">import * as React from 'react'</span><span id="4191" class="no mc iq nh b gy nt nq l nr ns">const FunctionComponent: React.FC = () =&gt; {<br/>  const [count, setCount] = React.useState(0) // The useState hook<br/>}</span></pre><p id="2254" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认情况下，React包含10个钩子。其中3个钩子被认为是你最常用的“基本”或核心钩子。还有7个额外的“高级”挂钩，最常用于边缘情况。根据React官方文件，钩子:</p><p id="0029" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">基本挂钩</strong></p><ul class=""><li id="6117" class="nu nv iq ka b kb kc kf kg kj nw kn nx kr ny kv nz oa ob oc bi translated"><code class="fe ne nf ng nh b"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank">useState</a></code></li><li id="650c" class="nu nv iq ka b kb od kf oe kj of kn og kr oh kv nz oa ob oc bi translated"><code class="fe ne nf ng nh b"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#useeffect" rel="noopener ugc nofollow" target="_blank">useEffect</a></code></li><li id="cd8c" class="nu nv iq ka b kb od kf oe kj of kn og kr oh kv nz oa ob oc bi translated"><code class="fe ne nf ng nh b"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">useContext</a></code></li></ul><p id="46f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">高级挂钩</strong></p><ul class=""><li id="dee6" class="nu nv iq ka b kb kc kf kg kj nw kn nx kr ny kv nz oa ob oc bi translated"><code class="fe ne nf ng nh b"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank">useReducer</a></code></li><li id="c97b" class="nu nv iq ka b kb od kf oe kj of kn og kr oh kv nz oa ob oc bi translated"><code class="fe ne nf ng nh b"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank">useCallback</a></code></li><li id="4215" class="nu nv iq ka b kb od kf oe kj of kn og kr oh kv nz oa ob oc bi translated"><code class="fe ne nf ng nh b"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">useMemo</a></code></li><li id="e24c" class="nu nv iq ka b kb od kf oe kj of kn og kr oh kv nz oa ob oc bi translated"><code class="fe ne nf ng nh b"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank">useRef</a></code></li><li id="ba93" class="nu nv iq ka b kb od kf oe kj of kn og kr oh kv nz oa ob oc bi translated"><code class="fe ne nf ng nh b"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#useimperativehandle" rel="noopener ugc nofollow" target="_blank">useImperativeHandle</a></code></li><li id="970f" class="nu nv iq ka b kb od kf oe kj of kn og kr oh kv nz oa ob oc bi translated"><code class="fe ne nf ng nh b"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#uselayouteffect" rel="noopener ugc nofollow" target="_blank">useLayoutEffect</a></code></li><li id="77c7" class="nu nv iq ka b kb od kf oe kj of kn og kr oh kv nz oa ob oc bi translated"><code class="fe ne nf ng nh b"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#usedebugvalue" rel="noopener ugc nofollow" target="_blank">useDebugValue</a></code></li></ul><p id="c0a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然钩子本身是有用的，但是如果将它们组合成<a class="ae kw" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank">自定义钩子函数</a>，它们会变得更加强大。通过构建自己的钩子，您能够将React逻辑提取到可重用的函数中，这些函数可以简单地导入到我们的组件中。对钩子的唯一警告是你必须遵循一些基本规则。</p><h1 id="30b4" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">将State与TypeScript一起使用</h1><p id="44f4" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated"><code class="fe ne nf ng nh b">useState</code>是一个钩子，允许我们从类组件中替换<code class="fe ne nf ng nh b">this.state</code>。我们执行钩子返回一个包含当前状态值的数组和一个更新状态的函数。当状态被更新时，它导致组件的重新呈现。下面的代码显示了一个简单的<code class="fe ne nf ng nh b">useState</code>钩子:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="be9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">状态可以是任何JavaScript类型，上面我们把它变成了一个<code class="fe ne nf ng nh b">number</code>。set state函数是一个纯函数，它将指定如何更新状态，并且将始终返回相同类型的值。</p><p id="c25d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于简单的函数，<code class="fe ne nf ng nh b">useState</code>可以从初始值和基于提供给函数的值的返回值中推断出类型。对于更复杂的状态，<code class="fe ne nf ng nh b">useState&lt;T&gt;</code>是一个泛型，我们可以在其中指定类型。下面的例子显示了一个可以是<code class="fe ne nf ng nh b">null</code>的<code class="fe ne nf ng nh b">user</code>对象。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="6654" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">官方打字如下:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="3d8a" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">对TypeScript使用效果</h1><p id="e361" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated"><code class="fe ne nf ng nh b">useEffect</code>是我们如何管理API调用等副作用，以及如何在功能组件中利用React生命周期。<code class="fe ne nf ng nh b">useEffect</code>以一个回调函数为参数，回调可以返回一个清理函数。回调将在<code class="fe ne nf ng nh b">componentDidMount</code>和<code class="fe ne nf ng nh b">componentDidUpdate</code>执行，清理功能将在<code class="fe ne nf ng nh b">componentWillUnmount</code>执行。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="a970" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认情况下，<code class="fe ne nf ng nh b">useEffect</code>将在每次渲染时被调用，但是你也可以传递一个可选的第二个参数，该参数允许你仅在值改变时或者仅在初始渲染时执行<code class="fe ne nf ng nh b">useEffect</code>函数。第二个可选参数是一个值数组，只有其中一个值发生变化时，它才会重新执行效果。如果数组为空，它将只在初始渲染时调用<code class="fe ne nf ng nh b">useEffect</code>。要更全面地了解它是如何工作的，请参考官方<a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#useeffect" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="dac2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用钩子时，应该只返回<code class="fe ne nf ng nh b">undefined</code>或者一个<code class="fe ne nf ng nh b">function</code>。如果返回任何其他值，React和TypeScript都会给你一个错误。如果使用箭头函数作为回调函数，必须小心确保没有隐式返回值。例如，<code class="fe ne nf ng nh b">setTimeout</code>在浏览器中返回一个整数:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="a014" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ne nf ng nh b">useEffect</code>的第二个参数是一个只读数组，可以包含<code class="fe ne nf ng nh b">any</code>值— <code class="fe ne nf ng nh b"> any[]</code>。</p><p id="f081" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于<code class="fe ne nf ng nh b">useEffect</code>将一个<code class="fe ne nf ng nh b">function</code>作为参数，并且只返回一个<code class="fe ne nf ng nh b">function</code>或<code class="fe ne nf ng nh b">undefined</code>，这些类型已经被React类型系统声明了:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="950c" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">将上下文与TypeScript一起使用</h1><p id="288d" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated"><code class="fe ne nf ng nh b">useContext</code>允许您使用React <code class="fe ne nf ng nh b">context</code>，这是管理应用程序状态的全局方法，可以在任何组件内部访问，而无需将值作为<code class="fe ne nf ng nh b">props</code>传递。</p><p id="e9cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ne nf ng nh b">useContext</code>函数接受一个<code class="fe ne nf ng nh b">Context</code>对象并返回当前的上下文值。当提供者更新时，这个钩子将触发用最新的上下文值重新呈现。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="18ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用构建上下文对象的<code class="fe ne nf ng nh b">createContext</code>函数初始化一个上下文。<code class="fe ne nf ng nh b">Context</code>对象包含一个<code class="fe ne nf ng nh b">Provider</code>组件，所有想要访问其上下文的组件都必须在<code class="fe ne nf ng nh b">Provider</code>的子树中。如果您使用过Redux，这相当于通过上下文访问全局存储的<code class="fe ne nf ng nh b">&lt;Provider store={store} /&gt;</code>组件。关于上下文的进一步解释，请参考<a class="ae kw" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">正式文件</a>。</p><p id="6c59" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ne nf ng nh b">useContext</code>的类型如下:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="20a4" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">使用TypeScript的useReducer</h1><p id="679f" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">对于更复杂的状态，您可以选择使用<code class="fe ne nf ng nh b">useReducer</code>功能作为<code class="fe ne nf ng nh b">useState</code>的替代。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="00ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你之前用过Redux，这个应该很熟悉。<code class="fe ne nf ng nh b">useReducer</code>接受3个参数并返回一个<code class="fe ne nf ng nh b">state</code>和<code class="fe ne nf ng nh b">dispatch</code>函数。<code class="fe ne nf ng nh b">reducer</code>是表单<code class="fe ne nf ng nh b">(state, action) =&gt; newState</code>的一个函数。<code class="fe ne nf ng nh b">initialState</code>很可能是一个JavaScript对象，而<code class="fe ne nf ng nh b">init</code>参数是一个函数，它允许你延迟加载初始状态并将执行<code class="fe ne nf ng nh b">init(initialState)</code>。</p><p id="8a21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个有点密集，让我们看一个实际的例子。我们将重做来自<code class="fe ne nf ng nh b">useState</code>部分的反例，但是用一个<code class="fe ne nf ng nh b">useReducer</code>替换它，然后我们将在它后面加上一个包含类型定义的要点。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="87e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ne nf ng nh b">useReducer</code>功能可以利用以下类型:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="92cc" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">将回调与TypeScript一起使用</h1><p id="6296" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated"><code class="fe ne nf ng nh b">useCallback</code>钩子返回一个内存化的回调。这个钩子函数有两个参数:第一个参数是一个内联回调函数，第二个参数是一个值数组。值的数组将在回调函数中被引用，并按照它们在数组中的顺序被访问。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7334" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ne nf ng nh b">useCallback</code>将返回回调的记忆化版本，只有当输入数组中的一个输入发生变化时，该版本才会发生变化。当您将回调函数传递给子组件时，会用到这个钩子。它将防止不必要的渲染，因为回调将只在值改变时执行，允许您优化您的组件。这个挂钩可以被视为与<code class="fe ne nf ng nh b">shouldComponentUpdate</code>生命周期方法类似的概念。</p><p id="34c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ne nf ng nh b">useCallback</code>的类型脚本定义如下:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="d94b" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">将备忘录与类型脚本一起使用</h1><p id="8de4" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated"><code class="fe ne nf ng nh b">useMemo</code>钩子将一个“create”函数作为它的第一个参数，将一个值数组作为第二个参数。它返回一个记忆值，只有当输入值改变时才会重新计算。这使您可以避免为计算值进行渲染时的昂贵计算。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="4fc9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ne nf ng nh b">useMemo</code>允许你计算任何类型的值。下面的例子显示了如何创建一个输入的记忆数字。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="8b02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ne nf ng nh b">useMemo</code>的打字稿定义如下:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="94fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ne nf ng nh b">DependencyList</code>允许包含<code class="fe ne nf ng nh b">any</code>类型的值，对内置类型或与<code class="fe ne nf ng nh b">T</code>的关系没有严格要求。</p><h1 id="490e" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">带有TypeScript的useRef</h1><p id="0894" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated"><code class="fe ne nf ng nh b">useRef</code>钩子允许你创建一个<code class="fe ne nf ng nh b">ref</code>，它可以让你访问一个<a class="ae kw" href="https://reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank">底层DOM节点</a>的属性。当您需要从元素中提取值或获取与DOM相关的信息(如滚动位置)时，可以使用这种方法。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="kx ky kz"><p id="8fd2" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">以前我们用<code class="fe ne nf ng nh b">createRef()</code>。这个函数总是在函数组件中的每一次渲染返回一个新的<code class="fe ne nf ng nh b">ref</code>。现在，<code class="fe ne nf ng nh b">useRef</code>在被创建后将总是返回相同的ref，这将导致性能的提高。</p></blockquote><p id="d3f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">钩子返回一个<code class="fe ne nf ng nh b">ref</code>对象(类型为<code class="fe ne nf ng nh b">MutableRefObject</code>)，其<code class="fe ne nf ng nh b">.current</code>属性被初始化为<code class="fe ne nf ng nh b">initialValue</code>的传递参数。返回的对象将在组件的整个生存期内保持不变。可以通过使用React元素上的<code class="fe ne nf ng nh b">ref</code>属性设置来更新<code class="fe ne nf ng nh b">ref</code>的值。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="8025" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ne nf ng nh b">useRef</code>的类型脚本定义如下:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="4771" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您作为泛型<code class="fe ne nf ng nh b">T</code>传递的泛型类型将对应于您将在<code class="fe ne nf ng nh b">current</code>中访问的HTML元素的类型。</p><h1 id="d6bd" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">将ImperativeHandle与TypeScript一起使用</h1><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="6ff4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ne nf ng nh b">useImperativeHandle</code>钩子函数有3个参数——1。一反应过来<code class="fe ne nf ng nh b">ref</code>，2。一个<code class="fe ne nf ng nh b">createHandle</code>功能，和3。一个可选的<code class="fe ne nf ng nh b">deps</code>数组，用于显示给<code class="fe ne nf ng nh b">createHandle</code>的参数。</p><p id="a094" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ne nf ng nh b">useImperativeHandle</code>是一个<strong class="ka ir">很少使用的函数</strong>，在大多数情况下应避免使用参考。这个钩子用于定制一个可变的<code class="fe ne nf ng nh b">ref</code>对象，该对象暴露给父组件。<code class="fe ne nf ng nh b">useImperativeHandle</code>应与<code class="fe ne nf ng nh b">forwardRef</code>配合使用:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="kx ky kz"><p id="d751" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">组件的第二个<code class="fe ne nf ng nh b">ref</code>argument(<code class="fe ne nf ng nh b">FancyInput(props, <strong class="ka ir">ref</strong>)</code>)只在使用<code class="fe ne nf ng nh b"><a class="ae kw" href="https://reactjs.org/docs/forwarding-refs.html" rel="noopener ugc nofollow" target="_blank">forwardRef</a></code> <a class="ae kw" href="https://reactjs.org/docs/forwarding-refs.html" rel="noopener ugc nofollow" target="_blank">函数</a>时存在，它允许您更容易地将引用传递给子组件。</p></blockquote><p id="ba21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，呈现<code class="fe ne nf ng nh b">&lt;FancyInput ref={fancyInputRef} /&gt;</code>的父组件将能够调用<code class="fe ne nf ng nh b">fancyInputRef.current.focus()</code>。</p><p id="d844" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ne nf ng nh b">useImperativeHandle</code>的类型脚本定义如下:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="4b0e" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">使用TypeScript的useLayoutEffect</h1><p id="a88f" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated"><code class="fe ne nf ng nh b">useLayoutEffect</code>与<code class="fe ne nf ng nh b">useEffect</code>相似，不同之处在于它仅用于与DOM相关的副作用。这个钩子允许你从DOM中读取值，并在浏览器有机会重画之前同步重画。</p><p id="e952" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">尽可能使用</strong> <code class="fe ne nf ng nh b"><strong class="ka ir">useEffect</strong></code> <strong class="ka ir">钩子，只有在绝对必要时才避免</strong> <code class="fe ne nf ng nh b"><strong class="ka ir">useLayoutEffect</strong></code> <strong class="ka ir">钩子，以避免阻塞可视化更新。</strong></p><p id="8dc3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ne nf ng nh b">useLayoutEffect</code>的打字稿定义与<code class="fe ne nf ng nh b">useEffect</code>几乎相同:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="b30a" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">将DebugValue与TypeScript一起使用</h1><p id="1b76" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated"><code class="fe ne nf ng nh b">useDebugValue</code>是一个用来调试你自定义钩子的工具。它允许你在React Dev工具中为你的定制钩子函数显示一个标签。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="1381" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在下面构建一个自定义钩子，但是这个例子向我们展示了如何使用<code class="fe ne nf ng nh b">useDebugValue</code>钩子在它们内部进行调试。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="acc3" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">定制挂钩</h1><p id="3e2c" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">建立你自己的钩子的能力是这次更新如此有影响力的真正原因。之前我们在React应用中使用<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/understanding-react-higher-order-components-by-example-95e8c47c8006">高阶组件</a>和<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/understanding-react-render-props-by-example-71f2162fd0f2">渲染道具</a>共享组件。这导致我们的组件树变得笨拙，并产生难以阅读和推理的代码。此外，这些通常是使用类组件实现的，这可能<a class="ae kw" href="https://reactjs.org/docs/hooks-intro.html#complex-components-become-hard-to-understand" rel="noopener ugc nofollow" target="_blank">导致许多问题并阻止优化</a>。</p><p id="60d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">自定义挂钩允许您将核心React挂钩结合到自己的函数中，并提取组件逻辑。这个定制钩子函数可以像任何其他JavaScript函数一样容易地共享和导入，它的行为与核心React钩子相同，并且必须遵循相同的规则。</p><p id="4313" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了构建我们的定制钩子，我们将使用来自<a class="ae kw" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank"> React文档</a>的例子并添加我们的TypeScript类型。这个定制钩子将利用<code class="fe ne nf ng nh b">useState</code>和<code class="fe ne nf ng nh b">useEffect</code>，并管理用户的在线状态。我们将假设我们可以访问一个<code class="fe ne nf ng nh b">ChatAPI</code>，我们可以订阅它并接收我们朋友的在线状态。</p><p id="cdff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于自定义钩子，我们应该遵循React钩子的模式，在我们的函数前面加上单词<code class="fe ne nf ng nh b">use</code>，表示该函数是一个钩子。我们将把我们的钩子命名为<code class="fe ne nf ng nh b">useFriendStatus</code>。代码如下，后面是解释。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="d40c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ne nf ng nh b">useFriendStatus</code>挂钩带有一个<code class="fe ne nf ng nh b">friendID</code>，它允许我们订阅这个用户的在线状态。我们利用<code class="fe ne nf ng nh b">useState</code>函数并将其初始化为<code class="fe ne nf ng nh b">null</code>。我们将状态值命名为<code class="fe ne nf ng nh b">isOnline</code>，并有一个函数<code class="fe ne nf ng nh b">setIsOnline</code>来切换这个布尔值。由于我们有一个简单的状态，TypeScript可以推断出我们的状态值和updater函数的类型。</p><p id="3b23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来我们有一个<code class="fe ne nf ng nh b">handleStatusChange</code>函数。这个函数接受一个包含一个<code class="fe ne nf ng nh b">isOnline</code>值的<code class="fe ne nf ng nh b">status</code>参数。我们调用<code class="fe ne nf ng nh b">setIsOnline</code>函数来更新状态值。<code class="fe ne nf ng nh b">status</code>无法推断，所以我们为它创建一个TypeScript接口(我们还将任意假设它包含用户ID)。</p><p id="1c85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ne nf ng nh b">useEffect</code>钩子的回调订阅API来检查一个朋友的状态，并在组件卸载时返回一个清理函数来取消订阅API。当在线状态改变时，我们的订阅执行<code class="fe ne nf ng nh b">handleStatusChange</code>功能。因为这更新了我们的状态，所以它会将结果传播给使用钩子的组件，并强制重新呈现。</p><p id="ae16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">钩子可以导入到任何功能组件中。由于我们向自定义挂钩添加了类型，默认情况下，使用的组件将获得类型定义。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="50be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个逻辑现在可以扩展到任何需要知道用户在线状态的组件</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><div class="lf lg lh li gt lm"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="ln ab fo"><div class="lo ab lp cl cj lq"><h2 class="bd ir gy z fp lr fr fs ls fu fw ip bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="lt l"><h3 class="bd b gy z fp lr fr fs ls fu fw dk translated">排名前49的React教程-免费学习React。课程由开发人员提交并投票，使您能够…</h3></div><div class="lu l"><p class="bd b dl z fp lr fr fs ls fu fw dk translated">gitconnected.com</p></div></div><div class="lv l"><div class="op l lx ly lz lv ma jw lm"/></div></div></a></div></div></div>    
</body>
</html>