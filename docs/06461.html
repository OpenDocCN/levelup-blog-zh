<html>
<head>
<title>5 Tips for Better TypeScript Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更好的类型脚本代码的5个技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-tips-for-better-typescript-code-5603c26206ef?source=collection_archive---------2-----------------------#2020-11-27">https://levelup.gitconnected.com/5-tips-for-better-typescript-code-5603c26206ef?source=collection_archive---------2-----------------------#2020-11-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5e94353808293377d2607d91e3fb2512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VGWjFbzekvE7WD3e5fGQHQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">提高打字质量的5个技巧</figcaption></figure><p id="b88f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">JavaScript有很多问题。TypeScript有很多解决方案——但是其中一些需要稍微挖掘一下才能找到。</p><p id="a803" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在我前端旅程的早期，我发现TypeScript是JavaScript的许多问题的解决方案。在我的开发过程中，传递不正确的参数、无组织的开关或空访问每天都会出现。</p><p id="5201" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在我的JavaScript上添加一个TypeScript层，使我的生产率飞速提高。我一直在学习TypeScript的来龙去脉，在这里和大家分享一下我学到的东西。</p><p id="6d4d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果这些技巧对你来说还不够高级，我推荐你去看看这篇文章，在这里我写了5个高级打字技巧！</p><h1 id="9e2f" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">1.零聚结</h1><p id="3e90" class="pw-post-body-paragraph kf kg it kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated">有时，TypeScript会自动在属性访问字段中插入一个问号。类似于<code class="fe mi mj mk ml b">let t = myObj?.property </code>然后<code class="fe mi mj mk ml b">t</code>以值:<code class="fe mi mj mk ml b">property | undefined</code>结束。这很好，但是确切地知道这里发生了什么是很重要的，这样您就可以将它作为一种工具来使用，而不是作为TypeScript自动完成的副产品。</p><p id="3495" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果我们使用一个常规的属性访问，<code class="fe mi mj mk ml b">myObj.property</code>，并且myObj未定义，我们会得到一个错误:<code class="fe mi mj mk ml b">Cannot access property 'property' of undefined.</code>这显然不是我们想要的，所以使用<code class="fe mi mj mk ml b">.?</code>意味着如果<code class="fe mi mj mk ml b">myObj</code>未定义，我们就“停止查找”那里，只将<code class="fe mi mj mk ml b">t</code>赋值为未定义。</p><p id="8b45" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这对于避免错误非常有用，但有时我们需要默认情况。例如，如果我们有一个用户从未激活的文本字段，因此内部文本是未定义的，该怎么办？我们不想把<code class="fe mi mj mk ml b">undefined</code>送到后端。我们可以将<strong class="kh iu">可选访问操作符</strong>(我们刚刚学过的，<code class="fe mi mj mk ml b">.?</code>)与<strong class="kh iu">空合并操作符链接起来。大概是这样的:</strong></p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="a25c" class="mu lg it ml b gy mv mw l mx my">sendFieldToServer(textField?.text ?? '')</span></pre><p id="ecff" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是非常有弹性的代码，可以非常安全地处理很多情况。事实上，<strong class="kh iu">不可能将未定义的传递给函数。TypeScript知道这一点，所以如果<code class="fe mi mj mk ml b">sendFieldToServer</code>接受<code class="fe mi mj mk ml b">string</code>的属性，它就能工作！</strong></p><p id="914a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是因为null合并操作符使得如果左边的是<code class="fe mi mj mk ml b">undefined</code>，我们转而传入右边的，一个空字符串。</p><p id="3e50" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在JavaScript中，很容易忘记代码中所有可能未定义的地方。谢天谢地，TS处理了这个问题，并在这里警告你<code class="fe mi mj mk ml b">sendFieldToServer</code>不能接受未定义的。通过使用问号运算符，您现在拥有了100%安全的代码。</p><h1 id="0215" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">2.不要使用默认导入</h1><p id="d064" class="pw-post-body-paragraph kf kg it kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated">TypeScript优于JavaScript的一个原因是代码自动完成。因为在TypeScript中，编译器确切地知道你当时正在处理什么对象，它确切地知道什么属性对你可用。如果你有一个<code class="fe mi mj mk ml b">dog</code>对象，我们知道我们可以访问<code class="fe mi mj mk ml b">bark()</code>方法。</p><p id="c256" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">也就是说，如果<code class="fe mi mj mk ml b">dog</code>在范围内。</p><p id="6497" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果我们用默认导出在<code class="fe mi mj mk ml b">dog.ts</code>中导出<code class="fe mi mj mk ml b">dog</code>，就像这样:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="7879" class="mu lg it ml b gy mv mw l mx my">default export interface Dog {<br/>     bark: () =&gt; void,<br/>}</span></pre><p id="1b28" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">那么进口可以是任何东西。如果我愿意，我可以将<code class="fe mi mj mk ml b">dog</code>作为<code class="fe mi mj mk ml b">cat</code>从另一个文件导入:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="743d" class="mu lg it ml b gy mv mw l mx my">import cat from 'dog.ts'</span><span id="75b9" class="mu lg it ml b gy mz mw l mx my">cat.bark()</span></pre><p id="b8fe" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是有效的类型脚本代码。这意味着如果我们这样做:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="74f6" class="mu lg it ml b gy mv mw l mx my">let t: dog = {<br/>   bark: () =&gt; console.log('woof!')<br/>}</span></pre><p id="2170" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">TypeScript不知道<code class="fe mi mj mk ml b">dog</code>是什么。在<code class="fe mi mj mk ml b">dog</code>下面会有一条小红线，表示<code class="fe mi mj mk ml b">dog</code>未定义。您需要找到dog的定义位置，并手动导入它——然后确保将其命名为dog。</p><p id="54b3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这就是常规出口的切入点。像这样导出<code class="fe mi mj mk ml b">dog</code>:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="110a" class="mu lg it ml b gy mv mw l mx my">export interface dog {..} //export without 'default'</span></pre><p id="2b5f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">意味着现在，在我们的另一个文件中，当我们键入<code class="fe mi mj mk ml b">let t: dog</code>时，typescript知道寻找一个名为<code class="fe mi mj mk ml b">dog</code>的接口！这意味着您将自动将导入放入文件中，并且TypeScript知道您可以吠叫。</p><p id="23f8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">代码自动完成是一个很棒的特性。我发现没有理由更喜欢默认导出，因为常规导出系统实际上更有用。即使你只出口一件东西，常规出口仍然可以轻而易举地处理。</p><p id="e16e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">eslint有一个<code class="fe mi mj mk ml b">no default export</code>规则，可以让任何默认的导出都被标记出来。</p><h1 id="a055" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">3.使用受约束的字符串字段</h1><p id="370e" class="pw-post-body-paragraph kf kg it kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated">枚举是这个星球给程序员的礼物，所以当JavaScript决定不使用枚举时，它充其量从S层语言变成了B层语言。</p><p id="ecb8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">虽然TypeScript有自己的枚举，但说…你并不100%需要它们可能会令人惊讶。枚举由于必须定义它而增加了一点开销。TypeScript有更好的东西。</p><p id="f492" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe mi mj mk ml b">t: "left" | "right" | "middle" = "middle"</code></p><p id="51da" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这在功能上作为枚举操作。你可以打开它，除了这三个值，你不能给t赋值。但是我们在一行中定义了它，并且TypeScript知道不允许在其中包含任何其他内容。如果我尝试做<code class="fe mi mj mk ml b">t="center"</code>，TypeScript会出错。我可以100%确定<code class="fe mi mj mk ml b">t</code>的值是这3个值中的一个，所以我可以做像打开这3个字符串这样的事情，而不必担心缺省值。</p><p id="ece8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">另外，t仍然是一个字符串。因此，如果我们想向用户显示值，我们可以将它传递到字符串字段中，这样就可以很好地工作了。</p><h1 id="7920" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">4.使用地图<t/></h1><p id="7542" class="pw-post-body-paragraph kf kg it kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated">JavaScript确实有一个优势，那就是灵活的原型系统。你可以毫不费力地在任何物体上添加任何键。<code class="fe mi mj mk ml b">myObj.nonExistantField = "Is This" + 12312 + "A string or a number? Who Cares!" * 4</code>有效。但是，让我在一个一些秘密…</p><ol class=""><li id="661a" class="na nb it kh b ki kj km kn kq nc ku nd ky ne lc nf ng nh ni bi translated">并不快。</li><li id="e334" class="na nb it kh b ki nj km nk kq nl ku nm ky nn lc nf ng nh ni bi translated">迭代不容易(需要<code class="fe mi mj mk ml b">Object.keys(myObj)</code>或者类似的)</li><li id="90e3" class="na nb it kh b ki nj km nk kq nl ku nm ky nn lc nf ng nh ni bi translated">如果每个程序员都只是将字段附加到对象上，那就很难共事了</li><li id="eede" class="na nb it kh b ki nj km nk kq nl ku nm ky nn lc nf ng nh ni bi translated">一个字段的存在并不意味着它的值被定义</li></ol><p id="992e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你也可以在TypeScript中做同样的事情，允许值是任意的，但是我甚至不打算告诉你怎么做，因为我不希望你这样做。</p><p id="f8b5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">相反，存在着<code class="fe mi mj mk ml b">Map</code>。它也存在于JS中，但是在JS中它没有类型限制，所以它不是很有用。它是这样工作的:</p><p id="4920" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe mi mj mk ml b">let myMap: Map&lt;string, string&gt; = new Map()</code></p><p id="34b2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这创建了一个地图，它解决了我提到的基于原型的地图的所有问题。</p><ol class=""><li id="23df" class="na nb it kh b ki kj km kn kq nc ku nd ky ne lc nf ng nh ni bi translated">它很快:HashMaps的检查速度是O(1 ),添加速度也很快。</li><li id="9759" class="na nb it kh b ki nj km nk kq nl ku nm ky nn lc nf ng nh ni bi translated">很容易迭代，用<code class="fe mi mj mk ml b">map.forEach()</code></li><li id="6155" class="na nb it kh b ki nj km nk kq nl ku nm ky nn lc nf ng nh ni bi translated">只要键和值的类型正确，您仍然可以将任何内容放入其中</li><li id="7372" class="na nb it kh b ki nj km nk kq nl ku nm ky nn lc nf ng nh ni bi translated">undefined不能在其中(只要你没有将类型定义为undefined)</li></ol><p id="8520" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">地图很棒，这也是为什么它们是面试中最常被问到的数据结构问题。在我看来，它们比基于原型的映射要好。如果您曾经试图允许用户定义一个对象的键，也许您正在使用错误的数据结构。</p><h1 id="0c31" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">5.算出你的eslint配置/ tsconfig</h1><p id="f8b2" class="pw-post-body-paragraph kf kg it kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated">一般来说，TS和JS最大的优点是可以在代码中进行大量的定制。例如，我来自python，我偏爱无分号风格。所以我说“不要分号！”在我的eslint配置中，现在当我不小心放入分号时，我的编译器对我大喊大叫。</p><p id="fd60" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在我看来，保持双引号一致会使代码看起来更漂亮，因为你经常使用“in strings but not”。所以我在我的eslint配置中，必须使用双引号。</p><p id="5bda" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我非常喜欢在模式匹配中强制耗尽，所以我在我的tsconfig中强制这样做。</p><p id="0f3a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我更喜欢无默认导出，所以我强制这样做。</p><p id="5ee8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我强烈建议你每天花一个小时浏览一下<code class="fe mi mj mk ml b">.tsconfig</code>和<code class="fe mi mj mk ml b">.eslintrc</code>文件中的所有值，并根据自己的喜好设置所有选项。然后，将这些文件保存在计算机上的某个地方，这样当您开始一个新项目时，就可以很容易地将其粘贴进去。</p><p id="7c48" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我对我的代码非常满意，并且我发现当所有这些规则都被强制执行时，它变得更加干净——作为一个额外的奖励，任何参与你的项目的人都必须遵守<code class="fe mi mj mk ml b">eslintrc</code>中一致同意的风格和<code class="fe mi mj mk ml b">tsconfig</code>中一致同意的功能，所以你可以保证项目的一致性。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="7626" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">就是这样！这是我对打字稿代码的5个建议。我总是在寻找更多的建议，所以如果你有任何重要的东西，请让我知道！</p></div></div>    
</body>
</html>