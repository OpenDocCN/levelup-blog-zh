<html>
<head>
<title>Dictionary Data Types in Python — More Than Just Dict</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的字典数据类型——不仅仅是字典</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dictionary-data-types-in-python-more-than-just-dict-a9ff84d38738?source=collection_archive---------3-----------------------#2020-03-16">https://levelup.gitconnected.com/dictionary-data-types-in-python-more-than-just-dict-a9ff84d38738?source=collection_archive---------3-----------------------#2020-03-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/66c095ce3e8b46c805ca758d8bb23a40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G8YR1mk0_OwkyLWjCPOFZw.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://unsplash.com/@waldemarbrandt67w?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Waldemar Brandt </a>在<a class="ae jg" href="https://unsplash.com/s/photos/dictionary?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><div class=""><h2 id="a31b" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">快速浏览Python中三种常见的字典数据类型。</h2></div><p id="5e0f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">字典是Python和任何其他现代编程语言(如Javascript和Swift)中必不可少的数据结构。它们也被称为映射、散列表、散列表和关联数组。尽管名称不同，但它们有着相同的特性——它们的元素是键值对。简单地说，字典由一个或多个条目组成，我们可以使用唯一的键来标识每个元素。使用一个特定的键，我们将能够找到与那个键相关的值。</p><p id="fa60" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你学过Python，你大概知道<code class="fe lu lv lw lx b">dict</code>是最常用的内置数据类型之一。是dictionary的简称，但是你知道Python中还有其他的字典数据类型吗？让我们在这篇文章中了解一下它们是什么。我们还将介绍它们自己的基本用法。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h2 id="37d9" class="mf mg jj bd mh mi mj dn mk ml mm dp mn lh mo mp mq ll mr ms mt lp mu mv mw mx bi translated">内置字典</h2><p id="ffb4" class="pw-post-body-paragraph ky kz jj la b lb my kk ld le mz kn lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated"><code class="fe lu lv lw lx b">dict</code>数据类型是Python标准库中唯一的内置映射数据结构。它的主要用途非常简单，如下所述。</p><figure class="nd ne nf ng gt iv"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">字典的基本用法</figcaption></figure><p id="0870" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于<code class="fe lu lv lw lx b">dict</code>数据类型的常见用法，下面列出了一些要点。</p><ul class=""><li id="ffee" class="nj nk jj la b lb lc le lf lh nl ll nm lp nn lt no np nq nr bi translated">钥匙需要<a class="ae jg" href="https://docs.python.org/3/glossary.html#term-hashable" rel="noopener ugc nofollow" target="_blank">可拆卸</a>。如果一个对象的类型实现了<code class="fe lu lv lw lx b">__hash__()</code>方法，那么这个对象就是可散列的，这样就可以为该类型的每个对象计算一个散列值。重要的是，可散列对象在其生命周期中不应该改变，这意味着像<code class="fe lu lv lw lx b">list</code>和<code class="fe lu lv lw lx b">dict</code>这样的可变对象是不可散列的，因此不能用作键，如下所示。</li></ul><pre class="nd ne nf ng gt ns lx nt nu aw nv bi"><span id="57ea" class="mf mg jj lx b gy nw nx l ny nz">&gt;&gt;&gt; dict_example = {1: 1, 'three': 3, (4, 5): 0}<br/>&gt;&gt;&gt; dict_example[[1,2]] = 5<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>TypeError: unhashable type: 'list'</span></pre><ul class=""><li id="f825" class="nj nk jj la b lb lc le lf lh nl ll nm lp nn lt no np nq nr bi translated">如果我们使用方括号方法(即<code class="fe lu lv lw lx b">student[‘firstName’]</code>)访问一个值，如果键不在<code class="fe lu lv lw lx b">dict</code>中，解释器将抛出一个<code class="fe lu lv lw lx b">KeyError</code>。因此，访问特定键值的更安全的方法是使用<code class="fe lu lv lw lx b">get(key[, default])</code>方法。当键不存在时，除非设置默认值并相应返回，否则将返回<code class="fe lu lv lw lx b">None</code>。</li></ul><pre class="nd ne nf ng gt ns lx nt nu aw nv bi"><span id="afc5" class="mf mg jj lx b gy nw nx l ny nz">&gt;&gt;&gt; dict_missing = {'zero': 0, 'one': 1}<br/>&gt;&gt;&gt; dict_missing['two']<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>KeyError: 'two'<br/>&gt;&gt;&gt; print(dict_missing.get('two'))<br/>None<br/>&gt;&gt;&gt; print(dict_missing.get('two', -1))<br/>-1</span></pre><ul class=""><li id="f9d2" class="nj nk jj la b lb lc le lf lh nl ll nm lp nn lt no np nq nr bi translated">我们可以分别使用<code class="fe lu lv lw lx b">keys()</code>、<code class="fe lu lv lw lx b">values()</code>和<code class="fe lu lv lw lx b">items()</code>方法来访问<code class="fe lu lv lw lx b">dict</code>的键、值和键值对(显示为元组)。这些被称为<a class="ae jg" href="https://docs.python.org/3/library/stdtypes.html#dict-views" rel="noopener ugc nofollow" target="_blank">视图对象</a>，这意味着它们只是<code class="fe lu lv lw lx b">dict</code>的动态视图，并且随着<code class="fe lu lv lw lx b">dict</code>的变化而变化。此外，这些视图是可迭代的，因此它们都可以在for循环中使用。</li></ul><pre class="nd ne nf ng gt ns lx nt nu aw nv bi"><span id="8942" class="mf mg jj lx b gy nw nx l ny nz">&gt;&gt;&gt; dict_iterable = {'zero': 0, 'one': 1}<br/>&gt;&gt;&gt; dict_iterable_keys = dict_iterable.keys()<br/>&gt;&gt;&gt; dict_iterable_keys<br/>dict_keys(['zero', 'one'])<br/>&gt;&gt;&gt; dict_iterable['two']=2<br/>&gt;&gt;&gt; dict_iterable_keys<br/>dict_keys(['zero', 'one', 'two'])<br/>&gt;&gt;&gt; for i in dict_iterable_keys:<br/>...     print(i)<br/>... <br/>zero<br/>one<br/>two</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h2 id="ae2e" class="mf mg jj bd mh mi mj dn mk ml mm dp mn lh mo mp mq ll mr ms mt lp mu mv mw mx bi translated">默认字典</h2><p id="4ca6" class="pw-post-body-paragraph ky kz jj la b lb my kk ld le mz kn lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">作为内置<code class="fe lu lv lw lx b">dict</code>类的子类，<code class="fe lu lv lw lx b">defaultdict</code>对象有时被用作类似字典的对象。应该注意的是，<code class="fe lu lv lw lx b">defaultdict</code>数据类型不是标准库的一部分，它在<code class="fe lu lv lw lx b">collections</code>模块中可用。</p><p id="10fd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了拥有一个<code class="fe lu lv lw lx b">default_factory</code>属性之外，<code class="fe lu lv lw lx b">defaultdict</code>类型具有与<code class="fe lu lv lw lx b">dict</code>类相同的功能。<code class="fe lu lv lw lx b">defaultdict</code>的构造函数是<code class="fe lu lv lw lx b">defaultdict([<em class="oa">default_factory</em>[, <em class="oa">...</em>]])</code>。具体来说，<code class="fe lu lv lw lx b">default_factory</code>参数的默认值是<code class="fe lu lv lw lx b">None</code>。当它被设置时，当给定的键不在<code class="fe lu lv lw lx b">defaultdict</code>中时，它被不带参数地调用以生成默认值。下面给出一个例子。</p><pre class="nd ne nf ng gt ns lx nt nu aw nv bi"><span id="31f3" class="mf mg jj lx b gy nw nx l ny nz">&gt;&gt;&gt; from collections import defaultdict<br/>&gt;&gt;&gt; letter_counts = defaultdict(int)<br/>&gt;&gt;&gt; for i in 'abbcccddddeeeee':<br/>...     letter_counts[i] += 1<br/>... <br/>&gt;&gt;&gt; letter_counts.items()<br/>dict_items([('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)])</span></pre><p id="203c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如上图所示，当<code class="fe lu lv lw lx b">letter_counts</code>没有任何键时，访问缺少的键的值(如‘a’)，调用<code class="fe lu lv lw lx b">default_factory</code>(即<code class="fe lu lv lw lx b">int</code>)，返回0，因为<code class="fe lu lv lw lx b">int()</code>返回0。因此，<code class="fe lu lv lw lx b">defaultdict</code>最突出的特点就是<strong class="la jk">通过调用</strong> <code class="fe lu lv lw lx b"><strong class="la jk">default_factory</strong></code> <strong class="la jk">函数来返回缺省值。</strong></p><p id="c093" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">需要注意的一点是<code class="fe lu lv lw lx b">default_factory</code>参数只能用可调用的东西来设置，比如函数或lambda。所以上面的例子可以改写成下面这样。我们使用λ函数<code class="fe lu lv lw lx b">lambda: 0</code>来代替<code class="fe lu lv lw lx b">int</code>函数。</p><pre class="nd ne nf ng gt ns lx nt nu aw nv bi"><span id="2ec9" class="mf mg jj lx b gy nw nx l ny nz">&gt;&gt;&gt; from collections import defaultdict<br/>&gt;&gt;&gt; letter_counts = defaultdict(lambda: 0)<br/>&gt;&gt;&gt; for i in 'abbcccddddeeeee':<br/>...     letter_counts[i] += 1<br/>... <br/>&gt;&gt;&gt; letter_counts.items()<br/>dict_items([('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)])</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h2 id="f373" class="mf mg jj bd mh mi mj dn mk ml mm dp mn lh mo mp mq ll mr ms mt lp mu mv mw mx bi translated">有序的</h2><p id="d9ac" class="pw-post-body-paragraph ky kz jj la b lb my kk ld le mz kn lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">另一个有用的类似字典的类型是<code class="fe lu lv lw lx b">OrderedDict</code>，它也作为<code class="fe lu lv lw lx b">defaultdict</code>类型在<code class="fe lu lv lw lx b">collections</code>模块中可用。过去，<code class="fe lu lv lw lx b">OrderedDict</code>和<code class="fe lu lv lw lx b">dict</code>类型的主要区别在于前者记得物品的顺序。然而，从Python 3.7开始，<code class="fe lu lv lw lx b">dict</code>类型也实现了基于键值对插入顺序的排序，因此这种跟踪顺序的差异消失了。除此之外，还有两件事值得注意。</p><ul class=""><li id="e747" class="nj nk jj la b lb lc le lf lh nl ll nm lp nn lt no np nq nr bi translated">它们以不同的方式实现了<code class="fe lu lv lw lx b">popitem()</code>方法。在<code class="fe lu lv lw lx b">dict</code> (Python 3.7+)中，该方法使用LIFO(即后进先出)顺序移除并返回一个键值对。然而，在<code class="fe lu lv lw lx b">OrderedDict</code>中，我们可以设置一个布尔参数last。当它为真时，被移除和返回的键值对将是LIFO顺序，当它为假时，顺序将是FIFO(即先进先出)，这样<code class="fe lu lv lw lx b">OrderedDict</code>在我们想要使用哪个顺序移除项目方面给了我们更多的灵活性。相关的例子如下。</li></ul><pre class="nd ne nf ng gt ns lx nt nu aw nv bi"><span id="a973" class="mf mg jj lx b gy nw nx l ny nz">&gt;&gt;&gt; from collections import OrderedDict<br/>&gt;&gt;&gt; dict_remove = {0: 'zero', 1: 'one', 2: 'two'}<br/>&gt;&gt;&gt; dict_remove.popitem()<br/>(2, 'two')<br/>&gt;&gt;&gt; ordereddict_remove = OrderedDict({0: 'zero', 1: 'one', 2: 'two'})<br/>&gt;&gt;&gt; ordereddict_remove.popitem(last=False)<br/>(0, 'zero')<br/>&gt;&gt;&gt; ordereddict_remove.popitem(last=True)<br/>(2, 'two')</span></pre><ul class=""><li id="1284" class="nj nk jj la b lb lc le lf lh nl ll nm lp nn lt no np nq nr bi translated">它们实现相等测试的方式不同。当我们比较两个<code class="fe lu lv lw lx b">OrderedDict</code>时，条目的顺序很重要。然而，当我们与<code class="fe lu lv lw lx b">dict</code> s比较时，项目的顺序并不重要。除了在各自的数据类型中进行比较，当我们比较一个<code class="fe lu lv lw lx b">OrderedDict</code>和一个<code class="fe lu lv lw lx b">dict</code>时，顺序并不重要。这里有一些例子。</li></ul><pre class="nd ne nf ng gt ns lx nt nu aw nv bi"><span id="973b" class="mf mg jj lx b gy nw nx l ny nz">&gt;&gt;&gt; ordereddict0 = OrderedDict({0: 0, 1: 1})<br/>&gt;&gt;&gt; ordereddict1 = OrderedDict({1: 1, 0: 0})<br/>&gt;&gt;&gt; ordereddict2 = OrderedDict({0: 0, 1: 1})<br/>&gt;&gt;&gt; dict0 = {0: 0, 1: 1}<br/>&gt;&gt;&gt; dict1 = {1: 1, 0: 0}<br/>&gt;&gt;&gt; ordereddict0 == ordereddict1<br/>False<br/>&gt;&gt;&gt; ordereddict0 == ordereddict2<br/>True<br/>&gt;&gt;&gt; dict0 == dict1<br/>True<br/>&gt;&gt;&gt; ordereddict0 == dict0<br/>True<br/>&gt;&gt;&gt; ordereddict0 == dict1<br/>True</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="7c71" class="ob mg jj bd mh oc od oe mk of og oh mn kp oi kq mq ks oj kt mt kv ok kw mw ol bi translated">外卖食品</h1><p id="3340" class="pw-post-body-paragraph ky kz jj la b lb my kk ld le mz kn lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">在本文中，我们学习了Python中三个最常用的字典。我们什么时候知道用哪个？以下是一些通用指南。</p><ul class=""><li id="1674" class="nj nk jj la b lb lc le lf lh nl ll nm lp nn lt no np nq nr bi translated">在大多数情况下，我们可以使用内置的<code class="fe lu lv lw lx b">dict</code>数据类型。不仅因为它为我们的需求提供了最多的功能，还因为它不需要导入任何模块。</li><li id="9656" class="nj nk jj la b lb om le on lh oo ll op lp oq lt no np nq nr bi translated">当我们构造一个字典时，如果我们知道应该为一个丢失的键设置什么默认值，我们应该考虑使用<code class="fe lu lv lw lx b">defaultdict</code>数据类型，因为它针对这种用法进行了优化。</li><li id="ac59" class="nj nk jj la b lb om le on lh oo ll op lp oq lt no np nq nr bi translated">总的来说，<code class="fe lu lv lw lx b">OrderedDict</code>和<code class="fe lu lv lw lx b">dict</code>有相似的用法，所以我们可以互换使用它们，除非我们运行相等测试时考虑到字典的顺序。</li></ul><p id="26d0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢您阅读这篇文章。</p></div></div>    
</body>
</html>