<html>
<head>
<title>From the Implicit Flow to PKCE — OAuth 2.0 for SPA and Mobile Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从隐式流程到PKCE——面向SPA和移动应用的OAuth 2.0</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/from-the-implicit-flow-to-pkce-oauth-2-0-for-spa-and-mobile-apps-df4343938053?source=collection_archive---------0-----------------------#2021-11-11">https://levelup.gitconnected.com/from-the-implicit-flow-to-pkce-oauth-2-0-for-spa-and-mobile-apps-df4343938053?source=collection_archive---------0-----------------------#2021-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="d625" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如何才能让OAuth流在单页面应用和移动App中安全？在本文中，让我们回顾一下在2010年实现这一点的传统方法，并看看它是如何演变成今天的最佳实践的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/fec553d3acdc7702b23a0b2051f36f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SasPDt75TsJb94VtW9mPKQ.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图片由<a class="ae le" href="https://unsplash.com/photos/wh-RPfR_3_M?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditShareLink" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄。</figcaption></figure><p id="27f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，你应该有一些关于OAuth和OIDC的背景知识，并且理解为什么说“通过OAuth登录”是不好的。我推荐以下资源:</p><ul class=""><li id="01a5" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">在<a class="ae le" href="https://truongnmt.medium.com/nh%E1%BA%ADp-m%C3%B4n-oauth-v%C3%A0-openid-connect-e7875e60dda0" rel="noopener">越南</a></li><li id="c7fa" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">在<a class="ae le" href="https://www.youtube.com/watch?v=996OiexHze0" rel="noopener ugc nofollow" target="_blank">英语</a></li></ul><h1 id="19d0" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">为什么会存在隐性流？</h1><p id="a68c" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">我们已经有了一个非常好的工作授权代码流程，为什么还要发明另一个流程呢？为什么SPA和手机app不用授权码流？</p><p id="1f1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">原来是不能的。首先，SPA和移动应用程序是公共客户端，没有合适的方法来隐藏秘密，所以在这些类型的应用程序中没有存储客户端秘密，只有公共客户端id。在授权代码交换步骤中，授权代码流需要客户端密码来向授权服务器验证其自身，但是由于公共客户端没有客户端密码，所以它不能这样做。</p><p id="4112" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二个原因是，在2010年，浏览器的工作方式与现在不同。Javascript只能向加载页面的服务器发出请求(<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy" rel="noopener ugc nofollow" target="_blank">同源策略</a>)。这个限制使得代码交换请求对于SPA来说是不可能的，因为授权服务器通常与部署的Javascript代码域在不同的域中。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mw"><img src="../Images/fb9206117b5c7928f2694cad63d66e02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iClwJsJQ1TCwnfl4GV_sHA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由于同源策略，在步骤6中不允许Javascript的POST请求。</figcaption></figure><p id="c871" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于上述原因，授权码交换步骤无法在SPA和移动应用程序中工作，因此捷径是在浏览器的授权响应中返回访问令牌(步骤5)。隐式流就是这样工作的。OAuth 2.0推荐SPA的隐式流。</p><h1 id="0060" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">为什么不好？</h1><p id="2f39" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">隐式流程看起来超级简单，我们省略了授权代码交换步骤，但有什么问题吗？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mx"><img src="../Images/555fff674ba8499ec344925c8cbab895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*adbhACBNXFGOKW5z3WbDbQ.png"/></div></div></figure><p id="41dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你阅读我之前给你的资源，只是回顾一下，前通道中的返回访问令牌是不好的，因为前通道不是一个安全的环境，用户可以被诱骗安装一个恶意的浏览器扩展，它可以监听用户的网络或访问浏览器历史记录，或者只是简单地站在用户背后窥探令牌。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="49cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是OAuth 2.0安全最佳当前实践RFC 关于隐式流的说法:</p><blockquote class="na nb nc"><p id="10ac" class="jq jr nd js b jt ju jv jw jx jy jz ka ne kc kd ke nf kg kh ki ng kk kl km kn im bi translated"><em class="it">隐式授权(响应类型为“令牌”)和其他导致授权服务器在授权响应中发布接入令牌的响应类型容易出现接入令牌泄漏和接入令牌重放……</em></p><p id="7ad7" class="jq jr nd js b jt ju jv jw jx jy jz ka ne kc kd ke nf kg kh ki ng kk kl km kn im bi translated"><em class="it">此外，由于在</em> <a class="ae le" href="https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-18#section-2.2" rel="noopener ugc nofollow" target="_blank"> <em class="it">章节2.2 </em> </a> <em class="it">中推荐了<br/>，因此不存在可行的机制来将授权响应中发布的访问<br/>令牌加密绑定到某个客户端。这使得在资源服务器上不可能对这种<br/>访问令牌进行重放检测。</em></p></blockquote><p id="86e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，在隐式流期间不发布刷新令牌。因此:</p><ul class=""><li id="9a72" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">经常需要访问令牌万岁</li><li id="8615" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">当客户端需要额外的/新的令牌时，要么使用隐藏的iframe进行静默重定向(prompt=none ),要么必须将用户发送给ID提供者并重新认证用户。</li></ul><p id="9ba1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然有所有这些风险，但隐性流动是当时唯一可能的方式。我们可以通过限制权限和使用短时令牌(通过静默重定向获得良好的UX)来降低这些风险。那是当时人们通常的做法。(但是，我应该说，现在，SameSite=Lax使带有隐藏iframe的静默重定向成为不可能)</p><p id="b703" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如今，<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank">【CORS】</a>被浏览器广泛采用。CORS为JavaScript提供了一种向不同域中的服务器发出请求的方式，只要目的地(IdP)允许。这开启了在JavaScript中使用授权代码流的可能性。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nh mz l"/></div></figure><h1 id="893e" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">授权代码流</h1><p id="791c" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">让我们看看如果我们只对公共客户端SPA使用授权代码流会发生什么。这里我们有一个序列图:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ni"><img src="../Images/ffa182ded5577f9fcaf8c689e25685f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P3RFt6tck85KXT0S36keAQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">公共客户端授权代码流上的访问令牌劫持</figcaption></figure><p id="c382" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设用户的网络被监控，攻击者可以监听所有用户的请求。在步骤4中，用户登录到授权服务器后，授权码被返回。由于能够监听用户的网络活动，攻击者可以窃取授权码，其想法是在真正的用户这样做之前交换授权码。这实际上是可行的，因为对于公共客户端，授权服务器不会请求客户端机密来交换访问令牌。其他信息，如客户端id、redirect_uri、范围等，都可以在对授权服务器的请求中检索到，攻击者可以获得所有需要的信息并伪造合法的令牌交换请求。</p><p id="1533" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是为什么对于公众客户，建议使用<strong class="js iu"> PKCE </strong>。让我们看看如果我们在授权代码流之上添加PKCE会发生什么:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nj"><img src="../Images/15f1799ea0efe3faa28bf5985108b4a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hz1Kzj6iJ9xfxlHsdFZOZw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">PKCE的授权代码流</figcaption></figure><blockquote class="na nb nc"><p id="5990" class="jq jr nd js b jt ju jv jw jx jy jz ka ne kc kd ke nf kg kh ki ng kk kl km kn im bi translated"><em class="it"> PKCE:密码交换的证明密钥</em></p></blockquote><p id="78cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(还要注意，在步骤12中，当设置应用程序时，客户端必须向授权服务器注册网站URL，客户端将从该URL发出跨来源请求。)</p><p id="afac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在步骤2中，客户端生成code_verifier和code_challenge，创建它的方法是选择一种单向散列方法，散列一个纯文本并得到一个散列字符串。</p><pre class="kp kq kr ks gt nk nl nm nn aw no bi"><span id="79c1" class="np lu it nl b gy nq nr l ns nt">code_challenge_method(code_verifier) = code_challenge</span><span id="ef49" class="np lu it nl b gy nu nr l ns nt"># which equivalent to</span><span id="39c5" class="np lu it nl b gy nu nr l ns nt">hash_method(plain_text) = hash</span></pre><p id="8257" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">客户端保存code_verifier，并在步骤3的授权请求中发送code _ challenge _ method code _ challenge。授权服务器将保存这两个值。</p><p id="ad78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在令牌交换步骤中，授权服务器在步骤12中要求客户端提供client_verifier，并通过在code_verifier上运行哈希方法来验证在步骤3中收到的code_challenge，就像客户端在步骤1中所做的一样:</p><pre class="kp kq kr ks gt nk nl nm nn aw no bi"><span id="19fd" class="np lu it nl b gy nq nr l ns nt">code_challenge_method(code_verifier) == code_challenge?</span></pre><p id="2773" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于假客户端，它没有code_verifier，所以验证会失败！！！这样，code_vefirier就充当了一个临时的客户端秘密！</p><blockquote class="na nb nc"><p id="1382" class="jq jr nd js b jt ju jv jw jx jy jz ka ne kc kd ke nf kg kh ki ng kk kl km kn im bi translated">客户端必须防止攻击者将授权代码注入(重放)到授权响应中。<strong class="js iu">为此，公共客户必须使用PKCE </strong> [ <a class="ae le" href="https://datatracker.ietf.org/doc/html/rfc7636" rel="noopener ugc nofollow" target="_blank"> RFC7636 </a> ]。对于机密客户，建议使用PKCE [ <a class="ae le" href="https://datatracker.ietf.org/doc/html/rfc7636" rel="noopener ugc nofollow" target="_blank"> RFC7636 </a> ]。</p></blockquote><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv mz l"/></div></figure><h1 id="78ac" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">刷新公共客户端的令牌</h1><p id="0fdb" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">使用授权代码流的一个好处是客户端可以拥有刷新令牌，这是一个非常强大的功能。如果泄露，可以无限期使用。因此，根据风险评估，授权服务器的策略决定是否在上面的步骤15中发布刷新令牌。</p><p id="071a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果发布了刷新令牌，授权服务器需要通过以下方法小心地管理这些令牌以防恶意参与者:</p><ul class=""><li id="3ca4" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">受发件人约束的刷新令牌</li><li id="579d" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">刷新令牌循环</li></ul><p id="b9c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更多详细信息请参见第<a class="ae le" href="https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-18#section-4.13.2" rel="noopener ugc nofollow" target="_blank">节OAuth 2.0安全最佳当前实践RFC #第4.13.2节</a>。</p><h1 id="1bf5" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">授权代码流是否使SPA完全安全？</h1><p id="69a0" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">在用户关闭应用程序并再次打开它后，我们不希望用户不得不再次启动该流程，这是非常糟糕的UX。因此，在上面的步骤17中，在我们获得访问令牌之后，我们需要以某种方式存储它以供以后使用。</p><p id="350a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">PKCE的授权代码流确保访问令牌在传输过程中是安全的。然而，问题是我们如何存储这个访问令牌。无论我们使用隐式流程还是新推荐的流程，这个问题仍然存在。</p><p id="0f5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以答案是否定的，问题还是出在前通道，它无法存储秘密。最好的方法(目前)是将令牌管理完全放在Javascript之外，将授权代码流交给一个保密的客户端。</p><h1 id="ec9f" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">结论</h1><p id="d50e" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">希望你能大致了解为什么不推荐SPA和移动应用程序使用Implicit Flow。在下一篇文章中，我将向您展示SPA和移动应用程序的安全最佳实践，敬请关注下一篇文章。^^</p><h1 id="a431" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">资源</h1><ul class=""><li id="7382" class="lf lg it js b jt mr jx ms kb nw kf nx kj ny kn lk ll lm ln bi translated"><a class="ae le" href="https://oauth.net/2/oauth-best-practice/" rel="noopener ugc nofollow" target="_blank"> OAuth 2.0安全最佳实践</a>(oauth.net)</li><li id="b7ed" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">【oauth.net】OAuth 2.0隐式授权</li><li id="eaab" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae le" href="https://auth0.com/blog/oauth2-implicit-grant-and-spa/" rel="noopener ugc nofollow" target="_blank"> OAuth2隐性资助和水疗</a>(维托里奥·贝托奇)</li><li id="3587" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae le" href="https://developer.okta.com/blog/2019/05/01/is-the-oauth-implicit-flow-dead" rel="noopener ugc nofollow" target="_blank">OAuth 2.0隐式流死了吗？</a>(作者亚伦·帕雷基)</li><li id="b575" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae le" href="https://medium.com/oauth-2/why-you-should-stop-using-the-oauth-implicit-grant-2436ced1c926" rel="noopener">为什么您应该停止使用OAuth隐式授权！</a>(托尔斯滕·洛德斯特)</li></ul></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><p id="1b02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="nd">感谢阅读本文！如果你有任何问题，请留言。如果你觉得这篇文章有帮助，请按住鼓掌按钮，让其他人也能发现。请务必在下面注册我的时事通讯，或者在Medium上关注我，以获得更多类似的文章。</em> ☝️👏 😄</p></div></div>    
</body>
</html>