<html>
<head>
<title>How To: Solving ‘Chunk Array’ Interview Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何:解决“组块阵列”面试问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-solving-chunk-array-interview-questions-a0fe3db12598?source=collection_archive---------7-----------------------#2020-03-22">https://levelup.gitconnected.com/how-to-solving-chunk-array-interview-questions-a0fe3db12598?source=collection_archive---------7-----------------------#2020-03-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9c53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">继续我为常见面试问题撰写<a class="ae ko" href="https://medium.com/@briandsalemi" rel="noopener">教程</a>的主题，在这篇博文中，我将教你如何回答<strong class="js iu">组块数组</strong>问题。该问题通常如下所示:</p><blockquote class="kp kq kr"><p id="6749" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">给定一个<code class="fe kw kx ky kz b">array</code>和<code class="fe kw kx ky kz b">chunk size</code>作为参数，编写一个函数，将<code class="fe kw kx ky kz b">array</code>分成几个<code class="fe kw kx ky kz b">subarrays</code>，其中每个<code class="fe kw kx ky kz b">subarray</code>都有一个<code class="fe kw kx ky kz b">chunk size</code>的<code class="fe kw kx ky kz b">length</code>。</p></blockquote><p id="81b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个问题初看起来可能很难，但是一旦你找到了解决它的最佳方法，它就变得非常容易实现。</p><p id="84fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们开始吧。首先，我们将从一个名为<code class="fe kw kx ky kz b">chunk</code>的函数开始，它将接收一个<code class="fe kw kx ky kz b">array</code>和一个<code class="fe kw kx ky kz b">size</code>作为它的参数。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi la"><img src="../Images/59d8d4fe274e5da8b37e8a60858ad487.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*RgjOJ6MJqA3ZZ2_SE4jLww.png"/></div></figure><p id="02ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们需要声明一个新变量<code class="fe kw kx ky kz b">chunked</code>，并将其设置为一个空数组。这个数组将负责包含每个新的分块子数组。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi la"><img src="../Images/5781a5317634efea909c0544d270b310.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*X1KtIrkfxLS6q9RTvQBM5Q.png"/></div></div></figure><p id="d140" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们将使用一个<code class="fe kw kx ky kz b">for…of </code>语句迭代<code class="fe kw kx ky kz b">array </code>中的每个元素。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/c75c83f83c992cdcaa6be5c178fb0116.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*DuYLuO6g1gDDWH05OYJaug.png"/></div></figure><p id="5318" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的<code class="fe kw kx ky kz b">for…of</code>语句中，事情变得有点棘手。我们的第一步是声明一个名为<code class="fe kw kx ky kz b">last</code>的新变量，并将其设置为等于我们的<code class="fe kw kx ky kz b">chunked</code>数组中的最后一个元素。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/91efce49840c5bd18a7fe1cc15e1ba59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*omYDqpu9GW5D60ld99AXNw.png"/></div></figure><p id="41e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们将设置一个条件来检查两件事。首先，它会检查<code class="fe kw kx ky kz b">last</code>是否不存在。如果它确实存在，那么我们将检查<code class="fe kw kx ky kz b">last.length</code>是否等于我们的参数<code class="fe kw kx ky kz b">size</code>。如果这些检查中的任何一个返回<code class="fe kw kx ky kz b">true</code>，那么我们将<code class="fe kw kx ky kz b">push</code>一个带有当前<code class="fe kw kx ky kz b">element</code>的新子数组到我们的<code class="fe kw kx ky kz b">chunked</code>数组中。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/f16a2c7dd9005dbdfe7b84e940526375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*u--otYImj0K50n1PonoY-w.png"/></div></figure><p id="7e87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，如果这两个检查都返回<code class="fe kw kx ky kz b">false</code>，我们将把当前的<code class="fe kw kx ky kz b">element</code>返回到<code class="fe kw kx ky kz b">last</code>，并从<code class="fe kw kx ky kz b">array</code>的下一个元素开始迭代。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/43e920a3f1277d9b4e48aec75052da0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*6bdC_L_8H3jdPoZWgAKeXg.png"/></div></figure><p id="7dea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的<code class="fe kw kx ky kz b">for…of</code>语句的每一次迭代完成后，我们的<code class="fe kw kx ky kz b">chunked</code>数组将被正确地填充长度等于<code class="fe kw kx ky kz b">size</code>的子数组。为满足可交付结果，<code class="fe kw kx ky kz b">return</code> <code class="fe kw kx ky kz b">chunked</code>后的<code class="fe kw kx ky kz b">for…of</code>语句完成此功能</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/defa046bdf219a031a4d40db0102ead2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*rJ0mA00eVdpViMxra_pqIg.png"/></div></figure><h2 id="8336" class="lr ls it bd lt lu lv dn lw lx ly dp lz kb ma mb mc kf md me mf kj mg mh mi mj bi translated">用...解决。切片()</h2><p id="1867" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">解决这个问题的另一种方法是使用JavaScript数组<a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" rel="noopener ugc nofollow" target="_blank">方法</a> <code class="fe kw kx ky kz b">.slice()</code>。<code class="fe kw kx ky kz b">.slice()</code>方法返回一个数组的<strong class="js iu">部分</strong>的浅拷贝，从开始索引直到(但<strong class="js iu">不包括</strong>)结束索引。例如，如果我们调用<code class="fe kw kx ky kz b">array.slice(0,2)</code>，它将复制数组的第一个和第二个元素(<code class="fe kw kx ky kz b">index 0 and 1</code>)，但不复制第三个元素(<code class="fe kw kx ky kz b">index 2</code>)。</p><p id="ac2f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个解决方案与前一个解决方案一样，通过设置一个等于空数组的变量<code class="fe kw kx ky kz b">chunked</code>开始。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi la"><img src="../Images/5781a5317634efea909c0544d270b310.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*X1KtIrkfxLS6q9RTvQBM5Q.png"/></div></div></figure><p id="2b7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，与前面的解决方案不同，我们将使用一个<code class="fe kw kx ky kz b">while loop</code>来迭代<code class="fe kw kx ky kz b">array</code>，而不是一个<code class="fe kw kx ky kz b">for…of</code>语句。<code class="fe kw kx ky kz b">while loop</code>将从索引<code class="fe kw kx ky kz b">0</code>开始，只要<code class="fe kw kx ky kz b">index</code>小于<code class="fe kw kx ky kz b">array.length</code>就会继续。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/1380dc44d5bb4ce2b351bc251d81f8e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*wHC3sCeBlyJQDlYhYru_MA.png"/></div></figure><p id="436f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe kw kx ky kz b">while loop</code>内我们要将<code class="fe kw kx ky kz b">push</code>的一个<code class="fe kw kx ky kz b">slice</code>的<code class="fe kw kx ky kz b">array</code>放入我们的空<code class="fe kw kx ky kz b">chunked</code>阵中。<code class="fe kw kx ky kz b">.slice()</code>的参数将从<code class="fe kw kx ky kz b">index</code>开始，在<code class="fe kw kx ky kz b">index + size</code>之前结束。切片被推入<code class="fe kw kx ky kz b">chunked</code>后，<code class="fe kw kx ky kz b">index</code>将增加<code class="fe kw kx ky kz b">size</code>。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/8fc78ace6e34aeb9b8d52bca0d3478fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*3K9XAuGmDMFMRB_558NNMw.png"/></div></figure><p id="8e02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与前面的解决方案一样，在<code class="fe kw kx ky kz b">while loop</code>完成<code class="fe kw kx ky kz b">return</code> <code class="fe kw kx ky kz b">chunked</code>后，返回子数组并正确回答问题。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/02881e47f124bbefb733aab23f55b136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*6XkDniNhQwnHNAXtYSbs6Q.png"/></div></figure><h2 id="4637" class="lr ls it bd lt lu lv dn lw lx ly dp lz kb ma mb mc kf md me mf kj mg mh mi mj bi translated">结论</h2><p id="7858" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated"><strong class="js iu"> Chunk Array </strong>面试问题一开始可能有点难以计划，但是一旦核心概念被确定，它就变得容易处理了。这个问题，以及类似的问题，都需要一个<strong class="js iu">循环</strong>来迭代数组参数和一个<strong class="js iu">空数组</strong>来存储子数组。通过练习，记住这个基本框架，你将能够解决面试官可能抛给你的任何类型的问题。</p></div></div>    
</body>
</html>