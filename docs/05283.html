<html>
<head>
<title>How to encrypt a file using Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Go加密文件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-short-guide-to-encryption-using-go-da97c928259f?source=collection_archive---------2-----------------------#2020-08-17">https://levelup.gitconnected.com/a-short-guide-to-encryption-using-go-da97c928259f?source=collection_archive---------2-----------------------#2020-08-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="35e9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及如何保护您的数据。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7f87b9dfd1c713015e314993d3b5eacd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mZuwMFh7kvF94gxchReSkg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·温克勒在<a class="ae ky" href="https://unsplash.com/s/photos/key-lock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="6c29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在当今世界，密码学是强制性的。在这个大数据和数据科学的时代，确保您的数据免受恶意攻击非常重要。</p><p id="09ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多算法和技术可以确保你的系统是安全的，没有未经授权的访问你的数据。</p><p id="e766" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对称加密就是这些技术中的一种，在本教程中，我将向你展示如何在<a class="ae ky" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>中实现。</p><p id="3355" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注意:本教程使用的Go版本是1.14.7。</em></p><h1 id="5b08" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">介绍</h1><p id="a337" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">对称密钥加密是一种用于加密只有一个密钥的消息的技术。该密钥用于该过程的两个部分，即加密和解密消息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/f3b9cbb666beb644d773a37ad3d5cbe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*QPDIi-w9u5D9dRSwG-C6Dg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</figcaption></figure><p id="e5e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用任何一种对称密钥算法，消息都被转换成无法理解的形式。除非有人有秘钥。在这种情况下，发送方和接收方拥有相同的密钥(以某种安全的方式交换)，因此他们可以发送消息并相互理解。</p><p id="8498" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所使用的算法决定了密钥的大小以及加密或解密过程的模式。通常，密钥越长，破解就越难，加密就越安全。例如，一个128位的密钥可能需要几十亿年才能被普通计算机破解。</p><p id="5c29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种类型的算法:</p><ul class=""><li id="5680" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated"><strong class="lb iu">块</strong>:使用固定大小的块对消息进行加密。例子:<a class="ae ky" href="https://en.wikipedia.org/wiki/Data_Encryption_Standard" rel="noopener ugc nofollow" target="_blank"> DES </a>、<a class="ae ky" href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard" rel="noopener ugc nofollow" target="_blank"> AES </a>等。</li><li id="fd60" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><strong class="lb iu">流</strong>:消息采用单个字符加密。例如:<a class="ae ky" href="https://en.wikipedia.org/wiki/RC4" rel="noopener ugc nofollow" target="_blank"> RC4 </a>、<a class="ae ky" href="https://en.wikipedia.org/wiki/Salsa20" rel="noopener ugc nofollow" target="_blank">萨尔萨20 </a>等。</li></ul><h2 id="85c0" class="ni lx it bd ly nj nk dn mc nl nm dp mg li nn no mi lm np nq mk lq nr ns mm nt bi translated">模式</h2><p id="13c8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">由于块密码只对固定长度的位组进行运算，因此您必须描述如何重复单次运算来转换比块大的数据。</p><p id="e3a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数模式需要一个独特的初始序列，通常称为<em class="lv">初始化向量(IV)。</em>静脉注射必须不重复，有时也是随机的。</p><p id="d84f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果数据长度不是块大小的倍数，则将最后一个块填充为一个完整的块。但是，有些模式不需要它，因为它们将它用作流密码。一些常见模式:</p><ul class=""><li id="e46d" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated"><strong class="lb iu"> ECB </strong>:最简单的。分别加密每个块。这种模式一点也不安全，不应该使用。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/6fa6c880aa1390de40e7549063c4f458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/0*hAJdBbykop8tLA3n.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">WhiteTimberwolf (SVG版本)/公共领域</figcaption></figure><ul class=""><li id="0d25" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated"><strong class="lb iu"> CBC </strong>:在这种模式下，原始消息的每一个块在被加密之前都与前一个加密块进行异或运算。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/dfdd55db374de282f3ec2d73a5a78487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/0*C7w7_yvQlcP0tWV7.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">WhiteTimberwolf (SVG版本)/公共领域</figcaption></figure><ul class=""><li id="5cdb" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated"><strong class="lb iu"> CFB / OFB / CTR </strong>:这些模式通过仅在加密部分之后使用消息块，将分组密码变成流密码。</li><li id="7363" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><strong class="lb iu"> XTS </strong>:用于编码随机存取数据(如硬盘或RAM)。</li></ul><h2 id="8ac0" class="ni lx it bd ly nj nk dn mc nl nm dp mg li nn no mi lm np nq mk lq nr ns mm nt bi translated">消息认证</h2><p id="9744" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了提高消息的安全性，会添加一小段信息来验证它。换句话说，它确认消息确实来自发件人，并且没有被修改。</p><p id="22cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这条信息被称为<em class="lv">消息认证码(MAC) </em>，保护消息的数据完整性和真实性。实现它的算法有很多，比如<a class="ae ky" href="https://en.wikipedia.org/wiki/HMAC" rel="noopener ugc nofollow" target="_blank"> HMAC </a>、<a class="ae ky" href="https://en.wikipedia.org/wiki/Galois/Counter_mode" rel="noopener ugc nofollow" target="_blank"> GCM </a>等。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h1 id="df69" class="lw lx it bd ly lz oc mb mc md od mf mg jz oe ka mi kc of kd mk kf og kg mm mn bi translated">加密</h1><p id="cd9e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">使用Go加密文件的过程很简单。使用包<code class="fe oh oi oj ok b"><a class="ae ky" href="https://golang.org/pkg/crypto/" rel="noopener ugc nofollow" target="_blank">crypto</a></code>我们可以做所有必要的步骤来加密一个文件。</p><p id="4298" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步是打开文件并阅读其内容。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="b847" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是为我们的算法创建块。这个对象实现了实际的代码，所以我们不必担心它。在本教程中，我们将使用AES。</p><p id="7795" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">密钥必须是16字节(AES-128)、24字节(AES-192)或32字节(AES-256)，我们从文件中读取。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="103b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong> : <a class="ae ky" href="https://www.freecodecamp.org/news/how-to-securely-store-api-keys-4ff3ea19ebda/" rel="noopener ugc nofollow" target="_blank">永远不要在你的代码上保存你的密钥</a>。</p><p id="6ab1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，有一些模式你可以加密你的信息。为了方便起见，包<code class="fe oh oi oj ok b">crypto/cipher</code>已经为我们实现了其中的一些。</p><p id="4b81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Galois/Counter_Mode" rel="noopener ugc nofollow" target="_blank"> GCM </a>模式，这是一种带认证的流模式。因此，我们不必担心填充或进行身份验证，因为它已经由包完成了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="45d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此模式需要一个nonce数组。它像静脉注射一样工作。确保这永远不会是同一个值，也就是说，每次加密时都要更改它，即使它是同一个文件。您可以使用包<code class="fe oh oi oj ok b">crypto/rand</code>用一个随机值来做到这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="d8d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了加密数据，我们使用函数<code class="fe oh oi oj ok b"><a class="ae ky" href="https://golang.org/pkg/crypto/cipher/#AEAD" rel="noopener ugc nofollow" target="_blank">Seal</a></code>。它将使用GCM模式加密文件，将<code class="fe oh oi oj ok b">nonce</code>和<code class="fe oh oi oj ok b">tag</code> (MAC值)附加到最终数据，因此我们可以在以后使用它来解密。</p><p id="e068" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这之后，我们只需要将密文保存到我们的目标文件中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="a090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！你已经加密了一个文件。完整的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h1 id="cd37" class="lw lx it bd ly lz oc mb mc md od mf mg jz oe ka mi kc of kd mk kf og kg mm mn bi translated">[通信]解密</h1><p id="ce26" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">要解密文件，过程基本相同。我们现在必须读取加密文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="ee07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建密钥和模式块与加密过程相同。由于这是一种对称密钥算法，请确保使用与加密时相同的密钥。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="1433" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解密我们的文件，我们使用了<code class="fe oh oi oj ok b"><a class="ae ky" href="https://golang.org/pkg/crypto/cipher/#AEAD" rel="noopener ugc nofollow" target="_blank">Open</a></code>函数。需要注明我们在加密过程中使用的<code class="fe oh oi oj ok b">nonce</code>值。在我们的加密过程中，这个值保存在文件的开头。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="4c25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们只需将解密内容保存到一个文件中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h1 id="fdde" class="lw lx it bd ly lz oc mb mc md od mf mg jz oe ka mi kc of kd mk kf og kg mm mn bi translated">加密大文件</h1><p id="2709" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">虽然这是一种简单的加密文件的方法，但对于大文件来说却不是一个好的选择。所有内容在加密前都被读入内存。为了避免任何问题，我们必须按块读取和加密。</p><p id="7847" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们首先使用<code class="fe oh oi oj ok b">os.Open</code>函数打开我们感兴趣的加密文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="ec61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">密钥和块的创建与前面的例子相同，所以我不打算在这里重复。</p><p id="f7db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Counter_(CTR)" rel="noopener ugc nofollow" target="_blank"> CTR </a>模式，因为它是一种流模式，非常接近GCM。此模式还需要一个IV，其大小与块相同(对于AES，16字节)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="e546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在进入实际的读取循环之前，我们必须打开目标文件，以便能够写入其中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="7a3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们逐块读取文件。在本教程中，我们选择1024字节的缓冲区，但是您可以选择任何您喜欢的大小。</p><p id="0f7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于从输入文件中读取的每个块，我们使用函数<code class="fe oh oi oj ok b">XORKeyStream</code>执行加密过程。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="89eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们将使用的IV保存到目标文件中，这样我们就可以用它来解密。完整代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h1 id="80b7" class="lw lx it bd ly lz oc mb mc md od mf mg jz oe ka mi kc of kd mk kf og kg mm mn bi translated">解密大文件</h1><p id="d3d8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">要解密它，我们只需要改变一件事:从文件中读取IV，而不是随机值。这个值保存在文件的最后，所以很容易阅读。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="0332" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在CTR模式下，加密和解密过程是一样的，所以我们实际上不需要做任何改变。</p><p id="2f1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解密部分的完整代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="1a83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，我们没有使用任何形式的认证。这可以使用<code class="fe oh oi oj ok b">crypto/hmac</code>包轻松完成。计算出MAC值后，可以将其附加到目标文件中。对于解密过程，你必须读取它，并与你执行的新计算进行比较。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h1 id="1193" class="lw lx it bd ly lz oc mb mc md od mf mg jz oe ka mi kc of kd mk kf og kg mm mn bi translated">结论</h1><p id="ebec" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">通过使用<code class="fe oh oi oj ok b">crypto</code>包，使用Go语言加密文件并不困难。</p><p id="a351" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您也对如何使用Go创建散列感兴趣，请查看另一篇文章:</p><div class="on oo gp gr op oq"><a href="https://medium.com/better-programming/a-short-guide-to-hashing-in-go-e8bb0173e97e" rel="noopener follow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">围棋散列法简明指南</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">如何散列一个字符串或文件</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">medium.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe ks oq"/></div></div></a></div><p id="c1eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想收到更多关于编程的文章，请在<a class="ae ky" href="https://twitter.com/ustropo" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。</p></div></div>    
</body>
</html>