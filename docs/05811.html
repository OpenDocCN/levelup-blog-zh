<html>
<head>
<title>Learning Higher Order Components in React.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习React.js中的高阶组件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-higher-order-components-in-react-js-2245c1a5ff4d?source=collection_archive---------1-----------------------#2020-10-04">https://levelup.gitconnected.com/learning-higher-order-components-in-react-js-2245c1a5ff4d?source=collection_archive---------1-----------------------#2020-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/885146cc2aee4b5a5b7759bfa45b2a9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*baOjZ_HwA6wfQr_s"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Wojciech Portnicki 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1e16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">高阶组件是React中使用的一种技术，它允许我们重用组件逻辑。这方面的一个例子是根据用户是否登录来有条件地呈现的组件。</p><p id="fb40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更具体地说，高阶分量是一个函数，它将一个分量作为参数，并返回一个分量。</p><p id="8ae9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于本演练，让我们构建一个简单的React应用程序，它将使用高阶组件来保护页面，需要有人登录才能查看它。我们将使用一个按钮来控制登录/退出状态，这样我们就可以专注于HOC。然后，我们将创建另一个HOC来根据是否加载了我们的API或数据库内容来保护页面，并且我们将嵌套HOC！首先，让我们创建一个新的React项目:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="f360" class="lk ll iq lg b gy lm ln l lo lp">#=&gt; npx create-react-app learning-hoc<br/>#=&gt; cd learning-hoc<br/>#=&gt; code .</span></pre><p id="2ac6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们把<code class="fe lq lr ls lg b">App.js</code>清理出来，改成类组件。我们正在更改它，以便我们可以在我们的演练中以简单的方式使用状态。当我们完成时，它看起来像这样:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="f035" class="lk ll iq lg b gy lm ln l lo lp">// App.js</span><span id="6ce0" class="lk ll iq lg b gy lt ln l lo lp">import React from 'react';<br/>import './App.css';</span><span id="c44e" class="lk ll iq lg b gy lt ln l lo lp">class App extends React.Component {<br/>    render () {<br/>        return (<br/>            &lt;div className="App"&gt;<br/>            <br/>            &lt;/div&gt;<br/>        )<br/>    }<br/>};</span><span id="6761" class="lk ll iq lg b gy lt ln l lo lp">export default App;</span></pre><p id="7e7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们快速构建一个组件来保存我们想要保护的内容。出于本演练的目的，这将非常简单:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="bc8e" class="lk ll iq lg b gy lm ln l lo lp">#=&gt; cd src<br/>#=&gt; mkdir components<br/>#=&gt; cd components<br/>#=&gt; touch Content.js</span></pre><p id="832c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lq lr ls lg b">Content.js</code>文件中，我们将建立一个简单的类组件，它返回我们的超级机密保护信息，包装在一个<code class="fe lq lr ls lg b">&lt;h1&gt;</code>标签中:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="05a4" class="lk ll iq lg b gy lm ln l lo lp">// ./components/Content.js</span><span id="279a" class="lk ll iq lg b gy lt ln l lo lp">import React from 'react';</span><span id="af42" class="lk ll iq lg b gy lt ln l lo lp">class Content extends React.Component {<br/>    render () {<br/>        return (<br/>            &lt;h1&gt;Super Secret Protected Information&lt;/h1&gt;<br/>        )<br/>    }<br/>};</span><span id="39b2" class="lk ll iq lg b gy lt ln l lo lp">export default Content;</span></pre><p id="ba03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们将它导入到<code class="fe lq lr ls lg b">App.js</code>中，并使用<code class="fe lq lr ls lg b">npm start</code>来确保我们可以看到它:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6926" class="lk ll iq lg b gy lm ln l lo lp">// App.js</span><span id="eb9f" class="lk ll iq lg b gy lt ln l lo lp">import React from 'react';<br/>import './App.css';<br/>import Content from './components/Content.js'</span><span id="1aa6" class="lk ll iq lg b gy lt ln l lo lp">class App extends React.Component {<br/>    render () {<br/>        return (<br/>            &lt;div className="App"&gt;<br/>                &lt;Content /&gt;<br/>            &lt;/div&gt;<br/>        )<br/>    }<br/>};</span><span id="a44a" class="lk ll iq lg b gy lt ln l lo lp">export default App;</span></pre><p id="bac5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">酷，我们可以看到我们的超级秘密信息！但是，我们如何控制对它的访问，要求用户登录才能看到它呢？</p><p id="4e27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们构建我们的隐私高阶组件，它将在呈现我们通过它传递的任何组件之前验证用户是否登录。对我们来说，那将是<code class="fe lq lr ls lg b">&lt;Content /&gt;</code>。因此，让我们在<code class="fe lq lr ls lg b">/src/</code>中创建一个名为HOCs的新文件夹，然后在该文件夹中创建我们的<code class="fe lq lr ls lg b">PrivacyHOC.js</code>文件:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6419" class="lk ll iq lg b gy lm ln l lo lp">#=&gt; cd src<br/>#=&gt; mkdir HOCs<br/>#=&gt; cd HOCs<br/>#=&gt; touch PrivacyHOC.js</span></pre><p id="f4f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了！让我们开始构建高阶组件吧！我们将从设置骨架开始:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="a46f" class="lk ll iq lg b gy lm ln l lo lp">// ./HOCs/PrivacyHOC.js</span><span id="4a85" class="lk ll iq lg b gy lt ln l lo lp">import React from 'react';</span><span id="c0ba" class="lk ll iq lg b gy lt ln l lo lp">export default function PrivacyHOC(WrappedComponent) {<br/>    return (<br/>        class PrivacyHOC extends React.Component {<br/>            render () {<br/>                return &lt;WrappedComponent /&gt;<br/>            }<br/>        }<br/>    )<br/>};</span></pre><p id="2831" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们花一点时间来思考我们正在做的事情。我们的函数<code class="fe lq lr ls lg b">PrivacyHOC</code>将一个组件作为参数。然后，它返回该组件。现在够简单了，对吧？</p><p id="c918" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，我们如何用这个<code class="fe lq lr ls lg b">PrivacyHOC</code>组件包装我们的<code class="fe lq lr ls lg b">Content</code>组件呢？让我们跳回<code class="fe lq lr ls lg b">Content.js</code>，改变我们的出口声明。我们将导出我们的<code class="fe lq lr ls lg b">PrivacyHOC</code>函数，并通过它传递<code class="fe lq lr ls lg b">Content</code>，而不是导出<code class="fe lq lr ls lg b">Content</code>:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="91de" class="lk ll iq lg b gy lm ln l lo lp">// ./components/Content.js</span><span id="a50d" class="lk ll iq lg b gy lt ln l lo lp">import React from 'react';<br/><strong class="lg ir"><em class="lu">import PrivacyHOC from '../HOCs/PrivacyHOC.js'</em></strong></span><span id="5f63" class="lk ll iq lg b gy lt ln l lo lp">class Content extends React.Component {<br/>    render () {<br/>        return (<br/>            &lt;h1&gt;Super Secret Protected Information&lt;/h1&gt;<br/>        )<br/>    }<br/>};</span><span id="1e0e" class="lk ll iq lg b gy lt ln l lo lp"><strong class="lg ir"><em class="lu">export default PrivacyHOC(Content);</em></strong></span></pre><p id="9ece" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">酷！检查浏览器，确保它显示的是超级机密信息！好了，现在我们需要构建一些逻辑，在显示<code class="fe lq lr ls lg b">Content</code>之前查看我们是否登录。让我们考虑一下我们希望如何做到这一点…</p><p id="f410" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，在<code class="fe lq lr ls lg b">App.js</code>中，我们希望用状态中的一个布尔值来跟踪登录状态，然后将它作为道具传递给<code class="fe lq lr ls lg b">Content</code>组件。因为<code class="fe lq lr ls lg b">Content</code>通过<code class="fe lq lr ls lg b">Content</code>的导出语句包装在<code class="fe lq lr ls lg b">PrivacyHOC</code>中，<code class="fe lq lr ls lg b">PrivacyHOC</code>将可以访问传递给<code class="fe lq lr ls lg b">Content</code>的道具。我们可以使用它根据登录状态有条件地呈现<code class="fe lq lr ls lg b">Content</code>。我们可以在以后添加更多的复杂性，但是让我们设置它以确保它能工作:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="aa47" class="lk ll iq lg b gy lm ln l lo lp">// App.js</span><span id="1634" class="lk ll iq lg b gy lt ln l lo lp">import React from 'react';<br/>import './App.css';<br/>import Content from './components/Content.js'</span><span id="8c5d" class="lk ll iq lg b gy lt ln l lo lp">class App extends React.Component {<br/>    <strong class="lg ir"><em class="lu">state = {<br/>        loggedIn : true<br/>    }</em></strong><br/>    render () {<br/>        return (<br/>            &lt;div className="App"&gt;<br/>                &lt;Content <strong class="lg ir"><em class="lu">loggedIn={this.state.loggedIn} </em></strong>/&gt;<br/>            &lt;/div&gt;<br/>        )<br/>    }<br/>};</span><span id="6ee5" class="lk ll iq lg b gy lt ln l lo lp">export default App;</span></pre><p id="6032" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面，我们已经在<code class="fe lq lr ls lg b">App</code>级别将<code class="fe lq lr ls lg b">loggedIn</code>添加到我们的状态中，并将其设置为<code class="fe lq lr ls lg b">true</code>。我们还将该值传递给了<code class="fe lq lr ls lg b">Content</code>(以及随后的<code class="fe lq lr ls lg b">PrivacyHOC</code>)，因此我们可以通过props在那些组件中访问它。让我们在<code class="fe lq lr ls lg b">PrivacyHOC</code>中设置我们的条件渲染:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="9284" class="lk ll iq lg b gy lm ln l lo lp">// ./HOCs/PrivacyHOC.js</span><span id="abd3" class="lk ll iq lg b gy lt ln l lo lp">import React from 'react';</span><span id="16b1" class="lk ll iq lg b gy lt ln l lo lp">export default function PrivacyHOC(WrappedComponent) {<br/>    return (<br/>        class PrivacyHOC extends React.Component {<br/>            <strong class="lg ir"><em class="lu">isLoggedIn = () =&gt; {<br/>                return this.props.loggedIn<br/>            }</em></strong><br/>            render () {<br/>                return <strong class="lg ir"><em class="lu">this.isLoggedIn() ?<br/>                    &lt;WrappedComponent {...this.props} /&gt; :<br/>                    &lt;h1&gt;You must be logged in&lt;/h1&gt;</em></strong><br/>            }<br/>        }<br/>    )<br/>};</span></pre><p id="fe01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面，我们有一个函数，<code class="fe lq lr ls lg b">isLoggedIn</code>，它返回<code class="fe lq lr ls lg b">this.props.loggedIn</code>的值，这个值是从<code class="fe lq lr ls lg b">App</code>的状态传递过来的。在返回组件的呈现中，我们使用了基于<code class="fe lq lr ls lg b">this.isLoggedIn</code>值的三元语句。如果是<code class="fe lq lr ls lg b">true</code>，它将返回并呈现<code class="fe lq lr ls lg b">&lt;WrappedComponent /&gt;</code>，在本例中是<code class="fe lq lr ls lg b">Content</code>。如果是<code class="fe lq lr ls lg b">false</code>，它会告诉我们必须登录。</p><p id="786f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lu">注意，我们把</em> <code class="fe lq lr ls lg b"><em class="lu">{…this.props}</em></code> <em class="lu">加进了我们的</em> <code class="fe lq lr ls lg b"><em class="lu">&lt;WrappedComponent /&gt;</em></code> <em class="lu">。这将传递和传播所有的道具，所以我们可以在组件中访问它们。当我们将一个特设嵌套在另一个特设中时，这一点尤其重要。</em></p><p id="f86b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，因为我们的<code class="fe lq lr ls lg b">App</code>的<code class="fe lq lr ls lg b">state.loggedIn</code>被设置为<code class="fe lq lr ls lg b">true</code>，我们应该看到<code class="fe lq lr ls lg b">Content</code>。请回到您的浏览器进行验证。如果工作正常，将<code class="fe lq lr ls lg b">state.loggedIn</code>改为<code class="fe lq lr ls lg b">false</code>，然后再次检查。它应该告诉我们，我们必须登录。</p><p id="f5f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嘿，你猜怎么着？您刚刚构建并实现了一个高阶组件！我现在很想和你击掌。让我们乘着这股浪潮，把我们的项目建设得更好一些。让我们制作一个按钮来切换我们的登录状态，这样我们就可以实时看到变化。之后，我们将根据内容是从数据库还是从API加载来控制呈现的内容。</p><p id="6304" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从<code class="fe lq lr ls lg b">App.js</code>中的一个按钮开始，这个按钮将切换它的<code class="fe lq lr ls lg b">state.loggedIn</code>布尔值。我们还将在屏幕上显示<code class="fe lq lr ls lg b">state.loggedIn</code>的当前值:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b208" class="lk ll iq lg b gy lm ln l lo lp">// App.js</span><span id="678e" class="lk ll iq lg b gy lt ln l lo lp">import React from 'react';<br/>import './App.css';<br/>import Content from './components/Content.js'</span><span id="3e98" class="lk ll iq lg b gy lt ln l lo lp">class App extends React.Component {<br/>    state = {<br/>        loggedIn : true<br/>    }<br/>    render () {<br/>        return (<br/>            &lt;div className="App"&gt;<br/>                <strong class="lg ir"><em class="lu">{this.state.loggedIn ? &lt;h2&gt;You are logged in!&lt;/h2&gt; : &lt;h2&gt;You are logged out :(&lt;/h2&gt;}<br/>                &lt;button onClick={() =&gt; this.setState({loggedIn : !this.state.loggedIn})}&gt;<br/>                    Toggle Login/Logout<br/>                &lt;/button&gt;</em></strong><br/>                &lt;Content loggedIn={this.state.loggedIn} /&gt;<br/>            &lt;/div&gt;<br/>        )<br/>    }<br/>};</span><span id="b098" class="lk ll iq lg b gy lt ln l lo lp">export default App;</span></pre><p id="d9ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面，我们已经设置了一个三元语句，基于<code class="fe lq lr ls lg b">this.state.loggedIn</code>的值，它将告诉我们已经登录或者已经注销。下面是一个按钮，用于切换<code class="fe lq lr ls lg b">this.state.loggedIn</code>的值。现在，我们可以实时看到我们的<code class="fe lq lr ls lg b">PrivacyHOC</code>如何控制屏幕上显示的内容！</p><p id="3a1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总结一下，现在让我们构建一个<code class="fe lq lr ls lg b">LoaderHOC</code>来根据内容是否被加载来控制呈现的内容。这样，当我们的API或数据库加载和渲染时，我们可以在屏幕上让用户看到一些东西，而不是挂着，冒着用户移动的风险。<code class="fe lq lr ls lg b">LoaderHOC</code>看起来与<code class="fe lq lr ls lg b">PrivacyHOC</code>几乎相同:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="dae1" class="lk ll iq lg b gy lm ln l lo lp">// ./HOCs/LoaderHOC.js</span><span id="c9f8" class="lk ll iq lg b gy lt ln l lo lp">import React from 'react';</span><span id="3042" class="lk ll iq lg b gy lt ln l lo lp">export default function LoaderHOC(WrappedComponent) {<br/>    return (<br/>        class LoaderHOC extends React.Component {<br/>            isLoaded = () =&gt; {<br/>                return this.props.loaded<br/>            }<br/>            render () {<br/>                return this.isLoaded() ? &lt;WrappedComponent {...this.props} /&gt; : &lt;h1&gt;Content loading...&lt;/h1&gt;<br/>            }<br/>        }<br/>    )<br/>}</span></pre><p id="791c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面，就像<code class="fe lq lr ls lg b">PrivacyHOC</code>一样，我们将一个组件作为参数，并使用一个三元组来检查<code class="fe lq lr ls lg b">App</code>的<code class="fe lq lr ls lg b">state.loaded</code>的状态，以显示我们的<code class="fe lq lr ls lg b">Content</code>或显示内容正在加载的消息。</p><p id="fbe5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们在<code class="fe lq lr ls lg b">App.js</code>把这个连接起来:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="97d3" class="lk ll iq lg b gy lm ln l lo lp">// App.js</span><span id="7a95" class="lk ll iq lg b gy lt ln l lo lp">import React from 'react';<br/>import './App.css';<br/>import Content from './components/Content.js'</span><span id="c8ad" class="lk ll iq lg b gy lt ln l lo lp">class App extends React.Component {<br/>    state = {<br/>        loggedIn : true,<br/><strong class="lg ir"><em class="lu">        loaded : false<br/></em></strong>    }<br/>    render () {<br/>        return (<br/>            &lt;div className="App"&gt;<br/>                <strong class="lg ir"><em class="lu">&lt;div&gt;</em></strong><br/>                    {this.state.loggedIn ? &lt;h2&gt;You are logged in!&lt;/h2&gt; : &lt;h2&gt;You are logged out :(&lt;/h2&gt;}<br/>                    &lt;button onClick={() =&gt; this.setState({loggedIn : !this.state.loggedIn})}&gt;<br/>                        Toggle Login/Logout<br/>                    &lt;/button&gt;<br/>                <strong class="lg ir"><em class="lu">&lt;/div&gt;<br/>                &lt;div&gt;<br/>                    {this.state.loaded ? &lt;h2&gt;Content loaded&lt;/h2&gt; : &lt;h2&gt;Content loading...&lt;/h2&gt;}<br/>                    &lt;button onClick={() =&gt; this.setState({loaded : !this.state.loaded})}&gt;<br/>                        Toggle Content Loaded<br/>                    &lt;/button&gt;<br/>                &lt;/div&gt;</em></strong><br/>            &lt;Content loggedIn={this.state.loggedIn} /&gt;<br/>            &lt;/div&gt;<br/>        )<br/>    }<br/>};</span><span id="44f1" class="lk ll iq lg b gy lt ln l lo lp">export default App;</span></pre><p id="f46f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的最后一步是将<code class="fe lq lr ls lg b">LoaderHOC</code>嵌套在<code class="fe lq lr ls lg b">Content.js</code>导出语句的<code class="fe lq lr ls lg b">PrivacyHOC</code>中:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="9ddc" class="lk ll iq lg b gy lm ln l lo lp">// ./components/Content.js</span><span id="a28e" class="lk ll iq lg b gy lt ln l lo lp">import React from 'react';<br/><strong class="lg ir"><em class="lu">import PrivacyHOC from '../HOCs/PrivacyHOC.js'<br/>import LoaderHOC from '../HOCs/LoaderHOC.js'</em></strong></span><span id="9ae0" class="lk ll iq lg b gy lt ln l lo lp">class Content extends React.Component {<br/>    render () {<br/>        return (<br/>            &lt;h1&gt;Super Secret Protected Information&lt;/h1&gt;<br/>        )<br/>    }<br/>};</span><span id="d82e" class="lk ll iq lg b gy lt ln l lo lp"><strong class="lg ir"><em class="lu">export default PrivacyHOC(LoaderHOC(Content));</em></strong></span></pre><p id="9f85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，<code class="fe lq lr ls lg b">PrivacyHOC</code>控制着我们的<code class="fe lq lr ls lg b">Content</code>，不管装没装！相当酷！</p><p id="dedb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着我们的应用程序的增长，我们可以将这些hoc用于任何我们想要的组件——我们所要做的就是将我们的组件通过该组件的导出语句中的hoc！</p><p id="263b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望这能帮助你更好地理解高阶函数，我很想听听你的经验或想法！</p></div></div>    
</body>
</html>