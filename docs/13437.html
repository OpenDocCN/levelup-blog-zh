<html>
<head>
<title>The Art of Writing Beautiful Unit Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写漂亮单元测试的艺术</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/4-rules-for-clean-expressive-and-reliable-unit-tests-d88d5db82b7c?source=collection_archive---------6-----------------------#2022-09-04">https://levelup.gitconnected.com/4-rules-for-clean-expressive-and-reliable-unit-tests-d88d5db82b7c?source=collection_archive---------6-----------------------#2022-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a369" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在本文中，我们将看到创建干净、有表现力和可靠的单元测试是多么简单。</h2></div><h1 id="d9c6" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">概观</h1><p id="7cf8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当每个人都把<em class="lw">干净的代码</em>作为他们简历和LinkedIn个人资料上的主要技能时，没有人提到任何关于需要干净的单元测试的事情。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi lx"><img src="../Images/7570f05e3c48a370beb65807ee9a3b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YdMBP9PlZlxLYpaw"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">干净的单元测试读起来应该像诗歌一样。(<em class="mn">照片由</em><a class="ae mo" href="https://unsplash.com/@alvaroserrano?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">T5】Á阿尔瓦罗塞拉诺 </a> <em class="mn">上</em><a class="ae mo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"><em class="mn">Unsplash</em></a><em class="mn">)</em></figcaption></figure><blockquote class="mp mq mr"><p id="16ff" class="la lb lw lc b ld ms ju lf lg mt jx li mu mv ll lm mw mx lp lq my mz lt lu lv im bi translated">干净的代码简单而直接。干净的代码读起来像写得很好的散文。<br/> - <em class="it">格雷迪·布奇</em></p></blockquote><p id="8b65" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated">每当我听到这个干净代码的定义时，我意识到这正是我们在单元测试中需要的。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h2 id="f1b8" class="nh kj it bd kk ni nj dn ko nk nl dp ks lj nm nn ku ln no np kw lr nq nr ky ns bi translated">代码示例</h2><p id="2888" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于本文中的代码示例，我们将假设我们想要测试Medium的文章推荐服务。</p><p id="4799" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated">我们将有一个<em class="lw"> ArticleController </em>来处理传入的请求，还有一个<em class="lw"> ArticleService — </em>来实现业务用例(在我们的例子中，是文章推荐的逻辑。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nt"><img src="../Images/5ea9e1b49e598a32ba19f622d8052ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mwtg_GqZW8tLJ54CTNR3Dg.png"/></div></div></figure><p id="bce0" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated">代码片段是用Java编写的，但是核心概念可以很容易地应用于任何其他语言。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h2 id="e67e" class="nh kj it bd kk ni nj dn ko nk nl dp ks lj nm nn ku ln no np kw lr nq nr ky ns bi translated">1.测试用例，而不是它的实现</h2><p id="9ab4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">通常，我们会发现单元测试通过模仿所有与之交互的组件来测试一个对象。</p><p id="2a14" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated">在我们的例子中，我们可以想象<em class="lw">服务</em>被一个<em class="lw">测试double </em>或一个<em class="lw">模拟对象</em>替换，并被指示在被调用时返回一个硬编码的值:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nu"><img src="../Images/9c295e9bc8387fb20c3cdf2765cc083f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ECH-XhC5Sw9a6rT2t6C6nw.png"/></div></div></figure><p id="7bcd" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated">老实说，我们到底在测试什么？</p><p id="b3d2" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated">我们真的要写10行样板测试代码来检查一个方法调用吗？</p><p id="e47c" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated">这个问题的解决方案是测试实际的用例。也就是说，对于对科技感兴趣的读者来说，我们想推荐一篇科技文章，如果这是数据库中保存的唯一一篇文章。</p><p id="8aad" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated">测试的范围将会扩大，但是模拟对象的数量将会减少。<strong class="lc iu">理想情况下，我们应该只使用模拟来替换外部依赖，比如数据库和外部HTTP调用。</strong></p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/8be8e4a9cd05b11df88ff2c13825715a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*cK2Utgv-AcgdtQtAVg_qLg.png"/></div></figure><p id="c4f6" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated">根据您希望的测试速度，您可以对数据层、内存数据库或测试容器使用test-double。</p><p id="31bc" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated">让我们选择第一个选项。我们将为数据层手动创建测试副本(在我们的例子中是<em class="lw"> ArticleRepository </em>和<em class="lw">reader repository</em>)——这将把数据保存在内存中的HashMap中。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nw"><img src="../Images/316d7ce6c8bdd689338e504859c2815d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aLrAi4s4TNB04B6EFd1n3Q.png"/></div></div></figure><p id="408d" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated">编写良好的测试的一个巨大优势是，它允许你重构产品代码，同时确保功能保持不变。</p><p id="ac2e" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated">另一方面，包含许多模拟的粒度测试使得源代码更难重构。这是因为开发人员还需要花时间重构测试。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/48038fc5468257a92456e21e4fc3bd40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*dZd_4CP_7R_paPq9U9Imfg.png"/></div></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h2 id="f71f" class="nh kj it bd kk ni nj dn ko nk nl dp ks lj nm nn ku ln no np kw lr nq nr ky ns bi translated">2.单一责任原则</h2><p id="df80" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">尽管增加测试的范围可以帮助我们最小化模拟的使用，但是<em class="lw">单一责任原则</em>同样适用于单元测试。</p><p id="fdb7" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated"><strong class="lc iu">每个用例有一个单独的测试，并保持它们相互隔离，这是非常重要的。</strong></p><p id="bac6" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated">换句话说，当涉及到这些大型测试时，我们必须小心并遵守以下规则:</p><ul class=""><li id="5140" class="ny nz it lc b ld ms lg mt lj oa ln ob lr oc lv od oe of og bi translated">每个测试都有一个对产品代码的调用。</li><li id="4bc9" class="ny nz it lc b ld oh lg oi lj oj ln ok lr ol lv od oe of og bi translated">每个测试都有一个逻辑断言。</li><li id="f211" class="ny nz it lc b ld oh lg oi lj oj ln ok lr ol lv od oe of og bi translated">测试之间没有持续的状态。</li><li id="55dc" class="ny nz it lc b ld oh lg oi lj oj ln ok lr ol lv od oe of og bi translated">代码中的任何错误都应该破坏最少数量的测试。</li></ul><p id="54bf" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated">我写了一篇关于<a class="ae mo" href="https://medium.com/javarevisited/how-solid-are-your-unit-tests-392b437ac310" rel="noopener">单元测试和单一责任原则</a>的专门文章。如果您想更深入地研究这个主题，请随意查看并通读代码片段。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h2 id="26ef" class="nh kj it bd kk ni nj dn ko nk nl dp ks lj nm nn ku ln no np kw lr nq nr ky ns bi translated">3.测试设置的帮助方法</h2><p id="c7c2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们已经可以看到一些改进——我们现在正在测试我们的应用程序的行为！这允许我们在不接触测试的情况下重构产品代码。</p><p id="8906" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated">尽管如此，测试方法仍然有许多样板代码，这使得它们更难理解。</p><p id="fba9" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated">此时，我们可以将测试设置的公共功能提取到小的构建器和帮助器方法中。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi om"><img src="../Images/ec44ffc1a9983f59fa7a06b4c15cc9a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QMRgeIJe_5p4rRgH3mL0xw.png"/></div></div></figure><p id="11ca" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated">结果，单元测试将更具可读性，读者将能够关注实际的用例，而不是测试设置。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi on"><img src="../Images/539655e78f7b94424e6d721be2298b15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VOsAbmbE6OrowxNYIDvrRQ.png"/></div></div></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h2 id="34e2" class="nh kj it bd kk ni nj dn ko nk nl dp ks lj nm nn ku ln no np kw lr nq nr ky ns bi translated">4.自定义断言</h2><p id="2286" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">正如我们之前所讨论的，每个测试都应该有一个逻辑断言。这意味着我们可以很容易地将其提取到一个单独的方法中，并使用一个有意义的名称:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oo"><img src="../Images/360bf9a37f1aaaf7a4ec1c66979b8861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GR-natMKDnWd_12mduDI6A.png"/></div></div></figure><p id="a0ed" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated">结果，我们更加简化了我们的测试。总而言之，我们的测试现在包括:</p><ul class=""><li id="6290" class="ny nz it lc b ld ms lg mt lj oa ln ob lr oc lv od oe of og bi translated">“<em class="lw">给定的</em>”部分——由测试构建器和助手方法组成。</li><li id="bae6" class="ny nz it lc b ld oh lg oi lj oj ln ok lr ol lv od oe of og bi translated">“<em class="lw"> when </em>”部分—调用生产代码的一行程序。</li><li id="4ef7" class="ny nz it lc b ld oh lg oi lj oj ln ok lr ol lv od oe of og bi translated">“<em class="lw"> then </em>”部分—封装单个逻辑断言的自定义断言。</li></ul><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi op"><img src="../Images/a1b6ff1beb06f86433822269ce2346bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6cfgNVoby0Znt16bTYpT7w.png"/></div></div></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h2 id="47ec" class="nh kj it bd kk ni nj dn ko nk nl dp ks lj nm nn ku ln no np kw lr nq nr ky ns bi translated">5.构建小型测试框架</h2><p id="d108" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">最后，让我们为其他场景添加测试。</p><p id="4a8e" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated">出于演示目的，我们将为拥有和不拥有Medium高级会员资格的读者添加测试，并检查他们对“仅限会员”文章的访问:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oq"><img src="../Images/ff1aa866a83b46e54e7dd3dc07e150cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*27x1ca3uXqCKnLA0mm-NBg.png"/></div></div></figure><p id="3c84" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated">我们可以注意到所有的测试都非常容易阅读和理解。</p><p id="0fd4" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated">此外，添加这些测试非常容易，因为我们能够利用所有的测试助手和定制断言。</p><p id="0b7b" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated">总之，通过遵循这些规则，我们最终得到了一个特定于我们业务的小型测试框架。当我们需要检查一些跨多个项目共享的特定于业务的对象和用例时，这可能特别有用。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="0dec" class="ki kj it bd kk kl or kn ko kp os kr ks jz ot ka ku kc ou kd kw kf ov kg ky kz bi translated">分级编码</h1><p id="c661" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="f517" class="ny nz it lc b ld ms lg mt lj oa ln ob lr oc lv od oe of og bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="72ef" class="ny nz it lc b ld oh lg oi lj oj ln ok lr ol lv od oe of og bi translated">📰查看<a class="ae mo" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>中的更多内容</li><li id="0340" class="ny nz it lc b ld oh lg oi lj oj ln ok lr ol lv od oe of og bi translated">🔔关注我们:<a class="ae mo" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae mo" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae mo" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="13f7" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mv ll lm ln mx lp lq lr mz lt lu lv im bi translated">🚀👉<a class="ae mo" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iu">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>