<html>
<head>
<title>Spring Data — Transactional Caveats</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring数据—交易警告</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/spring-data-transactional-caveats-f6edd41d6785?source=collection_archive---------4-----------------------#2021-06-07">https://levelup.gitconnected.com/spring-data-transactional-caveats-f6edd41d6785?source=collection_archive---------4-----------------------#2021-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3569" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Spring是最流行的Java框架。它为web、安全性、缓存和数据访问提供了许多现成的解决方案。Spring Data 尤其让开发者的生活变得更加轻松。我们不必担心数据库连接和事务管理。框架完成了这项工作。但是它对我们隐藏了一些重要的细节，这可能会导致难以追踪的错误和问题。那么，让我们深入探讨一下<code class="fe km kn ko kp b">@Transactional</code>注释。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/9d7a69f5290de91358ee62d9e3d031dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*NQw2Cy575tV1rILoMJAbAQ.png"/></div></figure><h1 id="876f" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">默认回滚行为</h1><p id="16f6" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">假设我们有一个简单的服务方法，在一个事务中创建3个用户。如果出错，它抛出<code class="fe km kn ko kp b">java.util.Exception</code>。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">可能检查到异常的人员服务</figcaption></figure><p id="673b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个简单的单元测试。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">人员服务测试</figcaption></figure><p id="12b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你认为考试会通过吗？逻辑告诉我们，由于一个异常，Spring应该回滚事务。所以，<code class="fe km kn ko kp b">personRepository.count()</code>应该返回0，对吗？不完全是。</p><pre class="kr ks kt ku gt mh kp mi mj aw mk bi"><span id="65a5" class="ml kz iq kp b gy mm mn l mo mp">expected: &lt;0&gt; but was: &lt;2&gt;<br/>Expected :0<br/>Actual   :2</span></pre><p id="280a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这需要一些解释。默认情况下，Spring仅在发生<strong class="jp ir">未检查的</strong>异常时回滚事务。被检查的<strong class="jp ir">和</strong>被视为<strong class="jp ir">可恢复</strong>。在我们的例子中，Spring执行提交而不是回滚。这就是为什么<code class="fe km kn ko kp b">personRepository.count()</code>返回2。</p><p id="6444" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解决这个问题最简单的方法是用一个未检查的异常替换一个已检查的异常(例如，<code class="fe km kn ko kp b">NullPointerException</code>)。或者我们可以使用注释的属性<code class="fe km kn ko kp b">rollbackFor</code>。</p><p id="2d64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，这两种情况都是完全正确的。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">可能存在已检查和未检查例外的人员服务</figcaption></figure><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">人员服务测试</figcaption></figure><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/cfa988f8ee3d2fa622e0dc1d3fdbde0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*cLcrYnj8Mvsvg8T86RvjUA.png"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">试验结果</figcaption></figure><h1 id="f242" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">异常抑制时回滚</h1><p id="f3ef" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">并非所有的异常都必须传播。有时捕捉它并记录相关信息是可以接受的。</p><p id="585c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有另一个<strong class="jp ir">事务性</strong>服务，它检查是否可以用给定的名字创建这个人。如果不是，则抛出<code class="fe km kn ko kp b">IllegalArgumentException</code>。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">PersonValidateService</figcaption></figure><p id="e7d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们给我们的<code class="fe km kn ko kp b">PersonService</code>添加验证。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">带验证的人员服务</figcaption></figure><p id="f219" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果验证没有通过，我们将使用默认名称创建一个新人。</p><p id="a96a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，现在我们需要测试它。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">人员服务测试</figcaption></figure><p id="953d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但结果却颇为出人意料。</p><pre class="kr ks kt ku gt mh kp mi mj aw mk bi"><span id="46ef" class="ml kz iq kp b gy mm mn l mo mp">Unexpected exception thrown: org.springframework.transaction.UnexpectedRollbackException: Transaction silently rolled back because it has been marked as rollback-only</span></pre><p id="2b3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太奇怪了。该异常已被禁止。Spring为什么回滚交易？首先，我们需要了解<code class="fe km kn ko kp b">@Transactional</code>管理方法。</p><p id="f0ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Spring内部使用了<a class="ae kl" href="https://www.baeldung.com/spring-aop" rel="noopener ugc nofollow" target="_blank">面向方面的编程模式</a>。跳过复杂的细节，其背后的思想是用执行所需操作(在我们的例子中是事务管理)的代理来包装对象。所以，当我们注入具有任何<code class="fe km kn ko kp b">@Transactional</code>方法的服务时，实际上Spring放置了代理。</p><p id="9fef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是定义的<code class="fe km kn ko kp b">addPeople</code>方法的工作流程。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/619d105ecba6dd9b1c83d5020301f3e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wMKOakTvbpOfT0QArfEPhg.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">人员服务测试工作流</figcaption></figure><p id="bcf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认的<code class="fe km kn ko kp b">@Transactional</code>传播是<code class="fe km kn ko kp b">REQUIRED</code>。这意味着，如果缺少新事务，就会创建新事务。如果已经存在，则支持当前版本。因此，整个请求在单个事务中执行。</p><p id="7b76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无论如何，有一个警告。如果<code class="fe km kn ko kp b">RuntimeException</code>抛出<em class="mw">事务代理</em>，Spring将当前事务标记为仅回滚。这正是我们的情况。<code class="fe km kn ko kp b">PersonValidateService.validateName</code>摔投<code class="fe km kn ko kp b">IllegalArgumentException</code>。事务代理跟踪它并设置回滚标志。事务期间的后续执行没有任何影响，因为它们最终应该被回滚。</p><p id="e125" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有什么解决办法？有几个一。例如，我们可以给<code class="fe km kn ko kp b">PersonValidateService</code>添加<code class="fe km kn ko kp b">noRollbackFor</code>属性。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">具有“noRollbackFor”属性的PersonValidateService</figcaption></figure><p id="1fcf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一种方法是将事务传播改为<code class="fe km kn ko kp b">REQUIRES_NEW</code>。在这种情况下，<code class="fe km kn ko kp b">PersonValidateService.validateName</code>将在一个单独的事务中执行。因此，父级不会回滚。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">具有“传播”属性的PersonValidateService</figcaption></figure><h1 id="34d0" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">可能的Kotlin问题</h1><p id="414b" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">Kotlin与Java有许多共同之处。但是异常管理却不是这样。</p><p id="c14b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">科特林消除了<em class="mw">已检查</em>和<em class="mw">未检查</em>异常的想法。基本上，语言中的任何异常都是<em class="mw">未检查的</em>，因为我们不需要在方法声明中指定<code class="fe km kn ko kp b">throws SomeException</code>。这个决定的利弊应该是另一个故事的主题。但现在我想向大家展示它可能带来的Spring数据使用问题。</p><p id="cceb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们用Kotlin重写文章的第一个例子<code class="fe km kn ko kp b">java.util.Exception</code>。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">用Kotlin写的PersonService</figcaption></figure><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">用Kotlin编写的PersonServiceTest</figcaption></figure><p id="d874" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试失败，就像在Java中一样。</p><pre class="kr ks kt ku gt mh kp mi mj aw mk bi"><span id="393e" class="ml kz iq kp b gy mm mn l mo mp">expected: &lt;0&gt; but was: &lt;2&gt;<br/>Expected :0<br/>Actual   :2</span></pre><p id="5e65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没有惊喜。Spring在Java或Kotlin中以同样的方式管理事务。但是在Java中，我们不能不小心执行一个抛出<code class="fe km kn ko kp b">java.util.Exception</code>的方法。科特林允许了。这可能会带来意想不到的错误，所以，你应该格外注意这种情况。</p><h1 id="722e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="b424" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">这就是我想告诉你的关于Spring <code class="fe km kn ko kp b">@Transactional</code>注释的全部内容。如果您有任何问题或建议，请在下面留下您的评论。感谢阅读！</p></div></div>    
</body>
</html>