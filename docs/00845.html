<html>
<head>
<title>4 options to prevent extra rerenders with React context</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React上下文防止额外重新呈现的4个选项</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/4-options-to-prevent-extra-rerenders-with-react-context-7b5db8af6539?source=collection_archive---------1-----------------------#2019-08-21">https://levelup.gitconnected.com/4-options-to-prevent-extra-rerenders-with-react-context-7b5db8af6539?source=collection_archive---------1-----------------------#2019-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0f9e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你觉得反应追踪怎么样</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/55249a8dcda7bb32470de5b036995e79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JrmB0JJojkgu-6fj7JCCFA.jpeg"/></div></div></figure><h1 id="70b9" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="f02e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">React <code class="fe mi mj mk ml b">context</code>和<code class="fe mi mj mk ml b">useContext</code>非常得心应手。在开发一个小应用程序时，使用它不会有任何问题。如果你的应用程序变得很大，你可能会遇到一些关于<code class="fe mi mj mk ml b">useContext</code>的性能问题。这是因为<code class="fe mi mj mk ml b">useContext</code>将在上下文值改变时触发rerender。即使渲染中没有使用该值的一部分，也会发生这种情况。这是故意的。如果<code class="fe mi mj mk ml b">useContext</code>有条件地触发重新呈现器，钩子将变得不可组合。</p><p id="4426" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">已经有过几次讨论，特别是在<a class="ae mr" href="https://github.com/facebook/react/issues/14110" rel="noopener ugc nofollow" target="_blank">这一期</a>。目前，React core还没有直接的解决方案。本期中描述了三个选项。</p><p id="ab38" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">这篇文章展示了这三个选项的一个例子，以及另一个名为<a class="ae mr" href="https://github.com/dai-shi/react-tracked" rel="noopener ugc nofollow" target="_blank"> react-tracked </a>的库选项。</p><h1 id="c688" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">基本示例</h1><p id="3496" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">让我们举一个最小的例子:一个带有<code class="fe mi mj mk ml b">firstName</code>和<code class="fe mi mj mk ml b">familyName</code>的person对象。</p><pre class="kj kk kl km gt ms ml mt mu aw mv bi"><span id="4ae0" class="mw kv it ml b gy mx my l mz na">const initialState = {<br/>  firstName: 'Harry',<br/>  familyName: 'Potter',<br/>};</span></pre><p id="ce9b" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">我们定义一个减速器来输入<code class="fe mi mj mk ml b">useReducer</code>。</p><pre class="kj kk kl km gt ms ml mt mu aw mv bi"><span id="1fce" class="mw kv it ml b gy mx my l mz na">const reducer = (state, action) =&gt; {<br/>  switch (action.type) {<br/>    case 'setFirstName':<br/>      return { ...state, firstName: action.firstName };<br/>    case 'setFamilyName':<br/>      return { ...state, familyName: action.familyName };<br/>    default:<br/>      throw new Error('unexpected action type');<br/>  }<br/>};</span></pre><p id="c980" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">我们的上下文提供者如下所示。</p><pre class="kj kk kl km gt ms ml mt mu aw mv bi"><span id="6ff4" class="mw kv it ml b gy mx my l mz na">const NaiveContext = () =&gt; {<br/>  const value = useReducer(reducer, initialState);<br/>  return (<br/>    &lt;PersonContext.Provider value={value}&gt;<br/>      &lt;PersonFirstName /&gt;<br/>      &lt;PersonFamilyName /&gt;<br/>    &lt;/PersonContext.Provider&gt;<br/>  );<br/>};</span></pre><p id="5d9a" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated"><code class="fe mi mj mk ml b">PersonFirstName</code>是这样实现的。</p><pre class="kj kk kl km gt ms ml mt mu aw mv bi"><span id="646c" class="mw kv it ml b gy mx my l mz na">const PersonFirstName = () =&gt; {<br/>  const [state, dispatch] = useContext(PersonContext);<br/>  return (<br/>    &lt;div&gt;<br/>      First Name:<br/>      &lt;input<br/>        value={state.firstName}<br/>        onChange={(event) =&gt; {<br/>          dispatch({ type: 'setFirstName', firstName: event.target.value });<br/>        }}<br/>      /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="6441" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">类似于此，实现了<code class="fe mi mj mk ml b">PersonFamilyName</code>。</p><p id="840a" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">因此，如果<code class="fe mi mj mk ml b">familyName</code>发生变化，<code class="fe mi mj mk ml b">PersonFirstName</code>将重新渲染，产生与之前相同的输出。因为用户不会注意到变化，这不会是一个大问题。但是，当要重新渲染的组件数量很大时，速度可能会变慢。</p><p id="3e15" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">现在，如何解决这个问题？这里有4个选项。</p><h1 id="cd0f" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">选项1:拆分上下文</h1><p id="0e0d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">最可取的选择是拆分上下文。在我们的例子中，它将是这样的。</p><pre class="kj kk kl km gt ms ml mt mu aw mv bi"><span id="6bca" class="mw kv it ml b gy mx my l mz na">const initialState1 = {<br/>  firstName: 'Harry',<br/>};</span><span id="7db9" class="mw kv it ml b gy nb my l mz na">const initialState2 = {<br/>  familyName: 'Potter',<br/>};</span></pre><p id="1d3d" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">我们定义了两个归约器并使用了两个上下文。如果这在你的应用中有意义，在习惯用法React中它总是被推荐。但如果需要让它们保持单一状态，就不能采取这个选项。我们的例子可能是这样，因为它意味着是一个人的对象。</p><h1 id="846d" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">选项2: React.memo</h1><p id="d4e4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">第二种选择是使用<code class="fe mi mj mk ml b">React.memo</code>。我觉得这也是惯用的。</p><p id="4c71" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">我们不改变基本示例中的上下文。<code class="fe mi mj mk ml b">PersonFirstName</code>由两个组件重新实现。</p><pre class="kj kk kl km gt ms ml mt mu aw mv bi"><span id="056f" class="mw kv it ml b gy mx my l mz na">const InnerPersonFirstName = React.memo(({ firstName, dispatch }) =&gt; (<br/>  &lt;div&gt;<br/>    First Name:<br/>    &lt;input<br/>      value={firstName}<br/>      onChange={(event) =&gt; {<br/>        dispatch({ type: 'setFirstName', firstName: event.target.value });<br/>      }}<br/>    /&gt;<br/>  &lt;/div&gt;<br/>);</span><span id="1d93" class="mw kv it ml b gy nb my l mz na">const PersonFirstName = () =&gt; {<br/>  const [state, dispatch] = useContext(PersonContext);<br/>  return &lt;InnerPersonFirstName firstName={state.firstName} dispatch={dispatch} /&gt;;<br/>};</span></pre><p id="2e35" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">当person对象中的<code class="fe mi mj mk ml b">familyName</code>改变时，<code class="fe mi mj mk ml b">PersonFirstName</code>重新渲染。但是，<code class="fe mi mj mk ml b">InnerPersonFirstName</code>没有重新招标，因为<code class="fe mi mj mk ml b">firstName</code>没有改变。</p><p id="24b7" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">所有复杂的逻辑都被移到了<code class="fe mi mj mk ml b">InnerPersonFirstName</code>中，而<code class="fe mi mj mk ml b">PersonFirstName</code>通常是轻量级的。因此，对于这种模式，性能不是问题。</p><h1 id="1036" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">选项3:使用备忘录</h1><p id="32d6" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果<code class="fe mi mj mk ml b">React.memo</code>没有如你所愿，你可以<code class="fe mi mj mk ml b">useMemo</code>作为第三种选择。我个人不会推荐这个。可能会有一些限制。比如不能用钩子。</p><p id="50f7" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated"><code class="fe mi mj mk ml b">PersonFirstName</code>跟<code class="fe mi mj mk ml b">useMemo</code>长这样。</p><pre class="kj kk kl km gt ms ml mt mu aw mv bi"><span id="fcc0" class="mw kv it ml b gy mx my l mz na">const PersonFirstName = () =&gt; {<br/>  const [state, dispatch] = useContext(PersonContext);<br/>  const { firstName } = state;<br/>  return useMemo(() =&gt; {<br/>    return (<br/>      &lt;div&gt;<br/>        First Name:<br/>        &lt;input<br/>          value={firstName}<br/>          onChange={(event) =&gt; {<br/>            dispatch({ type: 'setFirstName', firstName: event.target.value });<br/>          }}<br/>        /&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }, [firstName, dispatch]);<br/>};</span></pre><h1 id="f34c" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">选项4:反应-跟踪</h1><p id="5ef2" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">第四个选择是使用图书馆。</p><div class="nc nd gp gr ne nf"><a href="https://github.com/dai-shi/react-tracked" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">戴式/反应跟踪式</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">如果你正在寻找一个基于Redux的库，请访问…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">github.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt ks nf"/></div></div></a></div><p id="377d" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">有了这个库，我们的提供者看起来会有点不同，如下所示。</p><pre class="kj kk kl km gt ms ml mt mu aw mv bi"><span id="8875" class="mw kv it ml b gy mx my l mz na">const { Provider, useTracked } = createContainer(() =&gt; useReducer(reducer, initialState));</span><span id="0b98" class="mw kv it ml b gy nb my l mz na">const ReactTracked = () =&gt; {<br/>  return (<br/>    &lt;Provider&gt;<br/>      &lt;PersonFirstName /&gt;<br/>      &lt;PersonFamilyName /&gt;<br/>    &lt;/Provider&gt;<br/>  );<br/>};</span></pre><p id="72cc" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated"><code class="fe mi mj mk ml b">PersonFirstName</code>是这样实现的。</p><pre class="kj kk kl km gt ms ml mt mu aw mv bi"><span id="f49f" class="mw kv it ml b gy mx my l mz na">const PersonFirstName = () =&gt; {<br/>  const [state, dispatch] = useTracked();<br/>  return (<br/>    &lt;div&gt;<br/>      First Name:<br/>      &lt;input<br/>        value={state.firstName}<br/>        onChange={(event) =&gt; {<br/>          dispatch({ type: 'setFirstName', firstName: event.target.value });<br/>        }}<br/>      /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="b86b" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">请注意基础示例的变化。只是换了一句台词。</p><pre class="kj kk kl km gt ms ml mt mu aw mv bi"><span id="ebec" class="mw kv it ml b gy mx my l mz na">-  const [state, dispatch] = useContext(PersonContext);<br/>+  const [state, dispatch] = useTracked();</span></pre><p id="b2f9" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">这是如何工作的？由<code class="fe mi mj mk ml b">useTracked()</code>返回的状态被代理包装，并且它的使用被跟踪。这意味着钩子知道在render中只使用了<code class="fe mi mj mk ml b">firstName</code>属性。这允许仅在使用的属性更改时触发rerender。这种毫不费力的优化就是我所说的“状态使用跟踪”</p><h1 id="8aa2" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">什么是状态使用跟踪</h1><p id="063a" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">更多信息，请访问我的其他博客帖子。例如:</p><p id="e038" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated"><a class="ae mr" href="https://blog.axlight.com/posts/what-is-state-usage-tracking-a-novel-approach-to-intuitive-and-performant-api-with-react-hooks-and-proxy/" rel="noopener ugc nofollow" target="_blank">什么是状态使用跟踪？使用React钩子和代理实现直观和高性能全局状态的新方法</a></p><p id="3e47" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">还有一个博客帖子列表。</p><h1 id="59c5" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">完整示例演示</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="3cb6" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated"><a class="ae mr" href="https://github.com/dai-shi/react-tracked/tree/master/examples/08_comparison" rel="noopener ugc nofollow" target="_blank">回购中的源代码</a></p><h1 id="b329" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结束语</h1><p id="55a1" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果你已经看过我以前的一些博客文章，那么这篇文章不会有新的发现。</p><p id="9562" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">我想从别人那里学习更多的编码模式。请让我知道它在你的用例中会是什么样子。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="ac88" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated"><em class="od">原载于2019年8月21日</em><a class="ae mr" href="https://blog.axlight.com/posts/4-options-to-prevent-extra-rerenders-with-react-context/" rel="noopener ugc nofollow" target="_blank"><em class="od">【https://blog.axlight.com】</em></a><em class="od">。</em></p></div></div>    
</body>
</html>