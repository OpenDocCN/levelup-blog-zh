<html>
<head>
<title>Eventual Consistency: What, How, and Why</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最终一致性:什么，如何，为什么</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/eventual-consistency-what-how-and-why-50c942472a0c?source=collection_archive---------1-----------------------#2020-01-06">https://levelup.gitconnected.com/eventual-consistency-what-how-and-why-50c942472a0c?source=collection_archive---------1-----------------------#2020-01-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9a65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">曾经有一个API叫弗雷德。Fred经常收到来自客户端的PUT请求，并将数据插入数据库，然后用id进行回复。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/0b86eb46352d2ea7acc61863dfca3725.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*unKjxNk6gmswjsb-PwkMuA.png"/></div></div></figure><p id="598c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Fred的生活很简单，直到一个新的数据审计服务开始要求Fred接收的任何数据也要进入它。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kx"><img src="../Images/6e771b32efa84389807132b610f3c291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tf35vajugHABylhMHTUSBA.png"/></div></div></figure><p id="fd0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这产生了两个不同的问题。</p><h2 id="9016" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">问题#1</h2><p id="6b64" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">想象一下，将数据插入数据库需要大约<strong class="jp ir"> n </strong>毫秒，这意味着在第一个场景中，发出请求的客户端将需要<strong class="jp ir"> n </strong>来接收id并完成请求。我们还假设请求数据的审计服务花费了大约<strong class="jp ir"> m </strong>毫秒来消耗数据，因此在添加了该服务之后，发出请求的客户端现在需要<strong class="jp ir"> n+m </strong>来完成请求。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lw"><img src="../Images/9257a30facbb7548467f016561b4fdcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7vbVRZFfQIAq5gk7ZlK83g.png"/></div></div></figure><p id="5d0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们正在构建可扩展的架构，随着我们添加更多的服务，这一时间将会不断增加。</p><h2 id="ec88" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">问题#2</h2><p id="3db3" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">现实生活中，有时请求失败的原因有很多:客户端没有准备好，验证失败，请求太多..等等..等等..那么，如果其中一个请求失败了，也就是说，如果数据被插入到数据库中，但是没有到达审计服务，会发生什么呢</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lx"><img src="../Images/7df3eea2fdaadbf0b7c1f1f9ce327c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zrUvDWzUA6Z9hUcLyBfIpg.png"/></div></div></figure><p id="056b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们不能告诉客户端请求失败了，因为它并没有失败，如果我们试图重新插入数据，数据库会抱怨(我们可以通过向上插入来解决这个问题，但我们会违反业务规则)</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><p id="7b80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">两个问题的一个解决方案是<strong class="jp ir">最终一致性</strong>，但是要理解我们需要首先覆盖<strong class="jp ir"> CAP </strong></p><h1 id="976b" class="mf kz iq bd la mg mh mi ld mj mk ml lg mm mn mo lj mp mq mr lm ms mt mu lp mv bi translated">上限原则</h1><p id="1261" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated"><strong class="jp ir"> CAP </strong>代表一致性、可用性和分区阻力。CAP原则指出，不可能构建一个保证一致性、可用性和抵抗分区的分布式系统。任何一个或两个都可以实现，但不能同时实现所有三个。</p><blockquote class="mw mx my"><p id="46f9" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated">一致性意味着所有节点同时看到相同的数据。</p><p id="0a1a" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated">可用性是一种保证，即每个请求都会收到一个关于它是成功还是失败的响应。</p><p id="4ea2" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated">分区容差意味着尽管任意消息丢失或系统的一部分出现故障，系统仍能继续运行。</p></blockquote><p id="d62a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mz">摘自Thomas A. Limoncelli、Strata R. Chalup、Christina J. Hogan所著的《云系统管理实践:Web服务的DevOps和SRE实践，第2卷》</em></p><p id="b773" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终一致性(EC)能够以一致性为代价实现可用性和分区容差，这意味着我们不能保证所有数据接收者都能在同一时间看到数据，但我们可以保证服务始终可用，因为我们能够容忍任何依赖关系失败。</p><p id="525d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们保证:<br/> - <strong class="jp ir"> A </strong>可用性<br/> - <strong class="jp ir"> P </strong>划分容差(也称为失败依赖)<br/>我们不保证:<br/> - <strong class="jp ir"> C </strong>数据存储之间的一致性</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="6d78" class="mf kz iq bd la mg nd mi ld mj ne ml lg mm nf mo lj mp ng mr lm ms nh mu lp mv bi translated">用咖啡解释最终的一致性</h1><p id="4140" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">想象一下，你去一家咖啡店，点了一杯拿铁和一份烤饼。收银员帮你点餐，你付钱，然后等你的咖啡，但你马上拿走了你的烤饼。</p><p id="9dbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你走到下一个窗口等着拿咖啡的时候，你在想刚刚发生了什么:</p><ul class=""><li id="c585" class="ni nj iq jp b jq jr ju jv jy nk kc nl kg nm kk nn no np nq bi translated">收银员可以接受您的订单，并给您一张交易收据</li><li id="a8b4" class="ni nj iq jp b jq nr ju ns jy nt kc nu kg nv kk nn no np nq bi translated">你不知道点餐时浓缩咖啡机是否在工作，但这并不影响你的点餐</li><li id="4307" class="ni nj iq jp b jq nr ju ns jy nt kc nu kg nv kk nn no np nq bi translated">你保证你最终会得到你的咖啡，但是你不知道确切的时间</li></ul><p id="9eac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你的拿铁现已准备好，你拿着它和烤饼一起享用吧。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><p id="e7d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经讨论了为什么，现在让我们讨论它是什么以及如何实现它。</p><h1 id="9ba7" class="mf kz iq bd la mg mh mi ld mj mk ml lg mm mn mo lj mp mq mr lm ms mt mu lp mv bi translated">什么？</h1><p id="3cd2" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">EC将数据传递到一个消息队列，该队列接收消息并将其传递给任何正在侦听的人。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nw"><img src="../Images/f215467640fa9fa8eff66153c0b814e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-3AtJM87zeF53AbijADVmA.png"/></div></div></figure><p id="787a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些消息队列推送到接收方，而另一些队列只保存数据，接收方记录它们所在的消息。</p><p id="bd36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，大多数消息队列的主要特征是，如果接收方出于任何原因没有使用消息，消息队列将继续尝试发送消息，或者接收方将继续尝试使用消息。</p><h1 id="72a3" class="mf kz iq bd la mg mh mi ld mj mk ml lg mm mn mo lj mp mq mr lm ms mt mu lp mv bi translated">怎么做？</h1><p id="e27b" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">使用我们前面的例子，Fred API，我们可以用两种方式实现EC:</p><h2 id="b4a9" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">方式1数据库优先</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nx"><img src="../Images/35a6936d5253308a18d5772c945082cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q8SaUQHDL6w2rAQ-cvlB1Q.png"/></div></div></figure><p id="edcc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该请求仅限于在数据库中插入数据；插入数据后，Fred告诉他的客户数据已经进入，请求到此结束，但数据的旅程并没有结束。数据库触发MQ并向它发送刚收到的数据，审计服务拾取数据并使用它，而不会影响可靠性或完成请求所需的时间。</p><p id="22ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种方法中，我们保证在请求结束时数据已经在数据库中，但是我们不能保证它在消息队列中。</p><h2 id="e86f" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">方式2消息队列优先</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ny"><img src="../Images/4bfb5d54acf55e084af50ee9713b263e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UPHKVdS-wAU7TI9fU7IQng.png"/></div></div></figure><p id="dde7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种方法中，我们保证数据在消息队列中，而不在数据库中。API还负责为新数据创建标识符。</p><p id="68e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果将数据放在消息队列中比放在数据库中更重要，那么可以使用这种方法。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="ed18" class="mf kz iq bd la mg nd mi ld mj ne ml lg mm nf mo lj mp ng mr lm ms nh mu lp mv bi translated">最终一致性的真实例子</h1><p id="7fcd" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">在我的豚鼠应用程序中，我们将宠物的档案数据拆分到不同的DynamoDb表格中。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/5d43b6c616263b481130b8152e4aa936.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HLH3rCRwBIAUS59VqtArKg.png"/></div></div></figure><p id="6f57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mz"> PetProfile </em>表包含该个人资料的摘要，但不是全部数据，即姓名、年龄、性别和一些日志。</p><p id="b416" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mz">宠物</em>表包含较少的关于简档的数据，但是包含该用户宠物的所有名字。</p><p id="2622" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果客户端请求查看用户拥有的所有宠物，我们使用<em class="mz">宠物</em>表，如果客户端请求查看关于特定宠物的摘要数据，那么我们查询<em class="mz">宠物简介</em>表，如果客户端需要更新宠物的年龄，那么我们转到拥有该数据的表，在这种情况下是<em class="mz">宠物简介</em>。</p><p id="5e91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，如果客户端需要添加新的配置文件，则需要将数据存储在两个表中，即使我们可以在单个事务中同时批量更新两个表，我们也不需要<em class="mz">使用</em>，因为<em class="mz"> Pets </em>表不需要在该信息可用时立即知道它，但最终需要知道它，所以我们使用了EC。</p><h2 id="e7ab" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">DynamoDb的最终一致性</h2><p id="be52" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">DynamoDb提供了一个名为Streams的特性，它允许我们触发一个lambda函数，将数据放入另一个表中:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nz"><img src="../Images/855afc5a5d1c2dbd5b3d6fa7ef6b7bfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X1mcDyIlsMcYdiDgnY7IDA.png"/></div></div></figure><p id="cf07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其余的表也是如此，在某些情况下，我们有触发多个函数的流。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oa"><img src="../Images/8b185a48275813681c2124a1a572f426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7LPRzbIkHIsKLSWaO6bd2Q.png"/></div></div></figure><h2 id="6498" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">这张图有什么问题？</h2><p id="d81a" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">正如CAP原理所解释的，我们可以保证服务可用，并且数据将被插入到至少一个表中，但是我们不能保证所有的表在任何时间点都具有相同的数据。在我们的例子中，这是一个可以接受的场景，在一个健康的系统中，客户端不会注意到，因为数据传输几乎是瞬间发生的。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h2 id="dfcc" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">进一步阅读</h2><p id="f84d" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我希望这篇文章简单地解释了什么是最终一致性以及如何使用它，但是我鼓励你在决定EC适合你之前做进一步的阅读:</p><div class="ob oc gp gr od oe"><a href="https://martinfowler.com/articles/microservice-trade-offs.html" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">微服务权衡</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">许多开发团队已经发现微服务架构风格是一种更好的方法</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">martinfowler.com</p></div></div><div class="on l"><div class="oo l op oq or on os kv oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a href="https://programmaticponderings.com/2018/06/17/using-eventual-consistency-%E2%80%A8and-spring-for-kafka-to-manage-a-distributed-data-model-part-1/" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">使用最终一致性和Spring for Kafka管理分布式数据模型:第1部分</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">给定一个由多个微服务组成的现代分布式系统，每个微服务拥有域的子集…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">programmaticponderings.com</p></div></div><div class="on l"><div class="ot l op oq or on os kv oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a href="https://pradeeploganathan.com/patterns/transactional-outbox-pattern/" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">事务发件箱模式-帕拉德普·洛根纳森</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">微服务通常需要发布消息或事件，作为更新数据库的事务的一部分。对于…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">pradeeploganathan.com</p></div></div><div class="on l"><div class="ou l op oq or on os kv oe"/></div></div></a></div></div></div>    
</body>
</html>