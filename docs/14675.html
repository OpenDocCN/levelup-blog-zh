<html>
<head>
<title>Nyx, the Semantic Release Automation Tool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">倪克斯，语义发布自动化工具</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/nyx-the-semantic-release-automation-tool-4e2dfa949f38?source=collection_archive---------3-----------------------#2022-12-16">https://levelup.gitconnected.com/nyx-the-semantic-release-automation-tool-4e2dfa949f38?source=collection_archive---------3-----------------------#2022-12-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a851" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你像我一样，你可能不想重复你自己，你喜欢自动化事情，这样你就可以专注于重要的事情。虽然有大量的工具和方法可以帮助你完成软件生命周期管理中如此多的常见任务，但是发布自动化是它们不足的一个领域。</p><p id="ca73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设您正在维护一个Git存储库(可选地托管在<a class="ae kl" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>、<a class="ae kl" href="https://gitlab.com/" rel="noopener ugc nofollow" target="_blank"> GitLab </a>或其他服务上)，并且已经有了CI/CD(使用<a class="ae kl" href="https://docs.github.com/en/free-pro-team@latest/actions/guides/about-continuous-integration" rel="noopener ugc nofollow" target="_blank"> GitHub动作</a>、<a class="ae kl" href="https://docs.gitlab.com/ee/ci/" rel="noopener ugc nofollow" target="_blank"> GitLab CI </a>、<a class="ae kl" href="https://www.jenkins.io/" rel="noopener ugc nofollow" target="_blank"> Jenkins </a>、<a class="ae kl" href="https://www.jetbrains.com/teamcity/" rel="noopener ugc nofollow" target="_blank"> TeamCity </a>、<a class="ae kl" href="https://www.atlassian.com/software/bamboo" rel="noopener ugc nofollow" target="_blank"> Bamboo </a>、<a class="ae kl" href="https://circleci.com/" rel="noopener ugc nofollow" target="_blank"> CircleCI </a>等)。如果你是一个最佳实践忍者，你可能也已经定义了一个适合你的工作流的分支模型，建立了<a class="ae kl" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank"> SemVer </a>作为你的版本化方案，也采用了一个提交消息约定，比如<a class="ae kl" href="https://www.conventionalcommits.org/" rel="noopener ugc nofollow" target="_blank">常规提交</a>或者甚至定义了你自己的。</p><p id="dbb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您离发布管理天堂只有一步之遥了！总体策略已经很好地定义了，但是当涉及到管理分支、标签、拉/合并请求、变更日志和发布时，你要么手动地做，绞尽脑汁试图不留下任何东西，要么自动地用你缝合在一起的几个工具，用一些定制代码来填补空白。</p><p id="2c02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">倪克斯是一个非常灵活的工具，可以让你把所有的东西放在一起，这样你就可以在自动驾驶上设置发布管理。你可以在GitHub上的这里找到<a class="ae kl" href="https://github.com/mooltiverse/nyx" rel="noopener ugc nofollow" target="_blank">。在这篇文章中，我将向你展示如何在几分钟内开始，不管你的项目堆栈，规模和复杂性。</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/12ddfb9d1e3047cebc18bca05bb42c36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rsDRMKFcsGngr379"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">照片由<a class="ae kl" href="https://unsplash.com/@yancymin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">扬西·敏</a>在<a class="ae kl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="c434" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">背景和免责声明</h1><p id="dda9" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">几年前，我在GitLab  上给<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/semantic-versioning-and-release-automation-on-gitlab-9ba16af0c21">写过一篇关于<em class="mf">语义版本化和发布自动化的类似文章。这个解决方案是基于<a class="ae kl" href="https://github.com/semantic-release/semantic-release" rel="noopener ugc nofollow" target="_blank"> <em class="mf">语义发布</em> </a>的，因为当时它是我发现的最有效的工具。如果您正在进行节点项目，这可能仍然是您的最佳选择。然而，在寻找一个更加便携和简化的解决方案时，它有一些我无法用其他任何方法克服的缺点。</em></a></p><p id="7b3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我决定发布一个全新的工具，它可以大规模用于任何堆栈，易于上手，功能强大，足以应对最微妙的边缘情况。这就是了！所以，如果我是第一个倪克斯迷，不要感到惊讶！</p><p id="8593" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还写了另一篇关于倪克斯的帖子，就像这篇一样，但是使用了Gradle，所以如果你使用Gradle作为你的构建工具，你可能应该直接跳到那篇帖子。</p><p id="a547" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本指南假设:</p><ul class=""><li id="c135" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated"><a class="ae kl" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本化(SemVer) </a>用于版本化。在撰写本文时，这是倪克斯唯一支持的方案，但是将来的版本可能也会支持Maven和定制方案</li><li id="17a3" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">你已经对<strong class="jp ir">提交消息约定</strong>有了基本的了解，这是用于将结构化信息嵌入提交消息并自动读取它们的模式。如果您不这样做，那么<a class="ae kl" href="https://www.conventionalcommits.org/" rel="noopener ugc nofollow" target="_blank">常规提交</a>(也称为<em class="mf">角度约定</em>)是一个很好的起点，它是开箱即用的，尽管您甚至可以自由配置自定义约定</li><li id="ba88" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">你知道什么是分支模型。如果你没有，你可以从<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/best-practice/branching-models/" rel="noopener ugc nofollow" target="_blank">这里</a>开始，这里也涵盖了标准模型，如<a class="ae kl" href="https://nvie.com/posts/a-successful-git-branching-model/" rel="noopener ugc nofollow" target="_blank"> GitFlow </a>、<a class="ae kl" href="https://www.endoflineblog.com/oneflow-a-git-branching-model-and-workflow" rel="noopener ugc nofollow" target="_blank"> OneFlow </a>或<a class="ae kl" href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/github-flow" rel="noopener ugc nofollow" target="_blank"> GitHubFlow </a>和<a class="ae kl" href="https://docs.gitlab.com/ee/topics/gitlab_flow.html" rel="noopener ugc nofollow" target="_blank"> GitLabFlow </a></li><li id="e0f2" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">你对<a class="ae kl" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> Git </a>、<a class="ae kl" href="https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell" rel="noopener ugc nofollow" target="_blank">branch</a>和<a class="ae kl" href="https://git-scm.com/book/en/v2/Git-Basics-Tagging" rel="noopener ugc nofollow" target="_blank">tag</a>很有信心。您可以选择适当的CI/CD环境，虽然倪克斯并不受限于任何环境，但是提供了关于<a class="ae kl" href="https://docs.github.com/en/free-pro-team@latest/actions/guides/about-continuous-integration" rel="noopener ugc nofollow" target="_blank"> GitHub动作</a>和<a class="ae kl" href="https://docs.gitlab.com/ee/ci/" rel="noopener ugc nofollow" target="_blank"> GitLab CI </a>的示例</li></ul></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="2c87" class="lc ld iq bd le lf nb lh li lj nc ll lm ln nd lp lq lr ne lt lu lv nf lx ly lz bi translated">倪克斯是如何运作的</h1><p id="99e6" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">倪克斯<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/how-nyx-works/" rel="noopener ugc nofollow" target="_blank">将整个发布过程分成几个步骤</a>，你可以一起运行，也可以通过不同的命令一个接一个地运行。步骤是:<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/how-nyx-works/#infer" rel="noopener ugc nofollow" target="_blank"> <em class="mf">推断</em> </a>，<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/how-nyx-works/#make" rel="noopener ugc nofollow" target="_blank"> <em class="mf">制作</em> </a>，<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/how-nyx-works/#mark" rel="noopener ugc nofollow" target="_blank"> <em class="mf">标记</em> </a>，<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/how-nyx-works/#publish" rel="noopener ugc nofollow" target="_blank"> <em class="mf">发布</em> </a>，它们都是可选的，但它们有连锁依赖:<em class="mf">发布&gt;标记&gt;制作&gt;推断</em>，所以可以单独运行<em class="mf">推断</em>而<em class="mf">制作</em>依赖于<em class="mf"/></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/b662f9f8335eaef84cb0485b90ee4e19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*hRfRL-EE146Dk6wY7dXV1Q.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">倪克斯台阶</figcaption></figure><p id="43ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mf">推断</em>是第一步也是最重要的一步，它读取Git提交历史来设置项目<strong class="jp ir">版本</strong>，该版本可能是新版本(如果有<strong class="jp ir">重大</strong>变更要发布)或之前的版本(如果没有遇到重大变更)。换句话说:您总是有正确的<strong class="jp ir">版本</strong>设置，无论是以前的版本还是新版本。先前的<strong class="jp ir">版本</strong>从Git标签中读取，如果必须生成新的版本，则通过<strong class="jp ir">在先前版本上碰撞</strong>正确的标识符来计算。结果是<a class="ae kl" href="https://docs.gradle.org/current/userguide/writing_build_scripts.html#sec:standard_project_properties" rel="noopener ugc nofollow" target="_blank">项目<strong class="jp ir">版本</strong>属性</a>设置为正确的值。<em class="mf">推断</em>到此为止，不采取进一步的行动，但是你的外部脚本现在可以出于任何目的使用项目<strong class="jp ir">版本</strong>。</p><p id="77a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值得注意的是，许多其他工具只在整个过程结束时给你<strong class="jp ir">版本</strong>，从构建脚本的角度来看，它基本上是无用的(甚至在工件已经被推送到存储库之后)，所以你不能截取<strong class="jp ir">版本</strong>供你的定制任务使用(例如，将它嵌入到文档或其他文件中)。使用这些工具，你甚至不能在中间添加任何验证，因此一旦你运行发布任务，你就没有其他机会来控制将要发布的内容。有些工具甚至更糟糕，因为你甚至不知道他们是否会给你一个<strong class="jp ir">版本</strong>来使用(比如当没有新的变化时)，所以你最终运行它们两次:第一次作为<em class="mf">抽测</em>，只是为了看看是否有新版本可用，第二次(你需要有条件地运行)是为了实际使用它。</p><p id="7ff0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，有了倪克斯，你可以自由地运行<em class="mf">推断</em>，在任何你需要的地方使用<strong class="jp ir">版本</strong>号，甚至使用它的内部发现来定制整个过程。你<strong class="jp ir">总有一个版本</strong>，可能是以前的，也可能是新的。即使你不需要发布一个新的版本，你也有一个可以在内部使用的版本(例如用于测试)。</p><p id="1ce6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mf"> Make </em>是使用来自release范围的信息，通过渲染一个可定制的<a class="ae kl" href="https://handlebarsjs.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">手柄</strong> </a> <strong class="jp ir"> </strong>模板，生成一个<strong class="jp ir"> changelog </strong>的步骤。</p><p id="fbf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mf">标记</em>可以有选择地<strong class="jp ir">提交</strong>未决的变更(即，如果你想在密封它之前将changelog文件添加到你的发布版本中)，<strong class="jp ir">用新的发布版本名称标记</strong>最新的提交，<strong class="jp ir">将</strong>变更推送到远程存储库。</p><p id="7bf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mf">发布</em>可以最终发布新版本给远程服务(即<a class="ae kl" href="https://docs.github.com/en/github/administering-a-repository/about-releases" rel="noopener ugc nofollow" target="_blank"> GitHub发布</a>，<a class="ae kl" href="https://docs.gitlab.com/ee/user/project/releases/" rel="noopener ugc nofollow" target="_blank"> GitLab发布</a>)使其对观众可用。<em class="mf"> Make </em>生成的changelog也可以作为发布<strong class="jp ir">描述</strong>。</p><p id="0687" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过这些粒度任务，您可以构建任何<strong class="jp ir">增量</strong>发布流程，而不会失去一致性，即使暂停流程并在以后的任何时间恢复。在构建脚本的最开始运行<em class="mf">推断</em>之后，您可以将<strong class="jp ir">版本</strong>和其他发现用于任何其他任务，然后，如果您愿意，您可以使用<em class="mf">标记</em>和<em class="mf">发布</em>来完成发布。</p><p id="2728" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这要归功于倪克斯揭露的另一个非常强大的特性:状态<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/state-reference/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"/></a>对象。<strong class="jp ir">状态</strong>是倪克斯存储其所有内部信息的地方，也可供您阅读其关于发布范围和解析配置值的详细信息。所有上述任务都会创建和更新<strong class="jp ir">状态</strong>。</p><h1 id="0757" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">开始</h1><p id="3fab" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">倪克斯二进制文件可用于任何平台，并且可以从最新发布页面下载。选择一个符合你的平台的并下载到本地。</p><p id="bd9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本指南的其余部分假设您正在Linux上运行，倪克斯可执行文件已经被重命名为<code class="fe nh ni nj nk b">nyx</code>(没有平台名称)，并且该可执行文件在系统<code class="fe nh ni nj nk b">PATH</code>中可用。</p><p id="2a1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑到<strong class="jp ir">所有的</strong>配置选项都可以通过<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/configuration-methods/" rel="noopener ugc nofollow" target="_blank">不同的方式</a>来定义，包括配置文件(甚至是两者的组合，都是<code class="fe nh ni nj nk b">.json</code>或<code class="fe nh ni nj nk b">.yaml</code>)、命令行参数和环境变量。在本指南中，我们将混合使用命令行参数和配置文件。</p><p id="6f9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，打开一个shell，进入Git项目文件夹，然后运行:</p><pre class="kn ko kp kq gt nl nk nm bn nn no bi"><span id="a123" class="np ld iq nk b be nq nr l ns nt">$ nyx --info<br/>Version: '1.3.0'</span></pre><p id="c8e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以安全地运行上面的命令，因为它不会改变您的存储库中的任何东西。这是因为默认情况下只有<em class="mf">推断</em>命令被执行，事实上上述命令相当于:</p><pre class="kn ko kp kq gt nl nk nm bn nn no bi"><span id="9ee8" class="np ld iq nk b be nq nr l ns nt">$ nyx --info infer<br/>Version: '1.3.0'</span></pre><p id="975f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你准备好了，你可以用其他命令代替<code class="fe nh ni nj nk b">infer</code>来运行倪克斯，比如<code class="fe nh ni nj nk b">make</code>、<code class="fe nh ni nj nk b">mark</code>和<code class="fe nh ni nj nk b">publish</code>，所有这些都在上面描述过。</p><p id="3053" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nh ni nj nk b">--info</code>选项只增加了输出的详细程度，以查看倪克斯从存储库中推断出的版本(在本例中是1.3.0)。</p><p id="68c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在像这样再运行一次:</p><pre class="kn ko kp kq gt nl nk nm bn nn no bi"><span id="1009" class="np ld iq nk b be nq nr l ns nt">$ nyx --state-file=nyx-state.json</span></pre><p id="1638" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在没有控制台输出，因为我们使用默认的详细度，但是已经创建了一个新的<code class="fe nh ni nj nk b">nyx-state.json</code>文件，包含关于Git存储库发现的结构化信息。如果您使用<code class="fe nh ni nj nk b">.yaml</code>扩展名，内容输出将变为YAML格式。</p><p id="224b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">状态文件记录在这里<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/state-reference/" rel="noopener ugc nofollow" target="_blank">如果你看一下它的内容，你会发现里面有大量的信息。您可以使用该文件中的内容以结构化的方式(即，从其他工具和脚本)访问存储库中的所有发现。</a></p><p id="6d4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们继续之前，考虑运行<code class="fe nh ni nj nk b">nyx --help</code>来获得完整的概要，或者看一看<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/" rel="noopener ugc nofollow" target="_blank">配置参考</a>。</p><h1 id="9d36" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">使用预设进行配置</h1><p id="4a96" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">先说一个巨大的省时器:<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-presets/" rel="noopener ugc nofollow" target="_blank">配置<strong class="jp ir">预置</strong> </a>。不要将预设与默认混淆，因为它们是相当精简的工作配置，您可以开箱即用或作为基线使用，您可以覆盖任何选项以更好地满足您的需求。</p><p id="0ad2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看它们有多强大和简单，从Git repository文件夹中一个名为<code class="fe nh ni nj nk b">.nyx.json</code>的简单配置文件开始。该文件名默认由倪克斯加载，但您可以使用<code class="fe nh ni nj nk b"><a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/global-options/#configuration-file" rel="noopener ugc nofollow" target="_blank">--configuration-file</a></code> <a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/global-options/#configuration-file" rel="noopener ugc nofollow" target="_blank">命令行参数</a>更改文件名和路径。同样，将扩展名改为<code class="fe nh ni nj nk b">.yaml</code>允许您用YAML而不是JSON编写配置。</p><p id="5156" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-presets/extended/" rel="noopener ugc nofollow" target="_blank"> <em class="mf">扩展</em> </a>预置使<code class="fe nh ni nj nk b">.nyx.json</code>文件看起来像这样:</p><pre class="kn ko kp kq gt nl nk nm bn nn no bi"><span id="9c49" class="np ld iq nk b be nq nr l ns nt">{<br/>  "preset":"extended"<br/>}</span></pre><p id="ce35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就这么简单！<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-presets/extended/" rel="noopener ugc nofollow" target="_blank"> <em class="mf">扩展</em> </a>预置并不是唯一可用的预置，但它可以让您体验一下只需一行配置就能得到的东西:</p><ul class=""><li id="390f" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">配置两个<strong class="jp ir">提交消息约定</strong>:<a class="ae kl" href="https://www.conventionalcommits.org/" rel="noopener ugc nofollow" target="_blank"><em class="mf">常规提交</em> </a>和<a class="ae kl" href="https://gitmoji.dev/" rel="noopener ugc nofollow" target="_blank"> <em class="mf"> gitmoji </em> </a>。<em class="mf">常规提交</em>具有优先级，因此只有当<em class="mf">常规提交</em>不匹配提交时，倪克斯才会尝试将提交与<em class="mf"> gitmoji </em>进行匹配。当提交与约定匹配时，它们的<strong class="jp ir">类型</strong>被推断出来，以将它们分类到变更日志的不同部分，并且如果需要的话，还确定哪个版本标识符应该被<strong class="jp ir">碰撞</strong>以生成新的<strong class="jp ir">版本</strong>。只有那些应该<strong class="jp ir">碰撞</strong>版本标识符的提交被认为是<strong class="jp ir">重要的</strong></li><li id="5631" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">八个<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">发布类型</strong> </a>，涵盖了广泛的<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/best-practice/branching-models/" rel="noopener ugc nofollow" target="_blank">分支模型</a>，包括:<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/best-practice/branching-models/#mainline" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mf">主线</em></strong></a><em class="mf">正式</em>或<em class="mf">常规</em>发布从<em class="mf">主</em>或<em class="mf">主</em>分支仅使用<em class="mf">核心</em>版本标识符如<em class="mf">x . y . z</em>；<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/best-practice/branching-models/#integration-branches" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mf">集成</em> </strong> </a>和<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/best-practice/branching-models/#maturity-branches" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="mf"/></strong></a>(又名<em class="mf">预览版</em>发布，从<em class="mf">开发</em>，<em class="mf">开发</em>，<em class="mf">集成</em>，<em class="mf">最新，alpha </em>，<em class="mf"> beta </em>等分支使用<strong class="jp ir">预发布</strong> <em class="mf">特性/XXX </em>、<em class="mf">修复/XXX </em>、<em class="mf">热修复/XXX </em>分支)、<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/best-practice/branching-models/#maintenance-branches" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mf">维护</em> </strong> </a>(又名<em class="mf">后期发布</em>)和<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/best-practice/branching-models/#release-branches" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mf">发布</em> </strong> </a>(来自<em class="mf"> x.y.z </em></li><li id="6d5e" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">两个<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/services/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">服务</strong> </a> (GitHub和GitLab)，它们可以分别从<code class="fe nh ni nj nk b">GITHUB_TOKEN</code>和<code class="fe nh ni nj nk b">GITLAB_TOKEN</code>环境变量中读取认证令牌(如个人访问令牌),以备不时之需</li><li id="e32a" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe nh ni nj nk b">CHANGELOG.md</code>文件在项目根目录下生成，每个版本有四个部分:<em class="mf">添加</em>，<em class="mf">修复</em>，<em class="mf">删除</em>，<em class="mf">安全</em>，每个部分收集特定<strong class="jp ir">类型的提交</strong></li></ul><p id="f667" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于像这样的帖子来说，详细描述这一切太多了，但是你仍然可以跳到<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/" rel="noopener ugc nofollow" target="_blank">配置参考</a>或者看下面的更多内容。尽管如此，我们还是可以概述一些事情:</p><ul class=""><li id="156f" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">如果产生了一个新的版本，与该版本匹配的<strong class="jp ir">发布类型</strong>是您可以配置是否必须执行Git操作的地方，比如提交新的变更、标记和推送到远程</li><li id="f84e" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">如果想知道是否支持版本<strong class="jp ir">前缀</strong>(即<strong class="jp ir"><em class="mf">v</em></strong><em class="mf">1 . 2 . 3</em>或<strong class="jp ir"><em class="mf">rel</em></strong><em class="mf">1 . 2 . 3</em>而不是简单的<em class="mf"> 1.2.3 </em>)答案是<strong class="jp ir">是</strong>，请参见<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/global-options/" rel="noopener ugc nofollow" target="_blank">参考文献</a></li><li id="bd39" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">一些发布类型被配置为版本号的线性增加(如<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/best-practice/branching-models/#mainline" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mf">【主线】</em> </strong> </a>，仅使用<em class="mf">核心</em>版本标识符，如<em class="mf"> x.y.z </em>)而其他的(如<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/best-practice/branching-models/#integration-branches" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mf">集成</em> </strong> </a>和<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/best-practice/branching-models/#maturity-branches" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mf">成熟度</em> </strong> </a>，使用额外的标识符，如<em class="mf"> x.y.z-prerelease.n </em></li><li id="4e8e" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><strong class="jp ir">内部</strong>发布类型并不意味着应用任何标签或被发布，但仍然会为您生成一个<strong class="jp ir">版本</strong>号(带有额外的标识符以使其明确，如<em class="mf">x . y . z-internal . n-timestamp . 20220101</em>)来完成构建。对于内部发布，您应该总是有一个后备发布类型(它实际上并不发布或推送任何东西，但是即使在这种情况下也能保持您的构建过程的一致性)</li><li id="19ae" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">倪克斯没有预定义的发布类型集(像<em class="mf">标准</em>、<em class="mf">预发布</em>、<em class="mf">维护</em>)，每一个都可以从头开始完全配置，给你完全的选择自由。这同样适用于您可以完全配置的分支名称</li><li id="84d9" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">当使用<strong class="jp ir">额外标识符</strong>(即预发行版)时，您可以定义任意多个，可选地为它们分配动态值(或使用自动增量)，并且不限于一个</li></ul><h2 id="247c" class="nu ld iq bd le nv nw dn li nx ny dp lm jy nz oa lq kc ob oc lu kg od oe ly of bi translated">覆盖预设值</h2><p id="1d7a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">如果一个预置<strong class="jp ir">几乎</strong>是你需要的，但不是完美的契合，那该怎么办？别担心，你不需要放弃预置，写一个全新的配置。您可以从预设开始，<strong class="jp ir">覆盖</strong>您需要的值。让我向您展示这个经过修改的版本的<code class="fe nh ni nj nk b">.nyx.json</code>文件，其中有一些改动:</p><pre class="kn ko kp kq gt nl nk nm bn nn no bi"><span id="3cfe" class="np ld iq nk b be nq nr l ns nt">{<br/>  "preset":"extended"<br/>  "changelog":{<br/>    "path":"build/CHANGELOG.md"<br/>  },<br/>  "releaseTypes":{<br/>    "publicationServices":[<br/>      "github"<br/>    ],<br/>    "items":{<br/>      "mainline":{<br/>        ...<br/>        "description": "{{#fileContent}}build/CHANGELOG.md{{/fileContent}}"<br/>        "gitCommit":"true"<br/>      }<br/>    }<br/>  },<br/>  "services":{<br/>    "github": {<br/>      "type": "GITHUB",<br/>      "options": {<br/>        "AUTHENTICATION_TOKEN": "{{#environmentVariable}}GH_TOKEN{{/environmentVariable}}",<br/>        "REPOSITORY_NAME": "myrepo",<br/>        "REPOSITORY_OWNER": "jdoe"<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="dd43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，我们仍在使用<em class="mf">扩展</em>预设，但这里的其他选项具有优先权，因此它们可以<strong class="jp ir">添加新选项</strong>或<strong class="jp ir">覆盖现有选项</strong>。</p><p id="3894" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个备注:当使用多种配置方法或定制预置时，复杂的配置选项(例如<code class="fe nh ni nj nk b">commitMessageConventions</code>、<code class="fe nh ni nj nk b">releaseTypes</code>、<code class="fe nh ni nj nk b">services</code>)必须整体继承或覆盖。这种类型的配置选项不支持覆盖单个值和继承其他值，因此当它们在一个配置级别重新声明时，所有从优先级较低的配置方法继承的值(包括预设)都将被抑制。</p><p id="92d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们改变了变更日志的目标文件，现在是<code class="fe nh ni nj nk b">build/CHANGELOG.md</code>而不是<code class="fe nh ni nj nk b">CHANGELOG.md</code>。</p><p id="97c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们覆盖<em class="mf">主线</em>发布类型，在新版本的情况下启用挂起变更的git提交(<code class="fe nh ni nj nk b">"gitCommit" = "true"</code>)，并使用将发布到<a class="ae kl" href="https://docs.github.com/en/github/administering-a-repository/about-releases" rel="noopener ugc nofollow" target="_blank"> GitHub发布</a>的发布<strong class="jp ir">描述</strong>的变更日志文件的内容。如果我们想发布到<a class="ae kl" href="https://docs.gitlab.com/ee/user/project/releases/" rel="noopener ugc nofollow" target="_blank"> GitLab Releases </a>我们可以这样:</p><pre class="kn ko kp kq gt nl nk nm bn nn no bi"><span id="a2a5" class="np ld iq nk b be nq nr l ns nt">{<br/>  "preset":"extended"<br/>  "changelog":{<br/>    "path":"build/CHANGELOG.md"<br/>  },<br/>  "releaseTypes":{<br/>    "publicationServices":[<br/>      "gitlab"<br/>    ],<br/>    "items":{<br/>      "mainline":{<br/>        ...<br/>        "description": "{{#fileContent}}build/CHANGELOG.md{{/fileContent}}"<br/>        "gitCommit":"true"<br/>      }<br/>    }<br/>  },<br/>  "services":{<br/>    "gitlab": {<br/>      "type": "GITLAB",<br/>      "options": {<br/>        "AUTHENTICATION_TOKEN": "{{#environmentVariable}}GL_TOKEN{{/environmentVariable}}",<br/>        "REPOSITORY_NAME": "myrepo",<br/>        "REPOSITORY_OWNER": "jdoe"<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="a6a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还记得上面预置配置的两个服务(GitHub和GitLab)吗？在那个阶段，他们是助手，但是他们还不活跃(这是服务特有的)，所以为了实际发布版本，我们使用<code class="fe nh ni nj nk b">"publicationServices": [ "github" ]</code>或<code class="fe nh ni nj nk b">"publicationServices": [ "gitlab" ]</code>来启用服务。</p><p id="16b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，在<code class="fe nh ni nj nk b">services.github</code>或<code class="fe nh ni nj nk b">services.gitlab</code>部分中，我们设置存储库名称(<code class="fe nh ni nj nk b">myrepo</code>和所有者(<code class="fe nh ni nj nk b">jdoe</code>)并更改环境变量的名称以从(<code class="fe nh ni nj nk b">GH_TOKEN</code>或<code class="fe nh ni nj nk b">GL_TOKEN</code>)读取安全令牌。不管您为变量使用什么名称，需要注意的重要一点是，您可以<strong class="jp ir">避免将您的凭证</strong>硬编码到配置文件中，相反，您可以从环境中动态地读取它们，在那里您可以将它们存储为<strong class="jp ir">机密</strong>，您可以将它们配置为本地环境变量或CI/CD平台。</p><p id="df58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在GitHub上，你可以使用<a class="ae kl" href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token" rel="noopener ugc nofollow" target="_blank">这些指令</a>创建一个新的个人访问令牌，然后将它作为一个环境变量作为一个<a class="ae kl" href="https://docs.github.com/en/actions/security-guides/encrypted-secrets" rel="noopener ugc nofollow" target="_blank">加密的秘密</a>提供给你的CI/CD管道。更简单的是(但是只在CI/CD环境下工作)，您可以只使用自动生成的<code class="fe nh ni nj nk b"><a class="ae kl" href="https://docs.github.com/en/actions/learn-github-actions/contexts#secrets-context" rel="noopener ugc nofollow" target="_blank">secrets</a>.GITHUB_TOKEN</code>，仍然来自<code class="fe nh ni nj nk b"><a class="ae kl" href="https://docs.github.com/en/actions/learn-github-actions/contexts#secrets-context" rel="noopener ugc nofollow" target="_blank">secrets</a></code> <a class="ae kl" href="https://docs.github.com/en/actions/learn-github-actions/contexts#secrets-context" rel="noopener ugc nofollow" target="_blank">上下文</a>。</p><p id="5868" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在GitLab上，您可以使用这些指令创建一个新的个人访问令牌，然后将它作为一个<a class="ae kl" href="https://docs.gitlab.com/ee/ci/variables/index.html" rel="noopener ugc nofollow" target="_blank">环境变量</a>提供给CI/CD管道。</p><p id="1d39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不管平台如何，确保您使用的令牌有足够的权限来执行您需要的操作(比如发布版本)。</p><h2 id="3b03" class="nu ld iq bd le nv nw dn li nx ny dp lm jy nz oa lq kc ob oc lu kg od oe ly of bi translated">模板</h2><p id="717d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">想知道发布版<code class="fe nh ni nj nk b">description</code>和<code class="fe nh ni nj nk b">AUTHENTICATION_TOKEN</code>的语法是什么吗？那些是<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/templates/" rel="noopener ugc nofollow" target="_blank">胡子模板</a>。您可以将其用于许多配置选项，以使您的配置<strong class="jp ir">动态</strong>和<strong class="jp ir">自适应</strong>。</p><p id="b49f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">倪克斯提供了一个<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/templates/#the-functions-library" rel="noopener ugc nofollow" target="_blank">函数库</a> (Mustache lambdas)供你在渲染内容(如变更日志)或读取值(如配置)时使用，这让你释放出很多额外的能力。</p><p id="6b64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只要允许使用模板，您仍然可以硬编码简单的值，但是使用这些函数通常会在安全性和灵活性方面给您带来额外的价值。</p><h2 id="9367" class="nu ld iq bd le nv nw dn li nx ny dp lm jy nz oa lq kc ob oc lu kg od oe ly of bi translated">Git远程凭据</h2><p id="986f" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">如果您的任何发布类型被配置为<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#git-push" rel="noopener ugc nofollow" target="_blank">将</a>本地变更推送到远程存储库(有些在<em class="mf">扩展</em>预置do中),并且您的远程存储库是写保护的，您需要将您的凭证传递到倪克斯，如下面的配置片段所示:</p><pre class="kn ko kp kq gt nl nk nm bn nn no bi"><span id="235d" class="np ld iq nk b be nq nr l ns nt">{<br/>  "git":{<br/>    "remotes":{<br/>      "origin":{<br/>        "user":"jdoe",<br/>        "password":"{{#environmentVariable}}PAT{{/environmentVariable}}"<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="82ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本例中，我们为<code class="fe nh ni nj nk b">origin</code>远程存储库配置凭证，将<code class="fe nh ni nj nk b">jdoe</code>硬编码为用户名，并从<code class="fe nh ni nj nk b">PAT</code>环境变量中读取密码。</p><p id="ad92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于Git API的工作方式，即使使用OAuth或个人访问令牌，也总是需要同时传递<code class="fe nh ni nj nk b">user</code>和<code class="fe nh ni nj nk b">password</code>。但是，根据目标服务的不同，您可能需要以不同的方式传递它们:</p><ul class=""><li id="2ee0" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">当配置GitHub远程存储库时，将令牌作为名称<code class="fe nh ni nj nk b">user</code>传递，将空字符串作为名称<code class="fe nh ni nj nk b">password</code></li><li id="db53" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">当配置GitLab远程存储库时，传递固定字符串<code class="fe nh ni nj nk b">PRIVATE-TOKEN</code>作为<code class="fe nh ni nj nk b">user</code>名称，传递令牌作为<code class="fe nh ni nj nk b">password</code></li></ul><h1 id="4ffd" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">该跑了</h1><p id="4524" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">准备好了吗？让我们运行这个！你还不自信吗？您仍然可以使用<code class="fe nh ni nj nk b"><a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/global-options/#dry-run" rel="noopener ugc nofollow" target="_blank">dryRun</a></code>标志，这样倪克斯就不会改变您环境中的任何东西。</p><p id="5b2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有大量的例子来展示倪克斯基于分支和发布类型的行为，但是无论如何让我们在这里做一个简单的介绍。</p><p id="c2ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设您正在<code class="fe nh ni nj nk b">main</code>或<code class="fe nh ni nj nk b">master</code>分支中运行构建脚本，其中您有一个标记为<code class="fe nh ni nj nk b">2.3.4</code>的先前提交和此后的其他提交，表明<code class="fe nh ni nj nk b">minor</code>和<code class="fe nh ni nj nk b">patch</code>标识符都必须被碰撞(根据<a class="ae kl" href="https://www.conventionalcommits.org/" rel="noopener ugc nofollow" target="_blank">常规提交</a>):</p><pre class="kn ko kp kq gt nl nk nm bn nn no bi"><span id="62a3" class="np ld iq nk b be nq nr l ns nt">$ nyx --info<br/>Version: '2.4.0'</span></pre><p id="75e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">生成版本<code class="fe nh ni nj nk b">2.4.0</code>是因为<code class="fe nh ni nj nk b">minor</code>标识符比<code class="fe nh ni nj nk b">patch</code>更重要。如果没有发现重要的提交，仍然使用先前标签的版本<code class="fe nh ni nj nk b">2.3.4</code>。</p><p id="2e46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们在刚刚从<code class="fe nh ni nj nk b">main</code>分支创建的<code class="fe nh ni nj nk b">alpha</code>分支中运行，其中<code class="fe nh ni nj nk b">2.3.4</code>是前一次提交的标签，然后我们添加了其他提交来碰撞<code class="fe nh ni nj nk b">minor</code>和<code class="fe nh ni nj nk b">patch</code>标识符，会怎么样？这是:</p><pre class="kn ko kp kq gt nl nk nm bn nn no bi"><span id="ca57" class="np ld iq nk b be nq nr l ns nt">$ nyx --info<br/>Version: '2.4.0-alpha.1'</span></pre><p id="3485" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在另一个<code class="fe nh ni nj nk b">minor</code>提交之后？</p><pre class="kn ko kp kq gt nl nk nm bn nn no bi"><span id="e24e" class="np ld iq nk b be nq nr l ns nt">$ nyx --info<br/>Version: '2.4.0-alpha.2'</span></pre><p id="fad0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而当我们合并回<code class="fe nh ni nj nk b">main</code>？</p><pre class="kn ko kp kq gt nl nk nm bn nn no bi"><span id="8267" class="np ld iq nk b be nq nr l ns nt">$ nyx --info<br/>Version: '2.4.0'</span></pre><p id="0964" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#collapse-versions" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">折叠版本</strong> </a>的妙处，用于<em class="mf">预发布</em>，而发生这种情况是因为<code class="fe nh ni nj nk b">alpha</code>分支配置了这种方案。</p><p id="5b11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您还运行了<code class="fe nh ni nj nk b">publish</code>任务，那么您将发布到已配置的服务，其描述来自changelog。</p><h1 id="d1d3" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">在后台</h1><p id="4337" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们说<em class="mf">推断</em>是最重要的任务，但是它如何确定<strong class="jp ir">版本</strong>号呢？这很复杂，但我们会尽量保持简单。它考虑到了:</p><ul class=""><li id="4f03" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">Git提交历史</li><li id="ec50" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">已配置的发布类型</li><li id="31d5" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">已配置的提交消息约定</li></ul><p id="7e28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">释放类型</strong>在每次运行时根据<strong class="jp ir">当前分支</strong>的名称与正则表达式和其他可选约束进行匹配，如工作区状态(<em class="mf">干净</em>或<em class="mf">脏</em>)或一些环境变量的值。一旦从已配置的版本中选择了正确的版本类型，它将指示倪克斯:</p><ul class=""><li id="9eab" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">采取哪些Git操作(即<strong class="jp ir">提交</strong>、<strong class="jp ir">标记</strong>、<strong class="jp ir">推送</strong>)</li><li id="b3e9" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">使用哪个版本化方案(即<strong class="jp ir">线性</strong> x.y.x用于<em class="mf">正式</em>发布，<strong class="jp ir">折叠</strong> x.y.x-alpha.n用于预发布)以及可选的额外标识符添加到版本号(即<em class="mf">x . y . z-user . jdoe-timestamp . 2022 01 01</em>)</li><li id="0427" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">发布是否必须使用一些已知的服务<strong class="jp ir">发布</strong>(即<a class="ae kl" href="https://docs.github.com/en/github/administering-a-repository/about-releases" rel="noopener ugc nofollow" target="_blank"> GitHub发布</a>，<a class="ae kl" href="https://docs.gitlab.com/ee/user/project/releases/" rel="noopener ugc nofollow" target="_blank"> GitLab发布</a>)或者只是留在本地</li><li id="9c61" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#filter-tags" rel="noopener ugc nofollow" target="_blank">在读取提交历史时，将哪些标签视为以前的版本，这样可以避免错误匹配</a></li><li id="6ec7" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#version-range" rel="noopener ugc nofollow" target="_blank">版本<strong class="jp ir">范围检查</strong> </a>(确保分行只发布特定范围内的版本)。您甚至可以让倪克斯<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#version-range-from-branch-name" rel="noopener ugc nofollow" target="_blank">从分支名称</a>推断版本范围，以防您遵循某种模式</li></ul><p id="af36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦知道了上述信息，<em class="mf">推断器</em>检查提交历史并确定<strong class="jp ir">发布范围</strong>(将被包括在发布中的提交)，其可能包含也可能不包含关于新发布的<strong class="jp ir">重大变更</strong>。每个提交是否重要取决于用于检查每个提交消息的已配置的<strong class="jp ir">提交消息约定</strong>。</p><p id="e26b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果必须创建一个新版本，它用标识符确定在先前版本上<strong class="jp ir">碰撞</strong>并创建新的版本号，否则保持先前版本不变。被碰撞的标识符也由使用中的<strong class="jp ir">约定</strong>决定。提交惯例用于收集其消息符合已知模式的提交的意图，以便倪克斯知道变更是否应该发布新的<em class="mf">主要</em>或<em class="mf">次要</em>版本、一个<em class="mf">补丁</em>、一个<em class="mf">热修复</em>、一个<em class="mf">预发布</em>、一个<em class="mf">维护</em>或<em class="mf">内部</em>版本等等。</p><p id="e724" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，可选的<strong class="jp ir">额外标识符</strong>被应用于版本号，并且<strong class="jp ir">范围检查</strong>被执行以确保新版本在可选的范围约束内。</p><p id="2457" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更多关于这个话题的信息可以在<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/how-nyx-works/#infer" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="d089" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">关于配置的更多信息</h1><p id="9843" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">正如我们在上面看到的，预置功能强大且易于使用。上面的<em class="mf">扩展</em>预置带来了很多配置选项，这里<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-presets/extended/" rel="noopener ugc nofollow" target="_blank">列出了</a>，但是倪克斯的配置可以更进一步。</p><p id="fc33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用YAML和JSON文件，甚至是它们的组合。如果在默认位置(<code class="fe nh ni nj nk b">.nyx.json</code>或<code class="fe nh ni nj nk b">.nyx.yaml</code>)找不到它们，您可以传递它们的路径(或者远程URL)。</p><p id="1991" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，通过混合几种配置方式，你可以继承一些集中管理的组织范围的设置，然后在项目的基础上定制它们，或者让不同的团队共享部分配置等等。</p><p id="19f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有配置选项也可以作为<strong class="jp ir">命令行</strong>参数或者甚至是<strong class="jp ir">环境变量</strong>来传递，以便满足甚至是最偏远的边缘情况(即，安全机密管理、在强化环境中的合规性、在CI/CD环境中的灵活性等等)。</p><p id="1ad1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此处的<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/configuration-methods/" rel="noopener ugc nofollow" target="_blank">描述了全部配置方法及其评估顺序</a>，而<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/" rel="noopener ugc nofollow" target="_blank">配置参考</a>描述了每个选项的所有方法。</p><h2 id="63c2" class="nu ld iq bd le nv nw dn li nx ny dp lm jy nz oa lq kc ob oc lu kg od oe ly of bi translated">关于提交消息约定和版本覆盖的更多信息</h2><p id="094b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在本指南中，我们使用<a class="ae kl" href="https://www.conventionalcommits.org/" rel="noopener ugc nofollow" target="_blank">约定提交</a>约定，因为它被广泛使用，但是没有什么可以阻止您使用任何其他约定，包括一些您自己定义的自定义约定。</p><p id="62bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在倪克斯，提交消息约定可以<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/commit-message-conventions/" rel="noopener ugc nofollow" target="_blank">配置</a>为其他任何东西，并且<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/commit-message-conventions/#enabled" rel="noopener ugc nofollow" target="_blank">可以使用多个</a>，因此您甚至可以组合它们。</p><p id="e147" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">约定是倪克斯能够从提交历史中推断信息以实现完全自动化的方式。同样，它们允许每个提交定义哪些版本标识符要被<strong class="jp ir">碰撞</strong>(如果有的话)，以便从以前的版本号开始计算新的<strong class="jp ir">版本号</strong>。</p><p id="0479" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管如此，当您需要完全接管推理逻辑时，您总是可以覆盖<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/global-options/#version" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">版本</strong> </a>来使用，或者您可以通过将标识符传递给<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/global-options/#bump" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">【bump】</strong></a>来完成，这样倪克斯仍然可以从提交历史中读取以前的版本并直接进入bumping，而无需检查提交。</p><h2 id="3273" class="nu ld iq bd le nv nw dn li nx ny dp lm jy nz oa lq kc ob oc lu kg od oe ly of bi translated">有条件释放类型</h2><p id="486a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">让我们假设您希望您的正式发布只由<code class="fe nh ni nj nk b">main</code>或<code class="fe nh ni nj nk b">master</code>分支发布，但是，为了保证构建环境的一致性，要执行的整个范围的测试，等等，您需要它们只从集中的CI/CD环境发布，避免开发人员利用漏洞。</p><p id="dee6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">换句话说，您需要官方发布类型<strong class="jp ir">有条件地</strong>只在CI/CD环境中匹配。</p><p id="023d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，发布类型是按照它们在<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#enabled" rel="noopener ugc nofollow" target="_blank">列表</a>中的顺序进行评估的，因此只有在先前的发布类型没有成功匹配的情况下，才会对每个项目进行评估。同样，用于匹配一个发布类型的规则是基于<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#match-branches" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">当前分支</strong>名称</a>(匹配一个正则表达式)<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#match-workspace-status" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">工作区状态</strong> </a> ( <em class="mf">干净</em>或<em class="mf">脏</em>)或一些<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#match-environment-variables" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">环境变量</strong> </a>。</p><p id="180e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，我们可以使用一个环境变量(即<code class="fe nh ni nj nk b">CI</code>)来匹配官方发布类型。</p><p id="2050" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了完成这个例子，让我们添加一个模拟官方版本的后备版本类型，但是，它不发布官方版本，而只发布内部版本，正确地标识为内部版本。</p><p id="550f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">截取的配置示例可能是:</p><pre class="kn ko kp kq gt nl nk nm bn nn no bi"><span id="79b5" class="np ld iq nk b be nq nr l ns nt">{<br/>  ...<br/>  "releaseTypes":{<br/>    "enabled":[<br/>      "mainline",<br/>      "internal"<br/>    ],<br/>    "items":{<br/>      "mainline":{<br/>        "filterTags":"^([0-9]\\d*)\\.([0-9]\\d*)\\.([0-9]\\d*)$",<br/>        "gitCommit":"false",<br/>        "gitPush":"true",<br/>        "gitTag":"true",<br/>        "matchBranches":"^(master|main)$",<br/>        "matchEnvironmentVariables":{<br/>          "CI":"^true$"<br/>        },<br/>        "publish":"true"<br/>      },<br/>      "internal":{<br/>        "filterTags":"^([0-9]\\d*)\\.([0-9]\\d*)\\.([0-9]\\d*)$",<br/>        "gitCommit":"false",<br/>        "gitPush":"false",<br/>        "gitTag":"false",<br/>        "identifiers":[<br/>          {<br/>            "position":"BUILD",<br/>            "qualifier":"internal",<br/>            "value":"{{#sanitize}}{{branch}}{{/sanitize}}"<br/>          }<br/>        ],<br/>        "matchBranches":"^(master|main)$",<br/>        "publish":"false"<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="e2f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，<code class="fe nh ni nj nk b">internal</code>类型仅在<code class="fe nh ni nj nk b">mainline</code>首先不匹配时被评估(即，因为没有找到值为<code class="fe nh ni nj nk b">true</code>的<code class="fe nh ni nj nk b">CI</code>环境变量),而<code class="fe nh ni nj nk b">mainline</code>发布<em class="mf">正式</em>版本，如<em class="mf"> x.y.x </em>，<code class="fe nh ni nj nk b">internal</code>在版本号的构建部分添加<code class="fe nh ni nj nk b">internal</code>限定符，如:<em class="mf"> x.y.z+branch.main </em>。<code class="fe nh ni nj nk b">internal</code>发布类型不提交、标记或推送任何变更到存储库，也不发布任何东西，而<code class="fe nh ni nj nk b">mainline</code>会。</p><h2 id="16db" class="nu ld iq bd le nv nw dn li nx ny dp lm jy nz oa lq kc ob oc lu kg od oe ly of bi translated">关于使用模板进行动态配置的更多信息</h2><p id="ded5" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">实现上一个示例相同结果的另一种方法是利用模板。这样，您甚至不需要添加额外的发布类型(但是请记住，在所有配置中建议使用最后一个后备发布类型)。看起来是这样的:</p><pre class="kn ko kp kq gt nl nk nm bn nn no bi"><span id="2120" class="np ld iq nk b be nq nr l ns nt">{<br/>  ...<br/>  "releaseTypes":{<br/>    "enabled":[<br/>      "mainline"<br/>    ],<br/>    "items":{<br/>      "mainline":{<br/>        "filterTags":"^([0-9]\\d*)\\.([0-9]\\d*)\\.([0-9]\\d*)$",<br/>        "gitCommit":"false",<br/>        "gitPush":"{{#environmentVariable}}CI{{/environmentVariable}}",<br/>        "gitTag":"{{#environmentVariable}}CI{{/environmentVariable}}",<br/>        "matchBranches":"^(master|main)$",<br/>        "publish":"{{#environmentVariable}}CI{{/environmentVariable}}"<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="3b7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，配置更加简洁，无论环境如何，都匹配相同的发布类型<code class="fe nh ni nj nk b">mainline</code>。然而，它的一些控制是否必须执行Git <a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#git-push" rel="noopener ugc nofollow" target="_blank"> push </a>和<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#git-tag" rel="noopener ugc nofollow" target="_blank"> tag </a>操作的标志(以及最终的<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#publish" rel="noopener ugc nofollow" target="_blank">发布</a>)通过<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/templates/#environmentvariable" rel="noopener ugc nofollow" target="_blank">读取</a> <code class="fe nh ni nj nk b"><a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/templates/#environmentvariable" rel="noopener ugc nofollow" target="_blank">CI</a></code> <a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/templates/#environmentvariable" rel="noopener ugc nofollow" target="_blank">环境变量的值来动态获取它们的值。</a></p><p id="27f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是可能的，因为<code class="fe nh ni nj nk b">CI</code>环境变量在定义时具有值<code class="fe nh ni nj nk b">true</code>，并且提到的标志被评估为布尔值。</p><h1 id="1020" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">使用Docker</h1><p id="1b77" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">倪克斯也可以在两个公共注册表中作为小足迹Docker映像使用:</p><ul class=""><li id="c214" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated"><a class="ae kl" href="https://hub.docker.com/repository/docker/mooltiverse/nyx" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>(默认)</li><li id="5c58" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><a class="ae kl" href="https://github.com/mooltiverse/nyx/pkgs/container/nyx" rel="noopener ugc nofollow" target="_blank"> GitHub容器注册表</a></li></ul><p id="9fe8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以像往常一样提取并运行容器，比如(在本例中使用Docker Hub注册表):</p><pre class="kn ko kp kq gt nl nk nm bn nn no bi"><span id="acd0" class="np ld iq nk b be nq nr l ns nt">$ docker run -it --rm -v /local/path/to/project:/project mooltiverse/nyx:latest --info infer<br/>Version: '1.3.0'</span></pre><p id="a50a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此示例类似于它的命令行等效项:</p><pre class="kn ko kp kq gt nl nk nm bn nn no bi"><span id="579c" class="np ld iq nk b be nq nr l ns nt">$ nyx --info infer<br/>Version: '1.3.0'</span></pre><p id="276e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一个警告:您需要使用<code class="fe nh ni nj nk b">-v /local/path/to/project:/project</code>标志将Git存储库目录挂载到容器中，否则倪克斯将无法访问它。只需将<code class="fe nh ni nj nk b">/local/path/to/project</code>路径替换为主机上Git存储库文件夹的实际路径(或者一个<a class="ae kl" href="https://docs.docker.com/storage/volumes/" rel="noopener ugc nofollow" target="_blank"> Docker卷</a>名称)即可。</p><p id="efeb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以像往常一样使用所有命令行参数和配置文件，如果您正在使用环境变量，请记住您需要将它们作为<code class="fe nh ni nj nk b"><a class="ae kl" href="https://docs.docker.com/engine/reference/run/#env-environment-variables" rel="noopener ugc nofollow" target="_blank">-e</a></code> <a class="ae kl" href="https://docs.docker.com/engine/reference/run/#env-environment-variables" rel="noopener ugc nofollow" target="_blank">标志</a>传递。</p><p id="1496" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还要考虑使用<code class="fe nh ni nj nk b">-u $(id -u):$(id -g)</code>标志(或者简单地使用<code class="fe nh ni nj nk b">-u $(id -u)</code>来运行容器，以避免容器和主机访问之间的文件所有权问题。</p><p id="a8f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请跳转到<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/usage/#using-the-docker-image" rel="noopener ugc nofollow" target="_blank">文档网站</a>了解更多信息。</p><h1 id="f0a2" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">拉/合并提交</h1><p id="721d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">当创建<a class="ae kl" href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests" rel="noopener ugc nofollow" target="_blank">拉</a>或<a class="ae kl" href="https://docs.gitlab.com/ee/user/project/merge_requests/" rel="noopener ugc nofollow" target="_blank">合并请求</a>时，您通常会挤压属于合并的提交。这是避免混淆提交历史的好方法，但是从倪克斯的角度来看，这使得属于合并操作的单个提交的消息不可见，它们的消息也是不可见的。换句话说，如果您的意思是提交通过它们的提交消息来触发释放，您将看到倪克斯没有对来自合并请求的提交进行版本控制，因为它不再看到那些消息，并且提交消息约定无法检测它们的意图。这是真的，除非你将合并请求的标题设置为一个<strong class="jp ir">重要的</strong>消息，在这种情况下，倪克斯能够检测到该消息并触发版本。</p></div></div>    
</body>
</html>