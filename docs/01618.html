<html>
<head>
<title>Knights, Pikemen, Archers and Multiple Dispatch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">骑士、枪兵、弓箭手和多重派遣</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/knights-pikemen-archers-and-multiple-dispatch-69aaee2c4141?source=collection_archive---------3-----------------------#2020-01-16">https://levelup.gitconnected.com/knights-pikemen-archers-and-multiple-dispatch-69aaee2c4141?source=collection_archive---------3-----------------------#2020-01-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="ir is gp gr it iu gh gi paragraph-image"><div class="ab gu cl iv"><img src="../Images/c677af6a6273afc2af284d4591f3b48f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*cqaQIhYPBPWvDMlcribEOw.jpeg"/></div></figure><div class=""/><div class=""><h2 id="f177" class="pw-subtitle-paragraph jx iz ja bd b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dk translated">面向程序员的Julia介绍</h2></div><p id="b531" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">厌倦了以银行账户、雇员和雇主为特征的编程示例？我也是！让我通过编码一场骑士、长枪兵和弓箭手之间的战斗，向你介绍一些Julia编程语言的独特之处。</p><p id="f125" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们的目标是对Julia编程语言做一个简单的介绍，主要集中在使Julia成为有趣而强大的语言的各个方面。</p><p id="a043" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在我们能走之前，我们得先爬，所以让我先简单介绍一下朱莉娅·REPL(阅读-评估-打印-循环)。<a class="ae ll" href="https://julialang.org/downloads/" rel="noopener ugc nofollow" target="_blank">安装Julia </a>并在unix风格的shell中启动它:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="9d43" class="lv lw ja lr b gy lx ly l lz ma">$ julia<br/>              _<br/>  _       _ _(_)_     |  Documentation: https://docs.julialang.org<br/> (_)     | (_) (_)    |<br/>  _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.<br/> | | | | | | |/ _` |  |<br/> | | |_| | | | (_| |  |  Version 1.2.0 (2019-08-20)<br/>_/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release<br/>|__/                   |<br/><br/>julia&gt; println("hello world")<br/>hello world</span></pre><h2 id="3bf8" class="lv lw ja bd mb mc md dn me mf mg dp mh ky mi mj mk lc ml mm mn lg mo mp mq mr bi translated">字符串连接和插值</h2><p id="4897" class="pw-post-body-paragraph kp kq ja kr b ks ms kb ku kv mt ke kx ky mu la lb lc mv le lf lg mw li lj lk im bi translated">让我们对文本字符串做一些更有趣的事情。我们将看看变量是如何与字符串结合在一起的。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="74f8" class="lv lw ja lr b gy lx ly l lz ma">julia&gt; engine = "RD-180";<br/>julia&gt; company = "Energomash";<br/>julia&gt; thrust = 3830;<br/><br/>julia&gt; string("The ", engine, " rocket engine, produced by ", company, " produces ", thrust, " kN of thrust")<br/>"The RD-180 rocket engine, produced by Energomash produces 3830 kN of thrust"</span></pre><p id="49fa" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这是一个字符串插值的例子。您可以看到语法是受unix shell的启发。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="1a1e" class="lv lw ja lr b gy lx ly l lz ma">julia&gt; println("The $company $engine produce $thrust kN of thrust")<br/>The Energomash RD-180 produce 3830 kN of thrust</span></pre><p id="9d9b" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在Julia中,<code class="fe mx my mz lr b">$</code>有各种各样的相关用法。当从Julia调用shell命令时，也可以使用它。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="f554" class="lv lw ja lr b gy lx ly l lz ma">julia&gt; run(echo The $company $engine produce $thrust kN of thrust)<br/>The Energomash RD-180 produce 3830 kN of thrust<br/>Process(`echo The Energomash RD-180 produce 3830 kN of thrust`, ProcessExited(0))</span></pre><h2 id="8bd6" class="lv lw ja bd mb mc md dn me mf mg dp mh ky mi mj mk lc ml mm mn lg mo mp mq mr bi translated">功能</h2><p id="5530" class="pw-post-body-paragraph kp kq ja kr b ks ms kb ku kv mt ke kx ky mu la lb lc mv le lf lg mw li lj lk im bi translated">在Julia中，你可以写一个函数，就像在数学中一样:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="6c56" class="lv lw ja lr b gy lx ly l lz ma">julia&gt; f(x) = 3x + 2<br/>julia&gt; f(1)<br/>5</span></pre><p id="8a24" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">还要注意Julia支持文字系数。<code class="fe mx my mz lr b">3x</code>与<code class="fe mx my mz lr b">3*x</code>相同。当你有多行代码时，你需要标记函数的开始和结束。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="531c" class="lv lw ja lr b gy lx ly l lz ma">function f(x)<br/>   3x + 2<br/>end</span></pre><p id="5bd6" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">Julia是一种动态类型语言，所以变量没有类型，值有类型。</p><p id="063d" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">但是，您可以根据输入类型定制函数行为。实际调用什么函数实现仍然是在运行时决定的。我们把函数的每个实现都称为方法。是的，我知道这让人们对面向对象语言感到奇怪。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="f900" class="lv lw ja lr b gy lx ly l lz ma">hello(x::Number) = 3x<br/>hello(name::AbstractString) = "Hi $name"<br/>hello(x::Bool) = !x</span></pre><p id="9645" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">让我们尝试一下:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="c566" class="lv lw ja lr b gy lx ly l lz ma">julia&gt; hello(3)<br/>9<br/><br/>julia&gt; hello("Bilbo")<br/>"Hi Bilbo"<br/><br/>julia&gt; hello(false)<br/>true</span></pre><h2 id="e3ee" class="lv lw ja bd mb mc md dn me mf mg dp mh ky mi mj mk lc ml mm mn lg mo mp mq mr bi translated">类型</h2><p id="1dde" class="pw-post-body-paragraph kp kq ja kr b ks ms kb ku kv mt ke kx ky mu la lb lc mv le lf lg mw li lj lk im bi translated">在朱莉娅的作品中，我们主要有两种类型:</p><ul class=""><li id="c9f8" class="na nb ja kr b ks kt kv kw ky nc lc nd lg ne lk nf ng nh ni bi translated">抽象类型</li><li id="1f3a" class="na nb ja kr b ks nj kv nk ky nl lc nm lg nn lk nf ng nh ni bi translated">具体类型，分为位类型和复合类型。</li></ul><p id="3746" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们将首先制作一些复合类型来表示一个骑士。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="1b28" class="lv lw ja lr b gy lx ly l lz ma">struct Knight {            mutable struct Knight<br/>   string name;               name::String<br/>   int health;                health::Int<br/>   int armour;                armour::Int<br/>};                         end</span></pre><p id="a41f" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">左边是C++版本，右边是Julia版本。注意，在Julia中，我们只使用冒号<code class="fe mx my mz lr b">;</code>来分隔同一行中的多个语句。换行符也分隔语句。</p><p id="9b37" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">对于外面的花括号爱好者，很抱歉我们没有在朱莉娅。在C++ <code class="fe mx my mz lr b">{ ... }</code>中形成了一个代码块。在朱莉娅中，我们使用<code class="fe mx my mz lr b">begin ... end</code>。然而，当我们启动一个程序块作为某些语句的一部分时，如<code class="fe mx my mz lr b">struct</code>、<code class="fe mx my mz lr b">if</code>、<code class="fe mx my mz lr b">while</code>和<code class="fe mx my mz lr b">for</code>，就会省略<code class="fe mx my mz lr b">begin</code>。</p><p id="250e" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">注意我们如何在<code class="fe mx my mz lr b">struct</code>前面写<code class="fe mx my mz lr b">mutable</code>。这是因为像许多其他现代语言一样，Julia倾向于默认使事物不可变。除非你有充分的理由，否则你应该选择不可变的数据类型。</p><p id="1fbf" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在我们的例子中，可变性是实用的。我们正在处理一个特殊的骑士，并希望能够修改这个骑士的健康，因为他在战斗中受伤。</p><p id="6bb5" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">让我们创建一个数据类型来代表我们将要模拟的每一种士兵。为了简单起见，我们将只记录他们的健康状况。当生命值为零或更低时，我们的士兵就会死亡。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="5570" class="lv lw ja lr b gy lx ly l lz ma">mutable struct Archer<br/>   health::Int<br/>end<br/><br/>mutable struct Pikeman<br/>   health::Int<br/>end<br/><br/>mutable struct Knight<br/>   health::Int<br/>end</span></pre><p id="7aeb" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这就是我们如何在朱莉娅中创造这些士兵的一些例子。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="2a64" class="lv lw ja lr b gy lx ly l lz ma">julia&gt; archer = Archer(4)<br/>Archer(4)<br/><br/>julia&gt; pikeman = Pikeman(5)<br/>Pikeman(5)<br/><br/>julia&gt; knight = Knight(6)<br/>Knight(6)</span></pre><p id="27c7" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们给骑士最好的健康，因为我们认为他是最好的训练，食物和装甲。</p><h2 id="58d1" class="lv lw ja bd mb mc md dn me mf mg dp mh ky mi mj mk lc ml mm mn lg mo mp mq mr bi translated">多重分派和函数重载</h2><p id="45da" class="pw-post-body-paragraph kp kq ja kr b ks ms kb ku kv mt ke kx ky mu la lb lc mv le lf lg mw li lj lk im bi translated">我们将模拟每种士兵之间的战斗，类似于石头、布、剪刀的比赛:</p><ul class=""><li id="ce9d" class="na nb ja kr b ks kt kv kw ky nc lc nd lg ne lk nf ng nh ni bi translated">弓箭手将击败枪兵，因为他们移动缓慢，当他们逼近弓箭手时，弓箭手将设法射下他们中的大多数。</li><li id="a787" class="na nb ja kr b ks nj kv nk ky nl lc nm lg nn lk nf ng nh ni bi translated">然而骑士会击败弓箭手，因为他们移动迅速。弓箭手无法击中快速移动的目标，而且在骑士包围并砍倒他们之前，他们无法射出许多箭。</li><li id="f2e3" class="na nb ja kr b ks nj kv nk ky nl lc nm lg nn lk nf ng nh ni bi translated">另一方面，枪兵会击败骑士，因为楔形矛会阻止马匹攻击。</li></ul><p id="7b0b" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">因此，谁对谁造成伤害完全取决于我们面对的是哪种士兵组合。</p><h2 id="c189" class="lv lw ja bd mb mc md dn me mf mg dp mh ky mi mj mk lc ml mm mn lg mo mp mq mr bi translated">单一派遣的问题</h2><p id="3c72" class="pw-post-body-paragraph kp kq ja kr b ks ms kb ku kv mt ke kx ky mu la lb lc mv le lf lg mw li lj lk im bi translated">动态面向对象语言在解决这个问题时会有问题，因为它们就是我们所说的单一分派。下面是一个尝试用Python解决这个问题的例子。首先我们定义<code class="fe mx my mz lr b">Archer</code>类。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="2f07" class="lv lw ja lr b gy lx ly l lz ma">class Archer:<br/>    def __init__(self, health):<br/>        self.health = health<br/><br/>    def fight(self, opponent):<br/>        if type(opponent) == Pikeman:<br/>            opponent.health -= 4<br/>            if opponent.health &lt;= 0:<br/>                print("Archer killed pikeman")<br/>        elif type(opponent) == Knight:<br/>            opponent.health -= 2<br/>            if opponent.health &lt;= 0:<br/>                print("Archer killed knight")<br/>                return<br/>            <br/>            self.health -= 6<br/>            if self.health &lt;= 0:<br/>                print("Knight killed archer")</span></pre><p id="3290" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">然后我们定义<code class="fe mx my mz lr b">Pikeman</code>类。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="8715" class="lv lw ja lr b gy lx ly l lz ma">class Pikeman:<br/>    def __init__(self, health):<br/>        self.health = health<br/>        <br/>    def fight(self, opponent):<br/>        if type(opponent) == Archer:<br/>            opponent.fight(self)<br/>        elif type(opponent) == Knight:<br/>            opponent.health -= 4<br/>            if opponent.health &lt;= 0:<br/>                print("Pikeman killed knight")</span></pre><p id="299d" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">对于这个演示，我们并不真正需要Knight的完整实现，所以我们将使它变得简单。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="5d19" class="lv lw ja lr b gy lx ly l lz ma">class Knight:<br/>    def __init__(self, health):<br/>        self.health = health</span></pre><p id="bb42" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们可以启动Python REPL(读取-评估-打印-循环)来测试这段代码:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="451d" class="lv lw ja lr b gy lx ly l lz ma">&gt;&gt;&gt; pikeman = Pikeman(5)<br/>&gt;&gt;&gt; archer = Archer(4)<br/>&gt;&gt;&gt; knight = Knight(6)<br/>&gt;&gt;&gt; archer.fight(pikeman)<br/>&gt;&gt;&gt; archer.fight(pikeman)<br/>Archer killed pikeman<br/>&gt;&gt;&gt; archer.fight(knight)<br/>Knight killed archer</span></pre><p id="599e" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">虽然我们得到了这个工作，这个解决方案的问题是，添加一个新类型的士兵将需要修改每个类的<code class="fe mx my mz lr b">fight()</code>方法的代码。精心制作的<code class="fe mx my mz lr b">if-else</code>声明会很快失控。</p><h2 id="92df" class="lv lw ja bd mb mc md dn me mf mg dp mh ky mi mj mk lc ml mm mn lg mo mp mq mr bi translated">函数重载的问题</h2><p id="36fe" class="pw-post-body-paragraph kp kq ja kr b ks ms kb ku kv mt ke kx ky mu la lb lc mv le lf lg mw li lj lk im bi translated">让我们探索用支持函数重载的静态类型语言解决这个问题，比如C++。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="c759" class="lv lw ja lr b gy lx ly l lz ma">#include &lt;iostream&gt;<br/><br/>struct Archer {<br/>   int health;<br/>};<br/><br/>struct Pikeman {<br/>   int health;<br/>};<br/><br/>struct Knight {<br/>   int health;<br/>};<br/><br/>using namespace std;</span></pre><p id="a0fc" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">现在我们可以更好地定义士兵类型的每种组合会发生什么。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="4e4e" class="lv lw ja lr b gy lx ly l lz ma">void fight(Archer *a, Pikeman *b) {<br/>  b-&gt;health -= 4;<br/>  if (b-&gt;health &lt;= 0) {<br/>      cout &lt;&lt; "Archer killed pikeman" &lt;&lt; endl;<br/>  }<br/>}<br/><br/>void fight(Archer *a, Knight *b) {<br/>  b-&gt;health -= 2;<br/>  if (b-&gt;health &lt;= 0) {<br/>      cout &lt;&lt; "Archer killed knight" &lt;&lt; endl;<br/>      return;       <br/>  }<br/>  <br/>  a-&gt;health -= 6;<br/>  if (a-&gt;health &lt;= 0) {<br/>      cout &lt;&lt; "Knight killed archer" &lt;&lt; endl;<br/>  }<br/>}</span></pre><p id="cbe7" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这是一个创造一些士兵并让他们在<code class="fe mx my mz lr b">main</code>战斗的例子。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="6b7a" class="lv lw ja lr b gy lx ly l lz ma">int main (int argc, char const *argv[]) {<br/>   Pikeman pikeman = {5};<br/>   Archer archer = {4};<br/>   Knight knight = {6};<br/>   <br/>   fight(&amp;archer, &amp;pikeman);<br/>   fight(&amp;archer, &amp;pikeman);<br/>   fight(&amp;archer, &amp;knight);<br/>   return 0;<br/>}</span></pre><p id="ab4c" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">因此，这个解决方案看似可行，看似优雅。有什么问题？</p><p id="06fc" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这是对问题的完全不切实际的描述。在任何真实的游戏中，你都不知道每个玩家在编译时会有什么样的士兵。玩家将在运行时创造不同种类的士兵。</p><p id="b116" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">因此实际上我们只知道他们是某种士兵，但不知道是哪种。让我们更准确地模拟这个问题。这将需要对<code class="fe mx my mz lr b">struct</code>定义进行一些修改。</p><p id="029c" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们引入了一个新的基类，现在每个人都需要一个构造函数，因为我们不再有普通的旧结构，而是类。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="1c42" class="lv lw ja lr b gy lx ly l lz ma">struct Soldier {<br/>   int health;<br/>   <br/>   Soldier(int health) : health(health) {}    <br/>};<br/><br/>struct Archer : public Soldier {<br/>   Archer(int health) : Soldier(health) {}<br/>};<br/><br/>struct Pikeman : public Soldier {<br/>   Pikeman(int health) : Soldier(health) {}<br/>};<br/><br/>struct Knight : public Soldier {<br/>   Knight(int health) : Soldier(health) {}<br/>};</span></pre><p id="43e6" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">现在让我们改变测试代码，这样士兵的精确类型是未知的。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="9a1f" class="lv lw ja lr b gy lx ly l lz ma">int main (int argc, char const *argv[]) {<br/>   Pikeman pikeman(5);<br/>   Archer archer(4);<br/>   Knight knight(6);<br/>   <br/>   Soldier *a = &amp;archer;<br/>   Soldier *b = &amp;pikeman;<br/>   <br/>   fight(a, b);<br/>   fight(a, b);<br/>   <br/>   b = &amp;knight;<br/>   fight(a, b);<br/>   return 0;<br/>}</span></pre><p id="66b0" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">但是，如果我们试图编译它，就会遇到麻烦。我们得到的错误消息之一是:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="cc95" class="lv lw ja lr b gy lx ly l lz ma">note: candidate function not viable: cannot convert from base class pointer 'Soldier *' to derived class pointer 'Archer *' for 1st argument<br/>void fight(Archer *a, Pikeman *b) {</span></pre><p id="2e6a" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">基本上，它是在告诉我们，C++编译器对我们试图用一个<code class="fe mx my mz lr b">Soldier</code>类型的变量调用<code class="fe mx my mz lr b">fight</code>函数并不感冒，因为它不知道调用哪个特定的重载函数。这种东西必须在编译时决定。当您使用函数重载时，在运行时无法选择正确的函数。</p><p id="3503" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们可以通过添加一个将<code class="fe mx my mz lr b">Solider</code>类型作为输入的函数来演示这一点。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="c559" class="lv lw ja lr b gy lx ly l lz ma">void fight(Soldier *a, Soldier *b) {<br/>   cout &lt;&lt; "Could not pick right overloaded function" &lt;&lt; endl;<br/>}</span></pre><p id="4c50" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这编译了find，但是当我们运行这个程序时，对<code class="fe mx my mz lr b">fight</code>的三个调用产生了这个输出:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="5b46" class="lv lw ja lr b gy lx ly l lz ma">Could not pick right overloaded function<br/>Could not pick right overloaded function<br/>Could not pick right overloaded function</span></pre><p id="fccb" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">显然，我们不能在运行时选择合适的函数。</p><h2 id="b0ae" class="lv lw ja bd mb mc md dn me mf mg dp mh ky mi mj mk lc ml mm mn lg mo mp mq mr bi translated">茱莉亚多重派遣救援</h2><p id="9586" class="pw-post-body-paragraph kp kq ja kr b ks ms kb ku kv mt ke kx ky mu la lb lc mv le lf lg mw li lj lk im bi translated">所以我们看到，像Python这样的动态面向对象语言不能令人满意地解决这个问题，静态类型语言也不能。朱莉娅能做得更好吗？</p><p id="7cda" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">为了与C++版本进行比较，我们将把我们的类型修改为抽象类型<code class="fe mx my mz lr b">Soldier</code>的子类型。与C++不同，抽象类型不能保存数据。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="7c46" class="lv lw ja lr b gy lx ly l lz ma">abstract type Soldier end<br/><br/>mutable struct Archer &lt;: Soldier<br/>   health::Int<br/>end<br/><br/>mutable struct Pikeman &lt;: Soldier<br/>   health::Int<br/>end<br/><br/>mutable struct Knight &lt;: Soldier<br/>   health::Int<br/>end</span></pre><p id="7d57" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">为了与C++版本进行比较，我们可以实现一个以<code class="fe mx my mz lr b">Solider</code>类型作为参数的<code class="fe mx my mz lr b">fight</code>函数。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="966f" class="lv lw ja lr b gy lx ly l lz ma">function fight!(a::Soldier, b::Soldier)<br/>   error("You have not registered a method for fight!($(typeof(a)), $(typeof(b))")<br/>end</span></pre><p id="1b65" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">注意<code class="fe mx my mz lr b">fight!</code>中的感叹号，这是标记函数的Julia约定，它改变或变异它们的输入。这是由LISP和Ruby推广的一种约定。</p><p id="613f" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这里有一个针对各种组合的<code class="fe mx my mz lr b">fight!</code>实现。我们提供了一个更完整的实现，同时也考虑了同类型士兵之间的战斗。</p><p id="5573" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><code class="fe mx my mz lr b">Archer</code>是第一个参数的情况。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="113f" class="lv lw ja lr b gy lx ly l lz ma">function fight!(a::Archer, b::Pikeman)<br/>  b.health -= 4<br/>  if b.health &lt;= 0<br/>      println("Archer killed pikeman")<br/>  end <br/>end</span></pre><p id="7280" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">请注意与骑士互动的小变化。我们让弓箭手在靠近拱门之前对骑士造成一些伤害，并造成更多伤害。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="25a9" class="lv lw ja lr b gy lx ly l lz ma">function fight!(a::Archer, b::Knight)<br/>  b.health -= 2<br/>  if b.health &lt;= 0<br/>      println("Archer killed knight")<br/>      return       <br/>  end<br/>  <br/>  a.health -= 6<br/>  if a.health &lt;= 0<br/>      println("Knight killed archer")<br/>  end <br/>end<br/><br/>function fight!(a::Archer, b::Archer)<br/>  a.health -= 2<br/>  b.health -= 2<br/>  if a.health &lt;= 0 &amp;&amp; b.health &lt;= 0<br/>      println("Archers killed each other")<br/>  elseif a.health &lt;= 0 || b.health &lt;= 0<br/>      println("One archer was killed")<br/>  end <br/>end</span></pre><p id="6316" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><code class="fe mx my mz lr b">Pikeman</code>是第一个参数的情况。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="a685" class="lv lw ja lr b gy lx ly l lz ma">fight!(a::Pikeman, b::Archer) = fight!(b, a)<br/><br/>function fight!(a::Pikeman, b::Pikeman)<br/>  a.health -= 4<br/>  b.health -= 4<br/>  if a.health &lt;= 0 &amp;&amp; b.health &lt;= 0<br/>      println("Pikemen killed each other")<br/>  elseif a.health &lt;= 0 || b.health &lt;= 0<br/>      println("One pikeman was killed")<br/>  end <br/>end<br/><br/>function fight!(a::Pikeman, b::Knight)<br/>  b.health -= 4<br/>  if a.health &lt;= 0<br/>      println("Pikeman killed cavalry")<br/>  end <br/>end</span></pre><p id="4164" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><code class="fe mx my mz lr b">Knight</code>是第一个参数的情况。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="0f2d" class="lv lw ja lr b gy lx ly l lz ma">fight!(a::Knight, b::Archer) = fight!(b, a)<br/>fight!(a::Knight, b::Pikeman) = fight!(b, a)<br/><br/>function fight!(a::Knight, b::Knight)<br/>  a.health -= 4<br/>  b.health -= 4<br/>  if a.health &lt;= 0 &amp;&amp; b.health &lt;= 0<br/>      println("Knights killed each other")<br/>  elseif a.health &lt;= 0 || b.health &lt;= 0<br/>      println("One knight was killed")<br/>  end <br/>end</span></pre><p id="6ed6" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如果我们在朱丽亚·REPL中运行这个，我们得到这些结果:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="7e0e" class="lv lw ja lr b gy lx ly l lz ma">julia&gt; pikeman = Pikeman(5)<br/>Pikeman(5)<br/><br/>julia&gt; archer = Archer(4)<br/>Archer(4)<br/><br/>julia&gt; knight = Knight(6)<br/>Knight(6)<br/><br/>julia&gt; fight!(archer, pikeman)<br/><br/>julia&gt; fight!(archer, pikeman)<br/>Archer killed pikeman<br/><br/>julia&gt; fight!(archer, knight)<br/>Knight killed archer</span></pre><p id="17db" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">换句话说，Julia能够在运行时选择正确的函数实现。在Julia术语中，每个不同的函数实现称为一个方法。对于习惯于面向对象编程的人来说，这是对单词method的一种不寻常的使用。</p><p id="dd78" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">但确实有一定道理。在OOP中，我们也在运行时分派给一个特定的方法。所以在Julia术语中,<code class="fe mx my mz lr b">fight!</code>是一个函数，而<code class="fe mx my mz lr b">fight!(a::Pikeman, b::Archer)</code>是一个方法定义。</p><p id="4d71" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">Julia会根据需要自动创建函数。但是你可以在Julia中显式地创建一个函数。这将创建<code class="fe mx my mz lr b">fight!</code>函数。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="130e" class="lv lw ja lr b gy lx ly l lz ma">function fight! end</span></pre><p id="0870" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">但是如果没有相应的方法，这将是毫无用处的。</p><h2 id="dfe5" class="lv lw ja bd mb mc md dn me mf mg dp mh ky mi mj mk lc ml mm mn lg mo mp mq mr bi translated">元编程</h2><p id="c3ea" class="pw-post-body-paragraph kp kq ja kr b ks ms kb ku kv mt ke kx ky mu la lb lc mv le lf lg mw li lj lk im bi translated">下一个让你领略Julia威力的话题是元编程。这是一个更大的主题，所以我们在这里只讨论代码生成。</p><p id="09f6" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">你可能注意到每个士兵类型都是一样的。如果我们添加更多属性，如<code class="fe mx my mz lr b">armor</code>和<code class="fe mx my mz lr b">name</code>，这种重复将变得乏味。</p><p id="436f" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">Python或C++开发人员可以通过将成员变量放入基类来解决这个问题。但是Julia没有可以保存数据的基类。</p><p id="5a20" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">相反，我们可以使用代码生成。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="f75c" class="lv lw ja lr b gy lx ly l lz ma">for T in [:Archer, :Pikeman, :Knight]<br/>   @eval mutable struct $T &lt;: Soldier<br/>      health::Int<br/>      damage::Int <br/>   end<br/>end</span></pre><p id="9227" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们使用for循环来迭代包含树符号<code class="fe mx my mz lr b">:Archer</code>、<code class="fe mx my mz lr b">:Pikeman</code>和<code class="fe mx my mz lr b">:Knight</code>的数组中的每个元素。符号类似于字符串。<code class="fe mx my mz lr b">"Archer"</code>是字符串，而<code class="fe mx my mz lr b">:Archer</code>是符号。符号主要用于表示程序代码中的标识符。当键不是面向用户时，它们也经常被用作字典中的键。</p><p id="e48f" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><code class="fe mx my mz lr b">@eval</code>是宏，对代码表达式求值。你几乎可以把接下来的看作是一个包含被求值的代码的字符串。就像你可以用美元符号<code class="fe mx my mz lr b">$</code>在字符串中插入值一样，你也可以在代码中这样做。</p><p id="9866" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><code class="fe mx my mz lr b">$T</code>用于将<code class="fe mx my mz lr b">Archer</code>、<code class="fe mx my mz lr b">Pikeman</code>和<code class="fe mx my mz lr b">Knight</code>连续放入定义<code class="fe mx my mz lr b">Soldier</code>子类型的表达式中。</p><p id="9d45" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">与用Python或C++解决同样的问题相比，这可能看起来很复杂。但是你必须记住这是一个更加通用和强大的特性，它允许你做更多的事情，而不仅仅是避免打出相似的复合类型。你也可以用它来生成看起来非常相似但有细微变化的函数。</p><p id="ee19" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">它是Python decorators的一个更强大的版本，几乎可以用来做decorators做的任何事情。</p></div></div>    
</body>
</html>