<html>
<head>
<title>Getting started with JavaFX and FXGL game development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaFX和FXGL游戏开发入门</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/getting-started-with-javafx-and-fxgl-game-development-7f3324727406?source=collection_archive---------11-----------------------#2020-05-17">https://levelup.gitconnected.com/getting-started-with-javafx-and-fxgl-game-development-7f3324727406?source=collection_archive---------11-----------------------#2020-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ddcc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/AlmasB/FXGL" rel="noopener ugc nofollow" target="_blank"> FXGL </a>是由<a class="ae kl" href="https://twitter.com/AlmasBaim" rel="noopener ugc nofollow" target="_blank"> Almas Baimagambetov </a>制作的Java、JavaFX、Kotlin游戏库(引擎)。当我的儿子(快10岁了)挑战我在我“呆在家里的时间”做一个游戏时，我很幸运，Almas提供了一个详细的分步指南。</p><p id="dc13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将是本教程的最终结果:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="8ff1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用JavaFX游戏开发框架<a class="ae kl" href="https://github.com/AlmasB/FXGL" rel="noopener ugc nofollow" target="_blank"> FXGL </a>制作一个<em class="kt">非常</em>简单的《几何战争》克隆版。你可以在我的GitHub 上找到这个帖子的完成项目<a class="ae kl" href="https://github.com/FDelporte/FXGLFirstTest" rel="noopener ugc nofollow" target="_blank">作为Maven项目。</a></p><p id="7d1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要完成这个教程，你首先需要<a class="ae kl" href="https://github.com/AlmasB/FXGL/wiki/Get-FXGL-%28Maven%2C-Gradle%2C-Uber%29" rel="noopener ugc nofollow" target="_blank">通过Maven / Gradle或者作为一个超级jar获得FXGL </a>。确保你用的是FXGL 11，目前最新版本是<code class="fe ku kv kw kx b">11.8</code>。本教程是独立的，不需要以前的FXGL知识。</p><h1 id="f302" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">属国</h1><p id="173e" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我从一个空的Maven项目开始，用这个依赖项扩展了pom.xml文件:</p><pre class="km kn ko kp gt mb kx mc md aw me bi"><span id="6096" class="mf kz iq kx b gy mg mh l mi mj">&lt;dependency&gt;<br/> &lt;groupId&gt;com.github.almasb&lt;/groupId&gt;<br/> &lt;artifactId&gt;fxgl&lt;/artifactId&gt;<br/> &lt;version&gt;11.8&lt;/version&gt; <br/>&lt;/dependency&gt;</span></pre><h1 id="6045" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">密码</h1><p id="4593" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">代码分为两类</p><ul class=""><li id="cd03" class="mk ml iq jp b jq jr ju jv jy mm kc mn kg mo kk mp mq mr ms bi translated">GeoWarsApp.java是主要的应用程序</li><li id="b40b" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated">GeoWarsFactory.java定义了图形元素的外观和行为</li></ul><h1 id="90e6" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">GeoWarsApp最小代码</h1><p id="b816" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">创建一个文件<code class="fe ku kv kw kx b">GeoWarsApp.java</code>，让我们导入所有这些文件，并在本教程的剩余部分中忘记它们。<strong class="jp ir">注意:</strong>静态导入允许我们写例如<code class="fe ku kv kw kx b">getAppHeight()</code>而不是<code class="fe ku kv kw kx b">FXGL.getAppHeight()</code>，这使得代码更干净。</p><pre class="km kn ko kp gt mb kx mc md aw me bi"><span id="28f7" class="mf kz iq kx b gy mg mh l mi mj">import static com.almasb.fxgl.dsl.FXGL.getAppHeight;<br/>import static com.almasb.fxgl.dsl.FXGL.getAppWidth;<br/>import static com.almasb.fxgl.dsl.FXGL.getGameController;<br/>import static com.almasb.fxgl.dsl.FXGL.getGameWorld;<br/>import static com.almasb.fxgl.dsl.FXGL.onBtnDown;<br/>import static com.almasb.fxgl.dsl.FXGL.onCollisionBegin;<br/>import static com.almasb.fxgl.dsl.FXGL.onKey;<br/>import static com.almasb.fxgl.dsl.FXGL.run;<br/>import static com.almasb.fxgl.dsl.FXGL.showMessage;<br/>import static com.almasb.fxgl.dsl.FXGL.spawn;<br/><br/>import com.almasb.fxgl.app.GameApplication;<br/>import com.almasb.fxgl.app.GameSettings;<br/>import com.almasb.fxgl.entity.Entity;<br/>import com.almasb.fxgl.entity.EntityFactory;<br/>import javafx.scene.input.KeyCode;<br/>import javafx.scene.input.MouseButton;<br/>import javafx.util.Duration;</span></pre><h2 id="ee74" class="mf kz iq bd la my mz dn le na nb dp li jy nc nd lm kc ne nf lq kg ng nh lu ni bi translated">游戏类中最少的代码</h2><p id="a1d5" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">本节将介绍每种方法，并解释代码的主要部分。默认情况下，FXGL将游戏大小设置为800x600，这适用于我们的游戏。您可以更改这些和其他各种设置，例如<code class="fe ku kv kw kx b">settings.setWidth(1280)</code>。现在，我们将只设置标题并添加入口点- <code class="fe ku kv kw kx b">main()</code>。</p><pre class="km kn ko kp gt mb kx mc md aw me bi"><span id="226d" class="mf kz iq kx b gy mg mh l mi mj">public class GeoWarsApp extends GameApplication {<br/><br/>    public static void main(String[] args) {<br/>        launch(args);<br/>    }<br/><br/>    @Override<br/>    protected void initSettings(GameSettings settings) {<br/>        settings.setTitle("Geometry Wars");<br/>    }<br/>}</span></pre><h2 id="a59c" class="mf kz iq bd la my mz dn le na nb dp li jy nc nd lm kc ne nf lq kg ng nh lu ni bi translated">定义游戏实体</h2><p id="fcef" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">下一步是考虑游戏对象的类型，它们被称为实体，我们将在游戏中拥有它们。在这个简单的例子中，我们将有玩家、子弹和敌人。为了标记这些类型，我们将创建一个枚举:</p><pre class="km kn ko kp gt mb kx mc md aw me bi"><span id="b95e" class="mf kz iq kx b gy mg mh l mi mj">public enum EntityType {<br/> PLAYER, BULLET, ENEMY <br/>}</span></pre><h1 id="de44" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">地质工厂</h1><p id="2ea6" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在这个工厂中，我们创建元素类型。在FXGL中，有一个创建所有实体的地方，它被称为实体工厂。为了创建您自己的工厂，我们用列出的导入创建了第二个类，其中一些是静态的，以保持代码整洁:</p><pre class="km kn ko kp gt mb kx mc md aw me bi"><span id="542d" class="mf kz iq kx b gy mg mh l mi mj">import static com.almasb.fxgl.dsl.FXGL.entityBuilder;<br/>import static com.almasb.fxgl.dsl.FXGL.getAppHeight;<br/>import static com.almasb.fxgl.dsl.FXGL.getAppWidth;<br/>import static com.almasb.fxgl.dsl.FXGL.getInput;<br/>import static com.almasb.fxgl.dsl.FXGLForKtKt.getGameWorld;</span><span id="b90b" class="mf kz iq kx b gy nj mh l mi mj">import be.webtechie.GeoWarsApp.EntityType;<br/>import com.almasb.fxgl.dsl.components.OffscreenCleanComponent;<br/>import com.almasb.fxgl.dsl.components.ProjectileComponent;<br/>import com.almasb.fxgl.dsl.components.RandomMoveComponent;<br/>import com.almasb.fxgl.entity.Entity;<br/>import com.almasb.fxgl.entity.EntityFactory;<br/>import com.almasb.fxgl.entity.SpawnData;<br/>import com.almasb.fxgl.entity.Spawns;<br/>import javafx.geometry.Point2D;<br/>import javafx.geometry.Rectangle2D;<br/>import javafx.scene.paint.Color;<br/>import javafx.scene.shape.Circle;<br/>import javafx.scene.shape.Rectangle;<br/><br/>public class GeoWarsFactory implements EntityFactory {<br/><br/>}</span></pre><h2 id="803e" class="mf kz iq bd la my mz dn le na nb dp li jy nc nd lm kc ne nf lq kg ng nh lu ni bi translated">定义玩家实体</h2><p id="75ef" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">工厂需要知道如何创建每个实体。因此，对于我们在EntityType枚举中指定的每个类型，首先从<code class="fe ku kv kw kx b">player</code>开始，我们必须提供以下细节:</p><pre class="km kn ko kp gt mb kx mc md aw me bi"><span id="2be0" class="mf kz iq kx b gy mg mh l mi mj">public class GeoWarsFactory implements EntityFactory {<br/><br/>    @Spawns("player")<br/>    public Entity newPlayer(SpawnData data) {<br/>        return entityBuilder()<br/>                .from(data)<br/>                .type(EntityType.PLAYER)<br/>                .viewWithBBox(new Rectangle(30, 30, Color.BLUE))<br/>                .collidable()<br/>                .build();<br/>    }<br/>}</span></pre><p id="71ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，方法签名很重要。它有一个注释，我们稍后可以用它来生成一个播放器。接下来，让我们看看我们是如何定义玩家的。</p><ul class=""><li id="dd49" class="mk ml iq jp b jq jr ju jv jy mm kc mn kg mo kk mp mq mr ms bi translated">我们使用<code class="fe ku kv kw kx b">entityBuilder()</code>来帮助我们这样做。</li><li id="b32e" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated"><code class="fe ku kv kw kx b">.from(data)</code>设置职位等典型属性，从<code class="fe ku kv kw kx b">SpawnData data</code>获取。</li><li id="85ac" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated">我们还通过<code class="fe ku kv kw kx b">.type(EntityType.PLAYER)</code>设置实体的类型。</li><li id="ee77" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated">下一行<code class="fe ku kv kw kx b">.viewWithBBox(new Rectangle(30, 30, Color.BLUE))</code>有两个目的:a)为玩家提供矩形视图，b)为视图中的碰撞生成一个边界框。</li><li id="9bd0" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated">最后，我们将实体标记为<code class="fe ku kv kw kx b">.collidable()</code>并构建它。</li></ul><h2 id="95ca" class="mf kz iq bd la my mz dn le na nb dp li jy nc nd lm kc ne nf lq kg ng nh lu ni bi translated">用项目符号实体扩展</h2><p id="b4e2" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">现在对子弹采用同样的方法…</p><pre class="km kn ko kp gt mb kx mc md aw me bi"><span id="9642" class="mf kz iq kx b gy mg mh l mi mj">public class GeoWarsFactory implements EntityFactory {<br/><br/>    // ...<br/><br/>    @Spawns("bullet")<br/>    public Entity newBullet(SpawnData data) {<br/>        Entity player = getGameWorld()<br/>            .getSingleton(EntityType.PLAYER);</span><span id="81e1" class="mf kz iq kx b gy nj mh l mi mj">        Point2D direction = getInput().getMousePositionWorld()<br/>            .subtract(player.getCenter());<br/><br/>        return entityBuilder()<br/>                .from(data)<br/>                .type(EntityType.BULLET)<br/>                .viewWithBBox(new Rectangle(10, 2, Color.BLACK))<br/>                .collidable()<br/>                .with(new ProjectileComponent(direction, 1000))<br/>                .with(new OffscreenCleanComponent())<br/>                .build();<br/>    }<br/>}</span></pre><p id="c3c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先我们得到玩家实例。第二行计算子弹创建时的行进方向，从玩家中心开始。除了我们上面已经介绍过的API，<code class="fe ku kv kw kx b">.with(new ProjectileComponent(direction, 1000))</code>和<code class="fe ku kv kw kx b">.with(new OffscreenCleanComponent())</code>将<strong class="jp ir">组件</strong>附加到我们的bullet实体上。组件可以包含数据和行为，并为实体带来新的功能。例如，<code class="fe ku kv kw kx b">ProjectileComponent</code>以给定的速度沿<code class="fe ku kv kw kx b">direction</code>每帧移动实体。<code class="fe ku kv kw kx b">OffscreenCleanComponent</code>顾名思义，如果实体超出屏幕边界，就将其从游戏中移除。</p><h2 id="5300" class="mf kz iq bd la my mz dn le na nb dp li jy nc nd lm kc ne nf lq kg ng nh lu ni bi translated">最后，我们有敌人的实体</h2><p id="5e70" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">敌人是我们在EntityType枚举中定义的最后一个。</p><pre class="km kn ko kp gt mb kx mc md aw me bi"><span id="069d" class="mf kz iq kx b gy mg mh l mi mj">public class GeoWarsFactory implements EntityFactory {<br/><br/>    // ...<br/><br/>    @Spawns("enemy")<br/>    public Entity newEnemy(SpawnData data) {<br/>        Circle circle = new Circle(20, 20, 20, Color.RED);<br/>        circle.setStroke(Color.BROWN);<br/>        circle.setStrokeWidth(2.0);<br/><br/>        return entityBuilder()<br/>                .from(data)<br/>                .type(EntityType.ENEMY)<br/>                .viewWithBBox(circle)<br/>                .collidable()<br/>                .with(new RandomMoveComponent(<br/>                    new Rectangle2D(0, 0, <br/>                    getAppWidth(), getAppHeight()), 50))<br/>                .build();<br/>    }<br/>}</span></pre><p id="6f35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们的敌人，我们将使用一个圆作为视图。上面已经介绍了大多数方法，所以我们将重点介绍<code class="fe ku kv kw kx b">RandomMoveComponent</code>。该组件使用提供的矩形边界，在这些边界内随机移动实体。这个简单的行为对我们的小游戏来说已经足够了。</p><p id="edba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在已经完成了工厂类！</p><h1 id="08a7" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">GeoWarsApp进一步扩展</h1><p id="cbc4" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">现在FXGL知道了如何创建实体，让我们回到应用程序类GeoWarsApp来添加输入和逻辑。</p><p id="06f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们添加一个对工厂和我们的播放器的引用，这将在后面生成。</p><pre class="km kn ko kp gt mb kx mc md aw me bi"><span id="9cb6" class="mf kz iq kx b gy mg mh l mi mj">public class GeoWarsApp extends GameApplication {<br/><br/>    private final GeoWarsFactory geoWarsFactory = new GeoWarsFactory();<br/>    private Entity player;<br/>    <br/>    // .. other code<br/>}</span></pre><p id="2a1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用这个引用，我们可以开始添加一些用户操作，称为输入处理:</p><pre class="km kn ko kp gt mb kx mc md aw me bi"><span id="f774" class="mf kz iq kx b gy mg mh l mi mj">@Override<br/>protected void initInput() {<br/>    onKey(KeyCode.W, () -&gt; player.translateY(-5));<br/>    onKey(KeyCode.S, () -&gt; player.translateY(5));<br/>    onKey(KeyCode.A, () -&gt; player.translateX(-5));<br/>    onKey(KeyCode.D, () -&gt; player.translateX(5));<br/>    onBtnDown(MouseButton.PRIMARY, () -&gt; <br/>        spawn("bullet", player.getCenter()));<br/>}</span></pre><p id="a8c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码应该是不言自明的，并且利用了Java 8+ lambda符号。如果您希望能够在按下鼠标按钮的同时进行拍摄，而不是只按一次，您可以将<code class="fe ku kv kw kx b">onBtnDown</code>更改为<code class="fe ku kv kw kx b">onBtn</code>。</p><p id="f7da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的游戏中还增加了另外两个东西:初始化逻辑和物理。不要担心，虽然这听起来很复杂，但事实并非如此。初始化逻辑:</p><pre class="km kn ko kp gt mb kx mc md aw me bi"><span id="2fcb" class="mf kz iq kx b gy mg mh l mi mj">@Override<br/>protected void initGame() {<br/>    getGameWorld().addEntityFactory(geoWarsFactory);<br/><br/>    player = spawn("player", getAppWidth() / 2 - 15, getAppHeight() / 2 - 15);<br/>    geoWarsFactory.setPlayer(player);<br/><br/>    run(() -&gt; spawn("enemy"), Duration.seconds(1.0));<br/>}</span></pre><p id="2f57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将我们的工厂添加到游戏世界中，这样我们就可以使用像<code class="fe ku kv kw kx b">spawn()</code>这样的方法。接下来，我们通过在游戏中心生成玩家实体来初始化我们的<code class="fe ku kv kw kx b">player</code>引用。我们还需要为我们的geoWarsFactory提供这个播放器，因为它需要它来定义新子弹的起点。</p><p id="e3cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一个调用设置了一个每秒运行一次的计时器。你能猜出每秒钟发生了什么吗？答案是:<code class="fe ku kv kw kx b">spawn("enemy")</code>，即产生了一个新的敌人实体。由于我们不提供任何位置，敌人实体将在<code class="fe ku kv kw kx b">(0,0)</code>出现。</p><p id="2a73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">物理代码很简单，因为我们已经设置了最复杂的东西:</p><pre class="km kn ko kp gt mb kx mc md aw me bi"><span id="ccb1" class="mf kz iq kx b gy mg mh l mi mj">@Override<br/>protected void initPhysics() {<br/>    onCollisionBegin(EntityType.BULLET, EntityType.ENEMY, (bullet, enemy) -&gt; {<br/>        bullet.removeFromWorld();<br/>        enemy.removeFromWorld();<br/>    });<br/><br/>    onCollisionBegin(EntityType.ENEMY, EntityType.PLAYER, (enemy, player) -&gt; {<br/>        showMessage("You Died!", () -&gt; {<br/>            getGameController().startNewGame();<br/>        });<br/>    });<br/>}</span></pre><p id="a352" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们设置了两个冲突处理程序。第一个处理子弹型和敌人型的碰撞。当这样的冲突发生时，我们简单地从游戏中移除两个实体。在第二个处理程序中，我们显示了一个信息对话框，文本为“你死了！”并重新开始游戏。</p><h1 id="5d54" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nk"><img src="../Images/6bced4e56e1db37a7c4d6d437b60d18b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8GUJH2BoNNXdbmHNDsrQXg.png"/></div></div></figure><p id="fa8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在IDE的main方法上点击run，就这样！用FXGL创建的第一个JavaFX游戏。</p><p id="2929" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以从<a class="ae kl" href="https://github.com/FDelporte/FXGLFirstTest" rel="noopener ugc nofollow" target="_blank">github.com/FDelporte/FXGLFirstTest</a>那里得到完成的源代码。</p><p id="7112" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">访问<a class="ae kl" href="https://github.com/AlmasB/FXGL/wiki/FXGL-11" rel="noopener ugc nofollow" target="_blank"> FXGL wiki </a>获取更多教程。从<a class="ae kl" href="https://fxgl.itch.io/" rel="noopener ugc nofollow" target="_blank"> itch.io </a>可以获得预建的游戏，让你知道FXGL可以实现什么。更复杂的例子可以在<a class="ae kl" href="https://github.com/AlmasB/FXGLGames" rel="noopener ugc nofollow" target="_blank"> FXGLGames </a>找到。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="be33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kt">最初发布于</em><a class="ae kl" href="https://webtechie.be/post/2020-05-07-getting-started-with-fxgl/" rel="noopener ugc nofollow" target="_blank"><em class="kt">https://web techie . be</em></a><em class="kt">。</em></p></div></div>    
</body>
</html>