<html>
<head>
<title>What Are iOS App Lifecycle Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是iOS应用生命周期方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-are-ios-app-lifecycle-methods-cc1c8c4dcb7f?source=collection_archive---------3-----------------------#2022-01-03">https://levelup.gitconnected.com/what-are-ios-app-lifecycle-methods-cc1c8c4dcb7f?source=collection_archive---------3-----------------------#2022-01-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="81a4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解iOS版本12-和13+之间的细微差别</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2501c985c5c2299b38e56eccb9b3e32e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fFbvDDRY_niZaH5z"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@currentspaces?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布兰登·罗马丘克</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="d1a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将了解iOS应用程序的生命周期。此外，我们还将通过在模拟器中测试那些生命周期方法的执行来探索iOS 12和13中生命周期的差异。这是本教程结束时您将学到的内容:</p><ul class=""><li id="0eb5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们可以用什么方法来监控生命周期</li><li id="c2ed" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">调用这些方法的顺序</li><li id="bc82" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">iOS版本如何影响<em class="mj">调用什么</em>方法</li></ul><p id="bda5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文底部提供了一个示例项目的源代码。事不宜迟，我们开始吧。</p><h1 id="1391" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">我们开始吧</h1><p id="aad9" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们从一个几乎是空的项目开始，只有一个屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/e38f74743c196c49e938636fe08c2801.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*-CNA7NxcbIIb80ENoELBVg.png"/></div></figure><p id="a8eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的目标是实现生命周期方法，然后看看它们被调用的顺序。此外，我们还想知道每种方法最适合什么。在我们开始研究代码之前，让我们回顾一下任何iOS应用程序的状态:</p><ul class=""><li id="814f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">非活动-应用程序进程处于前台，但它无法响应事件。</li><li id="cb12" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">活动-应用程序进程处于前台，可以响应事件。</li><li id="a7d0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">后台-应用程序进程在后台运行，并执行一些逻辑。</li><li id="964b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">暂停-应用程序进程在后台运行，但不执行任何逻辑。</li><li id="20fa" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">未运行-应用程序进程未启动，这意味着它既不在前台也不在后台。</li></ul><p id="4cef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从<code class="fe ni nj nk nl b">AppDelegate</code>开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="85db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们添加以下方法:</p><ul class=""><li id="2fab" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">application(_:willFinishLaunchingWithOptions:)</code> —应用程序启动时调用。在调用该方法时，我们的应用程序处于非活动状态，但它已经加载了主故事板。此外，<a class="ae ky" href="https://developer.apple.com/documentation/uikit/view_controllers/preserving_your_app_s_ui_across_launches" rel="noopener ugc nofollow" target="_blank">状态恢复</a>(从用户上次使用该应用程序时恢复屏幕层次和UI状态)尚未开始。有<code class="fe ni nj nk nl b">userInfo</code>参数，我们可以用它来确定应用程序启动的原因。例如，如果启动应用程序是为了打开特定URL上的文档，我们可能希望阻止状态恢复的发生。要了解更多可能的发布原因，请访问<a class="ae ky" href="https://developer.apple.com/documentation/uikit/uiapplication/launchoptionskey" rel="noopener ugc nofollow" target="_blank">文档</a>。</li><li id="3c49" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">application(_:didFinishLaunchingWithOptions:)</code> —当我们的应用程序启动时被调用，如果需要，应用程序的<a class="ae ky" href="https://developer.apple.com/documentation/uikit/uiscenedelegate/restoring_your_app_s_state" rel="noopener ugc nofollow" target="_blank">状态被恢复</a>。但是，UI还没有显示出来。就像前面的方法一样，也有<code class="fe ni nj nk nl b">userInfo</code>参数。正如苹果指出的，这是执行与该属性相关的逻辑的最后机会。</li><li id="ddd8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">applicationWillEnterForeground(_:)</code> —调用不支持<a class="ae ky" href="https://developer.apple.com/documentation/uikit/app_and_environment/scenes" rel="noopener ugc nofollow" target="_blank">场景</a>的应用。否则，它将被它的<code class="fe ni nj nk nl b">sceneWillEnterForeground(_:)</code>协变所取代，我们将在稍后检查<code class="fe ni nj nk nl b">SceneDelegate</code>时深入探讨这一点。当应用程序从后台进入活动状态<em class="mj">时，该方法被调用。</em></li><li id="b950" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">applicationDidBecomeActive(_:)</code> —在不支持<a class="ae ky" href="https://developer.apple.com/documentation/uikit/app_and_environment/scenes" rel="noopener ugc nofollow" target="_blank">场景</a>的应用中调用。否则，它将被其在<code class="fe ni nj nk nl b">SceneDelegate</code>中的<code class="fe ni nj nk nl b">sceneDidBecomeActive(_:)</code>协变所取代。当应用程序进入活动状态时，将调用方法。此时，UI已经加载，但尚未显示。</li><li id="a625" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">applicationWillResignActive(_:)</code> —在不支持<a class="ae ky" href="https://developer.apple.com/documentation/uikit/app_and_environment/scenes" rel="noopener ugc nofollow" target="_blank">场景</a>的应用中调用。否则，它就被它的<code class="fe ni nj nk nl b">sceneWillResignActive(_:)</code> <strong class="lb iu">替换为<code class="fe ni nj nk nl b">SceneDelegate</code>中的</strong>协变。当应用程序被系统警报、电话呼叫等中断时，会调用该方法。当我们使用Home键关闭应用程序时，我们也会触发它。我们可以使用这个方法来保存未保存的数据。例如，我们可能希望将项目列表保存在磁盘中，这样，如果系统终止了应用程序，或者我们强制退出它，下次启动它时，我们可以再次看到所有项目。</li><li id="1c64" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">applicationDidEnterBackground(_:)</code> —在不支持<a class="ae ky" href="https://developer.apple.com/documentation/uikit/app_and_environment/scenes" rel="noopener ugc nofollow" target="_blank">场景</a>的应用中调用。否则，就用它在<code class="fe ni nj nk nl b">SceneDelegate</code>中的<code class="fe ni nj nk nl b">sceneDidEnterBackground(_:)</code> <strong class="lb iu"> </strong>共变来代替。当我们将应用程序移动到后台时，会调用该方法。在这里，我们需要确保停止计时器，减少应用程序的内存使用，如果必要的话，为应用程序终止时的状态恢复做准备。另外，<em class="mj">在</em>该方法返回后，UIKit会对应用的最新UI进行快照，以显示在应用切换器中。因此，我们需要对UI隐藏用户的敏感信息，比如密码。</li><li id="e9c8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">applicationWillTerminate(_:)</code> —当应用程序即将被终止并从内存中删除时，调用此方法。对于不支持后台模式的应用程序，它总是被调用。然而，对于具有后台功能的应用程序，该方法通常不被调用，因为应用程序进入后台状态。另一方面，如果系统决定释放内存并终止后台的应用程序，那么这个方法就会被调用。</li></ul><p id="e328" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ni nj nk nl b">AppDelegate</code>做完了，现在我们来检查一下<code class="fe ni nj nk nl b">SceneDelegate</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="547d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有这些方法:</p><ul class=""><li id="6672" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">scene(_:willConnectTo:options:)</code> —当应用程序请求用户界面时调用。如<a class="ae ky" href="https://developer.apple.com/documentation/uikit/app_and_environment/scenes" rel="noopener ugc nofollow" target="_blank">场景文档</a>中所述，场景包含一个窗口和视图控制器。所以本质上，当我们添加一个场景到应用程序时，这个方法被调用。大多数app只有一个场景，所以这种情况下会调用一次这个方法。在该方法中，我们配置了层次结构，并为窗口设置了根视图控制器。例如:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><ul class=""><li id="3bfa" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">sceneWillEnterForeground(_:)</code> —就像它的非场景对应物<code class="fe ni nj nk nl b">applicationWillEnterForeground(_:)</code>一样，当应用程序处于前台非活动状态并准备显示给用户时，该方法被调用。</li><li id="c6ce" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">sceneDidBecomeActive(_:)</code> —与<code class="fe ni nj nk nl b">applicationDidBecomeActive(_:)</code>相同，当UI进入前台活动模式且UI已加载但尚未显示时，调用该方法。</li><li id="7461" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">sceneWillResignActive(_:)</code> —正如它的非场景协变<code class="fe ni nj nk nl b">applicationWillResignActive(_:)</code>一样，当应用程序被电话或系统警报中断时，该方法被调用。我们也可以通过点击Home键来触发它。</li><li id="2526" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">sceneDidEnterBackground(_:)</code> —当应用程序不再出现在屏幕上时调用。正如苹果建议的那样，我们可以使用这种方法来减少场景的内存使用，并从屏幕上隐藏敏感的用户信息，因为在这种方法返回后，UIKit将创建UI的快照，并在应用程序切换器中显示它。</li><li id="70b5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">sceneDidDisconnect(_:)</code> —当用户通过关闭应用切换器从应用中移除场景时调用。如果需要，系统还可以断开场景以释放内存空间。</li></ul><p id="dc32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成方法描述后，现在让我们检查调用这些方法的顺序和条件。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="125d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了查看被调用的每个方法的名称，我们在添加到<code class="fe ni nj nk nl b">AppDelegate</code>和<code class="fe ni nj nk nl b">SceneDelegate</code>的每个方法中包含了<code class="fe ni nj nk nl b">print(#function)</code>命令:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a6cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以很容易地测试这些方法的执行。首先，我们将在iOS 13+模拟器上测试它，然后在iOS 12 one上测试。</p><h1 id="a6db" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">在iOS 13+上测试</h1><ul class=""><li id="cd99" class="lv lw it lb b lc nc lf nd li nv lm nw lq nx lu ma mb mc md bi translated">启动应用程序:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/6c38d9fd08e4e4fb16ea1fdd7b1d534b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*D-xIih3l_hXq3u0aVL-_fg.gif"/></div></div></figure><ul class=""><li id="58d8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">关闭应用程序:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/1e6a0c4356aebcd9b09c939c9fd8f4bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8DZ_nuLqsVYLHZurMjDOMw.gif"/></div></div></figure><ul class=""><li id="8355" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">将应用移至后台，而不是关闭:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/81d42c7ba6ea83e5fc906af8f8787729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xGPwKXjds0oNO7YELyaFJA.gif"/></div></div></figure><ul class=""><li id="4069" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">从后台返回应用程序:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/32525cd0302cc2e46229954931e8ff9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*4R7Lx044k-os6Q6qCqJZYA.gif"/></div></div></figure><p id="f814" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们用一个iOS 12模拟器做同样的事情。</p><h1 id="f627" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">在iOS 12上测试</h1><ul class=""><li id="33db" class="lv lw it lb b lc nc lf nd li nv lm nw lq nx lu ma mb mc md bi translated">启动应用程序:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi gj"><img src="../Images/0b038d57bc4c6505bfffafea2d39c17f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8sXEDoG5AByFBmiMPPSa1Q.gif"/></div></div></figure><ul class=""><li id="f2d0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">关闭应用程序:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi gj"><img src="../Images/d3c217dd87300b5398be68afbf0b6d4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xeFrNp09bSFbhy5vrzYvQw.gif"/></div></div></figure><ul class=""><li id="aa32" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">将应用移至后台，而不是关闭:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi gj"><img src="../Images/044a402bc9dfe8852a2cf5592de0c2f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*hHk-uYrXswLv2aBbnYS0Vw.gif"/></div></div></figure><ul class=""><li id="e85f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">从后台返回应用程序:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi gj"><img src="../Images/d1f6c538020a65a94ebbdcbb0c7752e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fX7e3i-6Yw5jZvCteCaTnA.gif"/></div></div></figure><h1 id="8682" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">检查差异</h1><p id="26ef" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">正如我们在上面看到的，执行在某些阶段是不同的。</p><ol class=""><li id="847c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu oa mb mc md bi translated">当应用程序在iOS 13+上启动时，这些方法会运行:</li></ol><ul class=""><li id="8324" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">application(_:willFinishLaunchingWithOptions:)</code>，</li><li id="06bb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">application(_:didFinishLaunchingWithOptions:)</code>，</li><li id="0e9b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">scene(_:willConnectTo:options:),</code></li><li id="ed36" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">sceneWillEnterForeground(_:)</code>，</li><li id="69d5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">sceneDidBecomeActive(_:)</code>。</li></ul><p id="7812" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在iOS 12上，我们只看到三种方法在运行:</p><ul class=""><li id="9d6a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">application(_:willFinishLaunchingWithOptions:)</code>，</li><li id="95f0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">application(_:didFinishLaunchingWithOptions:)</code>，</li><li id="a049" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">applicationDidBecomeActive(_:)</code>。</li></ul><p id="06c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里最明显的区别是在iOS 12上没有调用<code class="fe ni nj nk nl b">applicationWillEnterForeground(_:)</code>方法，尽管在iOS 13+上<code class="fe ni nj nk nl b">sceneWillEnterForeground(_:)</code>是它的替代品，并且它是在iOS 13设备上执行的。</p><p id="1f22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.当应用在iOS 13+上被终止时，这些方法被运行:</p><ul class=""><li id="8cb8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">sceneWillResignActive(_:)</code></li><li id="4303" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">sceneDidDisconnect(_:)</code></li><li id="8164" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">applicationWillTerminate(_:)</code></li></ul><p id="827f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在iOS 12上，我们看到这些方法正在执行:</p><ul class=""><li id="20fb" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">applicationWillResignActive(_:)</code></li><li id="e035" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">applicationDidEnterBackground(_:)</code></li><li id="6fcb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">applicationWillTerminate(_:)</code></li></ul><p id="93a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们注意到，在iOS 12上，应用程序在被终止之前被移到了后台，而在iOS 13+上，协变方法<code class="fe ni nj nk nl b">sceneDidEnterBackground(_:)</code>没有被调用。</p><p id="f322" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.在iOS 13+上，当应用程序只是被解除而不是终止时，这些方法会运行:</p><ul class=""><li id="ba6c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">sceneWillResignActive(_:)</code></li><li id="4a3d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">sceneDidEnterBackground(_:)</code></li></ul><p id="2a6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在iOS 12上:</p><ul class=""><li id="45c0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">applicationWillResignActive(_:)</code></li><li id="285c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">applicationDidEnterBackground(_:)</code></li></ul><p id="22fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个阶段，我们没有注意到任何不同，因为正如官方文档所说，iOS 12及之前版本的<code class="fe ni nj nk nl b">application</code>方法被iOS 13及以后版本的<code class="fe ni nj nk nl b">scene</code>方法所取代。</p><p id="4eaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.在iOS 13+上，当我们将应用从后台移回活动状态时，我们看到打印了以下方法:</p><ul class=""><li id="a1ad" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">sceneWillEnterForeground(_:)</code></li><li id="25f0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">sceneDidBecomeActive(_:)</code></li></ul><p id="fa03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在iOS 12上:</p><ul class=""><li id="e3f3" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">applicationWillEnterForeground(_:)</code></li><li id="68dd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ni nj nk nl b">applicationDidBecomeActive(_:)</code></li></ul><p id="66e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像上一步一样，这里我们也没有执行的区别。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="56a5" class="mk ml it bd mm mn ob mp mq mr oc mt mu jz od ka mw kc oe kd my kf of kg na nb bi translated">资源</h1><p id="e2f2" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">源代码可在<a class="ae ky" href="https://github.com/zafarivaev/app-lifecycle-methods" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><h1 id="fb6b" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">包扎</h1><p id="a4a7" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">要了解更多关于应用生命周期的信息，包括场景和状态恢复，请访问<a class="ae ky" href="https://developer.apple.com/documentation/uikit/app_and_environment/managing_your_app_s_life_cycle" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><p id="f553" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>