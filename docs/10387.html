<html>
<head>
<title>When Vue Meets Proxy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当Vue遇到代理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/when-vue-meets-proxy-402e9e3c6722?source=collection_archive---------6-----------------------#2021-11-30">https://levelup.gitconnected.com/when-vue-meets-proxy-402e9e3c6722?source=collection_archive---------6-----------------------#2021-11-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7a7c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">检查vue的内部。JS揭示它如何使用代理来实现反应</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e007d5f1df4cfa44200a6d171a74100d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w9sijI5MTZziYCYRtcyqJA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@wocintechchat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯蒂娜@ wocintechchat.com</a>在<a class="ae ky" href="https://unsplash.com/s/photos/meet?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="3b8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反应性是每个现代JavaScript框架的基本特征，Vue.js也不例外。但是反应性到底是什么意思呢？有很多不同的答案。其中许多都过于复杂和混乱。</p><p id="f07d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我试着简单解释一下。</p><p id="da5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">向前跳:</p><ul class=""><li id="e7b6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="#e9c0" rel="noopener ugc nofollow"> Vue 2数据反应性</a></li><li id="b55f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#f598" rel="noopener ugc nofollow">Vue 3中的代理</a></li><li id="fb8a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#7735" rel="noopener ugc nofollow">ES6中的代理</a></li><li id="50fc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#8c49" rel="noopener ugc nofollow">代理如何在Vue 3中工作</a></li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="83d4" class="mq mr it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated">反应</h2><p id="5f9b" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">反应性是让你的程序以声明的方式对异步数据流做出反应的能力。</p><p id="f7fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反应性的典型例子如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/7cca6cf55d1da842b625e5b1a0efec5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*8wVZzCXQDkr85QcOXBKirg.png"/></div></figure><p id="572f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图通过Rxjs说明了反应性。订阅者(即UI组件)订阅发布者(即可观察)。当状态发生变化时，发布者将使用<code class="fe np nq nr ns b">.next</code>推送数据流，订阅者接收数据并对数据变化做出反应。</p><p id="e5cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Vue.js如何实现反应性？我们来看看Vue 2。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="e9c0" class="mq mr it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated">Vue 2数据反应性</h2><p id="fd2e" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在Vue 2中，数据反应是通过遍历数据并利用<code class="fe np nq nr ns b">Object.definedProperty()</code>将其属性转换为getter/setter来实现的。它通过一个定制的getter收集数据依赖，并在一个定制的setter中监视数据更改和订阅事件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/dfe10789e3f5cd26ee803444e39fc759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*HhumaJOXdbqJyG9G7rAF7g.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://vuejs.org/v2/guide/reactivity.html" rel="noopener ugc nofollow" target="_blank">https://vuejs.org/v2/guide/reactivity.html</a></figcaption></figure><p id="d22b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是Vue 2源代码关于反应性实现的要点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="ce7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该代码块是从<code class="fe np nq nr ns b">defineReactive</code>函数<em class="nw">中提取的。当初始化<code class="fe np nq nr ns b">Observer</code>时，数据对象的所有属性都调用<code class="fe np nq nr ns b"><em class="nw">defineReactive</em></code>函数。您可以看到getter被定义为收集依赖项，该设置将监视数据更改并在检测到更改时发送通知。</em></p><p id="e6be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然上述机制有效，但它确实存在一些问题。两个主要的是:</p><ul class=""><li id="f597" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">无法检测属性</strong>的删除或添加。反应仅在应用程序初始化时应用。当您在运行时添加一个新属性时，这个新属性将不会是被动的。换句话说，属性值的改变不会触发反应性副作用。Vue 2确实提供了一种变通的<code class="fe np nq nr ns b">.set</code>方法，允许开发人员手动添加一个属性来进行反应。</li><li id="38ce" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">性能</strong>:对于一个大的和/或嵌套的数据集，性能可能会受到负面影响，因为Vue 2需要横切所有属性的数据和创建getter/setter。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="f598" class="mq mr it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated">Vue 3中的代理</h2><p id="b77d" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在<a class="ae ky" href="https://evanyou.me/" rel="noopener ugc nofollow" target="_blank">尤雨溪</a>的文章“<a class="ae ky" href="https://increment.com/frontend/making-vue-3/" rel="noopener ugc nofollow" target="_blank">过程:制作Vue 3 </a>”中，他提到重写的原因之一是利用新的语言特性，如“代理”。</p><blockquote class="nx ny nz"><p id="ac5b" class="kz la nw lb b lc ld ju le lf lg jx lh oa lj lk ll ob ln lo lp oc lr ls lt lu im bi translated">其中最值得注意的是<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener ugc nofollow" target="_blank">代理</a>，它允许框架拦截对象上的操作。Vue的一个核心特性是能够监听对用户定义的状态所做的更改，并反应性地更新DOM。Vue 2通过用getters和setters替换状态对象的属性来实现这种反应性。切换到代理将允许我们消除Vue现有的限制，例如无法检测新的属性添加，并提供更好的性能。</p></blockquote><p id="2c88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Vue 3中，使用代理是解决Vue 2中反应性相关问题的关键。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="7735" class="mq mr it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated">ES6中的代理</h2><p id="d1bf" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在ES6中引入的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener ugc nofollow" target="_blank">代理</a>支持在不直接访问对象的情况下定义自定义行为。它的工作原理是作为中间代理进行拦截。</p><p id="5297" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代理的使用很简单。</p><pre class="kj kk kl km gt od ns oe of aw og bi"><span id="204f" class="mq mr it ns b gy oh oi l oj ok">const proxy = new Proxy(target, handler);</span></pre><p id="4a78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述声明包括:</p><ul class=""><li id="bb69" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">目标:要代理的对象</li><li id="d35b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">处理程序:它包含“陷阱”方法。它们是覆盖原始行为的函数。对于任何可用的基本操作，都有相应的陷阱。</li></ul><p id="c651" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子展示了如何使用代理基于<code class="fe np nq nr ns b">firstName</code>和<code class="fe np nq nr ns b">surName</code>创建<code class="fe np nq nr ns b">name</code>属性。</p><pre class="kj kk kl km gt od ns oe of aw og bi"><span id="9a74" class="mq mr it ns b gy oh oi l oj ok">const handler = {<br/>  get: function(target, name) {<br/>    return name<!-- -->=== 'Name' ? '${target.firstName} ${target.surName}' : target[<!-- -->name<!-- -->];<br/>  }<br/>}<br/><br/>const p = new Proxy({firstName: 'Peter;, surName: 'Lee'}, handler)<br/>console.log(p.name) // 'Peter Lee'</span></pre><p id="ef4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，使用Proxy会创建一个新的代理实例，而不是更改原来的目标对象。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="8c49" class="mq mr it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated">Vue 3中代理的工作方式</h2><p id="88fb" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">让我们来看看Proxy在Vue 3中是如何实现的。Vue 3中反应性的核心在<code class="fe np nq nr ns b">createReactiveObject</code>功能中实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="f9e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述代码的要点是:</p><ul class=""><li id="a020" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">原始类型的数据将被直接返回，因为我们在这里只想处理对象。Vue 3使用<a class="ae ky" href="https://v3.vuejs.org/api/refs-api.html" rel="noopener ugc nofollow" target="_blank"> ref </a>来处理原始类型。在内部，它还利用了反应式代理对象。</li><li id="0301" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果对象已经有了相应的代理，我们直接返回缓存的代理。</li><li id="aa67" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">推断目标对象类型，vue3将只为数组、对象、贴图、集合、WeakMap和WeakSet创建代理。目标类型之外的对象将被设置为无效并被返回。</li><li id="0336" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">创建新的代理对象，并在返回之前将其保存到<code class="fe np nq nr ns b">proxyMap </code>缓存中。</li></ul><p id="732f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Proxy如何解决Vue 2反应性问题？</p><p id="5a20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用代理对象，任何访问或修改对象的调用都将被拦截。自定义操作是在getter和setter中定义的。比如在<code class="fe np nq nr ns b">createSetter </code>函数中，处理的是添加属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="46d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果该属性不存在(<code class="fe np nq nr ns b">hadKey </code>为假)，则使用trigger方法通知依赖项添加了新属性。这解决了Vue 2中无法检测添加属性的问题。类似地，<code class="fe np nq nr ns b">deleteProperty </code>处理程序操作解决了无法检测Vue 2中删除属性的问题。</p><p id="21c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Vue 3中reactivity API的代理实现，不需要遍历数据中的所有属性。这在处理大型数据集时带来了显著的性能提升。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="2289" class="mq mr it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated">结论</h2><p id="4d97" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在本文中，我们讨论如何从Vue 2到Vue 3实现反应性。</p><p id="fdf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代理是一个强大的<a class="ae ky" href="https://en.wikipedia.org/wiki/Metaprogramming" rel="noopener ugc nofollow" target="_blank"> <em class="nw">元编程</em> </a>特性。Vue 3中代理的应用是一个优雅的解决方案。它不仅解决了来自Vue 2的警告，而且还打开了进一步扩展的潜力。</p><p id="5eec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">了解内部机制将有助于您编写更好的代码。</p><p id="87ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你觉得这篇文章有用，你也可以看看下面这篇。</p><div class="ol om gp gr on oo"><a rel="noopener  ugc nofollow" target="_blank" href="/typescript-compiler-and-compiler-api-part-1-4bb0d24a565e"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">TypeScript编译器和编译器API(第1部分)</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">解释了TypeScript编译器的内部</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ks oo"/></div></div></a></div><p id="de3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>