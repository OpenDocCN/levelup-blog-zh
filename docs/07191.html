<html>
<head>
<title>Writing an RPC server in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中编写RPC服务器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/writing-an-rpc-server-in-go-eb9afd56d1e1?source=collection_archive---------3-----------------------#2021-01-31">https://levelup.gitconnected.com/writing-an-rpc-server-in-go-eb9afd56d1e1?source=collection_archive---------3-----------------------#2021-01-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/58fba04e0fec248d29661ebb33185087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vy7DDRn_mGMmc8jy_G1PbA.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">RPC的图示</figcaption></figure><div class=""/><div class=""><h2 id="9253" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated"><em class="ku">本文是GoLang系列文章</em> <a class="ae kv" href="https://sumit-agarwal.medium.com/golang-building-a-web-server-2d34d4f90fa1" rel="noopener"> <em class="ku">的一部分:构建Web服务器</em> </a></h2></div><p id="7e44" class="pw-post-body-paragraph kw kx jf ky b kz la kg lb lc ld kj le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嘿，各位编码员，在上一篇文章<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/writing-fx-modules-517193b9c4f0">中，我们学习了如何编写Fx模块，并在我们的项目中添加了一个日志模块。继续使用相同的代码库，我们将添加对服务RPC请求的支持。</a></p><h2 id="9c36" class="ls lt jf bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">RPC是什么？</h2><p id="dcd7" class="pw-post-body-paragraph kw kx jf ky b kz ml kg lb lc mm kj le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">RPC代表<a class="ae kv" href="https://users.cs.cf.ac.uk/Dave.Marshall/C/node33.html" rel="noopener ugc nofollow" target="_blank">远程过程调用</a>。这是一种<a class="ae kv" href="https://www.geeksforgeeks.org/inter-process-communication-ipc" rel="noopener ugc nofollow" target="_blank">进程间通信</a>,使用间接方法在接收方和发送方之间传递消息，以便在两者之间建立通道。</p><p id="e9ec" class="pw-post-body-paragraph kw kx jf ky b kz la kg lb lc ld kj le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">RPC通常用于客户机/服务器体系结构中进行通信。RPC被广泛使用和接受的主要原因是它能够分离物理层和逻辑层。参与通信的任何一方都不需要理解对方的实现细节或传输机制，他们只关心输入和输出。</p><h2 id="91e8" class="ls lt jf bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">一个基本的RPC服务器</h2><p id="e104" class="pw-post-body-paragraph kw kx jf ky b kz ml kg lb lc mm kj le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们将使用Go的<code class="fe mq mr ms mt b">net/rpc</code>包来构建我们的RPC服务器。为此，我们需要对到目前为止编写的代码进行一些修改。</p><ol class=""><li id="2b0a" class="mu mv jf ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">我们将在<code class="fe mq mr ms mt b">onStart</code>钩子块中添加一个<code class="fe mq mr ms mt b">net.Listen</code>,这将确保我们监听RPC请求</li></ol><pre class="nd ne nf ng gt nh mt ni nj aw nk bi"><span id="b730" class="ls lt jf mt b gy nl nm l nn no">// start the rpc server<br/>l, err := net.Listen("tcp", ":8081")<br/>logger.Errorf("Error while starting rpc server: %+v", err)<br/>go func() {<br/>   for {<br/>      rpc.Accept(l)<br/>   }<br/>}()<br/>logger.Info("Listening on port 8081 for RPC requests")</span></pre><p id="2c2e" class="pw-post-body-paragraph kw kx jf ky b kz la kg lb lc ld kj le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">goroutine中的for循环确保我们监听所有从端口8081上无限发出的请求。到目前为止，RPC还没有什么特别的。</p><p id="b0a8" class="pw-post-body-paragraph kw kx jf ky b kz la kg lb lc ld kj le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.接下来，我们添加一个简单的RPC处理程序，它的工作是通过网络公开一个方法。</p><pre class="nd ne nf ng gt nh mt ni nj aw nk bi"><span id="962a" class="ls lt jf mt b gy nl nm l nn no">import (<br/>   "net/rpc"<br/>)</span><span id="ee1d" class="ls lt jf mt b gy np nm l nn no">// User message<br/>type User struct {<br/>   // The user name<br/>   Name string<br/>   // The user age<br/>   Age int32<br/>}</span><span id="2c8f" class="ls lt jf mt b gy np nm l nn no">// Handler is the struct which exposes the User Server methods<br/>type Handler struct {<br/>}<br/><br/>// New returns the object for the RPC handler<br/>func New() *Handler {<br/>   h := &amp;Handler{}<br/>   err := rpc.Register(h)<br/>   if err != nil {<br/>      panic(err)<br/>   }<br/>   return h<br/>}<br/><br/>// GetUsers function returns the list of users<br/>func (rh *Handler) GetUsers(payload int, reply *string) error {<br/>   // add logic to return users<br/>   return nil<br/>}</span></pre><p id="07db" class="pw-post-body-paragraph kw kx jf ky b kz la kg lb lc ld kj le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nq">注意:为了便于理解，我在代码中添加了用户实体，它与RPC的核心逻辑无关。</em></p><p id="bbce" class="pw-post-body-paragraph kw kx jf ky b kz la kg lb lc ld kj le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.最后的改变是为我们的Fx模块提供服务器，这样它就可以被初始化了。</p><pre class="nd ne nf ng gt nh mt ni nj aw nk bi"><span id="231f" class="ls lt jf mt b gy nl nm l nn no">fx.New(<br/>   ...<br/>   fx.Provide(rpcServer.New),<br/>).Run()</span></pre><p id="fc1f" class="pw-post-body-paragraph kw kx jf ky b kz la kg lb lc ld kj le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们就有了我们的RPC服务器。我们需要做的就是执行<code class="fe mq mr ms mt b">go run main.go</code></p><p id="2f60" class="pw-post-body-paragraph kw kx jf ky b kz la kg lb lc ld kj le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仍然没有答案的问题是，在没有RPC客户端的情况下，我如何测试我的RPC服务器？下面的代码片段帮助您测试您的服务器。您可以将它作为一个独立的main方法运行，并对其进行测试。发生了什么事！</p><pre class="nd ne nf ng gt nh mt ni nj aw nk bi"><span id="df0d" class="ls lt jf mt b gy nl nm l nn no">client, _ := rpc.Dial("tcp", "localhost:8081")<br/><br/>if err := client.Call("Handler.GetUsers", 1, nil); err != nil {<br/>    fmt.Printf("Error:1 user.GetUsers() %+v", err)<br/>} else {<br/>    fmt.Printf("user found")<br/>}</span></pre><p id="3478" class="pw-post-body-paragraph kw kx jf ky b kz la kg lb lc ld kj le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请在<a class="ae kv" href="https://github.com/sumiet/medium_webserver_series/tree/master/4" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到上面写的代码。</p><p id="87da" class="pw-post-body-paragraph kw kx jf ky b kz la kg lb lc ld kj le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您必须在日常项目中使用RPC时，我们上面所做的既不可扩展也不容易编写/维护。这就是gRPC拯救世界的原因。在下一篇文章的<a class="ae kv" href="https://sumit-agarwal.medium.com/using-grpc-and-protobuf-in-golang-9c218d662db3" rel="noopener">中，我们将探索如何使用gRPC和Protobuf来编写一个高质量的Golang RPC服务器。</a></p><div class="ip iq gp gr ir nr"><a href="https://grpc.io/" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd jg gy z fp nw fr fs nx fu fw je bi translated">gRPC</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">gRPC是一个现代的开源高性能RPC框架，可以在任何环境中运行。它可以高效地连接…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">grpc.io</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ix nr"/></div></div></a></div><div class="ip iq gp gr ir nr"><a href="https://developers.google.com/protocol-buffers" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd jg gy z fp nw fr fs nx fu fw je bi translated">协议缓冲区|谷歌开发者</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">协议缓冲区是Google的语言中立、平台中立、可扩展的机制，用于序列化结构化数据…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">developers.google.com</p></div></div><div class="oa l"><div class="og l oc od oe oa of ix nr"/></div></div></a></div></div><div class="ab cl oh oi hu oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="ij ik il im in"><p id="b6a9" class="pw-post-body-paragraph kw kx jf ky b kz la kg lb lc ld kj le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi oo translated"><span class="l op oq or bm os ot ou ov ow di">C</span>o有趣的事实:“C”编程语言的前身叫做“<a class="ae kv" href="https://en.wikipedia.org/wiki/B_(programming_language)" rel="noopener ugc nofollow" target="_blank"> B </a></p></div><div class="ab cl oh oi hu oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="ij ik il im in"><p id="1e77" class="pw-post-body-paragraph kw kx jf ky b kz la kg lb lc ld kj le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky jg"> <em class="nq">请求:</em> </strong> <em class="nq">请在评论中添加您的宝贵反馈，这将真正帮助我提高内容的质量，并使其符合您的期望。</em></p></div></div>    
</body>
</html>