<html>
<head>
<title>Automatic Testing in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋自动测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/automatic-testing-in-go-ce581238eb57?source=collection_archive---------4-----------------------#2020-03-04">https://levelup.gitconnected.com/automatic-testing-in-go-ce581238eb57?source=collection_archive---------4-----------------------#2020-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/962663fcaa8e49df01f29d786d3906b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*44fv4Pi2W9jxvy3uaCEyLg.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">标志归功于golang.org</figcaption></figure><div class=""/><div class=""><h2 id="3a48" class="pw-subtitle-paragraph kf jh ji bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dk translated">Go元编程的进一步探索。其中，我们构建了Golang元编程工具。</h2></div><p id="b8c6" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这是上一篇文章的续篇，Go 中的<a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/metaprogram-in-go-5a2a7e989613">元程序，如果你还没有读过的话，可以从这里开始。在本文中，我们将关注为我们的CRUD api自动创建测试。回想一下，我们已经基于PostgreSQL表定义自动制作了api本身。在这个过程中，我们还将构建几个实用程序，使我们的元编程工具更加有用。</a></p><p id="a2e8" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">从几行SQL表定义中自动创建数百行可编译的、可运行的、无错误的* (*不尽然，请继续阅读)代码让我们兴奋不已，我们就像是在寻找钉子的锤子。我们还能做什么元编程？很多，事实证明，但一切都需要时间。从哪里开始？</p><p id="e489" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让我们为改进<a class="ae lt" href="https://github.com/exyzzy/metaapi" rel="noopener ugc nofollow" target="_blank"> metaapi </a>设定四个目标。</p><ol class=""><li id="8b23" class="lu lv ji kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated">为我们的metaapi生成的api自动创建测试</li><li id="9e5a" class="lu lv ji kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">使用内部模板生成默认代码</li><li id="23d8" class="lu lv ji kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">支持metaapi之外的代码生成</li><li id="0517" class="lu lv ji kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">自动创建初始metaapi项目</li></ol><p id="ebe5" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们将更详细地讨论所有这些。</p><h1 id="306a" class="mi mj ji bd mk ml mm mn mo mp mq mr ms ko mt kp mu kr mv ks mw ku mx kv my mz bi translated">自动测试</h1><p id="cd32" class="pw-post-body-paragraph kx ky ji kz b la na kj lc ld nb km lf lg nc li lj lk nd lm ln lo ne lq lr ls im bi translated">许多项目缺少的一件事是测试代码。这里有一个问题——您应该为自动生成的代码构建测试吗？您可能会认为，如果生成器工作正常，那么它正在生成无错误的代码。对吗？</p><p id="eb3b" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">当然，您不能假设生成的代码是没有错误的，原因很简单，生成的代码是生成器的产品，而生成器本身仍然很容易出现人为错误。此外，生成器作者<strong class="kz jj">有义务</strong>提供自动测试，就好像他们在编写非元(正常？)节目。考虑以下几点:</p><ul class=""><li id="5763" class="lu lv ji kz b la lb ld le lg lw lk lx lo ly ls nf ma mb mc bi translated">自动测试成为一个契约和文档，记录了生成的代码被测试的程度。</li><li id="8838" class="lu lv ji kz b la md ld me lg mf lk mg lo mh ls nf ma mb mc bi translated">用户可能会随着时间的推移修改/扩展生成的代码，并且在代码发生变化时需要进行测试。</li><li id="3187" class="lu lv ji kz b la md ld me lg mf lk mg lo mh ls nf ma mb mc bi translated">生成的代码所在的上下文(其他代码)可能会以生成器作者从未考虑过的方式使用它。</li><li id="68b9" class="lu lv ji kz b la md ld me lg mf lk mg lo mh ls nf ma mb mc bi translated">覆盖率统计需要测试。</li><li id="f24b" class="lu lv ji kz b la md ld me lg mf lk mg lo mh ls nf ma mb mc bi translated">自动测试是对生成器本身的测试，因此应该作为构建生成器的过程来实现(我错了，事实上我确实发现了一些我不经常使用的sql类型的原始metaapi生成代码的问题)。</li><li id="45ca" class="lu lv ji kz b la md ld me lg mf lk mg lo mh ls nf ma mb mc bi translated">锦上添花:如果可以自动生成测试，为什么要强迫用户手动编写测试呢？</li></ul><p id="c1a3" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">有了这些论据，让我们在go中进行一些自动测试。幸运的是，我们的metaapi程序为我们提供了几乎所有我们需要的跳板，使这变得容易。这是应该的——如果你能元编程一些东西x.go，你也应该能元编程一些东西x_test.go，而不需要太多额外的努力。我们可以保留所有原始的词法分析器和语法分析器。我们只需要为我们的测试文件创建一个新的模板，在generate.go中创建一些新的receiver方法，并集成这些东西。</p><p id="da2a" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">作为复习，让我们首先看看我们将基于一个简单的todo sql表定义测试的自动生成的metaapi api。</p><p id="1e93" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">newtodo/todo.sql:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="e39a" class="np mj ji nl b gy nq nr l ns nt">create table todos (<br/>  id           integer generated always as identity primary key,<br/>  updated_at   timestamptz,<br/>  done         boolean,<br/>  title        text<br/>);</span></pre><p id="f211" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">newtodo/todo_generated_api.go:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="9f66" class="np mj ji nl b gy nq nr l ns nt">//Auto generated with MetaApi <a class="ae lt" href="https://github.com/exyzzy/metaapi" rel="noopener ugc nofollow" target="_blank">https://github.com/exyzzy/metaapi</a><br/>package main</span><span id="ef6b" class="np mj ji nl b gy nu nr l ns nt">import (<br/>  "database/sql"<br/>  _ "github.com/lib/pq"<br/>  "time"<br/>)</span><span id="5fe1" class="np mj ji nl b gy nu nr l ns nt">//Create Table<br/>func CreateTableTodos(db *sql.DB) (err error) {<br/>  _, err = db.Exec("DROP TABLE IF EXISTS todos CASCADE")<br/>  if err != nil {<br/>    return<br/>  }<br/>  _, err = db.Exec(`create table todos ( id integer generated always as identity primary key , updated_at timestamptz , done boolean , title text ) ; `)<br/>  return<br/>}</span><span id="a449" class="np mj ji nl b gy nu nr l ns nt">//Drop Table<br/>func DropTableTodos(db *sql.DB) (err error) {<br/>  _, err = db.Exec("DROP TABLE IF EXISTS todos CASCADE")<br/>  return<br/>}</span><span id="d44d" class="np mj ji nl b gy nu nr l ns nt">//Struct<br/>type Todo struct {<br/>  Id int32`xml:"Id" json:"id"`<br/>  UpdatedAt time.Time`xml:"UpdatedAt" json:"updatedat"`<br/>  Done bool`xml:"Done" json:"done"`<br/>  Title string`xml:"Title" json:"title"`</span><span id="f58e" class="np mj ji nl b gy nu nr l ns nt">}</span><span id="5573" class="np mj ji nl b gy nu nr l ns nt">//Create<br/>func (todo *Todo) CreateTodo(db *sql.DB) (result Todo, err error) {<br/>  stmt, err := db.Prepare("INSERT INTO todos ( updated_at, done, title) VALUES ($1,$2,$3) RETURNING id, updated_at, done, title")<br/>  if err != nil {<br/>    return<br/>  }<br/>  defer stmt.Close()<br/>  err = stmt.QueryRow( todo.UpdatedAt, todo.Done, todo.Title).Scan( &amp;result.Id, &amp;result.UpdatedAt, &amp;result.Done, &amp;result.Title)<br/>  return<br/>}</span><span id="f407" class="np mj ji nl b gy nu nr l ns nt">//Retrieve<br/>func (todo *Todo) RetrieveTodo(db *sql.DB) (result Todo, err error) {<br/>  result = Todo{}<br/>  err = db.QueryRow("SELECT id, updated_at, done, title FROM todos WHERE (id = $1)", todo.Id).Scan( &amp;result.Id, &amp;result.UpdatedAt, &amp;result.Done, &amp;result.Title)<br/>  return<br/>}</span><span id="3b86" class="np mj ji nl b gy nu nr l ns nt">//RetrieveAll<br/>func RetrieveAllTodos(db *sql.DB) (todos []Todo, err error) {<br/>  rows, err := db.Query("SELECT id, updated_at, done, title FROM todos ORDER BY id DESC")<br/>  if err != nil {<br/>    return<br/>  }<br/>  for rows.Next() {<br/>    result := Todo{}<br/>    if err = rows.Scan( &amp;result.Id, &amp;result.UpdatedAt, &amp;result.Done, &amp;result.Title); err != nil {<br/>      return<br/>    }<br/>    todos = append(todos, result)<br/>  }<br/>  rows.Close()<br/>  return<br/>}</span><span id="d99e" class="np mj ji nl b gy nu nr l ns nt">//Update<br/>func (todo *Todo) UpdateTodo(db *sql.DB) (result Todo, err error) {<br/>  stmt, err := db.Prepare("UPDATE todos SET updated_at = $2, done = $3, title = $4 WHERE (id = $1) RETURNING id, updated_at, done, title")<br/>  if err != nil {<br/>    return<br/>  }<br/>  defer stmt.Close()</span><span id="cb2f" class="np mj ji nl b gy nu nr l ns nt">err = stmt.QueryRow( todo.Id, todo.UpdatedAt, todo.Done, todo.Title).Scan( &amp;result.Id, &amp;result.UpdatedAt, &amp;result.Done, &amp;result.Title)<br/>  return<br/>}</span><span id="2519" class="np mj ji nl b gy nu nr l ns nt">//Delete<br/>func (todo *Todo) DeleteTodo(db *sql.DB) (err error) {<br/>  stmt, err := db.Prepare("DELETE FROM todos WHERE (id = $1)")<br/>  if err != nil {<br/>    return<br/>  }<br/>  defer stmt.Close()</span><span id="c2b3" class="np mj ji nl b gy nu nr l ns nt">_, err = stmt.Exec(todo.Id)<br/>  return<br/>}</span><span id="a605" class="np mj ji nl b gy nu nr l ns nt">//DeleteAll<br/>func DeleteAllTodos(db *sql.DB) (err error) {<br/>  stmt, err := db.Prepare("DELETE FROM todos")<br/>  if err != nil {<br/>    return<br/>  }<br/>  defer stmt.Close()</span><span id="27c9" class="np mj ji nl b gy nu nr l ns nt">_, err = stmt.Exec()<br/>  return<br/>}</span></pre><p id="b6df" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们将采用与构建api生成器相同的方式来创建api测试函数文件，也就是说，我们将从一个已知良好的go测试文件开始，并慢慢地将其转换为模板。因此，第一项工作是为上面生成的CRUD api构建一个工作测试文件。让我们先这么做，记住我们的目标是在完成后使用metaapi自动生成<strong class="kz jj">这个完全相同的测试文件</strong>。</p><p id="ad1a" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">newtodo/api_test.go:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="56ac" class="np mj ji nl b gy nq nr l ns nt">package main</span><span id="eae7" class="np mj ji nl b gy nu nr l ns nt">import (<br/>  "database/sql"<br/>  "encoding/json"<br/>  "fmt"<br/>  "log"<br/>  "os"<br/>  "reflect"<br/>  "strings"<br/>  "testing"<br/>  "time"<br/>)</span><span id="f432" class="np mj ji nl b gy nu nr l ns nt">var testDb *sql.DB<br/>var configdb map[string]interface{}</span><span id="72b7" class="np mj ji nl b gy nu nr l ns nt">const testDbName = "testtodo"</span><span id="2981" class="np mj ji nl b gy nu nr l ns nt">// ======= helpers</span><span id="8196" class="np mj ji nl b gy nu nr l ns nt">//assumes a configlocaldb.json file as:<br/>//{<br/>//    "Host": "localhost",<br/>//    "Port": "5432",<br/>//    "User": "dbname",<br/>//    "Pass": "dbname",<br/>//    "Name": "dbname",<br/>//    "SSLMode": "disable"<br/>//}<br/>func loadConfig() {<br/>  fmt.Println("  loadConfig")<br/>  file, err := os.Open("configlocaldb.json")<br/>  if err != nil {<br/>    log.Fatalln("Cannot open configlocaldb file", err)<br/>  }<br/>  decoder := json.NewDecoder(file)<br/>  err = decoder.Decode(&amp;configdb)<br/>  if err != nil {<br/>    log.Fatalln("Cannot get local configurationdb from file", err)<br/>  }<br/>}</span><span id="46ea" class="np mj ji nl b gy nu nr l ns nt">func createDb(db *sql.DB, dbName string, owner string) (err error) {<br/>  ss := fmt.Sprintf("CREATE DATABASE %s OWNER %s", dbName, owner)<br/>  fmt.Println("  " + ss)<br/>  _, err = db.Exec(ss)<br/>  return<br/>}</span><span id="0c0b" class="np mj ji nl b gy nu nr l ns nt">func setTzDb(db *sql.DB) (err error) {<br/>  ss := fmt.Sprintf("SET TIME ZONE UTC")<br/>  fmt.Println("  " + ss)<br/>  _, err = db.Exec(ss)<br/>  return<br/>}</span><span id="a754" class="np mj ji nl b gy nu nr l ns nt">func dropDb(db *sql.DB, dbName string) (err error) {<br/>  ss := fmt.Sprintf("DROP DATABASE %s", dbName)<br/>  fmt.Println("  " + ss)<br/>  _, err = db.Exec(ss)<br/>  return<br/>}</span><span id="65a7" class="np mj ji nl b gy nu nr l ns nt">func rowExists(db *sql.DB, query string, args ...interface{}) (exists bool, err error) {<br/>  query = fmt.Sprintf("SELECT EXISTS (%s)", query)<br/>  fmt.Println("  " + query)<br/>  err = db.QueryRow(query, args...).Scan(&amp;exists)<br/>  return<br/>}</span><span id="f6a8" class="np mj ji nl b gy nu nr l ns nt">func tableExists(db *sql.DB, table string) (valid bool, err error) {</span><span id="fb50" class="np mj ji nl b gy nu nr l ns nt">  valid, err = rowExists(db, "SELECT 1 FROM pg_tables WHERE tablename = $1", table)<br/>  return<br/>}</span><span id="2875" class="np mj ji nl b gy nu nr l ns nt">func initTestDb() (err error) {<br/>  loadConfig()<br/>  psqlInfo := fmt.Sprintf("host=%s port=%s user=%s password=%s "+<br/>    "sslmode=%s", configdb["Host"], configdb["Port"], configdb["User"], configdb["Pass"], configdb["SSLMode"])<br/>  testDb, err = sql.Open("postgres", psqlInfo)<br/>  return<br/>}</span><span id="354f" class="np mj ji nl b gy nu nr l ns nt">func TestMain(m *testing.M) {<br/>  //test setup<br/>  err := initTestDb()<br/>  if err != nil {<br/>    log.Panicf("cannot initTestDb " + err.Error())<br/>  }</span><span id="3906" class="np mj ji nl b gy nu nr l ns nt">  err = createDb(testDb, testDbName, configdb["User"].(string))<br/>  if err != nil {<br/>    log.Panicf("cannot CreateDb " + err.Error())<br/>  }</span><span id="dc15" class="np mj ji nl b gy nu nr l ns nt">  err = setTzDb(testDb)<br/>  if err != nil {<br/>    log.Panicf("cannot setTzDb " + err.Error())<br/>  }</span><span id="fee5" class="np mj ji nl b gy nu nr l ns nt">  //run tests<br/>  exitVal := m.Run()</span><span id="38dd" class="np mj ji nl b gy nu nr l ns nt">  //test teardown<br/>  err = dropDb(testDb, testDbName)<br/>  if err != nil {<br/>    log.Panicf("cannot DropDb " + err.Error())<br/>  }<br/>  os.Exit(exitVal)<br/>}</span><span id="6f31" class="np mj ji nl b gy nu nr l ns nt">type compareType func(interface{}, interface{}) bool</span><span id="4930" class="np mj ji nl b gy nu nr l ns nt">func noCompare(result, expect interface{}) bool {<br/>  fmt.Printf("noCompare: %v, %v -  %T, %T \n", result, expect, result, expect)<br/>  return (true)<br/>}</span><span id="659d" class="np mj ji nl b gy nu nr l ns nt">func defaultCompare(result, expect interface{}) bool {<br/>  fmt.Printf("defaultCompare: %v, %v -  %T, %T \n", result, expect, result, expect)<br/>  return (result == expect)<br/>}</span><span id="18bc" class="np mj ji nl b gy nu nr l ns nt">func jsonCompare(result, expect interface{}) bool {<br/>  fmt.Printf("jsonCompare: %v, %v -  %T, %T \n", result, expect, result, expect)</span><span id="f086" class="np mj ji nl b gy nu nr l ns nt">  //json fields can be any order after db return, <br/>  //so read into   map[string]interface and look up<br/>  resultMap := make(map[string]interface{})<br/>  err := json.Unmarshal([]byte(result.(string)), &amp;resultMap)<br/>  if err != nil {<br/>    log.Panic(err)<br/>  }<br/>  expectMap := make(map[string]interface{})<br/>  err = json.Unmarshal([]byte(expect.(string)), &amp;expectMap)<br/>  if err != nil {<br/>    log.Panic(err)<br/>  }</span><span id="f42a" class="np mj ji nl b gy nu nr l ns nt">for k, v := range expectMap {<br/>    if v != resultMap[k] {<br/>      fmt.Printf("Key: %v, Result: %v, Expect: %v", k, resultMap[k], v)<br/>      return false<br/>    }<br/>  }<br/>  return true<br/>}</span><span id="7760" class="np mj ji nl b gy nu nr l ns nt">func stringNotEqual(result, expect []byte) bool {</span><span id="ffec" class="np mj ji nl b gy nu nr l ns nt">  return (strings.TrimSpace(string(result)) != strings.TrimSpace(string(expect)))</span><span id="da12" class="np mj ji nl b gy nu nr l ns nt">}</span><span id="2ee5" class="np mj ji nl b gy nu nr l ns nt">func stringCompare(result, expect interface{}) bool {</span><span id="03bd" class="np mj ji nl b gy nu nr l ns nt">resultJson, err := json.Marshal(result)<br/>  if err != nil {<br/>    log.Panic(err)<br/>  }<br/>  expectJson, err := json.Marshal(expect)<br/>  if err != nil {<br/>    log.Panic(err)<br/>  }<br/>  fmt.Printf("stringCompare: %v, %v -  %T, %T \n", string(resultJson), string(expectJson), result, expect)<br/>  return (strings.TrimSpace(string(resultJson)) == strings.TrimSpace(string(expectJson)))<br/>}</span><span id="7c2c" class="np mj ji nl b gy nu nr l ns nt">//iterate through each field of struct and apply the <br/>//compare function to each field based on compareType map<br/>func equalField(result, expect interface{}, compMap map[string]compareType) error {</span><span id="fd98" class="np mj ji nl b gy nu nr l ns nt">  u := reflect.ValueOf(expect)<br/>  v := reflect.ValueOf(result)<br/>  typeOfS := u.Type()</span><span id="aa17" class="np mj ji nl b gy nu nr l ns nt">  for i := 0; i &lt; u.NumField(); i++ {</span><span id="54d7" class="np mj ji nl b gy nu nr l ns nt">  if !(compMap[typeOfS.Field(i).Name])(v.Field(i).Interface(), u.Field(i).Interface()) {<br/>      return fmt.Errorf("Field: %s, Result: %v, Expect: %v", typeOfS.Field(i).Name, v.Field(i).Interface(), u.Field(i).Interface())<br/>    }<br/>  }<br/>  return nil<br/>}</span><span id="2a86" class="np mj ji nl b gy nu nr l ns nt">//table specific</span><span id="5238" class="np mj ji nl b gy nu nr l ns nt">const todostableName = "todos"</span><span id="29ff" class="np mj ji nl b gy nu nr l ns nt">//test data - note: double brackets in test data need space <br/>//between otherwise are interpreted as template action</span><span id="67ff" class="np mj ji nl b gy nu nr l ns nt">var testTodo = [2]Todo{ {1, time.Now().UTC().Truncate(time.Microsecond), false, "TaoLVzKbOmA7o6XG"}, {2, time.Now().UTC().Truncate(time.Microsecond), false, "mkty9P5syMWIFQHs"} }</span><span id="6c1d" class="np mj ji nl b gy nu nr l ns nt">var updateTodo = Todo{1, time.Now().UTC().Truncate(time.Microsecond), false, "gtJYE5QGUfrlzMzw"}</span><span id="792c" class="np mj ji nl b gy nu nr l ns nt">//compare functions<br/>var compareTodos = map[string]compareType{<br/>  "Id":        defaultCompare,<br/>  "UpdatedAt": stringCompare,<br/>  "Done":      defaultCompare,<br/>  "Title":     defaultCompare,<br/>}</span><span id="5a0a" class="np mj ji nl b gy nu nr l ns nt">// ======= tests: Todo</span><span id="9a1f" class="np mj ji nl b gy nu nr l ns nt">func reverseTodos(todos []Todo) (result []Todo) {</span><span id="a6e0" class="np mj ji nl b gy nu nr l ns nt">  for i := len(todos) - 1; i &gt;= 0; i-- {<br/>    result = append(result, todos[i])<br/>  }<br/>  return<br/>}</span><span id="e6d4" class="np mj ji nl b gy nu nr l ns nt">func TestCreateTableTodos(t *testing.T) {<br/>  fmt.Println("==CreateTableTodos")</span><span id="c1d2" class="np mj ji nl b gy nu nr l ns nt">  err := CreateTableTodos(testDb)<br/>  if err != nil {<br/>    t.Errorf("cannot CreateTableTodos " + err.Error())<br/>  } else {<br/>    fmt.Println("  Done: CreateTableTodos")<br/>  }<br/>  exists, err := tableExists(testDb, todostableName)<br/>  if err != nil {<br/>    t.Errorf("cannot tableExists " + err.Error())<br/>  }<br/>  if !exists {<br/>    t.Errorf("tableExists(todos) returned wrong status code: got %v want %v", exists, true)<br/>  } else {<br/>    fmt.Println("  Done: tableExists")<br/>  }<br/>}</span><span id="2d78" class="np mj ji nl b gy nu nr l ns nt">func TestCreateTodo(t *testing.T) {<br/>  fmt.Println("==CreateTodo")</span><span id="d02b" class="np mj ji nl b gy nu nr l ns nt">  result, err := testTodo[0].CreateTodo(testDb)<br/>  if err != nil {<br/>    t.Errorf("cannot CreateTodo " + err.Error())<br/>  } else {<br/>    fmt.Println("  Done: CreateTodo")<br/>  }</span><span id="4d0e" class="np mj ji nl b gy nu nr l ns nt">  err = equalField(result, testTodo[0], compareTodos)<br/>  if err != nil {<br/>    t.Errorf("api returned unexpected result. " + err.Error())<br/>  }<br/>}</span><span id="a4bc" class="np mj ji nl b gy nu nr l ns nt">func TestRetrieveTodo(t *testing.T) {<br/>  fmt.Println("==RetrieveTodo")</span><span id="9432" class="np mj ji nl b gy nu nr l ns nt">  result, err := testTodo[0].RetrieveTodo(testDb)<br/>  if err != nil {<br/>    t.Errorf("cannot RetrieveTodo " + err.Error())<br/>  } else {<br/>    fmt.Println("  Done: RetrieveTodo")<br/>  }<br/>  err = equalField(result, testTodo[0], compareTodos)<br/>  if err != nil {<br/>    t.Errorf("api returned unexpected result. " + err.Error())<br/>  }<br/>}</span><span id="b789" class="np mj ji nl b gy nu nr l ns nt">func TestRetrieveAllTodos(t *testing.T) {<br/>  fmt.Println("==RetrieveAllTodos")</span><span id="828b" class="np mj ji nl b gy nu nr l ns nt">  _, err := testTodo[1].CreateTodo(testDb)<br/>  if err != nil {<br/>    t.Errorf("cannot CreateTodo " + err.Error())<br/>  } else {<br/>    fmt.Println("  Done: CreateTodo")<br/>  }<br/>  result, err := RetrieveAllTodos(testDb)<br/>  if err != nil {<br/>    t.Errorf("cannot RetrieveAllTodos " + err.Error())<br/>  } else {<br/>    fmt.Println("  Done: RetrieveAllTodos")<br/>  }</span><span id="dc6b" class="np mj ji nl b gy nu nr l ns nt">//reverse because api is DESC, [:] is slice of all array elements<br/>  expect := reverseTodos(testTodo[:])<br/>  for i, _ := range expect {<br/>    err = equalField(result[i], expect[i], compareTodos)<br/>    if err != nil {<br/>      t.Errorf("api returned unexpected result. " + err.Error())<br/>    }<br/>  }<br/>}</span><span id="349b" class="np mj ji nl b gy nu nr l ns nt">func TestUpdateTodo(t *testing.T) {<br/>  fmt.Println("==UpdateTodo")</span><span id="defd" class="np mj ji nl b gy nu nr l ns nt">  result, err := updateTodo.UpdateTodo(testDb)<br/>  if err != nil {<br/>    t.Errorf("cannot UpdateTodo " + err.Error())<br/>  } else {<br/>    fmt.Println("  Done: UpdateTodo")<br/>  }<br/>  err = equalField(result, updateTodo, compareTodos)<br/>  if err != nil {<br/>    t.Errorf("api returned unexpected result. " + err.Error())<br/>  }<br/>}</span><span id="36c7" class="np mj ji nl b gy nu nr l ns nt">func TestDeleteTodo(t *testing.T) {<br/>  fmt.Println("==DeleteTodo")</span><span id="a80a" class="np mj ji nl b gy nu nr l ns nt">  err := testTodo[0].DeleteTodo(testDb)<br/>  if err != nil {<br/>    t.Errorf("cannot DeleteTodo " + err.Error())<br/>  } else {<br/>    fmt.Println("  Done: DeleteTodo")<br/>  }<br/>  _, err = testTodo[0].RetrieveTodo(testDb)<br/>  if err == nil {<br/>    t.Errorf("api returned unexpected result: got Row want NoRow")<br/>  } else {<br/>    if err == sql.ErrNoRows {<br/>      fmt.Println("  Done: RetrieveTodo with no result")<br/>    } else {<br/>      t.Errorf("cannot RetrieveTodo " + err.Error())<br/>    }<br/>  }<br/>}</span><span id="b8eb" class="np mj ji nl b gy nu nr l ns nt">func TestDeleteAllTodos(t *testing.T) {<br/>  fmt.Println("==DeleteAllTodos")</span><span id="5a98" class="np mj ji nl b gy nu nr l ns nt">  err := DeleteAllTodos(testDb)<br/>  if err != nil {<br/>    t.Errorf("cannot DeleteAllTodos " + err.Error())<br/>  } else {<br/>    fmt.Println("  Done: DeleteAllTodos")<br/>  }<br/>  result, err := RetrieveAllTodos(testDb)</span><span id="d542" class="np mj ji nl b gy nu nr l ns nt">  if err != nil {<br/>    t.Errorf("cannot RetrieveAllTodos " + err.Error())<br/>  }<br/>  if len(result) &gt; 0 {<br/>    t.Errorf("api returned unexpected result: got Row want NoRow")<br/>  } else {<br/>    fmt.Println("  Done: RetrieveAllTodos with no result")<br/>  }<br/>}</span></pre><p id="65b9" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在这个测试文件中有一些事情需要注意。</p><p id="d549" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">一个新的测试数据库在测试开始时被创建。</strong>这有许多原因:</p><ol class=""><li id="346c" class="lu lv ji kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated">为了防止生产数据库中的污染</li><li id="3652" class="lu lv ji kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">无需保存即可知道测试数据序列主键id</li><li id="4d39" class="lu lv ji kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">测试创建表功能</li></ol><p id="04b5" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj"> JSON测试数据可以解释为go模板动作</strong>。如果您创建JSON测试数据，例如，一个结构数组，并且使用默认的go模板操作分隔符，那么您可能会得到一个字符模式{{}，{}，..{ } }编译器会将其解释为一个<a class="ae lt" href="https://golang.org/pkg/text/template/" rel="noopener ugc nofollow" target="_blank">模板动作</a>。修复很容易，只需在任何双括号之间加一个空格:<strong class="kz jj"> { { </strong> }，{}，..{ <strong class="kz jj"> } }。</strong>这在txt模板中变得有点棘手，因为在我们不想要的地方旁边会有我们想要的双括号解释为模板动作的地方，它们之间的区别是一个空格字符——这是在乞求错误。一个更好的解决方案是改变go用来标识模板动作的分隔符。我们可以通过使用<a class="ae lt" href="https://golang.org/pkg/text/template/#Template.Delims" rel="noopener ugc nofollow" target="_blank">模板来做到这一点。generate.go中的Delims() </a>将分隔符从{{}}更改为&lt; &lt; &gt; &gt;。如果我们的模板是html，这可能会有问题，但是因为它们是go，所以会更好。</p><p id="de08" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">输入PostgreSQL的数据可能会被修改后返回</strong>:这可能会搞砸你的测试，除非你做好准备。这里有几个例子。<a class="ae lt" href="https://github.com/lib/pq/issues/227" rel="noopener ugc nofollow" target="_blank">这个有趣的问题</a>在<a class="ae lt" href="https://golang.org/pkg/time/" rel="noopener ugc nofollow" target="_blank"> Go(纳秒)</a>和<a class="ae lt" href="https://www.postgresql.org/docs/12/datatype-datetime.html" rel="noopener ugc nofollow" target="_blank"> Postgres(微秒)</a>之间的时间分辨率是不同的。这在linux上似乎是个问题，但在OS X上不是，但可能会影响您的本地测试。解决方案是将时间截断到最低(普通)分辨率，以便通过时间测试:</p><p id="ebd6" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><code class="fe nv nw nx nl b">time.Now().UTC().Truncate(time.Microsecond)</code></p><p id="5acc" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">另一个是时间格式化，其中pq将使用一个<a class="ae lt" href="https://golang.org/pkg/time/" rel="noopener ugc nofollow" target="_blank">时间。timestamp和date的Time </a>结构，因此它们可以带着时区进入PG，然后不带时区返回。一种解决方案是将它们整理成字符串，然后比较这些字符串。</p><p id="ec2c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">还有一点是，JSON结构键/字段<a class="ae lt" href="https://stackoverflow.com/questions/36698065/ordering-difference-in-json-marshaled-from-map-and-struct" rel="noopener ugc nofollow" target="_blank">从PG返回时可以是任何顺序</a>，这对于JSON 来说是正常的<a class="ae lt" href="https://www.ietf.org/rfc/rfc4627.txt" rel="noopener ugc nofollow" target="_blank">。所以我们需要遍历每个键，并在目标中查找以进行比较。</a></p><p id="a934" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">由于这些问题，测试文件在每个表上使用一个映射，允许测试函数为每个字段调用一个唯一的比较函数。我们将在generate.go中生成这个映射，它可以在“编译时”访问sql表数据。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="f8d6" class="np mj ji nl b gy nq nr l ns nt">//compare functions</span><span id="d331" class="np mj ji nl b gy nu nr l ns nt">var compareTodos = map[string]compareType{<br/>  "Id":        defaultCompare,<br/>  "UpdatedAt": stringCompare,<br/>  "Done":      defaultCompare,<br/>  "Title":     defaultCompare,<br/>}</span></pre><p id="548b" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">如果我们运行<code class="fe nv nw nx nl b">go test</code>，它看起来确实与我们的api相违背，所以现在我们将复制我们的go测试文件为api_test.txt，并开始对它进行模板化，同时在需要的地方添加新的receiver方法来生成. go。</p><p id="ae67" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">metaapi/metasql/api_test.txt:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="e02f" class="np mj ji nl b gy nq nr l ns nt">//Auto generated with MetaApi <a class="ae lt" href="https://github.com/exyzzy/metaapi" rel="noopener ugc nofollow" target="_blank">https://github.com/exyzzy/metaapi</a><br/>package &lt;&lt; .Package &gt;&gt;</span><span id="072b" class="np mj ji nl b gy nu nr l ns nt">import (<br/>  "database/sql"<br/>  "encoding/json"<br/>  "fmt"<br/>  "log"<br/>  "os"<br/>  "reflect"<br/>  "strings"<br/>  "testing"<br/>  "time"<br/>)</span><span id="5e0a" class="np mj ji nl b gy nu nr l ns nt">var testDb *sql.DB<br/>var configdb map[string]interface{}<br/>const testDbName = "test&lt;&lt; .FilePrefix &gt;&gt;"</span><span id="2613" class="np mj ji nl b gy nu nr l ns nt">// ======= helpers</span><span id="f374" class="np mj ji nl b gy nu nr l ns nt">//assumes a configlocaldb.json file as:<br/>//{<br/>//    "Host": "localhost",<br/>//    "Port": "5432",<br/>//    "User": "dbname",<br/>//    "Pass": "dbname",<br/>//    "Name": "dbname",<br/>//    "SSLMode": "disable"<br/>//}<br/>func loadConfig() {<br/>  fmt.Println("  loadConfig")<br/>  file, err := os.Open("configlocaldb.json")<br/>  if err != nil {<br/>    log.Panicln("Cannot open configlocaldb file", err.Error())<br/>  }<br/>  decoder := json.NewDecoder(file)<br/>  err = decoder.Decode(&amp;configdb)<br/>  if err != nil {<br/>    log.Panicln("Cannot get local configurationdb from file", err.Error())<br/>  }<br/>}</span><span id="4cab" class="np mj ji nl b gy nu nr l ns nt">func createDb(db *sql.DB, dbName string, owner string) (err error) {<br/>  ss := fmt.Sprintf("CREATE DATABASE %s OWNER %s", dbName, owner)<br/>  fmt.Println("  " + ss)<br/>  _, err = db.Exec(ss)<br/>  return<br/>}</span><span id="2218" class="np mj ji nl b gy nu nr l ns nt">func setTzDb(db *sql.DB) (err error) {<br/>  ss := fmt.Sprintf("SET TIME ZONE UTC")<br/>  fmt.Println("  " + ss)<br/>  _, err = db.Exec(ss)<br/>  return<br/>}</span><span id="be84" class="np mj ji nl b gy nu nr l ns nt">func dropDb(db *sql.DB, dbName string) (err error) {<br/>  ss := fmt.Sprintf("DROP DATABASE %s", dbName)<br/>  fmt.Println("  " + ss)<br/>  _, err = db.Exec(ss)<br/>  return<br/>}</span><span id="f4a2" class="np mj ji nl b gy nu nr l ns nt">func rowExists(db *sql.DB, query string, args ...interface{}) (exists bool, err error) {<br/>  query = fmt.Sprintf("SELECT EXISTS (%s)", query)<br/>  fmt.Println("  " + query)<br/>  err = db.QueryRow(query, args...).Scan(&amp;exists)<br/>  return<br/>}</span><span id="b848" class="np mj ji nl b gy nu nr l ns nt">func tableExists(db *sql.DB, table string) (valid bool, err error) {</span><span id="d84a" class="np mj ji nl b gy nu nr l ns nt">  valid, err = rowExists(db, "SELECT 1 FROM pg_tables WHERE tablename = $1", table)<br/>  return<br/>}</span><span id="9f2f" class="np mj ji nl b gy nu nr l ns nt">func initTestDb() (err error) {<br/>  loadConfig()<br/>  psqlInfo := fmt.Sprintf("host=%s port=%s user=%s password=%s "+<br/>    "sslmode=%s", configdb["Host"], configdb["Port"], configdb["User"], configdb["Pass"], configdb["SSLMode"])<br/>  testDb, err = sql.Open("postgres", psqlInfo)<br/>  return<br/>}</span><span id="21b0" class="np mj ji nl b gy nu nr l ns nt">func TestMain(m *testing.M) {<br/>  //test setup<br/>  err := initTestDb()<br/>  if err != nil {<br/>    log.Panicln("cannot initTestDb ", err.Error())<br/>  }</span><span id="29ec" class="np mj ji nl b gy nu nr l ns nt">  err = createDb(testDb, testDbName, configdb["User"].(string))<br/>  if err != nil {<br/>    log.Panicln("cannot CreateDb ", err.Error())<br/>  }</span><span id="7c70" class="np mj ji nl b gy nu nr l ns nt">  err = setTzDb(testDb)<br/>  if err != nil {<br/>    log.Panicln("cannot setTzDb ", err.Error())<br/>  }</span><span id="da3f" class="np mj ji nl b gy nu nr l ns nt">  //run tests<br/>  exitVal := m.Run()</span><span id="3313" class="np mj ji nl b gy nu nr l ns nt">  //test teardown<br/>  err = dropDb(testDb, testDbName)<br/>  if err != nil {<br/>    log.Panicln("cannot DropDb ", err.Error())<br/>  }<br/>  os.Exit(exitVal)<br/>}</span><span id="e7d0" class="np mj ji nl b gy nu nr l ns nt">type compareType func(interface{}, interface{}) bool</span><span id="6c94" class="np mj ji nl b gy nu nr l ns nt">func noCompare(result, expect interface{}) bool {<br/>  fmt.Printf("noCompare: %v, %v -  %T, %T \n", result, expect, result, expect)<br/>  return (true)<br/>}</span><span id="72e1" class="np mj ji nl b gy nu nr l ns nt">func defaultCompare(result, expect interface{}) bool {<br/>  fmt.Printf("defaultCompare: %v, %v -  %T, %T \n", result, expect, result, expect)<br/>  return (result == expect)<br/>}</span><span id="5e6d" class="np mj ji nl b gy nu nr l ns nt">func jsonCompare(result, expect interface{}) bool {<br/>  fmt.Printf("jsonCompare: %v, %v -  %T, %T \n", result, expect, result, expect)</span><span id="8909" class="np mj ji nl b gy nu nr l ns nt">  //json fields can be any order after db return, <br/>  //so read into map[string]interface and look up<br/>  resultMap := make(map[string]interface{})<br/>  err := json.Unmarshal([]byte(result.(string)), &amp;resultMap)<br/>  if err != nil {<br/>    log.Panic(err)<br/>  }<br/>  expectMap := make(map[string]interface{})<br/>  err = json.Unmarshal([]byte(expect.(string)), &amp;expectMap)<br/>  if err != nil {<br/>    log.Panic(err)<br/>  }</span><span id="67fd" class="np mj ji nl b gy nu nr l ns nt">  for k, v := range expectMap {<br/>    if v != resultMap[k] {<br/>      fmt.Printf("Key: %v, Result: %v, Expect: %v", k, resultMap[k], v)<br/>      return false<br/>    }<br/>  }<br/>  return true<br/>}</span><span id="9b80" class="np mj ji nl b gy nu nr l ns nt">func stringCompare(result, expect interface{}) bool {</span><span id="f1fd" class="np mj ji nl b gy nu nr l ns nt">  resultJson, err := json.Marshal(result)<br/>  if err != nil {<br/>    log.Panic(err)<br/>  }<br/>  expectJson, err := json.Marshal(expect)<br/>  if err != nil {<br/>    log.Panic(err)<br/>  }<br/>  fmt.Printf("stringCompare: %v, %v -  %T, %T \n", string(resultJson), string(expectJson), result, expect)<br/>  return (strings.TrimSpace(string(resultJson)) == strings.TrimSpace(string(expectJson)))<br/>}</span><span id="083a" class="np mj ji nl b gy nu nr l ns nt">//iterate through each field of struct and apply the <br/>//compare function to each field based on compareType map<br/>func equalField(result, expect interface{}, compMap map[string]compareType) error {</span><span id="7540" class="np mj ji nl b gy nu nr l ns nt">  u := reflect.ValueOf(expect)<br/>  v := reflect.ValueOf(result)<br/>  typeOfS := u.Type()</span><span id="dfae" class="np mj ji nl b gy nu nr l ns nt">  for i := 0; i &lt; u.NumField(); i++ {</span><span id="1a0d" class="np mj ji nl b gy nu nr l ns nt">  if !(compMap[typeOfS.Field(i).Name])(v.Field(i).Interface(), u.Field(i).Interface()) {<br/>      return fmt.Errorf("Field: %s, Result: %v, Expect: %v", typeOfS.Field(i).Name, v.Field(i).Interface(), u.Field(i).Interface())<br/>    }<br/>  }<br/>  return nil<br/>}</span><span id="37b6" class="np mj ji nl b gy nu nr l ns nt">//table specific</span><span id="d526" class="np mj ji nl b gy nu nr l ns nt">&lt;&lt; range $index, $table := .Tables &gt;&gt;<br/>const &lt;&lt; $table.Name &gt;&gt;tableName = "&lt;&lt; $table.Name &gt;&gt;"</span><span id="0649" class="np mj ji nl b gy nu nr l ns nt">var test&lt;&lt; $table.CapSingName &gt;&gt; = [2]&lt;&lt; $table.CapSingName &gt;&gt;{ &lt;&lt; $table.TestData 1 &gt;&gt;, &lt;&lt; $table.TestData 2 &gt;&gt; }</span><span id="4351" class="np mj ji nl b gy nu nr l ns nt">var update&lt;&lt; $table.CapSingName &gt;&gt; = &lt;&lt; $table.CapSingName &gt;&gt;&lt;&lt; $table.TestData 1 &gt;&gt;</span><span id="aed1" class="np mj ji nl b gy nu nr l ns nt">//compare functions<br/>var compare&lt;&lt; $table.CapName &gt;&gt; = map[string]compareType{<br/>&lt;&lt; $table.CompareMapFields &gt;&gt;<br/>}</span><span id="903c" class="np mj ji nl b gy nu nr l ns nt">// ======= tests: &lt;&lt; $table.CapSingName &gt;&gt;</span><span id="61bf" class="np mj ji nl b gy nu nr l ns nt">func reverse&lt;&lt; $table.CapName &gt;&gt;(&lt;&lt; $table.Name &gt;&gt; []&lt;&lt; $table.CapSingName &gt;&gt;) (result []&lt;&lt; $table.CapSingName &gt;&gt;) {</span><span id="37ab" class="np mj ji nl b gy nu nr l ns nt">for i := len(&lt;&lt; $table.Name &gt;&gt;) - 1; i &gt;= 0; i-- {<br/>    result = append(result, &lt;&lt; $table.Name &gt;&gt;[i])<br/>  }<br/>  return<br/>}</span><span id="5e69" class="np mj ji nl b gy nu nr l ns nt">func TestCreateTable&lt;&lt; $table.CapName &gt;&gt;(t *testing.T) {<br/>  fmt.Println("==CreateTable&lt;&lt; $table.CapName &gt;&gt;")</span><span id="0147" class="np mj ji nl b gy nu nr l ns nt">  err := CreateTable&lt;&lt; $table.CapName &gt;&gt;(testDb)<br/>  if err != nil {<br/>    t.Errorf("cannot CreateTable&lt;&lt; $table.CapName &gt;&gt; " + err.Error())<br/>  } else {<br/>    fmt.Println("  Done: CreateTable&lt;&lt; $table.CapName &gt;&gt;")<br/>  }<br/>  exists, err := tableExists(testDb, &lt;&lt; $table.Name &gt;&gt;tableName)<br/>  if err != nil {<br/>    t.Errorf("cannot tableExists " + err.Error())<br/>  }<br/>  if !exists {<br/>    t.Errorf("tableExists(&lt;&lt; $table.Name &gt;&gt;) returned wrong status code: got %v want %v", exists, true)<br/>  } else {<br/>    fmt.Println("  Done: tableExists")<br/>  }<br/>}</span><span id="a085" class="np mj ji nl b gy nu nr l ns nt">func TestCreate&lt;&lt; $table.CapSingName &gt;&gt;(t *testing.T) {<br/>  fmt.Println("==Create&lt;&lt; $table.CapSingName &gt;&gt;")</span><span id="a688" class="np mj ji nl b gy nu nr l ns nt">  result, err := test&lt;&lt; $table.CapSingName &gt;&gt;[0].Create&lt;&lt; $table.CapSingName &gt;&gt;(testDb)<br/>  if err != nil {<br/>    t.Errorf("cannot Create&lt;&lt; $table.CapSingName &gt;&gt; " + err.Error())<br/>  } else {<br/>    fmt.Println("  Done: Create&lt;&lt; $table.CapSingName &gt;&gt;")<br/>  }</span><span id="3413" class="np mj ji nl b gy nu nr l ns nt">  err = equalField(result, test&lt;&lt; $table.CapSingName &gt;&gt;[0], compare&lt;&lt; $table.CapName &gt;&gt;)<br/>  if err != nil {<br/>    t.Errorf("api returned unexpected result. " + err.Error())<br/>  }<br/>}</span><span id="a32c" class="np mj ji nl b gy nu nr l ns nt">func TestRetrieve&lt;&lt; $table.CapSingName &gt;&gt;(t *testing.T) {<br/>  fmt.Println("==Retrieve&lt;&lt; $table.CapSingName &gt;&gt;")</span><span id="f844" class="np mj ji nl b gy nu nr l ns nt">  result, err := test&lt;&lt; $table.CapSingName &gt;&gt;[0].Retrieve&lt;&lt; $table.CapSingName &gt;&gt;(testDb)<br/>  if err != nil {<br/>    t.Errorf("cannot Retrieve&lt;&lt; $table.CapSingName &gt;&gt; " + err.Error())<br/>  } else {<br/>    fmt.Println("  Done: Retrieve&lt;&lt; $table.CapSingName &gt;&gt;")<br/>  }<br/>  err = equalField(result, test&lt;&lt; $table.CapSingName &gt;&gt;[0], compare&lt;&lt; $table.CapName &gt;&gt;)<br/>  if err != nil {<br/>    t.Errorf("api returned unexpected result. " + err.Error())<br/>  }<br/>}</span><span id="efea" class="np mj ji nl b gy nu nr l ns nt">func TestRetrieveAll&lt;&lt; $table.CapName &gt;&gt;(t *testing.T) {<br/>  fmt.Println("==RetrieveAll&lt;&lt; $table.CapName &gt;&gt;")</span><span id="0b34" class="np mj ji nl b gy nu nr l ns nt">  _, err := test&lt;&lt; $table.CapSingName &gt;&gt;[1].Create&lt;&lt; $table.CapSingName &gt;&gt;(testDb)<br/>  if err != nil {<br/>    t.Errorf("cannot Create&lt;&lt; $table.CapSingName &gt;&gt; " + err.Error())<br/>  } else {<br/>    fmt.Println("  Done: Create&lt;&lt; $table.CapSingName &gt;&gt;")<br/>  }<br/>  result, err := RetrieveAll&lt;&lt; $table.CapName &gt;&gt;(testDb)<br/>  if err != nil {<br/>    t.Errorf("cannot RetrieveAll&lt;&lt; $table.CapName &gt;&gt; " + err.Error())<br/>  } else {<br/>    fmt.Println("  Done: RetrieveAll&lt;&lt; $table.CapName &gt;&gt;")<br/>  }</span><span id="a5c0" class="np mj ji nl b gy nu nr l ns nt">//reverse because api is DESC, [:] is slice of all array elements<br/>  expect := reverse&lt;&lt; $table.CapName &gt;&gt;(test&lt;&lt; $table.CapSingName &gt;&gt;[:])<br/>  for i, _ := range expect {<br/>    err = equalField(result[i], expect[i], compare&lt;&lt; $table.CapName &gt;&gt;)<br/>    if err != nil {<br/>      t.Errorf("api returned unexpected result. " + err.Error())<br/>    }<br/>  }<br/>}</span><span id="696a" class="np mj ji nl b gy nu nr l ns nt">func TestUpdate&lt;&lt; $table.CapSingName &gt;&gt;(t *testing.T) {<br/>  fmt.Println("==Update&lt;&lt; $table.CapSingName &gt;&gt;")</span><span id="a291" class="np mj ji nl b gy nu nr l ns nt">  result, err := update&lt;&lt; $table.CapSingName &gt;&gt;.Update&lt;&lt; $table.CapSingName &gt;&gt;(testDb)<br/>  if err != nil {<br/>    t.Errorf("cannot Update&lt;&lt; $table.CapSingName &gt;&gt; " + err.Error())<br/>  } else {<br/>    fmt.Println("  Done: Update&lt;&lt; $table.CapSingName &gt;&gt;")<br/>  }<br/>  err = equalField(result, update&lt;&lt; $table.CapSingName &gt;&gt;, compare&lt;&lt; $table.CapName &gt;&gt;)<br/>  if err != nil {<br/>    t.Errorf("api returned unexpected result. " + err.Error())<br/>  }<br/>}</span><span id="af80" class="np mj ji nl b gy nu nr l ns nt">func TestDelete&lt;&lt; $table.CapSingName &gt;&gt;(t *testing.T) {<br/>  fmt.Println("==Delete&lt;&lt; $table.CapSingName &gt;&gt;")</span><span id="d20b" class="np mj ji nl b gy nu nr l ns nt">  err := test&lt;&lt; $table.CapSingName &gt;&gt;[0].Delete&lt;&lt; $table.CapSingName &gt;&gt;(testDb)<br/>  if err != nil {<br/>    t.Errorf("cannot Delete&lt;&lt; $table.CapSingName &gt;&gt; " + err.Error())<br/>  } else {<br/>    fmt.Println("  Done: Delete&lt;&lt; $table.CapSingName &gt;&gt;")<br/>  }<br/>  _, err = test&lt;&lt; $table.CapSingName &gt;&gt;[0].Retrieve&lt;&lt; $table.CapSingName &gt;&gt;(testDb)<br/>  if err == nil {<br/>    t.Errorf("api returned unexpected result: got Row want NoRow")<br/>  } else {<br/>    if err == sql.ErrNoRows {<br/>      fmt.Println("  Done: Retrieve&lt;&lt; $table.CapSingName &gt;&gt; with no result")<br/>    } else {<br/>      t.Errorf("cannot Retrieve&lt;&lt; $table.CapSingName &gt;&gt; " + err.Error())<br/>    }<br/>  }<br/>}</span><span id="a5e3" class="np mj ji nl b gy nu nr l ns nt">func TestDeleteAll&lt;&lt; $table.CapName &gt;&gt;(t *testing.T) {<br/>  fmt.Println("==DeleteAll&lt;&lt; $table.CapName &gt;&gt;")</span><span id="28cc" class="np mj ji nl b gy nu nr l ns nt">  err := DeleteAll&lt;&lt; $table.CapName &gt;&gt;(testDb)<br/>  if err != nil {<br/>    t.Errorf("cannot DeleteAll&lt;&lt; $table.CapName &gt;&gt; " + err.Error())<br/>  } else {<br/>    fmt.Println("  Done: DeleteAll&lt;&lt; $table.CapName &gt;&gt;")<br/>  }<br/>  result, err := RetrieveAll&lt;&lt; $table.CapName &gt;&gt;(testDb)</span><span id="85c9" class="np mj ji nl b gy nu nr l ns nt">  if err != nil {<br/>    t.Errorf("cannot RetrieveAll&lt;&lt; $table.CapName &gt;&gt; " + err.Error())<br/>  }<br/>  if len(result) &gt; 0 {<br/>    t.Errorf("api returned unexpected result: got Row want NoRow")<br/>  } else {<br/>    fmt.Println("  Done: RetrieveAll&lt;&lt; $table.CapName &gt;&gt; with no result")<br/>  }<br/>}<br/>&lt;&lt; end &gt;&gt;</span></pre><p id="2b35" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">你会注意到事情没有太大的变化，直到我们到达这条线<code class="fe nv nw nx nl b">&lt;&lt; range $index, $table := .Tables &gt;&gt;</code>,在这条线之前，主要是帮助函数，它们对所有的表都是一样的。在那一行之后，我们创建特定于表的函数，generate.go需要访问我们从。sql文件。</p><p id="a8bb" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在这条线的正下方还有几个有趣的部分。<code class="fe nv nw nx nl b">&lt;&lt; $table.TestData 1 &gt;&gt;</code>是我们创建测试数据的地方，测试数据由go struct字段驱动，而go struct字段又对应于。表中的sql字段。我们传入我们知道PostgreSQL将生成的主键id。<code class="fe nv nw nx nl b">&lt;&lt; $table.CompareMapFields &gt;&gt;</code>是我们生成上面提到的比较函数映射的地方，因此我们可以根据表字段类型使用唯一的比较函数。</p><p id="9ab1" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我在第一篇文章里说过，但是值得记住过程。我们的模板化的txt文件，就像上面的api_test.txt，看起来非常不可读。然而，这不是一个真正的问题，因为我们没有把它开发成一个txt文件。我们首先编写一个很好的完全可行的版本，我们编译它，迭代它，清理它，重构它，测试它。然后，当我们都完成了它，我们把它变成一个丑陋的txt文件，以便我们可以在以后重建它的参数。大部分工作发生在创建初始go文件和向generate.go添加接收器方法的过程中，将go文件转换为模板化的txt文件很快，如果基本go代码发生重大变化，我们可以很容易地重复多次。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="0991" class="np mj ji nl b gy nq nr l ns nt">&lt;&lt; range $index, $table := .Tables &gt;&gt;<br/>const &lt;&lt; $table.Name &gt;&gt;tableName = "&lt;&lt; $table.Name &gt;&gt;"</span><span id="fb03" class="np mj ji nl b gy nu nr l ns nt">var test&lt;&lt; $table.CapSingName &gt;&gt; = [2]&lt;&lt; $table.CapSingName &gt;&gt;{ &lt;&lt; $table.TestData 1 &gt;&gt;, &lt;&lt; $table.TestData 2 &gt;&gt; }</span><span id="74bf" class="np mj ji nl b gy nu nr l ns nt">var update&lt;&lt; $table.CapSingName &gt;&gt; = &lt;&lt; $table.CapSingName &gt;&gt;&lt;&lt; $table.TestData 1 &gt;&gt;</span><span id="fe99" class="np mj ji nl b gy nu nr l ns nt">//compare functions<br/>var compare&lt;&lt; $table.CapName &gt;&gt; = map[string]compareType{<br/>&lt;&lt; $table.CompareMapFields &gt;&gt;<br/>}</span></pre><p id="20fa" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们需要添加到原始generate.go中的惟一东西是为任何sql数据类型创建测试数据的能力。我们现在的简单测试策略是将数据保存到PostgreSQL数据库中，然后确保同样的东西再次返回。对于metaapi支持的27种不同的sql数据类型，这意味着大量的测试生成函数。只需要三个比较函数:defaultCompare、stringCompare和jsonCompare —您可以在上面的api_test.txt中找到这些函数。</p><p id="8b74" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">在metapi/metasql/generate.go中增加了</strong>:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="c8aa" class="np mj ji nl b gy nq nr l ns nt">..abridged</span><span id="fe41" class="np mj ji nl b gy nu nr l ns nt">//TEST SPECIFIC</span><span id="e2b3" class="np mj ji nl b gy nu nr l ns nt">type GenerateFunc func(int, int) string</span><span id="52be" class="np mj ji nl b gy nu nr l ns nt">type testFuncs struct {<br/>  GenerateData GenerateFunc<br/>  CompareData  string<br/>}</span><span id="60d8" class="np mj ji nl b gy nu nr l ns nt">var dataMap = map[string]testFuncs{<br/>  "BOOLEAN":     {boolTestData, "defaultCompare"},<br/>  "BOOL":        {boolTestData, "defaultCompare"},<br/>  "CHARID":      {stringTestData, "defaultCompare"}, <br/>  "VARCHARID":   {stringTestData, "defaultCompare"},<br/>  "TEXT":        {stringTestData, "defaultCompare"},<br/>  "SMALLINT":    {int16TestData, "defaultCompare"},<br/>  "INT":         {int32TestData, "defaultCompare"},<br/>  "INTEGER":     {int32TestData, "defaultCompare"},<br/>  "BIGINT":      {int32TestData, "defaultCompare"},<br/>  "SMALLSERIAL": {serialTestData, "defaultCompare"},<br/>  "SERIAL":      {serialTestData, "defaultCompare"},<br/>  "BIGSERIAL":   {serialTestData, "defaultCompare"},<br/>  "FLOATID":     {float64TestData, "defaultCompare"}, <br/>  "REAL":        {float32TestData, "defaultCompare"},<br/>  "FLOAT8":      {float32TestData, "defaultCompare"},<br/>  "DECIMAL":     {float64TestData, "defaultCompare"},<br/>  "NUMERIC":     {float64TestData, "defaultCompare"},<br/>  "NUMERICID":   {float64TestData, "defaultCompare"}, <br/>  "PRECISION":   {float64TestData, "defaultCompare"}, <br/>  "DATE":        {dateTestData, "stringCompare"},     <br/>  "TIME":        {timeTestData, "stringCompare"},<br/>  "TIMESTAMPTZ": {timestampTestData, "stringCompare"},<br/>  "TIMESTAMP":   {timestampTestData, "stringCompare"},<br/>  "INTERVAL":    {durationTestData, "defaultCompare"},<br/>  "JSON":        {jsonTestData, "jsonCompare"}, <br/>  "JSONB":       {jsonbTestData, "jsonCompare"},<br/>  "UUID":        {uuidTestData, "defaultCompare"},<br/>}</span><span id="b5f6" class="np mj ji nl b gy nu nr l ns nt">func (table Table) CompareMapFields() string {<br/>  var s string</span><span id="dcd8" class="np mj ji nl b gy nu nr l ns nt">  for _, column := range table.Columns {<br/>    s += "\t\"" + camelize(column.Name) + "\": "<br/>    s += dataMap[column.Type].CompareData + ",\n"<br/>  }<br/>  return s<br/>}</span><span id="5ea1" class="np mj ji nl b gy nu nr l ns nt">func (table Table) TestData(dataid int) string {<br/>  rand.Seed(time.Now().UnixNano())</span><span id="e5b2" class="np mj ji nl b gy nu nr l ns nt">  var s string</span><span id="d75b" class="np mj ji nl b gy nu nr l ns nt">  s = "{"<br/>  for columnid, column := range table.Columns {<br/>    s += " " + dataMap[column.Type].GenerateData(dataid, columnid)<br/>    s += comma(columnid, len(table.Columns))<br/>  }<br/>  s += "}"<br/>  return s<br/>}</span><span id="6c02" class="np mj ji nl b gy nu nr l ns nt">func boolTestData(dataid int, columnid int) string {<br/>  return (strconv.FormatBool(rand.Intn(2) != 0))<br/>}<br/>func stringTestData(dataid int, columnid int) string {<br/>  return ("\"" + randString(16) + "\"")<br/>}<br/>func int16TestData(dataid int, columnid int) string {<br/>  if columnid == 0 { //assume serial<br/>    return (strconv.FormatInt(int64(dataid), 10))<br/>  } else {<br/>    return (strconv.FormatInt(int64(rand.Intn(32767)), 10))<br/>  }<br/>}<br/>func int32TestData(dataid int, columnid int) string {<br/>  if columnid == 0 { //assume serial<br/>    return (strconv.FormatInt(int64(dataid), 10))<br/>  } else {<br/>    return (strconv.FormatInt(int64(rand.Int31()), 10))<br/>  }<br/>}<br/>func int64TestData(dataid int, columnid int) string {<br/>  if columnid == 0 { //assume serial<br/>    return (strconv.FormatInt(int64(dataid), 10))<br/>  } else {<br/>    return (strconv.FormatInt(rand.Int63(), 10))<br/>  }<br/>}<br/>func serialTestData(dataid int, columnid int) string {<br/>  return strconv.Itoa(dataid)<br/>}<br/>func float64TestData(dataid int, columnid int) string {<br/>  return (strconv.FormatFloat(rand.NormFloat64(), 'f', -1, 64))<br/>}<br/>func float32TestData(dataid int, columnid int) string {<br/>  return (strconv.FormatFloat(float64(rand.Float32()), 'f', -1, 32))<br/>}<br/>func timeTestData(dataid int, columnid int) string {<br/>  return "time.Date(0000, time.January, 1, time.Now().UTC().Hour(), time.Now().UTC().Minute(), time.Now().UTC().Second(), time.Now().UTC().Nanosecond(), time.UTC)"<br/>}<br/>func timestampTestData(dataid int, columnid int) string {<br/>  return "time.Now().UTC().Truncate(time.Microsecond)"<br/>}<br/>func durationTestData(dataid int, columnid int) string {<br/>  return "\"12:34:45\""<br/>}<br/>func dateTestData(dataid int, columnid int) string {<br/>  return "time.Now().UTC().Truncate(time.Hour * 24)"<br/>}<br/>func jsonTestData(dataid int, columnid int) string {<br/>  return randJson()<br/>}<br/>func jsonbTestData(dataid int, columnid int) string {<br/>  return randJson()<br/>}<br/>func uuidTestData(dataid int, columnid int) string {<br/>  return "\"" + randUUID() + "\""<br/>}</span><span id="2666" class="np mj ji nl b gy nu nr l ns nt">func randString(length int) string {<br/>  const charset = "abcdefghijklmnopqrstuvwxyz" +<br/>    "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"</span><span id="a1d2" class="np mj ji nl b gy nu nr l ns nt">  b := make([]byte, length)<br/>  for i := range b {<br/>    b[i] = charset[rand.Intn(len(charset))]<br/>  }<br/>  return string(b)<br/>}</span><span id="f514" class="np mj ji nl b gy nu nr l ns nt">func randJson() string {<br/>  return "\"{\\\"name\\\": \\\"" + randString(16) + "\\\", \\\"age\\\": " + strconv.FormatInt(int64(rand.Int31()), 10) + ", \\\"city\\\": \\\"" + randString(20) + "\\\"}\""<br/>}</span><span id="b726" class="np mj ji nl b gy nu nr l ns nt">func randUUID() (uuid string) {<br/>  u := new([16]byte)<br/>  _, err := rand.Read(u[:])<br/>  if err != nil {<br/>    log.Panicln("Cannot generate UUID", err.Error())<br/>  }<br/>  u[8] = (u[8] | 0x40) &amp; 0x7F<br/>  u[6] = (u[6] &amp; 0xF) | (0x4 &lt;&lt; 4)<br/>  uuid = fmt.Sprintf("%x-%x-%x-%x-%x", u[0:4], u[4:6], u[6:8], u[8:10], u[10:])<br/>  return<br/>}</span></pre><p id="2ea9" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在，当我们使用todo.sql表定义在go generate语句中运行新版本的metaapi时，它将创建todo_api.go和todo_api_test.go</p><p id="6cbd" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">newtodo/todo.go:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="bdc1" class="np mj ji nl b gy nq nr l ns nt">//go:generate  metaapi -sql=todo.sql  -txt=api.txt<br/>//go:generate  metaapi -sql=todo.sql  -txt=api_test.txt<br/>package main</span></pre><p id="dc29" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">毫无疑问，我们已经重建了原始的api文件和测试文件。它真的适用于任何sql类型吗？让我们尝试一个sql文件，它定义了几个表，包括所有27种类型:</p><p id="8bbe" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">metaapi/examples/alltypes.sql:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="13fb" class="np mj ji nl b gy nq nr l ns nt">create table todos (<br/>  id           integer generated always as identity primary key,<br/>  updated_at   timestamptz,<br/>  done         boolean,<br/>  title        text<br/>);</span><span id="ac2d" class="np mj ji nl b gy nu nr l ns nt">create table allbools (<br/>  id         serial primary key,<br/>  abool      boolean,<br/>  abool2     bool<br/>);</span><span id="8853" class="np mj ji nl b gy nu nr l ns nt">create table allchars (<br/>  id         serial primary key,<br/>  achar      char(16),<br/>  avarchar   varchar(16),<br/>  atext      text<br/>);</span><span id="21f0" class="np mj ji nl b gy nu nr l ns nt">create table allints (<br/>  id         serial primary key,<br/>  asmallint  smallint,<br/>  aint       int,<br/>  aint2      integer,<br/>  asmallser  smallserial,<br/>  aser       serial,<br/>  abigser    bigserial<br/>);</span><span id="9c53" class="np mj ji nl b gy nu nr l ns nt">create table allfloats (<br/>  id         serial primary key,<br/>  afloat     float(53),<br/>  areal      real,<br/>  afloat8    float8,<br/>  adecimal   decimal,<br/>  anumeric   numeric,<br/>  anumeric2  numeric(36,18),<br/>  adouble    double precision<br/>);</span><span id="b03d" class="np mj ji nl b gy nu nr l ns nt">create table alltimes (<br/>  id         serial primary key,<br/>  adate      date,<br/>  atime      time,<br/>  ats        timestamp,<br/>  atsz       timestamptz,<br/>  ainterval  interval<br/>);</span><span id="3df6" class="np mj ji nl b gy nu nr l ns nt">create table alljsons (<br/>  id         serial primary key,<br/>  ajson      json,<br/>  ajsonb     jsonb<br/>);</span><span id="242b" class="np mj ji nl b gy nu nr l ns nt">create table uuids (<br/>  id         serial primary key,<br/>  auuid      uuid<br/>);</span></pre><p id="1e3c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">是的，它工作了。好吧，算是吧。我在char()、float()和numeric()上作弊，选择了我知道可以工作的参数，如果没有更好的测试数据生成函数，这些类型将无法处理任何任意参数。实现正确的测试数据生成功能仍然是待定的。</p><p id="a7a9" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">另一个需要做更多工作的领域是处理外键的通用测试策略。这不会影响CRUD api的生成，但是会影响测试。现在，metaapi一次测试一个表，因此外键不会通过测试。让我们解决这个问题。例如:</p><p id="f2d4" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">metaapi/examples/todoref.sql</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="93ef" class="np mj ji nl b gy nq nr l ns nt">create table owners (<br/>    id           integer generated always as identity primary key,<br/>    name         text<br/>);</span><span id="8e3a" class="np mj ji nl b gy nu nr l ns nt">create table todos (<br/>    id           integer generated always as identity primary key,<br/>    updated_at   timestamptz,<br/>    done         boolean,<br/>    title        text,<br/>    owner        integer references owners(id)<br/>);</span></pre><p id="75be" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">只要做一些小的修改，我们就可以改变我们的测试来允许整数外键。我不会在这里展示代码的变化，但你可以在回复中看到它们。我们的策略是:</p><ol class=""><li id="2af4" class="lu lv ji kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated">向列结构添加一个bool来跟踪外键字段(generate.go)</li><li id="5f52" class="lu lv ji kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">当我们解析<code class="fe nv nw nx nl b">REFERENCES table(field)</code> sql语法(parse.go)时，添加一个函数来设置该字段</li><li id="b061" class="lu lv ji kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">更改我们的整数测试数据生成器，如果它们是外键，使用已知的id(generator . go)</li><li id="1caa" class="lu lv ji kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">更改我们的测试模板，在测试结束时以相反的顺序删除所有的表。</li></ol><p id="b98e" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这些更改将保证我们的被引用表在外键需要它们时仍然存在，并且我们以正确的顺序展开所有的删除。如果您使用上面的todoref.sql创建一个新项目，生成api/test代码，并运行测试，您将看到所有测试都通过了。</p><h1 id="d2e1" class="mi mj ji bd mk ml mm mn mo mp mq mr ms ko mt kp mu kr mv ks mw ku mx kv my mz bi translated">内部模板</h1><p id="af6e" class="pw-post-body-paragraph kx ky ji kz b la na kj lc ld nb km lf lg nc li lj lk nd lm ln lo ne lq lr ls im bi translated">在这一点上，我们有了创建api的metaapi，也测试了该api，但是，我们要求用户将我们的模板(api.txt和api_test.txt)复制到他们的本地项目，以便运行go generate。如果我们可以访问metaapi中的这些内容，这样用户就不必管理它们，这对用户来说会好得多。原来有这样一个应用程序！实际上，这是一个CLI工具，叫做<a class="ae lt" href="https://github.com/jteeuwen/go-bindata" rel="noopener ugc nofollow" target="_blank"> go-bindata </a>，虽然已经几年没人碰它了，但它仍然非常好用。我们将使用go-bindata来压缩源文件，并将其转换成可以在metaapi中直接访问的资源。我们首先安装go-bindata <code class="fe nv nw nx nl b">go get -u github.com/jteeuwen/go-bindata/...</code>，然后我们将创建一个名为data的新目录，将我们的txt模板复制到该目录中，并在该目录上运行go bindata。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="cec2" class="np mj ji nl b gy nq nr l ns nt">cd metaapi/data<br/>go-bindata .</span></pre><p id="0e2f" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这将创建一个新的文件metaapi/data/bindata.go，它将我们的文件压缩到资源中，并提供一些很好的方法来与它们进行交互——所有这些都是自包含的，不需要更多的东西。对我们来说唯一重要的方法是Asset()。我们只是交换了我们的借据。Readfile()，将包名从main改为data，我们就可以开始读取我们自己的资产了。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="f8e2" class="np mj ji nl b gy nq nr l ns nt">  //for external templates, instead of data.Asset, use:<br/>  // dat, err := ioutil.ReadFile("./" + txtFile)<br/>  // if err != nil {<br/>  //  return err<br/>  // }</span><span id="9876" class="np mj ji nl b gy nu nr l ns nt">  dat, err := data.Asset(txtFile)<br/>  if err != nil {<br/>   return err<br/>  }</span></pre><p id="37ba" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">不要忘记，每当你改变你的资产，在我们的例子中是api.txt和api_test.txt，你必须再次在它们上面运行go-bindata并编译你的应用程序。所有的资产都存储在bindata.go中，这很好，因为这意味着用户不需要go-bindata工具，但是如果开发人员改变了资产，他们就需要了。</p><h1 id="3b16" class="mi mj ji bd mk ml mm mn mo mp mq mr ms ko mt kp mu kr mv ks mw ku mx kv my mz bi translated">外部生成</h1><p id="6082" class="pw-post-body-paragraph kx ky ji kz b la na kj lc ld nb km lf lg nc li lj lk nd lm ln lo ne lq lr ls im bi translated">现在我们已经切换到api模板的内部访问，我们不再有一个好的方式让用户轻松地定制和扩展模板和生成器。让我们把它加回去，让它变得更好一点。现在，metaapi负责所有的词法分析、解析和代码生成。作为一个选项，我们希望让metaapi进行词法分析和解析，然后将其解析结果(sm结构)传递给我们正在处理的任意程序。如果我们想使用自己的模板和生成器，这将改善我们的工作流，因为我们在对生成器进行更改时不需要重新编译metaapi。</p><p id="0fe8" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">有很多方法可以让我们看到这一点。最初，您可能会尝试将json形式的sm数据从metaapi传输到您的项目中，类似于:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="e9e9" class="np mj ji nl b gy nq nr l ns nt">//go:generate  metaapi -sql=todo.sql -txt=api.txt | myproj<br/>//this does not work</span></pre><p id="ba05" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这里的问题是go generate不是一个shell，只是一个原始命令，所以这不起作用——管道是一个shell函数。我们可以尝试在go generate中执行一个shell命令，但是将shell放入其中是不可移植的。您可以使用多行go generate命令，因此在一个命令中从metaapi保存到中间statemachine.json文件，然后在另一个命令中读入myproj将会有效..但这是一个多么丑陋的解决方案。最后，golang的net/rpc包可以在两端添加几行新代码，然后通过过程调用传递sm数据。我尝试过这种方法，它很有效，但是对于按需启动rpc服务器来说似乎有点大材小用了。</p><p id="3880" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让我们改为修复go generate，我们可以用一个小的实用程序来完成，我们称它为“管道”。它的工作是执行任意数量的带有参数的命令，将一个命令的输出传递给下一个命令的输入。这是简单、干净和有效的。</p><p id="5dfd" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">管道/干管. go:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="460b" class="np mj ji nl b gy nq nr l ns nt">//pipe: use in go generate statements to pipe commands<br/>//commands are executed left to right<br/>//stdout from preceding is piped into stdin of next<br/>//commands are separated by ::<br/>//format is: pipe cmd0 arg0 arg1.. :: cmd1 arg0 arg1.. :: cmdn..<br/>//use pipe -v (verbose) to print output from each command<br/>package main</span><span id="1607" class="np mj ji nl b gy nu nr l ns nt">import (<br/>  "fmt"<br/>  "io"<br/>  "io/ioutil"<br/>  "log"<br/>  "os"<br/>  "os/exec"<br/>)</span><span id="1e48" class="np mj ji nl b gy nu nr l ns nt">func main() {<br/>  if len(os.Args) == 1 {<br/>    fmt.Println(" valid usage is:")<br/>    fmt.Println("  //go generate pipe cmd0 arg0 arg1.. :: cmd1 arg0 arg1.. :: cmdn..")<br/>    fmt.Println("  //go generate pipe -v cmd0 arg0 arg1.. :: cmd1 arg0 arg1.. :: cmdn..")<br/>    os.Exit(1)<br/>  }<br/>  //parse command string into nxm slice of strings<br/>  verbose := false<br/>  startindex := 0<br/>  if os.Args[1] == "-v" { //verbose<br/>    verbose = true<br/>    startindex = 1<br/>  }<br/>  var cmda [][]string<br/>  for i := startindex; i &lt; len(os.Args); i++ {<br/>    if (i == startindex) || (os.Args[i] == "::") {<br/>      cmda = append(cmda, []string{})<br/>    } else {<br/>      cmda[len(cmda)-1] = append(cmda[len(cmda)-1], os.Args[i])<br/>    }<br/>  }</span><span id="8282" class="np mj ji nl b gy nu nr l ns nt">  var out []byte<br/>  //execute all commands hooking up outputs to inputs<br/>  for i := 0; i &lt; len(cmda); i++ {<br/>    fmt.Println("Command: ", cmda[i][0], cmda[i][1:])<br/>    cmd := exec.Command(cmda[i][0], cmda[i][1:]...)<br/>    stderr, err := cmd.StderrPipe()<br/>    if err != nil {<br/>      log.Fatal(err)<br/>    }<br/>    stdout, err := cmd.StdoutPipe()<br/>    if err != nil {<br/>      log.Fatal(err)<br/>    }<br/>    if i &gt; 0 {<br/>      stdin, err := cmd.StdinPipe()<br/>      if err != nil {<br/>        log.Fatal(err)<br/>      }</span><span id="1343" class="np mj ji nl b gy nu nr l ns nt">      go func() {<br/>        defer stdin.Close()<br/>        io.WriteString(stdin, string(out))<br/>      }()<br/>    }<br/>    if err := cmd.Start(); err != nil {<br/>      log.Fatal(err)<br/>    }<br/>    newout, _ := ioutil.ReadAll(stdout)<br/>    if verbose {<br/>      fmt.Println(string(newout))<br/>    }<br/>    errtxt, _ := ioutil.ReadAll(stderr)<br/>    if string(errtxt) != "" {<br/>      fmt.Printf("%s\n", errtxt)<br/>    }<br/>    if err := cmd.Wait(); err != nil {<br/>      log.Fatal(err)<br/>    }<br/>    out = newout<br/>  }<br/>}</span></pre><p id="1f1c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">你可以像这样安装这个工具，注意，它被设计成在go generate中作为一个原始命令运行，而不是作为一个shell命令，shell会干扰它。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="63fa" class="np mj ji nl b gy nq nr l ns nt">go get github.com/exyzzy/pipe<br/>go install $GOPATH/src/github.com/exyzzy/pipe</span></pre><p id="8d07" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">要使用pipe，您只需将它作为第一件事包含在您的go generate语句中，其他应用程序和它们使用的任何标志用以下符号分隔:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="592a" class="np mj ji nl b gy nq nr l ns nt">//go generate pipe app1 -flag=app1flag :: app2 -flag=app2flag</span></pre><p id="6571" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">因此，现在将执行app1，它的任何stdout都将通过管道传入app2的stdin，您可以将任意多的应用程序连接在一起。Pipe还有一个-v选项，用于使用详细模式，打印出正在执行的应用程序和参数。</p><p id="b2fa" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们还需要对metaapi进行一些更改，提供一个选项，通过stdout将statemachine数据的json版本传递给项目中的新生成器，后者将通过stdin接受它。</p><p id="1cc9" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">metaapi/main.go:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="4df4" class="np mj ji nl b gy nq nr l ns nt">pipePtr := flag.Bool("pipe", false, "use piped generation")<br/>flag.Parse()</span><span id="3f41" class="np mj ji nl b gy nu nr l ns nt"><br/>..some code..</span><span id="8834" class="np mj ji nl b gy nu nr l ns nt">if !*pipePtr {<br/>  err := metasql.Generate(*sm, txtFile)<br/>  if err != nil {<br/>    log.Panic(err)<br/>  }<br/>} else {<br/>  //send to stdio<br/>  psm, err := json.Marshal(sm)<br/>  if err != nil {<br/>    log.Panic(err)<br/>    return<br/>  }<br/>  fmt.Println(string(psm))<br/>}</span></pre><p id="03b2" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这允许我们现在在新项目中接收sm数据，并在那里编译生成器。</p><p id="9336" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">newtodo/main.go:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="6288" class="np mj ji nl b gy nq nr l ns nt">package main</span><span id="664c" class="np mj ji nl b gy nu nr l ns nt">import (<br/>  "flag"<br/>  "log"<br/>  "os"<br/>  "strings"<br/>)</span><span id="dcde" class="np mj ji nl b gy nu nr l ns nt">func main() {<br/>  txtPtr := flag.String("txt", "api.txt", "go template as .txt file")<br/>  pipePtr := flag.Bool("pipe", false, "use piped generation")<br/>  flag.Parse()<br/>  if *pipePtr { //set up for more code<br/>    txtFile := strings.ToLower(*txtPtr)<br/>    if (txtFile == "") || (!strings.HasSuffix(txtFile, ".txt")) {<br/>      log.Panic("No .txt File")<br/>    }</span><span id="0219" class="np mj ji nl b gy nu nr l ns nt">    sm, err := ReadSM()<br/>    if err != nil {<br/>      log.Panic(err)<br/>    }<br/>    err = Generate(*sm, txtFile)<br/>    if err != nil {<br/>      log.Panic(err)<br/>    }<br/>    os.Exit(0)<br/>  }<br/>    //more stuff...<br/>}</span></pre><p id="9788" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">newtodo/todo.go</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="d8be" class="np mj ji nl b gy nq nr l ns nt">//go:generate  pipe metaapi -pipe=true -sql=todo.sql  :: newtodo -pipe=true -txt=api.txt<br/>//go:generate  pipe metaapi -pipe=true -sql=todo.sql  :: newtodo -pipe=true -txt=api_test.txt<br/>//Note requires:<br/>//      <a class="ae lt" href="https://github.com/exyzzy/metaapi" rel="noopener ugc nofollow" target="_blank">https://github.com/exyzzy/metaapi</a><br/>//      <a class="ae lt" href="https://github.com/exyzzy/pipe" rel="noopener ugc nofollow" target="_blank">https://github.com/exyzzy/pipe</a></span><span id="a962" class="np mj ji nl b gy nu nr l ns nt">package main</span><span id="0291" class="np mj ji nl b gy nu nr l ns nt">//before first go test:<br/>//createuser -P -d newtodo &lt;pass: newtodo&gt;<br/>//createdb newtodo</span></pre><p id="3b76" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在，在使用metaapi的这个变体中，我们已经将generate.go和两个模板文件:api.txt和api_test.txt移到了我们当前的项目newtodo中。这允许我们在当前项目中修改txt模板和generate.go，并在metaapi中使用它们，而无需重新编译metaapi。如果您正在开发一个带有自定义模板的项目，这是一个不错的选择。</p><h1 id="2f29" class="mi mj ji bd mk ml mm mn mo mp mq mr ms ko mt kp mu kr mv ks mw ku mx kv my mz bi translated">自动创建项目</h1><p id="ef61" class="pw-post-body-paragraph kx ky ji kz b la na kj lc ld nb km lf lg nc li lj lk nd lm ln lo ne lq lr ls im bi translated">我们现在有很多关于metaapi和pipe的事情。即使有好的文档，我们的用户也可能很难设置和使用，所以让我们通过构建一个自动创建初始metaapi项目的小命令行实用程序来简化它。我们将使用上面已经使用过的相同技术，使用go-bindata创建内部资产文件，然后使用它们和go模板来参数化我们的模板。我们的目标是在一个CLI行中为内部或外部metaapi项目创建一个项目。</p><p id="77bc" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们在这里要做的是将我们项目的所有相关文件复制到。根据需要模板化的txt文件。然后我们将使用go-bindata将它们转化为内部资产。最后，我们将在main.go中访问它们，并将它们作为模板来创建我们的项目文件。这是一个简单的模式，可以用来从模板化的txt文件自动生成目标文件。</p><p id="dec8" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">metaproj/main.go:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="d4ca" class="np mj ji nl b gy nq nr l ns nt">package main</span><span id="b58d" class="np mj ji nl b gy nu nr l ns nt">import (<br/>  "errors"<br/>  "flag"<br/>  "fmt"<br/>  "io/ioutil"<br/>  "log"<br/>  "os"<br/>  "path/filepath"<br/>  "strings"<br/>  "text/template"</span><span id="d7c0" class="np mj ji nl b gy nu nr l ns nt">  "github.com/exyzzy/metaproj/data"<br/>)</span><span id="91d0" class="np mj ji nl b gy nu nr l ns nt">//This struct passed into all templates for generation<br/>//also use receiver methods such as Project, below<br/>type ProjData struct {<br/>  ProjName string<br/>  SqlFile  string<br/>  ProjType string<br/>}</span><span id="d2e2" class="np mj ji nl b gy nu nr l ns nt">// Create a metaapi base project from a .sql table definition, example:<br/>//  metaproj -proj=newtodo -sql=todo.sql -type=external  (or, for internal:  metaproj -proj=newtodo -sql=todo.sql )<br/>//  cd newtodo<br/>//  go generate<br/>func main() {<br/>  projPtr := flag.String("proj", "myproj", "project to create")<br/>  sqlPtr := flag.String("sql", "", ".sql input file to parse")<br/>  typePtr := flag.String("type", "internal", "project type to create")</span><span id="bc03" class="np mj ji nl b gy nu nr l ns nt">  var p ProjData</span><span id="e5f7" class="np mj ji nl b gy nu nr l ns nt">  flag.Parse()<br/>  if flag.NFlag() == 0 {<br/>    fmt.Println(" valid usage is:")<br/>    fmt.Println("  metproj -proj=yourproj -sql=yoursql.sql")<br/>    fmt.Println("  metproj -proj=yourproj -sql=yoursql.sql -type=external")<br/>    os.Exit(1)<br/>  }</span><span id="ac0a" class="np mj ji nl b gy nu nr l ns nt">  p.ProjName = strings.ToLower(*projPtr)<br/>  p.SqlFile = strings.ToLower(*sqlPtr)<br/>  p.ProjType = strings.ToLower(*typePtr)</span><span id="0506" class="np mj ji nl b gy nu nr l ns nt">  if (p.SqlFile != "") &amp;&amp; (!strings.HasSuffix(p.SqlFile, ".sql")) {<br/>    log.Panic("Invalid .sql File")<br/>  }</span><span id="ceda" class="np mj ji nl b gy nu nr l ns nt">  err := createProj(&amp;p)<br/>  if err != nil {<br/>    log.Panic(err)<br/>  }<br/>}</span><span id="74e0" class="np mj ji nl b gy nu nr l ns nt">func createProj(pp *ProjData) error {<br/>  if (pp.ProjName == "") || (pp.SqlFile == "") {<br/>    log.Panic(errors.New("Must have projName and sqlFile"))<br/>  }</span><span id="c2ea" class="np mj ji nl b gy nu nr l ns nt">var projTypes = map[string]int{"internal": 0, "external": 1}<br/>  pIndex, ok := projTypes[pp.ProjType]<br/>  if !ok {<br/>    log.Panic(errors.New(fmt.Sprintf("Invald project type, use: %v", keys(projTypes))))<br/>  }</span><span id="3c06" class="np mj ji nl b gy nu nr l ns nt">err := os.MkdirAll(pp.ProjName, os.FileMode(0755))<br/>  if err != nil {<br/>    return err<br/>  }</span><span id="ebcc" class="np mj ji nl b gy nu nr l ns nt">type FileList struct {<br/>    Name       string<br/>    IsGenerate bool //if false just copy the file with no template actions applied<br/>  }</span><span id="d1ca" class="np mj ji nl b gy nu nr l ns nt">var files = [][]FileList{{{"sqlname.txt", true}, {"configlocaldb.txt", true}},<br/>    {{"sqlname2.txt", true}, {"configlocaldb.txt", true}, {"generate.txt", true}, {"main.txt", true}, {"api.txt", false}, {"api_test.txt", false}}}</span><span id="4259" class="np mj ji nl b gy nu nr l ns nt">  for _, f := range files[pIndex] {<br/>    dat, err := data.Asset(f.Name)<br/>    if err != nil {<br/>      return err<br/>    }<br/>    if f.IsGenerate {<br/>      err = generateFile(dat, pp, getDest(pp, f.Name))<br/>      if err != nil {<br/>        return err<br/>      }<br/>    } else {<br/>      err = writeFile(dat, getDest(pp, f.Name))<br/>    }<br/>  }<br/>  err = copyFile(pp, pp.SqlFile)<br/>  return err<br/>}</span><span id="e1f3" class="np mj ji nl b gy nu nr l ns nt">func keys(ms map[string]int) []string {<br/>  kys := make([]string, len(ms))<br/>  i := 0<br/>  for k := range ms {<br/>    kys[i] = k<br/>    i++<br/>  }<br/>  return kys<br/>}</span><span id="c523" class="np mj ji nl b gy nu nr l ns nt">func getDest(pp *ProjData, name string) string {<br/>  var dest string<br/>  switch name {<br/>  case "sqlname.txt", "sqlname2.txt":<br/>    dest = prefix(pp.SqlFile) + ".go"<br/>  case "configlocaldb.txt":<br/>    dest = "configlocaldb.json"<br/>  case "generate.txt":<br/>    dest = "generate.go"<br/>  case "main.txt":<br/>    dest = "main.go"<br/>  case "api.txt":<br/>    dest = "api.txt"<br/>  case "api_test.txt":<br/>    dest = "api_test.txt"<br/>  }<br/>  return filepath.Join(pp.ProjName, dest)<br/>}</span><span id="f7a8" class="np mj ji nl b gy nu nr l ns nt">func prefix(name string) string {<br/>  dot := strings.Index(name, ".")<br/>  if dot &gt; 0 {<br/>    return name[:dot]<br/>  } else {<br/>    return name<br/>  }<br/>}</span><span id="ccfe" class="np mj ji nl b gy nu nr l ns nt">func generateFile(templatesrc []byte, data interface{}, dest string) error {<br/>  tt := template.Must(template.New("file").Parse(string(templatesrc)))<br/>  file, err := os.Create(dest)<br/>  if err != nil {<br/>    return err<br/>  }<br/>  err = tt.Execute(file, data)<br/>  file.Close()<br/>  return err<br/>}</span><span id="7863" class="np mj ji nl b gy nu nr l ns nt">func copyFile(pp *ProjData, namesrc string) error {<br/>  dat, err := ioutil.ReadFile("./" + namesrc)<br/>  if err != nil {<br/>    return err<br/>  }<br/>  err = ioutil.WriteFile(filepath.Join(pp.ProjName, namesrc), dat, 0644)<br/>  if err != nil {<br/>    return err<br/>  }<br/>  return nil<br/>}</span><span id="d0df" class="np mj ji nl b gy nu nr l ns nt">func writeFile(templatesrc []byte, dest string) error {<br/>  err := ioutil.WriteFile(dest, templatesrc, 0644)<br/>  if err != nil {<br/>    return err<br/>  }<br/>  return nil<br/>}</span><span id="46e5" class="np mj ji nl b gy nu nr l ns nt">func (pp *ProjData) Package() string {<br/>  proj := os.Getenv("GOPACKAGE")<br/>  if proj == "" {<br/>    proj = "main"<br/>  }<br/>  return proj<br/>}</span></pre><p id="4d08" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">请注意，我们使用文件名的嵌套数组来确定哪些文件用于内部还是外部metaapi项目。如果应用了模板操作(参数),则尾部布尔值为真，如果是直接的文件副本，则为假:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="f148" class="np mj ji nl b gy nq nr l ns nt">var files = [][]FileList{{{"sqlname.txt", true}, <br/>     {"configlocaldb.txt", true}},<br/>    {{"sqlname2.txt", true}, {"configlocaldb.txt", true}, <br/>     {"generate.txt", true}, {"main.txt", true}, {"api.txt", false}, <br/>     {"api_test.txt", false}}}</span></pre><p id="7087" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">此外，我们将返回到metaproj中模板的默认go分隔符，因为我们将模板化的txt文件之一是generate.go本身，它包括行<code class="fe nv nw nx nl b">tt := template.Must(template.New(“file”).Delims(“&lt;&lt;”, “&gt;&gt;”).Parse(string(templatesrc)))</code>注意，Delim语句将始终作为(失败的)模板操作执行，因为它包括开始和结束模板操作分隔符<code class="fe nv nw nx nl b">&lt;&lt;&gt;&gt;</code>。所以我们需要metaproj和metaapi中不同的分隔符。</p><p id="b9be" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">查看github repo以查看完整的文件集，因为有一个txt文件的数据/文件夹和从它们创建的bindata.go。</p><p id="75cb" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在，我们有了一个简单的命令行实用程序，可以基于sql表定义创建两种不同风格的初始metaapi项目。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="92e9" class="np mj ji nl b gy nq nr l ns nt">metaproj -sql=mysqltables -proj=myprojectname</span></pre><p id="aa23" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">您可以添加可选的<code class="fe nv nw nx nl b">-type=external</code>，让它创建一个使用pipe的metaapi项目，这样您就可以定制api txt模板和generate.go</p><p id="e492" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">好了，现在让我们将所有这些放在一起并进行测试，包括内部和外部的metaapi项目。</p><p id="407f" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">首先创建您的PostgreSQL项目数据库，以便测试可以工作:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="d942" class="np mj ji nl b gy nq nr l ns nt">createuser -P -d myproj &lt;pass: myproj&gt;<br/>createdb myproj</span></pre><p id="76d5" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在，创建一个默认的内部metaapi项目并测试它:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="6575" class="np mj ji nl b gy nq nr l ns nt">go get github.com/exyzzy/metaapi<br/>go install $GOPATH/src/github.com/exyzzy/metaapi<br/>go get github.com/exyzzy/metaproj<br/>go install $GOPATH/src/github.com/exyzzy/metaproj<br/>cp $GOPATH/src/github.com/exyzzy/metaapi/examples/alltypes.sql .<br/># or your own postgreSQL table definition<br/>rm -rf myproj<br/>#clean out the old directory if needed</span><span id="d221" class="np mj ji nl b gy nu nr l ns nt">metaproj -sql=alltypes.sql -proj=myproj <br/>cd myproj<br/>go generate<br/>go test</span></pre><p id="8e35" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">该项目将看起来像:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="35d6" class="np mj ji nl b gy nq nr l ns nt">myproj/<br/>    alltypes.go<br/>    alltypes.sql<br/>    alltypes_generated_api.go<br/>    alltypes_generated_api_test.go<br/>    configlocaldb.json</span></pre><p id="21ad" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">最后，让我们创建一个外部metaapi项目，您希望在其中开发定制模板:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="f79a" class="np mj ji nl b gy nq nr l ns nt">go get github.com/exyzzy/metaapi<br/>go install $GOPATH/src/github.com/exyzzy/metaapi<br/>go get github.com/exyzzy/metaproj<br/>go install $GOPATH/src/github.com/exyzzy/metaproj<br/>go get github.com/exyzzy/pipe<br/>go install $GOPATH/src/github.com/exyzzy/pipe<br/>cp $GOPATH/src/github.com/exyzzy/metaapi/examples/alltypes.sql .<br/>rm -rf myproj<br/>#clean out the old directory if needed</span><span id="3bdb" class="np mj ji nl b gy nu nr l ns nt">metaproj -sql=alltypes.sql -proj=myproj -type=external <br/># or your own postgreSQL table definition<br/>cd myproj<br/>go install<br/>go generate<br/>go test</span></pre><p id="b513" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">该项目将看起来像:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="4668" class="np mj ji nl b gy nq nr l ns nt">myproj/<br/>    alltypes.go<br/>    alltypes.sql<br/>    alltypes_generated_api.go<br/>    alltypes_generated_api_test.go<br/>    configlocaldb.json<br/>    api.txt<br/>    api_test.txt<br/>    generate.go<br/>    main.go</span></pre><p id="6b0f" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这两者都应该:</p><ul class=""><li id="6882" class="lu lv ji kz b la lb ld le lg lw lk lx lo ly ls nf ma mb mc bi translated">生成初始项目</li><li id="aea7" class="lu lv ji kz b la md ld me lg mf lk mg lo mh ls nf ma mb mc bi translated">为sql表生成CRUD api</li><li id="bc17" class="lu lv ji kz b la md ld me lg mf lk mg lo mh ls nf ma mb mc bi translated">为CRUD api生成基本测试</li><li id="cde6" class="lu lv ji kz b la md ld me lg mf lk mg lo mh ls nf ma mb mc bi translated">通过所有测试</li></ul><p id="dc8f" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们已经成功地将我们最初的metaapi工具扩展为一个能够为大多数PostgreSQL类型创建CRUD api的工具，并创建相应的api测试函数。我们创建了一个实用程序pipe，允许多个应用程序在go generate调用中链接在一起。我们创建了另一个实用程序metaproj，它是从参数化的基础文件创建任何新项目的通用模式。这些应该会给我们从PostgreSQL表定义构建go项目一个巨大的开端。</p><p id="4b27" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">您可以在以下网址找到所有源代码:</p><ul class=""><li id="c3ad" class="lu lv ji kz b la lb ld le lg lw lk lx lo ly ls nf ma mb mc bi translated"><a class="ae lt" href="https://github.com/exyzzy/metaapi" rel="noopener ugc nofollow" target="_blank">https://github.com/exyzzy/metaapi</a></li><li id="e697" class="lu lv ji kz b la md ld me lg mf lk mg lo mh ls nf ma mb mc bi translated"><a class="ae lt" href="https://github.com/exyzzy/pipe" rel="noopener ugc nofollow" target="_blank">https://github.com/exyzzy/pipe</a></li><li id="c031" class="lu lv ji kz b la md ld me lg mf lk mg lo mh ls nf ma mb mc bi translated">【https://github.com/exyzzy/metaproj T2】号</li></ul><p id="0e39" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">玩得开心。</p></div></div>    
</body>
</html>