<html>
<head>
<title>Makie Bar Plots in Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">《朱丽亚》中的酒吧情节</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/makie-barplots-in-julia-2821dbe35366?source=collection_archive---------12-----------------------#2022-02-27">https://levelup.gitconnected.com/makie-barplots-in-julia-2821dbe35366?source=collection_archive---------12-----------------------#2022-02-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d92e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Makie绘图包制作堆叠和躲避栏</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c2156a997d0f0a7a5320f7e8e92ae225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N5sh2XekPXEKK6rQ2C55eA.png"/></div></div></figure><p id="9162" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Makie 给了你很大的绘制条形图的灵活性，但是你如何使用这个功能并不总是显而易见的。</p><p id="2c7a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> Makie参考文件:</em> <a class="ae lq" href="https://makie.juliaplots.org/v0.15.1/examples/plotting_functions/barplot/" rel="noopener ugc nofollow" target="_blank">柱状图</a></p><p id="99e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了解释Makie如何处理条形图，我们将从一个非常简单的图开始，然后逐渐添加更多的复杂性。如果你想跟着做，我建议你要么使用一个编辑器，比如可以显示图形的VS Code，要么像我一样使用<a class="ae lq" href="https://github.com/queryverse/ElectronDisplay.jl" rel="noopener ugc nofollow" target="_blank"> ElectronDisplay </a>包。简单的用<code class="fe ls lt lu lv b">using ElectronDisplay</code>加载包应该就够了。</p><p id="a8b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">绘图函数的许多参数都接受数组或区域。棘手的是理解所有这些数组是如何相互关联的。为了帮助解释，我们将从一个简单的情节开始:</p><pre class="kj kk kl km gt lw lv lx ly aw lz bi"><span id="7763" class="ma mb it lv b gy mc md l me mf">xs = 1:5<br/>ys = [3, 2, 4, 5, 2]<br/>cs = 1:5<br/>barplot(<br/>   xs,          # Where to place each bar<br/>   ys,          # Height of each bar<br/>   color=cs,    # Color of each bar<br/>)</span></pre><p id="c0c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每一条都在x轴上的位置<code class="fe ls lt lu lv b">xs[i]</code>处标有高度<code class="fe ls lt lu lv b">ys[i]</code>和颜色<code class="fe ls lt lu lv b">cs[i]</code>。因为<code class="fe ls lt lu lv b">xs[2] == 2</code>，第二个条(蓝色)将绘制在位置二。之所以是蓝色，是因为<code class="fe ls lt lu lv b">cs[2] == 2</code>和当前配色方案中的第二种颜色是蓝色。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mg"><img src="../Images/18850c0cd9e90df54256fdb85ec15fb1.png" data-original-src="https://miro.medium.com/v2/format:webp/1*sJ-QOJlQOd46Lwkt58PfCg.png"/></div></figure><p id="40dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">需要指出的一点是，你可以多次重复相同的x轴位置。接下来会发生什么？多个条被绘制在彼此之上。下面是一个执行此操作的代码示例:</p><pre class="kj kk kl km gt lw lv lx ly aw lz bi"><span id="16f8" class="ma mb it lv b gy mc md l me mf">fig = barplot(<br/>      [1, 2, 3, 2, 1], <br/>      ys,<br/>      color=cs,<br/>)</span></pre><p id="ab69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，我们将紫色和黄色条放在相同的位置。紫色条的位置在x轴的1处，因为<code class="fe ls lt lu lv b">xs[5] == 1</code>。因此，因为<code class="fe ls lt lu lv b">xs[1]</code>和<code class="fe ls lt lu lv b">xs[5]</code>具有相同的值，黄色和紫色条被放置在相同的位置。</p><p id="3214" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">绿色条被绘制在蓝色条的顶部。这是因为<code class="fe ls lt lu lv b">xs[2]</code>和<code class="fe ls lt lu lv b">xs[4]</code>都是2。条形的位置改变了，但是它们的颜色保持不变，因为我们没有改变包含每个条形颜色的<code class="fe ls lt lu lv b">cs</code>数组。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mg"><img src="../Images/4c61f98581db0f46cc7aef83feb1cd63.png" data-original-src="https://miro.medium.com/v2/format:webp/1*l4aHRVnDvW-VhsvOp7lVdA.png"/></div></figure><h1 id="d7e9" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">将棒堆叠在彼此之上</h1><p id="716b" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">在一个接一个的上面画条通常更令人困惑，而不是更有帮助。然而，我们可以将它们堆叠在一起，这意味着它们不会相互混淆。</p><pre class="kj kk kl km gt lw lv lx ly aw lz bi"><span id="a26b" class="ma mb it lv b gy mc md l me mf">stk = [1, 1, 1, 2, 2]<br/>fig = barplot(<br/>      [1, 2, 3, 2, 1], <br/>      ys,<br/>      color=cs,<br/>      stack=stk,<br/>)</span></pre><p id="6701" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的<code class="fe ls lt lu lv b">stk</code>数组指定了堆叠顺序。它是这样工作的:<code class="fe ls lt lu lv b">stk[i]</code>表示在位置<code class="fe ls lt lu lv b">xs[i]</code>应该放置什么样的命令栏<code class="fe ls lt lu lv b">i</code>。例如<code class="fe ls lt lu lv b">1</code>杆和<code class="fe ls lt lu lv b">5</code>杆在同一位置(<code class="fe ls lt lu lv b">xs[1] == xs[5]</code>)。哪一条应该画在底部，哪一条应该画在顶部？</p><p id="90d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为第五个(黄色)条将被绘制在顶部，第一个(紫色)条将被绘制在底部。我们对绿色和蓝色条进行类似的操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mg"><img src="../Images/14d06b3a8b1e13969ebeba5099783393.png" data-original-src="https://miro.medium.com/v2/format:webp/1*ca5TrPBPyTq1s3bRPTDtAA.png"/></div></figure><p id="d738" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些数字只是相对的，所以它们可能是任何东西。所以这会有完全相同的结果:</p><pre class="kj kk kl km gt lw lv lx ly aw lz bi"><span id="d1b4" class="ma mb it lv b gy mc md l me mf">stack = [10, 5, 1, 20, 40]</span></pre><p id="0da9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，我们在第三个(海绿色)条上设置了1。我们在这里放什么数字并不重要，因为它不与任何其他条形图堆叠在一起。</p><p id="e013" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Makie中采用面向对象的条形视图可能有助于概念化。想象一个酒吧的定义是:</p><pre class="kj kk kl km gt lw lv lx ly aw lz bi"><span id="be66" class="ma mb it lv b gy mc md l me mf">struct Bar<br/>   xpos::Int         # where on the x-axis<br/>   height::Number    # height along y-axis<br/>   order::Int        # Stacking order<br/>end</span></pre><p id="5bde" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">绘制条形时，绘图系统使用这些值来决定将其放置在何处以及多高。如果条形与另一个条形共享位置，我们指示绘图系统堆叠条形，那么<code class="fe ls lt lu lv b">order</code>帮助定义在相同x轴位置绘制的条形的相对堆叠顺序。</p><h1 id="e18a" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">同一位置的簇条(减淡)</h1><p id="d858" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">我们可以围绕相同的位置对它们进行分组或聚类，而不是绘制相互堆叠的条形图。这叫<em class="lr">躲闪</em>。把<code class="fe ls lt lu lv b">stack</code>换成<code class="fe ls lt lu lv b">dodge</code>就行了。</p><pre class="kj kk kl km gt lw lv lx ly aw lz bi"><span id="3b40" class="ma mb it lv b gy mc md l me mf">stk = [1, 1, 1, 2, 2]<br/>fig = barplot(<br/>      [1, 2, 3, 2, 1], <br/>      ys,<br/>      color=cs,<br/>      dodge=stk,<br/>)</span></pre><p id="9af7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个实验中，我注意到不同于叠加，数字的大小很重要。如果你使用更大的数字，你会得到更细的线条。在下面的图中，你可以看到紫色条和黄色条是如何并排放置的。</p><p id="d4d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">没有分组的海绿条，分开的距离更大。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mg"><img src="../Images/92d4af8127af5025cc6ac7d30168f550.png" data-original-src="https://miro.medium.com/v2/format:webp/1*B8ge11bUtwlxObETF3ahNQ.png"/></div></figure><h1 id="7089" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">配置条形图的外观</h1><p id="5a35" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">虽然这在官方文档中有所涉及，但获得一些关于如何修改条形图外观的提示还是很有用的。</p><h2 id="c65c" class="ma mb it bd mi nd ne dn mm nf ng dp mq ld nh ni ms lh nj nk mu ll nl nm mw nn bi translated">选择条形的颜色</h2><p id="cc08" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">这里的<code class="fe ls lt lu lv b">ColorSchemes</code>包非常有用。在他们的<a class="ae lq" href="https://juliagraphics.github.io/ColorSchemes.jl/stable/catalogue/" rel="noopener ugc nofollow" target="_blank">目录</a>中找到你喜欢的配色方案。</p><p id="324c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设您找到了<code class="fe ls lt lu lv b">Spectral_5</code>配色方案并喜欢使用该方案。然后，您以下列方式获取该方案中的颜色:</p><pre class="kj kk kl km gt lw lv lx ly aw lz bi"><span id="57c0" class="ma mb it lv b gy mc md l me mf">cs = ColorSchemes.Spectral_5.colors</span></pre><p id="1aae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ls lt lu lv b">cs</code>将是一个颜色数组。每种颜色都是一个类型为<code class="fe ls lt lu lv b">RGB{Float64}</code>的对象。它具有属性<code class="fe ls lt lu lv b">r</code>、<code class="fe ls lt lu lv b">g</code>和<code class="fe ls lt lu lv b">b</code>来表示0到1范围内的红色、绿色和蓝色值。</p><p id="0077" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您将这个颜色数组<code class="fe ls lt lu lv b">cs</code>传递给<code class="fe ls lt lu lv b">barplot</code>函数:</p><pre class="kj kk kl km gt lw lv lx ly aw lz bi"><span id="1c58" class="ma mb it lv b gy mc md l me mf">figure = barplot(xs, ys, color=cs)</span></pre><h2 id="1af5" class="ma mb it bd mi nd ne dn mm nf ng dp mq ld nh ni ms lh nj nk mu ll nl nm mw nn bi translated">配置轴的外观</h2><p id="88d2" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">x轴、y轴、下方带有数字的刻度线都是Makie中绘图的<code class="fe ls lt lu lv b">Axis</code>对象的一部分。你可以想象你的条被画在一个由<code class="fe ls lt lu lv b">Axis</code>对象定义的区域内。</p><p id="324d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们使用的例子中，Makie已经自动为你创建了一个<code class="fe ls lt lu lv b">Axis</code>对象。调用<code class="fe ls lt lu lv b">barplot</code>时，可以通过命名参数配置这个轴对象。然而，我发现单独创建这个对象并调用<code class="fe ls lt lu lv b">barplot!</code>更干净。与<code class="fe ls lt lu lv b">barplot</code>方法不同的是，<code class="fe ls lt lu lv b">barplot!</code>方法将图形绘制到您作为第一个参数提供的某个可视对象中。这通常是一个<code class="fe ls lt lu lv b">Axis</code>对象，但也可能是一个代表整个页面的<code class="fe ls lt lu lv b">Figure</code>对象。</p><p id="e38f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有什么区别？Makie可以制作一个内部有多个情节的图形。每个图都由一个<code class="fe ls lt lu lv b">Axis</code>对象表示。</p><p id="e79c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是使用<code class="fe ls lt lu lv b">Axis</code>对象调整绘图的x轴和y轴的范围。</p><pre class="kj kk kl km gt lw lv lx ly aw lz bi"><span id="0295" class="ma mb it lv b gy mc md l me mf"># Create figure to hold multiple plots with resolution 1024x768<br/>fig = Figure(resolution = (1024, 764))<br/><br/># At location (1,1) create an axis to contain a plot<br/>axis = Axis(fig[1, 1], limits=(0, 6, 0, 8))</span></pre><p id="1ded" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">数组访问在图形对象上有点滑稽。Makie认为这个图形是一个由多个图组成的大网格。您将每个轴对象放在这个网格中的某一行和列上。这里我们把它放在第1行第1列。由于我们不再创建任何轴对象，当我们绘制它时，该轴对象将填充整个图形:</p><pre class="kj kk kl km gt lw lv lx ly aw lz bi"><span id="f8bc" class="ma mb it lv b gy mc md l me mf">barplot!(axis, xs, ys, color=cs)<br/>display(fig)</span></pre><p id="15db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你认为这种方法对于一个简单的情节来说是乏味的，你可以用这种捷径表达完全相同的意思:</p><pre class="kj kk kl km gt lw lv lx ly aw lz bi"><span id="b917" class="ma mb it lv b gy mc md l me mf">fig = barplot(xs, ys, color=cs,<br/>          axis = (limits=(0, 6, 0, 8),)<br/>      )</span></pre><p id="d519" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ls lt lu lv b">axis</code>的参数是一组命名参数，通常会传递给<code class="fe ls lt lu lv b">Axis</code>构造函数。我们可以添加更多的参数。这里我们指定不希望x轴上有任何刻度线:</p><pre class="kj kk kl km gt lw lv lx ly aw lz bi"><span id="1bb3" class="ma mb it lv b gy mc md l me mf">fig = barplot(<br/>          xs,<br/>          ys,<br/>          color=cs,<br/>          <br/>          # Define the Axis object<br/>          axis = (limits=(0, 6, 0, 8), <br/>                  xticks=0:0),<br/>       )</span></pre><p id="560d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们显式地构造了一个<code class="fe ls lt lu lv b">Axis</code>对象，我们应该这样写:</p><pre class="kj kk kl km gt lw lv lx ly aw lz bi"><span id="f483" class="ma mb it lv b gy mc md l me mf">axis = Axis(fig[1, 1], limits=(0, 6, 0, 8), xticks=0:0)<br/>barplot!(axis, xs, ys, color=cs)<br/>display(fig)</span></pre><h1 id="0266" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">完整示例</h1><p id="abc6" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">我们可以把现有的知识放在一起，组成一个更复杂、也许更真实的柱状图示例。在这种情况下，我想灵活地绘制1900年不同国家的铁产量图。</p><p id="7a7a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着我们需要对我之前展示的简单情节进行一些改变:</p><ol class=""><li id="2ada" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp nt nu nv nw bi translated">每个条形都应该有一个文本标签，表明一个国家，而不仅仅是一个数字。我们使用<code class="fe ls lt lu lv b">xticks</code>到<code class="fe ls lt lu lv b">Axis</code>的参数来控制这一点。</li><li id="4617" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">使用<code class="fe ls lt lu lv b">Axis</code>对象的<code class="fe ls lt lu lv b">ylabel</code>参数指定沿y轴的单位。</li></ol><p id="0661" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个功能<code class="fe ls lt lu lv b">ironproduction</code>，可以让我选择一些我想要绘制铁矿产量的国家。</p><pre class="kj kk kl km gt lw lv lx ly aw lz bi"><span id="cd10" class="ma mb it lv b gy mc md l me mf"># Numbers given in million metric tons<br/>const ironprod = Dict(<br/>                "USA"=&gt; 28.0, <br/>                "Germany"=&gt;12.7, <br/>                "France"=&gt;5.5, <br/>                "UK"=&gt;14.2, <br/>                "Sweden"=&gt;2.6, <br/>                "Soviet"=&gt;6.0, <br/>                "Luxembourg"=&gt;6.1)<br/>                    <br/>function ironproduction(countries)<br/>    fig = Figure(resolution = (1024, 600), font = noto_sans)<br/><br/>    xs = 1:length(countries)<br/>    ys = [ironprod[country] for country in countries]<br/>    <br/>    axis = Axis(fig[1,1],<br/>                 xticks = (xs, countries),<br/>                 ylabel = "million metric tons",<br/>                 title = "Iron ore production (1900)")<br/>    <br/>    ylims!(axis, (0, 30))<br/><br/>    barplot!(axis, xs, ys, <br/>        color=xs,          # Colors picked from the color table for each bar<br/>        bar_labels=:y,     # Put value labels on top of each bar<br/>        width = 0.7        # Width of each of the bars in relation to xs values<br/>    )<br/>                              <br/>    return fig<br/>end</span></pre><p id="c5db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以调用这个函数来绘制一个图:</p><pre class="kj kk kl km gt lw lv lx ly aw lz bi"><span id="7154" class="ma mb it lv b gy mc md l me mf">fig = ironproduction(["Germany", "UK", "USA"])<br/>display(fig)</span></pre><p id="9765" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以注意到这里的一些差异。我们使用<code class="fe ls lt lu lv b">ylims!</code>函数在<code class="fe ls lt lu lv b">axis</code>对象创建后修改它的限制，而不是用<code class="fe ls lt lu lv b">limits</code>参数指定它。让我们更仔细地看看这部分是如何工作的:</p><pre class="kj kk kl km gt lw lv lx ly aw lz bi"><span id="5e83" class="ma mb it lv b gy mc md l me mf">xticks = (xs, countries)</span></pre><p id="275d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它说对于x轴位置<code class="fe ls lt lu lv b">xs[i]</code>，我们应该使用<code class="fe ls lt lu lv b">countries[i]</code>中的文本标签。在这种情况下，如果有4个国家，<code class="fe ls lt lu lv b">xs</code>将只是一个范围<code class="fe ls lt lu lv b">1:4</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mg"><img src="../Images/fb275ebd2124acf87a3ab27cb83503ad.png" data-original-src="https://miro.medium.com/v2/format:webp/1*zGJFAt2DQiQOX0iWxZ6d0A.png"/></div></figure><h1 id="93d5" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">关于策划的相关故事</h1><p id="d7b8" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">之前的故事讨论了Julia中的绘图术语和其他绘图框架。我过去使用Plots.jl，但我认为Julia plotting的未来是Makie。</p><ul class=""><li id="4d29" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp oc nu nv nw bi translated"><a class="ae lq" href="https://erik-engheim.medium.com/plotting-and-graph-terminology-f2b26cb72b77" rel="noopener">绘图和图形术语</a> —什么是数列、数据源和轴？</li><li id="94c0" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp oc nu nv nw bi translated"><a class="ae lq" href="https://erik-engheim.medium.com/working-with-data-in-tables-for-machine-learning-6d7e1bb5bcd7" rel="noopener">使用表格中的数据进行机器学习</a> —数据帧的创建、下载和基本使用。</li><li id="3942" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp oc nu nv nw bi translated"><a class="ae lq" href="https://erik-engheim.medium.com/working-with-tables-in-excel-vs-julia-da674417dc86" rel="noopener">放弃Excel，使用Julia数据框</a> —使用Julia重新创建电子表格中使用的常见操作。加载数据，检查数据并分组。</li><li id="fd3b" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp oc nu nv nw bi translated"><a class="ae lq" href="https://erik-engheim.medium.com/slicing-and-dicing-pizza-data-with-julia-1c6f8b17e278" rel="noopener">用Julia和牛虻对披萨数据进行切片和切块</a> —通过摆弄披萨数据并绘制它来介绍Julia数据帧。</li><li id="d956" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp oc nu nv nw bi translated"><a class="ae lq" href="https://github.com/sswatson/cheatsheets/blob/master/plotsjl-cheatsheet.pdf" rel="noopener ugc nofollow" target="_blank"> Plots.jl参考卡</a> —常用Plots包中的功能概述。</li><li id="3e65" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp oc nu nv nw bi translated">使用Julia 分析世界数据，这是一个更现实、更先进的例子，可以观察GDP、失业、政府支出以及如何提取和绘制相关数据。</li></ul></div></div>    
</body>
</html>