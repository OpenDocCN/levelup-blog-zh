<html>
<head>
<title>Unity: Implementing Dark mode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Unity:实现黑暗模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/unity-implementing-dark-mode-9715ac8ac715?source=collection_archive---------6-----------------------#2020-04-09">https://levelup.gitconnected.com/unity-implementing-dark-mode-9715ac8ac715?source=collection_archive---------6-----------------------#2020-04-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/cc033f5a32e44a2d643c9f1669b73bcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ap0un3eTqJcH83kollQXSg.jpeg"/></div></div></figure><p id="b1f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">桌面上称之为黑暗模式，移动设备上称之为黑暗主题是当今的趋势。如果你想让你的游戏看起来更现代，让用户开心，拥有模式切换的可能性是一个必须具备的特性。在本教程中，我将向您展示如何添加黑暗模式的支持，相对较少的改变现有的图标和图像。</p><h1 id="4a83" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">先决条件</h1><p id="0644" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我在这里使用的是Unity 2019.3，但该解决方案也可以在任何其他版本中使用。我已经在我的一个游戏中实现了它——Zen Jigsaw——在那里找到它的实际应用。</p><p id="4241" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">和往常一样，GitHub上有源代码，链接在文章的末尾。</p><p id="4e31" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本教程在逻辑上分为两个部分:映像准备和实现。所描述的方法可能需要基本的图像编辑技能(我是一个Photoshop用户)。请教你的设计师或者在下面留言，有需求我会加一个Photoshop的部分！</p><p id="257f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最终结果将如下所示:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/c6eb1543f61a82b7a6cb9e5ab126370a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YiFt_U2pyr0gqR8Y"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">亮(左)和暗(右)模式</figcaption></figure><blockquote class="mm mn mo"><p id="4698" class="kb kc mp kd b ke kf kg kh ki kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ky im bi translated"><strong class="kd iu">注意！在设计深色主题时，我偶然发现了这篇<a class="ae mc" href="https://material.io/design/color/dark-theme.html#" rel="noopener ugc nofollow" target="_blank">的文章</a>，它提供了许多关于颜色、形状和意识形态的宝贵建议。正如上面所说，“推荐的深色主题表面颜色是#121212”。#121212是RGB模型中的颜色。我将把它称为深灰色。</strong></p></blockquote><h1 id="332d" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">第一部分。调整图像</h1><p id="1fbf" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">重要的是保持所有项目的资产在黑暗或光明的模式。不要把它们搞混了！这里值得一提的另一点是，由于游戏的极简设计，整个项目中只使用了两种颜色——深灰色和白色。然而，给定的解决方案，经过一些调整，适用于更广泛的颜色。</p><p id="06d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有3种不同的情况需要实施，我将一个一个地向您介绍。</p><ol class=""><li id="381e" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated">仅颜色不同的图标</li></ol><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/94435567a1d8b173b143750db95b4d4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KbC-n_COr8ZH1bye"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">每个图标都是一个单独的png文件，背景透明。</figcaption></figure><p id="c235" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可能想知道，为什么在上面的图片中图标的颜色是白色的，而在之前的最终结果屏幕上，在光线模式下，图标的颜色是黑色的。我不想在两种形式中复制所有的图标，并发现只有一个区别——颜色。因此，你可以默认所有的图标都是白色的，并在Unity中直接改变它们。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/e42ada0950d627120df5dff2fe86d45b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/0*_XDVzYZ_QW0rNzSi"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">使白色图标变成深灰色</figcaption></figure><p id="5750" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这当然只适用于单色图标。如果不是这样，那么下一点是一个解决方案。</p><p id="1b56" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2.在每种模式下有不同精灵的图像</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/7a9ea5a9217d476a3661983ea9dbc0f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BdgjSpOqpApmBqTG"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">我公司的徽标</figcaption></figure><p id="3c6a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种情况相对简单，您只需要拥有同一个图像的两个版本。考虑看看我以前的文章中关于如何减小最终apk/aab文件大小的提示。</p><p id="2b17" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">3.无论选择何种模式，图像都保持不变</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/8d172497813d81ef88a71a166441feda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*2sFh1QdaWNPayAan"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">直接取自禅宗七巧板！</figcaption></figure><p id="33ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它在本教程中没有特殊作用，只是一个不会改变的形象。</p><p id="32de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">至于场景设置，它是在光线模式下用一些图像和文本完成的，一切都来自标准的Unity UI包。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nf"><img src="../Images/1157a0e75916ed4395d6c6267ed1a15e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wWcDLLMgebX40P0y"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">场景设置</figcaption></figure><p id="db58" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，当场景和图像准备好了，我们可以继续前进，围绕它实现逻辑。</p><h1 id="9e6b" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">第二部分。解析模式</h1><p id="0bd3" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">如果你读过我以前的文章，你就会知道我是干净代码和关注点分离的忠实粉丝。本教程也不例外。先说这里最重要的脚本— <code class="fe ng nh ni nj b">UIModeResolver</code>。这个类将负责所有与UI模式解析相关的事情。正如上一部分所述，我们有3种不同的情况要实现。</p><p id="dc4d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，<code class="fe ng nh ni nj b">UIModeResolver</code>应该能够找到场景中所有的白色图标和文本，并根据选择的模式改变它们的颜色。</p><pre class="me mf mg mh gt nk nj nl nm aw nn bi"><span id="35c4" class="no la it nj b gy np nq l nr ns">public class UIModeResolver : MonoBehaviour<br/>{<br/>   private const float DarkGrey = 0.07f;<br/>   private readonly Color _darkGrey = new Color(DarkGrey, DarkGrey, DarkGrey, 1);</span><span id="d325" class="no la it nj b gy nt nq l nr ns">   public void ResolveMode()<br/>   {<br/>       foreach (var text in GetComponentsInChildren&lt;Text&gt;(true))<br/>       {<br/>           text.color = text.color == Color.white ? _darkGrey : Color.white;<br/>       }</span><span id="138b" class="no la it nj b gy nt nq l nr ns">       foreach (var image in GetComponentsInChildren&lt;Image&gt;(true))<br/>       {<br/>           image.color = image.color == Color.white ? _darkGrey : Color.white;<br/>       }<br/>   }<br/>}</span></pre><blockquote class="mm mn mo"><p id="b0bf" class="kb kc mp kd b ke kf kg kh ki kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ky im bi translated"><strong class="kd iu">注意！</strong>深灰色的颜色值是RGB 0–1.0格式。</p></blockquote><p id="cb80" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里的想法是决定如何改变一个元素的当前颜色，并把它变成相反的颜色。我们必须依赖颜色而不是布尔标志，因为场景中的资源在同一模式下可以是两种颜色。例如，如果你决定在浅色模式下文本为深灰色，图标为白色，那么在深色模式下文本为白色，图标为深灰色。</p><p id="c6f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我们使用了<code class="fe ng nh ni nj b">GetComponentsInChildren</code>方法，所以这个脚本应该附加到整个UI的父对象上— <code class="fe ng nh ni nj b">Canvas</code>。</p><p id="ef50" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于我们还没有从任何地方调用它，因此让我们创建另一个负责场景UI处理的脚本，并将其附加到Panel对象:</p><pre class="me mf mg mh gt nk nj nl nm aw nn bi"><span id="1568" class="no la it nj b gy np nq l nr ns">public class UIController : MonoBehaviour<br/>{<br/>   private UIModeResolver _modeResolver;<br/>  <br/>   private void Awake()<br/>   {<br/>       _modeResolver = FindObjectOfType&lt;UIModeResolver&gt;();<br/>   }</span><span id="f9e7" class="no la it nj b gy nt nq l nr ns">   public void ToggleUIMode()<br/>   {<br/>       _modeResolver.ResolveMode();<br/>   }<br/>}</span></pre><p id="ad08" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里缺少的最后一部分是调用按钮上的<code class="fe ng nh ni nj b">ToggleUIMode</code>方法:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/2f2c0e036828589488db896d78f37a89.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/0*0JlYltfzJcCBvJsl"/></div></figure><p id="237b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在开始游戏，按下<code class="fe ng nh ni nj b">UIMode</code>按钮，你会看到:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/fd4c8d09ff77f332bbaef4984260438e.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/0*MlsXSqKvjxgzceCT"/></div></figure><p id="cddf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">图标和文字与黑暗模式完美对齐！</p><p id="a98d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们实现第二种情况，其中一个图像根据模式有不同的精灵。</p><pre class="me mf mg mh gt nk nj nl nm aw nn bi"><span id="c71e" class="no la it nj b gy np nq l nr ns">public class UIModeElement : MonoBehaviour<br/>{<br/>   public Sprite LightModeSprite;<br/>   public Sprite DarkModeSprite;</span><span id="4eb2" class="no la it nj b gy nt nq l nr ns">   public void ResolveImage()<br/>   {<br/>       GetComponent&lt;Image&gt;().sprite = PrefsHolder.IsDarkMode() ? DarkModeSprite : LightModeSprite;<br/>   }<br/>}</span></pre><p id="85bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个非常小的脚本，但在整个架构中起着至关重要的作用！主要是因为它封装了模式解析逻辑，并将其缩小到只有两个精灵。</p><p id="b399" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有一个<code class="fe ng nh ni nj b">PrefsHolder</code>类，你可能在我之前的教程里见过。这是一个简单的静态实用程序类，基本上是Unity的<code class="fe ng nh ni nj b">PlayerPrefs</code>的包装器，负责存储是否选择了黑暗模式并返回其布尔值:</p><pre class="me mf mg mh gt nk nj nl nm aw nn bi"><span id="9089" class="no la it nj b gy np nq l nr ns">public static class PrefsHolder<br/>{<br/>   private const string DarkMode = "DarkMode";</span><span id="25b0" class="no la it nj b gy nt nq l nr ns">   public static void SaveDarkMode(bool on)<br/>   {<br/>       PlayerPrefs.SetInt(DarkMode, on ? 1 : 0);<br/>   }</span><span id="2257" class="no la it nj b gy nt nq l nr ns">   public static bool IsDarkMode()<br/>   {<br/>       return PlayerPrefs.GetInt(DarkMode, 0) == 1;<br/>   }<br/>}</span></pre><p id="15b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在大型项目中，拥有这样的包装器而不是分散的属性是非常方便的。</p><p id="9a73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回到<code class="fe ng nh ni nj b">UIModeElement</code>——让我们把它附加到<code class="fe ng nh ni nj b">Logo</code>图像上，并相应地选择精灵。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/a5e78fd879a98583698fc0351dab3d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/0*2bKM2RQbOsjiNW2_"/></div></figure><p id="970a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后一步是将其连接到<code class="fe ng nh ni nj b">UIModeResolver</code>中，只需对<code class="fe ng nh ni nj b">ResolveMode</code>方法中的图像处理循环进行一次更改:</p><pre class="me mf mg mh gt nk nj nl nm aw nn bi"><span id="6767" class="no la it nj b gy np nq l nr ns">public void ResolveMode()<br/>{<br/>   ...<br/>   foreach (var image in GetComponentsInChildren&lt;Image&gt;(true))<br/>   {<br/>       var uiModeElement = image.GetComponent&lt;UIModeElement&gt;();<br/>       if (uiModeElement)<br/>       {<br/>           uiModeElement.ResolveImage();<br/>       }<br/>       else<br/>       {<br/>           image.color = image.color == Color.white ? _darkGrey : Color.white;<br/>       }<br/>   }<br/>}</span></pre><p id="2b39" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在切换回Unity之前，我建议我们先来看看第三种情况，精灵不需要在不同的模式下改变。这里的解决方案非常简单，只需做一点小小的修改，就可以重用<code class="fe ng nh ni nj b">UIModeElement</code>:</p><pre class="me mf mg mh gt nk nj nl nm aw nn bi"><span id="d9a7" class="no la it nj b gy np nq l nr ns">public void ResolveImage()<br/>{<br/>   if (LightModeSprite)<br/>   {<br/>       GetComponent&lt;Image&gt;().sprite = PrefsHolder.IsDarkMode() ? DarkModeSprite : LightModeSprite;<br/>   }<br/>}</span></pre><p id="047a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你注意到if语句了吗？这正是我们所需要的！这里的想法是，如果没有指定精灵，什么都不应该改变。让我们把它附加到<code class="fe ng nh ni nj b">Puzzle</code>图片上</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/7e91c4ee3b0bfb9d941f5685d57b91de.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/0*4JEWsbLWnR5f4DTz"/></div></figure><p id="7ddf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">是时候看看一切是否如预期的那样运转了。现在开始游戏，按下<code class="fe ng nh ni nj b">UIMode</code>按钮在模式间切换:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/41e7b6f952c4b931b4020a71ec902db1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_Is_CczH-C1Tq9SI"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">接近最终结果</figcaption></figure><h1 id="d79f" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak">第三部分。保存状态</strong></h1><p id="71e4" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">正如你在上面的屏幕上看到的,<code class="fe ng nh ni nj b">UIMode</code>按钮精灵在两种模式下是一样的，这显然是不正确的。此外，选择的状态仍然没有持续，因此，如果玩家选择黑暗模式并重新开始游戏，他将看到光模式。让我们修复这两个缺陷吧！</p><p id="11a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将从每个模式一个合适的按钮图标图像开始。在当前的实现中,<code class="fe ng nh ni nj b">UIController</code>脚本是这种功能的完美位置，因为它已经负责切换模式。</p><pre class="me mf mg mh gt nk nj nl nm aw nn bi"><span id="b046" class="no la it nj b gy np nq l nr ns">public class UIController : MonoBehaviour<br/>{<br/>   public Sprite[] UIModeImages;<br/>  <br/>   private UIModeResolver _modeResolver;<br/>   private Button _uiMode;<br/>  <br/>   private void Awake()<br/>   {<br/>       _modeResolver = FindObjectOfType&lt;UIModeResolver&gt;();<br/>       _uiMode = GetComponentInChildren&lt;Button&gt;();<br/>       _uiMode.image.sprite = UIModeImages[PrefsHolder.IsDarkMode() ? 0 : 1];<br/>   }</span><span id="217b" class="no la it nj b gy nt nq l nr ns">   public void ToggleUIMode()<br/>   {<br/>       var state = !PrefsHolder.IsDarkMode();<br/>       PrefsHolder.SaveDarkMode(state);<br/>       _uiMode.image.sprite = UIModeImages[state ? 0 : 1];<br/>       _modeResolver.ResolveMode();<br/>   }<br/>}</span></pre><p id="9d04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里的三个变化是:</p><ul class=""><li id="f8c3" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky nx mz na nb bi translated">增加了一个两种模式都有按钮精灵的公共字段</li></ul><figure class="me mf mg mh gt ju gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/48471bf39d5058bde9a5fb7ed4bdc646.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/0*mXsZcbN1lC6SD0ZF"/></div></figure><ul class=""><li id="a8a6" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky nx mz na nb bi translated">在<code class="fe ng nh ni nj b">Awake</code>上，根据之前选择的模式解析出正确的按钮图标</li><li id="7a76" class="mt mu it kd b ke nz ki oa km ob kq oc ku od ky nx mz na nb bi translated">在<code class="fe ng nh ni nj b">ToggleUIMode</code>方法中，选择的模式被保存，图标子画面相应改变</li></ul><p id="db33" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">剩下的最后一步是解决黑暗模式，如果它以前被选中，并设置所有的精灵。因为我们已经在光照模式下设计了场景(和整个游戏),所以只有当保存模式是黑暗模式时才需要它。这一改变将存在于<code class="fe ng nh ni nj b">UIModeResolver</code>脚本中。</p><pre class="me mf mg mh gt nk nj nl nm aw nn bi"><span id="dbc3" class="no la it nj b gy np nq l nr ns">public class UIModeResolver : MonoBehaviour<br/>{<br/>   ...<br/>   private void Awake()<br/>   {<br/>       ResolveDarkMode();<br/>   }</span><span id="c660" class="no la it nj b gy nt nq l nr ns">   private void ResolveDarkMode()<br/>   {<br/>       if (!PrefsHolder.IsDarkMode()) return;</span><span id="4da5" class="no la it nj b gy nt nq l nr ns">       ResolveMode();<br/>   }<br/>   ...<br/>}</span></pre><p id="699b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">看起来很简单，在<code class="fe ng nh ni nj b">Awake</code>上，我们正在检查保存的模式，如果需要，调用之前创建的<code class="fe ng nh ni nj b">ResolveMode</code>方法。</p><h1 id="e91a" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">然后</h1><p id="bd3d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">完成教程做得很好！如果你有任何问题，请在下面的评论区留言。</p><p id="ee20" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">项目源文件可以在<a class="ae mc" href="https://github.com/Enigo/UnityDarkMode" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>中找到。</p><p id="3b2b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我提到的游戏在这里可以买到<a class="ae mc" href="https://play.google.com/store/apps/details?id=pro.pudding.zen" rel="noopener ugc nofollow" target="_blank">禅宗七巧板</a>。</p><h1 id="d16f" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">支持</h1><p id="884d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">如果你喜欢你看的内容，想支持作者——非常感谢！<br/>这里是我的以太坊钱包给小费:<br/><strong class="kd iu">0x b 34 C2 BCE 674104 a7 ca 1 ecebf 76d 21 Fe 1099132 f 0</strong></p></div></div>    
</body>
</html>