<html>
<head>
<title>Crazier Cubes: a simple, performance-optimized scene using Unity DOTS.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更疯狂的立方体:一个使用Unity DOTS的简单的、性能优化的场景。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/crazier-cubes-a-simple-performance-optimized-scene-using-unity-dots-abdcf6e7c5a3?source=collection_archive---------19-----------------------#2022-11-08">https://levelup.gitconnected.com/crazier-cubes-a-simple-performance-optimized-scene-using-unity-dots-abdcf6e7c5a3?source=collection_archive---------19-----------------------#2022-11-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6bed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何轻松创建具有数千个立方体的场景，同时不断修改它们的位置、旋转和缩放属性，并保持高水平的性能。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/defb88061988ac5f0bf0d1a6000b0f13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5cNOFuaZZfsb7PwUvKh2NA.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">雷纳托·拉莫斯·普马在<a class="ae lb" href="https://unsplash.com/photos/hBaPqlwNarc" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="8d17" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">介绍</h1><p id="800c" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">之前，我们展示了Unity ECS实施的基本技术方面，以及它可以为我们的项目带来的性能改进。现在，我们将为每个立方体创建更复杂的运动模式，更深入地挖掘编码细节，应用简单的性能优化技术并展示其结果。</p><h1 id="7305" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">规范</h1><p id="1a59" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">本文使用的硬件是2016年的笔记本电脑，16 GB RAM，英伟达GTX 960M显卡，四核2.6 GHz处理器；Unity编辑器版本为2019.4.23f1。</p><h1 id="df3c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">我们的目标</h1><p id="6bb2" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在这个项目中，复杂性应该尽可能低，无论是代码大小还是游戏对象层次结构。只有一个主摄像头的空场景就可以了。我们也不需要任何“产卵者”游戏对象，因为所有的实体都将从系统内部动态产生。几千个随机大小的立方体将被注入到场景中，系统将同时随机激活每个立方体的平移、旋转和缩放属性。</p><h1 id="0bd6" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">组件</h1><p id="3cfb" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们需要一组分量来表示三个基本运动矢量；平移、旋转和缩放。这些组件中的每一个都支持在下一次作业迭代中保持自己的状态。定标器和转换器组件也支持主值的允许范围的边界。使用GenerateAuthoringComponent属性，不需要提供单独的IConvertGameObjectToEntity实现；Unity会自动为每个实体生成适当的组件数据。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">代码片段1: TRS组件实现</figcaption></figure><h1 id="adad" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">立方体预制件和材料</h1><p id="293b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们还需要一个标准的预制品和一个简单的材质，这样我们就可以批量生成立方体实体，并在渲染过程中获得更大的性能增益。这里没有惊喜；该材质只是一个单色不透明选择，在标准着色器下运行。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/6dd6058f0342c114ed7e20fc39fca628.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*CJJzunThDimxEbUWKE7ALg.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图1:立方体预制和材料配置</figcaption></figure><h1 id="47ad" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">动画核心</h1><p id="6b9a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">与典型的游戏对象相反，Unity ECS中的实体默认不包含转换组件；相反，它们可以附加一个LocalToWorld组件(参见参考文献[4]和[5])。LocalToWorld组件(float4x4类型的4x4矩阵)的值用于计算其所属实体的精确定位、旋转和缩放，以便可以在我们的场景中直观地呈现该实体。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mi"><img src="../Images/74701d20b1f28078daaaf43f2089a7fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pCSKBr6fxm0kJVcd_qiK0A.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图2:场景中渲染的选定实体的LocalToWorld组件</figcaption></figure><p id="03ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在场景中生成立方体后，我们的目标是随机并不断地修改每个立方体的LocalToWorld。重视我们预定工作中的数据，以创造高性能的“更疯狂的立方体”效果。</p><h1 id="a483" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">系统和工作</h1><p id="fc7f" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们的系统实现是直接从Unity.Entities.SystemBase中派生出来的。LocalToWorld(内部)、缩放器、旋转器和转换器。这意味着我们可以在访问它们之前轻松地过滤掉它们。在OnCreate()方法中构造一个标准的EntityQuery并应用到我们的作业中就足够了。</p><p id="8683" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，在相同的方法中，我们通过根据预设的名称解析/Resources项目文件夹的内容来解析立方体预设。这样，我们甚至不需要为预置本身添加一个明确的编辑器引用。细节可以在图片1和片段2中看到。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">代码片段2:动态解析立方体预置并从中衍生实体。</figcaption></figure><p id="cafb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样需要注意的是，为了让效果正常工作，我们将同时修改每个渲染立方体实例的平移、旋转和缩放(TRS)值。在每次调用IJobChunk时。Execute()方法实现，我们分别计算新的平移、旋转和缩放值，使用它们来获得新的TRS变换矩阵，然后将该矩阵赋给LocalToWorld组件的Value成员。然后，新的TRS值存储在组件实例中，以便在下一次IJobChunk迭代中使用。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">代码片段3:用于创建“更疯狂的立方体”效果的工作的核心功能。</figcaption></figure><p id="720f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与前一篇文章(见参考文献[1])相比，在编辑器中没有发生混淆的“拖放”操作来将立方体预设连接到IConvertGameObjectToEntity类，没有“spawner”空游戏对象被添加到场景中，并且只有两个代码文件被用于实现ECS模式；一个用于组件，一个用于系统。这使得整个项目设置更简单，也更容易记忆。</p><p id="1913" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="https://github.com/mkoutroumpas/UEduFour" rel="noopener ugc nofollow" target="_blank">的完整源代码</a>可以在参考文献【2】中找到。</p><h1 id="f85a" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">简单优化</h1><p id="5e0a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">事实上，我们在上一步中创建的自定义材质将用于所有衍生的实体，这有助于在游戏过程中显著提高性能。仅在材质上启用GPU实例化，就足以批量处理数千个绘制调用，并且对于1480 x 680像素的视口大小，指定笔记本电脑上的帧速率几乎翻倍。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mj"><img src="../Images/36e15316421fba750fbef557eff268eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7efNgJHk_lRp_o8ARj0FKA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图3:通过在自定义材质上启用GPU实例化来提高渲染性能</figcaption></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk mg l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">视频1:游戏过程中主摄像头拍摄的演示场景</figcaption></figure><h1 id="2e45" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="f5f5" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">Unity的DOTS是一个强大的工具，当我们的场景包含数千个同时渲染的相似实体时，它会变得非常有用。尽管如此，它并不复杂或难以学习，所以这个演示项目旨在为更大规模和更复杂的Unity DOTS实现提供一个快速简单的“手册”。</p><h1 id="f8a7" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">参考</h1><ol class=""><li id="b8c1" class="ml mm iq jp b jq ma ju mb jy mn kc mo kg mp kk mq mr ms mt bi translated">【Unity ECS的简单入门指南</li><li id="d1e0" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated"><a class="ae lb" href="https://github.com/mkoutroumpas/UEduFour" rel="noopener ugc nofollow" target="_blank">项目源代码</a></li><li id="9af1" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated"><a class="ae lb" href="https://docs.unity3d.com/Packages/com.unity.entities@0.11/manual/index.html" rel="noopener ugc nofollow" target="_blank"> Unity实体v. 0.11.2规范</a></li><li id="414a" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated"><a class="ae lb" href="https://docs.unity3d.com/Packages/com.unity.entities@0.11/manual/transform_system.html" rel="noopener ugc nofollow" target="_blank"> Unity Entities v. 0.11.2转换系统规范</a></li><li id="9f87" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated"><a class="ae lb" href="https://youtu.be/NGLVVI2HAo4" rel="noopener ugc nofollow" target="_blank">揭开Unity ECS中转换的神秘面纱</a></li><li id="fb27" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated"><a class="ae lb" href="https://docs.unity3d.com/2019.4/Documentation/Manual/GPUInstancing.html" rel="noopener ugc nofollow" target="_blank"> Unity GPU实例化手册</a></li></ol></div></div>    
</body>
</html>