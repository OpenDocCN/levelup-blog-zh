# 10 个简便的春季批处理技巧

> 原文：<https://levelup.gitconnected.com/10-handy-spring-batch-tricks-24556cf549a4>

## 来解决现实生活中的问题

![](img/9dffe461544ebf1fbe613e6a92f42ab2.png)

批处理作业并不特别令人兴奋，但它们在各种应用中仍然非常普遍，从计算每月账单到重新训练机器学习模型。如果您在 Java/Spring 生态系统中操作，Spring Batch 是一个显而易见的选择，它是一个成熟的库，具有过多的功能和预构建的适配器。

Spring Batch 的创建者显然已经考虑到了在创建批处理作业时试图解决的许多问题，并且已经找到了解决这些问题的方法。不幸的是，Spring Batch 不太容易学习和使用，并且默认行为和文档经常无法解决一些相当常见的现实生活中的行为。

这篇文章是为已经接触过 Spring Batch 的人写的。它将演示如何避开一些 Spring 批处理陷阱，以及如何解决一些相当常见的实际问题。

查阅以下目录，找到您感兴趣的问题:

# 目录

[1。阻止作业在启动时运行](#73aa)
[2。初始化春季批处理模式](#c8fc)
[3。写一个没有读者或作者的作业](#b35f)
[4。将运行时参数传递给作业](#91d6)
[5。使作业重新运行](#9bf2)
[6。读取文件时跳过不需要的字段](#f81d)
[7。地图自定义数据类型](#89df)
[8。跳过错误实例而不使作业](#2773)
[9 失败。处理器](#c0a6)
[10 中的跳过与过滤。如何汇总项目处理器的结果](#029b)

# 1.阻止作业在启动时运行

当您启动 Spring Boot 应用程序时，您可能会惊讶地发现配置中的所有 Spring 批处理作业都会立即开始运行。这很少是想要的行为。大多数情况下，您会希望按需或根据某种计划启动作业。您可以通过在 *application.properties* 中设置一个配置参数来禁用此默认行为:

```
*#Do not auto start spring batch jobs
spring.batch.job.enabled=false*
```

# 2.初始化 Spring 批处理模式

Spring Batch 将其状态存储在关系数据库的表中。假设您已经用一个关系数据库配置了 Spring Boot，您可以很容易地让 Spring Batch 用一个属性创建这些表:

```
*#Initialize schema
spring.batch.initialize-schema=always*
```

如果您更愿意自己生成模式，您可以从这里的[复制表定义，并将它们放入一个 flyway 脚本或类似的脚本中。](https://docs.spring.io/spring-batch/docs/3.0.x/reference/html/metaDataSchema.html)

# 3.在没有读者或作者的情况下编写作业

标准的 Spring 批处理作业由一系列步骤组成。每个步骤由一个阅读器、一个可选的处理器和一个写入器组成。经常需要编写一个作业或一个步骤来执行一些逻辑，但不需要读取或写入任何数据。在这些情况下，您可以使用一个**小任务**:

执行小任务的步骤是这样配置的:

# 4.将运行时参数传递给作业

运行作业时，您可以像这样传递运行时参数:

但是作业如何知道如何处理这些参数呢？

有几种方法可以在作业定义中注入参数。

对于微线程，可以直接从 JobExecution 中检索参数，访问方式如下:

要在 bean 定义中注入运行时参数，如读取器、处理器或写入器，可以使用“@Value”注释，如下所示:

**重要提示**:您*必须*使用“@StepScope”，以指示 bean 应该为每个新步骤重新创建。否则，bean 将是一个全局单例，并且将不能看到参数。

# 5.使作业可重新运行

默认情况下，Spring Batch 不会两次执行相同的作业。spring batch 认为“相同的作业”是具有相同参数的相同作业 bean。因此，举例来说，如果我尝试使用不同的文件名运行上面示例中的 *executeScriptJob* ，它将工作，但是如果我尝试使用相同的文件名重新运行它，它将抛出一个*JobInstanceAlreadyCompleteException*。

要使作业真正可重新运行，您必须传递一个因作业而异的运行时参数。例如，这可以通过传递当前时间戳来实现:

# 6.读取文件时跳过不需要的字段

Spring Batch 为构建平面文件读取器提供了一个灵活但相当冗长的框架。下面是设置标准阅读器以将 CSV 映射到 Java beans 的概述:

本例的输入文件如下所示:

我只对“金额”字段感兴趣，不想映射“trans_id”和“operation”。有几种方法可以排除不需要的字段。这里的方法是放置一个在这些 beans 中确实存在的属性，即“X”:

```
{"X", "transactionId", "accountId", "date", "type", "X", "amount"};
```

要做到这一点，要求 FieldSetMapper 不严格是很重要的，这样它就不会因为不存在的属性而失败:

```
//Do not complain if properties don't exist    fieldSetMapper.setStrict(false);
```

# 7.映射自定义数据类型

将平面文件映射到 beans 时，通常需要将字符串转换为自定义数据类型。Spring Batch 提供了几种不同的方法来实现这一点。也许最直接的方法是在 FieldSetMapper 中使用一个**属性编辑器**。请注意，在上面的示例中，我包含了以下行:

```
fieldSetMapper.setCustomEditors(getCustomEditors());
```

在本例中，我想将一个字段映射到一个 LocalDate。下面是实现过程:

# 8.跳过错误实例而不使作业失败

在接收文件时，您希望数据采用特定的格式，但是您不能保证一定会是这样。某些行的格式可能不正确或包含无效信息。发生异常时，Spring Batch 的默认行为是重试处理块几次，如果所有尝试都失败，整个作业就会失败。更糟糕的是，失败前处理的任何批处理都已提交，因此作业只是部分完成。

对于这些类型的错误，重试不会成功，并且作业失败很少是我们想要的行为。我们需要的是跳过包含错误的行，以某种方式报告问题，并继续处理剩余的记录。

为了配置处理过程中遇到异常时的行为，我们将一个步骤定义为**容错**，如下所示:

上面的 skip()指令指出了异常，如果发生异常，它们应该导致记录被跳过，而不是过程失败。在本例中，我们从一个平面文件中读取，任何未能正确解析和映射的记录都将导致 FlatFileParseException。如果我们想要更好地控制跳过哪些异常，我们可以指定一个 [SkipPolicy](https://docs.spring.io/spring-batch/docs/current/api/org/springframework/batch/core/step/skip/SkipPolicy.html) 来代替。

skipLimit 指定在实际引发错误之前可以跳过多少记录。这背后的基本原理是，如果出现太多异常，那么整个文件可能有问题。

最后，我们需要一种方法来捕获发生的错误并以某种方式报告它们。这就是 skip listener 的作用。这里简单的 SkipListener 只记录错误:

# 9.处理器中的跳过与过滤

如果一条记录通过了阅读器，它仍然会在处理器中遇到问题。处理器中的意外异常也会导致进程提前终止，因此对此加以防范非常重要。

处理器中的异常可以像在读取器中一样被跳过，方法是显式地列出它们或者将它们包含在跳过策略中。以这种方式引发的任何异常都将通知 SkipListener，后者将广播该问题。

还有一种方法可以在不发出警报的情况下丢弃流程中的记录。这被称为**过滤**，它通过简单地为不需要的实例返回 null 来完成。跳过和过滤在语义上的区别在于，前者指的是输入数据中的错误，应该报告，而后者只是因为遇到了我们不感兴趣处理的记录。如果我们从允许条件查询的数据存储中读取，我们可以很容易地将这些实例作为查询的一部分删除，但是当我们从文件、流或键/值存储中读取时，我们无法控制我们得到什么，所以我们需要作为处理的一部分进行过滤。

在上面的示例中，我们希望过滤掉来自波士顿银行(或 BOB)的任何交易，但是如果我们收到一个金额为负的交易，我们希望引发一个错误。

# 10.如何汇总项目处理者的结果

不可否认，这最后一个技巧是一个小技巧，我用它来说明记录过滤的创造性使用。Spring Batch 是一个数据转换工具，不太适合计算复杂的聚合，这最好留给数据库或 map/reduce 框架。

尽管如此，如果您决定将汇总项目处理器的结果作为工作的一部分，这里有一个方法:

1.  确保读取器按照应该处理的顺序提供数据。
2.  编写一个维护状态的项处理器，以便它知道到目前为止已经处理了什么。
3.  当聚合不完整时，继续返回 null。这将导致结果被跳过，不发送到编写器。
4.  当聚合完成时，发送结果。

在下面的例子中，我使用这个方法将单个交易汇总成每月的现金流。

monthlyGroup 列表用于收集同一个月内的所有交易。lastDate 用于跟踪月份。只要月份不变，我们就一直收集列表中的交易并返回 null，从而导致结果被无声地过滤掉。只有当月份发生变化时，我们才汇总交易并输出整月的单个记录。

# 结论

在本文中，我演示了如何使用 Spring Batch 解决一些实际的数据转换问题。这里展示的例子，以及其他现实问题的解决方案，可以在这个 [GitHub 库](https://github.com/algorythmist/fluid-spring-batch/tree/main/advanced-spring-batch)中找到。