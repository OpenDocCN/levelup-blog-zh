<html>
<head>
<title>Flutter Bloc v8.0 is Here and Will Change the Way You Handle State Forever</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter Bloc v8.0已经发布，它将永远改变你处理状态的方式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/flutter-bloc-v8-0-is-here-and-will-change-the-way-you-handle-state-forever-72ddb4da9e1d?source=collection_archive---------0-----------------------#2021-09-03">https://levelup.gitconnected.com/flutter-bloc-v8-0-is-here-and-will-change-the-way-you-handle-state-forever-72ddb4da9e1d?source=collection_archive---------0-----------------------#2021-09-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1f546d2b2dfd53551828a516e9b2b6f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PEJc3_TxuhksYMvgRInjkA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">新集团</figcaption></figure><p id="4094" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="ld">如果您想直接阅读变更，</em> <a class="ae le" href="https://github.com/felangel/bloc/issues/2526" rel="noopener ugc nofollow" target="_blank"> <em class="ld">这里是迁移的链接。</em>T11】</a></p><p id="ecfc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">自从Flutter进入移动开发领域以来，它的状态管理一直是一个热门话题。应用程序是基于状态构建的，不使用状态管理解决方案很难扩展，也很难测试。</p><p id="5157" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Flutter Bloc是第一个获得支持的状态管理解决方案(提供商也在其中，这是值得称赞的)——但像所有MVP一样，1.0版本有点粗糙。经过7个版本，Bloc变得越来越好，直到它成为状态管理解决方案的精彩生态系统:功能丰富，易于测试，促进可伸缩的架构。</p><p id="1729" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是，唉，Flutter Bloc的最大问题似乎是无法解决的食物问题:<em class="ld">有一大堆锅炉板。</em></p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="03ef" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Cubit是第一个修复:完全移除事件——现在，你可以调用cubit上的一个方法，比如<code class="fe lm ln lo lp b">cubit.method</code>,而不是调用<code class="fe lm ln lo lp b">Bloc.add(Event)</code>,允许我们完全放弃事件，将样板文件减少三分之一。</p><p id="4cd7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然而，Cubit并不是一个完美的解决方案:事件仍然非常有用，并且允许扩展或监控。在我的应用程序中，90%的时间我使用cubits另外10%的时间我需要功能更丰富的东西。</p><p id="8349" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">下面是一个不能使用cubit(pseudocode)的例子:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="e3ce" class="ly lz it lp b gy ma mb l mc md">class FooState extends State&lt;Foo&gt; {<br/>   final ScrollController _scrollController = ScrollController();</span><span id="4849" class="ly lz it lp b gy me mb l mc md">   initState() {<br/>      super.initState();<br/>      _scrollController.addListener(_infiniteScroll);<br/>    }</span><span id="a240" class="ly lz it lp b gy me mb l mc md">    void _infiniteScroll() {<br/>       if (_scrollController.atBottom()) {<br/>          cubit.fetchMorePosts();<br/>       }<br/>   }<br/>}</span></pre><p id="27e9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们遇到了真正的问题。如果用户过度滚动，(这几乎每次都会发生)滚动控制器会说它在底部…一遍又一遍，一遍又一遍。根据滚动距离的不同，你可能会给<code class="fe lm ln lo lp b">fetchMorePosts</code>打100多次电话！这不是我们想要的；就打一次然后等着。</p><p id="ceb7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您可以潜在地向腕关节添加状态，比如:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="d5fb" class="ly lz it lp b gy ma mb l mc md">class MyCubit extends Cubit&lt;PostState&gt; {<br/>   bool isFetching = false;</span><span id="f93b" class="ly lz it lp b gy me mb l mc md">   Future&lt;void&gt; fetchMorePosts() {<br/>      if (isFetching) return;<br/>      isFetching = true;<br/>      final newPosts = await _fetch();<br/>      isFetching = false;<br/>      emit(PostState(newPosts));<br/>   }<br/>}</span></pre><p id="b1c5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是这导致更多的代码维护和大量的调试。一个更简单的处理方法？使用带有<code class="fe lm ln lo lp b">transformEvents.</code>的块</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="cad1" class="ly lz it lp b gy ma mb l mc md">@override<br/>Stream&lt;FetchEvent&gt; transform(Stream&lt;FetchEvent&gt; events) {<br/>  return (events as Observable&lt;FetchEvent&gt;)<br/>      .debounce(Duration(milliseconds: 500));<br/>}</span></pre><p id="a314" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Boom —解决了过卷问题。</p><p id="b828" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Bloc还允许我们保持更高水平的可观察性，即能够观察输入事件，而不仅仅是输出状态。</p><h2 id="ccaf" class="ly lz it bd mf mg mh dn mi mj mk dp ml kq mm mn mo ku mp mq mr ky ms mt mu mv bi translated">输入v8</h2><p id="65b7" class="pw-post-body-paragraph kf kg it kh b ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky na la lb lc im bi translated">好的，很明显Bloc仍然有用，我们不应该完全放弃Cubit。事件对于可观察性很有用，并且有很好的用例。</p><p id="bc59" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们应该尽可能地限制样板文件，但是从bloc的概念来看，bloc样板文件中有一部分没有被触及……直到v8。</p><p id="cced" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe lm ln lo lp b">mapEventToState</code>。</p><p id="c94e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe lm ln lo lp b">mapEventToState</code>在每个单个块中具有几乎完全相同的代码:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="b3a3" class="ly lz it lp b gy ma mb l mc md">@override<br/>Stream&lt;State&gt; mapEventToState(Event event) async* {<br/>  if (event is EventA) {<br/>    yield* _mapEventAToState(event);<br/>  } else if (event is EventB) {<br/>    yield* _mapEventBToState(event);<br/>  }<br/>}<br/><br/>Stream&lt;State&gt; _mapEventAToState(EventA event) async* {...}<br/>Stream&lt;State&gt; _mapEventBToState(EventB event) async* {...}</span></pre><p id="8d04" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您不熟悉bloc，<code class="fe lm ln lo lp b">mapEventToState</code>是一个接受输入事件并输出状态的函数！我得说它的名字很贴切。</p><p id="3cd2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">尽管命名很恰当，但是代码越多，出错的机会就越多，这里有很多地方会出错。众所周知，流是很难理解的概念，比async-await更难理解，并且需要编程技巧来优雅地处理。愚蠢的长<code class="fe lm ln lo lp b">if else if else if else</code>在许多事件中变得太难维持，并且很容易在杂草中丢失事件。</p><p id="7a66" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">修复？新的<code class="fe lm ln lo lp b">on&lt;Event&gt; </code>方法。</p><p id="ae29" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe lm ln lo lp b">on&lt;Event&gt;</code>阻塞方法只有一个必需的参数:一个带有签名的回调<code class="fe lm ln lo lp b">FutureOr&lt;void&gt; Function&lt;Event&gt;(Event, Emitter&lt;State&gt;) handler</code>。<code class="fe lm ln lo lp b">on&lt;Event&gt;</code>分解起来，采取的方法是:</p><ul class=""><li id="21a9" class="nb nc it kh b ki kj km kn kq nd ku ne ky nf lc ng nh ni nj bi translated">传递两个参数:输入事件和发射器。如果你用过<code class="fe lm ln lo lp b">cubit</code>，你可能对发射器很熟悉(如果没有，不用担心！很快就清楚了)。</li><li id="a476" class="nb nc it kh b ki nk km nl kq nm ku nn ky no lc ng nh ni nj bi translated">可以是异步或同步——没关系(这是<code class="fe lm ln lo lp b">FutureOr</code>部分！)</li></ul><p id="5e5a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">每个事件类型只能调用<code class="fe lm ln lo lp b">on&lt;Event&gt;</code>一次，否则它会抛出一个状态错误。最好在构造函数里做，然后就忘了。</p><p id="5184" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">目前，只要你使用版本`<code class="fe lm ln lo lp b">7.2.0-dev.1</code>，v8就可以向后兼容v7。下面是在<code class="fe lm ln lo lp b">pubspec.yaml</code>中的样子:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="bd1c" class="ly lz it lp b gy ma mb l mc md">bloc: ^7.2.0-dev.1</span></pre><p id="0251" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">注意:</strong>这是一个开发版本！虽然它在我的测试中相当稳定，但如果你运行的是生产应用，你可能希望等待迁移达到稳定，这样你就处于最没有错误的状态，以避免意外的行为。</p><h2 id="4100" class="ly lz it bd mf mg mh dn mi mj mk dp ml kq mm mn mo ku mp mq mr ky ms mt mu mv bi translated">运行中的v8</h2><p id="c595" class="pw-post-body-paragraph kf kg it kh b ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky na la lb lc im bi translated">下面是典型的反例:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="bbcb" class="ly lz it lp b gy ma mb l mc md">abstract class CounterEvent {}</span><span id="f98c" class="ly lz it lp b gy me mb l mc md">class Increment extends CounterEvent {}</span><span id="9780" class="ly lz it lp b gy me mb l mc md">class Decrement extends CounterEvent {}</span><span id="c26e" class="ly lz it lp b gy me mb l mc md">class SetCounter extends CounterEvent {<br/> final int setTo;</span><span id="6c71" class="ly lz it lp b gy me mb l mc md"> SetCounter({required this.setTo});<br/>}</span><span id="9625" class="ly lz it lp b gy me mb l mc md">class CounterBloc extends Bloc&lt;CounterEvent, int&gt; {<br/>CounterBloc() : super(0) {<br/>   on&lt;Increment&gt;((event, emit) =&gt; emit(state + 1));<br/>   on&lt;Decrement&gt;((event, emit) =&gt; emit(state - 1));<br/>   on&lt;SetCounter&gt;((event, emit) =&gt; emit(event.setTo));<br/> }<br/>}</span></pre><p id="d301" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">看不到<code class="fe lm ln lo lp b">mapEventToState</code>！构造函数设置了一组“监听器”，监听输入事件。当给定输入事件时，它调用回调。</p><p id="c9b2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">不过，碰巧我的计数器应用程序的客户端也想要一个“随机”特性。下面是他希望我构建的:用户可以指定一个范围，将从该范围中选择一个随机整数。他希望从他的微服务团队构建的随机整数API中获取整数，因此我们需要进行API调用。(傻管理——他们不知道<code class="fe lm ln lo lp b">dart:math</code>图书馆吗？)</p><p id="ee49" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">首先，我们需要定义一个状态:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="d3c4" class="ly lz it lp b gy ma mb l mc md">class Random extends CounterEvent {<br/>  final int from;<br/>  final int to;</span><span id="8d86" class="ly lz it lp b gy me mb l mc md">  Random({required this.from, required this.to});<br/>}</span></pre><p id="d0d3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">就这么简单。我们不会对显示层进行编码，但是用<code class="fe lm ln lo lp b">context.read&lt;CounterBloc&gt;().add(Random(from: 10, to: 30));</code>很容易调用。用<code class="fe lm ln lo lp b">context.watch&lt;CounterBloc&gt;().state</code>听状态也很容易。</p><p id="1d77" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">接下来，我们需要一个加载状态，因为我们希望用户知道我们正在生成一个数字。让我们写下一些状态:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="fd09" class="ly lz it lp b gy ma mb l mc md">abstract class CounterState {}</span><span id="8bf9" class="ly lz it lp b gy me mb l mc md">class CounterValue extends CounterState {<br/>  final int value;<br/>   <br/>  CounterValue(this.value);<br/>}</span><span id="1f43" class="ly lz it lp b gy me mb l mc md">class CounterLoading extends CounterState {}</span></pre><p id="2412" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">两个简单的状态；一个有我们的价值，一个正在加载。</p><p id="bf7a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，我们需要重写我们的块，如下所示:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="3a7f" class="ly lz it lp b gy ma mb l mc md">class CounterBloc extends Bloc&lt;CounterEvent, CounterState&gt; {<br/>  CounterBloc() : super(CounterValue(0)) {<br/>    on&lt;Increment&gt;((event, emit) =&gt; emit(state + 1));<br/>    on&lt;Decrement&gt;((event, emit) =&gt; emit(state - 1));<br/>    on&lt;SetCounter&gt;((event, emit) =&gt;     emit(CounterValue(event.setTo)));<br/>  }<br/>}</span></pre><p id="b452" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">啊哦，错误！让我们将increment和decrement重写到一个私有的helper函数中(就像您在<code class="fe lm ln lo lp b">mapEventToState</code>中所做的一样，但是这次我们不需要一个很长的if-else链来找到正确的事件):</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="cac3" class="ly lz it lp b gy ma mb l mc md">CounterBloc() : super(CounterValue(0)) {<br/>  on&lt;Increment&gt;((event, emit) =&gt; _addToValue(1, emit));<br/>  on&lt;Decrement&gt;((event, emit) =&gt; _addToValue(-1, emit));<br/>  on&lt;SetCounter&gt;((event, emit) =&gt; emit(CounterValue(event.setTo)));<br/> }</span><span id="b101" class="ly lz it lp b gy me mb l mc md">void _addToValue(int toAdd, Emitter&lt;CounterState&gt; emit) {<br/>  if (state is CounterValue) {<br/>   emit(CounterValue((state as CounterValue).value + toAdd));<br/>  }<br/>}</span></pre><p id="07ae" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果我们在装货，我们什么也不做。如果我们没有加载，我们执行所需的加法/减法！几乎没有样板文件。</p><p id="8a4c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">差不多完成了…让我们用随机方法:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="1334" class="ly lz it lp b gy ma mb l mc md">Future&lt;void&gt; _randomize(Random event, Emitter&lt;CounterState&gt; emit) async {<br/>  emit(CounterLoading());<br/>   <br/>  final int randomInt = await callApi(event.from, event.to);</span><span id="8c7f" class="ly lz it lp b gy me mb l mc md">  emit(CounterValue(randomInt));<br/>}</span></pre><p id="cc06" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是最好的状态管理:当API调用正在调用时，用户将看到一个加载状态。当调用完成时，用户将看到生成的随机整数。集团的魔力，现在在容易阅读的方法！</p><p id="7297" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后，让我们注册处理程序。谢天谢地，我们刚刚写的方法和<code class="fe lm ln lo lp b">on&lt;Event&gt;</code>函数有相同的签名，所以我们可以像这样注册它:<code class="fe lm ln lo lp b">on&lt;Random&gt;(_randomize);</code></p><p id="ca96" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">就是这样！我们完了。我们拥有bloc的魔力，而不必处理流，或者说<code class="fe lm ln lo lp b">mapEventToState</code>。我们减少了一大块样板文件，但仍然有可响应的、可测试的状态。</p><p id="20f1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">下面是完整的代码，不包括api调用函数:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="3ab6" class="ly lz it lp b gy ma mb l mc md">abstract class CounterEvent {}</span><span id="59cf" class="ly lz it lp b gy me mb l mc md">class Increment extends CounterEvent {}</span><span id="0120" class="ly lz it lp b gy me mb l mc md">class Decrement extends CounterEvent {}</span><span id="83e9" class="ly lz it lp b gy me mb l mc md">class SetCounter extends CounterEvent {<br/>   final int setTo;<br/> <br/>   SetCounter({required this.setTo});<br/> }</span><span id="e519" class="ly lz it lp b gy me mb l mc md">class Random extends CounterEvent {<br/>    final int from;<br/>    final int to;<br/>   <br/>    Random({required this.from, required this.to});<br/>}</span><span id="6eba" class="ly lz it lp b gy me mb l mc md"><br/>abstract class CounterState {}</span><span id="f44a" class="ly lz it lp b gy me mb l mc md">class CounterValue extends CounterState {<br/>   final int value;</span><span id="44e5" class="ly lz it lp b gy me mb l mc md">   CounterValue(this.value);<br/>}</span><span id="ae7b" class="ly lz it lp b gy me mb l mc md">class CounterLoading extends CounterState {}</span><span id="8689" class="ly lz it lp b gy me mb l mc md">class CounterBloc extends Bloc&lt;CounterEvent, CounterState&gt; {<br/>  CounterBloc() : super(CounterValue(0)) {<br/>     on&lt;Increment&gt;((event, emit) =&gt; _addToValue(1, emit));<br/>     on&lt;Decrement&gt;((event, emit) =&gt; _addToValue(-1, emit));<br/>     on&lt;SetCounter&gt;((event, emit) =&gt; emit(CounterValue(event.setTo)));<br/>     on&lt;Random&gt;(_randomize);<br/>  }</span><span id="ad4c" class="ly lz it lp b gy me mb l mc md"> void _addToValue(int toAdd, Emitter&lt;CounterState&gt; emit) {<br/>   if (state is CounterValue) {<br/>     emit(CounterValue((state as CounterValue).value + toAdd));<br/>   }<br/> }</span><span id="23b3" class="ly lz it lp b gy me mb l mc md"> Future&lt;void&gt; _randomize(Random event, Emitter&lt;CounterState&gt; emit)    async {<br/>   emit(CounterLoading());</span><span id="7a23" class="ly lz it lp b gy me mb l mc md">   final int randomInt = await callApi(event.from, event.to);</span><span id="6ddf" class="ly lz it lp b gy me mb l mc md">   emit(CounterValue(randomInt));<br/>  }<br/>}</span></pre><p id="470e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">无功的、可测试的状态不是很美吗？</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="8899" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你怎么想呢?你会从其他状态管理解决方案切换到Flutter Bloc吗？你认为集团还是黑暗时代吗？</p><p id="ca61" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我欢迎提问和评论！感谢阅读！</p></div></div>    
</body>
</html>