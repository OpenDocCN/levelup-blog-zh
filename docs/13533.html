<html>
<head>
<title>How to Create a Wordle with TDD in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Javascript中用TDD创建一个Wordle</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-a-wordle-with-tdd-in-javascript-926d7947bd90?source=collection_archive---------8-----------------------#2022-09-13">https://levelup.gitconnected.com/how-to-create-a-wordle-with-tdd-in-javascript-926d7947bd90?source=collection_archive---------8-----------------------#2022-09-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dcff" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们不断练习这个惊人的形并学习。可以按照步骤来！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/adf05141bb24d67c9273d157c779588e.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*ncAjhZm29SE41G8JyB86-A.png"/></div></figure><blockquote class="kn ko kp"><p id="2d22" class="kq kr ks kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="iq">TL；DR: Javascript对TDD来说也很棒</em></p></blockquote><p id="07ab" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">在2022年1月的Wordle rush期间，我写了一篇文章描述<a class="ae lq" href="https://blog.devgenius.io/how-to-develop-a-wordle-game-using-tdd-in-25-minutes-2157c93dda9f" rel="noopener ugc nofollow" target="_blank">如何使用PHP </a>创建一个带有TDD的Wordle。</p><div class="lr ls gp gr lt lu"><a href="https://blog.devgenius.io/how-to-develop-a-wordle-game-using-tdd-in-25-minutes-2157c93dda9f" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd ir gy z fp lz fr fs ma fu fw ip bi translated">如何在25分钟内用TDD开发一个Wordle游戏</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">使用TDD开发一个完整的Wordle游戏非常容易</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">blog.devgenius.io</p></div></div><div class="md l"><div class="me l mf mg mh md mi kl lu"/></div></div></a></div><p id="9b61" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">几个月后，我转录了用Codex人工智能创建的一个<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/step-by-step-wordle-creation-with-codex-ai-fcf243212594">单词的UI版本。</a></p><div class="lr ls gp gr lt lu"><a rel="noopener  ugc nofollow" target="_blank" href="/step-by-step-wordle-creation-with-codex-ai-fcf243212594"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd ir gy z fp lz fr fs ma fu fw ip bi translated">一步一步用Codex人工智能创造世界</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">我抄写指令，用自然语言创造一个工作词</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="md l"><div class="mj l mf mg mh md mi kl lu"/></div></div></a></div><p id="b280" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我将结合两个世界作为一个半人马来编程。</p><p id="0496" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我还将比较不同语言版本的流程和输出。</p><p id="d6e5" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">这是Javascript版本。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="7d4f" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">建立</h1><p id="0d88" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">像往常一样，我们将专注于游戏业务逻辑，知道我们可以用<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/step-by-step-wordle-creation-with-codex-ai-fcf243212594">自然语言命令</a>构建用户界面。</p><p id="517f" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">在本文中，我将使用一个带有<a class="ae lq" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>的<a class="ae lq" href="https://replit.com/@mcsee/Wordle-TDD" rel="noopener ugc nofollow" target="_blank"> repl.it </a>。</p><p id="1844" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">Javascript有许多单元测试框架。</p><p id="d5fa" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">你喜欢什么就用什么。</p><p id="9b79" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">让我们开始吧…</p><h1 id="8b6c" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">定义一个词</h1><p id="aa92" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">遵循与上一篇文章相同的原则，我们将从定义一个单词开始。</p><p id="bf8a" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">Wordle中最小的信息量是一个词。</p><p id="7876" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们可以争辩说<em class="ks">字母</em>更小，但是所有需要的字母协议都已经定义好了(我们可能错了)。</p><p id="374e" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">一个字不是一个<em class="ks">char⑤</em>。</p><p id="e221" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">一个字不是一个<em class="ks">数组</em>。</p><p id="4e63" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">一言不合<em class="ks">成串</em>。</p><p id="1774" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">这是一个常见的错误，也是一个<a class="ae lq" href="https://codeburst.io/the-one-and-only-software-design-principle-5328420712af" rel="noopener" target="_blank">双射违例</a>。</p><p id="1874" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">一个<em class="ks">单词</em>和一个<em class="ks">字符串</em>有不同的职责，尽管它们可能会相交。</p><blockquote class="kn ko kp"><p id="65a9" class="kq kr ks kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="iq">将(偶然的)实现细节与(</em> <a class="ae lq" href="https://medium.com/dev-genius/no-silver-bullet-65cba1775f9b" rel="noopener"> <em class="iq">【本质的】</em> </a> <em class="iq">)行为混为一谈是一种普遍的错误。</em></p></blockquote><p id="f5cc" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">所以我们需要定义一下<em class="ks">什么是词</em>。</p><p id="423c" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">Wordle中的一个单词是一个<em class="ks">有效的</em> 5个字母的单词。</p><p id="708c" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">让我们从我们的快乐之路开始:</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="78f5" class="ny ms iq nu b gy nz oa l ob oc">test("test01ValidWordLettersAreValid", async function() {<br/>  const word = new Word('valid');<br/>  expect(['v', 'a', 'l', 'i', 'd']).toStrictEqual(word.letters());<br/>});</span></pre><p id="9e85" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们断言对‘有效’中字母的提示会返回一个字母数组。</p><p id="9f03" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">这是结果:</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="828b" class="ny ms iq nu b gy nz oa l ob oc">Message: letters from word must be 'valid'<br/>Stack Trace:<br/>ReferenceError: Word is not defined<br/>    at Object.&lt;anonymous&gt; (/home/runner/Wordle-TDD/_test_runnertest_suite.js:6:18)<br/>    at Promise.then.completed (/home/runner/Wordle-TDD/node_modules/jest-circus/build/utils.js:333:28)</span></pre><p id="3dd0" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">这很好，因为我们还没有定义单词是什么。</p><h1 id="3296" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">通知；注意</h1><ul class=""><li id="2af3" class="od oe iq kt b ku nj kx nk ln of lo og lp oh lm oi oj ok ol bi translated">这是一个TDD模式。</li><li id="6d06" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">甚至在它们存在之前，我们就根据它们的<strong class="kt ir">行为</strong>给它们命名。</li><li id="4455" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated"><em class="ks">一词</em>类尚未定义。</li><li id="ab51" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">我们的词的第一个琐碎的责任是回复它的字母。</li><li id="f2a8" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">这不是<a class="ae lq" href="https://blog.devgenius.io/code-smell-68-getters-68571a0f7fa8" rel="noopener ugc nofollow" target="_blank">吸气剂</a>。每个单词都必须符合它的字母。</li><li id="a82b" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">我们不关心信件分类。这将是一个<strong class="kt ir">过早优化</strong>和镀金的场景。</li><li id="be94" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">我们从一个简单的例子开始。没有重复。</li><li id="0c9c" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">我们还没有弄乱单词验证(单词可能是XXXXX)。</li><li id="cace" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">我们可以从一个更简单的验证单词创建的测试开始。这将违反总是需要断言的测试结构。</li><li id="30f4" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">期望值应该始终是断言中的第一个值。</li></ul><h1 id="62d4" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">创造一个词</h1><p id="cad2" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">我们需要用letters()函数创建一个单词。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="3fca" class="ny ms iq nu b gy nz oa l ob oc">class Word {<br/>  letters() {<br/>    return ['v', 'a', 'l', 'i', 'd'];<br/>  }  <br/>}</span></pre><h1 id="8f8f" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">通知；注意</h1><ul class=""><li id="fd94" class="od oe iq kt b ku nj kx nk ln of lo og lp oh lm oi oj ok ol bi translated">我们还不需要构造函数。</li><li id="bb4f" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">我们硬编码字母函数，因为这是迄今为止最简单的可能解决方案。</li><li id="ebf6" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">假装直到我们成功。</li></ul><p id="2f4f" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们运行了所有的测试(只有一个)，我们都没问题。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="02db" class="ny ms iq nu b gy nz oa l ob oc">✅  test01ValidWordLettersAreValid</span><span id="fc4a" class="ny ms iq nu b gy or oa l ob oc">  All tests have passed 1/1</span></pre></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="7046" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">几个字母</h1><p id="fe96" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">让我们编写另一个测试:</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="67d1" class="ny ms iq nu b gy nz oa l ob oc">test("test02FewWordLettersShouldRaiseException", async function() {<br/>  expect(() =&gt; { <br/>    new Word('vali');                 <br/>               }).toThrow(Error);<br/>});</span></pre><p id="feef" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">测试不出所料…</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="5344" class="ny ms iq nu b gy nz oa l ob oc">❌  test02FewWordLettersShouldRaiseException<br/>Stack Trace:<br/>Error: expect(received).toThrow(expected)</span><span id="2a06" class="ny ms iq nu b gy or oa l ob oc">Expected constructor: Error</span><span id="475c" class="ny ms iq nu b gy or oa l ob oc">Received function did not throw<br/>    at Object.toThrow (/home/runner/Wordle-TDD/_test_runnertest_suite.js:10:23)</span><span id="9c45" class="ny ms iq nu b gy or oa l ob oc">✅  test01ValidWordLettersAreValid</span><span id="7e66" class="ny ms iq nu b gy or oa l ob oc">  1/2 passed, see errors above</span></pre><h1 id="a709" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">通知；注意</h1><ul class=""><li id="64e4" class="od oe iq kt b ku nj kx nk ln of lo og lp oh lm oi oj ok ol bi translated">第一次测试通过了</li><li id="f169" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">第二个测试预计会抛出一个异常。但事实并非如此。</li><li id="1c87" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">我们只是声明一个通用的异常会被抛出。</li><li id="f95c" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">我们只是提出一个一般性的错误。</li><li id="4871" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">创建特殊异常是一种<a class="ae lq" href="https://blog.devgenius.io/code-smell-26-exceptions-polluting-9246aca40234" rel="noopener ugc nofollow" target="_blank">代码味道</a>污染名称空间。(除非我们抓住它，但这不是现在发生的事情)。</li></ul><h1 id="3ffa" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">改变当前的实现</h1><p id="5e2d" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">我们需要更改我们的实现来使test02通过(还有test01)。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="1beb" class="ny ms iq nu b gy nz oa l ob oc">class Word {<br/>  constructor(word) {<br/>    if (word.length &lt; 5)<br/>      throw new Error('Too few letters. Should be 5');<br/>  }<br/>  letters() {<br/>      return ['v', 'a', 'l', 'i', 'd'];<br/>  }  <br/>}</span></pre><p id="329d" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">测试通过了。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="0d5b" class="ny ms iq nu b gy nz oa l ob oc">✅  test02FewWordLettersShouldRaiseException</span><span id="2d04" class="ny ms iq nu b gy or oa l ob oc">✅  test01ValidWordLettersAreValid</span><span id="737e" class="ny ms iq nu b gy or oa l ob oc">  All tests have passed 2/2</span></pre><h1 id="f4be" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">通知；注意</h1><ul class=""><li id="1c02" class="od oe iq kt b ku nj kx nk ln of lo og lp oh lm oi oj ok ol bi translated">我们还没有使用构造函数参数来设置实际的字母。</li><li id="1ccd" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">我们只是检查几封信。不会太多，因为我们还没有覆盖测试。</li><li id="a46c" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">TDD要求全覆盖。在没有测试的情况下添加另一个检查是违反技术的。</li></ul><h1 id="dc32" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">检查太多信件</h1><p id="5659" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">让我们检查太多</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="3f6c" class="ny ms iq nu b gy nz oa l ob oc">test("test03TooManyWordLettersShouldRaiseException", async function() {<br/>  expect(() =&gt; { <br/>    new Word('toolong');                 <br/>               }).toThrow(Error);</span><span id="f3eb" class="ny ms iq nu b gy or oa l ob oc">});</span></pre><p id="abd3" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们运行它们:</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="c437" class="ny ms iq nu b gy nz oa l ob oc">❌  test03TooManyWordLettersShouldRaiseException<br/>Stack Trace:<br/>Error: expect(received).toThrow(expected)</span><span id="8e22" class="ny ms iq nu b gy or oa l ob oc">Expected constructor: Error</span><span id="07f6" class="ny ms iq nu b gy or oa l ob oc">Received function did not throw<br/>    at Object.toThrow (/home/runner/Wordle-TDD/_test_runnertest_suite.js:10:23)</span><span id="e1bb" class="ny ms iq nu b gy or oa l ob oc">✅  test02FewWordLettersShouldRaiseException</span><span id="8d2e" class="ny ms iq nu b gy or oa l ob oc">✅  test01ValidWordLettersAreValid</span><span id="5ede" class="ny ms iq nu b gy or oa l ob oc">  2/3 passed, see errors above</span></pre><p id="7d71" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们添加了验证:</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="fd21" class="ny ms iq nu b gy nz oa l ob oc">class Word {<br/>  constructor(letters) {<br/>    if (letters.length &lt; 5)<br/>      throw new Error('Too few letters. Should be 5');<br/>    if (letters.length &gt; 5)<br/>      throw new Error('Too many letters. Should be 5');<br/>  }<br/>  letters() {<br/>      return ['v', 'a', 'l', 'i', 'd'];<br/>  }  <br/>}</span></pre><p id="327d" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">所有测试都通过了。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="a18e" class="ny ms iq nu b gy nz oa l ob oc">All tests have passed 3/3</span></pre></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="ed05" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">重构(或不重构)</h1><p id="c9a5" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">我们现在可以进行(可选的)重构，并更改函数以断言一个范围而不是两个边界。我们决定保留这种方式，因为它更具有声明性。</p><p id="f334" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们还可以按照<a class="ae lq" href="https://blog.devgenius.io/how-i-survived-the-zombie-apocalypse-19905db22043" rel="noopener ugc nofollow" target="_blank">僵尸方法</a>添加一个零单词测试。</p><p id="25b9" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">让我们开始吧。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="528e" class="ny ms iq nu b gy nz oa l ob oc">test("test04EmptyLettersShouldRaiseException", async function() {<br/>  expect(() =&gt; { <br/>    new Word('');                 <br/>               }).toThrow(Error);</span><span id="fea5" class="ny ms iq nu b gy or oa l ob oc">});</span><span id="aca3" class="ny ms iq nu b gy or oa l ob oc">✅  test04EmptyLettersShouldRaiseException</span><span id="9ce8" class="ny ms iq nu b gy or oa l ob oc">✅  test03TooManyWordLettersShouldRaiseException</span><span id="6c8b" class="ny ms iq nu b gy or oa l ob oc">✅  test02FewWordLettersShouldRaiseException</span><span id="49e7" class="ny ms iq nu b gy or oa l ob oc">✅  test01ValidWordLettersAreValid</span></pre><p id="fd22" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">测试通过并不奇怪，因为我们已经有了一个覆盖这个场景的测试。</p><p id="f4d7" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">由于这个测试没有增加任何价值，我们应该取消它。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="51ea" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">有效信函</h1><p id="3fba" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">现在让我们检查一下什么是有效的字母:</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="d23e" class="ny ms iq nu b gy nz oa l ob oc">test("test05InvalidLettersShouldRaiseException", async function() {<br/>   expect(() =&gt; { <br/>    new Word('vali*');                 <br/>               }).toThrow(Error);</span><span id="05ca" class="ny ms iq nu b gy or oa l ob oc">});</span></pre><p id="65bb" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">…测试中断，因为没有产生断言。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="a2a6" class="ny ms iq nu b gy nz oa l ob oc">❌  test05InvalidLettersShouldRaiseException<br/>Stack Trace:<br/>Error: expect(received).toThrow(expected)</span><span id="d902" class="ny ms iq nu b gy or oa l ob oc">Expected constructor: Error</span><span id="5287" class="ny ms iq nu b gy or oa l ob oc">Received function did not throw</span></pre><p id="977e" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们需要更正代码…</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="ea81" class="ny ms iq nu b gy nz oa l ob oc">class Word {<br/>  constructor(word) {<br/>    if (word.length &lt; 5)<br/>      throw new Error('Too few letters. Should be 5');<br/>    if (word.length &gt; 5)<br/>      throw new Error('Too many letters. Should be 5');<br/>    if (word.indexOf('*') &gt; -1) <br/>      throw new Error('Word has invalid letters');<br/>  }<br/>}</span></pre><p id="6f79" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">并且所有测试都通过了，因为我们显然是硬编码的。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="16ad" class="ny ms iq nu b gy nz oa l ob oc">All tests have passed 5/5</span></pre><h1 id="04ed" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">通知；注意</h1><ul class=""><li id="2a25" class="od oe iq kt b ku nj kx nk ln of lo og lp oh lm oi oj ok ol bi translated">我们将星号硬编码为唯一的无效字符(据我们所知)。</li><li id="c825" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">我们可以将校验码<em class="ks">放在前面验证的</em>之前，或者<em class="ks">放在</em>之后。—除非我们有无效的大小写(包含无效字符和无效长度),否则我们无法假设预期的行为。</li></ul><h1 id="004b" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">更无效</h1><p id="5b58" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">让我们添加更多的无效字母并更正代码。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="c466" class="ny ms iq nu b gy nz oa l ob oc">test("test06PointShouldRaiseException", async function() {<br/>   expect(() =&gt; { <br/>    new Word('val.d');                 <br/>               }).toThrow(Error);</span><span id="76e0" class="ny ms iq nu b gy or oa l ob oc">});</span><span id="51f8" class="ny ms iq nu b gy or oa l ob oc">// Solution</span><span id="eb94" class="ny ms iq nu b gy or oa l ob oc"> constructor(word) {<br/>    if (word.indexOf('*') &gt; -1) <br/>      throw new Error('Word has invalid letters');<br/>    if (word.indexOf('.') &gt; -1) <br/>      throw new Error('Word has invalid letters');<br/>}</span></pre><h1 id="69d8" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">通知；注意</h1><ul class=""><li id="7971" class="od oe iq kt b ku nj kx nk ln of lo og lp oh lm oi oj ok ol bi translated">我们还没有写一个更通用的函数，因为我们不能同时修正测试和重构(技术不允许我们这么做)。</li></ul><h1 id="c38f" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">重构</h1><p id="9e98" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">所有测试都没问题。</p><p id="890b" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们可以重构。</p><p id="b87f" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们替换最后两句话。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="59f0" class="ny ms iq nu b gy nz oa l ob oc">class Word {<br/>  constructor(word) {<br/>    if (word.length &lt; 5)<br/>      throw new Error('Too few letters. Should be 5');<br/>    if (word.length &gt; 5)<br/>      throw new Error('Too many letters. Should be 5');<br/>    // Refactor  <br/>    if (!word.match(/^[a-z]+$/i)) <br/>      throw new Error('word has invalid letters');<br/>    //   <br/>}</span></pre><h1 id="dff2" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">通知；注意</h1><ul class=""><li id="f5b6" class="od oe iq kt b ku nj kx nk ln of lo og lp oh lm oi oj ok ol bi translated">只有当我们不同时改变测试时，我们才能重构。</li><li id="94f2" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">断言只检查大写字母。因为我们到现在都在处理这些例子。</li><li id="cb79" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">我们尽可能推迟设计决策。</li><li id="1c1c" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">我们定义了一个基于英文字母的正则表达式。我们很确定它不接受西班牙语、德语等。</li></ul><p id="6f09" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">作为检查点，从现在开始我们只有五个字母单词。</p><p id="3db7" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">让我们断言<em class="ks">字母()</em>函数。</p><p id="2054" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们把它硬编码了。</p><p id="8e5f" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">TDD开放了很多路径。</p><p id="2a30" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">在我们开新的之前，我们需要记录所有的。</p><h1 id="6de2" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">比较单词</h1><p id="a2cc" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">我们需要比较单词</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="2de2" class="ny ms iq nu b gy nz oa l ob oc">test("test07TwoWordsAreNotTheSame", async function() {<br/>    const firstWord = new Word('valid');<br/>    const secondWord = new Word('happy');<br/>    expect(firstWord).not.toStrictEqual(secondWord);<br/>});</span><span id="c62f" class="ny ms iq nu b gy or oa l ob oc">test("test08TwoWordsAreTheSame", async function() {<br/>    const firstWord = new Word('valid');<br/>    const secondWord = new Word('valid');<br/>    expect(firstWord).toStrictEqual(secondWord);<br/>});</span></pre><p id="eeb3" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">测试失败。</p><p id="c242" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">让我们使用发送给他们的参数。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="c533" class="ny ms iq nu b gy nz oa l ob oc">class Word {<br/>  constructor(word) { <br/>    // ...<br/>    this._word = word;<br/>  }<br/>  letters() {<br/>      return ['v', 'a', 'l', 'i', 'd'];<br/>  }  <br/>}</span><span id="3494" class="ny ms iq nu b gy or oa l ob oc">✅  test08TwoWordsAreTheSame</span><span id="30a5" class="ny ms iq nu b gy or oa l ob oc">✅  test07TwoWordsAreNotTheSame</span><span id="1869" class="ny ms iq nu b gy or oa l ob oc">✅  test06PointShouldRaiseException</span><span id="7135" class="ny ms iq nu b gy or oa l ob oc">✅  test05InvalidLettersShouldRaiseException</span><span id="c4e4" class="ny ms iq nu b gy or oa l ob oc">✅  test04EmptyLettersShouldRaiseException</span><span id="b9eb" class="ny ms iq nu b gy or oa l ob oc">✅  test03TooManyWordLettersShouldRaiseException</span><span id="9485" class="ny ms iq nu b gy or oa l ob oc">✅  test02FewWordLettersShouldRaiseException</span><span id="2c50" class="ny ms iq nu b gy or oa l ob oc">✅  test01ValidWordLettersAreValid</span><span id="b6fa" class="ny ms iq nu b gy or oa l ob oc">  All tests have passed 8/8</span></pre><h1 id="8312" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">通知；注意</h1><ul class=""><li id="ee69" class="od oe iq kt b ku nj kx nk ln of lo og lp oh lm oi oj ok ol bi translated">我们存储字母，这足以进行对象比较(这可能取决于语言)。</li><li id="efdf" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">letters()函数仍然是硬编码的</li></ul></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="1b6e" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">更多单词</h1><p id="6aea" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">我们添加了一个不同的单词用于字母比较。</p><p id="34c0" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">记住字母()一直到现在都是硬编码的。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="e670" class="ny ms iq nu b gy nz oa l ob oc">test("test09LettersForGrassWord", async function() {<br/>  const grassWord = new Word('grass'); <br/>  expect(['g','r','a','s','s']).toStrictEqual(grassWord.letters());<br/>});</span></pre><p id="3ad9" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">测试不出所料地失败了。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="ebaa" class="ny ms iq nu b gy nz oa l ob oc">❌  test09LettersForGrassWord<br/>Stack Trace:<br/>Error: expect(received).toStrictEqual(expected) // deep equality</span><span id="9095" class="ny ms iq nu b gy or oa l ob oc">- Expected  - 4<br/>+ Received  + 4</span><span id="a297" class="ny ms iq nu b gy or oa l ob oc">  Array [<br/>-   "v",<br/>+   "g",<br/>+   "r",<br/>    "a",<br/>-   "l",<br/>-   "i",<br/>-   "d",<br/>+   "s",<br/>+   "s",<br/>  ]<br/>    at Object.toStrictEqual (/home/runner/Wordle-TDD/_test_runnertest_suite.js:9:37)</span></pre><h1 id="a857" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">通知；注意</h1><ul class=""><li id="be56" class="od oe iq kt b ku nj kx nk ln of lo og lp oh lm oi oj ok ol bi translated">检查相等/不相等而不是assertTrue()是非常重要的，因为许多ide打开了一个基于对象的比较工具。</li><li id="c6ab" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">这是使用ide而不使用文本编辑器的另一个原因。</li></ul><p id="cd33" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">让我们更改letters()函数，因为我们一直在伪造它。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="adf4" class="ny ms iq nu b gy nz oa l ob oc">class Word {<br/>  letters() {<br/>      return this._word.split("");<br/>  }  <br/>}</span></pre></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="7a54" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">比较不同的案例</h1><p id="a875" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">我们需要确保比较不区分大小写。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="53ef" class="ny ms iq nu b gy nz oa l ob oc">test("test10ComparisonIsCaseInsensitve", async function() {<br/>    const firstWord = new Word('valid');<br/>    const secondWord = new Word('VALID');<br/>    expect(firstWord).toStrictEqual(secondWord); <br/>});</span></pre><p id="897b" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">测试失败。</p><p id="1d1f" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们需要做出决定。</p><p id="e724" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们决定我们所有的域名都是小写的。</p><p id="3c6a" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">尽管用户界面有大写字母，我们也不允许大写字母。</p><p id="04ac" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们不会进行魔法转换。</p><p id="f5f8" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们改变测试来捕捉无效的大写字母并修正它们。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="24ac" class="ny ms iq nu b gy nz oa l ob oc">test("test10NoUppercaseAreAllowed", async function() {<br/>   expect(() =&gt; { <br/>    new Word('vAliD');                 <br/>               }).toThrow(Error);<br/>});</span><span id="4c94" class="ny ms iq nu b gy or oa l ob oc">class Word {<br/>  constructor(word) {<br/>    // We remove the /i modifier on the regular expression  <br/>    if (!word.match(/^[a-z]+$/)) <br/>      throw new Error('word has invalid letters');   <br/>  }</span></pre><h1 id="6e8b" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">英语词典</h1><p id="66d2" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">我们的单词和英语单词一模一样。还是没有？</p><p id="57de" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">让我们试试一个非英语单词</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="5910" class="ny ms iq nu b gy nz oa l ob oc">test("test11XXXXIsnotAValidWord", async function() {<br/>  expect(() =&gt; { <br/>    new Word('XXXXX');                 <br/>               }).toThrow(Error);<br/>});</span></pre><p id="85c7" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">这个测试失败了。</p><p id="e587" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们没有捕捉无效的英语5个字母的单词。</p><h1 id="f9ad" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">通知；注意</h1><ul class=""><li id="76e1" class="od oe iq kt b ku nj kx nk ln of lo og lp oh lm oi oj ok ol bi translated">我们需要做出决定。根据我们的<a class="ae lq" href="https://codeburst.io/the-one-and-only-software-design-principle-5328420712af" rel="noopener" target="_blank">双射</a>，有一个外部字典断言有效单词。</li><li id="a69d" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">我们可以在造词时用字典来验证。但是我们希望字典存储有效的单词。没有条件。</li><li id="23b0" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">这是一个先有蛋还是先有鸡的问题。</li><li id="2b78" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">我们决定处理字典中的无效单词，而不是单词。</li><li id="8a8e" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">我们取消测试。</li><li id="7df2" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">一会儿我们会找到更好的方法。</li></ul></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="4a5c" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">沃尔多游戏</h1><p id="40a9" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">让我们来创造这个游戏。</p><p id="abbe" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们开始谈论一个不存在的游戏。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="e81d" class="ny ms iq nu b gy nz oa l ob oc">test("test11EmptyGameHasNoWinner", async function() {<br/>  const game = new Game()<br/>  expect(false).toStrictEqual(game.hasWon());<br/>});</span></pre><p id="6369" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">测试失败。</p><p id="93a0" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们需要创建类和函数。</p><h1 id="d174" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">创建游戏对象</h1><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="9f13" class="ny ms iq nu b gy nz oa l ob oc">class Game {<br/>  hasWon() {<br/>      return false;<br/>  }  <br/>}</span></pre></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="4916" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">尝试的单词</h1><p id="4dfd" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">我们实施话语尝试。</p><p id="8fad" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">也是最简单的解决方案。</p><p id="f233" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">一如既往的硬编码。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="c142" class="ny ms iq nu b gy nz oa l ob oc">test("test12EmptyGameWordsAttempted", async function() {<br/>  const game = new Game()<br/>  expect([]).toStrictEqual(game.wordsAttempted());<br/>});</span><span id="2f6f" class="ny ms iq nu b gy or oa l ob oc">class Game {<br/>  wordsAttempted() {<br/>    return [];<br/>  }<br/>}</span><span id="0151" class="ny ms iq nu b gy or oa l ob oc">✅  test12EmptyGameWordsAttempted<br/>...<br/>  All tests have passed 12/12</span></pre><h1 id="4049" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">开始猜测</h1><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="3e92" class="ny ms iq nu b gy nz oa l ob oc">test("test13TryOneWordAndRecordIt", async function() {<br/>  var game = new Game();<br/>  game.addAttempt(new Word('loser'));<br/>  expect([new Word('loser')]).toStrictEqual(game.wordsAttempted());   <br/>});</span><span id="16a9" class="ny ms iq nu b gy or oa l ob oc">class Game {<br/>  constructor() {<br/>    this._attempts = [];<br/>  }<br/>  hasWon() {<br/>      return false;<br/>  }<br/>  wordsAttempted() {<br/>    return this._attempts;<br/>  }<br/>  addAttempt(word) {<br/>    this._attempts.push(word);    <br/>  }<br/>}</span></pre><h1 id="5f4a" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">通知；注意</h1><ul class=""><li id="2a5f" class="od oe iq kt b ku nj kx nk ln of lo og lp oh lm oi oj ok ol bi translated">我们在本地存储尝试，添加尝试，并更改wordsAttempted() real实现。</li></ul></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="dc60" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">已经输了</h1><p id="d329" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">我们可以实现hasLost()，如果它错过了6次尝试。</p><p id="bcf7" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">通常使用最简单的实现。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="2f15" class="ny ms iq nu b gy nz oa l ob oc">test("test14TryOneWordAndDontLooseYet", async function() {<br/>  const game = new Game();<br/>  game.addAttempt(new Word('loser'));<br/>  expect(false).toStrictEqual(game.hasLost());   <br/>});</span><span id="75b1" class="ny ms iq nu b gy or oa l ob oc">class Game { <br/>  hasLost() {<br/>      return false;<br/>  }<br/>}</span></pre><h1 id="dc3a" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">通知；注意</h1><ul class=""><li id="9c9e" class="od oe iq kt b ku nj kx nk ln of lo og lp oh lm oi oj ok ol bi translated">随着模型的增长，我们正在学习规则。</li></ul><h1 id="1af1" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">我们输了比赛</h1><p id="605b" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">一如既往。我们不再假装，而是决定去做。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="2b34" class="ny ms iq nu b gy nz oa l ob oc">test("test15TryFiveWordsLoses", async function() {<br/>  const game = new Game([new Word('loser'), new Word('music')], new Word('music'));<br/>  game.addAttempt(new Word('loser'));<br/>  game.addAttempt(new Word('loser'));<br/>  game.addAttempt(new Word('loser'));<br/>  game.addAttempt(new Word('loser'));<br/>  game.addAttempt(new Word('loser'));<br/>  expect(false).toStrictEqual(game.hasLost());  <br/>  // last attempt<br/>  game.addAttempt(new Word('loser'));<br/>  expect(true).toStrictEqual(game.hasLost());  <br/>});</span><span id="2b4e" class="ny ms iq nu b gy or oa l ob oc">class Game {<br/>  hasLost() {<br/>    return this._attempts.length &gt; 5;<br/>  }<br/>}</span></pre><h1 id="cd14" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">我们按字典来玩</h1><p id="befd" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">我们有大部分的机械。</p><p id="1ce7" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们来添加有效单词字典，玩无效。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="8463" class="ny ms iq nu b gy nz oa l ob oc">test("test16TryToPlayInvalid", async function() {<br/>  const game = new Game([]);  <br/>  expect(() =&gt; { <br/>    game.addAttempt(new Word('xxxxx'));            <br/>               }).toThrow(Error);<br/>});</span></pre><p id="97d3" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">测试不出所料地失败了</p><p id="5313" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们修好它。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="1294" class="ny ms iq nu b gy nz oa l ob oc">class Game {<br/>  constructor(validWords) {<br/>    this._attempts = [];<br/>    this._validWords = validWords;<br/>  }   <br/>  addAttempt(word) {<br/>    if (!this._validWords.some(validWord =&gt; validWord.sameAs(word))) {<br/>      throw new Error(word.letters() + " is not a valid word");<br/>    }<br/>    this._attempts.push(word);    <br/>  }<br/>}</span><span id="f0ac" class="ny ms iq nu b gy or oa l ob oc">// fix previous tests<br/>// change </span><span id="64c7" class="ny ms iq nu b gy or oa l ob oc">const game = new Game([]);</span><span id="58a1" class="ny ms iq nu b gy or oa l ob oc">// to </span><span id="3262" class="ny ms iq nu b gy or oa l ob oc">const game = new Game([new Word('loser')]);</span><span id="f47c" class="ny ms iq nu b gy or oa l ob oc">Also add: <br/>Class Word {<br/> sameAs(word) {<br/>    return word.word() == this.word();<br/>  }<br/>}</span></pre><p id="b3f0" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">测试是固定的，但是…</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="0938" class="ny ms iq nu b gy nz oa l ob oc">test16TryToPlayInvalid</span><span id="43b4" class="ny ms iq nu b gy or oa l ob oc">❌  test15TryFiveWordsLoses<br/>Stack Trace:<br/>TypeError: Cannot read properties of undefined (reading 'includes')</span><span id="eac7" class="ny ms iq nu b gy or oa l ob oc">❌  test14TryOneWordAndDontLooseYet<br/>Stack Trace:<br/>TypeError: Cannot read properties of undefined (reading 'includes') </span><span id="9f46" class="ny ms iq nu b gy or oa l ob oc">❌  test13TryOneWordAndRecordIt<br/>Stack Trace:<br/>TypeError: Cannot read properties of undefined (reading 'includes')</span><span id="a3a9" class="ny ms iq nu b gy or oa l ob oc">✅  test12EmptyGameWordsAttempted</span><span id="c2c3" class="ny ms iq nu b gy or oa l ob oc">✅  test10EmptyGameHasNoWinner</span><span id="7d0d" class="ny ms iq nu b gy or oa l ob oc">  12/15 passed, see errors above</span></pre><h1 id="ca41" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">通知；注意</h1><ul class=""><li id="2020" class="od oe iq kt b ku nj kx nk ln of lo og lp oh lm oi oj ok ol bi translated">测试13、测试14和测试15之前是工作的。</li><li id="504f" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">现在，由于我们添加了新的业务规则，它们被打破了。</li><li id="e510" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">我们在创建游戏时需要通过字典。</li><li id="29ea" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">我们通过添加一个包含我们将要使用的单词的数组来修复这三个问题。</li><li id="bc9d" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">我们的设置变得复杂，以不断创建有效的场景，这是一个好迹象。</li></ul><h1 id="0461" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">为赢而战</h1><p id="02b0" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">现在，我们为胜利而战</p><p id="2a43" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们添加了测试，并需要相应地更改hasWon()。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="a59e" class="ny ms iq nu b gy nz oa l ob oc">test("test17GuessesWord", async function() {<br/>  const words = [new Word('happy')];<br/>  const correctWord = new Word('happy');<br/>  const game = new Game(words, correctWord);  <br/>  expect(game.hasWon()).toStrictEqual(false);<br/>  game.addAttempt(new Word('happy'));<br/>  expect(game.hasWon()).toStrictEqual(true);<br/>});</span><span id="673e" class="ny ms iq nu b gy or oa l ob oc">// we need to store the correct word<br/>class Game {<br/>  constructor(validWords, correctWord) {<br/>    this._attempts = [];<br/>    this._validWords = validWords;<br/>    this._correctWord = correctWord;<br/>  }<br/>  hasWon() {<br/>    return this._attempts.some(attempt =&gt; attempt.sameAs(this._correctWord)); <br/>}</span></pre><h1 id="5f8b" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">通知；注意</h1><ul class=""><li id="2d68" class="od oe iq kt b ku nj kx nk ln of lo og lp oh lm oi oj ok ol bi translated">我们不使用标志来检查是否有人赢了。我们可以直接去查。</li><li id="b3c3" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">我们不在乎它在之前的尝试中是否赢过。</li><li id="6eb8" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">我们用这个新元素对以前的游戏定义做了一个<em class="ks"> addParameter </em>重构。</li></ul></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="3851" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">正确的单词</h1><p id="388f" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">我们添加了<em class="ks">正确词</em>。</p><p id="d3e8" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们需要断言这个单词在字典中。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="9823" class="ny ms iq nu b gy nz oa l ob oc">test("test18CorrectWordNotInDictionary", async function() {<br/>  const words = [new Word('happy')];<br/>  const correctWord = new Word('heros');  <br/>   expect(() =&gt; { <br/>     new Game(words, correctWord);                 <br/>               }).toThrow(Error);<br/>});</span><span id="b3bf" class="ny ms iq nu b gy or oa l ob oc">class Game {<br/>  constructor(validWords, correctWord) {<br/>    if (!validWords.some(validWord =&gt; validWord.sameAs(correctWord)))<br/>      throw new Error("Correct word " + word.word() + " is not a valid word");  <br/>  }</span></pre><h1 id="bfb1" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">通知；注意</h1><ul class=""><li id="2155" class="od oe iq kt b ku nj kx nk ln of lo og lp oh lm oi oj ok ol bi translated">我们需要改变所有以前的游戏，因为我们需要在开始前通过获胜游戏</li><li id="fcb9" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">这是一个好的副作用，因为它有利于完整和不可变的对象。</li></ul></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="caad" class="ny ms iq nu b gy nz oa l ob oc">✅  test18CorrectWordNotInDictionary<br/>...</span><span id="2ca0" class="ny ms iq nu b gy or oa l ob oc">✅  test01ValidWordLettersAreValid</span><span id="a88e" class="ny ms iq nu b gy or oa l ob oc">  All tests have passed 17/17</span></pre><h1 id="5593" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">输了，赢了，都输了？</h1><p id="634e" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">如果我们在最后一次尝试中获胜会发生什么？</p><p id="0c67" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">僵尸要求我们总是检查虫子藏身的边界。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="f1ce" class="ny ms iq nu b gy nz oa l ob oc">test("test19TryFiveWordsWins", async function() {<br/>  const game = new Game([new Word('loser'),new Word('heros')],new Word('heros'));<br/>  game.addAttempt(new Word('loser'));<br/>  game.addAttempt(new Word('loser'));<br/>  game.addAttempt(new Word('loser'));<br/>  game.addAttempt(new Word('loser'));<br/>  game.addAttempt(new Word('loser'));<br/>  expect(false).toStrictEqual(game.hasLost());  <br/>  expect(false).toStrictEqual(game.hasWon());  <br/>  // last attempt<br/>  game.addAttempt(new Word('heros'));<br/>  expect(false).toStrictEqual(game.hasLost());  <br/>  expect(true).toStrictEqual(game.hasWon());  <br/>});</span><span id="a3a4" class="ny ms iq nu b gy or oa l ob oc">// And the correction</span><span id="9db5" class="ny ms iq nu b gy or oa l ob oc">hasLost() {<br/>    return !this.hasWon() &amp;&amp; this._attempts.length &gt; 5;<br/>  }</span></pre></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="a6b4" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们有所有的机制。</p><h1 id="55b4" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">字母位置</h1><p id="2150" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">让我们把字母的位置加起来。</p><p id="6381" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们可以在单词课上做。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="0413" class="ny ms iq nu b gy nz oa l ob oc">test("test20LettersDoNotMatch", async function() {<br/>  const firstWord = new Word('trees');<br/>  const secondWord = new Word('valid');<br/>  expect([]).toStrictEqual(firstWord.matchesPositionWith(secondWord));<br/>});</span></pre><p id="910f" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">像往常一样，我们得到一个<em class="ks">未定义函数</em>错误:</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="233d" class="ny ms iq nu b gy nz oa l ob oc">❌  test20LettersDoNotMatch<br/>Stack Trace:<br/>TypeError: firstWord.matchesPositionWith is not a function</span></pre><p id="7add" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们像往常一样假装一下。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="c29e" class="ny ms iq nu b gy nz oa l ob oc">class Word {<br/>  matchesPositionWith(correctWord) {<br/>    return [];    <br/>  }<br/>}</span></pre><h1 id="5754" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">通知；注意</h1><ul class=""><li id="7ca2" class="od oe iq kt b ku nj kx nk ln of lo og lp oh lm oi oj ok ol bi translated">名字总是很重要的。</li><li id="a1a4" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">我们可以把这个参数命名为<em class="ks">，换句话说就是</em>。</li><li id="1426" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">我们更喜欢<em class="ks">正确词</em>。</li><li id="0249" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">我们意识到，我们将很快需要一个复杂的算法，角色应该是明确的和上下文相关的。</li></ul></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="f07b" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">比赛</h1><p id="b32b" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">让我们比赛</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="261e" class="ny ms iq nu b gy nz oa l ob oc">test("test21MatchesFirstLetter", async function() {<br/>  const guessWord = new Word('trees');<br/>  const correctWord = new Word('table');<br/>  expect([1]).toStrictEqual(guessWord.matchesPositionWith(correctWord));<br/>});</span></pre><p id="23ee" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">失败了。</p><p id="70fb" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们需要更好地定义它</p><p id="b8e8" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">这是一个足够好的算法。</p><p id="7fde" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">丑陋而迫切</p><p id="a027" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">当然，我们以后会重构它。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="b0ef" class="ny ms iq nu b gy nz oa l ob oc">matchesPositionWith(correctWord) {<br/>   var positions = [];<br/>   for (var currentPosition = 0; <br/>      currentPosition &lt; this.letters().length; <br/>      currentPosition++) {<br/>       if (this.letters()[currentPosition] == correctWord.letters()[currentPosition]) {<br/>             positions.push(currentPosition + 1); <br/>             //Humans start counting on 1<br/>       }<br/>   }<br/>   return positions;<br/>}</span></pre><p id="611c" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">所有的测试都通过了。</p><h1 id="fa92" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">通知；注意</h1><ul class=""><li id="543b" class="od oe iq kt b ku nj kx nk ln of lo og lp oh lm oi oj ok ol bi translated">匹配属性不对称</li></ul></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="8c82" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">不正确的位置</h1><p id="aedd" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">现在我们需要最后的步骤。</p><p id="14e0" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">在不正确的位置匹配。</p><p id="2e36" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">而且总是最简单的解决方案…</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="0b72" class="ny ms iq nu b gy nz oa l ob oc">test("test23MatchesIncorrectPositions", async function() {<br/>  const guessWord = new Word('trees');<br/>  const correctWord = new Word('drama');<br/>  expect([2]).toStrictEqual(guessWord.matchesPositionWith(correctWord));<br/>  expect([]).toStrictEqual(guessWord.matchesIncorrectPositionWith(correctWord));<br/>});</span><span id="50af" class="ny ms iq nu b gy or oa l ob oc">// The simplest solution</span><span id="1715" class="ny ms iq nu b gy or oa l ob oc">class Word {<br/>  matchesIncorrectPositionWith(correctWord) {<br/>     return [];<br/>  }<br/>}</span></pre><h1 id="018c" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">通知；注意</h1><ul class=""><li id="7c12" class="od oe iq kt b ku nj kx nk ln of lo og lp oh lm oi oj ok ol bi translated">通过添加这些安全的零案例，我们可以忽略许多常见的错误。</li></ul><p id="c1bc" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">更辛辣的测试案例。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="cf11" class="ny ms iq nu b gy nz oa l ob oc">test("test24MatchesIncorrectPositionsWithMatch", async function() {<br/>  const guessWord = new Word('alarm');<br/>  const correctWord = new Word('drama');<br/>  expect([3]).toStrictEqual(guessWord.matchesPositionWith(correctWord));<br/>  expect([1, 4, 5]).toStrictEqual(guessWord.matchesIncorrectPositionWith(correctWord));<br/>  // A*ARM vs *RAMA<br/>  expect([3]).toStrictEqual(correctWord.matchesPositionWith(guessWord));<br/>  expect([2, 4, 5]).toStrictEqual(correctWord.matchesIncorrectPositionWith(guessWord));<br/>});</span></pre><p id="a2e4" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">让我们开始实现吧</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="3277" class="ny ms iq nu b gy nz oa l ob oc">class Word {<br/>  matchesIncorrectPositionWith(correctWord) {<br/>      var positions = [];<br/>      for (var currentPosition = 0; currentPosition &lt; 5; currentPosition++) {<br/>        if (correctWord.letters().includes(this.letters()[currentPosition])) {<br/>          positions.push(currentPosition + 1);<br/>        }<br/>      }<br/>      return positions.filter(function(position) {<br/>        return !this.matchesPositionWith(correctWord).includes(position);<br/>     }.bind(this));<br/>    }<br/>  }<br/>}</span></pre><p id="eb07" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">就是这样。</p><p id="f924" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们实现了一个非常小的模型，包含了所有有意义的规则。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="81ad" class="ny ms iq nu b gy nz oa l ob oc">All tests have passed 21/21</span></pre><h1 id="26ef" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">玩真实的例子</h1><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="14f4" class="ny ms iq nu b gy nz oa l ob oc">test("test20220911", async function() {<br/>  const correctWord = new Word('tibia');<br/>    // Sorry for the spoiler<br/>  const words = [<br/>    // all the words I've tried<br/>    new Word('paper'), <br/>    new Word('tools'),<br/>    new Word('music'),<br/>    new Word('think'), <br/>    new Word('twins'),<br/>    new Word('tight'),<br/>    // plus the winning word<br/>    correctWord<br/>  ];</span><span id="e27e" class="ny ms iq nu b gy or oa l ob oc">  const game = new Game(words, correctWord);  <br/>  expect(game.hasWon()).toStrictEqual(false);<br/>  expect(game.hasLost()).toStrictEqual(false);<br/>  // P(A)PER vs TIBIA<br/>  game.addAttempt(new Word('paper'));<br/>  expect([]).toStrictEqual((new Word('paper')).matchesPositionWith(correctWord));<br/>  expect([2]).toStrictEqual((new Word('paper')).matchesIncorrectPositionWith(correctWord));<br/>  // [T]OOLS vs TIBIA<br/>  expect([1]).toStrictEqual((new Word('tools')).matchesPositionWith(correctWord));<br/>  expect([]).toStrictEqual((new Word('tools')).matchesIncorrectPositionWith(correctWord));  <br/>  game.addAttempt(new Word('tools'));<br/>  // MUS[I]C vs TIBIA<br/>  expect([4]).toStrictEqual((new Word('music')).matchesPositionWith(correctWord));<br/>  expect([]).toStrictEqual((new Word('music')).matchesIncorrectPositionWith(correctWord));<br/>  game.addAttempt(new Word('music'));<br/>  // [T]H(I)NK vs TIBIA<br/>  expect([1]).toStrictEqual((new Word('think')).matchesPositionWith(correctWord));<br/>  expect([3]).toStrictEqual((new Word('think')).matchesIncorrectPositionWith(correctWord));<br/>  game.addAttempt(new Word('think'));<br/>  // [T]W(I)NS vs TIBIA<br/>  expect([1]).toStrictEqual((new Word('twins')).matchesPositionWith(correctWord));<br/>  expect([3]).toStrictEqual((new Word('twins')).matchesIncorrectPositionWith(correctWord));  <br/>  game.addAttempt(new Word('twins'));  <br/>  expect(game.hasWon()).toStrictEqual(false);<br/>  expect(game.hasLost()).toStrictEqual(false);<br/>  // [T][I]GHT vs TIBIA<br/>  expect([1, 2]).toStrictEqual((new Word('tight')).matchesPositionWith(correctWord));<br/>  expect([]).toStrictEqual((new Word('tight')).matchesIncorrectPositionWith(correctWord));  </span><span id="f0b1" class="ny ms iq nu b gy or oa l ob oc">  game.addAttempt(new Word('tight'));<br/>  expect(game.hasWon()).toStrictEqual(false);<br/>  expect(game.hasLost()).toStrictEqual(true);<br/>});</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/0af3e7dc868524895988211598f531f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*uv2cGmOowTJEqYPd4Y2Whw.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/ac43bb38a21015f284525bd1239afed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*Dd8_skDFFEaUoKdCoLcYVw.png"/></div></figure><p id="3678" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">(你会在回购中找到更多日常例子)</p><h1 id="68e8" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">遵守复杂的规则</h1><p id="164d" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">我对我的工作很满意。</p><p id="7edb" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">然后我读到了<a class="ae lq" href="https://jonahlawrence.hashnode.dev/why-most-wordle-clones-are-wrong" rel="noopener ugc nofollow" target="_blank">它复杂的规则</a></p><p id="4e94" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">当我们有了<a class="ae lq" href="https://blog.devgenius.io/tdd-conference-2021-all-talks-e1eeef89497e" rel="noopener ugc nofollow" target="_blank"> TDD </a>的时候，学习新规则不是问题。</p><p id="845a" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">让我们看看文章中的例子</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="66df" class="ny ms iq nu b gy nz oa l ob oc">test("test25VeryComplexWrongPositions", async function() {</span><span id="ba25" class="ny ms iq nu b gy or oa l ob oc">  const guessWord = new Word('geese');<br/>  const correctWord = new Word('those');<br/>  expect([4, 5]).toStrictEqual(guessWord.matchesPositionWith(correctWord));<br/>  expect(['s','e']).toStrictEqual(guessWord.lettersAtCorrectPosition(correctWord));<br/>  expect([]).toStrictEqual(guessWord.lettersAtWrongtPosition(correctWord));<br/>  expect([]).toStrictEqual(guessWord.matchesIncorrectPositionWith(correctWord));<br/>  // GEE[S][E] vs THOSE</span><span id="6a46" class="ny ms iq nu b gy or oa l ob oc">  const anotherGuessWord = new Word('added');<br/>  const anotherCorrectWord = new Word('dread');<br/>  expect([5]).toStrictEqual(anotherGuessWord.matchesPositionWith(anotherCorrectWord));<br/>  expect(['d']).toStrictEqual(anotherGuessWord.lettersAtCorrectPosition(anotherCorrectWord));<br/>  expect(['a', 'd', 'e']).toStrictEqual(anotherGuessWord.lettersAtWrongtPosition(anotherCorrectWord));<br/>  expect([1, 2, 4]).toStrictEqual(anotherGuessWord.matchesIncorrectPositionWith(anotherCorrectWord));<br/>  // (A)(D)D(E)[D] vs DREAD</span><span id="4e50" class="ny ms iq nu b gy or oa l ob oc">  const yetAnotherGuessWord = new Word('mamma');<br/>  const yetAnotherCorrectWord = new Word('maxim');<br/>  expect([1, 2]).toStrictEqual(yetAnotherGuessWord.matchesPositionWith(yetAnotherCorrectWord));<br/>  expect(['m', 'a']).toStrictEqual(yetAnotherGuessWord.lettersInCorrectPosition(yetAnotherCorrectWord));<br/>  expect(['m']).toStrictEqual(yetAnotherGuessWord.lettersAtWrongtPosition(yetAnotherCorrectWord));<br/>  expect([3]).toStrictEqual(yetAnotherGuessWord.matchesIncorrectPositionWith(yetAnotherCorrectWord));<br/>  // [M][A](M)MA vs MAXIM<br/>});</span></pre><p id="163c" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">让我们从文章中窃取算法</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="1dd0" class="ny ms iq nu b gy nz oa l ob oc">matchesIncorrectPositionWith(correctWord) {     <br/>    const correctPositions = this.matchesPositionWith(correctWord);<br/>    var incorrectPositions = [];<br/>    var correctWordLetters = correctWord.letters();<br/>    var ownWordLetters = this.letters();<br/>    for (var currentPosition = 0; currentPosition &lt; 5; currentPosition++) {<br/>      if (correctPositions.includes(currentPosition + 1)) {<br/>        // We can use these wildcards since they are no valid letters<br/>        correctWordLetters.splice(currentPosition, 1, '*');<br/>        ownWordLetters.splice(currentPosition, 1, '+');<br/>      }<br/>    }    <br/>    for (var currentPosition = 0; currentPosition &lt; 5; currentPosition++) {<br/>      const positionInCorrectWord = correctWordLetters.indexOf(ownWordLetters[currentPosition]);<br/>      if (positionInCorrectWord != -1) {        <br/>        correctWordLetters.splice(positionInCorrectWord, 1, '*');<br/>        ownWordLetters.splice(currentPosition, 1, '+');<br/>        incorrectPositions.push(currentPosition + 1); <br/>      }<br/>    }    <br/>    return incorrectPositions;<br/>  }</span></pre><p id="058f" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们需要添加另一个功能(将用于键盘颜色)</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="7cc6" class="ny ms iq nu b gy nz oa l ob oc">lettersAtCorrectPosition(correctWord) {<br/>    return this.matchesPositionWith(correctWord).map(position =&gt; this.letters()[position -1 ]);<br/>}</span><span id="d4f3" class="ny ms iq nu b gy or oa l ob oc">lettersAtWrongtPosition(correctWord) {<br/>    return this.matchesIncorrectPositionWith(correctWord).map(position =&gt; this.letters()[position -1]);<br/>}</span></pre><h1 id="e10e" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">通知；注意</h1><ul class=""><li id="f610" class="od oe iq kt b ku nj kx nk ln of lo og lp oh lm oi oj ok ol bi translated">当正确的位置匹配时，该算法通过放置“*”来改变正确单词的副本</li><li id="0635" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">它还通过将访问过的字母更改为特殊的(无效)“+”来隐藏它们</li></ul><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="f5f2" class="ny ms iq nu b gy nz oa l ob oc">DREAD vs ADDED<br/>DREA* vs ADDE+<br/>DRE** vs +DDE+<br/>*RE** vs ++DE+<br/>*R*** vs ++D++</span></pre><h1 id="93fc" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">结论</h1><p id="1594" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">这个解决方案与<a class="ae lq" href="https://blog.devgenius.io/how-to-develop-a-wordle-game-using-tdd-in-25-minutes-2157c93dda9f" rel="noopener ugc nofollow" target="_blank">之前的</a>不同，也更完整。</p><p id="1258" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">世界规则没有改变。</p><p id="e761" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">大卫·法利认为，我们需要成为学习专家。</p><p id="4ea2" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们通过练习像这样的形来学习。</p><p id="b490" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">我们以2个紧凑的类结束，在那里我们定义了我们的业务模型。</p><p id="8ec8" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">这个小模型在真实世界的<a class="ae lq" href="https://medium.com/@mcsee/what-is-software-9a78c1172cf9" rel="noopener">映射器</a>中有一个真实的1:1双射。</p><p id="ce1a" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">它准备好进化了。</p><p id="2177" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">这个游戏是真正的软件工程的隐喻。</p><p id="ec71" class="pw-post-body-paragraph kq kr iq kt b ku kv jr kw kx ky ju kz ln lb lc ld lo lf lg lh lp lj lk ll lm ij bi translated">希望你会觉得有趣，跟我学这个形。</p><h1 id="8ef7" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">试试吧！</h1><p id="5ff7" class="pw-post-body-paragraph kq kr iq kt b ku nj jr kw kx nk ju kz ln nl lc ld lo nm lg lh lp nn lk ll lm ij bi translated">你可以玩玩这个工作<a class="ae lq" href="https://replit.com/@mcsee/Wordle-TDD" rel="noopener ugc nofollow" target="_blank">回复</a></p><div class="lr ls gp gr lt lu"><a href="https://replit.com/@mcsee/Wordle-TDD" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd ir gy z fp lz fr fs ma fu fw ip bi translated">Wordle - TDD - Node.js Repl</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">跳到content shields.io，但是对于Replit。我也包括一些其他的东西(用户/回复预览)。无限…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">replit.com</p></div></div><div class="md l"><div class="ou l mf mg mh md mi kl lu"/></div></div></a></div><h1 id="0592" class="mr ms iq bd mt mu no mw mx my np na nb jw nq jx nd jz nr ka nf kc ns kd nh ni bi translated">后续步骤</h1><ul class=""><li id="4021" class="od oe iq kt b ku nj kx nk ln of lo og lp oh lm oi oj ok ol bi translated">将这个解决方案与人工智能生成的</li><li id="b4e8" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">使用真正的字典</li><li id="f823" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">改变语言和字母表。</li><li id="d33a" class="od oe iq kt b ku om kx on ln oo lo op lp oq lm oi oj ok ol bi translated">将规则更改为不同的单词</li></ul></div></div>    
</body>
</html>