<html>
<head>
<title>HTTP/2 in Node.JS Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">节点中的HTTP/2。JS核心</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/http-2-innode-js-core-91eb25e296e8?source=collection_archive---------0-----------------------#2017-11-06">https://levelup.gitconnected.com/http-2-innode-js-core-91eb25e296e8?source=collection_archive---------0-----------------------#2017-11-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e15c798b5d9cb4a51d5ee227fa49d6cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NJWq7rgDciC8vPktP8KfWA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://youtu.be/yToHjxhCeYM" rel="noopener ugc nofollow" target="_blank">http 2的崛起| Daniela Matos de Carvalho | YLDio | empire js Conf 2017</a></figcaption></figure><p id="f57f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">HTTP/2开始被越来越多地使用(它从今年年初的11%跃升至网络总使用量的18%)。如果你还记得我们上一篇关于HTTP/2的博客文章，比如<a class="ae kc" href="https://blog.yld.io/2017/01/10/http-2-a-look-into-the-future-of-the-web" rel="noopener ugc nofollow" target="_blank"> HTTP/2:展望web的未来</a>、<a class="ae kc" href="https://blog.yld.io/2017/02/08/alternatives-to-http" rel="noopener ugc nofollow" target="_blank">HTTP/2的替代方案</a>或<a class="ae kc" href="https://blog.yld.io/2017/03/01/optimize-with-http-2-server-push-and-service-workers" rel="noopener ugc nofollow" target="_blank">用服务器推送和服务工作者进行优化</a>，你可能还记得HTTP/2协议中的一些细节以及与版本1的区别。如果你还没有的话，就去看看吧，因为我们不会在这篇博文中讨论RFC的细节。</p><p id="d253" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们最新的blogposts中，我们提到HTTP/2的一个版本开始在<a class="ae kc" href="https://github.com/nodejs/http2" rel="noopener ugc nofollow" target="_blank"> nodejs/http2 repository </a>下实现，但当时还没有决定它是要合并到Node.js核心模块中，还是作为一个外部模块。拥有一个新实现背后的主要原因是其他实现并不完全遵守<a class="ae kc" href="https://tools.ietf.org/html/rfc7540" rel="noopener ugc nofollow" target="_blank"> HTTP/2 RFC </a>。</p><p id="67e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终，提交了一个<a class="ae kc" href="https://github.com/nodejs/node/pull/14239" rel="noopener ugc nofollow" target="_blank">拉请求</a>以将其添加到核心。它在8月(<a class="ae kc" href="https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V8.md#2017-08-15-version-840-current-addaleax" rel="noopener ugc nofollow" target="_blank">版本8.4.0 </a>)被合并并包含在一个标志(<code class="fe lb lc ld le b">--expose-http2</code>)下作为实验。</p><p id="875c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Twitter宣布该标志将在8.x LTS版本中被移除后，Node.js最终在8.8.0版本中移除了该标志。HTTP/2仍然被认为是实验性的，尽管事实上它还没有100%完成，你已经可以开始用它做实验并查看<a class="ae kc" href="https://nodejs.org/api/http2.html" rel="noopener ugc nofollow" target="_blank"> HTTP/2 API文档</a>。</p><h1 id="bde4" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">四处玩耍</h1><p id="7c9a" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">创建一个HTTP/2服务器应该没有那么难。事实上，如果你已经有了Node.js的经验，它应该和你所熟悉的非常相似。看看下面的例子:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="bebf" class="mq lg iq le b gy mr ms l mt mu"><strong class="le ir">const</strong> http2 = require('http2'),  <br/>  fs = require('fs');</span><span id="f27f" class="mq lg iq le b gy mv ms l mt mu"><strong class="le ir">const</strong> options = {  <br/>  key: fs.readFileSync('keys/server.key'),<br/>  cert: fs.readFileSync('keys/server.crt')<br/>};</span><span id="607d" class="mq lg iq le b gy mv ms l mt mu"><strong class="le ir">const</strong> server = http2.createSecureServer(options);  <br/>server.on('stream', (stream, requestHeaders) =&gt; {  <br/>  stream.respond({<br/>    'content-type': 'text/html',<br/>    ':status': 200<br/>  });<br/>  stream.end('&lt;h1&gt;Hi, and welcome to YLD blog!&lt;/h1&gt;');<br/>});<br/>server.listen(3000);</span></pre><p id="d3e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">主要的区别是我们需要“http2”并向<code class="fe lb lc ld le b">http2.createSecureServer</code>函数发送凭证选项。浏览器只在HTTPS下实现HTTP/2，确保你正在建立一个TLS连接。</p><p id="828b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能已经注意到我们到处都在使用流。然而，有一个<a class="ae kc" href="https://nodejs.org/api/http2.html#http2_compatibility_api" rel="noopener ugc nofollow" target="_blank">兼容API </a>允许从HTTP/1轻松迁移到HTTP/2。这是您设置请求和响应处理程序的方式，因为您已经习惯了:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="8d7e" class="mq lg iq le b gy mr ms l mt mu">// ...</span><span id="0897" class="mq lg iq le b gy mv ms l mt mu"><strong class="le ir">const</strong> onRequestHandler = (req, res) =&gt; {  <br/>  <strong class="le ir">const</strong> { socket: { alpnProtocol } } = req.httpVersion === '2.0' ? req.stream.session : req;<br/>  res.writeHead(200, `Hi, and welcome to YLD blog! The server you are talking with supports ${alpnProtocol} `);<br/>}</span><span id="b9e2" class="mq lg iq le b gy mv ms l mt mu"><strong class="le ir">const</strong> server = http2.createSecureServer(  <br/>  options,<br/>  onRequestHandler<br/>).listen(3000);</span></pre><p id="786b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请求和响应处理程序将按预期工作，尽管事实上它们已经有了HTTP/2额外的信息，例如连接是否使用了<a class="ae kc" href="https://tools.ietf.org/html/rfc7301" rel="noopener ugc nofollow" target="_blank"> ALPN </a>(仅用于HTTP/2)。</p><p id="8891" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">HTTP/2中最有趣的特性之一是服务器推送，推送文件非常简单。在下一个示例中，我们可以看到，每次请求索引路由时，都会推送一个CSS文件:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="4795" class="mq lg iq le b gy mr ms l mt mu"><strong class="le ir">const</strong> onRequestHandler = (req, res) =&gt; {  <br/>  <strong class="le ir">const</strong> currentUrl = url.parse(req.url);</span><span id="66fc" class="mq lg iq le b gy mv ms l mt mu">  <strong class="le ir">if</strong> (currentUrl.pathname === '/') {<br/>    <strong class="le ir">const</strong> cssFile = {<br/>      path: '/style.css',<br/>      filePath: './style.css',<br/>      headers: {<br/>        'content-type': 'text/css'<br/>      }<br/>    };<br/>    pushAsset(res.stream, cssFile);</span><span id="4b41" class="mq lg iq le b gy mv ms l mt mu">    // ...</span></pre><p id="17bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以如下实现<code class="fe lb lc ld le b">pushAsset</code>:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="6e9a" class="mq lg iq le b gy mr ms l mt mu"><strong class="le ir">const</strong> pushAsset = (stream, file) =&gt; {  <br/>  <strong class="le ir">const</strong> filePath = path.join(__dirname, file.filePath);<br/>  stream.pushStream({ [HTTP2_HEADER_PATH]: file.path }, (pushStream) =&gt; {<br/>    pushStream.respondWithFile(filePath, file.headers);<br/>  });<br/>}</span></pre><p id="052b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实上，Node.js API允许您使用<a class="ae kc" href="https://nodejs.org/api/http2.html#http2_http2stream_respondwithfile_path_headers_options" rel="noopener ugc nofollow" target="_blank"> respondWithFile </a>或使用<a class="ae kc" href="https://nodejs.org/api/http2.html#http2_http2stream_respondwithfd_fd_headers_options" rel="noopener ugc nofollow" target="_blank"> respondWithFD </a>的文件描述符来推送文件。<code class="fe lb lc ld le b">file.path</code>在这里非常相关，因为这将是将要被请求的路径。例如，如果<code class="fe lb lc ld le b">/styles/style.css</code>中的窗口请求该文件，则需要相应地修改路径。在我们的情况下，它只是<code class="fe lb lc ld le b">/style.css</code>。请注意，我们可以推送尽可能多的文件，您也可以推送您认为与索引页面相关的内容。查看<a class="ae kc" href="https://github.com/sericaia/http2-examples-empireconf/tree/master/04-server-push" rel="noopener ugc nofollow" target="_blank">完整示例</a>。</p><p id="f54e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还可以像我们在<a class="ae kc" href="https://blog.yld.io/2017/03/01/optimize-with-http-2-server-push-and-service-workers" rel="noopener ugc nofollow" target="_blank">使用服务器推送和服务工作程序优化</a>中所做的那样，使用服务器推送和服务工作程序进行测试。查看一个使用HTTP/2 Node.js核心实现的例子。</p><h1 id="337f" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">框架和预期，敬请关注！</h1><p id="7543" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">坏消息是，像<a class="ae kc" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>或<a class="ae kc" href="https://hapijs.com/" rel="noopener ugc nofollow" target="_blank"> Hapi.js </a>这样的框架还不支持HTTP/2。好消息是，这即将实现，它应该与用于<a class="ae kc" href="https://www.npmjs.com/package/spdy" rel="noopener ugc nofollow" target="_blank"> spdy </a>或Node.js的其他旧HTTP/2模块的实现非常相似</p><p id="76d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想了解这方面的最新信息，请查看以下帖子:</p><p id="29e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">快递:</p><ul class=""><li id="f8a9" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated"><a class="ae kc" href="https://github.com/expressjs/express/issues/3388" rel="noopener ugc nofollow" target="_blank">https://github.com/expressjs/express/issues/3388</a></li><li id="09c0" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><a class="ae kc" href="https://github.com/expressjs/express/pull/3390" rel="noopener ugc nofollow" target="_blank">https://github.com/expressjs/express/pull/3390</a></li><li id="40b8" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><a class="ae kc" href="https://github.com/nodejs/node/issues/15203" rel="noopener ugc nofollow" target="_blank">https://github.com/nodejs/node/issues/15203</a></li></ul><p id="d34e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Hapi.js:</p><ul class=""><li id="bb43" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated"><a class="ae kc" href="https://github.com/hapijs/hapi/issues/2510" rel="noopener ugc nofollow" target="_blank">https://github.com/hapijs/hapi/issues/2510</a></li><li id="bd72" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><a class="ae kc" href="https://github.com/hapijs/hapi/issues/3584" rel="noopener ugc nofollow" target="_blank">https://github.com/hapijs/hapi/issues/3584</a></li></ul><h1 id="46ac" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">想了解更多？</h1><p id="aeef" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">10月13日，我在<a class="ae kc" href="http://2017.empireconf.org/" rel="noopener ugc nofollow" target="_blank"> EmpireConf </a>做了一个关于这个话题的演讲。如果你对此感兴趣，如果你想了解更多关于HTTP/2的知识，请查看我的演讲<a class="ae kc" href="https://www.youtube.com/watch?v=yToHjxhCeYM" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">HTTP/2的兴起</strong> </a> <strong class="kf ir">，我用管弦乐队的比喻解释了HTTP/2！你也可以在github.com/sericaia/http2-examples-empireconf知识库中找到代码示例。</strong></p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="742f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由<a class="ae kc" href="https://twitter.com/sericaia" rel="noopener ugc nofollow" target="_blank">丹妮拉·马托斯·德·卡瓦略</a>出版——YLD<a class="ae kc" href="https://twitter.com/YLDio" rel="noopener ugc nofollow" target="_blank">的软件工程师</a></p></div></div>    
</body>
</html>