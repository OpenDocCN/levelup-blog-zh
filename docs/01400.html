<html>
<head>
<title>TypeScript Advanced Types: Union and Intersection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript高级类型:联合和交集</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-advanced-types-union-and-intersection-types-9283046d7859?source=collection_archive---------0-----------------------#2019-12-23">https://levelup.gitconnected.com/typescript-advanced-types-union-and-intersection-types-9283046d7859?source=collection_archive---------0-----------------------#2019-12-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/bd1188bfcbc309789dc8e7f03a916bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bHaVcFsM8JAbwZMn"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@urimeron?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">URI·梅龙</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="368e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript具有许多高级类型功能，这使得编写动态类型代码变得容易。它还有助于采用现有的JavaScript代码，因为它允许我们在使用TypeScript的类型检查功能的同时保留JavaScript的动态功能。TypeScript中有多种高级类型，如交集类型、联合类型、类型保护、可空类型和类型别名等等。在本文中，我们将研究交集和并集类型。</p><h1 id="a9a4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">交叉点类型</h1><p id="2291" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">交集类型允许我们将多种类型组合成一种类型。具有交集类型的对象的结构必须同时具有构成交集类型的所有类型的结构。它由一个<code class="fe mh mi mj mk b">&amp;</code>符号表示。交集类型的对象中需要所有类型的所有成员。</p><p id="8263" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以在下面的代码中使用交集类型:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b5b4" class="mt lf it mk b gy mu mv l mw mx">interface Animal {<br/>  kind: string;<br/>}</span><span id="fb22" class="mt lf it mk b gy my mv l mw mx">interface Person {<br/>  firstName: string;<br/>  lastName: string;<br/>  age: number;<br/>}</span><span id="b29e" class="mt lf it mk b gy my mv l mw mx">interface Employee {<br/>  employeeCode: string;<br/>}</span><span id="d81f" class="mt lf it mk b gy my mv l mw mx">let employee: Animal &amp; Person &amp; Employee = {<br/>  kind: 'human',<br/>  firstName: 'Jane',<br/>  lastName: 'Smith',<br/>  age: 20,<br/>  employeeCode: '123'<br/>}</span></pre><p id="f507" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上面的代码中我们可以看到，每种类型都用一个<code class="fe mh mi mj mk b">&amp;</code>符号分隔开。同样，<code class="fe mh mi mj mk b">employee</code>对象具有<code class="fe mh mi mj mk b">Animal</code>、<code class="fe mh mi mj mk b">Person</code>和<code class="fe mh mi mj mk b">Employee</code>的所有属性。每个属性都有一个在每个接口中定义的类型。如果结构不完全匹配，那么我们将从TypeScript编译器得到如下的错误消息:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7611" class="mt lf it mk b gy mu mv l mw mx">Type '{ kind: string; firstName: string; lastName: string; age: number; }' is not assignable to type 'Animal &amp; Person &amp; Employee'.</span><span id="2289" class="mt lf it mk b gy my mv l mw mx">Property 'employeeCode' is missing in type '{ kind: string; firstName: string; lastName: string; age: number; }' but required in type 'Employee'.(2322)</span><span id="42cf" class="mt lf it mk b gy my mv l mw mx">input.ts(12, 3): 'employeeCode' is declared here.</span></pre><p id="c47b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们有下面的代码，就会出现上面的错误:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="bbd2" class="mt lf it mk b gy mu mv l mw mx">let employee: Animal &amp; Person &amp; Employee = {<br/>  kind: 'human',<br/>  firstName: 'Jane',<br/>  lastName: 'Smith',<br/>  age: 20  <br/>}</span></pre><p id="72a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript查找<code class="fe mh mi mj mk b">employeeCode</code>属性，因为<code class="fe mh mi mj mk b">employeeCode</code>属性在<code class="fe mh mi mj mk b">Employee</code>接口中。</p><p id="39f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果两个类型有相同的成员名称但不同的类型，那么当它们作为交集类型结合在一起时，它会自动被分配<code class="fe mh mi mj mk b">never</code>类型。这意味着我们不能给它赋值。例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="dbfd" class="mt lf it mk b gy mu mv l mw mx">interface Animal {<br/>  kind: string;<br/>}</span><span id="97cc" class="mt lf it mk b gy my mv l mw mx">interface Person {<br/>  firstName: string;<br/>  lastName: string;<br/>  age: number;<br/>}</span><span id="ca29" class="mt lf it mk b gy my mv l mw mx">interface Employee {<br/>  employeeCode: string;<br/>  age: string;<br/>}</span><span id="aba6" class="mt lf it mk b gy my mv l mw mx">let employee: Animal &amp; Person &amp; Employee = {<br/>  kind: 'human',<br/>  firstName: 'Jane',<br/>  lastName: 'Smith',<br/>  age: 20<br/>}</span></pre><p id="2014" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们从TypeScript编译器得到以下错误:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d035" class="mt lf it mk b gy mu mv l mw mx">Type 'number' is not assignable to type 'never'.(2322)</span><span id="ffce" class="mt lf it mk b gy my mv l mw mx">input.ts(8, 3): The expected type comes from property 'age' which is declared here on type 'Animal &amp; Person &amp; Employee'</span></pre><p id="fb4a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们忽略这个属性，那么编译器也会抛出一个关于<code class="fe mh mi mj mk b">age</code>属性丢失的错误。因此，如果我们想从类型中创建交集类型，就不应该有成员名称相同的类型。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/307b2837193f7c884df486bc6ce7646a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jtKo49Nw1p_FBGrH"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@freestocks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">freestocks.org</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="582f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">工会类型</h1><p id="afb5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">联合类型创建了一个新类型，它允许我们创建具有创建联合类型的每种类型的部分或全部属性的对象。联合类型通过用管道符号<code class="fe mh mi mj mk b">|</code>连接多个来创建。</p><p id="324d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以定义一个具有联合类型的对象，如下面的代码所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8713" class="mt lf it mk b gy mu mv l mw mx">interface Animal {<br/>  kind: string;<br/>}</span><span id="cc39" class="mt lf it mk b gy my mv l mw mx">interface Person {<br/>  firstName: string;<br/>  lastName: string;<br/>  age: number;<br/>}</span><span id="8e5a" class="mt lf it mk b gy my mv l mw mx">interface Employee {<br/>  employeeCode: string;<br/>}</span><span id="4318" class="mt lf it mk b gy my mv l mw mx">let employee: Animal | Person | Employee = {<br/>  kind: 'human',<br/>  firstName: 'Jane',<br/>  lastName: 'Smith',<br/>  age: 20  <br/>}</span></pre><p id="a73e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码有一个<code class="fe mh mi mj mk b">Animal | Person | Employee</code>类型的<code class="fe mh mi mj mk b">employee</code>对象，这意味着它可以拥有<code class="fe mh mi mj mk b">Animal</code>、<code class="fe mh mi mj mk b">Person</code>或<code class="fe mh mi mj mk b">Employee</code>接口的一些属性。不是所有的都必须包含，但是如果包含了，那么类型必须与接口中的类型相匹配。</p><p id="6401" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于联合类型，我们可以有两个成员名称相同但类型不同的类型。例如，如果我们有以下代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5de8" class="mt lf it mk b gy mu mv l mw mx">interface Animal {<br/>  kind: string;<br/>}</span><span id="6dec" class="mt lf it mk b gy my mv l mw mx">interface Person {<br/>  firstName: string;<br/>  lastName: string;<br/>  age: number;<br/>}</span><span id="2302" class="mt lf it mk b gy my mv l mw mx">interface Employee {<br/>  employeeCode: string;<br/>  age: string;<br/>}</span><span id="f0ee" class="mt lf it mk b gy my mv l mw mx">let employee: Animal | Person | Employee = {<br/>  kind: 'human',<br/>  firstName: 'Jane',<br/>  lastName: 'Smith',<br/>  age: '20'<br/>}</span></pre><p id="e2c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以将一个数字或一个字符串赋给<code class="fe mh mi mj mk b">age</code>属性。这符合JavaScript的动态特性，同时允许我们为对象分配数据类型。这不同于传统的面向对象代码，在传统的面向对象代码中，我们可以将公共成员抽象到父类中，然后从中派生出具有专用成员的子类。</p><p id="db46" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">管道符号表示联合类型的对象可以具有每种类型的零个、一些或所有属性。</p><p id="26ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">访问联合类型的对象中的成员不同于从交集类型访问成员。具有交集类型的对象必须在每种类型的成员中列出所有属性，因此从逻辑上讲，我们可以访问对象中定义的所有属性。然而，联合类型就不是这样了，因为某些成员可能只对组成联合类型的某些类型可用。</p><p id="5253" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们有一个联合类型，那么我们只能访问在组成联合类型的所有类型中可用的成员。例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4a6b" class="mt lf it mk b gy mu mv l mw mx">interface Animal {<br/>  kind: string;<br/>}</span><span id="9cd8" class="mt lf it mk b gy my mv l mw mx">interface Person {<br/>  firstName: string;<br/>  lastName: string;<br/>  age: number;<br/>}</span><span id="a749" class="mt lf it mk b gy my mv l mw mx">interface Employee {<br/>  employeeCode: string;<br/>  age: string;<br/>}</span><span id="c304" class="mt lf it mk b gy my mv l mw mx">let employee: Animal | Person | Employee = {<br/>  kind: 'human',<br/>  firstName: 'Jane',<br/>  lastName: 'Smith',<br/>  age: '20'<br/>}</span><span id="f415" class="mt lf it mk b gy my mv l mw mx">console.log(employee)</span></pre><p id="f0a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们不能访问<code class="fe mh mi mj mk b">employee</code>对象的任何属性，因为没有一个成员在所有类型中都可用。如果我们试图访问类似于<code class="fe mh mi mj mk b">kind</code>属性的属性，我们将得到以下错误:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2afa" class="mt lf it mk b gy mu mv l mw mx">Property 'kind' does not exist on type 'Animal | Person | Employee'.</span><span id="d66d" class="mt lf it mk b gy my mv l mw mx">Property 'kind' does not exist on type 'Person'.(2339)</span></pre><p id="6d10" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想让某些属性可访问，我们可以编写类似下面的代码来让我们访问属性:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="348c" class="mt lf it mk b gy mu mv l mw mx">interface Animal {<br/>  kind: string;<br/>}</span><span id="297a" class="mt lf it mk b gy my mv l mw mx">interface Person {<br/>  kind: string;<br/>  firstName: string;<br/>  lastName: string;<br/>  age: number;<br/>}</span><span id="21cb" class="mt lf it mk b gy my mv l mw mx">interface Employee {<br/>  kind: string;<br/>  employeeCode: string;<br/>}</span><span id="8442" class="mt lf it mk b gy my mv l mw mx">let employee: Animal | Person | Employee = {<br/>  kind: 'human',<br/>  firstName: 'Jane',<br/>  lastName: 'Smith',<br/>  age: 20,<br/>  employeeCode: '123'<br/>}</span><span id="0e6f" class="mt lf it mk b gy my mv l mw mx">console.log(employee.kind)</span></pre><p id="cb57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的所有3个接口中，我们都有<code class="fe mh mi mj mk b">kind</code>成员。因为它们存在于我们在union类型中使用的所有3个接口中，所以我们可以访问<code class="fe mh mi mj mk b">employee.kind</code>属性。然后我们会在<code class="fe mh mi mj mk b">console.log</code>语句中得到文本‘人类’。</p><p id="de35" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">交集类型允许我们将多种类型组合成一种类型。具有交集类型的对象的结构必须同时具有构成交集类型的所有类型的结构。它由多个类型通过一个<code class="fe mh mi mj mk b">&amp;</code>符号连接而成。联合类型创建了一个新类型，它允许我们创建具有创建联合类型的每种类型的部分或全部属性的对象。联合类型是通过用管道符号<code class="fe mh mi mj mk b">|</code>连接多个而创建的。它让我们创建一个新类型，该类型具有构成联合类型的每种类型的一些结构。</p></div></div>    
</body>
</html>