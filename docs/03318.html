<html>
<head>
<title>Writing Clean React Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写干净的React代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/writing-clean-react-code-74b42f9cc70c?source=collection_archive---------2-----------------------#2020-05-03">https://levelup.gitconnected.com/writing-clean-react-code-74b42f9cc70c?source=collection_archive---------2-----------------------#2020-05-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4fb442c4b6d9f616f0a0e2b52b404eb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fM3DwXPFGzWHVmVo"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@kimdonkey?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">万基·金</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a7d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">React是一个用于创建应用程序的流行库。虽然库让我们的生活变得更容易，但编写糟糕的代码却很容易让我们的生活变得更艰难。</p><p id="2615" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们将看看如何编写干净的React代码，这样我们的生活最终会更轻松。</p><h1 id="d265" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使反应元件尽可能短</h1><p id="6dee" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">组件应该尽可能的短，这样我们就不会有阅读和重构代码的困难。</p><p id="ce22" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">易读代码易于阅读和理解，易于维护。</p><p id="b474" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">React组件可以轻松扩展到数百甚至数千行代码。这对任何阅读的人来说都将是一场噩梦，而且对如此大的组件进行修改会更加困难。</p><p id="eb98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该将组件重构为尽可能小的部分。如果我们有逻辑，我们应该把它们放到帮助函数中。</p><p id="f1dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">帮助功能可以重用，这就更好了。</p><p id="f93c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以这样做:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="38fb" class="mq lf it mm b gy mr ms l mt mu">import React, { useState, useEffect } from "react";</span><span id="e3d8" class="mq lf it mm b gy mv ms l mt mu">const getPerson = async () =&gt; {<br/>  const res = await fetch("https://api.agify.io?name=michael");<br/>  return res.json();<br/>};</span><span id="11a6" class="mq lf it mm b gy mv ms l mt mu">const Person = () =&gt; {<br/>  const [person, setPerson] = useState({});<br/>  const getData = async () =&gt; {<br/>    const p = await getPerson();<br/>    setPerson(p);<br/>  };<br/>  useEffect(() =&gt; {<br/>    getData();<br/>  }, []);</span><span id="70f8" class="mq lf it mm b gy mv ms l mt mu">  return &lt;p&gt;{person.name}&lt;/p&gt;;<br/>};</span><span id="5ffe" class="mq lf it mm b gy mv ms l mt mu">export default function App() {<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;Person /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="4f21" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有一个<code class="fe mw mx my mm b">getPerson</code>助手函数，它从一个API获取数据，并返回一个我们可以在组件内部使用的承诺。</p><p id="ce8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe mw mx my mm b">Person</code>中，我们调用<code class="fe mw mx my mm b">getData</code>函数中的<code class="fe mw mx my mm b">getPerson</code>帮助函数，这样我们可以将响应数据设置为组件内部的状态并显示出来。</p><p id="9cbc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe mw mx my mm b">App</code>组件内部使用<code class="fe mw mx my mm b">Person</code>组件。这样，组件只有几行长，内部没有很多逻辑。</p><p id="7dfa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个组件中的行数也很少。</p><h1 id="7ab0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">处于同一抽象层次的组件应该在一起</h1><p id="09c7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">同级别的职能应该在一起。这也适用于React组件。</p><p id="a7fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有一个文本编辑器应用程序，它有一个菜单和一个文本编辑器，那么它们应该一起呈现，因为它们都是根级别的UI元素。</p><p id="f1c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写下面的代码来一起呈现它们:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6b95" class="mq lf it mm b gy mr ms l mt mu">import React from "react";</span><span id="e829" class="mq lf it mm b gy mv ms l mt mu">const Menu = () =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;button&gt;Save&lt;/button&gt;<br/>      &lt;button&gt;Close&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="d473" class="mq lf it mm b gy mv ms l mt mu">const TextEditor = () =&gt; {<br/>  return &lt;textarea /&gt;;<br/>};</span><span id="7b8e" class="mq lf it mm b gy mv ms l mt mu">export default function App() {<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;Menu /&gt;<br/>      &lt;TextEditor /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="44a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们用<code class="fe mw mx my mm b">Menu</code>和<code class="fe mw mx my mm b">TextEditor</code>组件将我们的文本编辑器分成两个组件。然后我们在<code class="fe mw mx my mm b">App</code>中把他们两个列入同一级别。</p><p id="b892" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是我们想要的，因为它们都是根级别的UI组件，所以它们应该放在一起放在顶部。</p><p id="c8cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们不这样做，那么我们的大脑会感到困惑，因为如果它们都应该处于最高水平，那么为什么有些组件处于不同的水平呢？</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/abf82286121a0dcd5973f132b0dd5d1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*72Ocju_QJjddlW7Z"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@averieclaire?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> averie woodard </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="f835" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">把道具的数量减到最少</h1><p id="eab7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">函数应该有尽可能少的参数，以使它们易于阅读，并减少在传递参数时出错的机会，如以错误的顺序传递参数或传递错误数据类型的参数等，</p><p id="43ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们应该通过减少传入的道具数量来清理React组件。</p><p id="7555" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b91b" class="mq lf it mm b gy mr ms l mt mu">import React from "react";</span><span id="a386" class="mq lf it mm b gy mv ms l mt mu">const Greeting = ({ greeting, firstName, lastName }) =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      {greeting}, {firstName} {lastName}<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="cad0" class="mq lf it mm b gy mv ms l mt mu">export default function App() {<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;Greeting greeting="hello" firstName="jane" lastName="smith" /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="1c0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当<code class="fe mw mx my mm b">Greeting</code>组件采用3个道具时，我们可以将它们组合如下:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6fd4" class="mq lf it mm b gy mr ms l mt mu">import React from "react";</span><span id="82c6" class="mq lf it mm b gy mv ms l mt mu">const Greeting = ({ greeting, person: { firstName, lastName } }) =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      {greeting}, {firstName} {lastName}<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="10c6" class="mq lf it mm b gy mv ms l mt mu">export default function App() {<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;Greeting<br/>        greeting="hello"<br/>        person={{ firstName: "jane", lastName: "smith" }}<br/>      /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="8cf9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们通过将<code class="fe mw mx my mm b">firstName</code>和<code class="fe mw mx my mm b">lastName</code>组合成<code class="fe mw mx my mm b">person</code>道具，将道具的数量减少到2个。这减少了我们大脑的认知负荷，因为我们只需要看两个道具。</p><p id="79af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mw mx my mm b">Greeting</code>，我们仍然有和以前一样的破坏操作。唯一的区别是我们必须析构<code class="fe mw mx my mm b">person</code>道具，而不是顶层的<code class="fe mw mx my mm b">firstName</code>和<code class="fe mw mx my mm b">lastName</code>。</p><h1 id="d456" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="19b4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">小部件好。它们更容易阅读和修改。</p><p id="9903" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们应该减少组件所用的道具数量，使其更易于阅读。</p><p id="2dcf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，具有相同抽象级别的组件应该在相同的级别上呈现。</p></div></div>    
</body>
</html>