<html>
<head>
<title>Starting my Big-O Journey</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开始我的大O之旅</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/starting-my-big-o-journey-4425081bcb11?source=collection_archive---------8-----------------------#2020-08-28">https://levelup.gitconnected.com/starting-my-big-o-journey-4425081bcb11?source=collection_archive---------8-----------------------#2020-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/828ac924ba043f0d231588818a7d75e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AYekrw1L6CnrUrXG"/></div></figure><div class=""/><p id="9de0" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以，新的大O符号。这是进入Big-O符号之旅的起点的基本分类。</p><p id="28df" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我将围绕几个函数示例来撰写这篇文章。但是首先，大O符号是做什么的？</p><p id="9a8d" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它用于显示您的算法在相对于输入的最差情况下的效率。例如:</p><figure class="kt ku kv kw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ks"><img src="../Images/f1dc275601aebecb37c8192543b08e3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9yBI7XRbLowbex6n-fYQ2A.png"/></div></div></figure><p id="44d3" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">看这个函数。你会认为找到本又快又容易…你是对的！数组中只有一个名字，所以它会非常快地找到它。但是我们需要考虑相对于输入的最坏情况，所以假设这个数组包含了世界上所有的名字，其中只有一个人叫Ben，他在最后面。那么这个函数花费的时间将会非常非常长。</p><p id="407c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Big-O符号将会考虑你的算法运行和完成所花费的时间，以及这个过程所需要的额外空间。算法效率如何？</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="1681" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以我们上面的函数的Big-O符号是O(n)。但是我是怎么知道的呢？什么是(n)？</p><p id="5765" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">(n)代表潜在输入。因此，如果输入是10，那么它将是O(10)，如果我们的输入是1000，它将是O(1000)。我们的函数是一个线性函数，也就是说，对于输入中的每个额外元素，我们的代码都要多运行一次。下图对此进行了解释:</p><figure class="kt ku kv kw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi li"><img src="../Images/5efe5cfc2f149e895e0406a48aca960a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Aj-ra4mQhv_LPfaYMtgAA.png"/></div></div></figure><p id="cf57" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好吧，也许还是有点困惑。这很好。接下来，我将讨论如何计算上面的函数，最后是计算Big-O的任何规则。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="8ab7" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以回到我们的函数。我是如何到达O(n)的？好吧，我已经包含了一些额外的控制台日志来真正强调这一点。在计算Big-O的时候，你需要看看一段代码在函数被调用的时候会运行多少次。让我们来看一下下面的每一行:</p><figure class="kt ku kv kw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi lj"><img src="../Images/e10507739f3b603f055f13056ffba7a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gzrA71G3_mI3_nNGbFwLQQ.png"/></div></div></figure><p id="c51e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当调用该函数时，第一个控制台日志将只运行一次。它不存在于循环中，因此不依赖于数组的长度。第二个控制台日志也是如此。因此，您将它们计为O(1 ),因为它们只运行一次！</p><p id="0929" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后我们遇到了循环。循环依赖于数组长度。因此，正如我们前面提到的，我们用(n)来表示这一点。所以循环中的每一行代码都是O(n ),因为每一行代码将运行(n)或“数组长度”倍。</p><p id="1bae" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是等等…您可能会问，如果Ben是输入中的第一个名字，会发生什么？</p><p id="c9f0" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">计算Big-O时，您应该始终遵循一些规则，其中一条规则是:</p><ol class=""><li id="9c7b" class="lk ll ix jw b jx jy kb kc kf lm kj ln kn lo kr lp lq lr ls bi translated">Big-O只关心最糟糕的情况！</li></ol><p id="0275" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下一个规则允许我得到O(n)的大O，而不是O(3 + 3n)，如上所示。</p><p id="4f85" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">2.移除常数。因此O(3 + 3n)变成O(n)。</p><figure class="kt ku kv kw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi lj"><img src="../Images/5042bb1bfd72314f892c60a43a2f622a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R7kdy_ypD03m2uBbOB0Xfg.png"/></div></div></figure><p id="6fef" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">举这个例子。我们有两个循环函数。它们相互独立，但是bot依赖于数组的长度。尽管有两个独立的循环函数，这条线仍然是线性的。如果有两个名字，每个数组将运行两次，函数本身将总共产生4个操作。直线更陡。</p><p id="3eea" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Big-O关心的是当输入增加时，线条如何移动。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="f804" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">3.输入的不同术语。</p><figure class="kt ku kv kw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi lt"><img src="../Images/343e53224b4692696a34f62a0437c780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GqhVWYkTCxIUNenMce8CbA.png"/></div></div></figure><p id="c809" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里我们又有两个for循环。但是一个在数组上循环，另一个在另一个数组上循环。那么什么是大O呢？</p><p id="12ba" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这种情况下，Big-O是O(a + b)或(n + m)…这是因为循环在不同的项目上循环。第一个数组可以是100个元素，第二个数组可以是1000个元素。但想法是，它们仍然是独立的输入，需要这样对待！</p><p id="bba1" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是等等，如果这些循环嵌套在另一个循环中会怎么样呢？？太好了！这也发生了变化。</p><figure class="kt ku kv kw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi lu"><img src="../Images/98008b4c63b1365b93255cc56f8d386b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LKt2K_ntcKz13WZ2U2N29Q.png"/></div></div></figure><p id="200e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里我们有一个循环在另一个循环中。一个好的经验法则是——如果你看到两个嵌套循环，那么你使用乘法。或者O(n * n)或者O(n)。</p><p id="8cb5" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这叫二次时间。因此，如果我们有2个元素，那么发生的操作数是4。如果我们有3，那么它就变成9，以此类推。因此，如果我们的例子中有一个O(a + b)的大O，那么这个大O就会变成O(a * b)。这并不理想。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="17bc" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">4.丢弃非主导。</p><figure class="kt ku kv kw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi lu"><img src="../Images/e3627f5b189b90a9df1a4da6fb33cf9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tndftZweZnXSCHAI7N8LiA.png"/></div></div></figure><p id="d597" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们举这个例子。在这个函数中，我们有一个独立的循环和一个嵌套在另一个循环中的循环。那么什么是大O呢？如果我们像以前一样处理它，我们会得到O(n + n)，因为第一个循环代表n，第二个嵌套循环是n。</p><p id="59a9" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后我们去掉n，大O变成O(n)。这是因为随着输入数的增加，我们希望看到最差的情况，n比n更差，以O(n + 10n + 1000 + n/2)为例。如果n是3，那么1000是最大的……但是记住最坏情况的规则。如果n是6000会怎么样？那么n显然是占优势的那个。</p><p id="ce2e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就是了。Big-O的四个规则。除了O(n)和O(n ),还有更多Big-O的例子。一个例子是O(1)。我建议你在读完这篇博客后，看看自己是否理解了。这是一个简单的学习方法，因为它是常数。</p><p id="2919" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">祝您好运，感谢您的任何反馈！</p></div></div>    
</body>
</html>