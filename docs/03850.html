<html>
<head>
<title>JavaScript Best Practices — Defining Functions and Calling Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践——定义函数并调用它们</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-defining-functions-and-calling-them-a10b7e6142c1?source=collection_archive---------15-----------------------#2020-05-29">https://levelup.gitconnected.com/javascript-best-practices-defining-functions-and-calling-them-a10b7e6142c1?source=collection_archive---------15-----------------------#2020-05-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/363dae7a45e67a540173adfe7c2d86fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ELbGJjsZdxUZOCzd"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@mbriney?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马特布里内</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="822a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="8ae8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将了解如何在JavaScript代码中定义函数并调用参数数量可变的函数。</p><h1 id="2701" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">永远不要使用函数构造函数来创建新函数</h1><p id="ee23" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在JavaScript中，<code class="fe mh mi mj mk b">Function</code>构造函数让我们定义一个带有参数字符串和函数体的函数。</p><p id="d3ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除最后一个参数外，所有参数都是参数，以字符串形式传入。最后一个参数是函数体，它也作为字符串传入。</p><p id="de34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">Function</code>构造函数返回一个只在全局范围内运行的函数。</p><p id="0322" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以定义一个函数如下:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="fd9c" class="mt lf it mk b gy mu mv l mw mx">const add = new Function('a', 'b', 'return a + b');</span></pre><p id="16af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们用被定义为字符串的参数<code class="fe mh mi mj mk b">a</code>和<code class="fe mh mi mj mk b">b</code>以及函数体<code class="fe mh mi mj mk b">return a + b</code>调用了<code class="fe mh mi mj mk b">Function</code>构造函数。</p><p id="939a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很糟糕，因为一切都被定义为字符串，这意味着它们很难跟踪和调试。此外，有人可能会将恶意字符串传递到<code class="fe mh mi mj mk b">Function</code>构造函数中，从而运行恶意代码。</p><p id="d21e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有返回的函数也在全局范围内运行，这可能不是我们想要的。</p><p id="74ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们不应该运行任何使用<code class="fe mh mi mj mk b">Function</code>构造函数的代码。</p><h1 id="83b6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">函数签名中的间距</h1><p id="0f11" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">函数签名中的间距应该是标准化的和一致的。<code class="fe mh mi mj mk b">function</code>关键字或函数名后面不应该有空格。应该有一个右括号和左花括号。</p><p id="2e33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们应该编写类似下面的代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b08e" class="mt lf it mk b gy mu mv l mw mx">function() {}<br/>function add() {}</span></pre><p id="4088" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们可以很容易地阅读名字，括号也很容易阅读。</p><h1 id="f814" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">永远不要改变参数</h1><p id="6a31" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">改变参数总是不好的。因为对象是通过引用传递的，所以它们也会变异外部变异的参数。</p><p id="4d9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们编写以下代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1efa" class="mt lf it mk b gy mu mv l mw mx">const foo = (a) =&gt; a.foo = 2;<br/>let a = {<br/>  foo: 1<br/>};<br/>foo(a);<br/>console.log(a);</span></pre><p id="9454" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在上面的代码中，我们在我们的<code class="fe mh mi mj mk b">foo</code>函数中有了<code class="fe mh mi mj mk b">a</code>参数。在函数内部，我们将<code class="fe mh mi mj mk b">a.foo</code>设置为2。</p><p id="592d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么当我们用下面的等式定义变量<code class="fe mh mi mj mk b">a</code>时:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="edd6" class="mt lf it mk b gy mu mv l mw mx">{<br/>  foo: 1<br/>}</span></pre><p id="12b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来当我们调用<code class="fe mh mi mj mk b">foo(a)</code>时，我们得到<code class="fe mh mi mj mk b">a</code>是<code class="fe mh mi mj mk b">{foo: 2}</code>，因为我们改变了参数，这被传播到<code class="fe mh mi mj mk b">a</code>变量本身，因为<code class="fe mh mi mj mk b">a</code>是通过引用<code class="fe mh mi mj mk b">foo</code>函数传入的。</p><p id="1e46" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们应该做的是，在函数内部分配属性值变量，然后对其进行变异。</p><p id="3bcf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以这样做:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8b15" class="mt lf it mk b gy mu mv l mw mx">const foo = (a) =&gt; {<br/>  let bar = a.foo;<br/>  bar = 2;<br/>};</span><span id="6cbe" class="mt lf it mk b gy my mv l mw mx">let a = {<br/>  foo: 1<br/>};<br/>foo(a);<br/>console.log(a);</span></pre><p id="20d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们得到<code class="fe mh mi mj mk b">a</code>是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="567c" class="mt lf it mk b gy mu mv l mw mx">{<br/>  foo: 1<br/>}</span></pre><p id="070a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是我们最初传递的内容。在上面的代码中，我们将<code class="fe mh mi mj mk b">a.foo</code>赋值给<code class="fe mh mi mj mk b">bar</code>，并将<code class="fe mh mi mj mk b">bar</code>的值设置为2。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/0f516c6f0e7e029e5091b0846171653c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DgT8fAug_yIq0fV2"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@davidclode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> David Clode </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="537e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">更喜欢使用扩展运算符<code class="fe mh mi mj mk b">... to Call Functions with Variable Number of Parameters</code></h1><p id="016c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">随着spread操作符的引入，我们可以使用它来调用带有可变参数数量的函数，方法是通过spread操作符将数组扩展到方法的参数中。</p><p id="4562" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这比老办法好多了，老办法是在函数上调用<code class="fe mh mi mj mk b">apply</code>来调用参数个数可变的函数。</p><p id="5171" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以调用<code class="fe mh mi mj mk b">Math.max</code>方法从一个数字数组中获取最大数字，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e066" class="mt lf it mk b gy mu mv l mw mx">const max = Math.max(...[1, 2, 3]);</span></pre><p id="baf2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们通过使用spread操作符用一个数组调用了<code class="fe mh mi mj mk b">Math.max</code>。扩展操作符将数组<code class="fe mh mi mj mk b">[1, 2, 3]</code>扩展到<code class="fe mh mi mj mk b">Math.max</code>方法的参数中，</p><p id="7677" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到3作为<code class="fe mh mi mj mk b">max</code>的结果。</p><p id="a1e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这比老方法好多了，老方法是按如下方式使用<code class="fe mh mi mj mk b">apply</code>:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e2cd" class="mt lf it mk b gy mu mv l mw mx">const max = Math.max.apply(undefined, [1, 2, 3]);</span></pre><p id="cdac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们用两个参数调用了<code class="fe mh mi mj mk b">apply</code>，第一个参数是<code class="fe mh mi mj mk b">this</code>的值，它可以是任何值，因为它是一个静态函数，但是我们选择了<code class="fe mh mi mj mk b">undefined</code>。第二个参数是我们想要传递给<code class="fe mh mi mj mk b">Math.max</code>的参数数组。</p><p id="e15d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到同样的结果。正如我们所看到的，这是一个更复杂的方法来获得相同的结果。</p><h1 id="e221" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="99f5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不应该使用<code class="fe mh mi mj mk b">Function</code>构造函数来创建函数。此外，我们应该使用spread操作符来调用参数数量可变的函数，而不是使用<code class="fe mh mi mj mk b">apply</code>。</p></div></div>    
</body>
</html>