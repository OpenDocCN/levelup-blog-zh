<html>
<head>
<title>Performance: FFImageLoading.SVG.Forms vs Xamarin.Forms.Image</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">性能:FImageLoading。SVG.Forms vs Xamarin。表单.图像</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/performance-ffimageloading-svg-forms-vs-xamarin-forms-image-cf47801dfbf6?source=collection_archive---------13-----------------------#2022-03-22">https://levelup.gitconnected.com/performance-ffimageloading-svg-forms-vs-xamarin-forms-image-cf47801dfbf6?source=collection_archive---------13-----------------------#2022-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="71bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你使用SVG图像吗？在这篇文章中，我将比较FFImageLoading。Svg.Forms vs Xamarin。形式。形象表现。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/ad8c85f15a0ad97803501b3c87ebe25a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8Do0iqxgg8-cD4CV.png"/></div></div></figure><p id="65c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我喜欢这个插件。因为它非常容易使用，可能每个Xamarin开发人员都知道它，它有像转换和缓存这样的内置特性。因此，对于嵌入式SVG图像，答案可能是显而易见的:<a class="ae kx" href="https://github.com/luberda-molinet/FFImageLoading/wiki/SVG-support" rel="noopener ugc nofollow" target="_blank">f image loading。Svg.Forms </a>。然而，将我们可爱的插件用于嵌入式矢量图形是个好主意吗？所以让我们通过比较FImageLoading来检查一下。Svg.Forms vs Xamarin。形式。形象表现。</p><h1 id="32f2" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">我们为什么需要它？</h1><p id="49f8" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">有很多事情会让一个移动应用用户不开心。问题可能是由后端，错误，糟糕的用户界面/UX，或者…性能。不像后端或UI/UX可能会超出移动开发者的控制，移动应用的性能是我们的责任，是我们必须关心的事情。当谈到页面之间的导航时，用户最讨厌的问题可能是页面渲染速度。让我们想象一个用户按下按钮导航到另一个页面。用户最不希望看到的就是无响应或延迟。这就是为什么牢记性能并遵循良好实践非常重要。但是，有一个不明显的东西会显著影响页面渲染速度——图像和图标的渲染速度。</p><h1 id="15fa" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">如何测量FImageLoading？Svg.Forms vs Xamarin。形式。形象表现？</h1><p id="3de4" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">为了测量性能，我将把SVG图像添加到一个<a class="ae kx" href="https://docs.microsoft.com/en-us/xamarin/xamarin-forms/user-interface/controls/pages" rel="noopener ugc nofollow" target="_blank"> ContentPage </a>中，以测量页面渲染器创建和页面内容可见之间的时间。之后，将测量两种平台(iOS和Android)和两种方法(Xamarin)的页面加载时间。Forms.Image和FImageLoading。很容易看出哪种方式更快。</p><h1 id="76c2" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">准备</h1><p id="ada9" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我会用Visual Studio 2019 for Mac作为IDE。我也会用两台物理设备来进行测量:<strong class="jp ir"> iPhone SE2 (2020) </strong>和<strong class="jp ir">三星A5 2017 </strong>。图像也是需要的。于是我从网上弄了15个路标的SVG图片。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mb"><img src="../Images/b558fccd407368bc5eca438a497c9b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*H-GuxmegELEsKrGs.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">要显示的图像</figcaption></figure><h1 id="c27b" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第一步。创建应用程序</h1><p id="aa5b" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">现在让我们创建一个空白的Xamarin。窗体应用程序，并向其中再添加一个带有导航的页面。为了在屏幕上显示测量的时间，需要一些标签。最后，让我们安装<a class="ae kx" href="https://www.nuget.org/packages/Xamarin.FFImageLoading.Svg.Forms" rel="noopener ugc nofollow" target="_blank">f image loading。将图像控件添加到StackLayout中。</a></p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="ef8f" class="ml kz iq mh b gy mm mn l mo mp">using Xamarin.Forms;  namespace _2_SVG_XFImage_vs_FFImageLoading <br/>{<br/>     public partial class App : Application<br/>     {<br/>         public App()<br/>         {<br/>             InitializeComponent();<br/>             MainPage = new NavigationPage(new MainPage());<br/>         }<br/>     }<br/> }</span><span id="1a52" class="ml kz iq mh b gy mq mn l mo mp">&lt;ContentPage<br/>     x:Class="_2_SVG_XFImage_vs_FFImageLoading.MainPage"<br/>     <br/>     xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"&gt;     &lt;Button<br/>         Clicked="OnButtonClicked"<br/>         Text="Navigate to Images Page"<br/>         VerticalOptions="Center" /&gt;<br/>&lt;/ContentPage&gt;</span><span id="6f58" class="ml kz iq mh b gy mq mn l mo mp">using System;<br/>using _SVG_XFImage_vs_FFImageLoading;<br/>using Xamarin.Forms;namespace _2_SVG_XFImage_vs_FFImageLoading<br/>{<br/>     public partial class MainPage : ContentPage<br/>     {<br/>         public MainPage()<br/>         {<br/>             InitializeComponent();<br/>         }         private async void OnButtonClicked(Object sender, EventArgs e)<br/>         {<br/>             await Navigation.PushAsync(new ImagesPage());<br/>         }<br/>     }<br/>}</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mb"><img src="../Images/b9b4686080d816f25c075d47716167d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hOFX81rcxqtF9Twb.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">加入Xamarin。FImageLoading.Svg.Forms插件到共享项目</figcaption></figure><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="8551" class="ml kz iq mh b gy mm mn l mo mp">&lt;ContentPage<br/>     x:Class="_SVG_XFImage_vs_FFImageLoading.ImagesPage"<br/>     <br/>     xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"<br/>     xmlns:ffSvg="clr-namespace:FFImageLoading.Svg.Forms;assembly=FFImageLoading.Svg.Forms"&gt;<br/>     &lt;ContentPage.Resources&gt;<br/>         &lt;ResourceDictionary&gt;<br/>             &lt;Style TargetType="ffSvg:SvgCachedImage"&gt;<br/>                 &lt;Setter Property="Aspect" Value="AspectFit" /&gt;<br/>             &lt;/Style&gt;<br/>         &lt;/ResourceDictionary&gt;<br/>     &lt;/ContentPage.Resources&gt;<br/>      &lt;ScrollView&gt;<br/>         &lt;StackLayout Spacing="10"&gt;<br/>             &lt;Label<br/>                 x:Name="measuredTimeLabel"<br/>                 FontSize="Large"<br/>                 HorizontalOptions="Center" /&gt;<br/>             &lt;ffSvg:SvgCachedImage<br/>                 Source="resource://arrowuparrowdownsign.svg" /&gt;<br/>             &lt;ffSvg:SvgCachedImage<br/>                 Source="resource://bicyclesroadsign.svg" /&gt;<br/>             &lt;ffSvg:SvgCachedImage<br/>                 Source="resource://crossingsign.svg" /&gt;<br/>             &lt;ffSvg:SvgCachedImage<br/>                 Source="resource://dangerousbend.svg" /&gt;<br/>             &lt;ffSvg:SvgCachedImage<br/>                 Source="resource://horsesroadsign.svg" /&gt;<br/>             &lt;ffSvg:SvgCachedImage<br/>                 Source="resource://nobicycles.svg" /&gt;<br/>             &lt;ffSvg:SvgCachedImage<br/>                 Source="resource://noentry.svg" /&gt;<br/>             &lt;ffSvg:SvgCachedImage<br/>                 Source="resource://payloadsign.svg" /&gt;<br/>             &lt;ffSvg:SvgCachedImage<br/>                 Source="resource://roadlayoutsign.svg" /&gt;<br/>             &lt;ffSvg:SvgCachedImage<br/>                 Source="resource://roadsignslippery.svg" /&gt;<br/>             &lt;ffSvg:SvgCachedImage<br/>                 Source="resource://tramroadsign.svg" /&gt;<br/>             &lt;ffSvg:SvgCachedImage<br/>                 Source="resource://trucksign.svg" /&gt;<br/>             &lt;ffSvg:SvgCachedImage<br/>                 Source="resource://tunnelroadsign.svg" /&gt;<br/>             &lt;ffSvg:SvgCachedImage<br/>                 Source="resource://warningsign.svg" /&gt;<br/>             &lt;ffSvg:SvgCachedImage<br/>                 Source="resource://yieldroadsign.svg" /&gt;<br/>         &lt;/StackLayout&gt;<br/>     &lt;/ScrollView&gt;<br/>&lt;/ContentPage&gt;</span><span id="3f61" class="ml kz iq mh b gy mq mn l mo mp">using System; using Xamarin.Forms;namespace _SVG_XFImage_vs_FFImageLoading<br/>{<br/>     public partial class ImagesPage : ContentPage<br/>     {<br/>         public ImagesPage()<br/>         {<br/>             InitializeComponent();<br/>         }         public void SetMeasuredTime(TimeSpan measuredTime)<br/>         {<br/>             measuredTimeLabel.Text = $"Measured time is {(int)measuredTime.TotalMilliseconds}ms";<br/>         }<br/>     }<br/>}</span></pre><h1 id="1be0" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第二步。添加ImagePage iOS渲染器</h1><p id="725f" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">现在让我们为ImagesPage创建一个自定义渲染器。总渲染时间将在渲染创建和ViewDidAppear调用之间进行测量。为此，我向_startTime字段写入了一个时间戳，并覆盖了ViewDidAppear方法。不要忘记使用<a class="ae kx" href="https://docs.microsoft.com/en-us/xamarin/xamarin-forms/app-fundamentals/custom-renderer/introduction#creating-a-custom-renderer-class" rel="noopener ugc nofollow" target="_blank"> ExportRenderer属性</a>正确注册渲染器。在覆盖了ViewDidAppear方法之后，就可以使用上一步中的SetMeasuredTime方法来计算时间并将其显示在显示器上了。</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="f257" class="ml kz iq mh b gy mm mn l mo mp">using System;<br/>using _2_SVG_XFImage_vs_FFImageLoading.iOS.Renderers;<br/>using _SVG_XFImage_vs_FFImageLoading;<br/>using Xamarin.Forms;<br/>using Xamarin.Forms.Platform.iOS;[assembly: ExportRenderer(typeof(ImagesPage), typeof(ImagesPageRenderer))]<br/>namespace _2_SVG_XFImage_vs_FFImageLoading.iOS.Renderers<br/>{<br/>     public class ImagesPageRenderer : PageRenderer<br/>     {<br/>         private ImagesPage _imagesPage;<br/>         private TimeSpan _startTime;<br/>         public ImagesPageRenderer() : base()<br/>         {<br/>             _startTime = DateTime.Now.TimeOfDay;<br/>         }<br/>         <br/>         protected override void OnElementChanged(VisualElementChangedEventArgs e)<br/>         {<br/>             base.OnElementChanged(e);<br/>             if (e.NewElement is ImagesPage imagesPage)<br/>             {<br/>                 _imagesPage = imagesPage;<br/>             }<br/>         }<br/>         public override void ViewDidAppear(bool animated)<br/>         {<br/>             base.ViewDidAppear(animated);<br/>             _imagesPage.SetMeasuredTime(DateTime.Now.TimeOfDay - _startTime);<br/>         }<br/>     }<br/>}</span></pre><h1 id="8d7a" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第三步。添加ImagePage Android渲染器</h1><p id="70fc" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">现在让我们为ImagesPage创建一个自定义渲染器。总渲染时间将在渲染创建和ViewDidAppear调用之间进行测量。为此，我向_startTime字段写入了一个时间戳，并覆盖了ViewDidAppear方法。不要忘记使用<a class="ae kx" href="https://docs.microsoft.com/en-us/xamarin/xamarin-forms/app-fundamentals/custom-renderer/introduction#creating-a-custom-renderer-class" rel="noopener ugc nofollow" target="_blank"> ExportRenderer属性</a>正确注册渲染器。在覆盖了ViewDidAppear方法之后，就可以使用上一步中的SetMeasuredTime方法来计算时间并将其显示在显示器上了。</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="b8f4" class="ml kz iq mh b gy mm mn l mo mp">using System;<br/>using _2_SVG_XFImage_vs_FFImageLoading.iOS.Renderers;<br/>using _SVG_XFImage_vs_FFImageLoading;<br/>using Xamarin.Forms;<br/>using Xamarin.Forms.Platform.iOS;[assembly: ExportRenderer(typeof(ImagesPage), typeof(ImagesPageRenderer))]namespace _2_SVG_XFImage_vs_FFImageLoading.iOS.Renderers<br/>{<br/>     public class ImagesPageRenderer : PageRenderer<br/>     {<br/>         private ImagesPage _imagesPage;<br/>         private TimeSpan _startTime;         public ImagesPageRenderer() : base()<br/>         {<br/>             _startTime = DateTime.Now.TimeOfDay;<br/>         }         protected override void OnElementChanged(VisualElementChangedEventArgs e)<br/>         {<br/>             base.OnElementChanged(e);             if (e.NewElement is ImagesPage imagesPage)<br/>             {<br/>                 _imagesPage = imagesPage;<br/>             }<br/>         }         public override void ViewDidAppear(bool animated)<br/>         {<br/>             base.ViewDidAppear(animated);             _imagesPage.SetMeasuredTime(DateTime.Now.TimeOfDay - _startTime);<br/>         }<br/>     }<br/>}</span></pre><h1 id="4186" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第三步。添加ImagePage Android渲染器</h1><p id="c6f2" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">android渲染器的一般思想是相同的:测量渲染创建和页面渲染后立即调用某个本机API之间的时间。然而，Android没有特殊的本机回调或事件来指示视图是否完全出现。在谷歌搜索了一番后，我找到了一个使用<em class="mr"> OnGlobalLayoutListener </em>的建议。</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="c157" class="ml kz iq mh b gy mm mn l mo mp">using System;<br/>using _2_SVG_XFImage_vs_FFImageLoading.Droid.Renderers;<br/>using _SVG_XFImage_vs_FFImageLoading;<br/>using Android.Content;<br/>using Xamarin.Forms;<br/>using Xamarin.Forms.Platform.Android;<br/>using static Android.Views.ViewTreeObserver;[assembly: ExportRenderer(typeof(ImagesPage), typeof(ImagesPageRenderer))]<br/>namespace _2_SVG_XFImage_vs_FFImageLoading.Droid.Renderers<br/>{<br/>     public class ImagesPageRenderer : PageRenderer, IOnGlobalLayoutListener<br/>     {<br/>         private ImagesPage _imagesPage;<br/>         private TimeSpan _startTime;         public ImagesPageRenderer(Context context) : base(context)<br/>         {<br/>             _startTime = DateTime.Now.TimeOfDay;<br/>         }         protected override void OnElementChanged(ElementChangedEventArgs&lt;Page&gt; e)<br/>         {<br/>             base.OnElementChanged(e);             if (e.NewElement is ImagesPage imagesPage)<br/>             {<br/>                 _imagesPage = imagesPage;<br/>                 ViewTreeObserver.AddOnGlobalLayoutListener(this);<br/>             }<br/>         }         public void OnGlobalLayout()<br/>         {<br/>             ViewTreeObserver.RemoveOnGlobalLayoutListener(this);<br/>             _imagesPage.SetMeasuredTime(DateTime.Now.TimeOfDay - _startTime);<br/>         }<br/>     }<br/>}</span></pre><h1 id="43b7" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">图像加载方式的测量</h1><p id="7468" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在共享项目中创建一个“资源”文件夹，并将SVG图像添加到该文件夹中。不要忘记为每个图像资源的“构建动作”属性设置“嵌入资源”值。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/fe7ddc126eae4237e07bfbddc118781a.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/0*MeJosNMI_TitSwne.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">15幅图像在资源文件夹中</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/9526d11f7035a464e42f067098e41a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/0*nnyUdp9u_5EDiyXL.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">设置嵌入式资源构建操作和资源ID</figcaption></figure><p id="7902" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一切准备就绪，可以发射了。我得到的结果在下面的截图上。</p><div class="km kn ko kp gt ab cb"><figure class="mu kq mv mw mx my mz paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><img src="../Images/e673f2664c0f4f8adb9eafcddf34f9f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*ECZfPlElQeAzn-74zIDKxQ.jpeg"/></div></figure><figure class="mu kq na mw mx my mz paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><img src="../Images/9dc8cfa8cfc758f177662db935702e94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*4-Cr5JemsYm_8CYTZvsAdg.jpeg"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk nb di nc nd translated">f图像加载测量结果。iPhone SE2020(左)，三星A5 2017(右)</figcaption></figure></div><h1 id="dc6b" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Xamarin内置方式的测量<br/>步骤1。将SVG图像添加到iOS项目</h1><p id="ff78" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">虽然从iOS 13开始iOS就支持SVG图片了，但是无论是Rider IDE还是Visual Studio IDE，由于某种原因仍然不允许添加SVG图片。然而，我的上一篇文章中提到了一个解决方法。<a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/how-to-svg-as-an-ios-image-asset-in-xamarin-8bcb9d7f901a">阅读它，了解如何将SVG图像资源添加到iOS项目</a>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/497c2177f1cc4207bc3634e780d867ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*eprKL46v44kuCw6B.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">SVG iOS资产</figcaption></figure><h1 id="9e63" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第二步。添加Android矢量图像</h1><p id="747a" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在Android平台上显示SVG图像的原生方式是将SVG图像转换为Android VectorDrawable XML。幸运的是，这种转换真的很容易。我通常用https://svg2vector.com的<a class="ae kx" href="https://svg2vector.com/" rel="noopener ugc nofollow" target="_blank">和T4的</a><a class="ae kx" href="https://svg2vector.com/" rel="noopener ugc nofollow" target="_blank">。所以在转换之后，我将XML添加到Android项目的Resources/drawable文件夹中。请记住:iOS资产和Android drawable的图像名称必须相同。</a></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/c75fa74d8fb9f863d9bd33aa58cc8805.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/0*TbukS-PeuDr5UEED.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">Android drawables</figcaption></figure><h1 id="173d" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第三步。修改表单项目</h1><p id="797a" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">因为我们不再需要SvgCachedImage控件，为了让实验更加清晰，我移除了FFImageLoading。Svg.Forms从项目中获取。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ng"><img src="../Images/ffa8dde677d3066bbf45b6795635416b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VZvAucMnlJ9Us3el.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">卸载FFImageLoading NuGet</figcaption></figure><p id="effe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我需要修改ImagesPage.xaml，如下所示。</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="a8b0" class="ml kz iq mh b gy mm mn l mo mp">&lt;ContentPage<br/>     x:Class="_SVG_XFImage_vs_FFImageLoading.ImagesPage"<br/>     <br/>     xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"&gt;<br/>     &lt;ContentPage.Resources&gt;<br/>         &lt;ResourceDictionary&gt;<br/>             &lt;Style TargetType="Image"&gt;<br/>                 &lt;Setter Property="Aspect" Value="AspectFit" /&gt;<br/>             &lt;/Style&gt;<br/>         &lt;/ResourceDictionary&gt;<br/>     &lt;/ContentPage.Resources&gt;     &lt;ScrollView&gt;<br/>         &lt;StackLayout Spacing="10"&gt;<br/>             &lt;Label<br/>                 x:Name="measuredTimeLabel"<br/>                 FontSize="Large"<br/>                 HorizontalOptions="Center" /&gt;<br/>             &lt;Image Source="arrowuparrowdownsign" /&gt;<br/>             &lt;Image Source="bicyclesroadsign" /&gt;<br/>             &lt;Image Source="crossingsign" /&gt;<br/>             &lt;Image Source="dangerousbend" /&gt;<br/>             &lt;Image Source="horsesroadsign" /&gt;<br/>             &lt;Image Source="nobicycles" /&gt;<br/>             &lt;Image Source="noentry" /&gt;<br/>             &lt;Image Source="payloadsign" /&gt;<br/>             &lt;Image Source="roadlayoutsign" /&gt;<br/>             &lt;Image Source="roadsignslippery" /&gt;<br/>             &lt;Image Source="tramroadsign" /&gt;<br/>             &lt;Image Source="trucksign" /&gt;<br/>             &lt;Image Source="tunnelroadsign" /&gt;<br/>             &lt;Image Source="warningsign" /&gt;<br/>             &lt;Image Source="yieldroadsign" /&gt;<br/>         &lt;/StackLayout&gt;<br/>     &lt;/ScrollView&gt;<br/>&lt;/ContentPage&gt;</span></pre><h1 id="4dfa" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第四步。尺寸</h1><p id="f117" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">现在，我们准备再次启动应用程序并查看结果。附注:我从设备中移除了应用程序的一个先前版本，并为整个解决方案调用了“构建-&gt;全部清理”。</p><p id="c54e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果:</p><div class="km kn ko kp gt ab cb"><figure class="mu kq mv mw mx my mz paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><img src="../Images/47bf32b07d3923a5901e15f428b90297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*gDt2o79XePhpt0BFB7WyzA.jpeg"/></div></figure><figure class="mu kq na mw mx my mz paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><img src="../Images/d26c433a047f0bc20632c1be4da87d70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*-x3USqTBJfH7nd_NalzjUg.jpeg"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk nb di nc nd translated">Xamarin。表格。图像测量结果。iPhone SE2020(左)，三星A5 2017(右)</figcaption></figure></div><h1 id="a395" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nh"><img src="../Images/0ec27b227d0cad95faf691e5cc02aa72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tz6QjRhOGQvn5qY9.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">比较结果</figcaption></figure><p id="3e93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，在iPhone的情况下，几乎没有什么不同。然而，Xamarin。当使用Android矢量可绘制图像时，图像控制方法要快两倍以上。当我之前在其他设备上比较这两种方法时，结果是一样的:在iPhone 8上没有显著差异，但Xamarin有显著差异。谷歌Pixel 5的图像处理速度快了两倍。</p><p id="7c98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，虽然FImageLoading。Svg.Forms是一个很棒且易于使用的插件，当性能很重要时，最好不要将它用于嵌入式矢量图形。</p><p id="2ef2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谢谢你，祝你愉快🙂</p><h1 id="8507" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">将SVG转换为VactorDrawable XML的工具</h1><p id="5fc2" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">安卓工作室指南—<a class="ae kx" href="https://developer.android.com/studio/write/vector-asset-studio#svg" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/Studio/write/vector-asset-Studio # SVG</a><br/><a class="ae kx" href="https://svg2vector.com/" rel="noopener ugc nofollow" target="_blank">https://svg2vector.com</a><br/><a class="ae kx" href="https://inloop.github.io/svg2android/" rel="noopener ugc nofollow" target="_blank">https://inloop.github.io/svg2android/</a></p></div></div>    
</body>
</html>