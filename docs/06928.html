<html>
<head>
<title>Migrating site from Rails to Next.js App — How to add TypeScript, ESLint, CSS Modules, IE11 detection and Contentful integration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将站点从Rails迁移到Next.js应用——如何添加TypeScript、ESLint、CSS模块、IE11检测和内容丰富的集成</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/migrating-site-from-rails-to-next-js-bb8f7632a3ef?source=collection_archive---------15-----------------------#2021-01-12">https://levelup.gitconnected.com/migrating-site-from-rails-to-next-js-bb8f7632a3ef?source=collection_archive---------15-----------------------#2021-01-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d290d943794b79f481da09e7eb4857ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8JA_06dDHSqE5lepoWBa5A.png"/></div></div></figure><div class=""/><p id="0dbb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们希望将我们的营销网站从我们的Rails应用中分离出来的那一天已经到来。我们知道我们想要使用一个React框架，这归结为<a class="ae kz" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>或<a class="ae kz" href="https://www.gatsbyjs.com/" rel="noopener ugc nofollow" target="_blank"> Gatsby。最终，Next.js胜出，因为它具有混合静态和服务器渲染能力。目前，我们网站的大部分内容是静态的，只有几个动态页面。此外，新的</a><a class="ae kz" href="https://nextjs.org/blog/next-10" rel="noopener ugc nofollow" target="_blank"> Next.js 10 </a>功能包括国际化和一个<code class="fe la lb lc ld b">Image</code>组件，该组件通过延迟加载、WebP格式和响应式大小调整来自动优化图像，这些都是我们计划纳入我们网站的迷人功能。</p><p id="c477" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当迁移所有的Rails <code class="fe la lb lc ld b">erb</code>文件以作出反应时，有许多需要改变。我将记录我将Rails文件转换成新创建的Next.js应用程序的过程。我将添加<strong class="kd jf"> TypeScript、ESLint、CSS模块、IE11检测、</strong>和<strong class="kd jf">内容丰富的集成</strong>。我还将讨论我如何使用Next.js <code class="fe la lb lc ld b">Head</code>组件和由Next.js <code class="fe la lb lc ld b">Link</code>组件制成的<strong class="kd jf">路由组件</strong>来制作一个可重用的<strong class="kd jf"> SEO组件</strong>。</p><p id="96fc" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我练习创建<a class="ae kz" href="https://nextjs.org/learn/basics/create-nextjs-app?utm_source=next-site&amp;utm_medium=nav-cta&amp;utm_campaign=next-website" rel="noopener ugc nofollow" target="_blank"> Next.js教程博客应用</a>。这帮助我熟悉了Next.js组件和Next.js应用程序的一般配置。对于我们新的营销网站repo，我使用了<a class="ae kz" href="https://nextjs.org/docs/api-reference/create-next-app" rel="noopener ugc nofollow" target="_blank"> Next.js样板文件</a>。下面的命令将为您生成样板代码。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="4d07" class="lm ln je ld b gy lo lp l lq lr">npx create-next-app</span><span id="b33d" class="lm ln je ld b gy ls lp l lq lr">yarn create next-app</span></pre><p id="92b4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，确保您已经安装了<a class="ae kz" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>。您需要10.13版或更高版本。要启动服务器，运行<code class="fe la lb lc ld b">npm run dev</code>或<code class="fe la lb lc ld b">yarn dev</code>并在浏览器中通过<a class="ae kz" href="http://localhost:3000/contact" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>访问您的开发服务器。</p><p id="f901" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了将Rails <code class="fe la lb lc ld b">erb</code>文件引入Next.js，我从视图中复制了HTML。我保留了我们文件夹的大致结构。在Next.js中，所有页面都是React组件，存放在<code class="fe la lb lc ld b">pages</code>目录中。知道页面路由是基于它们的文件名是很重要的。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/d8af15ca317b26e9241154f36f6bcc45.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*OL7lA07W6Cbh68ECtKfAAA.png"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">文件夹层次结构</figcaption></figure><p id="2561" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当从Rails迁移代码时，会立即出现一些错误并需要更新。<code class="fe la lb lc ld b">erb</code>文件的语法抛出错误，因为<code class="fe la lb lc ld b">class</code>需要改为<code class="fe la lb lc ld b">className</code>。我们所有的营销网站图片都使用我们的CDN来支持我们的网站。因为Next.js的<code class="fe la lb lc ld b">Image</code>组件的<a class="ae kz" href="https://nextjs.org/docs/basic-features/image-optimization" rel="noopener ugc nofollow" target="_blank">图像优化</a>，我们想把它用于我们的图像。用组件替换<code class="fe la lb lc ld b">&lt;img&gt;</code>标签非常简单。下面的<code class="fe la lb lc ld b">&lt;img&gt;</code>标签:</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ly"><img src="../Images/d4cc61cdcb22574502e22572f80e7b28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kbZBddMpYLCpib_hI5aUvA.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated"><img/> HTML标签</figcaption></figure><p id="49bf" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">变成了这个<code class="fe la lb lc ld b">Image</code>组件:</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lz"><img src="../Images/6ecd126b2bd45213922f7276a1657bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yrilEoZmude7OiyxD-3Pjg.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">Next.js图像组件</figcaption></figure><p id="79eb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，这对于绝对定位的图像来说并不理想，因为外部的<code class="fe la lb lc ld b">&lt;div&gt;</code>环绕着实际的图像。下面是使用<code class="fe la lb lc ld b">Image</code>组件的输出示例。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ma"><img src="../Images/2bd7e4f7061a365394ad94ee82b8eba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ea21MjKHKyEU1HfQzmxIQQ.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">图像组件HTML</figcaption></figure><p id="7ecb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，我们没有在Vercel上部署我们的应用程序，因此我们不会自动配置全局CDN或访问图像优化API。当用<code class="fe la lb lc ld b">Image</code>组件构建应用程序时，出现了这个错误。当我移除组件并返回到<code class="fe la lb lc ld b">&lt;img&gt;</code>标签时，构建成功了。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mb"><img src="../Images/0311eb2fd196828dbe27baa2fadea9b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MMq_Ziw3Yrqb5ToQK8DB9A.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">图像组件出现终端错误</figcaption></figure><p id="d71a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，我们能够为托管在外部站点上的图像启用图像优化。为此，您需要在项目的根目录下创建一个<code class="fe la lb lc ld b">next.config.js</code>文件。该文件用于为您的Next.js应用程序定制高级行为。在这里，您将陈述图像<code class="fe la lb lc ld b">src</code>的绝对url，并指出允许优化哪些域。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="09c1" class="lm ln je ld b gy lo lp l lq lr">module.exports = {<br/>  images: {<br/>    domains: ['external.domain.com'],<br/>  }<br/>}</span></pre><p id="10c3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在为我们的表单复制Marketo脚本时，我想我可以像这样在<code class="fe la lb lc ld b">Head</code>组件中添加脚本:</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mc"><img src="../Images/aa71982518405e354bf586af38925bc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EwNY-EG6CrGaXnkb-VQomQ.jpeg"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">Head组件中的Marketo脚本</figcaption></figure><p id="ec60" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，这导致了控制台错误“未捕获的语法错误:意外的标记' &amp; '”我可以通过在Marketo <code class="fe la lb lc ld b">loadForm</code>函数周围添加<code class="fe la lb lc ld b">dangerouslySetInnerHTML</code>来解决这个错误。这允许您直接从React 向<a class="ae kz" href="https://reactjs.org/docs/dom-elements.html" rel="noopener ugc nofollow" target="_blank"> set HTML传递一个对象，在本例中是表单。</a></p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi md"><img src="../Images/41d39ad98dde92f42d2efc5592467fad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qxYCyM7auAwiKuIn5fu4jA.jpeg"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">用dangerouslySetInnerHTML在脚本中包装HTML</figcaption></figure><p id="6df9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于接下来的部分，由于每个部分都有多个步骤，我将分解我是如何添加的:</p><ul class=""><li id="da0c" class="me mf je kd b ke kf ki kj km mg kq mh ku mi ky mj mk ml mm bi translated">打字稿</li><li id="1de1" class="me mf je kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><strong class="kd jf"> ESLint </strong></li><li id="5ed1" class="me mf je kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><strong class="kd jf"> CSS模块</strong></li><li id="4a62" class="me mf je kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><strong class="kd jf"> IE11检测</strong></li><li id="7944" class="me mf je kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><strong class="kd jf">徐老头组件</strong></li><li id="9f22" class="me mf je kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><strong class="kd jf">外部链接组件</strong></li><li id="ee23" class="me mf je kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><strong class="kd jf">内容丰富的整合</strong></li></ul><h1 id="d0ec" class="ms ln je bd mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no bi translated">以打字打的文件</h1><p id="7f87" class="pw-post-body-paragraph kb kc je kd b ke np kg kh ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky im bi translated">开箱即用，Next.js可以与TypeScript集成。首先创建一个<code class="fe la lb lc ld b">tsconfig.json</code>文件。重新启动服务器，您将在终端中收到一条消息，提示您安装TypeScript。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="d426" class="lm ln je ld b gy lo lp l lq lr">npm install --save-dev typescript @types/react @types/node<br/><br/>yarn add --dev typescript @types/react @types/node</span></pre><p id="baf5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，安装完软件包后，重启您的服务器，<code class="fe la lb lc ld b">tsconfig.json</code>文件已经被填充。此外，还创建了<code class="fe la lb lc ld b">next-env.d.ts</code>文件，以便为TypeScript编译器识别类型。一定不要删除！现在您可以将您的<code class="fe la lb lc ld b">.js</code>和<code class="fe la lb lc ld b">.jsx</code>文件更改为<code class="fe la lb lc ld b">.ts</code>和<code class="fe la lb lc ld b">.tsx</code>。</p><h1 id="ac9c" class="ms ln je bd mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no bi translated">埃斯林特</h1><p id="e487" class="pw-post-body-paragraph kb kc je kd b ke np kg kh ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky im bi translated">有多个<a class="ae kz" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> ESLint </a>包可以分析你的代码的一致性并帮助防止错误。这实际上是基于您的偏好、您安装的组件以及您的团队同意的内容。我安装的软件包是:</p><ul class=""><li id="d832" class="me mf je kd b ke kf ki kj km mg kq mh ku mi ky mj mk ml mm bi translated"><code class="fe la lb lc ld b">eslint</code></li><li id="0542" class="me mf je kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><code class="fe la lb lc ld b">babel-eslint</code></li><li id="f0ac" class="me mf je kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><code class="fe la lb lc ld b">eslint-plugin-import</code></li><li id="a3e9" class="me mf je kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><code class="fe la lb lc ld b">eslint-plugin-jsx-a11y</code></li><li id="a274" class="me mf je kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><code class="fe la lb lc ld b">eslint-plugin-react</code></li><li id="91db" class="me mf je kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><code class="fe la lb lc ld b">eslint-plugin-react-hooks</code></li></ul><p id="9d16" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一个很多团队常用的是<code class="fe la lb lc ld b"><a class="ae kz" href="https://www.npmjs.com/package/eslint-config-airbnb" rel="noopener ugc nofollow" target="_blank">eslint-config-airbnb</a></code>。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="1158" class="lm ln je ld b gy lo lp l lq lr">npm install --save-dev babel-eslint eslint eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react eslint-plugin-react-hooks</span><span id="a27a" class="lm ln je ld b gy ls lp l lq lr">yarn add --dev babel-eslint eslint eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react eslint-plugin-react-hooks</span></pre><p id="7143" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦你安装了这些包，你会想要在你的项目的根目录下创建一个<code class="fe la lb lc ld b">.eslintrc.js</code>或者<code class="fe la lb lc ld b">.eslintrc.json</code>文件。在这个文件中，您将指定您的林挺规则。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="01be" class="lm ln je ld b gy lo lp l lq lr">module.exports = {<br/>  env: {<br/>    commonjs: true,<br/>    node: true,<br/>    browser: true,<br/>    es6: true,<br/>    jest: true,<br/>  },<br/>  extends: [<br/>    "eslint:recommended",<br/>    "plugin:jsx-a11y/recommended",<br/>    "plugin:react/recommended",<br/>    "plugin:<a class="ae kz" href="http://twitter.com/typescript" rel="noopener ugc nofollow" target="_blank">@typescript</a>-eslint/recommended"<br/>  ],<br/>  globals: {<br/>    "React": true<br/>  },<br/>  parser: "<a class="ae kz" href="http://twitter.com/typescript" rel="noopener ugc nofollow" target="_blank">@typescript</a>-eslint/parser",<br/>  parserOptions: {<br/>    ecmaFeatures: {<br/>      jsx: true,<br/>    },<br/>    ecmaVersion: 2018,<br/>    sourceType: "module",<br/>  },<br/>  plugins: [<br/>    "react",<br/>    "import",<br/>    "jsx-a11y",<br/>    "react-hooks"<br/>  ],<br/>  ignorePatterns: [<br/>    "node_modules/",<br/>    "out/"<br/>  ],<br/>  rules: {<br/>    "jsx-a11y/anchor-is-valid": 0,<br/>    "react/react-in-jsx-scope": "off",<br/>    "react/no-unescaped-entities": 0,<br/>    "semi": [1, "always"]<br/>  },<br/>  settings: {<br/>    "import/resolver": {<br/>      "node": {<br/>        "extensions": [<br/>          ".js",<br/>          ".jsx",<br/>          ".ts",<br/>          ".tsx"<br/>        ]<br/>      }<br/>    },<br/>    react: {<br/>      version: "latest",<br/>    },<br/>  }<br/>};</span></pre><p id="a8ec" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当您执行<code class="fe la lb lc ld b">yarn export</code>命令时，会生成一个<code class="fe la lb lc ld b">out</code>文件夹，其中包含您提供的所有页面。你会想忽略林挺这个文件夹。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="d5b9" class="lm ln je ld b gy lo lp l lq lr">ignorePatterns: [<br/>  "node_modules/",<br/>  "out/"<br/>]</span></pre><p id="95dc" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你正在使用TypeScript，我建议添加这些<a class="ae kz" href="https://www.npmjs.com/package/@typescript-eslint/eslint-plugin" rel="noopener ugc nofollow" target="_blank">包</a>:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="e0fb" class="lm ln je ld b gy lo lp l lq lr">npm install --save-dev typescript @typescript-eslint/parser<br/>npm install --save-dev @typescript-eslint/eslint-plugin</span><span id="2970" class="lm ln je ld b gy ls lp l lq lr">yarn add -D typescript @typescript-eslint/parser<br/>yarn add -D @typescript-eslint/eslint-plugin</span></pre><p id="e854" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，你需要覆盖<code class="fe la lb lc ld b">react/prop-types</code>，否则linter会大叫“道具验证中缺少X”</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="7a25" class="lm ln je ld b gy lo lp l lq lr">overrides: [<br/>  {<br/>    "files": ["**/*.ts", "**/*.tsx"],<br/>    "rules": {<br/>      "react/prop-types": "off"<br/>    }<br/>  }<br/>]</span></pre><h1 id="3c05" class="ms ln je bd mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no bi translated">CSS模块</h1><p id="e072" class="pw-post-body-paragraph kb kc je kd b ke np kg kh ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky im bi translated">有了Next.js，就没有设置<a class="ae kz" href="https://nextjs.org/docs/basic-features/built-in-css-support" rel="noopener ugc nofollow" target="_blank"> CSS模块</a>的配置了，万岁！它自动基于文件命名约定。</p><p id="755c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您将希望使用这个约定来命名您的组件文件:<code class="fe la lb lc ld b">[component].module.css</code>。如果你用Sass，那就是<code class="fe la lb lc ld b">[component].module.scss</code>。</p><p id="a0c4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当用<a class="ae kz" href="https://github.com/css-modules/css-modules" rel="noopener ugc nofollow" target="_blank"> CSS模块</a>确定组件样式的范围时，你需要在元素类后面加上<code class="fe la lb lc ld b">styles</code>。然后，您必须将样式表导入React组件。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="434e" class="lm ln je ld b gy lo lp l lq lr">import styles from './component.module.scss'</span></pre><p id="3cd7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在声明类名时，有多种方法可以编写CSS模块。首先是点符号:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="5d31" class="lm ln je ld b gy lo lp l lq lr">className={styles.blog}</span></pre><p id="c49e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，如果你的类中有一个连字符呢？你可以用括号符号使类camelCase或kebab case工作。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="fd60" class="lm ln je ld b gy lo lp l lq lr">className={styles.blogTitle}</span><span id="5a1b" class="lm ln je ld b gy ls lp l lq lr">className={styles['blog-title']}</span></pre><p id="e6f9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设您有一个全局样式，您想在一个组件中专门针对它，并对它稍作更改。我发现你可以声明全局类名，但是为了在一个组件中定位它，你必须使用CSS模块。例如，我的目标是我的类<code class="fe la lb lc ld b">flex-half</code>。有一个全球风格，使这个类的宽度为50%。在我的组件中，我想给这个类添加特定的填充。除了使全局类成为CSS模块之外，我还可以通过添加全局类来实现这一点:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="79bc" class="lm ln je ld b gy lo lp l lq lr">className={`flex-half ${styles['flex-half']}`}</span></pre><p id="e8a8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们谈到样式时，Sass在Next.js中很容易设置，并且可以在CSS模块中使用。支持<code class="fe la lb lc ld b">scss</code>和<code class="fe la lb lc ld b">sass</code>扩展。你只需要安装<code class="fe la lb lc ld b">sass</code>。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="0cc8" class="lm ln je ld b gy lo lp l lq lr">npm install sass</span><span id="0368" class="lm ln je ld b gy ls lp l lq lr">yarn add sass</span></pre><h1 id="036c" class="ms ln je bd mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no bi translated"><strong class="ak"> IE11检测</strong></h1><p id="36e9" class="pw-post-body-paragraph kb kc je kd b ke np kg kh ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky im bi translated">令我惊讶的是，当我试图设置这个变量时，我收到了一个控制台错误消息<code class="fe la lb lc ld b">window is not defined</code>。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="9b4e" class="lm ln je ld b gy lo lp l lq lr">const ie11 = window.navigator.userAgent.indexOf('Trident') !== -1;</span></pre><p id="7e33" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">没有定义<code class="fe la lb lc ld b">window</code>,因为Node.js呈现应用程序，并且<code class="fe la lb lc ld b">window</code>对象不能通过Node.js访问。我看到了这篇<a class="ae kz" href="https://morioh.com/p/f7b08fe33a67" rel="noopener ugc nofollow" target="_blank">文章</a>以了解更多关于此的详细信息。</p><p id="c943" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我可以通过使用React <code class="fe la lb lc ld b">useEffect</code>钩子来访问<code class="fe la lb lc ld b">window</code>对象。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nu"><img src="../Images/c5246f8f35290bcfe973be0da7697efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yosT0IesEH9MBeJyZb_Xng.png"/></div></div></figure><p id="dab6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我想在IE11中为特定样式添加CSS回退，所以我能够检查状态以确定浏览器是否是IE11并添加一个<code class="fe la lb lc ld b">class</code>。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nv"><img src="../Images/94914893c2d1c0d81d6671c0114a0ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FYjedGgEZypzR_Pq6PVqNg.png"/></div></div></figure><h1 id="1403" class="ms ln je bd mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no bi translated">SEO组件</h1><p id="2f0f" class="pw-post-body-paragraph kb kc je kd b ke np kg kh ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky im bi translated">非常重要的是，创建这个新的Next.js应用程序不会影响我们的SEO。有一个叫做<a class="ae kz" href="https://www.npmjs.com/package/next-seo" rel="noopener ugc nofollow" target="_blank"> next-seo </a>的通用包，它将带有seo属性的对象传递给页面。然而，我决定自己定制SEO组件。Next.js有一个<code class="fe la lb lc ld b">Head</code>组件，它将元素追加到页面的<code class="fe la lb lc ld b">head</code>中。然后，可以在每个页面上重用该组件，并且可以传递特定的元数据。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="615f" class="lm ln je ld b gy lo lp l lq lr">import Head from 'next/head';</span><span id="295f" class="lm ln je ld b gy ls lp l lq lr">interface MetaProps {<br/>  canonical: string,<br/>  desc: string,<br/>  image: string,<br/>  title: string,<br/>}</span><span id="335b" class="lm ln je ld b gy ls lp l lq lr">const Meta: React.FunctionComponent&lt;MetaProps&gt; = ({<br/>  canonical,<br/>  desc,<br/>  image,<br/>  title,<br/>}) =&gt; {<br/>  return (<br/>    &lt;Head&gt;<br/>      &lt;title&gt;{title}&lt;/title&gt;<br/>      &lt;meta name="description" content={desc} /&gt;<br/>      &lt;meta name="author" content="Brandfolder" /&gt;<br/>      &lt;meta property="og:locale" content="en_US" /&gt;<br/>      &lt;meta property="og:type" content="website" /&gt;<br/>      &lt;meta name="og:title" property="og:title" content={title} /&gt;<br/>      &lt;meta name="og:description" property="og:description" content={desc} /&gt;<br/>      &lt;meta property="og:site_name" content="Brandfolder" /&gt;<br/>      &lt;meta property="og:url" content={canonical} /&gt;<br/>      &lt;meta property="og:image" content={image} /&gt;<br/>      &lt;meta name="twitter:card" content="summary_large_image" /&gt;<br/>      &lt;meta name="twitter:title" content={title} /&gt;<br/>      &lt;meta name="twitter:description" content={desc} /&gt;<br/>      &lt;meta name="twitter:site" content="Brandfolder" /&gt;<br/>      &lt;meta name="twitter:image" content={image} /&gt;<br/>      &lt;link rel="canonical" href={canonical} /&gt;<br/>      &lt;link rel="icon" type="image/png" href="<a class="ae kz" href="https://cdn.bfldr.com/I6FML9WY/at/pglude-85mvp4-f59eh1/favicon-32x32" rel="noopener ugc nofollow" target="_blank">https://cdn.bfldr.com/I6FML9WY/at/pglude-85mvp4-f59eh1/favicon-32x32</a>" /&gt;<br/>    &lt;/Head&gt;<br/>  );<br/>};</span><span id="225f" class="lm ln je ld b gy ls lp l lq lr">export default Meta;</span></pre><h1 id="86fb" class="ms ln je bd mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no bi translated">路由组件</h1><p id="5742" class="pw-post-body-paragraph kb kc je kd b ke np kg kh ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky im bi translated">当在页面之间传送时，需要<code class="fe la lb lc ld b">Link</code>组件。在<code class="fe la lb lc ld b">pages</code>目录中创建的任何文件都有一个可用的路径。嵌套路由还依赖于您在<code class="fe la lb lc ld b">pages</code>目录中的文件结构，因此要明确您的命名。我们的网站上有几个链接，看起来像链接到其他内部页面的按钮，所以我想创建一个可重用的链接组件。使用<code class="fe la lb lc ld b">Link</code>组件的典型页面路由如下所示:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="5fa3" class="lm ln je ld b gy lo lp l lq lr">&lt;Link href="/contact"&gt;<br/>  &lt;a&gt;Contact&lt;/a&gt;<br/>&lt;/Link&gt;</span></pre><p id="44fd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于我想将我的锚标记设计成按钮的样式，并向其传递其他属性，所以我创建了这个<code class="fe la lb lc ld b">LinkButton</code>组件。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="54f6" class="lm ln je ld b gy lo lp l lq lr">import { forwardRef, HTMLProps } from 'react';<br/>import Link from 'next/link';<br/>import styles from './LinkButton.module.scss';</span><span id="de59" class="lm ln je ld b gy ls lp l lq lr">type AnchorLinkProps = HTMLProps&lt;HTMLAnchorElement&gt;</span><span id="4116" class="lm ln je ld b gy ls lp l lq lr">const AnchorLink = forwardRef&lt;HTMLAnchorElement, AnchorLinkProps&gt;((props, ref) =&gt; (<br/>  &lt;a {...props} ref={ref}&gt;<br/>    {props.children}<br/>  &lt;/a&gt;<br/>));<br/>AnchorLink.displayName = 'AnchorLink';</span><span id="bddc" class="lm ln je ld b gy ls lp l lq lr">interface LinkButtonProps {<br/>  href: string,<br/>  link: string,<br/>  buttonStyle?: string,<br/>  size?: string,<br/>  styleClass?: string<br/>}</span><span id="cb9e" class="lm ln je ld b gy ls lp l lq lr">export const LinkButton: React.FunctionComponent&lt;LinkButtonProps&gt; = ({<br/>  href,<br/>  link,<br/>  buttonStyle,<br/>  download,<br/>  size,<br/>  styleClass,<br/>  target<br/>}) =&gt; {<br/>  return (<br/>    &lt;Link href={href} passHref&gt;<br/>      &lt;AnchorLink className={`${styleClass} ${styles.button} ${styles[buttonStyle]} ${styles[size]}`} download={download}&gt;{link}&lt;/AnchorLink&gt;<br/>    &lt;/Link&gt;<br/>  );<br/>};</span></pre><h1 id="de16" class="ms ln je bd mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no bi translated">令人满意的整合</h1><p id="0cf4" class="pw-post-body-paragraph kb kc je kd b ke np kg kh ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky im bi translated">由于内容丰富的集成需要多个设置步骤，我写了一个单独的博客来记录我的过程。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h1 id="88b2" class="ms ln je bd mt mu od mw mx my oe na nb nc of ne nf ng og ni nj nk oh nm nn no bi translated"><strong class="ak">结论</strong></h1><ul class=""><li id="6ca7" class="me mf je kd b ke np ki nq km oi kq oj ku ok ky mj mk ml mm bi translated">从Rails迁移到Next.js是一个漫长的过程，但是如果您了解React，并且已经从以前的代码中构建了视图、部分和组件，那么这是您的Next.js应用程序结构的一个很好的起点。📂</li><li id="76fb" class="me mf je kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">有一些问题，特别是使用<code class="fe la lb lc ld b">Image</code>组件时。我会密切关注何时可以轻松地对这些图像进行绝对定位。🖼此外，路由有一些新的细微差别。就像你的文件在<code class="fe la lb lc ld b">pages</code>文件夹中的命名惯例一样，你的slug和客户端路由需要使用包裹在你的锚标签周围的<code class="fe la lb lc ld b">Link</code>组件。</li><li id="516a" class="me mf je kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">喜欢CSS模块🎨开箱即用，不需要在<code class="fe la lb lc ld b">next.config.js</code>文件中进行配置。</li><li id="1b53" class="me mf je kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">总的来说，Next.js有很好的文档和很大的开发者社区，所以有很多例子和资源。这是一个易于使用的框架，可以快速设置。接下来，我期待着更多地了解他们的国际化路由！🌎</li></ul></div></div>    
</body>
</html>