<html>
<head>
<title>Asynchronous processing of database events in a robust and lightweight manner using django-pgpubsub.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用django-pgpubsub以健壮和轻量级的方式异步处理数据库事件。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/asynchronous-processing-of-database-events-in-a-robust-and-lightweight-manner-using-django-pgpubsub-cfb0dcf12803?source=collection_archive---------4-----------------------#2022-05-13">https://levelup.gitconnected.com/asynchronous-processing-of-database-events-in-a-robust-and-lightweight-manner-using-django-pgpubsub-cfb0dcf12803?source=collection_archive---------4-----------------------#2022-05-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2c59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现代web开发中的一个常见模式是，在一些用户操作或数据库事件之后，需要异步处理数据。在本文中，我们将通过一个具体的例子来描述一种传统的方法，使用<a class="ae kl" href="https://docs.djangoproject.com/en/4.0/topics/signals/" rel="noopener ugc nofollow" target="_blank"> django信号</a>和<a class="ae kl" href="https://docs.celeryq.dev/en/stable/getting-started/introduction.html" rel="noopener ugc nofollow" target="_blank">芹菜信号</a>来解决基于Django/Postgres的应用程序的这个问题。然后，我们将继续讨论这种方法的一些缺点，并演示如何使用<a class="ae kl" href="https://github.com/Opus10/django-pgpubsub" rel="noopener ugc nofollow" target="_blank"> django-pgpubsub </a>来提供一个轻量级的、更健壮的解决方案。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/0a274b19fd58e5ca89264bb624b12420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gfC_lqTZhoP7GllLXswMg.png"/></div></div></figure><h2 id="31f9" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">Easy:一个分享和评论科学文章的平台</h2><p id="ae2f" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">Easy是一个平台，用户可以在这个平台上撰写和发布科学文章，其他用户可以对文章发表评论。Easy的产品负责人想要引入一个新功能:每当有人对一篇文章发表评论时，该文章的作者就会收到一封电子邮件，让他们了解新的评论。</p><p id="4fda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，<em class="lw"> Easy </em>的技术基础设施是由单个Postgres数据库服务的单个django实例。有了这些信息，让我们来探索如何增加对这个新需求的支持。</p><h2 id="027e" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated"><strong class="ak">设置</strong></h2><p id="26f7" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我们有两个简单的Django模型:</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="bc6c" class="ky kz iq ly b gy mc md l me mf"><strong class="ly ir">class </strong>Article(models.Model):<br/>    content = models.TextField()<br/>    user = models.ForeignKey(contrib.auth.models.User)</span><span id="fe4d" class="ky kz iq ly b gy mg md l me mf">class Comment(models.Model):<br/>    content = models.TextField()<br/>    article = models.ForeignKey(Article)<br/>    user = models.ForeignKey(contrib.auth.models.User)</span></pre><p id="d3da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每当用户在帖子上发表评论时，就会创建一个引用登录用户和发表评论的<code class="fe mh mi mj ly b">Article</code>实例的<code class="fe mh mi mj ly b">Comment</code>对象。因此，为了解决新的需求，我们需要找到一种方法，每当一个<code class="fe mh mi mj ly b">Comment</code> is对象被插入到数据库中时，发送一封电子邮件给正确的<code class="fe mh mi mj ly b">User</code>。</p><h2 id="dbf4" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated"><strong class="ak">信号</strong></h2><p id="f3d5" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">Django的<a class="ae kl" href="https://docs.djangoproject.com/en/4.0/topics/signals/" rel="noopener ugc nofollow" target="_blank">信号</a>允许我们在动作发生时调用回调。在我们的例子中，操作是创建一个评论，回调是一个向留下评论的文章作者发送电子邮件的函数。Django内置的<a class="ae kl" href="https://docs.djangoproject.com/en/4.0/ref/signals/#post-save" rel="noopener ugc nofollow" target="_blank"> post_save </a>信号非常适合这种情况:</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="5c5f" class="ky kz iq ly b gy mc md l me mf">from django.db.models.signals import post_save<br/>from django.dispatch import receiver</span><span id="1e24" class="ky kz iq ly b gy mg md l me mf">from email_utils import email</span><span id="f5fe" class="ky kz iq ly b gy mg md l me mf"><br/>@receiver(post_save, sender=Comment)<br/>def email_article_author(sender, instance, **kwargs):<br/>    article_author = instance.post.user<br/>    email(user)</span></pre><p id="86af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过这个简单的添加，我们实际上已经为新的需求设计了一个解决方案。然而，这种解决方案有一个主要缺陷:电子邮件是在与评论创建相同的线程中发送的。这意味着发表评论的用户需要等待电子邮件发送，然后才能收到他们的评论已被保存的通知。此外，它在创建评论时引入了另一个失败点:如果评论碰巧是在一个<a class="ae kl" href="https://docs.djangoproject.com/en/4.0/topics/db/transactions/" rel="noopener ugc nofollow" target="_blank">原子事务</a>中创建的，那么当试图发送电子邮件时遇到的任何错误都将回滚评论的创建。</p><h2 id="f541" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated"><strong class="ak">使用芹菜异步发送电子邮件</strong></h2><p id="7245" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我们需要将电子邮件逻辑移出用户线程，并让它异步发生。人们可以使用python <a class="ae kl" href="https://realpython.com/intro-to-python-threading/" rel="noopener ugc nofollow" target="_blank"> Thread </a>对象来实现这一点，但这将很快耗尽资源。一个常见的选择是使用某种分布式消息处理框架，django应用程序最流行的选择是<a class="ae kl" href="https://docs.celeryq.dev/en/stable/getting-started/introduction.html" rel="noopener ugc nofollow" target="_blank"> Celery </a>。Celery允许我们定义一个辅助进程，专门处理从用户线程接收到的消息。我们不会在这里详细讨论实现，但它可能看起来像这样:</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="4c53" class="ky kz iq ly b gy mc md l me mf"># tasks.py</span><span id="4163" class="ky kz iq ly b gy mg md l me mf">app = Celery('tasks', broker='rabbitmq')</span><span id="bf1e" class="ky kz iq ly b gy mg md l me mf"><strong class="ly ir">@</strong>app.task<br/>def email_user(user):<br/>    email(user)</span><span id="fdf5" class="ky kz iq ly b gy mg md l me mf"># signals.py</span><span id="f296" class="ky kz iq ly b gy mg md l me mf">@receiver(post_save, sender=Comment)<br/>def email_article_author(sender, instance, **kwargs):<br/>    article_author = instance.post.user<br/>    <!-- --># send a message to email_user task running in another process<br/>    email_user.delay(user)<!-- -->  </span></pre><p id="bab3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这个解决方案，我们的电子邮件逻辑现在从评论创建逻辑中分离出来，用同步解决方案解决了前面提到的问题。然而，上述解决方案仍然存在一些严重的缺陷:</p><ul class=""><li id="2ce4" class="mk ml iq jp b jq jr ju jv jy mm kc mn kg mo kk mp mq mr ms bi translated"><strong class="jp ir">信号可能会被错过</strong>:在常规的<code class="fe mh mi mj ly b">Comment.objects.create</code>呼叫之后，总会呼叫一个<code class="fe mh mi mj ly b">post_save</code>信号。当我们通过<code class="fe mh mi mj ly b">Comment.objects.bulk_create</code>批量创建时，它将<em class="lw">而不是</em>被调用。因此，如果在某些时候<em class="lw"> Easy </em>需要批量创建评论(例如，他们可能希望在一段时间内不活动的文章上留下自动评论)，我们的解决方案将意味着这些评论是在没有向文章作者发送邮件的情况下创建的。</li><li id="236e" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated"><strong class="jp ir">与celery沟通增加了另一个失败点:</strong>虽然我们在添加评论时删除了电子邮件作为一个失败点，但是我们引入了与celery(或者更确切地说是经纪人)沟通作为一个失败点。</li><li id="579e" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated"><strong class="jp ir">添加一个芹菜和一个代理在操作上是繁重的:</strong>设置和维护芹菜框架在操作上是昂贵的。对于发送电子邮件这样简单的任务来说，这可能被认为是过分的。</li><li id="599e" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated"><strong class="jp ir">就评论事务</strong>而言，与Celery的通信不是原子的:如果我们的评论是在原子事务中创建的，而该事务恰好在我们的email_user任务被异步调用后<em class="lw">回滚，那么我们最终会在作者的文章没有新评论时向作者发送电子邮件。然而，这可以使用Django的<code class="fe mh mi mj ly b">transaction.on_commit</code>函数来解决，但是很容易忘记包括这一点。</em></li></ul><h2 id="0ff1" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">使用django-pgpubsub异步发送电子邮件</h2><p id="9643" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">现在让我们探索一下<em class="lw"> Easy </em>是如何使用django-pgpubsub(pgpubsub)添加这个新特性的，django-pgpubsub为使用PostgreSQL数据库在django应用程序之上构建异步和分布式消息处理网络提供了一个框架。这是通过利用Postgres的<a class="ae kl" href="https://www.postgresql.org/docs/current/sql-notify.html" rel="noopener ugc nofollow" target="_blank"> LISTEN/NOTIFY </a>协议在数据库层构建消息队列来实现的。</p><p id="2f91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于<em class="lw"> Easy </em>已经在Postgres上运行Django，开始使用pgpubsub(通过<code class="fe mh mi mj ly b">pip install django-pgpubsub</code>安装后)不需要额外的操作工作。这意味着我们可以直接开始编写业务逻辑(关于这里使用的对象和术语的更详细的解释，请参见<a class="ae kl" href="https://github.com/Opus10/django-pgpubsub#documentation-by-example" rel="noopener ugc nofollow" target="_blank">文档</a>):</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="fb6f" class="ky kz iq ly b gy mc md l me mf"># Channels are the medium through which we send notifications<br/># Define a channel in channels.py<br/>from pgpubsub.channels import TriggerChannel</span><span id="2321" class="ky kz iq ly b gy mg md l me mf"><br/>@dataclass<br/>class CommentChannel(TriggerChannel):<br/>    model = Comment<br/>    lockable_notifications = True<br/></span><span id="6bf1" class="ky kz iq ly b gy mg md l me mf"># A <em class="lw">listener</em> is the function which processes notifications sent  <br/># through a channel.<br/># Define a listener function in listeners.py<br/>@pgpubsub.post_insert_listener(CommentChannel)<br/>def email_user(old: Comment, new: Comment):<br/>    email(comment.post.user)</span></pre><p id="9fb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意<strong class="jp ir"> </strong>现在已经从之前的解决方案中丢弃了我们的<code class="fe mh mi mj ly b">post_save</code>信号。正如我们指出的，信号很容易被遗漏(例如被<code class="fe mh mi mj ly b">bulk_create</code>)。相反，我们使用了一个<a class="ae kl" href="https://www.google.com/search?q=postgres+trigger&amp;oq=postgres+trigger&amp;aqs=chrome.0.69i59j35i39j0i512j69i61l2j69i65l2j69i61.2271j0j7&amp;sourceid=chrome&amp;ie=UTF-8" rel="noopener ugc nofollow" target="_blank"> Postgres触发器</a>:如上定义的监听器利用了<a class="ae kl" href="https://github.com/Opus10/django-pgtrigger" rel="noopener ugc nofollow" target="_blank"> django-pgtrigger </a>库来编写一个Postgres触发器到我们的数据库，它的工作是<a class="ae kl" href="https://www.postgresql.org/docs/current/sql-listen.html" rel="noopener ugc nofollow" target="_blank">通知</a>我们的通道，无论何时一个评论被插入到数据库中。对于检测数据库写事件，触发器远比信号更健壮；应用级触发器很容易被遗漏，而触发器总是会被执行。</p><p id="2c9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以上是我们想要的功能所需的所有代码。现在我们需要做的就是启动我们的<em class="lw">监听</em>进程，它的工作是通过我们的<code class="fe mh mi mj ly b">CommentChannel</code>通道监听来自我们的触发器的通知，并将它们交给我们的<code class="fe mh mi mj ly b">email_user</code>监听器函数进行处理。Easy的开发人员决定将服务器的两个进程用于监听和处理电子邮件。这是通过命令实现的</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="0b44" class="ky kz iq ly b gy mc md l me mf">./manage.py listen --processes 2</span></pre><p id="73ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它使用python的<code class="fe mh mi mj ly b">multiprocessing</code>库来启动两个进程，分别用于监听通知和发送电子邮件。</p><p id="78d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该解决方案的一些亮点:</p><ul class=""><li id="9bca" class="mk ml iq jp b jq jr ju jv jy mm kc mn kg mo kk mp mq mr ms bi translated">我们可以肯定django-pgpubsub的<a class="ae kl" href="https://github.com/Opus10/django-pgpubsub#lockable-notifications-and-exactly-once-messaging" rel="noopener ugc nofollow" target="_blank">恰好一次消息传递</a>功能将意味着我们可以让两个进程并行监听同一个通道，而不用担心同一封邮件会被发送两次。</li><li id="832e" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated">由于Postgres <code class="fe mh mi mj ly b">NOTIFY</code>协议尊重它所调用的事务的原子性，当且仅当注释成功保存在数据库中时，才会发送电子邮件。</li><li id="4850" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated">内置的<a class="ae kl" href="https://github.com/Opus10/django-pgpubsub#recovery" rel="noopener ugc nofollow" target="_blank">恢复</a>选项允许我们稍后重放任何未能发送的电子邮件。</li><li id="e3ce" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated">我们没有引入另一个故障点或技术；我们仍然只使用Django和Postgres。</li><li id="102e" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated">如前所述，我们不再担心潜在的信号丢失，因为我们使用的是Postgres触发器。</li></ul><p id="1d2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lw">更多我的作品请看</em><a class="ae kl" href="https://github.com/PaulGilmartin/graph_wrap" rel="noopener ugc nofollow" target="_blank"><em class="lw">https://github.com/PaulGilmartin/</em></a><em class="lw">。</em></p></div></div>    
</body>
</html>