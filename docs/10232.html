<html>
<head>
<title>Improve the performance of your Java programs with string builders</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用字符串生成器提高Java程序的性能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/improve-the-performance-of-your-java-programs-with-string-builders-4c3316ccad55?source=collection_archive---------8-----------------------#2021-11-09">https://levelup.gitconnected.com/improve-the-performance-of-your-java-programs-with-string-builders-4c3316ccad55?source=collection_archive---------8-----------------------#2021-11-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="47cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文激发并解释了StringBuilder类在Java中的使用。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/fa94189b082963a6f7328df6da66be4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pS94dh5jh6ZwzOYT"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://unsplash.com/@steve_j?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯蒂夫·约翰森</a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="9e6b" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">不变性的结果</h1><p id="1db6" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">Java中的字符串是不可变的。这意味着当您给类型为<code class="fe mf mg mh mi b">String</code>的变量重新赋值时，它实际上会创建一个新的<code class="fe mf mg mh mi b">String</code>实例。特别是，当您使用<code class="fe mf mg mh mi b">+=</code>连接两个字符串时，会创建一个新的<code class="fe mf mg mh mi b">String</code>对象。这样做的结果是，像下面这样的程序将在每次迭代中创建一个新对象，并在下一次迭代后将其转储。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="ea07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这会占用堆上的空间，并给垃圾收集器带来更多的工作。</p><p id="7b0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要解决这个问题，建议使用<code class="fe mf mg mh mi b">StringBuilder</code>类代替<code class="fe mf mg mh mi b">String</code>。一个<code class="fe mf mg mh mi b">StringBuilder</code>只不过是一个可变的字符序列。本文的其余部分将展示如何创建字符串生成器，并介绍其中包含的一些方法。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="218c" class="lc ld iq bd le lf ms lh li lj mt ll lm ln mu lp lq lr mv lt lu lv mw lx ly lz bi translated">构造、追加和插入</h1><p id="5f3d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">两个最常见的<code class="fe mf mg mh mi b">StringBuilder</code>构造函数是<code class="fe mf mg mh mi b">StringBuilder()</code>，它创建一个空的字符串生成器，和<code class="fe mf mg mh mi b">StringBuilder(String)</code>，它从一个现有的常规的、不可变的字符串创建一个字符串生成器。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="c685" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">方法<code class="fe mf mg mh mi b">append</code>接受任何类型的参数，并将其附加到字符串生成器。这可能需要:</p><ul class=""><li id="9e4c" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nc nd ne nf bi translated">一个原始类型(<code class="fe mf mg mh mi b">int</code>，<code class="fe mf mg mh mi b">double</code> …)，</li><li id="9451" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">一个对象(它附加了参数的字符串表示，由方法<code class="fe mf mg mh mi b">toString</code>给出)，</li><li id="21e6" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">实现<code class="fe mf mg mh mi b">CharSequence</code>接口的类的实例(例如，另一个字符串生成器)。</li></ul><p id="ccb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似的方法是<code class="fe mf mg mh mi b">insert</code>。它将一个索引和<em class="nl"> something </em>作为参数插入指定的索引(其中<em class="nl"> something </em>与<code class="fe mf mg mh mi b">append</code>的参数类型相同)。<code class="fe mf mg mh mi b">insert</code>抛出一个<code class="fe mf mg mh mi b">StringIndexOutOfBoundsException</code>是指标不在合适的范围内。</p><p id="8a4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="c1fb" class="lc ld iq bd le lf ms lh li lj mt ll lm ln mu lp lq lr mv lt lu lv mw lx ly lz bi translated">基准</h1><p id="fc05" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我在电脑上运行了以下程序:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="5232" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它执行相同的操作两次，一次使用字符串生成器，一次使用不可变字符串。使用字符串生成器需要0.04秒，使用不可变字符串需要6分58.12秒，这表明与字符串生成器相比，连接常规字符串是多么低效。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="72c7" class="lc ld iq bd le lf ms lh li lj mt ll lm ln mu lp lq lr mv lt lu lv mw lx ly lz bi translated">高级方法</h1><p id="8f47" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">本节介绍一些对操作字符串生成器有用的附加方法。</p><p id="383b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mf mg mh mi b">charAt</code>获取一个索引并返回该索引处的字符。如果索引无效，它抛出一个<code class="fe mf mg mh mi b">StringIndexOutOfBoundsException</code>。</p><p id="d4f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mf mg mh mi b">deleteCharAt</code>获取一个索引并删除该索引处的字符。这是破坏性的，但也会返回更新后的字符串生成器:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="0a81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mf mg mh mi b">substring</code>带<code class="fe mf mg mh mi b">int</code>类型的两个参数:<code class="fe mf mg mh mi b">begin</code>和<code class="fe mf mg mh mi b">end</code>。它返回一个<code class="fe mf mg mh mi b">String</code>，对应于从索引<code class="fe mf mg mh mi b">begin</code>开始到索引<code class="fe mf mg mh mi b">end — 1</code>结束的字符串生成器的子字符串。</p><p id="de62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，<code class="fe mf mg mh mi b">delete</code>是一个破坏性的方法，删除从第一个参数(含)给定的索引开始，到第二个参数(不含)给定的索引结束的序列。</p><h1 id="c5da" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">下降趋势</h1><p id="4cfe" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">字符串生成器仍然有一些您需要注意的缺点:</p><ul class=""><li id="8fac" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nc nd ne nf bi translated">可变对象使得代码更难维护，并且可能会发生意外的/不想要的变化；</li><li id="422c" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">它们不是线程安全的，这意味着当多个线程操作单个<code class="fe mf mg mh mi b">StringBuilder</code>实例时，可能会发生意外的行为；</li><li id="b490" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">它们占用了更多的空间，因为它们允许额外的内存，以防我们想给它们添加更多的字符。</li></ul><p id="bf9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一点值得深入探讨一下。字符串生成器的“大小”由两个属性表征:<code class="fe mf mg mh mi b">length</code>和<code class="fe mf mg mh mi b">capacity</code>。<code class="fe mf mg mh mi b">length</code>是它包含的字符数，而<code class="fe mf mg mh mi b">capacity</code>是分配的内存块可以包含的字符总数。当实例化一个新的字符串生成器时，默认情况下它的容量被设置为16个字符。当长度达到容量时，包含字符串生成器的内存块会随着容量的更新而重新分配。</p><p id="1033" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果需要节省空间，可以使用<code class="fe mf mg mh mi b">trimToSize</code>的方法。它调整字符串占用的内存块的大小，使其容量等于实际的字符数。</p><p id="08c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了演示容量和长度是如何演变的，wen可以运行如下程序。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="8017" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它给出以下输出:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><h1 id="e1b0" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><ul class=""><li id="bbdf" class="mx my iq jp b jq ma ju mb jy nm kc nn kg no kk nc nd ne nf bi translated">字符串生成器是Java中常规字符串的可变替代品。</li><li id="9460" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">它们提供了更好的性能，尤其是在执行重复连接时。</li><li id="84f6" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">它们不是线程安全的，并且比不可变字符串占用更多的内存。</li></ul></div></div>    
</body>
</html>