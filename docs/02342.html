<html>
<head>
<title>Use body-parser Express Middleware to Parse Text and URL-Encoded Requests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用body-parser Express中间件来解析文本和URL编码的请求</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/use-body-parser-express-middleware-to-parse-text-and-url-encoded-requests-286d419ce333?source=collection_archive---------3-----------------------#2020-03-07">https://levelup.gitconnected.com/use-body-parser-express-middleware-to-parse-text-and-url-encoded-requests-286d419ce333?source=collection_archive---------3-----------------------#2020-03-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6fcd4f3130237b4ebc9637980f362246.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z_lR8fmI3EbqaOrV"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@jwwhitt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔丹·惠特</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="dccd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">默认情况下，Express 4.x或更高版本没有提供任何解析请求体的功能。因此，我们需要添加一些东西来做到这一点。</p><p id="36d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究如何使用<code class="fe le lf lg lh b">body-parser</code>中间件来处理文本和URL编码的请求体。</p><h1 id="fd73" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">解析文本正文</h1><p id="800e" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以用<code class="fe le lf lg lh b">text</code>方法解析文本请求体。支持<code class="fe le lf lg lh b">gzip</code>和<code class="fe le lf lg lh b">deflate</code>编码的自动膨胀。</p><p id="eb1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解析后的字符串将被设置为<code class="fe le lf lg lh b">req.body</code>的值。</p><p id="3e58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它采用一个可选的<code class="fe le lf lg lh b">option</code>对象，该对象具有以下属性:</p><ul class=""><li id="291a" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">defaultCharset</code> —如果没有在<code class="fe le lf lg lh b">Content-Type</code>标题中指定，则指定文本内容的默认字符集。默认为<code class="fe le lf lg lh b">utf-8</code>。</li><li id="ea8c" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">inflate</code> —当设置为<code class="fe le lf lg lh b">true</code>时，压缩的请求体将膨胀。否则，他们会被拒绝。</li><li id="1ee7" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">limit</code> —控制最大请求正文大小。如果是数字，那就用字节来衡量。如果它是一个字符串，那么它可以被解析成多个字节。</li><li id="ae21" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">type</code> —这用于确定它将解析什么媒体类型。它可以是字符串、字符串数组或函数。如果不是函数，那么就直接传入<code class="fe le lf lg lh b">type-is</code>库。否则，如果调用函数的数据类型返回真值，则解析请求</li><li id="40bd" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">verify</code> —这是一个带有签名<code class="fe le lf lg lh b">(req, res, buf, encoding)</code>的函数，其中<code class="fe le lf lg lh b">buf</code>是原始请求体的缓冲对象。解析可以通过在函数中抛出一个错误来中止。</li></ul><p id="d662" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="c37c" class="nh lj it lh b gy ni nj l nk nl">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();<br/>const options = {<br/>  inflate: true,<br/>  limit: 1000,<br/>  defaultCharset: 'utf-8'<br/>};<br/>app.use(bodyParser.text(options));</span><span id="d1e0" class="nh lj it lh b gy nm nj l nk nl">app.post('/', (req, res) =&gt; {<br/>  res.send(req.body);<br/>});</span><span id="5d64" class="nh lj it lh b gy nm nj l nk nl">app.listen(3000);</span></pre><p id="542a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后当我们用主体<code class="fe le lf lg lh b">foo</code>向<code class="fe le lf lg lh b">/</code>发出POST请求时，我们得到<code class="fe le lf lg lh b">foo</code>的返回。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/524a5ede24ec58725e6f080d8b46402b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O5u2LN85e9pFgVmf"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@shuxin00?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ellicia </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="0d31" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">解析URL编码的请求正文</h1><p id="54d7" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以使用<code class="fe le lf lg lh b">urlencoded</code>方法来解析URL编码体。支持<code class="fe le lf lg lh b">gzip</code>和<code class="fe le lf lg lh b">deflate</code>编码的自动膨胀。</p><p id="268d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解析后的请求体将被设置为<code class="fe le lf lg lh b">req.body</code>的值。该对象将包含键值对，当<code class="fe le lf lg lh b">extended</code>设置为<code class="fe le lf lg lh b">false</code>或其他值时，该值可以是字符串或数组。</p><p id="4856" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它采用一个可选的<code class="fe le lf lg lh b">option</code>对象，该对象具有以下属性:</p><ul class=""><li id="a7d7" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">extended</code>—<code class="fe le lf lg lh b">extended</code>选项允许我们选择在<code class="fe le lf lg lh b">false</code>时使用<code class="fe le lf lg lh b">querystring</code>库解析URL编码的数据，或者在设置为<code class="fe le lf lg lh b">true</code>时使用<code class="fe le lf lg lh b">qs</code>库。<code class="fe le lf lg lh b">extended</code>语法允许我们对丰富的对象和数组进行编码，允许使用URL编码的类似JSON的体验。默认值为<code class="fe le lf lg lh b">true</code>，但使用默认值已被否决。</li><li id="4464" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">inflate</code> —当设置为<code class="fe le lf lg lh b">true</code>时，压缩的请求体将膨胀。否则，他们会被拒绝。</li><li id="5a00" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">limit</code> —控制最大请求正文大小。如果是数字，那就用字节来衡量。如果它是一个字符串，那么它可以被解析成多个字节。</li><li id="d71d" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">parameterLimit</code> —让我们控制URL编码数据中允许的最大数量。如果超过给定值，将返回413响应代码。默认值为1000。</li><li id="04eb" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">type</code> —这用于确定它将解析什么媒体类型。它可以是字符串、字符串数组或函数。如果不是函数，那么就直接传入<code class="fe le lf lg lh b">type-is</code>库。否则，如果调用函数的数据类型返回真值，则解析请求</li><li id="d37d" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">verify</code> —这是一个带有签名<code class="fe le lf lg lh b">(req, res, buf, encoding)</code>的函数，其中<code class="fe le lf lg lh b">buf</code>是原始请求体的缓冲对象。解析可以通过在函数中抛出一个错误来中止。</li></ul><p id="eb78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="f85d" class="nh lj it lh b gy ni nj l nk nl">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();<br/>const options = {<br/>  inflate: true,<br/>  limit: 1000,<br/>  extended: true<br/>};<br/>app.use(bodyParser.urlencoded(options));</span><span id="d6ca" class="nh lj it lh b gy nm nj l nk nl">app.post('/', (req, res) =&gt; {<br/>  res.send(req.body);<br/>});</span><span id="46a2" class="nh lj it lh b gy nm nj l nk nl">app.listen(3000);</span></pre><p id="4cb9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们用正文<code class="fe le lf lg lh b">name=Mary&amp;age=10</code>向<code class="fe le lf lg lh b">/</code>路由发送一个URL编码的POST正文时，我们得到:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="c2ac" class="nh lj it lh b gy ni nj l nk nl">{"name":"Mary","age":"10"}</span></pre><p id="8891" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过发送以下命令来发送数组:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="5eca" class="nh lj it lh b gy ni nj l nk nl">name=Mary&amp;age=10&amp;favoriteFood=apple&amp;favoriteFood=orange</span></pre><p id="1ba6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们回来了:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="7715" class="nh lj it lh b gy ni nj l nk nl">{"name":"Mary","age":"10","favoriteFood":["apple","orange"]}</span></pre><p id="aee2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为回应。这里假设<code class="fe le lf lg lh b">extends</code>是<code class="fe le lf lg lh b">true</code>。</p><p id="4f97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们将<code class="fe le lf lg lh b">parameterLimit</code>设置为1，如下所示:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="2d96" class="nh lj it lh b gy ni nj l nk nl">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();<br/>const options = {<br/>  inflate: true,<br/>  limit: 1000,<br/>  extended: true,<br/>  parameterLimit: 1,<br/>};<br/>app.use(bodyParser.urlencoded(options));</span><span id="e5d0" class="nh lj it lh b gy nm nj l nk nl">app.post('/', (req, res) =&gt; {<br/>  res.send(req.body);<br/>});</span><span id="77b6" class="nh lj it lh b gy nm nj l nk nl">app.listen(3000);</span></pre><p id="1596" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到一个413错误。</p><h1 id="e280" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="32d7" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">使用<code class="fe le lf lg lh b">text</code>方法，<code class="fe le lf lg lh b">body-parser</code>可以解析文本请求体。我们将通过<code class="fe le lf lg lh b">req.body</code>获得一个带有已解析主体的字符串。</p><p id="7766" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了解析URL编码的请求体，我们可以使用<code class="fe le lf lg lh b">urlencoded</code>方法。它可以解析数组和对象。URL编码的主体作为查询字符串发送，我们可以多次发送具有相同键的查询，使其被解析为数组。</p></div></div>    
</body>
</html>