<html>
<head>
<title>Actor-Model System with Akka.NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Akka演员模型系统。网</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/actor-model-system-with-akka-net-e86fac9743be?source=collection_archive---------11-----------------------#2021-05-14">https://levelup.gitconnected.com/actor-model-system-with-akka-net-e86fac9743be?source=collection_archive---------11-----------------------#2021-05-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/00c26dfc63329e53c1b08874b30de643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ol8fDYRx4CxKM9-4BtFEQ.png"/></div></div></figure><div class=""/><div class=""><h2 id="ba8a" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">如何使用Akka实现演员模型系统和处理并发性？网</h2></div><p id="4de0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在这篇文章中，我们将看看演员模型系统。</p><p id="81b0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们将从解释什么是演员和它能做什么开始。然后，讨论将进入演员模型系统的历史，它们与竞争对手的解决方案有何不同，以及一些可能非常适合这种模型的潜在场景。</p><p id="5566" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们还将回顾一个特定的演员系统，Akka.NET，并检查演员之间的层次和沟通——也许是演员系统的两个最重要的方面。</p><h1 id="59c0" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">演员模式是什么？</h1><p id="f7e9" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">所谓的actor模型是一个并发计算的数学模型，它在1973年作为一个理论概念首次进入技术领域。它通过制定系统组件(称为参与者)在并发计算环境中应该如何交互的一般准则来运行。actor模型的两个最著名的实现是Akka和Erlang。</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mm"><img src="../Images/d130a19942f7b74db8d4b8b139e31fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*E-RRfh1t8sZGuQOs.png"/></div></div></figure><p id="817c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在编写并发和分布式系统时，actor模型允许更高层次的抽象。它使开发人员不必处理显式锁定和线程管理，从而更容易编写并发和并行系统。</p><h1 id="aaa2" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">为什么是阿卡。网？</h1><p id="a60b" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">此时，您可能想知道我们是否首先需要另一个并发模型。没有。NET已经有了自己的并发线程模型？</p><p id="52d5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">不完全是。你看，在。网络世界很有挑战性。它需要多线程代码，这很难编写、测试和调试。</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/d124c68ec0a5b7c2390e3d8ecf244673.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/0*vZY4jiODc6mt5VCC.png"/></div></figure><p id="237c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">actor模型的优点之一是它的通用原语是actor。为了实现并发性，您至少需要几个相互通信的参与者。</p><p id="f546" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">你可以把一个演员想象成记忆中的一个对象——但是要记住，它不同于你可能想到的通常的对象。像每个对象一样，参与者也有状态和行为。然而，让它与众不同的是它的邮箱，这是与演员交流的唯一方式。例如，除了向邮箱发送消息并触发消息返回给您之外，没有其他方法可以读取参与者状态。</p><p id="3b58" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这里需要注意的是，每个参与者一次只能处理一条消息。如果你看一下左边的图片，你会看到当邮箱中有几个消息时，参与者会一个接一个地处理它们。</p><p id="cdc0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">乍一看，这种设置可能会让你觉得很奇怪。一次只处理一条消息难道不违背并发系统的概念吗？</p><p id="4837" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">不完全是。</p><p id="db7a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">Actor系统通过在尽可能多和尽可能小的actor之间分配工作来实现有效的并发。在上图中，您可以看到该演员有一个父演员和子演员P1、P2和P3。系统中的每个参与者都可以创建多个子参与者，以便更有效地分配工作。</p><h1 id="31d4" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">演员能为你的系统做什么？</h1><p id="8f7e" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">除了创建子执行元，执行元还处理来自邮箱的消息。对于收到的每条消息，参与者必须决定是否:</p><ul class=""><li id="84ee" class="ms mt je kv b kw kx kz la lc mu lg mv lk mw lo mx my mz na bi translated">更新内部状态</li><li id="9f41" class="ms mt je kv b kw nb kz nc lc nd lg ne lk nf lo mx my mz na bi translated">执行特定的操作，比如通过API进行外部通信、写入数据库或发送HTTP请求</li><li id="5d61" class="ms mt je kv b kw nb kz nc lc nd lg ne lk nf lo mx my mz na bi translated">向不同的演员发送新消息</li><li id="2d6b" class="ms mt je kv b kw nb kz nc lc nd lg ne lk nf lo mx my mz na bi translated">回复发件人0次或更多次</li></ul><h1 id="0723" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">什么是演员制度？</h1><p id="6a86" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">简单来说，演员系统就是演员生活的地方。就Akka.NET而言，框架提供了行为者系统。</p><p id="af32" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您可以使用执行元系统来管理以下事项:</p><ul class=""><li id="0cf8" class="ms mt je kv b kw kx kz la lc mu lg mv lk mw lo mx my mz na bi translated">演员生命周期</li><li id="2a21" class="ms mt je kv b kw nb kz nc lc nd lg ne lk nf lo mx my mz na bi translated">信息发送</li><li id="4913" class="ms mt je kv b kw nb kz nc lc nd lg ne lk nf lo mx my mz na bi translated">收件箱</li></ul><p id="fa56" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">从开发的角度来看，拥有一个透明且易于跟踪的actor系统是件好事，因为这有助于在以后尝试诊断问题时节省时间。</p><p id="392b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们考虑一个实际的例子。在下面的截图中，您可以看到使用Akka.NET创建的酒店房间预订的预订执行元。actor是C# class，它继承自框架提供的一个类:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mm"><img src="../Images/ccb4213e239e7809b47753cad971a452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*j6hRI3jy7G6E7TQ9.png"/></div></div></figure><p id="e952" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">本例中的参与者是接收参与者，这意味着您必须定义它将处理什么类型的消息。</p><p id="da0c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如您所见，参与者将收到三种类型的消息:</p><ul class=""><li id="cf74" class="ms mt je kv b kw kx kz la lc mu lg mv lk mw lo mx my mz na bi translated"><em class="ng">预定房间</em></li><li id="1100" class="ms mt je kv b kw nb kz nc lc nd lg ne lk nf lo mx my mz na bi translated"><em class="ng">客房预订</em></li><li id="56bb" class="ms mt je kv b kw nb kz nc lc nd lg ne lk nf lo mx my mz na bi translated"><em class="ng"> RoomBusy </em></li></ul><p id="2535" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">要定义这些，需要在actor类的构造函数中调用Receive it is <em class="ng"> typed method) </em>。模板参数决定了参与者将处理的消息类型。作为参数，Receive接受一个函数，该函数反过来定义当有特定类型的传入消息时会发生什么。</p><p id="fae0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">请注意，当一个参与者收到一个没有定义函数的消息时，该消息将被忽略。例如，如果参与者收到A类消息，它将忽略它。</p><p id="5104" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">上面的例子也有助于展示参与者如何处理并发问题。</p><p id="362f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">想象一下，两个人试图同时预订同一个房间。在我们的例子中，我们可以通过同时为房间1发送两条<em class="ng"> BookTheRoom </em>消息来实现这一点。消息将在邮箱中排队，预订角色将逐个处理它们。例如，这样就不需要担心使用互斥锁来锁定参与者的共享状态。</p><h1 id="d6e4" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">如何在Akka打造演员体系？网</h1><p id="0972" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">为了创建一个actor系统，我们在<em class="ng"> ActorSystem </em>类上调用静态方法。框架提供了<em class="ng"> ActorSystem </em>类。为了调用这个方法，您需要传递系统的名称(参见下面的第一行代码)。一旦创建了系统，就可以开始创建参与者了。</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mm"><img src="../Images/53bffdcc348d83a788da24787a3c3784.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GEgAEtbV2gBvd0wT.png"/></div></div></figure><p id="2e72" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">值得一提的是，这个actor方法返回的，是一个代理。这是为了确保没有人能够访问actor状态。</p><p id="2f7f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如上所述，我们可以使用方法向参与者发送消息。消息发送后，将执行中的功能。</p><p id="8268" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">接下来，让我们假设示例中的可用房间已经被成功预订。我们现在想发送同样的消息给，比如说，一个付费演员。通过在reservation actor中创建子actor和队列，我们可以使用<em class="ng">上下文属性</em>向子actor发送消息。要创建子参与者，您总是需要使用框架提供的上下文属性。见下文:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mm"><img src="../Images/cde010265f9bc3bbe56e74a99f8daf1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TGB3dRYGqNzrGqIP.png"/></div></div></figure><h1 id="2cdb" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">演员之间的等级和交流</h1><p id="bf88" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">如前所述，系统中的参与者会形成一个层级。位于层次结构顶端的主要参与者由框架提供。在这种情况下，框架是Akka.NET。该执行元将成为您可能创建的所有其他执行元的父级。因此，即使您创建了一级参与者，父级仍然是框架提供的主要参与者。</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/1bdec106d83e5c1126a3cc7f8aaad2ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/0*_WImZ-kPc7gGOZc-.png"/></div></figure><h1 id="528e" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">演员之间的等级制度</h1><p id="6192" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">与演员交流有两种方法。</p><p id="d5e4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">层次结构中的每个参与者都有一个唯一的标识地址。如果某个参与者知道其他参与者各自的地址，它就可以与其他参与者直接通信。</p><p id="c5ca" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在上图中，如果参与者A1知道其地址，则参与者C1可以与它通信，即使后者不是参与者c的子代</p><p id="48b8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">阿卡。NET提供了位置透明性，这意味着只要知道参与者的地址，他住在哪里并不重要。这很有用，因为它允许您毫无问题地将参与者分布到不同的机器上。</p><p id="38da" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">第二种通信方式是使用actor A的上下文属性来获得对发送方或父方的访问权。</p><h1 id="41b6" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">演员之间的交流</h1><p id="a5d3" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">演员通过信息交流。那些消息是不可变的POCO类。如果您使用我们前面提到的代理，您有两种形式的通信可用。第一种是“使用Ask方法的请求-响应”，第二种是“使用Tell方法的一次性处理”</p><p id="1215" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">一般来说，你应该总是使用Tell方法。如果您使用Ask，您必须等待响应，因为这违背了Akka的本质(以及拥有异步actor系统的概念)。</p><h1 id="c3bb" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">演员系统内部的监督</h1><p id="5197" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">有时候，演员会失败。接下来会发生什么，你该怎么办？</p><p id="257e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">每个演员都是所有孩子的监督者。因此，子进程引发的任何错误都将传递给父进程。</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/ba8d72cd648cd614c6cb7b42ac4bd61b.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*Y92O5zHp2RkcZpvt.png"/></div></figure><p id="d021" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这里有一个例子。左图中，演员A是演员B、C、d的父演员，子演员提出的每一个问题都会传递给父演员。</p><p id="e2f2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在本例中，由参与者C引发的错误传递给参与者A，然后参与者A决定如何处理该错误。</p><p id="19bd" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">阿卡。NET提供了四种不同的错误处理策略:</p><ol class=""><li id="4e3c" class="ms mt je kv b kw kx kz la lc mu lg mv lk mw lo nj my mz na bi translated">继续操作子角色，保持其累积的内部状态。</li><li id="5bb9" class="ms mt je kv b kw nb kz nc lc nd lg ne lk nf lo nj my mz na bi translated">重新启动子actor，清除其累积的内部状态。</li><li id="5e8b" class="ms mt je kv b kw nb kz nc lc nd lg ne lk nf lo nj my mz na bi translated">永久停止童星。</li><li id="7d2b" class="ms mt je kv b kw nb kz nc lc nd lg ne lk nf lo nj my mz na bi translated">将错误升级到层次结构中的下一个父级，导致失败。</li></ol><p id="8ed8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">应尽可能避免升级到下一个父参与者。相反，尽可能在接近问题根源的地方解决问题。为了避免在使用Akka.NET时升级，您需要在actors中覆盖监督策略方法。简单地说，Akka提供了基类，因此，要改变策略，您必须覆盖该方法。</p><h1 id="a94e" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">Akka的演员模型扩展。网</h1><h2 id="04bc" class="nk lq je bd lr nl nm dn lv nn no dp lz lc np nq mb lg nr ns md lk nt nu mf nv bi translated">NuGet包:</h2><p id="c90f" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">阿卡。NET是作为一组NuGet包分发的。</p><p id="59fb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">阿卡。Remote </strong>是一个NuGet包，它允许您将系统中的参与者分布到不同的机器上。这个包的好处在于，从开发者的角度来看，它是100%透明的。每个参与者都有一个唯一的地址和自己的传输方式，比如TCP主机和端口。远程参与者的地址看起来类似于HTTP地址。</p><p id="7dad" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">阿卡。集群</strong>是一个远程Akka扩展，支持弹性伸缩。</p><p id="9d58" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">阿卡。Routing </strong>是另一个有用的包。它允许您创建可以将发送给他们的消息路由给其他参与者的参与者。看看下面的插图。在其中，演员基本上是一个路由器，可以被视为单个演员。然而，这里有多个参与者，路由器在其中分发消息。</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nw"><img src="../Images/04341479f1a8d7d306e7a60e2545d059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XrM26y0GkKeoFGjp.png"/></div></div></figure><p id="ff48" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">有各种方法来分发消息。例如，您可以实现循环调度，让消息按照没有优先级的循环顺序进行处理。这些消息将相应地分发给三个参与者。</p><h1 id="8da4" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">一个演员模型系统的例子</h1><p id="3713" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">假设您的任务是构建一个具有不同类型传感器(如气体、运动或光传感器)的智能家居系统，如下图所示。</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mm"><img src="../Images/3446fe6276e5ee98b10bb6d00ec8072f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9XJJxWxEQEGz-aK1.png"/></div></div></figure><p id="79a2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们称父演员为“豪斯”演员。</p><p id="f0cc" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">构建系统的一种方法是为每个传感器分配一个参与者。每当您命令某个参与者从其对应的物理传感器中读取值时，它就会这样做。参与者可以被视为仅处理一条消息的虚拟对象。你可以称之为<em class="ng"> ReadSensorValue </em>，它会将结果发送给家长，也就是众议院演员。</p><p id="9f89" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">房屋参与者应该能够注册房屋中的新传感器，并处理从传感器收集的结果。它还应该有一个调度器，定期向传感器参与者发送消息<em class="ng"> ReadSensorValue </em>。调度程序应该以不同的时间间隔向每种类型的传感器发送消息，因为有些传感器的检查频率可能低于其他传感器。</p><p id="f8aa" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">每个house actor还需要一个名为<em class="ng"> CheckSensorValue </em>的子actor。house actor将从传感器收集的信息转发给<em class="ng"> CheckSensorValue </em>以检查这些值是否高于或低于所需的限值。</p><p id="448a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这是这个模型的层次结构在有多个房子的情况下的样子(但是请记住，为了本文的目的，它已经被简化了):</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mm"><img src="../Images/0173d3c6b2e676e27b9c24e8bad9b8f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*c0bQDEcBbb_YpHkQ.png"/></div></div></figure><h1 id="9776" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">演员模型系统的优点和缺点</h1><p id="f4f3" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">actor模型的一个主要优点是，它允许您创建分布式并发系统，而不必求助于典型的。NET库和机制，如线程、任务、互斥等。</p><p id="5b8b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这个模型的锁定功能也非常有用，正如我们在上面的reservation actor代码中看到的那样。这使我们能够处理两个人同时试图改变一个参与者的状态的情况，我们不需要使用锁定机制就可以做到这一点。</p><p id="36e5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">就测试而言，它可能比传统系统更复杂。尽管Akka提供了一个测试框架，但是测试actor系统可能仍然比较困难，因为您通常不会为actor编写单元测试(练习通常非常简单，并且只定义如何对消息做出反应)。因此，为了测试参与者，您需要创建一个系统并开始发送消息。</p><p id="08ae" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">创建高质量、健壮的演员模型系统所需的学习曲线也可能是一个缺点。尤其是当你第一次开始时，可能很难想象所有潜在的业务需求，并想出一种方法来将它们转化为actor系统。设置本身相当简单，但是创建完美的内部逻辑可能需要一些时间。</p><p id="90a1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然而，一旦掌握了设置和系统设计的诀窍，参与者模型对于非开发人员来说就很容易解释了，从消息流到系统的行为。这有助于提高组织内不同部门之间的集成和透明度。</p><p id="dc81" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">为了获得最佳结果，我们的建议是构建actor系统，其中每个层次或服务都是一个有界上下文，有界上下文使用队列机制相互通信。这将允许您创建专用于业务特定部分的系统，其中不同的有界上下文处理特定的流程。</p><p id="3f45" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi">—</p><p id="a530" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><em class="ng">本文是最初由</em><a class="ae nx" href="https://pl.linkedin.com/in/mateusz-strycharski-0542ba46" rel="noopener ugc nofollow" target="_blank"><em class="ng">Mateusz Strycharski</em></a><em class="ng"/><a class="ae nx" href="https://www.zartis.com/" rel="noopener ugc nofollow" target="_blank"><em class="ng">zart is</em></a><em class="ng">高级工程师主持的一个网络研讨会的摘要。可以在这里</em>  <em class="ng">观看完整录制</em> <a class="ae nx" href="https://youtu.be/EpQnIEV9K-c" rel="noopener ugc nofollow" target="_blank"> <em class="ng">。</em></a></p><p id="c1b9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果你有任何问题或需要更多相关信息，请随时联系。</p></div></div>    
</body>
</html>