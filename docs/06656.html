<html>
<head>
<title>Immutability with Redux and useSelector</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux和useSelector的不变性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/immutability-with-redux-and-useselector-39e5a91da1e0?source=collection_archive---------2-----------------------#2020-12-17">https://levelup.gitconnected.com/immutability-with-redux-and-useselector-39e5a91da1e0?source=collection_archive---------2-----------------------#2020-12-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5654ead7f7598e56d22a6fe5bb8657f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8XBeSHRIPWDIpUyFbSuTcA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">我们最喜欢的两个标志</figcaption></figure><p id="5e91" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最近，在看了一个拉请求后，我看到一个同事直接在一个从<code class="fe ld le lf lg b">useSelector</code>出来的对象上使用关键字<code class="fe ld le lf lg b">delete</code>。</p><p id="4808" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">即使在JS对象上应用delete并不是一个很好的实践，并且经常受到副作用的影响，我们也想知道redux存储会受到删除的影响有多坏。</p><p id="4b92" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">剧透警告:非常糟糕</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="0838" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">示范</h1><p id="90c3" class="pw-post-body-paragraph kf kg it kh b ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky mq la lb lc im bi translated">我在sandbox.io 上创建了一个<a class="ae mr" href="https://codesandbox.io/s/userselectornonimmutable-cr2qz" rel="noopener ugc nofollow" target="_blank">新项目来进行测试。我们感兴趣的两个主要文件是主文件(App.js)和用户缩减器(userReducer.js ),其中也包含了用于本文目的的操作。</a></p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ms"><img src="../Images/dd2af65322eb33229d512de9307d2cd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q4Owv1wzYx9abW51rTNUyg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">App.js</figcaption></figure><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/186367d0e664e8a014123a448bd3ceaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QSay3WrDro7Ml6TkZLQXCQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">userReducer.js</figcaption></figure><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/bcba78358757c9c307432dfcfe42bc43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VUGku4MNan2t3Csa_CIp8A.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">App.js的渲染</figcaption></figure><p id="f7bb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因此，我们的<code class="fe ld le lf lg b">App.js</code>是一个简单的应用程序，将用户商店显示为字符串，然后显示五个不同的按钮供我们实验。<br/><code class="fe ld le lf lg b">userReducer.js</code>是一个基本的减压器，允许设置姓氏并将存储复位到初始状态。</p><p id="7801" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，让我们来看看按钮。<code class="fe ld le lf lg b">refresh</code>按钮正在调用函数<code class="fe ld le lf lg b">updateUserObject</code>，并将使用减速器将存储器中的<code class="fe ld le lf lg b">lastName</code>设置为特定值<code class="fe ld le lf lg b">MyName</code>。这样做的目的是触发react组件上的刷新，以查看存储是否在正常流程之外被修改。</p><p id="75ae" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">两个删除按钮(名字和电话)用于从userSelector返回的对象中删除一些数据。我们正在测试移除对象根处的原语(测试浅拷贝)和嵌套对象中的原语(深拷贝)</p><p id="4333" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里的重置按钮用于将存储重置为初始状态。</p><p id="e457" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后，<code class="fe ld le lf lg b">print initial state</code>按钮会在控制台上打印初始状态。</p><h2 id="2ee1" class="mz lp it bd lq na nb dn lu nc nd dp ly kq ne nf mc ku ng nh mg ky ni nj mk nk bi translated">实验一:浅层复制</h2><p id="8a76" class="pw-post-body-paragraph kf kg it kh b ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky mq la lb lc im bi translated">那么，Redux在调用useSelector时有没有做什么浅层复制？我们可以通过点击<code class="fe ld le lf lg b">remove first name</code>按钮，然后调用刷新按钮来验证。如果有浅拷贝，我们期望UI不要改变。<br/>下面是我们得到的结果:</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/0b90bfb2a2005e74fdcead2ce98fd7b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ByeoPOO5WvriHnLQWEVLMQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">名字在哪里？？</figcaption></figure><p id="16fc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如你所见，第一个名字不见了！这意味着点击<code class="fe ld le lf lg b">remove first name</code>时调用的删除产生了非常不好的副作用！</p><h2 id="0fe2" class="mz lp it bd lq na nb dn lu nc nd dp ly kq ne nf mc ku ng nh mg ky ni nj mk nk bi translated">实验二:深度复制</h2><p id="9c3f" class="pw-post-body-paragraph kf kg it kh b ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky mq la lb lc im bi translated">我想你已经知道答案了，但是作为优秀的科学家，我们不能在没有测试的情况下做任何假设。让我们首先刷新以回到初始状态，然后点击<code class="fe ld le lf lg b">Remove phone</code>按钮，接着点击<code class="fe ld le lf lg b">refresh</code>，看看发生了什么。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/4f00720d492619554aa521b21d579a8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eIIWfd8SLigib26GhsS_lg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">手机不见了</figcaption></figure><p id="4a31" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如你所料，深度复制并不更成功。JS不会原谅玩坏对象的人，Redux/React-Redux也不例外。</p><h2 id="42b3" class="mz lp it bd lq na nb dn lu nc nd dp ly kq ne nf mc ku ng nh mg ky ni nj mk nk bi translated">实验奖金:我可以重置吗？</h2><p id="dc7a" class="pw-post-body-paragraph kf kg it kh b ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky mq la lb lc im bi translated">有两个按钮我们还没有使用。最后两个。</p><p id="265f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是我第三个实验的案例。我们删除了名字和电话。然后我们刷新。之后，我们重置到初始状态(不要忘记刷新之前不包括以前的实验)</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/bb1ffb7c02dc3ea0772fcfc744cc4d63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0QYFV1SBqhErNgWdhAGpIw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">同样的结果。不应该重置吗？</figcaption></figure><p id="2a10" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">很奇怪吧？我们期望重置到reducer中定义的初始状态。之所以没有发生，是因为到处都在用初态的参考！如果没有copy，那么我们最终不仅仅是删除存储中的项目，还会删除初始状态中的项目！初始状态的console.log证明了这一点(点击<code class="fe ld le lf lg b">print initial state</code>，看一下控制台)</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div class="gh gi no"><img src="../Images/7c5477974daf5e2ab0694a3367676ff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*xTY53EIiLkOZRlHwLdrx-w.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">具有缺失项目的初始状态对象</figcaption></figure><h2 id="2b87" class="mz lp it bd lq na nb dn lu nc nd dp ly kq ne nf mc ku ng nh mg ky ni nj mk nk bi translated">这些实验的结论</h2><p id="1168" class="pw-post-body-paragraph kf kg it kh b ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky mq la lb lc im bi translated">我们很多人都知道<code class="fe ld le lf lg b">delete</code>是一种非常危险的做法，应该非常小心地使用。但是在Redux环境中，对于应用程序的完整性来说，这可能是灾难性的！这就是为什么我们建议总是复制最大值(使用<code class="fe ld le lf lg b">{...myObj}</code>的浅层复制或使用众所周知的<code class="fe ld le lf lg b">JSON.parse(JSON.stringify(myObj))</code>(或深层复制库)的深层复制)</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="5b4e" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">避免存储外部减速器可变性的解决方案</h1><p id="4f70" class="pw-post-body-paragraph kf kg it kh b ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky mq la lb lc im bi translated">我将对这篇文章提出两个解决方案。</p><h2 id="c7f9" class="mz lp it bd lq na nb dn lu nc nd dp ly kq ne nf mc ku ng nh mg ky ni nj mk nk bi translated">总是（德语词）</h2><div class="np nq gp gr nr ns"><a href="https://www.npmjs.com/package/immer" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">总是（德语词）</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">通过改变当前状态来创建下一个不可变状态</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">www.npmjs.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og jz ns"/></div></div></a></div><p id="6b09" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> Immer </strong>在我看来是最简单的解决方案。这是另一个第三方库，它包装了reducers并返回不可变对象。因此，你可以对你的对象使用尽可能多的删除，你不会对存储有任何副作用。你可以看到一个例子，在这个<a class="ae mr" href="https://codesandbox.io/s/userselectorimmutable-mj055" rel="noopener ugc nofollow" target="_blank"> sandbox.io项目</a>上试一试。</p><h2 id="5b67" class="mz lp it bd lq na nb dn lu nc nd dp ly kq ne nf mc ku ng nh mg ky ni nj mk nk bi translated">redux-工具包</h2><div class="np nq gp gr nr ns"><a href="https://www.npmjs.com/package/@reduxjs/toolkit" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">@reduxjs/toolkit</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">官方的、固执己见的、包含电池的高效Redux开发工具集(以前称为“Redux Starter…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">www.npmjs.com</p></div></div><div class="ob l"><div class="oh l od oe of ob og jz ns"/></div></div></a></div><p id="b450" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Redux-Toolkit 更大更耐用，但也包含了更多的特性。这也迫使开发人员尊重使用redux的良好实践。引擎盖后面用的是Immer。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><p id="83da" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我希望你像我喜欢写这篇文章一样喜欢它。JS是一种充满惊喜的语言，尝试我们的问题是理解它的最好方式！</p><p id="164f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">下一篇文章再见！<br/>雷米</p></div></div>    
</body>
</html>