<html>
<head>
<title>Make your code lightning quick by Executing Calls in Parallel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过并行执行调用，让您的代码快如闪电</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/make-your-code-lightning-quick-by-executing-calls-in-parallel-5ddde9965d50?source=collection_archive---------23-----------------------#2020-09-24">https://levelup.gitconnected.com/make-your-code-lightning-quick-by-executing-calls-in-parallel-5ddde9965d50?source=collection_archive---------23-----------------------#2020-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="38fc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">学习创建并行异步任务</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/e14959d9bf7c85a9fb33efaa9a5baf11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*kSOhBtX5ukdglCTaFOr_EA.jpeg"/></div></figure><h1 id="4fbb" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">为什么并行工作？</h1><p id="e5a9" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在大💪，快🏃‍♂️和复杂的⁉️代码库，有大量的处理工作需要完成。同步(一个接一个)进行所有这些处理会增加时间🕐代码需要执行。</p><p id="1a70" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">解决这个问题的一个好方法是，当这些过程彼此不依赖时，异步地执行其中的一些过程。</p><p id="a9ef" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">最佳实践包括使用线程池，并将任务包装在Runnable(不返回任何内容)或Callable(返回某些内容)中。</p><p id="8b8b" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">在本教程中，我们将看到如何通过创建几个虚拟服务调用并并行运行它们来加速我们的程序，使我们的代码像火箭一样飞行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mg"><img src="../Images/f08d37b03ec0f4adcd269c7bfae2b731.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ng27eZOm6KgjKv0RVauEGQ.jpeg"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">比尔·杰伦在<a class="ae mp" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> unsplash </a>上的照片</figcaption></figure><h1 id="f613" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">实现Runnable</h1><p id="bb2f" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">下面，我们将实现我所说的Runnable接口，在这个例子中我们不需要返回任何东西，所以我们不需要使用Callable。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="9d72" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">在我们的<strong class="lh ir"> run() </strong>中，我们将打印任务的<strong class="lh ir">开始时间</strong>以及<strong class="lh ir">任务名称</strong>和<strong class="lh ir">线程名称</strong>。</p><p id="bab6" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">然后，我们将等待适当的时间，并打印出我们的“完成”✅消息。</p><p id="4c3b" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">我们需要将这段代码包装在一个try catch中，因为它将在一个并行线程上执行。每当我们有运行在并行线程上的代码时，我们都有机会抛出InterruptedException，所以我们只需添加一个快速捕捉。</p><h1 id="3824" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">我们的模拟应用</h1><p id="fc06" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">想象一下，我们有一个网站，需要加载一些资产才能正常工作</p><ul class=""><li id="d5cb" class="ms mt iq lh b li mb ll mc lo mu ls mv lw mw ma mx my mz na bi translated">获取客户数据库，5000毫秒</li><li id="9334" class="ms mt iq lh b li nb ll nc lo nd ls ne lw nf ma mx my mz na bi translated">获取产品数据库，7500毫秒</li><li id="18d9" class="ms mt iq lh b li nb ll nc lo nd ls ne lw nf ma mx my mz na bi translated">加载前端资源1000毫秒</li><li id="2643" class="ms mt iq lh b li nb ll nc lo nd ls ne lw nf ma mx my mz na bi translated">验证安全性4000毫秒</li></ul><p id="09b1" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">按顺序执行此操作需要17500毫秒🙀。然而，我们可以使用并行化来加速这个过程🤓。</p><p id="bff2" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">下图显示了如何使用2个线程执行这些任务。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ng"><img src="../Images/e88a92faadc9db508a7af36516623008.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x_4I7sbNCO8QTWUixX3CXg.jpeg"/></div></div></figure><p id="5f7a" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">并行完成(2个线程)的时间是10000毫秒😃这几乎比同步时间快两倍。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="1b86" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">下面是预期的输出。</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="26b2" class="nm ko iq ni b gy nn no l np nq">Task started: Get Products DB on thread pool-1-thread-2<br/>Task started: Get Customer DB on thread pool-1-thread-1<br/>Task done: Get Customer DB after 5004ms on thread pool-1-thread-1<br/>Task started: Load Front End Resources on thread pool-1-thread-1<br/>Task done: Load Front End Resources after 1002ms on thread pool-1-thread-1<br/>Task started: Verify Security on thread pool-1-thread-1<br/>Task done: Get Products DB after 7504ms on thread pool-1-thread-2<br/>Task done: Verify Security after 4004ms on thread pool-1-thread-1</span></pre><h1 id="c412" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">⚠️Amdahl's Law⚠️</h1><p id="90ce" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在有一个极限，这个极限可以加速你的代码，这个原理叫做阿姆达尔定律。公式是</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="0f97" class="nm ko iq ni b gy nn no l np nq">(Total work)/(Largest work that must be done in sequence)</span></pre><p id="8361" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">在我们的示例中，这将是(17，500)/(7，500) = 2.333。</p><p id="e736" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">因此，我们可以通过使用并行化实现2.333倍的加速比。(为了达到这个速度，我们需要增加更多的线程)。</p></div></div>    
</body>
</html>