<html>
<head>
<title>Shortest Unsorted Continuous Subarray</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最短未排序连续子阵列</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/shortest-unsorted-continuous-subarray-b7401e839b7e?source=collection_archive---------14-----------------------#2021-03-03">https://levelup.gitconnected.com/shortest-unsorted-continuous-subarray-b7401e839b7e?source=collection_archive---------14-----------------------#2021-03-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7fe7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将解释我对2021年2月月度挑战中的<a class="ae kl" href="https://leetcode.com/explore/challenge/card/february-leetcoding-challenge-2021/587/week-4-february-22nd-february-28th/3652/" rel="noopener ugc nofollow" target="_blank"> Leetcode算法问题的解决方案。</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/e578ef585fd2c423933af3e6bbbe983f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eBWxsODAf8STjQNcnKZUtA.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">最短未排序连续子阵列</figcaption></figure><p id="e875" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题陈述</strong> <br/>给定一个整数数组<code class="fe lc ld le lf b">nums</code>，你需要找到一个<strong class="jp ir">连续的子数组</strong>如果你只对这个子数组进行升序排序，那么整个数组都会进行升序排序。返回该子数组中最短的<em class="lg">并输出其长度</em>。</p><p id="4394" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解</strong> <br/>从上图可以看出，最短的连续子数组是一个数组中最短的未排序子数组，排序后会使整个数组按该顺序排序。例如，在数组<code class="fe lc ld le lf b">{1,2,3,4,<strong class="jp ir">6,7,8,10,9,5,</strong>11,15}</code>中，我们可以排序以保持整个数组升序排序的最短子数组是从索引<code class="fe lc ld le lf b">4</code>开始到索引<code class="fe lc ld le lf b">9</code>即<code class="fe lc ld le lf b">{6,7,8,10,9,5}</code>的子数组，因此解是<code class="fe lc ld le lf b">6</code>，这是子数组的长度。你能想出解决这个问题的办法吗？当然，暴力方法。</p><p id="619b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">令人惊讶的是，在这种情况下，即使是被认为简单的蛮力方法也不是很直观。你认为这个问题的强力解决方案是什么？以下步骤解释了我所采用的暴力方法:</p><p id="2748" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 1 </strong>。对于数组中的每个值，比如说<strong class="jp ir">当前值；</strong> <br/> <strong class="jp ir"> 2 </strong>。如果存在，从数组的<strong class="jp ir">开始</strong>到<strong class="jp ir">当前值</strong>的位置，找到比<strong class="jp ir">当前值</strong>大<strong class="jp ir">的数组中<strong class="jp ir">第一个</strong>值的<strong class="jp ir">索引</strong>。如果索引存在，我们姑且称之为<code class="fe lc ld le lf b">left_index</code>。<br/> <strong class="jp ir"> 3 </strong>。此外，从数组的<strong class="jp ir">末端</strong>开始到<strong class="jp ir">当前值</strong>的位置，查找数组中小于当前值的第一个值的索引(如果存在)。如果指数存在，我们姑且称之为<code class="fe lc ld le lf b">right_index</code>。<br/> <strong class="jp ir"> 4 </strong>。找到与数组中所有条目相关的所有现有的<code class="fe lc ld le lf b">left_index</code>和<code class="fe lc ld le lf b">right_index</code>。让<code class="fe lc ld le lf b">min_left</code>代表所有<code class="fe lc ld le lf b">left_index</code> es的最小值<code class="fe lc ld le lf b">min_right</code>代表所有<code class="fe lc ld le lf b">right_index</code> es的最大值。子数组<code class="fe lc ld le lf b">[min_left, min_right</code>是原始数组中最短的未排序连续子数组。如果不存在<code class="fe lc ld le lf b">left_index</code>和<code class="fe lc ld le lf b">right_index</code>，那么数组已经按升序排序。</strong></p><p id="d2f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，考虑数组<code class="fe lc ld le lf b">{11,12,13,16,15,14,17,19}</code>。让我们从索引i=0到7对数组执行上述步骤:<br/> <strong class="jp ir">当i= 0 </strong>且值为<strong class="jp ir"> 11 </strong>时:11左边没有大于11的值，11右边没有小于11的值，因此没有<code class="fe lc ld le lf b">left_index</code>也没有<code class="fe lc ld le lf b">right_index</code>。<br/> <strong class="jp ir">当i=1 </strong>值为<strong class="jp ir"> 12: </strong>无<code class="fe lc ld le lf b">left_index</code>无<code class="fe lc ld le lf b">right_index</code>。<br/> <strong class="jp ir">当i=2 </strong>值为<strong class="jp ir"> 13 </strong>时:无<code class="fe lc ld le lf b">left_index</code>和无<code class="fe lc ld le lf b">right_index</code>。<br/> <strong class="jp ir">当i=3 </strong>值为<strong class="jp ir"> 16 </strong>时:否<code class="fe lc ld le lf b">left_index</code>，但<code class="fe lc ld le lf b">right_index = 5</code>(因为从数组开头算起，索引为5的14是第一个小于16的元素。<br/> <strong class="jp ir">当i=4 </strong>值为<strong class="jp ir"> 15 </strong> : <code class="fe lc ld le lf b">left_index = 3</code>(因为索引为3的16是数组开头的第一个元素，小于15)。也是<code class="fe lc ld le lf b">right_index = 5</code>。<br/> <strong class="jp ir">当i=5 </strong>且值<strong class="jp ir"> 14 </strong> : <code class="fe lc ld le lf b">left_index = 3</code>但无<code class="fe lc ld le lf b">right_index</code>时。<br/> <strong class="jp ir">当i=6 </strong>值为<strong class="jp ir"> 17 </strong>时:无<code class="fe lc ld le lf b">left_index</code>和无<code class="fe lc ld le lf b">right_index</code>。<br/> <strong class="jp ir">当i=7 </strong>值为<strong class="jp ir"> 19 </strong>时:无<code class="fe lc ld le lf b">left_index</code>和无<code class="fe lc ld le lf b">right_index</code>。</p><p id="2c8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有<code class="fe lc ld le lf b">left_index</code> es的<strong class="jp ir">最小值</strong>为<code class="fe lc ld le lf b">3</code>，所有<code class="fe lc ld le lf b">right_index</code> es的<strong class="jp ir">最大值</strong>为<code class="fe lc ld le lf b">5</code>，因此<strong class="jp ir">最短未排序连续子阵列</strong>为<code class="fe lc ld le lf b">[3, 5]</code>。您可以通过查看示例中给定数组的子数组[3，5]中的值{16，15，14}来确认这一点。注意，这个子数组不是按升序排序的，如果它按升序排序，那么给定的数组也会按升序排序。下面是上述方法在Java中的代码实现。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="c5ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">暴力破解方法分析</strong> <br/>暴力破解方法的时间复杂度为O(N)。注意，当原始数组已经按升序排序时，这种方法会出现最坏的情况。在这种情况下，对于每个条目，针对<code class="fe lc ld le lf b">left_index</code>和<code class="fe lc ld le lf b">right_index</code>检查整个数组。没有使用辅助存储器。</p><p id="2a88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">方法2:预处理和2指针技术</strong> <br/>该方法只有2个主要步骤；<br/> <strong class="jp ir"> 1。</strong>给定一个数组，比如说<strong class="jp ir"> arr </strong>，迭代给定的数组一次，找到这个格式的所有出现:<code class="fe lc ld le lf b">arr[i] &gt; a[j] for all i &lt; j</code>，其中a[j]是较小的值，a[i]是较大的值。记录所有a[j]的最小值作为最小值<strong class="jp ir">和所有a[i]的最大值作为最大值<strong class="jp ir">。如果没有出现这种情况，那么给定的数组已经按升序排序。<strong class="jp ir"> <br/> 2。</strong>利用步骤1中得到的<strong class="jp ir"> min </strong>和<strong class="jp ir"> max </strong>，采用2指针技术从开始处寻找给定数组中第一个元素的索引(比如说<code class="fe lc ld le lf b">left</code>)，该索引大于<strong class="jp ir"> min </strong>的<strong class="jp ir">。同样，找到给定数组中从末尾开始的第一个元素的索引(比如说<code class="fe lc ld le lf b">right</code>)，它比<strong class="jp ir"> max </strong>小<strong class="jp ir">。<br/>子阵列<code class="fe lc ld le lf b">[left, right]</code>是给定阵列的<strong class="jp ir">最短未排序连续子阵列</strong>。</strong></strong></strong></strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lj"><img src="../Images/68f8d241f01366f50d832f655c5be2bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZJKFYpEd_tEySdLwcKlhuw.png"/></div></div></figure><p id="6561" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第二种方法的分析</strong> <br/>第二种方法的时间复杂度为<strong class="jp ir"> O(N) </strong>其中N为给定数组的长度。请注意，我们只对数组进行了两次线性迭代——在排列不匹配的位置找到min和max元素，然后使用2指针技术找到min和max的正确位置。没有使用辅助空间。下面是第二种方法在Java中的代码实现。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="b601" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">结论性备注:</strong> <br/>感谢你查看这篇帖子。如果你有任何意见或建议，请在评论区告诉我。:-)</p></div></div>    
</body>
</html>