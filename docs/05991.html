<html>
<head>
<title>Learning C++: Inheritance Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习C++:继承第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-inheritance-part-1-cc8f4e9a69b1?source=collection_archive---------11-----------------------#2020-10-16">https://levelup.gitconnected.com/learning-c-inheritance-part-1-cc8f4e9a69b1?source=collection_archive---------11-----------------------#2020-10-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/51a711e20ddbc56cccacc14ca4c6c32b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*INqrwf02DWbcFC4_"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@furbee?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">奥斯卡·诺德</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="94db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我将介绍如何在C++中执行对象继承。当我们在C++程序中使用继承时，我们是在建模<em class="le"> is-a </em>关系。比如狗<em class="le">是——一种</em>哺乳动物；一辆大众甲壳虫<em class="le">是一辆</em>汽车；正方形<em class="le">是一个</em>形状。这意味着，以大众甲壳虫为例，甲壳虫具有许多典型汽车的属性，尽管它可能具有一些其他汽车没有的属性，并且它与汽车共有的属性可能与其他汽车不相同。例如，甲壳虫的形状完全不同于其他任何汽车的形状。但是一般来说，一个从另一个对象继承的对象与它所继承的对象有许多共同的特征。</p><h1 id="6259" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">一些术语</h1><p id="7190" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">我们将要继承的类叫做<em class="le">基类</em>。从另一个类继承的类被称为<em class="le">派生类</em>。包括一个基类和一个或多个派生类的一组类被称为<em class="le">类层次</em>。当一个派生类只继承一个基类时，这就是所谓的单一继承。当一个派生类从多个类继承时，这被称为多重继承。在这组文章中，我将使用单一继承。</p><p id="3a02" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">认识到一个类可以包含其他类作为其定义的一部分是很重要的。这不是一个继承的例子，而是一个<em class="le">组合的例子。合成的一个例子可能是一个正方形类，它包含一个点类作为正方形的原点。</em></p><p id="c503" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与我上面提到的is-a关系相反，组合用于has-a关系。一个人有-一个名字；一辆汽车有一个发动机；一个员工有工资。我会在这个继承系列的最后多讲讲构图。</p><h1 id="311b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">继承基础</h1><p id="a6b7" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">为了演示继承，我将使用一个创建不同形状的经典示例。我将从一个基本的<code class="fe mi mj mk ml b">Shape</code>类开始，它没有定义一个真实的形状，但是提供了一些我们可以用于特定形状的基本属性和过程。</p><p id="809a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是我的<code class="fe mi mj mk ml b">Shape</code>类的定义:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="74b0" class="mu lg it ml b gy mv mw l mx my">class Shape {<br/>private:<br/>  int x, y;<br/>public:<br/>  Shape(int newx, int newy) {<br/>    x = newx;<br/>    y = newy;<br/>  }<br/>  <br/>  int getX() { return x; }<br/>  int getY() { return y; }</span><span id="d1e1" class="mu lg it ml b gy mz mw l mx my">  void setX(int newx) { x = newx; }<br/>  void setY(int newy) { y = newy; }</span><span id="4ab1" class="mu lg it ml b gy mz mw l mx my">  void draw() {<br/>    cout &lt;&lt; "Drawing a shape with origin point, x: "<br/>         &lt;&lt; x &lt;&lt; ", y: " &lt;&lt; y;<br/>  }<br/>};</span></pre><p id="43fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当创建一个类的目的仅仅是作为一个类层次结构中的基类时，这个类被称为抽象类。<code class="fe mi mj mk ml b">Shape</code>类是一个经典的抽象类，因为形状只是某种特定形状类型的抽象，比如正方形或三角形。</p><p id="a595" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要使一个类成为派生类，可以这样开始定义:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="94f2" class="mu lg it ml b gy mv mw l mx my">class Square : public Shape {</span><span id="1df7" class="mu lg it ml b gy mz mw l mx my">};</span></pre><p id="36d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这告诉编译器<code class="fe mi mj mk ml b">Shape</code>类将从<code class="fe mi mj mk ml b">Square</code>类派生而来。</p><p id="cbe4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">继续讨论<code class="fe mi mj mk ml b">Square</code>类，我们需要识别该类的成员变量。一个<code class="fe mi mj mk ml b">Square</code>对象将会有一个<code class="fe mi mj mk ml b">Shape</code>的x和y坐标，但是它也有成员变量来表示其边的长度和宽度。我们把这些放在私人区域:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="aad1" class="mu lg it ml b gy mv mw l mx my">class Square : public Shape {<br/>private:<br/>  int length, width;<br/>};</span></pre><p id="aa32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一行:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="1044" class="mu lg it ml b gy mv mw l mx my">class Square : public Shape</span></pre><p id="7845" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">指示基类具有公共规范，这意味着继承的类可以直接访问基类的公共成员。在基类中声明为私有的成员变量和成员函数对于继承的类也是私有的。这意味着，例如，我们很快就会看到，如果我们想让一个继承的类访问基类的私有成员变量，我们就必须使用公共成员函数，比如getters，来获得这种访问。</p><p id="d46c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们给类定义添加一个构造函数。派生类构造函数的形式与基类的构造函数略有不同，所以让我先给你演示一下，然后我会解释为什么它是这样形成的:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="7cbd" class="mu lg it ml b gy mv mw l mx my">class Square : public Shape {<br/>private:<br/>  int length, width;<br/>public:<br/>  Square(int newx, int newy, int len, int wdth)<br/>    : Shape(newx, newy) {<br/>    length = len;<br/>    width = wdth;<br/>  }<br/>};</span></pre><p id="9223" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了正确设置<code class="fe mi mj mk ml b">x</code>和<code class="fe mi mj mk ml b">y</code>成员变量，构造函数需要调用设置这些值的<code class="fe mi mj mk ml b">Shape</code>(基类)构造函数。这是必要的，因为在基类构造函数中可能有一些专门的代码需要被调用。另外，我们不想重复调用已经被调用的代码，所以我们只调用基类构造函数，让它来完成这项工作。</p><p id="e6c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请记住，基类构造函数总是在派生类构造函数之前被调用，这样就可以在移动到派生类之前设置基类成员。从语法上看，这是显而易见的，但我想让它更清楚，以防万一。</p><p id="e0ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们写一个简短的测试程序，看看我们到目前为止有什么。我们可以创建一个<code class="fe mi mj mk ml b">Square</code>对象，并通过调用从<code class="fe mi mj mk ml b">Shape</code>继承的draw成员函数来“绘制”它。下面是测试的代码:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="51ab" class="mu lg it ml b gy mv mw l mx my">int main () {<br/>  Square sq1(1,2,3,3);<br/>  sq1.draw();<br/>  return 0;<br/>}</span></pre><p id="f470" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="c571" class="mu lg it ml b gy mv mw l mx my">Drawing a shape with origin point, x: 1, y: 2</span></pre><p id="764e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这不是我们想要的。程序运行，但是<code class="fe mi mj mk ml b"> sq1</code>正在为一个形状使用<code class="fe mi mj mk ml b">draw</code>成员函数，它输出它正在绘制一个形状。我们希望函数输出它正在画一个正方形。我们可以通过为<code class="fe mi mj mk ml b">Square</code>类定义一个新的<code class="fe mi mj mk ml b">draw</code>成员函数来实现这一点，该函数将覆盖或隐藏该类从<code class="fe mi mj mk ml b"> Shape</code>继承的<code class="fe mi mj mk ml b">draw</code>函数。</p><p id="ec41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">定义如下:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="4172" class="mu lg it ml b gy mv mw l mx my">void draw() {<br/>  cout &lt;&lt; "Drawing a square with origin point, x: " &lt;&lt; x<br/>       &lt;&lt; ", y: " &lt;&lt; y;<br/>  cout &lt;&lt; ", with length: " &lt;&lt; length &lt;&lt; " and width: "<br/>       &lt;&lt; height;<br/>}</span></pre><p id="14dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只是这个成员函数不太管用。该函数不能直接访问<code class="fe mi mj mk ml b">x</code>和<code class="fe mi mj mk ml b">y</code>，因为它们是<code class="fe mi mj mk ml b">Shape</code>的私有函数。相反，我们需要使用Shape类定义中的getters来访问<code class="fe mi mj mk ml b">x</code>和<code class="fe mi mj mk ml b">y</code>。(另一种解决方案是在<code class="fe mi mj mk ml b">Shape</code>中进行<code class="fe mi mj mk ml b">x</code>和<code class="fe mi mj mk ml b">y</code>和<code class="fe mi mj mk ml b">protected </code>的访问。我将在另一篇文章中讨论这种选择。)</p><p id="fcbc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是<code class="fe mi mj mk ml b">Square</code>的<code class="fe mi mj mk ml b">draw</code>成员函数的新定义:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="b91b" class="mu lg it ml b gy mv mw l mx my">void draw() {<br/>  cout &lt;&lt; "Drawing a square with origin point, x: " &lt;&lt; getX()<br/>       &lt;&lt; ", y: " &lt;&lt; getY() &lt;&lt; endl;<br/>  cout &lt;&lt; "With length: " &lt;&lt; length &lt;&lt; " and width: "<br/>       &lt;&lt; width;<br/>}</span></pre><p id="7bda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是使用新版本<code class="fe mi mj mk ml b">draw</code>的输出:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="104e" class="mu lg it ml b gy mv mw l mx my">Drawing a square with origin point, x: 1, y: 2<br/>With length: 3 and width: 3</span></pre><h1 id="90c0" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">关于析构函数的快速说明</h1><p id="b175" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">我没有花太多时间讨论析构函数，因为它们对我介绍的简单类没什么用。然而，我需要讨论派生类中使用的析构函数的一个方面。</p><p id="5dbc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我前面提到过，基类构造函数总是在派生类构造函数之前被调用。然而，对于析构函数，顺序是相反的。在调用基类析构函数之前调用派生类析构函数。</p><p id="3349" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个简单的例子来说明这一点:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="f117" class="mu lg it ml b gy mv mw l mx my">class Base {<br/>private:<br/>  string value;<br/>public:<br/>  Base(string val) {<br/>    value = val;<br/>  }<br/>  <br/>  ~Base() {<br/>    cout &lt;&lt; "Calling base class destructor." &lt;&lt; endl;<br/>  }<br/>};</span><span id="1cb9" class="mu lg it ml b gy mz mw l mx my">class Derived : public Base {<br/>public:<br/>  Derived(string val) : Base(val) {<br/>    // nothing to do here<br/>  }</span><span id="d966" class="mu lg it ml b gy mz mw l mx my">  ~Derived() {<br/>    cout &lt;&lt; "Calling derived class destructor." &lt;&lt; endl;<br/>  }<br/>};</span><span id="8c45" class="mu lg it ml b gy mz mw l mx my">int main () {<br/>  Derived d("Test");<br/>  return 0;<br/>}</span></pre><p id="8951" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该程序的输出是:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="4278" class="mu lg it ml b gy mv mw l mx my">Calling derived class destructor.<br/>Calling base class destructor.</span></pre><h1 id="eb07" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">继承继续，并解释了受保护的访问</h1><p id="fdfc" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">这就结束了我对C++中对象继承的介绍。我的下一篇文章将继续这个讨论，解释受保护的访问是如何工作的，什么时候应该使用它，什么时候应该避免使用它。</p><p id="aa2c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请给我发电子邮件提出意见和建议。如果你对我的在线编程课程感兴趣，请访问<a class="ae kf" href="https://learningcpp.teachable.com" rel="noopener ugc nofollow" target="_blank">https://learningcpp.teachable.com</a>。</p></div></div>    
</body>
</html>