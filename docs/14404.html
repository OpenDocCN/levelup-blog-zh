<html>
<head>
<title>How do Bytes live in Solidity and coexist with String</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">字节如何在坚固中生存并与字符串共存</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-do-bytes-live-in-solidity-and-coexist-with-strings-98ef3fcc0a12?source=collection_archive---------6-----------------------#2022-11-23">https://levelup.gitconnected.com/how-do-bytes-live-in-solidity-and-coexist-with-strings-98ef3fcc0a12?source=collection_archive---------6-----------------------#2022-11-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fe6badabb987f8e71ed36e40d6fd4ca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FHS099Ww0TI4njgV"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@amir_v_ali?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> amirali mirhashemian </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="f6db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">字节和字符串在Solidity编程语言中有着特殊的地位。这两种类型的工作方式非常相似，但又有所不同。偶数字节有两种方式——固定大小或动态大小。根据我们的需要，字节和字符串可以相互转换。让我们在这篇博文中更深入地了解一下。</p><h1 id="c09a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">固定大小的字节数组</h1><p id="a9f6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们知道想要存储的字节大小，最好的方法是使用固定大小的字节数组类型。Solidity语言允许在一个序列中存储1到32个字节。就汽油费而言，使用已知的前期大小来存储字节的成本要便宜得多。</p><p id="f0b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了初始化一个固定大小的字节数组，我们需要指定我们想要存储多少字节的大小。</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="6aee" class="mq lf it mm b be mr ms l mt mu">bytes1 b1 = hex"41";</span></pre><p id="d628" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">字节可以用十六进制字符串<code class="fe mv mw mx mm b">hex"41"</code>或十六进制值<code class="fe mv mw mx mm b">0X41</code>初始化，根据ASCII，该值是字母<code class="fe mv mw mx mm b">A</code>。</p><p id="2b05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个重要的注意事项是，在Solidity编程语言中，固定大小的字节可以在智能契约之间传递。</p><h1 id="bf07" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">动态大小字节数组</h1><p id="8b99" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">动态大小字节数组可以保存可变的字节数。</p><p id="2663" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有可能得到字节的索引，但字符串类型不是这样。</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="e02e" class="mq lf it mm b be mr ms l mt mu">function dynamicBytesMemoryNew() external view returns(bytes memory) {<br/>  bytes memory _dynamicBytesMemoryNew = new bytes(200);<br/>  _dynamicBytesMemoryNew[0] = hex"41";<br/>  console.log(string(_dynamicBytesMemoryNew));<br/>  return _dynamicBytesMemoryNew;<br/>}</span></pre><p id="8c40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Solidity语言在内存中分配字节有几种方法。</p><h1 id="e3ca" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">存储中的动态大小字节数组</h1><p id="21a2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当在存储器上分配动态字节时，我们需要提供我们想要的最大容量。</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="8ab9" class="mq lf it mm b be mr ms l mt mu">bytes _dynamicBytesStorage = new bytes(200);</span></pre><p id="0af8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在存储器中分配一个动态大小的字节数组，我们可以使用<code class="fe mv mw mx mm b">pop</code>和<code class="fe mv mw mx mm b">push</code>方法。请记住，这样做的代价可能会很高。</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="8139" class="mq lf it mm b be mr ms l mt mu">function dynamicBytesStorage() external returns(bytes memory) {<br/>  _dynamicBytesStorage.push(hex"41");<br/>  console.log(string(_dynamicBytesStorage));<br/>  return _dynamicBytesStorage;<br/>}</span></pre><h1 id="d7be" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">内存中动态大小字节数组</h1><p id="4841" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当在内存中分配动态字节数组时，我们不需要指定大小。</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="e42e" class="mq lf it mm b be mr ms l mt mu">function dynamicBytesMemory() external view returns(bytes memory) {<br/>  bytes memory _dynamicBytesMemory = hex"41";<br/><br/>  console.log(string(_dynamicBytesMemory));<br/>  return _dynamicBytesMemory;<br/>}</span></pre><h1 id="c85e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">字符串是字节(几乎)</h1><p id="0eac" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Solidity中的字符串类型几乎就像字节的动态数组。它可以保存任意长度的字符数据。这一次我们不会更深入地讨论这种类型，而是从字节的角度来看它。</p><p id="c422" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将任何字符串转换成字节。这允许我们在字节级别上修改和读取字符。这意味着我们需要处理ASCII级别的字符。</p><p id="9a3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个关键的注意事项是字符串不能在智能合约之间传递。为此，我们需要深入到字节级别。但是在这些类型之间进行转换是可行的。</p><h1 id="e6fd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">转换为字节</h1><p id="3a6b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">将字符串转换成字节是一项简单的任务。我们需要初始化传入字符串类型的字节。作为回报，我们得到一个动态字节数组。</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="44bc" class="mq lf it mm b be mr ms l mt mu">bytes memory stringBytes = bytes("This is string");</span></pre><p id="326b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想转换成<code class="fe mv mw mx mm b">bytes32</code>类型，我们需要进入汇编级，将字符串写入内存。</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="672a" class="mq lf it mm b be mr ms l mt mu">bytes32 result;<br/><br/>assembly {<br/>  result := mload(add("This is string", 32))<br/>}</span></pre><p id="8489" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请记住，我们最多只能写入32个字节。</p><h1 id="9426" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从字节转换</h1><p id="327e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在Solidity语言中，我们可以将字符串值转换回动态大小的字节数组。我们无法转换为固定字符串字节，因为字符串类型的大小未知。</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="3bff" class="mq lf it mm b be mr ms l mt mu">bytes memory bytesData = hex"41";<br/>string memory stringData = string(bytesData);</span></pre><h1 id="1bff" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="44a3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">字节在Solidity编程语言中起着至关重要的作用。它可以在固定或动态大小的字节数组中保存任何数据。例如，与字节非常相似但功能有限的字符串。幸运的是，字符串和字节之间的转换是可行的，但有一些小的注意事项。</p><h1 id="31f5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">链接</h1><ul class=""><li id="7cf0" class="my mz it ki b kj mc kn md kr na kv nb kz nc ld nd ne nf ng bi translated"><a class="ae kf" href="https://gist.github.com/fassko/548c83158f4006c38e70e5dceed2a8cb" rel="noopener ugc nofollow" target="_blank">样本代码</a></li><li id="5cfd" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><a class="ae kf" href="https://solang.readthedocs.io/en/latest/language/types.html#fixed-length-byte-arrays" rel="noopener ugc nofollow" target="_blank">固定长度字节数组</a></li><li id="9ac5" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><a class="ae kf" href="https://solang.readthedocs.io/en/latest/language/types.html#dynamic-length-bytes" rel="noopener ugc nofollow" target="_blank">动态长度字节</a></li><li id="285e" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><a class="ae kf" href="https://jeancvllr.medium.com/solidity-tutorial-all-about-bytes-9d88fdb22676" rel="noopener">坚实度教程:关于字节的一切</a></li></ul></div></div>    
</body>
</html>