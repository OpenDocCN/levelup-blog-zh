<html>
<head>
<title>RxJS Filtering Operators — Skip and Take</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS过滤运算符—跳过和采用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rxjs-filtering-operators-skip-and-take-3576acda1f1f?source=collection_archive---------4-----------------------#2020-02-29">https://levelup.gitconnected.com/rxjs-filtering-operators-skip-and-take-3576acda1f1f?source=collection_archive---------4-----------------------#2020-02-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/828f07afc424f6a0487bb81edadbd5ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X7vUEll0SNFrvU-e"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@moonboyz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">比尔·费尔斯</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4e42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Rxjs是一个用于进行反应式编程的库。创建操作符对于从各种数据源生成供观察者订阅的数据非常有用。</p><p id="2529" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看到更多的过滤操作符，包括<code class="fe le lf lg lh b">skipUntil</code>、<code class="fe le lf lg lh b">skipWhile</code>、<code class="fe le lf lg lh b">take</code>、<code class="fe le lf lg lh b">takeLast</code>、<code class="fe le lf lg lh b">takeUntil</code>和<code class="fe le lf lg lh b">takeWhile</code>操作符。</p><h1 id="f998" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><code class="fe le lf lg lh b">skipUntil</code></h1><p id="aea0" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">操作符返回一个可观察对象，它跳过源可观察对象发出的项目，直到第二个可观察对象发出一个项目。</p><p id="a2c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它需要一个参数，即<code class="fe le lf lg lh b">notifer</code>可观测值。当它发出一个项目时，那么源可观察对象的发出值将由<code class="fe le lf lg lh b">skipUntil</code>操作符发出。</p><p id="5d03" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="47e6" class="mt lj it lh b gy mu mv l mw mx">import { interval } from "rxjs";<br/>import { skipUntil, take } from "rxjs/operators";</span><span id="345e" class="mt lj it lh b gy my mv l mw mx">const numbers = interval(1000).pipe(<br/>  take(10),<br/>  skipUntil(interval(5000).pipe(take(1)))<br/>);<br/>numbers.subscribe(x =&gt; console.log(x));</span></pre><p id="911f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码从<code class="fe le lf lg lh b">interval(1000)</code> Observabkem获取发出的值，然后<code class="fe le lf lg lh b">pipe</code>将其传递给<code class="fe le lf lg lh b">take(10)</code>操作符以获取前10个值，然后将这些值传递给<code class="fe le lf lg lh b">skipUntil</code>操作符，该操作符传入了<code class="fe le lf lg lh b">interval(5000).pipe(take(1))</code>可观察值。</p><p id="3f07" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">interval(5000).pipe(take(1))</code>在5秒后发出一个值，然后触发<code class="fe le lf lg lh b">interval(1000)</code>可观察的发射值的发射。</p><p id="4f75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们应该看到:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="30f4" class="mt lj it lh b gy mu mv l mw mx">4<br/>5<br/>6<br/>7<br/>8<br/>9</span></pre><h1 id="d539" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">滑雪时</h1><p id="6e29" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">skipWhile</code>操作符返回一个可观察对象，它跳过源可观察对象发出的所有项目，直到<code class="fe le lf lg lh b">predicate</code>函数返回的条件变为<code class="fe le lf lg lh b">false</code>。</p><p id="f153" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它需要一个参数，这是一个<code class="fe le lf lg lh b">predicate</code>函数，用该函数返回的条件测试每一项。</p><p id="0a46" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以这样写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="32d3" class="mt lj it lh b gy mu mv l mw mx">import { of } from "rxjs";<br/>import { skipWhile } from "rxjs/operators";</span><span id="6513" class="mt lj it lh b gy my mv l mw mx">const numbers = of(1, 2, 3, 4, 5, 6).pipe(skipWhile(x =&gt; x &lt; 3));<br/>numbers.subscribe(x =&gt; console.log(x));</span></pre><p id="5cf4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么当这个值小于3时，<code class="fe le lf lg lh b">of(1, 2, 3, 4, 5, 6)</code>可观测的物品就不会被发射。这意味着<code class="fe le lf lg lh b">numbers</code>会发出3，4，5，6。</p><p id="df57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦<code class="fe le lf lg lh b">predicate</code>函数中的条件被测试<code class="fe le lf lg lh b">false</code>一次，它将继续发射，不管来自源可观测值的发射值是否使条件评估为<code class="fe le lf lg lh b">false</code>。</p><p id="a6de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="60f0" class="mt lj it lh b gy mu mv l mw mx">import { of } from "rxjs";<br/>import { skipWhile } from "rxjs/operators";</span><span id="e8ff" class="mt lj it lh b gy my mv l mw mx">const numbers = of(1, 2, 3, 4, 3, 2).pipe(skipWhile(x =&gt; x &lt; 3));<br/>numbers.subscribe(x =&gt; console.log(x));</span></pre><p id="dea5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到3、4、5和2，因为一旦第一个3由<code class="fe le lf lg lh b">of(1, 2, 3, 4, 3, 2)</code>发出，条件就变成了<code class="fe le lf lg lh b">false</code>。</p><h1 id="8857" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">拿</h1><p id="a1f0" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">take</code>操作符返回一个可观察对象，它发出由源可观察对象发出的第一个<code class="fe le lf lg lh b">count</code>值。</p><p id="44d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它有一个参数是<code class="fe le lf lg lh b">count</code>，它表示要发出的值的最大数量。</p><p id="b262" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="1512" class="mt lj it lh b gy mu mv l mw mx">import { of } from "rxjs";<br/>import { take } from "rxjs/operators";</span><span id="63bc" class="mt lj it lh b gy my mv l mw mx">const numbers = of(1, 2, 3, 4, 3, 2).pipe(take(2));<br/>numbers.subscribe(x =&gt; console.log(x));</span></pre><p id="4fba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，由于我们将2传递给了<code class="fe le lf lg lh b">take</code>操作符，所以我们记录了1和2。</p><h1 id="7655" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">takeLast</h1><p id="13cf" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">takeLast</code>运算符返回一个可观察对象，该可观察对象发出由源可观察对象发出的最后一个<code class="fe le lf lg lh b">count</code>值。</p><p id="3dc0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它有一个参数是<code class="fe le lf lg lh b">count</code>，从值序列的末尾发出的值的最大数量。</p><p id="8b9f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="67bd" class="mt lj it lh b gy mu mv l mw mx">import { of } from "rxjs";<br/>import { takeLast } from "rxjs/operators";</span><span id="008e" class="mt lj it lh b gy my mv l mw mx">const numbers = of(1, 2, 3, 4, 5, 6).pipe(takeLast(2));<br/>numbers.subscribe(x =&gt; console.log(x));</span></pre><p id="bc3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该得到5和6，因为我们将2传递给了<code class="fe le lf lg lh b">takeLast</code>操作符，这意味着我们只想要来自发出的<code class="fe le lf lg lh b">of(1, 2, 3, 4, 5, 6)</code>可观察值的最后2个值。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/79368d69fcc257aa00cb6ced07aea331.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0A3SGjOM-2ae1oyj"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@mpho_mojapelo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Mpho Mojapelo </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="ef39" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">直到</h1><p id="8a5b" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">takeUntil</code>操作符返回一个从源可观察对象发出值的可观察对象，直到<code class="fe le lf lg lh b">notifier</code>可观察对象发出值。</p><p id="1d20" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它接受一个参数，即<code class="fe le lf lg lh b">notifier</code>，其发出的值将导致返回可观察对象停止从源可观察对象发出值。</p><p id="2d5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b9cc" class="mt lj it lh b gy mu mv l mw mx">import { interval, timer } from "rxjs";<br/>import { takeUntil } from "rxjs/operators";</span><span id="578a" class="mt lj it lh b gy my mv l mw mx">const source = interval(1000);<br/>const result = source.pipe(takeUntil(timer(5000)));<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="7622" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码将发出来自<code class="fe le lf lg lh b">source</code>可观察值的值，直到<code class="fe le lf lg lh b">timer(5000)</code>发出它的第一个值。</p><p id="6dd3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们应该得到这样的结果:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="1fea" class="mt lj it lh b gy mu mv l mw mx">0<br/>1<br/>2<br/>3</span></pre><h1 id="a93f" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">抓紧时间</h1><p id="c5e4" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">只要满足<code class="fe le lf lg lh b">predicate</code>函数中的条件，操作符<code class="fe le lf lg lh b">takeWhile</code>就会返回一个发出源可观察值的可观察值，一旦条件不满足，操作就会完成。</p><p id="bedf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它采用参数，即返回条件以检查来自源可观测值的每个值的<code class="fe le lf lg lh b">predicate</code>函数。该函数将来自源可观察对象的项作为第一个参数，将发出的值的索引(从0开始)作为第二个参数。</p><p id="8afa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="ed1a" class="mt lj it lh b gy mu mv l mw mx">import { interval } from "rxjs";<br/>import { takeWhile } from "rxjs/operators";</span><span id="5fe9" class="mt lj it lh b gy my mv l mw mx">const source = interval(1000);<br/>const result = source.pipe(takeWhile(x =&gt; x &lt;= 10));<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="762c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们应该得到:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="bac2" class="mt lj it lh b gy mu mv l mw mx">0<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9<br/>10</span></pre><p id="3b6f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于我们在<code class="fe le lf lg lh b">predicate</code>函数中指定了<code class="fe le lf lg lh b">x =&gt; x &lt;= 10</code>，这意味着任何小于或等于10的值都会从源可观测值中被发射出来。</p><p id="de4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">skipUntil</code>操作符返回一个可观察对象，它跳过源可观察对象发出的项目，直到第二个可观察对象发出一个项目。</p><p id="6aea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">skipWhile</code>操作符返回一个可观察对象，它跳过源可观察对象发出的所有项目，直到传递给<code class="fe le lf lg lh b">predicate</code>函数的条件变为<code class="fe le lf lg lh b">false</code></p><p id="6ab2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">take</code>操作符返回一个可观察对象，它发出源可观察对象发出的第一批值。</p><p id="7e8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">takeLast</code>操作符返回一个可观察对象，它发出源可观察对象发出的最后几个值。</p><p id="1b2c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">takeUntil</code>运算符返回一个从源可观察对象发出值的可观察对象，直到传入该运算符的可观察对象发出值。</p><p id="9d81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，<code class="fe le lf lg lh b">takeWhile</code>操作符返回一个可观察对象，只要传递给它的条件得到满足，这个可观察对象就会发出由源可观察对象发出的值。</p></div></div>    
</body>
</html>