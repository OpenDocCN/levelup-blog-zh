<html>
<head>
<title>4 Problems of Angular 14 Typed Forms and How to Fix Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角形14类表格的4个问题及解决方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-new-angular-14-typed-forms-isnt-good-and-how-to-fix-it-1ffebf193df?source=collection_archive---------0-----------------------#2022-07-16">https://levelup.gitconnected.com/why-new-angular-14-typed-forms-isnt-good-and-how-to-fix-it-1ffebf193df?source=collection_archive---------0-----------------------#2022-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="73a9" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">1.我们无法从模型中获取控件类型</h1><p id="5774" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">你不能从你的模型类型中得到<code class="fe lj lk ll lm b">FormGroup</code>或<code class="fe lj lk ll lm b">FormArray</code>。但是在现实世界的形式中，与模型绑定。例如，您应该能够从模型中构造控件的类型。</p><p id="6df5" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">您定义了一些模型:</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="6ba5" class="ma jo iq lm b gy mb mc l md me">interface Model {<br/>  a: string;<br/>  b: number;<br/>}</span></pre><p id="d6c3" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">然后定义类型:</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="b3f6" class="ma jo iq lm b gy mb mc l md me">type Form: SomeMagicType&lt;Model&gt;;</span></pre><p id="be7d" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">然后你会在我们的<code class="fe lj lk ll lm b">Form</code>中看到类似的东西:</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="7dc2" class="ma jo iq lm b gy mb mc l md me">FormGroup&lt;{<br/>  a: FormControl&lt;string&gt;;<br/>  b: FormControl&lt;number&gt;;<br/>}&gt;</span></pre><p id="7393" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">我知道你可能需要管理你想要的:<code class="fe lj lk ll lm b">FormGroup</code>或<code class="fe lj lk ll lm b">FormControl</code>或<code class="fe lj lk ll lm b">FormArray</code>在某些情况下，它是可能实现的，我会在“让我们修复它”一章中告诉你如何实现。</p><h1 id="f568" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">2.fb.group <form> (…)不支持数组语法</form></h1><p id="5365" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">假设您有表单类型，但是<code class="fe lj lk ll lm b">fb.group&lt;Form&gt;(...)</code>不支持数组语法，例如:</p><p id="60a7" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">您有一些表单类型:</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="7f5d" class="ma jo iq lm b gy mb mc l md me">type Form = FormGroup&lt;{<br/>  a: FormControl&lt;string&gt;;<br/>  b: FormControl&lt;number&gt;;<br/>}&gt;</span></pre><p id="f884" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">然后你传给fb.group:</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="5b7c" class="ma jo iq lm b gy mb mc l md me">const fb = new FormBuilder()</span><span id="2b2a" class="ma jo iq lm b gy mf mc l md me">const form: Form = fb.group&lt;Form['controls']&gt;({<br/>  a: ['test'],<br/>  b: [42, Validators.required]<br/>})</span></pre><p id="634c" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">但是如果你尝试了，就不行了，因为fb.group不支持那个语法。所以我们不能修复那个bug，它站在有棱角的开发者一边</p><h1 id="491c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">3.您应该为表单编写无用的样板代码</h1><p id="841b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果你需要一些表单，并且需要在它初始化之前获取表单类型，那么你应该为它定义类型并定义类似的表单实例。这是样板代码，如果你有很多表格，这将是非常无聊的，当然，当你键入大量无聊的代码时，你可能会犯错误。示例:</p><p id="6d66" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">你有一个模型:</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="9efd" class="ma jo iq lm b gy mb mc l md me">interface User {<br/>  firstName: string;<br/>  lastName: string;<br/>  birthday: Date;<br/>  nickname: string;<br/>}</span></pre><p id="77d8" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">然后你应该定义你的类型:</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="96e0" class="ma jo iq lm b gy mb mc l md me">type UserForm = FormGroup&lt;{<br/>  firstName: FormControl&lt;string | null&gt;;<br/>  lastName: FormControl&lt;string | null&gt;;<br/>  birthday: FormControl&lt;Date | null&gt;;<br/>  nickname: FormControl&lt;string | null&gt;;<br/>}&gt;</span></pre><p id="91c0" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">然后，您应该定义您的表单:</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="afef" class="ma jo iq lm b gy mb mc l md me">const userForm: UserForm = fb.group({<br/>  firstName: fb.control&lt;string | null&gt;(null),<br/>  lastName: fb.control&lt;string | null&gt;(null),<br/>  birthday: fb.control&lt;Date | null&gt;(null),<br/>  nickname: fb.control&lt;string | null&gt;(null),<br/>})</span></pre><h1 id="f8b4" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">4.样板代码对模型一无所知</h1><p id="8235" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">从上一个问题可以看出，<code class="fe lj lk ll lm b">UserForm</code>对<code class="fe lj lk ll lm b">User</code>接口一无所知。</p><p id="b4fd" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">如果我们的模型改变了，你应该修正两个地方(<code class="fe lj lk ll lm b">UserForm</code>类型和<code class="fe lj lk ll lm b">userForm</code> <code class="fe lj lk ll lm b">const</code>)。</p><p id="2d51" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">此外，您只会在使用setValue或patch之类的地方看到错误。这些都是间接错误，对开发者没有好处。</p><h1 id="148f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">让我们修理它</h1><p id="69d4" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">所以我们需要一种魔法来解决我们的问题。但是它看起来像什么？</p><p id="43c8" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">假设我们有一个复杂的模型:</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="e2b2" class="ma jo iq lm b gy mb mc l md me">interface Model {<br/>    a: number;<br/>    b: string[];<br/>    c: {<br/>        d: {<br/>            e: number[];<br/>        }<br/>    }<br/>}</span></pre><p id="23bc" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">我们需要递归地将我们的<code class="fe lj lk ll lm b">Model</code>变成<code class="fe lj lk ll lm b">FormGroup</code>、<code class="fe lj lk ll lm b">FormArray</code>和<code class="fe lj lk ll lm b">FormControl</code>的集合。</p><p id="f57a" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">在TypeScript中，我们有<code class="fe lj lk ll lm b"><a class="ae mg" href="https://www.typescriptlang.org/docs/handbook/2/mapped-types.html" rel="noopener ugc nofollow" target="_blank">Mapped Types</a></code>，类型可以是递归的。我们还需要<code class="fe lj lk ll lm b"><a class="ae mg" href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html" rel="noopener ugc nofollow" target="_blank">Conditional Types</a></code>来管理我们想要推断的内容。</p><p id="5b40" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">但是我们怎么知道我们想要推断什么呢？有些情况下<code class="fe lj lk ll lm b">Model.b</code>应该是<code class="fe lj lk ll lm b">FormControl</code>而不是<code class="fe lj lk ll lm b">FormArray</code>或者<code class="fe lj lk ll lm b">Model.c</code>应该是<code class="fe lj lk ll lm b">FormGroup</code>而不是<code class="fe lj lk ll lm b">FormControl</code>，我们该如何描述？</p><p id="7ecf" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">我们需要注释来定义嵌套对象的输出类型。</p><p id="9da7" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">假设我们的类型应该是这样的:</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="fdae" class="ma jo iq lm b gy mb mc l md me">type FormModel&lt;TModel, TAnnotation&gt; = ...</span></pre><p id="03c0" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">我们有一些对象、数组和原语，假设<code class="fe lj lk ll lm b">Model.b</code>应该是<code class="fe lj lk ll lm b">FormArray</code>,<code class="fe lj lk ll lm b">Model.c.d</code>应该是<code class="fe lj lk ll lm b">FormGroup</code>。如何编写可以传递给类型参数的注释？应该是一个类型吧！好，我们可以用什么来描述类型？我们可以使用对象、数组和常量，这就是我们所需要的！</p><p id="99b5" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">所以我们可以这样写我们的注释:</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="f6a2" class="ma jo iq lm b gy mb mc l md me">type Annotation = { b: 'array', c: { d: 'group' } }</span></pre><p id="bc46" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">并且是正确的TypeScript类型。我们可以利用这一点。</p><p id="f87a" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">所以我们使用<code class="fe lj lk ll lm b"><a class="ae mg" href="https://www.typescriptlang.org/docs/handbook/2/mapped-types.html" rel="noopener ugc nofollow" target="_blank">Mapped Types</a></code>和<code class="fe lj lk ll lm b"><a class="ae mg" href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html" rel="noopener ugc nofollow" target="_blank">Conditional Types</a></code>将<code class="fe lj lk ll lm b">Model</code>类型映射到一组控件。我们可以通过特殊的<code class="fe lj lk ll lm b">Annotation</code>来告诉我们的<code class="fe lj lk ll lm b">FormModel</code>我们需要推断什么控件。然后我们基于我们的<code class="fe lj lk ll lm b">Model</code>得到递归构造的<code class="fe lj lk ll lm b">FormGroup</code>类型。</p><p id="0f6a" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">这一章只是对主要思想的总结。如果你愿意，你可以深入到现成的解决方案中，阅读我的库中的文档、测试和代码</p><div class="mh mi gp gr mj mk"><a href="https://github.com/iamguid/ngx-mf" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ir gy z fp mp fr fs mq fu fw ip bi translated">GitHub - iamguid/ngx-mf:将模型类型绑定到angular FormGroup类型</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">ngx-mf是递归推断角度FormGroup、FormArray或FormControl类型的零依赖性类型脚本集…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">github.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my mz mk"/></div></div></a></div><p id="8879" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">还有，你可以在https://stackblitz.com/edit/angular-ngx-mf上试试</p><p id="2a7e" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">感谢您的阅读，祝您愉快！</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="1609" class="jn jo iq bd jp jq nh js jt ju ni jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk bi translated">分级编码</h1><p id="9d6c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="284e" class="nm nn iq kn b ko ln ks lo kw no la np le nq li nr ns nt nu bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="ef67" class="nm nn iq kn b ko nv ks nw kw nx la ny le nz li nr ns nt nu bi translated">📰查看<a class="ae mg" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>中的更多内容</li><li id="bf4b" class="nm nn iq kn b ko nv ks nw kw nx la ny le nz li nr ns nt nu bi translated">🔔关注我们:<a class="ae mg" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae mg" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae mg" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li><li id="4b5e" class="nm nn iq kn b ko nv ks nw kw nx la ny le nz li nr ns nt nu bi translated">🚀👉<a class="ae mg" href="https://jobs.levelup.dev/jobs?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank"> <strong class="kn ir">软件工程师的顶级工作</strong> </a></li></ul></div></div>    
</body>
</html>