<html>
<head>
<title>Introduction to Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归介绍</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-recursion-7848231b0d1b?source=collection_archive---------0-----------------------#2018-07-17">https://levelup.gitconnected.com/introduction-to-recursion-7848231b0d1b?source=collection_archive---------0-----------------------#2018-07-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="45b1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">递归如何工作的可视化表示和解释。</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/4510732ea8276c760f5b74554488260b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AkKo7CuIrvRzOtNV"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated"><a class="ae kw" href="https://i.redditmedia.com/LMkJ4cPOIM1DUXr_4WiqtTa1TesLyTPKvQB1zeSGsCM.jpg?s=fc887c7be031ee51426b8379c5b76024" rel="noopener ugc nofollow" target="_blank">https://I . redditmedia . com/lmkj 4 copim 1 duxr _ 4 wiqt 1 teslytpk vqb 1 zesgscm . jpg？s = fc 887 c7be 031 ee 51426 b 8379 C5 b 76024</a></figcaption></figure><p id="ca4b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi lt translated"><span class="l lu lv lw bm lx ly lz ma mb di">我</span>清晰地记得在大学的那一天，我的《数据结构导论》教授介绍了递归的概念。我的大脑立刻爆炸了。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="9614" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是一个如此激进的想法，我觉得自己就像一个长着腿的土豆，试图弄清楚到底发生了什么。</p><p id="ce70" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">是的，递归可能是一个令人头疼的问题……但是一旦你把它抽出来，解决方案就变得清晰多了。所以今天，我将分解一个简单的递归问题，希望你也能掌握这个复杂的主题。</p><h1 id="3847" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">什么是递归？</h1><p id="6298" class="pw-post-body-paragraph kx ky iq kz b la mw jr lc ld mx ju lf lg my li lj lk mz lm ln lo na lq lr ls ij bi translated">递归是<a class="ae kw" href="https://en.wikipedia.org/wiki/Recursion_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <em class="nb">“一种解决问题的方法，其解决方案依赖于同一问题的较小实例的解决方案(与迭代相反)</em> </a> <em class="nb">”</em></p><p id="e747" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">递归示例#1:玉米饼摊</strong></p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nc"><img src="../Images/b43de5820d5b8c59b92a1485c84ed8c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8K3NHuz5MS0UdWgSVofY2A.png"/></div></div></figure><p id="49d6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">假设你在排队买玉米卷，但不幸的是你看不到有多少人在你前面排队。你可以走到队伍的前面，数人数(迭代)。这是一件令人头疼的事情，因为它要求你离开你的位置，而你正在犹豫。</p><p id="4c2a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">相反，你可以问你前面的人，他们前面有多少人在排队。他们不知道答案，所以他们问排在他们前面的人，他们前面有多少人。</p><p id="9459" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这种模式一直持续到问题排到队伍的前面，最后被问的人说“我前面没有人。”然后，每个排队的人都会转过身，告诉他们的邻座他们前面的人数，再加一。这种情况一直持续到你得到最终答案。</p><p id="d97a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">JavaScript代码可能如下所示:</p><pre class="kh ki kj kk gt nd ne nf ng aw nh bi"><span id="dd5b" class="ni mf iq ne b gy nj nk l nl nm">function findPlaceInLine(numberOfPeopleInLine) {<br/>    if(numberOfPeopleInLine === 1) {<br/>        return 0;<br/>    }<br/>    return 1 + findPlaceInLine(numberOfPeopleInLine-1);<br/>}</span></pre><p id="5bba" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">并且为了简洁进行了重构:</p><pre class="kh ki kj kk gt nd ne nf ng aw nh bi"><span id="845e" class="ni mf iq ne b gy nj nk l nl nm">function findPlaceInLine(numberOfPeopleInLine) {<br/>    return numberOfPeopleInLine === 1 ? 0 : 1 + findPlaceInLine(numberOfPeopleInLine-1);<br/>}</span></pre><p id="80f2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">你可能想知道…好吧，但是这两种解决方案都需要你遍历整行才能得到答案，所以在这里使用递归没有任何好处。</p><p id="0ef2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">你完全正确。但是在一些用例中，递归可以大大超越迭代解决方案。</p><p id="c252" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">递归示例#2:地址簿</strong></p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nn"><img src="../Images/72dd96546d6125e9d29ad0d79f0a21c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oqyz_nqXGQmoA2x-XhhW2A.png"/></div></div></figure><p id="5501" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">假设你要结婚了。你发出了所有的邀请，收到了所有的回复，除了一个人:莎伦阿姨。</p><p id="3c05" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">莎伦阿姨是出了名的可疑…所以你决定打电话给她，要求知道她的反应。</p><p id="2e1b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">你拿出你的地址簿，有两个选择。你可以从第一页开始，一页一页翻，直到找到她的联系方式。如果莎伦阿姨的姓以Z开头，这可能会非常耗时；或者，如果她的姓以a开头会更有效率。嗯…我不想两面下注(尽管我知道莎伦阿姨的姓…在这里和我一起工作。)</p><p id="ac8b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">相反，你决定翻到书的中间，用“二分搜索法算法”来查找她。</p><p id="3901" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我不打算深入研究算法，但二分搜索法算法的前提是，它抓取一个排序数组中的中间元素，并将目标值与中间元素进行比较。如果目标值和中间元素相等，则返回中间元素(woohoo！)如果目标低于中间，则在数组的下半部分递归，否则在上半部分递归(并丢弃中间的元素)。</p><p id="a0be" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因为莎伦阿姨的姓很古怪，而且字母表有26个字母，所以我们从字母“M”开始(因为有偶数个字母，所以我四舍五入)。因为“F”在M之前，我们做同样的事情，但是使用字母A到L作为新的“数组”。这个过程看起来像这样:</p><pre class="kh ki kj kk gt nd ne nf ng aw nh bi"><span id="b0cb" class="ni mf iq ne b gy nj nk l nl nm">letters = [A - Z]<br/>target = F<br/>middle = M</span><span id="8ba5" class="ni mf iq ne b gy no nk l nl nm">target &lt; M<br/>// recurse on lower half</span><span id="df4c" class="ni mf iq ne b gy no nk l nl nm">letters = [A - L]<br/>middle = F<br/>target = middle<br/>FOUND!</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi np"><img src="../Images/102e638a041b9c67178705c3b54c76ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6LiX6gEA_Uj1JMQv0JYX1g.png"/></div></div></figure><p id="2d45" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">通过使用递归，我们非常快地找到了莎伦阿姨的名字！不幸的是，这个疯女人忘了她买了当天“猫咪博览会”的门票，所以她不会参加你们的婚礼了。</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="ef4c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果这个例子在小范围内为我们节省了宝贵的时间，想象一下在大范围内可以节省多少计算时间。</p><p id="5595" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当然，在某些情况下递归是有问题的(堆栈溢出)，但这是另一天的主题。</p><h1 id="e4c3" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">破解递归编码问题</h1><p id="7148" class="pw-post-body-paragraph kx ky iq kz b la mw jr lc ld mx ju lf lg my li lj lk mz lm ln lo na lq lr ls ij bi translated">完成编码面试的许多焦虑是可怕的递归问题。所以我将带你了解一个常见面试问题的解决方案。</p><p id="aa00" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是取自编码网站<a class="ae kw" href="https://www.hackerrank.com/challenges/the-power-sum/problem" rel="noopener ugc nofollow" target="_blank">黑客等级</a>的问题。</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="43bc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">问题提示:</p><p id="a51b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nb">找出给定整数X可以表示为唯一自然数的n次方之和的方法。</em></p><p id="98e4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">嗯……什么？？</p><p id="512b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们举几个例子:</p><ol class=""><li id="5a84" class="nx ny iq kz b la lb ld le lg nz lk oa lo ob ls oc od oe of bi translated">如果X = 10，N = 2，找出所有加起来等于10的唯一正方形的组合。对此只有一个唯一的解决方案，那就是1 + 3。</li><li id="a263" class="nx ny iq kz b la og ld oh lg oi lk oj lo ok ls oc od oe of bi">100 = (10²) = (6² + 8²) + (1² + 3² + 4² + 5² + 7²).</li></ol><p id="bc45" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">好的，我们开始吧。</p><p id="0bd3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">首先，让我们创建函数框架:</p><pre class="kh ki kj kk gt nd ne nf ng aw nh bi"><span id="1ac4" class="ni mf iq ne b gy nj nk l nl nm">function powerSum(X, N, number) {</span><span id="d02a" class="ni mf iq ne b gy no nk l nl nm">}</span></pre><ul class=""><li id="6bbb" class="nx ny iq kz b la lb ld le lg nz lk oa lo ob ls ol od oe of bi translated">x是我们要寻找的目标值</li><li id="5472" class="nx ny iq kz b la og ld oh lg oi lk oj lo ok ls ol od oe of bi translated">n是我们要乘以的指数</li><li id="a933" class="nx ny iq kz b la og ld oh lg oi lk oj lo ok ls ol od oe of bi translated">number是我们提升到N次方的值</li></ul><p id="566d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nb">注意，随着递归的进行，X和number将改变值，但是N将保持不变。</em></p><p id="cc1f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">好吧，我们首先需要什么？</p><p id="ca18" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">在递归函数中，你首先需要有一个</strong> <strong class="kz ir">基础用例</strong>。如果你没有一个基本情况(一个条件，当满足时，将触发递归冒泡备份)，你将得到一个堆栈溢出错误。</p><p id="c36f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这种情况下，我们将进行3次检查:</p><ul class=""><li id="8d97" class="nx ny iq kz b la lb ld le lg nz lk oa lo ob ls ol od oe of bi translated">number的N次方的值小于X吗？</li><li id="42e0" class="nx ny iq kz b la og ld oh lg oi lk oj lo ok ls ol od oe of bi translated">number的N次方值等于X吗？</li><li id="f85d" class="nx ny iq kz b la og ld oh lg oi lk oj lo ok ls ol od oe of bi translated">number的N次方值是否大于X？</li></ul><p id="95bf" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们概述一下这三种情况下的每一种情况。为了简单起见，我将num的值称为N的幂。</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="44f0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nb">number的N次方值是否小于X？</em></p><p id="8dfa" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果powerof sum&lt; X, we need to recurse on the left and right side.</p><ul class=""><li id="3b62" class="nx ny iq kz b la lb ld le lg nz lk oa lo ob ls ol od oe of bi translated">On the left side, we call  【T0】  with X = 10, N = 2, and number = 2.</li><li id="f4f9" class="nx ny iq kz b la og ld oh lg oi lk oj lo ok ls ol od oe of bi translated">On the right side, we call  【T1】  with X having the value of X minus the  【T2】  variable we declared above (num to the power of N), N stays 2, and number = number + 1;</li></ul></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="de4c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nb">number的N次方的值等于X？</em></p><p id="ad8b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果<code class="fe om on oo ne b">powerOfNum</code>的值等于X，则返回1，因为我们已经得到了加起来等于目标的平方和！</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="7cc4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nb">number的N次方值是否大于X？</em></p><p id="111a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这种情况下，我们没有等于目标的平方和，所以只返回0。</p><p id="4612" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">太好了！所以我们来写代码吧。</p><pre class="kh ki kj kk gt nd ne nf ng aw nh bi"><span id="9d35" class="ni mf iq ne b gy nj nk l nl nm">function powerSum(X, N, number) {<br/>   let powerOfNum = Math.pow(number, N);</span><span id="c203" class="ni mf iq ne b gy no nk l nl nm">   if(powerOfNum &lt; X) {<br/>      return powerSum(X, N, number+1) + powerSum(X - powerOfNum, N, number + 1);<br/>   } else if (powerOfNum === X) {<br/>       return 1;<br/>   } else {<br/>       return 0;<br/>   }  <br/>}</span></pre><p id="8e47" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这有点难以理解，所以这里有一个X = 10和N = 2的递归树的图示。你可以看到，当X = 10时，只有一个解。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi op"><img src="../Images/54712bdc4d1809f78401369918f6b40a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LjXs5-lOObVh4P9noP0lMg.png"/></div></div></figure><p id="8c52" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是流程的样子:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi op"><img src="../Images/6cd9e129a993d134911e3ff972ad6aa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C_BG1dqp6oBRhkXQVGI_Ow.png"/></div></div></figure><p id="3d40" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果其他方法都失败了，就用蛮力吧。</p><h1 id="2236" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">结论</h1><p id="68fc" class="pw-post-body-paragraph kx ky iq kz b la mw jr lc ld mx ju lf lg my li lj lk mz lm ln lo na lq lr ls ij bi translated">我并不自称是递归专家，但是以这种方式思考复杂的主题有助于使它更容易理解。</p><p id="0926" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你喜欢这篇文章，我令人敬畏的类比，或者我高超的图表制作技巧，请随意给我一两下掌声，然后跟我来！</p><p id="63c8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">感谢阅读！</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oq"><img src="../Images/cf8fb57f0beb16c700b0fab90984ffa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UTOmvaJpYT8DMp6ys4xXnw.png"/></div></div></figure><p id="5ae0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Emma Bostian是德国卡尔斯鲁厄LogMeIn公司的一名软件工程师。她喜欢看书，写娱乐性的博客，用第三人称谈论自己。</p></div></div>    
</body>
</html>