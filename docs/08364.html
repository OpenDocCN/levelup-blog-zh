<html>
<head>
<title>LINQ: Beware of deferred execution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LINQ:当心延期执行</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/linq-beware-of-deferred-execution-9723581d4cda?source=collection_archive---------9-----------------------#2021-04-25">https://levelup.gitconnected.com/linq-beware-of-deferred-execution-9723581d4cda?source=collection_archive---------9-----------------------#2021-04-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f0dee08a1322bbead57d2643705ab0f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0sOx84fB26Nki-Mc"/></div></div></figure><p id="ff71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你曾经接触过C#和。NET，你可能已经遇到过<a class="ae kw" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/" rel="noopener ugc nofollow" target="_blank"> LINQ(语言集成查询)</a>，它允许你直接在C#语言中使用一系列强大的查询功能。</p><p id="8747" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的例子演示了LINQ的几个常见特性(注意，我使用的是扩展方法语法，而不是LINQ表达式)。在本例中，我们有一个人的列表，并希望获得该列表中成年人的姓名列表。然后，我们将对这些名称进行两次迭代(这将有助于演示立即执行和延迟执行之间的区别)。</p><p id="73e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用LINQ，我们可以:</p><ul class=""><li id="0834" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">使用<code class="fe lg lh li lj b">Where</code>按年龄过滤</li><li id="cd3b" class="kx ky iq ka b kb lk kf ll kj lm kn ln kr lo kv lc ld le lf bi translated">使用<code class="fe lg lh li lj b">Select</code>从Person对象映射到name字符串</li><li id="fc74" class="kx ky iq ka b kb lk kf ll kj lm kn ln kr lo kv lc ld le lf bi translated">使用<code class="fe lg lh li lj b">ToList</code>将查询评估为列表</li></ul><pre class="lp lq lr ls gt lt lj lu lv aw lw bi"><span id="6208" class="lx ly iq lj b gy lz ma l mb mc">public class Person<br/>{<br/>    public string Name { get; set; }<br/>    public int Age { get; set; }<br/>}</span><span id="e23d" class="lx ly iq lj b gy md ma l mb mc">var people = new List&lt;Person&gt;<br/>{<br/>    new Person { Name = "Sam", Age = 27 },<br/>    new Person { Name = "Suzie", Age = 17 },<br/>    new Person { Name = "Harry", Age = 23 },<br/>};</span><span id="320e" class="lx ly iq lj b gy md ma l mb mc">var adultNames = people<br/>    .Where(person =&gt; <br/>    {<br/>        Console.WriteLine("Filtering by age...");<br/>        return person.Age &gt;= 18;<br/>    })<br/>    .Select(person =&gt; person.Name)<br/>    .ToList();</span><span id="dd07" class="lx ly iq lj b gy md ma l mb mc">foreach(var name in adultNames)<br/>    Console.Writeline(name);</span><span id="0c19" class="lx ly iq lj b gy md ma l mb mc">foreach(var name in adultNames)<br/>    Console.Writeline(name);</span><span id="201e" class="lx ly iq lj b gy md ma l mb mc">/* output<br/>Filtering by age<br/>Filtering by age<br/>Filtering by age<br/>Sam<br/>Harry<br/>Sam<br/>Harry<br/>*/</span></pre><p id="a38e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，在上面的例子中，我们显式地将查询转换为列表。这将立即执行查询，给出一个只包含成人姓名的新列表，然后我们可以对其进行迭代。</p><p id="bd3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们去掉<code class="fe lg lh li lj b">ToList</code>，会发生什么？</p><pre class="lp lq lr ls gt lt lj lu lv aw lw bi"><span id="d85a" class="lx ly iq lj b gy lz ma l mb mc">var adultNames = people<br/>    .Where(person =&gt; <br/>    {<br/>        Console.WriteLine("Filtering by age...");<br/>        return person.Age &gt;= 18;<br/>    })<br/>    .Select(person =&gt; person.Name);</span><span id="7993" class="lx ly iq lj b gy md ma l mb mc">foreach(var name in adultNames)<br/>    Console.Writeline(name);</span><span id="f900" class="lx ly iq lj b gy md ma l mb mc">foreach(var name in adultNames)<br/>    Console.Writeline(name);</span><span id="ef4a" class="lx ly iq lj b gy md ma l mb mc">/* output<br/>Filtering by age<br/>Sam<br/>Filtering by age<br/>Filtering by age<br/>Harry<br/>Filtering by age<br/>Sam<br/>Filtering by age<br/>Filtering by age<br/>Harry<br/>*/</span></pre><p id="b2c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在输出看起来很不一样。不是首先进行所有的过滤，然后遍历成人姓名，而是在我们评估每一项之前立即对该项进行过滤。重要的是，过滤也发生在我们每次迭代条目的时候。这就是所谓的延迟执行，因为我们要等到真正需要值来评估查询时才执行。</p><h1 id="4dd1" class="me ly iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">延期执行的好处</h1><p id="00d6" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">看起来延迟执行是LINQ的默认行为，除非你明确地告诉它立即求值(使用ToList，ToDictionary等)。).所以这么做肯定有好处吧？</p><h2 id="e4a0" class="lx ly iq bd mf ng nh dn mj ni nj dp mn kj nk nl mr kn nm nn mv kr no np mz nq bi translated">1.更好的性能</h2><p id="4322" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">在大多数情况下，预计延迟执行会带来更好的性能，因为您不必一次对整个数据集执行查询。相反，您可以一次对一个项目执行查询，因为您已经对它进行了迭代。</p><h2 id="947b" class="lx ly iq bd mf ng nh dn mj ni nj dp mn kj nk nl mr kn nm nn mv kr no np mz nq bi translated">2.查询构造</h2><p id="81b4" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">由于查询不需要立即执行，您可以分几个步骤构建它，也许要通过附加的条件逻辑。这为您创建更复杂的查询提供了额外的能力。</p><pre class="lp lq lr ls gt lt lj lu lv aw lw bi"><span id="a22c" class="lx ly iq lj b gy lz ma l mb mc">public IEnumerable&lt;Person&gt; GetNames(IEnumerable&lt;Person&gt; people, bool onlyAdults)<br/>{<br/>    var query = people.AsEnumerable();</span><span id="f84c" class="lx ly iq lj b gy md ma l mb mc">    if (onlyAdults)<br/>    {<br/>        // only add this filter when onlyAdults is true<br/>        query = query.Where(person =&gt; person.Age &gt;= 18);<br/>    }</span><span id="74bc" class="lx ly iq lj b gy md ma l mb mc">    query = query.Select(person =&gt; person.Name);</span><span id="e42a" class="lx ly iq lj b gy md ma l mb mc">    return query.ToList();<br/>}</span></pre><h2 id="cec4" class="lx ly iq bd mf ng nh dn mj ni nj dp mn kj nk nl mr kn nm nn mv kr no np mz nq bi translated">3.总是重估</h2><p id="c7bc" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">由于查询总是在每个枚举上被重新赋值，所以在查询被构造之后，你可以添加/移除/改变你的集合的元素，并且查询将知道这些改变。这样，您就知道您总是在迭代最新的数据。</p><pre class="lp lq lr ls gt lt lj lu lv aw lw bi"><span id="02a7" class="lx ly iq lj b gy lz ma l mb mc">var people = new List&lt;Person&gt;<br/>{<br/>    new Person { Name = "Sam", Age = 27 },<br/> new Person { Name = "Suzie", Age = 17 },<br/> new Person { Name = "Harry", Age = 23 },<br/>};<br/>   <br/>var adultNames = people<br/> .Where(person =&gt; person.Age &gt;= 18)<br/> .Select(person =&gt; person.Name);<br/>  <br/>foreach(var name in adultNames)<br/> Console.WriteLine(name);<br/>  <br/>people.Add(new Person { Name = "Sally", Age = 26 });<br/>  <br/>foreach(var name in adultNames)<br/> Console.WriteLine(name);</span><span id="861a" class="lx ly iq lj b gy md ma l mb mc">/* output<br/>Sam<br/>Harry<br/>Sam<br/>Harry<br/>Sally<br/>*/</span></pre><h1 id="e813" class="me ly iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">延期执行的陷阱</h1><p id="0fd3" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">尽管目前为止对LINQs延迟执行赞不绝口，这篇文章还是受到了我在使用它时遇到的一些问题的启发。如果您在编写代码时不够小心，它的好处之一也是一个陷阱——查询总是被重新评估。</p><p id="6ebe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然延迟执行通常被认为是一种性能优势，但是如果不小心的话，有时它会大大降低应用程序的速度。任何时候，如果您知道您需要多次重复相同的集合(例如嵌套的for/foreach循环)，请确保首先调用list。否则，您将每次都评估整个集合，这将极大地降低性能。如果源集合特别大，尤其如此，因为即使您的查询进行了大量过滤，查询每次都会应用到整个源集合。</p><p id="67b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要提到的最后一个陷阱是使用<code class="fe lg lh li lj b">Select</code>来运行一组任务。我看到有人争论说这是你根本不应该做的事情，但是我在代码库中看到的足够多，知道这是人们确实在做的事情，也是你应该意识到的事情。想象以下场景:</p><pre class="lp lq lr ls gt lt lj lu lv aw lw bi"><span id="c821" class="lx ly iq lj b gy lz ma l mb mc">var listOfIds = new List&lt;int&gt; { 1, 5, 8, 15 };</span><span id="c05f" class="lx ly iq lj b gy md ma l mb mc">var tasks = listOfIds.Select(id =&gt; _repository.GetAsync(id));<br/>await Task.WhenAll(tasks);<br/>var results = tasks.Select(task =&gt; task.Result).ToList();</span></pre><p id="8668" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，GetAsync方法实际上为每个ID执行了两次，第一次是在第一次声明时，第二次是在使用<code class="fe lg lh li lj b">ToList</code>评估查询时。这不仅会因为多次执行昂贵的操作而对性能产生巨大的影响，而且，由于任务是重新执行的，当您真正开始评估它时，并不能保证它会完成。正如您可能想象的那样，如果您正在运行的任务实际上是一个创建或更新操作(是的，我也见过这种情况)，这也是非常危险的。为了安全地执行get，您需要立即评估查询:</p><pre class="lp lq lr ls gt lt lj lu lv aw lw bi"><span id="ba86" class="lx ly iq lj b gy lz ma l mb mc">var tasks = listOfIds.Select(id =&gt; _repository.GetAsync(id)).ToList();</span></pre><p id="7527" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我介绍了。LINQ篮网队。我已经展示了它的一些特性，以及为什么它比立即执行更有益。最后，我讨论了使用LINQ和deffered执行时要注意的一些常见陷阱。</p><p id="03f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我发布的大部分内容都是关于全栈的。NET和Vue web开发。为了确保你不会错过任何帖子，请关注这个博客并<a class="ae kw" href="https://samwalpole.com" rel="noopener ugc nofollow" target="_blank">订阅我的简讯</a>。如果你觉得这篇文章有帮助，请喜欢它并分享它。你也可以在<a class="ae kw" href="https://twitter.com/dr_sam_walpole" rel="noopener ugc nofollow" target="_blank">推特</a>上找到我。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="6247" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ny">原载于</em><a class="ae kw" href="https://samwalpole.com/linq-beware-of-deferred-execution" rel="noopener ugc nofollow" target="_blank"><em class="ny">https://samwalpole.com</em></a><em class="ny">。</em></p></div></div>    
</body>
</html>