<html>
<head>
<title>GraphQL Resolvers in Apollo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apollo中的GraphQL解析器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/graphql-resolvers-in-apollo-cf64d404376f?source=collection_archive---------4-----------------------#2020-03-31">https://levelup.gitconnected.com/graphql-resolvers-in-apollo-cf64d404376f?source=collection_archive---------4-----------------------#2020-03-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5bd0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解Apollo服务器中的上下文对象</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/50444819889b1443f1def8a8d382c0df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZxDw0j3ANBxpatoCdNW8JQ.png"/></div></div></figure><p id="2413" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">本文中介绍的所有模式和思想都在</em><a class="ae lr" href="https://github.com/TheMagoo73/Apollo-Example" rel="noopener ugc nofollow" target="_blank"><em class="lq">https://github.com/TheMagoo73/Apollo-Example</em></a><em class="lq">的演示代码中显示。</em></p><p id="44cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi ls translated">esolvers是创建基于GraphQL的服务的关键元素；在解析器中，您将获取和形成您的数据，无论是在简单的情况下直接从数据库获取，还是更有可能从基于微服务的系统中的其他后端服务和API获取。在本文中，我们将着眼于创建与<a class="ae lr" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank"> Apollo framework </a>一起使用的解析器，然后特别是它提供的经常被忽略的“上下文”对象，以及我们如何在代码中使用它来提高可测试性，并存储“预调用”状态。</p><blockquote class="mb mc md"><p id="e4f8" class="ku kv lq kw b kx ky ju kz la lb jx lc me le lf lg mf li lj lk mg lm ln lo lp im bi translated">在本文中，我们特别关注Apollo，并使用apollo-server-express包。然而，我们在这里看到的对于绝大多数GraphQL服务器框架都是有效的。</p></blockquote><h2 id="f18c" class="mh mi it bd mj mk ml dn mm mn mo dp mp ld mq mr ms lh mt mu mv ll mw mx my mz bi translated">构建解析器</h2><p id="90ff" class="pw-post-body-paragraph ku kv it kw b kx na ju kz la nb jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">让我们看看一个非常简单的旋变器，了解一下发生了什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="d713" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们定义了一个非常简单的GraphQL模式——给定用户名，只需一个查询就可以得到个性化的问候。记住，模式定义了契约，但是我们需要一个解析器通过创建问候并经由Apollo框架返回来实际实现查询。</p><p id="930e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以在<code class="fe nh ni nj nk b">resolvers.Query</code>文字对象中看到这个解析器。注意，Apollo为解析器提供了几个参数，<code class="fe nh ni nj nk b">root, args</code>和<code class="fe nh ni nj nk b">context</code>。让我们更详细地分析一下。</p><p id="b3da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nh ni nj nk b">root</code>参数，也称为<code class="fe nh ni nj nk b">parent</code>，主要用于主从式查询，其中Apollo构建了一个解析器链，以构建更复杂的响应。此参数用于将“父级”解析器的结果传递给其子级。在这篇文章中，我们不会触及它的用法。</p><p id="3652" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据这个例子,<code class="fe nh ni nj nk b">args</code>参数非常简单明了，它是一个对象，包含模式中为每个解析器定义的参数。</p><p id="adf1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">是《阿波罗》中最有趣和最有用的解析器元素之一。默认情况下，在上面的例子中，它将是一个空对象，因为我们还没有定义我们想要它包含什么，Apollo本身不会添加任何东西。为了创建更好的解析器，我们可以使用该参数向每个解析器传递我们定义的对象，该对象注入解析器可以使用的数据和功能，例如数据访问器。在本文的剩余部分，我们将更详细地研究这个特性。</p><h2 id="5018" class="mh mi it bd mj mk ml dn mm mn mo dp mp ld mq mr ms lh mt mu mv ll mw mx my mz bi translated">在上下文中注入功能</h2><p id="095e" class="pw-post-body-paragraph ku kv it kw b kx na ju kz la nb jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">上下文的一个常见用途是将功能注入解析器，下面是一个简单的例子。在这种情况下，我们创建一个“随机报价”查询；我们需要调用一个API并获得一个报价列表，然后从列表中随机抽取一个报价。我们还希望解析器能够记录它在做什么。这个功能是在解析器之外创建的，所以可以很容易地进行单元测试和修改，然后使用上下文将其“注入”到解析器中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="4218" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以看到注入发生在我们创建Apollo服务器的地方；我们创建一个包含数据访问函数的静态上下文对象，以及我们希望解析器使用的记录器。</p><h2 id="2273" class="mh mi it bd mj mk ml dn mm mn mo dp mp ld mq mr ms lh mt mu mv ll mw mx my mz bi translated">使用上下文和注入进行测试</h2><p id="a6b0" class="pw-post-body-paragraph ku kv it kw b kx na ju kz la nb jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">我们已经看到了使用context对象如何允许我们为数据访问之类的事情注入容易测试的单元。但是这种注入也允许我们以一种更加端到端的方式非常容易地测试我们的GraphQL模式和解析器。让我们看看如何使用Mocha和Chia以及上下文来实现这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="2ac3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个例子测试了我们上面定义的API，假设我们已经将resolvers和typedefs重构到单独的文件中(这是一个好的实践)。通过这样做，并将记录器和报价服务的模拟注入到上下文中，我们可以使用<code class="fe nh ni nj nk b">graphql()</code>方法来执行查询并验证响应，从而测试我们的模式和解析器是否正确绑定。</p><h2 id="6d60" class="mh mi it bd mj mk ml dn mm mn mo dp mp ld mq mr ms lh mt mu mv ll mw mx my mz bi translated">动态语境</h2><p id="7d86" class="pw-post-body-paragraph ku kv it kw b kx na ju kz la nb jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">到目前为止，我们已经把上下文看作是一个简单的对象，它是我们在创建服务器时设置的。在简单的情况下，这可能是所有需要的。然而，我们可以使用第二个选项来执行更复杂的用例，那就是在我们创建服务器时提供一个功能。然后，Apollo将为每个请求执行该函数，将返回的对象作为上下文参数传递给每个解析器。</p><p id="7978" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看看实际情况。一个常见的用例是，我们希望在解析器的请求中使用“authentication”头，例如，确保用户可以访问所请求的资源。这个例子使用了流行的Express服务器上的<code class="fe nh ni nj nk b">apollo-server-express</code>,但是这个原则也适用于其他服务器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="c5c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以稍微分解一下这个例子，看看到底发生了什么。</p><p id="f463" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们构建一个简单的模式，通过一个简单的查询就可以得到个性化的问候。然后，我们为查询设置解析器，该查询返回一个问候，并使用来自上下文对象的用户名完成。但是上下文如何知道每个请求的正确名称呢？</p><p id="baf5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实现这一点的关键是Apollo将为每个请求调用的<code class="fe nh ni nj nk b">createConext</code>方法。该方法从Apollo接收一个对象，该对象包含通常会传递给Express中间件的<code class="fe nh ni nj nk b">request</code>和<code class="fe nh ni nj nk b">response</code>对象。在我们的例子中，我们检查了一个<code class="fe nh ni nj nk b">authorization</code>头，如果找到了，就调用一个函数(为了简单起见省略了)从令牌中获取用户详细信息并返回一个用户名。我们将它构建到一个返回的对象中——这个对象将作为上下文传递给每个解析器。</p><p id="090d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，当我们创建Apollo服务器时，我们将createContext方法作为选项中的<code class="fe nh ni nj nk b">context</code>进行传递。Apollo将把它看作一个函数而不是一个简单的对象，并将确保它为每个请求执行。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="2840" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总之，上下文是GraphQL服务器框架的一个关键特性，这一点经常被忽略。然而，它为我们提供了许多非常有用的功能，因此在构建GraphQL API服务器时，花一些时间来考虑是非常值得的。</p></div></div>    
</body>
</html>