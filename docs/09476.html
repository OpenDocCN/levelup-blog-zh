<html>
<head>
<title>Getting the Stack Trace of a Running Python Program</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">获取正在运行的Python程序的堆栈跟踪</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/getting-the-stack-trace-of-a-running-python-program-f6e2f156f53a?source=collection_archive---------1-----------------------#2021-08-14">https://levelup.gitconnected.com/getting-the-stack-trace-of-a-running-python-program-f6e2f156f53a?source=collection_archive---------1-----------------------#2021-08-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/17ccedf59e3814891b75ecbdf8fa0d33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ej8WJLvjwuFntD9Kkc14jg.jpeg"/></div></div></figure><div class=""/><p id="513f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近想考察一个多线程Python程序，花了很长时间才完成，看起来卡死了，甚至偶尔崩溃。</p><p id="4b2b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之前有过java背景，我希望用一些实用程序如<a class="ae kw" href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr016.html" rel="noopener ugc nofollow" target="_blank"> jstack </a>来获得堆栈跟踪。令我惊讶的是，<strong class="ka jc"> Python并没有这样的实用程序，但是我们自己做一个却很容易！</strong></p><h1 id="2f50" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">代码</h1><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="4b22" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很明显——检查正在运行的线程，格式化堆栈跟踪并附加它，然后返回它。</p><p id="5f1b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它使用纯Python库，不需要任何插件。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="181f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">示例输出可能如下所示(主要关注底部):</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h1 id="7ba0" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">测试</h1><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="769f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的输出是测试中print语句的结果——注意，我们期望看到两个线程:主测试线程和我们刚刚创建的线程，以及堆栈跟踪中的测试函数和测试语句。</p><h1 id="175d" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">后续步骤/注意事项</h1><p id="87b0" class="pw-post-body-paragraph jy jz jb ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">因此，我们有了util函数，它可以工作，但是我们需要将它合并到我们的代码中:</p><ol class=""><li id="99fb" class="mn mo jb ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated">如果我们的程序是一个web服务器，我们可以有一个类似REST API的入口点来按需执行它。</li><li id="0447" class="mn mo jb ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">或者，我们可以运行一个守护线程，偶尔打印输出，这样我们就可以持续了解程序的运行情况。</li></ol></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="4411" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！希望这个小工具能在需要的时候帮到你。</p></div></div>    
</body>
</html>