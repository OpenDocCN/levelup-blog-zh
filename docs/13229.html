<html>
<head>
<title>Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">列表</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lists-153438bb822f?source=collection_archive---------13-----------------------#2022-08-18">https://levelup.gitconnected.com/lists-153438bb822f?source=collection_archive---------13-----------------------#2022-08-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/9098cf80171a27f87e7ea6cc4959c03e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jNJ6jE3XIgMZbI9LTR4ttw.gif"/></div></div></figure><div class=""/><p id="b047" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在C#中使用列表有点像在现实生活中使用列表。如果你想跟踪某样东西，特别是同类的东西，把它写在一个列表中，以便组织和保存它的一个<em class="kz">引用</em>。购买食品时，你可能会有一份手写的食品清单。当创建游戏对象时，你可能也想保留一个列表。好了，让我们开始使用列表吧！</p><p id="8e52" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">列表</em>的工作方式与<em class="kz">数组</em>相似，只是有一些不同。首先，声明和初始化的方式看起来有些不同。在<em class="kz"> ItemDatabase </em>类的顶部有两个变量。数组通常是非动态的，这意味着理想情况下您希望数组具有固定的大小。这里用<em class="kz">项数组</em>，为了<em class="kz">初始化</em>它，我需要声明数组<em class="kz"> (10) </em>的<em class="kz">大小</em>。列表可以被动态地<em class="kz"/>添加或删除，所以我不需要在这里声明和初始化<em class="kz"> itemList </em>变量时指定列表长度。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi la"><img src="../Images/e3232d49d5466bf14b223d74ebee0296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YAhBhiCztcVwidKZOwR3MA.png"/></div></div></figure><p id="88d4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">列出了</em>使用的<em class="kz">系统。Collections.Generic </em>名称空间。如此处所示，注释掉名称空间将导致列表出现<em class="kz">错误</em>。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lf"><img src="../Images/be36699a1620eed3e3e7f89be5b03a93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zhLGtoqLwCkwlFknnmJ9aw.png"/></div></div></figure><p id="6763" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个基本的<em class="kz">预设</em>将作为一个例子，说明如何将一个现有的<em class="kz">对象</em>添加到一个<em class="kz">列表</em>中。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/cf9e7fdd409bc1c1532109eee44cdddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*mrcodw3r-n0dmAPbzhWrNw.png"/></div></figure></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><p id="48e6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">添加到一个列表看起来也与数组不同。对于数组，我需要访问我想要初始化的数组的元素。列表可以用内置方法<em class="kz">添加</em>，然后你可以声明一个<em class="kz">现有的</em>游戏对象或者<em class="kz">初始化</em>一个<em class="kz">新的</em>一个。这里两个对象将被<em class="kz">添加到</em>列表中。一个用于通用<em class="kz">新</em>游戏对象，另一个用于<em class="kz"> itemPrafab </em>。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lo"><img src="../Images/a7f1918b42b2b923978bfc9a95345f6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-d5p-1vV3abTaAurpFuicQ.png"/></div></div></figure><p id="76d3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">访问和分配列表中的元素就像数组一样。上面的例子显示了<em class="kz">项目数组</em>访问第一个<em class="kz">元素(0) </em>，然后设置<em class="kz">项目名称</em>。<em class="kz"> itemList，List，</em>也使用<em class="kz">元素</em>系统来指定我正在分配的元素，然后给它命名。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/c67dffba8473aafd9c04d0b9feb396ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*7xTewt5xwCA8hQg8Urhvkg.png"/></div></figure></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><p id="2a93" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">挑战:</strong> <strong class="kd jf"> <em class="kz">姓名</em> </strong></p><p id="6bad" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于一个挑战，我的任务是制作一个<em class="kz">姓名</em>的<em class="kz">列表</em>，然后<em class="kz">用<em class="kz">用户输入</em>从列表中随机删除</em>一个姓名。然后一旦一个名字被删除，我需要<em class="kz">将<em class="kz">列表</em>中的所有名字</em>打印到<em class="kz">控制台</em>。这里的<em class="kz"> namesList </em>变量是用6个不同的名称值硬编码的。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lq"><img src="../Images/b173010442d3f6a15a07c5737b7eb8a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0CKko-zZIawzxMEcQMkRhg.png"/></div></div></figure><p id="a823" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">仍然在void <em class="kz"> Start </em>这里，我向<em class="kz">控制台</em>发送一个<em class="kz">调试</em>日志，让我知道这是将要打印的名字的初始列表。<em class="kz"> foreach </em>循环遍历列表中的每个名字，然后<em class="kz">将</em>打印到控制台。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/ed373713446aabf5f93a2d4b3f414322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*cVPPgmzqP8cROeKhYmUu_Q.png"/></div></figure><p id="1c05" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在void <em class="kz"> Update </em>中，我检查用户<em class="kz">对<em class="kz">空格键</em>的输入</em>，然后运行几个<em class="kz"> if else </em>条件。如果列表中有一个以上的名字，将运行一个函数来<em class="kz">从列表中删除</em>一个名字。如果列表中只有一个名字，一个清除的内置函数将运行<em class="kz">(当允许删除列表名函数将列表总数归零时，我得到了一个错误)</em>。如果这些条件都不满足，那么<em class="kz"> else </em>语句告诉我名单是空的。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ls"><img src="../Images/e5bcecfa1c67ad0104d1de76d01ac46d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1V4H1aEr4edBtNa2Gdky3A.png"/></div></div></figure><p id="4bc7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz"> RemoveListName </em>函数使用一个<em class="kz">局部变量</em>来存储一个<em class="kz">随机范围</em>。该编号将直接引用要从列表中删除的<em class="kz">元素</em>编号。在删除名字之前，我<em class="kz">将它打印到控制台，同时我还有一个对它的工作<em class="kz">引用</em>。这打印为移除的<em class="kz">名称</em>。根据传入的<em class="kz">元素</em>的值，<em class="kz"> Remove </em>函数实际上是从列表中删除名字。另一条<em class="kz">调试</em>消息打印到控制台，表明这是<em class="kz">更新的</em>名单。另一个<em class="kz"> foreach </em>循环运行，将<em class="kz">列表</em>中剩余的<em class="kz">名称打印到控制台。</em></em></p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lt"><img src="../Images/5bd4df62796e7114a5ebc5c270398c71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tQ0qk0ajm43-gnvDWnJo8g.png"/></div></div></figure><p id="6e8c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在检查器中，你可以看到<em class="kz">硬编码的</em>名称，可以选择从这里覆盖它们。<em class="kz">项</em>列表默认为空。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/8990fb7e79d5c4a2634305927aa53767.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*oamXRwIsy6OGGszzim9jTA.png"/></div></figure><p id="5c87" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<em class="kz">初始化</em>时，void <em class="kz">开始</em>中填充的两个示例项目。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/b13fa06ce9e3d56137c5fbe611acfa77.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*5V3AjbFVOcvHZ8hgFhKZ4g.png"/></div></figure><p id="f968" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里你可以看到当我按下<em class="kz">空格键</em>时，名单<em class="kz">会实时减少</em>的数量。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/b584d1a63390cb7e98e1f8d5f494c9d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/1*_gHntfp6tURPvlwBCle5YQ.gif"/></div></figure><p id="bf7c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里是<em class="kz">控制台</em>的打印输出。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/b98b5d4ab29ab0afc087fef1086ce3ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*2GtYnNFkE6vnaP48QIbvbw.png"/></div></figure></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><p id="77a6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">挑战:<em class="kz">产卵对象</em>T73】</strong></p><p id="a2ae" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我的另一个任务是将<em class="kz">个随机的</em>个物体放到<em class="kz">个随机的</em>个位置<em class="kz">(在-10x，10y，0z之间)</em>。这发生在用户<em class="kz">输入</em>时，产生的对象被添加到<em class="kz">列表</em>中。只有<em class="kz"> 10个</em>对象可以在它们全部变成<em class="kz">绿色</em>并且列表被<em class="kz">清除</em>之前繁殖。这里有三个<em class="kz">变量，</em>一个用于某个对象<em class="kz">预置</em>来产卵，两个<em class="kz">列表</em>和一个<em class="kz">布尔</em>条件来确定我们何时完成产卵对象。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ly"><img src="../Images/f0ccb4c1f326336852024a9c64e82065.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rw4LhHCSclcSxr6LcPR7Vw.png"/></div></div></figure><p id="c87d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在void <em class="kz"> Start </em>中，要生成的对象<em class="kz">列表</em>是用三个基本图元<em class="kz">(立方体、球体和胶囊)</em>初始化的<em class="kz">。要生成的对象<em class="kz">列表</em>被<em class="kz">初始化</em>并留空。</em></p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lz"><img src="../Images/1f18388fc574abcce2ec0cb7e9b28056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6enU_6Kc424iO8lLdBp86A.png"/></div></div></figure><p id="a7f9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<em class="kz">更新</em>中，是我在写这篇文章之前应该放到<em class="kz">方法</em>中的所有代码！对于<em class="kz">输入</em>检查<em class="kz">空格</em>键，然后检查<em class="kz">布尔</em>为<em class="kz">假</em>并且创建的对象<em class="kz">列表</em>小于10 的条件。如果条件满足，<em class="kz">局部</em>变量为要生成的对象<em class="kz">列表</em>中的<em class="kz">元素</em>存储一个<em class="kz">随机int </em>值，以及为要生成的<em class="kz">位置</em>存储两个<em class="kz">随机浮点</em>范围。声明一个<em class="kz"> Vector3 </em>变量，并将X和Y上的随机<em class="kz">值</em>分配给变量，z上的随机值为零。声明一个局部游戏对象变量以存储对实例化对象的引用。这是我最初犯<em class="kz">错误</em>的地方，因为我存储的是<em class="kz">随机对象</em>，它实际上是对<em class="kz"> assets </em>文件夹中<em class="kz">预置</em>的引用，而不是<em class="kz">层次中那个<em class="kz">预置</em>的<em class="kz">实例</em>！</em>修复是让<em class="kz">实例化</em>命令存储对象<em class="kz">变量</em>的<em class="kz">值</em>现在，来自要繁殖的对象列表的随机对象，在随机繁殖点位置被<em class="kz">实例化</em>，同时忽略旋转。通过使用<em class="kz"> Add </em>方法并传入<em class="kz"> createdObject </em>变量，创建的对象<em class="kz">变量</em>现在可以安全地放入创建的对象列表中。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ma"><img src="../Images/ea461a1a456bfd3971a93f489a989aa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ZPnbra2dnA_Ukh7TmGcDQ.png"/></div></div></figure><p id="75b3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里的<em class="kz"> else </em>语句处理如果前两个条件<em class="kz">不</em>满足时会发生什么。<em class="kz">控制台</em>发送消息通知我对象计数已满，<em class="kz">is donespowing</em>变量改为<em class="kz"> true </em>。<em class="kz"> foreach </em>循环将遍历<em class="kz">对象创建列表</em>中的所有游戏对象，获取<em class="kz">网格渲染器</em>上的<em class="kz">组件</em>，然后将<em class="kz">颜色</em>更改为<em class="kz">绿色</em>。最后，当该说的都说了，该做的都做了，这个列表就<em class="kz">清除了</em>。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mb"><img src="../Images/66020f1bbdc8cc4de8feb6ad9ad67087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6d4tSMmt-3CNJ8vCmfkDzA.png"/></div></div></figure><p id="1207" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">检查员</em>展示对象<em class="kz">预置</em>和当前空列表。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/7ebf5fb3569a8236fc7ffec7a1d5faf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*TwJcEe9fuyIbZMq_cLvRzQ.png"/></div></figure><p id="5b8e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在void <em class="kz"> Start </em>中的<em class="kz">初始化</em>时，生成列表中的<em class="kz">对象。</em></p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi md"><img src="../Images/59e055315657e218c7955632d078e946.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*bouJCsoV_NkPKfK_P25NDw.png"/></div></figure><p id="d609" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我按下<em class="kz">空格键</em>时，你可以看到新创建的游戏对象的实例化的<em class="kz">实例</em>，填充了<em class="kz">对象创建的</em>列表。一旦我在列表中有了<em class="kz"> 10 </em>个对象，再按一次空格键<em class="kz">就会清除</em>。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi me"><img src="../Images/75dbcb91632c11a169037e0191391733.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/1*RX8LXVVwQhfO-R-ezgXYGA.gif"/></div></figure><p id="cb37" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">检查员告诉我，对象计数已满。</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/5bee7666899330859a11df58a8f7f66a.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*Wb2GCmMx1TIZYZ3RZgObXA.png"/></div></figure><p id="a4f8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在场景视图中，您可以看到对象正在实例化，并最终在挑战的最后阶段变成绿色。我希望你喜欢这次使用<em class="kz">列表</em>的旅程，感谢你的阅读！</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/9098cf80171a27f87e7ea6cc4959c03e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jNJ6jE3XIgMZbI9LTR4ttw.gif"/></div></div></figure></div></div>    
</body>
</html>