<html>
<head>
<title>Why Angular Input Setter is Only Being Fired Once</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么角度输入设置器只被触发一次</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-angular-input-setter-is-only-being-fired-once-53f1a66b1716?source=collection_archive---------1-----------------------#2022-01-27">https://levelup.gitconnected.com/why-angular-input-setter-is-only-being-fired-once-53f1a66b1716?source=collection_archive---------1-----------------------#2022-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3334" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">研究在组件之间传递数据的各种方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4cadcf9a201945fb8bdffe6dea121e67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QIVnOoeHbOS_D97pSKcRLg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@altumcode?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> AltumCode </a>拍摄</figcaption></figure><p id="b119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Angular应用程序需要将不同的组件组合在一起，并在它们之间传递数据。将数据从父组件传递到子组件的一种常见方法是使用输入属性setter。我们都知道getter和setter，它们只是用来拦截对属性的访问。</p><p id="bd17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">令人惊讶的是，与“标准”TypeScript setter相比，Angular component input setter的行为有细微的差别。我是在处理以下问题时发现的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="f581" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">原始问题</h2><p id="5f1f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">为了说明这个问题，我设置了一个虚构的<a class="ae ky" href="https://stackblitz.com/edit/ng-input-setter-issue" rel="noopener ugc nofollow" target="_blank">例子</a>，如下所示。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="2983" class="mc md it nb b gy nf ng l nh ni">// Parent Component<br/>&lt;button (click)="reset()"&gt;set to Parent&lt;/button&gt;<br/>&lt;app-child [data]="message"&gt;&lt;/app-child&gt;</span><span id="d004" class="mc md it nb b gy nj ng l nh ni">reset() {<br/>  this.message = 'Parent';<br/>}</span><span id="a901" class="mc md it nb b gy nj ng l nh ni">//Child Component<br/>&lt;p&gt;Value  is: {{ data }}&lt;/p&gt;</span><span id="49ff" class="mc md it nb b gy nj ng l nh ni">_val = '';<br/>@Input()<br/>set data(val: string) {<br/>   this._val = val;<br/>}</span></pre><p id="d10c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有两个组件:上面例子中的父组件和子组件。<code class="fe nk nl nm nb b">data </code>是子组件中的简单输入设置器。当用户从父组件中点击“<code class="fe nk nl nm nb b">set to Parent</code>”按钮时，一个字符串值将被设置为“parent ”,子组件设置器将被调用。</p><p id="aa4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其实上面的说法只是第一次成立。如果多次点击<code class="fe nk nl nm nb b">set to Parent</code>按钮，则从第二次开始不会触发子组件设置器。</p><p id="1ab1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果setter的值没有改变，看起来输入setter只被触发一次。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="a97a" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">根本原因</h2><p id="125f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">为了理解这种行为的根本原因，我深入研究了angular源代码。在下面的<code class="fe nk nl nm nb b"><a class="ae ky" href="https://github.com/angular/angular/blob/d1ea1f4c7f3358b730b0d94e65b00bc28cae279c/packages/core/src/render3/bindings.ts#L52" rel="noopener ugc nofollow" target="_blank">bindingUpdated </a></code>函数行7中，Angular通过比较新值和其组件逻辑视图中的旧值来检查值的变化。它只在值实际改变时更新绑定。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="ab67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，Angular Input setter被设计为在值没有改变的情况下忽略绑定更新，而普通TypeScript类中的setter将在每次调用时被触发，不管值是否改变。</p><p id="6c5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个用例，我想在每次单击父组件中的“<code class="fe nk nl nm nb b">set to Parent</code>”按钮时触发子组件的重置。我怎样才能实现这一点？</p><h2 id="624e" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">工作区</h2><p id="b3bb" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我尝试的第一个解决方法是使用<code class="fe nk nl nm nb b">ngOnChanges</code>。我将下面的代码添加到子组件中，希望它能够在单击“设置为父组件”按钮时捕获数据。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="058b" class="mc md it nb b gy nf ng l nh ni">ngOnChanges(changes: SimpleChanges) {<br/>   console.log('ngOnChanges', changes);<br/>}</span></pre><p id="617d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是控制台日志只在按钮第一次点击时打印。显然，<code class="fe nk nl nm nb b">ngOnChanges </code>的下划线绑定代码与输入设置器相同。</p><p id="700b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个尝试是在子组件中公开一个新的公共方法<code class="fe nk nl nm nb b">setParent</code>。从父组件，我们用<code class="fe nk nl nm nb b">ViewChild</code> decorator创建对子组件的引用，并在点击按钮时调用<code class="fe nk nl nm nb b">setParent </code>方法。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ca47" class="mc md it nb b gy nf ng l nh ni">// Child Component<br/>setParent() {<br/>   this.data = 'Parent';<br/>}<br/>// Parent Component<br/>@ViewChild('childComp', { static: true })<br/>childComp: ChildComponent;<br/>  <br/>resetChild() { <br/>  this.childComp.setParent();<br/>}</span><span id="bc21" class="mc md it nb b gy nj ng l nh ni">// Parent Component template<br/>&lt;button (click)="resetChild()"&gt;call reset to Parent&lt;/button&gt;</span></pre><p id="8664" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法行得通。但是我对它不是很满意。公开一个方法并直接调用另一个组件并不是一种干净的方式。它在两个组件之间创建了一个紧密的耦合。当方法被多个父组件使用时，情况会变得更糟。</p><p id="2941" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我仍然喜欢使用input属性，因为它在组件之间创建了一个契约。我们还能通过绕过限制来利用输入属性setter吗？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="a0df" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">使用可观察值的更好方法</h2><p id="ccc4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果我们回到Angular源代码，它使用<code class="fe nk nl nm nb b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" rel="noopener ugc nofollow" target="_blank">Object.is</a></code>来检测值的变化。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="5b24" class="mc md it nb b gy nf ng l nh ni">If(Object.is(oldValue, value)) </span></pre><p id="e29c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比较两个对象时，如果“<code class="fe nk nl nm nb b">both the same object (meaning both values reference the same object in memory)</code>”，则<code class="fe nk nl nm nb b">Object.is</code>将返回true。</p><p id="2533" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果我们将包含相同值的可观察对象传递到输入属性中，Angular将把它作为一个更改的值！</p><p id="f285" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们使用observable作为输入属性的新实现。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="68be" class="mc md it nb b gy nf ng l nh ni">// Parent Component<br/>eventsSubject: Subject&lt;string&gt; = new Subject();</span><span id="f40a" class="mc md it nb b gy nj ng l nh ni">resetByObservable() {<br/>   this.eventsSubject.next('Parent');<br/>}</span><span id="d106" class="mc md it nb b gy nj ng l nh ni">// Parent Component template<br/>&lt;button (click)="resetByObservable()"&gt;set to Parent by observable&lt;/button&gt;</span><span id="5779" class="mc md it nb b gy nj ng l nh ni">&lt;app-childObservable [events]="eventsSubject"&gt;&lt;/app-childObservable&gt;</span><span id="50ef" class="mc md it nb b gy nj ng l nh ni">// Child Component<br/>_val: Subject&lt;string&gt; = new Subject();<br/>@Input()<br/>set events(val: Subject&lt;string&gt;) {<br/>  this._val = val;<br/>}<br/>ngOnInit() {<br/>  this.eventsSubscription = this.events.subscribe((x) =&gt; {<br/>     this.data = x;<br/>  });<br/>}</span></pre><p id="5b82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的实现中，我们使用一个输入设置器作为<code class="fe nk nl nm nb b">Subject </code>类型，并订阅子组件中的数据更改。子组件订阅捕获“设置为父”按钮的每次点击。</p><p id="bc7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在<a class="ae ky" href="https://stackblitz.com/edit/ng-input-setter-issue" rel="noopener ugc nofollow" target="_blank"> stackblitz </a>项目中尝试上面的例子。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="3191" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">输入属性setter与ngOnChanges</h2><p id="fc10" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在前面的小节中，我们尝试了输入属性setter和<code class="fe nk nl nm nb b">ngOnChanges</code>生命周期挂钩。</p><p id="fb61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们是检测和响应数据变化的两种方式，可用于在组件之间传递参数。只有当绑定值改变时，才会触发这两个事件。</p><p id="db36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们可以在不同的用例中使用。使用<code class="fe nk nl nm nb b">ngOnChanges </code>，您可以在一个地方访问所有的属性更改。对于输入属性设置器，它仅适用于单个属性。</p><p id="7025" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在组件之间共享数据还有其他常见的方法</p><ul class=""><li id="0f0a" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">通过与<a class="ae ky" href="https://www.learnrxjs.io/learn-rxjs/subjects/behaviorsubject" rel="noopener ugc nofollow" target="_blank">行为主体</a>的共享服务</li><li id="2f74" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">通过来自子组件或兄弟组件的<code class="fe nk nl nm nb b">@Output</code>装饰器和<code class="fe nk nl nm nb b">EventEmitter </code></li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="4a2c" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">摘要</h2><p id="e355" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">尽管TypeScript中的属性setter简单明了，但问题在于细节:Angular input属性setter在变化检测方面有细微的差别。在本文中，我们将探讨如何解决在两个角度分量之间发送重复值的问题。</p><p id="93f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以选择不同的方式在组件之间传递数据。使用<code class="fe nk nl nm nb b">@Input </code>和<code class="fe nk nl nm nb b"> @Output</code>是我的首选方法，因为它们充当组件之间的契约，并使组件更加可重用。</p><p id="86fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，你可能也喜欢看我下面的另一篇有角度的文章。</p><div class="od oe gp gr of og"><a href="https://javascript.plainenglish.io/angular-state-management-with-observable-service-pattern-27b18538f4c3" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">具有可观察服务模式的角度状态管理</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">Angular状态管理是任何Angular应用程序的核心，但没有放之四海而皆准的解决方案。</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div><p id="8af9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这篇文章对你有用。您可以在这个<a class="ae ky" href="https://stackblitz.com/edit/ng-input-setter-issue" rel="noopener ugc nofollow" target="_blank"> stackbliz </a>项目中找到示例代码。</p></div></div>    
</body>
</html>