<html>
<head>
<title>Mediator Design Pattern In .NET C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中介设计模式。NET C#</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/mediator-design-pattern-in-net-c-e1bfcc96789d?source=collection_archive---------0-----------------------#2021-12-22">https://levelup.gitconnected.com/mediator-design-pattern-in-net-c-e1bfcc96789d?source=collection_archive---------0-----------------------#2021-12-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="107a" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">设计模式</h2><div class=""/><div class=""><h2 id="988d" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">中了解中介器设计模式。NET C#与代码示例。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/914a92f3edfd198e7bda5665c75cce7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5U8PPMscW0klqY1ChEqgNA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@isodme?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Jonathan </a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="f996" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">中介设计模式定义</h1><p id="81c8" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated"><strong class="mc jd">中介设计模式</strong>是行为设计模式之一。</p><p id="4ffc" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">根据<a class="ae lh" href="https://en.wikipedia.org/wiki/Mediator_pattern" rel="noopener ugc nofollow" target="_blank">维基百科</a>，定义如下:</p><blockquote class="nb nc nd"><p id="ac02" class="ma mb ne mc b md mw kd mf mg mx kg mi nf my ml mm ng mz mp mq nh na mt mu mv im bi translated">中介模式的本质是“定义一个封装了一组对象如何交互的对象”。它通过防止对象显式地相互引用来促进松散耦合，并允许它们的交互独立变化。客户端类可以使用中介向其他客户端发送消息，并可以通过中介类上的事件从其他客户端接收消息。</p></blockquote><p id="7fcd" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，简单地说，<strong class="mc jd">中介设计模式</strong>用于管理一组对象(相似或不相似)之间的交互，保持对象相互隔离。</p><p id="b667" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">为了理解这一点，我用一个简单的例子来解释一下。</p><p id="69fd" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">假设你正在实现一个聊天室。因此，你有无限数量的用户可以加入聊天室，一旦任何用户发送消息，该消息应该被聊天室的所有其他用户接收。</p><p id="a56f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，实现这个，你将拥有一个带有<code class="fe ni nj nk nl b">SendMessage</code>方法的<code class="fe ni nj nk nl b">User</code>类。</p><p id="314a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">但是，您仍然需要访问其他用户，以便您可以将消息发送给他们。此外，每当用户离开聊天室时，您还需要将该用户从所有其他用户中删除，这样他们就不会给他发送消息。</p><p id="6f5a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">您有不止一种方法来实现这一点:</p><ol class=""><li id="f09e" class="nm nn it mc b md mw mg mx mj no mn np mr nq mv nr ns nt nu bi translated">在每个用户内部定义一个用户列表，并在用户进入或离开聊天室时更新这些列表。</li><li id="e065" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">使用另一个类或模块作为中间人来处理用户列表以及不同用户之间发送和接收消息的方式。</li></ol><p id="88e1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">第一种选择可行，但是不好，因为:</p><ol class=""><li id="06c4" class="nm nn it mc b md mw mg mx mj no mn np mr nq mv nr ns nt nu bi translated"><code class="fe ni nj nk nl b">User</code>类会做太多实际上与其主要工作无关的事情。</li><li id="44ba" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">每个<code class="fe ni nj nk nl b">User</code>现在都知道其他用户，这是不符合逻辑的。</li><li id="0c0a" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">如果我们想要应用一些商业规则来决定允许哪个用户与哪个用户通信，那将会非常困难。</li><li id="d859" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">维护所有用户列表的处理量太大。</li></ol><p id="4c4d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在，如果我们探索第二种选择:</p><ol class=""><li id="a51d" class="nm nn it mc b md mw mg mx mj no mn np mr nq mv nr ns nt nu bi translated">类完成了它的工作，也是唯一的工作。</li><li id="1cdc" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">维护用户列表的所有逻辑都集中在一个类或模块中。</li><li id="1882" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">这使我们能够在需要时轻松应用业务规则和聚合。</li></ol><p id="9370" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如你所见，选择第二种会更好。现在，让我告诉你，你将在第二个选项中实现的是<strong class="mc jd">中介设计模式</strong>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oa"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><div class="ob oc gp gr od oe"><a href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener follow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd jd gy z fp oj fr fs ok fu fw jc bi translated">🔥订阅艾哈迈德的时事通讯🔥</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">订阅艾哈迈德的时事通讯📰直接获得最佳实践、教程、提示、技巧和许多其他很酷的东西…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">medium.com</p></div></div><div class="on l"><div class="oo l op oq or on os lb oe"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oa"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="9edf" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">中介设计模式类图</h1><p id="751e" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">关于<strong class="mc jd">中介设计模式</strong>，我注意到它可以被实现成多种风格。</p><p id="d0ae" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">有时你可以使用<strong class="mc jd">事件</strong>、<strong class="mc jd">委托</strong>或<strong class="mc jd">直接方法</strong>。有时，您可以在许多地方使用<strong class="mc jd">中介</strong>并将其作为依赖项注入，或者您可以仅在集中式管理器中使用它。</p><p id="38fc" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，这使我将<strong class="mc jd">中介设计模式</strong>视为一个概念而不是一个模式。</p><p id="c643" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然而，为了帮助你想象<strong class="mc jd">中介设计模式</strong>可能是怎样的，这里有一个来自<a class="ae lh" href="https://en.wikipedia.org/wiki/Mediator_pattern" rel="noopener ugc nofollow" target="_blank">维基百科</a>的类图。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ot"><img src="../Images/4cdc384e1a4daf3a7e6b4e9fbd843787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O71zTb4oTvvr95AvJj7zZA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://en.wikipedia.org/wiki/Mediator_pattern" rel="noopener ugc nofollow" target="_blank">中介行为设计模式</a>，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ou"><img src="../Images/0fdde0c5543c9946ee7ddef5cbbc1389.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aWK6yDaBe7x5viez2VyeMw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@clark_fransa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Arnold Francisca </a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="4926" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">代码示例</h1><p id="44c7" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">现在是时候深入一些代码来理解<strong class="mc jd">中介设计模式</strong>了。我们现在要做的是实现<strong class="mc jd">聊天室</strong>的例子。</p><p id="a0ad" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">先说<code class="fe ni nj nk nl b">User</code>类。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="9f7b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们在这里可以注意到:</p><ol class=""><li id="ea27" class="nm nn it mc b md mw mg mx mj no mn np mr nq mv nr ns nt nu bi translated">我们定义了<code class="fe ni nj nk nl b">MessageBroadcastedEventHandler</code>委托作为每个用户发送消息时触发的事件。</li><li id="44ed" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">那么很明显，我们在<code class="fe ni nj nk nl b">User</code>类中定义了<code class="fe ni nj nk nl b">event MessageBroadcastedEventHandler MessageBroadcasted</code>。</li><li id="01db" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">我们还将<code class="fe ni nj nk nl b">protected void OnMessageBroadcasted(string message)</code>定义为处理触发事件的最佳实践。</li><li id="0ecd" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">每个<code class="fe ni nj nk nl b">User</code>都有一个<code class="fe ni nj nk nl b">Name</code>属性。</li><li id="1b20" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">另外，当某个<code class="fe ni nj nk nl b">User</code>发送消息时，每个<code class="fe ni nj nk nl b">User</code>都有主模块调用的<code class="fe ni nj nk nl b">SendMessage</code>方法。在这里，我们只是通过<code class="fe ni nj nk nl b">OnMessageBroadcasted</code>触发事件。</li><li id="ff28" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated"><code class="fe ni nj nk nl b">ReceiveMessage</code>方法用于在广播消息时通知<code class="fe ni nj nk nl b">User</code>。在这里，我们只是记录一些测试信息。</li></ol><p id="0875" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在，让我们转到<code class="fe ni nj nk nl b">ChatRoom</code>类，它是我们的<strong class="mc jd">中介</strong>类。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="6c17" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们在这里可以注意到:</p><ol class=""><li id="1051" class="nm nn it mc b md mw mg mx mj no mn np mr nq mv nr ns nt nu bi translated">我们定义了一个<strong class="mc jd">用户</strong>的私有列表。</li><li id="9217" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">我们定义了一个在向<code class="fe ni nj nk nl b">ChatRoom</code>添加新的<code class="fe ni nj nk nl b">User</code>时要调用的<code class="fe ni nj nk nl b">AddUser</code>方法。我们在这里做的是将用户添加到私有列表中，并订阅它的<code class="fe ni nj nk nl b">MessageBroadcasted</code>事件。</li><li id="a50c" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">我们定义了从<code class="fe ni nj nk nl b">ChatRoom</code>中移除<code class="fe ni nj nk nl b">User</code>时要调用的<code class="fe ni nj nk nl b">RemoveUser</code>方法。我们在这里做的是将用户从私有列表中移除，并取消订阅其<code class="fe ni nj nk nl b">MessageBroadcasted</code>事件。</li><li id="e05d" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">我们定义了<code class="fe ni nj nk nl b">OnMessageBroadcasted</code>方法来处理每个<code class="fe ni nj nk nl b">User</code>的<code class="fe ni nj nk nl b">MessageBroadcasted</code>事件。我们在这里所做的是循环所有的<strong class="mc jd">用户</strong>，除了那个广播消息的用户，并触发他们的<code class="fe ni nj nk nl b">ReceiveMessage</code>方法。</li></ol><p id="59d5" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">移动到主模块。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="d1ff" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们在这里可以注意到:</p><ol class=""><li id="5155" class="nm nn it mc b md mw mg mx mj no mn np mr nq mv nr ns nt nu bi translated">我们定义了3个用户。</li><li id="810b" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">我们创建了<strong class="mc jd">聊天室</strong>并逐一添加了3个用户。</li><li id="8396" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">然后，<strong class="mc jd">艾哈迈德</strong>开始说“大家好。”。我们在控制台上看到这个:<br/>“Tarek”收到一条来自“Ahmed”的消息:“大家好。”“哈桑”收到了“艾哈迈德”发来的信息:“大家好。”</li><li id="6f6b" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">然后塔瑞克回复说:“嗨，艾哈迈德。”。我们在控制台上看到这个:<br/>“艾哈迈德”收到了来自“塔里克”的消息:“你好，艾哈迈德。”“哈桑”收到了“塔雷克”发来的信息:“你好，艾哈迈德。”</li><li id="e633" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">然后<strong class="mc jd"> Tarek </strong>从聊天rom中删除。</li><li id="cc92" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">然后Tarek发了一条信息说“有人能听到我吗？”。然而，我们在控制台中没有得到任何东西，因为Tarek已经从聊天室中删除了。</li><li id="23bf" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">然后<strong class="mc jd">哈桑</strong>发来一条信息说“我认为塔里克断线了。”。我们在控制台上看到了这个:<br/>“艾哈迈德”收到了“哈桑”发来的信息:“我想塔里克断线了。”</li></ol><p id="068a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">所以，现在一切都正常工作，重要的是我们的对象(在我们的例子中；用户)是松散耦合的。</p><p id="6f82" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">此外，如果我们想要应用一些业务规则，我们可以很容易地做到，因为我们将关系和交互集中到一个地方。这也使得应用聚合变得非常容易。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ox"><img src="../Images/eb73f869c014bceccd1fa198770530d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ndt6NLUVtLEPRgRwyxtOzQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@sammywilliams?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">萨米·威廉姆斯</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>调整</figcaption></figure><h1 id="bba5" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">误解</h1><p id="957a" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">有一种误解认为<strong class="mc jd">中介设计模式</strong>管理相似对象或相同类型对象之间的关系和交互，然而，这不是真的。</p><p id="0ffa" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd">中介设计模式</strong>可以对不同种类的对象做同样的工作。一个著名的例子是<strong class="mc jd">请求处理器</strong>模式实现。</p><p id="3022" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">简而言之，如果您有一些输入或请求将通过一系列不同的处理程序(可能是预定义的或在运行时加载的)传递，那么使用<strong class="mc jd">中介设计模式</strong>会非常好。</p><p id="ef07" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">使用<strong class="mc jd">中介设计模式</strong>的主要好处是，你可以实现一个松散耦合的设计，这样请求和处理程序就不会互相察觉。</p><p id="2f5d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">让我们看一个例子。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oa"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="8077" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">请求处理程序示例</h1><p id="1f20" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">假设我们有一个员工管理系统，每当雇佣新员工时，我们都有不同的操作要执行。</p><p id="8764" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在这种情况下，您不希望像业务层中的<code class="fe ni nj nk nl b">CreateEmployee</code>方法一样在一个地方运行或触发这些操作。这是可行的，但是，您最终会得到一个臃肿的业务层。同样，每次你想添加一个新的动作，你都要修改<code class="fe ni nj nk nl b">CreateEmployee</code>方法。这样不好，因为你可能会无意中打碎东西。</p><p id="f498" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，在这里使用<strong class="mc jd">请求处理程序</strong>模式会很好。</p><p id="b054" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi oy translated"><span class="l oz pa pb bm pc pd pe pf pg di"> N </span> <strong class="mc jd"> ote </strong>:为了简单起见，这里将省略一些最佳实践，以便将注意力集中在<strong class="mc jd">请求处理程序</strong>模式的主要思想上。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="1c0b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们在这里可以注意到:</p><ol class=""><li id="d843" class="nm nn it mc b md mw mg mx mj no mn np mr nq mv nr ns nt nu bi translated">我们定义了一个简单的<code class="fe ni nj nk nl b">Employee</code>类。</li><li id="e3b8" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">我们定义了一个简单的<code class="fe ni nj nk nl b">IAddEmployeeRequest</code>接口。它只有一个要添加的<code class="fe ni nj nk nl b">Employee</code>属性。</li><li id="9f7d" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">我们定义了一个简单的<code class="fe ni nj nk nl b">AddEmployeeRequest</code>类来实现<code class="fe ni nj nk nl b">IAddEmployeeRequest</code>接口。</li><li id="9e84" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">我们定义了<code class="fe ni nj nk nl b">IAddEmployeeRequestHandler</code>接口来表示<code class="fe ni nj nk nl b">IAddEmployeeRequest</code>请求的任何处理程序。</li><li id="90e3" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">我们有两个简单的<code class="fe ni nj nk nl b">IAddEmployeeRequestHandler</code>接口实现；<code class="fe ni nj nk nl b">AddEmployeeRequestHandler1</code>和<code class="fe ni nj nk nl b">AddEmployeeRequestHandler2</code>。</li></ol><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="95a6" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们在这里可以注意到:</p><ol class=""><li id="d7f7" class="nm nn it mc b md mw mg mx mj no mn np mr nq mv nr ns nt nu bi translated">我们定义了<code class="fe ni nj nk nl b">AddEmployeeMediator</code>类。</li><li id="a2f8" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">它维护一个<code class="fe ni nj nk nl b">IAddEmployeeRequestHandler</code>处理程序列表。</li><li id="784a" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">当一个请求通过<code class="fe ni nj nk nl b">Handle</code>方法进入时，它在所有注册的处理程序上循环并触发它们的<code class="fe ni nj nk nl b">Handle</code>方法。</li><li id="ea12" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated"><code class="fe ni nj nk nl b">RegisterHandler</code>和<code class="fe ni nj nk nl b">UnregisterHandler</code>是注册和注销处理程序的两种方法。</li></ol><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="f4e6" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">运行这个程序，我们会得到以下结果:</p><blockquote class="nb nc nd"><p id="4452" class="ma mb ne mc b md mw kd mf mg mx kg mi nf my ml mm ng mz mp mq nh na mt mu mv im bi translated">AddEmployeeRequestHandler1处理Ahmed<br/>addemployeerequesthandler 2处理Ahmed<br/>addemployeerequesthandler 1处理Tarek<br/>addemployeerequesthandler 2处理Tarek</p></blockquote><p id="83cb" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这太棒了。现在，我们让不同的处理程序处理我们的请求，而没有紧密耦合的请求和处理程序。</p><p id="919d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">当然，示例代码并不是处于最佳状态，它可以通过提供更多的抽象和进行一些重构来增强，但这是很容易做到的，对吗？</p><p id="993e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在我们离开这一步之前，让我告诉你实现这一概念的著名图书馆之一是<a class="ae lh" href="https://github.com/jbogard/MediatR" rel="noopener ugc nofollow" target="_blank"><strong class="mc jd">mediator</strong></a>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/d5d52462bc03fb075aa7ff383d632a37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aC-Ey4vZohLOtzRXg2vI0Q.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@benwhitephotography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Ben White </a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="cce4" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">什么是联发科？</h1><p id="4a7b" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated"><a class="ae lh" href="https://github.com/jbogard/MediatR" rel="noopener ugc nofollow" target="_blank"> <strong class="mc jd">联发科</strong> </a>，按照团队的定义，我引用一下，就是:</p><blockquote class="nb nc nd"><p id="e6ca" class="ma mb ne mc b md mw kd mf mg mx kg mi nf my ml mm ng mz mp mq nh na mt mu mv im bi translated">简单，没有野心的中介实现。网</p><p id="2c96" class="ma mb ne mc b md mw kd mf mg mx kg mi nf my ml mm ng mz mp mq nh na mt mu mv im bi translated">无依赖性的进程内消息传递。</p><p id="39dd" class="ma mb ne mc b md mw kd mf mg mx kg mi nf my ml mm ng mz mp mq nh na mt mu mv im bi translated">支持请求/响应、命令、查询、通知和事件，同步和异步，通过C#通用变量进行智能调度。</p></blockquote><p id="bd97" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如果你愿意，你可以在<a class="ae lh" href="https://github.com/jbogard/MediatR/wiki" rel="noopener ugc nofollow" target="_blank">这个维基</a>页面上查看一些使用<a class="ae lh" href="https://github.com/jbogard/MediatR" rel="noopener ugc nofollow" target="_blank">mediator</a>的例子。</p><p id="1e0a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如今它已经和<strong class="mc jd">一起被大量使用。NetCore </strong>，已知在实现<strong class="mc jd">命令和查询责任分离(CQRS) </strong>时使用。</p><p id="6a89" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我真的建议你试一试。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/de779c5eafed25a0fddc5c8a152c995c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gPiLKE76Z3B6p3nQYCXL5Q.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://pixabay.com" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的<a class="ae lh" href="https://pixabay.com/users/colin00b-346653/" rel="noopener ugc nofollow" target="_blank"> ColiN00B </a>拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="1eaf" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">最后的想法</h1><p id="3d85" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated"><strong class="mc jd">中介设计模式</strong>是有史以来最伟大的模式之一。在某个时候，我发现我甚至在知道它之前就已经在使用它了。</p><p id="ca8c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">有时使用这种模式太明显了，而其他时候就有点棘手了。</p><p id="b92c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">为了了解更多关于<strong class="mc jd">中介设计模式</strong>的信息，我建议不要仅仅满足于从本文中学到的东西，继续做一些研究和尝试。这会帮助你更好地理解它。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oa"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="5704" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">希望这些内容对你有用。如果您想支持:</h1><p id="57d4" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">如果你还不是<strong class="mc jd">中介</strong>会员，你可以使用<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek/membership" rel="noopener"> <strong class="mc jd">我的推荐链接</strong> </a>，这样我可以从<strong class="mc jd">中介</strong>那里得到你的一部分费用，你不需要支付任何额外费用。订阅<a class="ae lh" href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener"> <strong class="mc jd">我的简讯</strong> </a>将最佳实践、教程、提示、技巧和许多其他很酷的东西直接发送到您的收件箱。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oa"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="16a5" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">其他资源</h1><p id="3681" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">这些是你可能会发现有用的其他资源。</p><div class="ob oc gp gr od oe"><a rel="noopener  ugc nofollow" target="_blank" href="/strategy-design-pattern-in-net-c-b9dbd863c31e"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd jd gy z fp oj fr fs ok fu fw jc bi translated">中的策略设计模式。NET C#</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">了解中的策略设计模式。NET C#</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="on l"><div class="pj l op oq or on os lb oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a rel="noopener  ugc nofollow" target="_blank" href="/when-implementations-affect-abstractions-1bb2adc808d1"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd jd gy z fp oj fr fs ok fu fw jc bi translated">当实现影响抽象时</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">关于实现的知识会影响抽象设计吗？</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="on l"><div class="pk l op oq or on os lb oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-cancel-a-running-process-in-a-separate-request-command-in-net-c-2ca8fb733618"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd jd gy z fp oj fr fs ok fu fw jc bi translated">如何在单独的请求/命令中取消正在运行的进程。NET C#</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">了解如何在单独的请求中取消已经运行的进程。NET C#</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="on l"><div class="pl l op oq or on os lb oe"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oa"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure></div></div>    
</body>
</html>