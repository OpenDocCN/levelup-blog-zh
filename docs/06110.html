<html>
<head>
<title>How to use RAII to keep the code lean and clean</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用RAII保持代码简洁明了</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-use-raii-to-rewind-std-istream-to-the-beginning-6725106b97f5?source=collection_archive---------24-----------------------#2020-10-26">https://levelup.gitconnected.com/how-to-use-raii-to-rewind-std-istream-to-the-beginning-6725106b97f5?source=collection_archive---------24-----------------------#2020-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/598752719bead9f2e6237234a1c0e484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V4okJhqTfUJJ2L6gr7Qr6A.jpeg"/></div></div></figure><p id="4ec9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我最近一直在研究<a class="ae kw" href="https://github.com/openvinotoolkit/openvino" rel="noopener ugc nofollow" target="_blank"> OpenVINO </a>的一个功能，并提出了一个我认为值得分享的解决方案。它使用了一个叫做RAII的C++特性，这个小技巧帮助我避免了必须实现的过度复杂的代码。</p><h1 id="1750" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">几句开场白</h1><p id="3c9a" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">OpenVINO支持许多类型的DL模型，但是在内部使用自己的表示，我们简单地称之为IR。IR通常由一个叫做模型优化器的“离线工具”产生，输出是一个XML文件，包含OpenVINO理解的模型表示。要将此模型加载到内存中，用户需要在其应用程序中使用以下API:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="b7ac" class="mj ky iq mf b gy mk ml l mm mn">InferenceEngine core;<br/>const auto network = core.ReadNetwork("model.xml");</span></pre><p id="5f2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从OpenVINO的2020.4版本开始，您可以使用相同的API直接加载ONNX模型，而无需使用模型优化器。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="22cf" class="mj ky iq mf b gy mk ml l mm mn">InferenceEngine core;<br/>const auto network = core.ReadNetwork("model.onnx");</span></pre><p id="a3f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ONNX模型只是序列化的protobuf文件。虽然它们可能相当大(高达2GB ),但在我们开始整体解析它们之前，我们希望快速浏览一下用户提供的文件，并判断它是否看起来像是给定类型的正确模型。换句话说，我们在开始时进行快速检查，如果文件看起来可疑，就从ReadNetwork方法提前返回。顶层代码如下所示:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="4e22" class="mj ky iq mf b gy mk ml l mm mn">CNNNetwork ReadNetwork(const std::string&amp; model_path) {<br/>    std::ifstream model(model_path);</span><span id="6e6a" class="mj ky iq mf b gy mo ml l mm mn">    for (auto&amp; reader : registered_readers) {<br/>        if (reader.supportsModel(model)) {<br/>            return reader.ReadNetwork(model);<br/>        }<br/>    }</span><span id="3a18" class="mj ky iq mf b gy mo ml l mm mn">    throw std::runtime_error{"None of the registered readers can <br/>                              parse the provided file"};<br/>}</span></pre><p id="4e41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">阅读器API看起来像这样:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="6858" class="mj ky iq mf b gy mk ml l mm mn">bool IReader::supportsModel(std::istream&amp; model) const;<br/>CNNNetwork IReader::ReadNetwork(std::istream&amp; model);</span></pre><h1 id="47a5" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用流</h1><p id="185c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">每个读者都应该对一个流进行操作，这个流下面可能是一个文件或一个已经加载到内存中的模型。但是对于如何使用流没有限制。最有问题的情况是当一个读取器从它的<code class="fe mp mq mr mf b">supportsModel()</code>方法返回false，并且没有“倒带”到流的开始。在这种情况下，存在另一个读者从文件中的无效位置开始验证模型的风险。</p><p id="8a22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，这正是我在第一版代码中犯的错误。我在输入文件中跳来跳去，发现模型不是ONNX格式，并从ONNX阅读器实现返回false。之后，IR读取器引用了表示模型文件的流，并返回false。这样我就无法导入任何模型，大量的测试开始失败。这是它开始时的样子:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="4aa3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要修复它，我只需要在我的代码中增加一些对<code class="fe mp mq mr mf b">model.seekg(0, model.beg)</code>的调用。但是…整个<code class="fe mp mq mr mf b">supportsModel()</code>方法已经相当复杂了，它有很多分支，并且依赖于返回语句中的另一个函数。不过，我必须确保在所有情况下流都被重置。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="264e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是混乱的、重复的，并且使得该方法看起来更加复杂。即使我减少了对<code class="fe mp mq mr mf b">seekg()</code>方法的调用次数，并将它移到return语句之前，它仍然不理想:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="9ead" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">RAII来救援了</h1><p id="97c5" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">那么在C++中我们能做些什么来确保函数返回时发生一些事情呢？我们是否也能确保无论如何都会发生？我指的是定期返回还是抛出异常？事实证明我们可以，如果你曾经使用过互斥体，你应该熟悉std::lock_guard。每当执行退出一个代码块时，它就解锁一个互斥体。</p><p id="8bf5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这正是我使用的方法，除了我不必释放任何资源(这是RAII的主要用途)。我创建了一个小小的帮助器结构，它保存了一个对流的引用，并在其析构函数中调用<code class="fe mp mq mr mf b">stream.seekg(0, stream.beg)</code>。就这么简单。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="eb23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这个小小的帮助结构，我可以回到我的原始代码版本，只需在开头添加一行代码。RAII和栈展开的美妙之处在于，即使在<code class="fe mp mq mr mf b">is_valid_model</code>的某个地方抛出异常，也能确保流被重置。</p><h1 id="6acb" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">附言</h1><p id="b819" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我知道<code class="fe mp mq mr mf b">StreamRewinder</code>不是一个完美的名字，但是命名和缓存失效不是编程中最困难的两件事吗？:)</p><p id="cd9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您的阅读，祝您周末愉快！</p></div></div>    
</body>
</html>