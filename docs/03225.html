<html>
<head>
<title>Merge Sorted Linked Lists — with Jest and A Little Curveball</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">合并排序链表——用笑话和一点曲线球</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/merge-sorted-linked-lists-with-jest-and-a-little-curveball-curveball-at-end-69d5eca73914?source=collection_archive---------10-----------------------#2020-04-26">https://levelup.gitconnected.com/merge-sorted-linked-lists-with-jest-and-a-little-curveball-curveball-at-end-69d5eca73914?source=collection_archive---------10-----------------------#2020-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e33f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">(曲球结束)！</h2></div><p id="d2c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">被劫持</p><p id="1850" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在名为“21:合并两个有序链表”的经典Leetcode算法中，我们将两个有序链表合并成一个有序链表。随着我对算法和数据结构的深入研究，我觉得这个问题似乎对阐明作为数据结构的链表非常有帮助，所以我认为这将有助于对这个问题做一个预演，并提供一些我发现非常有帮助的算法实践技巧。</p><p id="1b50" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">链表:基础知识</strong></p><p id="c884" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">链表是一种线性数据结构，像数组、堆栈或队列，这意味着数据是以有序的方式一个接一个地被顺序访问的。链表是由节点组成的。在单链表中，每个节点保存一个值和一个指向链中另一个节点的指针。在双向链表中，每个节点保存一个值和一个指向前一个节点和另一个节点的指针。链表有头有尾。头节点是一个链表的开始，包含一个值和一个指向下一个节点的指针。尾部是一个链表的结尾，有一个值和一个指向null的指针。然而，在双向链表中，头节点的前一个节点指针和尾节点的下一个节点指针一样指向空值。下面的链接(没有双关语)是一个非常棒的网站，它可视化了我们可以在链接节点上执行的方法。</p><div class="lb lc gp gr ld le"><a href="https://visualgo.net/en/list" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">链表(单链表，双链表)，堆栈，队列，队列</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">链表是一种数据结构，由一组顶点(节点)组成，它们共同代表一个序列。在…下面</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">visualgo.net</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls lt le"/></div></div></a></div><p id="abb1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">合并两个排序后的链表:积木</strong></p><p id="b351" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">出于我们的目的，我们不需要用传统上用于构建链表类的方法(创建、搜索、插入、移除)来构建LinkedList类，这些方法可以在上面的网站上看到:【https://visualgo.net/en/list<a class="ae lu" href="https://visualgo.net/en/list" rel="noopener ugc nofollow" target="_blank"/>。事实上，我们真正需要的是一个节点类，用它我们可以实例化节点，每个节点都有一个值和一个指向另一个节点的指针。使用ES6语法创建节点类非常简单，如下图所示。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/5a555bae694184bdc6f1b19fb586a079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*o9vyNC1VBcdgiRM6TbYXuQ.png"/></div></figure><p id="96a6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了一个名为Node的类。当一个节点被创建时，它用一个作为参数传递的值和一个设置为null的next属性进行实例化。由于在这篇博文中会变得更加清晰的原因，我已经将这个练习模块化了，所以最后我将导出我们的节点类。如果我们要创建一个新节点，其语法如下:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mc"><img src="../Images/a1c74f1c86e4390c003e4d6748cf82da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NPCQtVMjwdxYjqxQlWv60Q.png"/></div></div></figure><p id="5be7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们要查看这个节点，我们会看到节点的val属性是6，它的下一个属性是null。现在，假设我们决定在下一处房产中添加一些东西。正如我前面提到的，链表是由一个接一个顺序链接的节点组成的。因此，我们不会将next设置为一个数字，而是另一个节点。我们将节点的next属性设置为一个新的节点实例:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mh"><img src="../Images/c8e9ca1289d9482ef0da86274a60b45a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tvsLbRHVRxumwvdRvHPzYg.png"/></div></div></figure><p id="d75b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑到所有这些，现在让我们来看看这个问题。下面是Leetcode对这个问题的描述，以及它们的输入和输出示例:</p><p id="26a3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mi">“合并两个排序后的链表，作为新的链表返回。新列表应该是通过将前两个列表的节点拼接在一起而制成的。”</em></p><p id="cd9a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">举例:</strong></p><p id="498a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">输入:</strong> 1- &gt; 2- &gt; 4，1- &gt; 3- &gt; 4</p><p id="87ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">输出:</strong>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><p id="58eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从描述中，我特别注意到一些事情。首先，我们接收两个链表作为参数，它们被排序。其次，我们返回一个链表。最后，返回的链表的大小是传入的每个链表中节点的总和。记住了输入和输出，构建测试就变得容易多了，现在我将使用jest来完成。Jest是一个JavaScript测试框架。我发现执行你自己的测试，对于算法来说是非常值得的。构建自己的测试不仅对软件工程师来说是一项无价的技能，而且它还能让你更深入地思考解决算法所需的代码。如果你清楚地知道输入是什么样的，返回值应该是什么，在我看来，你已经解决了30%的问题，因为这也给了你一个思考边缘情况的机会。要在Node.js中使用jest，您需要做的就是创建一个目录，并在该目录中运行<strong class="kh ir">NPM I jest</strong>；要将其保存为开发依赖项，<strong class="kh ir"> npm i — save-dev jest </strong>。(在您的目录中，确保您已经首先运行了<strong class="kh ir"> npm init </strong>来创建package.json文件)！</p><p id="722d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，在您的目录中，您可以创建一个名为mergedTwoLists.js和mergedSortedLists.test.js的文件。当我们写出我们的解决方案时，或者当我们觉得我们可能有了解决方案时，运行jest [PATH/filename] —注意，运行测试。watch标志确保测试将在您对被测试文件执行的每个动作操作之后运行，工作方式类似于nodemon，如果您以前曾经使用过这个令人敬畏的包的话！大哥哥jest在看。</p><p id="1001" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们开始吧。我喜欢写出问题描述，并在我们要写算法的文件中定义一个函数。您可能会注意到，我已经导入了我们之前创建的节点文件，因为我们将使用它来构造合并的链表。在最后一行，我们将导出函数，因为我们将在测试中调用它！</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mj"><img src="../Images/9c173c34beb38dee8c20ce7947610d70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fe-lurtg6upBvQvxIQjXJA.png"/></div></div></figure><p id="9126" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在来看看测试文件本身。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mk"><img src="../Images/388d79364200d13a3f989706a2ee5cf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vbk5NdYcWi0DTzlzAOf2hg.png"/></div></div></figure><p id="907e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的测试文件中，我们导入了mergeTwoLists函数和Node类。虽然这肯定不是最佳实践，但我用node类构造函数为我们的测试创建了链表，为每个下一个节点添加了新的节点实例。然后，我创建了一个合并列表，它应该反映mergeTwoLists的返回值。现在检查一下测试函数调用中的测试语法。Test接受一个参数，这个参数描述了我们测试的内容，作为第一个参数，回调作为第二个参数。在回调中，我们调用函数，传入两个排序的链表参数，并写出我们期望的最终值。在这一点上，在编写了测试之后，我意识到描述并没有指定链表将是相同的长度，这可能会给我目前正在绘制的解决方案带来一个问题，所以我决定对此也进行测试。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ml"><img src="../Images/ee8c970298d642d0e69174faf214c27b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZpSilToOtmDxzjMqTuOG4g.png"/></div></div></figure><p id="e77a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们对mergeTwoLists进行两次测试，我会给你看我的答案，我们可以讨论我做了什么。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mm"><img src="../Images/400951971c4ee08601b4bef10a2173d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2G7IfyacwHqgeKqxbHZqlQ.png"/></div></div></figure><p id="0b85" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我运行这段代码时，我看到我们的测试通过了！！</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mn"><img src="../Images/aa5daed044b081d0091f8d5c641fab65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L5BeHynEA0UAmwMLFn9gQw.png"/></div></div></figure><p id="d363" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的函数mergeTwoLists中，我们想从创建一个新节点开始，它将作为我们的链表的头。这个节点是我们在函数末尾想要返回的链表，但是我们并不真正关心我们最初传入节点的值；我们只关心两个链表中的值。我们的节点构造函数要求我们在初始化时给一个节点一个value参数，这在我们的问题中没有考虑到最终的链表，所以我们返回head.next，忽略值为0的头节点。现在，我们希望将我们的新节点设置为等于另一个变量，我们将使用该变量通过迭代有条件地添加新节点。过程中的这一步一开始让我很困惑，但在很多链表问题中确实是常见的做法。如果我们考虑这个问题，我们希望遍历我们的两个列表，并在每次迭代中有条件地将新节点添加到合并的链表中。因此，我们也需要在每次迭代中运行我们的新节点。如果我们在没有定义header的情况下执行这个操作，仅仅在while循环块的末尾设置head等于head.next，那么head.next将等于null，因为我们将返回尾节点！！不，不，不。记住JavaScript是通过引用传递的，所以我们对runner做的任何事情也会发生在head上，所以我们必须创建一个临时变量来为我们的链表取值，这样我们就可以在最后返回整个链表。</p><p id="1819" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们遍历列表，只要两个列表的值都不为空，然后向runner.next添加一个新节点，并有条件地重新定义关联列表，使其等于下一个值。当我们的一个链表等于null时，while循环将结束，所以在最后，我们只剩下list1或list2，因为它们是排序的，我们可以只设置runner的next属性等于list1或list2。这也将说明我们的链表大小不同的情况。最后，我们返回head .下一个！</p><p id="5441" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">* *曲线球** </strong></p><p id="acc7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经完成并解决了Leetcode问题，我喜欢想出一些方法来使问题复杂化——尤其是如果它是一个我有一点麻烦的问题(惩罚我自己！).对于曲线球，我决定加入神秘的元素。如果给我们一个可变数量的链表会怎么样。1…2…3…50?怎样才能创建一个合并器，不管传入多少个链表，都把排序的链表合并成一个排序的链表？让我们从测试开始。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mo"><img src="../Images/9a103b2562edb1c469ca5eddd2e30561.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ndRZEgg-O-0ImmZmWJ98jg.png"/></div></div></figure><p id="9b1a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于这个函数，我决定构建三个不同的测试，以确保我们的代码没有错误、美观和干净。第一个测试考虑是否传入了四个链表。虽然我可以构建完整的链表来进行测试，但这听起来有点令人头痛，所以我们将根据最终链表的预计长度来测试它，在我们的合并中，它总是每个节点的总和。为了测试大小，我创建了一个名为size的方法，它返回链表的长度。查找一个链表的长度是一个O(n)运算，在我们的例子中，如果你查看我们为最后的测试创建的四个链表，每个节点的总和将是11。第二个测试检查是否传入了一个参数，因为链表是排序的，所以我们希望返回同一个链表。如果传递了两个列表，我们希望执行与Leetcode算法中相同的操作。所以，这里什么都没有。这是我的最终解决方案。首先，我引入了我们为Leetcode问题编写的方法。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mp"><img src="../Images/b5612bdd4066af391538f6a2e2be3e21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QFjUHavbI35M-gMUoCSsfw.png"/></div></div></figure><p id="9390" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">耶，我们通过了所有的测试！</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mq"><img src="../Images/a610f745e7deb14066ac26344910ab91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GwT0a1RlSMANRh4leH2tsw.png"/></div></div></figure></div></div>    
</body>
</html>