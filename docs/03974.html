<html>
<head>
<title>Immutability in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang中的不变性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/immutability-in-golang-7a13199060bb?source=collection_archive---------4-----------------------#2020-06-04">https://levelup.gitconnected.com/immutability-in-golang-7a13199060bb?source=collection_archive---------4-----------------------#2020-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="792a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何利用不变性来增强Golang应用程序的可读性和稳定性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/811202a0c84a8de0f434127024960b45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XnHaRQxkcrHqFvg9"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">费伦茨·阿尔马西在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="0789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不变性的概念非常简单。对象(或结构)一旦创建，就永远不能更改。这是不可改变的。虽然这个概念看起来很简单，但使用它或从中受益并不总是很容易。</p><p id="0730" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如计算机科学(和生活)中的大多数事情一样，有多种方法可以达到相同的结果，就不变性而言，没有什么不同。你必须将它视为你工具箱中的另一个工具，并针对你面临的每个问题使用最有效的工具。不变性的一个非常强的用例是当您使用并发编程时。Golang在设计时就考虑到了并发性，所以在go中使用并发性是很常见的。如果你想了解Golang的并发模型，请查看<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/goroutines-and-channels-concurrent-programming-in-go-9f9f8495c34d">这篇文章</a>。</p><p id="e60d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是如何在Golang中使用一些不变性概念，使您的代码更具可读性和稳定性，而不管您使用的是哪种范式。</p><h2 id="45d9" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">仅导出结构的函数，不导出其字段</h2><p id="880e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这与封装的原理相同。创建具有非导出字段的结构，只导出您想要操作的函数。这种技术非常适合接口，因为您只对那些结构的行为感兴趣。这项技术的另一个好处是向结构中添加和导出一个创建函数(或构造函数)。这样可以确保该结构的状态总是有效的。拥有一个始终有效的状态可以使你的代码更加可靠，因为你不必为你想用这个结构做的每个操作处理无效的状态。这里有一个非常基本的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d761" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个包中，我们定义了<code class="fe mv mw mx my b">Amount</code>类型，带有非导出字段<code class="fe mv mw mx my b">value</code>，构造函数<code class="fe mv mw mx my b">NewAmount</code>，以及<code class="fe mv mw mx my b">Amount</code>类型的<code class="fe mv mw mx my b">GetValue</code>方法。一旦由<code class="fe mv mw mx my b">NewAmount</code>函数创建了<code class="fe mv mw mx my b">Amount</code>结构，就没有办法改变它。因此，从包的外部来看，它是不可变的(在go 1中没有办法创建不可变的结构，尽管在go 2中有<a class="ae ky" href="https://github.com/golang/go/issues/27975" rel="noopener ugc nofollow" target="_blank">建议改变这一点</a>)。此外，没有类型为<code class="fe mv mw mx my b">Amount</code>的变量处于无效状态(在本例中为负数量),因为创建它们的唯一方法已经验证了这一点。下面是我们如何从另一个包中调用它:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="fc9a" class="lv lw it my b gy nd ne l nf ng">a, err := amounts.NewAmount(10)<br/><em class="nh">// handle err<br/></em>log.Println(a.GetValue())</span></pre><h2 id="5bd8" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">在函数中使用复制值而不是指针</h2><p id="12c6" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">最基本的概念是，在对象(或结构)被创建后，永远不要改变它。然而，我们经常使用实体状态非常重要的应用程序。然而，实体的状态和实体在程序中的内部表示是不同的事情。在使用不变性时，我们仍然可以让一个实体有多个状态。这意味着创建的结构不会改变，但是它的副本会改变。这并不意味着我们需要手动实现复制结构的每个字段的函数。</p><p id="a337" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我们可以依赖Golang在调用函数时复制值的固有行为。对于每个改变实体状态的操作，我们可以创建一个函数，它接收结构体作为一个参数(或者作为一个函数接收器),并在执行工作后返回修改后的版本。这是一项非常强大的技术，因为您可以在副本上随意更改，而无需更改函数调用方作为参数传递的变量。这意味着没有副作用，以及可预测的行为。如果同一个结构被传递给并发函数，每个函数都会收到一个它的副本，而不是一个指向它的指针。</p><p id="207e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当处理切片时，您可以看到这种行为被应用到<code class="fe mv mw mx my b"><a class="ae ky" href="https://golang.org/pkg/builtin/#append" rel="noopener ugc nofollow" target="_blank">append</a></code>函数中。您也可以对您的函数使用完全相同的技术。</p><p id="e134" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们的例子，让我们实现<code class="fe mv mw mx my b">Account</code>类型，它包含一个<code class="fe mv mw mx my b">Amount</code>类型的<code class="fe mv mw mx my b">balance</code>字段。同样，让我们添加改变<code class="fe mv mw mx my b">Account</code>实体状态的方法<code class="fe mv mw mx my b">Deposit</code>和<code class="fe mv mw mx my b">Withdraw</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f87c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你检查我们创建的方法，他们会觉得我们实际上是在改变用作函数接收器的<code class="fe mv mw mx my b">Account</code>结构的状态。因为我们没有使用指针，所以情况并非如此，因为该结构的副本被作为这些函数的接收器传递。我们正在改变仅在函数范围内有效的副本，然后返回它。如果我们从另一个包中调用它，这里有一个例子:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="9a5a" class="lv lw it my b gy nd ne l nf ng">a, err := amounts.NewAmount(10)<br/>acc := accounts.NewEmptyAccount()<br/>acc2 := acc.Deposit(a)<br/>log.Println(acc.GetBalance())<br/>log.Println(acc2.GetBalance())</span></pre><p id="5763" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命令行上的结果如下所示:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="9771" class="lv lw it my b gy nd ne l nf ng">2020/06/03 22:22:40 {0}<br/>2020/06/03 22:22:40 {10}</span></pre><p id="52ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，虽然在变量<code class="fe mv mw mx my b">acc</code>上调用了<code class="fe mv mw mx my b">Deposit</code>方法，但它实际上并没有改变那个变量上的任何东西，而是返回了一个新的<code class="fe mv mw mx my b">Account</code>副本(分配给了<code class="fe mv mw mx my b">acc2</code>)和改变后的字段。</p><p id="1313" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与复制值相比，使用指针有它的好处，特别是如果你的结构非常大，这可能会导致复制时的性能问题，但你应该总是问自己这样做是否值得，永远不要试图过早地优化代码。尤其是当您正在处理并发时。你可能会陷入一些糟糕的境地。</p><h2 id="1d47" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">较少依赖全局或外部状态</h2><p id="2cd6" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">不变性不仅适用于结构，也适用于函数。如果我们用相同的参数执行相同的函数两次，我们应该会收到相同的结果，对吗？如果我们依赖于外部状态或全局变量，这可能不总是正确的。最好避免这样。有几种方法可以实现这一点。我们称对于给定的输入总是返回相同输出的函数为纯函数。</p><p id="2e62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有一个共享的全局变量用于函数内部，考虑将该值作为参数传递，而不是直接在函数内部使用。这使得您的功能更加可预测，也更容易测试。整个代码的可读性也会变得更容易，因为其他人会知道值可能会影响函数的行为，因为它是一个参数，毕竟这就是参数的用途。这里有一个虚拟的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="33a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数<code class="fe mv mw mx my b">sum</code>使用一个全局变量作为其计算的一部分。这在函数签名中并不清楚。更好的方法是将rand变量作为参数传递。所以这个函数看起来像这样:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="2679" class="lv lw it my b gy nd ne l nf ng">func sum(a, b, rand <strong class="my iu">int</strong>) <strong class="my iu">int</strong> {<br/>   return a + b + rand<br/>}</span></pre><p id="395d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更加可预测，而且它不会影响函数范围之外的变量，以防我们需要给它赋值或者类似的事情。</p><p id="feb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种方法是将这些外部状态变量封装到一个不可变的结构中，并将该结构用作函数接收器。在函数签名是接口的一部分的情况下，这是非常重要的。这是我在本文的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/dependency-injection-in-go-using-receiver-functions-d76b7e541ecd">中提到的一种非常常见的技术(重点是依赖注入，但它也同样适用于这种场景)。</a></p><h2 id="c21a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">最后的想法</h2><p id="f389" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果您了解如何实现不变性，那么使用不变性可以提高代码的可读性和稳定性。就像生活中的一切一样，在每个场合使用它都有利弊。当在代码中实现它时，您必须考虑权衡。实现本文中描述的技术需要大量的样板代码，这可能非常繁琐并且容易出错。但是，如果我们在并发函数中共享状态时不使用不变性，事情会变得更糟，例如，这会导致复杂的逻辑和竞争条件。此外，实现不变性并不是免费的，因为通常您必须优先选择副本而不是指针，这在某些情况下会导致严重的性能问题。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><div class="kj kk kl km gt np"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">编写面试问题</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">技术开发</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od ks np"/></div></div></a></div></div></div>    
</body>
</html>