<html>
<head>
<title>How to use npm/yarn/Node.js package.json scripts as your build tool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用npm/yarn/Node.js package.json脚本作为您的构建工具</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-use-npm-yarn-node-js-package-json-scripts-as-your-build-tool-f4bf87e85af5?source=collection_archive---------14-----------------------#2020-09-02">https://levelup.gitconnected.com/how-to-use-npm-yarn-node-js-package-json-scripts-as-your-build-tool-f4bf87e85af5?source=collection_archive---------14-----------------------#2020-09-02</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj jr"><img src="../Images/2f433d4ea510419e739600e1436e6c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SPqwDvJbSR4Z0Nbh.jpg"/></div></div></figure><p id="2ae3" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">与Node.js平台捆绑在一起的是包管理工具<em class="la"> npm </em>的一个被低估的特性。npm的主要目的是访问运行在Node.js上的一个非常大的软件包库，但是它包含一个特性，即<code class="fe lb lc ld le b">scripts</code>标签，它本身非常强大。有了这个标记，就有可能使用任何命令行实用程序来构建复杂的数据操作系统。</p><p id="8483" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">使用<code class="fe lb lc ld le b">scripts</code>标签，我们可以在一个<code class="fe lb lc ld le b">package.json</code>文件中记录命名的命令。例如，<code class="fe lb lc ld le b">deploy</code>脚本可能使用<code class="fe lb lc ld le b">rsync</code>将文件上传到服务器。这个标签本身并不十分强大，尽管有了它我们可以运行任何命令行工具。但是，npm资源库中的一些可用工具可以用来在<code class="fe lb lc ld le b">scripts</code>部分构建复杂的处理架构。再加上可用Node.js包的庞大库，我们就有了一个强大的环境来实现构建系统、web发布系统，甚至远至训练机器学习模型的系统。</p><p id="48fe" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe lb lc ld le b">package.json</code>中的<code class="fe lb lc ld le b">scripts</code>标签由<em class="la"> npm </em>项目引入。它的主要用途是支持包安装、其他包管理任务和简单的项目脚本，如启动服务器的方法。主要目标是Node.js包或应用程序作者。</p><p id="04ec" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">仅仅因为这是设计目标并不意味着我们不能将<code class="fe lb lc ld le b">scripts</code>标签用于其他目的。运行任何命令行工具的能力，以及使用允许您构建复杂处理层次结构的插件的能力，给了我们强大的组合。</p><p id="52b1" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">与其使用<code class="fe lb lc ld le b">package.json</code>来开发Node.js包、应用程序或服务器，不如让我们考虑一个不同类型的项目。例如，您已经构建了一个Docker容器，并且想要自动构建它并将其发布到Docker存储库中。您可以编写一个shell脚本、一个Makefile，或者您可以用npm和<code class="fe lb lc ld le b">package.json</code>实现发布过程。这需要将<code class="fe lb lc ld le b">docker login</code>、<code class="fe lb lc ld le b">docker build</code>和<code class="fe lb lc ld le b">docker push</code>命令记录到<code class="fe lb lc ld le b">package.json</code>的<code class="fe lb lc ld le b">scripts</code>部分。您可能需要支持在Windows、Linux和macOS机器上运行构建，有一个Node.js工具可以帮助跨平台运行命令。</p><p id="5e2b" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">使用<code class="fe lb lc ld le b">package.json</code>或许多其他工具，可以自动完成这项任务和许多其他任务。选择权在你。本文将向您介绍如何将<code class="fe lb lc ld le b">package.json</code>用于其主要设计目标之外的目的。</p><p id="9cb1" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">对于那些已经在使用Node.js平台的人来说，这是最有意义的，无论是编写Node.js包或应用程序，还是使用Node.js中编写的工具。这些人可能已经在使用<code class="fe lb lc ld le b">package.json</code>文件，并且可以很容易地将该文件扩展为构建工具。</p><p id="d14f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">TL；DR如果你已经知道如何使用<code class="fe lb lc ld le b">package.json</code>和npm，你可能会觉得接下来的几节很无聊。这篇文章让读者从零开始，以防他们从未见过这些材料。</p><h1 id="794d" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">什么是<code class="fe lb lc ld le b">package.json</code>和npm/Yarn生态系统</h1><p id="085c" class="pw-post-body-paragraph kc kd iu ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz in bi translated">使用<code class="fe lb lc ld le b">package.json</code>的一个很大的吸引力是Node.js、npm和Yarn本身就支持它。触手可及的不仅仅是一个强大的编程平台，而是一个庞大的Node.js包生态系统。</p><p id="e335" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">正如我们刚才所说的，有三个领域<code class="fe lb lc ld le b">package.json</code>是重要的。首先，Node.js使用它来描述包目录。其次，它用于npm/Yarn生态系统中的包装管理。第三，它被包或应用程序作者用于与他们的项目相关的脚本。</p><p id="4fa0" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在本节中，我们先快速讨论前两个，然后再深入讨论第三个。</p><h1 id="edc0" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Node.js在<code class="fe lb lc ld le b">package.json</code>里找什么？</h1><p id="dfe2" class="pw-post-body-paragraph kc kd iu ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz in bi translated"><code class="fe lb lc ld le b">package.json</code>文件是为Node.js开发的，但是Node.js只使用了现代<code class="fe lb lc ld le b">package.json</code>的一小部分内容。例如:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="2145" class="mq lg iu le b gz mr ms l mt mu">{<br/>     "name": "example-package-json",<br/>     "type": "commonjs",<br/>     "main": "./path/to/main.js"<br/>}</span></pre><p id="e6b5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">大概就是这样。</p><p id="db2e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">上下文是Node.js将单个JavaScript文件视为<em class="la">模块</em>，并且它可以将正确构建的目录视为<em class="la">模块</em>。在Node.js文档中查找作为模块的<em class="la">文件夹。使目录成为模块的一个东西是<code class="fe lb lc ld le b">package.json</code>文件。Node.js运行时在该文件中查找非常少的字段。除了这里显示的三个字段，还有一个字段<code class="fe lb lc ld le b">exports</code>，它是<code class="fe lb lc ld le b">main</code>字段的替代字段。</em></p><h1 id="57dc" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">package.json</code>NPM或者Yarn找什么？</h1><p id="3c18" class="pw-post-body-paragraph kc kd iu ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz in bi translated">正如我们所说，包管理器应用程序(npm、Yarn等)向<code class="fe lb lc ld le b">package.json</code>添加了大量字段。这些字段涵盖包管理、依赖关系管理以及用于打包或项目管理的脚本。</p><p id="830a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">运行命令<code class="fe lb lc ld le b">npm help package.json</code>显示附加<code class="fe lb lc ld le b">package.json</code>字段的列表。</p><p id="201d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">字段<code class="fe lb lc ld le b">description</code>、<code class="fe lb lc ld le b">version</code>、<code class="fe lb lc ld le b">repository</code>、<code class="fe lb lc ld le b">keywords</code>、<code class="fe lb lc ld le b">author</code>、<code class="fe lb lc ld le b">license</code>、<code class="fe lb lc ld le b">bugs</code>和<code class="fe lb lc ld le b">homepage</code>是显示在<em class="la"> npmjs </em>上的套餐列表上的数据示例。<em class="la"> com </em>网站。这些是我们之前提到的<em class="la">包管理</em>的例子。</p><p id="1898" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">与<code class="fe lb lc ld le b">dependencies</code>和<code class="fe lb lc ld le b">devDependencies</code>字段一样，<code class="fe lb lc ld le b">version</code>字段也用于依赖关系管理。这些字段在安装软件包时使用，软件包管理器(npm/Yarn)读取这些字段中的条目以安装软件包。<code class="fe lb lc ld le b">version</code>字段通告每个包的每个实例的版本号，而<code class="fe lb lc ld le b">dependencies</code>字段指定要使用的可接受的版本号。通过这种方式，软件包管理器可以下载所需软件包的正确版本。依赖项字段也可以指向npm注册中心之外的包，比如来自Git存储库或任意URL的包。这些是我们之前提到的<em class="la">依赖管理</em>的例子。</p><p id="814b" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><em class="la">项目管理</em>的主要机制是<code class="fe lb lc ld le b">scripts</code>域。我们将在本文的剩余部分深入探讨这个问题。<code class="fe lb lc ld le b">scripts</code>字段是为包开发者或应用开发者服务而发明的。运行<code class="fe lb lc ld le b">npm help scripts</code>获取该字段的描述。在阅读时，要特别注意预定义的脚本。</p><h1 id="1c3d" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">创建一个<code class="fe lb lc ld le b">package.json</code>文件</h1><p id="8c1b" class="pw-post-body-paragraph kc kd iu ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz in bi translated">首先，让我们学习如何使用npm(或Yarn)创建一个<code class="fe lb lc ld le b">package.json</code>。很简单:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="8cd2" class="mq lg iu le b gz mr ms l mt mu">$ mkdir example1<br/>$ cd example1<br/>$ npm init -y<br/>Wrote to /Volumes/Extra/nodejs/npm-build-scripts/example1/package.json:</span><span id="cbde" class="mq lg iu le b gz mv ms l mt mu">{<br/>  "name": "example1",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>  },<br/>  "keywords": [],<br/>  "author": "David Herron &lt;<a class="ae mw" href="mailto:david@davidherron.com" rel="noopener ugc nofollow" target="_blank">david@davidherron.com</a>&gt;",<br/>  "license": "ISC"<br/>}</span></pre><p id="d4f7" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这是制造一个<code class="fe lb lc ld le b">package.json</code>最快的方法。去掉<code class="fe lb lc ld le b">-y</code>选项，你会被问一些关于项目的问题，使用这个选项时，每个选项都采用默认值。</p><p id="4b7f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">您可以设置一些npm配置设置，以帮助用正确的值自动填充生成的<code class="fe lb lc ld le b">package.json</code>:</p><ul class=""><li id="abb3" class="mx my iu ke b kf kg kj kk kn mz kr na kv nb kz nc nd ne nf bi translated"><code class="fe lb lc ld le b">npm config set init.author.name "..."</code> -设置作者姓名</li><li id="6c6b" class="mx my iu ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated"><code class="fe lb lc ld le b">npm config set init.author.email ...@...</code> -设置作者的电子邮件地址</li><li id="5dae" class="mx my iu ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated"><code class="fe lb lc ld le b">npm config set init.author.url https://...</code> -设置作者主页的网址</li><li id="04c3" class="mx my iu ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated"><code class="fe lb lc ld le b">npm config set init.license ...</code> -设置要使用的默认许可证</li></ul><p id="7cd3" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">要了解配置设置，运行<code class="fe lb lc ld le b">npm help 7 config</code>。</p><p id="72db" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">一旦你有了<code class="fe lb lc ld le b">package.json</code>，你就可以前进了。</p><h1 id="9085" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">熟悉<code class="fe lb lc ld le b">package.json</code>中的<code class="fe lb lc ld le b">scripts</code>标签</h1><p id="50dc" class="pw-post-body-paragraph kc kd iu ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz in bi translated"><code class="fe lb lc ld le b">package.json</code>的脚本部分包含一个命名脚本列表。当npm生成这个文件时，如上所示，它包含一个<code class="fe lb lc ld le b">test</code>脚本。它是这样运行的:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="b8a0" class="mq lg iu le b gz mr ms l mt mu">$ npm run test </span><span id="e121" class="mq lg iu le b gz mv ms l mt mu">&gt; example1@1.0.0 test /Users/David/nodejs/npm-build-scripts/example1 <br/>&gt; echo "Error: no test specified" &amp;&amp; exit 1 </span><span id="a3eb" class="mq lg iu le b gz mv ms l mt mu">Error: no test specified npm <br/>ERR! code ELIFECYCLE <br/>...</span></pre><p id="0938" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这个脚本运行一个<code class="fe lb lc ld le b">echo</code>命令，然后运行<code class="fe lb lc ld le b">exit 1</code>。最后是什么让npm认为发生了错误。</p><p id="f519" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们也可以将此作为<code class="fe lb lc ld le b">npm test</code>运行，省去<code class="fe lb lc ld le b">run</code>。这是因为npm有几个与npm子命令对应的预定义脚本名称:</p><ul class=""><li id="d2e0" class="mx my iu ke b kf kg kj kk kn mz kr na kv nb kz nc nd ne nf bi translated"><code class="fe lb lc ld le b">npm test</code> -运行一个测试脚本</li><li id="11cb" class="mx my iu ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated"><code class="fe lb lc ld le b">npm start</code> -运行命令启动服务器</li><li id="e40c" class="mx my iu ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated"><code class="fe lb lc ld le b">npm restart</code> -运行命令重启服务器</li><li id="97c4" class="mx my iu ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated"><code class="fe lb lc ld le b">npm stop</code> -运行命令停止正在运行的服务器</li></ul><p id="d0d8" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">对于任何其他脚本，它作为<code class="fe lb lc ld le b">npm run script-name</code>执行。运行<code class="fe lb lc ld le b">npm help scripts</code>给出了更多关于如何解释的信息。预烘焙脚本旨在处理<em class="la">生命周期事件</em>，这意味着它们在Node.js应用程序中安装、使用或开发Node.js包的特定阶段执行。</p><h1 id="7963" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用前脚本和后脚本</h1><p id="dd2d" class="pw-post-body-paragraph kc kd iu ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz in bi translated">该机制支持基本的控制流。考虑:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="ae13" class="mq lg iu le b gz mr ms l mt mu">"scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",<br/>    "prestart": "echo 'Pre-start runs before start'",<br/>    "start": "echo 'START'",<br/>    "poststart": "echo 'Post-start runs after start'"<br/>},</span></pre><p id="ca76" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">顾名思义，对于名为<em class="la"> foo </em>的脚本，<em class="la"> prefoo </em>脚本在<em class="la"> foo </em>之前运行，<em class="la"> postfoo </em>脚本在<em class="la"> foo </em>之后运行。看起来是这样的:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="ea6c" class="mq lg iu le b gz mr ms l mt mu">$ npm start</span><span id="aaa0" class="mq lg iu le b gz mv ms l mt mu">&gt; example1@1.0.0 prestart /Users/David/nodejs/npm-build-scripts/example1<br/>&gt; echo 'Pre-start runs before start'</span><span id="fb78" class="mq lg iu le b gz mv ms l mt mu">Pre-start runs before start</span><span id="1a69" class="mq lg iu le b gz mv ms l mt mu">&gt; example1@1.0.0 start /Users/David/nodejs/npm-build-scripts/example1<br/>&gt; echo 'START'</span><span id="3247" class="mq lg iu le b gz mv ms l mt mu">START</span><span id="6370" class="mq lg iu le b gz mv ms l mt mu">&gt; example1@1.0.0 poststart /Users/David/nodejs/npm-build-scripts/example1<br/>&gt; echo 'Post-start runs after start'</span><span id="86e0" class="mq lg iu le b gz mv ms l mt mu">Post-start runs after start</span></pre><p id="aca7" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如果想要无限循环，将<code class="fe lb lc ld le b">poststart</code>改为:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="8a11" class="mq lg iu le b gz mr ms l mt mu">"poststart": "echo 'Post-start runs after start' &amp;&amp; npm run start"</span></pre><p id="f55a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">由于脚本中的文本被视为Unix shell脚本，并且命令结构<code class="fe lb lc ld le b">cmd &amp;&amp; cmd</code>一个接一个地运行命令，这使得<code class="fe lb lc ld le b">poststart</code>脚本再次运行<code class="fe lb lc ld le b">start</code>。哪个...再次执行整个<code class="fe lb lc ld le b">prestart</code> / <code class="fe lb lc ld le b">start</code> / <code class="fe lb lc ld le b">poststart</code>序列。</p><h1 id="e323" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">向脚本传递参数</h1><p id="8182" class="pw-post-body-paragraph kc kd iu ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz in bi translated">可以从<code class="fe lb lc ld le b">npm</code>命令行向脚本传递参数。考虑:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="818a" class="mq lg iu le b gz mr ms l mt mu">"withargs": "echo ARGS"</span></pre><p id="a28b" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">然后我们运行这个:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="bc47" class="mq lg iu le b gz mr ms l mt mu">$ npm run withargs -- Hello World</span><span id="9883" class="mq lg iu le b gz mv ms l mt mu">&gt; example1@1.0.0 withargs /Users/David/nodejs/npm-build-scripts/example1<br/>&gt; echo ARGS "Hello" "World"</span><span id="bbd3" class="mq lg iu le b gz mv ms l mt mu">ARGS Hello World</span></pre><p id="0eb8" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe lb lc ld le b">--</code>之后的所有内容都在已执行脚本的命令行上传递。</p><h1 id="a147" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用壳牌管道</h1><p id="4914" class="pw-post-body-paragraph kc kd iu ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz in bi translated">由于脚本使用Unix shell脚本语法，这包括构建管道。</p><p id="d017" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">考虑:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="8d9f" class="mq lg iu le b gz mr ms l mt mu">"pipeline": "echo one two three four | wc"</span></pre><p id="c2e1" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如果您已经做到这一步，您可能知道<code class="fe lb lc ld le b">wc</code>命令打印标准输入的字数。这是我能想到的第一个微不足道的管道例子。让我们看看这是如何运行的:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="8960" class="mq lg iu le b gz mr ms l mt mu">$ npm run pipeline </span><span id="97d2" class="mq lg iu le b gz mv ms l mt mu">&gt; example1@ 1.0 .0 pipeline /Users/David/nodejs/npm-build-scripts/example1 <br/>&gt; echo one two three four | wc </span><span id="c7f6" class="mq lg iu le b gz mv ms l mt mu">1 4 19</span></pre><p id="ede9" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">是的，输入是一行，四个单词，十九个字符，就像<code class="fe lb lc ld le b">wc</code>命令所说的那样。这是一个微不足道的例子，但是在这里你当然可以构建和使用无数不同的管道。</p><p id="d227" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这些琐碎的例子是为了让你熟悉一些可能性。记住这一点，让我们看一些更全面的例子。</p><h1 id="e393" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">一个接一个地运行一系列脚本</h1><p id="7e67" class="pw-post-body-paragraph kc kd iu ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz in bi translated">在Unix命令行中，我们可以执行<code class="fe lb lc ld le b">cmd &amp;&amp; cmd &amp;&amp; cmd</code>来连续运行一系列命令。在<code class="fe lb lc ld le b">package.json</code>脚本中，我们已经看到我们可以做同样的事情来一个接一个地运行一组命令。考虑如何在<code class="fe lb lc ld le b">package.json</code>脚本中使用<code class="fe lb lc ld le b">&amp;&amp;</code>实现多步骤流程。</p><p id="3b47" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在一个名为<code class="fe lb lc ld le b">build-site</code>的新目录下，启动一个新项目(运行<code class="fe lb lc ld le b">npm init -y</code>)。在该目录中安装这些软件包:</p><p id="f766" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在<code class="fe lb lc ld le b">package.json</code>中添加这些<code class="fe lb lc ld le b">script</code>标签:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="283d" class="mq lg iu le b gz mr ms l mt mu">$ npm install lessc mustache html-minifer --save</span></pre><p id="c93c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">然后考虑在<code class="fe lb lc ld le b">build-site</code>目录中是另一个目录<code class="fe lb lc ld le b">site</code>，其中包含一个名为<code class="fe lb lc ld le b">style.less</code>的文件，该文件包含一个用LESS语法编写的样式表，以及一个要呈现到名为<code class="fe lb lc ld le b">index.html</code>的文件中的Mustache模板。</p><p id="9d2b" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在<code class="fe lb lc ld le b">package.json</code>中添加这些<code class="fe lb lc ld le b">script</code>标签:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="7d16" class="mq lg iu le b gz mr ms l mt mu">"scripts": {<br/>    "build-site": "npm run less &amp;&amp; npm run render &amp;&amp; npm run deploy",<br/>    "less": "lessc site/style.less build/style.css",<br/>    "render": "mustache data.json site/index.mustache build/index.html",<br/>    "deploy": "cd build &amp;&amp; rsync --archive --delete --verbose ./ <a class="ae mw" href="mailto:user-name@remote-host.com" rel="noopener ugc nofollow" target="_blank">user-name@remote-host.com</a>:docroot-directory/"<br/>},</span></pre><p id="e32a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们不会占用空间向您展示单个文件，所以请想象这些文件是存在的，并且具有合理的内容。<code class="fe lb lc ld le b">build-site</code>标签描述了一个多阶段过程，其中每个阶段是另一个脚本命令。第一阶段使用<code class="fe lb lc ld le b">lessc</code>编译样式表，第二阶段使用<code class="fe lb lc ld le b">mustache</code>呈现模板，使用<code class="fe lb lc ld le b">html-minifier</code>缩小HTML，最后一阶段使用<code class="fe lb lc ld le b">rsync</code>部署到服务器。</p><p id="7cfd" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如果我们模拟一些数据，如下所示:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="ed23" class="mq lg iu le b gz mr ms l mt mu">$ mkdir site<br/>$ touch site/style.less site/index.mustache<br/>$ echo '{}' &gt;data.json<br/>$ mkdir build</span></pre><p id="56b5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">再次，假装这里有真实的文件。例如，<code class="fe lb lc ld le b">data.json</code>可能是我们在这个过程的另一个阶段运行的数据库查询的结果。</p><p id="cad8" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们可以像这样运行构建:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="6bd8" class="mq lg iu le b gz mr ms l mt mu">$ npm run build-site</span><span id="1125" class="mq lg iu le b gz mv ms l mt mu">&gt; build-site@1.0.0 build-site /Users/David/nodejs/npm-build-scripts/build-site<br/>&gt; npm run less &amp;&amp; npm run render  &amp;&amp; npm run deploy</span><span id="044e" class="mq lg iu le b gz mv ms l mt mu">&gt; build-site@1.0.0 less /Users/David/nodejs/npm-build-scripts/build-site<br/>&gt; lessc site/style.less build/style.css</span><span id="41d9" class="mq lg iu le b gz mv ms l mt mu">&gt; build-site@1.0.0 render /Users/David/nodejs/npm-build-scripts/build-site<br/>&gt; mustache data.json site/index.mustache | html-minifier -o build/index.html</span><span id="3d88" class="mq lg iu le b gz mv ms l mt mu">&gt; build-site@1.0.0 deploy /Users/David/nodejs/npm-build-scripts/build-site<br/>&gt; cd build &amp;&amp; rsync --archive --delete --verbose ./ <a class="ae mw" href="mailto:user-name@remote-host.com" rel="noopener ugc nofollow" target="_blank">user-name@remote-host.com</a>:docroot-directory/</span><span id="c99e" class="mq lg iu le b gz mv ms l mt mu">...</span></pre><p id="5637" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">将每个阶段分成自己的<code class="fe lb lc ld le b">scripts</code>条目是一个很好的做法。这样，我们可以单独运行阶段，如果需要调试一个阶段，同时也使每个脚本更容易阅读。想象一下，如果你把所有的东西都写在一行，T2的剧本会是什么样子。当你想到这个就不寒而栗的时候，赞美npm(和Yarn)让你使用这个技术。</p><h1 id="ff9c" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用<code class="fe lb lc ld le b">npm-run-all</code>改进顺序脚本执行</h1><p id="60af" class="pw-post-body-paragraph kc kd iu ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz in bi translated"><code class="fe lb lc ld le b">build-site</code>的例子很有趣，因为它指向使用<code class="fe lb lc ld le b">package.json</code>构建复杂流程的能力。显然级数可以扩大。例如，我们建议可以从数据库查询中生成<code class="fe lb lc ld le b">data.json</code>,我们可以轻松地编写一个定制的Node.js脚本来执行该查询。还有其他工具可以考虑，比如使用TypeScript编译器从TypeScript源代码生成JavaScript文件。或者使用lint工具来确保生成的代码是干净的。并且可能需要一些图像处理步骤。当然，网站可以有多个页面来呈现。</p><p id="5223" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">一个问题是<code class="fe lb lc ld le b">build-site</code>脚本本身有点笨拙。我们实现的想法越多，这个脚本就变得越来越笨拙，直到变得完全不可管理。幸运是，有一个工具<code class="fe lb lc ld le b">npm-run-all</code>，可以简化设置。</p><p id="da16" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">有关文件，请参见:<a class="ae mw" href="https://www.npmjs.com/package/npm-run-all" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/npm-run-all</a></p><p id="0114" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">为了进行试验，将<code class="fe lb lc ld le b">build-site</code>目录复制为<code class="fe lb lc ld le b">build-site-2</code>，然后运行以下命令:</p><p id="b0a4" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">然后将脚本部分重写为:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="7d79" class="mq lg iu le b gz mr ms l mt mu">$ cd build-site-2<br/>$ npm install npm-run-all --save-dev</span></pre><p id="d349" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这样就干净一点了。<code class="fe lb lc ld le b">build-site</code>脚本更容易阅读，而且因为它更紧凑，所以有更大的发展空间。就其本身而言，这些都是小胜利，但<code class="fe lb lc ld le b">npm-run-all</code>的另一个特点将使它成为更大的胜利。具体来说:<em class="la">通配符</em></p><p id="8a1f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">将脚本更改为:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="9bc1" class="mq lg iu le b gz mr ms l mt mu">"scripts": {<br/>    "build-site": "npm-run-all build:less build:render build:deploy",<br/>    "build:less": "lessc site/style.less build/style.css",<br/>    "build:render": "mustache data.json site/index.mustache | html-minifier -o build/index.html",<br/>    "build:deploy": "cd build &amp;&amp; rsync --archive --delete --verbose ./ <a class="ae mw" href="mailto:user-name@remote-host.com" rel="noopener ugc nofollow" target="_blank">user-name@remote-host.com</a>:docroot-directory/"<br/>},</span></pre><p id="ba85" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这样就干净一点了。这个脚本更容易阅读，而且因为它更紧凑，所以有更大的发展空间。就其本身而言，这些都是小胜利，但是<code class="fe lb lc ld le b">npm-run-all</code>的另一个特点将使它成为更大的胜利。具体来说:<em class="la">通配符</em></p><p id="d0ac" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">将脚本更改为:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="d7d2" class="mq lg iu le b gz mr ms l mt mu">"build-site": "npm-run-all build:*",</span></pre><p id="bfe1" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如您所料，<code class="fe lb lc ld le b">build:*</code>模式匹配以<code class="fe lb lc ld le b">build</code>开头的每个脚本名。</p><p id="91b5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">其工作方式是，<code class="fe lb lc ld le b">npm-run-all</code>从<code class="fe lb lc ld le b">package.json</code>读取所有脚本，并使用glob风格的模式匹配来选择要运行的脚本。使用一个星号，它运行这里显示的模式的“子脚本”，但是它不运行像<code class="fe lb lc ld le b">build:render:index</code>这样的“子子脚本”。要运行sub-sub脚本，请使用“globstar”或<code class="fe lb lc ld le b">build:**</code>。</p><p id="275f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">最终的脚本执行如下所示:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="ff8b" class="mq lg iu le b gz mr ms l mt mu">$ npm run build-site</span><span id="a89f" class="mq lg iu le b gz mv ms l mt mu">&gt; build-site@1.0.0 build-site /Users/David/nodejs/npm-build-scripts/build-site-2<br/>&gt; npm-run-all build:*<br/></span><span id="bff7" class="mq lg iu le b gz mv ms l mt mu">&gt; build-site@1.0.0 build:less /Users/David/nodejs/npm-build-scripts/build-site-2<br/>&gt; lessc site/style.less build/style.css<br/></span><span id="21fe" class="mq lg iu le b gz mv ms l mt mu">&gt; build-site@1.0.0 build:render /Users/David/nodejs/npm-build-scripts/build-site-2<br/>&gt; mustache data.json site/index.mustache | html-minifier -o build/index.html<br/></span><span id="d884" class="mq lg iu le b gz mv ms l mt mu">&gt; build-site@1.0.0 build:deploy /Users/David/nodejs/npm-build-scripts/build-site-2<br/>&gt; cd build &amp;&amp; rsync --archive --delete --verbose ./ user-name@remote-host.com:docroot-directory/</span></pre><p id="7233" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">和以前差不多，但是<code class="fe lb lc ld le b">build-site</code>脚本现在更容易管理了。我们可以在<code class="fe lb lc ld le b">build</code>组中添加或删除脚本，而不必编辑<code class="fe lb lc ld le b">build-site</code>脚本。</p><h1 id="ffed" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">并行脚本执行</h1><p id="ffce" class="pw-post-body-paragraph kc kd iu ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz in bi translated">有了<code class="fe lb lc ld le b">npm-run-all</code>，我们不再局限于一步接一步的顺序执行。它还可以并行运行这些步骤，这在某些情况下可能很有用。为此，只需在命令行中添加<code class="fe lb lc ld le b">--parallel</code>选项。</p><p id="c70b" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在我们的<code class="fe lb lc ld le b">build-site</code>示例中，构建步骤彼此独立，不必按顺序运行。这意味着我们可以添加<code class="fe lb lc ld le b">-parallel</code>，就像这样:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="5e83" class="mq lg iu le b gz mr ms l mt mu">$ npm-run-all --parallel build:*</span></pre><p id="a0da" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们将在下一节看到一个使用这个特性的实际例子。</p><h1 id="f71b" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用<code class="fe lb lc ld le b">onchange</code>在文件改变时自动重建</h1><p id="c634" class="pw-post-body-paragraph kc kd iu ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz in bi translated">刚刚描述的简单的“<em class="la">构建HTML页面</em>”场景可以有几个方向。一个常见的方向是自动监视源文件，并重建任何被更改的文件。编码器将编辑网站代码，保存更改，自动重建发生，并在网络浏览器中重新加载屏幕。这是迭代开发的正常编辑-构建-测试循环。</p><p id="69f8" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">例如，如果这是一个实际的项目，HTML页面可能包含一个Vue.js或React客户端到一个后端服务。与应用程序相关的文件中的任何编辑都应该触发重建。</p><p id="778f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">让我们停止假装，做一些真正的文件，但让它保持简单和简洁。</p><p id="c8eb" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">创建一个工作目录:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="050c" class="mq lg iu le b gz mr ms l mt mu">$ mkdir build-site-3 <br/>$ cd build-site-3 <br/>$ cp ../build-site-2/package.json .</span></pre><p id="84b2" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这给了我们一个已知的上一节的起点。在<code class="fe lb lc ld le b">package.json</code>中，删除<code class="fe lb lc ld le b">build:deploy</code>脚本，因为我们实际上不需要它。然后安装这些软件包:</p><p id="0956" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><em class="la"> onchange </em>包是一个工具，用于查看文件集，并根据对这些文件的更改运行命令。我们将用它来触发自动重建。文件见:<a class="ae mw" href="https://www.npmjs.com/package/onchange" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/onchange</a></p><p id="f2b9" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><em class="la"> live-server </em>包是一个简单的web服务器，支持在文件改变时自动重新加载浏览器页面。文件见:<a class="ae mw" href="https://www.npmjs.com/package/live-server" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/live-server</a></p><p id="5cd6" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在我们了解如何使用这些包之前，让我们创建几个简单的源文件来使用。</p><p id="4da5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">创建一个<code class="fe lb lc ld le b">site</code>目录，并在该目录下创建一个名为<code class="fe lb lc ld le b">index.mustache</code>的文件:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="247e" class="mq lg iu le b gz mr ms l mt mu">&lt;html&gt;<br/>&lt;head&gt;<br/>    &lt;title&gt;{{ title }}&lt;/title&gt;<br/>    &lt;link rel="stylesheet" href="/style.css"&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>    &lt;h1&gt;{{ title }}&lt;/h1&gt;<br/>    &lt;form&gt;<br/>        &lt;label for="labelFibonum" class="form-label"&gt;{{ fibolabel }}&lt;/label&gt;<br/>        &lt;input type="text" class="form-control" id="inputFibonum"&gt;<br/>    &lt;/form&gt;<br/>    &lt;div id="fiboVal"&gt;&lt;/div&gt;<br/>    &lt;script src="/fibocalc.js"&gt;&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="d181" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们所拥有的是一个微不足道的HTML页面，我们可以用Mustache处理它来生成一个<code class="fe lb lc ld le b">index.html</code>。我们将从JSON文件中提取一些文本值。我们将使用JSON文件作为一个简单的I18N实现，让我们在JSON中存储文本字符串，并用不同的JSON文件替换不同的语言。在<code class="fe lb lc ld le b">fibocalc.js</code>中，我们将编写一个小的JavaScript应用程序来计算斐波那契值。用户将在输入字段中输入一个数字，代码将看到该值并计算相应的斐波那契数。</p><p id="155f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在父目录中，在<code class="fe lb lc ld le b">package.json</code>旁边，创建一个名为<code class="fe lb lc ld le b">labels.en.json</code>的文件:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="4aad" class="mq lg iu le b gz mr ms l mt mu">{<br/>    "title": "Fibo Calculator",<br/>    "fiboLabel": "Enter a number to calculate Fibonacci number"<br/>}</span></pre><p id="0577" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们将使用这个文件作为简单的国际化(I18N)方法。处理模板时，<code class="fe lb lc ld le b">title</code>和<code class="fe lb lc ld le b">fibolabel</code>的值成为<code class="fe lb lc ld le b">title</code>和<code class="fe lb lc ld le b">fibolabel</code>变量。因此，当我们运行<code class="fe lb lc ld le b">mustache</code>命令时，这些值将从这个文件中提取出来，并插入到渲染输出中。我们还需要修改<code class="fe lb lc ld le b">build:render</code>脚本来引用<code class="fe lb lc ld le b">labels.en.json</code>而不是<code class="fe lb lc ld le b">data.json</code>。</p><p id="9f76" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在<code class="fe lb lc ld le b">site</code>目录中添加一个名为<code class="fe lb lc ld le b">fibocalc.js</code>的文件，包含:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="20ce" class="mq lg iu le b gz mr ms l mt mu">document.addEventListener("DOMContentLoaded", function() {</span><span id="e3b8" class="mq lg iu le b gz mv ms l mt mu">let input = document.getElementById('inputFibonum');<br/>    let display = document.getElementById('fiboVal');</span><span id="758b" class="mq lg iu le b gz mv ms l mt mu">input.oninput = function(e) {<br/>        let entered = e.target.value;<br/>        let fibonum = Number.parseInt(entered);<br/>        if (Number.isNaN(fibonum)) {<br/>            display.textContent = `ERROR: Non-number entered ${entered}`;<br/>        } else {<br/>            let fiboval = fibonacciLoop(fibonum);<br/>            display.textContent = `Fibonacci ${fibonum} = ${fiboval}`;<br/>        }<br/>    }</span><span id="617d" class="mq lg iu le b gz mv ms l mt mu">    function fibonacciLoop(n) {<br/>        let fibos = [];<br/>        fibos[0] = 0;<br/>        fibos[1] = 1;<br/>        fibos[2] = 1;<br/>        for (let i = 3; i &lt;= n; i++) {<br/>            fibos[i] = fibos[i-2] + fibos[i-1];<br/>        }<br/>        return fibos[n];<br/>    }<br/>});</span></pre><p id="e245" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们在这里使用纯JavaScript/DOM代码，而不是像jQuery这样的框架。其外部包装相当于jQuery <code class="fe lb lc ld le b">$(document).ready</code>构造，目的是在运行JavaScript之前等待页面完成加载。</p><p id="7db1" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在JavaScript中，我们得到了<code class="fe lb lc ld le b">#inputFibonum</code>和<code class="fe lb lc ld le b">#fiboVal</code>元素的句柄。对于<code class="fe lb lc ld le b">#inputFibonum</code>,我们设置了一个<code class="fe lb lc ld le b">oninput</code>处理函数，使得任何输入到输入域的字符都可以调用这个函数。</p><p id="0040" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在处理程序中，我们试图将文本解析为整数。如果失败，我们在<code class="fe lb lc ld le b">#fiboVal</code>显示区输出一条错误信息。否则，我们运行一个简单的斐波那契计算，并在显示区域显示结果。</p><p id="a067" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">为了完善它，在<code class="fe lb lc ld le b">site</code>中添加一个名为<code class="fe lb lc ld le b">style.less</code>的文件，包含:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="e673" class="mq lg iu le b gz mr ms l mt mu">#fiboVal {<br/>    border: 3px dashed red;<br/>}</span></pre><p id="3fa1" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这将在显示区域周围抛出一个小边框。</p><p id="3e82" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们现在有了一个简单的小型浏览器端应用程序，以及一个从<code class="fe lb lc ld le b">site</code>到<code class="fe lb lc ld le b">build</code>目录呈现文件的构建过程。既然我们在本节开始时讨论了自动重建，那么让我们来关注一下。</p><p id="a94e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe lb lc ld le b">onchange</code>命令接受一个要监视的文件名模式列表和一个要运行的命令。例如:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="4387" class="mq lg iu le b gz mr ms l mt mu">$ onchange 'site/**.less' -- npm run build:less</span></pre><p id="9fae" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这将监视<code class="fe lb lc ld le b">site</code>目录中任何<code class="fe lb lc ld le b">.less</code>文件的变化，并运行<code class="fe lb lc ld le b">build:less</code>脚本。</p><p id="d20c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">记住这一点，让我们将<code class="fe lb lc ld le b">package.json</code>中的<code class="fe lb lc ld le b">scripts</code>部分改为:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="bf31" class="mq lg iu le b gz mr ms l mt mu">"scripts": {<br/>    "build-site": "npm-run-all build:*",<br/>    "build:less": "lessc site/style.less build/style.css",<br/>    "build:render": "mustache labels.en.json site/index.mustache | html-minifier -o build/index.html",<br/>    "build:js": "cp site/fibocalc.js build",<br/>    "preview": "cd build &amp;&amp; live-server --port=3333 ",<br/>    "watch": "npm-run-all --parallel watch:* preview",<br/>    "watch:less": "onchange 'site/**.less' -- npm run build:less",<br/>    "watch:js": "onchange 'site/**.js' -- npm run build:js",<br/>    "watch:html": "onchange 'labels.en.json' 'site/**.mustache' -- npm run build:render"<br/>},</span></pre><p id="7142" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这些<code class="fe lb lc ld le b">build</code>脚本和我们之前的差不多。我们添加了一个<code class="fe lb lc ld le b">build:js</code>脚本，它简单地将文件复制到构建目录中。该脚本可以做更多的事情，例如使用Babel将现代ES2019代码转换为可以在任何浏览器上运行的ES5代码。</p><p id="c2bf" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe lb lc ld le b">preview</code>脚本运行<code class="fe lb lc ld le b">build</code>目录中的<code class="fe lb lc ld le b">live-server</code>工具。这是一个简单的web服务器，包括自动实时重载。它监视提供给web浏览器的文件，一旦检测到变化，就会使浏览器重新加载页面。</p><p id="cc03" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">然后我们有了<code class="fe lb lc ld le b">watch</code>的剧本。<code class="fe lb lc ld le b">watch:*</code>脚本遵循刚才提到的模式，其中<code class="fe lb lc ld le b">onchange</code>命令监视某些文件，然后运行相应的<code class="fe lb lc ld le b">build:*</code>脚本。</p><p id="625d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">例如，运行<code class="fe lb lc ld le b">npm run watch:js</code>然后编辑<code class="fe lb lc ld le b">fibocalc.js</code>。每次编辑时，都会打印以下内容:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="fd3e" class="mq lg iu le b gz mr ms l mt mu">&gt; build-site@1.0.0 build:js /Users/David/nodejs/npm-build-scripts/build-site-3 <br/>&gt; site/fibocalc.js build</span></pre><p id="f0fa" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">换句话说，在每次编辑时，<code class="fe lb lc ld le b">build:js</code>脚本都会被执行，就像<code class="fe lb lc ld le b">watch:js</code>脚本所说的那样。</p><p id="481f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe lb lc ld le b">watch</code>脚本本身使用了<code class="fe lb lc ld le b">npm-run-all --parallel</code>选项。这样做是为了同时运行每个<code class="fe lb lc ld le b">watch:*</code>脚本和<code class="fe lb lc ld le b">preview</code>脚本。这样，我们可以自动重建源文件，并自动重新加载浏览器。</p><p id="e286" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">然后，我们可以运行这个:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="92cf" class="mq lg iu le b gz mr ms l mt mu">$ npm run watch</span><span id="6f73" class="mq lg iu le b gz mv ms l mt mu">&gt; build-site@1.0.0 watch /Volumes/Extra/nodejs/npm-build-scripts/build-site-3<br/>&gt; npm-run-all --parallel watch:* preview<br/></span><span id="b73e" class="mq lg iu le b gz mv ms l mt mu">&gt; build-site@1.0.0 watch:less /Volumes/Extra/nodejs/npm-build-scripts/build-site-3<br/>&gt; onchange 'site/**.less' -- npm run build:less<br/></span><span id="be06" class="mq lg iu le b gz mv ms l mt mu">&gt; build-site@1.0.0 watch:html /Volumes/Extra/nodejs/npm-build-scripts/build-site-3<br/>&gt; onchange 'labels.en.json' 'site/**.mustache' -- npm run build:render<br/></span><span id="8114" class="mq lg iu le b gz mv ms l mt mu">&gt; build-site@1.0.0 watch:js /Volumes/Extra/nodejs/npm-build-scripts/build-site-3<br/>&gt; onchange 'site/**.js' -- npm run build:js<br/></span><span id="c3fe" class="mq lg iu le b gz mv ms l mt mu">&gt; build-site@1.0.0 preview /Volumes/Extra/nodejs/npm-build-scripts/build-site-3<br/>&gt; cd build &amp;&amp; live-server --port=3333 </span><span id="05de" class="mq lg iu le b gz mv ms l mt mu">Serving "/Volumes/Extra/nodejs/npm-build-scripts/build-site-3/build" at http://127.0.0.1:3333<br/>Ready for changes</span></pre><p id="7c1d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这将启动并行运行的脚本。<code class="fe lb lc ld le b">live-server</code>流程告诉我们已经准备好进行变革。</p><p id="70f3" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe lb lc ld le b">live-server</code>还会自动打开一个浏览器标签，您会看到:</p><figure class="mi mj mk ml gu jv gi gj paragraph-image"><div class="gi gj nl"><img src="../Images/3e72d66bc27b7c8090bfeddc657953a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/0*_N5IeseVMe5Yf6Uv.jpg"/></div></figure><p id="7068" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">嗯，在输入栏中输入<code class="fe lb lc ld le b">55</code>后你会看到。</p><p id="9660" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">现在，编辑<code class="fe lb lc ld le b">site/fibocalc.js</code>,修改如下:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="a843" class="mq lg iu le b gz mr ms l mt mu">display.textContent = `Fibonacci CHANGE ${fibonum} = ${fiboval}`;</span></pre><p id="4689" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">一旦保存了更改，就会在您的终端中打印出来:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="e48b" class="mq lg iu le b gz mr ms l mt mu">&gt; build-site@1.0 .0 build:js /Volumes/Extra/nodejs/npm-build-scripts/build-site-3 <br/>&gt; cp site/fibocalc.js build </span><span id="51a2" class="mq lg iu le b gz mv ms l mt mu">Change detected /Volumes/Extra/nodejs/npm-build-scripts/build-site-3/build/fibocalc.js</span></pre><p id="f4f7" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">首先，<code class="fe lb lc ld le b">onchange</code>检测到JavaScript文件发生了变化，并运行了<code class="fe lb lc ld le b">build:js</code>脚本。第二，<code class="fe lb lc ld le b">live-server</code>检测到<code class="fe lb lc ld le b">site/fibocalc.js</code>改变，导致浏览器重新加载。输入要计算的新数字，消息将变为:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="0433" class="mq lg iu le b gz mr ms l mt mu">Fibonacci CHANGE 55 = 139583862445</span></pre><p id="c790" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">取消更改后，同样自动重建事件会发生，消息也会更改回来。</p><p id="c55d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">例如，编辑<code class="fe lb lc ld le b">labels.en.json</code>,修改如下:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="5029" class="mq lg iu le b gz mr ms l mt mu">"title": "Fibo Calculator - Hi Mom!",</span></pre><p id="02e2" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">检测到更改后，将运行以下程序:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="dc04" class="mq lg iu le b gz mr ms l mt mu">&gt; build-site@1.0.0 build:render /Volumes/Extra/nodejs/npm-build-scripts/build-site-3<br/>&gt; mustache labels.en.json site/index.mustache | html-minifier -o build/index.html</span><span id="8ec5" class="mq lg iu le b gz mv ms l mt mu">Change detected /Volumes/Extra/nodejs/npm-build-scripts/build-site-3/build/index.html</span></pre><p id="72c3" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">然后，就像变魔术一样，浏览器显示了这条消息:<em class="la"> Fibo计算器——嗨，妈妈！</em>再做一次更改，那些命令再次运行，浏览器自动更新匹配。</p><p id="4b25" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们在本节和上一节中演示的是，<code class="fe lb lc ld le b">npm-run-all</code>让我们在<code class="fe lb lc ld le b">package.json</code>文件中构建脚本执行的多维层次结构。好吧，也许称之为<em class="la">多维</em>是愚蠢的，但是我们在二维空间中有很多自由来构建复杂的命令执行层次。这是因为我们可以处理并行和顺序任务执行。</p><h1 id="315c" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">npm配置设置和环境变量</h1><p id="ee17" class="pw-post-body-paragraph kc kd iu ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz in bi translated">npm的另一个特性是配置设置。我不知道我要展示的东西在纱线上是否也一样。我们已经查看了几个配置设置，并看到它用于自定义npm的行为。一个有趣的细节是配置值在<code class="fe lb lc ld le b">package.json</code>脚本中作为环境变量可用。</p><p id="b354" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在开始本节之前，运行以下命令:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="e896" class="mq lg iu le b gz mr ms l mt mu">$ mkdir build-site-4 <br/>$ -r build-site-3/site build-site-3/package.json build-site-3/.gitignore build-site-4 <br/>$ cd build-site-4 <br/>$ npm install</span></pre><p id="ea85" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这给了我们一个干净的工作区域来做下面的实验。</p><p id="55fe" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">当npm执行一个脚本时，它会在其环境中设置许多值。<code class="fe lb lc ld le b">package.json</code>中的每个字段都被设置为以<code class="fe lb lc ld le b">npm_package_</code>开头的环境变量。我们可以通过向<code class="fe lb lc ld le b">scripts</code>部分添加以下内容来探索这一点:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="edca" class="mq lg iu le b gz mr ms l mt mu">"env": "env"</span></pre><p id="e05b" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe lb lc ld le b">env</code>脚本让您看到可用的变量。运行这个命令，您会看到很多都有前缀<code class="fe lb lc ld le b">npm_config_</code></p><p id="8dbb" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">让我们考虑我们的构建脚本中可能想要覆盖的两件事情。第一个是文件<code class="fe lb lc ld le b">labels.en.json</code>，我们认为它是一个简单的国际化实现。为此，我们将并行文件命名为<code class="fe lb lc ld le b">labels.ro.json</code>(罗马尼亚语)或<code class="fe lb lc ld le b">labels.fr.json</code>(法语)。第二个配置值是用于预览服务器的端口号。</p><p id="2622" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">让我们把重点放在后者上。</p><p id="eb0c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在<code class="fe lb lc ld le b">package.json</code>中，我们可以这样输入值:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="9873" class="mq lg iu le b gz mr ms l mt mu">"config" : { <br/>    "port" : "8080" <br/>}</span></pre><p id="0d00" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们可以在环境中看到它:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="f1ae" class="mq lg iu le b gz mr ms l mt mu">$ npm run env | grep port</span><span id="7e41" class="mq lg iu le b gz mv ms l mt mu">...<br/>npm_package_config_port=8080<br/>...</span></pre><p id="272f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这意味着<code class="fe lb lc ld le b">package.json</code>的<code class="fe lb lc ld le b">config</code>部分中的条目显示为带有前缀<code class="fe lb lc ld le b">npm_package_config_</code>的环境变量。</p><p id="c7dd" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">可以通过运行以下命令来覆盖该值:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="8075" class="mq lg iu le b gz mr ms l mt mu">npm config set build-site:port 9090</span></pre><p id="a9a2" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe lb lc ld le b">npm config</code>命令设置配置值，如果需要，我们可以设置自己的值。我们设置的任何值都成为执行脚本中的环境变量。</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="27ca" class="mq lg iu le b gz mr ms l mt mu">$ npm config get build-site:port <br/>9090 <br/>$ npm run env | grep port <br/>... <br/>npm_config_build_site_port=9090 <br/>npm_package_config_port=9090 <br/>...</span></pre><p id="d918" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这实际上设置了两个环境变量，很有意思。但重要的是<code class="fe lb lc ld le b">npm_package_config_port</code>被覆盖了。在<code class="fe lb lc ld le b">package.json</code>内部，值是<code class="fe lb lc ld le b">8080</code>，但是我们现在已经将它设置为<code class="fe lb lc ld le b">9090</code>。</p><p id="3e35" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">前缀<code class="fe lb lc ld le b">build-site:</code>是因为那是<code class="fe lb lc ld le b">package.json</code>中<code class="fe lb lc ld le b">name</code>字段的值。如果我们去掉前缀，换句话说就是run <code class="fe lb lc ld le b">npm config set port 9090</code>，那么就会设置一个不同的环境变量(<code class="fe lb lc ld le b">npm_config_port</code>)。为了覆盖<code class="fe lb lc ld le b">npm_package_config_port</code>，我们必须使用前缀。</p><p id="274a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这意味着我们现在可以在<code class="fe lb lc ld le b">preview</code>脚本中进行这一更改:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="c9bf" class="mq lg iu le b gz mr ms l mt mu">"preview": "cd build &amp;&amp; live-server --port=${npm_package_config_port} "</span></pre><p id="4a64" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们将之前使用的硬编码值改为引用该环境变量的值。然后，我们运行这个命令:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="1f12" class="mq lg iu le b gz mr ms l mt mu">$ npm run preview </span><span id="5289" class="mq lg iu le b gz mv ms l mt mu">&gt; build-site@ 1.0 .0 preview /Volumes/Extra/nodejs/npm-build-scripts/build-site-4 <br/>&gt; cd build &amp;&amp; live-server --port=${npm_package_config_port} </span><span id="da76" class="mq lg iu le b gz mv ms l mt mu">Serving "/Volumes/Extra/nodejs/npm-build-scripts/build-site-4/build" at http:<!-- -->//127.0.0.1:9090<br/>Ready for changes</span></pre><p id="1d54" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">事实上，预览服务器正在监听端口9090。</p><p id="43ad" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如果我们想删除覆盖:</p><pre class="mi mj mk ml gu mm le mn mo aw mp bi"><span id="92f7" class="mq lg iu le b gz mr ms l mt mu">$ npm config delete build-site:port <br/>$ npm config get build-site:port <br/>undefined <br/>$ npm run env | grep port </span><span id="6633" class="mq lg iu le b gz mv ms l mt mu">...<br/>npm_package_config_port=8080</span></pre><p id="a338" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">一旦我们删除了配置值，环境变量就恢复到在<code class="fe lb lc ld le b">package.json</code>文件的<code class="fe lb lc ld le b">config</code>标签中设置的值。再次运行<code class="fe lb lc ld le b">npm run preview</code>，预览服务器在端口<code class="fe lb lc ld le b">8080</code>打开。</p><h1 id="b2c6" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">用于<code class="fe lb lc ld le b">package.json</code>脚本的附加工具</h1><p id="e7b1" class="pw-post-body-paragraph kc kd iu ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz in bi translated">有大量工具可用于<code class="fe lb lc ld le b">package.json</code>文件中的脚本。到目前为止，我们已经看到这是非常强大的，这些其他工具甚至增加了更多的功能。</p><p id="4e0e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><strong class="ke iv">跨平台脚本</strong>:在上一节中，我们为其中一个脚本添加了一个环境变量引用。虽然这很好也很简单，但它在Windows上不起作用，因为cmd.exe对变量引用有不同的语法。有两个包涵盖了消除跨平台差异的不同方面。</p><ul class=""><li id="efc4" class="mx my iu ke b kf kg kj kk kn mz kr na kv nb kz nc nd ne nf bi translated"><em class="la"> cross-env </em>在命令行中轻松设置环境变量。参见文件:<a class="ae mw" href="https://www.npmjs.com/package/cross-env" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/cross-env</a></li><li id="7c20" class="mx my iu ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated"><em class="la"> cross-var </em>在命令行上处理环境变量引用。参见文件:<a class="ae mw" href="https://www.npmjs.com/package/cross-var" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/cross-var</a></li></ul><p id="bb8a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><strong class="ke iv">Unix命令的跨平台等价物</strong>:对于您的<code class="fe lb lc ld le b">package.json</code>脚本来说，支持在Windows以及类似Unix的系统上执行是一个最佳实践。有时候你想在脚本中运行普通的命令，比如<code class="fe lb lc ld le b">rm -rf build</code>，但是当然Windows没有这个命令。</p><ul class=""><li id="429b" class="mx my iu ke b kf kg kj kk kn mz kr na kv nb kz nc nd ne nf bi translated"><em class="la"> rimraf </em>相当于<code class="fe lb lc ld le b">rm -rf</code>。参见文档:<a class="ae mw" href="https://www.npmjs.com/package/rimraf" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/rimraf</a></li><li id="bc6f" class="mx my iu ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated"><em class="la"> mkdirp </em>相当于<code class="fe lb lc ld le b">mkdir -p</code>用于创建目录层次。参见文档:<a class="ae mw" href="https://www.npmjs.com/package/mkdirp" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/mkdirp</a></li><li id="aa2e" class="mx my iu ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated"><em class="la"> open-cli </em>相当于macOS命令<code class="fe lb lc ld le b">open</code>，Windows命令<code class="fe lb lc ld le b">start</code>，Linux命令<code class="fe lb lc ld le b">xdg-open</code>。这些命令使用正确的应用程序“打开”文件。这个CLI工具可以根据平台选择正确的命令，从而实现移植。参见文档:<a class="ae mw" href="https://www.npmjs.com/package/open-cli" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/open-cli</a></li><li id="8c13" class="mx my iu ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated"><em class="la"> shx </em>在可移植的Node.js代码中实现了大量类似Unix的命令。参见文件:<a class="ae mw" href="https://www.npmjs.com/package/shx" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/shx</a></li><li id="3503" class="mx my iu ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated"><em class="la"> shelljs </em>是用于实现<em class="la"> shx </em>的API，它让你编写一个Node.js脚本，使用类似Unix的命令。参见文件:<a class="ae mw" href="https://www.npmjs.com/package/shelljs" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/shelljs</a></li></ul><p id="420c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><strong class="ke iv">使用Husky </strong>与Git挂钩集成:Husky包允许您向<code class="fe lb lc ld le b">package.json</code>添加一个部分，指定将为某些Git生命周期挂钩执行的命令。Git hook是一个shell脚本，通常存储在<code class="fe lb lc ld le b">.git/hooks</code>中，对应于Git存储库生命周期中的不同时间点。例如，您可以使用一个<code class="fe lb lc ld le b">pre-commit</code>钩子来运行一些测试，以防止提交错误的代码。</p><ul class=""><li id="24a0" class="mx my iu ke b kf kg kj kk kn mz kr na kv nb kz nc nd ne nf bi translated">参见文档:<a class="ae mw" href="https://www.npmjs.com/package/husky" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/husky</a></li></ul><p id="2f1d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><strong class="ke iv">代码开发工具</strong>:node . js平台上有一长串可用的软件开发工具。我们提到了几个，比如Less编译器，但这里还有几个。</p><ul class=""><li id="3839" class="mx my iu ke b kf kg kj kk kn mz kr na kv nb kz nc nd ne nf bi translated">postcss是一个强大的css处理和林挺工具家族。参见文档:<a class="ae mw" href="https://www.npmjs.com/package/postcss" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/postcss</a></li><li id="4c3d" class="mx my iu ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated"><em class="la"> node-sass </em>处理处理SASS/SCSS文件，是绑定到LibSass的Node.js。见文档:【https://www.npmjs.com/package/node-sass T4】</li><li id="3994" class="mx my iu ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated">@babel/core 是一个用于处理和传输JavaScript文件的大型工具集的核心。例如，通过正确的配置，您可以编写ES2019语法JavaScript，将其编译成ES5 JavaScript，以便在旧浏览器上执行。参见文档:<a class="ae mw" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank">https://babeljs.io/</a></li><li id="5d87" class="mx my iu ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated"><em class="la"> eslint </em>是一个检查JavaScript代码正确性的流行工具。参见文档:<a class="ae mw" href="https://www.npmjs.com/package/eslint" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/eslint</a></li><li id="2e46" class="mx my iu ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated"><em class="la"> stylelint </em>是一个检查CSS代码正确性的工具。参见文档:<a class="ae mw" href="https://www.npmjs.com/package/stylelint" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/stylelint</a></li></ul><h1 id="924f" class="lf lg iu bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">摘要</h1><p id="7767" class="pw-post-body-paragraph kc kd iu ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz in bi translated">在本文中，我们已经看到了<code class="fe lb lc ld le b">package.json</code>有一个隐藏的超能力，可以用于任何数据处理任务。</p><p id="ab9a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">有接近无数不同的可能项目涉及输入数据，无论是源代码、HTML/CSS文件、数据文件、机器学习项目的数据集、天气报告数据，还是其他任何东西。输入数据将使用项目所需的工具进行处理，产生输出，输出可以是网站、软件包、机器学习模型或任何其他东西。</p><p id="5b24" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">虽然我们可以使用许多种类的构建工具来自动化这样的项目，但是<code class="fe lb lc ld le b">package.json</code>文件可能已经安装在您的计算机上，并且可以胜任这项任务。</p></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><p id="c45c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><em class="la">原载于https://techsparx.com</em><a class="ae mw" href="https://techsparx.com/nodejs/tools/npm-build-scripts.html" rel="noopener ugc nofollow" target="_blank"><em class="la"/></a><em class="la">。</em></p></div></div>    
</body>
</html>