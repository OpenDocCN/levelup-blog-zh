<html>
<head>
<title>React Universal Routing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应通用路由</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-universal-routing-94215253d9?source=collection_archive---------0-----------------------#2019-04-07">https://levelup.gitconnected.com/react-universal-routing-94215253d9?source=collection_archive---------0-----------------------#2019-04-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0c02" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何为服务器和客户端设计应用程序路由</h2></div><h2 id="ed5d" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">渲染或不渲染(服务器端)</h2><p id="306c" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">近年来，JavaScript世界经历了一场巨大的革命，从在静态站点中实现简单的动态元素，到创建可以在我们的浏览器中运行的大型、引人入胜的应用程序。这一重大变化之所以成为可能，要归功于这些库，它们使得单页面应用程序(SPA)开发在比以前大得多的规模上成为可能。其中一个顶级库是React，它附带了许多辅助库和实用程序，使SPA开发变得轻而易举。</p><p id="60f5" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">当然，对于用户和开发人员来说，SPAs比传统的静态方法有很多优势。然而，我们不得不提到一些整个社区都在努力解决的大缺点。容易察觉的两个主要问题是潜在的搜索引擎优化(SEO)劣势和首次在用户浏览器中绘图的时间。这两者结合在一起是因为经典的SPA概念假设在获取JS文件后，初始HTML为空，内容动态初始化。这种最初的内容缺乏让一些机器人(和用户)感到愤怒，并影响我们网站的可见性和最终的满意度。</p><p id="56d4" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">总而言之，我们同意SPA为前端设计和用户体验带来了新的质量，但为了解决缺点并更进一步，我们引入了一个升级的想法— <strong class="ld ir">服务器端呈现(SSR)单页应用程序，它将经典的服务器准备内容与更好的SPA用户体验相结合。</strong>SSR为什么这么重要？让我们说，它给了我们最快的应用程序的第一次打印，然后可以通过获取的JS文件一步一步或一次投入使用。它还为SEO繁重的项目提供了更可靠的可见性，因为甚至一些搜索供应商可能会正确地索引经典SPA，但与服务器端呈现的内容相比，它总是有一个缺点，因为它是同步的、无状态的，并且位于HTTP的根上。</p><h2 id="20b6" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">如何构建SSR/SPA路线—我们的目标</h2><p id="fe0b" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">现在我们知道SPA很好，SSR使它更好，但即使整个想法很简单，我们有正确的工具，也有许多不同的方法来应对一些挑战。<strong class="ld ir">SPA的关键组件之一是路由，它应该指定我们获取什么数据以及如何呈现它们。</strong>路由的这两个方面对每个前端应用都至关重要。</p><p id="ec73" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">首先，我们的代码应该是高效的，这样当应用程序增长时，客户机和服务器的实现都不会给我们带来麻烦。我们的实现应该将逻辑放入适当的顺序，并且不参与任何不必要的计算。此外，我们应该尝试创建一个在两种环境下都能很好工作的通用代码。这种解决方案为我们带来了许多优势，包括应用程序逻辑的复杂性更低、一致性更好。</p><p id="892b" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">这些都是具体的目标，使得创建新元素和将它们合并到我们的应用程序中变得非常容易和简单。因此，今天的问题是这样的:"<strong class="ld ir">我们应该如何设计应用程序路由，使它对服务器端和客户端都简单明了？</strong>”。</p><h2 id="0cd8" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">经典SPA —获取数据客户端</h2><p id="2414" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">首先，让我们回顾一下为组件提供数据的最自然的方式。假设我们有一些REST API——提供数据的端点。我们可以呈现组件，在它的生命周期方法中(通常在挂载之后)，我们可以调用获取数据的动作，并将其保存在全局存储或组件的状态中，无论我们喜欢什么。</p><p id="7a9b" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">对于我们是应该在每个需要数据的组件中检索数据，还是在某个视图组件中获取数据，以获得其子组件所需的一切，有不同的看法。无论我们选择什么，<strong class="ld ir">在组件中获取数据是一种自然而直接的方式，尤其是对于较小的项目，这种方式非常有效。</strong></p><p id="ae52" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">当我们决定在组件中获取数据时，剩下的唯一事情就是使用表示路由，这是一种将请求的路径名转换成我们应该显示的视图(组件)的映射。这可以使用ReactRouter或任何其他允许我们基于组件结构创建路由的实现来轻松实现。然后，每个组件可以为自己或其子组件获取所需的数据，这正是许多经典SPA项目的操作方式。</p><h2 id="a463" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">SSR应用程序—获取服务器端数据</h2><p id="eb90" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">有可能使用基于组件的抓取来获取服务器端的数据吗？事情是这样的，获得这一切需要等待异步操作，然后以最终状态呈现组件。当我们想象组件树中的每个组件都可以在任何时间点获取某些东西时，我们看到不可能找到一个等待的事件，在此之后我们可以开始最终的渲染。我们可以尝试不同的方法来限制我们的组件的行为，例如，只在安装或准备特定的动作后获取，静态方法或其他函数只适合获取数据。尽管这可能行得通，但它极大地降低了我们从组件内部获取数据的自由度。</p><p id="56e9" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">关于效率的另一件事是，我们应该只渲染组件树一次，以确保我们花时间明智地准备响应，而不是浪费时间试图模拟浏览器环境。结论很简单— <strong class="ld ir">我们的数据应该在接触组件树之前就准备好了。</strong></p><p id="cd08" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">试图在服务器环境中以客户端方式获取数据是一条死路，所以让我们回到服务器端渲染的基础上来。我们有许多例子，从简单的库开始，到为HTTP响应提供完全呈现的页面的整体框架结束。这些解决方案遍布编程世界，有许多不同的语言版本。这些解决方案的共同点是处理路由、获取数据和将整个页面发送回浏览器的顺序。该序列是等待异步位的同步逻辑。它从分析路由开始—映射路径名。然后，它负责准备所有需要的数据，一些是从数据库请求的，另一些是计算的。然后，将准备好的数据提供给响应模板，该模板用提供的数据填充每个变量和每个缺口。最后，浏览器接收HTML作为这个过程的结果。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/07c8a573c7412245445b7d7e6917a24c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cKz2lTlHkj-o4Z4aWoVgRw.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">应用流程(黑色箭头)和实施(绿色箭头)</figcaption></figure><h2 id="15ea" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">双路由的服务器实现</h2><p id="33d7" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">服务器方法非常简单，许多程序员都熟悉它，所以让我们试着在等式中加入一些反应，看看我们最终会得到什么。我们使用ReactRouter和Redux库来帮助我们实现。这个想法很简单。首先，我们应用定义请求路径的路由(视图)。然后根据这个路径，我们应该触发动作并获取视图需要的所有东西。最后，我们收集数据并把它们提供给我们的组件树，渲染成字符串并准备最终的响应。</p><p id="4f25" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">为了实现这一点并保持灵活性，我们需要两个路由，所以下面是一个服务器实现的例子。<strong class="ld ir">请注意这里有两个基于路径的动作:第一个是数据获取，第二个是组件渲染。</strong>我们的逻辑表现出每个高效服务器应有的行为。</p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="803c" class="kf kg iq mq b gy mu mv l mw mx"><strong class="mq ir">import </strong>* <strong class="mq ir">as </strong>express <strong class="mq ir">from </strong>"express";<br/><strong class="mq ir">import </strong>* <strong class="mq ir">as </strong>React <strong class="mq ir">from </strong>"react";<br/><strong class="mq ir">import </strong>* <strong class="mq ir">as </strong>ReactDOM <strong class="mq ir">from </strong>"react-dom/server";<br/><strong class="mq ir">import </strong>{createStore, applyMiddleware} <strong class="mq ir">from </strong>"redux";<br/><strong class="mq ir">import </strong>{Provider} <strong class="mq ir">from </strong>"react-redux";<br/><strong class="mq ir">import </strong>thunk <strong class="mq ir">from </strong>"redux-thunk";<br/><strong class="mq ir">import </strong>{StaticRouter} <strong class="mq ir">from </strong>"react-router";</span><span id="bf2a" class="kf kg iq mq b gy my mv l mw mx"><strong class="mq ir">import </strong>reducer <strong class="mq ir">from </strong>"./reducer";<br/><strong class="mq ir">import </strong>appPathDataFetcher <strong class="mq ir">from </strong>"./data-fetcher";<br/><strong class="mq ir">import </strong>AppLayout <strong class="mq ir">from </strong>"./components/AppLayout";<br/><strong class="mq ir">import </strong>renderFullHtml <strong class="mq ir">from </strong>"./utils/render-full-html";</span><span id="5bdb" class="kf kg iq mq b gy my mv l mw mx"><strong class="mq ir">const </strong>app = express();<br/>app.use(routeServerApp);<br/>app.listen(3000);</span><span id="1b89" class="kf kg iq mq b gy my mv l mw mx"><strong class="mq ir">async function </strong>routeServerApp(req, res) {<br/>    <br/>    // prepare store before fetching data<br/>    <strong class="mq ir">const </strong>store = createStore(reducer, applyMiddleware(thunk));<br/>    <br/>    // fetch data logic - first routing<br/>    <strong class="mq ir">const </strong>currentRoute = {pathname: req.path, query: req.query};<br/>    <strong class="mq ir">await </strong>appPathDataFetcher(store.dispatch, currentRoute, <strong class="mq ir">null</strong>);<br/>    <br/>    // render components with provided data - second routing<br/>    <strong class="mq ir">const </strong>componentHtml = ReactDOM.renderToString(<br/>        &lt;Provider store={store}&gt;<br/>            &lt;StaticRouter location={req.url}&gt;<br/>                &lt;AppLayout/&gt;<br/>            &lt;/StaticRouter&gt;<br/>        &lt;/Provider&gt;<br/>    );</span><span id="5662" class="kf kg iq mq b gy my mv l mw mx">    // prepare and send HTTP response with HTML text<br/>    <strong class="mq ir">const </strong>initialState = store.getState();<br/>    <strong class="mq ir">const </strong>html = renderFullHtml(componentHtml, initialState);<br/>    res.setHeader("Content-Type", "text/html");<br/>    res.status(200).send(html);<br/>}</span></pre><p id="7d97" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">在这段代码中，有两个导入需要特别解释，都是关于我们的双路由方法。第一个实现是<code class="fe mz na nb mq b">appPathDataFetcher</code>，它是一个异步动作，为特定的路由(路径)获取数据。第二部分在<code class="fe mz na nb mq b">AppLayout</code>中，包含表示路由。我们将在后面看到这两种方法的实现。现在，理解它们是通用的是至关重要的，因此我们可以在这里和下面的客户端示例中使用它们。</p><h2 id="c0e8" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">双向路由的客户端实现</h2><p id="f0c7" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">我们知道在组件中获取数据在服务器上是行不通的，此外，让我们想一想为什么我们还要费心将组件呈现与获取数据绑定在一起。这种方法可能会带来一些问题，特别是当我们考虑一个大型应用程序，其中不同的组件获取和使用相同的数据。在本文的开始，我们说明了基于组件的获取是一种简单明了的方法，但是<strong class="ld ir">当我们的目标是通用代码时，我们应该考虑将数据获取从组件中分离出来，就像服务器所做的那样，并提供两个独立的路由，而不是耦合在一起，可能会相互补充。</strong>也许基于服务器的解决方案可以在客户端上很好地工作，并且不会对我们造成不良影响。</p><p id="6c75" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">目标是使用预先准备好的路由逻辑:首先获取某个视图所需的所有数据，其次使用提供的数据呈现视图。这样，我们将数据逻辑与表示逻辑分离开来，这对我们的解决方案至关重要。让我们从表示逻辑的客户端实现开始。</p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="634b" class="kf kg iq mq b gy mu mv l mw mx"><strong class="mq ir">import </strong>* <strong class="mq ir">as </strong>React <strong class="mq ir">from </strong>"react";<br/><strong class="mq ir">import </strong>* <strong class="mq ir">as </strong>ReactDOM <strong class="mq ir">from </strong>"react-dom";<br/><strong class="mq ir">import </strong>{createStore, applyMiddleware} <strong class="mq ir">from </strong>"redux";<br/><strong class="mq ir">import </strong>{Provider} <strong class="mq ir">from </strong>"react-redux";<br/><strong class="mq ir">import </strong>thunk <strong class="mq ir">from </strong>"redux-thunk";<br/><strong class="mq ir">import </strong>{BrowserRouter} <strong class="mq ir">from </strong>"react-router-dom";</span><span id="46a8" class="kf kg iq mq b gy my mv l mw mx"><strong class="mq ir">import </strong>reducer <strong class="mq ir">from </strong>"./reducer";<br/><strong class="mq ir">import </strong>AppLayout <strong class="mq ir">from </strong>"./components/AppLayout";</span><span id="470a" class="kf kg iq mq b gy my mv l mw mx"><strong class="mq ir">const </strong>store = createStore(reducer, applyMiddleware(thunk));</span><span id="4921" class="kf kg iq mq b gy my mv l mw mx">// we hydrate already rendered server-side content<br/>ReactDOM.hydrate(<br/>    &lt;Provider store={store}&gt;<br/>        &lt;BrowserRouter&gt;<br/>            &lt;AppLayout/&gt;<br/>        &lt;/BrowserRouter&gt;<br/>    &lt;/Provider&gt;,<br/>    document.getElementById("root")<br/>);</span></pre><p id="3a23" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">包含表示路由的组件与我们在服务器实现中使用的组件相同。这很好，因为每当我们需要对主要的表示逻辑进行更改时，我们只需要在一个地方进行。请注意，我们在这里使用ReactRouter，并将<code class="fe mz na nb mq b">AppLayout</code>包装在<code class="fe mz na nb mq b">BrowserRouter</code>中，因为这是客户端实现，所以我们相应地在服务器实现中使用了<code class="fe mz na nb mq b">StaticRouter</code>。</p><p id="162c" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">现在是时候在客户机环境中使用我们的数据获取逻辑了。</p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="dbcc" class="kf kg iq mq b gy mu mv l mw mx"><strong class="mq ir">import </strong>* <strong class="mq ir">as </strong>React <strong class="mq ir">from </strong>"react";<br/><strong class="mq ir">import </strong>{connect} <strong class="mq ir">from </strong>"react-redux";<br/><strong class="mq ir">import </strong>{withRouter} <strong class="mq ir">from </strong>"react-router";<br/><strong class="mq ir">import </strong>* <strong class="mq ir">as </strong>qs <strong class="mq ir">from </strong>"query-string";<br/><strong class="mq ir">import </strong>* <strong class="mq ir">as </strong><em class="nc">hoistStatics </em><strong class="mq ir">from </strong>"hoist-non-react-statics";</span><span id="c8dd" class="kf kg iq mq b gy my mv l mw mx"><strong class="mq ir">import </strong>appPathDataFetcher <strong class="mq ir">from </strong>"./data-fetcher";</span><span id="c5d7" class="kf kg iq mq b gy my mv l mw mx"><strong class="mq ir">export const </strong>routeHandler = InnerComponent =&gt; {</span><span id="8ae5" class="kf kg iq mq b gy my mv l mw mx">    <strong class="mq ir">class </strong>RouteHandlerC <strong class="mq ir">extends </strong>React.Component {</span><span id="bd38" class="kf kg iq mq b gy my mv l mw mx">        <strong class="mq ir">async </strong>componentDidUpdate(prevProps) {<br/>            const {location, dispatch} = this.props;<br/>            <strong class="mq ir">if </strong>(prevProps.location.key !== location.key) {<br/>                <strong class="mq ir">const </strong>currentRoute = {<br/>                    pathname: location.pathname,<br/>                    query: qs.parse(location.search)<br/>                };<br/>                <strong class="mq ir">const </strong>prevRoute = {<br/>                    pathname: prevProps.location.pathname,<br/>                    query: qs.parse(prevProps.location.search)<br/>                };<br/>                <strong class="mq ir">await </strong>appPathDataFetcher(<br/>                    dispatch,<br/>                    currentRoute,<br/>                    prevRoute<br/>                );<br/>            }<br/>        }</span><span id="6bac" class="kf kg iq mq b gy my mv l mw mx">        render() {<br/>            <strong class="mq ir">return </strong>&lt;InnerComponent {...<strong class="mq ir">this</strong>.props} /&gt;;<br/>        }<br/>    }</span><span id="389e" class="kf kg iq mq b gy my mv l mw mx">    const RouteHandler = withRouter(connect()(RouteHandlerC));</span><span id="191b" class="kf kg iq mq b gy my mv l mw mx">    // opinionated HOC return - copy all non-React static methods<br/>    <strong class="mq ir">return </strong><em class="nc">hoistStatics</em>(RouteHandler, InnerComponent);<br/>};</span></pre><p id="30d4" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><strong class="ld ir">装饰器功能</strong> <code class="fe mz na nb mq b"><strong class="ld ir">routeHandler</strong></code> <strong class="ld ir">监视路由中的每一个变化，并相应地使用</strong> <code class="fe mz na nb mq b"><strong class="ld ir">appPathDataFetcher</strong></code> <strong class="ld ir">(与服务器相同)获取数据。</strong>传递当前和以前的路线有助于为操作提供上下文。装饰器应该包装主要的应用程序组件，所以在我们的例子中，我们按照<code class="fe mz na nb mq b">AppLayout</code>的定义使用它。</p><p id="01fe" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">现在是时候展示我们的两个元素的实现了，它们非常适合客户机和服务器。</p><h2 id="533a" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">通用表示逻辑</h2><p id="96b3" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">基于组件的路由根据当前路径名呈现正确的视图。<strong class="ld ir">我们只关心应该显示的组件，因为数据获取是一个独立的逻辑。</strong>这种方法使我们能够灵活地为相同的数据定义不同的表示，或者为不同的数据路径使用一种通用的表示。</p><p id="300b" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">服务器端是静态的，对于每个请求都是一样的，所以它总是获取一次数据，呈现一次。相反，客户端必须准备好改变路由，多次获取数据并相应地呈现它们。因此，我们需要<code class="fe mz na nb mq b">routeHandler</code> decorator来包装我们的最高应用程序组件，并在每次路由更改时获取数据。这个逻辑对服务器没有任何影响(所以你可以跳过它)，但是对客户机来说是必须的。</p><p id="73ef" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">这是简化的路由，呈现不同的视图。</p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="9027" class="kf kg iq mq b gy mu mv l mw mx"><strong class="mq ir">import </strong>* <strong class="mq ir">as </strong>React <strong class="mq ir">from </strong>"react";<br/><strong class="mq ir">import </strong>{Route, Switch} <strong class="mq ir">from </strong>"react-router";</span><span id="44dd" class="kf kg iq mq b gy my mv l mw mx"><strong class="mq ir">import </strong>{routeHandler} <strong class="mq ir">from </strong>"./route-handler";<br/><strong class="mq ir">import </strong>{Homepage, ArticleList, ArticleDetail} <strong class="mq ir">from </strong>"./components";</span><span id="034d" class="kf kg iq mq b gy my mv l mw mx">const componentRoutes = [<br/>    {path: "/", component: Homepage},<br/>    {path: "/articles/, component: ArticleList},<br/>    {path: "/articles/:articleId(\\d+)/", component: ArticleDetail}<br/>];</span><span id="58a6" class="kf kg iq mq b gy my mv l mw mx">// we decorate main component with independent data-fetching logic<br/>// routeHandler is crucial for client and has no effect for server</span><span id="2938" class="kf kg iq mq b gy my mv l mw mx"><strong class="mq ir">export const </strong>AppLayout = routeHandler(() =&gt; {<br/>    <strong class="mq ir">return </strong>(<br/>        &lt;Switch&gt;<br/>            {componentRoutes.map(route =&gt; &lt;Route<br/>                key={route.path}<br/>                path={route.path}<br/>                component={route.component}<br/>                exact={route.exact !== <strong class="mq ir">false</strong>}<br/>                strict<br/>            /&gt;)}<br/>        &lt;/Switch&gt;<br/>    );<br/>});</span></pre><h2 id="db68" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">通用数据逻辑</h2><p id="5ef5" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">让我们回到为我们的应用程序检索数据时的核心<code class="fe mz na nb mq b">appPathDataFetcher</code>。<strong class="ld ir">数据提取器最重要的是</strong> <code class="fe mz na nb mq b"><strong class="ld ir">fetchRoutes</strong></code> <strong class="ld ir"> —定义地图，定义根据给定的路线触发哪些动作。</strong>该图与我们在表示路由中的图非常相似，不同之处在于，我们在这里寻找要调用的动作，而不是要呈现的组件。</p><p id="d7f4" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">另一个关键区别是，基于组件的路由在单个组件渲染中是平面的，但是我们可以在树的深处组件中嵌入其他路由。因此，我们最终可能会有许多独立的路由，这对表示逻辑来说是一件好事。另一方面，获取逻辑应该只有一个真实的来源，这就是为什么我们的结构应该是嵌套的，这样我们就可以轻松地获取全局应用程序数据以及特定视图的本地数据。</p><p id="5d3a" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">这就是我们的例子<code class="fe mz na nb mq b">fetchRoutes</code>可能的样子。</p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="9a3f" class="kf kg iq mq b gy mu mv l mw mx">import {fetchGlobalAppData} from "./app-actions";<br/>import {fetchHomepageData} from "./homepage-actions";<br/>import {fetchArticleList, fetchArticleDetail} from "./article-actions";<br/>import {mapActions} from "./util-actions"</span><span id="afdd" class="kf kg iq mq b gy my mv l mw mx"><strong class="mq ir">export const </strong>fetchRoutes = [<br/>    {<br/>        path: "/", exact: <strong class="mq ir">false</strong>,<br/>        fetch: fetchGlobalAppData,<br/>        routes: [<br/>            {<br/>                path: "/",<br/>                fetch: fetchHomepageData<br/>            },<br/>            {<br/>                path: "/articles/",<br/>                fetch: fetchArticleList<br/>            },<br/>            {<br/>                path: "/articles/:articleId(\\d+)/",<br/>                fetch: fetchArticleDetail<br/>            }<br/>        ]<br/>    }<br/>];</span></pre><p id="39e0" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><code class="fe mz na nb mq b">appPathDataFetcher</code>是一种通用的异步逻辑，它将路由路径映射成我们需要调用的动作。具体的实现对于我们的情况并不重要，因为您可以自己实现它，甚至可以根据需要更改路由映射定义。然而，为了示例的完整性，我们在下面给出了建议的实现。</p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="e8f6" class="kf kg iq mq b gy mu mv l mw mx"><strong class="mq ir">import </strong>{matchPath} <strong class="mq ir">from </strong>"react-router";<br/>import {fetchRoutes} from "./fetch-routes";</span><span id="15f9" class="kf kg iq mq b gy my mv l mw mx">// main data-fetcher logic based on `fetchRoutes`<br/><strong class="mq ir">export async function </strong>appPathDataFetcher(<br/>    dispatch, currentRoute, prevRoute<strong class="mq ir"><br/></strong>) {<br/>    <strong class="mq ir">const </strong>matches = matchFetches(fetchRoutes, current.pathname);<br/>    <strong class="mq ir">let </strong>idx = 0;<br/>    <strong class="mq ir">let </strong>result = <strong class="mq ir">true</strong>;<br/>    <strong class="mq ir">while </strong>(result &amp;&amp; idx &lt; matches.length) {<br/>        <strong class="mq ir">const </strong>match = matches[idx++];<br/>        <strong class="mq ir">const </strong>matchRoute = {...current, params: match.params};<br/>        <br/>        // each action has to be dispatched<br/>        result = <strong class="mq ir">await </strong>dispatch(match.fetch(<br/>            matchRoute, prevRoute, result<br/>        ));<br/>    }<br/>}</span><span id="d5b3" class="kf kg iq mq b gy my mv l mw mx">// finds array of matches, searching deep into routing tree<br/>function matchFetches = (routes, pathname) {<br/>    <strong class="mq ir">let </strong>matches = [];<br/>    <strong class="mq ir">for </strong>(<strong class="mq ir">const </strong>route <strong class="mq ir">of </strong>routes) {<br/>        <strong class="mq ir">const </strong>match = matchPath(pathname, {<br/>            exact: route.exact !== <strong class="mq ir">false</strong>,<br/>            strict: <strong class="mq ir">true</strong>,<br/>            path: route.path<br/>        });<br/>        <strong class="mq ir">if </strong>(match == <strong class="mq ir">null</strong>) { // path does not match<br/>            <strong class="mq ir">continue</strong>;<br/>        }<br/>        // update matches with matched params and actions<br/>        const current = {params: match.params, fetch: route.fetch};<br/>        const deeper = route.routes ?<br/>            matchFetches(route.routes, pathname) : [];<br/>        matches = [current, ...deeper];<br/>        <strong class="mq ir">break</strong>;<br/>    }<br/>    <strong class="mq ir">return </strong>matches;<br/>}</span></pre><h2 id="e460" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h2><p id="47d1" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">当我们思考这个问题时，获取数据和呈现视图没有任何共同之处，除了协调它们的行为的更高层次的控制器逻辑。正因为如此，<strong class="ld ir">双路由和分离关注点的想法可能是非常有益的。提供只做一件事却做得很好的逻辑肯定会提高可读性，并且有助于团队中不同成员的合作。当我们和我们的团队一起在更大的项目中工作时，重要的因素是容易推理应用程序逻辑。</strong></p><p id="abdf" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">如何构建应用程序路由？这个问题总是有许多不同的和非常合适的答案，但是当我们创建越来越多的前端应用程序，并将它们迁移到服务器环境中时，我们通常需要三思而行，考虑我们面前出现的新需求。最后，当前状态下的frontend非常年轻，标准解决方案并不总是设计良好。我们应该明智地选择，评估来自不同语言的固执己见的建议，并在我们的代码中采纳它们。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><div class="ma mb mc md gt nk"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">排名前49的React教程-免费学习React。课程由开发人员提交并投票，使您能够…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">gitconnected.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny mj nk"/></div></div></a></div></div></div>    
</body>
</html>