<html>
<head>
<title>Generics in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的泛型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-generics-with-a-witcher-6f449f253e13?source=collection_archive---------9-----------------------#2021-01-11">https://levelup.gitconnected.com/typescript-generics-with-a-witcher-6f449f253e13?source=collection_archive---------9-----------------------#2021-01-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cb11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于不习惯泛型的人来说，泛型看起来绝对令人生畏。在这篇博文中，我将试图让它们不那么神秘，并通过使用更多的实践方法来展示它们是如何有用的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/41a0f2ef7797c7e37c98986e17467eb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*78sJBlS6mf8UHNGFhKZNfw.png"/></div></figure><p id="f344" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如果没有设置任何本地环境，可以跟随在</strong> <a class="ae kt" href="https://www.typescriptlang.org/play" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">打字游戏场</strong> </a> <strong class="jp ir">过来。</strong>我建议在单独的选项卡中键入示例。</p></div><div class="ab cl ku kv hu kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ij ik il im in"><h2 id="a132" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">第一眼</h2><p id="9526" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">顾名思义，泛型帮助我们创建更多可重用的代码块。</p><p id="ab2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">简而言之:</strong> <br/>它们可以帮助我们创建定义良好的类、接口和函数，同时仍然给我们保持它们“通用”的灵活性——通过让它们根据程序员传递的类型(或多个类型)工作。</p><p id="e6e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看我们的第一个例子，你可以在<a class="ae kt" href="https://www.typescriptlang.org/play" rel="noopener ugc nofollow" target="_blank"> Typescript Playground </a>中输入:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="7ee6" class="lb lc iq ma b gy me mf l mg mh">function iTakeAnyArrays(arr: any[]): any[] {<br/>    return arr;<br/>}</span><span id="a018" class="lb lc iq ma b gy mi mf l mg mh">iTakeAnyArrays(1); //error </span><span id="cd25" class="lb lc iq ma b gy mi mf l mg mh">function iTakeGenericArrays<strong class="ma ir">&lt;T&gt;</strong>(arr:<strong class="ma ir">T[]</strong>): <strong class="ma ir">T[]</strong> {<br/>    return arr;<br/>}</span><span id="c0b1" class="lb lc iq ma b gy mi mf l mg mh">iTakeGenericArrays(1); //error </span><span id="2351" class="lb lc iq ma b gy mi mf l mg mh"><br/>For now think of the &lt;<strong class="ma ir">T</strong>&gt; here as a kind of paceholder which will be replaced by a type passed in by the user (or a type that can be inferred from the arguments). As we proceed this will become clearer.</span></pre><p id="1162" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，我们故意给函数传递了一个错误的参数，这个参数当然应该是一个数组。这是为了看看幕后可能发生的事情。</p><p id="c240" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您将鼠标悬停在编辑器(或<a class="ae kt" href="https://www.typescriptlang.org/play" rel="noopener ugc nofollow" target="_blank">在线游乐场</a>)上的错误上:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="03a1" class="lb lc iq ma b gy me mf l mg mh">iTakeAnyArrays(1):<br/>Argument of type 'number' is not assignable to parameter of type '<strong class="ma ir">any[]</strong>'</span><span id="060f" class="lb lc iq ma b gy mi mf l mg mh">iTakeGenericArrays(1):<br/>Argument of type 'number' is not assignable to parameter of type '<strong class="ma ir">unknown[]</strong>'</span></pre><p id="cf1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不知道<strong class="jp ir"> any </strong>和<strong class="jp ir"> unknown </strong>的区别，只知道<strong class="jp ir"> unknown </strong>会缩小到一个可以从代码中推断出来的推断类型，然后坚持那个类型。</p><p id="e97e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kt" href="https://stackoverflow.com/questions/51439843/unknown-vs-any" rel="noopener ugc nofollow" target="_blank">这里的</a>更多的是关于这个的。</p><p id="7fa9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而“<strong class="jp ir">任何”</strong>永远不会缩小到一个类型，而永远是任意的。</p><p id="86fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是为什么“<strong class="jp ir">any”</strong>有时可能不适合概括代码片段，因为您会丢失一些(或很多)类型定义。</p><p id="0ba4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们现在尝试传递正确类型的参数:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="59cc" class="lb lc iq ma b gy me mf l mg mh">function iTakeAnyArrays(arr: any[]): any[] {<br/>    return arr;<br/>}</span><span id="44fa" class="lb lc iq ma b gy mi mf l mg mh">iTakeAnyArrays([1]);</span><span id="6811" class="lb lc iq ma b gy mi mf l mg mh">function iTakeGenericArrays&lt;T&gt;(arr:T[]): T[] {<br/>    return arr;<br/>}</span><span id="5087" class="lb lc iq ma b gy mi mf l mg mh">iTakeGenericArrays([1]);</span></pre><p id="963c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">错误当然消失了，更有趣的是，当您将鼠标悬停在以下内容上时(我已经注释了您将在IDE中看到的悬停内容):</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="ee5e" class="lb lc iq ma b gy me mf l mg mh">iTakeAnyArrays([1]);<br/>// function iTakeAnyArrays(arr: any[]): any[]</span><span id="6bad" class="lb lc iq ma b gy mi mf l mg mh">iTakeGenericArrays([1]);<br/>// function iTakeGenericArrays&lt;number&gt;(arr: number[]): number[]</span></pre><p id="2942" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们进一步修改代码，采用不同类型的数组，并将鼠标悬停在函数调用上:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="c7b4" class="lb lc iq ma b gy me mf l mg mh">function <strong class="ma ir">iTakeAnyArrays(arr: any[]): any[]</strong> {<br/>    return arr;<br/>}</span><span id="d32d" class="lb lc iq ma b gy mi mf l mg mh"><strong class="ma ir">iTakeAnyArrays([1]);<br/></strong>// function iTakeAnyArrays(arr: any[]): any[]</span><span id="d0f0" class="lb lc iq ma b gy mi mf l mg mh"><strong class="ma ir">iTakeAnyArrays(['A']);<br/></strong>// function iTakeAnyArrays(arr: any[]): any[]</span><span id="2e5e" class="lb lc iq ma b gy mi mf l mg mh"><br/>function <strong class="ma ir">iTakeGenericArrays&lt;T&gt;(arr:T[]): T[]</strong> {<br/>    return arr;<br/>}</span><span id="0b21" class="lb lc iq ma b gy mi mf l mg mh"><strong class="ma ir">iTakeGenericArrays([1]);<br/></strong>// function iTakeGenericArrays&lt;number&gt;(arr: number[]): number[]<br/></span><span id="07b7" class="lb lc iq ma b gy mi mf l mg mh"><strong class="ma ir">iTakeGenericArrays(['B']);<br/></strong>// function iTakeGenericArrays&lt;string&gt;(arr: string[]): string[]</span></pre><p id="3bfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您将看到，我们的函数iTakeGenericArrays根据可以从参数中推断出的类型来调整定义。</p><p id="a43e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">函数<strong class="jp ir"> iTakeGenericArrays </strong>是所谓的<strong class="jp ir">泛型，因为它现在在一系列类型</strong>上工作。</p><p id="31a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以通过在函数定义中使用<strong class="jp ir">“T”</strong>来实现:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="2c85" class="lb lc iq ma b gy me mf l mg mh">function iTakeGenericArrays&lt;<strong class="ma ir">T</strong>&gt;(arr:<strong class="ma ir">T</strong>[]): <strong class="ma ir">T</strong>[]</span></pre><p id="7ac5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这称为类型变量，用于简单地传递类型。这个变量只能传递类型，不能传递值。您不必使用“T”作为变量名，可以使用您选择的任何其他变量。</p></div><div class="ab cl ku kv hu kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ij ik il im in"><p id="a3ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，我们没有显式地传入任何类型，它是由TypeScript编译器从args中自动推断出来的。</p><p id="81da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以在需要时显式传入类型。我们对之前的通用函数做了一点修改，现在返回传入数组的长度:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="e0cb" class="lb lc iq ma b gy me mf l mg mh"><strong class="ma ir">function iTakeGenericArrays&lt;T&gt;(arr:T[]): number {<br/>    return arr.length;<br/>}</strong></span><span id="6434" class="lb lc iq ma b gy mi mf l mg mh">// <strong class="ma ir">T</strong> will be replaced by type <strong class="ma ir">string</strong>:</span><span id="7ccb" class="lb lc iq ma b gy mi mf l mg mh">let arrLength = <strong class="ma ir">iTakeGenericArrays&lt;string&gt;(['B'])</strong>;<br/>console.log(arrLength);</span><span id="4626" class="lb lc iq ma b gy mi mf l mg mh">// The following will give an error:</span><span id="e92d" class="lb lc iq ma b gy mi mf l mg mh">arrLength = iTakeGenericArrays&lt;<strong class="ma ir">string</strong>&gt;([<strong class="ma ir"><em class="mj">2</em></strong>]);<br/>console.log(arrLength);<br/>// Type 'number' is not assignable to type 'string'</span></pre><p id="6a41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经使用函数参数<strong class="jp ir"> arr:T[] </strong>到达这个点，这样我们就可以访问<strong class="jp ir">。数组的长度属性。</strong></p><p id="4bce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能想知道为什么我们不直接使用下面的代码，用类似于<strong class="jp ir"> string[] </strong>的代码替换T:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="ee27" class="lb lc iq ma b gy me mf l mg mh">function iTakeGenericArrays&lt;T&gt;(arr:<strong class="ma ir">T</strong>): number {<br/>    return arr.<em class="mj">length</em>;<br/>}</span><span id="1f25" class="lb lc iq ma b gy mi mf l mg mh">// T will be replaced by string:<br/>let arrLength = iTakeGenericArrays<strong class="ma ir">&lt;string[]&gt;</strong>(['B']);<br/>console.log(arrLength);</span><span id="fab7" class="lb lc iq ma b gy mi mf l mg mh"><em class="mj">Here we have written</em></span><span id="cc9d" class="lb lc iq ma b gy mi mf l mg mh">iTakeGenericArrays&lt;T&gt;(arr:<strong class="ma ir">T</strong>): number</span><span id="e24b" class="lb lc iq ma b gy mi mf l mg mh"><em class="mj">instead of</em></span><span id="d323" class="lb lc iq ma b gy mi mf l mg mh">iTakeGenericArrays&lt;T&gt;(arr:<strong class="ma ir">T[]</strong>): number</span><span id="8c19" class="lb lc iq ma b gy mi mf l mg mh">to see if we can directly pass in <strong class="ma ir">string[]</strong> into <strong class="ma ir">T, and if our compiler will accept it</strong></span></pre><p id="fa59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但这会产生错误:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="10be" class="lb lc iq ma b gy me mf l mg mh">...<br/>  return <strong class="ma ir">arr.<em class="mj">length</em></strong>;<br/>...</span><span id="6a63" class="lb lc iq ma b gy mi mf l mg mh">Property 'length' does not exist on type 'T'.</span></pre><p id="b6e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯，typescript记录了这个错误，因为它必须确保所有类型都被一致地传入。</p><p id="d1e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有人将类型<strong class="jp ir">的数字</strong>传递给类型变量，那么显然是<strong class="jp ir">。无法访问长度</strong>属性。因此，它确保我们的函数参数被正确定义，以适应所有可以传入的类型。</p><h2 id="1451" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">使用多个类型参数</h2><p id="f5f2" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">我们也可以在泛型函数中使用多种类型变量。这可以简单地按如下方式完成:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="1e14" class="lb lc iq ma b gy me mf l mg mh">function multipleGenericTypes<strong class="ma ir">&lt;T,K&gt;</strong>(arg1: <strong class="ma ir">T</strong>, arg2: <strong class="ma ir">K</strong>): boolean {<br/>    return <strong class="ma ir">typeof arg1 === typeof arg2</strong>;<br/>}</span><span id="52b1" class="lb lc iq ma b gy mi mf l mg mh">const res = multipleGenericTypes<strong class="ma ir">&lt;string, string&gt;</strong>('a', 'b');<br/>console.log(res); // true</span><span id="2878" class="lb lc iq ma b gy mi mf l mg mh">const anotherRes = multipleGenericTypes<strong class="ma ir">&lt;string, number&gt;</strong>('1', 1);<br/>console.log(anotherRes); //false</span></pre><p id="f657" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们简单地将额外的类型变量作为<t k="">传递，并像往常一样在我们的参数中使用它。</t></p><h1 id="2b89" class="mk lc iq bd ld ml mm mn lg mo mp mq lj mr ms mt lm mu mv mw lp mx my mz ls na bi translated">带约束的泛型</h1><p id="b3c4" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">到目前为止，我们已经看到，我们的类型变量可以接受所有类型的数据，我们使用这种类型变量编写的代码也必须与所有类型兼容。</p><p id="35b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们之前在尝试访问<strong class="jp ir">时看到了这一点。类型变量的长度</strong>也可以是数字而不是数组。</p><p id="698f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在某些情况下，这可能是一个缺点，例如，我们知道我们的函数将处理一系列类型。</p><h2 id="a53b" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">实际例子</h2><p id="f649" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">让我们看一个实际应用。游戏是我最喜欢的爱好之一，所以我们的例子将涉及一些相关的东西。</p><p id="4d63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想象我们有一个角色攻击另一个角色的场景。受害者将受到损害。现实游戏的一个常见情况是，角色使用的物品也会随着使用而退化。</p><p id="4579" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们可以使用一个普通的函数对一个角色造成伤害，然后重复使用这个函数来反映这次攻击导致的武器退化。</p><p id="3c34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们需要限制我们的通用函数，只接受一系列类型，在这些类型中，我们可以反映对某个特定属性的某种伤害。游戏中常见的属性是<strong class="jp ir">生命值(生命值)</strong>属性。</p><p id="4f76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们将尝试创建一个通用函数，它接受任何拥有hp属性的类型。</p><p id="1c08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，让我们首先创建一个接口:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="8d74" class="lb lc iq ma b gy me mf l mg mh">interface CanTakeDamage {<br/>    hp: number;<br/>}</span></pre><p id="abe2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个接口为我们游戏中可以拥有<strong class="jp ir"> hp </strong>属性的任何实体定义了一个<strong class="jp ir">类型</strong>。</p><p id="e7e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这之后，让我们为我们的角色定义职业和他们可能使用的武器。这些武器与角色有一些共同的属性:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="b3a5" class="lb lc iq ma b gy me mf l mg mh">class <strong class="ma ir">Character</strong> {<br/>    name: string; <br/>    attack: number; <br/>    hp: number;<br/>    constructor(<br/>        name: string, <br/>        attack: number, <br/>        hp: number,<br/>    ) {<br/>        this.name = name;<br/>        this.attack = attack;<br/>        this.hp = hp;<br/>    }<br/>}</span><span id="5412" class="lb lc iq ma b gy mi mf l mg mh">class Weapon <strong class="ma ir">extends</strong> Character {<br/>    price: number;<br/>    constructor(<br/>        name: string,<br/>        attack: number,<br/>        hp: number,<br/>        price: number,<br/>    ) {<br/>        <strong class="ma ir">super(<br/>            name,<br/>            attack,<br/>            hp<br/>        );</strong><br/>        this.price = price;<br/>    }<br/>}</span></pre><p id="3ee2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以这两个实体都将有一个<strong class="jp ir">名</strong>，一个基础<strong class="jp ir">攻击</strong>属性和<strong class="jp ir"> hp </strong>属性。该武器将额外拥有一个“价格”属性。</p><p id="9193" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们获得三个这样的游戏实体:一个巫师，一个巫师要攻击的怪物和一把他要用来攻击的剑。<br/>巫师是“杰洛特”，布鲁克萨是“百合”，剑是伟大的“艾伦迪特”。</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="9e32" class="lb lc iq ma b gy me mf l mg mh">const <strong class="ma ir">Witcher</strong> = new Character(<br/>    "Geralt",<br/>    1250,<br/>    3200<br/>);</span><span id="617b" class="lb lc iq ma b gy mi mf l mg mh">const <strong class="ma ir">Bruxa</strong> = new Character(<br/>    "Lily",<br/>    1450,<br/>    4200<br/>);</span><span id="677f" class="lb lc iq ma b gy mi mf l mg mh">const <strong class="ma ir">SilverSword</strong> = new <strong class="ma ir">Weapon</strong>(<br/>    "Aerondight", // name<br/>    550, // base attack<br/>    500, // hp property used here for sword "health"<br/>    5500 // price<br/>);</span></pre><p id="a1ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们传递给每个人他们各自的统计数据和他们的名字。</p><p id="0218" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很好，现在剩下要做的就是创建一个通用函数来帮助我们对这些游戏实体造成伤害。</p><p id="a726" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个函数可以使用类型变量“T ”,但是我们如何缩小这个类型变量的范围以确保只有具有<strong class="jp ir"> hp </strong>属性的东西被认为是有效的类型呢？</p><p id="748a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可以通过使用我们之前定义的接口，让我们的类型变量扩展这个接口来实现:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="3fb1" class="lb lc iq ma b gy me mf l mg mh"><strong class="ma ir">interface CanTakeDamage {<br/>    hp: number;<br/>}</strong></span><span id="0eda" class="lb lc iq ma b gy mi mf l mg mh">...</span><span id="ec53" class="lb lc iq ma b gy mi mf l mg mh">function inflictDamage&lt;T <strong class="ma ir">extends</strong> CanTakeDamage&gt;(<br/>    <strong class="ma ir">victimEntity: T</strong>,<br/>    damage:number<br/>) {<br/>    return <strong class="ma ir">victimEntity.hp</strong> - damage;<br/>}</span></pre><p id="3a4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，我们可以缩小可接受类型的范围，只接受那些可以作为CanTakeDamage传递的类型。</p><p id="8ffe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的<strong class="jp ir">造成伤害</strong>函数将只接受<strong class="jp ir">受害者实体</strong>参数的参数，该参数将是<strong class="jp ir">伤害</strong>类型，即它们将具有<strong class="jp ir"> hp </strong>属性。</p><p id="67ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为我们指定了无论传递给<strong class="jp ir"> T </strong>的是什么类型，都应该扩展<strong class="jp ir"> CanTakeDamage </strong>。</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="024b" class="lb lc iq ma b gy me mf l mg mh">&lt;T <strong class="ma ir">extends</strong> CanTakeDamage&gt;</span></pre><p id="1804" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们没有扩展这个接口，我们可能会传递任何任意类型，并且会从编译器得到一个关于<strong class="jp ir"> hp </strong>属性不在<strong class="jp ir"> T </strong>上的错误。因为T可以是任何其他类型，如字符串或数字。</p><p id="788c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，剩下要做的就是测试我们的功能。对于我们到目前为止拥有的代码，我们将添加以下内容:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="be6a" class="lb lc iq ma b gy me mf l mg mh">...</span><span id="8e47" class="lb lc iq ma b gy mi mf l mg mh">const <strong class="ma ir">damageBruxa</strong> = inflictDamage(<br/>    Bruxa, <br/>    <strong class="ma ir">Witcher.attack + SilverSword.attack</strong><br/>);</span><span id="03bc" class="lb lc iq ma b gy mi mf l mg mh">const <strong class="ma ir">damageSword</strong> = inflictDamage(<br/>    SilverSword, <br/>    <strong class="ma ir">Bruxa.hp/50</strong><br/>);</span><span id="90d4" class="lb lc iq ma b gy mi mf l mg mh">console.log(`<br/>    Bruxa now has <strong class="ma ir">${damageBruxa}</strong> hp,<br/>    Sword degrades to <strong class="ma ir">${damageSword}</strong> points<br/>`);</span><span id="97d2" class="lb lc iq ma b gy mi mf l mg mh"><br/>Which will log:</span><span id="57e4" class="lb lc iq ma b gy mi mf l mg mh">Bruxa now has 2400 hp,<br/>Sword degrades to 416 points</span></pre><p id="607d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完整的代码应该如下所示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="38db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们谈到接口和泛型的话题时，让我们接下来看看将两者更紧密联系在一起的东西。</p><h1 id="4dd7" class="mk lc iq bd ld ml mm mn lg mo mp mq lj mr ms mt lm mu mv mw lp mx my mz ls na bi translated">通用接口</h1><p id="fc44" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">假设我们有一个函数来检查传递的数组的长度:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="b558" class="lb lc iq ma b gy me mf l mg mh">function checkLength&lt;T&gt;(item: T[]): number {<br/>    return item.length;<br/>};</span></pre><p id="8ab1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有另一个函数，我们需要将它作为回调来传递。这个函数也将一个字符串作为它的第二个参数，并使用回调函数返回这个字符串的长度。</p><p id="b81f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似于以下内容，但缺少一部分:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="a7ed" class="lb lc iq ma b gy me mf l mg mh">function <strong class="ma ir">checkLength</strong>&lt;T&gt;(item: T[]): number {<br/>    return item.length;<br/>}</span><span id="b975" class="lb lc iq ma b gy mi mf l mg mh">function getStrLength(<br/>    cb<strong class="ma ir">: ??????,</strong> <br/>    str: string<br/>): number {<br/>    return checkLength(str.split(''));<br/>}</span><span id="f65d" class="lb lc iq ma b gy mi mf l mg mh">const len = getStrLength(<br/>    <strong class="ma ir">checkLength</strong>,<br/>    'The Lesser Evil.'<br/>);</span><span id="9db3" class="lb lc iq ma b gy mi mf l mg mh">console.log(len); </span></pre><p id="f8ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问号是故意放上去的，我们可以为回调函数<strong class="jp ir"> checkLength </strong>传递什么类型的函数呢？</p><p id="c8cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看我们的<strong class="jp ir"> checkLength </strong>函数，我们可以将回调的类型写成:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="402e" class="lb lc iq ma b gy me mf l mg mh">function checkLength&lt;T&gt;(item: T[]): number {<br/>    return item.length;<br/>}</span><span id="951f" class="lb lc iq ma b gy mi mf l mg mh">function getStrLength(<br/>    cb<strong class="ma ir">: &lt;T&gt;(item: T[]) =&gt; number</strong>, <br/>    str: string<br/>): number {<br/>    return cb&lt;string&gt;(str.split(''));<br/>}</span><span id="4957" class="lb lc iq ma b gy mi mf l mg mh">const len = getStrLength(<br/>    checkLength,<br/>    'The Lesser Evil.'<br/>);</span><span id="f41d" class="lb lc iq ma b gy mi mf l mg mh">console.log(len); // 16</span></pre><p id="0394" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的函数是这样的:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="0194" class="lb lc iq ma b gy me mf l mg mh"><strong class="ma ir">checkLength: &lt;T&gt;(item: T[]) =&gt; number</strong></span><span id="7975" class="lb lc iq ma b gy mi mf l mg mh">since it takes in an <strong class="ma ir">item parameter</strong> of an <strong class="ma ir">array of any T type</strong> of elements, and returns a <strong class="ma ir">number</strong> which is the length of the array.</span></pre><p id="1e09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行代码后，我们得到了预期的结果。</p><p id="d837" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在假设我们有另一种情况，我们需要检查两个字符串之间的长度差异。</p><p id="bfde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，使用传递的回调和两个字符串进行相互检查。</p><p id="ed54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以为回调部分重用我们的checkLength方法，以产生一个<strong class="jp ir"> getStrDiff </strong>函数。类似于以下内容:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="eb5d" class="lb lc iq ma b gy me mf l mg mh">function <strong class="ma ir">checkLength</strong>&lt;T&gt;(item: T[]): number {<br/>    return item.length;<br/>};</span><span id="d6d8" class="lb lc iq ma b gy mi mf l mg mh">function getStrLength(<br/>    cb: <strong class="ma ir">&lt;T&gt;(item: T[]) =&gt; number</strong>, <br/>    str: string<br/>): number {<br/>    return cb&lt;string&gt;(str.split(''));<br/>}</span><span id="3f2b" class="lb lc iq ma b gy mi mf l mg mh">function <strong class="ma ir">getStrDiff</strong>(<br/>    cb: <strong class="ma ir">&lt;T&gt;(item: T[]) =&gt; number</strong>, <br/>    str1: string,<br/>    str2: string<br/>): number {<br/>    return (<br/>        <strong class="ma ir">cb&lt;string&gt;(str1.split('')) - cb&lt;string&gt;(str2.split(''))</strong><br/>    );<br/>}</span><span id="0ab5" class="lb lc iq ma b gy mi mf l mg mh">const len = getStrLength(<br/>    <strong class="ma ir">checkLength</strong>,<br/>    'The Lesser Evil.'<br/>);</span><span id="e8c0" class="lb lc iq ma b gy mi mf l mg mh">const <strong class="ma ir">diff</strong> = <strong class="ma ir">getStrDiff</strong>(<br/>    <strong class="ma ir">checkLength</strong>,<br/>    'Silver for Monsters',<br/>    'Steel for Humans'<br/>)</span><span id="67c7" class="lb lc iq ma b gy mi mf l mg mh">console.log(len, <strong class="ma ir">diff</strong>); // 16, 3</span></pre><p id="ff74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我们不得不再次写出回调的整个类型。这肯定是可以避免的。</p><p id="9090" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个问题可以通过使用接口来解决。我们可以为这个公共回调的类型定义一个:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="fc07" class="lb lc iq ma b gy me mf l mg mh"><strong class="ma ir">interface CheckLength {<br/>    &lt;T&gt;(item: T[]): number<br/>}</strong></span><span id="437c" class="lb lc iq ma b gy mi mf l mg mh">(<strong class="ma ir">Note the capital "C"</strong>, this is not the same as our checkLength function earlier)</span></pre><p id="9790" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以使用这个接口在getStrDiff和getStrLength的函数参数中定义回调类型:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="6a58" class="lb lc iq ma b gy me mf l mg mh">interface <strong class="ma ir">CheckLength</strong> {<br/>    <strong class="ma ir">&lt;T&gt;(item: T[]): number</strong><br/>}</span><span id="caa9" class="lb lc iq ma b gy mi mf l mg mh">function checkLength<strong class="ma ir">&lt;T&gt;(item: T[]): number</strong> {<br/>    return item.length;<br/>};</span><span id="31cb" class="lb lc iq ma b gy mi mf l mg mh">function getStrLength(<br/>    cb: <strong class="ma ir">CheckLength</strong>, <br/>    str: string<br/>): number {<br/>    return cb<strong class="ma ir">&lt;string&gt;</strong>(str.split(''));<br/>}</span><span id="8039" class="lb lc iq ma b gy mi mf l mg mh">function getStrDiff(<br/>    cb: <strong class="ma ir">CheckLength</strong>, <br/>    str1: string,<br/>    str2: string<br/>): number {<br/>    return (<br/>        cb<strong class="ma ir">&lt;string&gt;</strong>(str1.split('')) - cb<strong class="ma ir">&lt;string&gt;</strong>(str2.split(''));<br/>    );<br/>}</span><span id="f62e" class="lb lc iq ma b gy mi mf l mg mh">const len = getStrLength(<br/>    checkLength,<br/>    'The Lesser Evil.'<br/>);</span><span id="b149" class="lb lc iq ma b gy mi mf l mg mh">const diff = getStrDiff(<br/>    checkLength,<br/>    'Silver for Monsters',<br/>    'Steel for Humans'<br/>)</span><span id="816f" class="lb lc iq ma b gy mi mf l mg mh">console.log(len, diff);</span></pre><p id="5be1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以向接口本身传递一个类型变量，以进一步细化我们的代码:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="43c8" class="lb lc iq ma b gy me mf l mg mh">interface <strong class="ma ir">CheckLength&lt;T&gt;</strong> {<br/>    (item: T[]): number<br/>}</span><span id="c02f" class="lb lc iq ma b gy mi mf l mg mh">function checkLength&lt;T&gt;(item: T[]): number {<br/>    return item.length;<br/>};</span><span id="abe8" class="lb lc iq ma b gy mi mf l mg mh">function getStrLength(<br/>    cb: CheckLength&lt;string&gt;, <br/>    str: string<br/>): number {<br/>   <strong class="ma ir"> return cb(str.split(''));</strong><br/>}</span><span id="3aa3" class="lb lc iq ma b gy mi mf l mg mh">function getStrDiff(<br/>    cb: CheckLength&lt;string&gt;, <br/>    str1: string,<br/>    str2: string<br/>): number {<br/>    return (<br/>        <strong class="ma ir">cb(str1.split('')) - cb(str2.split(''));</strong><br/>    );<br/>}</span><span id="80c7" class="lb lc iq ma b gy mi mf l mg mh">const len = getStrLength(<br/>    checkLength,<br/>    'The Lesser Evil.'<br/>);</span><span id="352a" class="lb lc iq ma b gy mi mf l mg mh">const diff = getStrDiff(<br/>    checkLength,<br/>    'Silver for Monsters',<br/>    'Steel for Humans'<br/>)</span><span id="8e43" class="lb lc iq ma b gy mi mf l mg mh">console.log(len, diff);</span></pre><p id="9b40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这和之前的代码有什么不同？之前，我们唯一的优势是使cb参数的类型定义更加简洁。</p><p id="7d9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之前，我们还必须写出:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="babe" class="lb lc iq ma b gy me mf l mg mh">function getStrLength(<br/>    cb: <strong class="ma ir">CheckLength</strong>, <br/>    str: string<br/>): number {<br/>    return cb<strong class="ma ir">&lt;string&gt;</strong>(str.split(''));<br/>}<br/>function getStrDiff(<br/>    cb: <strong class="ma ir">CheckLength</strong>, <br/>    str1: string,<br/>    str2: string<br/>): number {<br/>    return (<br/>        cb<strong class="ma ir">&lt;string&gt;</strong>(str1.split('')) - cb<strong class="ma ir">&lt;string&gt;</strong>(str2.split(''));<br/>    );<br/>}</span></pre><p id="b7b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而现在，</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="ec82" class="lb lc iq ma b gy me mf l mg mh">function getStrLength(<br/>    cb: <strong class="ma ir">CheckLength&lt;string&gt;</strong>, <br/>    str: string<br/>): number {<br/>    return <strong class="ma ir">cb(str.split(''));</strong><br/>}</span><span id="377c" class="lb lc iq ma b gy mi mf l mg mh">function getStrDiff(<br/>    cb: <strong class="ma ir">CheckLength&lt;string&gt;</strong>, <br/>    str1: string,<br/>    str2: string<br/>): number {<br/>    return (<br/>        <strong class="ma ir">cb(str1.split('')) - cb(str2.split(''));</strong><br/>    );<br/>}</span></pre><p id="1be5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在接口本身的帮助下，我们将T类型强制为回调<strong class="jp ir"> cb，</strong>的字符串。</p><p id="3cfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是完整的代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="18cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，让我们看看如何在另一个实际应用中，将<strong class="jp ir">泛型与</strong>类一起使用。</p><h2 id="6fc5" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">通用类</h2><p id="ad39" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">如果到目前为止您已经理解了这些概念，那么理解泛型类应该是轻而易举的事情。</p><p id="d41d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就像接口一样，我们只需在类声明后添加类型变量:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="9f26" class="lb lc iq ma b gy me mf l mg mh">class Character&lt;T&gt; {<br/>    private name: T;<br/>    sayMessage: (msg: T) =&gt; T;<br/>    constructor(<br/>        name: T,<br/>        sayMessage: (msg: T) =&gt; T<br/>    ) {<br/>        this.name = name;<br/>        this.sayMessage = sayMessage;<br/>    }</span><span id="daf1" class="lb lc iq ma b gy mi mf l mg mh">    sayName = (): T =&gt; {<br/>        return this.name;<br/>    };<br/>}</span></pre><p id="7425" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们可以创建一个角色对象，如下所示:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="a95c" class="lb lc iq ma b gy me mf l mg mh">const Geralt = new Character&lt;string&gt;(<br/>    'Geralt of Rivia',<br/>    (msg) =&gt; {<br/>        return msg<br/>    }<br/>);</span></pre><p id="a7c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，t将接受字符串作为它的类型，因此我们的杰洛特对象上的sayMessage方法将只接受字符串作为它的msg参数。</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="dfbc" class="lb lc iq ma b gy me mf l mg mh">const geraltSays = Geralt.sayMessage(`What is up my dude, I am ${Geralt.sayName()}`);<br/>console.log(geraltSays);</span><span id="f053" class="lb lc iq ma b gy mi mf l mg mh">Will log<br/>"What is up my dude, I am Geralt of Rivia"</span><span id="a9a9" class="lb lc iq ma b gy mi mf l mg mh">Whereas</span><span id="dbe2" class="lb lc iq ma b gy mi mf l mg mh">const geraltSays = Geralt.sayMessage(10);<br/>console.log(geraltSays);</span><span id="f373" class="lb lc iq ma b gy mi mf l mg mh">// will give an error since 10 is not of type string</span></pre><p id="b354" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完整的代码如下所示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb nc l"/></div></figure><blockquote class="nd ne nf"><p id="ae27" class="jn jo mj jp b jq jr js jt ju jv jw jx ng jz ka kb nh kd ke kf ni kh ki kj kk ij bi translated"><strong class="jp ir">这应该涵盖了你开始使用泛型所需要知道的大部分内容。</strong></p></blockquote></div><div class="ab cl ku kv hu kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ij ik il im in"><p id="e805" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我建议查看一下<a class="ae kt" href="https://www.typescriptlang.org/docs/handbook/generics.html" rel="noopener ugc nofollow" target="_blank"> Typescript手册</a>,从总体上了解更多关于泛型和类型脚本的知识。</p><p id="1ab8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望这至少在某种程度上有助于更好地理解泛型！</p></div><div class="ab cl ku kv hu kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ij ik il im in"><h1 id="9ca7" class="mk lc iq bd ld ml nj mn lg mo nk mq lj mr nl mt lm mu nm mw lp mx nn mz ls na bi translated">分级编码</h1><p id="b1a6" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">感谢您成为我们社区的一员！<a class="ae kt" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">订阅我们的YouTube频道</strong> </a>或者加入<a class="ae kt" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> Skilled.dev编码面试课程</strong> </a>。</p><div class="no np gp gr nq nr"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">编写面试问题+获得开发工作</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">掌握编码面试的过程</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">技术开发</p></div></div><div class="oa l"><div class="ob l oc od oe oa of kr nr"/></div></div></a></div></div></div>    
</body>
</html>