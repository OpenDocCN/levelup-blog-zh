# SQL Server 中的 ACID 属性

> 原文：<https://levelup.gitconnected.com/acid-properties-in-sql-server-d712d2850b8e>

在这篇文章中，我将用例子解释 SQL Server 中的 **ACID 属性。**

## 什么是数据库事务？

数据库事务是对数据库的一系列操作，这些操作被视为一个单独的单元，通过应用**“要么做一切，要么什么都不做”**的原则来执行，成功的事务必须通过 ACID 测试。事务可以由单个读、写、删除或更新操作或这些操作的组合组成。我们用一个例子来看这个:想象一下当我们想从 ATM 机取钱的时候。

**在 SQL 代码中大概是这样的:**

1.检查你的余额是否有足够的钱。从你的余额中取钱(更新)
3。添加事务日志(插入查询)

如您所见，整个流程由多个操作组成，但它们被视为单个事务。

**为什么我们需要交易？**

想象一下，当你从账户中取钱时，不知何故，系统在你取钱之前崩溃了。现在数据库状态会有一个奇怪的状态，就像你丢失了 X 数量，但是你没有拿走它。现在让我们看看现代关系数据库如何用 **ACID** 属性解决它。

**SQL Server 中的事务模式**

1.  **自动提交事务**模式是 SQL Server 的默认事务。在这种模式下，每个 T-SQL 语句都被视为一个事务，并根据其结果进行提交或回滚。成功的语句被提交，失败的语句被立即回滚
2.  **隐式事务**模式使 SQL Server 能够为每个 DML 语句启动一个隐式事务，但是我们需要在语句的末尾显式使用提交或回滚命令
3.  **显式事务**模式提供了用事务的起点和终点来精确定义事务

## 酸性

酸是原子性、一致性、隔离性和持久性的缩写。任何现代关系数据库的大部分架构都是建立在这些属性之上的。理解事务的 ACID 属性是理解 SQL Server 许多方面的先决条件。

**原子性:**确保事务内的所有 DML 语句(即插入、更新、删除)要么成功完成，要么全部回滚。

**一致性:**确保数据库数据在事务开始之前处于一致状态，并且在事务完成之后也保持一致状态。

**隔离:**确保一个事务的中间状态对其他事务不可见。一个事务所做的数据修改必须与所有其他事务所做的数据修改隔离开来

**持久性:**确保一旦事务成功完成，那么对数据库的更改将是永久的。即使出现系统故障、电源故障或任何异常变化，it 部门也应保护提交的数据。

**用实例理解交易**

让我们考虑一个银行交易，从一个账户向另一个账户汇款。事务语句应该是这样的: **X = 1500** ， **Y = 400**

1.  阅读(X)
2.  X = X–1000
3.  写(X)
4.  阅读(Y)
5.  Y = Y + 1000
6.  写(Y)

现在，让我们看看本例中每个属性的作用:

*   **原子性要求:**如果事务在步骤 3 之后、步骤 6 之前失败，系统应确保其更新不反映在数据库中，否则将导致不一致。
*   **一致性要求**—X 和 Y 之和不因事务的执行而改变。必须维护交易前后的总金额:所以 1500 + 400 = 500 + 1400
*   **持久性要求:**一旦通知用户事务已经完成，事务对数据库的更新必须在失败的情况下保持不变。

为了理解隔离级别，让我们在上面的示例旁边再添加一个事务，并将上面的示例称为 **T** ，下面的示例称为 **T1** :

1.阅读(X)
2。
读(Y)3。Z = X + Y
4。写(Z)

假设 **T** 已经执行到 **Read (Y)** 然后 **T1** 开始。结果， **T2** 读取了 **X** 的正确值，但是 **Y、**的错误值以及
**T2 计算的和:(X+Y = 500 + 400 = 900)**
与交易结束时的和:
**T:(X+Y = 500+1400 = 1900)**。
由于损失了 1000 个单位，这导致数据库不一致。因此，事务必须在隔离中发生，并且只有在对主存进行了更改之后，更改才是可见的。

感谢您的阅读，并随时分享您的反馈和意见:)