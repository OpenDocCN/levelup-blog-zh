<html>
<head>
<title>Visualization of Multidimensional Datasets Using t-SNE in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中使用t-SNE的多维数据集可视化</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/visualization-of-multidimensional-datasets-using-t-sne-in-python-64f1efa9ffe0?source=collection_archive---------15-----------------------#2020-04-13">https://levelup.gitconnected.com/visualization-of-multidimensional-datasets-using-t-sne-in-python-64f1efa9ffe0?source=collection_archive---------15-----------------------#2020-04-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="ad17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文将关注Python中的t-分布式随机邻居嵌入(t-SNE)及其在多维数据集数据可视化中的应用。</p><p id="ec31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">目录:</strong></p><ul class=""><li id="d0bd" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">介绍</li><li id="f3b4" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">随机邻居嵌入(SNE)概述</li><li id="4b77" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">t分布随机邻居嵌入(t-SNE)综述</li><li id="baf2" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">Python中的t分布随机邻居嵌入(t-SNE)</li><li id="9864" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">t分布随机邻居嵌入(t-SNE)超参数调整</li><li id="e7a5" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">附加说明</li><li id="7714" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">结论</li></ul></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="0788" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">介绍</h1><p id="0385" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">我们思考图形和可视化的方式通常是在2D和3D空间中。从高中开始，我们在XY平面和XYZ空间绘制数据，这对我们来说非常有意义。然而，当处理现实世界中的大多数数据集时，我们发现它们中的大多数都具有3个以上的特征，因此是多维的。现在出现了在k维中可视化数据的困难，仅仅是因为我们在日常生活中以3D形式看到和思考。</p><p id="1318" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">数据科学在线社区中有许多文章关注数据可视化和理解多维数据集。我个人阅读了几篇描述4D空间背后的代数和几何的文章，直到今天我还觉得很难在脑海中想象，更不用说更大的维度了。</p><p id="e552" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，降维背后的思想有两个关键部分:</p><ol class=""><li id="8b58" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn mm ku kv kw bi translated">帮助使数据对算法更加友好</li><li id="4b11" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn mm ku kv kw bi translated">帮助重塑数据，使其可视化</li></ol><p id="e3ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一部分更多的是一种数学方法，是算法开发和其他机器学习工作所需要的，例如，<a class="ae mn" href="https://pyshark.com/principal-component-analysis-in-python/" rel="noopener ugc nofollow" target="_blank">主成分分析</a>。</p><p id="fa04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将重点讨论第二部分。我们的目标是使多维数据集对可视化更友好。也有几种方法可以解决这个问题，但这里我们将与SNE霸王龙合作。</p></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="8b7a" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">随机邻居嵌入(SNE)概述</h1><p id="77b0" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">随机近邻嵌入(或SNE)是一种非线性概率降维技术。这对于将k维数据集降低到更低的维度(二维或三维空间)以实现数据可视化非常有用。</p><p id="47ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">SNE的做法是:</p><ol class=""><li id="1508" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn mm ku kv kw bi translated">构建一个概率分布来表示数据集，其中相似的点被选取的概率较高，不相似的点被选取的概率较低。</li><li id="fc9e" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn mm ku kv kw bi translated">创建一个低维空间，尽可能接近地复制步骤1中概率分布的属性。</li></ol><h2 id="712a" class="mo lk it bd ll mp mq dn lp mr ms dp lt kb mt mu lx kf mv mw mb kj mx my mf mz bi translated">第一步:高维空间中的条件概率</h2><p id="a15f" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">根据读者的统计知识，理解起来可能容易，也可能困难。此外，我们将使用最受欢迎的<a class="ae mn" href="http://jmlr.org/papers/volume9/vandermaaten08a/vandermaaten08a.pdf" rel="noopener ugc nofollow" target="_blank">论文之一</a>中关于SNE细节的公式和参考来展示这种转换是如何进行的。</p><p id="1397" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我们说，SNE从一个数据集构建了一个单一的概率分布，其中相似/不相似的点被选中的概率较高/较低。我们如何确定哪些点是相似的，哪些是不相似的？</p><p id="eb1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在随机邻居嵌入中，相似点是具有高条件概率的点。下面是我们的计算方法:</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div class="gh gi na"><img src="../Images/c7370fb7bb5fada82b20dd095cc8f9a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*L9ECg5uvCnzTICl2JA50FA.png"/></div></figure><p id="6944" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的目标是找到两点的条件概率:<em class="ni"> x_i </em>和<em class="ni"> x_j </em>。这是我们从数据集中选择的两个随机点(在模型中，它计算数据集中所有点对的条件概率)。</p><p id="485e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">换句话说，<em class="ni"> x_i </em>选择<em class="ni"> x_j </em>作为其邻居的概率是<em class="ni"> p_(j|i) </em>，这又是它们在以<em class="ni"> x_i </em>为中心的高斯(正态)分布下的概率密度与方差<em class="ni"> σ_i </em>的比例。</p><p id="d11d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上述计算的结果是，对于非常靠近的数据点，<em class="ni"> p_(j|i) </em>的值将会很高(意味着这些点彼此相似)，而对于彼此远离的数据点，<em class="ni"> p_(j|i) </em>的值将会很小(意味着这些点彼此不相似)。</p><h2 id="3389" class="mo lk it bd ll mp mq dn lp mr ms dp lt kb mt mu lx kf mv mw mb kj mx my mf mz bi translated">第二步:低维空间中的条件概率</h2><p id="cf37" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">在前面的部分中，我们基于k 维空间中的相似性找到了潜在的邻居。比如我们发现<em class="ni"> x_i </em>和<em class="ni"> x_j </em>是相似的。现在我们需要找到它们在低维空间中的对应物。</p><p id="6db4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设对于<em class="ni"> x_i </em>其较低维度的对应物是<em class="ni"> y_i </em>，对于<em class="ni"> x_j </em>其较低维度的对应物是<em class="ni"> x_j </em>。所以在低维空间我们有:<em class="ni"> x_i- &gt; </em> <em class="ni"> y_i </em>和<em class="ni"> x_j </em> - &gt; <em class="ni"> y_j </em>。</p><p id="a73d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们可以计算出<em class="ni"> y_j </em>与<em class="ni"> y_i </em>相似(并且是邻居)的相似条件概率，我们将其表示为<em class="ni"> q_(j|i) </em>。</p><p id="7fcb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ni"> q_(j|i) </em>的公式类似于<em class="ni"> p_(j|i) </em>的公式，其中有一处变化，我们将方差设置为(1/sqrt 2)，这使得<em class="ni"> σ </em>项等于1。下面是我们的计算方法:</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/3f53f96198f6360b2008cedb13d097f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*ahD8yxMcJZQe2QFX7GOaqA.png"/></div></figure><p id="2074" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">计算背后的直觉类似于步骤1中的直觉。因此，如果高维点<em class="ni"> x_i </em>和<em class="ni"> x_j </em>正确地用它们在低维空间<em class="ni"> y_i </em>和<em class="ni"> y_j </em>中的对应物来表示，那么两个分布中的条件概率应该相等:<em class="ni">p _(j | I)</em>=<em class="ni">q _(j | I)</em>。</p><p id="dc8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该技术采用了最小化<a class="ae mn" href="http://hanj.cs.illinois.edu/cs412/bk3/KL-divergence.pdf" rel="noopener ugc nofollow" target="_blank">库尔贝克-莱伯散度</a>的方法来得出其结果。它的作用是最小化两个概率分布之间的差异。</p><h2 id="de4a" class="mo lk it bd ll mp mq dn lp mr ms dp lt kb mt mu lx kf mv mw mb kj mx my mf mz bi translated">摘要</h2><p id="9b9a" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">以上部分显示了随机邻居嵌入背后的逻辑和计算。</p><p id="5294" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回想一下我们在SNE使用的步骤:</p><ol class=""><li id="3c48" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn mm ku kv kw bi translated">使用高斯(正态)分布创建一个概率分布，定义k维空间中数据点之间的关系。</li><li id="6fbb" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn mm ku kv kw bi translated">使用高斯(正态)分布在低维空间中重新创建定义数据对应物之间关系的概率分布。</li></ol><p id="2ad8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方法的缺点是什么？</p><ul class=""><li id="b0b5" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">它使用高斯分布，与学生的t分布(用于t-SNE)相比，高斯分布具有较短的尾部。</li><li id="f11f" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">它最小化了<a class="ae mn" href="http://hanj.cs.illinois.edu/cs412/bk3/KL-divergence.pdf" rel="noopener ugc nofollow" target="_blank"> Kullback-Leiber散度</a>，该散度具有难以优化的成本函数。</li></ul></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="612f" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">t分布随机邻居嵌入(t-SNE)综述</h1><p id="3cdf" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">在上一节中，我们讨论了降低数据集维度所需的大多数计算，我们在这里将重点解释为什么我们使用t-SNE而不是SNE进行可视化，以及它们有何不同。</p><p id="fac7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从这部分的名字你可能注意到了这个技术的开头使用了“t-Distributed”。在前面的SNE计算中，我们使用了高斯(正态)分布和梯度下降成本函数来最小化Kullback-Lieber散度。</p><p id="90e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">t-SNE计算非常相似，只是它将使用学生t-分布来重建低维空间中的概率分布。</p><p id="c000" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">SNE霸王龙的做法是:</p><ol class=""><li id="eb59" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn mm ku kv kw bi translated">使用高斯(正态)分布创建一个概率分布，定义k维空间中数据点之间的关系。</li><li id="a24b" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn mm ku kv kw bi translated">使用高斯(正态)分布在低维空间中重新创建定义数据对应物之间关系的概率分布。</li></ol><h2 id="20c0" class="mo lk it bd ll mp mq dn lp mr ms dp lt kb mt mu lx kf mv mw mb kj mx my mf mz bi translated">第一步:高维空间中的条件概率</h2><p id="b00c" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">该步骤与上一节中的步骤1相同。由于采用对称SNE方法，条件概率公式会有一些微小的差异，在<a class="ae mn" href="http://jmlr.org/papers/volume9/vandermaaten08a/vandermaaten08a.pdf" rel="noopener ugc nofollow" target="_blank">原始论文</a>中有详细描述。</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/0032ab07a2117ea99639131c9a7a26b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*27XJWMLLAIXgw-jSEUlQjA.png"/></div></figure><h2 id="cbac" class="mo lk it bd ll mp mq dn lp mr ms dp lt kb mt mu lx kf mv mw mb kj mx my mf mz bi translated">第二步:低维空间中的条件概率</h2><p id="7f60" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">计算与上一节中的步骤2相似，只是有一处不同。我们将使用学生t分布来利用它在低维的重尾。它将改变公式如下:</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/af377bc8459ba454d23cb21a2e0310bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*-bB5cHFZWaZ8_qTCAdv-8Q.png"/></div></figure><h2 id="e507" class="mo lk it bd ll mp mq dn lp mr ms dp lt kb mt mu lx kf mv mw mb kj mx my mf mz bi translated">摘要</h2><p id="532c" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">你会注意到这两种技术非常相似，SNE霸王龙本质上是SNE的改良版。但是我们为什么需要这个修改版本呢？为什么我们不能和SNE合作呢？</p><p id="9e6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有两个主要原因:</p><ul class=""><li id="b6be" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">难以优化成本函数</li><li id="f6f2" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">拥挤问题</li></ul><p id="e0cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">优化成本函数的困难更多的是数学上的，不在本文中讨论，但是欢迎您在线搜索，因为有许多文章显示了详细的推导过程。</p><h2 id="2150" class="mo lk it bd ll mp mq dn lp mr ms dp lt kb mt mu lx kf mv mw mb kj mx my mf mz bi translated">添加</h2><p id="8bbc" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">我们更感兴趣的是拥挤问题。拥挤问题本质上是在将高维数据转换为低维数据时，无法保持高维数据点之间的距离。这听起来可能是很多理论上的概念，所以我们来看一个简单的例子:</p><p id="81f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设您正在使用2D空间，并希望将其数据转换到1D空间。你的点有如下坐标:(0，0)，(-1，-1)，(1，-1)，(1，1)，(-1，1)。<br/>在2D空间看起来是这样的:</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/5639b01fb6cfb1c341600b9088497460.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/0*AJDrpzvkaQPXYLqo"/></div></figure><p id="3c66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，从<em class="ni"> x0 </em>到所有其他点(<em class="ni"> x1 </em>、<em class="ni"> x2 </em>、<em class="ni"> x3 </em>、<em class="ni"> x4 </em>)的距离是相同的，我们称之为<em class="ni"> d </em>。</p><p id="6b5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一步你要做的是把它转换到1D空间。在较低维度中发生的情况是，容纳来自较高维度的所有数据的空间较少。在上图中，我们看到有5个点，每个点都有自己的位置。现在让我们来看看更低的维度:</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/6b0680b2e102d3e1d085dc47f0461000.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/0*kGYUlWIbxp1mez76"/></div></figure><p id="d94e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，在1D空间中，距离点<em class="ni"> x0 </em>距离<em class="ni"> d </em>以内的点只有两个光斑。最终会发生的是，他们将“拥挤”，因为我们有4个点，只有2个点可用，因此这些1D相邻点中的每一个都将从2D空间中得到2个点。这就是所谓的拥挤问题。</p><p id="a8f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">t-SNE有效地解决了这个问题，它使用了一个更重尾的学生t分布来允许点之间有更大的分布，从而减少了“拥挤”。</p></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="d9f7" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">Python中的t分布随机邻居嵌入(t-SNE)</h1><p id="5a42" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">为了继续学习本教程，我们需要两个Python库:pandas、numpy、sklearn和matplotlib。</p><p id="cb10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您没有安装它们，请打开“命令提示符”(在Windows上)并使用以下代码安装它们:</p><pre class="nb nc nd ne gt no np nq nr aw ns bi"><span id="56dc" class="mo lk it np b gy nt nu l nv nw">pip install pandas<br/>pip install numpy<br/>pip install sklearn<br/>pip install matplotlib</span></pre><p id="2bff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">导入所需的库:</p><pre class="nb nc nd ne gt no np nq nr aw ns bi"><span id="80a0" class="mo lk it np b gy nt nu l nv nw">import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>from sklearn.datasets import load_wine<br/>from sklearn.preprocessing import StandardScaler<br/>from sklearn.manifold import TSNE</span></pre><p id="932c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦下载、安装和导入了库，我们就可以继续Python代码实现了。</p><h2 id="7bb4" class="mo lk it bd ll mp mq dn lp mr ms dp lt kb mt mu lx kf mv mw mb kj mx my mf mz bi translated">步骤1:加载数据集</h2><p id="3868" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">在本教程中，我们将使用作为sklearn库一部分的葡萄酒识别数据集。该数据集包含13个特征，目标是3类葡萄酒。这与我们在<a class="ae mn" href="https://pyshark.com/principal-component-analysis-in-python/" rel="noopener ugc nofollow" target="_blank">主成分分析</a>文章中使用的数据集相同。</p><p id="e4aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我选择这个数据集的另一个原因是因为它的形状，因为它符合我们展示SNE霸王龙性能的要求。另外，你可能已经从其他关于<a class="ae mn" href="https://pyshark.com/" rel="noopener ugc nofollow" target="_blank"> PyShark </a>的文章中熟悉了。</p><p id="e05e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们将特性存储到数据帧中，特性名称作为列名:</p><pre class="nb nc nd ne gt no np nq nr aw ns bi"><span id="1f9c" class="mo lk it np b gy nt nu l nv nw">wine = load_wine() <br/>df = pd.DataFrame(wine.data, columns=wine.feature_names)</span></pre><h2 id="bbb4" class="mo lk it bd ll mp mq dn lp mr ms dp lt kb mt mu lx kf mv mw mb kj mx my mf mz bi translated">步骤2:标准化数据集</h2><p id="fa1f" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">为了使数据集对算法更加友好，我们将对其进行标准化:</p><pre class="nb nc nd ne gt no np nq nr aw ns bi"><span id="a2b6" class="mo lk it np b gy nt nu l nv nw">df = StandardScaler().fit_transform(df) df=pd.DataFrame(df,columns=wine.feature_names)</span></pre><p id="6f9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:这不是必须的，但通常是首选。我们在以前的文章中研究了这个数据集，发现当它被标准化时，最好将其可视化，因为许多算法会受到彼此差异很大的特征范围的影响。</p><h2 id="f184" class="mo lk it bd ll mp mq dn lp mr ms dp lt kb mt mu lx kf mv mw mb kj mx my mf mz bi translated">步骤3:在Python中应用t-SNE并可视化数据集</h2><p id="e9a2" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">sklearn类<strong class="js iu"> TSNE() </strong>带有一个超级参数列表，在应用该技术时可以对其进行调整。我们将描述其中的前两个。然而，如果你有兴趣深入了解的话，我们鼓励你探索所有的<a class="ae mn" href="https://scikit-learn.org/stable/modules/generated/sklearn.manifold.TSNE.html" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="37f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来讨论这两个超参数:</p><ol class=""><li id="48d1" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn mm ku kv kw bi translated"><strong class="js iu"> n_components : <em class="ni"> int，optional(默认值:2) </em> </strong> <br/>这是一个参数，表示您要将数据集转换到的较低空间的维度。在我们的例子中，该值应该是2，因为我们希望在2维空间中可视化数据集。</li><li id="8849" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn mm ku kv kw bi translated"><strong class="js iu">困惑度<em class="ni">:浮点型，可选(默认值:30) </em> </strong> <br/>这是最近邻居数量的参数，t-SNE将根据该参数确定潜在邻居。通常，数据集越大，困惑值应该越大。下面我们将展示不同的困惑值如何影响结果。</li></ol><p id="2c3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，让我们从使用t-SNE默认值开始绘图，并在Python中创建t-SNE的实例时设置<strong class="js iu"> random_state=0 </strong>。你可以为随机状态选择任何其他整数，我们在附录中描述了它的含义。</p><pre class="nb nc nd ne gt no np nq nr aw ns bi"><span id="267c" class="mo lk it np b gy nt nu l nv nw">tsne = TSNE(random_state=0)<br/>tsne_results = tsne.fit_transform(df) </span><span id="b302" class="mo lk it np b gy nx nu l nv nw">tsne_results=pd.DataFrame(tsne_results, columns=['tsne1', 'tsne2'])</span><span id="8c2f" class="mo lk it np b gy nx nu l nv nw">plt.scatter(tsne_results['tsne1'], tsne_results['tsne2'], c=wine.target)<br/>plt.show()</span></pre><p id="2849" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们首先用Python创建t-SNE的实例，并将其存储为<strong class="js iu"> tsne </strong>。接下来，我们将原始数据集转换成它的二维形状(<strong class="js iu"> tsne_results </strong>)，它采用numpy数组的格式。出于可视化的目的，我们将其转换为pandas数据帧，并为我们的列命名。最后，我们创建一个散点图，颜色标签类似于葡萄酒的类型(<strong class="js iu">葡萄酒。目标</strong>)。</p><p id="feb0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是我们得出的结论:</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/0f3cca9bde4d3770adf3695bbd11b828.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/0*t-iQkzvqmgsxefaf"/></div></figure><p id="7387" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相当大的成就！我们从13维发展到2维，散点图看起来很棒！</p></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="e4d9" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">t分布随机邻居嵌入(t-SNE)超参数调整</h1><p id="c6cb" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">这一节是为更高级的读者准备的，但总的来说，这只是我们在前一节所做的基础上的又一层。</p><p id="60f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们已经知道的，Python中的t-SNE附带了一组我们可以调整的超参数。因此，对我们来说，调整n _ components没有意义，因为我们总是希望它等于2，以便在二维空间中工作。</p><p id="cc86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们讨论一下调优<strong class="js iu">困惑</strong>并看看它对转换的可视化输出的影响。</p><p id="8545" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">sklearn文档建议考虑一个介于5和50之间的困惑值。似乎这可能取决于您的数据集，选择不同的值可能会根据具体情况产生明显不同的结果。</p><p id="2556" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为一个例子，让我们用几个值来表示困惑:1，10，25，75。</p><p id="9e81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意:代码编辑器不支持添加循环，建议从</strong> <a class="ae mn" href="https://pyshark.com/visualization-of-multidimensional-datasets-using-t-sne-in-python/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">原帖</strong> </a> <strong class="js iu">中复制代码。</strong></p><pre class="nb nc nd ne gt no np nq nr aw ns bi"><span id="b454" class="mo lk it np b gy nt nu l nv nw">plt.figure(figsize = (8,4))<br/>plt.subplots_adjust(top = 1.5) for index, p in enumerate([1, 10, 25, 75]):</span><span id="2d94" class="mo lk it np b gy nx nu l nv nw">tsne = TSNE(n_components = 2, perplexity = p, random_state=0)<br/>tsne_results = tsne.fit_transform(df) </span><span id="9a1d" class="mo lk it np b gy nx nu l nv nw">tsne_results=pd.DataFrame(tsne_results, columns=['tsne1', 'tsne2']) </span><span id="091d" class="mo lk it np b gy nx nu l nv nw">plt.subplot(2,2,index+1)<br/>plt.scatter(tsne_results['tsne1'], tsne_results['tsne2'], c=wine.target, s=30)<br/>plt.title('Perplexity = '+ str(p))<br/>plt.show()</span></pre><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/2b8a82f417c6571e244d9c6c56b4d738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/0*ImaBmz1V5ISROU1G"/></div></figure><p id="0942" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从上面的可视化中，我们可以得出一些重要的发现:</p><ul class=""><li id="0e57" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">困惑= 1:局部变化占主导地位</li><li id="d08e" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">困惑= 75:全球变化占主导地位</li><li id="5582" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">困惑= 10或25:都在推荐的范围内，并且结果似乎或多或少相似</li></ul><p id="24ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，你可以看到，困惑是一个重要的参数，在使用SNE霸王龙时应该考虑到这一点，以确保你的可视化效果得到正确调整。</p></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="eb48" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">附加说明</h1><p id="2983" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">回想一下，在Python中初始化t-SNE的所有实例中，我们将<strong class="js iu"> random_state </strong>参数设置为0。它到底是做什么的？</p><p id="adfa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">顾名思义，<strong class="js iu"> random_state </strong>是内部随机数生成器，它决定数据集中的索引拆分。</p><p id="46ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，如果它没有被设置，那么它会被随机初始化。</p><p id="ad44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么这对SNE霸王龙很重要？让我们看看下面的图表。这里我们用相同的参数创建了4个散点图，除了我们没有指定<strong class="js iu"> random_state </strong>:</p><p id="7a56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意:代码编辑器不支持添加循环，建议从</strong> <a class="ae mn" href="https://pyshark.com/visualization-of-multidimensional-datasets-using-t-sne-in-python/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">原帖</strong> </a> <strong class="js iu">中复制代码。</strong></p><pre class="nb nc nd ne gt no np nq nr aw ns bi"><span id="5b5f" class="mo lk it np b gy nt nu l nv nw">plt.figure(figsize=(8, 4))<br/>plt.subplots_adjust(top = 1.5)<br/>tsne = TSNE()<br/>for i in range(4):<br/>tsne_results = tsne.fit_transform(df) </span><span id="8a70" class="mo lk it np b gy nx nu l nv nw">tsne_results=pd.DataFrame(tsne_results, columns=['tsne1', 'tsne2']) </span><span id="f341" class="mo lk it np b gy nx nu l nv nw">plt.subplot(2,2,int(i)+1)<br/>plt.scatter(tsne_results['tsne1'], tsne_results['tsne2'], c=wine.target, s = 30)<br/>plt.title('Run'+str(int(i)+1))</span><span id="1076" class="mo lk it np b gy nx nu l nv nw">plt.show()</span></pre><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/2b47ccdd781c1b2924cc773880b87fa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*o2Sa36b4-2zjui2Q"/></div></figure><p id="8770" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:您生成的4个散点图可能不同。</p><p id="a392" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们观察到，即使模型的其他参数相同，不设置<strong class="js iu"> random_seed </strong>并执行代码确实会生成4个不同的数据集。</p><p id="42c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于t-SNE在Python中的初始化是随机的，除非您以其他方式进行设置，所以会出现上述结果。增加了t-SNE的复杂性，因为它的成本函数和随机初始化导致该函数的不同局部最小值，并改变每次运行的结果。</p></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="801e" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">结论</h1><p id="dbfd" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">这篇文章是一个演练的应用t-分布式随机邻居嵌入(t-SNE)的可视化多维数据集在Python中。</p><p id="1017" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，您可以采取的进一步探索该技术优势的下一步是尝试将该技术应用于更多具有高级超参数调整的数据集，并将其性能与其他维度缩减技术(如<a class="ae mn" href="https://pyshark.com/principal-component-analysis-in-python/" rel="noopener ugc nofollow" target="_blank">主成分分析</a>)进行比较。</p><p id="c0df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你有任何问题或者对编辑有任何建议，请在下面留下你的评论。</p></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><p id="317a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ni">原载于2020年4月13日https://pyshark.com</em><a class="ae mn" href="https://pyshark.com/visualization-of-multidimensional-datasets-using-t-sne-in-python/" rel="noopener ugc nofollow" target="_blank"><em class="ni"/></a><em class="ni">。</em></p></div></div>    
</body>
</html>