<html>
<head>
<title>Design Pattern Synergies: Exploring the Decorator Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式协同:探索装饰模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/design-pattern-synergies-exploring-the-decorator-pattern-7c29bdd1ab1b?source=collection_archive---------12-----------------------#2020-07-25">https://levelup.gitconnected.com/design-pattern-synergies-exploring-the-decorator-pattern-7c29bdd1ab1b?source=collection_archive---------12-----------------------#2020-07-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b60b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章中，我将谈论一下<a class="ae ko" href="https://en.wikipedia.org/wiki/Decorator_pattern" rel="noopener ugc nofollow" target="_blank">装饰者</a> <a class="ae ko" href="https://en.wikipedia.org/wiki/Design_pattern" rel="noopener ugc nofollow" target="_blank">设计模式</a>。</p><p id="d780" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更具体地说，我将展示一些<strong class="js iu">装饰器</strong>模式与其他<strong class="js iu">设计模式</strong>的组合，以实现我们代码更好的可读性和可维护性。我将在本文的代码段中使用<strong class="js iu"> Java </strong>，但是所有的例子都应该适用于任何面向对象的语言。</p><p id="d2ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在检查设计模式协同之前，让我们确保对<strong class="js iu">装饰</strong>模式有一个共同的理解。</p><h1 id="21d7" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">装饰图案定义</h1><blockquote class="ln lo lp"><p id="4234" class="jq jr lq js b jt ju jv jw jx jy jz ka lr kc kd ke ls kg kh ki lt kk kl km kn im bi translated">在面向对象编程中，装饰模式是一种设计模式，它允许动态地将行为添加到单个对象中，而不会影响同一类中其他对象的行为。-维基百科</p></blockquote><p id="06dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">书中提供的另一个定义<a class="ae ko" href="https://www.oreilly.com/library/view/head-first-design/0596007124/" rel="noopener ugc nofollow" target="_blank">头先设计模式</a>如下:</p><blockquote class="ln lo lp"><p id="4248" class="jq jr lq js b jt ju jv jw jx jy jz ka lr kc kd ke ls kg kh ki lt kk kl km kn im bi translated">装饰模式动态地给对象附加额外的责任。Decorators为扩展功能提供了子类化的灵活替代方案。-头部优先设计模式</p></blockquote><h1 id="51ca" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">理解装饰模式</h1><p id="0398" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated"><strong class="js iu">装饰器</strong>模式有一些非常<em class="lq">强大的</em>特性。</p><p id="8fd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">装饰模式动态地给一个对象附加额外的责任。</strong></p><p id="fb62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着人们可以<em class="lq">在<a class="ae ko" href="https://en.wikipedia.org/wiki/Runtime_(program_lifecycle_phase)" rel="noopener ugc nofollow" target="_blank">运行时</a>修饰</em>一个对象，并为该对象添加额外的功能。</p><p id="ff2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">想象一下这个例子。我们有一个将文件写入文件系统的程序。</p><p id="b971" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可以用如下代码表示:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/cdbbe3972c99ac864b3f08e95d356a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*Vw-wuGhZzhHn7YDHLj1_dw.png"/></div></figure><p id="bc4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在某些时候，我们决定文件应该被压缩！然后通过遵循<strong class="js iu">装饰</strong>模式，我们可以添加这个额外的功能<em class="lq">而不改变任何相关的类</em>！</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mh"><img src="../Images/928eccde50bbdec31b10576748d2a986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wd84smGDGmYtGBRESigvHQ.png"/></div></div></figure><p id="185d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lq">请记住，如果在其中一个包装器的构建过程中出现错误，则</em> <code class="fe mm mn mo mp b"><em class="lq">try-with-resources</em></code> <em class="lq">可能会导致</em> <a class="ae ko" href="https://stackoverflow.com/questions/12552863/correct-idiom-for-managing-multiple-chained-resources-in-try-with-resources-bloc" rel="noopener ugc nofollow" target="_blank"> <em class="lq">无法关闭资源</em> </a> <em class="lq">。</em></p><p id="69fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了使运行时的<em class="lq">变化</em>部分更加明显，假设我们的一些用户想要选择是否压缩文件。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mq"><img src="../Images/fb18282d97d207a8e9d711fd121f51ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bRW6Jlx-BXfH3mThtvD23Q.png"/></div></div></figure><p id="89f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看，在上面的例子<em class="lq">中，行为可以在运行时</em>决定。</p><p id="d43f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个案例的关键点是<strong class="js iu">装饰器</strong>都实现了<a class="ae ko" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/OutputStream.html" rel="noopener ugc nofollow" target="_blank">输出流</a>接口。</p><p id="736c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个<strong class="js iu">装饰器</strong>都围绕<strong class="js iu">接口</strong>定义的方法添加了额外的功能。例如，<strong class="js iu"> GZIPOutputStream </strong>将包装<code class="fe mm mn mo mp b">os.write("Hello, World!".getBytes())</code>并压缩数据。然后调用<strong class="js iu"> FileOutputStream </strong>的<code class="fe mm mn mo mp b">write()</code>方法，将压缩数据写入指定文件。</p><p id="f5fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想这是最常见也可能是最强大的<strong class="js iu">装饰器</strong>模式。你可能有一个<strong class="js iu">输出流</strong>对象，它已经被<em class="lq">包装了十几次</em>，每一次都用<strong class="js iu">装饰器</strong>增加了一点点功能。</p><p id="fc1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了上面描述的情况，有时候我们可能需要给一个对象添加额外的功能。可能不遵循<em class="lq">通用接口</em>的功能。</p><p id="d437" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们仍然可以这样做。考虑下面的例子，我们想额外产生一个已创建文件的散列并打印给用户。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mr"><img src="../Images/c51c1ced7f5ecc07edfd3399940fe759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T822F5tyYopmHca3HkwGHA.png"/></div></div></figure><p id="43a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看，我们为<a class="ae ko" href="https://en.wikipedia.org/wiki/Checksum" rel="noopener ugc nofollow" target="_blank">校验和</a>的计算增加了一些额外的功能。这意味着现在我们依赖于代码中<strong class="js iu"> cos </strong>变量的存在，该变量具有<em class="lq">显式</em>类型的<strong class="js iu"> CheckedOutputStream </strong>。</p><p id="7b94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际上这并不坏。另一方面，如果我们想通过不为每个<strong class="js iu">装饰器</strong>使用单独的变量来稍微不同地编写<em class="lq">带资源尝试</em>，事情会变得复杂。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ms"><img src="../Images/457f5fb2ae607843ce0e00f0a6d703af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xIo9XN7eA7QaqTEkuqiySg.png"/></div></div></figure><p id="2294" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，在那种特定的情况下，有一种好的方法可以通过保存对<code class="fe mm mn mo mp b">Adler32</code>对象的引用来获得<strong class="js iu">校验和</strong>。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mt"><img src="../Images/54a9e56406201e7245b2155b80522fe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BMpd9RWFn-rOzQuspe8d6Q.png"/></div></div></figure><p id="b403" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">情况并非总是如此，因为我们可能需要访问特定包装器的字段。如果我们需要访问的特定<strong class="js iu">装饰器</strong>是堆栈中的最后一个，那么访问它就很容易。否则，保留特定装饰器对象的引用是唯一的选择。</p><h1 id="c764" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">输出流装饰器</h1><p id="f214" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">我们在前面的例子中看到的大多数<strong class="js iu">装饰器</strong>都是<a class="ae ko" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/package-summary.html" rel="noopener ugc nofollow" target="_blank"> java.io </a>包的一部分。<strong class="js iu">装饰者</strong>使用的基本接口是<a class="ae ko" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/OutputStream.html" rel="noopener ugc nofollow" target="_blank">输出流</a>。</p><p id="5ae0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个<strong class="js iu">装饰器</strong>有很多实现。人们可以通过检查<a class="ae ko" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/OutputStream.html" rel="noopener ugc nofollow" target="_blank">输出流</a>接口的<strong class="js iu"> Javadoc </strong>来找到它们。</p><p id="f787" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">输出流</strong>的<strong class="js iu">直接已知子类</strong>有:</p><ul class=""><li id="3901" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated"><a class="ae ko" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/ByteArrayOutputStream.html" rel="noopener ugc nofollow" target="_blank"> ByteArrayOutputStream </a></li><li id="a63e" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">文件输出流</li><li id="4282" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated"><a class="ae ko" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/FilterOutputStream.html" rel="noopener ugc nofollow" target="_blank"> FilterOutputStream </a></li><li id="0597" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated"><a class="ae ko" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/ObjectOutputStream.html" rel="noopener ugc nofollow" target="_blank">对象输出流</a></li><li id="f1b3" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated"><a class="ae ko" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PipedOutputStream.html" rel="noopener ugc nofollow" target="_blank"> PipedOutputStream </a></li></ul><p id="8015" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除此之外，<strong class="js iu"> FilterOutputStream </strong>的<strong class="js iu">直接已知子类</strong>还有:</p><ul class=""><li id="9c02" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated"><a class="ae ko" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/BufferedOutputStream.html" rel="noopener ugc nofollow" target="_blank">缓冲输出流</a></li><li id="4116" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated"><a class="ae ko" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/zip/CheckedOutputStream.html" rel="noopener ugc nofollow" target="_blank">检查输出流</a></li><li id="3c03" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated"><a class="ae ko" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/crypto/CipherOutputStream.html" rel="noopener ugc nofollow" target="_blank">密码输出流</a></li><li id="f236" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated"><a class="ae ko" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/DataOutputStream.html" rel="noopener ugc nofollow" target="_blank">数据输出流</a></li><li id="a7fa" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated"><a class="ae ko" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/zip/DeflaterOutputStream.html" rel="noopener ugc nofollow" target="_blank">放气输出流</a></li><li id="9189" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated"><a class="ae ko" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/security/DigestOutputStream.html" rel="noopener ugc nofollow" target="_blank"> DigestOutputStream </a></li><li id="f932" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated"><a class="ae ko" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/zip/InflaterOutputStream.html" rel="noopener ugc nofollow" target="_blank">通货膨胀输出流</a></li><li id="3d05" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated"><a class="ae ko" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintStream.html" rel="noopener ugc nofollow" target="_blank"> PrintStream </a></li></ul><p id="d9cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> FilterOutputStream </strong>有这么多子类的原因是<em class="lq">这个类是所有过滤输出流的类的超类。这些流位于已经存在的输出流(底层输出流)之上，它将输出流用作其基本的数据接收器，但可能会沿途转换数据或提供附加功能。</em></p><p id="b8ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">等等！还有<em class="lq">更有</em>！<strong class="js iu">放气输出流</strong>具有以下<strong class="js iu">直接已知子类</strong>:</p><ul class=""><li id="6119" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated"><a class="ae ko" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/zip/GZIPOutputStream.html" rel="noopener ugc nofollow" target="_blank"> GZIPOutputStream </a></li><li id="f8dd" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated"><a class="ae ko" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/zip/ZipOutputStream.html" rel="noopener ugc nofollow" target="_blank"> ZipOutputStream </a></li></ul><p id="49e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后<strong class="js iu">的ZipOutputStream </strong>有作为<strong class="js iu">直接已知子类的</strong>JarOutputStream。</p><p id="8812" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> PrintStream </strong>拥有作为<strong class="js iu">直接已知子类</strong>的<strong class="js iu"> LogStream </strong>，然而现在<strong class="js iu">已弃用</strong>。</p><p id="4f3d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们算上<strong class="js iu">所有的</strong>，我们总共有<strong class="js iu"> 15 </strong>个具体的<strong class="js iu">输出流</strong>实现。</p><p id="44b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，一个人必须非常熟悉<code class="fe mm mn mo mp b">java.io</code> <strong class="js iu"> API </strong>才能充分发挥它的潜力。</p><p id="f4a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">装饰器</strong>模式也用于<strong class="js iu"> API </strong>的其他部分，例如<a class="ae ko" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InputStream.html" rel="noopener ugc nofollow" target="_blank">输入流</a>。</p><h1 id="9297" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">装饰模式的缺点</h1><p id="203d" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">到现在为止，<strong class="js iu">装饰器</strong>模式的问题应该很明显了。</p><ul class=""><li id="ed8e" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">可能存在太多<strong class="js iu">装饰器</strong>接口的实现。一个人可能很难找到所有的实现或者知道如何使用它们。注意<strong class="js iu"> OutputStream </strong>类甚至没有全部包含在这种<strong class="js iu">装饰器</strong>专用的包中！</li><li id="6eac" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">很难访问未被基本接口定义的方法，尤其是当添加额外功能的特定<strong class="js iu">装饰器</strong>被<strong class="js iu">装饰器</strong>的许多其他实例包装时。</li></ul><p id="ee58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面我们将尝试通过添加更多的<strong class="js iu">设计模式</strong>来解决这两个问题！</p><h1 id="dcf4" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">用于比较的代码</h1><p id="28de" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">在继续之前，让我们设置一些我们稍后将尝试改进的公共代码:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/438107c79563c3fe6d4907bf7944a5c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*WMI2JMgq1x2WT5TkKdIcOQ.png"/></div></figure><p id="783b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本例中，我们保留了一个<strong class="js iu"> OutputStream </strong>对象，用于在其上执行所有基本操作，我们保留了对<strong class="js iu"> CheckedOutputStream </strong>和<strong class="js iu"> PrintStream </strong>装饰器的引用，因此我们可以调用这些<strong class="js iu"> 2 </strong>类型专门提供的一些方法。</p><p id="ec2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了清楚起见，我们现在省略<em class="lq"> try-with-resources </em>。</p><h1 id="206d" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">使用工厂方法初始化装饰器</h1><p id="8549" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">初始化共享一个公共<strong class="js iu">接口</strong>的对象时想到的第一个<strong class="js iu">设计模式</strong>可能是<a class="ae ko" href="https://en.wikipedia.org/wiki/Factory_method_pattern" rel="noopener ugc nofollow" target="_blank">工厂方法</a>模式。</p><p id="e911" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常一个<strong class="js iu">工厂方法</strong>接受一个或几个参数。我们案例中的工厂方法可能是这样的:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nj"><img src="../Images/a476067ddd29cd927d9f370bd5814280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FJgZMKL6iPTiiIASL9cokg.png"/></div></div></figure><p id="0607" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在代码中可以这样使用:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nk"><img src="../Images/a2ebf366360d61934199fa6aec0d3707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EHG8auBEx4AUIOU0Pk2oAQ.png"/></div></div></figure><p id="85e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，我们取得了什么成就？</p><p id="e192" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">优点</strong></p><ul class=""><li id="e02f" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">初始化修饰对象的代码更少。</li><li id="b674" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">我们想要支持的所有可能的decorators都可能被factory方法初始化。很容易检查一个方法、它的参数和文档，并且知道哪种装饰器是可用的。</li><li id="9592" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">具体装饰类的使用被封装在<strong class="js iu">工厂方法</strong>中，这使得未来的修改只需很少的重构工作。</li></ul><p id="eb22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> CONS </strong></p><ul class=""><li id="8612" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">没有办法访问内部装饰器。</li><li id="2426" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">工厂方法可能会因为过多的参数而变得过于拥挤。</li><li id="99a3" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">异常处理和对象初始化可能有点复杂。</li></ul><p id="3310" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总的来说，我个人认为上述解决方案没有任何好处。</p><p id="176a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也许多个工厂方法的实现有一点不同，每种情况一个可能更有益。</p><p id="344a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑下面的<strong class="js iu">类</strong>:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nl"><img src="../Images/e1b42f14c2e4c2fded39374255c4ebcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rv6AMFMDmY3cQowNlK4LpA.png"/></div></div></figure><p id="c85f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">嗯，这样我们实际上将每个具体的<strong class="js iu">输出流</strong>的初始化包装到了一个单独的方法中。这将被用于这样的行动:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nm"><img src="../Images/1758aac3ab5f80421172a8c7db453c32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t4fEhzSJY4l1yJR9lCCe1w.png"/></div></div></figure><p id="5f36" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你考虑一下，这就像调用具体的构造函数，但是有一些额外的好处！</p><p id="699f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，我们可以返回接口类型，但我没有像本例中那样实现它，以避免额外的<strong class="js iu">类型转换</strong>。</p><p id="0b18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">额外优势</strong></p><ul class=""><li id="b762" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">通过浏览<strong class="js iu"> OutputStreamFactory </strong>类的(最好是有文档记录的)方法，很容易找到所有可用的<strong class="js iu">装饰器</strong>。所有现代的IDE都应该支持自动完成。</li><li id="1325" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">封装的类可以通过最小的重构来改变(特别是如果我们将返回<strong class="js iu"> OutputStream </strong>对象而不是具体的类)。</li></ul><p id="be71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总的来说，我认为只有在周围有太多装饰者的情况下，拥有这样的<em class="lq">类才有好处。<strong class="js iu">程序员</strong>将可以自由地花更少的时间寻找外部文档，而花更多的时间依靠日常的行业工具，以便轻松地找到所需的信息。</em></p><p id="7171" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> CONS </strong></p><ul class=""><li id="a1cb" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">我们以前的其他缺点仍然存在。</li><li id="3d76" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated"><strong class="js iu"> API </strong>过于<em class="lq">冗长。静态导入工厂类使它不那么冗长，但是可读性可能会差一些，因为所有的工厂方法都可能被误认为是本地方法。</em></li></ul><h1 id="a67e" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">使用生成器模式进行装饰</h1><p id="8e2c" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">另一种流行的对象创建模式是<a class="ae ko" href="https://en.wikipedia.org/wiki/Builder_pattern" rel="noopener ugc nofollow" target="_blank">构建器模式</a>。</p><p id="9884" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用<a class="ae ko" href="https://en.wikipedia.org/wiki/Joshua_Bloch" rel="noopener ugc nofollow" target="_blank"> Josh Bloch在<a class="ae ko" href="https://www.amazon.co.uk/Effective-Java-Second-Joshua-Bloch/dp/0321356683" rel="noopener ugc nofollow" target="_blank"> Effective Java </a>中描述的</a>模式变体。</p><p id="84a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这应该是这样的:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/c9c356fe18c03f41a448c86acfc5e70a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*Jy0QEApBoZngHk3XvGiryQ.png"/></div></figure><p id="d406" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个可以这样用:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi no"><img src="../Images/2f15a2629f891df4f0ac637437fdeeb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*gMsskfMVAr5_s1JnCORqJA.png"/></div></figure><p id="5101" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们来评价一下这种模式吧！</p><p id="23c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">优点</strong></p><ul class=""><li id="c87a" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">在<strong class="js iu">构建器</strong>类下可以很容易地找到<strong class="js iu">装饰器</strong>。</li><li id="4e04" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">语法足够短。</li><li id="d975" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">我们可以使用创建的构建器来创建许多类似的对象。</li></ul><p id="4f33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> CONS </strong></p><ul class=""><li id="834e" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">我们不能访问中级装饰者。例如，在上面的代码中，我们将<strong class="js iu">输出流</strong>转换为最后一个使用的<strong class="js iu">打印流</strong>。例如，我们不能直接访问<strong class="js iu">检查输出流</strong>。</li><li id="96ab" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">装饰的顺序在<code class="fe mm mn mo mp b">build()</code>方法中是固定的。我们不能用同一个装饰器进行多次装饰，或者在不使实现过于复杂的情况下轻易改变顺序。但是，这种结构对于大多数常见情况来说已经足够了。</li></ul><p id="32ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">几个音符。</p><ol class=""><li id="ed38" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn np na nb nc bi translated">我们可以让builder类实现<strong class="js iu"> Autocloseable </strong>，以便<strong class="js iu">正确释放</strong>在<em class="lq"> try-with-resources </em>中使用的资源。</li><li id="17d9" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn np na nb nc bi translated">如果我们想将<strong class="js iu"> false </strong>传递给构建器方法，我们可以省略对它们的调用，因为这是默认值。此外，我们可以实现更流畅的<a class="ae ko" href="https://en.wikipedia.org/wiki/Fluent_interface" rel="noopener ugc nofollow" target="_blank"/><strong class="js iu">API</strong>。如果我们根本不接受论点。例如，为上一个示例调用一个更多的<strong class="js iu"> fluentAPI </strong>如下所示:</li></ol><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/effbc6871b23456046c301927a4c697a.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*8I6hK2JbhOujs2U1V7Vicg.png"/></div></figure><p id="b5e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，在某些情况下，有参数会让使用<strong class="js iu"> API </strong>更容易一些。考虑这样一个例子，其中基于某些条件在运行时添加了<strong class="js iu">压缩的</strong>功能。</p><p id="06b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我认为我个人最喜欢这种方式。它有一些粗糙的边缘，但它提供了一个美丽和可读的界面。</p><h1 id="21ad" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">现在怎么办？更多生成器模式</h1><p id="ca47" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">Bloch描述的构建器模式有一些重要的好处。</p><ol class=""><li id="17aa" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn np na nb nc bi translated">与使用<strong class="js iu"> setters </strong>方法初始化对象的<a class="ae ko" href="https://en.wikipedia.org/wiki/JavaBeans" rel="noopener ugc nofollow" target="_blank"> Javabean </a>相反，这样我们可以确保创建的对象将被完全初始化，并在使用它之前具有预期的状态。</li><li id="dcee" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn np na nb nc bi translated">工厂可以被重用并创建类似对象的其他实例。</li></ol><p id="f9a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就装饰者的建造者而言，我们可能会为了其他利益而忽略这些利益。构建器可以这样写:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nr"><img src="../Images/fa70e58a8bcd50a124d4ea1c0083e04c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*GvH-cqntyiCm7onewyiIlA.png"/></div></div></figure><p id="019a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们已经失去了前面提到的第二个利益。然而，我们获得了其他的东西。我们可以通过这种方式访问中间装饰者:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/e39555a9c22089061094949aacfbd387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*jBsoU7nqd4gRDfXTPFHvUg.png"/></div></figure><p id="15d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果需要，我们可以这样多次包装一个装饰器。此外，装饰器的应用顺序不再固定。</p><p id="c24a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们所看到的，与原来的相比，<em class="lq">建筑</em>物体的这种变化可能通常更适合于建筑<strong class="js iu">装饰者</strong>。</p><p id="b825" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想我们已经或多或少地讨论完了初始化装饰者实例的话题。在这个过程中，我们熟悉了每一种方法，以及它带来的好处和带来的问题。</p><p id="e2f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看能否解决第二个问题。当我们<strong class="js iu">用装饰器装饰</strong>一个对象时，它增加了<strong class="js iu">装饰器</strong>接口中没有定义的额外功能，我们必须保留对具体类的引用。</p><h1 id="17d1" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">遇见适配器</h1><blockquote class="ln lo lp"><p id="9b47" class="jq jr lq js b jt ju jv jw jx jy jz ka lr kc kd ke ls kg kh ki lt kk kl km kn im bi translated">在软件工程中，适配器模式是一种软件设计模式(也称为包装器，与装饰器模式共享的替代命名)，它允许将现有类的接口用作另一个接口。[1]它通常用于使现有的类与其他类一起工作，而无需修改它们的源代码。-维基百科</p></blockquote><p id="7088" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了解决访问中间具体类的问题，我们可以创建一个公开所有中间接口的<a class="ae ko" href="https://en.wikipedia.org/wiki/Adapter_pattern" rel="noopener ugc nofollow" target="_blank">适配器</a>。</p><p id="6222" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们示例中的适配器可能如下所示:</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="0a08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我在这个例子中只实现了一些方法，但是重点是实现添加额外功能的<strong class="js iu">装饰器</strong>的<strong class="js iu">所有</strong>。</p><p id="720e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这样的适配器，我们可以直接访问每一个，即使它没有被所有的装饰者实现。如果实现不存在，将抛出<strong class="js iu">异常</strong>。</p><p id="ca08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个可以这样用:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nv"><img src="../Images/6dfd20777a771d55442bad016b010a1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*q2AjEYz3FjrTQRH1Hz-osA.png"/></div></div></figure><p id="97e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这使用了之前的基于<em class="lq"> Bloch的</em> <strong class="js iu"> Builder </strong>类。但是，需要进行一些修改。<code class="fe mm mn mo mp b">build()</code>方法应该是这样的:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nw"><img src="../Images/7212ed2fea9cc851c9e37e6d1bba648a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MKKK14kXuDy4MxVO5sfisw.png"/></div></div></figure><p id="4812" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">优点</strong></p><ul class=""><li id="7177" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">我们可以访问所有的中间装饰器功能，而不会泄漏对中间具体类的引用。</li><li id="5606" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">如果实现没有抛出异常并将控制权委托给客户端，或者以某种方式无声地或优雅地失败，我们就有了控制权。</li></ul><p id="76f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> CONS </strong></p><ul class=""><li id="f35a" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">实现适配器的更多代码行。</li><li id="42a2" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">维护成本增加。对于每个偏离主接口的新装饰器，我们必须将新方法添加到<strong class="js iu">适配器</strong>。对于任何变化，我们可能必须相应地更新<strong class="js iu">适配器</strong>。</li><li id="df57" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">构建器<code class="fe mm mn mo mp b">build()</code>方法有点复杂。</li></ul><p id="7489" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不过，总的来说，我觉得在某些场合，它提供了一些有用的功能。</p><h1 id="9d67" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">结论</h1><p id="0891" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">在本文中，我们探索了<strong class="js iu">装饰器</strong>模式与<strong class="js iu">工厂方法</strong>、<strong class="js iu">构建器</strong>和<strong class="js iu">适配器</strong>模式的各种组合。希望我们都能更好地理解每种组合提供了什么。</p><p id="a700" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">无论如何不要走出去，开始使用这里演示的每一点设计模式组合。</p><p id="9b50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在大多数情况下，单独使用<strong class="js iu">装饰器</strong>模式是可以的，尤其是当装饰器的总数很低的时候。只是不要忘记提供必要的文档，也许可以将它们都放在同一个包/目录下。</p><p id="b101" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不要急着添加你不会很快需要或永远不需要的东西。正如您所看到的，上述许多组合增加了复杂性，需要更多的维护工作。保持简单，但要记住问题出现时如何解决。</p><p id="e252" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上述规则的唯一例外可能是您正在构建一个供外部使用的<strong class="js iu"> API </strong>。也许提供一个不会在未来引入突破性变化的<strong class="js iu"> API </strong>是很重要的。</p><p id="a91f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，一些模式如<strong class="js iu">适配器</strong>、<strong class="js iu">装饰器</strong>或<a class="ae ko" href="https://en.wikipedia.org/wiki/Proxy_pattern" rel="noopener ugc nofollow" target="_blank">、T9】代理 </a>共享类似的实现。不要搞混了，有时候差别很微妙。模式的名称首先表明了意图。具体的实现通常是明确定义的，但这是第二位的。</p><p id="5df5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望你已经发现以上任何一点有用。直到下一次保持编码<strong class="js iu">智能</strong> <em class="lq"> :-) </em></p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="cb2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lq">原载于</em><a class="ae ko" href="https://masterex.github.io/archive/2020/07/25/decorator-design-pattern-synergies.html" rel="noopener ugc nofollow" target="_blank"><em class="lq">https://masterex . github . io</em></a><em class="lq">。</em></p></div></div>    
</body>
</html>