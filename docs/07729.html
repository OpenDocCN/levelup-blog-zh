<html>
<head>
<title>Why You Should Graduate from Using Auto-Increment ID for Database Record</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么您应该放弃使用数据库记录的自动递增ID</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-you-should-graduate-from-using-auto-increment-id-for-database-record-1c1f584e958a?source=collection_archive---------21-----------------------#2021-03-07">https://levelup.gitconnected.com/why-you-should-graduate-from-using-auto-increment-id-for-database-record-1c1f584e958a?source=collection_archive---------21-----------------------#2021-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3cf6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">插入新的数据库记录时，从序列号开始移动。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/dee585ef91a62a9afdb5e9461447c0dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gUEKjWyAO8cT54qYngkxLg.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">数据库模式。</figcaption></figure><p id="97ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在任何数据库中，我们总是需要一个标识符来区分不同的记录，通常称为主键。现在，假设我们想要创建一个表来记录用户信息。我们经常会创建这样的表格:</p><pre class="km kn ko kp gt lb lc ld le aw lf bi"><span id="6567" class="lg lh iq lc b gy li lj l lk ll">create table user(<br/>  id serial primary key,<br/>  full_name varchar<br/>);</span></pre><p id="7a19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们中的大多数人习惯于创建主键序列。记住<code class="fe lm ln lo lc b">serial</code>是通过<code class="fe lm ln lo lc b">sequence</code>实现的，它的作用有点像计数器。每当我们向当前表中插入新数据时，下一个序列值就会递增。例如，如果当前表中有5行，最后一行的id为5，那么我们插入到表中的下一个数据将创建一个id为6的记录。</p><h1 id="8c13" class="lp lh iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">那么使用序列号作为主键有什么问题呢？</h1><h2 id="ccd7" class="lg lh iq bd lq mm mn dn lu mo mp dp ly jy mq mr mc kc ms mt mg kg mu mv mk mw bi translated">不想要的信息泄露</h2><p id="6671" class="pw-post-body-paragraph jn jo iq jp b jq mx js jt ju my jw jx jy mz ka kb kc na ke kf kg nb ki kj kk ij bi translated">假设您创建了一个页面来查看用户配置文件，并且您创建了一个格式为<code class="fe lm ln lo lc b">/users/user_id</code>的路径，其中<code class="fe lm ln lo lc b">user_id</code>基本上是指用户表上的主键。如果您想计算给定表中的行数，您所要做的就是让系统生成一个新的实体并检查它的id。想象你去<em class="nc">脸书</em>，创建一个新账户。你可以大致知道<em class="nc">脸书</em>里面的总用户记录。</p><h2 id="7916" class="lg lh iq bd lq mm mn dn lu mo mp dp ly jy mq mr mc kc ms mt mg kg mu mv mk mw bi translated">易迭代实体</h2><p id="ba00" class="pw-post-body-paragraph jn jo iq jp b jq mx js jt ju my jw jx jy mz ka kb kc na ke kf kg nb ki kj kk ij bi translated">假设前一个端点对公众开放。即使是最没有经验的攻击者现在也可以通过从端点1到n开始循环并点击端点来获取我们的表信息。抓取所有实体变得非常容易。</p><h2 id="6784" class="lg lh iq bd lq mm mn dn lu mo mp dp ly jy mq mr mc kc ms mt mg kg mu mv mk mw bi translated">水平可伸缩性的瓶颈</h2><p id="ce87" class="pw-post-body-paragraph jn jo iq jp b jq mx js jt ju my jw jx jy mz ka kb kc na ke kf kg nb ki kj kk ij bi translated">我们的桌子迟早会变得很大，我们希望它仍然能尽可能快地为用户服务。首先，垂直增加数据库大小的选择是显而易见的，从2核4 GB增加到4核8 GB，等等。我们的数据库迟早会达到增长的极限。然后我们学习水平扩展，我们可以用几个主数据库来分担输入负载。</p><p id="fc29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在假设我们有5个主数据库来处理新记录的插入，我们像以前一样使用<code class="fe lm ln lo lc b">serial int</code>作为主键来设置表定义。自然，我们不希望数据库A和数据库B具有引用不同用户的相同id值。id为1的记录应该属于服务中的一个用户。这是一个重要的需求，因为我们通常有其他表使用外键或对用户id的引用。假设我们在数据库A中有id为1的用户A，在数据库B中有id为1的用户B，然后我们有一个id为1和用户id为1的地址表。它属于用户A还是用户B？因此，我们需要在所有数据库中保持一个唯一的id。</p><p id="2e53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了保持用户id的惟一性，我们需要一种方法在将数据插入任何数据库之前存储实际的last <code class="fe lm ln lo lc b">sequence</code>值。假设我们用最简单的方法来做，我们要求所有的数据库返回它的最后一个<code class="fe lm ln lo lc b">sequence</code>值，取最大的一个值并加1。正如您所看到的，这引入了一个瓶颈，因为您需要运行对所有数据库的查询来查找下一个增量id。</p><p id="e0f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我看过一个服务，为了解决这个问题，他们把<code class="fe lm ln lo lc b">sequence</code>放在另一个数据库里，比如<code class="fe lm ln lo lc b">Redis</code>，这个数据库仍然足够快，可以提供信息。我反对使用另一个数据库，比如<code class="fe lm ln lo lc b">Redis</code>，因为用一个不同的表来计算下一个<code class="fe lm ln lo lc b">sequence</code>值很奇怪。在使用像<code class="fe lm ln lo lc b">Redis</code>这样的数据库的最坏情况下，当<code class="fe lm ln lo lc b">Redis</code>重启时，我们只是失去了<code class="fe lm ln lo lc b">sequence</code>的踪迹。此外，我们添加了太多的编排，只是为了做像插入新记录这样简单的事情。正如你所看到的，虽然这在一定程度上可能行得通，但这显然不是一个合适的解决方案。</p><h1 id="834d" class="lp lh iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">那么解决办法是什么呢？</h1><p id="0244" class="pw-post-body-paragraph jn jo iq jp b jq mx js jt ju my jw jx jy mz ka kb kc na ke kf kg nb ki kj kk ij bi translated">不使用<code class="fe lm ln lo lc b">serial id</code>，而是使用<code class="fe lm ln lo lc b">uuid</code>作为主键。<code class="fe lm ln lo lc b">UUID</code>代表<em class="nc">通用唯一标识符。</em> <code class="fe lm ln lo lc b">UUID</code>肯定是<em class="nc">通用惟一的</em>，这使它成为主键的良好候选。</p><p id="7f3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">记住<code class="fe lm ln lo lc b">UUID</code>值是随机产生的。该属性意味着:</p><ul class=""><li id="c1fe" class="nd ne iq jp b jq jr ju jv jy nf kc ng kg nh kk ni nj nk nl bi translated">它并不公开我们的表中当前有多少记录之类的信息。</li><li id="fb1f" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">它不容易被迭代，因为它是随机的。</li><li id="e4bf" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">它不会在我们的系统中引入水平可伸缩性的瓶颈，因为我们不需要找出下一个<code class="fe lm ln lo lc b">sequence</code>值是什么。我们可以生成一个新的<code class="fe lm ln lo lc b">UUID</code>并将其插入到任何数据库中。</li></ul><p id="24c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，它解决了使用<code class="fe lm ln lo lc b">serial id</code>的所有问题。</p><h2 id="b45e" class="lg lh iq bd lq mm mn dn lu mo mp dp ly jy mq mr mc kc ms mt mg kg mu mv mk mw bi translated">使用<code class="fe lm ln lo lc b">UUID</code>有什么弊端？</h2><p id="682b" class="pw-post-body-paragraph jn jo iq jp b jq mx js jt ju my jw jx jy mz ka kb kc na ke kf kg nb ki kj kk ij bi translated">基本上，我们没有一个有保证的唯一性。然而，碰撞的概率相当小。请记住，在极不可能发生UUIDs冲突的情况下，由于主键约束，它将被DB捕获。在最坏的情况下，我们可以尝试用新生成的UUID重新插入新数据。</p><p id="7737" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于好奇的灵魂来说，你可以在这里详细阅读碰撞概率<a class="ae nr" href="https://en.wikipedia.org/wiki/Universally_unique_identifier#Collisions" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="d4ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">瞧，我们完成了。现在，你们应该更好地理解为什么我们应该放弃使用自动递增或<code class="fe lm ln lo lc b">serial id</code>而使用<code class="fe lm ln lo lc b">UUID</code>了。</p></div></div>    
</body>
</html>