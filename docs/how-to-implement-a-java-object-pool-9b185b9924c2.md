# 如何实现 Java 对象池

> 原文：<https://levelup.gitconnected.com/how-to-implement-a-java-object-pool-9b185b9924c2>

![](img/b29abac247edd1b8b3f7552b9d275ba7.png)

托马斯·杜莫提尔在 [Unsplash](https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

**什么是对象池？**

池化并不是一项新技术，它更像是一种软件设计模式，主要功能是缓存一组已初始化的对象，随时可用。

在大多数情况下，对象池缓存那些创建成本太高或者需要重复创建和使用的对象。从池中获取对象的时间是可预测的，但是创建新对象的时间是不确定的。

当需要一个新对象时，一个对象被借出到池中，然后对象池将当前对象标记为正在使用，并在使用后将其返回到对象池，以便可以再次借出。

对象池场景的常见用法:

*   对象创建成本太高。
*   需要频繁创建大量重复对象，造成大量内存碎片。
*   不要同时使用太多的对象。
*   常见的特定场景如数据库连接池、线程池等。

**对象池可以解决哪些问题？**

如果对象的创建成本很高，比如建立到数据库的连接需要很长时间，那么在没有使用池技术的情况下，我们的查询过程可能是这样的。

*   查询 1:建立数据库连接->发起查询->接收响应->关闭连接。
*   查询 2:建立数据库连接->发起查询->接收响应->关闭连接。
*   查询 3:建立数据库连接->发起查询->接收响应->关闭连接。

在这种模式下，每个查询都要重新建立和关闭连接，因为建立连接是一个耗时的操作，所以这种模式会影响程序的整体性能。

那么使用联营的想法是什么样的呢？同样的过程转化为以下步骤。

*   初始化:建立 N 个数据库连接->缓存它们。
*   查询 1:从缓存中借用数据库连接->发起查询->接收响应->将数据库连接对象返回到缓存中。
*   查询 2:从缓存中借用数据库连接->发起查询->接收响应->将数据库连接对象返回到缓存中。
*   查询 3:从缓存中借用数据库连接->发起查询->接收响应->将数据库连接对象返回到缓存中。

使用池化思想后，不频繁创建和关闭数据库连接，而是启动后初始化 N 个连接供后续使用，使用后返回对象，从而提高程序的整体性能。

**如何实现对象池？**

通过上面的例子，还可以发现统筹思想的几个关键步骤:`initialization`、`lending`、`returning`。

上面没有显示销毁步骤。在某些场景中，还需要对象销毁的过程，比如释放连接。

接下来，我们手动实现一个简单的对象池，以加深我们对对象池的理解。主要是设置一个对象池管理类，然后在里面实现对象的初始化、借出、归还销毁等操作。

代码相对简单，只是一个简单的例子，让我们通过池化一个`Redis`连接对象`Jedis`来演示如何使用它。

实际上，`Jedis`已经有了对应的`Jedis`池化管理对象`JedisPool`，但是为了演示对象池的实现，我们不会使用官方提供的`JedisPool`。

这里就不介绍启动 Redis 服务了。假设您已经有一个 Redis 服务，下面介绍用 Java 连接 Redis 所需的 Maven 依赖项。

正常情况下如何使用 Jedis 对象。

如果使用上面的对象池，可以像下面这样使用。

输出日志:

```
Added object: 1556956098
Added object: 1252585652
Loaned objects: 1252585652
redis get: name_foo
Returned object: 1252585652
All objects have been destroyed
There are no objects that can be lent out
```

如果您使用 JMH 来比较使用对象池的 Redis 查询与创建 Redis 连接然后查询关闭连接的正常方式的性能，您会发现两者的性能有很大不同。

以下是测试结果。可以发现，使用对象池的性能大约是非池方法的 5 倍。

```
Benchmark                   Mode  Cnt      Score       Error  Units
MyObjectPoolTest.test      thrpt   15   2612.689 ±   358.767  ops/s
MyObjectPoolTest.testPool  thrpt    9  12414.228 ± 11669.484  ops/s
```

**有哪些开源对象池工具？**

上面自己实现的对象池总是有点简陋。事实上，开源工具中已经有非常有用的对象池实现，比如 Apache 的`commons-pool2`工具。许多开源工具中的对象池都是基于这个工具实现的。下面介绍了如何使用该工具。

添加 maven 依赖项:

在`commons-pool2`对象池工具中有几个关键的类。

*   `PooledObjectFactory`类是一个工厂接口，用于创建、验证和销毁您想要共享的对象。
*   `GenericObjectPool`类是一个通用对象池管理类，可以执行诸如借出和归还对象的操作。
*   `GenericObjectPoolConfig`类是对象池的配置类，可以配置对象的最大和最小容量信息。

下面通过一个具体的例子演示了`commons-pool2`工具类的使用。这里仍然选择 Redis 连接对象 Jedis 作为演示。

首先，我们需要实现`PooledObjectFactory`工厂类来实现其中的对象创建和销毁方法。

然后，继承 GenericObjectPool 类来实现借出和返回对象等操作。

可以看到`MyGenericObjectPool`类的构造函数中的输入参数有`GenericObjectPoolConfig`对象，是对象池的一个配置对象，可以配置对象池的容量和大小等信息。这里不会对其进行配置，将使用默认配置。

通过`GenericObjectPoolConfig`的源代码可以看到，在默认配置下，对象池的容量是`8`。

让我们使用测试类编写一个对象池。

输出日志:

```
redis get: name_foo
release the connection
```

上面已经演示了在`commons-pool2`工具中对象池的使用。从上面的例子可以发现，只有相同初始化条件的对象才能存储在这个对象池中。如果 Redis 在这里，我们需要存储一个本地连接，远程连接的两种 Jedis 对象不能满足。那怎么办呢？

事实上，`commons-pool2`工具已经考虑到了这种情况。通过添加一个键值，可以在同一个对象池管理中进行区分。代码和上面类似，完整的代码实现直接贴出来。

输出日志:

```
redis get: name_foo
```

**JedisPool 对象池实现分析。**

本文中的演示都使用 Jedis 连接对象。其实在 Jedis SDK 中已经实现了相应的对象池，也就是我们常用的 JedisPool 类。

那么这里的 JedisPool 是如何实现的呢？我们先来看看 JedisPool 是怎么用的。

代码中添加了注释，可以看到通过`jedisPool.getResource()`获得了一个对象，这与上面的`commons-pool2`工具中的`borrowObject`非常相似。如果继续跟踪它的代码实现，可以看到下面的代码。

看到了`super.borrowObject()`，多么熟悉的方法，如果继续分析代码，可以发现 Jedis 对象池也是用`commons-pool2`工具实现的。在这种情况下，我们也应该能够猜出`jedis.close()`方法的逻辑。应该有退货操作。检查代码，发现确实如此。

通过上面的分析可以看出，Jedis 确实使用了`commons-pool2`工具来管理对象池，这也可以通过分析`JedisPool`类的继承关系图来发现。

**总结。**

通过本文的介绍，可以发现统筹思想有几个明显的优点。

*   可以显著提高应用程序性能。
*   如果创建一个对象太昂贵，那么使用池是非常有效的。
*   池提供了一种管理和重用对象的方法，减少了内存碎片。
*   您可以对可以创建的对象数量进行限制，并为不能创建过多对象的场景提供保护。

但是，使用对象池有一些注意事项，例如返回一个对象以确保该对象已被重置为可重用状态。

同时还需要注意的是，在使用池化时，要根据具体场景合理设置池的大小。

感谢阅读。

如果你喜欢这样的故事，想支持我，请给我鼓掌。

你的支持对我来说非常重要，谢谢你。