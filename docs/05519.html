<html>
<head>
<title>Core Location — How to Display a Human-Readable Address Using CLGeocoder</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">核心位置-如何使用CLGeocoder显示人类可读的地址</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/core-location-how-to-display-a-human-readable-address-using-clgeocoder-b2497c51b8ab?source=collection_archive---------2-----------------------#2020-09-06">https://levelup.gitconnected.com/core-location-how-to-display-a-human-readable-address-using-clgeocoder-b2497c51b8ab?source=collection_archive---------2-----------------------#2020-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ac509c1faf3ee82e0397723f9c7c2af3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AX_b63Ce2kBJCagv_w10iQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/s/photos/location?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kc" href="https://unsplash.com/@element5digital?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Element5数码</a>拍摄</figcaption></figure><h2 id="5b73" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">绪论</h2><p id="5cf9" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">在之前的一篇文章中，我写了关于在UIKit应用程序中设置核心位置的内容。我介绍了向Info.plist文件添加用法描述、请求位置授权以及从CLLocationManager中提取位置。如果你需要一些帮助来设置UIKit应用程序中的核心位置，可以看看那个帖子:<a class="ae kc" href="https://rustynailsoftware.com/dev-blog/core-location-setting-up-core-location-with-uikit." rel="noopener ugc nofollow" target="_blank">https://rustynailsoftware . com/dev-blog/Core-Location-setting-up-Core-Location-with-ui kit。</a></p><p id="b9ab" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">在这篇文章中，我将介绍如何实现<strong class="lb ir">cl geocoder</strong>——这是一个位于核心位置的类，帮助开发人员在他们的iOS应用程序中生成人类可读版本的地理坐标。我还将简要介绍一下<strong class="lb ir"> CLLocation </strong>对象，因为我在第一篇核心位置文章中没有这样做。你可以跟随我在GitHub上托管的代码:<a class="ae kc" href="https://github.com/andrew-lundy/core-location-tutorial" rel="noopener ugc nofollow" target="_blank">https://github.com/andrew-lundy/core-location-tutorial</a></p><p id="5756" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">让我们开始吧。</p><h2 id="fb20" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">CLLocation类</h2><p id="0885" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">核心定位的一个重要方面是<strong class="lb ir"> CLLocation </strong>类。这太重要了，以至于我忘了在我的第一篇核心位置系列博文中写它。<strong class="lb ir"> CLLocation </strong>类是保存设备位置信息的对象，包括高度和路线信息。路线信息是设备的速度和方向。在核心位置中，您通过CLLocationManager类获取位置详细信息。这里，我将信息存储在<strong class="lb ir"> currentLocation </strong>变量中:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="9e7b" class="kd ke iq me b gy mi mj l mk ml">let locationManager = CLLocationManager()<br/>let currentLocation = locationManager.location</span></pre><p id="6f67" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">有了这个，我们就可以访问位置细节，并且能够提取这些细节。例如，要获得位置的坐标，使用位置管理器的<strong class="lb ir">坐标</strong>属性:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="617a" class="kd ke iq me b gy mi mj l mk ml">let locationManager = CLLocationManager()<br/>let currentLocation = locationManager.location<br/>// Print the location details.<br/>// Ex: &lt;+37.78735352, -122.40822700&gt; +/- 5.00m (speed - 1.99 mps / course - 1.00) @ 9/5/20, 5:13:46 PM Central Daylight Time<br/>print(currentLocation)</span><span id="27dc" class="kd ke iq me b gy mm mj l mk ml">let locationCoordinate = currentLocation.coordinate<br/>// Print the coordinate value of the location as a CLLocationCoordinate2D.<br/>// Ex: CLLocationCoordinate2D(latitude: 37.787353515625, longitude: -122.408227)<br/>print(locationCoordinate)</span></pre><h2 id="6be2" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">使用CLGeocoder进行反向地理编码</h2><p id="59ae" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">如上所述，<strong class="lb ir"> CLLocation </strong>类以几乎不可用的格式返回位置信息。当然，我们可以得到地理坐标和设备移动的速度。但是，这些信息只在某些情况下有用。当我们需要向不想读取和转换坐标的用户显示位置信息时会发生什么？答案就在苹果的<strong class="lb ir"> CLGeocoder </strong>类中。</p><p id="399f" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">到目前为止，<strong class="lb ir"> ViewController </strong>类持有以下对象和IBOutlets:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="10f5" class="kd ke iq me b gy mi mj l mk ml">@IBOutlet weak var changeLocationBttn: UIButton!<br/>@IBOutlet weak var reverseGeocodeLocation: UIButton!<br/>@IBOutlet weak var locationDataLbl: UILabel!</span><span id="8951" class="kd ke iq me b gy mm mj l mk ml">private var locationManager: CLLocationManager!<br/>private var currentLocation: CLLocation!<br/>private var geocoder: CLGeocoder!</span></pre><p id="a35c" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">我将继续初始化<strong class="lb ir"> ViewController </strong>类的<strong class="lb ir"> viewDidLoad </strong>方法中的<strong class="lb ir"> CLGeocoder </strong>:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="26e5" class="kd ke iq me b gy mi mj l mk ml">override func viewDidLoad() {<br/>  super.viewDidLoad()<br/>  changeLocationBttn.layer.cornerRadius = 10<br/>  reverseGeocodeLocation.layer.cornerRadius = 10<br/>  reverseGeocodeLocation.titleLabel?.textAlignment = .center<br/>  <br/>  locationManager = CLLocationManager()<br/>  locationManager.delegate = self<br/>  <br/>  // Initialize the Geocoder<br/>  geocoder = CLGeocoder()<br/>}</span></pre><p id="d860" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><strong class="lb ir"> CLGeocoder </strong>将要做的所有工作都将发生在<strong class="lb ir">reverseGeocodeLocationBttnTapped</strong>方法中。我们要做的第一件事是确保<strong class="lb ir"> currentLocation </strong>变量不为空。这是为了保存设备的位置信息，并在应用程序请求授权状态时赋予一个值。我们需要进行这项检查，因为如果没有位置值，就没有什么可进行反向地理编码的。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="8536" class="kd ke iq me b gy mi mj l mk ml">@IBAction func reverseGeocodeLocationBttnTapped(_ sender: Any) {<br/>    guard let currentLocation = self.currentLocation else {<br/>        print("Unable to reverse-geocode location.")<br/>        return<br/>    }<br/>}</span></pre><p id="716c" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">要开始反向地理编码坐标的过程，您必须在<strong class="lb ir"> CLGeocoder </strong>上调用<strong class="lb ir"> reverseGeocodeLocation </strong>方法。这个方法有两个参数——一个<strong class="lb ir"> CLLocation </strong>对象和一个<strong class="lb ir"> CLGeocodeCompletionHandler。</strong>完成处理器也有两个参数——一个数组<strong class="lb ir"> CLPlacemark </strong>和一个<strong class="lb ir"> Error </strong>。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="26e6" class="kd ke iq me b gy mi mj l mk ml">// The method that does the reverse-geocoding.<br/>geocoder.reverseGeocodeLocation(location: CLLocation, completionHandler: CLGeocodeCompletionHandler)</span><span id="a40c" class="kd ke iq me b gy mm mj l mk ml">// Here is the method when in use.<br/>geocoder.reverseGeocodeLocation(currentLocation) { (placemarks, error) in<br/>  <br/>}</span></pre><p id="70a6" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><strong class="lb ir"> CLPlacemark </strong>类是新的，我们来看看。一个<strong class="lb ir"> CLPlacemark </strong>或“Placemark”，保存了人类可读版本的坐标，并使开发人员能够访问诸如地名、城市、州、邮政编码等信息。关于<strong class="lb ir"> CLPlacemark </strong>类的更多内容可以在苹果的docs:<a class="ae kc" href="https://developer.apple.com/documentation/corelocation/clplacemark" rel="noopener ugc nofollow" target="_blank">https://developer . Apple . com/documentation/corelocation/CLPlacemark</a></p><p id="a825" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">下面是我们将在完成处理程序中执行的步骤:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="3209" class="kd ke iq me b gy mi mj l mk ml">geocoder.reverseGeocodeLocation(currentLocation) { (placemarks, error) in<br/>    // 1<br/>    if let error = error {<br/>        print(error)<br/>    }<br/>            <br/>    // 2<br/>    guard let placemark = placemarks?.first else { return }<br/>    print(placemark)<br/>    // Geary &amp; Powell, Geary &amp; Powell, 299 Geary St, San Francisco, CA 94102, United States @ &lt;+37.78735352,-122.40822700&gt; +/- 100.00m, region CLCircularRegion (identifier:'&lt;+37.78735636,-122.40822737&gt; radius 70.65', center:&lt;+37.78735636,-122.40822737&gt;, radius:70.65m)<br/>            <br/>    // 3<br/>    guard let streetNumber = placemark.subThoroughfare else { return }<br/>    guard let streetName = placemark.thoroughfare else { return }<br/>    guard let city = placemark.locality else { return }<br/>    guard let state = placemark.administrativeArea else { return }<br/>    guard let zipCode = placemark.postalCode else { return }<br/>            <br/>    // 4<br/>    DispatchQueue.main.async {<br/>        self.locationDataLbl.text = "\(streetNumber) \(streetName) \n \(city), \(state) \(zipCode)"<br/>    }<br/>}</span></pre><ol class=""><li id="f497" class="mn mo iq lb b lc lu lg lv km mp kq mq ku mr lt ms mt mu mv bi translated">检查处理程序是否产生错误。如果是，将其打印到控制台。在真正的应用程序中，您可以更有效地处理错误。</li><li id="3c9b" class="mn mo iq lb b lc mw lg mx km my kq mz ku na lt ms mt mu mv bi translated">使用guard语句获取从完成处理程序返回的第一个placemark。对于大多数地理编码请求，地标数组应该只包含一个条目。我打印了地标数据。</li><li id="ad89" class="mn mo iq lb b lc mw lg mx km my kq mz ku na lt ms mt mu mv bi translated">根据用例，从地标中提取特定的数据。在这个例子中，我提取了街道号、街道名、城市、州和邮政编码。</li><li id="192c" class="mn mo iq lb b lc mw lg mx km my kq mz ku na lt ms mt mu mv bi translated">最后，我用地标数据更新了应用程序中的标签。因为这改变了用户界面，所以我在主线程上使用了<strong class="lb ir"> DispatchQueue </strong>类。</li></ol><p id="fa3f" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><strong class="lb ir">reverseGeocodeLocationBttnTapped</strong>I action现在应该是这样的:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="da9c" class="kd ke iq me b gy mi mj l mk ml">@IBAction func reverseGeocodeLocationBttnTapped(_ sender: Any) {<br/>    guard let currentLocation = self.currentLocation else {<br/>        print("Unable to reverse-geocode location.")<br/>        return<br/>    }<br/>    <br/>    geocoder.reverseGeocodeLocation(currentLocation) { (placemarks, error) in<br/>        if let error = error {<br/>            print(error)<br/>        }<br/>            <br/>        guard let placemark = placemarks?.first else { return }<br/>        guard let streetNumber = placemark.subThoroughfare else { return }<br/>        guard let streetName = placemark.thoroughfare else { return }<br/>        guard let city = placemark.locality else { return }<br/>        guard let state = placemark.administrativeArea else { return }<br/>        guard let zipCode = placemark.postalCode else { return }<br/>  <br/>        DispatchQueue.main.async {<br/>            self.locationDataLbl.text = "\(streetNumber) \(streetName) \n \(city), \(state) \(zipCode)"<br/>        }<br/>    } <br/>}</span></pre><h2 id="c2b7" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">收尾工作</h2><p id="9816" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">该应用程序现在可以请求位置授权，获取设备的位置，并通过最新的功能对位置进行反向地理编码。这是应用程序的流程:</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/24615437e69dfbad37f0afa566ea3b77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kdNP8-fYWo5psY6Mi0eXmw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">自从上一篇文章以来，我已经在用户界面上添加了“反向地理编码”按钮。</figcaption></figure><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/27ae4bdc098527bdd8593b7ece069d84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JfMP5yu2ZF9WgX5KjMXsOg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">点击绿色按钮后，位置授权请求就通过了。</figcaption></figure><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/75d3d935193fda67319802f37fc9dc2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aBY5jLrYiYYgKA7ZxBAhgA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">点击绿色按钮后，位置授权请求就通过了。</figcaption></figure><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/a5e1796be4010fedb2f38437bb480ffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-g3D2IwkYc3iYpZjJOtabw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">点击橙色按钮后，使用<strong class="bd kf"> CLGeocoder </strong>类对位置进行反向地理编码。</figcaption></figure><p id="e78f" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">感谢您抽出时间阅读本演练。核心位置是构建任何基于位置的iOS应用的关键，我希望你学到了一些新东西。欢迎在Twitter上与我联系，帮助发展iOS开发社区:<a class="ae kc" href="https://twitter.com/andrewlundydev." rel="noopener ugc nofollow" target="_blank">https://twitter.com/andrewlundydev.</a></p><p id="a63d" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">可以在我的博客上阅读原文:<a class="ae kc" href="https://rustynailsoftware.com/dev-blog/core-location-reverse-geocoding-locations-using-clgeocoder" rel="noopener ugc nofollow" target="_blank">https://rustynailsoftware . com/dev-blog/core-location-reverse-geocoding-locations-using-cl geocoder</a></p><p id="e033" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><strong class="lb ir">资源:</strong></p><p id="b45d" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><em class="nc">用UIKit设置核心位置</em>:<a class="ae kc" href="https://rustynailsoftware.com/dev-blog/core-location-setting-up-core-location-with-uikit" rel="noopener ugc nofollow" target="_blank">https://rustynailsoftware . com/dev-blog/Core-Location-Setting-Up-Core-Location-with-ui kit</a></p><p id="900d" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><em class="nc"> CLLocation文档</em>:<a class="ae kc" href="https://developer.apple.com/documentation/corelocation/cllocation" rel="noopener ugc nofollow" target="_blank">https://developer . apple . com/documentation/core location/cl location</a></p><p id="7719" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><em class="nc">CLGeocoder Docs</em>:<a class="ae kc" href="https://developer.apple.com/documentation/corelocation/clgeocoder" rel="noopener ugc nofollow" target="_blank">https://developer . apple . com/documentation/corelocation/CLGeocoder</a></p><p id="ce19" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><em class="nc"> CLGeocodeCompletionHandler文档</em>:<a class="ae kc" href="https://developer.apple.com/documentation/corelocation/clgeocodecompletionhandler" rel="noopener ugc nofollow" target="_blank">https://developer . apple . com/documentation/corelocation/CLGeocodeCompletionHandler</a></p><p id="e2aa" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><em class="nc"> CLPlacemark文档</em>:<a class="ae kc" href="https://developer.apple.com/documentation/corelocation/clplacemark" rel="noopener ugc nofollow" target="_blank">https://developer . apple . com/documentation/corelocation/CLPlacemark</a></p><p id="abd4" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><em class="nc">dispatch queue Docs</em>:<a class="ae kc" href="https://developer.apple.com/documentation/dispatch/dispatchqueue" rel="noopener ugc nofollow" target="_blank">https://developer . apple . com/documentation/dispatch/dispatch queue</a></p></div></div>    
</body>
</html>