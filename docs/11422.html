<html>
<head>
<title>6 Tips for Writing More Elegant TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">写更优雅的打字稿的6个技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/6-tips-for-writing-more-elegant-typescript-1e705b47ccab?source=collection_archive---------3-----------------------#2022-03-15">https://levelup.gitconnected.com/6-tips-for-writing-more-elegant-typescript-1e705b47ccab?source=collection_archive---------3-----------------------#2022-03-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c336" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">像专家一样写出更好的打字稿代码。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7f6d776580fa5d9c633e4e49cbb71ab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xAE8Mk_EpmXjpyMqRJSTgw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="ba82" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">TypeScript是一把双刃剑，在让我们的代码健壮的同时也带来了一定的学习成本。如果使用不当，就会出现意想不到的bug。如果你也想像专业人士一样优雅地编写TypeScript代码，请跟随我来看看开发时的一些最佳实践！</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="8232" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">1.使用void代替any</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="10f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一定要确定函数的返回值，不要用any，如果想忽略返回值，最好用<strong class="la iu"> void </strong>代替any。</p><h1 id="3a09" class="mb mc it bd md me mv mg mh mi mw mk ml jz mx ka mn kc my kd mp kf mz kg mr ms bi translated">2.使用字符串枚举代替数字枚举</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f499" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们不显式地将值设置为枚举时，它们在默认情况下被设置为增量数字。所以上面的<code class="fe na nb nc nd b">Fruit.APPLE</code>、<code class="fe na nb nc nd b">Fruit.PINEAPPLE</code>和<code class="fe na nb nc nd b">Fruit.ORANGE</code>将被设置为0、1和2。当我们用它们作为变量的类型时，它本身和所有的数字都可以赋给它。</p><p id="7fd9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与字符串枚举不同，只有它本身可以被赋给它。</p><p id="08ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以当你在纠结用数值枚举还是字符串枚举的时候，请先用字符串枚举。因为它更容易调试，不容易出错。</p><h1 id="64b6" class="mb mc it bd md me mv mg mh mi mw mk ml jz mx ka mn kc my kd mp kf mz kg mr ms bi translated">3.正确使用类型别名和接口</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9685" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类型别名几乎涵盖了接口的所有特性，但是接口总是<strong class="la iu">可扩展的</strong>，而类型别名不是。所以你可能需要根据具体情况来选择它们。更多详情，请查看我的另一篇文章:</p><div class="ne nf gp gr ng nh"><a href="https://betterprogramming.pub/differences-between-type-aliases-and-interfaces-in-typescript-4-6-6489246d4e48" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">TypeScript 4.6中类型别名和接口之间的差异</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">类型别名和接口都很相似，那我该用哪个呢？</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">better编程. pub</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv ks nh"/></div></div></a></div><h1 id="e235" class="mb mc it bd md me mv mg mh mi mw mk ml jz mx ka mn kc my kd mp kf mz kg mr ms bi translated">4.注意函数重载的顺序</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8ecf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不要把更一般的重载放在更具体的重载之前。这是因为TypeScript在解析时更喜欢第一个匹配的重载。因此，当前面的重载更通用时，后面更具体的重载将被忽略。</p><h1 id="1483" class="mb mc it bd md me mv mg mh mi mw mk ml jz mx ka mn kc my kd mp kf mz kg mr ms bi translated">5.使用联合类型</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="98f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果同一个参数位置可以接受不同的类型，那么使用<strong class="la iu">联合类型</strong>而不是编写不同类型的重载。因为这样更简洁，在外部函数传递参数时也最有容忍度。</p><h1 id="4135" class="mb mc it bd md me mv mg mh mi mw mk ml jz mx ka mn kc my kd mp kf mz kg mr ms bi translated">6.使用可选参数</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="61c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果尾随参数是可选的，使用<strong class="la iu">可选参数</strong>而不是编写不同的重载。有两个具体原因:</p><p id="2451" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一:在上面的代码中，我们期望<code class="fe na nb nc nd b">getName</code>的第二个参数是可选的。但是重载的定义函数要求我们必须传递一个字符串。并且可选参数定义的函数是正确的。</p><p id="2c80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">StackBlitz默认不显示这个错误(因为“严格的空值检查”没有打开)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/7f2e7a0b5c6b37e1e4d2198910dc94ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G1P431A5orVnAXxGw_gfnw.png"/></div></div></figure><p id="bab6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第二:在上面的代码中，当把<code class="fe na nb nc nd b">getName</code>作为参数传递给<code class="fe na nb nc nd b">main</code>时，重载定义的函数会匹配第一个重载。这是因为TypeScript通过查看目标的任何签名是否可以用源的参数调用来解决签名兼容性问题，并允许使用无关的参数。所以TypeScript不会抛出导致bug的错误。</p><p id="e387" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相反，用可选参数声明的函数会抛出错误。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="5ab5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nx">感谢阅读。如果你喜欢这样的故事，想支持我，请考虑成为</em> <a class="ae ny" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="nx">中等会员</em> </a> <em class="nx">。每月5美元，你可以无限制地访问媒体内容。如果你通过</em> <a class="ae ny" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="nx">我的链接</em> </a> <em class="nx">报名，我会得到一点佣金。</em></p><p id="429b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你的支持对我来说非常重要——谢谢。</p></div></div>    
</body>
</html>