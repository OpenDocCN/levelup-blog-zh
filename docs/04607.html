<html>
<head>
<title>Decoding Python Boolean Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解码Python布尔运算符</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/decoding-python-boolean-operators-83019fbe0e60?source=collection_archive---------21-----------------------#2020-07-05">https://levelup.gitconnected.com/decoding-python-boolean-operators-83019fbe0e60?source=collection_archive---------21-----------------------#2020-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8b49" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python布尔操作符可能非常紧凑，但是有点混乱</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/311ac4268edd88810ba54cfad673e731.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Mvggo1UOPbL41BMhKbppQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">基于<a class="ae ky" href="https://unsplash.com/@lazycreekimages?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Michael Dziedzic </a>在<a class="ae ky" href="https://unsplash.com/s/photos/math?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="aab5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们大多数人都熟悉python中的<code class="fe lv lw lx ly b">and</code>和<code class="fe lv lw lx ly b">or</code>，它们在条件表达式中充当逻辑运算符。例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="c7a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，它们还有一个不太常见的用例，为了简洁起见，这些关键字可以在非条件上下文中使用。许多纯粹主义者并不认为<code class="fe lv lw lx ly b">and</code>和<code class="fe lv lw lx ly b">or</code>的这种用法非常pythonic化，不管是否简洁。我相信这样想的原因是，这些表达往往没有使用更传统的<code class="fe lv lw lx ly b">if</code> … <code class="fe lv lw lx ly b">else</code>结构清晰。</p><h2 id="4f16" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">它们是如何工作的</h2><p id="1004" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe lv lw lx ly b">and</code>、<code class="fe lv lw lx ly b">or</code>和<code class="fe lv lw lx ly b">not</code>有时被称为短路布尔运算符。您可以在<a class="ae ky" href="https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not" rel="noopener ugc nofollow" target="_blank"> python文档</a>中找到对它们的简要描述。</p><p id="3e9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，你只需要记住<code class="fe lv lw lx ly b">or</code>将返回第一个“真”值或者最右边的值，如果没有值是真的话。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="9e8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">and</code>将以相反的方式工作，返回第一个“Falsy”值，否则返回语句中的最后一个值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="b004" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">not</code>也属于这一类，尽管它有点离群，因为<code class="fe lv lw lx ly b">and</code>和<code class="fe lv lw lx ly b">or</code>是二元操作，<code class="fe lv lw lx ly b">not</code>是后缀一元操作符，这意味着它只接受在关键字后传递的单个参数。<code class="fe lv lw lx ly b">not</code>的不同之处还在于，它不返回它的参数作为响应，而是评估它的真值并返回逆布尔值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="be03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用dis，我们可以使用这些操作符来查看一些简单的语句。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">“2”是行号</figcaption></figure><p id="fa09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意这些操作符的操作顺序也很重要。<code class="fe lv lw lx ly b">or</code>先来，然后<code class="fe lv lw lx ly b">and</code>，最后<code class="fe lv lw lx ly b">not</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h2 id="f7da" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">例子</h2><p id="b830" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">虽然到目前为止大多数例子都是“玩具”例子——我相信在某些情况下这些操作符，特别是<code class="fe lv lw lx ly b">or</code>，是有用的。</p><p id="8743" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑一个例子，您收到了一些json，并希望解析出一个“last_updated_by”字段用于审计。让我们假设我们的json对象看起来像这样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="7b40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，如果对象还没有被更新，它将不会有一个<code class="fe lv lw lx ly b">updated_by</code>字段，在这种情况下，我们想回到<code class="fe lv lw lx ly b">created_by</code>，这恰好是一个可空的字段。使用传统的<code class="fe lv lw lx ly b">if</code> … <code class="fe lv lw lx ly b">elif</code> … <code class="fe lv lw lx ly b">else</code>语法似乎可以通过以下方式获得该值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="2459" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我们利用布尔运算<code class="fe lv lw lx ly b">or</code>,这可以被压缩成一个简洁的单行，易于阅读和理解。虽然<code class="fe lv lw lx ly b">and</code>有点违反直觉，但是<code class="fe lv lw lx ly b">or</code>的这种n进制用法对我来说读起来很好，就像javascript中的双管(||)操作符一样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h2 id="15ba" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">效率</h2><p id="dc44" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">除了简洁之外，您可能想知道使用操作符与条件表达式相比，是否有其他副作用或效率。首先让我们看看上面使用<code class="fe lv lw lx ly b">or</code>的例子的字节码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="ae57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，布尔操作符的字节码要短得多，这对于效率来说是个好兆头。查看代码时，您会注意到，如果值在字典中，布尔方法将少进行一次字典查找，因为它可以直接返回字典响应，而不是在评估条件后进行最终的字典查找。</p><p id="1be0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始计时吧。在这两种情况下，<code class="fe lv lw lx ly b">or</code>方法都稍微快一些，这可能是因为少了一个<code class="fe lv lw lx ly b">get</code>调用。然而，我不认为结果是确凿无疑的。您的里程可能会有所不同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h2 id="af48" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">结论</h2><p id="c267" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">虽然我发现自己很少使用<code class="fe lv lw lx ly b">and</code> / <code class="fe lv lw lx ly b">or</code>布尔运算符，但是当你在代码审查中遇到它们时，知道它们的意思是非常有用的。对于所有寻找高效、简洁解决方案的leetcoders来说，它们也很方便。</p></div></div>    
</body>
</html>