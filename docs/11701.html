<html>
<head>
<title>Handling unmodified requests in REST API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在REST API中处理未修改的请求</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/handling-unmodified-requests-in-rest-api-b15a035c6e70?source=collection_archive---------12-----------------------#2022-04-06">https://levelup.gitconnected.com/handling-unmodified-requests-in-rest-api-b15a035c6e70?source=collection_archive---------12-----------------------#2022-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3734" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">客户端-服务器通信中的各种响应状态代码就像你正在学习的语言中的单词一样——最初，你只是使用非常有限的子集来理解，然后你通过增加这个范围来提高自己，后来你试图使用最适合当前上下文的语言。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/623b621ed3f346fcd94bd080b1090e3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QRRAygj-AuRXfQBMgRwxhw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">谈判</figcaption></figure><p id="fba1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你的回答越具体，你被问到的额外问题就越少。</p><p id="30cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在客户端-服务器通信中也是如此:</p><ul class=""><li id="3f1e" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">通过创建一个新的资源，响应代码<code class="fe lk ll lm ln b">200</code>变得不如<code class="fe lk ll lm ln b">201</code>信息丰富，因为在这种状态下，客户端还期望找到带有该资源链接的<code class="fe lk ll lm ln b">Location </code>报头</li><li id="17ae" class="lb lc iq jp b jq lo ju lp jy lq kc lr kg ls kk lg lh li lj bi translated">当处理批处理请求时，<code class="fe lk ll lm ln b">207</code> status胜过了<code class="fe lk ll lm ln b">200</code>,因为它告诉用户一个响应可以包含关于每个发布的实体的单独统计信息，而不是一个总的汇总信息</li><li id="471c" class="lb lc iq jp b jq lo ju lp jy lq kc lr kg ls kk lg lh li lj bi translated"><code class="fe lk ll lm ln b">429</code> status比<code class="fe lk ll lm ln b">500</code>更适合表示服务器超出了它的容量，不得不暂时拒绝新的请求，因此智能重试(使用指数补偿策略)在这里是有效的</li><li id="8e2a" class="lb lc iq jp b jq lo ju lp jy lq kc lr kg ls kk lg lh li lj bi translated">身份验证状态代码(<code class="fe lk ll lm ln b">401</code>和<code class="fe lk ll lm ln b">403</code>)的误用也会混淆客户及其对此类响应的反应。使用401状态，您通知客户端会话不再有效，因此任何进一步的操作都将被拒绝。对于403状态的期望是不同的——只有这个特定的请求被禁止，但是其他API可能对您可用。</li></ul><p id="fa91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正确使用状态代码可以让您的客户端更明智地控制数据通信过程，并且不会因为在某些信息不足的故障情况下重试操作而对您的系统造成严重损害。</p><h2 id="490b" class="lt lu iq bd lv lw lx dn ly lz ma dp mb jy mc md me kc mf mg mh kg mi mj mk ml bi translated">但是一些更奇特的身份代码呢？</h2><p id="26b8" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">浏览器获取API性能优化策略通常包括本地缓存要求，以最大限度地减少不必要的往返。一个例子是支持<code class="fe lk ll lm ln b">304</code>状态码，该状态码指示服务器不包含该页面的升级版本，因此先前请求的页面仍然有效。</p><p id="09ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在单页应用程序中，此状态代码尽可能地优化web资源，以便请求的页面在不同的部署之间只加载一次。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mr"><img src="../Images/bd810796ec5904d2ff88d4733005bca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IDoTALjX_zKIGO0bKAuT-g.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">加载静态源</figcaption></figure><p id="b968" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这不是纯粹的离线模式，因为无论如何都会发送请求，但不会下载内容，因此总的请求处理时间要短得多。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ms"><img src="../Images/7fcf41cd187162fa746cdeebb963e8a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kf7z6SYx0_AjW_bztl34pQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">完整时间表</figcaption></figure><p id="0767" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此状态代码主要用于优化浏览器中的GET请求，因为它使用关于缓存文件的浏览器信息来正确配置请求头<code class="fe lk ll lm ln b">If-Modified-Since</code>和<code class="fe lk ll lm ln b">If-None-Match</code>，以提供该文件在本地缓存中的最后更改日期。</p><p id="d305" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但它的使用并不禁止任何其他类型。在常规数据管道中使用它来优化修改API怎么样？</p><h2 id="2bbe" class="lt lu iq bd lv lw lx dn ly lz ma dp mb jy mc md me kc mf mg mh kg mi mj mk ml bi translated">告诉我更多关于我的数据的信息</h2><p id="60ac" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">我们想要支持的用例之一是从父系统定期重新加载源数据。这包括已经加载并且在下次运行时没有有效更改的数据。</p><p id="d265" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与整个数据流相比，新数据和已更改数据的百分比非常小，因此减少存储压力的一个好策略是避免覆盖未修改的数据。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mt"><img src="../Images/7ea8c86f2a441159736049aab9e88441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fiEOaT2WWGSRUSMAO_wG1Q.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">同步数据</figcaption></figure><p id="3830" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，通知客户端系统认为输入数据与已经存储的快照相比没有变化，因此操作将被跳过，这是件好事。</p><p id="be2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这为在PUT/PATCH API中使用额外的状态代码提供了更多的自由，以更具体地说明对此数据的预期操作:</p><ul class=""><li id="ce62" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated"><code class="fe lk ll lm ln b">200</code> —输入数据将被存储，其版本将被增加</li><li id="191c" class="lb lc iq jp b jq lo ju lp jy lq kc lr kg ls kk lg lh li lj bi translated"><code class="fe lk ll lm ln b">304</code> —与已经存储的数据相比，输入数据没有有效的更改，因此修改请求将被跳过，记录版本不会被更改</li></ul><h2 id="06a9" class="lt lu iq bd lv lw lx dn ly lz ma dp mb jy mc md me kc mf mg mh kg mi mj mk ml bi translated">检测数据更改的挑战</h2><p id="a3d4" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">传统的更新操作可以用序列图来表示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mu"><img src="../Images/f4914dbc1ce3557ecbef583c58bb894b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RmHxYl-9VqHdu8-CSb5VNw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">经典更新操作</figcaption></figure><p id="1f21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每次我们想要更新一个实体时，我们都需要从源系统加载一个新的副本，将输入负载合并到其中，并将其持久化。</p><p id="9634" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么我们需要加载和合并？可能在极少数情况下，这些步骤是可以避免的。可以避免的通常情况— DTO和实体具有相同的表示。换句话说，从存储的角度来看，发布的数据是完整的，可以替换现有的记录，而无需额外的补充。</p><p id="9ca0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，输入数据方案比数据库记录更受限制，并且不包括系统私有标识符、元信息、安全内容等，因此需要进行合并，以通过利用用户输入来准备最终的数据库记录视图。有了这个，我们就不能忽略加载阶段，不考虑输入和存储的实体有多相似。</p><p id="764e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个挑战是如何检测发布的数据与已存储的数据相比是否有变化。毫无疑问，按需比较实体是一项CPU密集型操作，因此我们应该避免。</p><h2 id="198f" class="lt lu iq bd lv lw lx dn ly lz ma dp mb jy mc md me kc mf mg mh kg mi mj mk ml bi translated">一些更先进的技术？</h2><p id="bf11" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">算法解决了检测文档重复的问题，方法是只比较它的散列，而不是完全的深度比较。我们可以重用这种方法，并使用哈希计算和哈希比较步骤来扩展资源修改流程:</p><ul class=""><li id="cac0" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">当创建一个新实体时，它的散列被计算并存储为它的附加元信息</li><li id="ab12" class="lb lc iq jp b jq lo ju lp jy lq kc lr kg ls kk lg lh li lj bi translated">更新现有实体时，首先将其存储的哈希与输入有效负载的哈希进行比较</li></ul><p id="8f91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与活动对象比较相比，这使得检测更改的过程非常高效，因此我们可以轻松地跳过所有没有更改的请求，而不会影响数据库性能。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mv"><img src="../Images/bd5a7962453de7e1dc5030d8aa8fbde8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z-3E4mSCXF9OkNt9Js4WLg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">使用哈希比较</figcaption></figure><p id="6524" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每次处理一个修改请求时——首先将输入的有效负载与存储文档的散列进行比较，只有在不同的情况下才处理这个请求，否则通过发送回<code class="fe lk ll lm ln b">304</code>状态代码，用户立即被告知请求完成。</p><p id="3b68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种技术允许以足够高的性能处理大量没有有效更改的写请求，而不会用不必要的更新语句阻塞数据库。</p></div></div>    
</body>
</html>