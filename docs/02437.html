<html>
<head>
<title>[SQL] JOINs and UNIONs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[SQL]联接和联合</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/sql-joins-2cc89babb6f9?source=collection_archive---------1-----------------------#2020-03-13">https://levelup.gitconnected.com/sql-joins-2cc89babb6f9?source=collection_archive---------1-----------------------#2020-03-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3ff1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从1976年开始把桌子放在一起。</h2></div><p id="60ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我在程序员生涯的早期探索新的编程语言和框架时，我很快就发现了自动化的优点和缺点。为了澄清，我将自动化定义为框架/库/片段，它们消除了编写大量代码的需要。比如Lodash、下划线、jQuery，甚至VSC的林挺。</p><p id="dad0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">自动化极大地减少了开发时间、需要编写的代码量以及深入理解应用程序每个工作部分的需求。这很好。但与此同时，它也加速了许多原本非常有用的东西的学习曲线，或者在某些情况下是必要的，如果你还在学习诀窍，它会让你处于不利地位。</p><p id="2d5e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我使用Ruby on Rails和SQL的经验。</p><p id="ada9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Ruby on Rails的一个好处是你不必学习SQL。Ruby on Rails的一个不好的地方是你没有机会学习SQL。</p><p id="3217" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管SQL是我在用Ruby on Rails开发项目时经常使用的语言，但我对SQL的理解并不扎实，这一直困扰着我。</p><p id="25e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以最近我决定改变这一点，作为一个有点完美主义的人，开始慢慢钻研SQL。</p><p id="bd80" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">SQL中似乎会在新用户中引起很多误解或混淆的部分之一是连接和连接表，所以我想简单地介绍一下SQL中最常见的连接类型。</p><p id="49ee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将使用PostgreSQL、pgAdmin 4和我为这个博客准备的一个小型数据库，希望能更好地解释SQL中的连接是如何工作的。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="03f3" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated"><strong class="ak">基础知识</strong></h2><p id="3738" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">最简单的连接形式就是在SQL中将多个表组合在一起的一种方式。存在不同的联接类型是为了帮助您决定如何处理每个表中的不同比较。每个JOIN子句都扮演一个独立但重要的角色。</p><p id="f306" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，请记住，我在这篇博文中讨论的所有内容并不特定于PostgreSQL，而是适用于SQLite、mySQL、SQLserver或您正在使用的任何版本的SQL。每个版本之间都有差异，但是大多数SQL命令在它们之间是可以互换的。PostgreSQL中的一个区别是，如果您调用一个JOIN子句而没有明确说明您想要使用哪一个(内部连接、外部连接等)，PostgreSQL将自动默认使用内部连接。在继续之前，请注意一点。</p><p id="4797" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是我创建的PostgreSQL数据库的一个例子，我们将比较两个表。一个表包含一个虚构的美国人列表，另一个表包含一个虚构的欧洲人列表:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mj"><img src="../Images/7adee68c217f2f9ace637041d448ded3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jbooiuy8LBe7cKmIB_YRfQ.png"/></div></div></figure><p id="ceb5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这两个表都有相似的列和具有相似值的行，以及具有不同值的不同列和行，这对于解释联接如何工作是非常完美的。</p><p id="35c8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们用第一种也是最常见的连接类型:内部连接来比较这两个表。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="cae2" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">内部联接(内部联接)</h2><p id="1b77" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">内部联接是两个表中匹配的一组记录。如果要查找出现在两个不同表中的一行数据，可以使用内部联接。内部联接不会改变正在查询的两个表，但是会基于基本的布尔比较创建一组新的数据:等于(=)，不等于(！idspnonenote)。=)、大于(&gt;)、大于等于(&gt; =)、小于( =)。</p><p id="ce78" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">INNER JOIN子句是对称的，这意味着它将同等地查询两个表，以便确定我们的布尔比较的结果，并且无论您从哪个表中选择，或者与哪个表连接，返回的数据集都将产生相同的结果。</p><p id="fe98" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一种思考方式是，INNER JOIN子句是包含性的，或者它将包含新数据集中布尔比较返回true的所有内容。</p><p id="bec9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我遇到的理解内部连接如何工作的最好方法是通过维恩图:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mv"><img src="../Images/900d9b2c0d4740899e0e76a78f2eb941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7bXYka501QCn9MTp8QGvYw.png"/></div></div></figure><p id="ea70" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">绿色阴影的中间部分代表了我们的内部连接将要做的事情。假设我们希望找到两个列表中名字相同的所有人:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mv"><img src="../Images/db7a3f2ebd41636ec5d364fc4493e12b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CGjbPSHUw-Z1iVuOlV_mPw.png"/></div></div></figure><p id="da63" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">内部连接将比较两个表，然后返回一组新的数据，其中我们编写的布尔比较为真，我们将得到出现在两个列表中的所有人的姓名:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mv"><img src="../Images/f41f39665e176d5c82d4653e0dddcffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M6LZvSvpGxFCP5MMs3deow.png"/></div></div></figure><p id="7238" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们如何编写一个内部连接子句呢？</p><p id="a817" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我所知道的最简单的样板内部连接:</p><pre class="mk ml mm mn gt mw mx my mz aw na bi"><span id="0d9f" class="ll lm it mx b gy nb nc l nd ne">SELECT * FROM &lt;table1&gt; INNER JOIN &lt;table2&gt; ON &lt;table1.column_name&gt; &lt;comparison operator&gt; &lt;table2.column_name&gt;;</span></pre><p id="42f8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一些SQL向导可能知道一个更简单的方法，但是我想在这篇博客中把重点放在基础上。</p><p id="229a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们将查询细分如下:</p><pre class="mk ml mm mn gt mw mx my mz aw na bi"><span id="635c" class="ll lm it mx b gy nb nc l nd ne">SELECT * FROM &lt;table1&gt;</span></pre><p id="7a9a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的查询中选择表1中的所有列，以便我们可以与表2进行比较。</p><pre class="mk ml mm mn gt mw mx my mz aw na bi"><span id="70c0" class="ll lm it mx b gy nb nc l nd ne">INNER JOIN &lt;table2&gt;</span></pre><p id="61aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">调用INNER JOIN子句，这样SQL就知道我们要比较哪个表</p><pre class="mk ml mm mn gt mw mx my mz aw na bi"><span id="8dd1" class="ll lm it mx b gy nb nc l nd ne">ON &lt;table1.column_name&gt;</span></pre><p id="7a7d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">调用ON语句，这样我们可以选择要在表2中比较表1中的哪一列</p><pre class="mk ml mm mn gt mw mx my mz aw na bi"><span id="4aea" class="ll lm it mx b gy nb nc l nd ne">&lt;comparison operator&gt;</span></pre><p id="7aaa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的布尔表达式(=，！=, &gt;, &gt;=, </p><pre class="mk ml mm mn gt mw mx my mz aw na bi"><span id="58a5" class="ll lm it mx b gy nb nc l nd ne">&lt;table2.column_name&gt;;</span></pre><p id="66c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们从表2中选择一列与表1进行比较。请记住，为了使内部联接能够工作，两列必须具有相同的名称和相同的数据类型(char、text、integer、bigint等)。否则，我们的布尔比较将总是返回false，我们将在结果数据集中看不到任何东西。</p><p id="4ba8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，让我们使用boiler plate SQL查询，并将其应用于数据库中的两个人员列表。</p><p id="aa3a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，让我们继续使用上面的文氏图，在两个表中找到所有名字相同的人:</p><pre class="mk ml mm mn gt mw mx my mz aw na bi"><span id="662e" class="ll lm it mx b gy nb nc l nd ne">SELECT * FROM usa INNER JOIN europe ON usa.first_name = europe.first_name;</span></pre><p id="a790" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行这个查询，我们现在应该看到一个新的4行表，其中包含SQL在两个列表中找到名字相同的人的所有情况。</p><p id="6855" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，由于性能问题，以及它可能使事情变得有点混乱的事实，使用*操作符(意味着“all”)通常不是最佳实践:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nf"><img src="../Images/699ae4e99f4ca9eb4be6779533dc6429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D9Vsl9WA7pVvkhcHACmQnA.jpeg"/></div></div></figure><p id="fc41" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们通过明确说明我们想要查看哪些列来解决这个问题:</p><pre class="mk ml mm mn gt mw mx my mz aw na bi"><span id="9094" class="ll lm it mx b gy nb nc l nd ne">SELECT first_name, last_name, current_state, current_country FROM usa INNER JOIN europe ON usa.first_name = europe.first_name;</span></pre><p id="12ae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行这个查询，SQL将会混淆并抛出一个错误:</p><pre class="mk ml mm mn gt mw mx my mz aw na bi"><span id="bab6" class="ll lm it mx b gy nb nc l nd ne">ERROR: column reference “first_name” is ambiguous<br/>LINE 1: SELECT first_name, last_name, current_state, current_country…</span></pre><p id="25a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">别担心。这仅仅意味着我们还需要指定这些列来自哪个表，因为我们的两个表都包含相同的列名。如果我们想在数据集中查看这些信息，我们还需要添加两个表中的列名。</p><p id="79ee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了便于阅读，我还将开始将查询分成单独的行，我还发现如果将查询分成多行，会更容易理解。SQL对换行符的使用非常宽松，所以您可以随意使用它们:</p><pre class="mk ml mm mn gt mw mx my mz aw na bi"><span id="b438" class="ll lm it mx b gy nb nc l nd ne">SELECT usa.first_name, usa.last_name, current_state, europe.first_name, europe.last_name, current_country<br/>FROM usa<br/>INNER JOIN europe<br/>ON usa.first_name = europe.first_name;</span></pre><p id="b499" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将返回我们的内部连接，其中包含两个表中出现的所有名字，以及我们希望在结果中查看的所有数据:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi ng"><img src="../Images/1750d4434d08a394ddcf204b95606219.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l1Es-AwOjGHrLboP1Zq3ng.jpeg"/></div></div></figure><p id="f74d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想知道我们找到相似名称的次数，我们还可以加入一个聚合函数和一个GROUP BY子句，以及一些别名，这样我们就可以知道我们的数据集中返回的列，以及一个ORDER BY子句，以找出数据集中最常见的名称:</p><pre class="mk ml mm mn gt mw mx my mz aw na bi"><span id="2273" class="ll lm it mx b gy nb nc l nd ne">SELECT usa.first_name AS usa_first_names, europe.first_name AS europe_first_names, COUNT(*) AS similarities<br/>FROM usa<br/>INNER JOIN europe<br/>ON usa.first_name = europe.first_name<br/>GROUP BY usa.first_name, europe.first_name<br/>ORDER BY COUNT(usa.first_name = europe.first_name) DESC;</span></pre><p id="82c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是我们的查询应该返回的内容</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/ade8825ac220884d485c2119f03d728b.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*WXjw1ej__Y82PiNKheK_tA.jpeg"/></div></figure><p id="8533" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太好了。</p><p id="98c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">内部连接非常强大和灵活，可以很快变得相当复杂。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="8cbe" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">外部连接(完全外部连接)</h2><p id="c878" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">与内部联接相反的是外部联接。外部连接是一组只存在于被比较的一个表中的记录。如果要查找出现在一个表中而不是另一个表中的数据行，可以使用外部联接。与内部联接一样，外部联接不会改变您正在查询的两个表，并且还会基于布尔比较创建一组新的数据。</p><p id="5b0d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">OUTER JOIN子句也是对称的，但是不包含。它是唯一的。这意味着它将从布尔比较中排除返回true的数据，并返回所有产生false的数据。</p><p id="03f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，在我们的文氏图中，外部连接应该是这样的:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mv"><img src="../Images/d23016192db9a0b24dbb72fa59c020d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OBtX-zdiaJxcHG309N1lzg.png"/></div></div></figure><p id="734b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">两个外面的圆圈是蓝色和黄色的阴影，因为它代表了我们的外部连接将要做的事情，返回每个表唯一的所有数据。</p><p id="bd88" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果我们再次将其应用到我们的人员列表中，我们希望找到所有具有唯一名称的人员:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mv"><img src="../Images/ce072aea6ecd3332a33c0a7ebc2e4991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IxDGxFUcYJPsFy0MBCs2vw.png"/></div></div></figure><p id="9663" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">外部连接将比较这两个表，然后返回一组新的数据，其中我们编写的布尔比较为假，我们将得到我们国家特有的所有人名:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mv"><img src="../Images/ca50abbe03603a90a33dc779375b82df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E5K-oG-oOFpv4JU8eI2eQQ.png"/></div></div></figure><p id="b3ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里需要注意的重要一点是，只要布尔比较返回true，OUTER JOIN子句就会将NULL插入到它返回的数据集中。</p><p id="e921" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们稍后会解决这个问题。</p><p id="c88e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么，对于外部连接，我们的锅炉板查询看起来像什么呢？</p><p id="eee3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">嗯……基本上是一样的:</p><pre class="mk ml mm mn gt mw mx my mz aw na bi"><span id="2f0b" class="ll lm it mx b gy nb nc l nd ne">SELECT *<br/>FROM &lt;table1&gt;<br/>FULL OUTER JOIN &lt;table2&gt;<br/>ON &lt;table1.column_name&gt; &lt;comparison operator&gt; &lt;table2.column_name&gt;</span></pre><p id="c8c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们在我们的数据库上试试这个:</p><pre class="mk ml mm mn gt mw mx my mz aw na bi"><span id="ac21" class="ll lm it mx b gy nb nc l nd ne">SELECT *<br/>FROM usa<br/>FULL OUTER JOIN europe<br/>ON usa.first_name = europe.first_name</span></pre><p id="7a3a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是我们的外部连接现在返回的内容:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi ni"><img src="../Images/034afe4049eca639a2b7150904abe68f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wcCt8vEZccqq9IvKwOlN4A.jpeg"/></div></div></figure><p id="12a2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">嗯…这太乱了...</p><p id="d5e4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过使用WHERE操作符、or操作符和is操作符来解决这个问题。如果我们指定要在布尔比较为空的地方进行连接，我们将得到唯一的行:</p><pre class="mk ml mm mn gt mw mx my mz aw na bi"><span id="7cb7" class="ll lm it mx b gy nb nc l nd ne">SELECT usa.first_name, europe.first_name<br/>FROM usa<br/>FULL OUTER JOIN europe<br/>ON usa.first_name = europe.first_name<br/>WHERE usa.first_name IS null<br/>OR europe.first_name IS null</span></pre><p id="1f25" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的查询结果是:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/8b509eaaf73a2103ac0e6924dc7c19c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*s49VRwjTF2i8FJlak3Hjog.jpeg"/></div></figure><p id="321c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看起来好多了。但是让我们去掉空值，把一切都清理干净。</p><p id="1585" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用CONCAT函数来合并我们的列，因为我们的行中没有数据重叠，并且每一行都包含唯一的信息。我们还可以为要加入的新列分配一个新别名，并将所有内容合并到一列中:</p><pre class="mk ml mm mn gt mw mx my mz aw na bi"><span id="b607" class="ll lm it mx b gy nb nc l nd ne">SELECT CONCAT(usa.first_name, europe.first_name) AS first_names<br/>FROM usa<br/>FULL OUTER JOIN europe<br/>ON usa.first_name = europe.first_name<br/>WHERE usa.first_name IS null<br/>OR europe.first_name IS null</span></pre><p id="bd5e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它应该让我们的外部连接返回两个表中所有唯一名称的一列:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/fef371e2564c3e0b3aee2eb9a4df2350.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*eCsemiZLyHztOqMBHEMYPA.jpeg"/></div></figure><p id="347d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很好。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="d964" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">左外连接和右外连接(左连接和右连接)</h2><p id="7c6b" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">我将把左外连接和右外连接组合在一起，因为除了一个键的不同之外，它们的操作实际上是相同的，稍后我将对此进行解释。</p><p id="e695" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我将从左连接开始。从语法上讲，您可以同时使用左外连接或左连接，这取决于您的喜好。它们的功能相同，但我喜欢非常明确，所以我将坚持使用左外连接。</p><p id="96ad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">左外部联接返回您选择的第一个(或左)表中的所有行，以及出现在您与之联接的第二个(或右)表中的匹配项。</p><p id="8ba0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">左连接和右连接是SQL中6个连接子句中最不常见的(SELF JOIN是另一个，但我在这里不讨论它)，但了解它们仍然很重要。</p><p id="1e58" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是我们的文氏图:</p><p id="9a4f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">左外部联接:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mv"><img src="../Images/fad77304b39ee4d8db18d4773d5ab408.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7__AYSnvYeQaTO3M7-XKQg.png"/></div></div></figure><p id="6f0d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">右外部联接:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mv"><img src="../Images/7655b5b3539f93cb3753996128ca7b33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DWUCq4ZinUqjingA5twRzA.png"/></div></div></figure><p id="ad5d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以前，选择和联接表的顺序无关紧要，因为内部联接和外部联接都是对称操作的。</p><p id="ab69" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">左外连接和右外连接的操作是不对称的，这意味着根据您使用的子句，SQL将从左(第一个)或右(第二个)表中提取所有数据，以及从您要连接的表中提取匹配项。来自每个表的数据流不平衡。</p><p id="5101" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们数据库中两个人员表的上下文中，左外连接和右外连接将如何返回数据:</p><p id="f17d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">左外部联接:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mv"><img src="../Images/aff22d92bfd83397baf82a760bbb8e48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*urswiyV2TiZS4SZmXhF-hA.png"/></div></div></figure><p id="9872" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">右外部联接:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mv"><img src="../Images/98480dc25a9f85b5361f5c4e68f9b2a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*inhkI5Do54Ibem3DBwPffg.png"/></div></div></figure><p id="03f1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与外部连接一样，没有匹配的列用NULL填充，我们可以使用WHERE从任意一个表中获取唯一的行。</p><p id="981a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们在姓名和人员列表中使用它:</p><pre class="mk ml mm mn gt mw mx my mz aw na bi"><span id="6fcc" class="ll lm it mx b gy nb nc l nd ne">SELECT *<br/>FROM usa<br/>LEFT OUTER JOIN europe<br/>ON usa.first_name = europe.first_name</span></pre><p id="9a43" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将返回美国人的所有名字，以及同名的欧洲人的名字:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nf"><img src="../Images/1ad6c0ff0b1ba579aba1441ba06ba9f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RSlx30QGcQYNZcPr-6qQFg.jpeg"/></div></div></figure><p id="2e3e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这同样适用于RIGHT OUTER JOIN，除了我们将获得所有来自欧洲的人，以及美国同名人的名字。我们所要做的就是切换我们要选择和连接的表，并调用RIGHT OUTER JOIN:</p><pre class="mk ml mm mn gt mw mx my mz aw na bi"><span id="1998" class="ll lm it mx b gy nb nc l nd ne">SELECT *<br/>FROM europe<br/>RIGHT OUTER JOIN usa<br/>ON europe.first_name = usa.first_name</span></pre><p id="745b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们做到了:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nl"><img src="../Images/3d85e191ee8c4808a8addae6e96ba11f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2raXLHleIvw8URaR2ij18w.jpeg"/></div></div></figure><p id="3750" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们仍然可以使用WHERE语句来获取唯一的行，并根据我们使用的子句返回来自美国和欧洲的人名的唯一列表:</p><p id="b2a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">左外部联接:</p><pre class="mk ml mm mn gt mw mx my mz aw na bi"><span id="f64f" class="ll lm it mx b gy nb nc l nd ne">SELECT *<br/>FROM usa<br/>LEFT OUTER JOIN europe<br/>ON usa.first_name = europe.first_name<br/>WHERE europe.first_name IS null</span></pre><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nm"><img src="../Images/1fab5f91652b9713f9ad0f47697dd061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a9YjA0IDG5kLhQSV6QX7ew.jpeg"/></div></div></figure><p id="11f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">右外部联接:</p><pre class="mk ml mm mn gt mw mx my mz aw na bi"><span id="a5d0" class="ll lm it mx b gy nb nc l nd ne">SELECT *<br/>FROM europe<br/>LEFT OUTER JOIN usa<br/>ON europe.first_name = usa.first_name<br/>WHERE usa.first_name IS null</span></pre><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nn"><img src="../Images/9040c005d38d726e4dce6e9cdda427bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iCOApkeUQZmtcpG8Mpobiw.jpeg"/></div></div></figure><p id="a099" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">答对了。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="519f" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">工会(工会/工会所有人)</h2><p id="7165" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">UNION可能是所有JOIN子句中最简单的。</p><p id="9e57" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">联合就像洗牌一样。它将两个或多个SELECT语句的结果组合成一个数据集。根据您使用的SQL版本，UNION还可能将第一个查询中的行放在第二个查询的行之前、之后或之间。不过这真的不是问题，因为我们可以使用ORDER BY子句对组合数据集中的行进行排序。</p><p id="17ee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想看联合的维恩图…好吧…给你:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mv"><img src="../Images/851cf2f8d0bfdac95b5474e6f7682be4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*545EJbSWTxNr9fSzd-e8pA.png"/></div></div></figure><p id="feb8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相当直接。</p><p id="1eb2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了一个关键的区别之外，UNION和UNION都在相同的领域中起作用。</p><p id="af45" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">UNION会删除重复的行，而UNION ALL不会。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mv"><img src="../Images/5ee20882c4a7d3d604cb484ab1cec048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eIsjIjNbPAKmJe2RYsKLuw.png"/></div></div></figure><p id="fef3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不过还是有一些和工会的约定。两个SELECT子句必须返回相同数量的列，并且两列必须具有相同的数据类型。</p><p id="957a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看一些基本的例子:</p><pre class="mk ml mm mn gt mw mx my mz aw na bi"><span id="2917" class="ll lm it mx b gy nb nc l nd ne">SELECT first_name<br/>FROM usa<br/>UNION<br/>SELECT first_name<br/>FROM europe</span></pre><p id="cc96" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将返回一个新的数据集，其中包含我们从两个表中选择的两列，合并为一列:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div class="gh gi no"><img src="../Images/bac30bc7d7eba5c8e2f7c341248672a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*bAjXv6H4GwhnV1Y1DnnPPw.jpeg"/></div></figure><p id="6b45" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">UNION ALL以相同的方式编写，但应该返回一个包含重复项的完整数据集:</p><pre class="mk ml mm mn gt mw mx my mz aw na bi"><span id="54bf" class="ll lm it mx b gy nb nc l nd ne">SELECT first_name<br/>FROM usa<br/>UNION<br/>SELECT first_name<br/>FROM europe</span></pre><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div class="gh gi np"><img src="../Images/cf95f638a095ed2d5af040d9be71ef58.png" data-original-src="https://miro.medium.com/v2/resize:fit:338/format:webp/1*bJL3YMaIbKZWXFxP4TLNPQ.jpeg"/></div></figure><h1 id="5dd5" class="nq lm it bd ln nr ns nt lq nu nv nw lt jz nx ka lw kc ny kd lz kf nz kg mc oa bi translated">耶特。</h1></div></div>    
</body>
</html>