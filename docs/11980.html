<html>
<head>
<title>Running asynchronous redux-saga tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">运行异步redux-saga测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/running-asynchronous-redux-saga-tests-324c3486a031?source=collection_archive---------5-----------------------#2022-05-04">https://levelup.gitconnected.com/running-asynchronous-redux-saga-tests-324c3486a031?source=collection_archive---------5-----------------------#2022-05-04</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="7d7a" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">显而易见的解释</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/2c81bc74a7026691f1714ecdfc4da493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*csK9-jkZdD4VENeu"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">米哈伊尔·瓦西里耶夫在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="e377" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有几种方法可以为您的React应用程序编写异步逻辑。我有经验的两个是<a class="ae kz" href="https://redux.js.org/usage/writing-logic-thunks" rel="noopener ugc nofollow" target="_blank"> redux-thunk </a>和<a class="ae kz" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank"> redux-saga </a>。我个人更喜欢redux-saga而不是redux-thunk。对我来说，它比redux-thunk更容易阅读和维护代码。</p><p id="a0d9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一开始，为redux-saga编写测试可能是一个挑战。令我惊讶的是，redux-saga医生实际上很擅长解释如何做。</p><blockquote class="lw lx ly"><p id="3261" class="la lb lz lc b ld le jv lf lg lh jy li ma lk ll lm mb lo lp lq mc ls lt lu lv in bi translated"><a class="ae kz" href="https://redux-saga.js.org/docs/advanced/Testing" rel="noopener ugc nofollow" target="_blank">测试saga有两种主要方法:逐步测试saga生成器功能或运行完整的saga并断言副作用。</a></p></blockquote><p id="4215" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我将重点测试整个传奇。这个例子足够清楚了。</p><p id="13a4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你有一个这样的传奇:</p><pre class="kk kl km kn gu md me mf mg aw mh bi"><span id="8de3" class="mi mj iu me b gz mk ml l mm mn">function* callApi(url) {<br/>  const someValue = yield select(somethingFromState);<br/>  try {<br/>    const result = yield call(myApi, url, someValue);<br/>    yield put(success(result.json()));<br/>    return result.status;<br/>  } catch (e) {<br/>    yield put(error(e));<br/>    return -1;<br/>  }<br/>}</span></pre><p id="85a7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你的测试是这样的:</p><pre class="kk kl km kn gu md me mf mg aw mh bi"><span id="e7d8" class="mi mj iu me b gz mk ml l mm mn">const dispatched = [];<br/><br/>const saga = runSaga({<br/>  dispatch: (action) =&gt; dispatched.push(action),<br/>  getState: () =&gt; ({ value: 'test' }),<br/>}, callApi, 'http://url');</span><span id="270f" class="mi mj iu me b gz mo ml l mm mn">expect(myApi).toHaveBeenCalledTimes(1)</span></pre><p id="d6ac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它就这样工作了，至少我是这么认为的。</p><p id="d904" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当你引入第二个异步调用时，问题就来了，比如额外的API调用。</p><p id="e823" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以如果你的传奇看起来像这样:</p><pre class="kk kl km kn gu md me mf mg aw mh bi"><span id="f1f0" class="mi mj iu me b gz mk ml l mm mn">function* callApi(url) {<br/>  const someValue = yield select(somethingFromState);<br/>  try {<br/>    const result = yield call(myApi, url, someValue);<br/>    const anotherResult = yield call(myApi, url, someValue);<br/>    yield put(success(result.json()));<br/>    yield put(success(anotherResult.json()));<br/>    return result.status;<br/>  } catch (e) {<br/>    yield put(error(e));<br/>    return -1;<br/>  }<br/>}</span></pre><p id="bd65" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你的测试是这样的:</p><pre class="kk kl km kn gu md me mf mg aw mh bi"><span id="1c00" class="mi mj iu me b gz mk ml l mm mn">const dispatched = [];<br/><br/>const saga = runSaga({<br/>  dispatch: (action) =&gt; dispatched.push(action),<br/>  getState: () =&gt; ({ value: 'test' }),<br/>}, callApi, 'http://url');</span><span id="cf0c" class="mi mj iu me b gz mo ml l mm mn">expect(myApi).toHaveBeenCalledTimes(2)</span></pre><p id="4b7c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您的测试将会失败，因为测试不会等待<code class="fe mp mq mr me b">runSaga</code>函数完成完整的运行。</p><p id="ad4e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">乍一看，这些文档似乎没有任何关于如何在一个saga中运行多个异步调用的具体内容。</p><p id="e94c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是在文档中稍微滚动一下，你会看到这段代码:</p><pre class="kk kl km kn gu md me mf mg aw mh bi"><span id="170f" class="mi mj iu me b gz mk ml l mm mn">const result = await runSaga({<br/>  dispatch: (action) =&gt; dispatched.push(action),<br/>  getState: () =&gt; ({ state: 'test' }),<br/>}, callApi, url).toPromise();</span></pre><p id="8e9e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是在一个saga中运行多个异步调用的关键。</p><p id="5d4c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有了这些知识，去redux-saga <a class="ae kz" href="https://redux-saga.js.org/docs/api" rel="noopener ugc nofollow" target="_blank"> API参考</a>搜索<code class="fe mp mq mr me b">toPromise</code>。您会发现<code class="fe mp mq mr me b">toPromise</code>可以与<code class="fe mp mq mr me b">runSaga</code>一起使用，并将为您正在测试的传奇返回一个承诺解决/拒绝值。</p><p id="2264" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您现在像这样断言测试:</p><pre class="kk kl km kn gu md me mf mg aw mh bi"><span id="2acb" class="mi mj iu me b gz mk ml l mm mn">expect(myApi).toHaveBeenCalledTimes(2)</span></pre><p id="1ed6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">测试不会再失败了🎉</p></div></div>    
</body>
</html>