<html>
<head>
<title>How To Build a Video Chat App from Scratch: WebRTC Demystified | Step by Step Tutorial p. 2 | Angular + PeerJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从零开始构建视频聊天App:WebRTC揭秘|循序渐进教程p. 2 | Angular + PeerJS</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-a-video-chat-app-from-scratch-webrtc-demystified-step-by-step-tutorial-p-2e74767c673?source=collection_archive---------2-----------------------#2021-03-23">https://levelup.gitconnected.com/how-to-build-a-video-chat-app-from-scratch-webrtc-demystified-step-by-step-tutorial-p-2e74767c673?source=collection_archive---------2-----------------------#2021-03-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8c5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎阅读WebRTC非神秘化系列的第2部分。在本文中，我们将使用Angular和PeerJS(一个JavaScript WebRTC包装库)从头开始构建一个简单的视频聊天应用程序。如果你现在因为不知道WebRTC是什么而紧张不安，首先要冷静下来，其次去看看这个系列的第1部分<a class="ae kl" href="https://ullal-aaron.medium.com/what-powers-google-meet-and-microsoft-teams-webrtc-demystified-step-by-step-tutorial-e0cb422010f7" rel="noopener">吧</a>，我们在这里见😎</p><p id="8a6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们今天要建造的:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/0446e7a62fd9346c98eeee77a8e7fcec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*vhN5iLMZoVbDh91a7Ms7ew.gif"/></div></div></figure><p id="eaae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里找到一个<a class="ae kl" href="https://angularpeerjs.web.app/" rel="noopener ugc nofollow" target="_blank">工作演示</a>和<a class="ae kl" href="https://github.com/ullalaaron/angular-peerjs" rel="noopener ugc nofollow" target="_blank"> GitHub repo这里</a>。你激动吗？如果是的话，让我们开始派对吧🚀</p><h1 id="fed9" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">先决条件</strong></h1><ol class=""><li id="7e30" class="lw lx iq jp b jq ly ju lz jy ma kc mb kg mc kk md me mf mg bi translated">角度的基本知识</li><li id="81a7" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">安装了<a class="ae kl" href="https://angular.io/guide/setup-local" rel="noopener ugc nofollow" target="_blank">Angular</a>的计算机</li><li id="15a3" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">读/写能力</li></ol><h1 id="a83a" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">阶段0:设置</strong></h1><p id="e0b9" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">让我们从创建一个全新的Angular项目开始:</p><p id="e642" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mp mq mr ms b"><strong class="jp ir">ng new angular-peerjs</strong></code></p><p id="64a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦项目设置好了(不需要路由，我使用scss进行样式设计)，让我们进入新创建的项目目录并添加<a class="ae kl" href="https://material.angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular Material </a>来给我们的UI一个最起码的美学尊严:</p><p id="7cdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mp mq mr ms b"><strong class="jp ir">ng add @angular/material</strong></code></p><p id="19d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以继续安装项目的2个依赖项了:</p><p id="2340" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mp mq mr ms b"><strong class="jp ir">npm i --save peerjs uuid</strong></code></p><p id="1a2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在开始布局之前，让我们导入所有我们需要的有角度的材质组件。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><blockquote class="mv mw mx"><p id="5cd5" class="jn jo my jp b jq jr js jt ju jv jw jx mz jz ka kb na kd ke kf nb kh ki kj kk ij bi translated"><em class="iq">以后想看这个故事？</em> <a class="ae kl" href="https://usejournal.com/?utm_source=medium.com&amp;utm_medium=noteworthy_blog&amp;utm_campaign=tech&amp;utm_content=guest_post_read_later_text" rel="noopener ugc nofollow" target="_blank"> <em class="iq">把它保存在日记里。</em> </a></p></blockquote><h1 id="6b38" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">第一阶段:布局&amp;样式</strong></h1><p id="ddaf" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">让我们通过打开<code class="fe mp mq mr ms b"><strong class="jp ir">app.component.html </strong></code>文件来完成我们的基本布局。我们将构建一个简单的页面，如下所示。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nc"><img src="../Images/cc370ad63538ed46931da2979e7a8e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GQQt7HIU49fgWbuecbcntw.jpeg"/></div></div></figure><p id="b2f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，我们有3个按钮，使我们能够开始通话，加入通话和结束通话。下面我们找到两个视频元素，我们将使用它们来查看远程参与者和我们自己。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4728" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的模板中，我们使用<code class="fe mp mq mr ms b"><strong class="jp ir">isCallStarted$</strong></code> <strong class="jp ir"> </strong>来启用/禁用按钮(如果我们已经参与了一个通话，我们就不能开始通话；如果我们没有参与，我们就不能结束通话)。<code class="fe mp mq mr ms b"><strong class="jp ir">#remoteVideo</strong></code> <strong class="jp ir"> </strong>视频标签将用于播放远程对等体传输的流，而<code class="fe mp mq mr ms b"><strong class="jp ir">#localVideo</strong></code> <strong class="jp ir"> </strong>将用于播放我们的网络摄像头捕获的流。后者将<code class="fe mp mq mr ms b"><strong class="jp ir">muted</strong></code>标志设置为<code class="fe mp mq mr ms b"><strong class="jp ir">true</strong></code>，否则您会听到自己的声音两次。</p><p id="d76d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们在<code class="fe mp mq mr ms b"><strong class="jp ir">app.component.scss</strong></code>文件中添加一些基本的样式，以使我们的本地视频更小，并锚定在屏幕的右下方:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="17c8" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">阶段2:开始/加入呼叫模式</h1><p id="b710" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">正如你在上面的演示中看到的，当开始或加入一个呼叫时，一个模态被打开。如果需要开始通话，该模式将显示对方的唯一id，而如果目标是连接到远程对方，该模式将允许您指定远程方的id。让我们为这个对话框创建一个新组件</p><p id="03a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mp mq mr ms b"><strong class="jp ir">ng g c callinfo-dialog</strong></code></p><p id="148a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们来看看<code class="fe mp mq mr ms b"><strong class="jp ir">callinfo-dialog</strong></code> <strong class="jp ir"> </strong>组件。该模板定义如下:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="332f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们正在加入一个呼叫，文本字段将允许我们指定远程对等id，而如果我们正在开始一个呼叫，相同的输入将被禁用，因为它将显示本地对等id。我们使用<code class="fe mp mq mr ms b"><strong class="jp ir">cdkCopyToClipboard</strong></code>指令来允许简单地通过点击文本输入来复制我们同事的id。当我们关闭模态时，如果我们正在开始一个呼叫，我们想要传递我们的对等体id，或者如果我们正在加入它，我们想要传递远程对等体id到主<code class="fe mp mq mr ms b"><strong class="jp ir">app.component.ts</strong></code> <strong class="jp ir"> </strong>(我们将在阶段3中定义)。该组件非常简单，如下所示:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9b1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，这里没什么特别的。我们告诉构造函数我们正在期待一个<code class="fe mp mq mr ms b"><strong class="jp ir">data</strong></code>对象——由main <code class="fe mp mq mr ms b"><strong class="jp ir">app.component.ts</strong></code>提供，我们稍后会看到——它包含两个属性:对等体的Id和一个布尔值，它指定我们是要加入一个呼叫还是开始一个呼叫。</p><h1 id="aa3a" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第三阶段:主要部分</h1><p id="520c" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">让我们看一下<code class="fe mp mq mr ms b"><strong class="jp ir">app.component.ts</strong></code>文件，在这里我们将把按钮的逻辑与新创建的模态绑定在一起。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e961" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个组件依赖于我们将在下一节也是最后一节分析的<code class="fe mp mq mr ms b"><strong class="jp ir">call.service.ts</strong></code>。在构造函数中，我们得到了一个对<code class="fe mp mq mr ms b"><strong class="jp ir">isCallStarted$</strong></code> observable的引用，它将负责在通话进行中禁用启动/加入通话的按钮。此外，我们初始化我们的对等体，并获得我们唯一的对等体标识符，我们将其分配给<code class="fe mp mq mr ms b"><strong class="jp ir">peerId</strong></code> <strong class="jp ir"> </strong>变量。</p><p id="32d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Angular正确地实例化了我们的组件类之后，在<code class="fe mp mq mr ms b"><strong class="jp ir">ngOnInit</strong></code>方法中，我们订阅了两个流(我们自己的和远程对等体的),并将结果设置为我们之前在模板中定义的视频元素的<code class="fe mp mq mr ms b"><strong class="jp ir">srcObject</strong></code>。</p><p id="5d6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在由start/join call按钮触发的<code class="fe mp mq mr ms b"><strong class="jp ir">showModal</strong></code> <strong class="jp ir"> </strong>方法中，我们打开模态并传递两个变量:如果我们正在开始呼叫，我们将<code class="fe mp mq mr ms b"><strong class="jp ir">joinCall</strong></code>设置为false，并传递我们对等体的id(以便我们可以复制它并将其提供给远程对等体)，如果我们正在尝试加入呼叫，我们将<code class="fe mp mq mr ms b"><strong class="jp ir">joinCall</strong></code>设置为true，将<code class="fe mp mq mr ms b"><strong class="jp ir">peerId</strong></code>设置为null。当我们关闭该模式时，我们或者让我们的对等体应答呼叫——如果我们已经开始了一个呼叫的话——或者我们尝试与远程对等体建立呼叫，远程对等体的id由用户在该模式中提供。</p><h1 id="c8ae" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">阶段4:呼叫服务</h1><p id="ad66" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">这是魔法真正发生的地方，我们的同伴被创建，我们提供所有关于如何开始通话、接听和结束通话的指令。因为这是一个<a class="ae kl" href="https://gist.github.com/ullalaaron/fe32d384319f32094b1b8c822f95fb45" rel="noopener ugc nofollow" target="_blank"> 130多行的代码类</a>，我们将一个方法一个方法地分解它，看看到底发生了什么。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="80db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开始时，我们定义将要使用的变量:我们的peer，一个对实际调用连接的引用，两个行为主体/可观察对象对，用于管理并向外部世界公开本地和远程流，另一个行为主体/可观察对象对用于公开调用的状态(开始或结束)。在构造函数中，我们指示Angular DI注入<code class="fe mp mq mr ms b"><strong class="jp ir">MatSnackBar</strong></code>，我们将使用它来显示错误消息。如果导入peerjs时出现错误，打开<code class="fe mp mq mr ms b"><strong class="jp ir">tsconfig.json</strong></code>文件并设置<code class="fe mp mq mr ms b"><strong class="jp ir">allowSyntheticDefaultImports":true</strong></code></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c6b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个方法是我们为对等体定义配置的地方。<code class="fe mp mq mr ms b"><strong class="jp ir">PeerJSOption</strong></code>允许我们配置ICE:正如你所看到的，我们使用了Google提供的两个免费的STUN服务器(要了解更多关于ICE和STUN的信息，请参考我在本系列的前一篇文章)。如果我们有一个服务器，我们可以把它添加到列表中。在设置好我们的<code class="fe mp mq mr ms b"><strong class="jp ir">peerJSOption</strong></code>之后，我们生成一个新的惟一id并实例化我们的对等体。我们的客户端现在将连接到PeerJS的公共服务器(<a class="ae kl" href="https://github.com/peers/peerjs-server" rel="noopener ugc nofollow" target="_blank">也可以在本地部署</a>)，它将为我们处理信令。如果一切顺利，我们返回我们的同行的id。</p><p id="3146" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然我们的对等体已经被正确初始化了，是时候做真正的事情了🚀</p><p id="3c8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">发起调用的对等点调用<code class="fe mp mq mr ms b"><strong class="jp ir">establishMediaCall</strong></code>方法，该方法将远程对等点的id作为输入参数，并执行以下操作:</p><ol class=""><li id="2af7" class="lw lx iq jp b jq jr ju jv jy nd kc ne kg nf kk md me mf mg bi translated">尝试从本地设备(如网络摄像头和麦克风)获取音频/视频流，一旦获取，它将被提供给<code class="fe mp mq mr ms b"><strong class="jp ir">localStreamBs</strong></code>行为主体，该行为主体将依次将其提供给所有注册的观察者。</li><li id="c65c" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">尝试与远程对等方建立连接</li><li id="5371" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">一旦与对方建立了连接，呼叫就开始了。</li><li id="58c0" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">如果呼叫被应答- <code class="fe mp mq mr ms b"><strong class="jp ir">this.mediaCall.on('stream')</strong></code>回调-<code class="fe mp mq mr ms b"><strong class="jp ir">remoteStreamBs</strong></code>被提供远程流，组播给所有注册的观察者。</li><li id="b4a3" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">如果出现任何错误，它们都会被记录下来，并通知用户发生了什么错误。</li></ol><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="112c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应答呼叫的对等点调用<code class="fe mp mq mr ms b"><strong class="jp ir">enableCallAnswer</strong></code>方法。此方法执行以下操作:</p><ol class=""><li id="e52a" class="lw lx iq jp b jq jr ju jv jy nd kc ne kg nf kk md me mf mg bi translated">尝试从本地设备(如网络摄像头和麦克风)获取音频/视频流，一旦获取，它将被提供给<code class="fe mp mq mr ms b"><strong class="jp ir">localStreamBs</strong></code>行为主体，该行为主体将依次将其提供给所有注册收听的观察者。</li><li id="dbb4" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">对等方的<code class="fe mp mq mr ms b"><strong class="jp ir">call</strong></code> <strong class="jp ir"> </strong>回调已注册。一旦收到来电，该方法自动应答(将指示对等方开始向对方发送本地流)并开始监听远程流，该流被馈送给<code class="fe mp mq mr ms b"><strong class="jp ir">remoteStreamBs</strong></code>行为主体。</li><li id="ca09" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">如果有错误，记录下来并通知用户哪里出错了</li></ol><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="bdd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然已经定义了开始/应答呼叫的逻辑，我们需要做的最后一件事就是处理呼叫的结束。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ca6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们终止一个呼叫时，我们简单地停止所有曲目，包括远程和本地流。在退出应用程序之前，我们要确保我们结束了所有活动的调用并销毁了我们的对等体。</p><p id="cf32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！我们现在准备好<code class="fe mp mq mr ms b"><strong class="jp ir">ng serve</strong></code>我们的应用程序，尽情享受吧！</p><p id="a15f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="my"> PS:如果你得到下面的错误:</em> <code class="fe mp mq mr ms b"><strong class="jp ir">parcelRequire is not defined</strong></code> <em class="my">，打开index.html文件，在头标签</em>中放置以下内容</p><p id="ceab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mp mq mr ms b"><strong class="jp ir">&lt;script&gt;var parcelRequire;&lt;/script&gt;</strong></code></p><h1 id="440d" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="c66a" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">在这两篇系列文章中，我们已经了解了WebRTC是如何工作的，然后只用我们的双手构建了一个小巧的视频聊天应用程序。和一个非常强大的JavaScript框架。和一个为我们处理所有WebRTC东西的库。但是我们做到了🔥所以，给自己一个鼓励，回头见🚀</p><p id="5912" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="my">如果你喜欢这篇文章，请随意留下一两千个掌声，和你的奶奶谈谈，给我发几个比特币，做一个后空翻，或者在下面的部分留下评论:)</em></p><p id="f4bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="my">ETH:0 xe 00 ef 8 a6 d 7 c 43 BD 164d 41332 D5 e 577 be 9 BD 830 b 6</em></p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="8ccd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">📝将这个故事保存在<a class="ae kl" href="https://usejournal.com/?utm_source=medium.com&amp;utm_medium=noteworthy_blog&amp;utm_campaign=tech&amp;utm_content=guest_post_read_later_text" rel="noopener ugc nofollow" target="_blank">日志</a>中。</p></div></div>    
</body>
</html>