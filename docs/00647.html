<html>
<head>
<title>Scikit-Learn Machine Learning Classification 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scikit-Learn机器学习分类101</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scikit-learn-machine-learning-classification-101-c431de2dc2b2?source=collection_archive---------5-----------------------#2019-06-15">https://levelup.gitconnected.com/scikit-learn-machine-learning-classification-101-c431de2dc2b2?source=collection_archive---------5-----------------------#2019-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/95d77e246d6b0846801541ec400cc5a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A4JfpvOsHQrAu-iFWvLjiA.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://www.promptcloud.com/wp-content/uploads/2019/02/machine-learning-hearing-aid-article.jpg" rel="noopener ugc nofollow" target="_blank">https://www . prompt cloud . com/WP-content/uploads/2019/02/machine-learning-head-aid-article . jpg</a></figcaption></figure><div class=""/><p id="d8cf" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章不是关于移动或web开发或云平台，而是关于我对机器学习世界的探索。虽然我仍然是这个领域的探索者，但我会时不时地在博客上写下我的观察。</p><p id="ccea" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们继续之前，让我们理解这篇文章的目标。这篇文章提出了一个常见的机器学习问题，这个问题之前已经讨论并解决了。我的主要意图不是再次解决问题本身，而是使用<a class="ae jd" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> Scikit-Learn Python库</a>解释用于教育目的的机器学习分类程序的过程。</p><h1 id="c68a" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">最低要求条款</h1><p id="04cb" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在深入研究要解决的问题之前，我想指出一些我们需要理解的重要术语。</p><h2 id="9725" class="me lc jg bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">监督学习</h2><p id="0b66" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你有一个针对特定问题的输入输出数据(又名训练数据)(通常由领域专家提供)，目标是让机器在做了<strong class="kf jh">训练</strong>后，发现一个将输入数据映射到输出数据的一般规律。经过适当的训练后，机器可以以特定的精度水平预测任何输入的输出。</p><p id="2700" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们将在本文中讨论的分类问题(虹膜问题)。我们将有一些花瓣和萼片宽度和高度的数据，以及它们相应的物种类型。这样，我们就可以根据花瓣和萼片的宽度和高度来预测花卉的种类(在分类中，输出必须是训练数据中的可用输出之一)。</p><p id="aca9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">监督学习也包括类似于分类问题的回归问题。基于以前的训练，输入被映射到输出。但是在回归的情况下，输出是一个估计值<strong class="kf jh">而不仅仅是一类输出</strong>(例如，根据特定公司的股票价格历史数据预测其股票价格，它可以是任何正数)。</p><h2 id="bcde" class="me lc jg bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">无监督学习</h2><p id="55a6" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在无监督学习中，您有没有标签的输入数据，机器学习算法的责任是找出数据中所需的逻辑关系。这在聚类等问题中很有用。聚类和分类之间的区别在于，在聚类中(与分类不同)，您不知道数据组是什么。</p><p id="451e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无监督学习超出了本文的范围，但是我将在单独的帖子中讨论它。</p><p id="b940" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有其他类型的学习，如<strong class="kf jh">半监督</strong>和<strong class="kf jh">重新执行</strong>学习，但它们也超出了本文的范围。</p><h1 id="4727" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">虹膜问题描述</h1><p id="9ffa" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这是一个很常见的问题，在<a class="ae jd" href="https://en.wikipedia.org/wiki/Iris_flower_data_set" rel="noopener ugc nofollow" target="_blank">维基百科</a>中有很好的记录。Iris flower数据集或Fisher's Iris数据集是由英国统计学家和生物学家罗纳德·费雪在其1936年的论文<em class="mq">“多元测量在分类问题中的使用，作为线性判别分析的一个例子”中引入的多元数据集。</em></p><p id="0c93" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据集由来自鸢尾属三个花种(<code class="fe mr ms mt mu b">setosa</code>、<code class="fe mr ms mt mu b">virginica</code>和<code class="fe mr ms mt mu b">versicolor</code>)的每一个的许多样本组成。从cm中的每个样本测量四个特征:<br/> 1。萼片的长度。<br/> 2。花瓣的长度。<br/> 3。萼片的宽度。<br/> 4。花瓣的宽度。</p><p id="0560" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基于这四个特征的组合，Fisher开发了一个线性判别模型来区分花卉物种。下面是每个物种的样本数据。</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ca"><img src="../Images/4e54e087a77b09ef7e949d0797116563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1iKWRY_alMDX4odG9pHm7Q.png"/></div></div></figure><p id="a33b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能会问一个合理的问题——花瓣和花萼有什么区别？要回答这个问题，我参考<a class="ae jd" href="https://www.quora.com/What-is-the-difference-between-sepals-and-petals" rel="noopener ugc nofollow" target="_blank"> Quora </a>里的一个很棒的回答:两者的主要区别是花瓣形成花的内轮，而萼片形成花的外轮，如下图。</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/9258dcbef83dbed8cf62b7d18d338976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*r-HuqkOpo-0z4kH7VFkb5w.jpeg"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://www.quora.com/What-is-the-difference-between-sepals-and-petals" rel="noopener ugc nofollow" target="_blank">https://www . quora . com/萼片和花瓣的区别是什么</a></figcaption></figure><p id="7e48" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给定这个数据集，我们希望训练我们的分类器能够根据其萼片和花瓣数据预测鸢尾花的类别。</p><h1 id="462a" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">分类过程</h1><p id="44b2" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了对虹膜进行分类，我们将执行以下步骤:<br/> 1 .加载虹膜数据集。<br/> 2。将数据分成训练集和测试集。<br/> 3。在训练集上训练模型。<br/> 4。计算模型精确度。<br/> 5。对外部输入数据执行预测。</p><p id="2fdb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了执行所有这些步骤，我们将使用scikit-learn python库:<br/><a class="ae jd" href="https://scikit-learn.org/stable/tutorial/basic/tutorial.html" rel="noopener ugc nofollow" target="_blank">https://scikit-learn.org</a></p><p id="75f7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">scikit-learn库是一个非常强大的Python库，它通过Python中一致的API提供了广泛的监督和非监督学习算法。它建立在安装Sci-kit learn之前必须安装的SciPy和NumPy之上。</p><p id="aec8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用python pip3，您可以通过以下方式安装它:</p><pre class="mv mw mx my gt na mu nb nc aw nd bi"><span id="1d3b" class="me lc jg mu b gy ne nf l ng nh">pip3 install -U numpy scipy scikit-learn</span></pre><p id="46b6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们进入分类步骤的细节。</p><h2 id="6b47" class="me lc jg bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">1.正在加载数据集</h2><p id="c9bf" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">scikit-learn附带了iris数据集，因此我们在第一步中只需加载现有数据集，提取输入数据<code class="fe mr ms mt mu b">iris.data</code>，并输出目标数据<code class="fe mr ms mt mu b">iris.target</code>，如下面的代码所示。</p><pre class="mv mw mx my gt na mu nb nc aw nd bi"><span id="0d72" class="me lc jg mu b gy ne nf l ng nh">from sklearn.datasets import load_iris</span><span id="bbb8" class="me lc jg mu b gy ni nf l ng nh">iris = load_iris()</span><span id="8295" class="me lc jg mu b gy ni nf l ng nh">data = iris.data</span><span id="127a" class="me lc jg mu b gy ni nf l ng nh">target = iris.target</span><span id="a525" class="me lc jg mu b gy ni nf l ng nh">target_names = iris.target_names</span></pre><p id="3f91" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mr ms mt mu b">iris.target_names</code>是指我们在引言中所说的特征名称。对于这个问题，我们有4个特性，所以如果我们打印<code class="fe mr ms mt mu b">iris.target_names</code>，我们将得到如下输出。</p><pre class="mv mw mx my gt na mu nb nc aw nd bi"><span id="155c" class="me lc jg mu b gy ne nf l ng nh">[‘setosa’ ‘versicolor’ ‘virginica’]</span></pre><h2 id="c5de" class="me lc jg bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">2.为培训和测试拆分数据</h2><p id="42f7" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了测试我们的训练模型的准确性，我们需要一些关于准确性的参考，其中一种技术是将实际数据分成训练集和测试集，以便我们可以使用训练来进行实际的训练过程，然后使用测试集来验证模型输出并验证模型的准确性。让我们看看如何使用scikit-learn API来实现这一点。</p><pre class="mv mw mx my gt na mu nb nc aw nd bi"><span id="9124" class="me lc jg mu b gy ne nf l ng nh">from sklearn.model_selection import train_test_split</span><span id="09c3" class="me lc jg mu b gy ni nf l ng nh">data_train, data_test, target_train, target_test = train_test_split(self.data, self.target, test_size=0.3, random_state=12)</span></pre><p id="6ef5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe mr ms mt mu b">train_test_split()</code> API，在一行中就可以进行数据分割，它需要以下参数:</p><p id="4530" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1.<strong class="kf jh">输入</strong>数据(<code class="fe mr ms mt mu b">self.data</code>)。<br/> 2。<strong class="kf jh">目标</strong>数据(<code class="fe mr ms mt mu b">self.target</code>)。<br/> 3。<strong class="kf jh">测试大小</strong>，这表示我们想要在测试分割中包含整个数据集的多少，如果该参数是float，它应该在0.0和1.0之间，并表示要包含在测试分割中的数据集的比例(<code class="fe mr ms mt mu b">test_size=0.3</code>)。<br/> 4。<strong class="kf jh">随机</strong>状态只是一个随机数种子(<code class="fe mr ms mt mu b">random_state=12</code>)。</p><h2 id="4548" class="me lc jg bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">3.培训模式</h2><p id="15c8" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在，我们需要开始在训练集上训练模型。我们将使用K-Neighbors分类器来执行这个分类(关于这个分类器如何工作的细节超出了这篇介绍性文章的范围):<br/><a class="ae jd" href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html" rel="noopener ugc nofollow" target="_blank">https://sci kit-learn . org/stable/modules/generated/sk learn . Neighbors . kneighborsclassifier . html</a></p><p id="8e7c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以使用下面两行代码来训练模型。</p><pre class="mv mw mx my gt na mu nb nc aw nd bi"><span id="37b4" class="me lc jg mu b gy ne nf l ng nh">from sklearn.neighbors import KNeighborsClassifier</span><span id="f102" class="me lc jg mu b gy ni nf l ng nh">classifier = KNeighborsClassifier()</span><span id="ea3f" class="me lc jg mu b gy ni nf l ng nh">classifier.fit(data_train, target_train)</span></pre><p id="ca3e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe mr ms mt mu b">fit()</code>方法训练模型，将训练的输入数据<code class="fe mr ms mt mu b">data_train</code>作为第一个参数，将目标输出数据<code class="fe mr ms mt mu b">target_train</code>作为第二个参数。</p><h2 id="7db7" class="me lc jg bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">4.计算模型精确度</h2><p id="5ca5" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了计算模型精度，我们将使用测试分割<code class="fe mr ms mt mu b">data_test</code>来预测步骤3中建立的模型，然后我们将使用<code class="fe mr ms mt mu b">metrics.accuracy_score()</code> API来计算预测输出<code class="fe mr ms mt mu b">target_pred</code>如何远离原始正确输出<code class="fe mr ms mt mu b">target_test</code>。</p><pre class="mv mw mx my gt na mu nb nc aw nd bi"><span id="a860" class="me lc jg mu b gy ne nf l ng nh">from sklearn import metrics</span><span id="4c31" class="me lc jg mu b gy ni nf l ng nh">target_pred = classifier.predict(data_test)</span><span id="7a3f" class="me lc jg mu b gy ni nf l ng nh">accuracy = metrics.accuracy_score(target_test, target_pred)</span></pre><p id="212f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mr ms mt mu b">accuracy_score()</code>将原始正确输出<code class="fe mr ms mt mu b">target_test</code>作为第一个参数，在第二个参数中，将预测输出<code class="fe mr ms mt mu b">target_pred</code>作为第二个参数。最后，<code class="fe mr ms mt mu b">accuracy_score()</code>返回一个从<code class="fe mr ms mt mu b">0</code>到<code class="fe mr ms mt mu b">1</code>的分数，其中<code class="fe mr ms mt mu b">1</code>表示性能最好，0表示性能最差。</p><p id="4f26" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们打印精度变量，我们会发现它等于<code class="fe mr ms mt mu b">0.9777777777777777</code>，这是一个非常好的精度。</p><h2 id="d890" class="me lc jg bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">5.执行实际预测</h2><p id="772f" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">最后，我们到了最后一步，即执行实际的预测。为此，我们创建了一些外部测试输入样本，并将询问模型是否可以预测鸢尾花的数据是属于setosa、virginica还是versicolor。让我们用下面的三行代码来看看如何做到这一点。</p><pre class="mv mw mx my gt na mu nb nc aw nd bi"><span id="2698" class="me lc jg mu b gy ne nf l ng nh">external_input_sample = [[5, 2, 4, 1], [6, 3, 5, 2], [5, 4, 1, 0.5]]</span><span id="a797" class="me lc jg mu b gy ni nf l ng nh">prediction_raw_values = classifier.predict(external_input_sample)</span><span id="6640" class="me lc jg mu b gy ni nf l ng nh">prediction_resolved_values = [target_names[p] for p in prediction_raw_values]</span></pre><p id="1dd7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们打印<code class="fe mr ms mt mu b">prediction_resolved_values</code>，我们会发现预测出来的是:</p><p id="6684" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mr ms mt mu b">[‘versicolor’, ‘virginica’, ‘setosa’]</code></p><h1 id="ba83" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">把所有的部分连接起来，包装起来</h1><p id="17b9" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">实际上，我们可以将前面的所有分类步骤总结为两个抽象步骤:</p><p id="44b7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1.培训(从步骤1到4)。<br/> 2。预测(第五步)。</p><p id="b70b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以按需添加额外的抽象步骤模型保存/加载，以避免每次都重新训练模型。这都由这个简单的<strong class="kf jh">basicrisclassifier</strong>类来处理。</p><figure class="mv mw mx my gt is"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9573" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行这个Python类后，我们将得到以下输出。</p><pre class="mv mw mx my gt na mu nb nc aw nd bi"><span id="e237" class="me lc jg mu b gy ne nf l ng nh">Model Accuracy: 0.9777777777777777</span><span id="a933" class="me lc jg mu b gy ni nf l ng nh">Prediction for [[5, 2, 4, 1], [6, 3, 5, 2], [5, 4, 1, 0.5]] =&gt;</span><span id="dfd4" class="me lc jg mu b gy ni nf l ng nh">[‘versicolor’, ‘virginica’, ‘setosa’]</span></pre><p id="2522" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你可能在最后注意到的，我们调用了<code class="fe mr ms mt mu b">saveModel()</code>，它使用joblib的<code class="fe mr ms mt mu b">dump()</code> API保存了实际的模型。还有一个调用<code class="fe mr ms mt mu b">loadModel()</code>的注释行，它可以使用joblib的<code class="fe mr ms mt mu b">load()</code> API加载模型，如果你想避免每次执行这个类时重新训练你的模型，这一步很重要。这意味着我们可以简单地做以下事情来预测任何外部输出。</p><pre class="mv mw mx my gt na mu nb nc aw nd bi"><span id="bedc" class="me lc jg mu b gy ne nf l ng nh">basic_iris_classifier.loadModel()</span><span id="e98d" class="me lc jg mu b gy ni nf l ng nh">prediction = basic_iris_classifier.predict(external_input_sample)</span><span id="8787" class="me lc jg mu b gy ni nf l ng nh">print(“Prediction for {0} =&gt; \n{1}”.format(external_input_sample, prediction))</span></pre><p id="fb53" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，这段代码在我的GitHub里有，你可以随意检查它，提问，想怎么玩就怎么玩:<br/><a class="ae jd" href="https://github.com/hazems/basic-knn-classifier-python" rel="noopener ugc nofollow" target="_blank">https://github.com/hazems/basic-knn-classifier-python</a></p><p id="8228" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">快乐学习:)。</p><p id="479c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢<a class="ae jd" href="http://twitter.com/mohammed_nabil" rel="noopener ugc nofollow" target="_blank"> @mohammed_nabil </a>和<a class="ae jd" href="https://www.linkedin.com/in/yogeswararaol/" rel="noopener ugc nofollow" target="_blank"> Rao，Yogeswara </a>。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><div class="mv mw mx my gt ns"><a href="https://gitconnected.com/learn/python" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jh gy z fp nx fr fs ny fu fw jf bi translated">学习Python -最佳Python教程(2019) | gitconnected</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">80大Python教程-免费学习Python。课程由开发人员提交并投票，使您能够…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">gitconnected.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og ix ns"/></div></div></a></div></div></div>    
</body>
</html>