<html>
<head>
<title>How to Access Host Resources from a Docker Container</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从Docker容器访问主机资源</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-access-host-resources-from-a-docker-container-317e0d1f161e?source=collection_archive---------2-----------------------#2021-03-18">https://levelup.gitconnected.com/how-to-access-host-resources-from-a-docker-container-317e0d1f161e?source=collection_archive---------2-----------------------#2021-03-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0a3f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">绕过Docker抽象</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6c4b552e3feb5de4cc561502f1f83c50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sssMt3-edaVd73BoiBYVhg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@goosegrease?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">德里克·奥扬</a>在<a class="ae kv" href="/s/photos/whale?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="d87a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管Docker试图将应用程序从运行它的主机上抽象出来，但它永远不会被完全忽略。为了提供它的抽象，Docker必须添加一个间接层。这些层可能会对您正在运行的系统产生影响，有时您需要了解它们来解决操作问题。</p><p id="9af8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将研究如何规避其中的一些抽象，最终得到一个几乎没有Docker的Docker容器。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="ac38" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">名称空间和Docker</h2><p id="5285" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">Docker卷便于从主机共享文件，并将较大的文件放在图像层之外。它们的文件系统访问速度也比容器文件系统快得多，因为某些存储后端会给某些工作负载带来巨大的开销。</p><p id="ed33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Docker为每个容器提供自己的网络接口的设置会导致另一个性能下降。与文件系统性能一样，网络性能肯定不是每个人的瓶颈，但您可能希望对自己进行基准测试。此外，你可能还有其他理由完全绕过Docker网络。</p><p id="aa8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不管是什么原因，有时候Docker抽象会阻碍你的工作，Docker确实提供了根据需要选择退出的能力。</p><p id="16f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Docker提供了几种绕过Docker使用的内核名称空间功能的方法。</p><blockquote class="mx my mz"><p id="cf02" class="kw kx na ky b kz la jr lb lc ld ju le nb lg lh li nc lk ll lm nd lo lp lq lr ij bi translated"><strong class="ky ir">什么是名称空间？</strong>名称空间是由内核提供给程序的一种服务，它允许程序以一种看起来拥有单独的资源实例的方式获得全局资源的视图。例如，一个程序可以请求一个网络名称空间，这将为您提供一个完整的网络堆栈。Docker使用并管理这些名称空间来创建它的容器。</p></blockquote><p id="266c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下表总结了Docker如何使用名称空间，以及如何有效地关闭它们。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/dba4ad78887658b73cfc70ccdb15c5ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*xwAvDtURc1dTXfTnnZV7Tw.png"/></div></figure><p id="adce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果您的应用程序大量使用共享内存，并且您希望容器与主机共享这个空间，那么您可以使用<code class="fe nf ng nh ni b">--ipc=host</code>标志来实现这一点。Docker目前不使用Linux内核的用户名称空间功能，尽管在这方面一直在努力。</p><h2 id="4dc4" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">建立工作关系网</h2><p id="5c96" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">要使用主机的网络，运行容器，将<code class="fe nf ng nh ni b">--net</code>标志设置为host，如下所示:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="5784" class="lz ma iq ni b gy nn no l np nq">fabripautasso@Fabricios-MacBook-Pro ~ $ docker run -it --net=host ubuntu /bin/bash</span><span id="541b" class="lz ma iq ni b gy nr no l np nq">root@docker-desktop:/#</span></pre><p id="3d46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您会注意到这与网络命名空间的容器有很大的不同，因为容器中的主机名与主机的主机名相同。实际上，这可能会引起混淆，因为你在一个容器中并不明显。</p><p id="b8a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在网络隔离的容器中，快速的netstat将显示启动时没有连接:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="1a14" class="lz ma iq ni b gy nn no l np nq">root@3f17f5f70226:/# netstat</span><span id="0d36" class="lz ma iq ni b gy nr no l np nq">Active Internet connections (w/o servers)</span><span id="1c4e" class="lz ma iq ni b gy nr no l np nq">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><span id="6722" class="lz ma iq ni b gy nr no l np nq">tcp        0      0 3f17f5f70226:52242      actiontoad.canonical:80 TIME_WAIT</span><span id="104e" class="lz ma iq ni b gy nr no l np nq">tcp        0      0 3f17f5f70226:52240      actiontoad.canonical:80 TIME_WAIT</span><span id="fcf0" class="lz ma iq ni b gy nr no l np nq">tcp        0      0 3f17f5f70226:50128      kazooie.canonical.co:80 TIME_WAIT</span><span id="55bd" class="lz ma iq ni b gy nr no l np nq">Active UNIX domain sockets (w/o servers)</span><span id="ed7f" class="lz ma iq ni b gy nr no l np nq">Proto RefCnt Flags       Type       State         I-Node   Path</span></pre><p id="8141" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用主机网络的类似运行显示了同样繁忙的技术作者的通常网络繁忙的主机:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="fa5c" class="lz ma iq ni b gy nn no l np nq">root@docker-desktop:/# netstat -nap | head</span><span id="a301" class="lz ma iq ni b gy nr no l np nq">Active Internet connections (servers and established)</span><span id="61d0" class="lz ma iq ni b gy nr no l np nq">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><span id="e6bc" class="lz ma iq ni b gy nr no l np nq">tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      -</span><span id="fd11" class="lz ma iq ni b gy nr no l np nq">tcp        0      0 0.0.0.0:65101           0.0.0.0:*               LISTEN      -</span><span id="4905" class="lz ma iq ni b gy nr no l np nq">tcp        0      0 192.168.65.3:62732      91.189.88.152:80        TIME_WAIT   -</span><span id="e64e" class="lz ma iq ni b gy nr no l np nq">tcp        0      0 192.168.65.3:62730      91.189.88.152:80        TIME_WAIT   -</span><span id="d7b5" class="lz ma iq ni b gy nr no l np nq">tcp        0      0 192.168.65.3:62734      91.189.88.152:80        TIME_WAIT   -</span><span id="325c" class="lz ma iq ni b gy nr no l np nq">tcp6       0      0 :::111                  :::*                    LISTEN      -</span><span id="21a2" class="lz ma iq ni b gy nr no l np nq">tcp6       0      0 :::62141                :::*                    LISTEN      -</span><span id="4e97" class="lz ma iq ni b gy nr no l np nq">udp        0      0 0.0.0.0:64167           0.0.0.0:*                           -</span></pre><p id="37fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于几个原因，<code class="fe nf ng nh ni b">—-net=host</code>标志是最常用的标志。首先，它可以使连接容器更容易。但是，您将失去容器端口映射的好处。例如，如果您有两个监听端口80的容器，您不能以这种方式在同一台主机上运行它们。</p><p id="9288" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个原因是，使用这个标志时，网络性能比Docker好很多。虽然本地网络只需要通过主机的TCP/IP堆栈运行到网络接口卡(NIC)，但Docker必须额外维护一个虚拟以太网对(也称为veth对，是通过以太网电缆的物理连接的虚拟表示)，一个位于这对网络和主机网络之间的网桥，以及一个网络地址转换(NAT)层。在正常使用情况下，这种开销可能会导致Docker网络速度仅为本地主机网络速度的一半。</p><h2 id="4df5" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">PID</h2><p id="68d5" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">PID名称空间标志看起来像:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="5f0c" class="lz ma iq ni b gy nn no l np nq">fabripautasso@Fabricios-MacBook-Pro ~ $ docker run ubuntu ps -p 1</span><span id="56f7" class="lz ma iq ni b gy nr no l np nq">PID TTY          TIME CMD</span><span id="5b7e" class="lz ma iq ni b gy nr no l np nq">1 ?        00:00:00 ps</span><span id="6d97" class="lz ma iq ni b gy nr no l np nq">fabripautasso@Fabricios-MacBook-Pro ~ $ docker run --pid=host ubuntu ps -p 1</span><span id="0973" class="lz ma iq ni b gy nr no l np nq">PID TTY          TIME CMD</span><span id="c019" class="lz ma iq ni b gy nr no l np nq">1 ?        00:00:07 init</span></pre><p id="0c83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前面的例子演示了主机的<code class="fe nf ng nh ni b">init</code>进程在具有主机PID视图的容器中具有进程ID 1，而没有该视图，看到的唯一进程是ps命令本身。</p><h2 id="d726" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">增加</h2><p id="baaa" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如果您想要访问主机的设备，如果您想要使用特定的设备，您可以使用<code class="fe nf ng nh ni b">--device</code>标志，或者您可以使用<code class="fe nf ng nh ni b">--volume</code>标志挂载整个主机的文件系统:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="6be0" class="lz ma iq ni b gy nn no l np nq">docker run -ti —- volume /tmp:/ctmp ubuntu /bin/bash</span></pre><p id="2dc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个命令将主机的<code class="fe nf ng nh ni b">/tmp</code>目录挂载到容器的<code class="fe nf ng nh ni b">ctmp</code>目录。docker命令明确禁止将主机的<code class="fe nf ng nh ni b">/</code>目录挂载到容器的<code class="fe nf ng nh ni b">/</code>目录。</p><h2 id="bdf2" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">透明主机</h2><p id="875c" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">您可以使用这些标志创建一个几乎包含主机视图的容器:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="2966" class="lz ma iq ni b gy nn no l np nq">fabripautasso@Fabricios-MacBook-Pro ~ $ <br/>docker run -ti --net=host --pid=host --ipc=host \             1<br/>--volume /:/tmp \                                             2<br/>busybox chroot /tmp                                           3</span></pre><ul class=""><li id="4b7a" class="ns nt iq ky b kz la lc ld lf nu lj nv ln nw lr nx ny nz oa bi translated">1 —使用文章<code class="fe nf ng nh ni b">--net</code>、<code class="fe nf ng nh ni b">--ipc</code>和<code class="fe nf ng nh ni b">--pid</code>中讨论的3个标志运行容器</li><li id="425a" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated">2 —将主机的根文件系统装载到容器上的目录<code class="fe nf ng nh ni b">/tmp</code></li><li id="118c" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated">3 —启动一个<code class="fe nf ng nh ni b">busybox</code>容器，并执行<code class="fe nf ng nh ni b">chroot</code>命令，使挂载的文件系统显示为根。</li></ul><h2 id="12fe" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">最后的想法</h2><p id="dcb1" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">使用这些标志来绕过Docker的抽象将使您面临更多的安全风险。在安全性方面，使用它们应该等同于运行带有<code class="fe nf ng nh ni b">--privileged</code>标志的容器。所以，如果你需要使用它们，一定要小心。</p></div></div>    
</body>
</html>