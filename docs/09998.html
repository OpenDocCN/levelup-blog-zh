<html>
<head>
<title>Runbook to optimise your CI/CD pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化CI/CD渠道的操作手册</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/runbook-to-optimise-your-ci-cd-pipelines-7e0f4fc47e9a?source=collection_archive---------3-----------------------#2021-10-12">https://levelup.gitconnected.com/runbook-to-optimise-your-ci-cd-pipelines-7e0f4fc47e9a?source=collection_archive---------3-----------------------#2021-10-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/beb16c50b78d5e4a2807c3aac1569624.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ic9Ou8ZXZeiADVCXpOaKIw.jpeg"/></div></div></figure><p id="d8c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">近年来，许多组织已经转向DevOps文化。持续集成和持续交付是CI/CD最重要的方面。今天，许多工程团队的目标是最快地部署缺陷修复和特性。为了实现这一目标，必须拥有强大的CI/CD渠道。然而，我们还需要考虑实施这些解决方案的成本。</p><p id="c712" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我认为将您的流程容器化是走向有效管道的第一步。如果您正在处理CI/CD管道，并且已经将它们容器化，那么下面是我学到的一些东西，您可以实现它们来减少您的架构的时间和成本。</p><ol class=""><li id="93d2" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">使用浅克隆。</li><li id="fd29" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">不同的<em class="lk">。dockerignore </em>文件。</li><li id="0555" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">使用DOCKER_BUILDKIT。</li><li id="7eca" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">对docker构建使用远程缓存。</li><li id="736f" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">尽可能并行运行命令。</li><li id="d5cd" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">禁用npm进程并使用并行工作进程。</li></ol><h1 id="393e" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">使用浅层克隆:</h1><p id="75a0" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">标准克隆命令通常会取出所有文件以及所有文件的全部修订历史。这需要很多时间(取决于存储库的大小和历史)。相反，使用浅层克隆可以为您节省大量时间，因为它只会根据给定的深度提取最新版本。</p><h2 id="286d" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kj mt mu lz kn mv mw md kr mx my mh mz bi translated"><strong class="ak">怎么用？</strong></h2><p id="2856" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated"><strong class="ka ir"> Jenkins: </strong>您可以在Jenkins高级配置中设置浅克隆和深度克隆。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/e3def59312756037a78ef586a30c9f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*selWPWTD9aGJTVljY-rEqA.png"/></div></figure><p id="09b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> AWS CodeBuild: </strong>您可以在AWS CodeBuild项目配置中设置克隆深度，如下所示。(参见:<a class="ae nf" href="https://aws.amazon.com/codebuild/" rel="noopener ugc nofollow" target="_blank">https://aws.amazon.com/codebuild/</a>)</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/bf44828bb188205ae09d64e0d9d47e38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Es6r1GGWSOLpQGhCE2CxgQ.png"/></div></div></figure><p id="795a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Shell </strong>:使用<em class="lk">深度</em>和你的git克隆命令。</p><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="fdb4" class="mo lm iq ni b gy nm nn l no np">git clone --depth</span></pre><p id="f5ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> CircleCi </strong>:你可以使用下面的CircleCi orbs来设置一个浅层克隆体。(参见:<a class="ae nf" href="https://circleci.com/docs/2.0/orb-intro/" rel="noopener ugc nofollow" target="_blank">https://circleci.com/docs/2.0/orb-intro/</a>)</p><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="31c1" class="mo lm iq ni b gy nm nn l no np"> git-shallow-clone/checkout</span></pre><h1 id="24d1" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">不一样。dockerignore文件:</h1><p id="0272" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">如果您对管道使用docker，那么这是节省映像构建时间的另一种方式。Docker build将忽略<em class="lk"> dockerignore </em>中列出的所有文件和文件夹，因此您可以将所有不需要的文件作为您的CI或CD的一部分放在<em class="lk">中。T21号。也可以不止一个<em class="lk">。如果您想为CI和CD共享相同的docker映像，请使用dockerignore </em>文件。这样，您可以将测试中需要但开发中不需要的文件和文件夹列表放入<em class="lk"> .dockerignore.prod </em>中，从而加快部署。</em></p><h2 id="aa79" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kj mt mu lz kn mv mw md kr mx my mh mz bi translated"><strong class="ak">怎么用？</strong></h2><p id="ae39" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">对于ci，创建一个名为<em class="lk"> .dockerignore.ci </em>的文件，并将运行CI不需要的文件和文件夹放入其中。对于部署，创建一个名为<em class="lk"> .dockerignore.prod </em>的文件，并将不需要的文件和文件夹放入其中。在CI管道中，在docker构建步骤之前运行下面的命令。</p><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="b06f" class="mo lm iq ni b gy nm nn l no np">ln -fs .dockerignore.ci .dockerignore</span></pre><p id="21c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">类似地，对于部署，在构建步骤之前运行下面的命令。</p><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="95f1" class="mo lm iq ni b gy nm nn l no np">ln -fs .dockerignore.prod .dockerignore</span></pre><h1 id="6f86" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">使用DOCKER_BUILDKIT:</h1><p id="774e" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">Docker buildkit是最新Docker版本19.03中新增的功能之一。Buildkit通过缓存和并行运行可能的层来提供快速的docker构建。启用buildkit后，您的docker映像构建时间将会比其他方式减少。</p><h2 id="1f8d" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kj mt mu lz kn mv mw md kr mx my mh mz bi translated"><strong class="ak">怎么用？</strong></h2><p id="2163" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在开始docker构建之前，运行以下命令:</p><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="658a" class="mo lm iq ni b gy nm nn l no np">export DOCKER_BUILDKIT=1</span></pre><p id="769b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它有各种选项可以添加到docker文件中。我展示了一个如何为pip安装启用缓存的例子。</p><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="b598" class="mo lm iq ni b gy nm nn l no np">COPY requirements.txt $PROJECT_DIR/</span><span id="5611" class="mo lm iq ni b gy nq nn l no np">RUN — mount=type=cache,target=/root/.cache/pip pip install -r $PROJECT_DIR/requirements.txt</span></pre><p id="dc54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">参考:<a class="ae nf" href="https://docs.docker.com/develop/develop-images/build_enhancements/" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/develop/develop-images/build _ enhancements/</a></p><h1 id="0a96" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">docker版本的远程缓存:</h1><p id="4b44" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">如果您正在使用不提供docker层缓存的CI工具或服务，那么使用远程缓存可能是一个非常有用的选择，可以节省大量的构建时间。如果没有docker层缓存，每个docker层每次都将从头开始构建。这将在所有构建上花费更多的时间。相反，如果您管理管道的方式是在docker hub或AWS ECR上推送标准基础映像，并且docker build使用该映像的缓存，那么您将节省大量构建时间。</p><h2 id="0f61" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kj mt mu lz kn mv mw md kr mx my mh mz bi translated"><strong class="ak">怎么用？</strong></h2><ol class=""><li id="f223" class="kw kx iq ka b kb mj kf mk kj nr kn ns kr nt kv lb lc ld le bi translated">从Dockerfile创建docker映像</li><li id="ff2c" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">将图像推送到AWS ECR ( <base_image_uri>)</base_image_uri></li><li id="c423" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">构建管道中docker builds命令中的include-cache-from参数。</li></ol><p id="1c62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如:</p><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="07fe" class="mo lm iq ni b gy nm nn l no np">Docker build -f Dockerfile — cache-from &lt;base_image_uri&gt; -t &lt;image_name&gt;</span></pre><h1 id="38a3" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">尽可能并行运行命令:</h1><p id="35ec" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">如果在管道的一个作业或阶段中要执行多个任务，如果它们是独立的，可以考虑并行运行它们。</p><h2 id="e17b" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kj mt mu lz kn mv mw md kr mx my mh mz bi translated">怎么用？</h2><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="696f" class="mo lm iq ni b gy nm nn l no np">Command 1 &amp;<br/>Command 2 &amp;<br/>Command 3 &amp;<br/>wait</span></pre><p id="b8b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您还想收集所有进程的退出代码，并基于此继续或终止管道，可以参考这里提供的一些建议:<a class="ae nf" href="https://stackoverflow.com/questions/1570262/get-exit-code-of-a-background-process" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/1570262/get-exit-code-of-a-background-process</a></p><h1 id="ff3a" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">将npm进度设置为false或使用yarn:</h1><p id="d3ee" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">如果您正在构建npm模块作为管道的一部分，您可以使用yarn install/build或者禁用npm进度条。这两者都将在构建web包时节省大量时间。</p><h2 id="5c2d" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kj mt mu lz kn mv mw md kr mx my mh mz bi translated"><strong class="ak">怎么用？</strong></h2><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="f215" class="mo lm iq ni b gy nm nn l no np">npm set progress false<br/>npm install<br/>npm build</span></pre><p id="00ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还可以考虑并行运行web包。选择与构建web包的系统中可用内核数量相同的工作线程数量。</p><p id="bb0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(详情在此:<a class="ae nf" href="https://www.npmjs.com/package/parallel-worker)" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/parallel-worker)</a></p><p id="6f4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用上述解决方案，我们已经成功实现了自动化、更快的CI和部署流程。我们已经成功减少了超过50%的执行时间和99%的人工干预。此外，我们已经能够降低整个基础架构的成本，因为我们的大多数工具/服务都是按使用量付费的模式。如果你有兴趣了解更多，可以看看我在AWS博客上写的这篇文章。</p><div class="nu nv gp gr nw nx"><a href="https://aws.amazon.com/blogs/startups/hackerearth-scales-up-continuous-integration-for-future-needs-with-aws-codebuild-and-amazon-s3/" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">HackerEarth通过AWS | Amazon Web Services扩展持续集成以满足未来需求</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">每个快节奏组织的目标之一是拥有一个持续集成(CI)管道，以确保每个…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">aws.amazon.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol jw nx"/></div></div></a></div></div></div>    
</body>
</html>