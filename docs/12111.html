<html>
<head>
<title>Apache Kafka Architecture and how does it work</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">阿帕奇卡夫卡架构及其工作原理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/apache-kafka-architecture-and-how-does-it-work-54e99f72b9be?source=collection_archive---------4-----------------------#2022-05-16">https://levelup.gitconnected.com/apache-kafka-architecture-and-how-does-it-work-54e99f72b9be?source=collection_archive---------4-----------------------#2022-05-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d07931726b03f0e0a269cbe773000870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j4yt_xWBrHOeoStKZyitbQ.png"/></div></div></figure><p id="4a90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Apache Kafka是分布式事件存储。它基于发布者-订阅者模式。它为高度可伸缩的系统提供冗余和并发性。</p><p id="9982" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你更喜欢视频而不是文字，你可以在Youtube上找到同样的视频解释:【https://youtu.be/f8BDoivhtG4 T2】</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="0fc6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要理解卡夫卡，我们首先要理解出版商-订户模式。我们先来看看传统建筑的问题。</p><p id="5c40" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在传统架构的情况下，许多服务将对其他服务进行API调用。例如，我们有一个日志服务和指标服务，分别用于存储指标和指标和日志。因此，这种传统架构存在两个问题:首先，如果任何服务由于部署或任何故障而中断。从应用程序发送的信息将被丢弃，这将导致数据丢失。另一方面，如果我们看看这里的网络，这里的网络似乎非常混乱。</p><p id="7d87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以传统建筑有两个问题</p><ol class=""><li id="f0b5" class="lf lg iq ka b kb kc kf kg kj lh kn li kr lj kv lk ll lm ln bi translated">部署或服务中断时的数据丢失</li><li id="23de" class="lf lg iq ka b kb lo kf lp kj lq kn lr kr ls kv lk ll lm ln bi translated">网络非常混乱，这使得开发人员很难调试这些问题。</li></ol><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lt"><img src="../Images/d2e7b980d53b0d4b4513eafeeeb1fc87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YwyH1T1-QZcXBTEXbjKGxQ.png"/></div></div></figure><p id="358a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们使用发布者-订阅者模式来解决这个问题。在发布者-订阅者模式的情况下，我们在中间引入了一个代理。先前对服务进行REST API调用的应用程序现在将向代理发布数据。另一方面，较早接收数据的服务将从代理接收数据。</p><p id="dc19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，这里的网络非常干净，因为我们只使用来自代理的所有数据。</p><p id="f281" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">如果任何服务(如度量服务或日志服务)停止运行，该怎么办？</em></p><p id="9a62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，消息将由代理保留，不会丢失。当特定服务再次启动并运行时，它将能够使用从代理发布的数据。</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/5c731850a4f82502bad637a83d45f900.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bdk-u39uUnN0Wd9-IF4wgg.png"/></div></div></figure><h1 id="9116" class="lz ma iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated"><strong class="ak">卡夫卡是什么？</strong></h1><p id="5bad" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated">用技术术语来说，Kaka是一个分布式提交日志。</p><p id="0529" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以现在让我们试着分解一下，理解卡夫卡的各个组成部分。</p><ol class=""><li id="428d" class="lf lg iq ka b kb kc kf kg kj lh kn li kr lj kv lk ll lm ln bi translated">代理和消息</li><li id="f6b5" class="lf lg iq ka b kb lo kf lp kj lq kn lr kr ls kv lk ll lm ln bi translated">话题和政治家</li><li id="d03b" class="lf lg iq ka b kb lo kf lp kj lq kn lr kr ls kv lk ll lm ln bi translated">出版商消费者和消费者群体</li></ol><p id="9444" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">经纪人和消息</strong></p><p id="2a21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为卡夫卡一般分布在多台机器上。每台运行卡夫卡实例的机器。这些机器被称为代理。发布者发送给代理的信息称为消息。</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/1b1a1545b0af62974e32cdb5d4559e4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MljyXLEvMWMuqUXGZW8RRg.png"/></div></div></figure><p id="5e3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">主题和分区:</strong></p><p id="f559" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，当我们讨论Kaka是一个分布式提交日志时，我们可以假设这个主题是一个巨大的提交日志文件。主题相当于数据库中存储所有信息的表。所以出版商会将数据放入特定的主题中。主题是只附加文件系统，其中所有消息都附加在日志文件的末尾。这些主题被细分成更小的部分，这些部分被称为分区。这些分区用于使我们的系统更具可伸缩性，并在特定时间为并发请求提供服务。</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/3cf51ce13cba4e3350ba7b872a5e4379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xMit64vlD4ht7ycZZHbb9w.png"/></div></div></figure><p id="89ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">发布者</strong>:发布者是把数据推进卡夫卡的机器。</p><p id="e9f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">消费者</strong>:消费者从特定主题中读取数据。</p><p id="d357" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">代理</strong>:运行卡夫卡的个人机器被称为代理。</p><p id="3b54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">主题</strong>:主题相当于数据库中的表格。它是存储信息的抽象。</p><p id="3757" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">分区</strong>:主题的一个子分区称为分区。</p><h1 id="e133" class="lz ma iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated"><strong class="ak">卡夫卡是如何工作的？</strong></h1><p id="4214" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated">所以出版商过去常常在卡夫卡的主题中推送信息。一个卡夫卡主题被分成若干分区。特定主题的分区基于分区关键字来标识。这个分区密钥是由Kafka Broker通过在消息上运行一致的算法而生成的。</p><p id="6c76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将卡夫卡主题中的数据分成了更小的请愿书。将有一组消费者订阅特定的主题并接收数据进行处理。订阅特定主题的一组消费者被称为<strong class="ka ir">消费者群体。</strong></p><p id="910e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，每个使用者都维护偏移量，直到处理完数据。因此，消费者使用当前偏移量来轮询kaka代理，并要求在此之后发布数据。如果主题中存在许多这样的数据，消费者将获得这些数据。在接收到数据时，消费者将更新其偏移量，并将新偏移量标记为数据已被处理的点的标记。</p><figure class="lu lv lw lx gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div></div>    
</body>
</html>