<html>
<head>
<title>Exploiting App PIN Mechanisms on Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Android上的应用PIN机制</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/exploiting-custom-protection-mechanisms-in-apps-5983ecd936f6?source=collection_archive---------5-----------------------#2020-07-03">https://levelup.gitconnected.com/exploiting-custom-protection-mechanisms-in-apps-5983ecd936f6?source=collection_archive---------5-----------------------#2020-07-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4471" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">定位和利用自定义应用程序保护方法。</h2></div><p id="b40c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">移动应用是我们日常生活的一部分，从银行、消息、健康、金融到社交网络；但是这类app大多有什么共同点呢？</p><p id="1629" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们都持有某种私人用户数据。</p><p id="f71f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论这些数据是账号、私人信息、信用卡账单，还是你最后一次登记入住的地点……就在你家拐角处的那家不错的咖啡馆。我们的设备存储了大量信息，这些信息可能会帮助某些人窃取身份。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/b3bd2d6ca434a81b4551509b22f82b8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uDmwQ7GGiPLGpoXN"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">照片由<a class="ae lr" href="https://unsplash.com/@morningbrew?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">晨酿</a>在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><blockquote class="ls"><p id="3a9d" class="lt lu iq bd lv lw lx ly lz ma mb la dk translated">我们依靠应用程序开发人员来充分保护我们放入他们应用程序的数据。</p></blockquote><p id="73c5" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">作为用户，如果我们决定使用一个应用程序，我们必须依靠开发者来创建一个安全的应用程序并保护我们存储的数据；这是我们对他们的绝对信任。我们有用户名、密码、生物特征，但是那些添加到应用程序中试图保护这些私人信息免受恶意攻击的自定义安全特性呢？别针之类的保护措施？</p><p id="8545" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看一个应用程序，它有一个自定义的PIN输入机制，作为一个单独的防线，以防其他人物理访问设备或知道锁屏密码。这将是一个二级认证机制，试图平衡可用性和安全性，这样用户就不必每次使用应用程序时都登录。</p><p id="679b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不是在讨论PIN是如何存储的，也不是围绕它的加密。我们对PIN实现的实际逻辑和内部工作方式以及潜在的弱点感兴趣。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="bcef" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">一根针统治所有人</h1><h2 id="5f5b" class="ng mp iq bd mq nh ni dn mu nj nk dp my ko nl nm na ks nn no nc kw np nq ne nr bi translated">密码</h2><p id="363b" class="pw-post-body-paragraph kf kg iq kh b ki ns jr kk kl nt ju kn ko nu kq kr ks nv ku kv kw nw ky kz la ij bi translated">在第一个例子中，我们将展示如何修补应用程序，使其允许任何PIN工作，而不管用户创建的原始PIN。</p><p id="0027" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在查看Java代码时，我们看到一个名为<em class="nx">onpisubmit</em>()的方法，我们可以看到它返回void，因此没有任何东西被传递回调用方法。所有的PIN功能都在这里处理。</p><p id="0d63" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了绕过这个认证，我们需要确保我们总是触发适当的IF条件。</p><ol class=""><li id="c926" class="ny nz iq kh b ki kj kl km ko oa ks ob kw oc la od oe of og bi translated">之前已经设置了一个PIN，因此它存在。</li><li id="5882" class="ny nz iq kh b ki oh kl oi ko oj ks ok kw ol la od oe of og bi translated">提交的PIN字符串不为空。</li><li id="aea0" class="ny nz iq kh b ki oh kl oi ko oj ks ok kw ol la od oe of og bi translated">将存储的PIN与刚刚提交的PIN进行比较。</li></ol><p id="90cf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果PIN有效，则If通过，代码继续运行到第153行。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi om"><img src="../Images/34a2a291d21d2485e8cceeab503c7296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vuYqVBjafKOw_yUciSmNYw.png"/></div></div></figure><p id="1b00" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在查看smali时，我们可以清楚地看到这些IF条件和检查结果被传递到变量v0中，并根据第477、485和493行的值跳转到cond_2。这些语句与上面的三个要点相匹配，所以第493行实际比较了两个PIN字符串，这是最后一次检查。</p><p id="4511" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个比较是用语句来完成的，<strong class="kh ir"> if-eqz v0，:cond_2 </strong>，由此跳转到<strong class="kh ir"> cond_2 </strong>，<strong class="kh ir"> if </strong>的值<strong class="kh ir"> v0 </strong>是<strong class="kh ir"> eq </strong> ual到<strong class="kh ir"> z </strong> ero。等于零意味着如果字符串不匹配，结果将为0/False。如果PIN串匹配，结果将为1/真，并且不会跳转到<strong class="kh ir"> cond_2 </strong>。</p><p id="6bb2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">前面条件的结果，<em class="nx">是空的</em>，使用相反的，<strong class="kh ir"> if-nez v0，:cond_2，</strong>，因此如果结果为1/True将跳转。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi on"><img src="../Images/49576388021356295613b0bcbad21b1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LPWQhtqy-bfjsvIKhm-vbw.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">构成存储和输入PIN的条件比较的三个条件。</figcaption></figure><h2 id="539c" class="ng mp iq bd mq nh ni dn mu nj nk dp my ko nl nm na ks nn no nc kw np nq ne nr bi translated">修补</h2><p id="20e5" class="pw-post-body-paragraph kf kg iq kh b ki ns jr kk kl nt ju kn ko nu kq kr ks nv ku kv kw nw ky kz la ij bi translated">很明显，我们不想跳到<strong class="kh ir"> cond_2 </strong>，第493行的最后一次检查是最关键的，因为这是改变v0值的最后一个条件。如果我们修改上面的代码，一旦检查完成，v0将被另一个值覆盖。</p><blockquote class="ls"><p id="9f13" class="lt lu iq bd lv lw oo op oq or os la dk translated">注意到方法的返回值是布尔型的，我们可以开始构建我们的引脚旁路。</p></blockquote><p id="09f6" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">我们还可以看到，<em class="nx"> isEmpty </em>和<em class="nx"> equals </em>方法的返回值都是布尔值，这提供了我们修补该检查的方法。</p><p id="1811" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们可以修改从字符串的<em class="nx">等于</em>检查中接受值的行，而不是移动实际检查的结果，我们可以将常数1硬编码到v0中。</p><pre class="lc ld le lf gt ot ou ov ow aw ox bi"><span id="690d" class="ng mp iq ou b gy oy oz l pa pb">move-result v0  --&gt;  const/4 v0, 0x1</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi pc"><img src="../Images/1d3af6b6aadc26d0e5740ac5526baf29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mviMqMGR8IDnuh_YfUNoiQ.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">硬编码值1以确保检查返回True</figcaption></figure><p id="79bb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个补丁可以简单地反转smali条件语句的逻辑，使其在有效引脚而不是无效引脚上跳转到cond_2。然而，当用户试图使用该应用程序并插入正确的PIN码时，这可能会触发用户注意到有些不对劲，但它不起作用。这意味着在这种情况下选择1更可取。</p><pre class="lc ld le lf gt ot ou ov ow aw ox bi"><span id="020b" class="ng mp iq ou b gy oy oz l pa pb">if-eqz v0, :cond_2  --&gt;  if-nez v0, :cond_2</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi pd"><img src="../Images/f2182518edbcb81a9e20cd7790c5da28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5DKvJkQkU2DoBs9v4M104w.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">当输入不正确的PIN时，反转条件检查以返回True。然而，当输入真实的PIN时，这也将返回False</figcaption></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="804e" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">无限制PIN重试</h1><h2 id="a35d" class="ng mp iq bd mq nh ni dn mu nj nk dp my ko nl nm na ks nn no nc kw np nq ne nr bi translated">密码</h2><p id="360d" class="pw-post-body-paragraph kf kg iq kh b ki ns jr kk kl nt ju kn ko nu kq kr ks nv ku kv kw nw ky kz la ij bi translated">PIN认证机制还具有另一种保护；这种额外的安全措施是对不正确的PIN尝试进行计数。在3次不正确的尝试后，该应用程序将注销，并强制用户使用有效的用户名和密码重新进行完全验证。</p><p id="10a0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在与上面的PIN检查相同的类中，发现了一个名为<em class="nx"> checkPINRetryCount </em>()的返回void方法。这是一个非常简单的代码块，它检查在<em class="nx">onpisubmit</em>()方法中增加的错误尝试变量是否等于3。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/8be43a4371263eb2fd2b54b1269645ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*5sPJZDZvts4p0QAqREsHjw.png"/></div></figure><p id="a9e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们看一下smali代码，我们可以立即看到这个检查中包含的逻辑缺陷。重试计数器限值被硬编码为常量十进制值0x3，然后在第281行进行比较，<strong class="kh ir"> if-ne v0，v1，:cond_0 </strong>。</p><ul class=""><li id="88a8" class="ny nz iq kh b ki kj kl km ko oa ks ob kw oc la pf oe of og bi translated">如果<strong class="kh ir"> v0 </strong>不等于<strong class="kh ir"> v1 </strong>，则跳转到<strong class="kh ir"> cond_0。</strong></li><li id="793f" class="ny nz iq kh b ki oh kl oi ko oj ks ok kw ol la pf oe of og bi translated">:cond_0将<strong class="kh ir">返回-void </strong>。</li></ul><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi pg"><img src="../Images/4a25c2b3b58ca635e0d3694fd2b996e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SC96izw_db6hgFFjg1ArkQ.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">硬编码不正确的尝试值和比较检查</figcaption></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="572a" class="ng mp iq bd mq nh ni dn mu nj nk dp my ko nl nm na ks nn no nc kw np nq ne nr bi translated">修补</h2><p id="9b71" class="pw-post-body-paragraph kf kg iq kh b ki ns jr kk kl nt ju kn ko nu kq kr ks nv ku kv kw nw ky kz la ij bi translated">与前面的例子一样，由于机制的简单性，有多种方法可以绕过这种检查。</p><p id="fb04" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有以下选择:</p><ul class=""><li id="8639" class="ny nz iq kh b ki kj kl km ko oa ks ob kw oc la pf oe of og bi translated">在执行实际的比较检查之前，添加一个新的代码语句，以便在调用方法后立即返回void。</li></ul><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ph"><img src="../Images/0de875991c53e64634df684194e51a5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wS2D9VR1rGfrI1kxJAnw1w.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">通过在比较相等之前返回void来绕过检查。</figcaption></figure><ul class=""><li id="e08b" class="ny nz iq kh b ki kj kl km ko oa ks ob kw oc la pf oe of og bi translated">也可以更改第279行的硬编码限值。将其从3大幅增加到999，以允许更多的尝试。</li></ul><blockquote class="pi pj pk"><p id="b7d6" class="kf kg nx kh b ki kj jr kk kl km ju kn pl kp kq kr pm kt ku kv pn kx ky kz la ij bi translated">注意，在这种情况下，我们必须用<strong class="kh ir"> const/16 </strong>替换<strong class="kh ir"> const/4 </strong>，因为我们需要更多位来表示值为999的整数。</p></blockquote><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi po"><img src="../Images/f1507838d051cd8fed89b07982945ad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QRbDsCejx8-M1VyujLkpog.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">修改重试值以允许999次尝试，而不是原来的3次。</figcaption></figure><ul class=""><li id="7608" class="ny nz iq kh b ki kj kl km ko oa ks ob kw oc la pf oe of og bi translated">将比较指令替换为相反的等价指令<strong class="kh ir"> if-eq </strong>，同时改变用于比较的寄存器，以便始终返回True。<br/>修改后的代码现在将比较v1== v1，或0x3 == 0x3，并且总是为真以跳转到cond_0，即return-void语句。</li></ul><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi pp"><img src="../Images/3778c5d6d924b0996a5b13defdf5c06e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CIZDeClWdmw8zAiw4mvQjg.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">反转条件检查比较语句，使其始终返回True。</figcaption></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="9c13" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经看了两个以PIN输入形式自定义实现额外安全机制的例子。虽然从用户和开发的角度来看，这些额外保护的想法似乎是一个很好的想法，但如果不确保安全性是开发生命周期的一部分，就有可能在代码流中引入非常基本的缺陷，任何攻击者都可以利用这些缺陷。</p><p id="b573" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这些只是简单的例子，但它们代表了自制安全解决方案的一个非常现实的问题。任何自制程序的实现都应该比应用程序的其他部分更加关注安全性，其他部分可能会使用嵌入式开源库或供应商支持的API。</p><p id="fab5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的攻击媒介是一个非常真实的威胁，因为我们已经看到最困难的部分不是绕过防御，而是社交工程用户安装修改后的应用程序，并获得物理访问以从设备获取信息。</p></div></div>    
</body>
</html>