<html>
<head>
<title>Practical DDD in Golang: Repository</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">戈朗实用DDD:知识库</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/practical-ddd-in-golang-repository-d308c9d79ba7?source=collection_archive---------0-----------------------#2021-10-05">https://levelup.gitconnected.com/practical-ddd-in-golang-repository-d308c9d79ba7?source=collection_archive---------0-----------------------#2021-10-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="6ba4" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">领域驱动设计</h2><div class=""/><div class=""><h2 id="692f" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用著名的DDD模式——存储库实现反腐败层。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/daf323f008b474cf03cba804f9d36e55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RrLcVXjJg97-RRjU"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">乔治·科登伯格三世在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="9a10" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">今天，很难想象在运行时不访问一些存储就能编写一些应用程序。甚至可能不需要编写部署脚本，因为它们需要访问配置文件，从某种意义上说，这些文件仍然是存储类型。</p><p id="0999" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每当你编写一些应用程序来解决现实商业世界中的一些问题时，你都需要连接到数据库、外部API、一些缓存系统等等。这是不可避免的。</p><p id="f67a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从这个角度来看，有一个DDD模式可以满足这种需求就不足为奇了。当然，DDD并没有在其他文献中发明Repository及其许多设备，但是DDD增加了更多的清晰度。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="b553" class="mj mk it mf b gy ml mm l mn mo">Other articles from DDD series:</span><span id="ed2b" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">1. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-value-object-4fc97bcad70"><strong class="mf jd">Practical DDD in Golang: Value Object</strong></a></span><span id="ec6f" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-entity-40d32bdad2a3"><strong class="mf jd">Practical DDD in Golang: Entity</strong></a></span><span id="ada2" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">3. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-domain-service-4418a1650274"><strong class="mf jd">Practical DDD in Golang: Domain Service</strong></a></span><span id="7530" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">4. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-domain-event-de02ad492989"><strong class="mf jd">Practical DDD in Golang: Domain Event</strong></a></span><span id="df48" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">5. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-module-51edf4c319ec"><strong class="mf jd">Practical DDD in Golang: Module</strong></a></span><span id="cfec" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">6. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-aggregate-de13f561e629"><strong class="mf jd">Practical DDD in Golang: Aggregate</strong></a></span><span id="2549" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">7. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-factory-5ba135df6362"><strong class="mf jd">Practical DDD in Golang: Factory</strong></a></span></pre><div class="mq mr gp gr ms mt"><a href="https://blog.ompluscator.com/membership" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd jd gy z fp my fr fs mz fu fw jc bi translated">通过我的推荐链接加入媒体——马尔科·米洛耶维奇</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">blog.ompluscator.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh lb mt"/></div></div></a></div><h1 id="a02b" class="ni mk it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">反腐败层</h1><p id="cbb2" class="pw-post-body-paragraph li lj it lk b ll nz kd ln lo oa kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">领域驱动设计是一个我们可以应用到软件开发的许多方面和许多地方的原则。尽管如此，主要的焦点还是在领域层，我们的业务逻辑应该在那里。</p><p id="5f24" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于存储库总是代表一种结构，这种结构保存了与一些外部世界连接的技术细节，它已经不属于我们的业务逻辑。</p><p id="ace4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，有时，我们需要从领域层内部访问存储库。由于领域层位于底层，不与其他层通信，因此我们将存储库定义在其中，而是作为一个接口。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">合同示例</figcaption></figure><p id="2d60" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个接口我们称之为契约，它定义了我们可以在域内调用的方法签名。在上面的例子中，我们可以找到这样一个简单的接口，它定义了<a class="ae lh" href="https://www.codecademy.com/articles/what-is-crud" rel="noopener ugc nofollow" target="_blank"> CRUD </a>方法。</p><p id="8f9a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为我们将存储库定义为这样的接口，所以我们可以在域层的任何地方使用它。它总是期望并返回我们的实体，在这种情况下，<code class="fe og oh oi mf b">Customer</code>和<code class="fe og oh oi mf b">Customers</code>(我喜欢在Go中定义这样的特定集合，以便为它们附加不同的方法)。</p><p id="cf0c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">实体客户不持有任何关于以下存储类型的信息:没有定义JSON结构的Go标记、<a class="ae lh" href="https://gorm.io/index.html" rel="noopener ugc nofollow" target="_blank"> Gorm </a>列或任何类似的东西。为此，我们必须使用基础设施层。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">基础设施层内部的实际实现</figcaption></figure><p id="f68d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，你可以看到<code class="fe og oh oi mf b">CustomerRepository</code>实现的一个片段。在内部，它使用Gorm来简化集成，但是您也可以使用纯SQL查询。最近，我经常使用T4图书馆。</p><p id="63d9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这个例子中，你可以看到两个不同的结构，<code class="fe og oh oi mf b">Customer</code>和<code class="fe og oh oi mf b">CustomerGorm</code>。第一个是实体，我们希望在其中保存我们的业务逻辑、一些领域不变量和规则。它对底层数据库一无所知。</p><p id="eb9f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第二个结构是一个<a class="ae lh" href="https://martinfowler.com/eaaCatalog/dataTransferObject.html" rel="noopener ugc nofollow" target="_blank">数据传输对象</a>，它定义了我们的数据如何从存储器中传输出来以及如何传输到存储器中。这个结构除了将数据库的数据映射到我们的实体之外，没有任何其他职责。</p><blockquote class="oj ok ol"><p id="4755" class="li lj om lk b ll lm kd ln lo lp kg lq on ls lt lu oo lw lx ly op ma mb mc md im bi translated">这两种结构的划分是在我们的应用程序中使用存储库作为反腐败层的基本点。它确保表结构的技术细节不会污染我们的业务逻辑。</p></blockquote><p id="77fe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里的后果是什么？首先，我们需要维护两种类型的结构，一种用于业务逻辑，一种用于存储，这是事实。此外，我还插入了第三个结构，我将它用作API的数据传输对象。</p><p id="8032" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种方法给我们的应用程序和许多映射函数带来了复杂性，就像你在下面的例子中看到的那样。而且，您希望适当地测试这些方法，以避免常见的复制粘贴错误。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">数据传输对象的反腐败</figcaption></figure><p id="b146" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">尽管如此，除了整个维护，它还为我们的代码带来了新的价值。我们可以以最好地描述我们的业务逻辑的方式在域层中提供我们的实体。我们不会用我们使用的存储来限制它们。</p><p id="30de" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以在业务内部使用一种类型的标识符(比如UUID)，在数据库中使用另一种类型的标识符(无符号整数)。这适用于我们希望用于数据库和业务逻辑的任何数据。</p><p id="f8d0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每当我们对这些层中的任何一层进行修改时，我们可能会在映射函数内部进行调整，而层的其余部分我们不会触及(或至少破坏)。</p><p id="aafe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以决定要切换到MongoDB、Cassandra或任何其他类型的存储。我们可以切换到外部API，但仍然不会影响我们的领域层。</p><h1 id="2225" class="ni mk it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">坚持</h1><p id="bd5f" class="pw-post-body-paragraph li lj it lk b ll nz kd ln lo oa kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">我们主要使用存储库进行查询。它与另一个DDD模式完美地配合，您可能会在示例中注意到这个规范。我们可以不加规范地使用它，但有时它会让我们的生活变得更轻松。</p><p id="7ce6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">存储库的第二个特性是持久性。我们定义了将数据发送到下面的存储器中的逻辑，以便永久保存、更新甚至删除数据。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">生成UUID的持久性</figcaption></figure><p id="26d0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有时我们决定在应用程序中创建惟一的标识符。在这种情况下，存储库是合适的位置。在上面的例子中，您可以看到我们在创建数据库记录之前生成了一个新的UUID。</p><p id="f822" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们想避免从数据库引擎自动递增，我们可以用整数做到这一点。在任何情况下，如果我们不希望依赖数据库键，我们应该在存储库中创建它们。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">数据库事务</figcaption></figure><p id="e7b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们希望存储库用于的另一件事是事务。每当我们想要持久化一些数据并对相同的大量表执行许多查询时，这是定义事务的最佳时机，我们应该在存储库中交付事务。</p><p id="8a97" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，我们正在检查<code class="fe og oh oi mf b">Person</code>或<code class="fe og oh oi mf b">Company</code>的唯一性。如果它们存在，我们返回一个错误。我们可以将所有这些定义为单个事务的一部分，如果那里出现问题，我们可以回滚它。</p><p id="6fd8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这里，存储库是这种代码的理想场所。很好的一点是，我们还可以在将来使我们的插入更加简单，这样我们就完全不需要事务了。在这种情况下，我们不改变存储库的契约，而只改变里面的代码。</p><h1 id="260e" class="ni mk it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">储存库的类型</h1><p id="920b" class="pw-post-body-paragraph li lj it lk b ll nz kd ln lo oa kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">认为我们应该只为数据库使用存储库是错误的。是的，我们最常将它用于数据库，因为它们是我们的首选存储，但今天其他类型的存储更受欢迎。</p><p id="c1cd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如前所述，我们可以使用MongoDB或Cassandra。我们可以使用一个存储库来保存我们的缓存，在这种情况下，例如Redis。它甚至可以是REST API或配置文件。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">不同的存储</figcaption></figure><p id="99f7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们可以看到业务逻辑和技术细节分离的真正好处。我们为我们的存储库保留了相同的接口，所以我们的域层可以一直使用它。</p><p id="55b9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，有一天，我们的应用程序可能会发展到MySQL不再是分布式应用程序的完美解决方案的地步。因此，在迁移的情况下，我们不需要担心我们的业务逻辑是否会受到影响，只要我们保持我们的接口不变。</p><blockquote class="oj ok ol"><p id="bbd4" class="li lj om lk b ll lm kd ln lo lp kg lq on ls lt lu oo lw lx ly op ma mb mc md im bi translated">因此，您的存储库契约应该总是处理您的业务逻辑，但是您的存储库实现必须使用内部结构，您可以在以后将其映射到实体。</p></blockquote><h1 id="b69f" class="ni mk it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">结论</h1><p id="4be0" class="pw-post-body-paragraph li lj it lk b ll nz kd ln lo oa kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">存储库是一种众所周知的模式，负责在底层存储中查询和保存数据。这是我们应用程序内部反腐败的要点。</p><p id="cfc7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将它定义为域层内部的一个契约，并将实际的实现放在基础设施层内部。它是生成应用程序制作的标识符和运行事务的地方。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="030b" class="mj mk it mf b gy ml mm l mn mo">Other articles from DDD series:</span><span id="93fe" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">1. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-value-object-4fc97bcad70"><strong class="mf jd">Practical DDD in Golang: Value Object</strong></a></span><span id="88f6" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-entity-40d32bdad2a3"><strong class="mf jd">Practical DDD in Golang: Entity</strong></a></span><span id="b0bf" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">3. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-domain-service-4418a1650274"><strong class="mf jd">Practical DDD in Golang: Domain Service</strong></a></span><span id="ae2f" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">4. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-domain-event-de02ad492989"><strong class="mf jd">Practical DDD in Golang: Domain Event</strong></a></span><span id="ba8f" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">5. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-module-51edf4c319ec"><strong class="mf jd">Practical DDD in Golang: Module</strong></a></span><span id="e2db" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">6. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-aggregate-de13f561e629"><strong class="mf jd">Practical DDD in Golang: Aggregate</strong></a></span><span id="b6bb" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">7. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-factory-5ba135df6362"><strong class="mf jd">Practical DDD in Golang: Factory</strong></a></span></pre><h1 id="5e6b" class="ni mk it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">有用的资源:</h1><ul class=""><li id="8756" class="oq or it lk b ll nz lo oa lr os lv ot lz ou md ov ow ox oy bi translated">https://martinfowler.com/<a class="ae lh" href="https://martinfowler.com/" rel="noopener ugc nofollow" target="_blank"/></li><li id="40d3" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md ov ow ox oy bi translated"><a class="ae lh" href="https://www.domainlanguage.com/" rel="noopener ugc nofollow" target="_blank">https://www.domainlanguage.com/</a></li></ul></div></div>    
</body>
</html>