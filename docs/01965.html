<html>
<head>
<title>Creating Automatic Jest Mocks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建自动笑话模仿</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-automatic-jest-mocks-2fe5137c2a1?source=collection_archive---------7-----------------------#2020-02-09">https://levelup.gitconnected.com/creating-automatic-jest-mocks-2fe5137c2a1?source=collection_archive---------7-----------------------#2020-02-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b13dcba1c7ab4c52ebb246417eca185c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-SsAqEtkjsEcCS9B"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@battlecreekcoffeeroasters?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Battlecreek咖啡烘焙师</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="c23b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了创建单元测试，我们经常需要模拟函数来绕过代码的各个部分。例如，如果我们不想运行在函数中调用API的代码，那么我们必须创建该函数的模拟。</p><p id="5237" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些在Jest测试中创建模拟函数和类的方法。</p><h1 id="2ce3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">ES6类模拟</h1><p id="dc23" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用Jest来创建ES6类模拟。</p><p id="7579" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">ES6类只是构造函数之上的语法糖，所以我们可以使用模拟函数的相同方法来模拟类。</p><h1 id="e1a0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">制作测试用的东西</h1><p id="022f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">首先，我们通过创建<code class="fe mh mi mj mk b">videoPlayer.js</code>并添加:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4adc" class="mt lf it mk b gy mu mv l mw mx">class VideoPlayer {<br/>    constructor() {</span><span id="fe10" class="mt lf it mk b gy my mv l mw mx">    }</span><span id="f098" class="mt lf it mk b gy my mv l mw mx">    playVideoFile(fileName) {<br/>        console.log(`Playing ${fileName}`);<br/>    }<br/>}</span><span id="b624" class="mt lf it mk b gy my mv l mw mx">module.exports = VideoPlayer;</span></pre><p id="802b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们创建<code class="fe mh mi mj mk b">app.js</code>如下:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e41e" class="mt lf it mk b gy mu mv l mw mx">const VideoPlayer = require('./videoPlayer');</span><span id="cbc1" class="mt lf it mk b gy my mv l mw mx">class VideoPlayerApp {<br/>    constructor() {<br/>        this.videoPlayer = new VideoPlayer();<br/>    }</span><span id="fc13" class="mt lf it mk b gy my mv l mw mx">    play() {<br/>        const videoFileName = 'video.mp4';<br/>        this.videoPlayer.playVideoFile(videoFileName);<br/>    }<br/>}</span><span id="6a01" class="mt lf it mk b gy my mv l mw mx">module.exports = VideoPlayerApp;</span></pre><h1 id="04cb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建自动模拟</h1><p id="31d1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在这个例子中，我们将模拟<code class="fe mh mi mj mk b">VideoPlayer</code>类。</p><p id="7651" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们可以调用<code class="fe mh mi mj mk b">jest.mock(‘./videoPlayer’);</code>，因为我们用<code class="fe mh mi mj mk b">module.exports</code>导出了<code class="fe mh mi mj mk b">VideoPlayer</code>类。</p><p id="c2e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Jest足够聪明，可以在测试中创建自己的模拟类来代替实际的<code class="fe mh mi mj mk b">VideoPlayer</code>类。</p><p id="7e19" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它将用一个模拟构造函数替换这个类，并用总是返回<code class="fe mh mi mj mk b">undefined</code>的模拟函数替换它的所有方法。</p><p id="f1c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">方法调用保存在<code class="fe mh mi mj mk b">theAutomaticMock.mock.instances[index].methodName.mock.calls</code>中，其中<code class="fe mh mi mj mk b">theAutomaticMock</code>被替换为与我们最初模仿的类相同的名称。</p><p id="b3fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的例子中，我们不打算创建自己的方法实现，所以一旦我们调用了<code class="fe mh mi mj mk b">jest.mock(‘./videoPlayer’);</code>，我们就完成了对<code class="fe mh mi mj mk b">VideoPlayer</code>类的模仿。</p><p id="1112" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以创建<code class="fe mh mi mj mk b">app.test.js</code>来放置我们的测试。我们补充如下:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ff22" class="mt lf it mk b gy mu mv l mw mx">const VideoPlayer = require('./videoPlayer');<br/>const VideoPlayerApp = require('./app');<br/>jest.mock('./videoPlayer');</span><span id="e2af" class="mt lf it mk b gy my mv l mw mx">beforeEach(() =&gt; {<br/>    VideoPlayer.mockClear();<br/>});</span><span id="3dc1" class="mt lf it mk b gy my mv l mw mx">test('VideoPlayer is called once', () =&gt; {<br/>    const videoPlayerApp = new VideoPlayerApp();<br/>    expect(VideoPlayer).toHaveBeenCalledTimes(1);<br/>});</span><span id="dc2f" class="mt lf it mk b gy my mv l mw mx">test('VideoPlayer is called with video.mp4', () =&gt; {<br/>    expect(VideoPlayer).not.toHaveBeenCalled();<br/>    const videoPlayerApp = new VideoPlayerApp();<br/>    videoPlayerApp.play();<br/>    const videoFileName = 'video.mp4';<br/>    const mockVideoPlayer = VideoPlayer.mock.instances[0];<br/>    const mockPlayVideoFile = mockVideoPlayer.playVideoFile;<br/>    expect(mockPlayVideoFile.mock.calls[0][0]).toEqual(videoFileName);<br/>    expect(mockPlayVideoFile).toHaveBeenCalledWith(videoFileName);<br/>    expect(mockPlayVideoFile).toHaveBeenCalledTimes(1);<br/>});</span></pre><p id="07d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们重视包含每个类的模块。<code class="fe mh mi mj mk b">VideoPlayer</code>类将被我们的mock替换，但是我们仍然需要导入它。</p><p id="b8f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们有我们的<code class="fe mh mi mj mk b">beforeEach</code>钩子，它运行:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="49ec" class="mt lf it mk b gy mu mv l mw mx">VideoPlayer.mockClear();</span></pre><p id="59b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">清除<code class="fe mh mi mj mk b">VideoPlayer</code>类的模拟。</p><p id="14a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们编写第一个测试，它是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9717" class="mt lf it mk b gy mu mv l mw mx">test('VideoPlayer is called once', () =&gt; {<br/>    const videoPlayerApp = new VideoPlayerApp();<br/>    expect(VideoPlayer).toHaveBeenCalledTimes(1);<br/>}););</span></pre><p id="fd07" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们创建一个新的<code class="fe mh mi mj mk b">VideoPlayerApp</code>实例。<code class="fe mh mi mj mk b">VideoPlayerApp</code>调用的构造函数运行<code class="fe mh mi mj mk b">new VideoPlayer();</code>，这意味着<code class="fe mh mi mj mk b">VideoPlayer</code>类被调用。</p><p id="ac76" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们检查:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3954" class="mt lf it mk b gy mu mv l mw mx">expect(VideoPlayer).toHaveBeenCalledTimes(1);</span></pre><p id="9c07" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这应该是正确的，因为<code class="fe mh mi mj mk b">VideoPlayer</code>构造函数，也就是类，被调用了一次。</p><p id="ea86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们来看第二个测试，它更复杂:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="95c6" class="mt lf it mk b gy mu mv l mw mx">test('VideoPlayer is called with video.mp4', () =&gt; {<br/>    expect(VideoPlayer).not.toHaveBeenCalled();<br/>    const videoPlayerApp = new VideoPlayerApp();<br/>    videoPlayerApp.play();<br/>    const videoFileName = 'video.mp4';<br/>    const mockVideoPlayer = VideoPlayer.mock.instances[0];<br/>    const mockPlayVideoFile = mockVideoPlayer.playVideoFile;<br/>    expect(mockPlayVideoFile.mock.calls[0][0]).toEqual(videoFileName);<br/>    expect(mockPlayVideoFile).toHaveBeenCalledWith(videoFileName);<br/>    expect(mockPlayVideoFile).toHaveBeenCalledTimes(1);<br/>});</span></pre><p id="a22c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们检查<code class="fe mh mi mj mk b">VideoPlayer</code>没有被调用，以确保<code class="fe mh mi mj mk b">VideoPlayer.mockClear()</code>正在工作。</p><p id="a3a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们创建一个新的<code class="fe mh mi mj mk b">VideoPlayerApp</code>实例，并对其调用<code class="fe mh mi mj mk b">play</code>，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="348c" class="mt lf it mk b gy mu mv l mw mx">const videoPlayerApp = new VideoPlayerApp();<br/>videoPlayerApp.play();</span></pre><p id="5f4f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后，我们通过运行以下命令获得我们的模拟<code class="fe mh mi mj mk b">VideoPlayer</code>实例:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="cf9e" class="mt lf it mk b gy mu mv l mw mx">const mockVideoPlayer = VideoPlayer.mock.instances[0];</span></pre><p id="2cf8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们调用被模仿的<code class="fe mh mi mj mk b">VideoPlayer</code>类的<code class="fe mh mi mj mk b">playVideoFile</code>方法如下:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9a3f" class="mt lf it mk b gy mu mv l mw mx">const mockPlayVideoFile = mockVideoPlayer.playVideoFile;</span></pre><p id="d0df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以通过使用以下命令获得传递给模拟<code class="fe mh mi mj mk b">playVideoFile</code>调用的第一个参数:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6845" class="mt lf it mk b gy mu mv l mw mx">mockPlayVideoFile.mock.calls[0][0]</span></pre><p id="9179" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以通过编写以下内容来检查调用是否通过了<code class="fe mh mi mj mk b">'video.mp4'</code>:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f070" class="mt lf it mk b gy mu mv l mw mx">expect(mockPlayVideoFile.mock.calls[0][0]).toEqual(videoFileName);</span></pre><p id="74a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">等价地，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2c8c" class="mt lf it mk b gy mu mv l mw mx">expect(mockPlayVideoFile).toHaveBeenCalledWith(videoFileName);</span></pre><p id="61f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们通过运行以下命令来检查<code class="fe mh mi mj mk b">playVideoFile</code>方法是否只被调用了一次:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b907" class="mt lf it mk b gy mu mv l mw mx">expect(mockPlayVideoFile).toHaveBeenCalledTimes(1);</span></pre><p id="33d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是有意义的，因为在我们的测试中<code class="fe mh mi mj mk b">playVideoFile</code>只被调用一次。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/bf476f03abb410ed308e4fc88037d05c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mtJ-4brR8nu1Vy4G"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@andrewtanglao?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安德鲁·唐劳</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="dfc3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">运行测试</h1><p id="3b57" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">确保通过运行以下命令安装Jest:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="cac5" class="mt lf it mk b gy mu mv l mw mx">npm i jest</span></pre><p id="a919" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并放上:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f4a0" class="mt lf it mk b gy mu mv l mw mx">"test": "jest"</span></pre><p id="a7cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mh mi mj mk b">scripts</code>部分，这样我们可以运行测试。</p><p id="400a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们应该得到:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="57c0" class="mt lf it mk b gy mu mv l mw mx">PASS  ./app.test.js<br/>  √ VideoPlayer is called once (3ms)<br/>  √ VideoPlayer is called with video.mp4 (2ms)</span><span id="7094" class="mt lf it mk b gy my mv l mw mx">Test Suites: 1 passed, 1 total<br/>Tests:       2 passed, 2 total<br/>Snapshots:   0 total<br/>Time:        2.067s<br/>Ran all test suites.</span></pre><h1 id="34e2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="7151" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有了Jest的自动模拟，我们可以很容易地模拟类或构造函数。</p><p id="9b5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有方法都用返回<code class="fe mh mi mj mk b">undefined</code>的函数模拟。</p><p id="421e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以通过使用<code class="fe mh mi mj mk b">mockedObject.mock.instances</code>来检索mock，这是一个数组。</p><p id="d776" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以像往常一样进行检查。用<code class="fe mh mi mj mk b">toEqual</code>、<code class="fe mh mi mj mk b">toHaveBeenCalledWith</code>等匹配器方法。</p></div></div>    
</body>
</html>