<html>
<head>
<title>Starting Out With Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以笑话开头</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/starting-out-with-jest-b755756792b3?source=collection_archive---------11-----------------------#2020-07-30">https://levelup.gitconnected.com/starting-out-with-jest-b755756792b3?source=collection_archive---------11-----------------------#2020-07-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/75f74f484235f85746f155ff84ba7e1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JcTvlRdxjbCiQgQm.png"/></div></div></figure><div class=""/><p id="c1b1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我已经用RSpec和Ruby on Rails做了几个后端测试博客。我已经决定用Jest做一些前端测试。首先，我在看前端测试，不确定是开始学习Jest还是Mocha。我发现了一个很棒的博客解释了这两个问题，我强烈推荐你读一下，因为它简要地讨论了这两个问题。</p><p id="c761" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://blog.usejournal.com/jest-vs-mocha-whats-the-difference-235df75ffdf3" rel="noopener ugc nofollow" target="_blank"> <strong class="kd jf"> Jest Vs摩卡博客！</strong>T3】</a></p><p id="99d7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我最终看了Jest，仅仅是因为我觉得我想使用一个简单的设置，并准备好立即使用。测试框架的工作是尽快告诉开发人员哪些地方出了问题，快速设置总是很方便的。这就是笑话！</p><p id="a7ed" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">敬测试！</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="35b0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，让我们创建Javascript项目。如下图所示。</p><p id="bfad" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回答几个问题来设置您的项目文件夹。</p><p id="227e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一行创建我们的项目，第二行将jest添加到您的devDependencies中，这意味着它不需要下载用于生产，只需要用于本地开发和测试。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/859d31110bcccf1429c850e285c0cb27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*sHgcBfyFDayRSK3GdwNZHQ.png"/></div></figure><p id="98c7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们需要向package.json添加以下部分。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/3da591662b364051c250a55297cb7958.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*-DNJrTGdzD2aEiVQ6x4KOg.png"/></div></figure><p id="9a18" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可能已经有一个脚本部分，所以只需添加测试行。</p><p id="bd14" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">完美！我们已经准备好在Javascript项目中尝试一些基本的测试。</p><p id="f828" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的src文件夹中，让我们在main.js中键入一两个快捷函数。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ln"><img src="../Images/fbda9caa57d52800d3c485da051a6b83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uvYRZAuMUOMi-LZ6RT6pPA.png"/></div></div></figure><p id="dda2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，我们在main.js中编写了一些基本函数，并在最底层导出了这些函数。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/f0245952c00ede833bdd750313f63bd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*1lx9wso7ppIn_5su_IM2UQ.png"/></div></figure><p id="4062" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，在src中创建一个名为“test”的文件夹。这里是我们编写测试文件的地方。通常，您会为项目中创建的每个js.file编写一个测试文件。这允许测试清楚地给出它正在测试什么文件，以及你的项目的什么部分。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="63e0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们在这个文件中编写一个基本的测试。首先，我们想在测试文件的顶部调用我们正在测试的js文件。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lp"><img src="../Images/dd4a84594ab345455549346a01892427.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PdsHXcUM5ZD23eEcs8oFpA.png"/></div></div></figure><p id="e1a1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦您需要我们正在测试的文件，使用析构的概念从main.js文件中提取我想要测试的函数。析构使你的代码更易读，更容易理解。</p><p id="d47e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://medium.com/@lcriswell/destructuring-props-in-react-b1c295005ce0" rel="noopener"> <strong class="kd jf">博采众长</strong> </a> <strong class="kd jf">。</strong></p><p id="271f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们把这段代码分解一下，这样我们就能理解它了。如前所述，首先我们调用我们正在测试的文件，并提取函数。接下来，我们使用一个名为describe的内置方法。</p><p id="37e8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Describe是一个Jest方法，用于描述和包含我们的测试。正如您所看到的，我给了它一个描述性的句子，以允许另一个开发人员理解块中包含了哪些测试。它有两个参数，一个是描述测试套件的字符串，另一个是包装实际测试的回调函数。</p><p id="0dad" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们使用另一个名为“测试”的内置函数。这是不言自明的。这是一个包含我们想要测试的实际代码的块！</p><p id="7567" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好了，让我们深入实际的测试块本身。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lq"><img src="../Images/bb8b2cd4fce126d5969f9409bc7aedce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aGnHV33Xi08nybN-S9D9KA.png"/></div></div></figure><p id="9b2b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里，test方法有两个参数，类似于describe方法。在这里，我们想要描述我们正在测试的方法以及我们期望它做什么。接下来，我们使用一个名为expect的Jest内置方法。</p><p id="f8f8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">expect方法包含我们从测试文件顶部的main.js中提取的函数，并传递函数运行所需的两个参数。</p><p id="d931" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们通过一个会怎么样？</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lr"><img src="../Images/7f3adf4b383974c0471ef70e65af031f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uac0qtrewiyJGBIAa_uFLg.png"/></div></div></figure><p id="1d8d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是笑话的闪光点。如您所见，如果我尝试只传入一个参数并运行我们的测试，它会失败。但是Jest给了我们一个完美的分解，它所期待的和它所收到的。您可以看到它进行了深度的相等性检查，这意味着它还检查了传递给每个测试的参数的数量，如果您想自己检查失败消息，请修复该问题，然后继续。</p><p id="de15" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们有另一个内置方法来等同于。toEqual内置方法是我们输出函数的预期结果进行匹配的地方。同样，如果我在我们的。就像括号一样，玩笑是经不起考验的。</p><p id="ccd3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">完成后，在您的终端中编写“npm运行测试”,您应该会得到:</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ls"><img src="../Images/2e45b01ff2711dd9b10e08554f146dfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uHU9TbH-Sflg8rD2oLidIQ.png"/></div></div></figure><p id="d516" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">瞧啊。Jest测试的基础知识。如果你想试验一下，试着多写几个函数，把它们导入到你的测试文件中，然后试验一下。</p><p id="7528" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">也可以使用. not的内置方法。</p><p id="a836" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">。not本质上检查测试后的函数输出是否与。不是括号。下面是一个简单的例子来帮助您理解:</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lp"><img src="../Images/a04ba23087f50db09eab832151ec6d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M3jr6GtWX4tWzZWC-OjIaA.png"/></div></div></figure><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ls"><img src="../Images/f7f634aaed41e3648a204c2b7f81eccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KDMj4qbHChv7W2nI4hrI3A.png"/></div></div></figure><p id="8326" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里2减3不等于10000(据我所知)。所以测试通过了。</p><p id="7ca9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，如果你使用小数(浮点数)，要注意你使用的是哪种内置方法。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lq"><img src="../Images/b55f14fed62b137e0c9c275f54b26a11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ey7YlAyG-zqg1OVtxievpQ.png"/></div></div></figure><p id="d78b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">。由于最终的舍入误差，toEqual实际上会失败。你必须使用。为通过考试做准备。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lt"><img src="../Images/928dc2c00271481e61036d095953969b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kDJcWL6mZtjkCPV64fbcIQ.png"/></div></div></figure><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lu"><img src="../Images/df0e14757df2ff18ba0decb880c561ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q65JshJskHLrpQBcrBHc2A.png"/></div></div></figure><p id="5465" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我的下一篇博客中，我将深入Jest，查看更多的方法匹配器，然后转向异步函数！</p></div></div>    
</body>
</html>