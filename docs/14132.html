<html>
<head>
<title>7 Java Gems Experts Like To See</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">7 Java Gems专家喜欢看的</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/7-java-gems-experts-like-to-see-236555db7d1c?source=collection_archive---------5-----------------------#2022-11-03">https://levelup.gitconnected.com/7-java-gems-experts-like-to-see-236555db7d1c?source=collection_archive---------5-----------------------#2022-11-03</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="4146" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">这里有7个Java瑰宝，可以帮助有经验的开发人员交付优秀的代码</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/c941e8ff550db165f97c5976fa8f5f65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rp4pIln9czW6m-nsF5RM4w.jpeg"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">Lexica.art</figcaption></figure><p id="9c57" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">经验丰富的Java开发人员现在应该知道这7种Java宝石了。T3】</p><p id="9b2c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">所以任何有经验的开发人员都应该尝试一下。让我们开始吧。</p><h1 id="55e6" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">1.意识</h1><p id="fee9" class="pw-post-body-paragraph kz la iu lb b lc mo jv le lf mp jy lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated"><strong class="lb iv"> <em class="lv">你可以使用这个图书馆来等待物品。咄。</em> </strong></p><p id="4bd1" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> <em class="lv">那么这有什么用例呢？你需要在哪里等待什么？</em>T11】</strong></p><p id="c78c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> <em class="lv">我的一个用例是测试卡夫卡出版。</em>T15】</strong></p><p id="b069" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您可以发送消息、处理和提交相关数据。但是你怎么知道某个东西是否被写了呢？  Kafka发布了一条消息，但是你不能马上检查数据是否被提交到数据库中。</p><p id="8962" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">你不能做这样的事:</p><pre class="kk kl km kn gu mt mu mv mw aw mx bi"><span id="5300" class="my lx iu mu b gz mz na l nb nc">kafkaTemplate.send("topic", new MessagePayload("123"));<br/>assertTrue(dbService.getMessage("123").isPresent());</span></pre><p id="0729" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这就是你需要意识的原因。您可以在一定的超时时间内等待结果。</p><h1 id="0aa2" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">2.原始消息中的字段掩码</h1><p id="b2d6" class="pw-post-body-paragraph kz la iu lb b lc mo jv le lf mp jy lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">网飞利用了这一特性。你可以在这里阅读两部分<a class="ae nd" href="https://netflixtechblog.com/practical-api-design-at-netflix-part-1-using-protobuf-fieldmask-35cfdc606518" rel="noopener ugc nofollow" target="_blank"/>和<a class="ae nd" href="https://netflixtechblog.com/practical-api-design-at-netflix-part-2-protobuf-fieldmask-for-mutation-operations-2e75e1d230e4" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><p id="3287" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">原始信息只是故事的一部分。而有了<a class="ae nd" href="https://mvnrepository.com/artifact/com.google.protobuf/protobuf-java-util" rel="noopener ugc nofollow" target="_blank"> protobuf-java </a>和<a class="ae nd" href="https://mvnrepository.com/artifact/com.google.protobuf/protobuf-java" rel="noopener ugc nofollow" target="_blank"> protobuf-java-util </a>这样的库，可以做很多事情。</p><p id="9acc" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您可以将它们用作even REST API 的<a class="ae nd" href="https://www.baeldung.com/spring-rest-api-with-protocol-buffers" rel="noopener ugc nofollow" target="_blank">有效负载，或者在需要时创建一个</a><a class="ae nd" href="https://github.com/grpc-ecosystem/grpc-gateway" rel="noopener ugc nofollow" target="_blank"> gRPC网关</a>代理。此外，您可以创建<a class="ae nd" href="https://github.com/grpc/grpc-web" rel="noopener ugc nofollow" target="_blank"> grpc-web </a>客户端并调用grpc服务。但是proto的主要目的是gRPC服务。</p></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><p id="a2e9" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">回到野外面具。您可以使用字段掩码组合消息，并从请求中过滤出您需要的内容。</p><p id="8ea1" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这在某种意义上确实类似于GraphQL查询。但重要的是，您只发送字段掩码中定义的内容。</p></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><p id="17c5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> <em class="lv">这个功能还有什么好处？</em> </strong></p><p id="8583" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您将删除多余的dto。因为您可以发送字段掩码并获得部分消息，所以您不需要dto。更少的代码意味着更好的维护。</p><h1 id="b829" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">3.测试容器</h1><p id="2753" class="pw-post-body-paragraph kz la iu lb b lc mo jv le lf mp jy lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">另一个用Java旋转测试容器的很棒的库。</p><p id="7a48" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">所有需要做的就是编写<a class="ae nd" href="https://github.com/testcontainers/testcontainers-java/blob/main/examples/spring-boot/src/test/java/com/example/AbstractIntegrationTest.java" rel="noopener ugc nofollow" target="_blank"> Java代码来旋转容器</a>。</p><pre class="kk kl km kn gu mt mu mv mw aw mx bi"><span id="1a14" class="my lx iu mu b gz mz na l nb nc">// from testcontainers docs<br/>@Testcontainers<br/>class MixedLifecycleTests {</span><span id="3797" class="my lx iu mu b gz nl na l nb nc">    // will be started before and stopped after each test method<br/>    @Container<br/>    private PostgreSQLContainer postgresqlContainer = new PostgreSQLContainer()<br/>        .withDatabaseName("foo")<br/>        .withUsername("foo")<br/>        .withPassword("secret").start();</span><span id="0f6d" class="my lx iu mu b gz nl na l nb nc">    @Test<br/>    void test() {</span><span id="b517" class="my lx iu mu b gz nl na l nb nc">        assertThat(postgresqlContainer.isRunning()).isTrue();<br/>    }<br/>}</span></pre><p id="31bc" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">测试容器使得集成测试更加容易。短暂的，所以你不会得到任何古怪的测试。</p><h1 id="e1be" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">4.Mapstruct</h1><p id="592c" class="pw-post-body-paragraph kz la iu lb b lc mo jv le lf mp jy lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">如果你需要自定义的映射器，这是可以选择的库。Mapstruct从定义中生成所有映射器。定义是开放的，可以扩展或定制。</p><p id="ff72" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> <em class="lv">关于mapstruct有什么帮助？</em> </strong>映射嵌套结构。您还可以将嵌套的proto消息映射到POJOs。或者您可以继承一个相反的配置，只编写映射的一面。</p><p id="9af5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">下面是一个将proto消息映射到POJOs的例子。<code class="fe nm nn no mu b">TargetDTO</code>是POJO，<code class="fe nm nn no mu b">SourceDto</code>是proto消息。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="np nq l"/></div></figure><p id="9851" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您还可以使用mapstruct自定义如何生成映射器。例如，对于原型消息，您可以通过简单的配置使用加法运算。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="np nq l"/></div></figure><p id="dba5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">你会得到下面的代码。</p><pre class="kk kl km kn gu mt mu mv mw aw mx bi"><span id="f114" class="my lx iu mu b gz mz na l nb nc">if ( dto.getSecondLevelDTOList() != null ) {  <br/>    for ( SecondLevelDTO secondLevelDTOList : dto.getSecondLevelDTOList() ) {  <br/>        firstLevelDto.addDto( secondLevelProtoMapper.map( secondLevelDTOList ) );  <br/>    }  <br/>}</span></pre><h1 id="7fc5" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">5.巴泽尔</h1><p id="77af" class="pw-post-body-paragraph kz la iu lb b lc mo jv le lf mp jy lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">Bazel是一个用Java构建的构建系统。</p><p id="cf45" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> </strong>用对了更快。此外，您可以在同一个项目中使用多种语言，Bazel也会处理这个问题。</p><p id="709b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> <em class="lv">还可以将Bazel与Guice结合使用，用于更轻量级的项目。</em>T15】</strong></p><p id="0777" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">此外，如果使用微服务，Bazel是正确的选择。您可以限制可见性，拥有更细粒度的构建结构，并创建自己的构建规则。</p><p id="3f28" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">Bazel使用<a class="ae nd" href="https://bazel.build/docs/remote-caching" rel="noopener ugc nofollow" target="_blank">远程缓存</a>。输出可以被重用、缓存，并进行更快的构建。</p></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><p id="1412" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> <em class="lv">对于某些球队来说，巴泽尔未必是正确的选择。</em> </strong></p><p id="15b0" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">远程缓存对Kubernetes团队来说是一种威慑。他们每次都需要新鲜的产品。即便如此，对于常见的用例来说，这种方法非常有效。</p><p id="45c7" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您还可以使用Starlark和元编程创建一个宏来编写构建规则。这不仅有助于代码重用，还能生成定制的构建规则。</p><p id="a204" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">Bazel使构建更加通用、可配置和透明。 </p><h1 id="a8cf" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">6.来自番石榴的TreeRangeMap</h1><p id="fabf" class="pw-post-body-paragraph kz la iu lb b lc mo jv le lf mp jy lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">如果你需要你的树形图的键是区间，那么<a class="ae nd" href="https://javadoc.io/doc/com.google.guava/guava/28.1-jre/com/google/common/collect/TreeRangeMap.html" rel="noopener ugc nofollow" target="_blank"> TreeRangeMap </a>就是你要去的类。</p><p id="3177" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您还可以支持TreeMap提供的一切，排序键和键操作。</p><p id="6830" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">那么TreeRangeMap有哪些好处呢？ </p><ul class=""><li id="90ef" class="nr ns iu lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">您可以按间隔搜索某个范围</li><li id="b05c" class="nr ns iu lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">您可以为特定时间间隔添加新值</li><li id="eb39" class="nr ns iu lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">添加重叠时间范围时，TreeRangeMap会拆分间隔</li><li id="646c" class="nr ns iu lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">用<a class="ae nd" href="https://javadoc.io/doc/com.google.guava/guava/28.1-jre/com/google/common/collect/TreeRangeMap.html#subRangeMap-com.google.common.collect.Range-" rel="noopener ugc nofollow" target="_blank">子RangeMap </a>可以得到某个区间的RangeMap切片</li></ul><p id="1846" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在这个结构<a class="ae nd" href="https://stackoverflow.com/a/20290550/5999670" rel="noopener ugc nofollow" target="_blank">上的大多数操作或者是常数或者是对数时间复杂度。</a>所以所有的添加、放置等。都是在对数时间内完成的。但更重要的是，如果你在处理时间范围，这是正确的结构。</p><h1 id="b876" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">7.JUnit 5和参数化测试</h1><p id="b64d" class="pw-post-body-paragraph kz la iu lb b lc mo jv le lf mp jy lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">随着JUnit5的出现，参数化测试变得更好。 </p><p id="4f69" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们现在可以使用像<code class="fe nm nn no mu b">@CsvSource</code>和<code class="fe nm nn no mu b">@ValueSource</code>这样的结构。这些可以满足我们大部分的测试需求。此外，您可以定义代码中的每个参数，并配置自定义测试显示名称。</p><p id="8bbc" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">对于自定义名称，我们可以使用<code class="fe nm nn no mu b"><a class="ae nd" href="https://junit.org/junit5/docs/5.5.0/api/org/junit/jupiter/api/DisplayNameGeneration.html" rel="noopener ugc nofollow" target="_blank">@DisplayName</a></code>或<code class="fe nm nn no mu b"><a class="ae nd" href="https://junit.org/junit5/docs/5.5.0/api/org/junit/jupiter/api/DisplayNameGeneration.html" rel="noopener ugc nofollow" target="_blank">@DisplayNameGeneration</a></code>。虽然DisplayName已经足够了。但是也支持生成自定义显示名称。</p></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><p id="af22" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">Mike回顾了进度以及6月5日带来了什么<a class="ae nd" href="https://github.com/mikemybytes/the-unknowns-of-junit5/tree/e67db691e877481efa0f5f156270b3f8506ca79d/src/test/java/com/mikemybytes/junit5/pricing" rel="noopener ugc nofollow" target="_blank">这些例子</a>。</p><p id="e0c5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">下面是第一个例子:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="np nq l"/></div></figure><p id="a20e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">下面是JUnit5对前面代码块的处理:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="np nq l"/></div></figure></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><p id="a07e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">JUnit5改进的另一件事是异常测试。 </p><p id="cc3f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">以前你会有<code class="fe nm nn no mu b">expected</code>注解。但是你不能测试这个方法抛出了什么异常。或者是否需要测试更多的异常。</p><p id="5d38" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> <em class="lv">新版本的JUnit使用assertThrows </em> </strong></p><p id="6195" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您可以在调用可执行文件后捕获异常。自定义异常(第一个参数)确认预期的异常类型。可执行文件第二个参数抛出异常。错误消息，第三个参数，如果异常没有发生，则打印。</p></div></div>    
</body>
</html>