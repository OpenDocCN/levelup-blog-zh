<html>
<head>
<title>Foreach and IEnumerable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Foreach和IEnumerable</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/foreach-and-ienumerable-ca7b9ebed754?source=collection_archive---------2-----------------------#2019-12-13">https://levelup.gitconnected.com/foreach-and-ienumerable-ca7b9ebed754?source=collection_archive---------2-----------------------#2019-12-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/af5213239ae39f8c1d25d37b4bce54ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GPddFv4onZrrZTeK"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@jg?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔·格林</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6337" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最近我读了很多关于<code class="fe le lf lg lh b">foreach</code>和迭代器模式的文章。</p><p id="dbc9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我的研究中，我想到了这些问题:</p><ul class=""><li id="e4c1" class="li lj it ki b kj kk kn ko kr lk kv ll kz lm ld ln lo lp lq bi translated">foreach迭代变量如何只读？</li><li id="6740" class="li lj it ki b kj lr kn ls kr lt kv lu kz lv ld ln lo lp lq bi translated">为什么在直接使用迭代器模式时，编译器允许迭代变量的赋值？</li><li id="9807" class="li lj it ki b kj lr kn ls kr lt kv lu kz lv ld ln lo lp lq bi translated">为什么<code class="fe le lf lg lh b">IEnumerator.Current</code>是只读的？</li><li id="1b42" class="li lj it ki b kj lr kn ls kr lt kv lu kz lv ld ln lo lp lq bi translated">为什么我不能在<code class="fe le lf lg lh b">IEnumerable&lt;T&gt;</code>中添加/删除元素？</li><li id="c225" class="li lj it ki b kj lr kn ls kr lt kv lu kz lv ld ln lo lp lq bi translated">为什么运行时允许你在<code class="fe le lf lg lh b">IEnumerable&lt;T&gt;</code>中更新一个元素的属性？</li><li id="ecb6" class="li lj it ki b kj lr kn ls kr lt kv lu kz lv ld ln lo lp lq bi translated">为什么有<code class="fe le lf lg lh b">IEnumerator&lt;T&gt;</code>还需要<code class="fe le lf lg lh b">IEnumerable&lt;T&gt;</code>？</li><li id="6eb0" class="li lj it ki b kj lr kn ls kr lt kv lu kz lv ld ln lo lp lq bi translated"><code class="fe le lf lg lh b">Array.GetEnumerator()</code>什么时候用？</li></ul><p id="d257" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本页将深入探讨这些问题以及我从StackOverflow得到的答案。</p><h1 id="c3dc" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">foreach迭代变量如何只读？</h1><h2 id="050a" class="mu lx it bd ly mv mw dn mc mx my dp mg kr mz na mk kv nb nc mo kz nd ne ms nf bi translated">为什么？</h2><p id="8a95" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">回答“为什么”很容易，因为它让您不会想到您会更新集合中的元素，而您不会，因为您处理的是一个局部变量，它只引用了集合中的元素。</p><p id="9a0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更新局部变量中的引用不会对集合中的对象做任何事情。</p><h2 id="a674" class="mu lx it bd ly mv mw dn mc mx my dp mg kr mz na mk kv nb nc mo kz nd ne ms nf bi translated">怎么会？</h2><p id="55c4" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">“如何做”有点难以弄清楚。</p><p id="6ca8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在C#规范的8.8.4中，它提供了这个示例:</p><p id="5550" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nl">形式为</em>的foreach语句</p><pre class="nm nn no np gt nq lh nr ns aw nt bi"><span id="5d0f" class="mu lx it lh b gy nu nv l nw nx"><strong class="lh iu">foreach</strong> (V v <strong class="lh iu">in</strong> x) embedded-statement</span></pre><p id="2eb6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nl">随后扩展为:</em></p><pre class="nm nn no np gt nq lh nr ns aw nt bi"><span id="2549" class="mu lx it lh b gy nu nv l nw nx">{<br/>    E e = ((C)(x)).GetEnumerator();<br/>    <strong class="lh iu">try</strong> {<br/>        V v;<br/>        <strong class="lh iu">while</strong> (e.MoveNext()) {<br/>            v = (V)(T)e.Current;<br/>            embedded-statement<br/>        }<br/>    }<br/>    <strong class="lh iu">finally</strong> {<br/>        … // Dispose e<br/>    }<br/>}</span></pre><p id="cb95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nl">迭代变量对应于一个只读局部变量，其作用域扩展到嵌入式语句。变量v在嵌入式语句中是只读的。</em></p><p id="345f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当“扩展的”代码没有任何只读关键字时，我很困惑这怎么可能。</p><p id="f223" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">扩展代码是生成的CIL代码的C#等价物。</p><p id="4526" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有必要用某种显式的方法将其标记为readonly，因为CIL代码只有在编译时才会生成。</p><p id="89c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您试图更新迭代变量，代码首先不会编译。</p><p id="54db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编译器中有一条规则阻止你这样做。</p><h1 id="f489" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">为什么在直接使用迭代器模式时，编译器允许迭代变量的赋值？</h1><p id="28b2" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">考虑以下代码:</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="acef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果编译器能防止这种情况就好了。然而，对于编译器来说，识别这种情况并防止它发生所涉及的逻辑太复杂了。</p><p id="28cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编译器很容易知道什么时候试图在<code class="fe le lf lg lh b">foreach</code>中给迭代变量赋值，但是在while循环中给变量赋值是没问题的，如果它是迭代器模式的一部分的while循环，那就太难了。</p><h1 id="1325" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">为什么IEnumerator？当前只读？</h1><p id="9582" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">注意，这是一个不同于询问为什么<code class="fe le lf lg lh b">foreach</code>迭代变量是只读的问题。</p><p id="18bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">foreach</code>迭代变量代表<code class="fe le lf lg lh b">Current</code>属性，并且是只读的，因为如果您可以更新它，您可能会认为您正在更新集合中的元素，而您不会这样做。</p><p id="e2a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果<code class="fe le lf lg lh b">Current</code>属性有一个setter会怎么样呢？</p><p id="5574" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，这也没有用，因为这样你就可以更新<code class="fe le lf lg lh b">Current</code>属性，这不会影响到集合，而且在下次调用<code class="fe le lf lg lh b">MoveNext()</code>时会被覆盖。</p><p id="f7f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果setter中有更新集合的逻辑会怎么样呢？</p><p id="af14" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这在普通的集合中是可行的，但是因为你不能更新存储在<code class="fe le lf lg lh b">foreach</code>中的<code class="fe le lf lg lh b">IEnumerable&lt;T&gt;</code>元素中的引用，所以保持一致是有意义的，并且在迭代器模式中也要防止这种情况。</p><p id="813b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">Current</code>属性是只读的另一个原因是因为在一些集合中更新元素没有意义:</p><p id="d36c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您有以下代码:</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="3ee8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你到底要更新什么？更新这种类型的集合没有任何意义。</p><h1 id="e79c" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">为什么我不能在IEnumerable <t>中添加/删除元素？</t></h1><p id="b569" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">它会打乱集合的迭代。</p><p id="9851" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果这成为可能，当您在集合的开头添加一个元素时，您希望会发生什么？</p><p id="8fa3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然添加了新元素，那么<code class="fe le lf lg lh b">foreach</code>循环的下一次迭代应该回到起点吗？</p><p id="96d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于潜在的奇怪情况，<code class="fe le lf lg lh b">IEnumerable&lt;T&gt;</code>是只读的。</p><h1 id="0991" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">为什么运行时允许更新IEnumerable <t>中元素的属性？</t></h1><p id="d6d8" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">考虑以下代码:</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="17c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似于前面的例子，您不能更新存储在<code class="fe le lf lg lh b">foreach</code>迭代变量中的引用，您现在可以问这个问题，为什么当您试图更新作为<code class="fe le lf lg lh b">IEnumerable&lt;T&gt;</code>一部分的元素的属性时，运行时不抛出异常？</p><p id="ce95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更新一个<code class="fe le lf lg lh b">foreach</code>中的<code class="fe le lf lg lh b">IEnumerable&lt;T&gt;</code>元素的属性是没有用的，因为那只会更新当前的投影。即。在上面的foreach中，您正在更新一个对象，该对象将在迭代后立即被垃圾收集。一旦你再次迭代<code class="fe le lf lg lh b">IEnumerable&lt;T&gt;</code>，你将得到一个新的投影。</p><p id="ea78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编译器无法检测到这一点，因为很难判断这个集合是纯的<code class="fe le lf lg lh b">IEnumerable&lt;T&gt;</code>，还是仅仅实现了<code class="fe le lf lg lh b">IEnumerable&lt;T&gt;</code>的集合。然而，这可以通过运行时在检测到更新对象的尝试时抛出一个<code class="fe le lf lg lh b">Exception</code>来防止。</p><p id="cf4f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不抛出<code class="fe le lf lg lh b">Exception</code>的原因是因为运行时必须跟踪这个对象来源于一个可枚举的事实。它必须跟踪可枚举的类型(因为如果它是基于列表的，它应该允许这样做)，并且它必须跟踪变量是否被赋给了其他地方(因为，如果是，代码可能是合法的)。</p><p id="8b8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这简直是太多的开销却没有什么好处。</p><h1 id="0fc4" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">有IEnumerator <t>为什么还要有IEnumerable <t>？</t></t></h1><p id="b5e2" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated"><code class="fe le lf lg lh b">IEnumerable&lt;T&gt;</code>是最简单的界面。它声明了一个方法<code class="fe le lf lg lh b">GetEnumerator()</code>。</p><p id="3bfc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为什么不把<code class="fe le lf lg lh b">IEnumerator&lt;T&gt;</code>中的逻辑放到<code class="fe le lf lg lh b">IEnumerable&lt;T&gt;</code>中呢？</p><p id="ca9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">把<code class="fe le lf lg lh b">IEnumerable&lt;T&gt;</code>想象成创造<code class="fe le lf lg lh b">IEnumerator&lt;T&gt;</code>的工厂。</p><p id="7c3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您将枚举器当前位置的状态直接存储在一个<code class="fe le lf lg lh b">IEnumerable&lt;T&gt;</code>中，那么您将无法对集合使用嵌套枚举。</p><p id="01ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您到达嵌套循环时，<code class="fe le lf lg lh b">Current</code>属性将读取第二个元素，而不是第一个。</p><h1 id="c9f3" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">当是数组时。使用了GetEnumerator()。</h1><p id="5c2d" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">一些开发人员认为，无论何时使用<code class="fe le lf lg lh b">foreach</code>，它都会生成调用<code class="fe le lf lg lh b">IEnumerator&lt;T&gt;</code>方法的代码。</p><p id="93a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">情况并非总是如此。如果你在一个数组上使用<code class="fe le lf lg lh b">foreach</code>，它将在幕后使用一个for循环。</p><p id="cff6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑下面的C#代码:</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b5dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在等价的CIL代码中，没有对<code class="fe le lf lg lh b">MoveNext()</code>等的调用，这只是一个循环:</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="e600" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于数组不支持添加/删除项目，所以有一个隐含的固定的<code class="fe le lf lg lh b">Length</code>。</p><p id="96fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，在没有边界检查的情况下，通过索引(对于循环)而不是迭代器(<code class="fe le lf lg lh b">IEnumerable&lt;T&gt;</code>实现)访问数组项是一种优化。</p><p id="de96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，还是有理由有<code class="fe le lf lg lh b">Array.GetEnumerator()</code>。它是为Linq功能提供的:</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="ac22" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在等价的CIL代码中，我们可以看到对<code class="fe le lf lg lh b">MoveNext()</code>等的调用:</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure></div></div>    
</body>
</html>