<html>
<head>
<title>Strongly Typed ngTemplateOutlet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">强类型ngTemplateOutlet</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/strongly-typed-ngtemplateoutlet-3a3b55057e50?source=collection_archive---------2-----------------------#2022-11-27">https://levelup.gitconnected.com/strongly-typed-ngtemplateoutlet-3a3b55057e50?source=collection_archive---------2-----------------------#2022-11-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f425" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">泛型，ngTemplateContextGuard，指令</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/82e5dea4f1232ebcfd89648d5686e196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V7WRq0vCZxndM0nyMW3ZOQ.png"/></div></div></figure><p id="7499" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">ngTemplateOutlet可用于将内容投影到组件中，因此通用组件(如表格)通常会使用它们。但是实现强类型并不简单，需要一些小的TypeScript技巧。</p><div class="lq lr gp gr ls lt"><a href="https://ng-journal.com/blog/2022-11-28-strongly-typed-ng-template-outlet/" rel="noopener  ugc nofollow" target="_blank"><div class="lu ab fo"><div class="lv ab lw cl cj lx"><h2 class="bd iu gy z fp ly fr fs lz fu fw is bi translated">强类型ngTemplateOutlet</h2><div class="ma l"><h3 class="bd b gy z fp ly fr fs lz fu fw dk translated">下面，您可以看到一个非常基本的通用表的代码，该表利用ngTemplateOutlet可重用于…</h3></div><div class="mb l"><p class="bd b dl z fp ly fr fs lz fu fw dk translated">ng-journal.com</p></div></div><div class="mc l"><div class="md l me mf mg mc mh ks lt"/></div></div></a></div><h1 id="597b" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">松散类型表</h1><p id="9c9e" class="pw-post-body-paragraph ku kv it kw b kx na ju kz la nb jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">下面，您可以看到一个非常基本的通用表的代码，该表利用了<em class="nf">ngtemplateeoutlet</em>来重用各种用例。</p><pre class="kj kk kl km gt ng nh ni bn nj nk bi"><span id="e26b" class="nl mj it nh b be nm nn l no np">&lt;div class="overflow-x-auto relative"&gt;<br/>  &lt;table class="w-full text-sm text-left text-gray-500 dark:text-gray-400 table-fixed"&gt;<br/>    &lt;thead class="text-xs text-gray-700 uppercase bg-gray-50 dark:bg-gray-700 dark:text-gray-400"&gt;<br/>      &lt;tr&gt;<br/>        &lt;ng-container<br/>          *ngTemplateOutlet="tableHead"<br/>        &gt;&lt;/ng-container&gt;<br/>      &lt;/tr&gt;<br/>    &lt;/thead&gt;<br/>    &lt;tbody&gt;<br/>      &lt;tr *ngFor="let row of data" class="bg-white border-b dark:bg-gray-800 dark:border-gray-700"&gt;<br/>        &lt;ng-container<br/>          *ngTemplateOutlet="tableRow; context: { $implicit: row }"<br/>        &gt;&lt;/ng-container&gt;<br/>      &lt;/tr&gt;<br/>    &lt;/tbody&gt;<br/>  &lt;/table&gt;<br/>&lt;/div&gt;</span></pre><pre class="nq ng nh ni bn nj nk bi"><span id="0d5f" class="nl mj it nh b be nm nn l no np">export class TableComponent {<br/>  @Input() data!: any;<br/>  @ContentChild('tableHead') tableHead!: TemplateRef&lt;any&gt;;<br/>  @ContentChild('tableRow') tableRow!: TemplateRef&lt;any&gt;;<br/>}</span></pre><p id="d8d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可能已经发现了一些代码气味。比如<em class="nf">任何</em>类型。或者是用于<em class="nf">的ContentChild </em>的静态字符串选择器。</p><h1 id="f461" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">1.无商标消费品</h1><p id="7e20" class="pw-post-body-paragraph ku kv it kw b kx na ju kz la nb jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">首先，让我们删除任何类型的数据。为此，我们可以使用泛型类型，并确保该类型是一个对象数组，方法是使用下面的代码。我们知道，T是一个对象，然后数据的类型是这个类型的数组。当涉及到从泛型推断类型时，TypeScript是非常智能的，因此我们不需要做任何额外的事情。仅仅通过给数据赋值就可以推断出t的类型。</p><pre class="kj kk kl km gt ng nh ni bn nj nk bi"><span id="800f" class="nl mj it nh b be nm nn l no np">export class TableComponent&lt;T extends object&gt; {<br/>  @Input() data!: T[];<br/>  @ContentChild('tableHead') tableHead!: TemplateRef&lt;any&gt;;<br/>  @ContentChild('tableRow') tableRow!: TemplateRef&lt;any&gt;;<br/>}</span></pre><h1 id="e6e0" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">2.指令</h1><p id="5151" class="pw-post-body-paragraph ku kv it kw b kx na ju kz la nb jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">另一个代码味道是ContentChild中的静态字符串，它从模板中选择子元素。显然，这很容易出错，因为模板中的重构不会重构这个字符串。或者只是字符串中的一个简单的输入错误不会立即发出错误。</p><p id="5d23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是我们可以使用自定义指令来选择子元素，这样我们就可以摆脱字符串选择器。因此，我为每个ContentChild创建了一个指令。</p><pre class="kj kk kl km gt ng nh ni bn nj nk bi"><span id="e1d0" class="nl mj it nh b be nm nn l no np">@Directive({<br/>  selector: 'ng-template[appTableHead]'<br/>})<br/>export class TableHeadDirective {<br/>  constructor() { }<br/>}</span></pre><p id="bd22" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">table-head.directive.ts</p><pre class="kj kk kl km gt ng nh ni bn nj nk bi"><span id="a656" class="nl mj it nh b be nm nn l no np">export class TableComponent&lt;T extends object&gt; {<br/>  @Input() data!: T[];<br/>  @ContentChild(TableHeadDirective, {read: TemplateRef}) tableHead!: TemplateRef&lt;any&gt;;<br/>  @ContentChild(TableRowDirective, {read: TemplateRef}) tableRow!: TemplateRef&lt;any&gt;;<br/>}</span></pre><p id="0243" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">表.组件. ts</p><h1 id="b6db" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">3.ngTemplateContextGuard</h1><p id="c7e2" class="pw-post-body-paragraph ku kv it kw b kx na ju kz la nb jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">虽然这段代码已经简洁了很多，但是在实例化表的组件的ng-template中存在一个主要缺陷。通过ngTemplateOutletContext传递的隐式变量是any类型的，因此访问ng-template内部的属性根本不是类型化的，因此很容易出错。这个问题应该得到解决，但这绝对是重构中最棘手的部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/7cf6b2b14771e12d9159cb3e26184111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UP4YdyDbaAmKvsYY.png"/></div></div></figure><p id="d7b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了推断正确的类型，我们可以使用已经创建的指令，并结合使用泛型和名为ngTemplateContextGuard的静态方法。此方法使用带有is关键字的类型谓词，用于保护上下文的类型。</p><pre class="kj kk kl km gt ng nh ni bn nj nk bi"><span id="853d" class="nl mj it nh b be nm nn l no np">interface Row&lt;T extends object&gt; {<br/>  $implicit: T<br/>}</span></pre><pre class="nq ng nh ns nt aw nu bi"><span id="de06" class="nv mj it nh b gy nw nx l ny np">@Directive({<br/>  selector: 'ng-template[appTableRow]'<br/>})<br/>export class TableRowDirective&lt;T extends object&gt; {<br/>  @Input() appTableRow!: T[];</span><span id="5026" class="nv mj it nh b gy nz nx l ny np">  constructor() { }</span><span id="5c3c" class="nv mj it nh b gy nz nx l ny np">  static ngTemplateContextGuard&lt;TContext extends object&gt;(<br/>    directive: TableRowDirective&lt;TContext&gt;,<br/>    context: unknown<br/>  ): context is Row&lt;TContext&gt; {<br/>    return true;<br/>  }</span><span id="c7d3" class="nv mj it nh b gy nz nx l ny np">}</span></pre><p id="4f56" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">表-行.指令. ts</p><pre class="kj kk kl km gt ng nh ni bn nj nk bi"><span id="dceb" class="nl mj it nh b be nm nn l no np">&lt;app-table [data]="persons"&gt;<br/>  &lt;ng-template [appTableHead]&gt;<br/>    &lt;td scope="col" class="py-3 px-6"&gt;Firstname&lt;/td&gt;<br/>    &lt;td scope="col" class="py-3 px-6"&gt;Lastname&lt;/td&gt;<br/>    &lt;td scope="col" class="py-3 px-6"&gt;Age&lt;/td&gt;<br/>  &lt;/ng-template&gt;<br/>  &lt;ng-template [appTableRow]="persons" let-row&gt;<br/>    &lt;td class="py-4 px-6"&gt;&lt;/td&gt;<br/>    &lt;td class="py-4 px-6"&gt;&lt;/td&gt;<br/>    &lt;td class="py-4 px-6"&gt;&lt;/td&gt;<br/>  &lt;/ng-template&gt;<br/>&lt;/app-table&gt;</span></pre><p id="2642" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">app.component.html</p><p id="abdb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过向具有泛型类型的指令添加输入，该指令知道传递给表的类型。这需要使用静态上下文保护来推断上下文变量的类型，该静态上下文保护用于使用类型谓词断言类型。由于上下文保护是一个静态方法，它不能简单地重用指令的泛型类型，必须定义自己的泛型类型。</p><h1 id="bd6a" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">向约书亚·莫罗尼大喊</h1><p id="0ab6" class="pw-post-body-paragraph ku kv it kw b kx na ju kz la nb jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">这篇博文的灵感来源于约书亚·莫罗尼关于这个问题的非常棒的YouTube视频。我推荐你去看看:<a class="ae oa" href="https://www.youtube.com/watch?v=dau7kQMdH4A&amp;ab_channel=JoshuaMorony" rel="noopener ugc nofollow" target="_blank">约书亚·莫罗尼的YouTube视频</a></p><h1 id="cf35" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">谢谢你🤗</h1><p id="e9e1" class="pw-post-body-paragraph ku kv it kw b kx na ju kz la nb jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">感谢您阅读本文！我希望你喜欢它，并能学到一些新的和有趣的东西。<br/>如果你还有任何问题，不要犹豫，通过<a class="ae oa" href="https://twitter.com/StefanvHaas" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae oa" href="https://www.linkedin.com/in/stefan-haas-686a921b4/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我进行讨论。<br/> <strong class="kw iu">还没订阅？向下滚动，不要再错过任何新文章。</strong></p><p id="df33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">阅读全文</strong><a class="ae oa" href="http://ng-journal.com" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">ng-journal.com</strong></a></p><div class="lq lr gp gr ls lt"><a href="https://ng-journal.com/blog/2022-11-28-strongly-typed-ng-template-outlet/" rel="noopener  ugc nofollow" target="_blank"><div class="lu ab fo"><div class="lv ab lw cl cj lx"><h2 class="bd iu gy z fp ly fr fs lz fu fw is bi translated">强类型ngTemplateOutlet</h2><div class="ma l"><h3 class="bd b gy z fp ly fr fs lz fu fw dk translated">下面，您可以看到一个非常基本的通用表的代码，该表利用ngTemplateOutlet可重用于…</h3></div><div class="mb l"><p class="bd b dl z fp ly fr fs lz fu fw dk translated">ng-journal.com</p></div></div><div class="mc l"><div class="ob l me mf mg mc mh ks lt"/></div></div></a></div></div></div>    
</body>
</html>