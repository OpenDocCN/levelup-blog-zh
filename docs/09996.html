<html>
<head>
<title>Making Concurrent Web API Requests in Python, I Recommend AioHTTP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python制作并发Web API请求，我推荐AioHTTP</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/making-concurrent-web-api-requests-in-python-i-recommend-aiohttp-43f2d46ef4da?source=collection_archive---------1-----------------------#2021-10-12">https://levelup.gitconnected.com/making-concurrent-web-api-requests-in-python-i-recommend-aiohttp-43f2d46ef4da?source=collection_archive---------1-----------------------#2021-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e035" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">两个python web请求包request和Aiohttp之间的比较</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/55139ebeb8ecbc000bd2d9ca5410ea58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*5QlIUfsu1UPqVGamvWorqQ.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">请求速度比较</figcaption></figure><h2 id="399e" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">目录</h2><ul class=""><li id="70da" class="lq lr it ls b lt lu lv lw ld lx lh ly ll lz ma mb mc md me bi translated"><a class="ae mf" href="#a072" rel="noopener ugc nofollow">简单的请求</a></li><li id="a1d9" class="lq lr it ls b lt mg lv mh ld mi lh mj ll mk ma mb mc md me bi translated"><a class="ae mf" href="#ffae" rel="noopener ugc nofollow">会话请求</a></li><li id="ec0f" class="lq lr it ls b lt mg lv mh ld mi lh mj ll mk ma mb mc md me bi translated"><a class="ae mf" href="#6d03" rel="noopener ugc nofollow">线程池请求</a></li><li id="1131" class="lq lr it ls b lt mg lv mh ld mi lh mj ll mk ma mb mc md me bi translated"><a class="ae mf" href="#5365" rel="noopener ugc nofollow">简单Aiohttp </a></li><li id="3943" class="lq lr it ls b lt mg lv mh ld mi lh mj ll mk ma mb mc md me bi translated"><a class="ae mf" href="#a209" rel="noopener ugc nofollow"> AioHTTP并发</a></li></ul></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="2bc6" class="ms kv it bd kw mt mu mv kz mw mx my lc jz mz ka lg kc na kd lk kf nb kg lo nc bi translated">要求</h1><div class="nd ne gp gr nf ng"><a href="https://docs.python-requests.org/en/latest/user/quickstart/#make-a-request" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">快速入门-请求文档</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">渴望开始吗？本页很好地介绍了如何开始处理请求…</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">docs.python-requests.org</p></div></div></div></a></div><p id="30e5" class="pw-post-body-paragraph np nq it ls b lt nr ju ns lv nt jx nu ld nv nw nx lh ny nz oa ll ob oc od ma im bi translated"><a class="ae mf" href="https://docs.python-requests.org/en/latest/" rel="noopener ugc nofollow" target="_blank"> <strong class="ls iu"> Requests </strong> </a>是一个流行的用于进行web请求的HTTP库。让HTTP请求更简单、更人性化是这个包的目标。</p><p id="75a3" class="pw-post-body-paragraph np nq it ls b lt nr ju ns lv nt jx nu ld nv nw nx lh ny nz oa ll ob oc od ma im bi translated">那么让我们从一个简单的例子开始。</p><h2 id="a072" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">简单的请求</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">简单请求示例</figcaption></figure><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="56d9" class="ku kv it oh b gy ol om l on oo">{'origin': 'xx.xx.xx.xx'}<br/>{'origin': 'xx.xx.xx.xx'}<br/>{'origin': 'xx.xx.xx.xx'}<br/>          ...<br/>{'origin': 'xx.xx.xx.xx'}<br/>{'origin': 'xx.xx.xx.xx'}</span><span id="0669" class="ku kv it oh b gy op om l on oo">--- It took 60.77657389640808 seconds ---</span></pre><p id="aa8b" class="pw-post-body-paragraph np nq it ls b lt nr ju ns lv nt jx nu ld nv nw nx lh ny nz oa ll ob oc od ma im bi translated">使用这个库做一个请求是非常简单的，你所需要的就是给出一个目标URL，然后它返回一个网页响应。</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="b231" class="ku kv it oh b gy ol om l on oo">response = request.get(url)</span></pre><p id="58b9" class="pw-post-body-paragraph np nq it ls b lt nr ju ns lv nt jx nu ld nv nw nx lh ny nz oa ll ob oc od ma im bi translated">在这个例子中，我们向同一个web URL发出100个web请求，总运行时间大约是一分钟。</p><p id="78cc" class="pw-post-body-paragraph np nq it ls b lt nr ju ns lv nt jx nu ld nv nw nx lh ny nz oa ll ob oc od ma im bi translated">所以速度是100个请求/分钟，太慢了。让我们做一些改进。</p><h2 id="ffae" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">会话请求</h2><p id="d723" class="pw-post-body-paragraph np nq it ls b lt lu ju ns lv lw jx nu ld oq nw nx lh or nz oa ll os oc od ma im bi translated">当向同一个主机发出几个请求时，经常使用<code class="fe ot ou ov oh b">session</code>。因为它重用了底层的TCP连接，这可以显著提高性能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">会话请求示例</figcaption></figure><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="8e9b" class="ku kv it oh b gy ol om l on oo">{'origin': 'xx.xx.xx.xx'}<br/>{'origin': 'xx.xx.xx.xx'}<br/>{'origin': 'xx.xx.xx.xx'}<br/>          ...<br/>{'origin': 'xx.xx.xx.xx'}<br/>{'origin': 'xx.xx.xx.xx'}</span><span id="d4b8" class="ku kv it oh b gy op om l on oo">--- It took 31.942954063415527 seconds ---</span></pre><p id="ddbd" class="pw-post-body-paragraph np nq it ls b lt nr ju ns lv nt jx nu ld nv nw nx lh ny nz oa ll ob oc od ma im bi translated">正如我们所见，通过使用<code class="fe ot ou ov oh b">session</code>，我们节省了一半的时间。</p><p id="52a6" class="pw-post-body-paragraph np nq it ls b lt nr ju ns lv nt jx nu ld nv nw nx lh ny nz oa ll ob oc od ma im bi translated">然而，实现更高性能的最常见方法是使用多线程或多个进程。</p><h2 id="6d03" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">使用线程池的请求</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="a30a" class="ku kv it oh b gy ol om l on oo">{'origin': 'xx.xx.xx.xx'}<br/>{'origin': 'xx.xx.xx.xx'}<br/>{'origin': 'xx.xx.xx.xx'}<br/>          ...<br/>{'origin': 'xx.xx.xx.xx'}<br/>{'origin': 'xx.xx.xx.xx'}</span><span id="5107" class="ku kv it oh b gy op om l on oo">--- It took 2.7641241550445557 seconds ---</span></pre><p id="fecd" class="pw-post-body-paragraph np nq it ls b lt nr ju ns lv nt jx nu ld nv nw nx lh ny nz oa ll ob oc od ma im bi translated">正如我们所见，速度比前一个快了10倍以上。因此，使用线程池来并发执行web请求调用是值得的。</p><p id="e5d8" class="pw-post-body-paragraph np nq it ls b lt nr ju ns lv nt jx nu ld nv nw nx lh ny nz oa ll ob oc od ma im bi translated">还有提升的空间吗？答案是肯定的</p><h1 id="4ca6" class="ms kv it bd kw mt ow mv kz mw ox my lc jz oy ka lg kc oz kd lk kf pa kg lo nc bi translated">Aiohttp</h1><div class="nd ne gp gr nf ng"><a href="https://docs.aiohttp.org/en/stable/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">欢迎使用AIOHTTP - aiohttp文档</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">和Python的异步HTTP客户端/服务器。您可能希望安装可选的…</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">docs.aiohttp.org</p></div></div></div></a></div><p id="7395" class="pw-post-body-paragraph np nq it ls b lt nr ju ns lv nt jx nu ld nv nw nx lh ny nz oa ll ob oc od ma im bi translated"><code class="fe ot ou ov oh b">requests</code>库是完全同步的。调用<code class="fe ot ou ov oh b">requests.get</code>阻塞程序，直到服务器完全回复。创建多线程有所帮助，但是线程仍然会遇到阻塞。</p><p id="0030" class="pw-post-body-paragraph np nq it ls b lt nr ju ns lv nt jx nu ld nv nw nx lh ny nz oa ll ob oc od ma im bi translated">幸运的是，从3.5版本开始，Python使用Asyncio提供了异步性作为其核心。一个<a class="ae mf" href="https://docs.aiohttp.org/en/stable/" rel="noopener ugc nofollow" target="_blank"> <strong class="ls iu"> iohttp </strong> </a>是基于Asyncio的异步http客户端/服务器。<code class="fe ot ou ov oh b"/></p><h2 id="5365" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">简单Aiohttp</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="7a70" class="ku kv it oh b gy ol om l on oo">{'origin': 'xx.xx.xx.xx'}<br/>{'origin': 'xx.xx.xx.xx'}<br/>{'origin': 'xx.xx.xx.xx'}<br/>          ...<br/>{'origin': 'xx.xx.xx.xx'}<br/>{'origin': 'xx.xx.xx.xx'}</span><span id="cb10" class="ku kv it oh b gy op om l on oo">— — It took 30.914737701416016 seconds — -</span></pre><p id="4d6c" class="pw-post-body-paragraph np nq it ls b lt nr ju ns lv nt jx nu ld nv nw nx lh ny nz oa ll ob oc od ma im bi translated">简单的代码就是一个<code class="fe ot ou ov oh b">Aiohttp</code>的例子。速度没那么快，因为我们还没有实现并发。</p><p id="7fc9" class="pw-post-body-paragraph np nq it ls b lt nr ju ns lv nt jx nu ld nv nw nx lh ny nz oa ll ob oc od ma im bi translated">现在，让我们使用并发！</p><h2 id="a209" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">并发Aiohttp</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="e441" class="ku kv it oh b gy ol om l on oo">{'origin': 'xx.xx.xx.xx'}<br/>{'origin': 'xx.xx.xx.xx'}<br/>{'origin': 'xx.xx.xx.xx'}<br/>          ...<br/>{'origin': 'xx.xx.xx.xx'}<br/>{'origin': 'xx.xx.xx.xx'}</span><span id="2530" class="ku kv it oh b gy op om l on oo">— — It took 1.1164250373840332 seconds — -</span></pre><p id="fd02" class="pw-post-body-paragraph np nq it ls b lt nr ju ns lv nt jx nu ld nv nw nx lh ny nz oa ll ob oc od ma im bi translated">我们通过使用AioHTTP并发可以看到，速度可以达到每分钟5400个请求。这是令人敬畏的结果。</p><p id="afa8" class="pw-post-body-paragraph np nq it ls b lt nr ju ns lv nt jx nu ld nv nw nx lh ny nz oa ll ob oc od ma im bi translated">有时，如果我们需要降低速度，尝试下面的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="d149" class="ms kv it bd kw mt mu mv kz mw mx my lc jz mz ka lg kc na kd lk kf nb kg lo nc bi translated">性能比较</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/55139ebeb8ecbc000bd2d9ca5410ea58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*5QlIUfsu1UPqVGamvWorqQ.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">请求速度比较</figcaption></figure><p id="ffe5" class="pw-post-body-paragraph np nq it ls b lt nr ju ns lv nt jx nu ld nv nw nx lh ny nz oa ll ob oc od ma im bi translated">速度对比如上图所示。不出意外，并发的AioHTTP是赢家！</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="6245" class="pw-post-body-paragraph np nq it ls b lt nr ju ns lv nt jx nu ld nv nw nx lh ny nz oa ll ob oc od ma im bi translated">所以下次当你想像网络爬虫一样做IO密集型任务的时候，AioHTTP是你更好的朋友！</p></div></div>    
</body>
</html>