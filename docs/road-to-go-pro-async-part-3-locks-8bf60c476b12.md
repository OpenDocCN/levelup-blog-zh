# Pro 之路—异步第 3 部分:锁

> 原文：<https://levelup.gitconnected.com/road-to-go-pro-async-part-3-locks-8bf60c476b12>

*在我们开始之前，你可以在这个* [*资源库*](https://github.com/songx23/RoadToGoPro) *中找到本教程使用的代码。你可以在这里* *找到 Road to Go Pro* [*的全部内容。如果你错过了最后一个，你可以通过这个*](https://medium.com/@songx/road-to-go-pro-f9d1f8a51fad) [*链接*](/road-to-go-pro-async-part-2-channels-12645a160f73) *找到。好吧，我们开始吧。*

在前面的故事中，我们了解了 Go 中的两个异步组件，即 goroutine 和 channel。它们构成了异步流程的基础。在这个故事中，我们将看看在处理异步流程和竞争条件时的常见问题。以及如何通过使用不同类型的锁来解决这些问题。

# 竞赛条件

![](img/bf7d8b65e702827deedf2b191540bcd0.png)

拉尔夫·布隆伯格在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

让我们快速回顾一下什么是竞争条件。竞争是指代码试图从不同的 goroutines 中访问(读/写)一个非线程安全的元素。由于没有明确声明哪个 goroutine 应该首先访问元素，所以执行的顺序是不确定的。因此，在代码中包含竞争条件可能会导致意想不到的结果，并可能导致系统出现严重故障。因此，我们应该检测竞态条件并尽早解决它们。

竞争条件的定义很容易理解，但是即使是有经验的工程师也很难发现它们。并发是 Go 的头等公民，但并不是 Go 中的所有类型都是线程安全的。幸运的是，Go 测试工具有一个内置的竞争检测功能，可以帮助尽早、快速、可靠地发现问题。

我们稍后会谈到竞争检测工具，但首先，让我们有目的地创建一个竞争条件。

竞争条件:从两个 goroutines 写入非线程安全变量

示例函数想要实现的是将从`x`到`y`的所有整数相加。为了加速这个过程，我们可以把计算分成几个部分并行运行。在这个具体的例子中，我们对函数进行了硬编码，将计算分成两部分。例如，如果我们使用上面的函数对 1 到 100 的所有整数求和，将会有两个 goroutines，一个计算 1 到 50 的和，另一个计算 51 到 100 的和。听起来不错，对吧？然而，当将整数相加时，这两个 goroutines 更新同一个`sum`变量，这不是线程安全的。这就产生了一个竞争条件。让我们使用 Go 测试工具来证明这一点。

sumUpWithRace 函数的单元测试

我们需要首先为目标函数创建一个单元测试。上面的单元测试运行良好，它产生正确的结果:5050。然而，如果我们使用竞争检测工具再次运行单元测试，我们将看到这次测试失败。

> 这是运行带有竞争条件检测的单元测试的命令。

```
go test -race -run <function_name>
```

向测试工具致敬，没有多少语言提供这种现成的功能。

接下来，是时候探索竞争条件的解决方案之一了，引入锁。

# **锁**

![](img/b1028e8a35f87aa85ac4c9450f3b136f.png)

[飞:D](https://unsplash.com/@flyd2069?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍照

当访问非线程安全的元素时，我们可以使用锁来确保只有一个 goroutine 可以访问它。这可以防止竞态条件的发生。Go 有两种类型的锁结构可从`sync`包中获得。他们就是`Mutex`和`RWMutex`。

> `Mutex`表示互斥。`RW`表示读写。

让我们更深入地了解一下这两种锁的结构。

## `Mutex`

互斥是最简单的锁定机制。它提供了两个功能:`Lock`和`Unlock`。这两个函数包装的代码块一次只能由一个 goroutine 执行。

使用互斥来避免竞争情况

如上所示，向示例代码添加互斥锁很简单。首先要做的是创建一个互斥结构。然后我们可以用它用它的`Lock`和`Unlock`函数包装并发写逻辑。不要忘记调用`Unlock`函数，否则，Go 将会死机，因为所有的 goroutines 都睡着了。您可以使用`defer mux.Unlock()`来确保锁被释放。然而，这并不总是释放锁的最佳方式，因为您将失去对何时解锁的细粒度控制。锁定到位后，我们就可以告别比赛条件了。

让我们通过再次运行竞争检测测试工具来证明这个理论。不出所料，这次单元测试通过了。

```
ok      github.com/songx23/RoadToGoPro/Part9    0.135s
```

## RWMutex

读写互斥与互斥略有不同。互斥体只提供一种类型的锁。这个锁只允许一个 goroutine 执行锁定的代码(不管读还是写)。而 RWMutex 提供了两种锁。其中一个是和互斥锁一样的锁，姑且称之为“写锁”。另一种是“读锁”。对于写锁，它使用相同的`Lock`和`Unlock`功能来防止多个并发写。对于读锁，它使用`RLock`和`RUnlock`函数来防止多个并发读。RWMutex 有两种锁的原因是它允许同时读写。它服务于在写入时解除读阻塞的特定目的，也称为“脏读”。这允许更多的并发性，但是如果使用不当，也更容易受到竞争条件的影响。

> 强大的力量伴随着巨大的责任

让我们修改我们的函数来试验 RWMutex 锁。

竞争条件:对一个非线程安全变量的多个并发读取

在更新后的函数中，我们有两个不耐烦的检查员，他们想在计算发生时检查`sum`值。如果我们用竞争检测工具运行[单元测试](https://github.com/songx23/RoadToGoPro/blob/master/Part09-lock/race_test.go#L33-L59)，它将由于“脏读”而失败。是时候利用 RWMutex 带来的特性了。

和 Mutex 一样，我们需要首先初始化一个 RWMutex 结构。然后，我们可以利用它的四个锁定/解锁功能来启用脏读。就像我们对互斥所做的一样，我们使用 RWMutex 的`Lock`和`Unlock`函数来消除并发写的竞争情况。在读取部分，我们使用`RLock`和`RUnlock`函数来启用脏读取，但防止多个并发读取。在运行同样的[测试](https://github.com/songx23/RoadToGoPro/blob/master/Part09-lock/lock_test.go#L33-L59)后，我们可以看到竞态条件没有了。

# 下一步是什么？

![](img/585bd742bc36a1817f270bf4a1cd3e2a.png)

在这篇文章中，我们谈到了 Go！中的竞争条件和两种互斥锁。在处理并发性时，无意中编写带有难以检测的竞争条件的代码是非常常见的。谢天谢地，我们有一个方便的工具来发现这种问题，我们也有`sync`包来帮助解决竞争条件。不过，给你一个建议，使用 RWMutex 时要小心。你需要确保它用在正确的地方。

这就结束了我们的 Go 异步处理主题。在下一篇文章中，我们将探索如何使用 Go 编写一个简单的 API 服务器。

如果你遇到任何问题或者需要帮助，请在下面留下你的评论。随时欢迎反馈。感谢您的阅读！

如果你想支持我，你可以通过这个推荐链接成为一个中等会员。谢谢你。

[](https://songx.medium.com/membership) [## 通过我的推荐链接——宋雪加入 Medium

### 作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…

songx.medium.com](https://songx.medium.com/membership)