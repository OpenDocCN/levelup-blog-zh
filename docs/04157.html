<html>
<head>
<title>TypeScript’s Relation to JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript与JavaScript的关系</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescripts-relation-to-javascript-1dc8dc6fe626?source=collection_archive---------27-----------------------#2020-06-11">https://levelup.gitconnected.com/typescripts-relation-to-javascript-1dc8dc6fe626?source=collection_archive---------27-----------------------#2020-06-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4f62debb25434a3e83be47ccc3d033c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Des9yHIAQ6YsWjSw"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@brookelark?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布鲁克·拉克</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="b1d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript是JavaScript的自然扩展，在许多项目中取代了JavaScript。</p><p id="cc57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，并不是每个人都知道它实际上是如何工作的。</p><p id="c256" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看TypeScript如何让JavaScript项目变得更好。</p><h1 id="da9e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">类型强制</h1><p id="3e3d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JavaScript在执行某些操作时会对其变量进行数据类型强制。</p><p id="33da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它产生一致的结果，我们只需要知道它是如何工作的。</p><p id="2cbe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们使用<code class="fe mh mi mj mk b">==</code>操作符来比较对象，那么类型强制将在比较操作完成之前完成。</p><p id="381f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可能有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5c22" class="mt lf it mk b gy mu mv l mw mx">let applePrice = 1;<br/>let orangePrice = '1';<br/>if (applePrice == orangePrice) {<br/>  //...<br/>}</span></pre><p id="e643" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么在比较之前，两者都将被转换成数字。</p><p id="2891" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3209" class="mt lf it mk b gy mu mv l mw mx">let totalPrice = applePrice + orangePrice;</span></pre><p id="f1d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么两者在串联之前都会被转换成字符串，这很可能不是我们想要的。</p><h1 id="eecc" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">避免无意的类型强制</h1><p id="2547" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了使我们的生活更容易，我们应该采取措施避免无意的数据类型强制。</p><p id="ef92" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们可以使用<code class="fe mh mi mj mk b">===</code>操作符进行比较，并在进行连接之前先显式转换类型。</p><p id="bd63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="20a8" class="mt lf it mk b gy mu mv l mw mx">let applePrice = 1;<br/>let orangePrice = '1';<br/>if (applePrice === orangePrice) {<br/>  //...<br/>}</span></pre><p id="eab1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用于比较，以及:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="780f" class="mt lf it mk b gy mu mv l mw mx">let totalPrice = Number(applePrice) + Number(orangePrice);</span></pre><p id="7b84" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">===</code>不应用数据类型强制进行比较。</p><p id="9a06" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们通过使用<code class="fe mh mi mj mk b">Number</code>函数在将两个操作数相加之前将它们转换成数字来防止用<code class="fe mh mi mj mk b">+</code>符号连接。</p><h1 id="943c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">显式类型强制的好处</h1><p id="a5c4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用类型强制。</p><p id="cdbf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以使用<code class="fe mh mi mj mk b">||</code>将<code class="fe mh mi mj mk b">null</code>、<code class="fe mh mi mj mk b">undefined</code>或其他falsy值强制转换为<code class="fe mh mi mj mk b">false</code>，这样<code class="fe mh mi mj mk b">||</code>运算符将返回第二个操作数。</p><p id="316b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c3a0" class="mt lf it mk b gy mu mv l mw mx">let firstName; <br/>let secondName = firstName || "jane";</span></pre><p id="b7e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于<code class="fe mh mi mj mk b">firstName</code>是<code class="fe mh mi mj mk b">undefined</code>，那么<code class="fe mh mi mj mk b">||</code>运算符会强制<code class="fe mh mi mj mk b">firstName</code>到<code class="fe mh mi mj mk b">false</code>并返回第二个操作数，也就是<code class="fe mh mi mj mk b">'jane'</code>。</p><p id="97d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们可以使用<code class="fe mh mi mj mk b">||</code>操作符返回一个默认值inc，第一个是falsy。</p><h1 id="830e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用函数</h1><p id="d8a0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">函数是JavaScript的组成部分。</p><p id="2cbc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以定义函数来运行重复调用的代码。</p><p id="fd22" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="fdf7" class="mt lf it mk b gy mu mv l mw mx">const addPrices = (first, second) =&gt; {<br/>  return first + second;<br/>};</span></pre><p id="7caf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们可以这样称呼它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7b6b" class="mt lf it mk b gy mu mv l mw mx">let applePrice = 1;<br/>let orangePrice = 2;<br/>const totalPrice = addPrices(applePrice, orangePrice);</span></pre><p id="e7e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们在上面调用函数<code class="fe mh mi mj mk b">addPrices</code>时，它接收数字值。</p><p id="cf18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，当我们将变量传递给函数时，JavaScript不做任何验证。</p><p id="5f9f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们可能会得到意想不到的结果。</p><p id="d481" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是TypeScript可以帮助我们的地方，当参数传入时，我们可以在调用函数之前验证数据类型。</p><h1 id="205d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">函数结果</h1><p id="b8f9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在JavaScript中，函数返回类型由我们返回的值决定。</p><p id="383d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它可以是任何东西，取决于我们返回什么。</p><p id="c95d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="bc16" class="mt lf it mk b gy mu mv l mw mx">let applePrice = 1;<br/>let orangePrice = 2;<br/>const totalPrice = addPrices(applePrice, orangePrice);</span></pre><p id="14bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们返回一个数字。</p><p id="10b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="98ba" class="mt lf it mk b gy mu mv l mw mx">let applePrice = 1;<br/>let orangePrice = '2';<br/>const totalPrice = addPrices(applePrice, orangePrice);</span></pre><p id="8588" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后<code class="fe mh mi mj mk b">addPrices</code>返回一个字符串。</p><p id="5543" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可能是一个问题，因为我们可能不想连接而不是添加。</p><p id="871e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只有两个数相加。否则，它是串联的。</p><p id="ea87" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们不需要传递所有的论点。</p><p id="2014" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们向<code class="fe mh mi mj mk b">addPrices</code>添加第三个参数，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9ea6" class="mt lf it mk b gy mu mv l mw mx">const addPrices = (first, second, third) =&gt; {<br/>  return first + second + third;<br/>};</span><span id="00a9" class="mt lf it mk b gy my mv l mw mx">let applePrice = 1;<br/>let orangePrice = 2;<br/>const totalPrice = addPrices(applePrice, orangePrice);</span></pre><p id="1809" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到<code class="fe mh mi mj mk b">NaN</code>，因为<code class="fe mh mi mj mk b">third</code>是<code class="fe mh mi mj mk b">undefined</code>，将数字和<code class="fe mh mi mj mk b">undefined</code>相加得到<code class="fe mh mi mj mk b">NaN</code>。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/7198f11f54504ddc229867d92d975d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eRwFbcXwGU3EJ4lr"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">泰勒·基瑟在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="ce2e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">避免参数不匹配问题</h1><p id="2dbb" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在JavaScript中，我们可以为一个我们知道是可选的参数设置默认值。</p><p id="4522" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c1bb" class="mt lf it mk b gy mu mv l mw mx">const addPrices = (first, second, third = 0) =&gt; {<br/>  return first + second + third;<br/>};</span></pre><p id="93cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者，我们可以使用rest参数符号将一些或所有参数放入一个数组中。</p><p id="a5ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果<code class="fe mh mi mj mk b">third</code>没有传入值，那么<code class="fe mh mi mj mk b">third</code>被设置为0。</p><p id="6d8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="53ff" class="mt lf it mk b gy mu mv l mw mx">const addPrices = (...rest) =&gt; {<br/>  return rest.reduce((a, b) =&gt; a + b, 0);<br/>};</span></pre><p id="ff98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么<code class="fe mh mi mj mk b">rest</code>就是一个数组，因为spread操作符将所有参数放入一个数组中。</p><h1 id="984b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="fcfb" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">TypeScript只是使用了JavaScript的类型系统。</p><p id="c666" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它通过限制函数的参数类型和返回类型来驯服JavaScript类型系统的动态特性。</p></div></div>    
</body>
</html>