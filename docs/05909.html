<html>
<head>
<title>How to Upload a File from an Angular App using a JSON POST rather than form-data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用JSON POST而不是表单数据从Angular应用程序上传文件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-upload-a-file-from-an-angular-app-using-a-json-post-rather-than-form-data-d713a5966b96?source=collection_archive---------1-----------------------#2020-10-12">https://levelup.gitconnected.com/how-to-upload-a-file-from-an-angular-app-using-a-json-post-rather-than-form-data-d713a5966b96?source=collection_archive---------1-----------------------#2020-10-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f18b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">记录我两个星期的奋斗，克服比我预期的更多的障碍</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3c59b770dcde497a30d50f6909195c4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VZWnXlxCHlq2cmvAxkbk4A.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://www.shutterstock.com/g/Alohaflaminggo" rel="noopener ugc nofollow" target="_blank">alohaflamingo</a>在<a class="ae kv" href="https://www.shutterstock.com/image-photo/hurdle-race-on-red-running-stadium-578968027" rel="noopener ugc nofollow" target="_blank"> shutterstock </a>上拍摄</figcaption></figure><p id="3bb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我写这个故事一部分是为了我未来的自己——所以如果我需要再做一次，我会把这个食谱放在我的指尖上——一部分是为了其他人，希望让一些可怜的灵魂免受我刚刚经历的痛苦。</p><h1 id="2b60" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">序言</h1><p id="ed90" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我继承了一个任务，在我们的Angular 8应用程序中实现文件上传功能。</p><p id="3581" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这项任务与典型的文件上传有所不同，因为我们不是直接上传到文件存储服务器，而是上传到我们的中间节点服务器(由前端团队和我的团队所有)，然后上传到最终的目标文件存储微服务(由后端团队所有)。</p><p id="4e9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这对我和团队的其他成员来说都是新的，所以需要进行研究。</p><p id="ecda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我想把表单数据从浏览器直接发布到文件存储服务器上，我会很轻松，因为我发现了大量相关和有用的资源。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/bfcc480a95c75d834934290d63067b51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p3ODURPD9n7sV4aLOEn3jw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.shutterstock.com/g/Denis+Belitsky" rel="noopener ugc nofollow" target="_blank">丹尼斯·贝利茨基</a>在<a class="ae kv" href="https://www.shutterstock.com/" rel="noopener ugc nofollow" target="_blank"> shutterstock </a>上拍摄</figcaption></figure><p id="0e5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">唉，我走的是一条人迹罕至的路。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/54a5ffcd2fc77456787d6bd611172413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NrwEdoov-DwjIHN5ba9m1g.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://www.shutterstock.com/g/LAVRIKE" rel="noopener ugc nofollow" target="_blank">家庭之路工作室</a>在<a class="ae kv" href="https://www.shutterstock.com/image-photo/dense-forest-mountains-autumn-woods-665760265" rel="noopener ugc nofollow" target="_blank"> shutterstock </a>上拍摄的照片</figcaption></figure><p id="ad9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这让一切都不同了。</p><p id="fbae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我需要的信息分散在许多不同的来源中，将它们收集到一起成为实际可行的东西需要花费大量的时间、研究和失败的尝试。</p><h1 id="fd97" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最终目标:将JSON从节点发布到后端微服务</h1><p id="a98e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">最终我们需要实现的是从节点服务器到后端端点的JSON POST，结构如下:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="fd90" class="mv lt iq mr b gy mw mx l my mz">{<br/>  "filename": "important-info.csv",<br/>  "data":  "QXMgSSBzYXQgaW4gdGhlIGJhdGggdHViLCBzb2FwaW5nIGE...",<br/>  "md5Hash: "a0450857392c612ea0f5369864b60194"<br/>}</span></pre><p id="d0f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中,<code class="fe na nb nc mr b">data</code>是base64编码的文件数据，而<code class="fe na nb nc mr b">md5Hash</code>是数据的MD5哈希值，当数据到达后端时用作校验和来验证其完整性。</p><h1 id="0fcd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">任务#1:从浏览器(角度)发布到节点</h1><p id="c216" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Angular的帖子只是一个典型的JSON帖子，而不是表单数据帖子。</p><p id="bff7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们需要:</p><ol class=""><li id="dbf7" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">提取文件的原始数据(对JavaScript人员来说是一个<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" rel="noopener ugc nofollow" target="_blank">array buffer</a>，对其他人来说是字节数组)</li><li id="0b64" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">生成base64编码的数据字符串</li><li id="924c" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">生成数据MD5哈希</li></ol><p id="defb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们碰巧使用了<a class="ae kv" href="https://www.primefaces.org/primeng/showcase/#/fileupload" rel="noopener ugc nofollow" target="_blank"> PrimeNG的FileUpload组件</a>，但是您的JavaScript代码有很多方法可以获得正在上传的文件。</p><p id="f58a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们从FileUpload组件得到的是一个由<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/File" rel="noopener ugc nofollow" target="_blank">文件</a>对象组成的数组。</p><h2 id="dc26" class="mv lt iq bd lu nr ns dn ly nt nu dp mc lf nv nw me lj nx ny mg ln nz oa mi ob bi translated">任务1.1:提取文件的原始数据</h2><p id="722e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了获得文件的ArrayBuffer数据，我使用了<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/FileReader" rel="noopener ugc nofollow" target="_blank"> fileReader </a> API，它提供了一个从File对象异步读取数据的接口。</p><h2 id="fe07" class="mv lt iq bd lu nr ns dn ly nt nu dp mc lf nv nw me lj nx ny mg ln nz oa mi ob bi translated">任务1.2:获取Base64编码的文件数据字符串</h2><p id="7821" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一旦我得到了ArrayBuffer，我就使用方便的<a class="ae kv" href="https://www.npmjs.com/package/base64-arraybuffer" rel="noopener ugc nofollow" target="_blank">base64-arraybuffer</a>library将它编码为base64字符串，该库可以在array buffer之间编码和解码base64。完美！</p><p id="614a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是完成任务1.1和1.2的代码，将我们从File对象带到base64编码的文件数据字符串(包装在Observable中，因为作为所有好心的Angular开发人员，我们将异步事件作为流来处理):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="eeba" class="mv lt iq bd lu nr ns dn ly nt nu dp mc lf nv nw me lj nx ny mg ln nz oa mi ob bi translated">任务1.3:获取文件数据的MD5哈希</h2><p id="1a58" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">接下来我们需要的是文件数据的MD5散列。</p><p id="13ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我结合使用了<a class="ae kv" href="https://www.npmjs.com/package/spark-md5" rel="noopener ugc nofollow" target="_blank"> SparkMD5 </a>库和<a class="ae kv" href="https://dev.to/qortex/compute-md5-checksum-for-a-file-in-typescript-59a4" rel="noopener ugc nofollow" target="_blank">Michael Monerau</a>编写的库的巧妙用法，该库分块读取文件以避免一次性将整个文件加载到内存中。(你会注意到，我把他的基于承诺的解决方案包装成了可观察的，因为…好心的Angular developer。)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="c055" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意第44行和第48行，他为最终散列提供了两种格式选项。我需要hexdigest表单，所以我使用了第48行的表单。</p><h2 id="6969" class="mv lt iq bd lu nr ns dn ly nt nu dp mc lf nv nw me lj nx ny mg ln nz oa mi ob bi translated">任务1.4:收集发布到节点的信息</h2><p id="f46e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有了生成我们需要的数据的实用方法，我们只需将它们收集到我们的FileUploadService中。</p><p id="0256" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是我们的组件调用的服务方法，传递从FileUpload组件获得的File对象数组:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="44d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该方法调用另外两个方法:一个为每个文件构建POST主体，另一个批量执行文件的实际上传。</p><p id="565d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">建造柱身</strong></p><p id="1d2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一种方法是<code class="fe na nb nc mr b">getPostBodyForFileUpload</code>，将每个文件的片段放在一起。这个方法看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="0442" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">获取编码的文件数据和生成MD5散列都是异步任务，我们将其包装为可观察的，所以我们只使用<code class="fe na nb nc mr b"><a class="ae kv" href="https://rxjs-dev.firebaseapp.com/api/index/function/forkJoin" rel="noopener ugc nofollow" target="_blank">forkJoin</a></code>来执行这两个任务，并将结果映射到一个对象，该对象具有我们的POST主体所需的结构。</p><p id="7fd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">执行岗位</strong></p><p id="686a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由<code class="fe na nb nc mr b">saveFiles</code>、<code class="fe na nb nc mr b">uploadFiles</code>调用的第二个方法获取POST主体的数组，并执行对我们的HttpService的实际调用。方法如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="d2c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个帖子可以包含一个文件数组，但是由于每个请求的大小限制(参见下面的基础设施/架构障碍)，我创建了一个名为<code class="fe na nb nc mr b">getGroupedFileUploadBodies</code>的方法，该方法遍历所有文件并将它们分组到大小限制内的集合中。所以我用一个数组(<code class="fe na nb nc mr b">uploadGroups)</code>)结束，然后映射到一个POST请求数组(<code class="fe na nb nc mr b">requests</code>)。</p><h1 id="18b2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">基础设施/架构障碍</h1><p id="049d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">随着上传最终从浏览器上传，我们进入了旅程的下一阶段:基础设施障碍。</p><h2 id="99ae" class="mv lt iq bd lu nr ns dn ly nt nu dp mc lf nv nw me lj nx ny mg ln nz oa mi ob bi translated">障碍#1:快速中间件请求主体大小</h2><p id="d32e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">第一个显然是我已经计划好的。</p><p id="9324" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在节点服务器上使用了<a class="ae kv" href="https://github.com/expressjs/body-parser#bodyparserjsonoptions" rel="noopener ugc nofollow" target="_blank"> Express body-parser </a>中间件，默认的最大请求正文大小是100KB，因此我必须增加它，以考虑产品所有者请求的2GB文件大小限制:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="6736" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很简单！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/a38cba038fe8df74d80b7d38ce74771f.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*tNTHzDSJ934bY2E8Eir-Pg.gif"/></div></div></figure><p id="b52b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，所有后来的障碍都不那么明显。</p><h2 id="7de1" class="mv lt iq bd lu nr ns dn ly nt nu dp mc lf nv nw me lj nx ny mg ln nz oa mi ob bi translated">障碍#2:带NGINX入口控制器的Kubernetes</h2><p id="4c62" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们发现大于1MB的上传会触发错误响应，特别是来自类似nginx服务器的<code class="fe na nb nc mr b">413 Request Entity Too Large</code>错误响应页面:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="f045" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还发现请求没有到达我们的节点服务器，因为节点服务器日志中没有它们的记录。</p><p id="a944" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">了解你的架构！</strong></p><p id="e4d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用<a class="ae kv" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>来管理我们的服务，你们中熟悉它和经常与它一起使用的<a class="ae kv" href="https://www.nginx.com/products/nginx/kubernetes-ingress-controller/" rel="noopener ugc nofollow" target="_blank"> NGINX入口控制器</a>的人可能马上就知道413响应来自哪里。</p><p id="6a13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，我当时对它一无所知，在他们发现入口控制器正在拦截这些从浏览器到我们在Kubernetes集群中的节点服务器的请求，并且控制器的默认最大请求体大小为1MB之前，我与后端人员和SRE人员进行了几次会谈，向他们解释了我们在前端所做的事情。</p><p id="e9cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们的节点服务器日志中没有413响应和请求记录。</p><p id="5eda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">克服这个障碍需要在我们的应用程序的YAML文件中添加注释<code class="fe na nb nc mr b">nginx.ingress.kubernetes.io/proxy-body-size: "0"</code>,以防止入口控制器对我们的节点服务器的请求施加主体大小限制:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="897a" class="mv lt iq bd lu nr ns dn ly nt nu dp mc lf nv nw me lj nx ny mg ln nz oa mi ob bi translated">障碍#3:我们嘈杂的节点日志</h2><p id="75d0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一旦超过1MB的限制，我们的下一个障碍是10MB。</p><p id="7012" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大于1MB的请求最终到达我们的节点服务器，但是大于10MB的请求在从节点到后端服务的POST中出错。</p><p id="2cc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该请求是一个内部的集群内请求，因此没有通过入口控制器，所以我们需要查看其他地方。</p><p id="0e7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我很快发现，用我们当时的节点日志排除这些错误是不可能的。</p><p id="f37b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在节点服务器上进行日志记录，记录节点发出的每个请求的POST主体，以及发生错误时收到的错误对象。错误对象又包含请求对象。所以每个POST主体至少被写入日志两次。</p><p id="357f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们以前从来没有上传过文件，所以这从来都不是问题。但是现在我们的POST主体可以包含25MB的base64字符串，记录完整的POST主体——如果出现错误，还要多次记录——会使我们的日志变成噪音。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/32f5d10a9d2f67f9603e1e9ec8830b6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*Y5MOlTaoiEMY_IDeyJWxeg.jpeg"/></div></figure><p id="ccc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在我开始有效地排除故障之前，我必须找到代码中请求体或错误对象被写入日志的地方，并将日志消息截断到合理的大小。</p><h2 id="4c58" class="mv lt iq bd lu nr ns dn ly nt nu dp mc lf nv nw me lj nx ny mg ln nz oa mi ob bi translated">第四个障碍(最后一个障碍！):Axios</h2><p id="1a16" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在让我们嘈杂的日志得到控制并再次有用之后，我发现10MB的限制来自于我们的Node HTTP客户端<a class="ae kv" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>。</p><p id="c80b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从节点到后端服务的大于10MB的POST触发了来自axios的以下错误消息:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="cb7f" class="mv lt iq mr b gy mw mx l my mz">Request body larger than maxBodyLength limit</span></pre><p id="657b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">研究表明，axios的默认最大机身大小为10MB，可以通过向<a class="ae kv" href="https://github.com/axios/axios#request-config" rel="noopener ugc nofollow" target="_blank"> axios请求配置</a>对象添加以下选项来覆盖:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="b458" class="mv lt iq mr b gy mw mx l my mz">maxContentLength: Infinity,<br/>maxBodyLength: Infinity</span></pre><p id="ecc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据文档，我认为我需要设置<code class="fe na nb nc mr b">maxBodyLength</code>，但这并没有解决问题——设置<code class="fe na nb nc mr b">maxContentLength</code>就解决了问题。所以，为了安全起见，我把两个都设置了。(我很乐意将它们都设置为<code class="fe na nb nc mr b">Infinity</code>，因为我们在其他地方控制请求的大小。)</p><h1 id="dcc4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">努力做到完美！</h1><p id="d25b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">随着axios配置的改变，我们终于克服了最后的障碍，应用程序运行得非常完美。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/0d377b19a0344c7498b850fb2e893fe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/1*_9hxSvqXinQ0TmXDjTyEdg.gif"/></div></figure><h1 id="dcc9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">摘要</h1><p id="a8cb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">下面是一个让我们了解工作文件上传特性的总结。</p><h2 id="85bb" class="mv lt iq bd lu nr ns dn ly nt nu dp mc lf nv nw me lj nx ny mg ln nz oa mi ob bi translated">构建岗位主体</h2><ol class=""><li id="7a80" class="nd ne iq ky b kz mk lc ml lf oh lj oi ln oj lr ni nj nk nl bi translated">我们使用<a class="ae kv" href="https://www.primefaces.org/primeng/showcase/#/fileupload" rel="noopener ugc nofollow" target="_blank"> PrimeNG的FileUpload组件</a>为每个上传的文件获取了一个<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/File" rel="noopener ugc nofollow" target="_blank"> File </a>对象。</li><li id="8f18" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">我们使用<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/FileReader" rel="noopener ugc nofollow" target="_blank"> FileReader </a> API提取文件的ArrayBuffer数据。</li><li id="f0b4" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">我们使用库<a class="ae kv" href="https://www.npmjs.com/package/base64-arraybuffer" rel="noopener ugc nofollow" target="_blank"> base64-arraybuffer </a>对ArrayBuffer数据进行base64编码。</li><li id="e0a6" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">我们使用<a class="ae kv" href="https://www.npmjs.com/package/spark-md5" rel="noopener ugc nofollow" target="_blank"> SparkMD5 </a>库和该库的基于承诺的实现<a class="ae kv" href="https://dev.to/qortex/compute-md5-checksum-for-a-file-in-typescript-59a4" rel="noopener ugc nofollow" target="_blank">生成了ArrayBuffer数据的MD5散列。</a></li></ol><h2 id="cf09" class="mv lt iq bd lu nr ns dn ly nt nu dp mc lf nv nw me lj nx ny mg ln nz oa mi ob bi translated">让邮件通过管道</h2><p id="a3da" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">事实证明，构造格式正确的请求只是成功的一半。让这些请求通过管道被证明至少同样具有挑战性。</p><p id="be7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下图显示了我们需要安抚的各种把关者，以保持上传向最终目的地前进:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/8af1131f21df3700aa1ae80c8fff9e4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OpeeTo9YKZVmTwFuc9hbUg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">文件上传的基础设施障碍(斯科特·亚当斯的《呆伯特》中的卡通人物)</figcaption></figure><h1 id="7aad" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="9a6d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是我长期以来最具挑战性的任务之一，因为对我来说有太多的未知。</p><p id="ed5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在想，如果我在两周前就知道我现在所知道的所有这些难题，从如何构造POST主体到如何让这些POST请求通过管道中的各个网关守护设备，事情会进展得多顺利。</p><p id="12d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时候，我觉得自己就像印第安纳·琼斯(Indiana Jones)试图越过通往圣杯之路上的保护性陷阱:我刚解决了一个挑战，另一个挑战就在后面等着我。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/258cc67284e6d3d2f9f2881ef96c9d30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*eoS3Ddn3KAULPja5rsN2jA.gif"/></div></figure><h1 id="a786" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">离别之思</h1><p id="9a65" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">因此，我希望这篇文章有助于将完成这项任务所需的各个部分集中在一个地方，也许至少可以节省一个人一点时间和压力。</p></div></div>    
</body>
</html>