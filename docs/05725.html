<html>
<head>
<title>MVC vs MVP vs MVVM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MVC vs MVP vs MVVM</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/mvc-vs-mvp-vs-mvvm-35e0d4b933b4?source=collection_archive---------0-----------------------#2020-09-26">https://levelup.gitconnected.com/mvc-vs-mvp-vs-mvvm-35e0d4b933b4?source=collection_archive---------0-----------------------#2020-09-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="e75e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/tag/thought-programmer" rel="noopener">思维程序员</a></h2><div class=""/><div class=""><h2 id="ea3d" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">它们之间有什么不同？</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/dcd1d49f2bfbc05eb9a37a805f5eac44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zrwD7OZp_Lz0Trzm"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@theunsteady5?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃德温·安德拉德</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="4a67" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如今，当谈到架构设计模式时，我们有许多选择。在使用模型-视图-视图模型(MVVM)、模型-视图-演示者(MVP)和模型-视图-控制器(MVC)开发了许多应用程序后，我终于觉得有资格谈论它们之间的差异了。为了更容易理解，我们可以使用一个简单的例子，比如在<strong class="lk jd"> BookSearch </strong>应用程序中开发一个搜索书籍的屏幕。</p><p id="e336" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们现在开始吧…！</p><h1 id="b784" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">MV(X)要点</h1><p id="91b7" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">首先，在深入研究MVC、MVP和MVVM体系结构之前，我们需要简单地理解它们。</p><h2 id="0d2b" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">为什么是模型-视图-(C或P或VM)？</h2><p id="c9c5" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">这些架构的目的是分离UI应用程序的可视化、处理和数据管理的职责。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/0cd4e0906c4bcc1a47fea83c9d7e1135.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EyHs4py3rl8WsAKhno-oSw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">分离可视化、处理和数据管理的职责</figcaption></figure><p id="4f9f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">他们的目标是增加。</p><ul class=""><li id="67a8" class="nn no it lk b ll lm lo lp lr np lv nq lz nr md ns nt nu nv bi translated">模块性</li><li id="22e3" class="nn no it lk b ll nw lo nx lr ny lv nz lz oa md ns nt nu nv bi translated">灵活性</li><li id="83c9" class="nn no it lk b ll nw lo nx lr ny lv nz lz oa md ns nt nu nv bi translated">易测性</li><li id="ff66" class="nn no it lk b ll nw lo nx lr ny lv nz lz oa md ns nt nu nv bi translated">可维护性</li></ul><h1 id="9422" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">模型-视图-控制器</h1><p id="9ce4" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">或者简称为MVC，是一种广泛用于构建软件应用程序的设计模式。该模式最初是由Trygve Reenskaug在Smalltalk-80 (1979)工作期间设计的，最初被称为模型-视图-控制器-编辑器。MVC在1994年的<a class="ae lh" href="https://www.amazon.co.uk/Design-patterns-elements-reusable-object-oriented/dp/0201633612" rel="noopener ugc nofollow" target="_blank">“设计模式:可重用的面向对象软件的元素”</a>(GoF的书)中被深入的描述，这对推广它的使用起到了作用。该模式将应用程序分成三个部分。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/165b3a4e7bed7e9b79e6176d51fd7ded.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C6X8ZQf3grq0ifscFvMugw.png"/></div></div></figure><ul class=""><li id="6cee" class="nn no it lk b ll lm lo lp lr np lv nq lz nr md ns nt nu nv bi translated"><strong class="lk jd"> <em class="ob">模型</em> </strong> —负责应用程序的业务逻辑。它管理应用程序的状态。这还包括读取和写入数据、保持应用程序状态，甚至可能包括与数据管理相关的任务，如联网和数据验证。</li><li id="2003" class="nn no it lk b ll nw lo nx lr ny lv nz lz oa md ns nt nu nv bi translated"><strong class="lk jd"> <em class="ob">视图</em> </strong> —该组件有两个重要任务:向用户呈现数据和处理用户交互。</li><li id="eef9" class="nn no it lk b ll nw lo nx lr ny lv nz lz oa md ns nt nu nv bi translated"><strong class="lk jd"> <em class="ob">控制器</em> </strong> —视图层和模型层通过一个或多个控制器粘合在一起。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/f16d8635b01213f2bdbb93137eebc716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KuqHoiiiIAU9olKqlkFujA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">Android上的MVC</figcaption></figure><h1 id="2685" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">模型-视图-演示者</h1><p id="7ec9" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">MVP是MVC设计模式的衍生物，它专注于改进表示逻辑。它起源于20世纪90年代早期一家名为<a class="ae lh" href="http://Model-view-presenter (MVP) is a derivative of the MVC design pattern which focuses on improving presentation logic. It originated at a company named Taligent in the early 1990s while they were working on a model for a C++ CommonPoint environment." rel="noopener ugc nofollow" target="_blank"> Taligent </a>的公司，当时他们正在开发一个C++公共点环境的模型。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/40225299473e95338b343a13ac972a71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ru_qYzPdhTnOoFGOcU6qOA.png"/></div></div></figure><p id="34d6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然MVP是MVC的派生物，但它们确实有细微的区别。</p><ul class=""><li id="fe81" class="nn no it lk b ll lm lo lp lr np lv nq lz nr md ns nt nu nv bi translated"><strong class="lk jd"> <em class="ob">模型</em> </strong> —模型表示一组描述业务逻辑和数据的类。它还定义了数据的业务规则，即如何更改和操作数据。</li><li id="d781" class="nn no it lk b ll nw lo nx lr ny lv nz lz oa md ns nt nu nv bi translated"><strong class="lk jd"> <em class="ob">视图</em> </strong> —视图用于与用户进行交互，如XML、活动、片段。它与流程中要实现的逻辑无关。</li><li id="5370" class="nn no it lk b ll nw lo nx lr ny lv nz lz oa md ns nt nu nv bi translated"><strong class="lk jd"><em class="ob">Presenter</em></strong>—Presenter从视图中获取输入，在模型的帮助下处理数据，并在处理完成后将结果传回视图。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/ddbef02f5438a8893036dd8f5df23014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*naMJ_Kfe8sLShjoBwDfjzg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">Android上的MVP</figcaption></figure><h1 id="d1df" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">模型-视图-视图模型</h1><p id="fd77" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">MVVM最初由微软定义，用于Windows Presentation Foundation(WPF)和Silverlight，由John Grossman于2005年在一篇关于Avalon(WPF的代号)的博客文章中正式宣布。这种基于MVC和MVP的模式试图更清晰地将UI的开发与应用程序中的业务逻辑和行为分离开来。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/9c71cf78be8c04acb7a51c0512975320.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j6dM1iDMAn3d94g4tvuLFg.png"/></div></div></figure><p id="dcdd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它有如下三个主要组成部分。</p><ul class=""><li id="5257" class="nn no it lk b ll lm lo lp lr np lv nq lz nr md ns nt nu nv bi translated"><strong class="lk jd">模型</strong>—MVVM使用的模型类似于MVC中使用的模型，由运行软件所需的基本数据组成。</li><li id="1b10" class="nn no it lk b ll nw lo nx lr ny lv nz lz oa md ns nt nu nv bi translated"><strong class="lk jd">视图</strong> —视图是用户和设计模式之间的图形界面，类似于MVC中的视图。它显示已处理数据的输出。</li><li id="fc5a" class="nn no it lk b ll nw lo nx lr ny lv nz lz oa md ns nt nu nv bi translated"><strong class="lk jd">视图模型</strong> —视图模型一方面是视图的抽象，另一方面提供了要链接的模型数据的包装。也就是说，它包含一个被转换成视图的模型，并且它还包含视图可以用来影响模型的命令。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/026bb8d5e1379c3dc75c9544d6dad94d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XRtDb_FlcGjwvXjLqra94w.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">安卓上的MVVM</figcaption></figure><h1 id="d27a" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">MVC vs MVP vs MVVM</h1><p id="3850" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">让我们找出MVC Vs MVP Vs MVVM，主要的区别点。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/15227bfbe0c2e031e0e20ed051c6311f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sIwF6PKHDQl59SdKOYbsPA.jpeg"/></div></div></figure><p id="3330" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">性能评估</strong> —当我们测试UI性能时，MVP被证明是渲染帧时可靠性最高、障碍最小的一个。MVVM中的数据绑定会产生额外的过载，这可能会在执行复杂任务时严重影响其性能。</p><p id="1e72" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">兼容性</strong> —当根据兼容性测试模式时，MVVM是最好的，因为它的数据绑定产生了积极的影响。MVP比MVC表现更好，MVC有严重的重复问题。</p><p id="3a0b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">可修改性</strong> —当我们谈论设计模式时，很明显它应该是可修改的，因为这给了我们在应用程序中添加新功能和策略的选择。</p><ul class=""><li id="8dce" class="nn no it lk b ll lm lo lp lr np lv nq lz nr md ns nt nu nv bi translated">基于这些因素，我们观察到MVP和MVVM的变化很小，MVVM对可维护性贡献很大。</li><li id="af90" class="nn no it lk b ll nw lo nx lr ny lv nz lz oa md ns nt nu nv bi translated">在大多数情况下，MVC倾向于增加变更的数量。</li></ul><p id="c4cf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">引用</strong> —在MVC中，视图没有对控制器的引用，而在MVP中，视图有对演示者的引用，而在MVVM中，视图有对视图模型的引用。</p><p id="d3f7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">入口点</strong> —对于MVC，应用程序的入口点是控制器，而对于MVP和MVVM，入口点是视图。</p><h1 id="9a7b" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">通过各种架构实现示例</h1><p id="874b" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">您可以通过使用下图所示的三种架构之一来实现BookSearch应用程序。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/91be782d324fb34fee873011f7e4aad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*if_3uYnoFmxfWXkKYpDNqw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图书搜索应用程序的MVC、MVP和MVVM实现</figcaption></figure><p id="3a5c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">很简单，对吧？能自己实现吗？</p></div></div>    
</body>
</html>