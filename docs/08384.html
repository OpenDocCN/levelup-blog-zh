<html>
<head>
<title>Tenet of Inversion in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的反转原则</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/tenet-of-inversion-with-python-9759ef73dbcf?source=collection_archive---------9-----------------------#2021-04-27">https://levelup.gitconnected.com/tenet-of-inversion-with-python-9759ef73dbcf?source=collection_archive---------9-----------------------#2021-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="6ba3" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">Python中的干净架构</h2><div class=""/><div class=""><h2 id="33cf" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">打破依赖倒置原则。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/decf4ce7782b792d70a25c6e8c0c0ffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XVVtsGLNGcs8jKGd78B8Qw.jpeg"/></div></div></figure><p id="d26a" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">依赖倒置原则</strong>经常在<strong class="lc ja"> OOP </strong>范例中解释。关于这个概念我想分享另一个角度。在这篇短文中，我将走过一条从抽象到理解什么是真正倒置的道路。</p><h1 id="c2a6" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">介绍</h1><p id="ca09" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">自从第一批编程语言出现以来，它们的使用一直在持续增长。程序变得越来越庞大和复杂。软件开发转向工业。甚至编程的先驱们也开始把程序的大小视为一个难题。</p><blockquote class="mt mu mv"><p id="1b19" class="la lb mw lc b ld le ka lf lg lh kd li mx lk ll lm my lo lp lq mz ls lt lu lv ij bi translated">我的基本问题是，正是这种规模上的差异是我们编程困难的主要来源之一！<br/><strong class="lc ja">——e . w .迪杰斯特拉。结构化程序设计笔记。1970年</strong></p></blockquote><p id="47f5" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">随着规模的扩大，软件的成本也持续增长。开发软件变成了一个长期运行的过程。一旦开发出来，软件会随着时间和需求不断发展。事实证明，软件的主要成本可能不在最初的开发阶段，而在维护阶段。</p><p id="36d3" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">工程师和科学家继续开发理论和方法来处理成本和复杂性。</p><blockquote class="mt mu mv"><p id="7a0a" class="la lb mw lc b ld le ka lf lg lh kd li mx lk ll lm my lo lp lq mz ls lt lu lv ij bi translated">相对于减少调试和修改时间，简单性是评估替代设计的主要衡量标准。<br/><strong class="lc ja">——w . p .史蒂文，G.J .迈尔斯，L.L .康斯坦丁。结构化设计。1974年</strong></p></blockquote><p id="cb47" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">20世纪60、70年代出现了大量的编程范式。而主导模型变成了<strong class="lc ja">结构化设计</strong>和<strong class="lc ja">面向对象编程</strong>。把程序分解成模块和相互通信的对象，这是一个绝妙的主意！</p><p id="ebd0" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">但是开发人员应该如何组织系统的各个部分来达到良好的质量。应该遵循哪些规则？</p><p id="287a" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">1994年，罗伯特·马丁发表了一篇论文，研究了测量面向对象设计质量的标准。</p><blockquote class="mt mu mv"><p id="f7e9" class="la lb mw lc b ld le ka lf lg lh kd li mx lk ll lm my lo lp lq mz ls lt lu lv ij bi translated">本文介绍了简单地使用对象来建模应用程序不足以获得健壮的、可维护的和可重用的设计的情况。<br/><strong class="lc ja">——r·马丁。OO设计质量度量。1994年</strong></p></blockquote><p id="05a6" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">系统的各个部分如何组织和通信要重要得多。设计中子系统的相互依赖使得设计变得僵化和脆弱。</p><p id="0081" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在下一篇论文中，马丁阐述了这个原理。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="963d" class="lw lx iq bd ly lz nh mb mc md ni mf mg kf nj kg mi ki nk kj mk kl nl km mm mn bi translated">原则</h1><blockquote class="mt mu mv"><p id="a947" class="la lb mw lc b ld le ka lf lg lh kd li mx lk ll lm my lo lp lq mz ls lt lu lv ij bi translated">1.高层模块不应该依赖低层模块。两者都应该依赖于抽象(例如接口)。<br/> 2。抽象不应该依赖于细节。细节(具体的实现)应该依赖于抽象。<br/><strong class="lc ja">——r·马丁。依存倒置原则。1996年</strong></p></blockquote></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="eb10" class="lw lx iq bd ly lz nh mb mc md ni mf mg kf nj kg mi ki nk kj mk kl nl km mm mn bi translated">显示优点的东西</h1><p id="b53d" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">例如，让我们想出一个简单的<strong class="lc ja">用例</strong>。我们有一个脚本，接收一些输入数据，处理它，并打印结果。</p><p id="44e7" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为了简单起见，我用下面的方式写下来。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">显示优点的东西</figcaption></figure><p id="224e" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在我们的实验中，我们将思考<strong class="lc ja">抽象</strong>如何接收数据以及我们如何处理数据。我把它写成了<code class="fe ns nt nu nv b">data = [1, 2, 3]</code>，但是也可以写成<code class="fe ns nt nu nv b">requests.get(“<a class="ae nw" href="https://jsonplaceholder.typicode.com/users" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/users</a>”)</code>或者更复杂的东西。<code class="fe ns nt nu nv b">result = [each * each for each in data]</code>也是如此。这些细节我们不关心。</p><p id="dcf3" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在那里，我们引入了抽象概念。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="9ef0" class="lw lx iq bd ly lz nh mb mc md ni mf mg kf nj kg mi ki nk kj mk kl nl km mm mn bi translated">抽象</h1><p id="233d" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">抽象思维被认为是人类思维的关键属性之一。这种能力很可能与人类语言的发展密切相关。</p><p id="1862" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在软件工程和计算机科学中，<strong class="lc ja">抽象</strong>是去除时间细节以关注更重要的细节的过程。</p><p id="8b97" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">抽象的技术形式可以是不同的，仅举几个例子:</p><ul class=""><li id="4038" class="nx ny iq lc b ld le lg lh lj nz ln oa lr ob lv oc od oe of bi translated"><strong class="lc ja">数据类型</strong>的用法；</li><li id="f8a0" class="nx ny iq lc b ld og lg oh lj oi ln oj lr ok lv oc od oe of bi translated"><strong class="lc ja">程序</strong>和<strong class="lc ja">功能</strong>的概念；</li><li id="57fe" class="nx ny iq lc b ld og lg oh lj oi ln oj lr ok lv oc od oe of bi translated">将普通行为从非抽象<strong class="lc ja">类</strong>重组为<strong class="lc ja">“抽象类】</strong>的过程。</li></ul><p id="dd33" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们可以使用函数作为抽象来重写代码。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">作为抽象的功能</figcaption></figure><p id="3dcf" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">首先我们可以注意到代码变得越来越大。这是使用抽象的代价。</p><p id="c44d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">但是我们在代码中增加了结构。我们把<strong class="lc ja">用例</strong>分离到了<code class="fe ns nt nu nv b">run()</code>函数，现在它读起来就像一个故事。是我们<strong class="lc ja">高层</strong>的政策。</p><blockquote class="mt mu mv"><p id="d2cf" class="la lb mw lc b ld le ka lf lg lh kd li mx lk ll lm my lo lp lq mz ls lt lu lv ij bi translated">获取数据并处理数据。<br/> - <strong class="lc ja">用例。</strong></p></blockquote><p id="9c01" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们将<strong class="lc ja">低级</strong>细节隐藏在<strong class="lc ja">抽象</strong> <code class="fe ns nt nu nv b">fetch()</code>和<code class="fe ns nt nu nv b">process()</code>后面。</p><p id="b447" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">正如我们所见，我们的<strong class="lc ja">高级</strong>模块依赖于抽象，在我们的例子中，它们是函数。但是我们的底层抽象仍然依赖于细节。</p><p id="6ea3" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们的<strong class="lc ja">依赖</strong>感觉不对劲。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="92be" class="lw lx iq bd ly lz nh mb mc md ni mf mg kf nj kg mi ki nk kj mk kl nl km mm mn bi translated"><strong class="ak">依赖关系</strong></h1><p id="b71e" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">当我们引入一个新的组件时，它并不存在于真空中。它与其他组件进行通信和连接。这种连接有一个专门的术语——一个<strong class="lc ja">联轴器</strong>。</p><p id="fd9a" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">并非所有的从属关系都是平等的。<strong class="lc ja">耦合度</strong>可以不同。</p><p id="926b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">高耦合— </strong>组件使用另一组件的<strong class="lc ja">内部</strong>细节。</p><p id="9764" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">低耦合— </strong>组件依赖于另一个组件的<strong class="lc ja">外部</strong>名称或<strong class="lc ja">接口</strong>。</p><p id="6742" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">外部</strong>和<strong class="lc ja">内部</strong>关系与名称范围密切相关。</p><p id="0687" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">回到我们的例子，名字<code class="fe ns nt nu nv b">fetch()</code>和<code class="fe ns nt nu nv b">process()</code>是<strong class="lc ja">全局</strong>名字，直接用于<code class="fe ns nt nu nv b">run()</code>函数的<strong class="lc ja">内部</strong>名字空间。这种用法在组件之间形成了刚性的<strong class="lc ja">连接。</strong></p><p id="86a7" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果我们想要低<strong class="lc ja">耦合</strong>，我们可以向<code class="fe ns nt nu nv b">run()</code>函数添加参数，并使用这些名称作为对原始函数的引用。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">分离抽象</figcaption></figure><p id="73b6" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">通过这个简单的改变，我们使我们的<code class="fe ns nt nu nv b">run()</code>更加灵活和可测试。我们可以使用类似<strong class="lc ja">接口</strong>的其他函数。我们可以使用模拟来测试或实现其他获取或处理过程。</p><p id="01bd" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这些函数的<strong class="lc ja">接口</strong>到底是什么？</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="6d0f" class="lw lx iq bd ly lz nh mb mc md ni mf mg kf nj kg mi ki nk kj mk kl nl km mm mn bi translated">多态性</h1><p id="4d6b" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">参数<code class="fe ns nt nu nv b">fetch</code>和<code class="fe ns nt nu nv b">process</code>与<code class="fe ns nt nu nv b">fetch()</code>和<code class="fe ns nt nu nv b">process()</code>函数不是一回事。它们只是预期具有特定行为的东西的名称或者可以在<code class="fe ns nt nu nv b">run()</code>函数中使用的<strong class="lc ja">接口</strong>。</p><p id="7e09" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在语言层面上，这种可能性被称为<strong class="lc ja">多态性</strong>。</p><p id="c458" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在我们的<strong class="lc ja">依赖</strong>将不是一个函数，而是一个多态的<strong class="lc ja">接口。</strong>因为Python有一个<strong class="lc ja"> duck typing多态</strong>这个接口是隐式定义的。</p><p id="043d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们可以使用类型提示来描述预期的<strong class="lc ja">接口</strong>。可能是这样的。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">类型提示</figcaption></figure><p id="f825" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在我们将我们的<strong class="lc ja">依赖</strong>从函数转移到<strong class="lc ja">多态</strong>接口。</p><p id="2267" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">那就是<strong class="lc ja">反转</strong>发生的地方。</p><p id="7e75" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我在前面的故事中描述了Python中<strong class="lc ja">多态性</strong>的更多例子。</p><div class="ol om gp gr on oo"><a rel="noopener  ugc nofollow" target="_blank" href="/hidden-power-of-polymorphism-in-python-c9e2539c1633"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ja gy z fp ot fr fs ou fu fw iz bi translated">Python中多态隐藏的力量</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">如何在应用程序中实现多态接口？</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ky oo"/></div></div></a></div><h1 id="5a5e" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">倒置</h1><p id="e125" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">我们将画出<strong class="lc ja"> </strong>图来显示到底是什么在反转。</p><p id="010c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">首先，是“作为抽象的功能”变体的模式。其中高级功能<code class="fe ns nt nu nv b">run()</code>将低级功能作为依赖项。我们正在考虑将<strong class="lc ja">功能</strong>作为<strong class="lc ja">抽象</strong>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/90677922652000b50bf480acf7721d5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*cOCFsGd6k6JhmYhXwgxFMQ.png"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">作为抽象图的功能</figcaption></figure><p id="1615" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">但是抽象之间的<strong class="lc ja">耦合</strong>太严格了，我们的底层抽象依赖于细节。</p><p id="0ff0" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们向<code class="fe ns nt nu nv b">run()</code>函数添加了参数。通过这样做，我们引入了新的<strong class="lc ja">抽象</strong>作为<strong class="lc ja">多态</strong>接口。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/deddc1d1e35644fbc384f63959bf464e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*VNLi-oeGPXHzBUcGf4ANbA.png"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">解耦抽象图</figcaption></figure><p id="4845" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">实线表示代码执行时的运行时流程。虚线是源代码流程。</p><p id="bd96" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">运行时</strong>并不关心所有这些<strong class="lc ja">反转</strong>和<strong class="lc ja">抽象</strong>。它们只对开发人员有帮助。理解设计变得越来越容易，维护也越来越容易。</p><p id="8bd5" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们可以把<strong class="lc ja">反转</strong>看作是<strong class="lc ja">低级</strong>函数和该函数实现的<strong class="lc ja">接口</strong>之间的方向差异。</p><p id="c901" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">更多一些用<strong class="lc ja"> DIP </strong>分层的例子可以在我的GitHub repo<strong class="lc ja"/><a class="ae nw" href="https://github.com/pavel-fokin/py-dependency-inversion-study" rel="noopener ugc nofollow" target="_blank"><strong class="lc ja">py-dependency-inversion-study</strong></a><strong class="lc ja">中找到。</strong></p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="7231" class="lw lx iq bd ly lz nh mb mc md ni mf mg kf nj kg mi ki nk kj mk kl nl km mm mn bi translated"><strong class="ak">结论</strong></h1><p id="e030" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">作为一门高度动态的语言，Python有各种可能性来创建富有表现力和良好表达的应用程序。</p><p id="ee19" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">使用<strong class="lc ja"> DIP </strong>是在系统内创建干净架构的基本机制。它的正确应用将有助于进行分层良好的设计，将业务逻辑与其他细节分离开来。</p><h2 id="bb23" class="pe lx iq bd ly pf pg dn mc ph pi dp mg lj pj pk mi ln pl pm mk lr pn po mm iw bi translated">更多阅读</h2><p id="eb8d" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">如果你喜欢这篇文章，你可以对以下内容感兴趣。</p><p id="a880" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如何将<strong class="lc ja">功能</strong>和<strong class="lc ja">面向对象</strong>编程与Python中迭代器的组合结合起来</p><div class="ol om gp gr on oo"><a href="https://towardsdatascience.com/how-to-track-hazardous-asteroids-with-composition-of-iterators-in-python-3945cf8e8f84" rel="noopener follow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ja gy z fp ot fr fs ou fu fw iz bi translated">如何用Python中迭代器的组合追踪危险的小行星</h2><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">towardsdatascience.com</p></div></div><div class="ox l"><div class="pp l oz pa pb ox pc ky oo"/></div></div></a></div></div></div>    
</body>
</html>