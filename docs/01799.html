<html>
<head>
<title>How to Set up Your Own Dependency Injection with Reader</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Reader设置自己的依赖注入</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-set-up-your-own-dependency-injection-with-reader-69ef33a1d471?source=collection_archive---------22-----------------------#2020-01-29">https://levelup.gitconnected.com/how-to-set-up-your-own-dependency-injection-with-reader-69ef33a1d471?source=collection_archive---------22-----------------------#2020-01-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/cf1473df9fd1bf516066ed0aa68e96fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m82MwwyEzdz07dNM"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><em class="kf">原载于</em><a class="ae kg" href="https://edward-huang.com/functional-programming/scala/cats/monad/tech/2020/01/29/how-to-set-up-your-own-dependency-injection-with-reader/" rel="noopener ugc nofollow" target="_blank"><em class="kf">https://edward-huang.com</em></a><em class="kf">。</em></figcaption></figure><p id="5128" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">有许多方法可以创建依赖注入。依赖注入有助于将一个对象与另一个对象解耦，在运行时绕过对框架或对象的依赖。因此，客户端不需要找到需要向对象或框架提供什么依赖——相反，系统告诉客户端他们需要向对象提供什么依赖。</p><p id="5860" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在Scala中，有很多方法可以创建依赖注入。今天，我将讨论在Cats中使用Reader作为Monad来创建依赖注入，以及Reader如何帮助您快速地为您的系统创建配置验证。</p><p id="1c90" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">想象一下，如果您需要创建一个验证系统，可以轻松地挑选各种操作来验证系统中的配置。您可以创建一个方法来验证配置中的每个组件。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="5b3c" class="lo lp it lk b gy lq lr l ls lt">def isCorrectEmail(id:Long, email:String, repo: Repository) : Boolean = {<br/>  if(repo.findId(id)) repo.getId(id) ....<br/>}</span></pre><p id="77f0" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在这种情况下，如果有一天需要验证一个新的配置属性，或者需要对配置进行专门的检查以使其通过，您将需要查看代码并更改方法。</p><p id="1d59" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">随着配置文件中更多的更改，您需要每次都转到该文件并更改代码。此外，每一张支票都是相互关联的，因此将来很难更新。</p><h1 id="d6e8" class="lu lp it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">拯救读者</h1><p id="e387" class="pw-post-body-paragraph kh ki it kj b kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la mv lc ld le im bi translated">Cats Reader数据类型可以帮助您将多个操作链接在一起，并产生一个重要的计算，该计算接受一个配置作为一个参数。如果您输入了配置，它会按照我们指定的方式运行，这将是最好的。</p><p id="706f" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们来看看<code class="fe mw mx my lk b">Reader[A, B]</code>的定义:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="8482" class="lo lp it lk b gy lq lr l ls lt">object Reader {<br/>  def apply[A,B](f:A =&gt; B) : Reader[A,B] =  ReaderT[Id,A,B]<br/>}</span></pre><p id="4d8b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这意味着当你创建一个<code class="fe mw mx my lk b">Reader[A, B]</code>时，它得到A类型的回调函数并返回B类型。</p><p id="2802" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">创建阅读器的示例:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="0e58" class="lo lp it lk b gy lq lr l ls lt">case class Cat(sound: String)<br/><br/><em class="mz">// extracting the sound from the Cat class<br/></em>val retrieveSound : Reader[Cat, String] = Reader {cat =&gt; <br/>  cat.sound<br/>}</span></pre><p id="8160" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">当实例化Reader类型时，传递接收到的配置的回调函数，在本例中为<code class="fe mw mx my lk b">Cat</code>，并检索其中的一个属性，在本例中为<code class="fe mw mx my lk b">cat.sound</code>。</p><p id="b004" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在您定义了阅读器类型之后，您可以通过运行方法<code class="fe mw mx my lk b">run</code>来调用它，并将配置作为参数<code class="fe mw mx my lk b">run</code>提供:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="6cfe" class="lo lp it lk b gy lq lr l ls lt"><em class="mz">// calling the cat<br/></em>println(retrieveSound.run(Cat("meow"))) <em class="mz">// meow</em></span></pre><p id="8a98" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">如果您读到这里，您可能会停下来想一想，“Reader为什么要这样输入Monad，尤其是对于常规的验证原始函数？”</p><p id="ad58" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我的朋友，答案是单子型是它的独特之处。</p><p id="566b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">作为一个Monad，读取器类型可以调用map和flatMap来链接操作，并修改现有读取器的操作。</p><p id="bb14" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">通常，您会创建一组接受相同类型配置的读取器。然后，您可以用flatMap和Map组合并链接它们，然后使用<code class="fe mw mx my lk b">run</code>并在最后提供该配置。</p><h1 id="8b3d" class="lu lp it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">地图</h1><p id="9aa4" class="pw-post-body-paragraph kh ki it kj b kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la mv lc ld le im bi translated">map方法修改读取器内部的计算，绕过函数得到回调函数的结果。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="e32f" class="lo lp it lk b gy lq lr l ls lt"><em class="mz">// from previous Cat example<br/></em>val checkSound: Reader[Cat, Boolean] = retrieveSound.map(_ == "meow")<br/><br/>checkSound.run(Cat("bark")) <em class="mz">// false</em></span></pre><h1 id="e4f7" class="lu lp it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">平面地图</h1><p id="82cc" class="pw-post-body-paragraph kh ki it kj b kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la mv lc ld le im bi translated">平面图操作是Reader如此强大的原因。它有助于组合依赖于相同输入类型的操作。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="fee3" class="lo lp it lk b gy lq lr l ls lt">val greet:Reader[Cat, String] = Reader{cat =&gt;<br/>  s"hello $cat"<br/>}<br/><br/>val sound:Reader[Cat, String] = Reader{cat =&gt;<br/>  s"${cat.sound} ${cat.sound}"<br/>}<br/><br/>val greetAndSound = for{<br/>  g &lt;- greet<br/>  check &lt;- checkSound<br/>  s &lt;- sound<br/>} yield {<br/>  if(check) g + s else "sound is not right"<br/>}<br/><br/>val result = greetAndSound.run(Cat("meow"))<br/>println(result)<br/>val notRight = greetAndSound.run(Cat("bark"))<br/>println(notRight)</span></pre><h1 id="9b92" class="lu lp it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">读者在行动</h1><p id="1d9b" class="pw-post-body-paragraph kh ki it kj b kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la mv lc ld le im bi translated">Reader可以设置您的所有操作，并将配置作为参数注入您的操作。</p><p id="fa61" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们创建一个验证检查函数，给定一个id和一个电子邮件，检查数据库中是否有与该id对应的电子邮件。让我们创建我们的存储库案例类:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="8a87" class="lo lp it lk b gy lq lr l ls lt">case class Repository(userDB:Map[Long, String], emailDB: Map[String, List[String]])</span></pre><p id="840f" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><code class="fe mw mx my lk b">userDB</code>地图<code class="fe mw mx my lk b">id, Long</code>到<code class="fe mw mx my lk b">username, String</code>。<code class="fe mw mx my lk b">emailDB</code>将用户名映射到电子邮件列表。</p><p id="0a36" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">首先，我们需要创建一个获取id并检索用户名的阅读器类型getUser。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="ce6c" class="lo lp it lk b gy lq lr l ls lt">def getUser(id:Long):Reader[Repository, Option[String]] = Reader{repo =&gt;<br/>    repo.userDB.get(id)<br/>  }</span></pre><p id="b9c0" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">然后，我们创建<code class="fe mw mx my lk b">getEmail</code>，它将获取用户名并返回一个电子邮件列表。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="d0f4" class="lo lp it lk b gy lq lr l ls lt">def getEmail(username:Option[String]): Reader[Respository, List[String]] = Reader {repo =&gt;<br/>    repo.emailDB.getOrElse(username.fold("none")(st =&gt; st), List.empty[String])<br/>  }</span></pre><p id="1a81" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">最后，我们可以让Reader接受id和email参数，并检查id是否包含email地址。用这个方法，我们把<code class="fe mw mx my lk b">getUser</code>方法和<code class="fe mw mx my lk b">getEmail</code>结合起来。然后，我们检查电子邮件列表是否与参数中输入的电子邮件相匹配。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="343b" class="lo lp it lk b gy lq lr l ls lt">def checkIfEmailMatch(id:Long, email:String):UserReader[Boolean] = for {<br/>    usernameOption &lt;- getUser(id)<br/>    emails &lt;- getEmail(usernameOption)<br/>  } yield {<br/><br/>    emails.contains(email)<br/>  }</span></pre><p id="b219" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">如何执行<code class="fe mw mx my lk b">checkIfEmailMatch</code>？</p><p id="4798" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们设置主方法:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="04c9" class="lo lp it lk b gy lq lr l ls lt">val userDB = Map(<br/>    1L -&gt; "john",<br/>    2L -&gt; "jane",<br/>    3L -&gt; "kate"<br/>)<br/>val emailDB = Map(<br/>  "john" -&gt; List("something@gmail.com"),<br/>  "jane" -&gt; List("jane@yahoo.com", "jane@gmail.com"),<br/>  "kate" -&gt; List("kate@hotmail.com", "kate123@yahoo.com")<br/>)<br/><br/>val repo = Repository(userDB,emailDB)<br/>val res = checkIfEmailMatch(2L, "jane@gmail.com").run(repo)<br/>println(res)</span></pre><p id="74e9" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们设置了所有的操作，从<code class="fe mw mx my lk b">getUser</code>开始，然后是<code class="fe mw mx my lk b">getEmail</code>。然后，我们将这两个操作组合到<code class="fe mw mx my lk b">checkIfEmail</code> exist。这些都包含在一个配置文件中，也就是repo。当你调用<code class="fe mw mx my lk b">run</code>方法时，它执行操作。</p><h1 id="20bc" class="lu lp it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">外卖食品</h1><ul class=""><li id="e26c" class="na nb it kj b kk mr ko ms ks nc kw nd la ne le nf ng nh ni bi translated">Reader为依赖注入提供了一个工具——通过在相同的配置中设置所有的操作。</li><li id="d32b" class="na nb it kj b kk nj ko nk ks nl kw nm la nn le nf ng nh ni bi translated">当我们想构造一个可以很容易地用函数表示的批处理程序时，阅读器是最有用的；推迟一个已知参数的注入，隔离我们想要测试的程序部分。</li><li id="cb36" class="na nb it kj b kk nj ko nk ks nl kw nm la nn le nf ng nh ni bi translated">通过将您的系统设置为阅读器，您可以将您的阅读器表示为一个纯函数，并使用map或flatMap来组合它们。</li></ul></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="f9ad" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">注册我的<a class="ae kg" href="https://edward-huang.com/subscribe/" rel="noopener ugc nofollow" target="_blank">时事通讯</a>每周获取此内容！</p></div></div>    
</body>
</html>