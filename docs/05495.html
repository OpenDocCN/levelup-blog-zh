<html>
<head>
<title>Learning JavaScript: An Introduction to Classes Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习JavaScript:类的介绍第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-javascript-an-introduction-to-classes-part-1-d4c07b59ee3c?source=collection_archive---------16-----------------------#2020-09-02">https://levelup.gitconnected.com/learning-javascript-an-introduction-to-classes-part-1-d4c07b59ee3c?source=collection_archive---------16-----------------------#2020-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ddf75a89f76be276ecca67e510948fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NtVpkZAt7P3Dz8ED"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@rugeli?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">摄影师杨</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="6ce1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript并不总是能够像在C++和Java等语言中那样创建经典对象，但是自从EcmaScript 6的开发以来，您现在可以了。在本文中，我将介绍如何在JavaScript中创建类，包括如何实现构造函数和访问方法(getters和setters ),我将在以后的文章中介绍JavaScript类的其他方面。</p><h1 id="3f9e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">EcmaScript 6之前的类</h1><p id="fef1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在以前版本的JavaScript (EcmaScript)中，不能像在C++和Java等语言中那样创建类。相反，您必须创建一个构造函数，然后将方法分配给构造函数的原型。以下示例演示了这种技术:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7930" class="mq lf it mm b gy mr ms l mt mu">function Student(name, id, grades) {<br/>  this.name = name;<br/>  this.id = id;<br/>  this.grades = grades;<br/>}</span><span id="3495" class="mq lf it mm b gy mv ms l mt mu">Student.prototype.calcAverage = function() {<br/>  let sum = 0;<br/>  for (grade of this.grades) {<br/>    sum += grade;<br/>  }<br/>  return sum / this.grades.length;<br/>}</span><span id="1815" class="mq lf it mm b gy mv ms l mt mu">let stu1 = new Student("Jane Smith", 1234, [81, 77, 92]);<br/>print("Grade average: " + stu1.calcAverage());<br/>// displays 83.33333333333</span></pre><p id="e8f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这不是经典的面向对象编程(OOP)语言定义类对象和方法的方式，但在以前的JavaScript版本中，这是最接近的方式。</p><h1 id="bf7a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">现在用JavaScript创建类</h1><p id="fdd5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当前版本的JavaScript现在允许您创建与经典OOP语言创建类的方式更密切相关的类。让我们先看看如何将上面的学生示例定义为一个类:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e6cc" class="mq lf it mm b gy mr ms l mt mu">class Student {</span><span id="7f8a" class="mq lf it mm b gy mv ms l mt mu">  constructor(name, id, grades) {<br/>    this.name = name;<br/>    this.id = id;<br/>    this.grades = grades;<br/>  }<br/>  <br/>  calcAverage() {<br/>    let sum = 0;<br/>    for (let grade of this.grades) {<br/>      sum += grade;<br/>    }<br/>    return sum / this.grades.length;<br/>  }<br/>}</span><span id="bedd" class="mq lf it mm b gy mv ms l mt mu">let stu1 = new Student("Jane Smith", 1234, [81, 77, 92]);<br/>print("Grade average: " + stu1.calcAverage());</span></pre><p id="969b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c2eb" class="mq lf it mm b gy mr ms l mt mu">Grade average: 83.33333333333</span></pre><p id="c614" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类定义看起来更像是在其他OOP语言中完成的方式。关键字<code class="fe mw mx my mm b">class</code>表示一个类定义即将出现。创建一个构造函数，不是用类名，而是用关键字<code class="fe mw mx my mm b">constructor</code>。尽管如此，正如您在示例程序中看到的，仍然使用类名调用构造函数。</p><h1 id="3067" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">类定义是语法糖</h1><p id="25ac" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">类定义只是隐藏了JavaScript中创建对象原型的标准方式的语法糖。这意味着我可以使用旧的JavaScript对象语法来定义上面的<code class="fe mw mx my mm b">Student</code>类，就像这样(这个例子是根据尼古拉斯·c·扎卡斯的《理解EcmaScript 6 一书中的一个例子修改的，第168页):</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1b74" class="mq lf it mm b gy mr ms l mt mu">let Student = function(name, id, grades) {<br/>  "use strict";<br/>  const Student = function(name, id, grades) {<br/>    if (typeof new.target === "undefined") {<br/>      throw new Error("Constructor must be called with new.");<br/>    }<br/>    this.name = name;<br/>    this.id = id;<br/>    this.grades = grades;<br/>  }</span><span id="afcb" class="mq lf it mm b gy mv ms l mt mu">  Object.defineProperty(Student.prototype, "calcAverage", {<br/>    value: function() {<br/>      if (typeof new target !== "undefined") {<br/>        throw new Error("Method cannot be called with new.");<br/>      }<br/>      let sum = 0;<br/>      for (let grade of this.grades) {<br/>        sum += grade;<br/>      }<br/>      return sum / this.grades.length;<br/>  },<br/>  enumerable: false,<br/>  writable: true,<br/>  configurable: true<br/>  });<br/>  return Student;<br/>}());</span></pre><p id="e501" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显然，类语法使得创建类比用老方法容易得多。</p><p id="d9ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不过，这里有几件事需要注意。首先，默认情况下，类定义中的所有代码都以严格模式运行。此外，默认情况下，所有方法都被定义为不可数的。不能用<code class="fe mw mx my mm b">new</code>关键字调用类方法，但必须用new关键字调用类构造函数。</p><p id="0ebe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一般来说，这种新的用于创建类的JavaScript语法为您提供了许多功能，而不必像以前的JavaScript版本那样编写更复杂的基于对象的语法。</p><h1 id="2bc8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">类构造函数</h1><p id="987b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如上面的例子所示，类需要用构造函数实例化。下面是另一个定义了构造函数的类定义:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c54f" class="mq lf it mm b gy mr ms l mt mu">class Person {<br/>  constructor(name, age) {<br/>    this.name = name;<br/>    this.age = age;<br/>  }</span><span id="5eda" class="mq lf it mm b gy mv ms l mt mu">  show() {<br/>    return this.name + ", " + this.age;<br/>  }<br/>}</span></pre><p id="a1be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你没有定义构造函数，系统会自动为你提供一个默认的构造函数。这里有一个例子来说明这一点:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="645b" class="mq lf it mm b gy mr ms l mt mu">class Person {<br/>  show() {<br/>    return this.name + ", " + this.age;<br/>  }<br/>}</span><span id="6fbe" class="mq lf it mm b gy mv ms l mt mu">let you = new Person();<br/>print(you.show());</span></pre><p id="81f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3258" class="mq lf it mm b gy mr ms l mt mu">undefined, undefined</span></pre><p id="7255" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即使我没有定义构造函数方法，程序也没有崩溃，因为创建了一个默认的构造函数并将<code class="fe mw mx my mm b">undefined</code>分配给<code class="fe mw mx my mm b">name </code>和<code class="fe mw mx my mm b">age</code>。</p><p id="e0e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果已经定义了另一个构造函数，则不能定义默认构造函数。类只允许一个构造函数定义，或者，换句话说，它们只允许使用一次<code class="fe mw mx my mm b">constructor</code>关键字。当没有定义构造函数或者已经定义了另一个构造函数时，系统提供默认的构造函数。</p><h1 id="18bf" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">访问者属性</h1><p id="a0b1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">完整的类定义提供了用于检索和设置属性值的访问器方法(或者JavaScript中的属性)。在OOP语言中，这些通常被称为getters和setters。</p><p id="95cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们从获取当前属性开始。定义中使用的关键词是<code class="fe mw mx my mm b">get</code>。此属性只返回存储在属性中的值。下面是带有getter属性的<code class="fe mw mx my mm b">Person</code>类定义:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2513" class="mq lf it mm b gy mr ms l mt mu">class Person {<br/>  constructor(name, age) {<br/>    this.name = name;<br/>    this.pAge = age;<br/>  }</span><span id="e688" class="mq lf it mm b gy mv ms l mt mu">  get age() {<br/>    return this.pAge;<br/>  }</span><span id="7fe9" class="mq lf it mm b gy mv ms l mt mu">  show() {<br/>    return this.name + ", " + this.age;<br/>  }<br/>}</span><span id="f9b8" class="mq lf it mm b gy mv ms l mt mu">let me = new Person("John Green", 24);<br/>print("Age: " + me.age); // displays Age: 24</span></pre><p id="1add" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我将存储一个人的年龄的属性的名称改为<code class="fe mw mx my mm b">pAge</code>，这样我就可以使用<code class="fe mw mx my mm b">age</code>作为getter属性。</p><p id="c215" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们给类定义添加一个setter。拥有setter允许您在设置属性值时执行一些数据验证。例如，<code class="fe mw mx my mm b">age</code>属性可以设置为任何有效的数字，因此某人的年龄可以是-2000或123，456。让我们为<code class="fe mw mx my mm b">age</code>定义setter，以便它只接受从0到120的值。</p><p id="6abd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个setter的新类定义:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="25dd" class="mq lf it mm b gy mr ms l mt mu">class Person {<br/>  constructor(name, age) {<br/>    this.name = name;<br/>    if (age &gt;= 0 &amp;&amp; age &lt;= 120) {<br/>      this.pAge = age;<br/>    }<br/>    else {<br/>      this.pAge = 0;<br/>    }<br/>  }</span><span id="0590" class="mq lf it mm b gy mv ms l mt mu">  get age() {<br/>    return this.pAge;<br/>  }</span><span id="2e88" class="mq lf it mm b gy mv ms l mt mu">  set age(value) {<br/>    if (value &gt;= 0 &amp;&amp; value &lt;= 120) {<br/>      this.pAge = value;<br/>    }<br/>    else {<br/>      this.pAge = 0;<br/>    }<br/>  }</span><span id="cd70" class="mq lf it mm b gy mv ms l mt mu">  show() {<br/>    return this.name + ", " + this.age;<br/>  }<br/>}</span><span id="bf77" class="mq lf it mm b gy mv ms l mt mu">let me = new Person("John Green", 24);<br/>print("Age: " + me.age); // displays Age: 24<br/>me.age = 121;<br/>print("Age: " + me.age); // displays 0<br/>me.age = 25;<br/>print("Age: " + me.age); // displays Age: 25</span></pre><p id="67d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查看我的类定义，我还需要将这个数据验证代码添加到我的构造函数中，就像这样:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d84c" class="mq lf it mm b gy mr ms l mt mu">constructor(name, age) {<br/>  this.name = name;<br/>  if (age &gt;= 0 &amp;&amp; age &lt;= 120) {<br/>    this.pAge = age;<br/>  }<br/>  else {<br/>    this.pAge = 0;<br/>  }<br/>}</span></pre><p id="f247" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一种解决方案是编写一个函数来验证年龄，并从构造函数和设置函数中调用该函数。我将把它留给读者作为练习。</p><h1 id="5f3f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在第2部分中</h1><p id="15e6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我只是触及了用JavaScript创建类的表面。在我的下一篇文章中，我将讨论更多的类特性，包括如何将类视为一级对象、计算成员名和静态类成员。在那篇文章之后，我将转向JavaScript中的类继承。</p><p id="47db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请将您的意见和建议通过电子邮件发送至<a class="ae kf" href="mailto:mmmcmillan1@att.net" rel="noopener ugc nofollow" target="_blank">mmmcmillan1@att.net</a>。如果你对我的在线编程课程感兴趣，请访问https://learningcpp.teachable.com<a class="ae kf" href="https://learningcpp.teachable.com" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>