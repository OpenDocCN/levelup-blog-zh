<html>
<head>
<title>Learn how to build a token-based authentication service using Spring Boot and Spring Security</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解如何使用Spring Boot和Spring Security构建基于令牌的认证服务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learn-how-to-build-a-token-based-authentication-server-using-spring-boot-and-spring-security-14a82d186f88?source=collection_archive---------2-----------------------#2020-05-09">https://levelup.gitconnected.com/learn-how-to-build-a-token-based-authentication-server-using-spring-boot-and-spring-security-14a82d186f88?source=collection_archive---------2-----------------------#2020-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="27dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嘿伙计们，怎么了？让我们使用Spring Boot和Spring Security构建一个认证服务。在此之前，我写这篇文章的原因是，当我从事Spring Security时，我在理解它的整个架构方面做了很多努力。所以，我想我可以把这个分享给大家。顺便说一下，我不会像标题所说的那样在这里解释整个架构。所以，如果你想了解这个架构，我在这个博客的末尾提供了官方文档链接。进入正题，我们将使用<a class="ae kl" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JWT </a> <strong class="jp ir">，</strong>作为认证令牌来认证我们的客户端，这是一种快速且无状态的方法，但也有其缺点。</p><p id="7510" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，这种类型的身份验证机制将用于微服务架构，在这种架构中，整个应用程序被分解为独立工作的小而独立的模块。当然，它们部署在分布式系统上，服务之间的公共数据将通过按需HTTP请求或使用Apache Kafka之类的消息传递工具共享。好吧，我们开始吧。</p><p id="72fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重要的事情先来。我们将从<a class="ae kl" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"> start.spring.io </a>创建一个项目，并添加项目所需的依赖项列表。除了Spring依赖项，我还将JWT的Java库作为依赖项的一部分。为了简洁起见，我只包含了必需的依赖项。下图捕捉到了这一点。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/8b762d3a9a21d92a796ac6b72328254c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mz4was-mjxMZ2U2auE3Txg.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">build.gradle</figcaption></figure><p id="7480" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为它是一个Spring Boot应用程序，只有一个名为<em class="lc"> @EnableWebSecurity </em>的注释，并且有一个基本的设置，Spring将给出Spring Security的默认配置。尽管我们需要启用它，但我们不想使用默认的。我们将定制配置，使其支持“无状态身份验证”。这将很快变得明显。</p><p id="b022" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为我们的应用程序配置Spring安全性涉及三个主要组件。他们是，</p><ol class=""><li id="fd2a" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk li lj lk ll bi translated">安全配置—保存与身份验证和授权相关的配置</li><li id="7b83" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">身份验证提供者—处理对用户进行身份验证的身份验证部分或逻辑。例如，通过请求中传递的用户名获取用户。如果不成功，抛出相应的<em class="lc">认证异常</em></li><li id="18b7" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">身份验证过滤器—验证令牌并启动身份验证过程</li></ol><p id="9a43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在所有这些之上有一个根组件叫做<em class="lc">AuthenticationManager.java</em>。这是唯一负责做认证的。它识别正确的提供者并调用<em class="lc"> authenticate() </em>方法。Spring Security用一个按特定顺序排列的过滤器列表拦截HTTP请求。记住顺序很重要。这组过滤器一起被称为<em class="lc">过滤器链代理</em>。在<a class="ae kl" href="https://stackoverflow.com/a/41482134/6487148" rel="noopener ugc nofollow" target="_blank">这个</a> StackOverflow链接中有关于Spring安全过滤器的详细解释。现在让我们开始逐一实现它们。</p><p id="9715" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第一步</strong>:创建一个类，用<em class="lc"> @Configuration </em>对其进行注释，称之为<em class="lc">SecurityConfig.java</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lr"><img src="../Images/976355fbaf8c144a4fb8cedfafc169ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wWm4fx1oIm1tJLvoI1v5xg.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">SecurityConfig.java</figcaption></figure><p id="cec5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，我们已经定义了一个公共方法，该方法将创建一个<em class="lc"> SecurityFilterChain </em>的bean。我们很快就会谈到这一点。</p><p id="56f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤2: </strong>创建一个扩展<em class="lc">OncePerRequestFilter.java</em>的类来创建一个servlet过滤器。请记住，这个过滤器应该拦截应用程序中的所有HTTP端点，除了“/<em class="lc">authenticate”</em>和其他公共端点(如果有)，它将作为Spring安全过滤器的一部分包含在我们的配置中</p><p id="5da9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第三步:在进入过滤器之前，我们还需要再创建两个类。</p><ol class=""><li id="598f" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk li lj lk ll bi translated">JwtAuthenticationTokenProvider.java——处理<em class="lc">Authentication.java</em>类型的<em class="lc">AuthenticationProvider.java</em>的实现。这将有两个方法，即<em class="lc"> authenticate() </em>和<em class="lc"> supports() </em>。</li><li id="7903" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">JwtAuthenticationToken.java—Authentication.java<em class="lc">的实现</em>，它持有凭证、委托人和授权机构，并维护身份验证状态。从技术上讲，这个类可以扩展<em class="lc">AbstractAuthenticationToken.java</em>，它是所有认证对象的基类，我们的类也应该是<strong class="jp ir">不可变的</strong>。下图显示了两者的示例图像。</li></ol><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ls"><img src="../Images/766c595c48762fe5b43227188d330044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tFqfxjKtmtJF1VpmJfpLbA.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">JwtAuthenticationToken.java</figcaption></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lt"><img src="../Images/3cfbdba6e253f7adf00870ea2d8cf36f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n9NCE3_-5hS-032C9qwFfg.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">JwtAuthenticationProvider.java</figcaption></figure><p id="f080" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果类参数的类型是<em class="lc">JwtAuthenticationToken.java</em>，则<em class="lc"> supports() </em>方法应该返回true。因为，<em class="lc"> AuthenticationManager </em>将循环提供者列表，我们将在安全配置中给出该列表，以识别正确的提供者来认证该特定请求。它的设计使得您的应用程序可以支持不同类型的身份验证机制，如OAuth2.0或传统的基于用户名和密码的登录等。</p><p id="d0c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们的认证成功，JwtAuthenticationToken 类的一个实例将存储在Spring Security的一个线程本地变量中，如下所示。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lu"><img src="../Images/b492fcaea887325036dd062607b2ba89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TDIakUw_V5t2SZjpIiF3tQ.png"/></div></div></figure><p id="43a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果我们的认证失败了呢？Spring Security如何处理负面场景？嗯，Spring Security filters里有个家伙，叫做ExceptionTranslationFilter.java的<em class="lc">，他负责这个部分。它试图继续过滤器链，如果它捕捉到任何异常，这个过滤器有一个叫做AuthenticationEntrypoint.java</em>的东西，我们在我们的安全配置中配置它。这个切入点是我们开始应对的地方。这里我们得到当前的请求(<em class="lc"> HttpServletRequest </em>)和响应(<em class="lc"> HttpServletResponse </em>)对象，以及在身份验证过程中抛出的相应的<em class="lc">AuthenticationException</em>对象。所以我们使用它们来发送响应，通常带有一个基于抛出的异常的不成功的HTTP状态代码。</p><p id="f5b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在回到我们的过滤器类。我们从HTTP请求中传递的头部获取令牌，并用我们的JWT Java库验证JWT令牌。如果它是一个有效的令牌，我们通过构造<em class="lc"> JwtAuthenticationToken </em>对象并将其放入<em class="lc"> SecurityContextHolder </em>来引导认证过程。同样，我们这样做的原因是身份验证管理器将循环身份验证提供者的列表，并通过调用<em class="lc"> supports() </em>方法来识别正确的提供者。一旦确定了正确的提供者，它将调用该实现的<em class="lc"> authenticate() </em>方法。只有在这里才进行实际的认证，这次我们使用另一个构造函数JwtAuthenticationToken 类，它接受可认证用户的授权。下图显示了我们的过滤器类。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ls"><img src="../Images/4227a7a13fc8ccd4decafa17cdd81f26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mOx4Js6gDQDRx0SFJYAqkQ.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">JwtTokenAuthenticationFilter.java</figcaption></figure><p id="2647" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，我们使用<em class="lc"> JwtParser </em>来解析令牌。我使用了不健康的密钥，不推荐用于生产。这应该是很强烈的东西。最后但同样重要的是，我们需要用上述所有类创建安全配置。我们现在就做吧。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lv"><img src="../Images/9871e9cd8ab5a12a66a0b01dd99ca63a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oGTov9UrR-8OOBMjxUCfVg.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">SecurityConfig.java</figcaption></figure><p id="591b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此创建了两个beans。第一个(<em class="lc">authenticationManager()</em>)通过其<a class="ae kl" href="https://en.wikipedia.org/wiki/Builder_pattern" rel="noopener ugc nofollow" target="_blank"> builder </a>对象向身份验证管理器注册我们的身份验证提供者。后者(<em class="lc"> filterChain() </em>)配置安全部分。这种类型的连续方法调用在Java中被称为“方法链接”。看起来在<em class="lc"> filterChain() </em>方法内部发生了很多调用，对吗？我们来分解一下。</p><ol class=""><li id="2716" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk li lj lk ll bi translated">disable() — HTTP基本和CSRF支持。因为我们正在处理我们的认证系统，我们不想要这些。所以用这个方法来禁用那些</li><li id="a2c1" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">cors()-启用CORS滤波器，它将处理CORS误差</li><li id="baf5" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">无状态会话——我们禁用创建JSESSIONID的基于会话的身份验证来维护身份验证状态</li><li id="bf30" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">addFilter() —正如我前面所说，有一组Spring安全过滤器，其中之一是<em class="lc">UsernamePasswordAuthenticationFilter.java</em>。我们将我们的过滤器放在这个过滤器之前，因为在过滤器集合中，只有认证过程在这个过滤器开始。因此，我们需要在更新<em class="lc"> SecurityContextHolder </em>线程本地对象时，将它放在它之前。</li><li id="7e28" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">authorizeRequests() —通过匹配请求模式来限制对资源的访问。这里只是为了教程，我只提到了一个URI模式。<em class="lc"> permitAll() </em>方法将允许匹配给定模式的路径能够公开访问它。在一个典型的生产应用程序中，可以有许多URI模式来允许或禁止用户。例如，如果有一个API注册了一个逻辑上不需要认证的新用户，那么您可以像<em class="lc">那样允许它。antMatchers("**/register ")。permitAll() </em></li><li id="fdb5" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">。anyRequest()。authenticated() —此应用程序中可用的所有API的其余部分应该受到保护。这意味着只有通过有效身份验证的用户才能访问这些API</li></ol><p id="53a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我想就这样吧。这是非常基本的配置。您可以创建更复杂的配置，如基于角色的身份验证，其中您可以允许某些端点只供具有管理员角色的人访问。在构建自定义身份验证服务器应用程序时，可以参考一些很好的文档。你可以在这里了解更多关于Spring Security <a class="ae kl" href="https://spring.io/guides/topicals/spring-security-architecture" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="760c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谢谢，祝您愉快！</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><div class="kn ko kp kq gt md"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd ir gy z fp mi fr fs mj fu fw ip bi translated">编写面试问题</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">技术开发</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr kw md"/></div></div></a></div></div></div>    
</body>
</html>