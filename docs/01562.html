<html>
<head>
<title>SwiftUI: Create a Custom Gradient Color Picker like Snapchat</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI:创建一个像Snapchat一样的自定义渐变颜色选择器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/swiftui-create-a-custom-gradient-color-picker-like-snapchats-bcf508e69380?source=collection_archive---------5-----------------------#2020-01-13">https://levelup.gitconnected.com/swiftui-create-a-custom-gradient-color-picker-like-snapchats-bcf508e69380?source=collection_archive---------5-----------------------#2020-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b0e6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在SwiftUI中使用DragGesture()构建渐变颜色选择器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f55cfe08e85ca467b792b419de3fcee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IiJf0F0VJo3_vKW-MV_BVg.png"/></div></div></figure><h1 id="5b76" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">以下是我们将在本教程中构建的内容:</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/b4876a1a178c56790a35f3b51e35c036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*8m4uVZ1vK8xqx-4Ms8YZiA.gif"/></div></figure><p id="12ae" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">我们的颜色选择器将允许用户在颜色视图上拖动他们的手指，它将相应地更新我们的主视图的背景颜色。</p><p id="0a39" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">拖动手势将被限制在我们的颜色视图的高度内。</p><h1 id="84e7" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">入门指南</h1><p id="50e3" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">在Xcode中创建新的SwiftUI项目。确定您运行的是macOS Catalina，并且安装了Xcode 11。(允许您使用SwiftUI)</p><p id="2f7c" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">打开Xcode →文件→新建→项目</p><p id="2709" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">我把我的命名为<strong class="lp iu"> ColorPicker </strong>，但是你可以随意命名它。</p><p id="dcfa" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated"><strong class="lp iu">确保用户界面设置为SwiftUI。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/c69d4775d4fc626d66a5c2aafd6f1028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wbrSAqLQH4cdvJ0yOlSvgw.png"/></div></div></figure><h1 id="3d45" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">履行</h1><p id="100c" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">让我们从创建一个新的Swift文件开始。</p><p id="6ba6" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">右键点击你的项目文件夹→新建文件→ Swift文件，命名为<code class="fe mp mq mr ms b">ColorPickerView.swift</code>。</p><p id="c8df" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">添加以下代码来设置我们的SwiftUI视图:</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="3208" class="mx kv it ms b gy my mz l na nb">import SwiftUI</span><span id="8776" class="mx kv it ms b gy nc mz l na nb">struct ColorPickerView: View {<br/>    <br/>    var body: some View {<br/>        ZStack {<br/>            Text("Hello World")<br/>        }<br/>    }<br/>}<br/><br/>struct ColorPickerView_Previews: PreviewProvider {<br/>    static var previews: some View {<br/>        ColorPickerView()<br/>    }<br/>}</span></pre><p id="24ab" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">我们所做的就是设置我们新的SwiftUI视图，使其有资格在画布中进行实时预览。</p><p id="b4ae" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">此时，它应该只是在右边的画布中显示“Hello World”。</p><h1 id="89a8" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">我们如何创建渐变视图？</h1><p id="684d" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">如果是Swift，我们有能力使用一组<code class="fe mp mq mr ms b">Colors</code>，或者<code class="fe mp mq mr ms b">UIColors</code>，如果你正在考虑<code class="fe mp mq mr ms b">UIKit</code>，来创建渐变。当你构建一个<code class="fe mp mq mr ms b">UIColor</code>时，你可以选择使用HSB(色调、饱和度、亮度)。</p><blockquote class="nd ne nf"><p id="21ce" class="ln lo ng lp b lq lr ju ls lt lu jx lv nh lx ly lz ni mb mc md nj mf mg mh mi im bi translated"><em class="it">色相</em>是大多数人联想到<em class="it">色彩</em>这个词的维度。色调是红、绿、蓝等基本颜色名称的区别。在色轮中，色调是围绕色轮的圆周来表示的。因此，它由指定轮子上位置的角度来表示。角度可以从0(红色)到359(也是红色！).在中间你会发现彩虹的“颜色”——红色、橙色、黄色、绿色、蓝色、靛蓝色和紫色。一般来说，颜色的色调是由光的波长决定的。较短的波长通常呈现蓝色，而较长的波长呈现红色。</p></blockquote><p id="cf27" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">以上描述归功于<a class="ae nk" href="https://elvers.us/perception/hsv/" rel="noopener ugc nofollow" target="_blank">https://elvers.us/perception/hsv/</a>。</p><p id="6211" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">利用这些知识，我们可以创建360种颜色用于我们的<code class="fe mp mq mr ms b">GradientView</code>！</p><p id="b363" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">让我们试一试，但首先让我们设置好<code class="fe mp mq mr ms b">LinearGradient</code>。</p><p id="6601" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">在<code class="fe mp mq mr ms b">ColorPickerView.swift</code>中，将这段代码添加到我们的<code class="fe mp mq mr ms b">body</code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="41f7" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">我们有一个<code class="fe mp mq mr ms b">ZStack</code>,允许我们稍后在我们的渐变视图上叠加另一个视图。</p><ol class=""><li id="c26b" class="nn no it lp b lq lr lt lu lw np ma nq me nr mi ns nt nu nv bi translated">从两种颜色开始创建<code class="fe mp mq mr ms b">LinearGradient</code>。</li><li id="2dcb" class="nn no it lp b lq nw lt nx lw ny ma nz me oa mi ns nt nu nv bi translated">我们指定渐变的起点(蓝色)是视图的顶部，终点(粉色)是视图的底部。</li><li id="3701" class="nn no it lp b lq nw lt nx lw ny ma nz me oa mi ns nt nu nv bi translated">我们将自己的<code class="fe mp mq mr ms b">LinearGradient</code>框架设置为宽度10px，高度200px。</li><li id="85e9" class="nn no it lp b lq nw lt nx lw ny ma nz me oa mi ns nt nu nv bi translated">添加一个5px的圆角半径，这将很好地圆化我们的边，因为我们的宽度是10px。</li><li id="1fd0" class="nn no it lp b lq nw lt nx lw ny ma nz me oa mi ns nt nu nv bi translated">添加一个模糊半径为8px的漂亮阴影，这样就不会太突出了。</li><li id="8d63" class="nn no it lp b lq nw lt nx lw ny ma nz me oa mi ns nt nu nv bi translated">最后，通过添加一个白色边框和2px线宽的<code class="fe mp mq mr ms b">RoundedRectangle</code>叠加来添加一个边框。</li></ol><h2 id="59b2" class="mx kv it bd kw ob oc dn la od oe dp le lw of og lg ma oh oi li me oj ok lk ol bi translated">现在，让我们实现所有的颜色</h2><p id="2055" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">我们可以构造一个0 → 360的数组，然后为数组中的每个索引创建一个色调为<code class="fe mp mq mr ms b">index/360.0</code>的<code class="fe mp mq mr ms b">Color</code>，因为色调只接受0到1之间的颜色。</p><p id="b42e" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">在我们的<code class="fe mp mq mr ms b">ColorPickerView,</code>顶部创建一个名为“颜色”的变量</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1a4c" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">这个变量本质上是一个闭包，它将创建我们的<code class="fe mp mq mr ms b">[Color]</code>一次。</p><ol class=""><li id="dd70" class="nn no it lp b lq lr lt lu lw np ma nq me nr mi ns nt nu nv bi translated">我们使用给定范围的数组构造函数创建一个数组。这将自动创建我们的数组为[0，1，2，3，4，… 359]。</li><li id="ae2f" class="nn no it lp b lq nw lt nx lw ny ma nz me oa mi ns nt nu nv bi translated">我们映射数组，对于每次迭代，我们从<code class="fe mp mq mr ms b">UIColor</code>创建一个<code class="fe mp mq mr ms b">Color</code>，只改变每个数组的色调。这将创建0/359、1/359、2/359、3/359 … 359/359。每个值代表一种不同的颜色。</li></ol><p id="e59e" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">在我们的<code class="fe mp mq mr ms b">LinearGradient</code>中，替换</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="6313" class="mx kv it ms b gy my mz l na nb">Gradient(colors: [Color.blue, Color.pink])</span></pre><p id="9312" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">随着</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="f567" class="mx kv it ms b gy my mz l na nb">Gradient(colors: colors)</span></pre><p id="f4e9" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">我们的视图现在应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/17ab5740f1d0fb5c0622fdb5fcad1a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*uXaiam06pfL6ugzXxkrddw.png"/></div></figure><p id="97d1" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">接下来，让我们添加我们的<code class="fe mp mq mr ms b">DragGesture</code>的实现，并将我们选择的颜色传递回我们的父视图，这样他们就可以相应地更新背景视图。</p><p id="2d6b" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">在<code class="fe mp mq mr ms b">ColorPickerView.swift</code>中，将这些变量添加到我们结构的顶部。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="6407" class="mx kv it ms b gy my mz l na nb">@Binding var chosenColor: Color // 1<br/>    <br/>@State private var startLocation: CGFloat = .zero // 2<br/>@State private var dragOffset: CGSize = .zero // 3</span><span id="1d0b" class="mx kv it ms b gy nc mz l na nb">// 4<br/>init(chosenColor: Binding&lt;Color&gt;) {<br/>    self._chosenColor = chosenColor<br/>}</span></pre><ol class=""><li id="7b90" class="nn no it lp b lq lr lt lu lw np ma nq me nr mi ns nt nu nv bi translated">我们创建了一个<code class="fe mp mq mr ms b">Binding&lt;Color&gt;</code>变量(用<code class="fe mp mq mr ms b">@Binding</code>表示),它将允许我们父母更新他们的视图。为此，我们要做的就是在父节点中创建一个<code class="fe mp mq mr ms b">@State</code>变量，然后每当我们更新这个绑定变量时，它就会更新父节点的状态变量。绑定只是在应用程序中传递状态的一种方式。</li><li id="daa3" class="nn no it lp b lq nw lt nx lw ny ma nz me oa mi ns nt nu nv bi translated">我们需要知道手势的起始位置，这样我们就可以用它来计算当前的颜色。用户可以从绿色部分或红色或蓝色部分开始他们的手势，如果不记录在我们的<code class="fe mp mq mr ms b">startLocation</code>中，我们将无法捕捉该值。</li><li id="d599" class="nn no it lp b lq nw lt nx lw ny ma nz me oa mi ns nt nu nv bi translated">我们当前的拖动将通过<code class="fe mp mq mr ms b">dragOffset</code>变量更新。这将是一个起点为0的值，它将根据他们的手指是向下还是向上拖动而变为负值或正值。</li><li id="688d" class="nn no it lp b lq nw lt nx lw ny ma nz me oa mi ns nt nu nv bi translated">创建一个接受绑定变量的<code class="fe mp mq mr ms b">init</code>。</li></ol><p id="6643" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">确保更新文件底部的<code class="fe mp mq mr ms b">PreviewProvider</code>来修复错误:</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="b778" class="mx kv it ms b gy my mz l na nb">ColorPickerView(chosenColor: Binding.constant(Color.white))</span></pre><p id="33d6" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">现在我们已经声明了变量，让我们将手势识别器添加到我们的<code class="fe mp mq mr ms b">LinearGradient</code>中，并更新我们的<code class="fe mp mq mr ms b">ContentView</code>。我们之前提到的那个<code class="fe mp mq mr ms b">chosenColor</code>斯威夫特。</p><p id="d59e" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">还是在<code class="fe mp mq mr ms b">ColorPickerView.swift</code>中，添加以下代码作为我们<code class="fe mp mq mr ms b">LinearGradient</code>的另一个视图修饰符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><ol class=""><li id="4322" class="nn no it lp b lq lr lt lu lw np ma nq me nr mi ns nt nu nv bi translated">使用我们的<code class="fe mp mq mr ms b">normalizeGesture</code>函数，我们可以计算出我们当前的颜色。我们可以用我们的<code class="fe mp mq mr ms b">ColorPicker</code>的高度得到一个0到200之间的值，然后除以200得到一个0到1之间的值。这允许我们创建一个值在0和1之间的<code class="fe mp mq mr ms b">UIColor</code>。这对应于我们手指当前所在位置的确切颜色。</li><li id="7dfa" class="nn no it lp b lq nw lt nx lw ny ma nz me oa mi ns nt nu nv bi translated">我们的函数使用我们的开始位置和我们当前拖动手指的距离。这将给我们一个足够好的估计来得到我们的手指在我们的视野中的位置。例如，如果我们在中心开始拖动，我们的<code class="fe mp mq mr ms b">dragOffset.height</code>将是0，但是我们的开始位置将是100。然后，我们可以说我们距离视图顶部100像素。</li><li id="813c" class="nn no it lp b lq nw lt nx lw ny ma nz me oa mi ns nt nu nv bi translated">通过<code class="fe mp mq mr ms b">.onChanged()</code>增加<code class="fe mp mq mr ms b">DragGesture() </code>识别器，当数值不断变化时，更新<code class="fe mp mq mr ms b">dragOffset</code>、<code class="fe mp mq mr ms b">startLocation</code>和<code class="fe mp mq mr ms b">chosenColor</code>。</li></ol><p id="0e79" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">在这一点上，我们没有对我们的视图做任何更改，如果我们构建并运行，肯定不会发生任何事情。但是现在让我们来解决这个问题。</p><p id="8adf" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">接下来，打开<code class="fe mp mq mr ms b">ContentView.swift</code>添加添加以下更改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><ol class=""><li id="8419" class="nn no it lp b lq lr lt lu lw np ma nq me nr mi ns nt nu nv bi translated">正如所承诺的，我们有我们当前的颜色作为状态。</li><li id="ebd1" class="nn no it lp b lq nw lt nx lw ny ma nz me oa mi ns nt nu nv bi translated">使<code class="fe mp mq mr ms b">ZStack</code>。<code class="fe mp mq mr ms b">topTrailing</code>所以我们的视野一直在右上角</li><li id="6d72" class="nn no it lp b lq nw lt nx lw ny ma nz me oa mi ns nt nu nv bi translated">我们可以渲染我们当前的颜色，因为在引擎盖下<code class="fe mp mq mr ms b">Color</code>实际上只是一个<code class="fe mp mq mr ms b">View</code>。</li><li id="ee28" class="nn no it lp b lq nw lt nx lw ny ma nz me oa mi ns nt nu nv bi translated">使用绑定符号$将我们的状态添加到<code class="fe mp mq mr ms b">ColorPickerView</code>的构造函数中，同时指定一个帧和偏移量。</li></ol><p id="e4c9" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">我们现在应该有这样的东西。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/91c857579189afac6fd1f1194902ba92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*S7tsulbRdbhLd8FUk_pp6A.gif"/></div></figure><p id="bbc1" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">在我们的滑块上添加圆形视图，并在变化时制作动画。</p><p id="8e1d" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">打开备份<code class="fe mp mq mr ms b">ColorPickerView.swift</code>，让我们添加另一个<code class="fe mp mq mr ms b">View</code>到我们的<code class="fe mp mq mr ms b">ZStack</code>，这一次在滑块视图的顶部。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><ol class=""><li id="3031" class="nn no it lp b lq lr lt lu lw np ma nq me nr mi ns nt nu nv bi translated">添加另一个状态变量来跟踪用户当前是否在拖动手指。我们将用它来制作我们正在添加的新<code class="fe mp mq mr ms b">Color View </code>的动画。</li><li id="d91a" class="nn no it lp b lq nw lt nx lw ny ma nz me oa mi ns nt nu nv bi translated">创建一个名为圆形宽度的变量。这将是一个计算变量，意味着每次调用它时，这个计算都会再次运行。所以，当用户拖动时，圆的宽度将是3px，否则静止时是15px。</li><li id="3a17" class="nn no it lp b lq nw lt nx lw ny ma nz me oa mi ns nt nu nv bi translated">为<code class="fe mp mq mr ms b">ZStack</code>添加对齐为<code class="fe mp mq mr ms b">.top</code>，这确保了圆在渐变滑块的顶部(在我看来在那里看起来最好)。</li><li id="b94d" class="nn no it lp b lq nw lt nx lw ny ma nz me oa mi ns nt nu nv bi translated">确保将<code class="fe mp mq mr ms b">isDragging</code>添加到我们的拖动手势处理程序的<code class="fe mp mq mr ms b">.onChanged</code>中，</li><li id="d8e4" class="nn no it lp b lq nw lt nx lw ny ma nz me oa mi ns nt nu nv bi translated">确保当用户不再在<code class="fe mp mq mr ms b">.onEnded </code>处理程序中拖动变量时，我们更新我们的变量。</li><li id="882f" class="nn no it lp b lq nw lt nx lw ny ma nz me oa mi ns nt nu nv bi translated">在这里，我们创建我们的<code class="fe mp mq mr ms b">Circle</code>,我们的前景色等于我们当前的颜色。<br/> —我们还将我们的框架设置为基于变量，该变量将根据我们是否拖动而变大或变小。<br/> —添加一个阴影和一个有边框的覆盖图，就像我们做<code class="fe mp mq mr ms b">GradientView</code> <br/>一样——拖动时偏移我们的圆，使它出现在视图的左侧并变大。<br/> —将我们的动画速度更新为比默认速度更快。</li></ol><h1 id="623c" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">就是这样！</h1><p id="bd88" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">这是我们的成品</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/b4876a1a178c56790a35f3b51e35c036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*8m4uVZ1vK8xqx-4Ms8YZiA.gif"/></div></figure><p id="ff94" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">查看GitHub上的完整源代码</p><div class="on oo gp gr op oq"><a href="https://github.com/bbaars/SwiftUI-Gradient-ColorPicker" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">bbaars/swift ui-渐变-颜色选择器</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">github.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe ks oq"/></div></div></a></div></div></div>    
</body>
</html>