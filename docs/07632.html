<html>
<head>
<title>Micro-Frontends at Scale (part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大规模微前端(第二部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/micro-frontends-at-scale-part-2-d10994f09f18?source=collection_archive---------2-----------------------#2021-03-02">https://levelup.gitconnected.com/micro-frontends-at-scale-part-2-d10994f09f18?source=collection_archive---------2-----------------------#2021-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2915" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何通过模块联合利用微前端</h2></div><p id="abfd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">继<a class="ae le" href="https://medium.com/xgeeks/micro-frontends-at-scale-part-1-a8ab67bfb773" rel="noopener">系列的第一篇文章</a>详细描述了架构选择之后，这一篇文章将重点关注使用<strong class="kk iu">模块联合</strong>实现基于<strong class="kk iu">微前端</strong> (MFEs)的架构。到本文结束时，我们将已经创建并讨论了一个开源解决方案，它保持了客户对<strong class="kk iu">单页应用</strong>的UX感觉，同时让独立团队开发不同的产品。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/76e9d48e942e76497004272e0a282568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZvnQrUq8Ur_Q_bPb"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@danist07?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">贝莉儿 DANIST</a> on <a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="cabc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">概述👀</h1><p id="4e3c" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我们要模拟的业务是一个服装市场。它有你通常能在电子商务商店里找到的东西:物品清单、物品细节、结帐和博客(博客不是很常见，但它符合主题)。</p><p id="bbb8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们服装店的样子:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ms"><img src="../Images/920bf46ff79c2ea929ecd138cccb4316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8BqSyQ12HI3Td6MfKLPzoA.png"/></div></div></figure><p id="3264" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将跟随<a class="ae le" href="https://github.com/comoser/clothes-store-micro-frontends" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>和一些gists，所以我们有代表实现步骤的小代码片段。</p><p id="e27d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该项目没有配置CI/CD，也没有部署到任何地方。我们将在本系列的另一篇文章中讨论部署和所需的更改。</p><p id="476e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们可以在本地运行解决方案，包括在<code class="fe mt mu mv mw b">development</code>和<code class="fe mt mu mv mw b">production</code>环境中。</p><p id="4b60" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该项目也没有适当的状态管理解决方案。这将在以后的文章中讨论。</p><h2 id="ffeb" class="mx lw it bd lx my mz dn mb na nb dp mf kr nc nd mh kv ne nf mj kz ng nh ml ni bi translated">体系结构</h2><p id="efd9" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">该解决方案的架构选择和讨论在本系列的第一篇文章中有介绍，所以请务必查看。总之，这是我们在本文中要实现的图表:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nj"><img src="../Images/32a031d777c559f049109b97b7aa0cfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wmffR3b3dTCqH8IF38vv9w.jpeg"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">应用架构</figcaption></figure><p id="95aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果这张图带来了任何疑问或问题，请阅读系列文章的<a class="ae le" href="https://medium.com/xgeeks/micro-frontends-at-scale-part-1-a8ab67bfb773" rel="noopener">第一篇文章，其中深入讨论了解决方案的架构细节。</a></p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="469c" class="lv lw it bd lx ly nr ma mb mc ns me mf jz nt ka mh kc nu kd mj kf nv kg ml mm bi translated">履行💡</h1><h2 id="032c" class="mx lw it bd lx my mz dn mb na nb dp mf kr nc nd mh kv ne nf mj kz ng nh ml ni bi translated">初始设置</h2><p id="0967" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在根文件夹中，我们有我们的主<code class="fe mt mu mv mw b">package.json</code>文件，它将负责运行我们的编排命令并保存<code class="fe mt mu mv mw b">yarn workspaces</code>的配置。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">根级别package.json</figcaption></figure><p id="5130" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基本上，我们告诉yarn，我们的工作空间将是文件夹<code class="fe mt mu mv mw b">products</code>中的所有文件夹，在本例中是:</p><ul class=""><li id="2202" class="ny nz it kk b kl km ko kp kr oa kv ob kz oc ld od oe of og bi translated"><code class="fe mt mu mv mw b">app_shell</code></li><li id="132c" class="ny nz it kk b kl oh ko oi kr oj kv ok kz ol ld od oe of og bi translated"><code class="fe mt mu mv mw b">items</code></li><li id="43e1" class="ny nz it kk b kl oh ko oi kr oj kv ok kz ol ld od oe of og bi translated"><code class="fe mt mu mv mw b">checkout</code></li><li id="97ca" class="ny nz it kk b kl oh ko oi kr oj kv ok kz ol ld od oe of og bi translated"><code class="fe mt mu mv mw b">shared</code></li><li id="ffce" class="ny nz it kk b kl oh ko oi kr oj kv ok kz ol ld od oe of og bi translated"><code class="fe mt mu mv mw b">blog</code></li></ul><blockquote class="om on oo"><p id="988d" class="ki kj op kk b kl km ju kn ko kp jx kq oq ks kt ku or kw kx ky os la lb lc ld im bi translated"><strong class="kk iu">注意</strong> : yarn工作空间将要求您在根级别package.json上拥有一个<code class="fe mt mu mv mw b">private: true</code>属性，以便正确管理不同的MFEs依赖项。</p></blockquote><p id="d1e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> Pro提示:</strong> <em class="op"> yarn工作空间</em>将尝试将mfe的依赖项提升到根依赖项(如果可能的话)。这适用于大多数npm包，但也有不适用的情况。在这些情况下，你可以明确地告诉yarn不要提升它们，例如:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="335d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，<code class="fe mt mu mv mw b"><a class="ae le" href="https://www.npmjs.com/package/full-icu" rel="noopener ugc nofollow" target="_blank">full-icu</a></code> npm包将保留在每个MFE <code class="fe mt mu mv mw b">node_modules</code>文件夹中。</p><p id="5da2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还利用了<code class="fe mt mu mv mw b"><a class="ae le" href="https://www.npmjs.com/package/concurrently" rel="noopener ugc nofollow" target="_blank">concurrently</a></code>和<code class="fe mt mu mv mw b"><a class="ae le" href="https://www.npmjs.com/package/wsrun" rel="noopener ugc nofollow" target="_blank">wsrun</a></code>包，这样我们可以并行运行我们的mfe。在开发时，<code class="fe mt mu mv mw b">start:live</code>脚本将是goto命令，为了在生产中测试解决方案，<code class="fe mt mu mv mw b">build:serve:all</code>将是我们的选择。</p><p id="3716" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，在每个MFE根文件夹中，我们将有一个带有命令的<code class="fe mt mu mv mw b">package.json</code>，这些命令将响应根级别<code class="fe mt mu mv mw b">package.json</code>中的命令。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">产品/app_shell/package.json</figcaption></figure><p id="94ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，为每个MFE定义的端口是不同的，从<code class="fe mt mu mv mw b">3000</code>开始，到<code class="fe mt mu mv mw b">3004</code>结束。您可以在各自的<code class="fe mt mu mv mw b">webpack.config.js</code>文件中找到这些用于<strong class="kk iu">开发</strong>目的的端口，并在各自的<code class="fe mt mu mv mw b">serve</code>命令中找到这些用于<strong class="kk iu">生产</strong>的端口。</p><p id="eab3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在已经介绍了初始设置，让我们检查不同的MFE配置。</p><h2 id="7ce0" class="mx lw it bd lx my mz dn mb na nb dp mf kr nc nd mh kv ne nf mj kz ng nh ml ni bi translated">应用程序外壳MFE</h2><p id="5fd2" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">每个MFE的webpack配置文件都有一个包含名为<code class="fe mt mu mv mw b"><a class="ae le" href="https://webpack.js.org/concepts/module-federation/" rel="noopener ugc nofollow" target="_blank">ModuleFederationPlugin</a></code>的插件的部分。这是让我们利用这个新的<strong class="kk iu"> webpack </strong>特性的配置。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">app_shell的webpack.config.js</figcaption></figure><p id="2958" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从<code class="fe mt mu mv mw b">line 3</code>开始，<code class="fe mt mu mv mw b">name</code>属性是联邦模块的惟一标识符(在我们的上下文中，联邦模块总是MFE)。当另一个MFE需要引用这个MFE时，它需要指定这个唯一的<code class="fe mt mu mv mw b">name</code>。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">第4至9行</figcaption></figure><p id="e117" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码片段(关于webpack.config.js)中，定义了<code class="fe mt mu mv mw b">remotes</code>属性。这个属性决定当前MFE需要什么MFE。当前MFE需要的所有依赖项将在运行时<strong class="kk iu">从定义的远程设备</strong>导入。在这种情况下，就像“架构”一节中的架构图一样，我们可以验证<strong class="kk iu">应用程序外壳</strong>正在从<strong class="kk iu">项目</strong>、<strong class="kk iu">结账</strong>、<strong class="kk iu">共享</strong>和<strong class="kk iu">博客</strong>导入代码。</p><blockquote class="om on oo"><p id="3122" class="ki kj op kk b kl km ju kn ko kp jx kq oq ks kt ku or kw kx ky os la lb lc ld im bi translated"><strong class="kk iu">注意</strong>:如果我们以第5行的例子为例，remotes对象中的<strong class="kk iu">键</strong>在这个MFE中是对遥控器的引用。那个键的字符串<strong class="kk iu">值</strong>将启用与另一个MFE的连接。</p><p id="aa1a" class="ki kj op kk b kl km ju kn ko kp jx kq oq ks kt ku or kw kx ky os la lb lc ld im bi translated">在这种情况下，“@”前的“项目”是该MFE的<code class="fe mt mu mv mw b">name</code>属性。“@”后面的URL与MFE部署的位置相匹配。</p></blockquote><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="b9bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，定义了<code class="fe mt mu mv mw b">shared</code>属性。这种配置非常重要，如果配置不当，会导致很多问题。让我们来探讨一下这个话题。</p><h2 id="dd99" class="mx lw it bd lx my mz dn mb na nb dp mf kr nc nd mh kv ne nf mj kz ng nh ml ni bi translated">共享模块联合属性</h2><p id="cf0b" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">gist中给出的配置包含一些有趣的选项。</p><p id="dbf0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mt mu mv mw b">...deps</code>对象扩展提取<code class="fe mt mu mv mw b">package.json</code>中的所有<code class="fe mt mu mv mw b">dependencies</code>，这将自动共享其中定义的所有库。这样做是为了更好地管理依赖性。</p><p id="8fef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Webpack将能够验证应用程序是否已经有了依赖项，如果有，它将不会再次加载它。这些验证在<strong class="kk iu">运行时</strong>导入代码时发生。注意依赖关系的<strong class="kk iu">版本</strong>，因为如果不匹配，webpack会加载两个版本。</p><p id="84c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">需要注意的还有<code class="fe mt mu mv mw b">singleton</code>属性定义。每当依赖项具有内部状态时，都会使用它。因为，例如，React和React-dom有内部状态，通过将它们定义为singletons，我们告诉webpack我们永远不想加载这种依赖的两个版本。</p><p id="5121" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该共享对象配置在解决方案的每个MFE中都是相同的。根据不同的项目，这个对象可能会有很大的不同，所以总是要努力微调<code class="fe mt mu mv mw b">shared</code>属性。</p><h2 id="14f4" class="mx lw it bd lx my mz dn mb na nb dp mf kr nc nd mh kv ne nf mj kz ng nh ml ni bi translated">MFE项目</h2><p id="fabd" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在此MFE中，模块联合配置发生了一些变化。它具有两个App Shell MFE中没有的新属性。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">项目的webpack.config.js</figcaption></figure><p id="776b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mt mu mv mw b">filename</code>定义了作为其他mfe的<strong class="kk iu">清单</strong>的文件名。它包含描述公开代码位置的信息和一些其他配置。当一个MFE公开代码供其他MFE使用时，<code class="fe mt mu mv mw b">filename</code>属性是强制的。</p><p id="c3ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mt mu mv mw b">exposes</code>键定义了当前MFE公开的组件或通用代码。可以被webpack解析的一切也可以在模块联邦中公开(原语、函数、对象、react组件等)。</p><h2 id="49cc" class="mx lw it bd lx my mz dn mb na nb dp mf kr nc nd mh kv ne nf mj kz ng nh ml ni bi translated">远程导入</h2><p id="1555" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在运行时导入MFE的主要机制是导入该MFE的路由。这允许应用外壳充当平台的单一入口点，并从其他mfe动态导入用户需要的内容。也有这样的情况，需要一个来自远程的组件并直接导入，而不是使用路由。收银台就是一个例子。它公开了它的路线，同时也公开了一个<code class="fe mt mu mv mw b">CheckoutCart</code>，允许应用程序外壳中的<code class="fe mt mu mv mw b">navbar</code>有一个小的结帐组件。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ot"><img src="../Images/5ad8465c98e4a0f04e3cce8ea4ad3427.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*uU2Zw6i4dNtY9sjmKrUlBA.png"/></div></div></figure><p id="0546" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种单一入口点模式使应用程序对我们的客户来说就像一个常规的SPA，因为当用户导航到属于特定MFE(例如，项目)的路由时，它会在运行时异步加载这些路由。在提取它们时，它会显示一条正在加载的消息。加载后，它们被webpack缓存。从这一点开始，这些路线下的用户交互(例如/项目)由远程导入的MFE处理。</p><p id="3e99" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的代码片段中，我们可以看到如何在运行时安全地导入react组件。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">app_shell/src/App.jsx</figcaption></figure><p id="901c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，我们正在分析App Shell MFE的<code class="fe mt mu mv mw b">App.jsx</code>文件，安全导入路线需要两件主要事情:</p><ul class=""><li id="ee49" class="ny nz it kk b kl km ko kp kr oa kv ob kz oc ld od oe of og bi translated">用React.lazy导入组件</li><li id="f927" class="ny nz it kk b kl oh ko oi kr oj kv ok kz ol ld od oe of og bi translated">用React包装组件调用。焦虑</li></ul><p id="3ea6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这两个东西都是来自<a class="ae le" href="https://reactjs.org/docs/concurrent-mode-suspense.html" rel="noopener ugc nofollow" target="_blank">React suspension API</a>的组件。</p><p id="790d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">远程组件的导入按如下方式完成:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="45c2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了调用这些组件，我们使用<code class="fe mt mu mv mw b">AsyncLoader</code>。这是一个简单地将<code class="fe mt mu mv mw b">children</code>包装在<code class="fe mt mu mv mw b">React.Suspense</code>和<code class="fe mt mu mv mw b">ErrorBoundary</code>组件中的组件。通过使用它，我们保证在组件仍在导入时有一个后备，并且在加载代码时触发的任何错误都将被错误边界捕获，从而允许应用程序保持正常工作，尽管存在任何严重的javascript错误。</p><p id="ea29" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mt mu mv mw b">AsyncLoader</code>如下:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="23c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这当然更适合生产应用程序。当失败时，我们希望显示一个好看的页面，为我们的客户提供一些有用的信息。我们可能希望将这个错误记录到Sentry或任何类似的工具中。这是做这件事的最佳地点。</p><p id="17c0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们简单地使用<code class="fe mt mu mv mw b">AsyncLoader</code>来呈现我们的MFE特定路线:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="1b60" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，MFE路由的远程导入位于带有每个MFE的URL的库<code class="fe mt mu mv mw b">Route</code>中(例如/items)。通过这样做，我们确保了只有当用户真正需要时，才导入与MFE相关的内容。</p><h2 id="6c4f" class="mx lw it bd lx my mz dn mb na nb dp mf kr nc nd mh kv ne nf mj kz ng nh ml ni bi translated">独立模式</h2><p id="9307" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">出于开发目的，能够独立运行MFE是非常重要的。它减少了启动应用程序的时间，并在进行小的调整时总体上改善了开发体验。当然，在开发的某个阶段，您必须在所有mfe运行的情况下运行整个编排，以测试集成(这些测试应该是手动和自动的)。</p><p id="eee0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了实现这一点，我们的MFE基本上有两个入口点:</p><ul class=""><li id="8ebd" class="ny nz it kk b kl km ko kp kr oa kv ob kz oc ld od oe of og bi translated"><code class="fe mt mu mv mw b">App.jsx</code>将成为独立应用程序的入口点(正常的react应用程序入口点)</li><li id="5a26" class="ny nz it kk b kl oh ko oi kr oj kv ok kz ol ld od oe of og bi translated"><code class="fe mt mu mv mw b">routes.js</code>将是MFE在整个流程编排中运行时的入口点</li></ul><p id="0fb0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mt mu mv mw b">routes.js</code>组件拥有与MFE完全一样的路由。对于MFE项目:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">items/src/components/routes/index . js</figcaption></figure><p id="c53a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于作为独立入口点的<code class="fe mt mu mv mw b">App.jsx</code>,有一个额外的步骤:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="1879" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于在App Shell MFE中，我们为每个MFE都设置了一个基本路由，因此在独立模式下运行时，也更容易设置这个基本路由。这将允许我们直接重用<code class="fe mt mu mv mw b">routes.js</code>组件。</p><p id="f41e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过这种设置，您现在可以独立运行解决方案中的任何MFE。</p><h1 id="b10a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结果呢🌆</h1><p id="899e" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">最终结果可以在<a class="ae le" href="https://github.com/comoser/clothes-store-micro-frontends" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>中查看👈。</p><p id="d658" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了预览服装店并进行测试，您可以在<code class="fe mt mu mv mw b">package.json</code>下使用几个命令:</p><ul class=""><li id="98a1" class="ny nz it kk b kl km ko kp kr oa kv ob kz oc ld od oe of og bi translated"><code class="fe mt mu mv mw b">start:live</code>这将在<strong class="kk iu">开发</strong>模式下启动所有mfe，并开启热重装</li><li id="e161" class="ny nz it kk b kl oh ko oi kr oj kv ok kz ol ld od oe of og bi translated"><code class="fe mt mu mv mw b">build:serve:all</code>将在<strong class="kk iu">生产</strong>模式下构建所有mfe，并与<code class="fe mt mu mv mw b"><a class="ae le" href="https://www.npmjs.com/package/serve" rel="noopener ugc nofollow" target="_blank">serve</a></code> npm包一起提供服务</li></ul><p id="2e37" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想自动打开每个MFE各自的浏览器标签，那么您也可以在<code class="fe mt mu mv mw b">start:live</code>脚本中添加<code class="fe mt mu mv mw b">--open</code>参数。</p><h1 id="f50e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">⚠️常见错误</h1><h2 id="ea35" class="mx lw it bd lx my mz dn mb na nb dp mf kr nc nd mh kv ne nf mj kz ng nh ml ni bi translated">模块”。容器中不存在/Routes</h2><p id="e8f9" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在这种情况下，您很可能弄错了exposes语法:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h2 id="69d0" class="mx lw it bd lx my mz dn mb na nb dp mf kr nc nd mh kv ne nf mj kz ng nh ml ni bi translated">未捕获的类型错误:fn不是函数</h2><p id="4888" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">发生此错误的原因有几个:</p><ul class=""><li id="dc5d" class="ny nz it kk b kl km ko kp kr oa kv ob kz oc ld od oe of og bi translated">您忘了提及remotes reference中条目<code class="fe mt mu mv mw b">filename</code>的名称:</li></ul><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><ul class=""><li id="ce70" class="ny nz it kk b kl km ko kp kr oa kv ob kz oc ld od oe of og bi translated">在更改<code class="fe mt mu mv mw b">chunks</code>的webpack配置时，我也遇到了这个错误。默认情况下，这种配置通常是您所需要的一切，所以如果您出于某种原因更改了它，请仔细检查是否是这个原因。</li><li id="972d" class="ny nz it kk b kl oh ko oi kr oj kv ok kz ol ld od oe of og bi translated">也可能是为远程MFE定义的url是错误的。</li></ul><h2 id="a6e1" class="mx lw it bd lx my mz dn mb na nb dp mf kr nc nd mh kv ne nf mj kz ng nh ml ni bi translated">找不到模块:错误:无法解析“…/button”中的“shared/Button”</h2><p id="b8e6" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">基本上，配置中MFE的密钥引用与导入语句中使用的密钥不同:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h2 id="51a1" class="mx lw it bd lx my mz dn mb na nb dp mf kr nc nd mh kv ne nf mj kz ng nh ml ni bi translated">意外的标记“</h2><p id="6355" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">发生此错误的原因有很多，并且通常最难调试:</p><ul class=""><li id="1c2a" class="ny nz it kk b kl km ko kp kr oa kv ob kz oc ld od oe of og bi translated"><code class="fe mt mu mv mw b">output.publicPath</code>未配置到MFE或<code class="fe mt mu mv mw b">auto</code>的URL。模块联合需要这些定义良好的值来正确导入代码。</li><li id="2a60" class="ny nz it kk b kl oh ko oi kr oj kv ok kz ol ld od oe of og bi translated"><code class="fe mt mu mv mw b">output.chunkFilename</code>被覆盖，这可能会导致模块联合出现问题。</li><li id="12a4" class="ny nz it kk b kl oh ko oi kr oj kv ok kz ol ld od oe of og bi translated">加载了库的多个版本(例如React或react-router-dom ),这可能会导致不稳定的行为(请参考共享对象配置)。</li></ul><h1 id="55d4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="fef6" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">到目前为止，我希望您已经很好地掌握了webpacks的模块联合特性，并且发现服装店项目是您下一个企业项目的良好起点，或者只是改进现有项目。</p><p id="ee57" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这只是一个开始，有了这个代码库，就有可能扩展更多的主题，如mfe之间的通信、数据存储等等。我将在以后更多地讨论这些话题。</p><p id="bc4f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">模块联盟仍然是最近才出现的，它的创建者定义了一些建议和伪标准，但是定义真正可靠的标准还为时过早。这里的内容可能很快就会过时，但我会尽量让回购与webpack的最新变化保持同步。</p><p id="0bed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望你喜欢！👐请在下面留下你的评论来激起讨论！</p><p id="e174" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你觉得这篇文章很有趣，请分享出来，因为你知道——分享就是关爱！</p><p id="8ed4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你喜欢在具有全球影响力的大规模项目中工作，如果你喜欢真正的挑战，请随时通过 <a class="ae le" href="https://xgeeks.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> xgeeks </strong> </a> <strong class="kk iu">联系我们！我们正在壮大我们的团队，你可能是下一个</strong> <a class="ae le" href="https://grnh.se/3f6ef9fa2us" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">加入这个人才群体的人</strong> </a> <strong class="kk iu">😉</strong></p></div></div>    
</body>
</html>