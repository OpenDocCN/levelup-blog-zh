<html>
<head>
<title>The complexity of Java comparators, and the simplicity of Scala sort by</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java比较器的复杂性和Scala排序的简单性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-complexity-of-java-comparators-and-the-simplicity-of-scala-sort-by-f34f44d4b759?source=collection_archive---------13-----------------------#2020-01-27">https://levelup.gitconnected.com/the-complexity-of-java-comparators-and-the-simplicity-of-scala-sort-by-f34f44d4b759?source=collection_archive---------13-----------------------#2020-01-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0a514ead6f6c5d48f10b2e8a5f49c113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P32KRbjQjFn_fdpk"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">本·汉森在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="3371" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据可用的标准对一组对象进行排序是如此常见的操作，以至于我们认为这是理所当然的。</p><p id="7a3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，当您在网上购物时，您可能会运行一个查询来显示几页的产品。</p><p id="6c3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你希望网站能给你一些不同的排序方式，比如按价格、按平均星级、按销售排名等等。在后面，员工可以访问更多的排序选项，比如按库存单位(SKU)、最后订购日期等。</p><p id="6d27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于Java和Scala来说，这可能不像是一个现实的例子，因为这种前端排序通常是由JavaScript处理的。</p><p id="2f2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我确实认为理解这个例子的容易性超过了它明显的不现实性，所以我会继续下去。</p><p id="5ec2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了用Java实现它，我们可能会创建一个名为<code class="fe lb lc ld le b">Item</code>或<code class="fe lb lc ld le b">Product</code>之类的抽象类。我们不太关心派生类，只要超类拥有我们可能想要用作排序标准的所有字段。</p><p id="c20a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的系统上，我的确把<code class="fe lb lc ld le b">Item</code>抽象化了，把“具体”的子类做成<code class="fe lb lc ld le b">PetSuppliesItem</code>、<code class="fe lb lc ld le b">ElectronicsItem</code>和<code class="fe lb lc ld le b">MiscellaneousItem</code>。你可以选择不做所有的事情，仍然很容易地跟着做。</p><p id="3647" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要一个字段来保存项目的价格。实际上，在真实的用例中，我们可能需要几个价格字段:批发价、学生折扣价、老年人折扣价、特价等。</p><p id="236d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们暂时忘记这些，假装每件商品只有一个价格让我们担心。让我们假设每个SKU只对应一个UPC(现实生活中经常是这样，但不总是这样)。</p><p id="d795" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用浮点数表示一笔钱通常不是一个好主意。但至少我们可以很容易地比较浮点数。</p><p id="a542" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了一些深奥的注意事项(比如<a class="ae kc" href="https://medium.com/engineering-housing/nan-is-not-equal-to-nan-771321379694" rel="noopener">关于NaN </a>的注意事项)，我们通常可以发现一个浮点数是小于、等于还是大于另一个浮点数。</p><p id="ae3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用整数类型将金额表示为美分(例如，$1等于100)。比用浮点数好，但不如用专门为钱设计的类。</p><p id="410f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">整数原语不能比浮点原语携带更多关于货币的信息。一个数字原语可能代表，比如说，12.25，但是12.25是什么？美元？欧元？瑞士法郎？一些其他的货币？</p><p id="7c9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于标准Java开发工具包(JDK)不包含货币类，我们应该自己创建或者使用第三方库中的货币类。如果你自己做，确保它实现了<code class="fe lb lc ld le b">Comparable&lt;T&gt;</code>接口。第三方库应该已经解决了这个问题。</p><p id="f1b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，如果我们在一个标准的Java集合中有一堆money amount对象，我们可以使用<code class="fe lb lc ld le b">Collections.sort()</code>以升序对它们进行排序(例如，$5.29，$10.28，$255.73，$499.89，等等。)或降序排列。</p><p id="cbc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以使用我的<code class="fe lb lc ld le b">CurrencyAmount</code>类(<a class="ae kc" href="https://github.com/Alonso-del-Arte/toy-examples/blob/master/src/currency/CurrencyAmount.java" rel="noopener ugc nofollow" target="_blank">从GitHub </a>下载并带入项目)。它没有Joda Money的所有特性，但是它有我们在这个练习中需要的所有特性。</p><p id="02b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们将<code class="fe lb lc ld le b">CurrencyAmount</code>写成一个实现了<code class="fe lb lc ld le b">Ordered[CurrencyAmount]</code>特征的Scala类，我们将能够写出这样的东西</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="e316" class="ln lo iq le b gy lp lq l lr ls">    if (shoppingCartSubTotal &gt;= MINIMUM_FOR_FREE_SHIPPING) {<br/>      chargeShippingTo(store)<br/>    }</span></pre><p id="409c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是由于<code class="fe lb lc ld le b">CurrencyAmount</code>是一个实现<code class="fe lb lc ld le b">Comparable&lt;CurrencyAmount&gt;</code>接口的Java类，我们不得不使用<code class="fe lb lc ld le b">compareTo()</code>函数，将免费送货的例子变成类似于</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="0b27" class="ln lo iq le b gy lp lq l lr ls">    if (shoppingCartSubTotal.compareTo(MINIMUM_FOR_FREE_SHIPPING)<br/>                            &gt;= 0) {<br/>        chargeShippingTo(store);<br/>    }</span></pre><p id="6ff5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">compareTo()</code>函数是<code class="fe lb lc ld le b">Comparable&lt;T&gt;</code>接口要求我们实现的唯一东西。</p><p id="b37a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其工作方式是，如果<code class="fe lb lc ld le b">a</code>小于<code class="fe lb lc ld le b">b</code>，则<code class="fe lb lc ld le b">a.compareTo(b)</code>返回一个负整数(最好是1)，如果<code class="fe lb lc ld le b">a</code>等于<code class="fe lb lc ld le b">b</code>，则返回0，如果<code class="fe lb lc ld le b">a</code>大于<code class="fe lb lc ld le b">b</code>，则返回一个正整数(最好是1)。</p><p id="1979" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果对你来说这似乎比它需要的更复杂，你会更不喜欢我们在Java中按字段进行比较的做法。</p><p id="3567" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于这个例子来说，平均星级和销售排名可能只是数字原语。但是在现实生活的用例中，为这两个字段拥有对象可能是有益的。然后你还需要让他们实现<code class="fe lb lc ld le b">Comparable&lt;T&gt;</code>。</p><p id="8e9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的<code class="fe lb lc ld le b">Item</code>类可能还包括一个向最终用户显示产品图像的字段。但是这对于我们这里的排序无关紧要。也没有用于在收据上打印可选注释的字段。</p><p id="490c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的<code class="fe lb lc ld le b">Item</code>类是否像money amount对象一样<em class="lt">而不是</em>具有“自然排序”。例如，一袋狗粮可能比一个狗粮碗重，但是狗粮碗可能更贵。</p><p id="208c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以很明显我们不应该让<code class="fe lb lc ld le b">Item</code>实施<code class="fe lb lc ld le b">Comparable&lt;Item&gt;</code>。这充其量是一种误导。</p><p id="68ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果我们有办法使用<code class="fe lb lc ld le b">Collections.sort()</code>根据一个字段，比如价格或星级，对一组<code class="fe lb lc ld le b">Item</code>对象进行升序或降序排序，那就更好了。</p><p id="719e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一种方法，但是有点复杂。不过，在此之前，我们需要一些虚构的物品来玩玩。这些项目可能会以某种方式一起出现在搜索结果中。也可能不是。</p><ul class=""><li id="e87e" class="lu lv iq kf b kg kh kk kl ko lw ks lx kw ly la lz ma mb mc bi translated">大型犬的食物碗，18.99美元，★★★☆(准确的说是4.2)基于403次确认购买。宠物用品排名第20，整体排名第528。SKU: 67890，刚果爱国者联盟:0 12345 67890 5</li><li id="8754" class="lu lv iq kf b kg md kk me ko mf ks mg kw mh la lz ma mb mc bi translated">通用品牌电池，4节AA，3.49美元，★★★☆☆基于20次确认购买。电子学排名第348，综合排名第1043。SKU: AA447，刚果爱国者联盟:0 99999 01234 7</li><li id="1c5e" class="lu lv iq kf b kg md kk me ko mf ks mg kw mh la lz ma mb mc bi translated">猫粮，5磅。包，4.98美元，★★★☆基于22次确认购买。宠物用品排名第22，整体排名第548。SKU: 67895，刚果爱国者联盟:0 12345 67895 0</li><li id="f3b0" class="lu lv iq kf b kg md kk me ko mf ks mg kw mh la lz ma mb mc bi translated">狗粮，5磅。包，6.98美元，★★★★基于13次确认购买。宠物用品排名第19，整体排名第503。SKU: 67889，刚果爱国者联盟:0 12345 67889 9</li><li id="d2ca" class="lu lv iq kf b kg md kk me ko mf ks mg kw mh la lz ma mb mc bi translated">免费样品，购买任何其他项目免费。总体排名第一。SKU: 99999，刚果爱国者联盟:0 12345 99999 4</li><li id="48c2" class="lu lv iq kf b kg md kk me ko mf ks mg kw mh la lz ma mb mc bi translated">宠物食品碗，$10.99，★★★☆☆ (3.1)基于943次确认购买。宠物用品排名第43，整体排名第880。SKU: 67878，刚果爱国者联盟:0 12345 67878 3</li><li id="36f4" class="lu lv iq kf b kg md kk me ko mf ks mg kw mh la lz ma mb mc bi translated">名牌电池，4节AA，5.49美元，★★★☆☆ (3.2)基于1，210次确认购买。电子学排名第199，综合排名第789。SKU: AA403，刚果爱国者联盟:0 55555 00020 3</li></ul><p id="3236" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你所看到的，这些项目是乱序的几乎任何标准，我们可能振振有词地使用。所以让我们把这些放到<code class="fe lb lc ld le b">Item</code>对象中，看看如何对它们进行排序。</p><p id="1d75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的做法是让NetBeans在测试包中创建一个<code class="fe lb lc ld le b">ItemTest</code>类。我将虚构的项目声明为package private，并在<code class="fe lb lc ld le b">ItemTest.setUpClass()</code>中初始化它们(这样做的原因将在后面说明)。</p><p id="bdd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，在源码包中，我将声明一个实现<code class="fe lb lc ld le b">Comparator&lt;Item&gt;</code>接口的<code class="fe lb lc ld le b">PriceComparator</code>类。尽管标识符相似，但这与<code class="fe lb lc ld le b">Comparable&lt;Item&gt;</code>有很大不同。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="5042" class="ln lo iq le b gy lp lq l lr ls">package retail.items;</span><span id="8d76" class="ln lo iq le b gy mi lq l lr ls">import java.util.Comparator;</span><span id="9b8b" class="ln lo iq le b gy mi lq l lr ls">public class <strong class="le ir">PriceComparator implements Comparator&lt;Item&gt;</strong> {</span><span id="0ff4" class="ln lo iq le b gy mi lq l lr ls">}</span></pre><p id="99aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你的IDE应该在类声明下面画一条红色曲线，因为这不会覆盖任何需要覆盖的东西。我告诉NetBeans去处理它。这个对话框出现了:</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/cc04c174be68800be8d7e3eb62d3e662.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*iVQBap_VTNgbmVOjRZkqBQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">NetBeans生成实现方法对话框</figcaption></figure><p id="5d28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Eclipse和IntelliJ应该有类似的东西。第一次看到这个的时候很迷茫。只选择了<code class="fe lb lc ld le b">compare()</code>，没有选择<code class="fe lb lc ld le b">reversed()</code>和<code class="fe lb lc ld le b">thenComparing()</code>功能。为什么不呢？</p><p id="1525" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我忘记了，从Java 8开始，接口可以包含“具体方法”这使得Java接口更像Scala特征，模糊了接口和抽象类之间的界限。</p><p id="4195" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，让我们继续，单击“Generate”按钮，不要选中或取消选中任何内容。NetBeans生成一个抛出<code class="fe lb lc ld le b">UnsupportedOperationException</code>的<code class="fe lb lc ld le b">compare()</code>覆盖。用<code class="fe lb lc ld le b">return 0</code>替换抛绳。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="7444" class="ln lo iq le b gy lp lq l lr ls">    @Override<br/>    public int compare(Item itemA, Item itemB) {<br/>        <strong class="le ir">return 0;</strong><br/>    }</span></pre><p id="6faf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不喜欢标识符<code class="fe lb lc ld le b">o1</code>和<code class="fe lb lc ld le b">o2</code>，所以我用<code class="fe lb lc ld le b">itemA</code>和<code class="fe lb lc ld le b">itemB</code>替换了它们，IntelliJ会警告我们它们没有被使用(很快就会被使用)。</p><p id="8245" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这应该无法通过我们在<code class="fe lb lc ld le b">PriceComparatorTest</code>(测试包中)的第一次测试。确保将<code class="fe lb lc ld le b">ArrayList&lt;E&gt;</code>和<code class="fe lb lc ld le b">Collections</code>导入到测试类中。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="e446" class="ln lo iq le b gy lp lq l lr ls">package retail.items;</span><span id="1bc2" class="ln lo iq le b gy mi lq l lr ls"><strong class="le ir">import java.util.ArrayList;<br/>import java.util.Collections;</strong></span><span id="a7da" class="ln lo iq le b gy mi lq l lr ls">import org.junit.Test;<br/>import static org.junit.Assert.*;</span><span id="a3dc" class="ln lo iq le b gy mi lq l lr ls">public class PriceComparatorTest {<br/>    <br/>    <strong class="le ir">private static final PriceComparator COMPARATOR = new<br/>                                                  PriceComparator();</strong><br/>    <br/>    public PriceComparatorTest() {<br/>        <strong class="le ir">ItemTest.setUpClass();</strong><br/>    }<br/>    <br/>    /**<br/>     * Test of compare method, of class PriceComparator.<br/>     */<br/>    @Test<br/>    public void testCompareThruCollectionSort() {<br/>        <strong class="le ir">ArrayList&lt;Item&gt; unsorted = new ArrayList&lt;&gt;();</strong><br/>        unsorted.add(ItemTest.LARGE_DOGS_FOOD_BOWL); // $18.99<br/>        unsorted.add(ItemTest.GENERIC_AA_BATTERIES_4PK); // $3.49<br/>        unsorted.add(ItemTest.CAT_FOOD); // $4.98<br/>        unsorted.add(ItemTest.DOG_FOOD); // $6.98<br/>        unsorted.add(ItemTest.FREE_SAMPLE); // $0.00<br/>        unsorted.add(ItemTest.PET_FOOD_BOWL); // $10.99<br/>        unsorted.add(ItemTest.NAME_BRAND_BATTERIES_AA_4PK); // $5.49<br/>        <strong class="le ir">ArrayList&lt;Item&gt; expected = new ArrayList&lt;&gt;();</strong><br/>        expected.add(ItemTest.FREE_SAMPLE);                 // $0.00<br/>        expected.add(ItemTest.GENERIC_AA_BATTERIES_4PK);    // $3.49<br/>        expected.add(ItemTest.CAT_FOOD);                    // $4.98<br/>        expected.add(ItemTest.NAME_BRAND_BATTERIES_AA_4PK); // $5.49<br/>        expected.add(ItemTest.DOG_FOOD);                    // $6.98<br/>        expected.add(ItemTest.PET_FOOD_BOWL);              // $10.99<br/>        expected.add(ItemTest.LARGE_DOGS_FOOD_BOWL);       // $18.99<br/>        <strong class="le ir">ArrayList&lt;Item&gt; actual = new ArrayList&lt;&gt;(unsorted);<br/>        Collections.sort(actual, COMPARATOR);<br/>        assertEquals(expected, actual);</strong><br/>    }<br/>    <br/>}</span></pre><p id="72fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试的第一次运行应该会失败，让我们放心，一旦我们让价格比较器正常工作，测试就会通过。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="5194" class="ln lo iq le b gy lp lq l lr ls">Testcase: testCompareThruCollectionSort(retail.items.PriceComparatorTest): FAILED<br/><strong class="le ir">expected:</strong>&lt;[Free sample, Generic brand batteries 4-pack AA, Cat food 5-lb. bag, Name brand batteries 4-pack AA, Dog food 5-lb. bag, Pet food bowl, Food bowl for large dogs]&gt; <strong class="le ir">but was:</strong>&lt;[Food bowl for large dogs, Generic brand batteries 4-pack AA, Cat food 5-lb. bag, Dog food 5-lb. bag, Free sample, Pet food bowl, Name brand batteries 4-pack AA]&gt;<br/>... at retail.items.PriceComparatorTest.testCompareThruCollectionSort(PriceComparatorTest.java:55)</span></pre><p id="abe7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe lb lc ld le b">PriceComparator</code>中的<code class="fe lb lc ld le b">compare()</code>改写为:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="ff06" class="ln lo iq le b gy lp lq l lr ls">    @Override<br/>    public int compare(Item itemA, Item itemB) {<br/>        return <strong class="le ir">itemA.getPrice().compareTo(itemB.getPrice())</strong>;<br/>    }</span></pre><p id="000b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试现在应该通过了。</p><p id="6ac0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果我们想按价格对商品进行排序，但是是降序的，该怎么办呢？我们不需要写一个新的比较器。还记得<code class="fe lb lc ld le b">reversed()</code>是我们可以覆盖的“方法”之一吗？也许在这里会有用。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="9c4c" class="ln lo iq le b gy lp lq l lr ls">    @Test<br/>    public void testCompareDescendingOrder() {<br/>        ArrayList&lt;Item&gt; unsorted = new ArrayList&lt;&gt;();<br/>        unsorted.add( ...same as the previous one...<br/>        ArrayList&lt;Item&gt; <strong class="le ir">expected</strong> = new ArrayList&lt;&gt;();<br/>        expected.add(ItemTest.LARGE_DOGS_FOOD_BOWL);       // $18.99<br/>        expected.add(ItemTest.PET_FOOD_BOWL);              // $10.99<br/>        expected.add(ItemTest.DOG_FOOD);                    // $6.98<br/>        expected.add(ItemTest.NAME_BRAND_BATTERIES_AA_4PK); // $5.49<br/>        expected.add(ItemTest.CAT_FOOD);                    // $4.98<br/>        expected.add(ItemTest.GENERIC_AA_BATTERIES_4PK);    // $3.49<br/>        expected.add(ItemTest.FREE_SAMPLE);                 // $0.00<br/>        ArrayList&lt;Item&gt; actual = new ArrayList&lt;&gt;(unsorted);<br/>        Collections.sort(actual, <strong class="le ir">COMPARATOR.reversed()</strong>);<br/>        assertEquals(expected, actual);<br/>    }</span></pre><p id="f0c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，为了确保我们的测试工作正常，请在<code class="fe lb lc ld le b">compare()</code>中恢复<code class="fe lb lc ld le b">return 0</code>。两个测试都应该失败。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="c193" class="ln lo iq le b gy lp lq l lr ls">Testcase: testCompareDescendingOrder(retail.items.PriceComparatorTest): FAILED<br/><strong class="le ir">expected:</strong>&lt;[Food bowl for large dogs, Pet food bowl, Dog food 5-lb. bag, Name brand batteries 4-pack AA, Cat food 5-lb. bag, Generic brand batteries 4-pack AA, Free sample]&gt; <strong class="le ir">but was:</strong>&lt;[Food bowl for large dogs, Generic brand batteries 4-pack AA, Cat food 5-lb. bag, Dog food 5-lb. bag, Free sample, Pet food bowl, Name brand batteries 4-pack AA]&gt;<br/>... at retail.items.PriceComparatorTest.testCompareDescendingOrder(PriceComparatorTest.java:83)</span></pre><p id="70cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">恢复正确的价格比较，两个测试都应该通过。</p><p id="ebfb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们确实需要一个全新的比较器来比较平均星级。姑且称之为<code class="fe lb lc ld le b">StarRatingComparator</code>。我们也只重写<code class="fe lb lc ld le b">compare()</code>，用一个只返回0的存根，这样第一次测试就失败了。</p><p id="8993" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们对<code class="fe lb lc ld le b">StarRatingComparator</code>的测试非常相似。我们将再次使用<code class="fe lb lc ld le b">ItemTest</code>中的物品，而不是想出一套全新的虚拟物品，或者重复之前的虚拟物品。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="fdff" class="ln lo iq le b gy lp lq l lr ls">package retail.items;</span><span id="404f" class="ln lo iq le b gy mi lq l lr ls">import java.util.ArrayList;<br/>import java.util.Collections;</span><span id="21c7" class="ln lo iq le b gy mi lq l lr ls">import org.junit.BeforeClass;<br/>import org.junit.Test;<br/>import static org.junit.Assert.*;</span><span id="bd75" class="ln lo iq le b gy mi lq l lr ls">public class StarRatingComparatorTest {<br/>    <br/>    <strong class="le ir">private static final StarRatingComparator COMPARATOR = new<br/>                                             StarRatingComparator();</strong><br/>    <br/>    @BeforeClass<br/>    public static void setUpClass() {<br/>        ItemTest.setUpClass();<br/>    }<br/>    <br/>    @Test<br/>    public void testCompareThruCollectionSort() {<br/>        <strong class="le ir">ArrayList&lt;Item&gt; unsorted = new ArrayList&lt;&gt;();</strong><br/>        unsorted.add(ItemTest.LARGE_DOGS_FOOD_BOWL); // 4.2<br/>        unsorted.add(ItemTest.GENERIC_AA_BATTERIES_4PK); // 3.0<br/>        unsorted.add(ItemTest.CAT_FOOD); // 4.0<br/>        unsorted.add(ItemTest.DOG_FOOD); // 5.0<br/>        unsorted.add(ItemTest.PET_FOOD_BOWL); // 3.1<br/>        unsorted.add(ItemTest.NAME_BRAND_BATTERIES_AA_4PK); // 3.2<br/>        <strong class="le ir">ArrayList&lt;Item&gt; expected = new ArrayList&lt;&gt;();</strong><br/>        expected.add(ItemTest.GENERIC_AA_BATTERIES_4PK);      // 3.0<br/>        expected.add(ItemTest.PET_FOOD_BOWL);                 // 3.1<br/>        expected.add(ItemTest.NAME_BRAND_BATTERIES_AA_4PK);   // 3.2<br/>        expected.add(ItemTest.CAT_FOOD);                      // 4.0<br/>        expected.add(ItemTest.LARGE_DOGS_FOOD_BOWL);          // 4.2<br/>        expected.add(ItemTest.DOG_FOOD);                      // 5.0<br/>        <strong class="le ir">ArrayList&lt;Item&gt; actual = new ArrayList&lt;&gt;(unsorted);<br/>        Collections.sort(actual, COMPARATOR);<br/>        assertEquals(expected, actual);</strong><br/>    }<br/>    <br/>}</span></pre><p id="402f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为这里星级是作为数字原语实现的，所以我们可以在<code class="fe lb lc ld le b">StarRatingComparator</code>的<code class="fe lb lc ld le b">compare()</code>函数中使用大于和小于运算符。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="d083" class="ln lo iq le b gy lp lq l lr ls">    @Override<br/>    public int compare(Item itemA, Item itemB) {<br/>        if (itemA.getAverageStarRating() &lt;<br/>                                     itemB.getAverageStarRating()) {<br/>            return -1;<br/>        }<br/>        if (itemA.getAverageStarRating() &gt;<br/>                                     itemB.getAverageStarRating()) {<br/>            return 1;<br/>        }<br/>        return 0;<br/>    }</span></pre><p id="5e0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这通过了测试。然而，使用适当的原始包装器中的静态<code class="fe lb lc ld le b">compare()</code>函数会更有效。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="73d1" class="ln lo iq le b gy lp lq l lr ls">    @Override<br/>    public int compare(Item itemA, Item itemB) {<br/>        return Double.compare(itemA.getAverageStarRating(),<br/>                              itemB.getAverageStarRating());<br/>    }</span></pre><p id="e5dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想先按一个标准排序，然后再按另一个标准排序，该怎么办？例如，假设您想按价格升序排序，然后按平均星级降序排序。</p><p id="5848" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于上面的示例项目，我想避免在我们用作排序标准的任何字段中有任何项目相等。如果两个项目在一个字段中相等，我们使用另一个字段的比较器对它们进行排序，那么这些项目可能会保持相同的顺序。</p><p id="9bf6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，假设三个项目具有相同的价格，但是原始列表中的第一个被评为三星，第二个被评为五星，第三个被评为两星。</p><p id="afc2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，在应用价格比较排序后，这三个项目将一起结束，但按照以下星级顺序:三星，五星，两星。很明显他们没有按星级排序。</p><p id="de47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我们可能需要一个按价格排序的比较器，但是当商品价格相同时，它们会按星级或我们希望的任何其他标准进一步排序。</p><p id="472b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们当然可以从头开始创建一个全新的比较器，但是使用<code class="fe lb lc ld le b">thenComparing()</code>可能更有意义。这样，如果我们拥有所需的所有单字段比较器，就可以通过组合两个相关的单字段比较器来创建任何双字段比较器。</p><p id="1a9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是在我们尝试之前，我们还需要一些虚拟物品。这些额外的虚构物品应该至少在一个标准上与我们现有的虚构物品相匹配。</p><ul class=""><li id="6238" class="lu lv iq kf b kg kh kk kl ko lw ks lx kw ly la lz ma mb mc bi translated">狗锁骨魅力，10.99美元(与宠物食品碗价格相同)，★★★☆(高于宠物食品碗)基于803次确认购买。SKU: 67870，刚果爱国者联盟:0 12345 67870 7</li><li id="35cd" class="lu lv iq kf b kg md kk me ko mf ks mg kw mh la lz ma mb mc bi translated">512MB盘，10.99美元(与宠物食品碗价格相同)，★★☆☆(低于宠物食品碗)基于20次确认购买。SKU: FD527，刚果爱国者联盟:0 99999 00512 7</li><li id="b268" class="lu lv iq kf b kg md kk me ko mf ks mg kw mh la lz ma mb mc bi translated">以狗为主题的扑克扑克牌，$6.98(与那袋狗粮价格相同)，★★★☆(低于那袋狗粮)基于5次确认购买。SKU: P0052，刚果爱国者联盟:0 99999 00052 8</li></ul><p id="ae99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lb lc ld le b">ItemTest</code>中，我将把这些放在一个非常窄的范围内。然后，我们的<code class="fe lb lc ld le b">unsorted</code>和<code class="fe lb lc ld le b">expected</code>数组列表非常类似于价格比较器测试中的列表，但是增加了一些关键的内容:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="73b2" class="ln lo iq le b gy lp lq l lr ls">        ArrayList&lt;Item&gt; unsorted = new ArrayList&lt;&gt;();<br/>        unsorted.add(LARGE_DOGS_FOOD_BOWL); // $18.99<br/>        <strong class="le ir">unsorted.add(usbDrive); // $10.99, 2 stars</strong><br/>        unsorted.add(GENERIC_AA_BATTERIES_4PK); // $3.49<br/>        unsorted.add(CAT_FOOD); // $4.98<br/>        <strong class="le ir">unsorted.add(boneCharm); // $10.99, 4 stars</strong><br/>        unsorted.add(DOG_FOOD); // $6.98, 5 stars<br/>        unsorted.add(FREE_SAMPLE); // $0.00<br/>        <strong class="le ir">unsorted.add(dogPokerCards); // $6.98, 4 stars</strong><br/>        unsorted.add(PET_FOOD_BOWL); // $10.99, 3.1 stars<br/>        unsorted.add(NAME_BRAND_BATTERIES_AA_4PK); // $5.49<br/>        ArrayList&lt;Item&gt; expected = new ArrayList&lt;&gt;();<br/>        expected.add(FREE_SAMPLE);                 // $0.00<br/>        expected.add(GENERIC_AA_BATTERIES_4PK);    // $3.49<br/>        expected.add(CAT_FOOD);                    // $4.98<br/>        expected.add(NAME_BRAND_BATTERIES_AA_4PK); // $5.49<br/>        expected.add(DOG_FOOD);                  // $6.98, 5 stars<br/>        <strong class="le ir">expected.add(dogPokerCards);             // $6.98, 4 stars<br/>        expected.add(boneCharm);                // $10.99, 4 stars</strong><br/>        expected.add(PET_FOOD_BOWL);            // $10.99, 3.1 stars<br/>        <strong class="le ir">expected.add(usbDrive);                 // $10.99, 2 stars</strong><br/>        expected.add(LARGE_DOGS_FOOD_BOWL); // $18.99<br/>        ArrayList&lt;Item&gt; actual = new ArrayList&lt;&gt;(unsorted);</span></pre><p id="cd0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们需要设置比较器。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="2fea" class="ln lo iq le b gy lp lq l lr ls">        Comparator comp = (new PriceComparator()).<strong class="le ir">thenComparing</strong>((new<br/>                                StarRatingComparator()).reversed());</span></pre><p id="3aaf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后是实际的排序，接着是断言项目如我们预期的那样排序。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="aac5" class="ln lo iq le b gy lp lq l lr ls">        Collections.sort(actual, comp);<br/>        assertEquals(expected, actual);</span></pre><p id="fb68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这比从头开始编写两个场比较器要好。但我仍然无法摆脱这样的感觉，这不是最好的解决方案。</p><p id="3112" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">仅使用我们目前拥有的两个单字段比较器，结合<code class="fe lb lc ld le b">reversed()</code>和<code class="fe lb lc ld le b">thenComparing()</code>功能，我们就可以创建四个不同的双字段比较器。</p><p id="e4ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有另一个单场比较器，那么组成比较器的可能性就更多了。但是这些可能性中只有一部分有实用价值。</p><p id="c7f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这仍然给我们留下一个问题，要创建双场比较器，我们必须为任何可能要使用的场提供一个单场比较器。</p><p id="46dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们想按批发价格升序排序，然后按最近的订购日期排序，我们将需要一个批发价格的单字段比较器和另一个订购日期的比较器。</p><p id="9c10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可能希望用于排序的另一个标准是根据最终用户的搜索项的相关性。</p><p id="175d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果用户搜索“狗食碗”，那么，根据目前呈现的虚构项目，大狗的食物碗应该是顶部结果，具有100%的相关性，狗食袋和宠物食物碗应该各具有80%的相关性。</p><p id="b19c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许狗锁骨符咒和以狗为主题的扑克扑克牌应该只有40%或30%的相关性。猫粮可能有20%的相关性，假设“狗”比“食物”给出更多的相关性权重，因为它首先出现在搜索词中。</p><p id="974e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">电池和USB驱动器的相关性应该为0%，甚至不会出现在“狗粮碗”的搜索结果中</p><p id="0a48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们将在<code class="fe lb lc ld le b">Item</code>中放入一个<code class="fe lb lc ld le b">relevance()</code>函数，该函数接受一个<code class="fe lb lc ld le b">String searchTerm</code>参数并返回某种数字相关性评级，比如一个百分比，或者一个介于0.0和1.0之间的数字，1.0表示非常相关，0.0表示不相关。</p><p id="88fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在现实生活的用例中，我们必须弄清楚如何让<code class="fe lb lc ld le b">relevance()</code>给任何给定的<code class="fe lb lc ld le b">searchTerm</code>一个合适的结果。不过，在这里，我们只是通过一个setter硬编码必要的相关性值，我们不会在实际零售应用的程序中使用它。</p><p id="d5a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论哪种方式，我们的相关性比较器都需要某种方式来知道搜索项是什么。也许通过构造函数？</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="2b4c" class="ln lo iq le b gy lp lq l lr ls">package retail.items;</span><span id="ba82" class="ln lo iq le b gy mi lq l lr ls">import java.util.Comparator;</span><span id="891c" class="ln lo iq le b gy mi lq l lr ls">public class RelevanceComparator implements Comparator&lt;Item&gt; {<br/>    <br/>    <strong class="le ir">private final String searchTerm;</strong></span><span id="fc18" class="ln lo iq le b gy mi lq l lr ls">    @Override<br/>    public int compare(Item itemA, Item itemB) {<br/>        return 0; // FAIL THE FIRST TEST<br/>    }<br/>    <br/>    <strong class="le ir">public RelevanceComparator(String term) {<br/>        this.searchTerm = term;<br/>    }</strong><br/>    <br/>}</span></pre><p id="5e9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让这种比较器成为不可变的似乎有些浪费，但我们谈论的是计算机中的一个抽象概念，而不是一个必须制造并可能产生碳足迹的实际物理项目。</p><p id="6e31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有些人可能更喜欢让搜索词成为可以通过getter/setter对访问的可变字段。然后，在使用相关性比较器之前，您必须确保搜索词setter被调用。</p><p id="d533" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时<code class="fe lb lc ld le b">RelevanceComparatorTest</code>应该很容易编写。尽管我建议把免费样品、u盘和电池放在外面。</p><p id="14c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第一次测试失败后，我们修改<code class="fe lb lc ld le b">compare()</code>如下:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="d26e" class="ln lo iq le b gy lp lq l lr ls">    @Override<br/>    public int compare(Item itemA, Item itemB) {<br/>        return Double.compare(itemA.relevance(this.searchTerm),<br/>                              itemB.relevance(this.searchTerm));<br/>    }</span></pre><p id="c9db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试应该会通过。很简单，对吧？现在，对您可能想要用作排序标准的所有其他字段执行此操作。为了编写非常相似的比较器和比较器测试，做好复制和粘贴的苦差事。</p><p id="2f48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一定有更好的方法。本质上，我们用<code class="fe lb lc ld le b">Comparator</code>所做的是将一个函数包装在一个对象中，这样我们就可以传递这个函数。也许如果我们使用像Scala这样的函数式编程语言，我们可以直接传递函数，而不需要将它们包装在对象中。</p><p id="e5b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然可以在NetBeans中编写、编译和运行Scala程序，但是设置起来很困难，我还没有做到。使用IntelliJ，下载和安装Scala for IntelliJ插件是一件简单的事情。所以在本文的剩余部分，我将使用IntelliJ。</p><p id="2a9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦将<code class="fe lb lc ld le b">CurrencyAmount</code>定义为实现<code class="fe lb lc ld le b">Ordered[CurrencyAmount]</code>特征的Scala类，并且将<code class="fe lb lc ld le b">Item</code>类定义为我们虚构项目的所有适当实例，我们<em class="lt">就可以</em>编写基于<code class="fe lb lc ld le b">java.util.Comparator</code>接口的比较器。但是我们实际上不需要。</p><p id="6125" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也不需要使用<code class="fe lb lc ld le b">java.util.ArrayList</code>或<code class="fe lb lc ld le b">java.util.Collections</code>。Scala确实有可变集合，但是不可变集合使用起来更加简单和直观，我们通常不需要显式地导入任何东西来使用它们。</p><p id="04c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们将在<code class="fe lb lc ld le b">ItemTest</code>中按照不同的标准进行分类测试。我们将把虚构的项目放在测试包中的一个<code class="fe lb lc ld le b">FictItems</code>对象中(IntelliJ不使用这个术语)。</p><p id="6f47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还决定不在Scala版本的<code class="fe lb lc ld le b">Item</code>中使用Java getter/setter语义。这意味着，例如，要改变一个商品的价格，我们不需要调用<code class="fe lb lc ld le b">getPrice()</code>，我们只需访问<code class="fe lb lc ld le b">price</code>字段并相应地设置它。</p><p id="17b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您当然可以将<code class="fe lb lc ld le b">price</code>视为一个带有隐含括号的无参数方法。这样想不会有任何问题，因为在Scala中，需要的时候就可以这样。</p><p id="dbb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">SKU字段应该标记为final(在Scala中，这意味着用<code class="fe lb lc ld le b">val</code>声明它)。任何需要更改的字段都应该用<code class="fe lb lc ld le b">var</code>声明。</p><p id="2a87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些虚构的条目将用与本练习的Java版本中相同的属性来定义，并放入不可变的列表中。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="82e1" class="ln lo iq le b gy lp lq l lr ls">  @Test def testSortByPrice(): Unit = {<br/>    val <strong class="le ir">unsorted</strong> = List(FictItems.LARGE_DOGS_FOOD_BOWL,<br/>      FictItems.GENERIC_AA_BATTERIES_4PK,<br/>      FictItems.CAT_FOOD,<br/>      FictItems.DOG_FOOD,<br/>      FictItems.FREE_SAMPLE,<br/>      FictItems.PET_FOOD_BOWL,<br/>      FictItems.NAME_BRAND_BATTERIES_AA_4PK)<br/>    val <strong class="le ir">expected</strong> = List(FictItems.FREE_SAMPLE,<br/>      FictItems.GENERIC_AA_BATTERIES_4PK,<br/>      FictItems.CAT_FOOD,<br/>      FictItems.NAME_BRAND_BATTERIES_AA_4PK,<br/>      FictItems.DOG_FOOD,<br/>      FictItems.PET_FOOD_BOWL,<br/>      FictItems.LARGE_DOGS_FOOD_BOWL)<br/>    val actual = <strong class="le ir">unsorted.sortBy(_.price)</strong><br/>    assertEquals(expected, actual)<br/>  }</span></pre><p id="36c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原来<code class="fe lb lc ld le b">scala.collection.immutable.List</code>实际上是一个抽象类。我们不需要担心这些<code class="fe lb lc ld le b">List[Item]</code>实例的实际运行时类，因为无论它是什么，我们都能够在它上面使用<code class="fe lb lc ld le b">sortBy()</code>。</p><p id="141c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样。在IntelliJ: backspace中尝试删除“<code class="fe lb lc ld le b">.price</code>”，再次键入点，您将看到您可以选择任何可访问的可比较字段(或者“有序的”，使用Scala术语)。</p><p id="56f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实际上，IntelliJ会让你选择不可比较的字段，如果你试图运行它，它会传递一个来自Scala编译器的错误。例如，尝试使用product image字段(类型为<code class="fe lb lc ld le b">java.awt.Image</code>)将会给出错误“没有为java.awt.Image定义隐式排序”和“没有足够的参数用于方法sortBy”</p><p id="fc9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，嘿，我更喜欢犯这种错误，而不是为我想排序的每个字段编写一个全新的比较器。</p><p id="04d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要按降序排序，我们可以只使用<code class="fe lb lc ld le b">sortBy</code>按升序排序，然后反转列表。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="afad" class="ln lo iq le b gy lp lq l lr ls">  @Test def testSortByPriceDescending(): Unit = {<br/>  val <strong class="le ir">unsorted</strong> = List(...same as the previous one...)<br/>  val <strong class="le ir">expected</strong> = List(FictItems.LARGE_DOGS_FOOD_BOWL,<br/>    FictItems.PET_FOOD_BOWL,<br/>    FictItems.DOG_FOOD,<br/>    FictItems.NAME_BRAND_BATTERIES_AA_4PK,<br/>    FictItems.CAT_FOOD,<br/>    FictItems.GENERIC_AA_BATTERIES_4PK,<br/>    FictItems.FREE_SAMPLE)<br/>  val actual = <strong class="le ir">unsorted.sortBy(_.price).reverse</strong><br/>  assertEquals(expected, actual)<br/>}</span></pre><p id="90c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">理解我们传递给<code class="fe lb lc ld le b">sortBy()</code>的是一个函数是很重要的。函数可以带参数。例如:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="a694" class="ln lo iq le b gy lp lq l lr ls">  @Test def testSortByRelevanceDescending(): Unit = {<br/>    val <strong class="le ir">unsorted</strong> = List(FictItems.LARGE_DOGS_FOOD_BOWL,<br/>      FictItems.CAT_FOOD,<br/>      FictItems.DOG_FOOD,<br/>      FictItems.PET_FOOD_BOWL)<br/>    val <strong class="le ir">expected</strong> = List(FictItems.LARGE_DOGS_FOOD_BOWL,<br/>      FictItems.DOG_FOOD,<br/>      FictItems.PET_FOOD_BOWL,<br/>      FictItems.CAT_FOOD)<br/>    val actual = <strong class="le ir">unsorted.sortBy(_.relevance("dog food<br/>                                                     bowl")).reverse</strong><br/>    assertEquals(expected, actual)<br/>  }</span></pre><p id="c184" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，函数可以与其他函数“组合”。也许以后我会想出一个更实际的例子，所以现在我会满足于这个不太可能的例子，希望根据产品的UPC校验位对产品进行排序。</p><p id="dd49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们必须用模函数来构造UPC函数。大概是这样:<code class="fe lb lc ld le b">unsorted.sortBy(_.upc % 10)</code>。</p><p id="b4a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在需要按UPC校验位(如果有的话)排序之前，您可能需要按两个通用标准排序，如普通价格和星级。</p><p id="b3b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Scala中至少有两种不同的方法来按照两个标准进行排序。我认为最简单的方法是用<code class="fe lb lc ld le b">sortBy()</code>简单地通过管道进行排序。</p><p id="65db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，要先按价格升序排序，然后按星级降序排序，我们需要采取以下步骤:</p><ol class=""><li id="f925" class="lu lv iq kf b kg kh kk kl ko lw ks lx kw ly la mk ma mb mc bi translated">按星级将项目按升序排序</li><li id="f138" class="lu lv iq kf b kg md kk me ko mf ks mg kw mh la mk ma mb mc bi translated">反转列表，使他们按星级降序排列</li><li id="de1d" class="lu lv iq kf b kg md kk me ko mf ks mg kw mh la mk ma mb mc bi translated">按价格升序对项目进行排序</li></ol><p id="5f55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这应该行得通。还记得之前关于价格相同但星级不同的三种商品的假设吗，它们会因为价格相同而结束，但根据星级相对于彼此保持相同的排序。</p><p id="9b3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">的确<a class="ae kc" href="https://www.scala-lang.org/api/current/scala/collection/immutable/List.html" rel="noopener ugc nofollow" target="_blank"/><code class="fe lb lc ld le b"><a class="ae kc" href="https://www.scala-lang.org/api/current/scala/collection/immutable/List.html" rel="noopener ugc nofollow" target="_blank">List</a></code>的Scala文档支持这个假设:</p><blockquote class="ml mm mn"><p id="6fdd" class="kd ke lt kf b kg kh ki kj kk kl km kn mo kp kq kr mp kt ku kv mq kx ky kz la ij bi translated">排序是稳定的。也就是说，相等的元素(由<code class="fe lb lc ld le b">ord.compare</code>决定)以与原始元素相同的顺序出现在排序后的序列中。</p></blockquote><p id="16ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们编写一个测试，确保它如我们预期的那样工作。我将使用我在Java <code class="fe lb lc ld le b">thenComparing()</code>示例中使用的相同的额外虚构项目。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="a753" class="ln lo iq le b gy lp lq l lr ls">    val <strong class="le ir">unsorted</strong> = List(FictItems.LARGE_DOGS_FOOD_BOWL,<br/>      usbDrive,<br/>      FictItems.GENERIC_AA_BATTERIES_4PK,<br/>      FictItems.CAT_FOOD,<br/>      boneCharm,<br/>      FictItems.DOG_FOOD,<br/>      FictItems.FREE_SAMPLE,<br/>      dogPokerCards,<br/>      FictItems.PET_FOOD_BOWL,<br/>      FictItems.NAME_BRAND_BATTERIES_AA_4PK)<br/>    val <strong class="le ir">expected</strong> = List(FictItems.FREE_SAMPLE,<br/>      FictItems.GENERIC_AA_BATTERIES_4PK,<br/>      FictItems.CAT_FOOD,<br/>      FictItems.NAME_BRAND_BATTERIES_AA_4PK,<br/>      FictItems.DOG_FOOD,<br/>      dogPokerCards,<br/>      boneCharm,<br/>      FictItems.PET_FOOD_BOWL,<br/>      usbDrive,<br/>      FictItems.LARGE_DOGS_FOOD_BOWL)<br/>    val <strong class="le ir">actual</strong> =<br/>            <strong class="le ir">unsorted.sortBy(_.avgStarRating).reverse.sortBy(_.price)</strong><br/>    assertEquals(expected, actual)</span></pre><p id="1abe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它工作起来没有任何问题。</p><p id="fe91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以你有它。在Java中，按字段对对象进行排序并不十分困难，但也不简单，需要做一些艰苦的工作。相比之下，在Scala中按照字段对对象进行排序非常简单和直观。</p></div></div>    
</body>
</html>