<html>
<head>
<title>Understand Kotlin Past Participle Named Collection Function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Kotlin过去分词命名集合函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understand-kotlin-collection-function-past-tense-59f592af9436?source=collection_archive---------16-----------------------#2020-05-24">https://levelup.gitconnected.com/understand-kotlin-collection-function-past-tense-59f592af9436?source=collection_archive---------16-----------------------#2020-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="1a68" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">学习Kotlin编程</h2><div class=""/><div class=""><h2 id="2495" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">通过名称更快地学习Kotlin收集功能</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/18761b68314579c03856e36c2fb64249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eKGrDVZ5CdmhRDgO"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@waldemarbrandt67w?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">瓦尔德马尔·布兰德</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="b4d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di"> W </span>在浏览<a class="ae lh" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/" rel="noopener ugc nofollow" target="_blank"> Kotlin集合函数</a>时，我发现几个函数的名字很有趣。它们是原词和它的过去分词。即</p><blockquote class="mn"><p id="d52f" class="mo mp it bd mq mr ms mt mu mv mw md dk translated">排序vs已排序；</p><p id="dc89" class="mo mp it bd mq mr ms mt mu mv mw md dk translated">反向vs反向；</p><p id="c8e1" class="mo mp it bd mq mr ms mt mu mv mw md dk translated">洗牌vs洗牌</p></blockquote><p id="b469" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">从名字上，我们大概知道它们是做什么用的。</p><p id="a08b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是什么是原词vs过去分词呢？</p><p id="a88e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过了解这种命名约定的目的，您将会更快地了解这种命名的所有功能。</p><h1 id="7cdc" class="nc nd it bd ne nf ng nh ni nj nk nl nm ki nn kj no kl np km nq ko nr kp ns nt bi translated">首先了解每个功能</h1><p id="e1e9" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated">我们先来了解一下各个功能。</p><h2 id="54c7" class="nz nd it bd ne oa ob dn ni oc od dp nm lr oe of no lv og oh nq lz oi oj ns iz bi translated">分类</h2><p id="743b" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated">这个函数将把一个未排序的列表变成排序的列表。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ok"><img src="../Images/363ac52029fbe609bd2c3c37cba8bbce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*dDKIlH1JujQNxSq_f5Pa0g.png"/></div></div></figure><h2 id="fba8" class="nz nd it bd ne oa ob dn ni oc od dp nm lr oe of no lv og oh nq lz oi oj ns iz bi translated">反面的</h2><p id="708e" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated">该函数将颠倒原始列表的顺序。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ok"><img src="../Images/dcfd582a4f6c6c66c9afa8bbea75a620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*nshx1TdyQabcc6FIjBMWlg.png"/></div></div></figure><h2 id="3167" class="nz nd it bd ne oa ob dn ni oc od dp nm lr oe of no lv og oh nq lz oi oj ns iz bi translated">洗牌</h2><p id="2b80" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated">这个函数将对列表进行随机排序。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ok"><img src="../Images/8c5de2d72829e5895ec4647d97913e78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*dJYqDZH7CKHXz8vfIhRRZg.png"/></div></div></figure><h1 id="5558" class="nc nd it bd ne nf ng nh ni nj nk nl nm ki nn kj no kl np km nq ko nr kp ns nt bi translated">那么原分词和过去分词有什么区别呢？</h1><p id="9b62" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated">在只读和可变集合列表中使用的默认函数是过去分词函数，即<code class="fe ol om on oo b">sorted()</code>、<code class="fe ol om on oo b">reversed()</code>和<code class="fe ol om on oo b">shuffled()</code>。</p><p id="9806" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">他们将产生一个新的预期结果列表。</p><pre class="ks kt ku kv gt op oo oq or aw os bi"><span id="2fa2" class="nz nd it oo b gy ot ou l ov ow">val list = <em class="ox">listOf</em>(2, 3, 1, 4, 5, 6)<br/>val sorted = list.<strong class="oo jd"><em class="ox">sorted</em></strong>()<br/>val reversed = list.<strong class="oo jd"><em class="ox">reversed</em></strong>()<br/>val shuffled = list.<strong class="oo jd"><em class="ox">shuffled</em></strong>()<br/><em class="ox">println</em>(sorted)    // [1, 2, 3, 4, 5, 6]<br/><em class="ox">println</em>(reversed)  // [6, 5, 4, 1, 3, 2]<br/><em class="ox">println</em>(shuffled)  // [3, 4, 5, 1, 6, 2]<br/><em class="ox">println</em>(list)      // [2, 3, 1, 4, 5, 6]</span></pre><p id="d614" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你会注意到原来的单词功能，即<code class="fe ol om on oo b">sort()</code>、<code class="fe ol om on oo b">reverse()</code>和<code class="fe ol om on oo b">shuffle()</code>在<code class="fe ol om on oo b">list</code>中不可用。</p><h2 id="be88" class="nz nd it bd ne oa ob dn ni oc od dp nm lr oe of no lv og oh nq lz oi oj ns iz bi translated">原词功能</h2><p id="354e" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated">为了使用原来的word函数，你必须把它转换成一个<code class="fe ol om on oo b">mutableList</code>。原因很简单。原始word函数将改变原始列表，而不是从中创建一个新列表。它不会输出新的列表。</p><pre class="ks kt ku kv gt op oo oq or aw os bi"><span id="02e4" class="nz nd it oo b gy ot ou l ov ow">// SORT<br/>val list = <em class="ox">mutableListOf</em>(2, 3, 1, 4, 5, 6)<br/>list.<strong class="oo jd"><em class="ox">sort</em></strong>()<br/><em class="ox">println</em>(list)      // [1, 2, 3, 4, 5, 6]</span><span id="4ab6" class="nz nd it oo b gy oy ou l ov ow">// REVERSE<br/>val list = <em class="ox">mutableListOf</em>(2, 3, 1, 4, 5, 6)<br/>list.<strong class="oo jd"><em class="ox">reverse</em></strong>()<br/><em class="ox">println</em>(list)      // [6, 5, 4, 1, 3, 2]</span><span id="4f6c" class="nz nd it oo b gy oy ou l ov ow">// SHUFFLE<br/>val list = <em class="ox">mutableListOf</em>(2, 3, 1, 4, 5, 6)<br/>list.<strong class="oo jd"><em class="ox">shuffle</em></strong>()<br/><em class="ox">println</em>(list)      // [3, 4, 5, 1, 6, 2]</span></pre><p id="f8ba" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面的gif解释了这一切。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oz"><img src="../Images/c8b038f6c94285351d665267a16e9a2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*K4AWJeehCmMyvtzTL4NDgQ.gif"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">排序与已排序</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pa"><img src="../Images/a475f5aab6ae29110a412ba551191c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*skijrITF1u10odEgrvaXnA.gif"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">反向vs反向</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pa"><img src="../Images/853fea58cff8ca6e127748199ca77d9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KPMsv4jg2nDkOieuGwhAJA.gif"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">洗牌vs洗牌</figcaption></figure><h1 id="cb5d" class="nc nd it bd ne nf ng nh ni nj nk nl nm ki nn kj no kl np km nq ko nr kp ns nt bi translated">TL；DR；</h1><p id="e8f8" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated">对于这三个函数，过去分词命名的函数是会生成新列表的函数。但是最初命名的函数是会改变原始列表内容的函数。</p><blockquote class="pb pc pd"><p id="93b3" class="li lj ox lk b ll lm kd ln lo lp kg lq pe ls lt lu pf lw lx ly pg ma mb mc md im bi translated">如果Kotlin将来引入一个既有原始名称又有过去分词名称的函数，我相信这将是惯例。</p></blockquote><p id="c3bb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就我个人而言，我会这样做，因为</p><ol class=""><li id="8b34" class="ph pi it lk b ll lm lo lp lr pj lv pk lz pl md pm pn po pp bi translated">我相信过去分词代表改变一个内容。(免责声明，我的英语有限)</li><li id="2989" class="ph pi it lk b ll pq lo pr lr ps lv pt lz pu md pm pn po pp bi translated">对于所有其他函数，例如<code class="fe ol om on oo b">filter</code>、<code class="fe ol om on oo b">map</code>等，它们产生一个新的列表，但不是以过去分词的形式。</li></ol></div><div class="ab cl pv pw hx px" role="separator"><span class="py bw bk pz qa qb"/><span class="py bw bk pz qa qb"/><span class="py bw bk pz qa"/></div><div class="im in io ip iq"><p id="0f8c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢阅读。你可以在这里查看我的其他话题<a class="ae lh" href="https://medium.com/@elye.project/" rel="noopener"/>。</p><p id="f61f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以在此订阅<a class="ae lh" href="https://buttondown.email/Elye." rel="noopener ugc nofollow" target="_blank"/>或关注我的<a class="ae lh" href="https://medium.com/@elye.project" rel="noopener"> <em class="ox"> Medium </em> </a> <em class="ox">，</em><a class="ae lh" href="https://twitter.com/elye_project" rel="noopener ugc nofollow" target="_blank"><em class="ox">Twitter</em></a><em class="ox">，</em> <a class="ae lh" href="https://www.facebook.com/elye.project/" rel="noopener ugc nofollow" target="_blank"> <em class="ox">脸书</em> </a> <em class="ox">，</em> <a class="ae lh" href="https://www.reddit.com/user/elyeproj/" rel="noopener ugc nofollow" target="_blank"> <em class="ox"> Reddit </em> </a>获取关于移动开发、Medium写作等相关话题的小技巧和学习。~Elye~</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qc qd l"/></div></figure></div></div>    
</body>
</html>