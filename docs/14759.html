<html>
<head>
<title>Pre-rendering in Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Next.js中的预渲染</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/pre-rendering-in-next-js-90bbfc644cd2?source=collection_archive---------5-----------------------#2022-12-22">https://levelup.gitconnected.com/pre-rendering-in-next-js-90bbfc644cd2?source=collection_archive---------5-----------------------#2022-12-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a0e707d43eb4a110d3f7d71601a09d52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uMrFmA-EqukbJ74ap_HEEQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">背景图片由<a class="ae kc" href="https://unsplash.com/@gradienta?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Gradienta </a>在<a class="ae kc" href="https://unsplash.com/s/photos/abstract-background?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="17e0" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">什么是预渲染？</h1><p id="4eef" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">预渲染意味着预先为每个页面生成HTML，以及该页面所需的最少javascript代码。</p><p id="4a74" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">页面加载到浏览器后，Javascript代码被执行并使页面完全交互。这部分过程被称为<strong class="ld ir">水合</strong>。</p><h1 id="5c22" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">为什么要预渲染？</h1><ol class=""><li id="1d31" class="me mf iq ld b le lf li lj lm mg lq mh lu mi ly mj mk ml mm bi translated">预渲染提高了性能</li></ol><ul class=""><li id="d452" class="me mf iq ld b le lz li ma lm mn lq mo lu mp ly mq mk ml mm bi translated">在典型的react应用程序中，您需要等待javascript代码加载到浏览器并执行。因此，渲染用户界面需要更多的时间</li><li id="6e08" class="me mf iq ld b le mr li ms lm mt lq mu lu mv ly mq mk ml mm bi translated">有了预先呈现的页面，HTML就已经生成了，而且加载速度更快</li></ul><p id="bd77" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">2.预渲染有助于搜索引擎优化</p><ul class=""><li id="5c2b" class="me mf iq ld b le lz li ma lm mn lq mo lu mp ly mq mk ml mm bi translated">如果你正在建立一个博客或电子商务网站，搜索引擎优化是一个问题。</li><li id="6a99" class="me mf iq ld b le mr li ms lm mt lq mu lu mv ly mq mk ml mm bi translated">如果您检查使用CRA( <code class="fe mw mx my mz b">create-react-app</code>)创建的web应用程序的源代码，您只会在它的主体中看到一个id等于root的div标签。这是因为它的内容是使用客户端呈现来呈现的。如果搜索引擎点击这样的页面，搜索引擎将无法看到内容。正因为如此，一个典型的使用CRA创建的react应用程序对搜索引擎优化并不友好。</li><li id="2dac" class="me mf iq ld b le mr li ms lm mt lq mu lu mv ly mq mk ml mm bi translated">如果搜索引擎找到了一个使用Next.js创建的预呈现页面，所有内容都会出现在源代码中，这将有助于对该页面进行索引。</li></ul><h1 id="be16" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">检查现有网站预渲染的测试</strong></h1><p id="4622" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们做一个小测试，检查给定的网站是否配置了预渲染。</p><ul class=""><li id="18dd" class="me mf iq ld b le lz li ma lm mn lq mo lu mp ly mq mk ml mm bi translated">这个页面(<a class="ae kc" href="https://next-learn-starter.vercel.app/" rel="noopener ugc nofollow" target="_blank">https://next-learn-starter.vercel.app/</a>)是一个使用Next.js构建的web应用程序。因此，它具有预渲染功能。从这里开始我们就叫它<strong class="ld ir">舒的页面</strong>吧。</li><li id="d77f" class="me mf iq ld b le mr li ms lm mt lq mu lu mv ly mq mk ml mm bi translated">这个页面(<a class="ae kc" href="https://create-react-template.vercel.app/" rel="noopener ugc nofollow" target="_blank">https://create-react-template.vercel.app/</a>)是一个使用Create React App构建的web应用程序。这意味着它不是为预渲染而配置的。为了便于参考，我们称它为<strong class="ld ir"> CRA页面</strong>。</li></ul><ol class=""><li id="0063" class="me mf iq ld b le lz li ma lm mn lq mo lu mp ly mj mk ml mm bi translated">首先，访问这两个页面，看看它们是否工作。</li><li id="1b73" class="me mf iq ld b le mr li ms lm mt lq mu lu mv ly mj mk ml mm bi translated">现在，您必须在浏览器中禁用javascript。选择您正在使用的浏览器的相关指南，禁用javascript <br/> <a class="ae kc" href="https://developer.chrome.com/docs/devtools/javascript/disable/" rel="noopener ugc nofollow" target="_blank"> Chrome/Brave指南</a> <br/> <a class="ae kc" href="https://www.lifewire.com/disable-javascript-in-firefox-446039" rel="noopener ugc nofollow" target="_blank"> Firefox指南</a> <br/> <a class="ae kc" href="https://www.lifewire.com/disable-javascript-in-safari-4103708" rel="noopener ugc nofollow" target="_blank"> Safari指南</a></li><li id="b584" class="me mf iq ld b le mr li ms lm mt lq mu lu mv ly mj mk ml mm bi translated">禁用javascript后，您必须使用同一个浏览器选项卡(您禁用了javascript)再次访问这两个站点，以检查它们是否工作。<br/>你会注意到舒的页面运行良好，的页面显示一条消息，称<em class="na">“你需要启用JavaScript来运行这个应用。”</em>您看到此消息是因为应用程序没有预渲染为静态HTML。</li></ol><ul class=""><li id="b8bc" class="me mf iq ld b le lz li ma lm mn lq mo lu mp ly mq mk ml mm bi translated">在Shu的页面上，初始加载时会显示一个预渲染的HTML。之后，javascript代码被加载到浏览器中，然后应用程序变得具有交互性(这个过程被称为<strong class="ld ir">水合)。</strong></li><li id="d4eb" class="me mf iq ld b le mr li ms lm mt lq mu lu mv ly mq mk ml mm bi translated">在CRA页面上，初始加载期间什么都没有，因为javascript在初始加载期间没有被加载。一旦浏览器加载了javascript代码，整个页面就会呈现出来，变得具有交互性。</li></ul><h1 id="e4bd" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">预渲染的形式</h1><p id="5a27" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Next.js中有两种形式的预渲染。</p><ol class=""><li id="6087" class="me mf iq ld b le lz li ma lm mn lq mo lu mp ly mj mk ml mm bi translated">静态生成</li><li id="fae8" class="me mf iq ld b le mr li ms lm mt lq mu lu mv ly mj mk ml mm bi translated">服务器端渲染</li></ol><p id="4cb3" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们可以配置Next.js应用程序的页面，以这两种形式中的任何一种进行预呈现。但是“静态生成”是Next.js团队推荐的形式。</p><h1 id="ee04" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">静态生成</h1><p id="9786" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">使用<em class="na">静态生成</em>作为其预呈现形式的页面，<strong class="ld ir">在构建期间生成其HTML。<br/> </strong>在生产中，这个过程只有在你运行<code class="fe mw mx my mz b">next build</code>命令时才会发生。但是在开发模式下(当您运行<code class="fe mw mx my mz b">npm run dev</code>时)，页面会在每次请求时被预渲染。</p><p id="d75d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">使用这个过程生成的HTML可以在每个请求上重用，也可以被CDN缓存。</p><p id="95f1" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">当没有数据需要从外部来源(外部API，查询数据库等)获取时，静态生成将自动发生。)</p><p id="5465" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">但是如果你必须从外部来源获取一些数据，你将不得不使用<code class="fe mw mx my mz b">getStaticProps</code>函数来获取这些数据。</p><p id="92bf" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果页面中的数据不经常更改(例如，博客帖子、营销页面、电子商务产品列表、帮助和文档等)，建议使用静态生成。)</p><p id="1c53" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">下面是一个Next.js组件的代码，它从一个免费的API获取用户列表。这里我们使用了<code class="fe mw mx my mz b">getStaticProps</code>来获取数据。</p><pre class="nb nc nd ne gt nf mz ng bn nh ni bi"><span id="4494" class="nj ke iq mz b be nk nl l nm nn">// pages/sg/index.js<br/><br/>import styles from "../../styles/Home.module.css";<br/>import Link from "next/link";<br/><br/>export default function Component({ users }) {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;main className={styles.main}&gt;<br/>        &lt;h1&gt;Static Generation&lt;/h1&gt;<br/>        &lt;div className={styles.description}&gt;<br/>          &lt;ul&gt;<br/>            {users.map((user) =&gt; (<br/>              &lt;li key={user.email}&gt;&lt;Link href={`/sg/${user.id}`}&gt;{user.name}&lt;/Link&gt;&lt;/li&gt;<br/>            ))}<br/>          &lt;/ul&gt;<br/>        &lt;/div&gt;<br/>      &lt;/main&gt;<br/>    &lt;/&gt;<br/>  );<br/>}<br/><br/>// this function gets called during the build time<br/>export async function getStaticProps() {<br/>  // calling an external API to fetch data<br/>  const res = await fetch("https://jsonplaceholder.typicode.com/users");<br/>  const users = await res.json();<br/><br/>  // this returning data can be accessed from the component using the prop name<br/>  return { props: { users } };<br/>}</span></pre><p id="e87c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">下面是该代码的输出。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/b69150ef0cd3f8e8062766b1481b3e84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x0aQ28xPQctuemSayIGVRg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">静态生成代码的输出</figcaption></figure><p id="b98c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">本指南将为您提供更多关于<code class="fe mw mx my mz b">getStaticProps</code>的信息</p><p id="0302" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果当你点击上面用户列表中的一个名字时，你想路由到一个特定的页面(包含关于那个特定用户的更多细节)，你可以从一个动态页面调用<code class="fe mw mx my mz b">getStaticPaths()</code>函数。</p><pre class="nb nc nd ne gt nf mz ng bn nh ni bi"><span id="0b19" class="nj ke iq mz b be nk nl l nm nn">// pages/sg/[id].js<br/><br/>import styles from "../../styles/Home.module.css";<br/><br/>const Post = ({ user }) =&gt; {<br/>  console.log("user", user);<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;main className={styles.main}&gt;<br/>        &lt;h1&gt;Static Generation (Paths)&lt;/h1&gt;<br/>        &lt;div className={styles.description}&gt;Selected User : {user.name}&lt;/div&gt;<br/>      &lt;/main&gt;<br/>    &lt;/&gt;<br/>  );<br/>};<br/><br/>// this function gets called during the build time<br/>export async function getStaticPaths() {<br/>  // calling an external API to fetch all data<br/>  const res = await fetch("https://jsonplaceholder.typicode.com/users");<br/>  const users = await res.json();<br/><br/>  const paths = users.map((item) =&gt; ({<br/>    params: { id: item.id.toString() },<br/>  }));<br/><br/>  //these paths will get pre-rendered only at build time.<br/>  // { fallback: false } means other routes should 404.<br/>  return { paths, fallback: false };<br/>}<br/><br/>// This also gets called at build time<br/>export async function getStaticProps({ params }) {<br/>  // this fetch call has been made only to get the specific data<br/>  const res = await fetch(<br/>    `https://jsonplaceholder.typicode.com/users/${params.id}`<br/>  );<br/>  const user = await res.json();<br/><br/>  return { props: { user } };<br/>}<br/><br/>export default Post;</span></pre><p id="93d3" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">下面是上面代码的输出</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/26766fc2a15a38d2942c1c74731dbf8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pb4-W3FhyKl-6LjpVQ59pA.png"/></div></div></figure><p id="7d05" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">Next.js建议，如果你是使用动态路径的预渲染页面，并且数据来自下面列表中的一个来源，你应该使用<code class="fe mw mx my mz b">getStaticPaths</code></p><ul class=""><li id="c81e" class="me mf iq ld b le lz li ma lm mn lq mo lu mp ly mq mk ml mm bi translated">无头CMS</li><li id="2126" class="me mf iq ld b le mr li ms lm mt lq mu lu mv ly mq mk ml mm bi translated">数据库</li><li id="84c5" class="me mf iq ld b le mr li ms lm mt lq mu lu mv ly mq mk ml mm bi translated">文件系统</li></ul><p id="73a1" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">使用本指南，你可以了解更多关于<code class="fe mw mx my mz b">getStaticPaths</code>的信息。</p><h1 id="40b1" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">服务器端渲染</h1><p id="be48" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">使用服务器端呈现作为其预呈现形式的页面，<strong class="ld ir">为每个请求生成HTML。</strong></p><p id="6b80" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果您的页面显示经常更新的数据，那么服务器端呈现是用于预呈现的推荐形式。但是这将比静态生成慢得多。</p><p id="83c8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果您需要在您的应用程序中配置一个页面用于服务器端渲染，您必须包含<code class="fe mw mx my mz b">getServerSideProps</code>函数，该函数将在每次请求时被服务器调用。</p><pre class="nb nc nd ne gt nf mz ng bn nh ni bi"><span id="dcd1" class="nj ke iq mz b be nk nl l nm nn">import styles from "../../styles/Home.module.css";<br/><br/>export default function Component({ users }) {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;main className={styles.main}&gt;<br/>        &lt;h1&gt;Server-side rendering&lt;/h1&gt;<br/>        &lt;div className={styles.description}&gt;<br/>          &lt;ul&gt;<br/>            {users.map((user) =&gt; (<br/>              &lt;li key={user.email}&gt;{user.name}&lt;/li&gt;<br/>            ))}<br/>          &lt;/ul&gt;<br/>        &lt;/div&gt;<br/>      &lt;/main&gt;<br/>    &lt;/&gt;<br/>  );<br/>}<br/><br/>// this function gets called on each request<br/>export async function getServerSideProps() {<br/>  // calling an external API to fetch data<br/>  const res = await fetch("https://jsonplaceholder.typicode.com/users");<br/>  const users = await res.json();<br/><br/>  // this returning data can be accessed from the component using the prop name<br/>  return { props: { users } };<br/>}</span></pre><p id="76f0" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">跟随本指南<a class="ae kc" href="https://nextjs.org/docs/basic-features/data-fetching/get-server-side-props" rel="noopener ugc nofollow" target="_blank">了解更多关于<code class="fe mw mx my mz b">getServerSideProps</code>的信息</a></p><h1 id="3573" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">参考</h1><p id="56d0" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">预渲染和数据获取(Next.js学习指南)——<a class="ae kc" href="https://nextjs.org/learn/basics/data-fetching/pre-rendering" rel="noopener ugc nofollow" target="_blank">https://nextjs.org/learn/basics/data-fetching/pre-rendering</a></p><p id="fc98" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">Next.js预渲染文档—<a class="ae kc" href="https://nextjs.org/docs/basic-features/pages" rel="noopener ugc nofollow" target="_blank">https://nextjs.org/docs/basic-features/pages</a></p><p id="7c84" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我在本文中使用的Github Repo—<a class="ae kc" href="https://github.com/sankharr/next_pre-render" rel="noopener ugc nofollow" target="_blank">https://github.com/sankharr/next_pre-render</a></p></div></div>    
</body>
</html>