<html>
<head>
<title>Laravel: My Proposal for the Inertia-Based File Structure and Invokable Controllers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Laravel:我对基于惯性的文件结构和可调用控制器的建议</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/laravel-my-proposal-for-the-inertia-based-file-structure-and-invokable-controllers-8278ca15fbb3?source=collection_archive---------10-----------------------#2022-04-15">https://levelup.gitconnected.com/laravel-my-proposal-for-the-inertia-based-file-structure-and-invokable-controllers-8278ca15fbb3?source=collection_archive---------10-----------------------#2022-04-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9600" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为一名Laravel开发人员，我目前的喜好是将Vue作为前端，将Inertia作为连接器。在我的工作中，我相信我已经找到了建模任何Laravel/Inertia代码库的完美架构。</p><h1 id="ca1a" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">前端文件夹结构</h1><p id="2b20" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我的<em class="lo"> resources/js </em>的结构如下:</p><ul class=""><li id="75f4" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">Pages:保存GET请求返回的任何Vue文件。</li><li id="476f" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">组件:包含可重用的组件，这些组件可以扩展到其他存储库。</li><li id="47c9" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">Layouts:保存所有隐式包装在前端的布局。</li><li id="8bc4" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">分音:</li></ul><p id="45bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与组件不同，这些全局部分是由它们所工作的存储库专门标识的。它们可以应用于存储库中的任何Vue文件，但是不能在存储库之外重用。</p><p id="a901" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于本地部分，如果它们适用于页面/组件/布局目录中的一个或多个Vue文件，则它们嵌套在这些目录中。</p><ul class=""><li id="0c92" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">…所有其他文件</li></ul><p id="4b52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种设置非常方便，几乎与<a class="ae md" href="https://nuxtjs.org/docs/get-started/directory-structure/" rel="noopener ugc nofollow" target="_blank"> Nuxt </a>使用的设置相同。有了这种设置，我发现以镜像我的<em class="lo">资源/js </em>目录的方式构建我的控制器非常容易。</p><h1 id="8d38" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">可调用控制器还是普通控制器？此外，文件夹结构</h1><p id="f59d" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">如果你对可调用(或单个动作)控制器一无所知，请阅读这里的<a class="ae md" href="https://laravel.com/docs/9.x/controllers#single-action-controllers" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="4ee6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我的<em class="lo"> App/Http/Controllers </em>设置:</p><h2 id="54a7" class="me km iq bd kn mf mg dn kr mh mi dp kv jy mj mk kz kc ml mm ld kg mn mo lh mp bi translated">结构:App/Http/控制器</h2><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="179c" class="me km iq mv b gy mz na l nb nc">- API<br/>- Web<br/>  - Actions<br/>  - Pages</span></pre><p id="9f05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> API </strong>意在存储所有用于网站API的控制器，并保存在<em class="lo"> routes/api.php </em>文件中。</p><p id="9892" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Web </strong>显然是为了保存所有的基于Web的控制器或者那些位于<em class="lo"> routes/web.php </em>中的路由。</p><p id="1f6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在web下面，有两个子文件夹:<strong class="jp ir">动作</strong>和<strong class="jp ir">页面</strong>。这里，Pages文件夹中的每一个文件都要与<em class="lo"> resources/js/Pages </em>目录中的文件对齐。</p><p id="db6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，作为并列比较，它看起来完全像这样:</p><h2 id="e80f" class="me km iq bd kn mf mg dn kr mh mi dp kv jy mj mk kz kc ml mm ld kg mn mo lh mp bi translated">结构:App/Http/Controllers/Web/</h2><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="af55" class="me km iq mv b gy mz na l nb nc">- Pages<br/>  - Item<br/>    - Index.php</span></pre><h2 id="47a7" class="me km iq bd kn mf mg dn kr mh mi dp kv jy mj mk kz kc ml mm ld kg mn mo lh mp bi translated">结构:资源/js</h2><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="6d18" class="me km iq mv b gy mz na l nb nc">- Pages<br/>  - Item<br/>    - Index.vue</span></pre><p id="eaf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Index.vue文件包含索引可调用控制器类，Index.vue包含前端。</p><p id="840e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过这样做，你可以改善组织。此外，通过将每个方法分成自己的可调用控制器类文件，可以减少每个控制器的行数。</p><p id="22f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，如果您不想对每个控制器都使用invokable，您可以使用这种替代设置。</p><h2 id="90b6" class="me km iq bd kn mf mg dn kr mh mi dp kv jy mj mk kz kc ml mm ld kg mn mo lh mp bi translated">结构:应用程序/Http/控制器/网页/页面</h2><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="5630" class="me km iq mv b gy mz na l nb nc">- Pages<br/>  - ItemController.php</span></pre><h2 id="5c2e" class="me km iq bd kn mf mg dn kr mh mi dp kv jy mj mk kz kc ml mm ld kg mn mo lh mp bi translated">结构:资源/js</h2><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="21cb" class="me km iq mv b gy mz na l nb nc">- Pages<br/>  - Item<br/>    - Index.vue</span></pre><p id="4177" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在ItemController.php，你会有指数法。虽然乍看之下很难将它们与它们的Vue页面联系起来，但是它们确实让您能够使用Laravel的内置route::resource功能，从而允许您缩短routes/web.php文件。</p><p id="480b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，对于任何不完全符合[索引、创建、存储、编辑、更新、销毁]范式的控制器方法(例如，“发布”)，我建议将其设为可调用的，并放入<em class="lo">App/Http/Controllers/Web/Actions目录</em>。</p><h1 id="3f0f" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">服务层</h1><p id="3877" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">最后，为了处理重复的行为，我依赖服务类。</p><p id="c6ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我添加了一个目录<em class="lo"> App/Services </em>，我放了两个子目录。您可以将第二个命名为任何您喜欢的名称(例如，“Other”)，但是我将第一个命名为“<strong class="jp ir"> Client </strong>”，并且在那个子目录中，我将<strong class="jp ir"> <em class="lo">放置在方法与外部API </em> </strong>交互的任何服务类中。如果我想连接到一个特定组织的API，我将构建一个描述该组织的目录，然后创建一个服务类文件，描述该API试图完成的一组内容。</p><p id="e9fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们以这个例子为例，我正在创建一个客户端服务类，它连接到Widget Inc .的支付API (widget/v2/getPayments，widget/v2/postPayment)。</p><h2 id="0a11" class="me km iq bd kn mf mg dn kr mh mi dp kv jy mj mk kz kc ml mm ld kg mn mo lh mp bi translated">结构:应用程序/服务/客户端</h2><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="b909" class="me km iq mv b gy mz na l nb nc">- Services<br/>  - Client<br/>    - Widget<br/>      - V2<br/>        - PaymentService.php</span></pre><p id="53ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lo">PaymentService.php</em>包含所有调用相关支付API的方法。</p><h2 id="7900" class="me km iq bd kn mf mg dn kr mh mi dp kv jy mj mk kz kc ml mm ld kg mn mo lh mp bi translated">文件:App/Services/Client/Widget/V2/paymentservice . PHP</h2><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="92e6" class="me km iq mv b gy mz na l nb nc">&lt;?php<br/><br/>namespace App/Services/Client/PaymentService;<br/><br/>...<br/><br/>class PaymentService {<br/><br/>	public function getPayments(...)<br/>	{<br/>	   ...<br/>	}<br/><br/>	publc function postPayment(...)<br/>	{<br/>	   ...<br/>	}<br/>}</span></pre><p id="fb53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过这样做，我能够编写可重用的功能，其唯一目的是以清晰可读的方式与外部实体的API进行交互。我可以很容易地抓住这个逻辑，复制并粘贴到任何其他基于PHP的项目，并让它工作。</p><h1 id="7186" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">利弊</h1><h2 id="4562" class="me km iq bd kn mf mg dn kr mh mi dp kv jy mj mk kz kc ml mm ld kg mn mo lh mp bi translated">赞成的意见</h2><ul class=""><li id="b44f" class="lp lq iq jp b jq lj ju lk jy nd kc ne kg nf kk lu lv lw lx bi translated">不使用服务等级的较短控制器代码。</li><li id="5842" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">控制器类与前端页面匹配。</li><li id="5d84" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">不必考虑抽象的控制器名称来对逻辑进行分组(通常是模型的名称)，因为命名方案是基于您喜欢如何对页面和操作进行分组。</li><li id="ef17" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">由于缩短的控制器通常只需要一个服务类别，所以服务类别可以被相当普遍地注入。</li></ul><p id="10d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="ddf8" class="me km iq mv b gy mz na l nb nc">e...<br/><br/>$this-&gt;service = $service;<br/><br/>...</span></pre><h2 id="d7af" class="me km iq bd kn mf mg dn kr mh mi dp kv jy mj mk kz kc ml mm ld kg mn mo lh mp bi translated">骗局</h2><ul class=""><li id="29d0" class="lp lq iq jp b jq lj ju lk jy nd kc ne kg nf kk lu lv lw lx bi translated">较长的路由文件。</li></ul><p id="cbe2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为你的控制器保存在不同的文件中，你不能利用<code class="fe ng nh ni mv b">Route::resource</code>。</p><p id="f966" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果典型的控制器结构符合[索引、创建、存储、编辑、更新、销毁]范式，您可以使用它，只需将任何冗长的逻辑抽象为一个服务类，以减少所用代码行的长度。</p><ul class=""><li id="b9b8" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">如果您想要更改几个Vue文件的位置，并随后更改它们的等效控制器文件，那么重构可能是一场噩梦。</li><li id="bdb3" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">有些人喜欢每个模型有一个控制器来存储他们的模型CRUD逻辑，但是我不喜欢这种方法。任何一种抽象的典型模型-动作逻辑都应该在它自己的类中(例如，存储库模式)。而不是在控制器中，控制器主要用于抽象路由逻辑并保持路由文件整洁。</li></ul></div></div>    
</body>
</html>