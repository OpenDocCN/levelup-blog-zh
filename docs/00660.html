<html>
<head>
<title>Scala journals — for comprehensions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala期刊——为了理解</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scala-journals-part-5-for-comprehensions-4eac96fdc791?source=collection_archive---------4-----------------------#2019-06-20">https://levelup.gitconnected.com/scala-journals-part-5-for-comprehensions-4eac96fdc791?source=collection_archive---------4-----------------------#2019-06-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/53f6f3edc7ee4a8ad75103b5cfd1cc7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TT5rOnqCkwD3tbEi.jpg"/></div></div></figure><p id="0cf8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经知道了所有关于<code class="fe kz la lb lc b">map</code>和<code class="fe kz la lb lc b">flatMap</code>的内容，还有一件事非常重要，那就是理解的<strong class="kd iu">，你可以把它看作是for循环的“一种”替代——尽管你很快就会发现这是不一样的。</strong></p><p id="42ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简而言之——理解的<strong class="kd iu"/>给了我们使用<code class="fe kz la lb lc b">flatMap</code>、<code class="fe kz la lb lc b">map</code>和<code class="fe kz la lb lc b">filter</code>处理大型、有序和/或嵌套计算的语法糖。</p><p id="ea34" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">事不宜迟，让我们先看看下面的例子。假设我们有两个整数列表，我们想要得到它们元素上乘法的所有组合，所以对于<code class="fe kz la lb lc b">List(1, 2)</code>和<code class="fe kz la lb lc b">List(3, 4)</code>我们想要一个<code class="fe kz la lb lc b">List(3, 4, 6, 8)</code>的结果</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="eeb6" class="ll lm it lc b gy ln lo l lp lq">val list1 = List(1, 2) <br/>val list2 = List(3, 4)  </span><span id="deba" class="ll lm it lc b gy lr lo l lp lq">list1.flatMap(     <br/>   list1Element =&gt; list2.map(         <br/>        list2Element =&gt; list1Element * list2Element<br/>        ) <br/>   )  </span><span id="df96" class="ll lm it lc b gy lr lo l lp lq">// List(3, 4, 6, 8)</span></pre><p id="21a7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">…呀。这看起来不太好。令人欣慰的是，理解的<strong class="kd iu">给了我们一个很好的语法糖，使我们很容易将上面的内容重写为</strong></p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="83eb" class="ll lm it lc b gy ln lo l lp lq">val list1 = List(1, 2) <br/>val list2 = List(3, 4)  </span><span id="7626" class="ll lm it lc b gy lr lo l lp lq">for {     <br/> l1Element &lt;- list1 // for each list1 element called l1Element<br/> l2Element &lt;- list2 // and for each list2 element called l2Element   } yield l1Element * l2Element // multiply l1Element and l2Element</span><span id="07a8" class="ll lm it lc b gy lr lo l lp lq">// List(3, 4, 6, 8)</span></pre><p id="c4d1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这看起来更愉快，对不对？</p><h1 id="31ed" class="ls lm it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">理解中允许的表达式</h1><p id="ecb7" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">通常，理解遵循以下语法:</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="d81e" class="ll lm it lc b gy ln lo l lp lq">for {       <br/> sequenceOfExpressions<br/>} yield computeResultExpression</span></pre><p id="8768" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是理解表达式的列表(上图中的<code class="fe kz la lb lc b">sequenceOfExpressions</code>):</p><ul class=""><li id="8231" class="mu mv it kd b ke kf ki kj km mw kq mx ku my ky mz na nb nc bi translated">发电机(<code class="fe kz la lb lc b">element &lt;- list</code>)，把它想成“对<code class="fe kz la lb lc b">list</code>的每一个<code class="fe kz la lb lc b">element</code>”</li><li id="bf5f" class="mu mv it kd b ke nd ki ne km nf kq ng ku nh ky mz na nb nc bi translated">定义(<code class="fe kz la lb lc b">name = element.name</code>)，把它当成一个简单的赋值，就像<code class="fe kz la lb lc b">val dogName = dog.name</code></li><li id="0284" class="mu mv it kd b ke nd ki ne km nf kq ng ku nh ky mz na nb nc bi translated">滤镜(<code class="fe kz la lb lc b">if (name == "Joe")</code>)，嗯。只是一个滤镜:)</li></ul><p id="ca4e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">yield</code>这是我们通向理解的门吗——这是你的价值观和表达评估在理解范围内的唯一地方，这是一个对你的结果采取行动的地方。</p><h1 id="f00d" class="ls lm it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">对于理解规则</h1><p id="aaec" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">现在我们知道了允许的表达式和<code class="fe kz la lb lc b">yield</code>的作用，我们来谈谈一些规则。让我们从一个重要的注意事项开始:</p><h1 id="2c73" class="ls lm it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">不要试图记住这些！</h1><p id="039b" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">随着时间的推移，它会自然而然(也是合乎逻辑的)来到你身边。</p><h2 id="d6e8" class="ll lm it bd lt ni nj dn lx nk nl dp mb km nm nn mf kq no np mj ku nq nr mn ns bi translated">规则一:</h2><p id="b9cf" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">为了理解，必须总是从发电机开始。</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="965a" class="ll lm it lc b gy ln lo l lp lq">val list1 = List(1, 2) <br/>val list2 = List(3, 4)  </span><span id="f132" class="ll lm it lc b gy lr lo l lp lq">for {     <br/> l1Element = list1(1) // error: '&lt;-' expected but '=' found<br/> l2Element &lt;- list2   <br/>} yield l1Element * l2Element </span></pre><h2 id="7d84" class="ll lm it bd lt ni nj dn lx nk nl dp mb km nm nn mf kq no np mj ku nq nr mn ns bi translated">规则二:</h2><p id="f8f1" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">用一个生成器来理解是一个简单的<code class="fe kz la lb lc b">map</code>:</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="e8c0" class="ll lm it lc b gy ln lo l lp lq">for {     <br/> element &lt;- list<br/>} yield element * 2</span></pre><p id="14af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">…翻译过来就是…</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="ef45" class="ll lm it lc b gy ln lo l lp lq">list.map(_ * 2)</span></pre><h2 id="7f94" class="ll lm it bd lt ni nj dn lx nk nl dp mb km nm nn mf kq no np mj ku nq nr mn ns bi translated">规则三:</h2><p id="86a3" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">用于理解两个发生器的a是后面跟有<code class="fe kz la lb lc b">map</code>的<code class="fe kz la lb lc b">flatMap</code>。</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="658b" class="ll lm it lc b gy ln lo l lp lq">for {     <br/> element1 &lt;- list1<br/> element2 &lt;- list2 <br/>} yield element1 * element2</span></pre><p id="2b0f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">…翻译过来就是…</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="482e" class="ll lm it lc b gy ln lo l lp lq">list1.flatMap(     <br/> element1 =&gt; list2.map(<br/>     element2 =&gt; element1 * element2<br/>     )<br/>  )</span></pre><h2 id="1502" class="ll lm it bd lt ni nj dn lx nk nl dp mb km nm nn mf kq no np mj ku nq nr mn ns bi translated">规则四:</h2><p id="6749" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">用于理解发生器和滤波器的是一个<code class="fe kz la lb lc b">withFilter</code>后跟一个<code class="fe kz la lb lc b">map</code>:</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="adba" class="ll lm it lc b gy ln lo l lp lq">for {     <br/> element &lt;- list     <br/> if(element &gt; 3)   <br/>} yield element + 3</span></pre><p id="99f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">…翻译过来就是…</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="d872" class="ll lm it lc b gy ln lo l lp lq">list.withFilter(     <br/> element =&gt; element &gt; 1<br/>).map(_ + 3)</span></pre><h2 id="21ad" class="ll lm it bd lt ni nj dn lx nk nl dp mb km nm nn mf kq no np mj ku nq nr mn ns bi translated">规则五:</h2><p id="86e6" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">没有<code class="fe kz la lb lc b">yield</code>的理解的a是一个<code class="fe kz la lb lc b">forEach</code>(注意副作用！不推荐)</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="ad8a" class="ll lm it lc b gy ln lo l lp lq">for {     <br/> element &lt;- list     <br/> if(element &gt; 3)   <br/>} println(element)</span></pre><p id="3ed4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">…翻译过来就是…</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="a4ca" class="ll lm it lc b gy ln lo l lp lq">list.foreach(element =&gt; println(element))</span></pre><h1 id="30d1" class="ls lm it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">对现实生活的理解</h1><p id="9704" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">如果你有像下面这样的任务，Scala <strong class="kd iu">将成为你的救命稻草。考虑到上面的规则，想想你会创建一个什么样的平面地图-地图-过滤器怪物，在没有理解的情况下进行同样的计算。</strong></p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="9ac3" class="ll lm it lc b gy ln lo l lp lq">for {     <br/> result &lt;- operation // generator     <br/> result2 &lt;- operation(result) // generator     <br/> result3 &lt;- operation(result, result2) // generator     <br/> if(result3 == 0) // filter   <br/>} yield doSomething(result3) // yield</span></pre><p id="42c3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看。我不打算尝试建立一个非理解性的解决方案，但是根据我们上面的规则，我们可以猜测它将包括:</p><ul class=""><li id="0090" class="mu mv it kd b ke kf ki kj km mw kq mx ku my ky mz na nb nc bi translated">三个嵌套的生成器平面图</li><li id="00a9" class="mu mv it kd b ke nd ki ne km nf kq ng ku nh ky mz na nb nc bi translated">带过滤器的过滤器</li><li id="f6c2" class="mu mv it kd b ke nd ki ne km nf kq ng ku nh ky mz na nb nc bi translated">产量图</li></ul><p id="36a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在现实生活中，对于任何需要排序和编排大量操作的情况，理解是一个很好的解决方案。如果你的解决方案是单一的<code class="fe kz la lb lc b">map</code>或<code class="fe kz la lb lc b">flatMap</code>，也许不值得用a来理解。另一方面，如果你正在处理一些顺序操作，并且发现自己在映射、过滤和平面映射中使用了像<code class="fe kz la lb lc b">Try</code>、<code class="fe kz la lb lc b">Option</code>、<code class="fe kz la lb lc b">Future</code>这样的类型，或者这些类型的任意顺序，这就是理解的时候了。</p><p id="8f6a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们来列举几个用法:</p><ul class=""><li id="86cf" class="mu mv it kd b ke kf ki kj km mw kq mx ku my ky mz na nb nc bi translated">发出几个返回<code class="fe kz la lb lc b">Try</code>的数据库请求</li><li id="79fe" class="mu mv it kd b ke nd ki ne km nf kq ng ku nh ky mz na nb nc bi translated">发出几个返回<code class="fe kz la lb lc b">Future</code>的http请求</li><li id="e6a7" class="mu mv it kd b ke nd ki ne km nf kq ng ku nh ky mz na nb nc bi translated">跨多个序列的计算，例如跨4个列表</li><li id="c646" class="mu mv it kd b ke nd ki ne km nf kq ng ku nh ky mz na nb nc bi translated">引导应用程序——数据库、模块、http客户端等。(虽然你可能会想到用依赖注入来代替！)</li></ul><h1 id="a664" class="ls lm it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">摘要</h1><p id="1497" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">For comprehension是处理嵌套的<code class="fe kz la lb lc b">flatMap</code>、<code class="fe kz la lb lc b">map</code>和<code class="fe kz la lb lc b">filter</code>表达式的语法糖。</p><h2 id="551a" class="ll lm it bd lt ni nj dn lx nk nl dp mb km nm nn mf kq no np mj ku nq nr mn ns bi translated">(不那么)硬核笔记</h2><p id="f263" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">如果你听说过单词<strong class="kd iu"> monad </strong>(我肯定你听说过并想过“wtf”——但别担心我也是)，这里是我要提到它的第一个地方(但还没有进入细节或解释)。在<strong class="kd iu">大规模</strong>过度简化中，可以被平面映射的东西是单子(这意味着简单的<code class="fe kz la lb lc b">Option</code>也是单子——知道你已经处理了这个(不那么)可怕的东西是多么酷啊！).</p><p id="4017" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以你对总结的核心补充是:</p><blockquote class="nt nu nv"><p id="d17d" class="kb kc nw kd b ke kf kg kh ki kj kk kl nx kn ko kp ny kr ks kt nz kv kw kx ky im bi translated">因为理解对于处理和编写单子非常有用。</p></blockquote></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><p id="fb76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nw">原载于2019年6月20日</em><a class="ae oh" href="https://arfro.github.io/for-comprehensions/" rel="noopener ugc nofollow" target="_blank"><em class="nw">https://arfro . github . io</em></a><em class="nw">。</em></p></div></div>    
</body>
</html>