<html>
<head>
<title>Type Challenges: Implement the RequiredByKeys<t k=""> Utility Type</t></title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型挑战:实现RequiredByKeys <t k="">实用程序类型</t></h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/type-challenges-implement-the-requiredbykeys-t-k-utility-type-4df181f7d4cf?source=collection_archive---------8-----------------------#2022-10-06">https://levelup.gitconnected.com/type-challenges-implement-the-requiredbykeys-t-k-utility-type-4df181f7d4cf?source=collection_archive---------8-----------------------#2022-10-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4a18" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">内置的Required泛型不灵活，RequiredByKeys泛型可以解决这个问题。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a31601873375ec3874692fe1d0d5c994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jYtZnxQ_x11HDM9up5OWyg.jpeg"/></div></div></figure><p id="b4b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">欢迎来到<strong class="kw iu">掌握打字稿</strong>系列，这个系列有几十篇文章。为了帮助读者更好地巩固自己的TypeScript知识，我从Github上的<a class="ae lq" href="https://github.com/type-challenges/type-challenges" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">type-challenges</strong></a>资源库中挑选了几十个挑战，和大家一起完成type challenge。</p><div class="lr ls gp gr lt lu"><a href="https://medium.com/frontend-canteen/with-these-articles-you-will-not-be-confused-when-learning-typescript-d96a5c99e229" rel="noopener follow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd iu gy z fp lz fr fs ma fu fw is bi translated">有了这些文章，你在学习TypeScript的时候就不会迷茫了</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">通过生动的动画，让你轻松了解TypeScript的难点和核心知识！不断地…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">medium.com</p></div></div><div class="md l"><div class="me l mf mg mh md mi ks lu"/></div></div></a></div><ul class=""><li id="6332" class="mj mk it kw b kx ky la lb ld ml lh mm ll mn lp mo mp mq mr bi translated"><a class="ae lq" href="https://javascript.plainenglish.io/type-challenges-implement-the-built-in-pick-t-k-utility-type-90f1970f121c" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">类型挑战:实现内置挑&lt; T，K &gt;实用类型</strong> </a></li><li id="2b27" class="mj mk it kw b kx ms la mt ld mu lh mv ll mw lp mo mp mq mr bi translated"><a class="ae lq" href="https://blog.bitsrc.io/typescript-challenge-implement-the-built-in-omit-t-k-utility-type-5e953d5c94c" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">类型挑战:实现内置省略&lt; T，K &gt;实用类型</strong> </a></li></ul><h1 id="d8bf" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">挑战</h1><p id="29fa" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">实现一个泛型<code class="fe nu nv nw nx b">RequiredByKeys&lt;T, K&gt;</code>，它带有两个类型参数<code class="fe nu nv nw nx b">T</code>和<code class="fe nu nv nw nx b">K</code>。</p><p id="b715" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nu nv nw nx b">K</code>指定需要设置的<code class="fe nu nv nw nx b">T</code>的属性集。当没有提供<code class="fe nu nv nw nx b">K</code>时，它应该像正常的<code class="fe nu nv nw nx b">Required&lt;T&gt;</code>一样生成所有需要的属性。</p><p id="bf26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="216c" class="oc my it nx b gy od oe l of og">interface User {<br/>  name?: string<br/>  age?: number<br/>  address?: string<br/>}</span><span id="909c" class="oc my it nx b gy oh oe l of og">type UserRequiredName = RequiredByKeys&lt;User, 'name'&gt; <br/>// { name: string; age?: number; address?: string }</span></pre><h1 id="99e1" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">解决办法</h1><p id="7351" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">我们的类型挑战是实现<code class="fe nu nv nw nx b">RequiredByKeys&lt;T, K&gt;</code>泛型，当没有提供<code class="fe nu nv nw nx b">K</code>时，它应该像普通的<code class="fe nu nv nw nx b">Required&lt;T&gt;</code>一样提供所有需要的属性。所以我们先来了解一下<code class="fe nu nv nw nx b">Required&lt;T&gt;</code> generic是做什么的。</p><h2 id="9b1f" class="oc my it bd mz oi oj dn nd ok ol dp nh ld om on nj lh oo op nl ll oq or nn os bi translated">必需的<t/></h2><p id="e4ee" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">构造一个由设置为required的<code class="fe nu nv nw nx b">Type</code>的所有属性组成的类型。偏科的反义词。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6c5078811f5d7fe06098206ffd6b1b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8K5JFRCzwfg2gq_pW3Dacg.jpeg"/></div></div></figure><p id="6460" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nu nv nw nx b">Required&lt;T&gt;</code>是TypeScript的内置实用程序类型，在<code class="fe nu nv nw nx b">typescript/lib/lib.es5.d.ts</code>文件中定义:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="22b2" class="oc my it nx b gy od oe l of og">/**<br/> * Make all properties in T required.<br/> * typescript/lib/lib.es5.d.ts<br/> */<br/>type Required&lt;T&gt; = {<br/>    [P in keyof T]-?: T[P];<br/>};</span></pre><p id="fce1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nu nv nw nx b">Required&lt;T&gt;</code>泛型在内部使用TypeScript的<strong class="kw iu">映射类型</strong>，其语法如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/76de5401a4d68791fe5efa8057d15833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7iuvURZie0JxNSmuAQe94w.jpeg"/></div></div></figure><p id="5ef8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其中<code class="fe nu nv nw nx b">P in K</code>类似于JavaScript <code class="fe nu nv nw nx b">for...in</code>语句，用于遍历类型<code class="fe nu nv nw nx b">K</code>中的所有类型，以及类型变量<code class="fe nu nv nw nx b">T</code>，用于表示TypeScript中的任意类型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/847b91ccf8a6812b306a9bd7f94bd0a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*YK9f_jV3ETabwSDqHUSCmQ.gif"/></div></div></figure><p id="180f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还可以使用附加修饰符只读和问号(？)在映射过程中。通过添加加号(+)和减号(-)前缀来添加和删除相应的修饰符。<strong class="kw iu">如果没有添加前缀，默认使用加号。</strong></p><p id="d251" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">介绍完<strong class="kw iu">映射类型</strong>的相关知识后，实现<code class="fe nu nv nw nx b">RequiredByKeys</code>泛型的思路就很简单了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f19aa77e8cc23852c664c74b1f81b885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zQVBtpUJZPSays_tK-zcXg.jpeg"/></div></div></figure><p id="bb04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从上图可以看出，我们只需要选择与K相关联的属性，根据需要进行设置并生成一个新的对象类型，然后基于剩余的属性构建另一个对象类型，最后使用<code class="fe nu nv nw nx b">&amp;</code>运算符将上述两个对象类型合并成一个新的对象类型。</p><p id="783d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想了解更多关于<strong class="kw iu">路口类型</strong>的信息，可以阅读这篇文章。</p><div class="lr ls gp gr lt lu"><a href="https://javascript.plainenglish.io/using-typescript-intersection-types-like-a-pro-a55da6a6a5f7" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd iu gy z fp lz fr fs ma fu fw is bi translated">像专家一样使用TypeScript交集类型</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">你应该知道的关于TypeScript交集类型的细节——用动画解释。</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="md l"><div class="ou l mf mg mh md mi ks lu"/></div></div></a></div><h2 id="7db3" class="oc my it bd mz oi oj dn nd ok ol dp nh ld om on nj lh oo op nl ll oq or nn os bi translated">完全码</h2><p id="e2c5" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">最后，让我们看看完整的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="c52c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">TypeScript 4.1允许我们使用as子句在映射的类型中重新映射键。其语法如下:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="e2c6" class="oc my it nx b gy od oe l of og">type MappedTypeWithNewKeys&lt;T&gt; = {<br/>    [K in keyof T as NewKeyType]: T[K]<br/>    //            ^^^^^^^^^^^^^<br/>    //            New Syntax！<br/>}</span></pre><p id="0bbb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其中<strong class="kw iu"> NewKeyType </strong>的类型必须是<code class="fe nu nv nw nx b">string | number | symbol</code>联合类型的子类型。<strong class="kw iu">在重新映射键的过程中，我们可以通过返回never类型来过滤键。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6f937513ae72c70f67891892a3987888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fj_Ok76xv7a1m1vtlTXJjQ.jpeg"/></div></div></figure><p id="28e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nu nv nw nx b">Merge</code>类属的作用是合并对象类型。除了以上解决方案，还有一个更简洁的办法。</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="7887" class="oc my it nx b gy od oe l of og">type RequiredByKeys&lt;T, K = keyof T&gt; = Merge&lt;<br/>  T &amp; {<br/>    [P in keyof T as P extends K ? P : never]-?: T[P]<br/>  }<br/>&gt;</span></pre><p id="51b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个挑战涉及的主要知识是TypeScript的<strong class="kw iu">映射类型</strong>。如果您想了解更多关于<strong class="kw iu">映射类型</strong>的信息，您可以阅读以下文章:</p><div class="lr ls gp gr lt lu"><a href="https://javascript.plainenglish.io/using-typescript-mapped-types-like-a-pro-be10aef5511a" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd iu gy z fp lz fr fs ma fu fw is bi translated">像专业人员一样使用TypeScript映射类型</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">映射类型—用动画解释。掌握TypeScript映射类型并理解TypeScript的内置…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="md l"><div class="ox l mf mg mh md mi ks lu"/></div></div></a></div><p id="61b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你有其他的解决方法，可以给我留言。你也可以在<a class="ae lq" href="https://medium.com/@bytefer" rel="noopener"> Medium </a>或<a class="ae lq" href="https://twitter.com/Tbytefer" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，阅读更多关于TS和JS的内容！</p><h1 id="fca5" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">资源</h1><div class="lr ls gp gr lt lu"><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/02759-medium-requiredbykeys/README.md" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd iu gy z fp lz fr fs ma fu fw is bi translated">type-challenges/readme . MD at main type-challenges/type-challenges</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">由jiangshan @jiangshanmeta实现一个通用的RequiredByKeys，它接受两个类型参数T和K。</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">github.com</p></div></div><div class="md l"><div class="oy l mf mg mh md mi ks lu"/></div></div></a></div><div class="lr ls gp gr lt lu"><a href="https://medium.com/frontend-canteen/with-these-articles-you-will-not-be-confused-when-learning-typescript-d96a5c99e229" rel="noopener follow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd iu gy z fp lz fr fs ma fu fw is bi translated">有了这些文章，你在学习TypeScript的时候就不会迷茫了</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">通过生动的动画，让你轻松了解TypeScript的难点和核心知识！不断地…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">medium.com</p></div></div><div class="md l"><div class="me l mf mg mh md mi ks lu"/></div></div></a></div></div></div>    
</body>
</html>