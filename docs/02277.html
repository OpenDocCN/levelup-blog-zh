<html>
<head>
<title>Quicksort: Two Styles Of Implementations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速排序:两种实现风格</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/quicksort-the-history-and-two-styles-of-implementations-f36b9b07d2c8?source=collection_archive---------13-----------------------#2020-03-02">https://levelup.gitconnected.com/quicksort-the-history-and-two-styles-of-implementations-f36b9b07d2c8?source=collection_archive---------13-----------------------#2020-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/091bb75f2360e9affe615ce3ea37445b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mWXkvbEDlO1jHxzY.jpeg"/></div></div></figure><p id="a9f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">快速排序是一种经典、高效的分治排序算法。这在大多数算法教科书中都有解释，但是很少有程序员能够手工完成一个没有错误的实现。如果你不相信，关闭你的浏览器，试一试。</p><p id="3823" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我将解释quicksort是如何工作的，并探索命令式和函数式编程风格的实现之间的差异。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7a4e" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">一点历史</h1><p id="4c30" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">东尼·霍尔在1959年发明了快速排序，并于1961年发表。当东尼·霍尔第一次开发Quicksort时，他认为它太简单了，不能发表，只有在他能够分析它的预期运行时间后，才写了他的经典“Quicksort”论文。</p><p id="277b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">顺便说一下，Algol60是第一个支持递归的编译器，这有助于东尼·霍尔发布第一个版本的代码。</p><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/93aafe6b5606312e59fdff406ebd8eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/0*oQXodshFMkJg91HF.png"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">东尼·霍尔<a class="ae ms" href="https://www.bl.uk/voices-of-science/interviewees/tony-hoare/audio/tony-hoare-inventing-quicksort" rel="noopener ugc nofollow" target="_blank">讲述了</a>1960年在莫斯科时如何想出快速排序计算机排序算法的想法。</figcaption></figure><h1 id="86c4" class="lg lh it bd li lj mt ll lm ln mu lp lq lr mv lt lu lv mw lx ly lz mx mb mc md bi translated">快速排序的工作原理</h1><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/119a444449addb7e66ef61a434df0a47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SPnhU1fqqFDmfYC_.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">图片来源:idea-instructions.com</figcaption></figure><p id="2495" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">快速排序的基本步骤是:</p><ul class=""><li id="ebb6" class="mz na it kd b ke kf ki kj km nb kq nc ku nd ky ne nf ng nh bi translated">如果只有一个元素或没有元素，则完成排序。</li><li id="c1ba" class="mz na it kd b ke ni ki nj km nk kq nl ku nm ky ne nf ng nh bi translated">否则，我们选择一个元素作为轴心，例如最后一个元素。</li><li id="56d7" class="mz na it kd b ke ni ki nj km nk kq nl ku nm ky ne nf ng nh bi translated">将元素与枢轴进行比较，将较小的元素移动到左侧，将较大的元素移动到右侧，然后将枢轴固定到适当的位置</li><li id="3368" class="mz na it kd b ke ni ki nj km nk kq nl ku nm ky ne nf ng nh bi translated">在左子阵列和右子阵列中进行相同的操作。</li></ul><p id="2474" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">快速排序是一种递归算法。复杂度平均为O(N logN)，最坏的情况是O(N^2).</p><p id="3bc6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了避免在实践中出现最坏的情况，我们随机选择支点。</p><h1 id="1eac" class="lg lh it bd li lj mt ll lm ln mu lp lq lr mv lt lu lv mw lx ly lz mx mb mc md bi translated">命令式和函数式编程风格</h1><p id="805f" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">学习不同风格的实现可能有助于<a class="ae ms" href="https://coderscat.com/how-to-learn-data-structures-and-algorithms" rel="noopener ugc nofollow" target="_blank">学习数据结构和算法</a>。</p><p id="4103" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大多数教科书以命令式编程风格描述快速排序。以下代码是Ruby版本:</p><pre class="mk ml mm mn gt nn no np nq aw nr bi"><span id="e41e" class="ns lh it no b gy nt nu l nv nw">def partition(arr, low, high)<br/>  pos = rand(low..high) # random choose pivot<br/>  arr[pos], arr[high] = arr[high], arr[pos]</span><span id="f9ed" class="ns lh it no b gy nx nu l nv nw">  sep = low # index from the low position<br/>  (low..high - 1).each do |j|<br/>    if arr[j] &lt;= arr[high]<br/>      arr[sep], arr[j] = arr[j], arr[sep]<br/>      sep += 1<br/>    end<br/>  end<br/>  arr[sep], arr[high] = arr[high], arr[sep]<br/>  sep<br/>end</span><span id="e141" class="ns lh it no b gy nx nu l nv nw">def quick_sort(arr, low, high)<br/>  if low &lt; high<br/>    pi = partition(arr, low, high)<br/>    quick_sort(arr, low, pi - 1)<br/>    quick_sort(arr, pi + 1, high)<br/>  end<br/>end</span></pre><p id="9cfb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为quicksort是一种递归算法，所以用函数式编程风格来实现它是很自然的。当我第一次在Ruby中看到这一行快速排序时，我震惊了:</p><pre class="mk ml mm mn gt nn no np nq aw nr bi"><span id="49bf" class="ns lh it no b gy nt nu l nv nw">def qsort(a)<br/>  (x=a.pop) ? qsort(a.select { |i| i &lt;= x }) + [x] + qsort(a.select { |i| i &gt; x }) : []<br/>end</span></pre><p id="7ab8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ny nz oa no b">a.select</code>过滤比<code class="fe ny nz oa no b">pivot</code>更小或更大的元素，然后我们用<code class="fe ny nz oa no b">left-subarray + [pivot] + right-subarray</code>构造一个新的数组。如果你懂一门模式匹配的编程语言，那就更简单了。下面是一个Haskell实现:</p><pre class="mk ml mm mn gt nn no np nq aw nr bi"><span id="3f6a" class="ns lh it no b gy nt nu l nv nw">qsort n = case n of<br/> []-&gt;[]<br/> (x:xs)-&gt; qsort[a|a&lt;-xs, a&lt;=x] ++ [x] ++ qsort[a|a&lt;-xs, a&gt;x]</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="54e8" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">差异</h1><p id="d107" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">命令式编程是目前占主导地位的编程范式。</p><p id="4a38" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大多数主流编程语言主要支持命令式编程，如C、Java、Python等。</p><p id="4811" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在命令式编程中，变量用于跟踪程序的当前“状态”。代码的很多部分都在给变量赋值，这将引入一个<a class="ae ms" href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" rel="noopener ugc nofollow" target="_blank">副作用</a>。</p><p id="dde6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有人可能会认为上述命令式版本会执行得更好。因为它不需要不断地分配内存。</p><p id="cc6d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实际上，许多现代编程语言在编译器(或解释器)中实现了函数式编程的优化。</p><p id="31f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们先对以上两个版本做一个基准测试。我们生成100000个随机数作为输入:</p><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/de7c396fa7415a32851299f6b34dd806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KD1mp1xdk_X6Ul25.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">按作者</figcaption></figure><p id="763b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有点意外，功能版比命令版表现更好。</p><h1 id="ae9b" class="lg lh it bd li lj mt ll lm ln mu lp lq lr mv lt lu lv mw lx ly lz mx mb mc md bi translated">其他优化</h1><p id="8f06" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">看基准测试的结果，Ruby的内置排序有多快！</p><p id="bdde" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae ms" href="https://github.com/ruby/ruby/blob/c5eb24349a4535948514fe765c3ddb0628d81004/util.c#L375" rel="noopener ugc nofollow" target="_blank"> Ruby的Qsort </a>差不多有150行C代码，类似于GNU的版本。</p><p id="7ee4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有一些其他的优化变体，<a class="ae ms" href="https://epubs.siam.org/doi/abs/10.1137/1.9781611973198.6" rel="noopener ugc nofollow" target="_blank">kusha gra-Ortiz-Qiao-Munro</a>是quicksort的三支点变体。</p><p id="1764" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae ms" href="https://algs4.cs.princeton.edu/23quicksort/" rel="noopener ugc nofollow" target="_blank">算法，罗伯特·塞奇威克和凯文·韦恩</a>用一些精彩的插图描述得很好。</p><p id="aa5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae ms" href="http://typeocaml.com/2015/01/02/immutable/" rel="noopener ugc nofollow" target="_blank">typeacml</a>以quicksort为例展示了函数式编程的“不可变”。</p></div></div>    
</body>
</html>