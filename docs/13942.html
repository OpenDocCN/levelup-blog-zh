<html>
<head>
<title>Python: Object-Oriented Programming Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python:面向对象编程第2部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-object-oriented-programming-part-2-f8d17757efa8?source=collection_archive---------12-----------------------#2022-10-18">https://levelup.gitconnected.com/python-object-oriented-programming-part-2-f8d17757efa8?source=collection_archive---------12-----------------------#2022-10-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="287a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们讨论继承、静态/类方法、封装</h2></div><p id="892b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之前我们谈到了什么是类和对象，它们是如何使用的，以及为什么我们应该使用它们。本文将介绍更多的概念，这些概念在处理继承、属性修饰、静态/类方法、超类和私有/公共方法等类时非常重要。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi li"><img src="../Images/7ff734dbb6387f1b1987733767b054c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2chKKCELA9SfG-7o"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated"><a class="ae ly" href="https://unsplash.com/photos/YJdCZba0TYE" rel="noopener ugc nofollow" target="_blank">图片</a>由<a class="ae ly" href="https://unsplash.com/@dylandgillis" rel="noopener ugc nofollow" target="_blank">迪伦·吉利斯</a>拍摄</figcaption></figure><h2 id="9b0f" class="lz ma iq bd mb mc md dn me mf mg dp mh ko mi mj mk ks ml mm mn kw mo mp mq mr bi translated">目录:</h2><ul class=""><li id="2bf8" class="ms mt iq kh b ki mu kl mv ko mw ks mx kw my la mz na nb nc bi translated">继承/超类</li><li id="cab3" class="ms mt iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated">属性、静态和类方法</li><li id="4c8b" class="ms mt iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated">包装</li><li id="efd1" class="ms mt iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated">魔术/邓德方法</li><li id="4dc2" class="ms mt iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated">结论</li></ul><h2 id="c571" class="lz ma iq bd mb mc md dn me mf mg dp mh ko mi mj mk ks ml mm mn kw mo mp mq mr bi translated">继承和超类:</h2><p id="31c0" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">既然我们已经介绍了如何创建和设置类、__init__、属性和方法，</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi nl"><img src="../Images/98ad0787071f774ab608ff86d457c2d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_3SYHxDcAcsmZ98m.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">作者图片</figcaption></figure><p id="1f56" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来谈谈继承。如果我们想创建一个新的职业来帮助我们的怪物职业获得一些统计数据，这样它就可以肆虐了。现在是实现子类的好时机。这个想法是，它可以从父类Monster继承所有的属性和方法，并在我们的Monster_Stats子类中访问它们。现在当我们创建我们的Monster_Class对象时，定义我们的Monster的背景信息(名字、物种、身高、体重和位置)所需的所有属性都将由我们的Monster类的构造函数初始化。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi nm"><img src="../Images/a6f10619704fb18d5dd564c46d299bc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nHFbMf16H6aqp5NyZXgmBQ.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">作者图片</figcaption></figure><p id="9fa4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—首先，我们从我们的<code class="fe nn no np nq b">create_monster.py</code>模块导入我们的Monster类。</p><p id="76fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—在这里，我们像任何普通的类一样定义我们的子类，增加了一些额外的东西。我们仍然在Monster_Stats子类的参数中添加来自我们的父Monster类的属性。</p><p id="5ce7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—现在，当我们用它的统计数据创建新的怪物对象时，它将使用我们的怪物父类init来初始化名称、物种、高度、重量和位置。</p><p id="3a46" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—因此，本质上，一旦我们使用Monster类创建了Monster对象，我们就使用MonsterStats类为该Monster对象提供统计信息。</p><h2 id="1d10" class="lz ma iq bd mb mc md dn me mf mg dp mh ko mi mj mk ks ml mm mn kw mo mp mq mr bi translated">属性、静态方法和类方法:</h2><p id="631e" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated"><strong class="kh ir">属性方法:</strong> <br/>属性装饰器在你的类中的方法之上用一个<code class="fe nn no np nq b">@property</code>来表示。它允许您像访问类属性一样访问这些方法。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi nr"><img src="../Images/9344453893d19b4ce5f2a8d525351bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0qFvnNw-3aF4wQEPcngBTg.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">作者图片</figcaption></figure><p id="aa76" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—这里我们有MonsterSuper类中的monster_stats方法，它显示攻击和防御能力。</p><p id="cfb4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—如果我们要在没有<code class="fe nn no np nq b">@property</code>装饰器的情况下打印它，那么我们将不得不像这样编写这个调用，<code class="fe nn no np nq b">print(obelisk.monster_stats())</code>，因为它声明了一个方法，但是添加<code class="fe nn no np nq b">@property</code>装饰器允许我们像访问类属性一样访问这个方法。</p><p id="8b38" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">静态方法:<br/> </strong>静态方法用<code class="fe nn no np nq b">@staticmethod</code>装饰器表示，位于指定方法之上。它们被绑定到类而不是实例对象，也不需要使用实例对象。静态方法可以通过类本身来访问。但是它们是有限的，因为它们不能访问那个类的类属性，或者那个类的类对象，因为我们没有自己的或者访问那些类属性的权限。简单地说，静态方法对它所在的类一无所知，只使用给它的参数。把它想象成一个普通的python函数，就在一个类内部。要调用它，必须首先使用类名，然后使用静态方法本身。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi ns"><img src="../Images/7b746e2108386d79acbb38c53ada102f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oSoYfjFFdqAAV-CoGkRwdA.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">作者图片</figcaption></figure><p id="0995" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—这里我们有MonsterSuper类，我们在其中确定怪物的状态。</p><p id="8be5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—在MonsterSuper类中，我们有monster_super_tier静态方法。这种方法是用来根据我们的怪物的攻击力来确定它们是否在“超级等级”中。不是最详细的例子，但我赤裸裸的。这里我们使用方尖碑的攻击力作为输入，因此得到了他确实在超级怪物等级的回报。</p><p id="b6b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—我们使用MonsterSuper类调用monster_super_tier静态方法，而不是我们的类对象Obelisk。</p><p id="265c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">类方法(cls): </strong> <br/>用<code class="fe nn no np nq b">@classmethod</code>装饰符表示的类方法，在指定方法的顶部，允许你在所有对象中更新你的类变量的默认值。就像实例方法接收实例作为初始参数一样，类方法接收类作为第一个参数。这方面的一个例子是，如果我们想在超级怪物被创造出来的时候记录它们的数量。我们可以使用类和类对象来访问这些方法。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi nt"><img src="../Images/697af99c4ea41e29eb6f5da7398ea871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mo7xDy9aICnt_K7wa55Y4Q.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">作者图片</figcaption></figure><p id="5ba2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—这里的super_monster_count是一个属于MonsterSuper类的变量。</p><p id="023b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—在我们的__init__方法中，当我们创建新的monster对象时，我们调用<code class="fe nn no np nq b">up_count</code>方法来增加计数。</p><p id="1585" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—我们调用类方法<code class="fe nn no np nq b">get_count_num</code>三次。我们第一次调用类本身来访问这个类方法。第二次和第三次我们使用我们的obelisk和slifer类对象来访问类方法。因此，我们有0，1，2分别代表MonsterSuper类，方尖碑，和slifer。</p><h2 id="0324" class="lz ma iq bd mb mc md dn me mf mg dp mh ko mi mj mk ks ml mm mn kw mo mp mq mr bi translated">封装:</h2><p id="9b89" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">允许您对类属性/方法进行限制，以防止数据被修改。它阻止改变的方法是只允许objects变量被class方法单独改变。这意味着属性不能通过改变类外的值来改变，就像你通常更新一个对象的属性一样。</p><p id="a6bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">私有成员:<br/> </strong>私有成员是私有属性和/或方法，只能在类内部访问和更新。建议不要在类操作之外使用这些变量。这可以防止意外修改您不想修改的数据，也是隐藏您不想公开的类的内部功能的好方法。您可以通过在声明方法名之前使用_来指明在一个类中哪些方法应该是私有的，就像这样，<code class="fe nn no np nq b">__methodname</code>(确保在方法名之前使用双下划线)。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi nu"><img src="../Images/43f820ce1141192547b91048620f259e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iJ--YOs2MFg3_T51O-vDgw.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">作者图片</figcaption></figure><p id="f07c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—这里我们试图访问我们类中的私有monster方法，但是Python抛出了一个错误，因为我们的<code class="fe nn no np nq b">__privatemonster</code>方法是一个私有方法。</p><p id="1dd6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">公共成员:<br/> </strong>表示普通类中使用的公共属性和方法结构，在这里也可以在类外访问它们。</p><h2 id="9c02" class="lz ma iq bd mb mc md dn me mf mg dp mh ko mi mj mk ks ml mm mn kw mo mp mq mr bi translated"><strong class="ak">魔法/邓德方法:</strong></h2><p id="edba" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">方法名的两端都有下划线，就像我们的<code class="fe nn no np nq b">__init__</code>方法。如你所见，邓德代表双下划线。通常用于重载类中的运算符。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi nv"><img src="../Images/4f66856d495a0f96ed51f7ac2d57996c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9UggAcNKPvotJUrKjvrwSQ.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">作者图片</figcaption></figure><p id="a883" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—正如您所看到的，当我们打印出对象而没有在类中初始化__repr__函数时，python只打印对象在内存中的位置。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi nv"><img src="../Images/faff7dd552bd0005901d5bad97399ba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3i5Nj76qhqH6mzIVQmSczw.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">作者图片</figcaption></figure><p id="eac0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—当打印初始化了__repr__函数的函数时，我们只能根据__repr__函数的构建方式获得实际的可读返回。在这种情况下得到怪物的名字和它的攻击力。</p><h2 id="a8cd" class="lz ma iq bd mb mc md dn me mf mg dp mh ko mi mj mk ks ml mm mn kw mo mp mq mr bi translated">结论:</h2><p id="3068" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">使用子类、封装、静态/类和私有/公共方法增加了额外的复杂性，但是允许用户/团队创建可以更有效地扩展的生产级代码。是的，同样的应用程序可以用函数式编程方法来开发，但是这会增加开发时间，看起来更加混乱，更加没有条理，并且会给你的应用程序增加更多的代码行。我知道我用了一些权力的游戏和Yugioh作为我的“怪物”例子的灵感，但我想让事情变得更有趣一点，并作为对创作者高桥和希，瑞普的敬意。希望你们喜欢这些内容。请鼓掌，分享，评论，关注，快乐编码！</p><p id="7f05" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">相关内容:</strong></p><ul class=""><li id="9226" class="ms mt iq kh b ki kj kl km ko nw ks nx kw ny la mz na nb nc bi translated"><a class="ae ly" rel="noopener ugc nofollow" target="_blank" href="/python-object-oriented-programming-part-1-e9ea12ba1936"> Python:面向对象编程第1部分</a></li></ul></div></div>    
</body>
</html>