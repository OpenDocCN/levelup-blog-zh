<html>
<head>
<title>Hierarchical Tree Form Data Structure in .NET C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">层次树形数据结构。NET C#</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/hierarchical-tree-form-data-in-net-c-d2a868fcb756?source=collection_archive---------3-----------------------#2021-12-02">https://levelup.gitconnected.com/hierarchical-tree-form-data-in-net-c-d2a868fcb756?source=collection_archive---------3-----------------------#2021-12-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="b9ba" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">提示和技巧</h2><div class=""/><div class=""><h2 id="5e47" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">为分层树形数据及其相关操作设计一个数据结构。NET C#</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/60053a226e91a2a03f8a9efa18872785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bOokbEeXpF1Z4gd_BpL93w.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae lh" href="https://unsplash.com/@veeterzy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> veeterzy </a>拍摄，<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><p id="c070" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有时你会发现自己需要处理<strong class="lk jd">层次树形</strong>数据。简单地说，这是呈现在<strong class="lk jd">父子</strong>节点中的数据。</p><p id="2cf5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，您有时可能会与实现的复杂性作斗争，尤其是在处理大量数据时。</p><p id="806c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我将为您提供这种情况下的一种可能的设计。然而，您需要记住，像往常一样，拥有一个通用的设计可以提供抽象的功能，但是它可能缺乏针对特定场景的特定增强。</p><p id="9fa1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我建议您将本文中的设计作为一个开放思维的工具。你需要研究它，从中学习，从中获得一些想法，并最终使它适应你自己的需要。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="5109" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">主要目标</h1><p id="f51a" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">这是本设计的主要目标:</p><ol class=""><li id="b801" class="nc nd it lk b ll lm lo lp lr ne lv nf lz ng md nh ni nj nk bi translated">将分层数据表示成树形数据结构。</li><li id="dcc2" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">具有独立创建节点的能力。</li><li id="f474" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">具有连接和分离节点的能力。</li><li id="5af2" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">具有搜索具有适当性能的节点的能力。</li><li id="05c4" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">不要失去强类型数据的优势。</li></ol><p id="04ee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，在设计过程中，我们需要牢记这些要求。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><div class="nq nr gp gr ns nt"><a href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener follow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd jd gy z fp ny fr fs nz fu fw jc bi translated">🔥订阅艾哈迈德的时事通讯🔥</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">订阅艾哈迈德的时事通讯📰直接获得最佳实践、教程、提示、技巧和许多其他很酷的东西…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">medium.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh lb nt"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="8386" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">设计</h1><p id="8bb7" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">首先，我们需要记住，数据本身可以是任何业务实体。然而，层级结构是另外一回事。这是控制节点之间关系的结构，如何添加，如何删除，如何搜索等等。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h2 id="8208" class="oi mg it bd mh oj ok dn ml ol om dp mp lr on oo mr lv op oq mt lz or os mv iz bi translated">有效载荷</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="27ce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在这里可以注意到:</p><ol class=""><li id="42d4" class="nc nd it lk b ll lm lo lp lr ne lv nf lz ng md nh ni nj nk bi translated">这是主要的实体，代表要包装到我们的层次结构中的业务实体。</li><li id="317b" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">我们没有在这里添加任何成员，但可以肯定的是，如果你认为这是你所有业务实体之间的共同之处，你可以添加一些。</li></ol></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><h2 id="1a78" class="oi mg it bd mh oj ok dn ml ol om dp mp lr on oo mr lv op oq mt lz or os mv iz bi translated">节点类型</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="3b57" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在这里可以注意到:</p><ol class=""><li id="58b1" class="nc nd it lk b ll lm lo lp lr ne lv nf lz ng md nh ni nj nk bi translated">这是表示节点类型的枚举。</li><li id="e9ab" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">我们只有两种节点类型；<strong class="lk jd">结构</strong>和<strong class="lk jd">叶片</strong>。</li><li id="39c7" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated"><strong class="lk jd">结构</strong>节点是只提供层次结构信息的节点。简而言之，它就像一个文件夹或节点，其中会有子节点。</li><li id="1b32" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated"><strong class="lk jd">叶</strong>节点是只提供业务数据的节点。简而言之，它是包装数据的节点，不会有任何子节点。</li></ol></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><h2 id="25a3" class="oi mg it bd mh oj ok dn ml ol om dp mp lr on oo mr lv op oq mt lz or os mv iz bi translated">信息节点</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="18ca" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在这里可以注意到:</p><ol class=""><li id="d4eb" class="nc nd it lk b ll lm lo lp lr ne lv nf lz ng md nh ni nj nk bi translated">这是表示任何节点的公共成员的接口，无论它是<strong class="lk jd">结构</strong>还是<strong class="lk jd">叶</strong>。</li><li id="b864" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated"><code class="fe pc pd pe pf b">Id</code>是节点的唯一标识符。这应该是绝对独特的。我把它实现为一个字符串，但是你可以根据自己的需要自由地修改它。</li><li id="a730" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated"><code class="fe pc pd pe pf b">Name</code>是节点的名称。这应该在某个时候用于表示层。</li><li id="a810" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated"><code class="fe pc pd pe pf b">PathPart</code>是用来表示节点路径的名称。</li><li id="74f7" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated"><code class="fe pc pd pe pf b">Parent</code>是父节点。它的类型是<code class="fe pc pd pe pf b">IStructuralNode</code>，因为它不可能是<strong class="lk jd">叶子</strong>，因为<strong class="lk jd">叶子永远不会有孩子</strong>。</li></ol></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><h2 id="171b" class="oi mg it bd mh oj ok dn ml ol om dp mp lr on oo mr lv op oq mt lz or os mv iz bi translated">结构节点</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="7bce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在这里可以注意到:</p><ol class=""><li id="72ba" class="nc nd it lk b ll lm lo lp lr ne lv nf lz ng md nh ni nj nk bi translated">我们定义了委托<code class="fe pc pd pe pf b">ChildNodeAddedEventHandler</code>来表示一个事件的处理程序，当一个节点作为子节点被添加到另一个节点下时，该事件将被触发。</li><li id="8e68" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">我们还定义了委托<code class="fe pc pd pe pf b">ChildNodeRemovedEventHandler</code>来表示一个事件的处理程序，当一个节点从另一个节点的子节点中移除时，该事件将被触发。</li><li id="e8d0" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">我们定义了扩展<code class="fe pc pd pe pf b">INode</code>的<code class="fe pc pd pe pf b">IStructuralNode</code>接口。</li><li id="2666" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">它有两个事件；<code class="fe pc pd pe pf b">ChildNodeAdded</code>和<code class="fe pc pd pe pf b">ChildNodeRemoved</code>。</li><li id="6bd7" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">它有一个只读的子节点集合。</li><li id="ee31" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">它的节点类型默认为<strong class="lk jd">结构</strong>。</li><li id="65d8" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">它有一个添加子元素的方法。</li><li id="1bbf" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">它有一个移除子对象的方法。</li><li id="3363" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">它还有一个返回所有嵌套子节点的平面集合的方法。</li></ol></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><h2 id="ed4e" class="oi mg it bd mh oj ok dn ml ol om dp mp lr on oo mr lv op oq mt lz or os mv iz bi translated">ILeafNode和ILeafNode <tpayload/></h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="a1ff" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在这里可以注意到:</p><ol class=""><li id="978c" class="nc nd it lk b ll lm lo lp lr ne lv nf lz ng md nh ni nj nk bi translated"><code class="fe pc pd pe pf b">ILeafNode</code>是<code class="fe pc pd pe pf b">INode</code>的延伸。</li><li id="85c5" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">它具有属性<code class="fe pc pd pe pf b">Payload</code>，该属性返回类型<code class="fe pc pd pe pf b">Payload</code>的包装数据。</li><li id="194e" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">它隐藏父<code class="fe pc pd pe pf b">Type</code>并默认为<strong class="lk jd">叶</strong>。</li><li id="3682" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated"><code class="fe pc pd pe pf b">ILeafNode&lt;out TPayload&gt;</code>隐藏父<code class="fe pc pd pe pf b">Payload</code>并定义一个类型化的。</li></ol></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><h2 id="3661" class="oi mg it bd mh oj ok dn ml ol om dp mp lr on oo mr lv op oq mt lz or os mv iz bi translated">结节</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="733a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在这里可以注意到:</p><ol class=""><li id="4040" class="nc nd it lk b ll lm lo lp lr ne lv nf lz ng md nh ni nj nk bi translated">它执行<code class="fe pc pd pe pf b">INode</code>。</li><li id="7ca1" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">实现很简单。</li><li id="c798" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">如果你愿意，你可以扩展这个来实现<code class="fe pc pd pe pf b">IEquatable&lt;Node&gt;</code>。</li><li id="4d2c" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">我们还允许用户通过<code class="fe pc pd pe pf b">Parent</code>属性直接设置<strong class="lk jd">父</strong>。然而，实现被委托给了<code class="fe pc pd pe pf b">AddChild</code>和<code class="fe pc pd pe pf b">RemoveChild</code>方法。</li></ol></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><h2 id="f12b" class="oi mg it bd mh oj ok dn ml ol om dp mp lr on oo mr lv op oq mt lz or os mv iz bi translated">叶节点<tpayload/></h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="b58e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在这里可以注意到:</p><ol class=""><li id="8a7b" class="nc nd it lk b ll lm lo lp lr ne lv nf lz ng md nh ni nj nk bi translated">它继承了<code class="fe pc pd pe pf b">Node</code>并实现了<code class="fe pc pd pe pf b">ILeafNode&lt;TPayload&gt;</code>。</li><li id="5c3e" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">这里值得一提的是，在构造函数实现中，如果设置了父类，我们调用父类上的<code class="fe pc pd pe pf b">AddChild</code>传入<code class="fe pc pd pe pf b">this</code>。</li></ol></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><h2 id="d812" class="oi mg it bd mh oj ok dn ml ol om dp mp lr on oo mr lv op oq mt lz or os mv iz bi translated">结构节点</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="8ecd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在分析这段代码之前，我们需要了解它是如何工作的。</p><p id="d85d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我们所说的，节点应该能够被孤立地创建。这意味着最终用户应该能够在不设置任何父节点甚至子节点的情况下创建节点。</p><p id="fd1c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那么他应该能够将这个节点作为子节点附加到另一个节点。此外，他应该能够将其他节点作为子节点附加到该节点的子节点，…等等。</p><p id="9b48" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于所有这些操作，我们的代码应该保持节点之间的结构和关系不变。</p><p id="4e56" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，我们希望使搜索节点变得容易。一种特殊情况是按Id搜索。这应该是我们最快的速度。</p><p id="71ae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，记住这一点，让我们分析代码。</p><p id="2bf7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在这里可以注意到:</p><ol class=""><li id="6155" class="nc nd it lk b ll lm lo lp lr ne lv nf lz ng md nh ni nj nk bi translated">在构造函数中，如果设置了一个子集合，我们调用<code class="fe pc pd pe pf b">AddChild</code>方法传递子集合的每个子集合。</li><li id="5348" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">同样，如果设置了父节点，我们调用父节点上的<code class="fe pc pd pe pf b">AddChild</code>并传入<code class="fe pc pd pe pf b">this</code>。</li><li id="38fc" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">为了便于搜索节点，我们定义了<code class="fe pc pd pe pf b">Dictionary&lt;string, INode&gt; m_Catalog</code>。这是一个目录，其中保存了对当前节点下所有节点的引用，甚至是嵌套节点。</li><li id="31ba" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">为了保持该目录始终同步，当前节点在添加每个直接子节点时订阅它们的<code class="fe pc pd pe pf b">ChildNodeAdded</code>和<code class="fe pc pd pe pf b">ChildNodeRemoved</code>事件。</li><li id="3bdd" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">遵循同样的规则，当前节点在每个直接子节点被移除的时刻取消订阅每个直接子节点的<code class="fe pc pd pe pf b">ChildNodeAdded</code>和<code class="fe pc pd pe pf b">ChildNodeRemoved</code>事件。</li><li id="5cd8" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">此外，我们需要记住，无论何时将一个节点作为直接子节点添加到当前节点，该节点都可能有其他嵌套子树。在这种情况下，当前目录也必须用该子树的所有嵌套子树进行更新。</li><li id="d24f" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">那么，说到这里，我们来看看<code class="fe pc pd pe pf b">AddChild(INode child)</code>的实现。</li><li id="0092" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">在将新子节点附加到当前节点的新父节点之前，确保新子节点与其旧父节点分离。</li><li id="e9fe" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated"><code class="fe pc pd pe pf b">m_Catalog.Add(child.Id, child);</code>将新的子项添加到目录中。</li><li id="33d9" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated"><code class="fe pc pd pe pf b">m_Children.Add(child);</code>将孩子添加到<code class="fe pc pd pe pf b">Children</code>集合中。</li><li id="22ef" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated"><code class="fe pc pd pe pf b">OnDirectChildNodeAdded(child);</code>触发<code class="fe pc pd pe pf b">ChildNodeAdded</code>事件，通知直接父节点添加了一个新的子节点，最终新的更新将应用到它的目录中。</li><li id="47fd" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">然后我们检查新的子节点是否是一个<strong class="lk jd">结构</strong>节点，因为在这种情况下我们需要监听可能应用于它的变化。</li><li id="e1bc" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">因此，如果这是真的，我们循环新的子元素的平面子元素，将它们一个接一个地添加到当前目录中，并触发<code class="fe pc pd pe pf b">ChildNodeAdded</code>事件，但是这次使用了<code class="fe pc pd pe pf b">node</code>和<code class="fe pc pd pe pf b">added</code>参数的正确值。这样做也是为了向直接父节点通知嵌套更新。请注意，直接父节点也会这样做，并通知其直接父节点，…等等。</li><li id="ab83" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">正如我们所说的，当前节点应该订阅新子节点的<code class="fe pc pd pe pf b">ChildNodeAdded</code>和<code class="fe pc pd pe pf b">ChildNodeRemoved</code>事件，以便它总是被更新。这是我们在<code class="fe pc pd pe pf b">structuralNode.ChildNodeAdded += AddHandler;</code>和<code class="fe pc pd pe pf b">structuralNode.ChildNodeRemoved += RemoveHandler;</code>上做的事情。</li><li id="75f0" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated"><code class="fe pc pd pe pf b">child.Parent = this;</code>将子节点的父节点设置为当前节点。</li><li id="66b4" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">现在，让我们来看看<code class="fe pc pd pe pf b">RemoveChild(INode child)</code>的实现。</li><li id="c531" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated"><code class="fe pc pd pe pf b">m_Catalog.Remove(child.Id);</code>从目录中删除子项。</li><li id="c059" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated"><code class="fe pc pd pe pf b">m_Children.Remove(child);</code>从<code class="fe pc pd pe pf b">Children</code>集合中删除子元素。</li><li id="21d0" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated"><code class="fe pc pd pe pf b">OnDirectChildNodeRemoved(child);</code>触发<code class="fe pc pd pe pf b">ChildNodeRemoved</code>事件以通知直接父节点一个子节点被移除，最终新的更新将应用于其目录。</li><li id="1f3c" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">然后，我们检查新的子节点是否是一个<strong class="lk jd">结构</strong>节点，因为在这种情况下，我们需要监听可能应用于它的更改。</li><li id="c925" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">因此，如果这是真的，我们循环这个孩子的扁平孩子，从当前目录中一个接一个地删除他们，并且也触发<code class="fe pc pd pe pf b">ChildNodeRemoved</code>事件，但是这一次使用<code class="fe pc pd pe pf b">node</code>和<code class="fe pc pd pe pf b">added</code>参数的适当值。这样做也是为了向直接父节点通知嵌套更新。请注意，直接父节点也会这样做，并通知其直接父节点，…等等。</li><li id="e380" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">我们说过，当前节点应该取消订阅要删除的子节点的<code class="fe pc pd pe pf b">ChildNodeAdded</code>和<code class="fe pc pd pe pf b">ChildNodeRemoved</code>事件。这就是我们在<code class="fe pc pd pe pf b">structuralNode.ChildNodeAdded -= AddHandler;</code>和<code class="fe pc pd pe pf b">structuralNode.ChildNodeRemoved -= RemoveHandler;</code>做的事情。</li><li id="6fe0" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated"><code class="fe pc pd pe pf b">child.Parent = null;</code>将父项重置为空。</li></ol><p id="f5ea" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我知道这部分很难，但是，如果你再看一遍，你会发现它并不复杂。</p></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><h2 id="e055" class="oi mg it bd mh oj ok dn ml ol om dp mp lr on oo mr lv op oq mt lz or os mv iz bi translated">树形导航器</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="b6b0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就像一个<strong class="lk jd"> Helper </strong>类，它提供了额外的功能，比如搜索节点、评估完整路径、查找节点深度等等。</p><p id="1cf8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在内部，它很好地利用了我们在节点类中定义的定义良好的结构。</p><p id="4c3c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我没有抽象这个类，但是你可以这样做，你可以根据你的需要扩展它的功能。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pg"><img src="../Images/e0aced1bcec82fe33e92db5d56920ca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TpsvHImb6SvWSR41n5N5MA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@elishaterada?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Elisha Terada </a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="09f9" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">最后的话</h1><p id="e6c1" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">我本来打算编写一个示例应用程序来向您展示我们的设计是多么高效，但是，经过重新考虑之后，我决定将它留给您作为一个练习。</p><p id="635f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，我知道当你看到这个设计时，你可能会觉得它太难理解了。然而，你首先需要记住这项工作有多复杂。</p><p id="a582" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我在开头所说的，你需要把这篇文章中的设计作为一个思想开放器，给它一些思考，从中学习，放弃你不需要的，适应它，增强它，最后开始使用它。这永远是学习和获得新技能的正确方法。</p><p id="0ae7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就这样，希望你觉得读这个故事和我写它一样有趣。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h2 id="66a2" class="oi mg it bd mh oj ok dn ml ol om dp mp lr on oo mr lv op oq mt lz or os mv iz bi translated">希望这些内容对你有用。如果您想支持:</h2><p id="7e48" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">如果您还不是<strong class="lk jd">中型</strong>会员，您可以使用<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek/membership" rel="noopener"> <strong class="lk jd">我的推荐链接</strong> </a>，这样我就可以从<strong class="lk jd">中型</strong>中获得您的一部分费用，您无需支付任何额外费用。订阅<br/><a class="ae lh" href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener"><strong class="lk jd">我的简讯</strong> </a>将最佳实践、教程、提示、技巧和许多其他很酷的东西直接发送到您的收件箱。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="c976" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">其他资源</h1><p id="e1d2" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">这些是你可能会发现有用的其他资源。</p><div class="nq nr gp gr ns nt"><a rel="noopener  ugc nofollow" target="_blank" href="/when-implementations-affect-abstractions-1bb2adc808d1"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd jd gy z fp ny fr fs nz fu fw jc bi translated">当实现影响抽象时</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">关于实现的知识会影响抽象设计吗？</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oc l"><div class="ph l oe of og oc oh lb nt"/></div></div></a></div><div class="nq nr gp gr ns nt"><a rel="noopener  ugc nofollow" target="_blank" href="/web-scraping-in-net-c-934d6a85c32e"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd jd gy z fp ny fr fs nz fu fw jc bi translated">网页抓取。NET C#</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">如何在DotNet中进行网页抓取的指南(。NET) CSharp (C#)，附带代码示例。</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oc l"><div class="pi l oe of og oc oh lb nt"/></div></div></a></div><div class="nq nr gp gr ns nt"><a rel="noopener  ugc nofollow" target="_blank" href="/builder-design-pattern-in-net-c-bbf11c891548"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd jd gy z fp ny fr fs nz fu fw jc bi translated">中的生成器设计模式。NET C#</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">一步一步的指南，从零开始开发一个流畅的API。NET C#使用生成器设计模式。</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oc l"><div class="pj l oe of og oc oh lb nt"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure></div></div>    
</body>
</html>