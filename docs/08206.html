<html>
<head>
<title>AWS CDK Pipelines: Real-World Tips and Tricks (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS CDK管道:真实世界的提示和技巧(第2部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/aws-cdk-pipelines-real-world-tips-and-tricks-part-2-7a0d093a89a0?source=collection_archive---------1-----------------------#2021-04-11">https://levelup.gitconnected.com/aws-cdk-pipelines-real-world-tips-and-tricks-part-2-7a0d093a89a0?source=collection_archive---------1-----------------------#2021-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/617ad0247b0fbf62533f4006942e1733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2lOyTvYS-lYwwj34"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">罗曼·彭丁在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ddc2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">在本文中，我将与您分享一些使用AWS CDK管道的有用提示和技巧，这些提示和技巧超越了简单的演示，可以在您的实际应用程序中实现。这是我关于AWS CDK管道系列的第二篇文章。走</em> <a class="ae kc" href="https://medium.com/swlh/aws-cdk-pipelines-real-world-tips-and-tricks-part-1-544601c3e90b" rel="noopener"> <em class="lb">这里</em> </a> <em class="lb">为第一个。</em></p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="aa49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">AWS云开发工具包(<a class="ae kc" href="https://docs.aws.amazon.com/cdk/latest/guide/home.html" rel="noopener ugc nofollow" target="_blank"> AWS CDK </a>)是一个强大的开源开发框架，用于创建和部署云应用资源，可以被视为一个<em class="lb">基础设施即代码</em>工具。AWS CDK管道是这个框架中的一个库，它通过我称之为<em class="lb">自变异管道代码将基础设施自动化带到了一个新的水平。</em>这样的CDK管道包含应用程序代码<em class="lb">、</em>相应的<em class="lb">代码管道</em>，应用程序的云基础设施，以及<em class="lb">基础设施管道</em>，全部由代码定义，并且能够自动适应自身。在本系列的<a class="ae kc" href="https://medium.com/swlh/aws-cdk-pipelines-real-world-tips-and-tricks-part-1-544601c3e90b" rel="noopener">上一篇文章</a>中可以找到关于CDK和管道的更深入的介绍。</p><p id="8c45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目前，CDK管道公司仍处于开发者预览阶段，但是大量的团队和人员已经跳上了创新的快车。然而，由于它仍处于测试阶段，开发团队和社区都还没有很好地定义最佳实践。因此，我想与您分享一些我在几个CDK管道应用程序(在生产中运行)中总结的技巧和诀窍。)目前的工作。</p><p id="8581" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与第一篇文章类似，接下来的部分都回答了我的一个具体问题——很可能你也会回答。所有部分都遵循简单的格式“<strong class="kf ir">我该怎么做<em class="lb">这个？</em></strong>又可以认为是单机。它们不是按时间顺序排列的，也没有解释CDK管道的基本情况。没有一个章节描述特定问题的唯一解决方案，而是基于个人和专业经验的<em class="lb">解决方案。与第一篇文章不同的是，这篇文章将使用Python作为开发语言，而不是TypeScript，因为我和其他开发人员更喜欢Python。因此，在第一个CDK管道应用程序之后，我们转换了语言。然而，CDK管道问题的解决方案是跨语言的，无论您使用哪种CDK开发语言，都将使您受益。</em></p><p id="5af4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">免责声明:随着CDK开发团队高速扩展CDK库，并包括突破性的变化，一些细节可能不会完全按照您阅读本文时的方式工作。</em></p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="327e" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">如何管理所有环境的配置？</h1><p id="fed0" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">结构化配置总是一件困难的事情。我甚至在第一篇文章中避免了它，因为我自己还没有想出一个好的方法。但是现在我对我的方法很满意。</p><p id="b352" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">配置在两个级别上定义和管理:</p><ol class=""><li id="5041" class="mm mn iq kf b kg kh kk kl ko mo ks mp kw mq la mr ms mt mu bi translated">原始配置文件</li><li id="3bac" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">通过处理原始配置文件创建的配置对象</li></ol><p id="3ce3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您希望跨多个CDK管道应用程序标准化配置，还有第三个级别，我将参考“<em class="lb">如何管理跨CDK应用程序的配置”一节。</em></p><p id="f62e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">原始配置文件</strong></p><p id="6500" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我区分两种类型的配置。影响AWS环境中资源的配置和影响CDK应用程序本身的配置。因此，原始配置文件由这两部分组成，以及<em class="lb">应用</em>部分和<em class="lb">环境</em>部分。这是此类文件的高级结构:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">配置文件的高层结构。</figcaption></figure><p id="2c66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">应用程序部分包含应用程序的名称、它正在监视的git存储库、中央AWS构建环境的帐户和区域、CDK库的版本……环境部分包含每个<em class="lb">应用程序环境</em>的部分，例如开发、试运行和生产，不要与AWS环境混淆，AWS环境是帐户+区域的组合。在本例中，它还包含一个默认环境部分，该部分指定了所有环境的默认行为，除非在相应的部分中被显式覆盖。这不是必需的，您可以选择不包括这一部分。至少，每个环境部分需要包含资源必须部署到的客户和区域。此外，这还可以包含项目特定资源的配置(例如，存储段名称、自动缩放组详细信息、标准资源标签等)。<br/>此类文件的示例如下所示:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">配置文件的更详细的例子。</figcaption></figure><p id="5b3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">从原始配置文件创建的配置对象</strong></p><p id="0b37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就像配置文件一样，通过定义两个配置类来区分应用程序和资源配置。一个<code class="fe ng nh ni nj b">AppConfig</code>类和一个<code class="fe ng nh ni nj b">ResourceConfig</code>类，用于从原始配置文件创建配置对象。实际上，第三个<code class="fe ng nh ni nj b">RawConfig</code>类有助于解析原始配置文件，并将默认配置合并到每个环境部分中。<br/>快速总结:</p><ul class=""><li id="a978" class="mm mn iq kf b kg kh kk kl ko mo ks mp kw mq la nk ms mt mu bi translated"><code class="fe ng nh ni nj b">RawConfig</code> <br/>用于将整个原始配置文件处理成更多可用的部分。这个类的一个实例应该足够了。</li><li id="3615" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la nk ms mt mu bi translated"><code class="fe ng nh ni nj b">AppConfig</code> <br/>用于将所有原始应用程序配置转换成一个应用程序配置对象。这需要<code class="fe ng nh ni nj b">RawConfig</code>实例的输入。这个类的一个实例应该足够了。</li><li id="a33f" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la nk ms mt mu bi translated"><code class="fe ng nh ni nj b">ResourceConfig</code> <br/>用于将所有原始的环境特定配置转换成一个环境配置对象。这需要<code class="fe ng nh ni nj b">RawConfig</code>实例的输入。<br/>应该创建该类的多个实例，每个AWS环境一个(帐户+区域组合)。</li></ul><p id="ec98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是这些类的一些片段</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">RawConfig类的代码段。</figcaption></figure><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">AppConfig类的代码段。</figcaption></figure><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">ResourceConfig类的代码段。</figcaption></figure><p id="e864" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，这些类可以在CDK管道应用程序中使用。首先，在<code class="fe ng nh ni nj b">app.py</code>文件中创建一个<code class="fe ng nh ni nj b">PipelineStack</code>实例需要AWS环境，这个管道需要部署到这个环境中。这正是<code class="fe ng nh ni nj b">AppConfig</code>实例的<code class="fe ng nh ni nj b">build_environment</code>属性。</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">如何使用配置对象创建PipelineStack实例的代码片段。</figcaption></figure><p id="a719" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将<code class="fe ng nh ni nj b">RawConfig</code>和<code class="fe ng nh ni nj b">AppConfig</code>实例传递给<code class="fe ng nh ni nj b">PipelineStack</code>构造函数也很有用，因为在创建堆栈时需要它们的内容。例如，应用程序配置包含要查看的存储库的详细信息，并且需要原始配置实例来创建特定于环境的配置对象。这就是所有这些的组合方式:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">如何使用AppConfig实例字段并为每个环境创建ResourceConfig实例的代码片段。</figcaption></figure><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">如何分阶段使用配置对象的代码片段。</figcaption></figure><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">如何在堆栈中使用配置对象的代码片段。</figcaption></figure><p id="168f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，阶段和堆栈级别所需的所有信息都包含在配置对象中。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="f603" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">如何管理CDK应用程序的配置？</h1><p id="8668" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">为了标准化处理CDK管道配置arccos多应用程序的方式，在<em class="lb">中讨论了配置类如何管理所有环境的配置？</em>可以作为基类。每个应用程序都可以通过继承这些基类来创建更多特定于应用程序的配置类。将基类发布为Python包，这也将使可用性更容易。</p><p id="7a59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在每个CDK管道应用程序中，创建一个包含这些类的<code class="fe ng nh ni nj b">configuration.py</code>文件:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">特定于应用程序的配置类片段。</figcaption></figure><p id="79f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您可以在应用程序的其余部分使用这些更具体的配置类。此外，您可以根据需要定制配置类，例如添加额外的字段、包含额外的逻辑、扩展构造函数方法等等</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="4461" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">如何更新我的应用程序的CDK版本？</h1><p id="a24f" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">这听起来像是一个有着明显答案的直觉问题，但由于CDK管道的自我突变方面，它远非如此。为了正确回答这个问题，让我们先来谈谈我所说的<em class="lb">应用程序的CDK版本是什么意思。</em></p><p id="18e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">首先介绍一下CDK版本的背景:</strong> <br/>您可以在您的CDK管道应用程序中指定多个CDK版本。有两种主要类型，一种是CDK CLI版本，用于为您的堆栈合成云形成模板，另一种是CDK构造(Python)包版本，用于通过代码定义您的构造。前者应始终等于或高于后者。此外，确保所有CDK软件包都有相同的版本。</p><p id="1a11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，可以在管道应用程序中指定多个CDK CLI版本。在您的<code class="fe ng nh ni nj b">package.json</code>中指定的那个用于本地开发和预定义的管道动作，例如<code class="fe ng nh ni nj b">SimpleSynthAction.standard_npm_synth()</code>。如果没有使用标准的synth操作，最好明确说明您的代码构建应该使用哪个CDK CLI版本。此外，当您的代码管道执行某些操作时，也可以使用CDK CLI命令。默认情况下，它使用最新的CDK版本，但您可以指定一个特定的版本。</p><p id="0f6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为避免意外，最好保持所有版本的CDK CLI和CDK软件包相同:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在何处指定CDK版本以保持它们相同的示例。</figcaption></figure><p id="8739" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">升级您的CDK包</strong> <br/>当您想要将您的应用程序的CDK包版本升级到<code class="fe ng nh ni nj b">x.yz</code>时，您首先需要将您的管道的CDK CLI版本更新为等于或大于<code class="fe ng nh ni nj b">x.yz</code>(无论<code class="fe ng nh ni nj b">&lt;CDK_VERSION&gt;</code>是在何处定义的，例如在配置文件和<code class="fe ng nh ni nj b">package.json</code>文件中)<strong class="kf ir">和</strong>触发管道(通过提交/合并/…)，以便它在更新管道/自变异阶段/操作期间更新自身。接下来，用<code class="fe ng nh ni nj b">pip install aws-cdk.pipelines=x.yz</code>将应用程序的CDK包更新到版本<code class="fe ng nh ni nj b">x.yz</code>(确保更新所有的<code class="fe ng nh ni nj b">aws-cdk.abcd</code>包，而不仅仅是<code class="fe ng nh ni nj b">pipelines</code>)。当使用Python开发时，不要忘记导出一个更新的<code class="fe ng nh ni nj b">environment.yml</code>文件(或等效文件),这样这些新版本也将在管道执行中使用。下次触发管道时，升级CDK版本将创建资源。</p><p id="c397" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您不首先更新管道的CDK CLI版本，管道将尝试使用低于您应用程序的CDK软件包版本的CDK CLI版本合成云信息模板，这将失败。合成发生在代码构建实例中构建阶段的合成动作期间，该代码构建实例具有已经存在的管道规范，即具有低于升级包版本的CDK CLI版本。只有在PipelineUpdate阶段成功之后，才会更新下一个synth操作的CodeBuild实例。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="b7f1" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">我如何从失败的构建阶段中恢复过来？</h1><p id="b2c3" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">当错误配置CodeBuild实例的规范时，可能会陷入失败的构建阶段(Synth操作)。由于配置错误(例如，<code class="fe ng nh ni nj b">SimpleSynthAction</code>的安装命令输入错误)，该步骤可能会失败。此示例拼错了“install”:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">synth action install命令中的输入错误示例。</figcaption></figure><p id="4393" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在你意识到你的错别字后，你修复它并用一个新的提交再次触发管道。然而，构建阶段又失败了。您注意到您的错别字修复还没有包括在内。乍一看，这似乎很奇怪，但实际上这是意料之中的行为。您的管道需要更新(错别字修复)，但这只发生在构建阶段之后的<code class="fe ng nh ni nj b">UpdatePipeline/SelfMutate</code>阶段/动作<em class="lb">。由于构建阶段仍然具有带有错别字的配置，因此不可能通过自变异来修复管道。</em></p><p id="2268" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有两种解决方案。</p><ol class=""><li id="5dd2" class="mm mn iq kf b kg kh kk kl ko mo ks mp kw mq la mr ms mt mu bi translated">如果您(作为一名开发人员)拥有部署CDK管道的权限，您可以重新部署一个新的管道，该管道将直接拥有带有错别字修复的规范。你可以在你的本地机器上用<code class="fe ng nh ni nj b">npx cdk deploy</code>来做这件事。</li><li id="2c76" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">您可以通过AWS控制台手动修复代码构建规范(<code class="fe ng nh ni nj b">Build project -&gt; Build details -&gt; Buildspec</code>)中的错别字，并使用<code class="fe ng nh ni nj b">Release Change</code>按钮再次触发管道。</li></ol><p id="668a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我个人更倾向于第二种方案，因为这样更快。</p><p id="8cc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在一开始开发CDK管道时，这个问题经常发生。不仅仅是打字错误，错误的构建命令、错误的变量……都可能发生。为了避免将来出现这样的问题，在您的CDK管道源代码之外的一个单独的文件中指定install/build/…命令的细节是一个<strong class="kf ir">好的做法。一个有用的地方是<code class="fe ng nh ni nj b">package.json</code>文件，并从管道的代码构建中调用<code class="fe ng nh ni nj b">npm</code>脚本。这样，代码构建的规范可以始终保持不变，例如<code class="fe ng nh ni nj b">npm run ci_build</code>意味着代码构建实例不需要更新/自变异。如果您在<code class="fe ng nh ni nj b">ci_build</code>脚本中犯了一个错误，您可以很容易地修复它，并使用新的提交再次触发管道。但是这一次，代码构建不会陷入失败状态，因为从代码构建的角度来看，命令仍然是<code class="fe ng nh ni nj b">npm run ci_build</code>。</strong></p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">如何在synth操作命令中引用npm脚本的片段。</figcaption></figure><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">显式编写为npm脚本的synth操作命令片段。</figcaption></figure></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="f487" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">如何删除我的CDK管道？</h1><p id="e506" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">就像通过<code class="fe ng nh ni nj b">cdk deploy &lt;my-pipeline-stack&gt;</code>部署管道一样，可以通过从您的机器上调用<code class="fe ng nh ni nj b"> cdk destroy &lt;my-pipeline-stack&gt;</code>来删除它。</p><p id="e3f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过<code class="fe ng nh ni nj b">cdk destroy</code> <strong class="kf ir">移除CDK管道只会</strong>破坏管道，而<strong class="kf ir">不会</strong>破坏其部署的资源。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="f244" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">我如何拆除我的基础设施资源？</h1><p id="9a96" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">因为通过<code class="fe ng nh ni nj b">cdk destroy</code> <strong class="kf ir">移除CDK管线仅</strong>会破坏管线，而<strong class="kf ir">不会破坏</strong>其已经部署的资源，所以必须单独破坏资源。</p><p id="dfd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最简单的方法是通过AWS控制台手动完成。进入部署资源的账户中的云阵，按下所有所需堆栈的<code class="fe ng nh ni nj b">delete</code>按钮。</p><p id="befe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您也可以尝试自动完成这项工作，但是我目前还没有创建一种从管道内部完成这项工作的方法。然而，在GitHub 上有一些关于这个<a class="ae kc" href="https://github.com/aws/aws-cdk/issues/10190" rel="noopener ugc nofollow" target="_blank">的有趣讨论。棘手的是，您需要以正确的(相反的)顺序销毁它们<strong class="kf ir">和</strong>您的销毁操作需要在部署的帐户中承担具有正确权限的角色，以便执行<code class="fe ng nh ni nj b">cdk destroy </code>操作</a></p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="004d" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">如何在不干扰管道的情况下开发CDK堆栈？</h1><p id="b891" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">当开发团队很大时，可能需要单个开发人员创建/测试一些AWS资源，而不破坏/干扰开发环境。如果是这种情况，开发人员可以将源资源部署到一个单独的<em class="lb"> spike </em>环境中，而不触发管道，从而保持管道不变。</p><p id="34d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设已经引导了spike环境，开发人员必须采取以下步骤:</p><ol class=""><li id="5a96" class="mm mn iq kf b kg kh kk kl ko mo ks mp kw mq la mr ms mt mu bi translated">在所需stage构造的<code class="fe ng nh ni nj b">app.py</code>中为spike环境创建一个新的stage对象。<strong class="kf ir">始终创建个人阶段，而不是该级别的堆栈</strong>，因为否则CDK将不会在下一步创建新的<code class="fe ng nh ni nj b">assembly-* </code>目录，而是会将该内容直接生成到<code class="fe ng nh ni nj b">cdk.out/</code>。在这个具体示例中，spike帐户的配置遵循<em class="lb">我如何管理所有环境的配置中描述的方法？</em></li></ol><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">如何创建独立于CDK管道的个人舞台的片段。</figcaption></figure><ol class=""><li id="9d5e" class="mm mn iq kf b kg kh kk kl ko mo ks mp kw mq la mr ms mt mu bi translated">构建CDK应用程序，并使用<code class="fe ng nh ni nj b">npx cdk synth.</code>在本地合成云信息模板。这将创建一个文件夹<code class="fe ng nh ni nj b">cdk.out/assembly-Personal</code>，其中包含部署资源所需的所有文件。</li><li id="2f13" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">用<br/> <code class="fe ng nh ni nj b">npx cdk -a cdk.out/assembly-Personal deploy</code>将个人舞台资源调配到秒杀账号</li><li id="a407" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">开发堆栈，进行一些测试，探索AWS服务，…</li><li id="6a69" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">当不再需要这些资源时，通过用<br/>T3摧毁舞台来移除它们</li></ol><p id="0b46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，不应提交个人阶段的任何更改，因为不应触发管道。这种类型的开发只与单个开发人员的临时开发相关。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="f406" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">如何避免使用from_lookup()？</h1><p id="dd19" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">在<code class="fe ng nh ni nj b">vpc.from_lookup()</code>T22的情况下，文档已经提供了答案:</p><blockquote class="nl nm nn"><p id="0eb3" class="kd ke lb kf b kg kh ki kj kk kl km kn no kp kq kr np kt ku kv nq kx ky kz la ij bi translated">此功能仅需要用于使用您的CDK应用程序中未定义的VPC。如果您希望在堆栈之间共享VPC，您可以在堆栈之间传递Vpc对象并正常使用它。</p></blockquote><p id="f106" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果所需的<code class="fe ng nh ni nj b">vpc</code>是外部的(其他应用或其他阶段/环境)，您可以用<code class="fe ng nh ni nj b">vpc.from_vpc_attributes()</code>创建它的一个<em class="lb">虚拟</em> <code class="fe ng nh ni nj b">vpc</code>对象。该方法要求至少知道外部<code class="fe ng nh ni nj b">vpc</code>的<code class="fe ng nh ni nj b">availability_zones</code>和<code class="fe ng nh ni nj b">vpc_id</code>。使用<em class="lb">虚拟</em>对象，您只能使用创建时提供的属性。因此，如果您需要将<code class="fe ng nh ni nj b">vpc</code>的私有子网的<code class="fe ng nh ni nj b">SubnetSelection</code>传递给另一个构造，您需要将这些<code class="fe ng nh ni nj b">private_subnet_ids</code>传递给<code class="fe ng nh ni nj b">vpc.from_vpc_attributes()</code>方法。</p><p id="3639" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个例子:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">如何使用vpc.from_lookup()的代码片段。</figcaption></figure><p id="7d4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个解释对于<code class="fe ng nh ni nj b">route53.from_lookup()</code>是等价的。您需要使用<code class="fe ng nh ni nj b">from_hosted_zone_attributes()</code>方法并为其提供<code class="fe ng nh ni nj b">hosted_zone_id</code>和<code class="fe ng nh ni nj b">zone_name</code>。</p><p id="d652" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ng nh ni nj b">from_vpc_attributes()</code> <strong class="kf ir">不会从实际外部资源获取信息！</strong></p><p id="59f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<strong class="kf ir">不是</strong>T12】使用 CDK管道时，调用此方法将导致在执行CDK CLI时进行查找。因此，您不能使用任何仅在CloudFormation执行时可用的值(即令牌)。<code class="fe ng nh ni nj b">vpc</code>信息将被缓存在<code class="fe ng nh ni nj b">cdk.context.json</code>中，相同的<code class="fe ng nh ni nj b">vpc</code>将在以后的运行中使用。要刷新查找，您必须使用<code class="fe ng nh ni nj b">cdk context</code>命令从缓存中清除该值。有关上下文的更多信息可在<a class="ae kc" href="https://docs.aws.amazon.com/cdk/latest/guide/context.html" rel="noopener ugc nofollow" target="_blank">文档</a>中找到。</p><p id="a250" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是因为CDK管道不使用上下文查询，用<code class="fe ng nh ni nj b">from_vpc_attributes()</code>显式地提供属性相当于将它们存储在<code class="fe ng nh ni nj b">cdk.context.json</code>中，只是现在您将它们存储在配置文件中。</p><p id="2410" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对于其他<code class="fe ng nh ni nj b">from_xxx_attributes()</code>方法是等效的。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="b012" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">如何避免使用stack.availability_zones()？</h1><p id="7ee6" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated"><a class="ae kc" href="https://docs.aws.amazon.com/cdk/api/latest/python/aws_cdk.core/Stack.html#aws_cdk.core.Stack.availability_zones" rel="noopener ugc nofollow" target="_blank">文档</a>揭示了问题:</p><blockquote class="nl nm nn"><p id="cf58" class="kd ke lb kf b kg kh ki kj kk kl km kn no kp kq kr np kt ku kv nq kx ky kz la ij bi translated">返回与此堆栈关联的AWS环境(帐户/区域)中可用的az列表。<br/> … <br/>如果它们在上下文中不可用，则返回一组空值并报告它们丢失，并让CLI通过调用目标环境上的EC2 DescribeAvailabilityZones来解决它们。</p></blockquote><p id="2dde" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于CDK管道不支持上下文查询，<code class="fe ng nh ni nj b">stack.availability_zones()</code>将返回空值。解决方案是用正确的可用性区域覆盖<code class="fe ng nh ni nj b">vpc</code>堆栈中的get <code class="fe ng nh ni nj b">availability_zones()</code> getter方法。在Python中开发时，需要使用正确的getter装饰器:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">如何重写stack.availability()方法的代码片段。</figcaption></figure></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="b7ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我再一次与你分享了我个人的建议和技巧。我确实有更多，尤其是一些Python特有的once。所以请继续关注即将到来的文章。与此同时，AWS CDK开发团队继续高速扩展CDK库，所以我使用/解释的一些细节可能不再有效。</p><p id="1669" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望这些提示和技巧在某种程度上对你有所帮助！如果你还没有这样做，一定要看看<a class="ae kc" href="https://medium.com/swlh/aws-cdk-pipelines-real-world-tips-and-tricks-part-1-544601c3e90b" rel="noopener">以前的文章</a>以获得更多的提示和技巧。</p><h1 id="dd6f" class="lj lk iq bd ll lm nr lo lp lq ns ls lt lu nt lw lx ly nu ma mb mc nv me mf mg bi translated">一些有用的链接</h1><ul class=""><li id="7430" class="mm mn iq kf b kg mh kk mi ko nw ks nx kw ny la nk ms mt mu bi translated"><a class="ae kc" href="https://github.com/aws/aws-cdk" rel="noopener ugc nofollow" target="_blank"> AWS CDK知识库</a></li><li id="100f" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la nk ms mt mu bi translated"><a class="ae kc" href="https://aws.amazon.com/blogs/developer/cdk-pipelines-continuous-delivery-for-aws-cdk-applications/" rel="noopener ugc nofollow" target="_blank">关于CDK管道的博客</a></li><li id="6f43" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la nk ms mt mu bi translated"><a class="ae kc" href="https://github.com/aws-samples/cdk-pipelines-demo" rel="noopener ugc nofollow" target="_blank"> CDK管道演示(Python和TypeScript) </a></li><li id="9954" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la nk ms mt mu bi translated"><a class="ae kc" href="https://docs.aws.amazon.com/cdk/api/latest/docs/pipelines-readme.html" rel="noopener ugc nofollow" target="_blank"> CDK管道库</a></li><li id="743c" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la nk ms mt mu bi translated"><a class="ae kc" href="https://docs.aws.amazon.com/cdk/api/latest/python/" rel="noopener ugc nofollow" target="_blank"> CDK Python库</a></li><li id="d4f1" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la nk ms mt mu bi translated"><a class="ae kc" href="https://medium.com/swlh/aws-cdk-pipelines-real-world-tips-and-tricks-part-1-544601c3e90b" rel="noopener">我的第一篇CDK管道文章</a></li></ul></div></div>    
</body>
</html>