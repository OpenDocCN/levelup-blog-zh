<html>
<head>
<title>Writing Fx Modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写Fx模块</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/writing-fx-modules-517193b9c4f0?source=collection_archive---------6-----------------------#2021-01-26">https://levelup.gitconnected.com/writing-fx-modules-517193b9c4f0?source=collection_archive---------6-----------------------#2021-01-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/3199996f3fff99f4f304d184d0a89ed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jcS_Wu-nlRcg8vVu8Su6Gg.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">来源:<a class="ae jd" href="https://res.cloudinary.com/cpress/image/upload/w_1280,e_sharpen:60/rp1osul9qflgxvec52fo.jpg" rel="noopener ugc nofollow" target="_blank">戈朗周刊</a></figcaption></figure><div class=""/><div class=""><h2 id="8cdb" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated"><em class="kv">本文是</em> <a class="ae jd" href="https://sumit-agarwal.medium.com/golang-building-a-web-server-2d34d4f90fa1" rel="noopener"> <em class="kv"> GoLang:构建Web服务器</em> </a>系列文章的一部分</h2></div><p id="95b7" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae jd" href="https://medium.com/swlh/dependency-injection-in-go-using-fx-6a623c5c5e01" rel="noopener">上一篇文章</a>中，我们探索了如何使用<a class="ae jd" href="https://pkg.go.dev/go.uber.org/fx" rel="noopener ugc nofollow" target="_blank"> Fx </a>库将手动连接的HTTP web服务器转换成基于阿迪的web服务器。现在，一旦我们准备好了，我们的下一步就是给我们的服务器添加功能，也就是业务逻辑。但是在我们开始之前，我们需要先了解如何为我们的Fx服务器编写模块。这些模块将作为我们的应用程序的构建模块。</p><h2 id="8aa1" class="ls lt jg bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">什么是模块？</h2><p id="c83d" class="pw-post-body-paragraph kw kx jg ky b kz ml kh lb lc mm kk le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">一般来说，模块是一段独立且可互换的程序，因此每个模块包含执行所需功能的一个方面所需的一切。(来源:<a class="ae jd" href="https://en.wikipedia.org/wiki/Modular_programming" rel="noopener ugc nofollow" target="_blank">维基百科</a>)。</p><p id="5e3b" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们写一行代码时，我们实现了一个小目标。这可能是我们的业务逻辑，从字符串中删除尾随空格，或者获取当前系统时间，等等。这些案例中的每一个都是独一无二的，都可以独立存在，都有它自己的意义，那么我们要不要继续下去，用它来创建一个模块呢？我不这么认为。</p><p id="7ffa" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在定义模块的时候要深思熟虑。创建一个模块的理想场景是当你想封装一些行为，这样它就可以在应用程序中重用，有时也可以在应用程序之外重用。通常，这种行为是使用接口在模块外部公开的。例如，创建模块的一些好的用例是<em class="mq">日志模块、度量模块、授权模块等。</em></p><blockquote class="mr"><p id="3e5c" class="ms mt jg bd mu mv mw mx my mz na lr dk translated">请确保你理解库、框架和模块之间的区别。</p></blockquote><h2 id="975a" class="ls lt jg bd lu lv nb dn lx ly nc dp ma lf nd mc md lj ne mf mg ln nf mi mj mk bi translated">什么是Fx模块？</h2><p id="8d2f" class="pw-post-body-paragraph kw kx jg ky b kz ml kh lb lc mm kk le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">正如我们在上一篇文章中看到的，Fx所做的就是将一个对象注入另一个对象。为了将对象A注入到对象B中，它需要预先将对象A放在适当的位置。那么它首先从哪里得到对象A呢？</p><p id="5f69" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">迷惑…对吧？</p><p id="b891" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们试着简化它，当Fx创建一个新对象(我们称之为OBJ1，以下简称OBJ1)时，它查找obj 1需要的依赖项。</p><p id="bfdf" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">情况1:不需要依赖关系，OBJ1是在应用程序上下文中创建的。</p><p id="c4c9" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">案例2: Fx在应用程序上下文中找到需要的依赖项，注入它们，OBJ1就创建了。</p><p id="68c5" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一切都是在哪里发生的？它发生在一个<code class="fe ng nh ni nj b">fx.provide</code>调用中，该调用是一个模块的一部分，该模块的职责是在Fx生命周期中调用<code class="fe ng nh ni nj b">New</code>方法时创建OBJ1并将其提供给应用程序上下文。(<a class="ae jd" href="https://pkg.go.dev/go.uber.org/fx" rel="noopener ugc nofollow" target="_blank">外汇文件</a>)</p><p id="8813" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Fx是根据<a class="ae jd" href="https://en.wikipedia.org/wiki/Modular_programming" rel="noopener ugc nofollow" target="_blank">模块化编程</a>的概念设计的。每当你在一个使用Fx实现DI的应用程序中编写一行代码时，它总是某个模块的一部分(除非手动连接)。当您将应用程序转换为Fx应用程序时，您已经在模块中编写了代码。</p><h2 id="88b0" class="ls lt jg bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">我们的第一个Fx模块:LoggerFx</h2><p id="9f6c" class="pw-post-body-paragraph kw kx jg ky b kz ml kh lb lc mm kk le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们将尝试将日志添加到我们到目前为止构建的web服务器中。为此，我们将使用<a class="ae jd" href="https://pkg.go.dev/go.uber.org/zap" rel="noopener ugc nofollow" target="_blank"> zap </a>作为日志库(由uber构建)。我们添加一个名为<code class="fe ng nh ni nj b">loggerfx.go</code>的文件</p><pre class="nk nl nm nn gt no nj np nq aw nr bi"><span id="82ee" class="ls lt jg nj b gy ns nt l nu nv">// ProvideLogger to fx<br/>func ProvideLogger() *zap.SugaredLogger {<br/>   logger, _ := zap.NewProduction()<br/>   slogger := logger.Sugar()<br/><br/>   return slogger<br/>}<br/><br/>// Module provided to fx<br/>var Module = fx.Options(<br/>   fx.Provide(ProvideLogger),<br/>)</span></pre><p id="03ac" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后将<code class="fe ng nh ni nj b">main.go</code>更新为:</p><pre class="nk nl nm nn gt no nj np nq aw nr bi"><span id="8707" class="ls lt jg nj b gy ns nt l nu nv">func main() {<br/>   fx.New(<br/>      fx.Provide(http.NewServeMux),<br/>      fx.Invoke(server.New),<br/>      fx.Invoke(registerHooks),<br/>      loggerfx.Module,<br/>   ).Run()<br/>}<br/><br/>func registerHooks(<br/>   lifecycle fx.Lifecycle, mux *http.ServeMux, logger *zap.SugaredLogger,<br/>) {<br/>   lifecycle.Append(<br/>      fx.Hook{<br/>         OnStart: func(context.Context) error {<br/>            logger.Info("Listening on localhost:8080")<br/>            go http.ListenAndServe(":8080", mux)<br/>            return nil<br/>         },<br/>         OnStop: func(context.Context) error {<br/>            return logger.Sync()<br/>         },<br/>      },<br/>   )<br/>}</span></pre><p id="ba54" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经准备好运行应用程序，该应用程序将在“/”路由上提供“Hello World”响应。但这次我们也在控制台上看到了<code class="fe ng nh ni nj b">Listening on localhost:8080</code>日志。</p><blockquote class="nw nx ny"><p id="9043" class="kw kx mq ky b kz la kh lb lc ld kk le nz lg lh li oa lk ll lm ob lo lp lq lr ij bi translated"><code class="fe ng nh ni nj b"><em class="jg">go run main.go</em></code></p></blockquote><p id="62be" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">瞧啊。用Fx写模块就是这么简单。请在<a class="ae jd" href="https://github.com/sumiet/medium_webserver_series/tree/master/3" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到代码。</p><p id="5ccd" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mq">请注意，我们使用了Zap </em> <strong class="ky jh"> <em class="mq">库</em> </strong> <em class="mq">，在Fx </em> <strong class="ky jh"> <em class="mq">框架</em> </strong> <em class="mq">里面创建了LoggerFx </em> <strong class="ky jh"> <em class="mq">模块</em> </strong> <em class="mq">。希望这能帮助你更好地理解这三个术语的区别。</em></p><p id="b063" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您获得Fx模块实践经验的任务是将HTTP处理程序转换成一个模块。编码快乐！</p><p id="75b0" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一篇文章中，我们将探索远程过程调用，并为我们的服务添加一个RPC处理器模块。</p><figure class="nk nl nm nn gt is"><div class="bz fp l di"><div class="oc od l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">RPC解释道</figcaption></figure></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><p id="a66c" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ol translated"><span class="l om on oo bm op oq or os ot di"> C </span> <strong class="ky jh"> oding有趣的事实:</strong>计算机“bug”这个词的灵感来自于一个真实的bug。它是由<a class="ae jd" href="https://gocoderz.com/blog/great-women-of-stem/" rel="noopener ugc nofollow" target="_blank">格蕾丝·赫柏</a>于1947年创建的。</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><p id="a1ac" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky jh"> <em class="mq">请求:</em> </strong> <em class="mq">请在评论中添加您的宝贵反馈，这将真正帮助我提高内容的质量，并使其符合您的期望。</em></p></div></div>    
</body>
</html>