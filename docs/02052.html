<html>
<head>
<title>Modern Perl: Why Perl Rules For Text</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代Perl:为什么Perl为文本制定规则</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/modern-perl-why-perl-rules-for-text-1f3e6c0e3786?source=collection_archive---------11-----------------------#2020-02-15">https://levelup.gitconnected.com/modern-perl-why-perl-rules-for-text-1f3e6c0e3786?source=collection_archive---------11-----------------------#2020-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1968373b6b842924b42beb0d04c35f96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZHC-MSW3S7fuEXXW.jpg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由来自<a class="ae kf" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1655783" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae kf" href="https://pixabay.com/users/ninocare-3266770/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1655783" rel="noopener ugc nofollow" target="_blank">尼诺·卡雷</a>拍摄的特色图片</figcaption></figure><p id="d7a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Perl的<em class="le">瑞士军队电锯</em>可能不是热门的新语言，但它仍然是文本处理的强大工具<a class="ae kf" href="https://medium.com/swlh/perl-in-2020-is-it-still-worth-learning-today-6c88fa435fb4" rel="noopener">。我最初学习Perl是为了以日志处理的形式处理文本。当我开始认真学习中文时，我用它来消化大量的文本，看看我应该把重点放在什么地方。CGI和Dancer使我能够创建web应用程序，这真正启动了我目前的编程生涯。</a></p><p id="a839" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现代Perl对文本如此有效有很多原因。它还支持更新的数据格式，以保持其相关性。Perl并不是解决每个问题的最佳选择，但是在文本处理方面，它可以胜过许多语言。</p><h1 id="58db" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Perl和文本</h1><p id="9b9d" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">Perl 最初是作为一种通用语言创建的，用来帮助生成报告。报告功能需要文本提取和处理，以及处理和输出相关数据的简单方法。Perl支持一行程序，具有特定于文本的函数，这些函数不一定在每种(通用)语言中都有，并且有一种适合处理数据的类型。</p><h1 id="2d6d" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Perl一行程序</h1><p id="47a8" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated"><em class="le">一行程序</em>是小型语言语句，传统上可以从一行运行。这听起来没那么强大，但是想象一下，如果你想把一个DOS或Windows文件转换成Unix或POSIX格式，反之亦然。你不需要写一个完整的脚本，你只需要用一种特殊的方式运行一些语言。从DOS转到POSIX所要做的就是运行:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="fe8c" class="mr lg it mn b gy ms mt l mu mv">perl -pe 's/\r//g' myfile.dos &gt; myfile.unix</span></pre><p id="bf20" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个简单的操作快捷简单，可以在任何有Perl的机器上运行。使用Perl也可以更快更有效地挖掘日志。就拿假日志<em class="le"> fakelog </em>来说吧:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="78c3" class="mr lg it mn b gy ms mt l mu mv">WARN: Line 234 more than 140 characters, which is more than old Tweets could have<br/>ERROR: There's a problem on line 234<br/>PRINT: There are characters on line 234, but no semicolons<br/>PRINT: Some junk no one wants<br/>PRINT: More junk!!<br/>WARN: Oh no, some stuff that doesn't hurt anything<br/>ERROR: There's a big problem on line 234<br/>PRINT: I'm a fake log!<br/>WARN: Here's some problem that will affect you in 202020 if you don't patch me<br/>PRINT: Line 234 ends with a newline<br/>ERROR: Seriously, line 234, it's bad!<br/>PRINT: Did you know that 'today' ends in 'y'?</span></pre><p id="6c3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个日志有很多无用的行，这些行在查找bug时只是噪音。让我们过滤掉所有的错误:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="ded2" class="mr lg it mn b gy ms mt l mu mv">perl -ne 'print if m/^ERROR/g' fakelog <br/>ERROR: There's a problem on line 234<br/>ERROR: There's a big problem on line 234<br/>ERROR: Seriously, line 234, it's bad!</span></pre><p id="60ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好吧，我们知道“第234行”有一些东西，让我们看看日志中是否包括一些可以帮助进一步缩小范围的东西。我们只要跑:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="c248" class="mr lg it mn b gy ms mt l mu mv">perl -ne 'print if m/^ERROR/g' fakelog <br/>ERROR: There's a problem on line 234<br/>ERROR: There's a big problem on line 234<br/>ERROR: Seriously, line 234, it's bad!</span></pre><p id="4b77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过使用这种方法，我们可以推断出我们的问题是第234行缺少分号或类似的内容。虽然这对于您将要处理的日志来说有点夸张，但是同样的过程也适用于现实生活中的数据。警告和标准调试通常没有多大意义，直到它们突然变得有意义。大量的主要问题归结为一些基本的调试或详细的输出，如果实际的错误不能解决问题，则指出实际问题和实际解决方案的方向。</p><p id="0af4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管Perl是一种只写的语言，但就我在一行程序中所做的事情来看，它对我来说也是如此。我用Perl编写了尽可能多的项目，但是它提供的粘合剂最终在我的标准计算中表现得足够好，以至于它在许多方面远远超过了我的编程。当我可以直接使用Perl时，为什么要打开一个文本处理程序，点击Ctrl+h并找出内部正则表达式系统？</p><h1 id="19af" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Perl正则表达式</h1><p id="2216" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">当大多数编码应用程序实现regex时，它们在“正则表达式”和“Perl正则表达式”(现在许多更新的工具称之为“高级正则表达式”)之间进行划分。Perl正则表达式引擎非常强大。理论上，您可以用它编写一个基本的XML解析器(但不要这么做)。编写一个基本的解析器实际上是可行的(当规则相对可预测时)。</p><p id="de3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在前面的一行程序示例中使用了Perl的正则表达式，因为该引擎非常适合这项任务。我已经用一行程序和复杂的正则表达式的组合编写了几个<a class="ae kf" href="https://somedudesays.com/2019/12/data-munging-reverse-engineering-a-format/" rel="noopener ugc nofollow" target="_blank">数据管理</a>工具。像<a class="ae kf" href="https://somedudesays.com/2019/12/lua-string-operations/" rel="noopener ugc nofollow" target="_blank"> Lua </a>这样的语言有正则表达式，但是它们的实现看起来像是Perl完整课程的第一课，Lua被认为在这方面相当强大。这两个系统都不简单，但是Perl只是比大多数系统更进了一步，可以说更富于表现力。</p><h1 id="2fa9" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Perl中的字符串处理</h1><p id="8cc5" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">Perl中的某些内置函数是有意义的。像<em class="le"> chomp </em>这样的东西使得处理用户数据变得轻而易举。有一种简单的方法可以去掉最后一行对传统输入没有贡献的新行。如果你想要的话，你必须在Lua(和其他软件)中从头开始制作。</p><p id="59f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> Perl: </strong></p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="1254" class="mr lg it mn b gy ms mt l mu mv">#!/usr/bin/perl -l<br/><br/>require strict;<br/><br/>my $str = "junk\r\n";<br/>chomp( $str );<br/>print( "[" . $str . "]" );</span></pre><p id="f6b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> Lua: </strong></p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="f836" class="mr lg it mn b gy ms mt l mu mv">#!/usr/bin/lua5.1<br/><br/>function chomp( line )<br/>	line = string.gsub( line, "\n*\r*\n*$", "" ) --in case we care about being cross platform<br/>	return string.gsub( line, "\n$", "" )<br/>end<br/><br/>local str = "test\n"<br/><br/>print( "Shortened str to: " .. chomp( str ) )</span></pre><p id="72e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这只是生活质量的提高，但它也显示了开发商的努力方向。Perl使文本工作变得轻而易举，而其他语言需要您构建越来越多的样板文件。当我需要构建一个解析器或报告过程时，Perl是我的第一语言。</p><p id="465d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有其他一些基本函数，如<em class="le"> join </em>，它们存在于C#和类似的语言中，但不存在于其他语言中，如Lua。</p><p id="ce80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> Perl: </strong></p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="e7b4" class="mr lg it mn b gy ms mt l mu mv">#!/usr/bin/perl -l<br/><br/>require strict;<br/><br/>my @arr = ( "a", "b", "c" );<br/>my @arr2 = ();<br/>my @arr3 = ( "a", "b" );<br/><br/>print( join( " AND ", @arr ) );<br/>print( join( " AND ", @arr2 ) );<br/>print( join( " AND ", @arr3 ) );</span></pre><p id="c348" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">卢阿:</strong></p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3427" class="mr lg it mn b gy ms mt l mu mv">#!/usr/bin/lua5.1<br/><br/>function join( table, jstring )<br/>	local str = ""<br/>	<br/>	local tlength = #table<br/>	<br/>	if( tlength == 0 ) then<br/>		return str<br/>	end<br/>	<br/>	str = table[ 1 ]<br/>	<br/>	if( tlength == 1 ) then<br/>		return str<br/>	end<br/>	<br/>	for i = 2, tlength, 1 do<br/>		str = str .. jstring .. table[ i ]<br/>	end<br/>	<br/>	return str<br/>end<br/><br/>local arr = { "a", "b", "c" }<br/>local arr2 = {  }<br/>local arr3 = { "a" }<br/>local arr4 = { "a", "b" }<br/><br/>print( join( arr, " AND " ) )<br/>print( join( arr2, " ANYTHING " ) )<br/>print( join( arr3, " ANYTHING " ) )<br/>print( join( arr4, " AND " ) )</span></pre><p id="a59b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的Lua函数是我能写的最轻的版本。我们不考虑整个事情不是一个表和许多其他简单的处理点。Perl版本可以工作，Lua版本是一个教学练习。像C#这样的语言提供了一个<em class="le"> join </em>函数，但是对于类似的文本处理任务，它们的类型使它们比Perl稍弱一些。</p><h1 id="3496" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Perl类型和习惯用法</h1><p id="1506" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">Perl在任何用例中都是弱类型的，但是静态类型的严格Perl和动态类型的普通Perl是有区别的。<a class="ae kf" href="https://medium.com/swlh/static-typing-vs-dynamic-typing-83f0d8b82ef" rel="noopener">弱类型</a>意味着一个<em class="le">标量</em>是一个<em class="le">标量</em>，我们可以用一个<em class="le">字符串</em>把一个<em class="le"> int </em>放进去。Perl还允许我们做一些大多数语言不会做的事情。Perl中的<em class="le">“cat”+1 = 1</em>。字符串和数字之间的转换不会真的发生，它只是发生了。</p><p id="9220" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Perl的类型有助于数据处理，这是大多数语言所没有的。借助某些语言设计特性，它在许多方面更加直观。</p><p id="3e82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，以下任何一项都是有效的:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="095e" class="mr lg it mn b gy ms mt l mu mv">if( [condition] ) { [do thing]; }<br/>[do thing] if( [condition] );<br/>[do thing] unless [condition];</span></pre><p id="d43c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这让我们在实践中得到一些东西，比如:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="b88a" class="mr lg it mn b gy ms mt l mu mv">#!/usr/bin/perl -l<br/><br/>if( 1 + 1 == 2 ) { print( "1 + 1 = 2" ); }<br/>print( "1 + 1 = 2" ) if( 1 + 1 == 2 );<br/>print( "1 + 1 = 2" ) unless 1 + 1 &gt; 2;</span></pre><h1 id="0731" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Perl与世界</h1><p id="8fbe" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">借助CPAN T21的力量，Perl拥有了它所需要的一切，包括XML、JSON、CSV、SQL等等。有多种不同类型的库来处理CSV，从最普通的到最模糊的。XML和JSON在Perl中也有很好的表现。标准的SQL类型和晦涩的数据库几乎都有与Perl交互的模块。</p><p id="2448" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于Perl在文本处理和正则表达式方面的其他优势，解析基于文本的格式通常很容易。我写过许多解析器，将人类可读的数据转换成其他类型的人类可读的数据，并因此获得了丰厚的报酬。在其他语言中需要几周时间的项目在Perl中可能需要几个晚上。一个一年10，000美元的程序被一些聪明的Perl脚本和开源软件所取代。</p><h1 id="edfc" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">堆叠语言</h1><p id="e71e" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">Perl是我的第一门真正的语言，从那以后一直是我最喜欢的语言。我继续前进，因为我不得不这样做，但语言是我对每一个新范式的比较。它并不完美，但它胜过了我曾经考虑过的用于文本处理的任何东西。</p><p id="53d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Lua对某些事情更有用，但是Perl仍然是最好的通用脚本语言，在任何你不能远程控制已安装软件的地方。C#在Windows上更好，但是这种语言本身不需要太多的工作就能应付某些解析场景。C、C++和许多其他通用语言只是位于Lua之下。</p><p id="4d37" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有哪种语言一定更好，有些只是更适合特定的任务。Perl擅长文本处理，没有其他语言能与之匹敌。Perl可能不适合每一个项目，但是我参与的几乎所有大型项目都是用它粘在一起的。一行程序可以节省您的时间，正则表达式让您感觉您处于计算的未来，尽管有许多报告说这种语言已经死亡。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="3c98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">最初发表于</em><a class="ae kf" href="https://somedudesays.com/2020/02/modern-perl-why-perl-rules-for-text/" rel="noopener ugc nofollow" target="_blank">T5【https://somedudesays.com】</a><em class="le">。</em></p></div></div>    
</body>
</html>