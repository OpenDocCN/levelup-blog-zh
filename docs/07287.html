<html>
<head>
<title>Create a Serverless App on AWS using TypeScript — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript在AWS上创建一个无服务器应用程序—第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-a-simple-serverless-application-using-typescript-and-aws-part-1-be2188f5ff93?source=collection_archive---------0-----------------------#2021-02-07">https://levelup.gitconnected.com/creating-a-simple-serverless-application-using-typescript-and-aws-part-1-be2188f5ff93?source=collection_archive---------0-----------------------#2021-02-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9615f5aa74e5afa4f3593849e36bd759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DXZ6BwGUEDdgeAoJ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@kelvin1987?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kelvin Ang </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="17db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无服务器架构和微服务改变了我们对应用的看法。现在，我们拥有由应用程序开发人员编写的服务器端逻辑，这些逻辑在无状态计算容器中运行，这些容器由事件触发，并完全由第三方云提供商管理。本质上，<a class="ae kc" href="https://en.wikipedia.org/wiki/Function_as_a_service" rel="noopener ugc nofollow" target="_blank">功能即服务(<strong class="kf ir"> FaaS </strong> ) </a>。目前有许多FaaS的实现，但是AWS Lambda是最受欢迎的平台之一。</p><h2 id="39c1" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">为什么没有服务器？</h2><p id="d53f" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">有很多原因可以解释为什么很多人更喜欢<a class="ae kc" href="https://martinfowler.com/articles/serverless.html" rel="noopener ugc nofollow" target="_blank">无服务器应用</a>而不是传统的服务器托管应用。这些原因的核心是:</p><ul class=""><li id="dbe5" class="lz ma iq kf b kg kh kk kl ko mb ks mc kw md la me mf mg mh bi translated">成本损失和维护</li><li id="2941" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated">易于扩展</li></ul><p id="9f49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行<a class="ae kc" href="https://martinfowler.com/articles/serverless.html" rel="noopener ugc nofollow" target="_blank">无服务器应用</a>更便宜，因为我们只为每个请求付费，当我们不使用我们的应用时不会被收费。我们也只需要担心我们的代码，其他什么也不用担心。我们不需要担心服务器的管理，因此维护成本较低。此外，<a class="ae kc" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> Lambda </a>根据需求进行扩展，而<a class="ae kc" href="https://aws.amazon.com/dynamodb/" rel="noopener ugc nofollow" target="_blank"> DynamoDB </a>为我们提供了几乎无限的规模。</p><p id="3e7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于本文，我们将使用以下工具为待办应用程序创建一个简单的<a class="ae kc" href="https://www.redhat.com/en/topics/api/what-is-a-rest-api" rel="noopener ugc nofollow" target="_blank"> REST API </a>:</p><ul class=""><li id="92b3" class="lz ma iq kf b kg kh kk kl ko mb ks mc kw md la me mf mg mh bi translated"><a class="ae kc" href="https://www.serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>带有<a class="ae kc" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点</a>和<a class="ae kc" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">打字稿</a>在<a class="ae kc" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank"> AWS </a>上，</li><li id="4746" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated">测试使用<a class="ae kc" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank">摩卡</a>和<a class="ae kc" href="https://www.chaijs.com/" rel="noopener ugc nofollow" target="_blank">柴</a>和</li><li id="ecaf" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated">使用<a class="ae kc" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html" rel="noopener ugc nofollow" target="_blank"> API Gateway Lambda授权器</a>进行访问控制，防止对我们的终端发出未经授权的请求。</li></ul><h1 id="fd37" class="mn lc iq bd ld mo mp mq lg mr ms mt lj mu mv mw lm mx my mz lp na nb nc ls nd bi translated">发展</h1><p id="7f29" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我总是发现在开发<a class="ae kc" href="https://martinfowler.com/articles/serverless.html" rel="noopener ugc nofollow" target="_blank">无服务器应用</a>时，使用<a class="ae kc" href="https://www.serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>更容易。配置<a class="ae kc" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html" rel="noopener ugc nofollow" target="_blank">亚马逊API网关</a>和使用<a class="ae kc" href="https://docs.aws.amazon.com/lambda/latest/dg/welcome.html" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>可能会非常麻烦，这就是<a class="ae kc" href="https://www.serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>非常有用的地方。<a class="ae kc" href="https://www.serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>是一个开源的独立于提供商的框架，它为部署到<a class="ae kc" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank"> AWS </a>、<a class="ae kc" href="https://azure.microsoft.com/en-gb/" rel="noopener ugc nofollow" target="_blank">微软Azure </a>、<a class="ae kc" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌云平台</a>或任何选择的云提供商提供了强大的支持。使用<a class="ae kc" href="https://www.serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>也意味着作为一名开发人员，我能够快速构建、构建、打包、监控和部署我的无服务器应用程序。它移除了无服务器部署所需的大部分样板文件，同时支持代码为的<a class="ae kc" href="https://en.wikipedia.org/wiki/Infrastructure_as_code" rel="noopener ugc nofollow" target="_blank">基础设施。该框架还使我能够提供我的应用程序所需的资源和基础设施，如数据库、对象存储和队列，同时还使我能够构建多种类型的应用程序。你可以阅读更多关于</a><a class="ae kc" href="https://www.serverless.com/learn/comparisons/" rel="noopener ugc nofollow" target="_blank">无服务器框架与其他软件</a>的比较。</p><p id="3f29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank"> AWS </a>一直是我选择的云提供商，因为我发现它是最适合开发者进行<a class="ae kc" href="https://aws.amazon.com/serverless/" rel="noopener ugc nofollow" target="_blank">无服务器开发</a>的平台。另外，<a class="ae kc" href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/billing-free-tier.html" rel="noopener ugc nofollow" target="_blank"> AWS免费层</a>允许开发者免费试用一系列AWS服务。我能够尝试各种服务，看看它们是如何工作的，而不用担心成本。</p><p id="9ba7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于开发，您需要在全球范围内安装<code class="fe ne nf ng nh b"><strong class="kf ir">serverless</strong></code>、<code class="fe ne nf ng nh b"><strong class="kf ir">npm</strong></code>和/或<code class="fe ne nf ng nh b"><strong class="kf ir">yarn</strong></code>。参见如何<a class="ae kc" href="https://classic.yarnpkg.com/en/docs/install/" rel="noopener ugc nofollow" target="_blank">安装纱线</a>和<a class="ae kc" href="https://docs.npmjs.com/downloading-and-installing-node-js-and-npm" rel="noopener ugc nofollow" target="_blank"> NPM </a>。我也更喜欢使用NVM来管理我的节点版本。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="994c" class="lb lc iq nh b gy nq nr l ns nt">// Install serverless framework CLI<br/>$ <strong class="nh ir">npm install -g serverless</strong></span></pre><h2 id="4fcc" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">第一步。配置AWS</h2><p id="a6a6" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">如果尚未安装AWS CLI，请安装。我在文章中介绍了如何<a class="ae kc" href="https://sidneyb231.medium.com/configure-aws-for-development-and-deployment-ad822097fc22" rel="noopener">创建和配置AWS凭证</a>。接下来，我们需要设置我们的应用程序。</p><h2 id="b92d" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">第二步。设置项目</h2><p id="7031" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">使用typescript创建并设置一个无服务器项目:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="5ee8" class="lb lc iq nh b gy nq nr l ns nt">$ <!-- -->sls create --template aws-nodejs-typescript --path &lt;PROJECT-NAME&gt;</span></pre><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/10bb318fd2bc5faf0619561dccb913c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-M1XhNRCGg64mUzdbEbX7g.png"/></div></div></figure><p id="3e73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe ne nf ng nh b"><strong class="kf ir">&lt;PROJECT-NAME&gt;</strong></code>是您项目的名称。</p><p id="f6f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这为我们的应用程序生成了一个无服务器的样板文件。接下来，我们需要导航到我们的新项目<code class="fe ne nf ng nh b">cd &lt;PROJECT-NAME&gt;</code>，并通过运行<code class="fe ne nf ng nh b"><strong class="kf ir">yarn install</strong></code>安装我们的依赖项。</p><p id="52c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在开发应用程序时，我们将更新的最重要的文件是<code class="fe ne nf ng nh b"><strong class="kf ir">handler.ts</strong></code>和<code class="fe ne nf ng nh b"><strong class="kf ir">serverless.ts</strong></code>。<code class="fe ne nf ng nh b"><strong class="kf ir">handler.ts</strong></code>文件处理我们的lambda函数或对lambda函数的引用。它应该是这样的:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="3840" class="lb lc iq nh b gy nq nr l ns nt">import { APIGatewayProxyHandler } from 'aws-lambda';<br/>import 'source-map-support/register';<br/><br/>export const <em class="nv">hello</em>: APIGatewayProxyHandler = async (event, _context) =&gt; {<br/>  return {<br/>    statusCode: 200,<br/>    body: JSON.stringify({<br/>      message: 'Go Serverless Webpack (Typescript) v1.0! Your function executed successfully!',<br/>      input: event,<br/>    }, null, 2),<br/>  };<br/>}</span></pre><p id="2838" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过将基础设施视为代码，<code class="fe ne nf ng nh b"><strong class="kf ir">serverless.ts</strong></code>文件为我们提供了一个模板来为<a class="ae kc" href="https://aws.amazon.com/cloudformation/" rel="noopener ugc nofollow" target="_blank"> AWS CloudFormation </a>建模和供应我们的应用资源。这有助于我们轻松地创建、更新甚至删除资源。它应该是这样的:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="bd46" class="lb lc iq nh b gy nq nr l ns nt">import type { Serverless } from 'serverless/aws';<br/><br/>const serverlessConfiguration: Serverless = {<br/>  service: {<br/>    name: 'serverless-todo',<br/>    <em class="nv">// app and org for use with dashboard.serverless.com<br/>    // app: your-app-name,<br/>    // org: your-org-name,<br/>  </em>},<br/>  frameworkVersion: '&gt;=1.72.0',<br/>  custom: {<br/>    webpack: {<br/>      webpackConfig: './webpack.config.js',<br/>      includeModules: true<br/>    }<br/>  },<br/>  <em class="nv">// Add the serverless-webpack plugin<br/>  </em>plugins: ['serverless-webpack'],<br/>  provider: {<br/>    name: 'aws',<br/>    runtime: 'nodejs12.x',<br/>    apiGateway: {<br/>      minimumCompressionSize: 1024,<br/>    },<br/>    environment: {<br/>      AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1',<br/>    },<br/>  },<br/>  functions: {<br/>    hello: {<br/>      handler: 'handler.hello',<br/>      events: [<br/>        {<br/>          http: {<br/>            method: 'get',<br/>            path: 'hello',<br/>          }<br/>        }<br/>      ]<br/>    }<br/>  }<br/>}<br/><br/>module.exports = serverlessConfiguration;</span></pre><p id="16b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，由于<a class="ae kc" href="https://www.serverless.com/framework/docs/deprecations/" rel="noopener ugc nofollow" target="_blank">弃用</a>，您需要将服务属性直接设置为服务名:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="a6dd" class="lb lc iq nh b gy nq nr l ns nt">{ <br/>  service: 'serverless-todo',</span><span id="d188" class="lb lc iq nh b gy nw nr l ns nt">  ...<br/>}</span></pre><p id="ed9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并更新<code class="fe ne nf ng nh b"><strong class="kf ir">provider.apiGateway</strong></code>对象，如下所示:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="83d4" class="lb lc iq nh b gy nq nr l ns nt">provider: {<br/>  ...<br/>  apiGateway: {<br/>    shouldStartNameWithService: true,<br/>    ...<br/>  },<br/>  ...<br/>},</span></pre><p id="e05c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在我们的项目根<code class="fe ne nf ng nh b"><strong class="kf ir">$ serverless invoke local --function hello</strong></code>中运行我们的函数，您应该会看到响应:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="2461" class="lb lc iq nh b gy nq nr l ns nt">{<br/>    "statusCode": 200,<br/>    "body": "{\n  \"message\": \"Go Serverless Webpack (Typescript) v1.0! Your function executed successfully!\",\n  \"input\": \"\"\n}"<br/>}</span></pre><p id="59bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无服务器框架在本地调用<code class="fe ne nf ng nh b">hello</code>函数，运行<code class="fe ne nf ng nh b"><strong class="kf ir">handler.ts</strong></code>文件中导出的<code class="fe ne nf ng nh b"><strong class="kf ir">hello</strong></code>方法。<code class="fe ne nf ng nh b">serverless invoke local</code>命令允许我们在部署Lambda函数之前在本地运行它们。</p><p id="7be0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要为我们的应用程序安装一些依赖项:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="6fdb" class="lb lc iq nh b gy nq nr l ns nt">$ yarn add -D serverless-offline serverless-dotenv-plugin serverless-bundle<br/>$ yarn add aws-sdk uuid @types/uuid</span></pre><ul class=""><li id="fb9f" class="lz ma iq kf b kg kh kk kl ko mb ks mc kw md la me mf mg mh bi translated"><a class="ae kc" href="https://www.npmjs.com/package/aws-sdk" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> aws-sdk </strong> </a> —允许我们与aws服务进行通信</li><li id="7681" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><a class="ae kc" href="https://www.npmjs.com/package/uuid" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> uuid </strong> </a> —为我们的数据库条目生成唯一的id</li><li id="6f9a" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><a class="ae kc" href="https://www.npmjs.com/package/serverless-offline" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">无服务器-离线</strong> </a> <strong class="kf ir"> </strong> —这个插件使我们能够在本地运行我们的应用程序和Lambda函数</li><li id="354a" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><a class="ae kc" href="https://www.npmjs.com/package/serverless-dotenv-plugin" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">server less-dotenv-plugin</strong></a>—使我们能够将<code class="fe ne nf ng nh b"><strong class="kf ir">.env</strong></code>变量加载到我们的Lambda环境中</li><li id="1b7a" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><a class="ae kc" href="https://www.npmjs.com/package/serverless-bundle" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">server less-bundle</strong></a>—这个插件对我们的Typescript函数进行了优化打包，并确保我们不需要担心安装<a class="ae kc" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Babel </strong> </a>、<a class="ae kc" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Typescript </strong> </a>、<a class="ae kc" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Webpack </strong> </a>、<a class="ae kc" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> ESLint </strong> </a>以及其他一系列包。这意味着我们不需要维护自己的webpack配置。所以我们可以继续删除<code class="fe ne nf ng nh b"><strong class="kf ir">webpack.config.js</strong></code>文件以及在<code class="fe ne nf ng nh b">serverless.ts</code>自定义属性中对它的引用:</li></ul><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="11ff" class="lb lc iq nh b gy nq nr l ns nt">// FROM<br/>custom: {<br/>  webpack: {<br/>    webpackConfig: './webpack.config.js',<br/>    includeModules: true<br/>  }<br/>}</span><span id="5273" class="lb lc iq nh b gy nw nr l ns nt">// TO<br/>custom: {<br/>  <br/>}</span></pre><p id="563d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且也从<code class="fe ne nf ng nh b"><strong class="kf ir">plugins</strong></code>阵中移除。您还可以从项目中移除以下默认依赖项:</p><ul class=""><li id="71dc" class="lz ma iq kf b kg kh kk kl ko mb ks mc kw md la me mf mg mh bi translated"><strong class="kf ir">来源-地图-支持</strong></li><li id="8e50" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">fork-ts-checker-web pack-plugin</strong></li><li id="75fb" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir"> ts-loader </strong></li><li id="24f0" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">终端服务节点</strong></li><li id="0cea" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">打字稿</strong></li><li id="1b01" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">无服务器网络包</strong></li><li id="1376" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">网络包</strong></li><li id="cacc" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir"> webpack-node-externals </strong></li></ul><h2 id="3f91" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">性能</strong></h2><p id="34b9" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">同样需要注意的是，默认情况下，无服务器框架为所有Lambda函数创建一个包。这意味着每次调用Lambda函数时，它都会加载应用程序中的所有其他Lambda函数和代码。随着应用程序变得越来越大，这将对性能产生负面影响，也会使<a class="ae kc" href="https://dzone.com/articles/dealing-with-serverless-cold-starts-once-and-for-a" rel="noopener ugc nofollow" target="_blank">冷启动</a>时间更长。</p><p id="1f43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个特性可以被关闭，它将通过向我们的<code class="fe ne nf ng nh b"><strong class="kf ir">serverless.ts</strong></code>添加以下内容来确保我们的功能被单独打包:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="4f69" class="lb lc iq nh b gy nq nr l ns nt">// serverless.ts  </span><span id="a1a2" class="lb lc iq nh b gy nw nr l ns nt">package: {<br/>  individually: true,<br/>},</span></pre><p id="a3cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个启用的选项也将允许<code class="fe ne nf ng nh b"><strong class="kf ir">serverless-bundle</strong></code>使用Webpack通过<a class="ae kc" href="https://webpack.js.org/guides/tree-shaking/" rel="noopener ugc nofollow" target="_blank">树摇动算法</a>生成优化的包。</p><h2 id="a2c9" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">第三步。设置资源</h2><p id="26b9" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">构建CRUD应用程序的下一步是决定如何存储数据。在这种情况下，我们将使用<a class="ae kc" href="https://aws.amazon.com/dynamodb/" rel="noopener ugc nofollow" target="_blank"> DynamoDB </a>作为我们的数据库选择。DynamoDB是一个无服务器的数据库，因此可以自动扩展，我们只需为我们使用的东西付费。我们还将添加一些Lambda函数。</p><p id="737f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们的新应用程序架构将如下所示:</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/a6d0d76d397577e8eaf70324bcb2b196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aDlZHXpZOcC4g_lHG02sWg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">应用架构</figcaption></figure><p id="74c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你会注意到我们的数据库没有公开，只被我们的Lambda函数调用。</p><p id="2f0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在设置我们的资源时，重要的是我们用代码做所有的事情，并避免使用AWS控制台。这样，配置、部署和维护基础架构组件就更加容易、快速和一致。我们将用我们需要的资源更新<code class="fe ne nf ng nh b"><strong class="kf ir">serverless.ts</strong></code>文件。</p><p id="9a67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要如下设置我们的<code class="fe ne nf ng nh b"><strong class="kf ir">custom</strong></code>属性:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="629e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这设置了<code class="fe ne nf ng nh b"><strong class="kf ir">region</strong></code>、<code class="fe ne nf ng nh b"><strong class="kf ir">stage</strong></code>、<code class="fe ne nf ng nh b"><strong class="kf ir">table_throughputs</strong></code>、<code class="fe ne nf ng nh b"><strong class="kf ir">table_throughput</strong></code>和表格<code class="fe ne nf ng nh b"><strong class="kf ir">list_table</strong></code>和<code class="fe ne nf ng nh b"><strong class="kf ir">tasks_table</strong></code>变量。它还为本地开发配置<code class="fe ne nf ng nh b"><strong class="kf ir">dynamodb</strong></code>和<code class="fe ne nf ng nh b"><strong class="kf ir">serverless-offline</strong></code>。</p><p id="7fde" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要更新<code class="fe ne nf ng nh b"><strong class="kf ir">serverless.ts</strong></code>文件中的<code class="fe ne nf ng nh b"><strong class="kf ir">provider.environment</strong></code>属性，如下所示:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="cc31" class="lb lc iq nh b gy nq nr l ns nt">// serverless.ts</span><span id="c714" class="lb lc iq nh b gy nw nr l ns nt">provider: {<br/>  ...<br/>  environment: {<br/>    ...<br/>    REGION: '${self:custom.region}',<br/>    STAGE: '${self:custom.stage}',<br/>    LIST_TABLE: '${self:custom.list_table}',<br/>    TASKS_TABLE: '${self:custom.tasks_table}',<br/>  },<br/>  ...<br/>},</span></pre><p id="d058" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ne nf ng nh b">environment</code>部分为我们的Lambda函数定义了环境变量，并将在<code class="fe ne nf ng nh b">process.env</code> Node.js变量下提供。这将<code class="fe ne nf ng nh b"><strong class="kf ir">REGION</strong></code>、<code class="fe ne nf ng nh b"><strong class="kf ir">STATE</strong></code>、<code class="fe ne nf ng nh b"><strong class="kf ir">LIST_TABLE</strong></code>和<code class="fe ne nf ng nh b"><strong class="kf ir">TASKS_TABLE</strong></code>定义为环境变量。</p><p id="408e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要提供<a class="ae kc" href="https://aws.amazon.com/iam/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> AWS身份和访问管理</strong> </a> (IAM)访问，以允许对DynamoDB表进行读写。为此，我们需要将<code class="fe ne nf ng nh b"><strong class="kf ir">iamRoleStatements</strong></code>属性添加到<code class="fe ne nf ng nh b"><strong class="kf ir">provider</strong></code>对象中。这个部分告诉AWS我们希望Lambda函数访问哪些资源:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="666b" class="lb lc iq nh b gy nq nr l ns nt">provider: {<br/>  ...<br/>  iamRoleStatements: [<br/>    {<br/>      Effect: 'Allow',<br/>      Action: [<br/>          'dynamodb:DescribeTable',<br/>          'dynamodb:Query',<br/>          'dynamodb:Scan',<br/>          'dynamodb:GetItem',<br/>          'dynamodb:PutItem',<br/>          'dynamodb:UpdateItem',<br/>          'dynamodb:DeleteItem'<br/>      ],<br/>      Resource: [<br/>        {"Fn::GetAtt": [ 'ListTable', 'Arn' ]},<br/>        {"Fn::GetAtt": [ 'TasksTable', 'Arn' ]}<br/>      ]<br/>    }<br/>  ]<br/>},</span></pre><p id="a316" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面提到了三个权限块，分别是<code class="fe ne nf ng nh b"><strong class="kf ir">Effect</strong></code>、<code class="fe ne nf ng nh b"><strong class="kf ir">Action</strong></code>和<code class="fe ne nf ng nh b"><strong class="kf ir">Resource</strong></code>。设置为<code class="fe ne nf ng nh b">Allow</code>的效果在列出的资源上授予列出的动作。Action块包含所需DynamoDB动作的列表，如<strong class="kf ir">可描述的</strong>、<strong class="kf ir">查询</strong>、<strong class="kf ir">扫描</strong>、<strong class="kf ir"> GetItem </strong>、<strong class="kf ir"> PutItem </strong>、<strong class="kf ir"> UpdateItem </strong>和<strong class="kf ir"> DeleteItem </strong>。这些是我们的应用程序需要的唯一权限。最后，资源块拥有我们的表的ARN，并将我们的应用程序权限的范围限制在列出的表，并且不能查询任何未列出的其他表。</p><p id="6a12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要添加<code class="fe ne nf ng nh b"><strong class="kf ir">resources</strong></code>，当部署我们的应用程序时，它们会被添加到您的CloudFormation堆栈中。我们需要在名为<code class="fe ne nf ng nh b"><strong class="kf ir">resources</strong></code>的属性中定义AWS资源，如下所示:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="1059" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe ne nf ng nh b"><strong class="kf ir">ListTable</strong></code>和<code class="fe ne nf ng nh b"><strong class="kf ir">TasksTable</strong></code>是对我们的DynamoDB表的引用。</p><ul class=""><li id="c438" class="lz ma iq kf b kg kh kk kl ko mb ks mc kw md la me mf mg mh bi translated"><strong class="kf ir">类型</strong>:描述AWS资源类型。</li><li id="a82e" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir"> DeletionPolicy </strong>:描述所有资源的删除策略，默认设置为<code class="fe ne nf ng nh b"><strong class="kf ir">Delete</strong></code>。<code class="fe ne nf ng nh b"><strong class="kf ir">Retain</strong></code>确保无论何时删除堆栈，我们的表都不会被删除。</li><li id="ac9c" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">属性</strong>:描述表格属性</li><li id="d6da" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">表名</strong>:要创建的表的名称</li><li id="1fe7" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir"> AttributeDefinitions </strong>:描述表和索引的键模式的属性数组。</li><li id="b48a" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir"> KeySchema </strong>:指定构成表主键的属性。KeySchema中的属性也必须在AttributeDefinitions数组中定义。</li><li id="ac68" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir"> ProvisionedThroughput </strong>:这为我们的表定义了提供的吞吐量</li></ul><p id="4598" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以阅读更多关于在DynamoDB 中使用表和数据的信息。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/83effcf93e514c52344724f88e66ec66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3Fx0RUqFuqvEUSQq"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">多米尼克·汉普顿在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="b50e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">利用Javascript的强大功能，我们可以通过分割成文件和使用动态导入来避免大型服务定义文件。这很重要，因为随着应用程序的增长，单独的定义文件更容易维护。</p><p id="e53c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于这个项目，我们将分别组织我们的资源并导入到<code class="fe ne nf ng nh b"><strong class="kf ir">serverless.ts</strong></code>中。为此，我们需要首先在根目录中创建一个<code class="fe ne nf ng nh b"><strong class="kf ir">resources</strong></code>目录，然后为DynamoDB表创建一个<code class="fe ne nf ng nh b"><strong class="kf ir">dynamodb-tables.ts</strong></code>文件:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="e9be" class="lb lc iq nh b gy nq nr l ns nt">// At project root<br/>$ mkdir resources<br/>$ touch resources/dynamodb-tables.ts </span></pre><p id="026d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们如下更新<code class="fe ne nf ng nh b"><strong class="kf ir">dynamodb-tables.ts</strong></code>文件:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="8443" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并导入到<code class="fe ne nf ng nh b"><strong class="kf ir">serverless.ts</strong></code> —见第4行，在第98行使用:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="e921" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要定义我们的项目结构。</p><h2 id="1324" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">第四步。定义项目结构并创建功能</h2><p id="a886" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">下一步是为我们的待办事项应用程序创建我们的a<a class="ae kc" href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" rel="noopener ugc nofollow" target="_blank">CRUD</a>API。</p><p id="c9b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要在根目录中创建一个<code class="fe ne nf ng nh b"><strong class="kf ir">src</strong></code>目录，并定义我们如何构建项目的其余部分:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="f21d" class="lb lc iq nh b gy nq nr l ns nt">// At project root<br/>$ mkdir src<br/>$ mkdir src/actions src/interfaces src/enums src/models src/services src/constraints src/utils</span></pre><ul class=""><li id="7db1" class="lz ma iq kf b kg kh kk kl ko mb ks mc kw md la me mf mg mh bi translated"><strong class="kf ir">动作</strong> —针对我们的功能</li><li id="ed11" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">接口</strong> —用于我们的应用程序接口</li><li id="8c02" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">枚举</strong> —针对我们的应用枚举</li><li id="b82f" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">型号</strong> —针对我们的型号</li><li id="40d7" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">服务</strong> —针对我们的应用服务</li><li id="ca3b" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">约束</strong> —用于请求参数验证</li><li id="cec4" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">实用程序</strong> —用于我们的实用程序功能</li></ul><h2 id="1ce1" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">-模特</h2><p id="2163" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">接下来，我们需要创建我们的模型:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="4451" class="lb lc iq nh b gy nq nr l ns nt">$ touch src/models/response.model.ts src/models/list.model.ts src/models/task.model.ts</span></pre><p id="ae4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的响应模型将处理我们的API响应，并确保我们始终保持一致的格式。更新<code class="fe ne nf ng nh b"><strong class="kf ir">response.model.ts</strong></code>如下:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="04e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要更新我们的<code class="fe ne nf ng nh b"><strong class="kf ir">list.model.ts</strong></code>和<code class="fe ne nf ng nh b"><strong class="kf ir">task.model.ts</strong></code>文件来处理我们的数据输入。</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="451f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们为我们的应用程序创建几个枚举:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="31eb" class="lb lc iq nh b gy nq nr l ns nt">$ touch src/enums/response-message.enum.ts src/enums/status.enum.ts src/enums/status-code.enum.ts</span></pre><p id="7cdc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们更新如下:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="ed33" class="lb lc iq nh b gy nq nr l ns nt">// src/enums/status.enum.ts<br/>export enum Status {<br/>    <em class="nv">SUCCESS </em>= 'success',<br/>    <em class="nv">ERROR </em>= 'error',<br/>    <em class="nv">BAD_REQUEST </em>= 'bad request',<br/>}</span><span id="a782" class="lb lc iq nh b gy nw nr l ns nt">// src/enums/status-code.enum.ts<br/>export enum StatusCode {<br/>    <em class="nv">OK </em>= 200,<br/>    <em class="nv">ERROR </em>= 500,<br/>    <em class="nv">BAD_REQUEST </em>= 400,<br/>}</span></pre><p id="3ab0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并替换<code class="fe ne nf ng nh b"><strong class="kf ir">response.model.ts</strong></code>中的枚举。</p><h2 id="5626" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">-服务</h2><p id="3e32" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">接下来，我们需要创建我们的数据库服务来处理我们的应用程序CRUD进程。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="072e" class="lb lc iq nh b gy nq nr l ns nt">$ touch src/services/database.service.ts</span></pre><p id="8ddd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要为我们的数据库服务创建一些接口:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="0f3d" class="lb lc iq nh b gy nq nr l ns nt">$ touch src/interfaces/config.interface.ts</span></pre><p id="750d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们更新如下:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="cbb9" class="lb lc iq nh b gy nq nr l ns nt">// src/interfaces/config.interface.ts<br/>export default interface IConfig {<br/>    region: string;<br/>    accessKeyId?: string;<br/>    secretAccessKey?: string;<br/>    endpoint?: string;<br/>}</span></pre><p id="59c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要更新<code class="fe ne nf ng nh b"><strong class="kf ir">database.service.ts</strong></code>如下:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><ul class=""><li id="420e" class="lz ma iq kf b kg kh kk kl ko mb ks mc kw md la me mf mg mh bi translated"><strong class="kf ir">创建</strong> —将项目放入DynamoDB表的函数</li><li id="d5e0" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir"> batchCreate </strong> —将项目批量写入DynamoDB表的函数</li><li id="39b0" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">更新</strong> —更新DynamoDB表中项目的函数</li><li id="61a5" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">查询</strong> —在DynamoDB表上运行查询的函数</li><li id="a3a7" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir"> get </strong> —从DynamoDB表中获取项目的函数</li><li id="8de6" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">删除</strong> —从DynamoDB表中删除项目an的功能</li></ul><p id="7e3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要通过在我们的<code class="fe ne nf ng nh b">.<strong class="kf ir">env</strong></code>文件中添加本地DynamoDB环境变量来增加对本地开发的支持，并更新我们的AWS配置:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="239b" class="lb lc iq nh b gy nq nr l ns nt">const config: IConfig = { region: "eu-west-1" };<br/>if (process.env.STAGE === process.env.DYNAMODB_LOCAL_STAGE) {<br/>    config.accessKeyId = process.env.DYNAMODB_LOCAL_ACCESS_KEY_ID; <em class="nv"><br/>    </em>config.secretAccessKey = process.env.DYNAMODB_LOCAL_SECRET_ACCESS_KEY; <em class="nv"><br/>    </em>config.endpoint = process.env.DYNAMODB_LOCAL_ENDPOINT;<em class="nv"><br/></em>}<br/>AWS.config.<em class="nv">update</em>(config);</span></pre><p id="bc8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要在本地运行DynamoDB，我们需要首先安装<code class="fe ne nf ng nh b"><strong class="kf ir">serverless-dynamodb-local</strong></code>插件:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="ae96" class="lb lc iq nh b gy nq nr l ns nt">$ yarn add -D serverless-dynamodb-local </span></pre><p id="1d82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要更新<code class="fe ne nf ng nh b"><strong class="kf ir">serverless.ts</strong></code>插件数组:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="b207" class="lb lc iq nh b gy nq nr l ns nt">plugins: [<br/>    'serverless-bundle',<br/>    'serverless-dynamodb-local',<br/>    'serverless-offline',<br/>    'serverless-dotenv-plugin',<br/>],</span></pre><p id="f80b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用这个插件，我们需要在项目根目录下运行<code class="fe ne nf ng nh b"><strong class="kf ir">sls dynamodb install</strong></code>来安装DynamoDB Local。运行<code class="fe ne nf ng nh b"><strong class="kf ir">sls dynamodb start</strong></code>将在本地启动它:</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/78ebc657a5c6d915ced16829ac49f47d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rj9ycV_mTSVDKD8h80Iskw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">DynamoDB本地</figcaption></figure><p id="06ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经设置了DynamoDB，我们需要创建我们的CRUD函数——创建、读取、更新和删除我们的待办事项列表和任务。</p><h2 id="26cc" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">-功能</h2><p id="b18d" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">首先，我们需要创建目录来存储我们的Lambda函数:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="528a" class="lb lc iq nh b gy nq nr l ns nt">$ mkdir src/actions/list src/actions/task</span></pre><ul class=""><li id="83b7" class="lz ma iq kf b kg kh kk kl ko mb ks mc kw md la me mf mg mh bi translated"><code class="fe ne nf ng nh b"><strong class="kf ir">list</strong></code> —用于我们的列表功能</li><li id="dc83" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><code class="fe ne nf ng nh b"><strong class="kf ir">task</strong></code> —用于我们的任务功能</li></ul><p id="f669" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">— <strong class="kf ir">请求验证</strong></p><p id="dada" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不能依赖客户端验证，所以验证所有发送到端点的请求也很重要。</p><p id="fc8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我将安装<code class="fe ne nf ng nh b"><a class="ae kc" href="https://www.npmjs.com/package/validate.js" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">validate.js</strong></a></code>库，因为它提供了在Javascripts中验证对象的声明性方式。在项目根目录下，运行<code class="fe ne nf ng nh b"><strong class="kf ir">yarn add validate.js</strong></code>作为依赖项安装到我们的项目中。</p><p id="86b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要创建一个<code class="fe ne nf ng nh b"><strong class="kf ir">util</strong></code>验证函数来实现这种依赖性:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="0f8c" class="lb lc iq nh b gy nq nr l ns nt">$ touch src/utils/util.ts</span></pre><p id="a94b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并更新如下:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="adef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要为Lambda函数创建请求约束:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="2517" class="lb lc iq nh b gy nq nr l ns nt">// Create directories for our constraints<br/>$ mkdir src/constraints/list src/constraints/task</span><span id="15e8" class="lb lc iq nh b gy nw nr l ns nt">// List constraints<br/>$ touch src/constraints/list/create.constraint.json src/constraints/list/get.constraint.json src/actions/list/update.constraint.json</span><span id="a4ba" class="lb lc iq nh b gy nw nr l ns nt">// Task constraints<br/>$ touch src/constraints/task/create.constraint.json src/constraints/task/update.constraint.json src/constraints/task/get.constraint.json</span></pre><p id="874e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要注意的是，为了在我们的typescript项目中动态导入和使用JSON文件，我们需要更新<code class="fe ne nf ng nh b"><strong class="kf ir">tsconfig.json</strong></code>compile options并将<code class="fe ne nf ng nh b"><strong class="kf ir">resolveJsonModule</strong></code>设置为<code class="fe ne nf ng nh b"><strong class="kf ir">true</strong></code>。将<code class="fe ne nf ng nh b"><strong class="kf ir">tsconfig.json</strong></code> <strong class="kf ir"> </strong>的内容替换如下:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="bfb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们还需要为Lambda函数创建单独的文件:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="cb91" class="lb lc iq nh b gy nq nr l ns nt">// List functions<br/>$ touch src/actions/list/create-list.action.ts src/actions/list/get-list.action.ts src/actions/list/update-list.action.ts src/actions/list/delete-list.action.ts</span><span id="8145" class="lb lc iq nh b gy nw nr l ns nt">// Task functions<br/>$ touch src/actions/task/create-task.action.ts src/actions/task/update-task.action.ts src/actions/task/delete-task.action.ts</span></pre><p id="d403" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以开始创建我们的函数了。</p><h2 id="7a88" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">-列出函数</h2><p id="9137" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们从我们的<code class="fe ne nf ng nh b"><strong class="kf ir">createList</strong></code>函数开始。首先，我们需要通过更新<code class="fe ne nf ng nh b"><strong class="kf ir">create.constraint.json</strong></code>来定义请求的约束:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="2085" class="lb lc iq nh b gy nq nr l ns nt">// src/constraints/list/create.constraint.json<br/>{<br/>  "name": {<br/>    "presence": {<br/>      "allowEmpty": false<br/>    },<br/>    "type": "string"<br/>  }<br/>}</span></pre><p id="599b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这确保了<code class="fe ne nf ng nh b"><strong class="kf ir">createList</strong></code>函数期望一个包含<code class="fe ne nf ng nh b"><strong class="kf ir">name</strong></code>属性并且是字符串的请求对象。如果不匹配，则验证失败:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="0934" class="lb lc iq nh b gy nq nr l ns nt">{<br/>    "data": {<br/>        "validation": {<br/>            "name": [<br/>                "Name can't be blank"<br/>            ]<br/>        }<br/>    },<br/>    "message": "required fields are missing",<br/>    "status": "bad request"<br/>}</span></pre><p id="00ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要更新<code class="fe ne nf ng nh b"><strong class="kf ir">create-list.action.ts</strong></code>如下:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="7b3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们初始化我们的响应变量，然后解析来自代表HTTP请求体的<code class="fe ne nf ng nh b">event.body</code>的输入。我们还使用在<code class="fe ne nf ng nh b"><strong class="kf ir">serverless.ts</strong></code>中设置的<code class="fe ne nf ng nh b"><strong class="kf ir">process.env.LIST_TABLE</strong></code>从环境变量中读取DynamoDB表的名称。</p><p id="abdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们根据定义的约束验证请求参数。我们定义的约束需要一个请求对象，它看起来像:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="f5cd" class="lb lc iq nh b gy nq nr l ns nt"><em class="nv">// Request-Example:<br/>{<br/>   "name": "My To-do list",<br/>}</em></span></pre><p id="d282" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果请求有效，那么我们在DynamoDB表中创建一个新的列表项，并生成一条响应消息:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="600d" class="lb lc iq nh b gy nq nr l ns nt">// <em class="nv">Example </em>Success Response<br/><em class="nv">{<br/>  "data": { "listId": "468c8094-a756-4000-a919-example" },<br/>  "message": "To-do List successfully created"<br/>  "status": "success"<br/>}</em></span></pre><p id="e5b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们继续使用<code class="fe ne nf ng nh b"><strong class="kf ir">updateList</strong></code>函数，并在<code class="fe ne nf ng nh b"><strong class="kf ir">update.constraint.json</strong></code>中创建更新约束:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="d3aa" class="lb lc iq nh b gy nq nr l ns nt">// src/constraints/list/update.constraint.json<br/>{<br/>  "listId": {<br/>    "presence": {<br/>      "allowEmpty": false<br/>    },<br/>    "type": "string"<br/>  },<br/>  "name": {<br/>    "presence": {<br/>      "allowEmpty": false<br/>    },<br/>    "type": "string"<br/>  }<br/>}</span></pre><p id="7cf4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和我们之前的约束定义一样，这也确保了我们的<code class="fe ne nf ng nh b"><strong class="kf ir">updateList</strong></code> API期望一个带有<code class="fe ne nf ng nh b"><strong class="kf ir">listId</strong></code>和<code class="fe ne nf ng nh b"><strong class="kf ir">name</strong></code>属性的请求对象，这两个属性都是字符串。请求示例:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="11ea" class="lb lc iq nh b gy nq nr l ns nt"><em class="nv">// Request-Example:<br/>{<br/>  "listId": "468c8094-a756-4000-example",<br/>  "</em>name<em class="nv">": "My Wednesday List",<br/>}</em></span></pre><p id="0c6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无效请求，例如:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="bbec" class="lb lc iq nh b gy nq nr l ns nt"><em class="nv">// Invalid request<br/>{<br/>  "listId": "468c8094-a756-4000-example",<br/>  "</em>name<em class="nv">": 54647,<br/>}</em></span></pre><p id="33f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们还需要更新<code class="fe ne nf ng nh b"><strong class="kf ir">update-list.action.ts</strong></code>:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="31b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ne nf ng nh b"><strong class="kf ir">updateList</strong></code>函数只是更新DynamoDB表中现有的列表项，并生成一条响应消息:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="96ac" class="lb lc iq nh b gy nq nr l ns nt"><em class="nv">// Success Response<br/>{<br/>  "data": {},<br/>  "message": "To-do List successfully updated"<br/>  "status": "success"<br/>}</em></span></pre><p id="b25b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们创建我们的<code class="fe ne nf ng nh b"><strong class="kf ir">getList</strong></code>函数和约束。首先我们更新<code class="fe ne nf ng nh b"><strong class="kf ir">get.constraint.json</strong></code>:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="ec39" class="lb lc iq nh b gy nq nr l ns nt">// src/constraints/list/get.constraint.json<br/>{<br/>  "listId": {<br/>    "presence": {<br/>      "allowEmpty": false<br/>    },<br/>    "type": "string"<br/>  }<br/>}</span></pre><p id="1edb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这确保了<code class="fe ne nf ng nh b"><strong class="kf ir">getList</strong></code>函数的请求对象必须包含一个<code class="fe ne nf ng nh b"><strong class="kf ir">listId</strong></code>属性和类型<code class="fe ne nf ng nh b"><strong class="kf ir">string</strong></code>。</p><p id="2983" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来我们更新<code class="fe ne nf ng nh b"><strong class="kf ir">get-list.action.ts</strong></code>:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="3d23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe ne nf ng nh b"><strong class="kf ir">getList</strong></code>函数中，我们还从环境变量中读取DynamoDB表的名称。在该函数中，我们首先从DynamoDB表中检索一个列表项，然后用请求的<code class="fe ne nf ng nh b"><strong class="kf ir">listId</strong></code>查询另一个DynamoDB表中的所有任务项，并在我们的API响应中返回数据:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="5177" class="lb lc iq nh b gy nq nr l ns nt">{<br/>    "data": {<br/>        "name": "My To do List",<br/>            "createdAt": 1609475930597,<br/>            "id": "ae47940e-5bf3-45d6-a390-example",<br/>            "updatedAt": 1609475930597,<br/>            "taskCount": 2,<br/>            "tasks": [<br/>            {<br/>                "id": "566e06a7-a9e9-449f-9e19-example",<br/>                "description": "Task 1",<br/>                "completed": false,<br/>                "createdAt": 1609533804820,<br/>                "updatedAt": 1609534302597<br/>            },<br/>            {<br/>                "id": "263a3617-4a65-4879-b522-example",<br/>                "description": "Task 2",<br/>                "completed": false,<br/>                "createdAt": 1609533804820,<br/>                "updatedAt": 1609534302597            <br/>            }<br/>          <br/>        ]<br/>    },<br/>    "message": "To-do list successfully retrieved",<br/>    "status": "success"<br/>}</span></pre><p id="31ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们创建我们的<code class="fe ne nf ng nh b"><strong class="kf ir">deleteList</strong></code>函数并使用之前的<code class="fe ne nf ng nh b"><strong class="kf ir">get.constraint.json</strong></code>，因为它需要相同的请求参数:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="b6b1" class="lb lc iq nh b gy nq nr l ns nt">// src/constraints/list/get.constraint.json<br/>{<br/>  "listId": {<br/>    "presence": {<br/>      "allowEmpty": false<br/>    },<br/>    "type": "string"<br/>  }<br/>}</span></pre><p id="2139" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ne nf ng nh b"><strong class="kf ir">deleteList</strong></code>函数要复杂得多，因为每个列表项都与任务有一对多的关系。这意味着每个列表可以有一个或多个任务。因此，当我们删除一个列表时，我们也希望确保删除与该列表相关联的任务。</p><p id="9d15" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">DynamoDB提供了<code class="fe ne nf ng nh b"><strong class="kf ir">batchWrite</strong></code>函数，用于在DynamoDB表中插入或删除多个项目。但是，它被限制为每笔交易25个项目。除非我们将分配给列表的任务数量限制在25个以下，否则我们需要提供一种方法来处理超过25个任务的列表。我选择在<code class="fe ne nf ng nh b"><strong class="kf ir">util.ts</strong></code>中创建一个实用函数<code class="fe ne nf ng nh b"><strong class="kf ir">createChunks</strong></code>:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="7916" class="lb lc iq nh b gy nq nr l ns nt">// src/utils/util.ts</span><span id="fe1a" class="lb lc iq nh b gy nw nr l ns nt">export const <em class="nv">createChunks </em>= (data: any[], chunkSize: number) =&gt; {<br/>    const urlChunks = [];<br/>    let batchIterator = 0;<br/>    while (batchIterator &lt; data.length) {<br/>        urlChunks.push(data.slice(batchIterator, (batchIterator += chunkSize)));<br/>    }<br/>    return urlChunks;<br/>}</span></pre><p id="5b47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个函数只是将一个大数组分解成一个组块数组。这将在<code class="fe ne nf ng nh b"><strong class="kf ir">get-list.action.ts</strong></code>实施:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="f937" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和前面一样，我们首先验证请求数据，但是我们还需要检查DynamoDB表中是否存在该条目，然后才处理删除事务。我们还需要删除列表中所有的任务链接。无论成功与否，该函数都会返回一个API响应:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="01e4" class="lb lc iq nh b gy nq nr l ns nt">// Example Success response<br/><em class="nv">{<br/>  "data": {},<br/>  "message": "To-do list successfully deleted"<br/>  "status": "success"<br/>}</em></span><span id="6e49" class="lb lc iq nh b gy nw nr l ns nt">// Example Error response<br/>{<br/>    "data": {<br/>        "id": "468c8094-a756-4000-a919-example"<br/>    },<br/>    "message": "Item does not exist",<br/>    "status": "bad request"<br/>}</span></pre><h2 id="20c1" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak"> -任务功能</strong></h2><p id="3684" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">接下来，我们创建<code class="fe ne nf ng nh b"><strong class="kf ir">createTask</strong></code>、<code class="fe ne nf ng nh b"><strong class="kf ir">updateTask</strong></code>、<code class="fe ne nf ng nh b"><strong class="kf ir">deleteTask</strong></code>和<code class="fe ne nf ng nh b"><strong class="kf ir">getTask</strong></code>函数。由于每个任务都与一个列表项有一对一的关系，如<code class="fe ne nf ng nh b"><strong class="kf ir">TASKS_TABLE</strong></code>的AttributeDefinitions和KeySchema中的<code class="fe ne nf ng nh b"><strong class="kf ir">listId</strong></code> RANGE_KEY所定义:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="6603" class="lb lc iq nh b gy nq nr l ns nt">TasksTable: {<br/>    ...<br/>    Properties: {<br/>        TableName: '${self:provider.environment.TASKS_TABLE}',<br/>        AttributeDefinitions: [<br/>            ...<br/>            { AttributeName: 'listId', AttributeType: 'S' }<br/>        ],<br/>        KeySchema: [<br/>            ...<br/>            { AttributeName: 'listId', KeyType: 'RANGE' }<br/>        ],<br/>        ...<br/>    }<br/>}</span></pre><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/58ec3603ebba0aa95ce7536e982da6bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4oTZb4vepySH9DM-92vpDw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">任务表结构</figcaption></figure><p id="1d90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在创建<code class="fe ne nf ng nh b"><strong class="kf ir">createTask</strong></code>函数时，我们还需要为请求对象定义约束:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="ac20" class="lb lc iq nh b gy nq nr l ns nt">// src/constraints/task/create.constraint.json<br/>{<br/>  "listId": {<br/>    "presence": {<br/>      "allowEmpty": false<br/>    },<br/>    "type": "string"<br/>  },<br/>  "description": {<br/>    "presence": {<br/>      "allowEmpty": false<br/>    },<br/>    "type": "string"<br/>  }<br/>}</span></pre><p id="dff0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们运行一个<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank"> Promise.all() </a>来验证我们的请求参数(第36行)，并且在我们将任务插入DynamoDB表(第61行)之前，有一个与<code class="fe ne nf ng nh b"><strong class="kf ir">listId</strong></code>(第38行)相关联的列表项。我们不想为不存在的列表创建任务。参见下面的<code class="fe ne nf ng nh b"><strong class="kf ir">create-task.action.ts</strong></code>:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="1d72" class="lb lc iq nh b gy nq nr l ns nt"><em class="nv">// Request-Example:</em><br/>{<br/>    "listId": "ae47940e-5bf3-45d6-a390-example",<br/>    "description": "Buy milk"<br/>}</span><span id="36da" class="lb lc iq nh b gy nw nr l ns nt"><em class="nv">// Response-Example:</em><br/>{<br/>    "data": {<br/>        "taskId": "6cdff49d-a883-443b-87b2-example"<br/>    },<br/>    "message": "Task successfully added",<br/>    "status": "success"<br/>}</span></pre><p id="a989" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是设置<code class="fe ne nf ng nh b"><strong class="kf ir">updateTask</strong></code>函数，该函数通过首先定义请求参数的约束来更新任务项:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="e624" class="lb lc iq nh b gy nq nr l ns nt">// src/constraints/task/update.constraint.json<br/>{<br/>  "listId": {<br/>    "presence": {<br/>      "allowEmpty": false<br/>    },<br/>    "type": "string"<br/>  },<br/>  "taskId": {<br/>    "presence": {<br/>      "allowEmpty": false<br/>    },<br/>    "type": "string"<br/>  },<br/>  "description": {<br/>    "type": "string"<br/>  },<br/>  "completed": {<br/>    "type": "boolean"<br/>  }<br/>}</span></pre><p id="58c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这确保了请求参数必须包括相关的<code class="fe ne nf ng nh b"><strong class="kf ir">listId</strong></code>、一个<code class="fe ne nf ng nh b"><strong class="kf ir">taskId</strong></code>以及可选的<code class="fe ne nf ng nh b"><strong class="kf ir">description</strong></code>和<code class="fe ne nf ng nh b"><strong class="kf ir">completed</strong></code>属性。然而，对可选属性进行类型检查以确保有效性。接下来，我们更新<code class="fe ne nf ng nh b"><strong class="kf ir">update-task.action.ts</strong></code>:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="26d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的<code class="fe ne nf ng nh b"><strong class="kf ir">updateTask</strong></code>函数中，我们需要验证请求参数，并在更新任务之前验证DynamoDB表中是否存在带有请求<code class="fe ne nf ng nh b"><strong class="kf ir">listId</strong></code>的列表项。此外，由于<code class="fe ne nf ng nh b"><strong class="kf ir">description</strong></code>和<code class="fe ne nf ng nh b"><strong class="kf ir">completed</strong></code>属性都是可选的，可能不会出现在请求参数中，我们需要有条件地设置<code class="fe ne nf ng nh b"><strong class="kf ir">UpdateExpression</strong></code>和<code class="fe ne nf ng nh b"><strong class="kf ir">ExpressionAttributeValues</strong></code>。</p><p id="2c8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们可以更新每个任务项的属性。但是，如果两个参数都不存在，那么我们不应该更新该项，而是抛出一个错误，因为请求无效:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="579e" class="lb lc iq nh b gy nq nr l ns nt"><em class="nv">// Request-Example:</em><br/>{<br/>    "listId": "ae47940e-5bf3-45d6-a390-example",<br/>    "taskId": "7aa35acc-9a20-4cce-9191-example"<br/>}</span><span id="fa3d" class="lb lc iq nh b gy nw nr l ns nt">// Error Response<br/>{<br/>    "data": {},<br/>    "message": "Invalid Request!",<br/>    "status": "bad request"<br/>}</span></pre><p id="ac71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要设置<code class="fe ne nf ng nh b"><strong class="kf ir">deleteTask</strong></code>函数，该函数简单地从DynamoDB表中删除一个任务。首先，我们为我们的请求定义约束:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="85ab" class="lb lc iq nh b gy nq nr l ns nt">// src/constraints/task/delete.constraint.json<br/>{<br/>  "listId": {<br/>    "presence": {<br/>      "allowEmpty": false<br/>    },<br/>    "type": "string"<br/>  },<br/>  "taskId": {<br/>    "presence": {<br/>      "allowEmpty": false<br/>    },<br/>    "type": "string"<br/>  }<br/>}</span></pre><p id="b8bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与前面的约束一样，对<code class="fe ne nf ng nh b"><strong class="kf ir">deleteTask</strong></code>函数的请求必须包括相关的<code class="fe ne nf ng nh b"><strong class="kf ir">listId</strong></code>和要删除的任务的id<code class="fe ne nf ng nh b"><strong class="kf ir">taskId</strong></code>作为属性。因此我们相应地更新<code class="fe ne nf ng nh b"><strong class="kf ir">delete-task.action.ts</strong></code>:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="cdc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们首先验证请求，然后检索任务项(如果存在)，最后删除该项。</p><p id="a986" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一个函数是<code class="fe ne nf ng nh b">getTask</code>函数，它的作用就是为数据库获取一个任务。请求约束与<code class="fe ne nf ng nh b">getTask</code>函数完全相同，因为两者都需要<code class="fe ne nf ng nh b">HASH</code>和<code class="fe ne nf ng nh b">RANGE</code>键从DynamoDB表中检索项目:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="9aff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它验证请求，确保两个键都存在，然后在数据库中检查该项，如果存在则检索任务项，如果不存在则返回错误响应。</p><h2 id="59f8" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">—导出功能</h2><p id="d719" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">现在我们已经创建了所有的函数，我们需要在<code class="fe ne nf ng nh b"><strong class="kf ir">handler.ts</strong></code>中导出我们的新函数。我们需要用以下内容更新<code class="fe ne nf ng nh b"><strong class="kf ir">handler.ts</strong></code>:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="ed73" class="lb lc iq nh b gy nq nr l ns nt"><em class="nv">// List functions<br/></em>export { <em class="nv">createList </em>} from './src/actions/list/create-list.action';<br/>export { <em class="nv">deleteList </em>} from './src/actions/list/delete-list.action';<br/>export { <em class="nv">getList </em>} from './src/actions/list/get-list.action';<br/>export { <em class="nv">updateList </em>} from './src/actions/list/update-list.action';<br/><br/><em class="nv">// Task functions<br/></em>export { <em class="nv">createTask </em>} from './src/actions/task/create-task.action';<br/>export { <em class="nv">deleteTask </em>} from './src/actions/task/delete-task.action';<br/>export { <em class="nv">updateTask </em>} from './src/actions/task/update-task.action';<br/>export { <em class="nv">getTask </em>} from './src/actions/task/get-task.action';</span></pre><p id="65a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要在<code class="fe ne nf ng nh b"><strong class="kf ir">serverless.ts</strong></code>中为我们的函数定义API端点，然而，通过分离我们的函数定义和使用动态导入来避免大型服务定义是很重要的。为此，我们要在我们的<code class="fe ne nf ng nh b"><strong class="kf ir">resources</strong></code>目录中创建一个<code class="fe ne nf ng nh b"><strong class="kf ir">functions.ts</strong></code>文件:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="dc1b" class="lb lc iq nh b gy nq nr l ns nt">// At project root<br/>$ touch resources/functions.ts</span></pre><p id="8e4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们如下更新<code class="fe ne nf ng nh b"><strong class="kf ir">functions.ts</strong></code>文件:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><ul class=""><li id="8a8f" class="lz ma iq kf b kg kh kk kl ko mb ks mc kw md la me mf mg mh bi translated"><strong class="kf ir"> createList </strong> —指定我们如何处理对<code class="fe ne nf ng nh b">/list/create</code>端点的<code class="fe ne nf ng nh b">post</code>请求。</li><li id="4b16" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">删除列表</strong> —指定我们如何处理对<code class="fe ne nf ng nh b">/list/delete</code>端点的<code class="fe ne nf ng nh b">post</code>请求。</li><li id="4d12" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir"> getList </strong> —指定我们如何处理对<code class="fe ne nf ng nh b">/list</code>端点的<code class="fe ne nf ng nh b">post</code>请求。</li><li id="b48b" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">更新列表</strong> —指定我们如何处理对<code class="fe ne nf ng nh b">/list/update</code>端点的<code class="fe ne nf ng nh b">post</code>请求。</li><li id="f81b" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir"> createTask </strong> —指定我们如何处理对<code class="fe ne nf ng nh b">/task/create</code>端点的<code class="fe ne nf ng nh b">post</code>请求。</li><li id="9e83" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir"> deleteTask </strong> —指定我们如何处理对<code class="fe ne nf ng nh b">/task/delete</code>端点的<code class="fe ne nf ng nh b">post</code>请求。</li><li id="23d0" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir"> updateTask </strong> —指定我们如何处理对<code class="fe ne nf ng nh b">/task/update</code>端点的<code class="fe ne nf ng nh b">post</code>请求。</li><li id="2727" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir"> getTask </strong> —指定我们如何处理对<code class="fe ne nf ng nh b">/task</code>端点的<code class="fe ne nf ng nh b">post</code>请求。</li></ul><p id="16d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是使用单个Lambda函数响应单个HTTP事件的模式</p><p id="5fa2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并导入到<code class="fe ne nf ng nh b"><strong class="kf ir">serverless.ts</strong></code>:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b347" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面，我们只是将新功能导入到我们的无服务器配置中。</p><h2 id="fa00" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">-地方发展</h2><p id="4ab8" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们现在可以使用之前安装的插件<a class="ae kc" href="https://www.npmjs.com/package/serverless-offline" rel="noopener ugc nofollow" target="_blank">无服务器离线</a>在本地测试我们的功能。这个插件在你的本地机器上模拟<a class="ae kc" href="https://aws.amazon.com/lambda" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>和<a class="ae kc" href="https://aws.amazon.com/api-gateway" rel="noopener ugc nofollow" target="_blank"> API Gateway </a>并帮助加速开发。它通过启动HTTP服务器来处理请求的生命周期，并调用我们的处理程序，就像<a class="ae kc" href="https://aws.amazon.com/api-gateway" rel="noopener ugc nofollow" target="_blank"> API Gateway </a>一样。</p><p id="f622" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们项目的根目录下运行<code class="fe ne nf ng nh b">serverless offline start</code>将会捆绑我们的应用程序并在本地调用我们的处理程序:</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/239b96e54bf17d7f21e3b5a3d7176aa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8c08IxsAWPcAAK8XKG0rFg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">无服务器脱机—启动服务器</figcaption></figure><p id="7c62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还在本地公开了我们的端点:</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/50f8def195267a3082d907a1a961edd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4J17wgRpCPzx2lyZqraVvg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">无服务器离线—本地端点</figcaption></figure><p id="f257" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以发送请求，例如创建一个新的列表。为此，我将使用Postman向端点<code class="fe ne nf ng nh b">http://localhost:3000/dev/list/create</code>发送一个请求:</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/9082c9438643f8649fea4ab1c878e78f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0AF25v43cGDQk9jrotwhmg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">邮递员—创建列表</figcaption></figure><p id="8875" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们单击发送按钮时，我们应该会收到如下所示的响应:</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/14a3e36f9363fae2d719b9f70829a17e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jQTzDULl_sjPsXflhIC53A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">创建列表—有效请求</figcaption></figure><p id="2fbf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以通过在请求中发送一个空对象来测试我们的验证响应。我们应该会收到如下所示的验证响应:</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/14b5e94a4945ac585a283e643a29c51f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DbbqLsM9K1MWt5HMRymC2A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">创建列表—无效请求</figcaption></figure><p id="da50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们需要向我们的项目添加一些测试。</p><h1 id="f683" class="mn lc iq bd ld mo mp mq lg mr ms mt lj mu mv mw lm mx my mz lp na nb nc ls nd bi translated">测试</h1><p id="e101" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">为了向我们的应用程序添加测试，我们需要安装一些依赖项，即<a class="ae kc" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank"> Mocha </a>和<a class="ae kc" href="https://www.chaijs.com/" rel="noopener ugc nofollow" target="_blank"> Chai </a>:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="e396" class="lb lc iq nh b gy nq nr l ns nt">$ yarn add -D mocha @types/mocha chai @types/chai</span></pre><p id="1388" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并在<code class="fe ne nf ng nh b"><strong class="kf ir">tsconfig.json</strong></code>的编译选项中增加<code class="fe ne nf ng nh b"><strong class="kf ir">types</strong></code>:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="2bc7" class="lb lc iq nh b gy nq nr l ns nt">{<br/>  "compilerOptions": {<br/>    ....<br/>    "types" : [ "node", "mocha"]<br/>  },<br/>  ....<br/>}</span></pre><p id="26f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要在应用程序的根目录下创建一个<code class="fe ne nf ng nh b"><strong class="kf ir">tests</strong></code>目录:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="f2b2" class="lb lc iq nh b gy nq nr l ns nt">$ mkdir tests</span></pre><p id="18b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还喜欢将我的测试组织成<code class="fe ne nf ng nh b"><strong class="kf ir">unit</strong></code>和<code class="fe ne nf ng nh b"><strong class="kf ir">feature</strong></code>，并分别为我们的单元测试和特性测试创建目录。</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="d22f" class="lb lc iq nh b gy nq nr l ns nt">$ mkdir tests/feature tests/feature/list tests/feature/task tests/unit tests/unit/model tests/unit/util</span></pre><ul class=""><li id="1a38" class="lz ma iq kf b kg kh kk kl ko mb ks mc kw md la me mf mg mh bi translated"><strong class="kf ir">特性</strong> —特性目录将包含我们的Lambda端点的特性测试；<code class="fe ne nf ng nh b">feature/list</code>用于列表功能，而<code class="fe ne nf ng nh b">feature/task</code>用于任务</li><li id="1b8b" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated">单元目录将为我们的模型、工具和服务处理单元测试。</li></ul><p id="c568" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要一个用于处理函数的<code class="fe ne nf ng nh b"><strong class="kf ir">lib</strong></code>目录和用于模拟实体和请求的<code class="fe ne nf ng nh b"><strong class="kf ir">mocks</strong></code>:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="bd39" class="lb lc iq nh b gy nq nr l ns nt">$ mkdir tests/lib tests/lib/actions tests/mocks </span></pre><h2 id="3ea2" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">单元测试</h2><p id="1c60" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们首先为我们的应用程序创建单元测试。目的是确保我们应用程序的每个单元都按预期执行。为此，我们将测试我们的模型和实用功能。我们需要创建以下文件:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="6531" class="lb lc iq nh b gy nq nr l ns nt">$ touch tests/unit/model/response.model.test.ts tests/unit/model/list.model.test.ts tests/unit/model/task.model.test.ts tests/unit/util/util.test.ts</span></pre><p id="c927" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并更新<code class="fe ne nf ng nh b"><strong class="kf ir">tests/unit/model/list.model.test.ts</strong></code>如下:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="bc0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下次更新<code class="fe ne nf ng nh b"><strong class="kf ir">tests/unit/model/response.model.test.ts</strong></code> <strong class="kf ir"> : </strong></p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="8ceb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要更新<code class="fe ne nf ng nh b"><strong class="kf ir">tests/unit/model/task.model.test.ts</strong></code>如下:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="67a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们需要测试我们的<code class="fe ne nf ng nh b"><strong class="kf ir">util</strong></code>函数并更新<code class="fe ne nf ng nh b"><strong class="kf ir">tests/unit/util/util.test.ts</strong></code>:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="4db1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经创建了我们的单元测试，我们需要用我们的<code class="fe ne nf ng nh b"><strong class="kf ir">test</strong></code>命令更新我们的<code class="fe ne nf ng nh b"><strong class="kf ir">package.json</strong></code>中的<code class="fe ne nf ng nh b"><strong class="kf ir">scripts</strong></code>属性:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="0249" class="lb lc iq nh b gy nq nr l ns nt"><strong class="nh ir">// </strong>package.json</span><span id="4025" class="lb lc iq nh b gy nw nr l ns nt"><strong class="nh ir">"scripts": {<br/>  "unit-test": "./node_modules/.bin/mocha \"tests/unit/**/*.ts\" --require ts-node/register"<br/>},</strong></span></pre><p id="e6ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用节点CLI参数运行测试——Mocha需要<code class="fe ne nf ng nh b"><strong class="kf ir">ts-node</strong></code>,这样我们就可以执行Typescript测试文件，而不需要编译它们。我们还指定了单元测试文件的路径。它将运行路径中匹配模式的每个测试文件。在命令行上运行<code class="fe ne nf ng nh b"><strong class="kf ir">yarn run unit-test</strong></code>启动单元测试。输出应该如下所示:</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/4f290092e03a71c2073971328d7d66a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*exnwOqVIHsOnpko3-DxfFA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">用Mocha和Chai进行单元测试</figcaption></figure><h2 id="b433" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">功能测试</h2><p id="1392" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">接下来，我们还需要测试我们的CRUD特性，并确保对端点的请求得到应有的处理，并将准确的响应发送回客户端。我们还验证这些条目是从DynamoDB表中创建、更新还是删除的。</p><p id="e039" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将向我们的端点发出请求，所以首先我们需要安装<code class="fe ne nf ng nh b"><a class="ae kc" href="https://www.npmjs.com/package/node-fetch" rel="noopener ugc nofollow" target="_blank">node-fetch</a></code>依赖项来帮助我们:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="d10a" class="lb lc iq nh b gy nq nr l ns nt">$ yarn add -D node-fetch</span></pre><p id="7ac7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要创建我们的测试处理程序文件:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="d172" class="lb lc iq nh b gy nq nr l ns nt">$ touch tests/lib/actions/handler.ts</span></pre><p id="2926" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并更新如下:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="a798" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个<code class="fe ne nf ng nh b"><strong class="kf ir">post</strong></code>函数，它使用<code class="fe ne nf ng nh b"><strong class="kf ir">fetch</strong></code>库向我们需要测试的所有端点发出请求。</p><p id="f1a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要为每个API函数创建单独的目录:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="4f74" class="lb lc iq nh b gy nq nr l ns nt">// List functions<br/>$ mkdir tests/feature/list/create-list tests/feature/list/delete-list tests/feature/list/get-list tests/feature/list/update-list</span><span id="d537" class="lb lc iq nh b gy nw nr l ns nt">// Task functions<br/>$ mkdir tests/feature/task/create-task tests/feature/task/delete-task tests/feature/task/get-task tests/feature/task/update-task</span></pre><p id="fca4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个API函数都有一个<code class="fe ne nf ng nh b">valid.test.ts</code>,它用有效请求测试API端点并期望得到有效响应，还有一个<code class="fe ne nf ng nh b">invalid.test.ts</code>,它用无效请求测试端点并期望得到定义的错误处理响应。</p><p id="0f2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经包括了一个<code class="fe ne nf ng nh b">create-list/valid.test.ts</code>的样本:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="16f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它运行<code class="fe ne nf ng nh b"><strong class="kf ir">createList</strong></code>函数来创建一个新列表，并确保收到预期的响应。接下来，它运行<code class="fe ne nf ng nh b"><strong class="kf ir">getList</strong></code>函数来确认该商品是否存储在数据库中。</p><p id="4a18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要确保我们的端点相应地处理意外的请求和错误响应。见下文:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="4d03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以查看存储库中的所有其他测试。</p><h1 id="10cb" class="mn lc iq bd ld mo mp mq lg mr ms mt lj mu mv mw lm mx my mz lp na nb nc ls nd bi translated">部署</h1><p id="424e" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">既然我们已经有了API和测试，我们可以将它们部署到AWS。请阅读我关于如何<a class="ae kc" href="https://sidneyb231.medium.com/configure-aws-for-development-and-deployment-ad822097fc22" rel="noopener">为部署</a>创建和配置AWS凭证和概要文件的文章。</p><p id="505b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了进行部署，我们可以通过在您的工作目录中运行以下命令来使用默认的AWS概要文件:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="5021" class="lb lc iq nh b gy nq nr l ns nt">$ serverless deploy </span></pre><p id="c4e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，如果您有多个概要文件，并且希望使用特定的概要文件进行部署，那么您必须运行以下命令:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="cb9c" class="lb lc iq nh b gy nq nr l ns nt">$ serverless deploy --stage dev</span></pre><p id="685d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将使用为<code class="fe ne nf ng nh b">dev</code>阶段设置的概要文件进行部署。底部的服务信息应该如下所示:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="22d8" class="lb lc iq nh b gy nq nr l ns nt">Service Information<br/>service: serverless-todo<br/>stage: dev<br/>region: eu-west-1<br/>stack: serverless-todo-dev<br/>resources: 63<br/>api keys:<br/>  None<br/>endpoints:<br/>  POST - https://&lt;API-GATEWAY-ID&gt;.execute-api.eu-west-1.amazonaws.com/dev/list/create<br/>  POST - https://&lt;API-GATEWAY-ID&gt;.execute-api.eu-west-1.amazonaws.com/dev/list/delete<br/>  POST - https://&lt;API-GATEWAY-ID&gt;.execute-api.eu-west-1.amazonaws.com/dev/list<br/>  POST - https://&lt;API-GATEWAY-ID&gt;.execute-api.eu-west-1.amazonaws.com/dev/list/update<br/>  POST - https://&lt;API-GATEWAY-ID&gt;.execute-api.eu-west-1.amazonaws.com/dev/task/create<br/>  POST - https://&lt;API-GATEWAY-ID&gt;.execute-api.eu-west-1.amazonaws.com/dev/task/delete<br/>  POST - https://&lt;API-GATEWAY-ID&gt;.execute-api.eu-west-1.amazonaws.com/dev/task<br/>  POST - https://&lt;API-GATEWAY-ID&gt;.execute-api.eu-west-1.amazonaws.com/dev/task/update<br/>functions:<br/>  createList: serverless-todo-dev-createList<br/>  deleteList: serverless-todo-dev-deleteList<br/>  getList: serverless-todo-dev-getList<br/>  updateList: serverless-todo-dev-updateList<br/>  createTask: serverless-todo-dev-createTask<br/>  deleteTask: serverless-todo-dev-deleteTask<br/>  getTask: serverless-todo-dev-getTask<br/>  updateTask: serverless-todo-dev-updateTask<br/>layers:<br/>  None</span></pre><p id="32d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这有一个创建的API端点的列表。还要注意，在我们的例子中，<code class="fe ne nf ng nh b"><strong class="kf ir">eu-west-1</strong></code>是我们的API网关区域，<code class="fe ne nf ng nh b"><strong class="kf ir">&lt;API-GATEWAY-ID&gt;</strong></code>是我们的API网关ID。</p><p id="9d20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">部署应用程序时，您可能会遇到一些问题。在<a class="ae kc" href="https://seed.run/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Seed </strong> </a>的团队已经创建了一个<a class="ae kc" href="https://seed.run/docs/serverless-errors/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">汇编最常见的无服务器错误</strong> </a>以及如何修复它们。</p><p id="1390" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们对我们的功能进行更改时，我们也可以使用<code class="fe ne nf ng nh b">serverless deploy function</code>命令来部署单个功能，从而避免经历整个部署周期。例如，我们可以运行以下命令来再次部署<strong class="kf ir"> createList </strong>函数:</p><pre class="ni nj nk nl gt nm nh nn no aw np bi"><span id="797f" class="lb lc iq nh b gy nq nr l ns nt">$ serverless deploy function -f createList</span></pre><h2 id="8b8b" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">公共API架构</h2><p id="0b4f" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">作为参考，这是我们目前的API:</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/cccac9704d9696d54f92712de47263be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pHXAHcJ12Ium372IwQb8Og.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">应用架构</figcaption></figure><p id="58e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简而言之，一个用户向我们的无服务器API发出请求，它首先点击我们的API网关端点，然后根据请求的端点，请求被转发到适当的Lambda函数。</p><p id="126a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的API网关端点被允许调用在我们的<code class="fe ne nf ng nh b"><strong class="kf ir">serverless.ts</strong>.</code>中定义的Lambda函数。此外，由于权限也在<code class="fe ne nf ng nh b"><strong class="kf ir">serverless.ts</strong></code>中的<strong class="kf ir"> iamRoleStatements </strong>块中定义，我们的Lambda函数被允许连接到我们的DynamoDB表。</p><p id="2dc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能已经注意到，我们的API是公开可访问的，因此是不安全的，这意味着任何人都可以向我们的端点发送请求。解决这个问题的一个方法是扩展我们的应用程序来处理用户和身份验证。这将确保用户需要注册，然后登录进行身份验证。只有这样，他们才能创建和管理他们的待办事项列表。我们可以使用一些安全机制来做到这一点，包括<a class="ae kc" href="https://aws.amazon.com/cognito/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> AWS Cognito </strong> </a>和<a class="ae kc" href="https://auth0.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Auth0 </strong> </a>。对于这个应用程序，我选择使用一个定制的<a class="ae kc" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">API Gateway Lambda authorizer</strong></a>来验证对我们端点的请求。</p><p id="fd08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://sidneyb231.medium.com/creating-a-simple-serverless-application-using-typescript-and-aws-part-2-2f9192717015" rel="noopener">继续阅读本文的第二部分，看看我们如何控制对API的访问，接受和拒绝对端点的请求。</a></p><div class="ok ol gp gr om on"><a href="https://github.com/s-barrah/serverless-todo" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd ir gy z fp os fr fs ot fu fw ip bi translated">s-barrah/无服务器-todo</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">简单的无服务器todo应用程序您需要在本地安装以下软件包，然后再启动本地…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">github.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb jw on"/></div></div></a></div></div></div>    
</body>
</html>