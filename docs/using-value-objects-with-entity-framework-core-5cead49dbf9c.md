# 通过实体框架核心使用值对象

> 原文：<https://levelup.gitconnected.com/using-value-objects-with-entity-framework-core-5cead49dbf9c>

![](img/a90f160d8981fe26bde9dfff30acfc46.png)

[活动发起人](https://unsplash.com/@campaign_creators?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

如果让你在数据库中存储一个邮政地址，你会怎么做？可能是代表城市、州、邮政、国家和街道的几列。你完全可以这么做，但这看起来很奇怪，对吗？将所有这些属性作为参数传递给方法或其他对象将是一件苦差事。作为优秀的开发人员，您可能会倾向于创建一个用这些字段表示地址的对象:

酷，现在我们可以开始在我们的应用程序代码中使用它了。但是，我们仍然有映射到领域层和从领域层映射的问题。请记住，如果我们要查询一个“Order”对象，该对象包含前面提到的所有字符串属性，那么我们需要创建一个映射来从域实体中提取这些属性，并将它们映射到我们新创建的“Address”对象，反之亦然。嘘！这是站不住脚的，没有人有时间这样做——我是一名开发人员，必须遵守我懒惰的天性。

我给大家介绍一个概念，叫做值对象。简而言之，它基本上是一个表示内聚复合概念的对象。听起来很熟悉，是吧？如果你做 OOP 已经有一段时间了，这应该是。无论如何，作为一个例子，考虑一个对象，如坐标 2D。这个值对象有两个属性:“x”和“y”。很容易吗？很好。那么，这如何适应实体框架核心(EF 核心)和整个地址的事情呢？我快到了。所以 EF 核心允许你在你的域实体中使用这些值对象。这意味着我们的“订单”类可以从:

收件人:

最棒的是，EF 内核可以自动为我们处理映射。但没那么快。只是没那么容易。抱歉:`(

跟着我，你的时间会得到回报。我保证！

# 创建我们的值对象基类

为什么是基类？难道我们不能从上面的地址类中提取一段代码并使用它吗？你可以，但是这不仅会给你带来问题，还会给你团队中任何需要与之互动的人带来问题。让我解释一些任何值对象都必须遵守的简单规则:

*   他们没有身份。
*   它们必须是不可变的。

仔细阅读这些。记住它们。梦见他们..好吧，别这样。那么这对我们的“地址”对象意味着什么呢？好吧，让我们再来看看:

规则#1 似乎在这里被检查；这个对象中没有身份属性，而且，以后我们也不会用实体框架(EF)来配置它。规则#2 在这里没有被检查。解决这个问题最简单的方法是将 public setter 改为 private。但是，让我们先来看看这个基类的实现。根据微软:

[https://docs . Microsoft . com/en-us/dot net/standard/microservice-architecture/microservice-DDD-cqrs-patterns/implement-value-objects # value-object-implementation-in-c](https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/microservice-ddd-cqrs-patterns/implement-value-objects#value-object-implementation-in-c)

这个类只是实现了一些基本的东西，比如等式比较和 EF 所需的其他基础知识。最重要的是，它还将标记我们的派生类，这对我们很有用，您将在本文后面了解到。

# 从我们的基类派生对象

现在我们有了一个基类，让我们将它应用于我们的“地址”类。

# 配置实体以使用值对象

公平的警告，我使用流畅的 API 来配置我的域实体，我个人不容忍属性的使用(你知道你是谁)。现在，我已经说了，我们的“Address”类已经成形，让我们继续用我们的域实体来配置它。为此，我们将使用前面的“Order”类作为示例:

是时候将我们的焦点转移到实体配置上了。这提醒了我。我喜欢使用类风格的配置，而不是在“DbContext”类中配置所有东西。但是，只要您觉得合适，就可以随意实现实体配置。因此，我们对“Order”类的配置如下所示:

注意这里的“OwnsOne”方法。这将告诉 EF 我们的“订单”实体想要使用一个值对象。然而，关于这种方法如何工作，它能做什么和不能做什么，有一些重要的事情需要引起你的注意。这是直接取自微软的“[实现值对象](https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/microservice-ddd-cqrs-patterns/implement-value-objects#additional-details-on-owned-entity-types)”一字不差:

## 关于所有实体类型的其他详细信息

*   当您使用 OwnsOne fluent API 将导航属性配置为特定类型时，会定义所拥有的类型。
*   在我们的元数据模型中，所拥有类型的定义由以下几部分组成:所有者类型、导航属性和所拥有类型的 CLR 类型。
*   堆栈中拥有类型实例的标识(键)是拥有者类型的标识和拥有类型的定义的组合。

## 拥有的实体能力:

*   拥有的类型可以引用其他实体，无论是拥有的(嵌套拥有的类型)还是不拥有的(对其他实体的常规引用导航属性)。
*   您可以通过单独的导航属性将同一 CLR 类型映射为同一所有者实体中的不同所有者类型。
*   表拆分是按照约定设置的，但是您可以通过使用 ToTable 将所拥有的类型映射到不同的表来退出。
*   在拥有的类型上自动执行急切加载，即不需要在查询上调用 Include()。
*   从 EF Core 2.1 开始，可以配置属性[Owned]

## 自有实体限制:

*   您不能创建拥有类型的数据库集<t>(根据设计)。</t>
*   您不能调用模型构建器。拥有的类型上的实体<t>()(目前按设计)。</t>
*   还没有拥有类型的集合(从 EF Core 2.1 开始，但是在 2.2 中将支持它们)。
*   不支持与所有者映射在同一表中的可选(即可为 null)拥有的类型(即使用表拆分)。这是因为映射是针对每个属性进行的，我们没有针对整个空复数值 a 的单独标记。
*   不支持拥有类型的继承映射，但是您应该能够将相同继承层次结构的两个叶类型映射为不同的拥有类型。EF 核心不会考虑它们属于同一层级的事实。

# 数据库表中会出现什么

这需要做很多工作，但是现在创建新的值对象并将它们绑定到您的域实体已经很简单了。但是，有关于如何配置实体的选项。如前所述，您可以选择不进行表拆分，这实际上是将我们的“Address”类的所有字段放入您设置名称的表中。例如，附加以下内容:

```
.ToTable("OrderAddresses");
```

方法将在 Order 表和 OrderAddresses 表之间创建一对多关系。

另一件需要注意的事情是 EF 强加给值对象的默认命名约定。还记得在保存地址值对象的“Order”类中我们的属性名是什么吗？

```
public Address Address { get; set; }
```

因此，实体将采用该属性的名称，并将其作为包含在该值对象中的属性名称的前缀。因此，Order 表中的列将具有以下内容:

*   地址 _ 街道
*   地址 _ 城市
*   地址 _ 州
*   地址 _ 国家
*   地址 _ 邮政编码

不喜欢吗？没问题，您可以通过 fluent API 覆盖此配置:

打电话。属性()允许您使用实体中其他列上的普通配置选项。

用得着要求吗？

我想你已经找到窍门了。

# 结束了。

我们在这里讨论了很多材料。我将链接到这方面的另一个部分，讨论在试图保存具有空值对象的实体时绕过可空问题的一个聪明的方法。在那之前。下次见！

**第二部分** : [如何在实体框架核心中拥有可空的拥有类型](https://medium.com/@austin.davies0101/how-to-have-nullable-owned-types-in-entity-framework-core-84ed9f112878)