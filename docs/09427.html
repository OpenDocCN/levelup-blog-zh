<html>
<head>
<title>Building Kafka-compatible Streaming &amp; Batch Workers in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python构建Kafka兼容的流和批处理工作器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-kafka-compatible-streaming-batch-workers-in-python-8762ef769974?source=collection_archive---------4-----------------------#2021-08-10">https://levelup.gitconnected.com/building-kafka-compatible-streaming-batch-workers-in-python-8762ef769974?source=collection_archive---------4-----------------------#2021-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="43bf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建一个具有正常关机能力的可靠的工作器</h2></div><p id="708b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文原载<a class="ae le" href="https://www.fadhil-blog.dev/blog/streaming-batch-worker/" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/e9e85a31b762b9d94e3a1fa0cce431d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oJARHr7ZMSgOTPW6"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@isisfra?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Isis frana</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="302b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是工人？</h1><p id="62f1" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">worker是一个程序，<strong class="kk iu">监听你系统中的事件</strong> <strong class="kk iu">并在后台异步执行动作</strong><strong class="kk iu"/>。异步意味着工作者在请求-响应周期之外的背景中执行动作，因此用户不必等待执行完成。例如，当一个新用户注册到您的SaaS产品时，一个工作人员将监听用户注册事件并发送一封欢迎电子邮件。在本文中，我们将继续这个例子。</p><p id="bc2a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一般来说，有两种类型的工人:</p><ul class=""><li id="9aa4" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated"><strong class="kk iu">流式工作器</strong>将立即处理工作器看到的每条消息。在我们的案例中，每次用户注册我们的服务，我们都会立即向他们发送一封欢迎电子邮件。</li><li id="233b" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated"><strong class="kk iu">批处理工作器</strong>会将消息累积到一个缓冲队列中，并且只在它们满足特定条件时才进行处理，例如每5秒一次。在我们的例子中，当一个用户注册我们的服务时，工作人员将等待5秒钟来累积所有注册的用户，然后向他们批量发送一封欢迎电子邮件。</li></ul><p id="5bc0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这两种类型的工作者在他们的用例中都很棒。在大多数情况下，流媒体工作者是为您服务的，就像在注册您的服务后立即向用户发送欢迎电子邮件一样。但是有些操作批量做的话效率会高很多。例如，由于其分析数据库引擎的性质，Clickhouse DB更喜欢大批量插入的数据，而不是小批量频繁插入的数据。这时，您应该使用批处理工作进程，而不是流式工作进程。</p><h2 id="ca85" class="ng lw it bd lx nh ni dn mb nj nk dp mf kr nl nm mh kv nn no mj kz np nq ml nr bi translated">正常关机</h2><p id="a2ef" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">正确处理服务终止至关重要。十二因素应用程序中的'<a class="ae le" href="https://12factor.net/disposability" rel="noopener ugc nofollow" target="_blank">可处置性</a>'规则表明，这些过程可以随时开始或停止。</p><p id="5de9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们的工作人员在用户每次注册时执行两个操作:</p><ul class=""><li id="6b72" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated">向用户发送电子邮件</li><li id="e1dd" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">将用户记录从“待定”状态更新为“等待确认”</li></ul><p id="f9a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果流工作器在刚刚向用户发送完电子邮件但尚未更新用户记录时被终止，会发生什么情况？数据库中的记录不会反映用户的最新状态。您已经发送了电子邮件，但是状态没有像预期的那样更新。</p><p id="7059" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在批量工人的情况下，情况要糟糕得多。如果批处理工作器在刚刚发送完电子邮件并更新了队列缓冲区中100个用户的记录时被终止，那么当前在队列缓冲区中的其余用户将永远不会收到他们的欢迎电子邮件。</p><p id="7ee3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你应该做的是，当<strong class="kk iu">工作者收到SIGTERM或SIGINT </strong>信号时，<strong class="kk iu">应该停止获取新消息，并在终止服务</strong>之前完成手头的所有任务。这两个信号通常用来通知你的程序你想关闭服务；例如，当您在终端中点击<code class="fe ns nt nu nv b">Ctrl+C</code>或在Kubernetes中终止一个pod时。</p><h1 id="b876" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我们将会建造什么</h1><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nw"><img src="../Images/80ed07ef60ba9641a4a301e4bef1fcfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TGtRkLNsP5vyG3dG11qwCQ.png"/></div></div></figure><p id="b2a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">生产者:</strong>将消息发布到消息队列代理的脚本。</p><p id="760b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">消息队列代理:</strong>我们将推出一个<a class="ae le" href="https://vectorized.io/redpanda" rel="noopener ugc nofollow" target="_blank"> Redpanda </a> docker容器。Redpanda是一个Kafka兼容的消息代理。</p><p id="dfe5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">收集工人:</strong>会监听经纪人消息，假装发邮件的工人&amp;更新用户状态。我们将在流方法和批处理方法中实现。</p><p id="8d10" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">注意:</strong>如果你使用的是Django或Flask这样的web框架，建议使用像<a class="ae le" href="https://docs.celeryproject.org/en/stable/index.html" rel="noopener ugc nofollow" target="_blank"> Celery </a>或<a class="ae le" href="https://python-rq.org/" rel="noopener ugc nofollow" target="_blank"> RQ </a>这样的异步任务队列库，因为它们集成得很好。</p><p id="cade" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文的目的是讨论流和批处理工作器是如何在幕后工作的。我们将构建最小化的工人来理解它们是如何工作的。</p><h1 id="8284" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">环境设置</h1><h2 id="0e06" class="ng lw it bd lx nh ni dn mb nj nk dp mf kr nl nm mh kv nn no mj kz np nq ml nr bi translated">Python环境</h2><p id="9a73" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">对于本教程，我在Ubuntu 19.04上使用Python 3.7.3。您需要安装Python Kafka库。</p><pre class="lg lh li lj gt nx nv ny nz aw oa bi"><span id="2eb4" class="ng lw it nv b gy ob oc l od oe">$ pip3 install kafka-python</span></pre><h2 id="315a" class="ng lw it bd lx nh ni dn mb nj nk dp mf kr nl nm mh kv nn no mj kz np nq ml nr bi translated">消息代理</h2><p id="ce89" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">运行以下命令启动Redpanda容器:</p><pre class="lg lh li lj gt nx nv ny nz aw oa bi"><span id="2da5" class="ng lw it nv b gy ob oc l od oe">docker run --name=redpanda-1 --rm -p 9092:9092 docker.vectorized.io/vectorized/redpanda:latest redpanda start --overprovisioned --smp 1 --memory 1G --reserve-memory 0M --node-id 0 --check=false</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi of"><img src="../Images/740593b656401e8e044c89c295e15a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I6pZwBBoLz9ck7VxGmk2JA.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">启动Redpanda容器</figcaption></figure><h1 id="40c4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">生产者</h1><p id="fc16" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">首先，我们会写信给我们的制作人。生产者将向我们的消息代理发布消息。创建包含以下内容的<code class="fe ns nt nu nv b">producer.py</code>文件:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="7f94" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请记住，生产者可以有多种形式。您可以编写一个向消息代理发布消息的API端点，一个爬行网站并向消息代理发布消息的爬虫，等等。</p><p id="a7b9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该生成器脚本的输出示例:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oi"><img src="../Images/dd28c68d8a1bb3e380e1308608e882bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FdTQEQGxVxVLjSM9H3D-YA.png"/></div></div></figure><p id="8f62" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，生产者脚本正在创建一个<code class="fe ns nt nu nv b">user_signups</code>主题，并向该主题发布10条消息。</p><h1 id="25cf" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">流媒体工作者</h1><p id="0e84" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">这是流式工作器的最小实现。它会监听Kafka <code class="fe ns nt nu nv b">user_signups</code>主题中的每一条消息，并在看到消息时立即进行处理。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="79eb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">设置一个组ID </strong>非常重要，这样消费者就可以将偏移量提交给代理。否则，每次您启动worker时，它将从头开始读取消息，而不是从您上次的最后一条消息开始。</p><p id="78c3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该工作线程的输出示例:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oj"><img src="../Images/b0ce759008d350c07470ecfccc5906e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dFtmMNxqjVBYDsxhd4ldfA.png"/></div></div></figure><p id="f877" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">按<code class="fe ns nt nu nv b">Ctrl+C</code>退出脚本。</p><p id="c2a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以看到它正在为每个用户逐一发送电子邮件和更新用户状态。</p><h2 id="19a1" class="ng lw it bd lx nh ni dn mb nj nk dp mf kr nl nm mh kv nn no mj kz np nq ml nr bi translated">正常关机</h2><p id="13d3" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">要正常关闭流工作进程，该工作进程必须处理完当前正在处理的消息，然后退出进程。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="e6f2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当它接收到一个<strong class="kk iu"> SIGTERM或SIGINT信号</strong>时，它会将<code class="fe ns nt nu nv b">is_shutting_down</code>全局变量设置为True，关闭到代理的连接，并在处理完当前消息后立即退出脚本。关闭与代理的连接将提交分区中的偏移量，因此下次运行时不会处理相同的消息。</p><p id="4f40" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在运行这个脚本之前，记得再次运行<code class="fe ns nt nu nv b">producer.py</code>脚本来再次发布消息。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ok"><img src="../Images/e8501637cc8f6c7d8f40a130f2ef8665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*pIOcrlNJYtcMLyZ0dSmFBg.gif"/></div></div></figure><p id="4778" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的示例输出中，我多次按下了<code class="fe ns nt nu nv b">Ctrl+C</code>。但是，该工作线程在完成当前操作之前不会立即停止。成功更新用户状态后，只有it部门会终止该流程。这正是我们想要的。</p><h1 id="3aa4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">分批工人</h1><p id="d66e" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">对于批处理工作者，我们将利用Python多线程特性。主线程将每隔5秒处理一次队列缓冲区中的消息。我们将生成一个子线程来监听来自消息代理的消息，并将数据插入队列缓冲区。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="0ceb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您需要再次运行<code class="fe ns nt nu nv b">producer.py</code>脚本来向主题发布消息。这是批处理工作程序的示例输出:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ol"><img src="../Images/e18b47a702ae0fbf84c0f44526e09a49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cFCOuZWz3bNVt40-nRvhOA.png"/></div></div></figure><p id="d8eb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，它同时发送电子邮件和更新用户。这就是批处理工作器的美妙之处，在一次调用中合并所有有效负载。</p><h2 id="0a8c" class="ng lw it bd lx nh ni dn mb nj nk dp mf kr nl nm mh kv nn no mj kz np nq ml nr bi translated">正常关机</h2><p id="a400" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">要正常关闭批处理工作进程，该工作进程必须:</p><ol class=""><li id="8e1e" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld om my mz na bi translated">停止从代理获取新消息</li><li id="fac1" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld om my mz na bi translated">关闭代理连接</li><li id="879a" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld om my mz na bi translated">最后一次处理当前缓冲区中的所有消息</li><li id="1258" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld om my mz na bi translated">最后，退出流程</li></ol><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="7b22" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个具有正常关闭功能的批处理工作脚本的示例。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ok"><img src="../Images/7c9ec5443301737e228e0b9d4704bccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*tTe3MszEx9CLwo_ve3SKMQ.gif"/></div></div></figure><p id="a8ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您在这里看到的，当我按下<code class="fe ns nt nu nv b">Ctrl+C</code>时，worker将停止监听新消息，并处理队列缓冲区中的消息，直到所有消息都处理完。检查过了！</p><h1 id="59ed" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="b823" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">本教程中有两个重要的概念:</p><ul class=""><li id="50c4" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated">流式和批处理工人</li><li id="2310" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">正常关机</li></ul><p id="39ca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这两个概念都与语言和代理无关。这个概念适用于所有编程语言和所有代理。你可以把同样的概念带到Go，Ruby，Javascript等等。语言与卡夫卡、小熊猫、NATS、RabbitMQ等。消息代理。</p><p id="4c80" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望你能从这篇文章中学到一些东西。<a class="ae le" href="https://www.buymeacoffee.com/sdil" rel="noopener ugc nofollow" target="_blank">请支持我多写些教程</a>。</p><h1 id="cb79" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考</h1><ul class=""><li id="ad32" class="ms mt it kk b kl mn ko mo kr on kv oo kz op ld mx my mz na bi translated">https://github.com/dpkp/kafka-python/blob/master/example.py<a class="ae le" href="https://github.com/dpkp/kafka-python/blob/master/example.py" rel="noopener ugc nofollow" target="_blank"/></li><li id="f8ef" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">【https://papercups.io/blog/genserver T4】</li></ul></div></div>    
</body>
</html>