<html>
<head>
<title>OOD in Python — Managing Dependencies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的OOD管理依赖关系</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ood-in-python-managing-dependencies-887cd2dc6712?source=collection_archive---------13-----------------------#2020-10-19">https://levelup.gitconnected.com/ood-in-python-managing-dependencies-887cd2dc6712?source=collection_archive---------13-----------------------#2020-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7402" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Sandi Metz写的《实用的面向对象设计》是一部关于永恒的和基本的OOD知识的杰作。为了加深理解，我总结了每一章，并用Python重写了示例代码。当然，如果你想得到更多的细节，请得到这本书。</p><p id="d067" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文是第3章“管理依赖”的摘要。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/35f33978b4f3559e44b7db12ccd21fe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Es4ltH-AHKmKuUvVLjzPlQ.png"/></div></div></figure><p id="6e71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://github.com/shotin93/object-oriented-design-in-python" rel="noopener ugc nofollow" target="_blank">https://github . com/shotin 93/object-oriented-design-in-python</a></p><h1 id="519d" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">了解依赖关系</h1><p id="fff5" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">当一个对象依赖于另一个对象时，如果一个对象改变，另一个对象可能会被迫改变。</p><p id="f054" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">示例代码如下:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="6e9d" class="mg kz iq mc b gy mh mi l mj mk">class Gear:<br/>  def __init__(self, chainring, cog, rim, tire):<br/>    self.chainring = chainring<br/>    self.cog = cog<br/>    self.rim = rim<br/>    self.tire = tire</span><span id="6e97" class="mg kz iq mc b gy ml mi l mj mk">  def ratio(self):<br/>    return self.chainring / float(self.cog)</span><span id="bfd3" class="mg kz iq mc b gy ml mi l mj mk">  def gear_inches(self):<br/>    return self.ratio() * Wheel(self.rim, self.tire).diameter()</span><span id="dfa7" class="mg kz iq mc b gy ml mi l mj mk">class Wheel:<br/>  def __init__(self, rim, tire):<br/>    self.rim = rim<br/>    self.tire = tire</span><span id="994a" class="mg kz iq mc b gy ml mi l mj mk">  def diameter(self):<br/>    return self.rim + (self.tire * 2)</span><span id="8476" class="mg kz iq mc b gy ml mi l mj mk">Gear(52, 11, 26, 1.5).gear_inches()</span></pre><p id="0c2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">齿轮类对车轮类的依赖性至少为4。</p><ul class=""><li id="c323" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">Gear希望名为Wheel的类存在。</li><li id="8746" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">Gear期望轮子实例响应直径。</li><li id="b1db" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">Gear知道Wheel()需要轮辋和轮胎。</li><li id="38c8" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">Gear知道Wheel()的第一个参数必须是rim，第二个参数是tire。</li></ul><p id="99c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些相关性导致齿轮等级将由于车轮等级的改变而被迫改变。</p><p id="b565" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Gear类对Wheel类了解得越多，它们之间的耦合就越紧密。两个对象耦合得越紧密，它们就变得像一个单独的对象。</p><p id="c9f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果发生这种情况，当车轮等级改变时，你必须改变齿轮等级。当你想只使用齿轮类时，轮类就出现了。当你想测试齿轮等级时，你必须测试车轮等级。</p><h1 id="3d4f" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">编写松散耦合的代码</h1><p id="7a66" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在下一个示例代码中，Gear类期望用一个可以响应diameter的对象来初始化，而不是期望一个名为Wheel的类存在。</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="feed" class="mg kz iq mc b gy mh mi l mj mk">class Gear:<br/>  def __init__(self, chainring, cog, wheel):<br/>    self.chainring = chainring<br/>    self.cog = cog<br/>    self.wheel = wheel</span><span id="5e61" class="mg kz iq mc b gy ml mi l mj mk">def ratio(self):<br/>    return self.chainring / float(self.cog)</span><span id="a731" class="mg kz iq mc b gy ml mi l mj mk">def gear_inches(self):<br/>    return self.ratio() * self.wheel.diameter()</span><span id="144f" class="mg kz iq mc b gy ml mi l mj mk">class Wheel:<br/>  def __init__(self, rim, tire):<br/>    self.rim = rim<br/>    self.tire = tire</span><span id="a285" class="mg kz iq mc b gy ml mi l mj mk">def diameter(self):<br/>    return self.rim + (self.tire * 2)</span><span id="152f" class="mg kz iq mc b gy ml mi l mj mk">Gear(52, 11, Wheel(26, 1.5)).gear_inches()</span></pre><p id="ab80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个变化很小，但是这个变化带来巨大的好处。Gear现在可以与任何具有直径的对象协作，并且对象不需要命名为Wheel。通过代码行的数量减少而不是增加，带来好处。</p><h2 id="e03a" class="mg kz iq bd la na nb dn le nc nd dp li jy ne nf lm kc ng nh lq kg ni nj lu nk bi translated">隔离依赖性</h2><p id="dd39" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">然而，这个样本是理想情况。当您使用现有应用程序时，可能会受到严重的限制。</p><p id="e6d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">隔离实例创建</strong></p><p id="7eb0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以隔离实例创建，如下面的两个示例:</p><p id="b59d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Sample1实例创建被移至构造函数。</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="8169" class="mg kz iq mc b gy mh mi l mj mk">class Gear:<br/>  def __init__(self, chainring, cog, rim, tire):<br/>    self.chainring = chainring<br/>    self.cog = cog<br/>    self.wheel = Wheel(rim, tire)</span><span id="75b5" class="mg kz iq mc b gy ml mi l mj mk">  def gear_inches(self):<br/>    return self.ratio() * self.wheel.diameter()</span></pre><p id="2d65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">示例2 —方法中定义了实例创建。</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="13e6" class="mg kz iq mc b gy mh mi l mj mk">class Gear:<br/>  def __init__(self, chainring, cog, rim, tire):<br/>    self.chainring = chainring<br/>    self.cog = cog<br/>    self.rim = rim<br/>    self.tire = tire</span><span id="0167" class="mg kz iq mc b gy ml mi l mj mk">  def gear_inches(self):<br/>    return self.ratio() * self.wheel().diameter()</span><span id="9e70" class="mg kz iq mc b gy ml mi l mj mk">  def wheel(self):<br/>    return Wheel(self.rim, self.tire)</span></pre><p id="2ce8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，这两个样本仍然知道得太多，但是，gear_inches中的依赖项数量已经减少。</p><p id="72a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">隔离外部消息</strong></p><p id="7526" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是时候把注意力转向外部信息了，也就是“发给自己以外的人”。例如，gear_inches向自身发送比率和车轮，但向车轮发送直径。</p><p id="0c72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要删除外部依赖，您可以将其封装在如下方法中:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="f43c" class="mg kz iq mc b gy mh mi l mj mk">class Gear:<br/>  def __init__(self, chainring, cog, rim, tire):<br/>    self.chainring = chainring<br/>    self.cog = cog<br/>    self.rim = rim<br/>    self.tire = tire</span><span id="0d7c" class="mg kz iq mc b gy ml mi l mj mk">  def gear_inches(self):<br/>    return self.ratio() * self.diameter()</span><span id="9c8e" class="mg kz iq mc b gy ml mi l mj mk">  def wheel(self):<br/>    return Wheel(self.rim, self.tire)</span><span id="2932" class="mg kz iq mc b gy ml mi l mj mk">  def diameter(self):<br/>    self.wheel().diameter()</span></pre><p id="67e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在原始代码中，gear_inches知道轮子有一个直径。齿轮现在隔离车轮()。diameter()和gear_inches可以依赖于发送给self的消息。</p><h2 id="d44c" class="mg kz iq bd la na nb dn le nc nd dp li jy ne nf lm kc ng nh lq kg ni nj lu nk bi translated">移除参数顺序依赖性</h2><p id="f0ba" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">作为发送者，你不可避免地要知道发送消息的参数。许多方法不仅需要参数，还需要按照收集顺序传递参数。</p><p id="a502" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在此示例中，Gear类需要三个参数来初始化，即链环、齿轮和车轮。它不提供默认值，参数必须按收集顺序传递。</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="7f19" class="mg kz iq mc b gy mh mi l mj mk">class Gear:<br/>  def __init__(self, chainring, cog, wheel):<br/>    self.chainring = chainring<br/>    self.cog = cog<br/>    self.wheel = wheel</span><span id="2e48" class="mg kz iq mc b gy ml mi l mj mk">...</span><span id="a619" class="mg kz iq mc b gy ml mi l mj mk">Gear(52, 11, Wheel(26, 1.5)).gear_inches()</span></pre><p id="0613" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">使用字典进行初始化参数</strong></p><p id="eb5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以使用字典(像Ruby中的hash)来避免依赖固定顺序的参数。下一个例子展示了这种技术。</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="b681" class="mg kz iq mc b gy mh mi l mj mk">class Gear:<br/>  def __init__(self, args):<br/>    self.chainring = args["chainring"]<br/>    self.cog = args["cog"]<br/>    self.wheel = args["wheel"]</span><span id="87e9" class="mg kz iq mc b gy ml mi l mj mk">...</span><span id="a4e5" class="mg kz iq mc b gy ml mi l mj mk">Gear(<br/>  {<br/>    "chainring": 52<br/>    , "cog": 11<br/>    , "wheel": Wheel(26, 1.5)<br/>  }<br/>).gear_inches()</span></pre><p id="8fe6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种技术有几个优点:</p><ul class=""><li id="0887" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">移除对参数顺序的所有依赖</li><li id="4768" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">Gear现在可以自由添加或删除初始化参数</li><li id="9e56" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">任何改变都不会对其他代码产生副作用</li></ul><p id="01d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">明确定义默认值</strong></p><p id="d674" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用Python中的“get”设置字典的默认值，如下所示:</p><pre class="km kn ko kp gt mb mc md me aw mf bi"><span id="a59a" class="mg kz iq mc b gy mh mi l mj mk">class Gear:<br/>  def __init__(self, args):<br/>    self.chainring = args.get("chainring", 52)<br/>    self.cog = args.get("cog", 11)<br/>    self.wheel = args["wheel"]</span><span id="0da3" class="mg kz iq mc b gy ml mi l mj mk">...</span><span id="fda8" class="mg kz iq mc b gy ml mi l mj mk">Gear(<br/>  {<br/>    "wheel": Wheel(26, 1.5)<br/>  }<br/>).gear_inches()</span></pre><p id="d20b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，我们有任何其他方法来设置默认值，发送者不需要知道使用默认值需要的参数。</p><h1 id="151e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">管理依赖方向</h1><p id="9669" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">原书用一些有用的数字和较少的代码写了许多关于依赖方向的内容。我不会在这篇文章中写这些，因为这不是这本书的副本。如果你想要更多的细节，请购买。</p><p id="1bda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上面可以看出，您可以删除对象之间的依赖关系。感谢您的阅读！</p></div></div>    
</body>
</html>