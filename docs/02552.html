<html>
<head>
<title>How To Declare And Use Ionic Modals With Stencil</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在模板中声明和使用离子模态</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-declare-and-use-ionic-modals-with-stencil-d5d97e69c930?source=collection_archive---------6-----------------------#2020-03-21">https://levelup.gitconnected.com/how-to-declare-and-use-ionic-modals-with-stencil-d5d97e69c930?source=collection_archive---------6-----------------------#2020-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9708" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何声明和使用带有模板的离子模式，包括传递参数、关闭动作和硬件后退按钮支持</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9a7d65de330b94b5ef17db63c42795dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MUxo-oCL6aB0QEjOH8AU3A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@tirzavandijk?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">蒂尔扎·范·迪克</a>在<a class="ae ky" href="https://unsplash.com/s/photos/free?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="2626" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我每天分享<a class="ae ky" href="https://medium.com/@david.dalbusco/one-trick-a-day-d-34-469a0336a07e" rel="noopener">一个窍门</a>直到2020年4月19日新冠肺炎隔离期结束。离希望中的好日子到来还有29天。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="7e92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本周，我们讨论了<a class="ae ky" href="https://stenciljs.com" rel="noopener ugc nofollow" target="_blank">模板</a>应用中<a class="ae ky" href="https://ionicframework.com" rel="noopener ugc nofollow" target="_blank">离子</a>模态的用法。我分享了我们在所有应用程序<a class="ae ky" href="https://deckdeckgo.com" rel="noopener ugc nofollow" target="_blank"> DeckDeckGo </a>中实现的解决方案，这是我们用于演示的开源编辑器，看起来效果不错。</p><p id="99de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管相关的Ionic Modal文档是自解释的，并且有很好的文档记录，但是当涉及到普通JavaScript或现代前端框架时，没有任何关于模板使用的信息。</p><p id="ab1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么，总而言之，我想我可以分享一篇关于这个特定主题的文章。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8b91" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">控制器</h1><p id="fd59" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你将Ionic与React或vanilla Javascript相比较，在模板中使用Ionic模态需要<strong class="lb iu">控制器</strong>，这可能是用法上的主要区别。</p><p id="5462" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为已经测试了Ionic的所有风格(除了Vue ),这仍然是我最喜欢的解决方案，因为我感觉更舒服，但我不确定它在未来会保持这样，因为许多开发人员包括一些团队本身更喜欢其他没有控制器的解决方案。因此，如果你在不久的将来读到这篇文章，先检查一下这些是否仍然存在😉。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3c8d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建一个模型</h1><p id="15db" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">模态本身就是一个组件。这就是为什么，如果我们想添加一个到我们的应用程序，我们首先创建一个新的组件，我宁愿不设置为阴影。这样做，就有可能轻松地继承CSS属性和应用程序的样式。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="102a" class="ne md it na b gy nf ng l nh ni">import {Component, Element, h} from '@stencil/core';<br/><br/>@Component({<br/>  tag: 'app-modal'<br/>})<br/>export class AppRemoteConnect {<br/>  @Element() el: HTMLElement;<br/><br/>  render() {<br/>    return [<br/>      &lt;ion-content class="ion-padding"&gt;Hello&lt;/ion-content&gt;<br/>    ]<br/>  }<br/><br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cb85" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">打开一个模态</h1><p id="19d5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如介绍中所述，要在模板中使用模态，我们将使用控制器。诀窍是将模态标记名作为变量<code class="fe nj nk nl na b">component</code>的值传递。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d969" class="ne md it na b gy nf ng l nh ni">import {Component, h} from '@stencil/core';<br/><br/>import {modalController} from '@ionic/core';<br/><br/>@Component({<br/>  tag: 'app-home',<br/>  styleUrl: 'app-home.css'<br/>})<br/>export class AppHome {<br/><br/>  private async openModal() {<br/>    const modal: HTMLIonModalElement =<br/>                 await modalController.create({<br/>      component: 'app-modal'<br/>    });<br/><br/>    await modal.present();<br/>  }<br/><br/>  render() {<br/>    return (<br/>      &lt;ion-content&gt;<br/>        &lt;ion-button onClick={() =&gt; this.openModal()}<br/>                    color="primary"&gt;<br/>          &lt;ion-label&gt;Open Modal&lt;/ion-label&gt;<br/>        &lt;/ion-button&gt;<br/>      &lt;/ion-content&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="f676" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一切都按照计划进行，一旦开始和打开，它应该看起来如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/8f4da52a13b67eae8f83736742030375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oi7_UdlrP21Wuwm5UyB4mw.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d1b4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">关闭模态</h1><p id="32e8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本章中，我们将探讨关闭模态的不同方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="66d8" class="ne md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">模式标题中的按钮</h2><p id="7b73" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了从自身关闭模态，我们使用文档引用来找到最近的<code class="fe nj nk nl na b">ion-modal</code>元素，以便调用公开的方法<code class="fe nj nk nl na b">dismiss</code>来实现这样的目标。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ab56" class="ne md it na b gy nf ng l nh ni">import {Component, Element, h} from '@stencil/core';<br/><br/>@Component({<br/>  tag: 'app-modal'<br/>})<br/>export class AppRemoteConnect {<br/>  @Element() el: HTMLElement;<br/><br/>  async closeModal() {<br/>    await (this.el.closest('ion-modal') as <br/>           HTMLIonModalElement).dismiss();<br/>  }<br/><br/>  render() {<br/>    return [<br/>      &lt;ion-header&gt;<br/>        &lt;ion-toolbar color="secondary"&gt;<br/>          &lt;ion-buttons slot="start"&gt;<br/>            &lt;ion-button onClick={() =&gt; this.closeModal()}&gt;<br/>              &lt;ion-icon name="close"&gt;&lt;/ion-icon&gt;<br/>            &lt;/ion-button&gt;<br/>          &lt;/ion-buttons&gt;<br/>        &lt;/ion-toolbar&gt;<br/>      &lt;/ion-header&gt;,<br/><br/>      &lt;ion-content class="ion-padding"&gt;Hello&lt;/ion-content&gt;<br/>    ]<br/>  }<br/><br/>}</span></pre><p id="54ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，如果一切正常，标题中的关闭按钮应该会显示出来。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/4ff3636802c0843653f445c810613f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZV2OKs1bzf6eqI0SJnR9jg.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="d4e9" class="ne md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">硬件后退按钮支持</h2><p id="9a70" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我已经有一段时间没有在Android上测试关闭模态的硬件后退按钮支持了，但我通常做的是在模态中添加一个导航监听器，它调用与我们之前定义的关闭函数相同的关闭函数。这种攻击是基于历史的，这就是为什么在加载模型时必须推送状态。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7085" class="ne md it na b gy nf ng l nh ni">import {Listen} from '@stencil/core';</span><span id="96fd" class="ne md it na b gy ny ng l nh ni">async componentDidLoad() {<br/>  history.pushState({modal: true}, null);<br/>}</span><span id="47be" class="ne md it na b gy ny ng l nh ni">@Listen('popstate', {target: 'window'})<br/>async handleHardwareBackButton(_e: PopStateEvent) {<br/>  await this.closeModal();<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="55f1" class="ne md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">背景解散</h2><p id="6aad" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">默认情况下，可以通过点击背景来关闭模态。如果您希望禁用此选项，您必须在控制器级别指定它。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="592d" class="ne md it na b gy nf ng l nh ni">const modal: HTMLIonModalElement = await modalController.create({<br/>  component: 'app-modal',<br/>  backdropDismiss: false<br/>});</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d971" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">传递参数</h1><p id="10ae" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这一章中，我们将参数从页面传递到模态，或者从另一个方向传递。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="6aac" class="ne md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">页面到模态</h2><p id="0072" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这可能是我尝试过的所有离子模态中最喜欢的。用模板传递参数超级容易。</p><p id="addb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要读取模态中的参数，我们只需定义属性(<code class="fe nj nk nl na b">@Prop()</code>)。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6633" class="ne md it na b gy nf ng l nh ni">import {Component, Element, h, Listen, Prop} from '@stencil/core';<br/><br/>@Component({<br/>  tag: 'app-modal'<br/>})<br/>export class AppRemoteConnect {<br/>  @Element() el: HTMLElement;<br/>  <br/>  @Prop()<br/>  greetings: string;<br/><br/>  @Listen('popstate', {target: 'window'})<br/>  async handleHardwareBackButton(_e: PopStateEvent) {<br/>    await this.closeModal();<br/>  }<br/><br/>  async closeModal() {<br/>    await (this.el.closest('ion-modal')<br/>           as HTMLIonModalElement).dismiss();<br/>  }<br/><br/>  render() {<br/>    return [<br/>      &lt;ion-header&gt;<br/>        &lt;ion-toolbar color="secondary"&gt;<br/>          &lt;ion-buttons slot="start"&gt;<br/>            &lt;ion-button onClick={() =&gt; this.closeModal()}&gt;<br/>              &lt;ion-icon name="close"&gt;&lt;/ion-icon&gt;<br/>            &lt;/ion-button&gt;<br/>          &lt;/ion-buttons&gt;<br/>        &lt;/ion-toolbar&gt;<br/>      &lt;/ion-header&gt;,<br/><br/>      &lt;ion-content class="ion-padding"&gt;<br/>           {this.greetings}<br/>      &lt;/ion-content&gt;<br/>    ]<br/>  }<br/><br/>}</span></pre><p id="5edb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们通过控制器。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3f18" class="ne md it na b gy nf ng l nh ni">private async openModal() {<br/>  const modal: HTMLIonModalElement = await modalController.create({<br/>    component: 'app-modal',<br/>    backdropDismiss: false,<br/>    componentProps: {<br/>      greetings: 'Yolo'<br/>    }<br/>  });<br/><br/>  await modal.present();<br/>}</span></pre><p id="c884" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么都没有了，什么都没有了，真的很容易。我喜欢这样的解决方案。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/bfbd1a9fce8d4e399a24d185289ab077.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t5Ri1zehrQLJSVRHnt529w.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="a66a" class="ne md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">模式到页面</h2><p id="1de0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可能需要将结果从模式传递到页面或调用组件。为此，我们使用函数<code class="fe nj nk nl na b">dismiss</code>，就像关闭模态函数一样，但是我们传递一个对象作为参数。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="067a" class="ne md it na b gy nf ng l nh ni">async closeModalWithParams(greetings: string) {<br/>  await (this.el.closest('ion-modal')<br/>        as HTMLIonModalElement).dismiss(greetings);<br/>}</span><span id="61b4" class="ne md it na b gy ny ng l nh ni">&lt;ion-button onClick={() =&gt; this.closeModalWithParams('Hello')}&gt;<br/>     Say Hello!<br/>&lt;/ion-button&gt;</span></pre><p id="dfc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我将这个新动作与一个新按钮链接起来。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/895371bea0d4a7dfc7c23908a9a487c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qMxPYUnuhe4jtFicx5_yjQ.png"/></div></div></figure><p id="2865" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，为了处理结果，我们监听模态的<code class="fe nj nk nl na b">onDidDismiss</code>事件，并继续处理作为回调传递的细节。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5d26" class="ne md it na b gy nf ng l nh ni">import {Component, h, State} from '@stencil/core';<br/><br/>import {modalController, OverlayEventDetail} from '@ionic/core';<br/><br/>@Component({<br/>  tag: 'app-home',<br/>  styleUrl: 'app-home.css'<br/>})<br/>export class AppHome {<br/><br/>  @State()<br/>  private greetingsResult: string;<br/><br/>  private async openModal() {<br/>    const modal: HTMLIonModalElement =<br/>                 await modalController.create({<br/>      component: 'app-modal',<br/>      backdropDismiss: false,<br/>      componentProps: {<br/>        greetings: 'Yolo'<br/>      }<br/>    });<br/><br/>    modal.onDidDismiss().then(<br/>          async (detail: OverlayEventDetail) =&gt; {<br/>      this.greetingsResult = detail.data;<br/>    });<br/><br/>    await modal.present();<br/>  }<br/><br/>  render() {<br/>    return (<br/>      &lt;ion-content&gt;<br/>        &lt;ion-button onClick={() =&gt; this.openModal()} <br/>                    color="primary"&gt;<br/>          &lt;ion-label&gt;Open Modal&lt;/ion-label&gt;<br/>        &lt;/ion-button&gt;<br/><br/>        &lt;ion-label&gt;{this.greetingsResult}&lt;/ion-label&gt;<br/>      &lt;/ion-content&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="89f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了呈现结果，我使用了一个状态作为演示目的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/df4aff625bc748c0ec9059831f3818c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fCDBeVvWKiRktdlAb7eTwQ.png"/></div></div></figure><p id="0cc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，您可以使用两种基本类型、复杂对象、回调或事件作为参数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f1e3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">蛋糕上的樱桃</h1><p id="79e5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">与<code class="fe nj nk nl na b">popovers.</code>的工作原理完全相同</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d03e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">看看它的实际效果</h1><p id="8172" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你有兴趣看模板应用程序中使用的离子模态，在你的下一张幻灯片中试试<a class="ae ky" href="https://deckdeckgo.com" rel="noopener ugc nofollow" target="_blank"> DeckDeckGo </a>😁。</p><p id="d0d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">呆在家里，注意安全！</p><p id="a860" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大卫</p></div></div>    
</body>
</html>