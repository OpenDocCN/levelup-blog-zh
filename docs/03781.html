<html>
<head>
<title>A Docker Free Intro to Containers (Write One on Your Own)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker免费介绍容器(自己写一个)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-docker-free-intro-to-containers-write-one-on-your-own-a12f2a0f2255?source=collection_archive---------24-----------------------#2020-05-26">https://levelup.gitconnected.com/a-docker-free-intro-to-containers-write-one-on-your-own-a12f2a0f2255?source=collection_archive---------24-----------------------#2020-05-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/43447fa3841c1ead8d3c7b05c9e25ad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2DUUCOkayOA_Yd3u1gQctQ.png"/></div></div></figure><p id="22bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">容器是允许您运行进程的操作系统技术的集合。容器本身是一项非常古老的技术，但是在引入Docker和他们为创建、部署和运送容器而构建的软件系统之后，它使得容器被广泛采用。我们将看看在没有docker的情况下构建一个容器所需的原子单元，这样你就可以跳过像“轻量级VM”、“与docker有关的东西”、“穷人的虚拟化”这样的定义。</p><p id="d519" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么我们需要什么技术来创建自己的容器呢？</p><p id="14aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们先来看看一个OS为我们做了什么。操作系统运行进程，进程是一个实体，代表系统中要实现的基本工作单元。有一个<strong class="ka ir">进程控制块</strong>，它是一个由操作系统维护的表，其中借助一个称为PID(进程ID)的特殊数字来标识每个进程。它还有进程的状态以及特权、内存信息、环境变量、路径、子进程等。</p><p id="39e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个进程都有一个特定的根目录，该进程在其中执行。实际上，您可以在文件系统中名为<code class="fe kw kx ky kz b">/proc</code>的文件夹中或者通过运行一个命令来找到这些信息:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="7567" class="li lj iq kz b gy lk ll l lm ln">ps aux</span></pre><p id="1bd9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是它在我的机器上的样子:</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/c6102a5e4042891999d7326770c51975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O3OqQn1yu0xipuXbyIslJw.png"/></div></div></figure><blockquote class="lp lq lr"><p id="34fa" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><em class="iq">关于这一点还有很多，但我们将继续关注Linux系统的高级概述。</em></p></blockquote><p id="b9c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我们能够创建一个进程并隔离它，这样它也可以在其他地方运行，而无需安装整个操作系统，我们可以称之为容器。为了隔离这个进程，也就是说，使它不可能在自己的文件夹之外寻找，我们需要“监禁”它。我们可以使用以下命令来实现:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="408a" class="li lj iq kz b gy lk ll l lm ln">chroot /path/to/new/root command</span></pre><p id="e528" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它将更改该进程及其子进程的根文件夹，因此该进程将无法访问该文件夹之外的任何内容。让我们作为超级用户遵循一些步骤:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="e8fa" class="li lj iq kz b gy lk ll l lm ln">mkdir my-new-root<br/>chroot my-new-root bash</span></pre><p id="8897" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们创建了一个新文件夹，然后使用<code class="fe kw kx ky kz b">chroot</code>命令“改变根目录”并在其中运行<code class="fe kw kx ky kz b">bash</code>命令。</p><p id="2482" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您应该会看到一些错误，如bash未找到或命令未被识别。参考以下截图:</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lw"><img src="../Images/4dcbd6c4ae55d501a5ef28375345b8ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DT3sSXLhLLYslE7w.png"/></div></div></figure><p id="3aa7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为命令bash运行在my-new-root内部，它不能访问新根目录之外的任何内容，所以它无法找到运行bash shell的程序。</p><p id="75be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要解决这个问题，请使用<code class="fe kw kx ky kz b">ldd</code>。<code class="fe kw kx ky kz b">ldd</code>打印程序运行所需的其他共享对象。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="d4e3" class="li lj iq kz b gy lk ll l lm ln">ldd /bin/bash</span></pre><p id="9dd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该命令输出运行某个程序所需的依赖关系:</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lx"><img src="../Images/bfe236fd2e54847eb71042129614e104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mb_e6RbBt0vGbLuoH_sPrw.png"/></div></div></figure><p id="cd57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们将它们复制到my-new-root中各自的文件夹中。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="3212" class="li lj iq kz b gy lk ll l lm ln">mkdir my-new-root/{bin,lib64,lib}<br/>cp /bin/bash my-new-root/bin<br/>cp /lib/x86_64-linux-gnu/libtinfo.so.5 /lib/x86_64-linux-gnu/libdl.so.2 /lib/x86_64-linux-gnu/libc.so.6 my-new-root/lib<br/>cp /lib64/ld-linux-x86-64.so.2 my-new-root/lib64</span></pre><p id="f415" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们创建了3个文件夹，bash所需的共享库位于其中(在lib和lib64下)。然后我们将这些对象复制到其中。</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lw"><img src="../Images/1f97e2c06747e0788f2ab4c55e35a5fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*X704wJ8zZ765rZhV.png"/></div></div></figure><p id="681e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我们运行<code class="fe kw kx ky kz b">chroot my-new-root bash</code>，它将在my-new-root内部打开一个bash shell。你可以通过<code class="fe kw kx ky kz b">pwd</code>来验证它，它应该输出<code class="fe kw kx ky kz b">/</code></p><blockquote class="lp lq lr"><p id="65d7" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><em class="iq">你为什么不试着在这也启用</em> <code class="fe kw kx ky kz b"><em class="iq">ls</em></code> <em class="iq">命令呢？</em></p></blockquote><p id="f22d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管我们的新根不能访问外部文件，但它可以看到主机容器上仍在运行的进程。如果我们想在同一个主机上运行多个容器，这对我们来说是行不通的。为了实现真正的隔离，我们还需要对其他进程隐藏这些进程。如果没有这样做，那么一个容器可以杀死进程的PID，卸载文件系统，或者改变其他容器的网络设置。每个进程位于UNIX世界中定义的7个名称空间之一。我们可以使用一个名为<code class="fe kw kx ky kz b">unshare</code>的命令来查看这些:</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lw"><img src="../Images/7fc9ffa6fa2aa235ec5ab0b660faf444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_q_WmIZA3F3Lohcw.png"/></div></div></figure><p id="2455" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到上面重要的7个名称空间。我们可以使用unshare命令来限制这些名称空间。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="38c5" class="li lj iq kz b gy lk ll l lm ln">unshare --mount --uts --ipc --net --pid --fork --user --map-root-user chroot my-new-root bash</span></pre><p id="d5af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们的新根已经限制了对来自这些名称空间的进程的访问。他们现在也可以获得重复的PID！那才是真正的孤立。</p><p id="f35c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一件事，名称空间不能像内存限制一样帮助我们限制物理资源。对于它们，我们有<code class="fe kw kx ky kz b">cgroups</code>，它本质上是一个文件，我们可以在其中收集PID并定义CPU、内存或网络带宽的限制。它之所以重要，是因为一个容器可以耗尽主机环境的资源(比如受到<a class="ae ly" href="https://www.imperva.com/learn/application-security/fork-bomb/" rel="noopener ugc nofollow" target="_blank"> fork bomb攻击</a>)供其他容器使用。</p><blockquote class="lp lq lr"><p id="8dc3" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><em class="iq">注意:Windows操作系统不容易受到传统的派生炸弹攻击，因为它们不能派生其他进程。</em></p></blockquote><p id="0424" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是我们如何做的(不要担心命令，我们只是在学习容器是由什么组成的)</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="c8cc" class="li lj iq kz b gy lk ll l lm ln"># outside of unshare'd environment get the tools we'll need here<br/>apt-get install -y cgroup-tools htop<br/><br/># create new cgroups<br/>cgcreate -g cpu,memory,blkio,devices,freezer:/sandbox<br/><br/># add our unshare'd env to our cgroup<br/>ps aux # grab the bash PID that's right after the unshare one<br/>cgclassify -g cpu,memory,blkio,devices,freezer:sandbox &lt;PID&gt;<br/># Set a limit of 80M<br/>cgset -r memory.limit_in_bytes=80M sandbox</span></pre><blockquote class="lp lq lr"><p id="3148" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><em class="iq">你可以在这里</em> 了解更多关于 <a class="ae ly" href="https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> cgroups</em></a></p></blockquote><p id="f6fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！现在我们已经创建了自己的容器。<br/> <strong class="ka ir">让我们在没有docker的情况下创建图像</strong></p><h1 id="d850" class="lz lj iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">形象</h1><p id="a531" class="pw-post-body-paragraph jy jz iq ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">图像本质上是作为文件对象的预制容器包。<br/>我们可以使用下面的命令将这个容器打包成一个压缩文件:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="52cf" class="li lj iq kz b gy lk ll l lm ln">tar cvf dockercontainer.tar my-new-root</span></pre><p id="704a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以将它运送到其他地方，并创建一个文件夹来解压缩它:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="6eb5" class="li lj iq kz b gy lk ll l lm ln"># make container-root directory, export contents of container into it<br/>mkdir container-root<br/>tar xf dockercontainer.tar -C container-root/</span><span id="5408" class="li lj iq kz b gy nb ll l lm ln"># make a contained user, mount in name spaces<br/>unshare --mount --uts --ipc --net --pid --fork --user --map-root-user chroot $PWD/container-root ash # change root to it<br/># mount needed things<br/># change cgroup settings<br/># etc</span></pre><p id="a237" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就这样？这意味着我们可以四处走动，使用这样的容器。不尽然，docker为你做的远不止这些。它为我们提供了一个令人敬畏的预烤图像注册表，联网，导入，导出，运行，标记，列表，杀死这些图像等。</p><h1 id="7a63" class="lz lj iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated"><strong class="ak">码头集装箱的好处</strong></h1><ol class=""><li id="588f" class="nc nd iq ka b kb mw kf mx kj ne kn nf kr ng kv nh ni nj nk bi translated">运行时:docker引擎允许我们使用不同的编译包，并在不同的操作系统上运行相同的包。它的运行时也提供了很好的工作流程优势</li><li id="4ab6" class="nc nd iq ka b kb nl kf nm kj nn kn no kr np kv nh ni nj nk bi translated">图像:强大的可移植性，图像注册，图像差异</li><li id="5807" class="nc nd iq ka b kb nl kf nm kj nn kn no kr np kv nh ni nj nk bi translated">自动化:你的容器可以通过一台本地计算机到达jenkins，所有的文件都包含一个配置文件。它还支持容器的缓存和多阶段构建。因此，映像构建非常快</li></ol><p id="48f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用Go编程语言编写的上述过程的例子可以在这里找到<a class="ae ly" href="https://github.com/lizrice/containers-from-scratch/blob/master/main.go" rel="noopener ugc nofollow" target="_blank"/>和它的伴随<a class="ae ly" href="https://youtu.be/_TsSmSu57Zo" rel="noopener ugc nofollow" target="_blank">视频</a>。</p><p id="a2fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在以后的文章中讨论所有这些。谢谢你坚持到这篇文章的结尾。</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/828ea43ffdd4cbb0a778a93f851518f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/1*ooFcQpVzE3O3es1PnNwuGA.gif"/></div></figure><p id="7e9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果对你有所帮助，请分享。你可以在<a class="ae ly" href="https://twitter.com/dpkahuja" rel="noopener ugc nofollow" target="_blank">推特</a>上向我问好。保重:)</p></div></div>    
</body>
</html>