<html>
<head>
<title>Log Kubernetes Statefulsets Using Prometheus + Grafana in EKS Fargate and Enable CI/CD Using Jenkins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在EKS法盖特使用Prometheus + Grafana记录Kubernetes状态集，并使用Jenkins启用CI/CD</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-monitor-your-database-statefulsets-using-prometheus-grafana-and-enable-ci-cd-using-1b8a1447529a?source=collection_archive---------4-----------------------#2022-06-15">https://levelup.gitconnected.com/how-to-monitor-your-database-statefulsets-using-prometheus-grafana-and-enable-ci-cd-using-1b8a1447529a?source=collection_archive---------4-----------------------#2022-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7d51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的<a class="ae kl" href="https://medium.com/@shrut_terminator/how-to-deploy-a-multi-container-two-tier-go-application-in-eks-fargate-6266494f5bcf" rel="noopener">上一篇文章</a>中，我们探索了在EKS法盖特上部署一个2层多容器应用程序。我们探索了部署statefulsets，并通过AWS ALB控制器公开了我们的应用程序。</p><p id="9801" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们通过使用Prometheus启用日志记录，将我们的应用程序功能扩展到一个更加以生产为中心的环境。我们将探索使用Prometheus操作符启用Postgres数据库日志记录的步骤。由于<a class="ae kl" href="https://docs.aws.amazon.com/eks/latest/userguide/fargate.html#:~:text=Daemonsets%20aren't%20supported%20on,HostNetwork%20in%20the%20pod%20manifest." rel="noopener ugc nofollow" target="_blank"> daemonsets在EKS法盖特</a>不被支持，我们将为statefulsets创建我们自己的side car容器，并使用Prometheus和Grafana收集度量。最后，我们将创建一个CI/CD解决方案，以便在几分钟内交付！</p><p id="9579" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，Fargate上的EKS不支持Prometheus，因为Fargate只在EFS上运行，而Prometheus在EBS卷上运行。因此，在本教程中，我们将为Prometheus和Kube系统创建一个带有worker节点的新集群。本质上，我们将只为部署应用程序的默认名称空间创建fargate概要文件。然后，我们将扩展我们以前的应用程序，为有状态集合度量抓取部署一个sidecar容器。</p><p id="8939" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总体而言，主要步骤将是:</p><ul class=""><li id="9963" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">使用选定命名空间中的工作节点创建EKS Fargate集群。</li><li id="6895" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">扩展statefulset并部署postgres操作符作为sidecar来收集数据库指标。</li><li id="dad4" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">安装和配置普罗米修斯刮我们的自定义边车。</li><li id="7f61" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">配置Grafana dashboard以显示我们的数据库指标。</li><li id="a694" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">使用Jenkins创建CI/CD解决方案。</li></ul><h1 id="3323" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">步骤1:创建EKS法盖特集群</h1><p id="65d3" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">大部分步骤来自<a class="ae kl" href="https://aws.amazon.com/blogs/containers/monitoring-amazon-eks-on-aws-fargate-using-prometheus-and-grafana/" rel="noopener ugc nofollow" target="_blank">这个AWS博客</a>。使用下面的YAML文件创建集群，并进行相应的修改:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="aa88" class="mp lb iq ml b gy mq mr l ms mt">eksctl create cluster -f cluster.yaml</span></pre><p id="8634" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们将为普罗米修斯使用EBS块存储，我们需要安装和配置EBS驱动程序，并获得普罗米修斯和格拉夫纳的舵图表。遵循以下步骤:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="8eea" class="mp lb iq ml b gy mq mr l ms mt">helm repo add aws-ebs-csi-driver https://kubernetes-sigs.github.io/aws-ebs-csi-driver<br/>helm repo add kube-state-metrics https://kubernetes.github.io/kube-state-metrics<br/>helm repo add prometheus-community https://prometheus-community.github.io/helm-charts<br/>helm repo add grafana https://grafana.github.io/helm-charts<br/>helm repo update</span><span id="ee7a" class="mp lb iq ml b gy mu mr l ms mt">helm upgrade --install aws-ebs-csi-driver \<br/>    --namespace kube-system \<br/>    --set enableVolumeScheduling=true \<br/>    --set enableVolumeResizing=true \<br/>    --set enableVolumeSnapshot=true \<br/>    aws-ebs-csi-driver/aws-ebs-csi-driver</span></pre><p id="e217" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，对于我们的应用程序，我们需要AWS负载平衡器控制器作为入口。从下面的步骤安装它，或者<a class="ae kl" href="https://aws.amazon.com/premiumsupport/knowledge-center/eks-alb-ingress-controller-fargate/" rel="noopener ugc nofollow" target="_blank">跟随这个博客</a>:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="499a" class="mp lb iq ml b gy mq mr l ms mt">eksctl utils associate-iam-oidc-provider --cluster fargate-prometheus --approve</span><span id="19fd" class="mp lb iq ml b gy mu mr l ms mt">curl -o iam_policy.json https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.2.0/docs/install/iam_policy.json</span><span id="7177" class="mp lb iq ml b gy mu mr l ms mt">aws iam create-policy \<br/>   --policy-name AWSLoadBalancerControllerIAMPolicy \<br/>   --policy-document file://iam_policy.json</span><span id="7c94" class="mp lb iq ml b gy mu mr l ms mt">eksctl create iamserviceaccount \<br/>  --cluster=fargate-prometheus \<br/>  --namespace=kube-system \<br/>  --name=aws-load-balancer-controller \<br/>  --attach-policy-arn=arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:policy/AWSLoadBalancerControllerIAMPolicy \<br/>  --override-existing-serviceaccounts \<br/>  --approve</span><span id="f972" class="mp lb iq ml b gy mu mr l ms mt">helm repo add eks https://aws.github.io/eks-charts</span><span id="c65e" class="mp lb iq ml b gy mu mr l ms mt">kubectl apply -k "github.com/aws/eks-charts/stable/aws-load-balancer-controller//crds?ref=master"</span><span id="8c00" class="mp lb iq ml b gy mu mr l ms mt">helm install aws-load-balancer-controller eks/aws-load-balancer-controller \<br/>    --set clusterName=fargate-prometheus \<br/>    --set serviceAccount.create=false \<br/>    --set region=us-west-2 \<br/>    --set vpcId=<a class="ae kl" href="https://us-west-2.console.aws.amazon.com/vpc/home?region=us-west-2#VpcDetails:VpcId=vpc-0db04b6b1abeb9ddc" rel="noopener ugc nofollow" target="_blank">&lt;</a>VPC-ID&gt;<!-- --> \<br/>    --set serviceAccount.name=aws-load-balancer-controller \<br/>    -n kube-system</span></pre><p id="a3e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们需要为应用程序存储创建EFS。使用以下步骤或<a class="ae kl" href="https://docs.aws.amazon.com/eks/latest/userguide/efs-csi.html#efs-create-filesystem" rel="noopener ugc nofollow" target="_blank">关注此博客</a>:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="ccd8" class="mp lb iq ml b gy mq mr l ms mt">vpc_id=$(aws eks describe-cluster \<br/>    --name <!-- -->fargate-prometheus<!-- --> \<br/>    --query "cluster.resourcesVpcConfig.vpcId" \<br/>    --output text)</span><span id="fff6" class="mp lb iq ml b gy mu mr l ms mt">cidr_range=$(aws ec2 describe-vpcs \<br/>    --vpc-ids $vpc_id \<br/>    --query "Vpcs[].CidrBlock" \<br/>    --output text)</span><span id="f75e" class="mp lb iq ml b gy mu mr l ms mt">security_group_id=$(aws ec2 create-security-group \<br/>    --group-name MyEfsSecurityGroup \<br/>    --description "My EFS security group" \<br/>    --vpc-id $vpc_id \<br/>    --output text)</span><span id="5e98" class="mp lb iq ml b gy mu mr l ms mt">aws ec2 authorize-security-group-ingress \<br/>    --group-id $security_group_id \<br/>    --protocol tcp \<br/>    --port 2049 \<br/>    --cidr $cidr_range</span><span id="e16b" class="mp lb iq ml b gy mu mr l ms mt">file_system_id=$(aws efs create-file-system \<br/>    --region us-west-2 \<br/>    --performance-mode generalPurpose \<br/>    --query 'FileSystemId' \<br/>    --output text)</span><span id="2dad" class="mp lb iq ml b gy mu mr l ms mt"><em class="mv">#Get IP address of Nodes and match it with the subnets</em><br/>kubectl get nodes</span><span id="d017" class="mp lb iq ml b gy mu mr l ms mt">NAME                                         STATUS   ROLES    AGE   VERSION<br/>ip-192-168-56-0.region-code.compute.internal   Ready    &lt;none&gt;   19m   v1.19.6-eks-49a6c0</span><span id="627f" class="mp lb iq ml b gy mu mr l ms mt">aws ec2 describe-subnets \<br/>    --filters "Name=vpc-id,Values=$vpc_id" \<br/>    --query 'Subnets[*].{SubnetId: SubnetId,AvailabilityZone: AvailabilityZone,CidrBlock: CidrBlock}' \<br/>    --output table</span><span id="1042" class="mp lb iq ml b gy mu mr l ms mt"><em class="mv">#Match the subnets given by output of above command in the IP range of "kubectl get nodes" command. Save that subnet ID and supply it in the below command for mounting to EFS:</em></span><span id="2b11" class="mp lb iq ml b gy mu mr l ms mt">aws efs create-mount-target \<br/>    --file-system-id $file_system_id \<br/>    --subnet-id subnet-<em class="mv">EXAMPLEe2ba886490</em> \<br/>    --security-groups $security_group_id</span><span id="5263" class="mp lb iq ml b gy mu mr l ms mt"><em class="mv">#Repeat the above command for all subnets.</em></span></pre><h1 id="dc4a" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">步骤2:扩展statefulset并将postgres操作符部署为sidecar。</h1><p id="9c2e" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我们将使用从这个<a class="ae kl" href="https://github.com/gravito/simpleservice/tree/main/kubernetes" rel="noopener ugc nofollow" target="_blank"> repo </a>部署的以前应用程序的大部分YAMLs。</p><p id="572f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">部署所有YAMLs，除了statefulset，我们将扩展它以包括side car。由于我们使用的数据库是postgres，我们将使用的sidecar是<a class="ae kl" href="https://github.com/prometheus-community/postgres_exporter" rel="noopener ugc nofollow" target="_blank"> postgres-exporter </a>。我们正在使用它，因为它在普罗米修斯网站上被列为官方postgres出口商。从官方页面可以看到，<strong class="jp ir"> postgres-exporter使用DATA_SOURCE_NAME作为抓取</strong>的数据库URL。因此，我们将在statefulset secret中提供这个变量。</p><p id="41f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面找到我们将用于监控的更新的YAMLs。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="a3f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您所看到的，在上面的第10行，我们添加了DATA_SOURCE_NAME变量，使我们的sidecar能够抓取postgres数据库。</p><p id="13d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在更新我们的statefulset本身，以包括sidecar容器:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="9833" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第33行到第39行定义了我们用于监控的边车。<strong class="jp ir">确保将其暴露在端口9187 </strong>(线路#39)上，以确保Prometheus获取公制。</p><p id="b4ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，为了确保Prometheus获得我们的sidecar指标，我们需要为Prometheus定义一个内部服务来与我们的sidecar交互。我们定义如下:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="6757" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意<strong class="jp ir">我们再次公开了端口9187 </strong>上的服务，让Prometheus从边车上获取指标。</p><p id="8f0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成这些扩展后，我们需要做的就是应用所有的东西。确保创建PV、PVC、存储类、机密等。在应用部署之前。</p><p id="f88d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，设置Ingress并(可选)<a class="ae kl" href="https://aws.amazon.com/premiumsupport/knowledge-center/terminate-https-traffic-eks-acm/" rel="noopener ugc nofollow" target="_blank">通过使用ACM将其升级为使用TLS </a>。所有这些步骤都可以参考我之前的部分<a class="ae kl" href="https://medium.com/@shrut_terminator/how-to-deploy-a-multi-container-two-tier-go-application-in-eks-fargate-6266494f5bcf" rel="noopener">这里的</a>。</p><p id="adb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后的健全性检查:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="7f0b" class="mp lb iq ml b gy mq mr l ms mt">kubectl get all</span><span id="5588" class="mp lb iq ml b gy mu mr l ms mt">NAME                                         READY   STATUS    RESTARTS   AGE<br/>pod/fullstack-app-postgres-bf57ff694-bjhgh   1/1     Running   0          12m<br/>pod/fullstack-postgres-0                     2/2     Running   0          14m</span><span id="bf4f" class="mp lb iq ml b gy mu mr l ms mt">NAME                                     TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE<br/>service/fullstack-app-postgres           ClusterIP   10.100.124.112   &lt;none&gt;        8080/TCP         12m<br/>service/fullstack-app-postgres-sidecar   NodePort    10.100.189.130   &lt;none&gt;        9187:31360/TCP   23m<br/>service/fullstack-postgres               ClusterIP   10.100.80.163    &lt;none&gt;        5432/TCP         23m<br/>service/kubernetes                       ClusterIP   10.100.0.1       &lt;none&gt;        443/TCP          3h20m</span><span id="4593" class="mp lb iq ml b gy mu mr l ms mt">NAME                                     READY   UP-TO-DATE   AVAILABLE   AGE<br/>deployment.apps/fullstack-app-postgres   1/1     1            1           12m</span><span id="6a10" class="mp lb iq ml b gy mu mr l ms mt">NAME                                               DESIRED   CURRENT   READY   AGE<br/>replicaset.apps/fullstack-app-postgres-bf57ff694   1         1         1       12m</span><span id="6599" class="mp lb iq ml b gy mu mr l ms mt">NAME                                  READY   AGE<br/>statefulset.apps/fullstack-postgres   1/1     14m</span></pre><h1 id="d6bf" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">第三步:安装和配置Prometheus刮postgres边车集装箱。</h1><p id="9e7a" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我们将配置Prometheus的先决条件，例如创建命名空间和存储类。然而，在我们最终安装之前，我们将编辑配置文件(values.yaml)以允许Prometheus抓取我们的定制目标，这是我们部署的side car服务。</p><p id="6bf9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建命名空间并获取工作节点的AZ:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="6b7b" class="mp lb iq ml b gy mq mr l ms mt">kubectl create namespace prometheus</span><span id="eefa" class="mp lb iq ml b gy mu mr l ms mt">EBS_AZ=$(kubectl get nodes \<br/>  -o=jsonpath="{.items[0].metadata.labels['topology\.kubernetes\.io\/zone']}")</span></pre><p id="b017" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正在创建存储类:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="22c2" class="mp lb iq ml b gy mq mr l ms mt">echo "<br/>kind: StorageClass<br/>apiVersion: storage.k8s.io/v1<br/>metadata:<br/>  name: prometheus<br/>  namespace: prometheus<br/>provisioner: ebs.csi.aws.com<br/>parameters:<br/>  type: gp2<br/>reclaimPolicy: Retain<br/>allowedTopologies:<br/>- matchLabelExpressions:<br/>  - key: topology.ebs.csi.aws.com/zone<br/>    values:<br/>    - $EBS_AZ<br/>" | kubectl apply -f -</span></pre><p id="3d9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要安装普罗米修斯，我们将首先拉动图表，并修改值指向我们的边车。拉图表如下:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="bebd" class="mp lb iq ml b gy mq mr l ms mt">wget https://github.com/aws-samples/containers-blog-maelstrom/raw/main/fargate-monitoring/prometheus_values.yml</span></pre><p id="1d7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打开这个文件，并转到最底部，或者任何您可以找到值:"<strong class="jp ir"> extraScrapeConfigs </strong>"的地方。我们要做的是编辑这个文件，使普罗米修斯刮我们的边车。编辑文件并将此配置放入extraScrapeConfigs:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="37eb" class="mp lb iq ml b gy mq mr l ms mt">extraScrapeConfigs: |<br/>  - job_name: 'fullstack-app-postgres-sidecar'<br/>  static_configs:<br/>    - targets:<br/>      - "fullstack-app-postgres-sidecar.default.svc:9187"</span></pre><p id="2ece" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">确保将管道操作符:" |" </strong>放在extraScrapeConfigs之后，以使YAML能够识别字符串。此外，确保<strong class="jp ir">缩进是新行</strong>的两个空格(否则你会面临奇怪的错误)。最后，“full stack-app-postgres-sidecar . default . SVC”表示&lt;服务名&gt;。&lt; namespacename &gt; .svc. <strong class="jp ir">这是访问不同名称空间服务的模式</strong>。服务名与访问我们的sidecar容器的服务名相同。</p><p id="c308" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用以下命令保存文件并安装舵图。确保位于保存该文件的同一目录中(或提供该文件路径):</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="40fc" class="mp lb iq ml b gy mq mr l ms mt">helm install prometheus -f prometheus_values.yml \<br/>  prometheus-community/prometheus --namespace prometheus</span></pre><p id="b832" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装图表后，您可以验证是否安装了Prometheus:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="1e5d" class="mp lb iq ml b gy mq mr l ms mt">kubectl get pods --namespace prometheus</span><span id="319e" class="mp lb iq ml b gy mu mr l ms mt">NAME                                             READY   STATUS    RESTARTS   AGE</span><span id="2db5" class="mp lb iq ml b gy mu mr l ms mt">prometheus-alertmanager-bccd5ffc9-l6hw5          2/2     Running   0          3d4h</span><span id="e79c" class="mp lb iq ml b gy mu mr l ms mt">prometheus-kube-state-metrics-5fd8648d78-d2kv6   1/1     Running   0          3d4h</span><span id="6087" class="mp lb iq ml b gy mu mr l ms mt">prometheus-node-exporter-96v92                   1/1     Running   0          3d4h</span><span id="5eba" class="mp lb iq ml b gy mu mr l ms mt">prometheus-node-exporter-j57tt                   1/1     Running   0          3d4h</span><span id="39c0" class="mp lb iq ml b gy mu mr l ms mt">prometheus-pushgateway-5d7ff8d7f-94wcr           1/1     Running   0          3d4h</span><span id="7074" class="mp lb iq ml b gy mu mr l ms mt">prometheus-server-95ffc4b78-dj6pj                2/2     Running   0          3d4h</span></pre><h1 id="e315" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">步骤4:配置Grafana dashboard以显示数据库指标。</h1><p id="10b0" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">这一步非常简单，因为我们将按照下面的命令来设置Grafana仪表板。首先，我们需要验证我们的普罗米修斯是否正确地刮擦了我们的边车容器。</p><p id="8a7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在pods列表中，<strong class="jp ir"> prometheus-server是允许我们通过GUI访问Prometheus </strong>内部目标的服务器。我们将端口转发prometheus服务器以在本地访问它:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="677c" class="mp lb iq ml b gy mq mr l ms mt">kubectl port-forward -n prometheus svc/prometheus-server 9090:80</span></pre><p id="d185" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么9090:80？9090是我们要在本地公开的端口。80是在EKS运行的prometheus服务器服务的端口。一旦上面的命令运行，在本地访问它:<a class="ae kl" href="http://127.0.0.1:9090/" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:9090/ </a></p><p id="2c79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在GUI窗口中，选择状态-&gt;目标。您会看到边车状态为“UP ”:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/974db5a5b2de2e04bd5dd4529d11385f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n2K2rtEaHCbOK-w7k4Os4Q.png"/></div></div></figure><p id="142b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">验证这一点的另一种方法是手动登录prometheus服务器容器，并使用telnet检查您是否能够访问该服务。</p><p id="2689" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行以下命令手动进入prometheus-server容器:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="e0ff" class="mp lb iq ml b gy mq mr l ms mt">kubectl exec prometheus-server-95ffc4b78-dj6pj -c prometheus-server -n prometheus -it sh</span></pre><p id="2ac0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在“exec”后面输入POD名称，在“-c”后面输入容器名称。在描述了prometheus-server pod之后，我们可以获得容器的详细信息。</p><p id="fd50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进入prometheus-server容器后，运行telnet到服务以检查连接性:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="278b" class="mp lb iq ml b gy mq mr l ms mt">/prometheus $ telnet fullstack-app-postgres-sidecar.default.svc:9187</span><span id="45a2" class="mp lb iq ml b gy mu mr l ms mt">Connected to fullstack-app-postgres-sidecar.default.svc:9187</span></pre><p id="a139" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们已经验证了边车工作正常，Prometheus能够访问它，我们只需部署Grafana仪表板，并在丰富多彩的GUI中查看我们的指标！</p><p id="e306" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">遵循以下简单的步骤:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="8d6f" class="mp lb iq ml b gy mq mr l ms mt">wget <a class="ae kl" href="https://raw.githubusercontent.com/aws-samples/containers-blog-maelstrom/main/fargate-monitoring/grafana-values.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/aws-samples/containers-blog-maelstrom/main/fargate-monitoring/grafana-values.yaml</a></span><span id="62d6" class="mp lb iq ml b gy mu mr l ms mt">helm install grafana -f grafana-values.yaml \<br/>  grafana/grafana --namespace prometheus</span></pre><p id="d39c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装Grafana后，获取负载平衡器URL以访问仪表板:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="477a" class="mp lb iq ml b gy mq mr l ms mt">printf $(kubectl get service grafana \<br/>  --namespace prometheus \<br/>  -o jsonpath="{.status.loadBalancer.ingress[].hostname}");echo</span></pre><p id="2e8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在浏览器中打开URL。登录用户名是“admin”。您可以从以下秘密中获得密码:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="4661" class="mp lb iq ml b gy mq mr l ms mt">kubectl get secret --namespace prometheus grafana \<br/> -o jsonpath="{.data.admin-password}" | \<br/> base64 --decode ; echo</span></pre><p id="2bf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进入仪表板后，单击左侧的+,然后单击“Import”。然后输入仪表板编号:“9628”。选择数据集作为普罗米修斯:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nd"><img src="../Images/a3e391687612ec30ed78508b955e68f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ffkzojTJosGYGIGWqi2vAw.png"/></div></div></figure><p id="56e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导入后，您将开始看到指标在如下时间填充:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ne"><img src="../Images/157aa170d5ad4aa57878c805a615b5a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*inWFt7d6MpiSOWwFmFXkCQ.png"/></div></div></figure><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nf"><img src="../Images/5ff1eddccae7828a43a15c8eb141c555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*reXUabkgK6WtuZ7MsszvsA.png"/></div></div></figure><p id="372b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，您可以使用Prometheus和Grafana有效地监控您在EKS法盖特的statefulsets数据库！</p><h1 id="3ad1" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">步骤5:使用Jenkins创建CI/CD解决方案</h1><p id="00d9" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我们最终使用Jenkins创建了一个最先进的(不是真的:P) CI/CD解决方案来结束我们的应用程序！步骤很简单，我们将首先在EC2实例上安装Jenkins，然后启用Docker插件和凭证，连接我们的EKS集群，最后创建一个Jenkinsfile，它将依次构建映像并将映像部署到集群。</p><h2 id="b572" class="mp lb iq bd lc ng nh dn lg ni nj dp lk jy nk nl lo kc nm nn ls kg no np lw nq bi translated">a)安装Jenkins服务器:</h2><p id="8948" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">这里没有什么，但是命令让Jenkins服务器启动并运行。遵循任何指南，或以下命令(我用的是t2.medium Ubuntu box):</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="4191" class="mp lb iq ml b gy mq mr l ms mt">sudo apt update <br/>sudo apt install openjdk-8-jdk -y<br/>wget -q -O - <a class="ae kl" href="https://pkg.jenkins.io/debian-stable/jenkins.io.key" rel="noopener ugc nofollow" target="_blank">https://pkg.jenkins.io/debian-stable/jenkins.io.key</a> | sudo apt-key add <br/>sudo sh -c 'echo deb <a class="ae kl" href="http://pkg.jenkins.io/debian-stable" rel="noopener ugc nofollow" target="_blank">http://pkg.jenkins.io/debian-stable</a> binary/ &gt; /etc/apt/sources.list.d/jenkins.list' <br/>sudo apt update<br/>sudo apt install jenkins -y<br/>sudo systemctl start jenkins<br/>sudo systemctl status jenkins</span></pre><p id="6672" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">登录到Jenkins服务器并创建您的管理员用户。然后按照以下步骤添加Jenkins用户作为管理员。切换到该用户。</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="81ce" class="mp lb iq ml b gy mq mr l ms mt">sudo vim /etc/sudoers</span><span id="58a4" class="mp lb iq ml b gy mu mr l ms mt">## Add below at end of file<br/>jenkins ALL=(ALL) NOPASSWD: ALL</span><span id="8cf8" class="mp lb iq ml b gy mu mr l ms mt">## Switch to Jenkins user<br/>sudo su - jenkins</span></pre><h2 id="2486" class="mp lb iq bd lc ng nh dn lg ni nj dp lk jy nk nl lo kc nm nn ls kg no np lw nq bi translated">b)安装Docker和Kubernetes:</h2><p id="b0d5" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">(<strong class="jp ir">重要提示</strong> : <em class="mv">确保以Jenkins用户的身份执行以下所有步骤</em></p><p id="acb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装Docker:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="f71e" class="mp lb iq ml b gy mq mr l ms mt">sudo apt install docker.io -y</span><span id="c204" class="mp lb iq ml b gy mu mr l ms mt">## Adding Jenkins user to docker group.<br/>sudo usermod -aG docker jenkins</span></pre><p id="9095" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">配置<a class="ae kl" href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html" rel="noopener ugc nofollow" target="_blank"> AWS CLI </a>和Git:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="f564" class="mp lb iq ml b gy mq mr l ms mt">curl "<a class="ae kl" href="https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" rel="noopener ugc nofollow" target="_blank">https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip</a>" -o "awscliv2.zip"<br/>unzip awscliv2.zip<br/>sudo ./aws/install</span><span id="34ac" class="mp lb iq ml b gy mu mr l ms mt">aws configure<br/>// Enter your credentials in the prompt.</span><span id="1ff1" class="mp lb iq ml b gy mu mr l ms mt">sudo apt-get install git -y</span></pre><p id="f0ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装Kubectl。使用适当版本的集群。</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="82f5" class="mp lb iq ml b gy mq mr l ms mt">curl -LO "https://dl.k8s.io/release/<strong class="ml ir">$(</strong>curl -L -s https://dl.k8s.io/release/stable.txt<strong class="ml ir">)</strong>/bin/linux/amd64/kubectl"</span><span id="1614" class="mp lb iq ml b gy mu mr l ms mt">sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl</span></pre><p id="aa59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装<a class="ae kl" href="https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html" rel="noopener ugc nofollow" target="_blank"> eksctl </a>:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="eebd" class="mp lb iq ml b gy mq mr l ms mt">curl --silent --location "<a class="ae kl" href="https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname" rel="noopener ugc nofollow" target="_blank">https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname</a> -s)_amd64.tar.gz" | tar xz -C /tmp</span><span id="f6d8" class="mp lb iq ml b gy mu mr l ms mt">sudo mv /tmp/eksctl /usr/local/bin</span></pre><p id="0387" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，尝试使用Jenkins用户名访问我们创建的EKS集群:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="2552" class="mp lb iq ml b gy mq mr l ms mt"><br/>aws eks update-kubeconfig --name fargate-prometheus</span><span id="ed9b" class="mp lb iq ml b gy mu mr l ms mt">kubectl get pods</span><span id="d041" class="mp lb iq ml b gy mu mr l ms mt">NAME                                     READY   STATUS    RESTARTS   AGE</span><span id="bd50" class="mp lb iq ml b gy mu mr l ms mt">fullstack-app-postgres-bf57ff694-7nwxw   1/1     Running   0          3d1h</span><span id="35d9" class="mp lb iq ml b gy mu mr l ms mt">fullstack-postgres-0                     2/2     Running   0          3d1h</span></pre><h2 id="c731" class="mp lb iq bd lc ng nh dn lg ni nj dp lk jy nk nl lo kc nm nn ls kg no np lw nq bi translated">c)添加凭据</h2><p id="7107" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">安装Docker管道插件，我们将使用它来创建和推送图像。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nr"><img src="../Images/f453191ed051acc7863cf4cc40effc71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jnxTIW92KkycNXuCb6KSCw.png"/></div></div></figure><p id="8558" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">存储Docker凭证用户名和密码。进入凭证-&gt;系统-&gt;全局凭证，存储Docker HUB密码和<strong class="jp ir">记下使用的变量ID</strong>。这将在以后的管道中使用。</p><p id="cec9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:出于安全考虑，建议使用Dockerhub个人访问令牌。此外，出于某种原因，如果您得到登录错误，请确保密码中没有任何特殊字符。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ns"><img src="../Images/c3db71264f4c9628847b2e48af66fd9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E3Kbu7NG00pjWNu9lBqVTA.png"/></div></div></figure><h2 id="2d35" class="mp lb iq bd lc ng nh dn lg ni nj dp lk jy nk nl lo kc nm nn ls kg no np lw nq bi translated"><strong class="ak"> d)创建CI/CD管道</strong></h2><p id="283f" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">最后，我们使用管道脚本创建管道。找到以下步骤:</p><p id="6408" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们激活Github仓库的webhook。进入你的github repo，在那里你可以找到设置选项。点击左侧的“添加Webhook”，输入Jenkins DNS URL以及后缀:<strong class="jp ir"> /github-webhook/ </strong>。选择“仅推送事件”。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nt"><img src="../Images/3436aa7c3a076f271b4f77ac70c04062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ydQ74deNlJ699fUMK_AcQ.png"/></div></div></figure><p id="61c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，点击新项目，并选择管道。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nu"><img src="../Images/1938f7df48c0dc2f3139ffe3bce4b25e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GF7yYkhX7UJ6Ofioy9K2ZA.png"/></div></div></figure><p id="d9a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">选择Github项目并输入Github项目URL。选择Build trigger作为GITScm轮询的Github hook触发器。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nv"><img src="../Images/4e84704a6d35feb2379e6ee4253c54d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*49N0extTr_HZAIUftyMWQA.png"/></div></div></figure><p id="446d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，在Jenkinsfile(包含我们的groovy管道脚本的文件)中，输入以下详细信息:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nw"><img src="../Images/054e0237be7a310be342efe88d5604c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*npYa9NtOX9afhyRqZwbc9g.png"/></div></div></figure><p id="0850" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们实际上是从相同(或不同)的回购协议中获取构建文件。确保指定回购名称。我们也可以在本地存储文件(在Jenkins GUI中)。</p><p id="55af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，看看下面的Jenkinsfile:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="d0f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您可以推断的那样，我们首先使用Docker插件来构建我们的图像，并用我们的构建ID来标记它。然后，我们使用之前创建的dockerhub credentials变量(第15行)将这个标记的图像推送到Dockerhub注册表中(确保使用与在Jenkins credentials中创建的变量名相同的变量名)。最后，我们用标记的构建映像(带有构建ID)替换部署文件中的现有映像。然后，我们部署文件并重新启动部署，以使更改生效。</p><p id="05e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试这一点，我在handlers.go的第35行进行了修改(在http文件夹内)。我将输出从干得好:)更改为棒极了:):</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="44b0" class="mp lb iq ml b gy mq mr l ms mt">34         fmt.Printf("%s - request with database\n", time.Now().Format(time.ANSIC))</span><span id="1f8a" class="mp lb iq ml b gy mu mr l ms mt">35         w.Write([]byte("Awesome! :)"))</span></pre><p id="f490" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在执行标准git提交时:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="57ac" class="mp lb iq ml b gy mq mr l ms mt">git add .<br/>git commit -m "code changes"<br/>git push origin master</span></pre><p id="e810" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我可以看到构建是自动触发的，所有的更改都部署在Jenkins输出中:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="3582" class="mp lb iq ml b gy mq mr l ms mt">Started by GitHub push by gravito<br/>Obtained Jenkinsfile from git <a class="ae kl" href="https://github.com/gravito/simpleservice.git" rel="noopener ugc nofollow" target="_blank">https://github.com/gravito/simpleservice.git</a><br/>[Pipeline] Start of Pipeline<br/>[Pipeline] node<br/>Running on <a class="ae kl" href="http://ec2-34-227-11-17.compute-1.amazonaws.com:8080/computer/(built-in)/" rel="noopener ugc nofollow" target="_blank">Jenkins</a> in /var/lib/jenkins/workspace/eks<br/>[Pipeline] {<br/>[Pipeline] stage<br/>[Pipeline] { (Declarative: Checkout SCM)<br/>[Pipeline] checkout<br/>Selected Git installation does not exist. Using Default<br/>The recommended git tool is: NONE<br/>No credentials specified<br/> &gt; git rev-parse --resolve-git-dir /var/lib/jenkins/workspace/eks/.git # timeout=10<br/>Fetching changes from the remote Git repository<br/> &gt; git config remote.origin.url <a class="ae kl" href="https://github.com/gravito/simpleservice.git" rel="noopener ugc nofollow" target="_blank">https://github.com/gravito/simpleservice.git</a> # timeout=10<br/>Fetching upstream changes from <a class="ae kl" href="https://github.com/gravito/simpleservice.git" rel="noopener ugc nofollow" target="_blank">https://github.com/gravito/simpleservice.git</a><br/> &gt; git --version # timeout=10<br/> &gt; git --version # 'git version 2.34.1'<br/> &gt; git fetch --tags --force --progress -- <a class="ae kl" href="https://github.com/gravito/simpleservice.git" rel="noopener ugc nofollow" target="_blank">https://github.com/gravito/simpleservice.git</a> +refs/heads/*:refs/remotes/origin/* # timeout=10<br/> &gt; git rev-parse refs/remotes/origin/master^{commit} # timeout=10<br/>Checking out Revision 554bdcbcd0960880cd619f883b2ba1e551465f99 (refs/remotes/origin/master)<br/> &gt; git config core.sparsecheckout # timeout=10<br/> &gt; git checkout -f 554bdcbcd0960880cd619f883b2ba1e551465f99 # timeout=10<br/>Commit message: "changed message"<br/> &gt; git rev-list --no-walk ed91a24a14f52d0556d6ce321ab3bbe47ccbb459 # timeout=10<br/>[Pipeline] }<br/>[Pipeline] // stage<br/>[Pipeline] withEnv<br/>[Pipeline] {<br/>[Pipeline] stage<br/>[Pipeline] { (Build image)<br/>[Pipeline] script<br/>[Pipeline] {<br/>[Pipeline] isUnix<br/>[Pipeline] withEnv<br/>[Pipeline] {<br/>[Pipeline] sh<br/>+ docker build -t gravito/simple-service:7 .<br/>Sending build context to Docker daemon  11.95MB<br/><br/>Step 1/13 : FROM golang:alpine as builder<br/> ---&gt; 155ead2e66ca<br/>Step 2/13 : LABEL maintainer="Aayush Shrut &lt;aayush.shrut@gmail.com&gt;"<br/> ---&gt; Using cache<br/> ---&gt; 9eff72ae46ad<br/>Step 3/13 : WORKDIR /app<br/> ---&gt; Using cache<br/> ---&gt; b6af9e060344<br/>Step 4/13 : COPY go.mod go.sum ./<br/> ---&gt; Using cache<br/> ---&gt; 1c0cca91de31<br/>Step 5/13 : RUN go mod download<br/> ---&gt; Using cache<br/> ---&gt; 1f6703e534fa<br/>Step 6/13 : COPY . .<br/> ---&gt; 53f6366f93c2<br/>Step 7/13 : RUN GO111MODULE=on CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo<br/> ---&gt; Running in 7ac4680b5895<br/>Removing intermediate container 7ac4680b5895<br/> ---&gt; 0ce4e8196254<br/>Step 8/13 : FROM alpine:latest<br/> ---&gt; e66264b98777<br/>Step 9/13 : WORKDIR /root/<br/> ---&gt; Using cache<br/> ---&gt; 57ec9916b0f4<br/>Step 10/13 : COPY --from=builder /app/simple-service .<br/> ---&gt; 16f7592e1b4b<br/>Step 11/13 : COPY --from=builder /app/.env .<br/> ---&gt; 8878612aa0ba<br/>Step 12/13 : EXPOSE 8080<br/> ---&gt; Running in 0dfc93aa8033<br/>Removing intermediate container 0dfc93aa8033<br/> ---&gt; 8cc961070056<br/>Step 13/13 : CMD ["./simple-service"]<br/> ---&gt; Running in 7c877e5b7a27<br/>Removing intermediate container 7c877e5b7a27<br/> ---&gt; 5e0a9130ab72<br/>Successfully built 5e0a9130ab72<br/>Successfully tagged gravito/simple-service:7<br/>[Pipeline] }<br/>[Pipeline] // withEnv<br/>[Pipeline] }<br/>[Pipeline] // script<br/>[Pipeline] }<br/>[Pipeline] // stage<br/>[Pipeline] stage<br/>[Pipeline] { (Push image)<br/>[Pipeline] script<br/>[Pipeline] {<br/>[Pipeline] withEnv<br/>[Pipeline] {<br/>[Pipeline] withDockerRegistry<br/>$ docker login -u gravito -p ******** <a class="ae kl" href="https://registry.hub.docker.com/" rel="noopener ugc nofollow" target="_blank">https://registry.hub.docker.com</a><br/><br/>Login Succeeded<br/>[Pipeline] {<br/>[Pipeline] isUnix<br/>[Pipeline] withEnv<br/>[Pipeline] {<br/>[Pipeline] sh<br/>+ docker tag gravito/simple-service:7 registry.hub.docker.com/gravito/simple-service:7<br/>[Pipeline] }<br/>[Pipeline] // withEnv<br/>[Pipeline] isUnix<br/>[Pipeline] withEnv<br/>[Pipeline] {<br/>[Pipeline] sh<br/>+ docker push registry.hub.docker.com/gravito/simple-service:7<br/>The push refers to repository [registry.hub.docker.com/gravito/simple-service]<br/>ed84bb285891: Preparing<br/>8110c973ca20: Preparing<br/>24302eb7d908: Preparing<br/>24302eb7d908: Layer already exists<br/>ed84bb285891: Pushed<br/>8110c973ca20: Pushed<br/>7: digest: sha256:8036cd9a88874e175356a97ed51e2c99c0b82b254b88cc481110bc4e5799441e size: 946<br/>[Pipeline] }<br/>[Pipeline] // withEnv<br/>[Pipeline] }<br/>[Pipeline] // withDockerRegistry<br/>[Pipeline] }<br/>[Pipeline] // withEnv<br/>[Pipeline] }<br/>[Pipeline] // script<br/>[Pipeline] }<br/>[Pipeline] // stage<br/>[Pipeline] stage<br/>[Pipeline] { (Deploy to EKS)<br/>[Pipeline] sh<br/>+ sed -i s/simple-service:latest/simple-service:7/g kubernetes/app-postgres-deployment.yaml<br/>[Pipeline] sh<br/>+ kubectl apply -f kubernetes/app-postgres-deployment.yaml<br/>deployment.apps/fullstack-app-postgres configured<br/>[Pipeline] sh<br/>+ kubectl rollout restart deployment fullstack-app-postgres<br/>deployment.apps/fullstack-app-postgres restarted<br/>[Pipeline] }<br/>[Pipeline] // stage<br/>[Pipeline] }<br/>[Pipeline] // withEnv<br/>[Pipeline] }<br/>[Pipeline] // node<br/>[Pipeline] End of Pipeline<br/>Finished: SUCCESS</span></pre><p id="ebb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，当我们尝试访问入口时，我们得到了令人敬畏的:)消息:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="1765" class="mp lb iq ml b gy mq mr l ms mt">kubectl get ingress</span><span id="bbfb" class="mp lb iq ml b gy mu mr l ms mt">NAME          CLASS    HOSTS   ADDRESS                                                                 PORTS   AGE</span><span id="a326" class="mp lb iq ml b gy mu mr l ms mt">ingress-app   &lt;none&gt;   *       k8s-default-ingressa-1234567890.us-east-1.elb.amazonaws.com   80      2d15h</span><span id="daf7" class="mp lb iq ml b gy mu mr l ms mt">## Use the Ingress URL to access the changed output:</span><span id="1ae3" class="mp lb iq ml b gy mu mr l ms mt">Awesome :)</span></pre><h1 id="ea2d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="2cc5" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">关于EKS·法盖特的两篇文章到此结束。在第一部分中，我们探索了使用statefulsets在EKS Fargate部署一个简单的两层前端数据库Go应用程序的方法，并使用Ingress创建自定义URL，进一步使用TLS保护它。</p><p id="e18f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一部分中，我们扩展了我们的应用程序，增加了监控和CI/CD。我们首先创建了一个Prometheus和Grafana解决方案，通过创建一个sidecar代理来使用Postgres操作符收集我们的statefulset或数据库指标。然后，我们部署了我们的普罗米修斯解决方案来清理我们的定制边车。然后，我们使用Grafana dashboard显示这些指标。</p><p id="d2cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们最终通过安装Jenkins服务器和Docker插件创建了一个CI/CD解决方案。然后，我们从repo中创建了webhooks，并创建了适当的Jenkinsfile来构建映像并将其推送到Docker repo中，还在我们的EKS集群中部署了新的部署。我们使用一个简单的代码变化来测试这些。</p><p id="8675" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">EKS·法盖特是一个很棒的集装箱无服务器解决方案，我可以预见在未来几年它会越来越多地被企业采用。我希望你喜欢两部分系列。欢迎对任何建议或疑问发表评论。你的鼓掌和分享会创造奇迹！</p></div></div>    
</body>
</html>