<html>
<head>
<title>Immersive guide to microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务沉浸式指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/immersive-guide-to-microservices-f646a691d219?source=collection_archive---------10-----------------------#2022-12-26">https://levelup.gitconnected.com/immersive-guide-to-microservices-f646a691d219?source=collection_archive---------10-----------------------#2022-12-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="417a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kl translated">亲爱的学习者！让我向您介绍一下关于微服务架构(简称:MSA)的主要观点，这是我在工作中以及从这本宣传书中学到的:</p><div class="ku kv gp gr kw kx"><a href="https://www.oreilly.com/library/view/building-microservices-2nd/9781492034018/" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">构建微服务，第二版</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">随着组织从单一应用程序转向更小的独立微服务，分布式系统已经…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">www.oreilly.com</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll lm kx"/></div></div></a></div><p id="8d55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章不是一本学习书籍，而是一个带有参考资料的快照(虽然很大)+大量的文章，可以用来收集更多的知识。</p><p id="af1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个领域太大了，也很有争议，不可能在一篇文章中囊括所有内容(T2甚至是600多页的书，如上图)。</p><p id="4a43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">这是一个巨大的目录:</strong></p><ul class=""><li id="89ac" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><a class="ae lw" href="#0f1d" rel="noopener ugc nofollow">主要概念</a></li><li id="fbba" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><a class="ae lw" href="#6c3f" rel="noopener ugc nofollow">独石</a></li><li id="bd64" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><a class="ae lw" href="#a2ba" rel="noopener ugc nofollow">快速了解微服务使用的技术</a> <br/> -微服务的痛点</li><li id="2049" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><a class="ae lw" href="#b844" rel="noopener ugc nofollow">微服务因素</a> <br/> -联轴器类型</li><li id="e099" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><a class="ae lw" href="#be92" rel="noopener ugc nofollow">DDD——领域驱动设计</a><br/>——映射聚合和有界上下文</li><li id="6c5a" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><a class="ae lw" href="#42dc" rel="noopener ugc nofollow">分割巨石</a> <br/> -先分解什么<br/> -分解模式<br/> -数据问题</li><li id="4e4a" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><a class="ae lw" href="#20df" rel="noopener ugc nofollow"> MSA通信方式</a> <br/> -性能<br/> -变更<br/> -错误处理<br/> -进程间通信技术选择</li><li id="c67e" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><a class="ae lw" href="#2d8e" rel="noopener ugc nofollow">实现微服务通信</a> <br/> -规则<br/> -技术选择<br/> -模式<br/> -避免微服务中的突发变更<br/> -管理突发变更<br/> -微服务中的干燥<br/> -服务发现<br/> -简要介绍服务网格和API网关</li><li id="362a" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><a class="ae lw" href="#840f" rel="noopener ugc nofollow">工作流程:微服务<br/> </a>中的数据库素材- 2PC <br/> - Sagas</li><li id="5cf2" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><a class="ae lw" href="#9270" rel="noopener ugc nofollow"> Build: CI/CD及其周围的一切</a> <br/> -工件创建规则<br/> -将源代码和构建映射到微服务</li><li id="8e1e" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><a class="ae lw" href="#1b0f" rel="noopener ugc nofollow">部署</a> <br/> -环境<br/> -微服务原则部署<br/> -部署选项<br/> -关于servlets的回避<br/> -关于K8S的几句话<br/> -渐进交付</li><li id="f520" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><a class="ae lw" href="#cc85" rel="noopener ugc nofollow">测试</a> <br/> -合同测试和消费者驱动的合同<br/> -生产中测试<br/> - MTBF vs MTTR</li><li id="a65a" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><a class="ae lw" href="#e04f" rel="noopener ugc nofollow">从监控到可观察性</a> <br/> -日志<br/> -度量<br/> -分布式跟踪<br/>-SLA、SLO、SLI等</li><li id="2bb9" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><a class="ae lw" href="#933a" rel="noopener ugc nofollow">安全</a> <br/> -核心原则<br/> -应用安全基础<br/> -隐性信任对零信任<br/> -保护数据<br/> -单点登录<br/> -困惑的代理问题</li><li id="b7ce" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><a class="ae lw" href="#322d" rel="noopener ugc nofollow">弹性</a> <br/> -降级功能<br/> -稳定性模式(超时、隔板、断路器)<br/> -微服务的隔离<br/> -等幂<br/> -上限定理</li><li id="54b8" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><a class="ae lw" href="#913b" rel="noopener ugc nofollow">缩放</a> <br/> -缩放轴(垂直、水平、数据分区、功能分解)<br/> -缓存+缓存失效</li><li id="c1b4" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><a class="ae lw" href="#10b8" rel="noopener ugc nofollow">用户界面</a> <br/> -单片前端<br/> -微前端模式(基于页面，基于小部件)<br/> -用于在前端过滤数据的模式(聚合网关，BFF)</li><li id="8a64" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><a class="ae lw" href="#7f92" rel="noopener ugc nofollow"> Outro </a></li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/ac4913a559edb2113b264c6ee7fd6c89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zT4yanaLa_t_lZKS"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lw" href="https://unsplash.com/@jexo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jexo </a>在<a class="ae lw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="0f1d" class="my mz iq bd na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv bi translated">主要概念</h1><p id="f9a9" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">首先，让我们深入了解定义微服务的概念:</p><ul class=""><li id="2db3" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">面向服务的方法。这是一种企业级的方法，其中相同的概念被重用。它支持无代码复制，使用接口，有ESB(企业服务总线)。阅读更多信息:</li></ul><div class="ku kv gp gr kw kx"><a href="https://www.ibm.com/cloud/blog/soa-vs-microservices" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">SOA与微服务:有什么区别？</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">在本文中，我们将解释面向服务的架构(SOA)和微服务的基础知识，触及它们的关键…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">www.ibm.com</p></div></div><div class="lg l"><div class="ob l li lj lk lg ll lm kx"/></div></div></a></div><ul class=""><li id="c5af" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><strong class="jp ir">独立部署能力</strong> —微服务的主要特性，可以独立于其他服务部署微服务，即不需要重新部署其他n个微服务。它的先决条件:<br/> - <em class="oc">松散耦合的</em>代码，也就是微服务之间的<em class="oc">稳定契约</em></li><li id="3a25" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">围绕业务领域建模(<strong class="jp ir"> DDD </strong>将进一步提及)，而不是传统的<strong class="jp ir"> MVC </strong>。我们有端到端的团队，他们可以为特定的业务领域(如卡处理)提供前端、后端和数据库相关的功能。这样的团队构建了整个组织。在传统的MVC方法中，我们有前端开发团队来处理大量的任务，后端和数据库开发团队也是如此。因此，<strong class="jp ir">否</strong> <strong class="jp ir">改变为多个微服务，由不同的团队拥有，由一个团队拥有。</strong></li><li id="659c" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">没有针对多个微服务的<strong class="jp ir">共享数据库</strong>(从微服务到数据库的直接访问)。有一个完整的服务，它决定哪些微服务提供什么数据(它将请求传送到数据库或拒绝它)。我们将在<strong class="jp ir">耦合部分对此进行探讨。</strong></li><li id="efeb" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">规模—有争议，但没关系，因为每个服务都是独一无二的，每个组织都有自己的特点。</li></ul><h1 id="6c3f" class="my mz iq bd na nb od nd ne nf oe nh ni nj of nl nm nn og np nq nr oh nt nu nv bi translated">庞然大物</h1><p id="2418" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">接下来，让我们来看一下<strong class="jp ir"> monolith </strong>:一种所有东西都在一个应用程序中的架构。它有传统的<strong class="jp ir"> MVC </strong>方法。简而言之:monolith并不坏，它只是另一种类型的建筑。</p><blockquote class="oi oj ok"><p id="3a08" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">在我的文章中阅读关于<strong class="jp ir"> MVC </strong>的内容:<a class="ae lw" href="https://medium.com/gitconnected/how-i-implemented-design-patterns-in-production-186aa306ca6a" rel="noopener">https://medium . com/git connected/how-I-implemented-design-patterns-in-production-186 aa 306 ca6a</a></p></blockquote><p id="17a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">优点:</p><ul class=""><li id="9de8" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">容易测试。一切都在一个大的过程中，你可以编写测试，记住我们的应用程序将保持原样。</li><li id="398a" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">代码重用也更容易。我们可以使用传统的GoF模式或面向对象的设计来分离代码，并创建用于类似目的的类/系统。</li></ul><p id="391c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">缺点:</p><ul class=""><li id="ad22" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">更难扩展。<br/> -即使您可以将整个应用程序塞进一个容器中(这有时非常困难，因为WildFly等应用程序服务器很重)，如果pod关闭→所有内容都要重新调整(因为monolith很重，这可能需要很多时间)<br/> -如果应用程序的一部分关闭，则更难微调系统</li></ul><p id="4179" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">整体材料的类型:</p><ol class=""><li id="f878" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk oo lt lu lv bi translated">单进程整体——典型的“一个大生物”系统</li><li id="6802" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">模块化整体——有许多模块，但为了部署，它们将被组合在一起。<strong class="jp ir"> Shopify </strong>就是一个例子。</li><li id="2050" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">分布式整体结构——罕见的东西。</li></ol><h1 id="a2ba" class="my mz iq bd na nb od nd ne nf oe nh ni nj of nl nm nn og np nq nr oh nt nu nv bi translated">快速了解微服务中使用的技术</h1><p id="fa79" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">简要介绍微服务中使用的技术/方法:</p><ol class=""><li id="334e" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk oo lt lu lv bi translated"><em class="oc">日志和跟踪</em>:与monolith相比，它们需要另一种方法，因为存在一个实体跨越多个服务的情况。我们需要追踪它。</li><li id="15e8" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated"><em class="oc">流式</em>用于发送数据，不通过批处理，因为它要慢得多。</li><li id="b800" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">每个微服务可能包括<em class="oc">不同的语言</em>和<em class="oc">数据库。</em></li><li id="fcfc" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated"><em class="oc">健壮性</em> —系统处理错误的能力。阅读关于这个问题的monolith部分。</li><li id="a1f0" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated"><em class="oc">扩展</em>更简单——每个微服务都可以单独扩展，并且可以唯一地受到资源的限制。</li><li id="1993" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated"><em class="oc">易于部署</em> —与将系统部署在多台服务器上的monolith相比，每个部分都可以轻松重新部署，这需要花费大量时间，而且风险很高</li><li id="98a9" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated"><em class="oc">可组合性</em> —一段代码可以通过<em class="oc">单独的微服务</em>或<em class="oc">客户端库</em>在多个服务中使用。</li></ol><h2 id="7a7a" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">微服务的痛点:</h2><ol class=""><li id="c144" class="ln lo iq jp b jq nw ju nx jy pb kc pc kg pd kk oo lt lu lv bi translated">借助微服务，我们有了<em class="oc">分布式数据库</em>。这增加了分析整个数据的难度。因此，我们需要使用流，数据湖等。而在<strong class="jp ir"> monolith </strong>中，一个数据库→一个副本更容易让报告工具从中获取数据。</li></ol><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi pe"><img src="../Images/76fa2626d6dcb5c72b98b49f9edbc6fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VfJ2CU86cOlIH-3_oYHM_A.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">读取副本示例</figcaption></figure><p id="ef24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.技术超载</p><p id="2698" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.第一阶段的成本:更多用于计算、联网和存储的机器</p><p id="237b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.开发经验:有时不可能让一台机器上的所有服务都保持运行。</p><h1 id="b844" class="my mz iq bd na nb od nd ne nf oe nh ni nj of nl nm nn og np nq nr oh nt nu nv bi translated">微服务因素</h1><ol class=""><li id="c2d6" class="ln lo iq jp b jq nw ju nx jy pb kc pc kg pd kk oo lt lu lv bi translated"><strong class="jp ir">微服务内的信息隐藏</strong>导致:<br/> -改进的开发时间<br/> -可理解性(每个微服务可以单独查看)<br/> -灵活性(每个微服务可以单独更改，不影响其他系统)</li><li id="1700" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">高<strong class="jp ir">凝聚力</strong>。“一起更改的代码将保持不变”——这是我们的奋斗目标。该术语与<strong class="jp ir">内部微服务</strong>通信相关。</li><li id="f2db" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">低<strong class="jp ir">联轴器</strong>。该术语与<strong class="jp ir">跨微服务</strong>通信相关。我们需要使它们尽可能独立，以支持独立的可部署性。</li></ol><p id="b677" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，这里的<strong class="jp ir"> <em class="oc">不应该有任何假设</em> </strong>之间的服务才是真正独立的系统。</p><h2 id="1429" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">联轴器类型:</h2><ol class=""><li id="3e7a" class="ln lo iq jp b jq nw ju nx jy pb kc pc kg pd kk oo lt lu lv bi translated"><strong class="jp ir">域</strong>:一个微服务器调用另一个微服务器，因为它需要它提供的功能。如果明智地使用，这一点也不坏——分成更细粒度的服务来分散逻辑，并且您只需要共享最少量的数据来保持尽可能低的耦合。因此，如果保持最小化并利用<strong class="jp ir">信息隐藏</strong>是没问题的</li></ol><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi pf"><img src="../Images/836bc694193cb8dd8c076e787d9b5b66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K8TQxuzuyR5W1_CJALSjuw.png"/></div></div></figure><p id="b22e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2。穿越</strong>:部分数据通过某个微服务传输，因为第二个服务与第一个服务需要的服务有连接。</p><p id="f970" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解决方案:</p><ul class=""><li id="52b5" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">直接调用下游微服务</li><li id="239f" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">让第二个服务只接受下一次调用所需的信息(也称为创建<strong class="jp ir">合同</strong> ) — <strong class="jp ir">图片见</strong></li><li id="9997" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">仍然坚持这种耦合，但是隐藏信息，并使传递服务将它视为blob。</li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi pg"><img src="../Images/c5f1812ca2ae46ccc073649179f1fb03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HilUNmBb480t0HZk2hemoQ.png"/></div></div></figure><p id="63fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3。公共耦合</strong> : 2+服务使用共享<strong class="jp ir">数据</strong></p><p id="a771" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解决方案:使用单独的服务，该服务接受所有请求并决定接受/转到数据库还是拒绝</p><p id="d6bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是这会导致<strong class="jp ir">资源争夺</strong>，这就是为什么要小心的原因</p><p id="f271" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">错误的变体:</strong></p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ph"><img src="../Images/aaa587adb4cf6a1c09d5bfe52cd70a72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-K6r8ajHGFaR1QZE0JR5jQ.png"/></div></div></figure><p id="e2f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">好的变体:</strong></p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi pi"><img src="../Images/47516e6ebf8eb95c35489940c5381719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jglY__biM_ydB-jXYzQioA.png"/></div></div></figure><p id="7721" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 4。内容耦合</strong>:上游服务到下游，改变其内部状态。即可以直接访问数据库。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi pj"><img src="../Images/abe79a84a0e13f159f733d923c529348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sfCP_ykAfBEYTjeFcV2YWg.png"/></div></div></figure><h1 id="be92" class="my mz iq bd na nb od nd ne nf oe nh ni nj of nl nm nn og np nq nr oh nt nu nv bi translated">DDD —领域驱动设计</h1><p id="4c8a" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">这是一个很有争议的话题，我将从这本书的角度来写它，并增加阅读资源。</p><p id="d4ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">什么是<strong class="jp ir">域</strong>？这是我们的系统负责的一个领域。例如，银行系统具有为最终用户提供端到端支付功能的领域。它非常广泛，因此它被划分为子域，在子域中会发生更细粒度的专门化。</p><p id="6087" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与<strong class="jp ir"> DDD </strong>相关的三个主要概念:</p><ul class=""><li id="cb2b" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><strong class="jp ir">无处不在的语言</strong>——商业世界和开发者之间的共同语言。在代码库中开发这样的语言，以便将来的开发人员能够容易地理解它。它还包括设计API的类似概念。</li><li id="2270" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><strong class="jp ir">聚合</strong>—订单、应用程序等真实业务对象的表示。通常，聚合与一个微服务相关，但是一个微服务可以有多个聚合。它有状态、生命周期，通常应该禁止外部世界对其进行更改。此外，一个聚合也可能与其他聚合有关系，其中这种关系可以是一个微服务内的<em class="oc">或跨越多个</em>的<em class="oc">。</em></li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi pk"><img src="../Images/cb7e4bf5f260cb5f623ff107664783f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PmobHONg425mp4w0sUYp5w.png"/></div></div></figure><ul class=""><li id="05d4" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><strong class="jp ir">有界上下文</strong> —其背后有一些逻辑完成的上下文。例如，3个微服务可以围绕特定的业务需求执行逻辑。因此，它们在逻辑上可以放在同一个有界的上下文中。此外，一个具有多个微服务的有界上下文可以向外部世界展示一个端点，其中仅呈现<strong class="jp ir">集合</strong>中的特定数据(并非来自该微服务的所有字段都向外部世界显示)。这里的重点是<em class="oc">信息隐藏</em>。此外，我们可以从模型中暴露各种东西。如果相似的概念出现在不同的有界上下文中，用不同的名称命名它们(客户和接收者),以免混淆。</li></ul><p id="1af0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你感兴趣，你可以深入MDE，因为它使用了DDD的概念，但是有点不同。<strong class="jp ir"> Eclipse EMF </strong>是一个使用这个概念的工具。</p><div class="ku kv gp gr kw kx"><a href="https://modeling-languages.com/comparing-domain-driven-design-model-driven-engineering/" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">领域驱动设计与模型驱动工程的比较</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">在这篇评论中，David询问了领域驱动设计(在这本开创性的书中首次提出)…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">modeling-languages.com</p></div></div><div class="lg l"><div class="pl l li lj lk lg ll lm kx"/></div></div></a></div><h2 id="15c1" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">映射聚合和有界上下文</h2><p id="e055" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">内部有<em class="oc">聚合</em>的<em class="oc">有界上下文</em>的例子:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi pm"><img src="../Images/815a882b2a6de001954665826aad680a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EWXUPgbDq1jL5uLMIGXcPw.png"/></div></div></figure><p id="49c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">外部的一个微服务可以触发另一个微服务，但是第二个微服务可以公开一个API，然后该API被分成多个服务。此外，请记住，每个聚合最好由一个微服务来处理— <strong class="jp ir">信息隐藏</strong>。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi pn"><img src="../Images/7697cef519ec38e9d76fe7f61b1afc25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HDkvctSBt2nkUabDFZEiPA.png"/></div></div></figure><p id="7baf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">事件风暴</strong> —与所有利益相关者(技术和非技术)一起设计MSA系统的过程。它由多个步骤组成:</p><ul class=""><li id="6e34" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><em class="oc">域事件</em>标识:下单</li><li id="b74c" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">从上面触发事件的<em class="oc">命令</em>的识别</li><li id="0213" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">定义<em class="oc">聚合</em></li></ul><p id="e822" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">= &gt;因此，确定<strong class="jp ir">有界上下文</strong></p><p id="7224" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">MSA的其他概念:</p><ul class=""><li id="09d6" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><strong class="jp ir">易失性</strong> —将相似代码/常用部分提取到另一个微服务或客户端库中。</li><li id="2bc8" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><strong class="jp ir">数据</strong> —分离处理隐私数据的服务和不处理隐私数据的服务。</li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi po"><img src="../Images/0137d60fe78e84bf5ca6c2a0282f4a39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*88KKJtc9BW9qS6Rxex7VqQ.png"/></div></div></figure><ul class=""><li id="2211" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><strong class="jp ir">组织</strong> —垂直滑动(按领域划分的团队)比水平滑动(传统的MVC方法)更好</li></ul><h1 id="42dc" class="my mz iq bd na nb od nd ne nf oe nh ni nj of nl nm nn og np nq nr oh nt nu nv bi translated">劈开整块石头</h1><blockquote class="oi oj ok"><p id="19c2" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated"><strong class="jp ir"> Monolith </strong>还不错，你不需要把所有东西从它分解到<strong class="jp ir"> MSA </strong>。即使你决定这样做，也要分小部分来做。</p></blockquote><p id="4d2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最好的方法之一是将<em class="oc"> monolith </em>与<em class="oc"> MSA </em>结合起来。例如，您开始将您的monolith分解为微服务，并看到某些部分很难分开，于是决定让它们保持原样。<strong class="jp ir"> <em class="oc">扼杀者无花果图案</em> </strong>见下面几段。</p><blockquote class="oi oj ok"><p id="c4e1" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated"><strong class="jp ir">决定是否将某些功能拆分到MSA的规则</strong>:提取的难易程度与提取微服务的好处</p></blockquote><h2 id="d973" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">先分解什么</h2><p id="1502" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated"><em class="oc">代码优先</em>是一种更受欢迎的方法，在这种方法中，你将围绕业务逻辑的整体的一部分提取到单独的服务中。<em class="oc">数据第一</em>人气较低。这是您将monolith数据库分成多个独立服务的地方。</p><h2 id="5725" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">分解模式</h2><ol class=""><li id="a463" class="ln lo iq jp b jq nw ju nx jy pb kc pc kg pd kk oo lt lu lv bi translated"><em class="oc">扼杀者Fig模式</em> —一个面向外部世界的粗粒度API，然后内部请求被路由到新的<em class="oc">微服务</em>或<em class="oc"> monolith </em>。</li></ol><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi pp"><img src="../Images/b4dac78d13f7d0b4f11a295c8b1f1033.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y1-XIV9oybTAyz1HiOVz6A.png"/></div></div></figure><p id="e97f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<em class="oc">并行运行</em> —向两个部分发送请求的技术:旧的整体和新的MSA。并将它们进行比较。</p><p id="abc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.<em class="oc">功能切换</em> —允许在两个功能版本之间切换的开关。</p><h2 id="24e0" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">数据问题</h2><ol class=""><li id="be59" class="ln lo iq jp b jq nw ju nx jy pb kc pc kg pd kk oo lt lu lv bi translated"><strong class="jp ir">性能</strong>:当我们将monolith db拆分成服务时——在单个数据库中不再可能进行真正的连接操作。现在我们将这个功能转移到<em class="oc">应用层</em>。因此，<em class="oc">延迟</em>现在要高得多。</li></ol><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi pq"><img src="../Images/afa09694cf48488a58d8e8bf6aa7751c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Wetk1wgm1c34Fcg8ESN0w.png"/></div></div></figure><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi pr"><img src="../Images/6e80ba56903358ae1dcb8e280efd1370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9tDAmnumjUNXqux3ktsBJQ.png"/></div></div></figure><p id="c00f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<em class="oc">数据完整性</em>:忘掉<strong class="jp ir">酸</strong>。我们不再有我们所依赖的真正的数据库事务。因此，我们从数据没有完整性的角度来操作。注意<strong class="jp ir"> <em class="oc">复印图案</em> </strong>。</p><p id="0815" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.<em class="oc">报告数据库</em>:例如，我们仍然需要允许我们的业务部门对数据进行高效的查询。为此，每个微服务都有责任向一个<em class="oc">报告数据库</em>发送数据。通常，只有数据子集被发送到这个具有报告数据库的微服务。在这个数据库中，所有进一步的聚合都以结构化的方式呈现数据(是的，这个<em class="oc">报告数据库</em>本身就是一个微服务)。</p><h1 id="20df" class="my mz iq bd na nb od nd ne nf oe nh ni nj of nl nm nn og np nq nr oh nt nu nv bi translated">MSA沟通风格</h1><ul class=""><li id="b248" class="ln lo iq jp b jq nw ju nx jy pb kc pc kg pd kk ls lt lu lv bi translated"><strong class="jp ir">进程间</strong>跨网络</li><li id="cb36" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><strong class="jp ir">进程内</strong>在单个进程内</li></ul><h2 id="4b29" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">表演</h2><p id="b486" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">当<em class="oc">进程内</em>发生时，我们只需在内存中传递指针，编译器就会为我们完成所有需要的优化。</p><p id="19ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当<em class="oc">进程间</em>发生时，数据包通过网络发送，其中数据被<strong class="jp ir">串行化</strong>和<strong class="jp ir">解串行化</strong>。在这种情况下:</p><ol class=""><li id="f52b" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk oo lt lu lv bi translated">选择更优化的序列化机制</li><li id="a7dd" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">如果可能的话，<strong class="jp ir">将数据卸载到文件系统</strong>并传递对它的引用</li></ol><h2 id="e9d2" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">变化</h2><p id="099f" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">例如，当你改变微服务时，你需要记住<em class="oc">进程内</em>驻留在单一代码库和服务中→改变它没有太大的区别。</p><p id="2cdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，说到<em class="oc">进程间</em>，我们处理的是2+微服务，它们应该具有<strong class="jp ir">独立的可部署性。</strong></p><p id="c14f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我们应该避免<strong class="jp ir">亦步亦趋的部署</strong>。这是一种阻止用户使用我们的应用程序的方式，除非安装了更新。</p><h2 id="58fa" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">错误处理</h2><ul class=""><li id="7a31" class="ln lo iq jp b jq nw ju nx jy pb kc pc kg pd kk ls lt lu lv bi translated">进程内通信:错误是确定性的，存在于一个服务中。因此，我们可以跟踪错误</li><li id="7d1d" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><em class="oc">进程间</em>:错误不在我们的控制范围内，因为网络问题、容器被杀死等原因可能会导致短期错误。为此，尝试采用<strong class="jp ir">丰富的错误语义</strong>(就像HTTP中的400，500个代码)。它给予下游服务(在我们的例子中是客户机)更多的控制来处理某些错误情况→允许您构建更健壮的系统。</li></ul><h2 id="4cb5" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">进程间通信技术选择</h2><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ps"><img src="../Images/073dadc273e9e7e2dbd977945cc1927f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m2AZJRnPu064UMZI8jpEJw.png"/></div></div></figure><ol class=""><li id="c82e" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk oo lt lu lv bi translated"><strong class="jp ir"> <em class="oc">同步阻塞</em> </strong>是最容易实现的一个，但是它引入了2个服务之间的耦合。</li><li id="17cd" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated"><strong class="jp ir"> <em class="oc">异步无阻塞</em> </strong>在无法重构的长时间运行的流程或链中实现。</li></ol><p id="301f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">异步非阻塞方法:</p><ol class=""><li id="8ccb" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk oo lt lu lv bi translated"><strong class="jp ir">公共数据:</strong>一个微服务创建文件，其他微服务对这个动作做出反应。例子:<em class="oc">数据湖</em>、<em class="oc">数据仓库<br/> - </em>优点:易于用现有工具实现<br/> -缺点:服务间耦合度高，因为如果数据存储发生变化—要对微服务进行更改；读取/写入存储时的延迟问题；虚拟数据存储的健壮性。<br/> <strong class="jp ir">使用场合:</strong>在需要发送大量数据的情况下</li><li id="1c75" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated"><strong class="jp ir">请求-响应:</strong>通常通过队列风格实现，其中可以存储多个请求。<br/>记住<em class="oc">响应</em>到达另一个实例，因此我们需要记住最初的<em class="oc">请求</em>。即通过数据库。还有，别忘了实现<strong class="jp ir"> <em class="oc">超时</em> </strong>。<br/> <strong class="jp ir">用在哪里:</strong>当进一步的动作完成后有响应；当我们需要做某种补偿动作时，比如<strong class="jp ir"> <em class="oc">重试</em> </strong>等等。</li></ol><blockquote class="oi oj ok"><p id="d8c7" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">最好使用<strong class="jp ir">并行调用</strong>，可以通过async/await stuff完成，而不是<strong class="jp ir">顺序调用</strong>。在前者中，总的<em class="iq">延迟</em>是最慢的呼叫，而在后者中，总的<em class="iq">延迟</em>。</p></blockquote><p id="a261" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.<strong class="jp ir">事件驱动通信:</strong>一方发布事件，另一方订阅话题，监听事件。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi pt"><img src="../Images/7f63438b318875a0364bc952d89c8173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*quNaQDD4Nb7J_xYlJJNT4g.png"/></div></div></figure><blockquote class="oi oj ok"><p id="4e4b" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">顺便说一下:<strong class="jp ir">事件</strong>是有效载荷，<strong class="jp ir">消息</strong>是媒介</p></blockquote><p id="5aa2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主要优势:<strong class="jp ir"> <em class="oc">比前面提到的通信类型中的</em> </strong>耦合更少。</p><p id="758c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主要缺点:复杂得多，有许多潜在的问题</p><p id="ad8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir">事件</strong>中放什么？</p><ol class=""><li id="e041" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk oo lt lu lv bi translated"><strong class="jp ir">只有id </strong>的，例如，新创建的客户、订单等。但是这可能还不够，还需要进一步的请求= &gt;域耦合，微服务上的额外负载来处理请求</li></ol><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi pu"><img src="../Images/b9a789bb63044f82d94c3ce55a401122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CM129F5zyD9lt5l4GQkA5A.png"/></div></div></figure><p id="f391" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<strong class="jp ir">包含所有数据的完整事件</strong>可能是一个选项，但存在某些问题:</p><ul class=""><li id="e25a" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">没有<em class="oc">信息隐藏</em></li><li id="4484" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><strong class="jp ir">事件</strong>的大小可能过大</li><li id="4344" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><em class="oc">忠诚度</em>微服务可能不需要某些数据，但它仍然接收这些数据，因为<strong class="jp ir">事件</strong>拥有这些数据。关于<em class="oc">敏感/私有</em>数据，它可能存在某些问题——请小心</li><li id="b418" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">数据在<strong class="jp ir">事件</strong>之后—与外部服务签约。如果我们从<strong class="jp ir">事件</strong>中移除一些数据，契约可能会被破坏</li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi pu"><img src="../Images/6a38f3e4dd6a52abae07160620f049c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uI5cQrSGKUbtoVddYkmq0g.png"/></div></div></figure><h1 id="2d8e" class="my mz iq bd na nb od nd ne nf oe nh ni nj of nl nm nn og np nq nr oh nt nu nv bi translated">实施微服务通信</h1><h2 id="d956" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">规则:</h2><ol class=""><li id="58f3" class="ln lo iq jp b jq nw ju nx jy pb kc pc kg pd kk oo lt lu lv bi translated">使向后兼容变得容易(即添加字段不应破坏系统)</li><li id="06e6" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">使微服务的接口显式化(即使用模式)</li><li id="9e6d" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">保持API技术不可知(例如，想象一年后你需要用另一种语言重写整个服务)</li><li id="4f40" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">隐藏内部实现细节以减少耦合</li></ol><h2 id="aee5" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">技术选择:</h2><ol class=""><li id="ffc5" class="ln lo iq jp b jq nw ju nx jy pb kc pc kg pd kk oo lt lu lv bi translated">RPC: 远程过程调用。用于隐藏远程调用，就像在本地完成一样。<br/> <strong class="jp ir">优势:</strong>在一些实现中，如gRPC或AVRO，它能够在更大程度上序列化有效载荷→减小整体有效载荷的大小；更广泛的网络协议选择(TCP或UDP)。<br/> BTW，gRPC采用<strong class="jp ir"> HTTP 2.0 </strong> <br/> <strong class="jp ir">缺点:</strong>技术耦合；需要重新生成存根(如<code class="fe pv pw px py b">proto</code>文件)</li><li id="a2a8" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated"><strong class="jp ir"> REST: </strong>不购买任何协议，但一般与HTTP <br/> <strong class="jp ir">一起使用优点:</strong>对<em class="oc">资源</em>(即JSON)没有具体格式；像HATEOAS这样的现代东西可以被利用<br/> <strong class="jp ir">缺点:</strong>因为REST通常是通过HTTP完成的，所以你不得不使用TCP(除非你使用QUIC，其中HTTP over UDP)</li></ol><p id="7bb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以上两者都更适合于<em class="oc">同步请求-响应风格</em>。</p><blockquote class="oi oj ok"><p id="b3f6" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">阅读HATEOAS:</p></blockquote><div class="ku kv gp gr kw kx"><a href="https://restfulapi.net/hateoas/" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">HATEOAS驱动的REST APIs</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">HATEOAS(作为应用状态引擎的超媒体)是REST应用架构的一个约束。HATEOAS…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">restfulapi.net</p></div></div><div class="lg l"><div class="pz l li lj lk lg ll lm kx"/></div></div></a></div><blockquote class="oi oj ok"><p id="25b9" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">嘿，读一读我写的关于网络的文章，以便更好地理解这些流行词汇背后的含义:</p></blockquote><div class="ku kv gp gr kw kx"><a rel="noopener  ugc nofollow" target="_blank" href="/huge-course-about-networking-web-and-everything-in-between-d6f425ceea13"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">庞大的网络课程，网络和其间的一切</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">深入阅读本文，了解OSI、ARP、NAT、LB、TLS等更多信息。此外，还有过多的资源…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="lg l"><div class="qa l li lj lk lg ll lm kx"/></div></div></a></div><p id="edc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.<strong class="jp ir"> GraphQL: </strong>允许发出一个请求，该请求将被支持GraphQL的微服务API接受，所有需要的请求将被发送到下游微服务以收集数据。因此，我们不是向几个微服务发出多个请求，而是发出一个请求。</p><blockquote class="oi oj ok"><p id="6776" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">请记住:下游服务必须为客户端公开GraphQL API</p></blockquote><p id="c658" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">GraphQL使缓存变得几乎不可能，并且它给服务器增加了额外的负载。另外，它有利于读取，但不利于写入。因此，一些团队让<strong class="jp ir"> REST </strong>用于<em class="oc">写</em>，让<strong class="jp ir"> GraphQL </strong>用于<em class="oc">读</em>。</p><p id="5404" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，GraphQL <strong class="jp ir">不是数据库</strong>的包装器，它不能耦合到特定的数据存储。</p><p id="f78d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.<strong class="jp ir">消息经纪人:</strong></p><p id="1e2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">基于队列</strong>的代理是点对点的，生产者将数据放入队列，消费者获取数据。所以，我们通常了解消费者。</p><p id="cd4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir">主题中，基于</strong>的代理生产者发出消息，该消息可以是请求/响应/事件，并且<strong class="jp ir">多个消费者</strong>可以读取该数据。一般我们不了解消费者。</p><p id="0885" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">券商的主要优势是<strong class="jp ir">保底交割</strong>。此外，请注意<strong class="jp ir">只发送一次</strong>，即如果您的消费者不止一次看到该消息，请确保其能够处理(保留消息的<code class="fe pv pw px py b">id</code>或类似内容)。</p><p id="3f76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">卡夫卡的特点是信息的持久性，卡夫卡自身内部的流处理</p><blockquote class="oi oj ok"><p id="e3ec" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">阅读有关流处理与批处理的更多信息:</p></blockquote><div class="ku kv gp gr kw kx"><a href="https://hazelcast.com/glossary/stream-processing/" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">流处理</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">流处理是在创建数据时对一系列数据采取行动的实践。</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">hazelcast.com</p></div></div><div class="lg l"><div class="qb l li lj lk lg ll lm kx"/></div></div></a></div><p id="bc32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，还有两种序列化格式:<strong class="jp ir">文本格式</strong>和<strong class="jp ir">二进制格式</strong>。前者使用得更频繁，因为它是更常见的方式，而后者常见于gRPC之类的协议缓冲区。</p><h2 id="a796" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">计划</h2><p id="9973" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">您可以使用模式验证传入的消息。它们有各种类型，但是在XML中最流行的是XSD，而在JSON中最流行的是JSONSchema。</p><div class="ku kv gp gr kw kx"><a href="https://json-schema.org/" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">JSON模式</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">JSON Schema是一种声明性语言，允许您注释和验证JSON文档。JSON模式支持…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">json-schema.org</p></div></div></div></a></div><p id="7ade" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模式破坏分为两类:<strong class="jp ir">结构</strong>和<strong class="jp ir">语义</strong>。</p><p id="f367" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第一种情况下，很明显:端点的结构发生了变化。第二，端点的结构没有改变，但是行为改变了。例如，你需要返回计算的整数结果，但是你如何计算它们却有很大的不同。</p><h2 id="8ed7" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">避免微服务中的重大变化</h2><ol class=""><li id="491d" class="ln lo iq jp b jq nw ju nx jy pb kc pc kg pd kk oo lt lu lv bi translated">膨胀改变——当你给合同增加新的东西时，不要去掉旧的</li><li id="75fe" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated"><em class="oc">宽容的读者</em> —如果契约中有附加字段，那么让微服务接受并忽略它们</li><li id="c1cd" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated"><em class="oc">根据情况选择合适的技术</em></li><li id="5e13" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated"><em class="oc">显式接口</em> —尽可能多地使用模式</li><li id="55c7" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated"><em class="oc">尽早捕捉重大变更</em> —使用工具比较变更并轻松捕捉错误:协议缓冲区的protolock、json模式的json-schema-diff-validator、openapi规范的openapi-diff。最好将这一点纳入CI构建，以决定我们的准部署是通过还是失败</li></ol><h2 id="bc04" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">管理重大变更</h2><ol class=""><li id="8935" class="ln lo iq jp b jq nw ju nx jy pb kc pc kg pd kk oo lt lu lv bi translated"><em class="oc">锁步部署</em> —你让消费者更新，否则他们无法使用</li><li id="e28e" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated"><em class="oc">共存不兼容的微服务版本</em> —保持两个版本正常运行</li></ol><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi qc"><img src="../Images/d8ebf698ab7398ee833e778f1af04ee9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h9IVgwPKF_qzdN4gwX9vng.png"/></div></div></figure><p id="388e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="oc"> 3。模拟旧接口</em> —保留旧的和新的端点，但只有新版本的微服务在运行。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi qd"><img src="../Images/5345f34c9e2c5278b97220d34c473bbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rsp1GyhaKT6c7rsVsdgRyw.png"/></div></div></figure><h2 id="c32f" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">在微服务中干燥</h2><p id="bcfc" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated"><em class="oc">干</em>——<em class="oc">不要重复自己</em>是一个概念，它表明你不应该多次编写相同的代码。</p><p id="3a3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有两种主要的方法来实现这一点:图书馆和微服务。</p><p id="4cca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前者意味着你把相似的代码放在库里面，只是把它作为依赖来使用。单独的微服务—您可以将此服务作为另一个呼叫选项。库的问题是在你更新它们之后，你需要<strong class="jp ir">重新部署使用它的服务</strong>。</p><h2 id="b233" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">服务发现</h2><p id="6839" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">这是在系统中找到微服务的一种方式:</p><ul class=""><li id="1383" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">允许服务注册自己并说:我在这里，准备好了</li><li id="e865" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">注册时在系统中查找微服务</li></ul><p id="7f7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，<em class="oc">服务发现</em>允许服务注册它，然后允许服务被使用。</p><p id="5c95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现的方法:</p><p id="8bad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="oc">更简单的方法:</em></p><ol class=""><li id="c27c" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk oo lt lu lv bi translated">DNS。使用服务的IP地址。一种方法是将服务IP保存在负载平衡器中</li></ol><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi qe"><img src="../Images/352d827df77de894ca974200bc213934.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*emm8hwlRk2d66ju5x87-HA.png"/></div></div></figure><p id="4818" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="oc">更高级的方式是动态服务注册中心:</em></p><ol class=""><li id="0f95" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk oo lt lu lv bi translated">动物园管理员</li><li id="33fe" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">领事</li><li id="7a89" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">Kubernetes(通常使用<strong class="jp ir"> etcd </strong></li></ol><h2 id="d521" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">浅谈服务网格和API网关</h2><p id="adc1" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">有两种类型的流量:</p><ul class=""><li id="f454" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">南北:从数据中心外部到内部</li><li id="d7a7" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">东西:数据中心内部</li></ul><p id="726a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> API网关</strong>和<strong class="jp ir">服务网格</strong>的区别:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi qf"><img src="../Images/6f2705c1c79148a583ecc51b118d051d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7YKuMgM75C1vviSQtA3foA.png"/></div></div></figure><p id="71bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> API网关</strong>(又名管道)必须是哑的，而所有的<strong class="jp ir">智能</strong>(智能逻辑)——在我们的系统内部。</p><p id="0699" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通用的微服务间功能可以通过<em class="oc">服务网格</em>重用。</p><p id="ad97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于更加关注<em class="oc">南北流量</em>，API gateway在微服务环境中的主要关注点是将外部方的请求映射到内部微服务。这种责任类似于使用简单的HTTP代理所能实现的，事实上，API网关通常在现有HTTP代理产品的基础上构建更多的功能，并且它们在很大程度上充当反向代理。</p><blockquote class="oi oj ok"><p id="75e8" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">问题:2个微服务之间为什么不用API网关/普通网络代理？→网络跳跃→延迟问题</p></blockquote><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi qg"><img src="../Images/c0395936f45303cac4bb0ff44a536270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wJKLiGWnyDj4oDV-uJsxAQ.png"/></div></div></figure><p id="49d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，你可以通过使用<em class="oc">服务网</em>，尽可能减少南北交通流量，并尝试处理东西交通。</p><h1 id="840f" class="my mz iq bd na nb od nd ne nf oe nh ni nj of nl nm nn og np nq nr oh nt nu nv bi translated">工作流:微服务中的数据库内容</h1><p id="c59a" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">在微服务中，当我们拆分成服务时，我们也会对数据库做同样的事情。</p><p id="f043" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是它在<em class="oc">巨石</em>中的样子。我们有一个整体应用程序和一个整体数据库。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi qh"><img src="../Images/ce675aa5070a406d15adec788061b2a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d3z6s_RDzaDybi4V90kRlA.png"/></div></div></figure><p id="0e2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们拆分成独立的微服务时，我们还需要拆分数据库。看上面的<strong class="jp ir">先分解什么</strong>段。</p><p id="2063" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是具有自己数据库的独立微服务的示例。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi qh"><img src="../Images/8df6018606aec95a949ac12b17536df9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L6mNde_53D8thMkuad3jbQ.png"/></div></div></figure><p id="03fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在微服务中我们失去了传统的<em class="oc">酸</em>，尤其是<strong class="jp ir">原子数</strong>。不过，我们可以用一些不寻常的方式来实现它:分布式事务—两阶段提交(简称— 2PC)。</p><h2 id="89c6" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">2PC</h2><p id="cb9e" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">在两阶段提交中，我们有两个主要行动:</p><ul class=""><li id="b900" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">投票阶段</li><li id="95bf" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">提交阶段</li></ul><p id="4027" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们先看看图片，然后我会用<em class="oc"> plain/text </em>给出解释:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi qd"><img src="../Images/b60085e1ce7cb9200a1b780528ce9864.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tMOSJxn4ErSXujAmAvz1XQ.png"/></div></div></figure><p id="d8ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果两个工人<strong class="jp ir">同意</strong> —进入第二阶段<strong class="jp ir">提交</strong>。</p><p id="9160" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果出了什么问题呢:</p><p id="646b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="oc">第一个工人</em>接受命令<strong class="jp ir">锁定</strong>该行。但是<em class="oc">第二个工人</em>不同意<strong class="jp ir">拒绝</strong>。来自协调器的<em class="oc">回滚消息</em>被发送。所有的<strong class="jp ir">锁</strong>和类似的东西都被移除。</p><p id="8bef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题:</p><ul class=""><li id="ab8b" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">在2PC中，我们失去了<em class="oc">隔离</em>(字母I来自ACID)。所以，不能保证我们看不到中间结果</li><li id="fd27" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><strong class="jp ir">等待时间</strong>在<em class="oc">协调人</em>和参与者= &gt;之间处理时间受到影响</li><li id="2510" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">开发人员需要注意可能出现死锁</li></ul><p id="fcb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于好奇的人来说:</p><div class="ku kv gp gr kw kx"><a href="https://martinfowler.com/articles/patterns-of-distributed-systems/two-phase-commit.html" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">两阶段提交</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">在一个原子操作中更新多个节点上的资源。当数据需要以原子方式存储在多个集群上时…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">martinfowler.com</p></div></div><div class="lg l"><div class="qi l li lj lk lg ll lm kx"/></div></div></a></div><blockquote class="oi oj ok"><p id="50c4" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">按照Sam Newman的说法:“最好不要使用2PC，让这部分驻留在monolith数据库中”。</p></blockquote><p id="f578" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回想一下我们在开始时探索的:如果没有这样的需求，最好不要拆分。</p><p id="79b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更好的方法？→ <strong class="jp ir">传奇</strong></p><h2 id="2cb5" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">萨迦</h2><p id="860c" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">saga——无需2PC就能协调一个状态中的多个变化的算法。它使用许多可以独立执行的离散操作。</p><p id="c93e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它允许对行/表使用更少的锁→减少数据库中的争用。</p><p id="019b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们先来看一下这个图表:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi qj"><img src="../Images/74fec056e53c6edd1fb364260f4e0d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2uVoBYhtrTPcYcBlJo63TA.png"/></div></div></figure><blockquote class="oi oj ok"><p id="5aaf" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">最初它被设计用来处理<strong class="jp ir"><em class="iq">LLT——万岁交易</em> </strong>。</p></blockquote><p id="3901" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">重要:</strong>没有<em class="oc">原子性</em>在整个Saga操作的层次上，只是在每个单独操作的层次上。</p><p id="466f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Saga故障模式:<strong class="jp ir">向后</strong>(回滚—撤销之前提交的事务)和<strong class="jp ir">向前</strong>(从故障处开始并重试)恢复。</p><blockquote class="oi oj ok"><p id="86e0" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">重要提示: Saga使我们能够从业务失败中恢复，而不是从技术失败中恢复。技术问题由开发人员来跟踪</p></blockquote><p id="8222" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果发生了什么事情，我们需要进行回滚:<strong class="jp ir">补偿事务</strong>。它是一个事务序列，回滚每个微服务的初始事务。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi qj"><img src="../Images/0bd012347af4a5a5af0f991ab74a62cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-OZrtrYQ4yXoa2MucOgU2g.png"/></div></div></figure><p id="3803" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，<strong class="jp ir">这不是一个简单的回滚</strong>像完全擦除事务。这里我们创建一个新的事务<strong class="jp ir">来撤销前一个事务的更改。这些补偿事务被称为<strong class="jp ir">语义回滚</strong>。</strong></p><p id="3948" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">语义意味着我们需要处理业务逻辑问题:在交易过程中，已经向用户发送了一封电子邮件。使用<strong class="jp ir">补偿交易</strong> —已发送带有道歉的新电子邮件</p><p id="8c52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">减少Saga中错误的方法:</p><ul class=""><li id="a134" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">重新安排流程以减少回滚</li><li id="8225" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">向后和向前混合失败</li></ul><h2 id="da54" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">实施传奇</h2><p id="a36f" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">1.<em class="oc">精心策划的传奇</em>:集中协调和跟踪(指挥控制方法)；</p><ul class=""><li id="18c3" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">使用请求-响应风格</li><li id="42a2" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">具有更多的域耦合</li></ul><p id="6ff0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<em class="oc">精心设计的传奇</em>:松散耦合的模型，但是使得跟踪进度更加复杂(信任但是验证)</p><ul class=""><li id="27f1" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">使用代理来注册对特定事件感兴趣的微服务</li><li id="62de" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">更难跟踪我们的流程现在处于哪个阶段</li><li id="f6e9" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">例如，使用<strong class="jp ir">关联ID </strong>来跟踪日志记录</li><li id="7d38" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">使用单独的服务来清除事件，并在发生某些情况时采取<strong class="jp ir">补偿措施</strong></li></ul><blockquote class="oi oj ok"><p id="85a6" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">混合也是一种选择</p></blockquote><h1 id="9270" class="my mz iq bd na nb od nd ne nf oe nh ni nj of nl nm nn og np nq nr oh nt nu nv bi translated">构建:CI/CD及其周围的一切</h1><p id="9017" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated"><strong class="jp ir"> CI —持续集成</strong>。检查新代码是否与现有代码正确集成。</p><p id="7668" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CI有静态分析器和测试。因此，它确保代码被传输到正确的存储库。也就是说，像Jenkins这样的CI工具从<strong class="jp ir">我们的源repo </strong>中获取代码，编译代码，应用静态分析器，结果我们就有了一个工件。</p><p id="2bcf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">工件</strong> —用于每个部署的进一步验证。使用<strong class="jp ir">工件</strong>追溯代码，看看运行了哪些测试等等。每个工件都有其唯一的标识符:<em class="oc"> build-541 </em>。</p><div class="ku kv gp gr kw kx"><a href="https://dev.to/preciselyalyss/explain-artifacts-deployment-like-im-five-48c#comment-1894" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">像我五岁一样解释工件(部署)</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">艾莉丝的帖子💜。标签为explainlikeimfive，discuss，devops。</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">开发到</p></div></div><div class="lg l"><div class="qk l li lj lk lg ll lm kx"/></div></div></a></div><p id="67b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，为基础设施配置配置代码(简称:IAC)——更容易重现构建(代码的两个部分:程序本身和基础设施配置)。</p><div class="ku kv gp gr kw kx"><a href="https://www.copado.com/devops-hub/blog/what-is-the-difference-between-ci-and-cd-using-them-together-to-accelerate-the-feedback-loop-cddd" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">CI和CD有什么区别？一起使用它们来加速反馈循环</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">CI和CD有什么区别？虽然CI和CD经常互换使用，但它们是根本不同的…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">www.copado.com</p></div></div><div class="lg l"><div class="ql l li lj lk lg ll lm kx"/></div></div></a></div><blockquote class="oi oj ok"><p id="9745" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">分区构建成块:即快速测试和慢速测试</p></blockquote><p id="5370" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">连续交付</strong>使得在<strong class="jp ir">工件</strong>准备好之后进行大块流程成为可能:每个大块都是整个部署流程的一部分。对于每个部署，都有一个<strong class="jp ir">工件。</strong></p><p id="1e9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面我们可以看到，CI工具触发了流程，创建了工件，然后是进一步的步骤—CD。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi qm"><img src="../Images/f632d99f097576a10488c2e3ffa5d2ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fVHC6j37Izcglq7hOiopGw.png"/></div></div></figure><blockquote class="oi oj ok"><p id="27ad" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated"><strong class="jp ir">连续交付</strong> vs <strong class="jp ir">连续部署</strong>:前者可以没有后者而存在。前者需要人工干预来部署，而后者可以不需要人工干预。</p></blockquote></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><p id="ac1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在<strong class="jp ir">部署</strong>部分深入了解这张图片，我将对此进行深入解释。</p><p id="297e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">请注意:</strong>有时人们会说，say只是从回购中提取代码的过程，更进一步的步骤是CD。众说纷纭，但我更常看到第一种变体。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi qn"><img src="../Images/a3c0cd24996175267ad24ed7f87076c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kBDdAjsZBa7qTvxViZ98lA.png"/></div></div></figure><p id="0cd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，在支持高效CI/CD流程的开发中使用的良好实践:</p><p id="ea9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">基于主干的开发</strong>:短命的分支和小的、可读的补丁更好。</p><div class="ku kv gp gr kw kx"><a href="https://trunkbaseddevelopment.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">基于主干的开发</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">一种源代码控制分支模型，在这种模型中，开发人员在一个称为“主干”的分支中就代码进行协作，抵制任何…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">trunkbaseddevelopment.com</p></div></div><div class="lg l"><div class="qo l li lj lk lg ll lm kx"/></div></div></a></div><p id="8fe3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在CD期间，我们通常将我们的<strong class="jp ir">工件</strong>部署到不同的环境中，我们需要在快速反馈和类似生产的环境之间做出权衡。</p><h2 id="081e" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">工件创建的规则</h2><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi qp"><img src="../Images/21c3659917a75bcdf3b730d96e06dbd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*daLCkrxMGfwbd0ckLKgfkg.png"/></div></div></figure><ol class=""><li id="7000" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk oo lt lu lv bi translated">只构建一次</li><li id="2dad" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">为构建和部署使用相同的工件</li><li id="31f6" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">保持部署工件与环境无关</li></ol><p id="8c91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Artifactory或Nexus之类的仓库中存储工件</p><p id="ae68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然<strong class="jp ir">工件</strong>是我们的代码，但是最好有单独的配置(前面提到的IAC)。</p><h2 id="0253" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">将源代码和构建映射到微服务</h2><ol class=""><li id="fed8" class="ln lo iq jp b jq nw ju nx jy pb kc pc kg pd kk oo lt lu lv bi translated"><strong class="jp ir">针对所有微服务的一个大型回购</strong>和<strong class="jp ir">一个大型构建</strong> —所有实践中最差的。所有微服务的相同工件</li></ol><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi qq"><img src="../Images/b63658b1a94af045043b56e839ad6647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CsLOXjz99xdcLoKFc3Zm7Q.png"/></div></div></figure><p id="3f58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.每个微服务一个repo(又名<strong class="jp ir"> multirepo </strong>):每个微服务的<strong class="jp ir">唯一工件</strong>。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi qr"><img src="../Images/358780aac427389101ddbf205ed68e6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gD_G-IHKyHzkfMjoFZV-zw.png"/></div></div></figure><p id="7ce2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要记住的几点:</p><ul class=""><li id="b064" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">代码重用(类似于在下游微服务中用作依赖项的库)——在库在其报告中更新后→您还需要重新部署微服务</li><li id="e026" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">如果一个服务依赖于另一个(即端点)，那么我们需要在两个repos中进行更改。重要提示:如果不是异常，而是持续的—将微服务重构为<strong class="jp ir">太多耦合</strong></li></ul><p id="3037" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.<strong class="jp ir">单一回购</strong></p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi qs"><img src="../Images/da180dc038d6b16d41156eb0c6f336a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8yjQypv_ooVBWgz9o-Rxcw.png"/></div></div></figure><p id="5bc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CI触发有点困难</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi qt"><img src="../Images/499796078c0b380553f4fb93b5343939.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TYKPsqy0b55FvtvD4q1VYw.png"/></div></div></figure><blockquote class="oi oj ok"><p id="c7de" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">谷歌使用这种方法</p></blockquote><p id="4686" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要记住的几点:</p><ul class=""><li id="94fb" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><code class="fe pv pw px py b">atomic commit to the repo != atomic rollout</code>。在这种模式下，我们仍然需要两个独立的部署，所以要注意微服务的部署顺序。也就是说，对于服务A，我们需要首先部署带有更新的支持服务B</li><li id="50a9" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">要构建的映射:每个服务都有自己的<strong class="jp ir">工件</strong>。但一个回购可能引发另一个回购进行重建，或者某个回购可能引发许多其他回购。像巴泽尔一样使用smth</li><li id="c3b5" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">代码重用:在这种方法中，我们有可能不依赖于客户端库，而是依赖于单个源文件</li></ul><h2 id="dcee" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">所有权</h2><ol class=""><li id="98a8" class="ln lo iq jp b jq nw ju nx jy pb kc pc kg pd kk oo lt lu lv bi translated">强所有权——选定的一组人可以对代码进行更改。所以，如果有人想做出改变，就需要公关。</li><li id="b309" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">弱所有权——任何人都可以做出改变。</li></ol><h1 id="1b0f" class="my mz iq bd na nb od nd ne nf oe nh ni nj of nl nm nn og np nq nr oh nt nu nv bi translated">部署</h1><p id="5960" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">服务的多个实例应该在不同的硬件上，跨不同的数据中心，以保持更好的弹性和可伸缩性。</p><p id="2c77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于部署时的数据库:对同一类型的多个服务使用一个数据库。这并不违反共享数据库的规则。</p><p id="930b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> DC —数据中心</strong></p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi qu"><img src="../Images/93ddc10c2dffd995fa1e45bd915633d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RXEtPQFzvYs-u0SJu6UTMg.png"/></div></div></figure><p id="8278" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">说到数据库，最好将读取和写入副本分开，以便从数据库中移除整体负载。此外，它使我们能够更轻松地进行扩展。因此，我们可以轻松扩展读取副本的节点数量，甚至可以进一步<strong class="jp ir">分片</strong>它们以<strong class="jp ir">减少延迟</strong>。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi qv"><img src="../Images/0d568f5bba2cafff7f1a0450dddf52bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FpWnwJCKe1geKCkH4dYYLw.png"/></div></div></figure><p id="7fd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，有时公司更喜欢将多个孤立的数据库放入一个数据库基础设施中。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi qw"><img src="../Images/91a0f7107070d00af6a20602285c9289.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5slt_kicWW4lgY4jK-Bnww.png"/></div></div></figure><h2 id="6d0d" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">环境</h2><p id="9978" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">回忆一下构建部分的图片:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi qn"><img src="../Images/a3c0cd24996175267ad24ed7f87076c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kBDdAjsZBa7qTvxViZ98lA.png"/></div></div></figure><p id="cae9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的服务部署在不同的环境中。越接近生产，可能需要的时间越长，因为模拟越少，意味着测试时间越长，等等。此外，为此目的，需要更严格的基础设施。</p><h2 id="60bf" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">微服务原则部署:</h2><ul class=""><li id="fb29" class="ln lo iq jp b jq nw ju nx jy pb kc pc kg pd kk ls lt lu lv bi translated"><strong class="jp ir">每个服务的独立执行</strong>以支持独立的可部署性(每个机器/容器一个实例，以防止资源稀缺或依赖性问题)</li><li id="7d8d" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><strong class="jp ir">关注自动化</strong></li><li id="2105" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><strong class="jp ir">基础设施代码</strong> (IAC):自动化应该如何完成<br/> -负责人<br/> -傀儡<br/> -主厨</li></ul><blockquote class="oi oj ok"><p id="d899" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">随着木偶的出现，首领已经改变，因为今天大多数人使用Dockerfile作为Kubernetes。Puppet、Chief主要用于遗留代码或构建容器运行的集群</p></blockquote><ul class=""><li id="872c" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><strong class="jp ir">零停机部署</strong> : <em class="oc">上游消费者</em>不应该注意到有新版本上传。即使用Kubernetes</li><li id="2151" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><strong class="jp ir">期望的状态管理</strong>:当某件事情发生时，例如一个实例死亡，我们需要3个实例，它创建新的实例<br/>——先决条件:关于正在部署的微服务的新实例的自动化</li></ul><h2 id="49ba" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">部署选项</h2><ol class=""><li id="b239" class="ln lo iq jp b jq nw ju nx jy pb kc pc kg pd kk oo lt lu lv bi translated">物理机器:在现代世界中，我们几乎从来没有自己这样做过(当然，所有这些集群都是在传统的裸机上运行的)。这里是关于部署我们的微服务)</li><li id="09a6" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">虚拟机 : AWS EC2就是一个例子。每个虚拟机都有自己的计算资源和内核。但是，要分块底层物理机器的资源，我们需要利用<strong class="jp ir">虚拟机管理程序</strong>的能力，它会自行吞噬大量资源。</li></ol><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi qx"><img src="../Images/df9f75cebfe8b024d34ddec21e5cf90b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xJvogTIwxvKC68b9kUTTRw.png"/></div></div></figure><blockquote class="oi oj ok"><p id="2309" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">Linux有许多进程:终端进程<strong class="jp ir">是所有进程的父进程，也是其他进程的子进程。因此，一个进程中的问题不会打断其他进程。</strong></p><p id="7665" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">在容器中，我们没有内核。使用底层操作系统的内核。</p></blockquote><p id="5762" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.容器:每个服务独立运行的隔离环境。但是，在某些情况下，一个容器的进程可能会与另一个容器的进程纠缠在一起→要小心。最初我们有<strong class="jp ir"> LXC </strong>集装箱，作为码头集装箱的基础。</p><p id="3906" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.<strong class="jp ir">应用容器</strong>:类似于在Tomcat中部署JVM app(需要<code class="fe pv pw px py b">.jar</code>或<code class="fe pv pw px py b">.war</code>文件)</p><h2 id="740a" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">回避servlets:</h2><ol class=""><li id="af78" class="ln lo iq jp b jq nw ju nx jy pb kc pc kg pd kk oo lt lu lv bi translated">我们的代码在服务器里面。<br/> -应用服务器:<br/> *最大:WebSphere、Weblogic <br/> *中:Wildly、Glassfish <br/> - Web服务器&amp; &amp; Servlet容器/Web容器较小:Tomcat、Jetty</li></ol><div class="ku kv gp gr kw kx"><a href="https://stackoverflow.com/a/1893261/16543524" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">Tomcat - Web服务器还是Web容器？</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">感谢贡献一个堆栈溢出的答案！请务必回答问题。提供详细信息并分享…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">stackoverflow.com</p></div></div><div class="lg l"><div class="qy l li lj lk lg ll lm kx"/></div></div></a></div><p id="d79e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Web服务器将处理请求并解析所有的cookies等。然后这个请求被路由到特定的servlet。</p><p id="a314" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">Servlet</strong>—Java类的标准，接受来自服务器的HTTP请求并给出响应。</p><div class="ku kv gp gr kw kx"><a href="https://www.educba.com/servletcontext/" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">ServletContext |如何使用ServletContext接口？|方法|常见问题</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">ServletContext是对象Servlet容器，用于与…共享初始值(数据)或配置信息</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">www.educba.com</p></div></div><div class="lg l"><div class="qz l li lj lk lg ll lm kx"/></div></div></a></div><ol class=""><li id="5790" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk oo lt lu lv bi translated">通过HTTP向服务器发出请求→ <em class="oc"> Web容器<br/> - </em> Web容器(Servlet容器)使用路由器将请求定向到其中一个Servlet<br/>-通过<code class="fe pv pw px py b">web.xml</code>或使用注释<br/>指定路由-配置信息从z转到<strong class="jp ir"> ServletContext </strong></li><li id="d5a4" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">我们在web容器中接受请求的应用程序应该有类<code class="fe pv pw px py b">Servlet</code></li><li id="93d2" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">我们的<code class="fe pv pw px py b">Servlet</code>类实现了<code class="fe pv pw px py b">HttpServlet</code>接口或其他servlet接口<br/>——这个servlet有doGet()、doPost()方法</li><li id="14eb" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">web服务器的所有特性都不是必需的，因此出现了servlet容器/Web容器(如Tomcat、Jetty)<br/>——这些Servlet容器的用途:接受HTTP请求、处理、发送给我们的代码</li></ol><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ra"><img src="../Images/c0ea4e38fcaeeaaeec3da54336e1a44e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RoKeOCCyWjzZicFyBKA84A.png"/></div></div></figure></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi rb"><img src="../Images/d6c9591eeba7f7b55cf7f9dad14f97f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wn4-0gX7sBFqmPrQTan_VQ.png"/></div></div></figure><p id="d91f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.<strong class="jp ir"> PaaS(平台即服务)</strong>:例如Heroku。它为您提供了开箱即用的基础架构，但如果出现问题或您想修复它，您无法深入了解。</p><p id="4fb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">6.<strong class="jp ir"> FaaS(功能即服务)</strong>:例如AWS Lambda。简而言之，在这项技术中，我们让代码休眠，当事件触发它时，代码会唤醒并执行任务。之后，它再次进入睡眠状态。</p><p id="fa30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些限制:限制每个<strong class="jp ir"> <em class="oc">功能</em> </strong>可以运行的时间；此提供程序不支持所有语言；<strong class="jp ir">无状态函数</strong> —表示当前调用不能访问之前的调用结果；加速旋转(对JVM应用程序来说尤其痛苦)，尽管一些服务保持运行时温暖</p><h2 id="9a3f" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">关于K8S的几句话</h2><p id="b299" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">让我们看看Kubernetes是如何设计的:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi rc"><img src="../Images/771735ed1e7cef31813e2f70088276c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GnhVOTliV3blrLapqroGdg.png"/></div></div></figure><p id="7866" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要了解更多信息，请访问:</p><ul class=""><li id="3b16" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">文件:<a class="ae lw" href="https://kubernetes.io/docs/home/" rel="noopener ugc nofollow" target="_blank">https://kubernetes.io/docs/home/</a></li><li id="1d45" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">朋友代码课程:<a class="ae lw" href="https://amigoscode.com/p/kubernetes" rel="noopener ugc nofollow" target="_blank">https://amigoscode.com/p/kubernetes</a></li></ul><p id="2ea9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">面临的挑战是，虽然Kubernetes能够很好地管理不同目的的不同微服务，但它在平台如何“T11多租户化T12”方面有局限性。组织中的不同部门可能希望对各种资源进行不同程度的控制。Kubernetes中没有内置这类控件，这一决定似乎是明智的，因为它试图限制Kubernetes的范围。</p><p id="417c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">多租户:</strong><a class="ae lw" href="https://www.cloudflare.com/learning/cloud/what-is-multitenancy/" rel="noopener ugc nofollow" target="_blank">https://www . cloud flare . com/learning/cloud/what-is-multi tenance/</a></p><blockquote class="oi oj ok"><p id="e861" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">来自RedHat docs:当提到一个<a class="ae lw" href="https://www.redhat.com/en/topics/containers/what-is-container-orchestration" rel="noopener ugc nofollow" target="_blank">容器编排</a>平台，比如<a class="ae lw" href="https://www.redhat.com/en/topics/containers/what-is-kubernetes" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>时，术语多承租通常意味着服务于多个项目的单个集群。</p></blockquote><div class="ku kv gp gr kw kx"><a href="https://www.redhat.com/en/topics/cloud-computing/what-is-multitenancy" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">什么是多租户？</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">多租户是一种软件架构，其中单个软件实例可以服务于多个不同的用户组…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">www.redhat.com</p></div></div><div class="lg l"><div class="rd l li lj lk lg ll lm kx"/></div></div></a></div><p id="aa5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有两个选项:</p><ul class=""><li id="2ceb" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><strong class="jp ir">基于K8S </strong>构建的独立解决方案:<em class="oc"> Openshift </em>。它为您提供了多租户的所有优势。</li><li id="c843" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><strong class="jp ir">联邦模式</strong>。看图而不是百万字:</li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi re"><img src="../Images/d9bc199b3cfd8a0eead04ad12465c878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*37luS7feITMu2G7ZDz9EjQ.png"/></div></div></figure><p id="f615" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，通过联盟，我们可以将空闲资源(如<code class="fe pv pw px py b">Empty node</code>)从<em class="oc">集群B </em>移动到<em class="oc">集群A </em>。</p><blockquote class="oi oj ok"><p id="ce3e" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated"><strong class="jp ir"> CNCF </strong> —云原生计算基金会。它类似于Apache，但在这里属于云的范畴。</p></blockquote><h2 id="9099" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">渐进式交货</h2><p id="b471" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">根据《持续交付》的作者Jez Humble的说法:</p><blockquote class="oi oj ok"><p id="2199" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated"><strong class="jp ir">部署</strong>是指将软件的某个版本安装到特定的环境中(通常指生产环境)。<strong class="jp ir">发布</strong>是当你向用户提供一个系统或者它的一部分(例如，一个特性)的时候。</p></blockquote><ul class=""><li id="bc51" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><strong class="jp ir">蓝绿调配</strong>:蓝色是老服务，绿色是新服务。如果新版本没问题，您可以将客户从旧版本重定向到新版本</li><li id="4952" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">功能切换(标志):我们可以打开/关闭服务中的某些功能</li><li id="522a" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><strong class="jp ir">金丝雀释放</strong>:一部分流量给老服务，另一部分给新服务</li><li id="1ba7" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><strong class="jp ir">并行运行</strong>:两个服务存在/在一个微服务/不同的服务中。但关键是请求应该由双方来处理</li></ul><h1 id="cc85" class="my mz iq bd na nb od nd ne nf oe nh ni nj of nl nm nn og np nq nr oh nt nu nv bi translated">测试</h1><p id="e2ce" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">关于测试可以说很多，但是测试中最流行的层是:</p><ul class=""><li id="17d3" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">单元测试</li><li id="7ba3" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">服务测试(我们测试一个服务，模拟所有相邻的服务)</li><li id="303b" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">端到端测试——又名集成测试</li></ul><blockquote class="oi oj ok"><p id="f425" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">坚持<strong class="jp ir">独立测试性</strong>，每个团队都有自己的测试环境</p></blockquote><h2 id="cd28" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">契约测试和消费者驱动的契约</h2><p id="43de" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated"><strong class="jp ir">契约测试</strong>是一种测试，其中你检查的不是你的服务，而是生产方的行为。它通常是针对模拟生产服务的。它是消费者(上游)和生产者(下游)服务对彼此行为预期的编程表示。</p><p id="2432" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些<strong class="jp ir">契约测试</strong>作为<strong class="jp ir">消费者驱动契约(CDC)</strong>的一部分非常有用。CDC推动了服务之间更好的沟通，并确保每个相邻的团队都知道如何与您的服务沟通以及会发生什么。</p><p id="55a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常这样的测试在构建期间运行，以确保一切正常。有时这种测试会取代<em class="oc">端到端测试</em>。</p><h2 id="8736" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">生产中测试</h2><p id="e47c" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">生产过程中的测试也是一种很好的方法，应该被视为一种选择。因为<strong class="jp ir">前期制作</strong>不能捕捉所有的bug，实际上也不应该这么做。它的任务是将问题最小化。</p><ul class=""><li id="4dd2" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">冒烟测试:在真实软件发布之前运行(在部署期间)</li><li id="521c" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">金丝雀释放</li><li id="7857" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">假冒用户</li></ul><h2 id="45fd" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated"><strong class="ak"> MTBF vs MTTR </strong></h2><p id="f47a" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated"><strong class="jp ir"> MTBF </strong> —平均无故障时间。<strong class="jp ir"> MTTR </strong> —平均重构时间。</p><p id="cbd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有时，如果系统不严重，最好允许它失败。</p><h2 id="c8c0" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">非功能需求</h2><p id="4071" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">总是考虑功能性需求和非功能性需求。</p><blockquote class="oi oj ok"><p id="41fd" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated"><strong class="jp ir">非功能</strong>也称为<strong class="jp ir">跨功能需求</strong> (CFR)</p></blockquote><p id="cb2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CFR表格SLOs服务水平目标。我们将在<strong class="jp ir">中探讨从监控到可观察性的SLO。</strong></p><h2 id="85bc" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">此外…</h2><ul class=""><li id="989f" class="ln lo iq jp b jq nw ju nx jy pb kc pc kg pd kk ls lt lu lv bi translated"><strong class="jp ir">性能测试</strong> : <br/> -增加负载以观察<em class="oc">延迟</em> <br/>的变化-观察新增功能后的变化:帮助捕捉性能问题<br/> -也可以按单元、服务、端到端分类</li><li id="ae15" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">鲁棒性测试以捕捉弱点/集成，并使用<em class="oc">断路器</em></li></ul><h1 id="e04f" class="my mz iq bd na nb od nd ne nf oe nh ni nj of nl nm nn og np nq nr oh nt nu nv bi translated">从监控到可观察</h1><p id="5618" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">在MSA中，我们可以运行一个微服务的多个实例。这发生在客户端和服务器端。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi rf"><img src="../Images/237556b57afd41c2964eff7b8ce3c09e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TnRKyDX9Ohs-18sA1lqLcA.png"/></div></div></figure><p id="1275" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，筛选日志是非常困难和痛苦的。</p><p id="34a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">可观性</strong> —通过外部输出发现系统内部状态的行为。你更全面地看待这个系统，而不是孤立的实体。</p><p id="e365" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="oc">监控</em>上，你知道系统可能会在哪里出错。有了<em class="oc">可观察性</em>你就有能力<strong class="jp ir">询问</strong>系统。</p><h2 id="2ca6" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">使系统更易观察的技术</h2><ul class=""><li id="ef10" class="ln lo iq jp b jq nw ju nx jy pb kc pc kg pd kk ls lt lu lv bi translated">日志聚合</li><li id="76b2" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">度量聚合</li><li id="5910" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">分布式跟踪</li></ul><h2 id="5dc9" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">日志</h2><p id="78c2" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">我们可以以这样的方式进行日志聚合，即我们的应用程序将日志写入文件系统，本地守护进程获取它们并将其提供给日志聚合工具。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi rg"><img src="../Images/2bedc1f7b6f6aa8191616bbefb001c4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LId_c7jJbxr4Tl7tQjklSQ.png"/></div></div></figure><p id="4c2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实施日志时，请考虑:</p><ul class=""><li id="8b63" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><strong class="jp ir">关联id</strong>跟踪多个</li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi rh"><img src="../Images/3103b8c05111fe8b83066e8c60721432.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TWZKQHvTz8r3lgh-l0P1MA.png"/></div></div></figure><ul class=""><li id="37d2" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><strong class="jp ir">计时</strong>:即使是NTP(网络时间协议)也不能保证我们调用的顺序，依赖简单的<code class="fe pv pw px py b">time()</code>是不好的——分布式机器可能会有不同的日志等等。更好的方法:<strong class="jp ir">分布式跟踪工具</strong></li></ul><p id="d0cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">日志记录工具:用于发送日志的工具是Fluentbit/Fluentd。对于切片日志:Elasticsearch/Kibana</p><h2 id="23ee" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">韵律学</h2><p id="fb03" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">度量允许我们长时间地观察系统的健康状况，并回答诸如“负载增加20%是不好的还是正常的？；每分钟4XX/5XX码的量是正常的还是超出范围的？”等等。</p><ul class=""><li id="0bf9" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">指标允许我们根据需要为新主机制定<strong class="jp ir">容量规划</strong></li><li id="1063" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">高基数对低基数:如果放入高基数数据，像Prometheus这样为低基数构建的系统将会受到影响。此外，它会消耗更多的数据</li></ul><blockquote class="oi oj ok"><p id="7f42" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">这里有一些描述基数的方法，但是你可以把它想象成在一个给定的数据点中可以被容易地查询的字段的数量。我们可能想要查询的潜在字段越多，我们需要支持的基数就越高。</p></blockquote><div class="ku kv gp gr kw kx"><a href="https://newrelic.com/blog/best-practices/why-observability-requires-high-cardinality-data" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">为什么可观察性需要高基数数据</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">通常由维度度量数据表示的低基数数据有局限性。指标采用的功能包括…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">newrelic.com</p></div></div><div class="lg l"><div class="ri l li lj lk lg ll lm kx"/></div></div></a></div><h2 id="0d4a" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">分布式跟踪</h2><p id="da78" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">通过跟踪，我们为每个集成/系统捕获所谓的<em class="oc">跨度</em>，并用唯一标识符标记它们。然后它被送到中央收集器，在那里它被收集成一个<em class="oc">单条轨迹</em>。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi rj"><img src="../Images/13045ab90708287e98e7ae2e76fa1549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QH9m2ifDLxw10NLk7eITQg.png"/></div></div></figure><h2 id="4f9a" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">服务水平协议、SLO、SLI等</h2><p id="060b" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">想想系统的健康状况:如果一个<em class="oc">微服务</em>死了，其他的呢？如果别人还好，在服务范围内一切都好。</p><p id="86d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，在<strong class="jp ir"> SRE </strong>的范围内有一些方法需要记住:</p><ul class=""><li id="3741" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><strong class="jp ir"> SLA </strong>:用户和服务之间的协议。它适用于组织(给定实例90%的正常运行时间)</li><li id="c043" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><strong class="jp ir"> SLOs </strong>:服务的每个团队的协议，将构成SLA</li><li id="7b2c" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><strong class="jp ir"> SLIs </strong>:测量我们软件的数据(用于评估SLO)。即<em class="oc">响应时间</em>，发出订单</li><li id="31a4" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><strong class="jp ir">误差预算</strong>:达到当前SLO的评估方式。例如，如果我们目前已经达到了本季度的SLI误差，那么也许我们不需要冒险和推迟它。</li></ul><blockquote class="oi oj ok"><p id="03d2" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">不要给太多的<strong class="jp ir"> <em class="iq">警示</em> </strong>因为会混淆</p></blockquote><p id="2f59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">语义监控</strong>:对于系统来说，什么是可以接受的(比如一天卖2万美元等):</p><ul class=""><li id="2b9b" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">不仅仅是有没有问题，而是:我们的系统是否在可接受的范围内运行？从中我们可以区分所有事情的轻重缓急</li></ul><p id="4bd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也就是说，也许我们的系统工作正常，没有错误，但是它可能太慢或者对用户不友好→用户不继续</p><p id="db3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">生产测试</strong>是另一种形式的监控:</p><ul class=""><li id="ad69" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">合成交易(注入虚假事件/用户)</li><li id="ba9e" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">A/B测试</li><li id="936a" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">混沌工程</li><li id="422b" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">烟雾测试</li><li id="cb84" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">并行运行</li><li id="2f3d" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">金丝雀释放</li></ul><h2 id="2ca8" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">关于可观察性的更多信息</h2><p id="3721" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated"><strong class="jp ir">标准化</strong>对于有很多微服务的系统很重要。例如:相同的度量名称</p><p id="1554" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，提供背景:</p><ul class=""><li id="e0e7" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><em class="oc">时间上下文</em>:相对于小时、分钟等</li><li id="5541" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><em class="oc">相对语境</em>:这个<em class="oc">相对于系统中的另一个事物</em>如何变化</li><li id="4214" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><em class="oc">关系</em>:系统中的其他东西依赖于此吗</li><li id="f568" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><em class="oc">比例</em>:这个数字有多差？范围是什么？</li></ul><h2 id="12a7" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">再多一点点…</h2><p id="5154" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">首先，您希望能够捕获运行微服务的主机的基本信息— CPU速率、I/O等—并确保您可以将微服务实例与运行它的主机匹配起来。对于每个微服务实例，您希望捕获其服务接口的响应时间，并在日志中记录所有下游调用。从一开始就将关联id放入日志中。记录业务流程中的其他主要步骤。这将要求您至少有一个基本的度量和日志聚合工具链。</p><h1 id="933a" class="my mz iq bd na nb od nd ne nf oe nh ni nj of nl nm nn og np nq nr oh nt nu nv bi translated">安全性</h1><h2 id="70ab" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">免责声明:这一章和主题对我来说是最难的，因此如果你感兴趣的话，一定要多读一些。</h2><p id="eae0" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated"><strong class="jp ir">核心原则:</strong></p><ul class=""><li id="bd49" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><em class="oc">最小特权原则</em>:如果您授权访问的微服务是只读的，或者凭证在一定时间后过期→更好的选择</li><li id="4405" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><em class="oc">纵深防御</em>:多层次+多类型(预防性、检测性、响应性)</li><li id="e260" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><em class="oc">在CI中实现自动化工具(</em> <strong class="jp ir"> <em class="oc">)从构建段</em> </strong> <em class="oc"> ) </em>:即Snyk</li></ul><div class="ku kv gp gr kw kx"><a href="https://snyk.io/" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">Snyk |开发者安全|快速开发。保持安全。</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">查找并自动修复您的代码、开源依赖项、容器和基础设施中的漏洞，因为…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">snyk.io</p></div></div><div class="lg l"><div class="rk l li lj lk lg ll lm kx"/></div></div></a></div><p id="2536" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="oc">网络安全的五大功能:</em> </strong></p><ol class=""><li id="91f4" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk oo lt lu lv bi translated">识别:谁是攻击者，他们可以攻击哪些部分</li><li id="dac2" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">保护</li><li id="62e6" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">检测事件(即检测入侵的水)</li><li id="c59e" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">回应:如果事故已经发生，我们如何解决+我们需要采取什么行动来通知，即系统的用户</li><li id="5765" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">恢复</li></ol><h2 id="ec28" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">应用安全的基础:</h2><p id="9fa8" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">MSA背景下的关键主题:构建更安全的系统。</p><ol class=""><li id="3fb8" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk oo lt lu lv bi translated"><strong class="jp ir">凭证</strong></li></ol><ul class=""><li id="115c" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><em class="oc">用户凭证</em>:即访问AWS</li><li id="9b08" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><em class="oc"> secrets </em>(针对要运行的微服务):TLS的证书、SSH密钥、公共/私有API密钥对、db的creds。各种安全需求:<strong class="jp ir">创建</strong>，<strong class="jp ir">分发</strong>(秘密到达正确的地方)<strong class="jp ir">存储</strong>，<strong class="jp ir">监控</strong>(知道这个秘密是如何被使用的)<strong class="jp ir">轮换</strong> <br/> - <strong class="jp ir">凭证随时间轮换</strong>:从文件中或在运行中生成<br/> - <strong class="jp ir">如果被盗则撤销</strong></li></ul><p id="249c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于以上内容:<em class="oc"> Kubernetes </em>有内置的解决方案。但是更好的选择:<strong class="jp ir">金库</strong></p><div class="ku kv gp gr kw kx"><a href="https://www.vaultproject.io/" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">哈希公司跳马</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">自我管理|始终免费下载开源Vault二进制文件，并在本地或您的环境中运行。管理…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">www.vaultproject.io</p></div></div><div class="lg l"><div class="rl l li lj lk lg ll lm kx"/></div></div></a></div><ul class=""><li id="b71c" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><strong class="jp ir">限制秘密的范围</strong>其中每个服务都有自己的一组秘密</li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi rm"><img src="../Images/8e8df35cb76196e48a2b6be3b964f088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MyaXpQmmyYwwoI1_63PijA.png"/></div></div></figure><p id="2bf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<strong class="jp ir">打补丁</strong>让你的系统保持最新，防止漏洞</p><p id="c068" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最好不要处理所有可能的修补范围，将部分工作交给<strong class="jp ir"> K8S </strong>:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi rn"><img src="../Images/81c31d33ce893afc39e3658f0139ade1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5aCdtCxoiYM7KblQh34VCw.png"/></div></div></figure><p id="52bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样<strong class="jp ir"> Aqua </strong>有助于分析漏洞</p><div class="ku kv gp gr kw kx"><a href="https://www.aquasec.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">Aqua Cloud本机安全性、容器安全性和无服务器安全性</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">GitLab使用Aqua Trivy为客户提供默认的DevSecOps容器安全性GitLab的使命是提供…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">www.aquasec.com</p></div></div><div class="lg l"><div class="ro l li lj lk lg ll lm kx"/></div></div></a></div><p id="063a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">为什么SAST不再是一个选项:</strong></p><div class="ku kv gp gr kw kx"><a href="https://www.aquasec.com/cloud-native-academy/supply-chain-security/sast-security/" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">SAST安全:SAST仍然与现代应用相关吗？</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">静态应用程序安全测试(SAST)是一个代码测试工具，它分析应用程序源代码以识别…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">www.aquasec.com</p></div></div><div class="lg l"><div class="rp l li lj lk lg ll lm kx"/></div></div></a></div><p id="eb3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.<strong class="jp ir">备份</strong></p><ul class=""><li id="e86a" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">备份最重要的东西:日志，数据库等</li></ul><p id="5e0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.<strong class="jp ir">重建</strong></p><ul class=""><li id="95ed" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">不时地重建容器(当然还有轮换秘密)。否则你会惊讶地发现有人通过<strong class="jp ir"> rootkit </strong>获得了访问权限</li><li id="d1ad" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">还会不时地旋转新集群</li></ul><h2 id="329b" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated"><strong class="ak">隐性信任对零信任</strong></h2><p id="f22b" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated"><em class="oc">首先</em>是我们相信所有人<em class="oc">其次</em>是我们不相信任何人</p><p id="e906" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下图中，我们需要将服务部署到不同的区域:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi rq"><img src="../Images/55d7f6a43a4eea12a9072c0414d70548.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3RkSCdNjyDxRF0TiZweiPQ.png"/></div></div></figure><p id="8d3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以访问公共数据的微服务使用<strong class="jp ir">隐式信任</strong>，而私有和安全数据由另外两个微服务使用<strong class="jp ir">零信任方法</strong>。其次，下层服务使用上层服务，而不是相反。</p><h2 id="0454" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">保护数据</h2><p id="b893" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">每种交流方式都有其独特之处。即HTTP有TLS。但是如果你使用经纪人，那么你可能需要调查一下他们是怎么做的。</p><p id="f181" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">在途数据</strong></p><p id="e711" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们看看图片，然后看看核心要点:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi rr"><img src="../Images/ef41e9a0d1e3c18e67f57546c93f56eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nM4hsTfI8EjccqDOE4ZoPg.png"/></div></div></figure><ol class=""><li id="80c7" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk oo lt lu lv bi translated"><strong class="jp ir">服务器身份</strong>:我们与真实的服务器通信，而不是模拟的服务器:<br/>——一些<em class="oc">通信协议</em>在幕后使用HTTP，如SOAP/gRPC，可以利用HTTPS</li><li id="35c4" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated"><strong class="jp ir">客户身份</strong>:微服务调用我们(上游服务)。使用共享秘密或客户端证书<br/>——通常我们会进行某种<em class="oc">相互认证</em> ( <strong class="jp ir"> mTLS </strong>)来验证服务器身份<br/> - <em class="oc">相互认证</em>可以通过<strong class="jp ir">保险库</strong>或<strong class="jp ir">服务网格</strong>来完成</li><li id="01b9" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated"><strong class="jp ir">数据可见性</strong>:已经在HTTPS完成<br/>—HTTPS响应无法缓存。所以，没有鱿鱼或清漆</li><li id="d16c" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">数据操作:它能通过网络改变吗<br/> -使用HTTPS数据是不可见的<br/> -使用HTTP我们可以使用HMAC(基于散列的消息认证)</li></ol><p id="5e72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">静态数据</strong></p><ol class=""><li id="b6ad" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk oo lt lu lv bi translated">经常使用现有的库来散列密码和修补库(加盐密码散列)</li></ol><div class="ku kv gp gr kw kx"><a href="https://crackstation.net/hashing-security.htm#properhashing" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">安全加盐密码散列法——如何正确使用</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">在用户的哈希列表中搜索哈希(apple)...:匹配[alice3，0bob0，charles8]在…中搜索哈希(蓝莓)</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">crackstation.net</p></div></div></div></a></div><p id="2a73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.只存储您需要的信息。从磁盘的角度来看，它更安全、更便宜。例如，您将一些数据放在日志中，理想情况下您需要加密它们，但是这需要空间</p><p id="9034" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.存储加密密钥<strong class="jp ir">不在同一个数据库</strong>中。例如，使用单独的密钥保险库，即保险库。或者使用另一个设备来加密和解密数据。</p><h2 id="3201" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated"><strong class="ak">认证和授权</strong></h2><p id="8337" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated"><em class="oc">原</em>是在系统中识别用户。<em class="oc">后者</em>是允许委托人做出他们被允许的动作。</p><h2 id="0565" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">单点登录（single sign-on的缩写）</h2><p id="ad17" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated"><strong class="jp ir">单点登录</strong> —使用户只需认证一个用户即可访问各种服务的方式。例如，在谷歌产品中，你只需登录一次，就可以访问谷歌日历、Gmail等。</p><p id="4378" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常是通过<strong class="jp ir">身份提供者</strong>或者简称<strong class="jp ir"> IdP </strong>来完成，IdP要求登录和密码，甚至<strong class="jp ir"> MFA </strong>(多因素认证)。IdP可以是外部服务，如<em class="oc"> OpenID Connect </em>或组织内的系统。</p><p id="5f8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现方式:要么强制每个服务调用IdP，要么使用某个<strong class="jp ir">网关</strong>作为外部世界和您的服务之间的代理。因此，我们的单点登录网关会自动将每个请求重定向到IdP。</p><p id="a807" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题:</strong>下游服务如何知道主体的信息？</p><p id="afbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一种方法:如果使用HTTP，那么填充头</p><p id="060d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二种方法:使用JWT</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi rs"><img src="../Images/f2499afd32a7285887d04583a6cf9d71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X1KKo-gRzEUjrcF9DKpdTQ.png"/></div></div></figure><h2 id="3abc" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated"><strong class="ak">困惑的副手问题</strong></h2><p id="3401" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">上游方哄骗中介方做不该做的事。</p><p id="9822" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果隐性信任——我们可能会接受。但是它不安全=&gt; <strong class="jp ir">认证</strong>，但是它没有提供足够的<strong class="jp ir">授权→ </strong>用户A的信息必须只能被用户A看到，而不能被其他人看到。</p><p id="f09a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解决方案:</strong></p><p id="86d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">基于隐性信任:</strong></p><ul class=""><li id="644c" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">在网关中提供所有授权。所有下游服务仍然具有隐式信任</li><li id="f12c" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">让网关知道哪个微服务具有什么功能</li></ul><p id="9925" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但这意味着我们不只是部署微服务，而是将授权相关的配置应用到上游网关(因为每个请求最初都访问这个网关代理)。→违反了<strong class="jp ir">独立部署</strong>原则。</p><p id="eccb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更好的选择——分散授权。有许多选项，但最常用的是JWT</p><p id="acc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">格式:</p><pre class="md me mf mg gt rt py ru bn rv rw bi"><span id="ae20" class="rx mz iq py b be ry rz l sa sb"> {<br/>   "sub": "545",<br/>   "name": "Random Name",<br/>   "exp": 53555444,<br/>   "groups": "admin, beta"<br/>}</span></pre><p id="c76b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编码后:</p><pre class="md me mf mg gt rt py ru bn rv rw bi"><span id="ae5b" class="rx mz iq py b be ry rz l sa sb">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.<br/> eyJzdWIiOiIxMjMiLCJuYW1lIjoiU2FtIE5ld21hbiIsImV4cCI6MTYwNjc0MTczNiwiZ3J... .<br/> Z9HMH0DGs60I0P5bVVSFixeDxJjGovQEtlNUi__iE_0</span></pre><p id="c7d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它可以在HTTP授权头中传递，也可以作为消息中的元数据传递。此外，它可以通过加密传输协议，如HTTPS。</p><p id="205c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一下实现:</p><ul class=""><li id="b959" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">OAuth令牌保存在客户端设备上，以允许登录会话</li><li id="3015" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">下游服务验证这个令牌，并确定哪种类型的授权是合适的。关于验证:验证需要一些公钥。受赞扬的保险库可以做到这一点，而不是在配置文件中硬编码公钥</li><li id="fc96" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">通常，JWT是基于每个请求生成的</li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi sc"><img src="../Images/da4a78342e935e089238e7e06f8ad55a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jiV0vmzFD1A2kyJk953WiA.png"/></div></div></figure><p id="e91e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">唷，太多了。让我们继续讨论几个话题</p><h1 id="322d" class="my mz iq bd na nb od nd ne nf oe nh ni nj of nl nm nn og np nq nr oh nt nu nv bi translated">跳回</h1><p id="3acf" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">这是一个过度的术语，包括:</p><ul class=""><li id="7759" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><em class="oc">鲁棒性</em>:吸收预期扰动的能力</li><li id="feea" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><em class="oc">反弹</em>:恢复能力</li><li id="471e" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><em class="oc">优雅的扩展性</em>:应对突发情况的能力</li><li id="9b5b" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><em class="oc">持续的适应性</em>:适应不断变化的环境、利益相关者和需求的能力</li></ul><blockquote class="oi oj ok"><p id="1756" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">许多组织将流程和控制放在适当的位置<strong class="jp ir">试图阻止故障</strong>的发生，但是很少或者根本没有考虑实际上使<strong class="jp ir">更容易从故障</strong>中恢复。</p></blockquote><p id="f16e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">构建系统时要问的问题</strong>。它们有助于形成SLO:</p><ul class=""><li id="ba0e" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">响应时间/延迟</li><li id="0197" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">有效性</li><li id="cbb0" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">数据的持久性:丢失是否可以接受，数据应该保留多长时间</li></ul><div class="ku kv gp gr kw kx"><a href="https://docs.aws.amazon.com/whitepapers/latest/availability-and-beyond-improving-resilience/distributed-system-availability.html" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">分布式系统可用性</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">分布式系统由软件组件和硬件组件组成。一些软件组件…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">docs.aws.amazon.com</p></div></div></div></a></div><h2 id="8e9a" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">降低功能</h2><ul class=""><li id="6cb9" class="ln lo iq jp b jq nw ju nx jy pb kc pc kg pd kk ls lt lu lv bi translated">问自己一个问题:如果这个服务关闭了怎么办？这被称为<strong class="jp ir">功能退化</strong></li><li id="dd5e" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">在<strong class="jp ir">单片应用</strong>中，系统健康是二进制的:向上或向下。在微服务中，我们需要从业务角度出发<em class="oc"/>:如果这是关闭的，我们应该显示这个页面/图标/电话吗？</li></ul><h2 id="b2cd" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">稳定性模式</h2><p id="cb0d" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">扼杀者无花果图案</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi sd"><img src="../Images/dc7fa0159550f21369b27dd26ed492dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U2vVyVwDJUwTDejFtpP3Sw.png"/></div></div></figure><p id="e8aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种模式本身如何导致问题的真实案例:</p><p id="47a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图像您的服务使用HTTP连接池库来处理到下游服务的所有连接。该池中的线程数量是有限的。新的请求进入池中，要求更多的工作线程。如果没有可用的工人-请求挂起。尽管线程池中的线程有等待响应的超时，但上面提到的HTTP库可能有默认禁用的工作线程的<strong class="jp ir">超时</strong>。</p><p id="ea12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，你可能有一个下游服务不可用，虽然工人有超时，图书馆没有关闭工人自己的超时。因此，对于许多请求，会有越来越多的阻塞线程等待响应。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi se"><img src="../Images/12c1509f15d3df0f88db66c8b45d0af3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5M5cdggV6_NnmtuDpzlJng.png"/></div></div></figure><p id="ed72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解决此类问题的方法:</strong></p><ol class=""><li id="c156" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk oo lt lu lv bi translated">暂停</li></ol><ul class=""><li id="9bd2" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">从系统到池中的线程</li><li id="533a" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">对于被worker <br/>调用的下游服务<strong class="jp ir"> PS:不要只考虑单个超时，要考虑整个流程(请求多个下游服务)。如果它已经超过了限制，那么中止调用。</strong></li><li id="3ef6" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><strong class="jp ir">重试</strong>是有用的，但是回忆一下上面关于总超时的超时内容:如果它已经越过了某个限制——中止并且不要再进行另一次<strong class="jp ir">重试</strong></li></ul><p id="6895" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.隔板:即使一部分损坏，也能使你的系统继续运行的东西。</p><ul class=""><li id="0f47" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">例如，为每个下游服务使用单独的连接池。它被称为<strong class="jp ir">关注点分离</strong>。因此，将您的系统/功能分解成独立的微服务</li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi sf"><img src="../Images/c2e1ab99425c915068c5686dd3d2c37f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R2NHQ73n5YqnFBCO7NqM3g.png"/></div></div></figure><p id="00b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">超时和<strong class="jp ir">断路器</strong>允许释放资源，但隔板首先会阻止这种情况。此外，它们允许<strong class="jp ir">减载</strong>，这意味着你可以拒绝请求。因此，通过应用负载削减，我们可以防止我们的系统被传入的请求淹没。</p><ul class=""><li id="cdb7" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><strong class="jp ir">断路器</strong>:允许阻止对下游系统的请求(p 402)。所以，它<strong class="jp ir">密封舱壁</strong>。经过一段时间后，如果健康检查响应发送OK，那么我们关闭断路器。它允许我们的服务快速失败，并且不会损失宝贵的资源。</li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi sg"><img src="../Images/fdc6957933890b594bcf4beb0dcea64c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hpZJQyZWHESSRQ9eqhHVqQ.png"/></div></div></figure><p id="76ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实施<strong class="jp ir">断路器</strong>的步骤:</p><ul class=""><li id="3d7a" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">定义什么是失败:即5XX响应代码</li><li id="6618" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">断路器熔断时:<br/> -某队列中的队列请求:用于<em class="oc">异步请求</em> <br/> -如果<em class="oc">同步请求</em>则快速返回失败</li></ul><p id="208e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从商业角度看是什么样子。如果我们定义有断路器激活→在站点上显示该服务不可用。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi sh"><img src="../Images/09a68bfb37ebaea2f857139b33e5a4b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1OOoFRW9W9sxK3r-I_OcKw.png"/></div></div></figure><p id="b254" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将手动打开和关闭<em class="oc">断路器</em>的过程编写为自动化部署过程的一部分可能是明智的下一步。</p><h2 id="d8ba" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">微服务的隔离</h2><ul class=""><li id="61af" class="ln lo iq jp b jq nw ju nx jy pb kc pc kg pd kk ls lt lu lv bi translated">即使逻辑上微服务是独立的，它们仍然可以作为主机<strong class="jp ir">依赖于一个系统基础设施</strong>。一个服务可以开始使用所有的CPU。或者两者都使用相同的数据库基础设施→容器允许解决这个问题。所以，我们在不同的机器上托管它们。但是单独的基础设施会导致更多的过载。</li><li id="3d55" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">即使我们使用一些中间件来分离系统，即代理，也会增加复杂性</li></ul><p id="3dd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="oc">隔离</em>可以增加<strong class="jp ir">鲁棒性</strong>，但是从以上几点我们可以看出，事情并没有那么简单。</p><h2 id="658b" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">向侧面的</h2><p id="2c03" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated"><strong class="jp ir">冗余</strong> —拥有某些服务的多个副本以提高<strong class="jp ir">负载</strong>和<strong class="jp ir">健壮性</strong>的技术。许多服务，如AWS，在它们的SLA中有这种固有的东西。</p><p id="dd3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">中间件</strong> —分离服务的软件。即多个服务之间的代理，它将请求保存在其中，直到我们的下游服务再次可用。另外，如果下游服务不可用，代理可以返回缓存的数据。</p><h2 id="0e2f" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">幂等性</h2><p id="25ab" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated"><strong class="jp ir">等幂运算</strong> —即使发生多次，结果也不会改变的运算。当我们的服务的多个实例被订阅到一个主题时，这对代理很有帮助。否则，当多个工作人员处理相同的消息时，您可能会陷入困境。</p><h2 id="be64" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">CAP定理</h2><p id="6a98" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">CAP —一致性、可用性、分区容差</p><p id="ad6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">一致性</strong>是我们去多个节点都会得到相同答案的系统特性。<strong class="jp ir">可用性</strong>意味着每个请求都会得到响应。<strong class="jp ir">分区容忍度</strong>是系统处理其部件之间有时无法通信的能力。</p><p id="5e5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的分布式系统中不可能有三个字母。让我们调查一下原因:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi si"><img src="../Images/3180592ee7581bdd5660ef7543b4730a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bLZeU2ouJithHt8T2c1Gyw.png"/></div></div></figure><p id="d5af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果一个微服务被部署到2个DC，其中的数据库之间的同步链接由于网络问题而中断→ <strong class="jp ir"> AP </strong>,因为我们牺牲了<em class="oc">强一致性</em>来换取<em class="oc">最终一致性</em>。</p><p id="be80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们在系统恢复之前不接受请求，以确保强一致性→ <strong class="jp ir"> CP </strong>。找出降低功能的方法</p><blockquote class="oi oj ok"><p id="e11f" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">获得正确的<strong class="jp ir">多节点一致性</strong>非常困难，强烈建议如果你需要，不要试图自己发明它。相反，选择一个提供这些特征的数据存储或锁定服务。例如，Consul是一个严格一致的键值存储。</p></blockquote><p id="638a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> CA </strong>？→不！如果我们的系统没有分区容忍度，那么我们就不能在网络上运行它。换句话说，它需要是在本地运行的单个进程。分布式系统中不存在CA 系统。分布式系统需要知道如何处理故障，并且预计会出现故障。</p><p id="8c44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在现实世界中，情况要微妙得多，我们可以不时地让我们的系统成为Ap或CP。卡珊德拉允许我们实现它。</p><h2 id="e02a" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">关于这个话题的更多信息</h2><p id="1985" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">混沌工程:故意让我们的系统看不到后果:</p><div class="ku kv gp gr kw kx"><a href="https://netflixtechblog.com/tagged/chaos-engineering" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">混沌工程-网飞科技博客</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">阅读网飞科技博客中关于混沌工程的文章。了解网飞世界一流的工程成果…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">netflixtechblog.com</p></div></div><div class="lg l"><div class="sj l li lj lk lg ll lm kx"/></div></div></a></div><p id="ce55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">混沌工具包:</p><div class="ku kv gp gr kw kx"><a href="https://chaostoolkit.org/" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">开发人员的混沌工程工具包</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">混沌工具包</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">chaostoolkit.org</p></div></div><div class="lg l"><div class="sk l li lj lk lg ll lm kx"/></div></div></a></div><p id="a4d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，<strong class="jp ir">关键稳定性模式</strong>像<em class="oc">断路器</em>、<em class="oc">超时</em>、<em class="oc">冗余</em>、<em class="oc">隔离</em>、<em class="oc">幂等</em>都是开放的，应该用来构建弹性软件。</p><h1 id="913b" class="my mz iq bd na nb od nd ne nf oe nh ni nj of nl nm nn og np nq nr oh nt nu nv bi translated">缩放比例</h1><p id="4f1f" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">结垢有两个主要原因:</p><ul class=""><li id="dac0" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">更好的性能(通过改善延迟或负载处理)</li><li id="ffe3" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">更强的鲁棒性</li></ul><p id="62b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缩放轴:</strong></p><ul class=""><li id="b291" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><em class="oc">垂直缩放</em></li><li id="6bc4" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><em class="oc">水平缩放</em></li><li id="3087" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><em class="oc">数据分区</em></li><li id="4950" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated"><em class="oc">功能分解</em>:基于类型的工作分离，例如微服务分解</li></ul><p id="eccc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">垂直缩放</strong></p><p id="f555" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在主要有2种选择/情况:<em class="oc">裸机</em>和<em class="oc">云</em> (VMs)。</p><p id="fe8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果很容易做到(例如。你在虚拟机上)，那么如果它能快速解决问题，为什么不呢？如果你使用像AWS这样的云，你甚至可以短期租用一些机器。</p><p id="82ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">主要优势:</strong></p><ol class=""><li id="9c2d" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk oo lt lu lv bi translated">同样值得注意的是<strong class="jp ir">垂直缩放</strong>可以更容易地执行其他类型的缩放。作为一个具体的例子，将您的数据库基础设施迁移到一台更大的机器上，可以让它为新创建的微服务托管逻辑隔离的数据库，作为<strong class="jp ir">功能分解</strong>的一部分</li><li id="353e" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">快的</li><li id="c8f5" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">在大多数情况下，除了一些标志值之外，不需要更改应用程序</li></ol><p id="8eba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">限制:</strong></p><ol class=""><li id="1e80" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk oo lt lu lv bi translated">一台大机器不会增加<strong class="jp ir">的健壮性</strong></li><li id="0926" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated"><strong class="jp ir"> CPU </strong>不会变快，但<strong class="jp ir">内核数量</strong>会变快。更改代码以利用多核硬件可能是一项重大任务，需要彻底改变编程习惯</li></ol><p id="109e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">水平缩放</strong></p><p id="b163" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只是增加机器的数量。</p><ul class=""><li id="3d46" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">例如，<em class="oc">负载平衡器</em>将流量重定向到同一个微服务的多个实例</li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi sl"><img src="../Images/5445e04207fcf50380eccc7b171c3a35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4zAcYMFZcsVfAv2m1qGu7Q.png"/></div></div></figure><ul class=""><li id="ecc6" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><strong class="jp ir">竞争消费者模式</strong>:增加从队列中读取(也称为竞争)作业的消费者(实例)数量。因此，每个实例都会竞争队列中的作业。</li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi sm"><img src="../Images/5397996ca3e7fd2d79e0e5035e78e492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dUeDmDPtLrIQazCCtVPRZQ.png"/></div></div></figure><ul class=""><li id="7583" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">使用读取副本来减少主数据库的负载(主数据库处理<strong class="jp ir">写入</strong></li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi sn"><img src="../Images/fd01df8d2a0809ed2ff8ea414f7632de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oIUChslwLBmIyTgTcKHxGw.png"/></div></div></figure><p id="03bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另外，我们可以使用<em class="oc">负载平衡器</em>，它将接受对<em class="oc">读取</em>的请求，然后将它们分散到多个<em class="oc">读取副本</em>上。模式:负载平衡器将读取分散到多个读取副本。</p><p id="d1d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">主要优势:</strong></p><ul class=""><li id="d912" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">可以通过a)负载平衡器b)消息代理将工作分布到多个实例中</li></ul><p id="770d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">限制:</strong></p><ul class=""><li id="a21c" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">这里的大部分工作是实现你的<strong class="jp ir">负载分配</strong>机制。从简单的(如HTTP负载平衡)到更复杂的(如使用消息代理或配置数据库读取副本)</li></ul><p id="1606" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与另外两种方法相比，上述两种方法要简单得多。</p><p id="2985" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">数据分区</strong></p><p id="5f23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">数据分区</strong>的工作方式是，我们获取一个与工作负载相关联的键，例如，它可以是<code class="fe pv pw px py b">userId</code>，并对其应用一个函数，结果是我们将工作分配到的分区(有时称为<strong class="jp ir">碎片</strong>)。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi so"><img src="../Images/cf20efb98b73e97571d17cd6fe4e4334.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v3pbJ4HzW1np4moQIUjEPA.png"/></div></div></figure><p id="7d93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">两种分区方式:</p><ul class=""><li id="d383" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">在系统级(数据库)。在<em class="oc">功能</em>被应用到<em class="oc">键</em>后，数据进入所需的节点。不同的节点有相同的模式，但是内部有不同的数据。</li><li id="81aa" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">在微服务级别。我们从<em class="oc">请求</em>中决定我们的请求应该映射到哪个分区。如果请求具有一些可用于划分的数据，即报头中的名称，则可以在代理中完成。通过这种方法，每个分区都可以在<em class="oc">数据库</em>和<em class="oc">微服务级别</em>进行扩展。</li></ul><p id="b8f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">主要优势:</strong></p><ol class=""><li id="cf63" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk oo lt lu lv bi translated">与<em class="oc">水平扩展</em>配合良好:每个分区可以由多个节点组成，这些节点可以处理传入的负载</li><li id="2d4b" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">更容易根据<em class="oc">分区进行更新或维护</em></li></ol><p id="1ef4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">限制:</strong></p><ol class=""><li id="d977" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk oo lt lu lv bi translated">为了提高<strong class="jp ir">的健壮性</strong>，将<em class="oc">水平缩放</em>与数据分区相结合。因为对于普通分区，如果一个节点出现故障，一些请求就会丢失</li><li id="4018" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">好的分割是困难的。像<strong class="jp ir"> A-Z </strong>这样的名字的简单划分是不好的。因此，使用类似用户的ID或使用哈希函数。</li><li id="5877" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">更改分区模式可能需要大量的工作。有时甚至让系统脱机一段时间</li><li id="743e" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">查询所有数据(即<code class="fe pv pw px py b">Users who are younger than 18</code>)可能很困难。2个选项:<br/> -查询每个碎片并连接(通常是异步完成的)<br/> -如果您已经用所有数据读取了存储库-使用它</li></ol><p id="b459" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">针对写入的扩展甚至更加困难，在这种情况下，公司可能会开始改变其数据存储，以达到他们期望的写入量指标。</p><p id="8636" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">功能分解</strong></p><p id="4d68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从现有系统中提取一些功能，并将这些功能作为自己的微服务单独扩展。</p><p id="59f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">比如你先从<em class="oc">垂直缩放</em>，然后<em class="oc">水平</em>，然后<em class="oc">数据划分</em> →剩下一个就是<strong class="jp ir">功能分解</strong>。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi sp"><img src="../Images/ecc38e7f4b68f1057cc385ef5c76e3a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-MeDXwnb3K7vBLOmmq3QGA.png"/></div></div></figure><p id="2a2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">主要优势:</strong></p><ol class=""><li id="2fa4" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk oo lt lu lv bi translated">随着我们的系统变得更细粒度→更容易计算所需的基础设施</li><li id="e6a6" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">这种分解并没有使系统更具可伸缩性，但是它允许构建能够容忍部分故障的系统</li></ol><p id="b970" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">限制:</strong></p><ol class=""><li id="2f8f" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk oo lt lu lv bi translated">与其他形式的缩放相比，对系统的影响更严重</li><li id="b6b5" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">您最终将增加您正在运行的微服务的数量，这将增加系统的整体复杂性——潜在地导致更多需要维护、增强和扩展的东西。</li></ol><p id="3663" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">组合模型</strong></p><p id="628d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，通过<em class="oc">“功能分解”</em>的分解允许增加微服务的实例，又名<em class="oc">水平缩放</em>，并应用<em class="oc">数据分区</em></p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi sq"><img src="../Images/921b8578bb2e403cc1d8985805b1fb8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tuf4tmduE0LYEwJcHVx0XQ.png"/></div></div></figure><h2 id="27a2" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">贮藏</h2><p id="47c5" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">如果在本地缓存中找到数据— <strong class="jp ir">缓存命中</strong>。否则— <strong class="jp ir">缓存未命中</strong></p><p id="b069" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过高速缓存来帮助提高我们系统的<em class="oc">性能</em>，作为帮助减少<em class="oc">延迟</em>的一部分，以<em class="oc">扩展</em>我们的应用，在某些情况下甚至可以提高我们系统的<em class="oc">健壮性</em>。</p><p id="af63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">对于性能:</strong></p><ul class=""><li id="89d5" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">减少网络跳数</li><li id="05a5" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">减少创建复杂查询的需要(说到数据库)→不需要在请求端创建数据</li></ul><p id="6f77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">对于刻度:</strong></p><ul class=""><li id="23f9" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">减少对某些资源的争用:分离<em class="oc">写/读副本</em></li><li id="840e" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">读取是在包含陈旧数据的副本上完成的。最终，数据将被从<strong class="jp ir">主节点</strong>到<strong class="jp ir">副本节点</strong>的复制更新(也称为无效)</li><li id="6efd" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">总之，从客户端减少服务器上的<em class="oc">负载</em></li></ul><p id="cacf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">鲁棒性:</strong></p><ul class=""><li id="cc04" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">如果您的<em class="oc">读取副本</em>不可用，那么您可以从缓存中读取数据。在使更新缓存失效之前，一定要检查是否可以填满它— <strong class="jp ir">从根本上说，在源不可用的情况下，使用本地缓存来实现健壮性意味着您更喜欢可用性而不是一致性(回想一下上限定理)</strong></li></ul><h2 id="87ce" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">缓存数据的位置:</h2><ol class=""><li id="0cb1" class="ln lo iq jp b jq nw ju nx jy pb kc pc kg pd kk oo lt lu lv bi translated"><strong class="jp ir">客户端</strong>:不在原点范围内，又名服务器微服务。因此，这个缓存位于正在查询的微服务内部。</li></ol><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi sr"><img src="../Images/79733e0e3d1216fe67f9a8f7d49948df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9kQMB7GVas4Q8s-NDwroGQ.png"/></div></div></figure><ul class=""><li id="f8fc" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">不仅适用于改善<strong class="jp ir">延迟</strong>的缓存，也适用于增强<strong class="jp ir">健壮性</strong>的缓存。</li></ul><p id="b22a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">这种方式的问题:</strong> <em class="oc">客户端看到的数据之间不一致</em>:很多微服务有一个微服务的缓存→ <strong class="jp ir">缓存失效</strong>不会同时发生。解决这个问题的方法？→ <strong class="jp ir">共享缓存</strong></p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi pq"><img src="../Images/7166d22cbaab31265805bb51cdee36e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q-xPvJrt3I7Nm9eHp4fsnQ.png"/></div></div></figure><p id="2e3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">共享缓存</strong>，即使用Redis。但是现在客户端需要往返于缓存+它模糊了客户端和服务器端缓存之间的界限。</p><p id="ab0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<strong class="jp ir">服务器端:</strong>缓存在服务器微服务内部</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ss"><img src="../Images/8410b2d830c99ba22f175035027910cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YcRpBqRRiu8OW9mIHkQy-w.png"/></div></div></figure><ul class=""><li id="b5d0" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">由于这些缓存通常是如何实现的，例如内存中的数据结构或本地专用缓存节点，因此更容易实现更复杂的缓存失效机制。像<em class="oc">直写</em>缓存。此外，所有消费者看到的都是相同的缓存</li><li id="a9c5" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">我们可以不直接在微服务中进行缓存，而是在反向代理、redis节点等中进行缓存</li></ul><p id="7013" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题:</strong>网络跳跃→减少<em class="oc">延迟优化的机会</em>，减少<em class="oc">健壮性的机会</em> <br/> <strong class="jp ir">主要优势:</strong>如果跨组织使用微服务，那么在其中实施缓存可以大幅提高性能</p><p id="2f9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">始终考虑哪种缓存形式更适合特定情况。</p><p id="ab18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.<strong class="jp ir">请求缓存:</strong>针对特定请求的缓存。非常有效，但是很具体。</p><h2 id="7c69" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">缓存失效</h2><p id="e1fa" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">1.<strong class="jp ir"> TTL(生存时间)</strong> —时间限制，超过此时间后数据被视为无效，需要更新。</p><p id="bee7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现它的方法很多，但我们将着眼于HTTP变体。<br/> HTTP有:</p><ul class=""><li id="b565" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">TTL通过<strong class="jp ir">缓存控制</strong>头</li><li id="9c78" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">通过<strong class="jp ir">过期</strong>标题过期</li></ul><div class="ku kv gp gr kw kx"><a href="https://stackoverflow.com/a/5823521/16543524" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">过期和缓存控制头之间有什么区别？</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">感谢贡献一个堆栈溢出的答案！请务必回答问题。提供详细信息并分享…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">stackoverflow.com</p></div></div><div class="lg l"><div class="st l li lj lk lg ll lm kx"/></div></div></a></div><p id="e6b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">这种方法的缺点:</strong>尽管如此，它是钝的，因为5分钟中的4分59秒被认为仍然可以</p><p id="be69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<strong class="jp ir">条件得到</strong></p><p id="0b87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">之前讨论过:</strong>缓存控制，过期</p><p id="031e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">更好的选择:</strong>电子标签</p><ul class=""><li id="e90b" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">尽管它对减少网络跳数没有帮助，但是如果创建响应的成本很高，可能需要一组昂贵的数据库查询，那么条件GET请求可能是一种有效的机制。因为在<strong class="jp ir"> TTL </strong>中，即使值不变，我们也需要放入新值(我们在上一节中看到的就是它的最小值)。</li></ul><blockquote class="oi oj ok"><p id="a61b" class="jn jo oc jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">看看我关于网络和Web的文章，你会读到更多关于电子标签的内容:</p></blockquote><div class="ku kv gp gr kw kx"><a rel="noopener  ugc nofollow" target="_blank" href="/huge-course-about-networking-web-and-everything-in-between-d6f425ceea13"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">庞大的网络课程，网络和其间的一切</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">深入阅读本文，了解OSI、ARP、NAT、LB、TLS等更多信息。此外，还有过多的资源…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="lg l"><div class="qa l li lj lk lg ll lm kx"/></div></div></a></div><p id="ef83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.<strong class="jp ir">基于</strong>的通知:使用事件告诉<em class="oc">用户</em>缓存应该失效。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi su"><img src="../Images/041c06fc25f6a50ed022f5795d45474e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AqL-knMkXXRYzkpWDKA70A.png"/></div></div></figure><ul class=""><li id="248e" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><strong class="jp ir">缓存</strong>现在可能正在提供陈旧数据的窗口被限制为通知被发送和处理所花费的时间<strong class="jp ir">。根据您用来发送通知的机制，这可能会非常快。为此，我们可以使用<strong class="jp ir">消息代理</strong>。</strong></li><li id="6b1a" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">2发送数据选项:<em class="oc">推</em>和<em class="oc">拉</em>。首先是速度更快，但是存在消息大小和敏感数据的问题(我们可以开始将敏感数据发送给不需要查看的订户)</li></ul><p id="ec46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题:</strong>知道经纪人是否活着。<strong class="jp ir">解决方案:</strong>发送<strong class="jp ir">心跳</strong>，如果没有响应—告诉客户端他看到了过时的数据，或者完全关闭该功能。</p><p id="85a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.<strong class="jp ir">直写</strong></p><p id="80f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在同一个<em class="oc">事务</em>中“同时”更新数据库和缓存。但是它只能在服务器端实现。</p><p id="6149" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，几乎消除了客户端可以看到陈旧数据窗口。</p><p id="0601" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.<strong class="jp ir">后写</strong></p><p id="2042" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，数据被写入<strong class="jp ir">缓存</strong>，然后被写入<strong class="jp ir">数据库</strong>。这里缓存被用作缓冲区，可以进一步更新真实的数据库。</p><p id="6e60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题:</strong>如果缓存不持久，数据丢失，我们会丢失无法写入数据库的数据。</p><h2 id="dccf" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">缓存的黄金法则</h2><p id="1f5c" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">在尽可能少的地方缓存，因为越多的缓存意味着越多的地方数据会变得陈旧。</p><p id="f1de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">平衡:数据的新鲜度与系统性能的提高(负载、延迟)。如果您需要更新的数据，则缩短TTL窗口。但这意味着我们需要提出更多的请求——增加系统的负荷。</p><p id="7379" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">失效缓存的真实案例:</strong></p><p id="2de9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果客户端缓存的TTL为1分钟，服务器端缓存的TTL为1分钟，那么在客户端缓存过期后，我们会向服务器请求更新缓存。然而，结果可能是服务器的TTL也是一分钟，而在请求的这个特定时刻<strong class="jp ir">是0:59秒。因此，我们为我们的客户端缓存获取的数据最多过期2分钟。</strong></p><p id="5abc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，如果缓存分布在不同的部分，而我们对此不够关心。</p><p id="0b08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS:为了解决上述问题，我们可以利用<strong class="jp ir">基于时间戳的过期</strong>。</p><h2 id="a41d" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">自动缩放</h2><p id="4264" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">如果您已经自动部署了微服务，那么您可以利用微服务的自动扩展。</p><ul class=""><li id="983c" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">通过众所周知的因素进行缩放:<strong class="jp ir">峰值时间</strong>等</li><li id="3517" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">反应式方法:当您看到负载增加或实例失败时</li></ul><p id="d4f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另外，保持<strong class="jp ir">负载测试</strong>来跟踪你的系统如何自动伸缩也是一个好主意。</p><h1 id="10b8" class="my mz iq bd na nb od nd ne nf oe nh ni nj of nl nm nn og np nq nr oh nt nu nv bi translated">用户界面</h1><p id="2bf4" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">UI和微服务的模式:</p><ul class=""><li id="746d" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><strong class="jp ir">单片前端:</strong> SPA从所需的微服务获取数据，并自行处理所有数据</li></ul><p id="69e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">缺点:难以适应各种设备</p><div class="ku kv gp gr kw kx"><a href="https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/choose-between-traditional-web-and-single-page-apps" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">在传统网络应用和单页应用之间选择</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">提示“阿特伍德定律:任何可以用JavaScript编写的应用程序，最终都会用JavaScript编写。”杰夫…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">learn.microsoft.com</p></div></div><div class="lg l"><div class="sv l li lj lk lg ll lm kx"/></div></div></a></div><div class="ku kv gp gr kw kx"><a href="https://link.medium.com/yOlHZ4wRRvb" rel="noopener follow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">单页应用与多页应用——你真的需要一个SPA吗？</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">你一定听说过很多关于单页应用程序的愤怒，如果你没有，你可能生活在…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">link.medium.com</p></div></div><div class="lg l"><div class="sw l li lj lk lg ll lm kx"/></div></div></a></div><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi sx"><img src="../Images/5dac6553a862f52bdd22655788e8b608.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4PLyEHKjXo6NaQsC4nJIgw.png"/></div></div></figure><ul class=""><li id="145f" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><strong class="jp ir">微前端模式:</strong>前端的不同部分可以独立开发和交付(就像<strong class="jp ir">前端的独立可部署性</strong></li></ul><h2 id="2a60" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">实现微前端的方法:</h2><p id="6082" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated"><strong class="jp ir">基于小部件的分解</strong>包括将前端的不同部分拼接到一个屏幕上。在这种情况下，每个团队负责每个小部件。这些部件可以相互混合。回想一下<strong class="jp ir">端到端团队</strong>负责小部件，即每个团队做前端、后端、数据库的事情。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi sx"><img src="../Images/67f0e8da8506ae389a16f5387d3f20c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L2-99nAJ_0cAuoU37GgYiQ.png"/></div></div></figure><p id="fc89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例子是<strong class="jp ir"> Spotify </strong>。</p><p id="c84d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">微件之间的交互是通过浏览器的<em class="oc">事件</em>完成的。这种方法是最好的和主要的选择之一。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi sy"><img src="../Images/0b9f5e663160e53ab65fb2a255df581a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tjcOn8_3QqT8Jdda9e4vlQ.png"/></div></div></figure><div class="ku kv gp gr kw kx"><a href="https://developer.mozilla.org/en-US/docs/Web/Events" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">事件参考| MDN</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">事件被触发以通知代码可能影响代码执行的“有趣的变化”。这些可能来自用户…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">developer.mozilla.org</p></div></div><div class="lg l"><div class="sz l li lj lk lg ll lm kx"/></div></div></a></div><p id="81d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">另一方面，基于页面的分解</strong>将前端分割成独立的网页。这两种方法都值得进一步探讨，我们很快就会谈到。每个微服务负责一个单独的页面。</p><h2 id="6718" class="op mz iq bd na oq or dn ne os ot dp ni jy ou ov nm kc ow ox nq kg oy oz nu pa bi translated">在前端过滤数据的模式</h2><ul class=""><li id="f38d" class="ln lo iq jp b jq nw ju nx jy pb kc pc kg pd kk ls lt lu lv bi translated"><strong class="jp ir">中央聚合网关</strong>。<strong class="jp ir">聚合网关</strong>允许从UI发出一个调用，它将发出所有需要的调用并过滤数据。所以，我们进行<strong class="jp ir">批量</strong>调用→ <em class="oc">降低带宽</em>和<em class="oc">改善延迟</em>。</li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ta"><img src="../Images/0abc0745eecb0e0899732af85b6ce18f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c_2M2ySBeqG_VgvuvlP-ZQ.png"/></div></div></figure><p id="3c8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题:</strong>这个<em class="oc">聚合网关</em>可能会成为<em class="oc">争用的来源</em>，因为多个团队可能需要它，它可能会开始包含太多的逻辑。所以，<em class="oc">所有权问题</em>是一个明确的问题。</p><ul class=""><li id="bda6" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><strong class="jp ir">后端对前端。</strong> BFF是为单一情况开发的，而<strong class="jp ir">聚合网关</strong>通常是整个系统的聚合网关。是UI团队来开发的:前端是用户界面，BFF是服务器。</li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi tb"><img src="../Images/07f62e6a5550fc5dabd049eb257f20eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fkUKEj8ImfnSUy892hAjBQ.png"/></div></div></figure><p id="4d13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">然而</strong>:如果体验非常相似——用一个BFF换一个体验(像Android和IOS app)。</p><p id="86e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">BFF中的代码重用:</strong></p><ol class=""><li id="6231" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk oo lt lu lv bi translated">形成客户端库。但是回想一下，它导致<strong class="jp ir">耦合</strong></li><li id="af1a" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk oo lt lu lv bi translated">制作一个单独的微服务，重复代码将驻留在这个微服务中——这里我们将微服务用作API，仅此而已。这是BFF模式的另一种用法。</li></ol><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi tc"><img src="../Images/ea0623e80c12a0ac596f28f5124d5fa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NFs3F5-9Uc_DRBXog59PPA.png"/></div></div></figure><p id="1d8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现聚合网关和BFF的方法:</p><ul class=""><li id="716d" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">传统微服务方法</li><li id="cd79" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">GraphQL</li></ul><div class="ku kv gp gr kw kx"><a href="https://netflixtechblog.com/embracing-the-differences-inside-the-netflix-api-redesign-15fd8b3dc49d" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd ir gy z fp lc fr fs ld fu fw ip bi translated">拥抱差异:网飞API重新设计内部</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">我们已经采用了全新的、完全可定制的API</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">netflixtechblog.com</p></div></div><div class="lg l"><div class="td l li lj lk lg ll lm kx"/></div></div></a></div><h1 id="7f92" class="my mz iq bd na nb od nd ne nf oe nh ni nj of nl nm nn og np nq nr oh nt nu nv bi translated">结尾部分</h1><p id="82ae" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">为了自学，你可以阅读更多关于康威定律、T42布鲁克定律以及建筑师应该如何参与产品开发以及他所扮演的角色。而且，你可以阅读一下<strong class="jp ir">平台</strong>以及这个特性的用途是什么。</p><p id="a8c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢您的阅读，欢迎发表评论或通过更多链接联系我:</p><ul class=""><li id="c1c1" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">领英:<a class="ae lw" href="http://www.linkedin.com/in/sleeplesschallenger" rel="noopener ugc nofollow" target="_blank">www.linkedin.com/in/sleeplesschallenger</a></li><li id="363d" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">GitHub:【https://github.com/SleeplessChallenger T2】</li><li id="7f5d" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">leet code:【https://leetcode.com/SleeplessChallenger/】T4</li><li id="958f" class="ln lo iq jp b jq lx ju ly jy lz kc ma kg mb kk ls lt lu lv bi translated">电报:@无眠挑战者</li></ul></div></div>    
</body>
</html>