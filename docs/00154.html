<html>
<head>
<title>AWS Lambda’s &amp; VPC cold starts — The dark side 🕶 ⛈</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS Lambda和VPC冷启动—🕶⛈的黑暗面</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lambda-vpc-cold-starts-a-latency-killer-5408323278dd?source=collection_archive---------0-----------------------#2018-06-14">https://levelup.gitconnected.com/lambda-vpc-cold-starts-a-latency-killer-5408323278dd?source=collection_archive---------0-----------------------#2018-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/69909b00d282b41aff6290f0591ed2e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q7SupkVtOxSPIilJni9-1w.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/photos/Ggt04LoGPBk?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Ethan Hu </a>在<a class="ae kc" href="https://unsplash.com/search/photos/cold?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="d9d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">编辑:</strong>这篇文章可能不太相关，因为自发表以来，AWS已经像往常一样完成了令人敬畏的工程工作，并减少了VPC冷启动次数。我还没有测试它，但检查他们的文章<a class="ae kc" href="https://aws.amazon.com/blogs/compute/announcing-improved-vpc-networking-for-aws-lambda-functions/" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><p id="6783" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有无服务器计算都遭受着<strong class="kf ir">可怕的</strong>“<strong class="kf ir">冷启动”，</strong>和<a class="ae kc" href="http://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>也不例外。我在之前的一篇文章中已经探讨过<a class="ae kc" href="https://medium.com/@nathan.malishev/lambda-cold-starts-language-comparison-️-a4f4b5f16a62" rel="noopener">冷启动</a>。但不为人知的是，将Lambda与虚拟私有云结合使用会如何影响延迟。从<a class="ae kc" href="https://www.reddit.com/r/aws/comments/6lfubn/aws_lambda_vpc_redis_slow/" rel="noopener ugc nofollow" target="_blank">各种</a> <a class="ae kc" href="https://forums.aws.amazon.com/thread.jspa?threadID=231069" rel="noopener ugc nofollow" target="_blank">报告</a><a class="ae kc" href="https://www.reddit.com/r/aws/comments/7gpd53/lambda_rds_incredibly_slow/" rel="noopener ugc nofollow" target="_blank"/><a class="ae kc" href="https://www.robertvojta.com/aws-journey-api-gateway-lambda-vpc-performance/" rel="noopener ugc nofollow" target="_blank">网页</a>来看，VPCs内的冷启动可能会增加<strong class="kf ir">长达10秒的延迟！</strong>😢</p><h1 id="936a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">背景</strong></h1><p id="daa0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">AWS Lambda和无服务器计算正在通过按需执行代码来改变计算范式。是的，这意味着您只需在代码执行时付费！💸</p><p id="50e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无服务器<strong class="kf ir">冷启动</strong>是你的代码第一次被你的云提供商执行，需要下载、封装、启动并准备运行。这可能会增加大量开销— <strong class="kf ir">高达1.5秒的延迟</strong>！</p><p id="bae9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但好消息是:这些冷启动预计是异常值，仅影响5%的执行。因此，虽然它们并不总是发生，但在设计应用程序时考虑它们是很重要的。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/158f767295c269582a056f74838f0c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HsUccdkDffywiUjM7AYdFw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://youtu.be/oQFORsso2go?t=8m5s" rel="noopener ugc nofollow" target="_blank">常规冷启动</a>(截图自视频)</figcaption></figure><p id="cfe6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">虚拟私有云(VPC) </strong>是一个私有网络，在其中您严格控制进出网络流量。它们被广泛使用，传统上，您会在VPC后面安全地运行数据库和服务器，只暴露一个负载平衡器。如果在需要访问的VPC后面已经有了严格的安全需求或服务，那么可能必须在VPC中部署Lambda函数。</p><p id="8514" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在VPC中使用Lambda函数所增加的复杂性会带来新的延迟。这些延迟是由于创建一个弹性网络接口，然后等待Lambda为自己分配该IP。也要小心，每个Lambda函数都需要一个IP地址，你不想用完！</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/f7bbf1ba45582e2baafce6c7a3c469e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FCpFITtI7oxassyWOQdrKw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://youtu.be/oQFORsso2go?t=41m49s" rel="noopener ugc nofollow" target="_blank">VPC内冷启动</a>(截图自视频)</figcaption></figure><p id="bfdb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是额外的网络开销，你对此无能为力，除非首先避免VPC。那么，到底有多糟糕？</p><h1 id="3601" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">设置</h1><p id="994a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了测试VPC和冷启动的影响，我创建了两个几乎相同的云形成堆栈。</p><p id="4d76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> CloudFormation是代码为</strong>的基础设施，由AWS提供本地支持。您可能听说过类似的产品，如Terraform或Ansible，它们是很好的替代产品。CloudFormation的巨大优势是与AWS及其<a class="ae kc" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference.html" rel="noopener ugc nofollow" target="_blank">固有功能</a>的紧密集成。</p><p id="fab7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://github.com/awslabs/serverless-application-model" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> AWS Sam </strong> </a>是CloudFormation的一个令人敬畏的扩展，它大大降低了部署Lambda函数的复杂性。它将多个云形成资源联系在一起，因此您不必单独管理它们来部署Lambda功能。它还通过无缝地将您的代码压缩和部署到S3，简化了部署过程。它还具有<a class="ae kc" href="https://docs.aws.amazon.com/lambda/latest/dg/automating-updates-to-serverless-apps.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">内置金丝雀部署</strong> </a>！但是如果你是云不可知论者的话，还有像<a class="ae kc" href="https://serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器</a>这样很好的选择。</p><p id="ed39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章不是关于云的形成和Sam。但是如果你想看的话，请发表评论:)</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/0e2a45079ec9c5a9332a7c7bb9420295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*teE_0mjhNDaQCTRz.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://github.com/awslabs/serverless-application-model" rel="noopener ugc nofollow" target="_blank"> AWS山姆</a>牛逼！</figcaption></figure><p id="81ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的两个栈都是带有AWS Sam扩展的CloudFormation栈。它们都具有简单的读写功能，用<a class="ae kc" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Golang </a>编写。这些函数读写单个<a class="ae kc" href="https://aws.amazon.com/rds/aurora/" rel="noopener ugc nofollow" target="_blank"> AWS Aurora RDS </a>实例。不同之处在于，一个堆栈位于专用子网中，需要额外的冷启动开销。</p><p id="ccb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">VPC和RDS实例仅由CloudFormation管理，而API网关和Lambda功能由Sam扩展管理。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/02299ffde4030dc6d16ea39a909b0d51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LwyfJUjmHsFbdMgGpLj57g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">该图试图给出两个栈的可视化表示&amp;它们的部署是如何管理的。</figcaption></figure><p id="20a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是堆栈#1的要点:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">创建公共Lambda &amp; RDS实例的云结构</figcaption></figure><p id="28f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个堆栈和剩余的代码可以在我的GitHub repo <a class="ae kc" href="https://github.com/nathanmalishev/go-lambda-vpc-experiment" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="c972" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结果</h1><p id="b873" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我运行了这些堆栈，使用自动化的<a class="ae kc" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/Create-CloudWatch-Events-Scheduled-Rule.html" rel="noopener ugc nofollow" target="_blank"> CloudWatch </a>规则每小时触发一次Lambda函数。我还部署了不同内存级别的堆栈:128mb、1536mb和3008mb。在下图中，高于5秒标记的所有值都来自堆栈#2(在VPC内)，低于5秒标记的所有值都来自堆栈#1(在VPC外)。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/5d0e86298e0735dbe1f03ec87cc75e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*16yC8qApBwQirGLItTPtjA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">栈#1和#2的Lambda读写函数。<a class="ae kc" href="https://plot.ly/~nathanmalishev/1/" rel="noopener ugc nofollow" target="_blank">在这里玩图形</a></figcaption></figure><p id="a39b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有趣的是，在所有数据点上，增加一个<strong class="kf ir"> VPC平均增加了8.83秒</strong>的冷启动时间。增加RAM似乎确实减少了VPC增加的冷启动时间。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/1c1583288b0c617de841b4a4f0e31f11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GwWZRFPuYZ8qx0cBRFiH2A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">堆栈和RAM配置的平均冷启动时间</figcaption></figure><p id="3a4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来互联网是对的，将Lambda函数部署到VPC会增加巨大的开销。仅仅8秒钟的延迟就已经是很糟糕的用户体验了。如果您的应用程序被适当地解耦，运行到多个冷启动将会对用户的体验产生负面影响。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mq mn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">冷启动时间的3pt移动平均值。<a class="ae kc" href="https://plot.ly/~nathanmalishev/3/" rel="noopener ugc nofollow" target="_blank">在这里玩图形</a></figcaption></figure><h1 id="eae6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么时候去VPC？</h1><p id="6d3d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">只有当你绝对需要访问不能暴露给外界的资源时，你才应该把你的Lambda函数放在VPC中。否则，你将在启动时间<strong class="kf ir">为其买单，这很重要</strong>。正如<a class="mr ms ep" href="https://medium.com/u/d00f1e6b06a2?source=post_page-----5408323278dd--------------------------------" rel="noopener" target="_blank">崔琰</a>在他的文章<a class="ae kc" href="https://medium.com/p/im-afraid-you-re-thinking-about-aws-lambda-cold-starts-all-wrong-7d907f278a4f?source=user_popover" rel="noopener">“你认为冷启动是错误的”</a>中强调的那样，冷启动可能在任何时候发生，尤其是在服务使用高峰期。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/519478ae62c0b1cce7d2df1c40181580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*4RwbY1CiZC2jzsD7jBtIlQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Lambda &amp; VPC的决策树来自他们的<a class="ae kc" href="https://d1.awsstatic.com/whitepapers/architecture/AWS-Serverless-Applications-Lens.pdf" rel="noopener ugc nofollow" target="_blank">无服务器白皮书</a></figcaption></figure><h1 id="a457" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">明白了💣</h1><p id="3c1f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果您确实需要使用VPC，请记住，每次执行Lambda函数时，它都会使用子网中一定比例的ENI容量。在<a class="ae kc" href="https://docs.aws.amazon.com/lambda/latest/dg/vpc.html" rel="noopener ugc nofollow" target="_blank"> AWS文档</a>中，他们声明您必须有足够的ENI容量来支持您的Lambda扩展需求。如果你用完了ENI容量，这将导致你的Lambda函数失败！</p><p id="44b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要计算给定子网中的最大并发Lambda执行数，我们必须使用以下公式。</p><p id="a2d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mu mv mw mx b">ENI Capacity = Projected peak concurrent executions * (Memory in GB / 3GB)</code></p><p id="b537" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mu mv mw mx b">ENI Capacity</code> =您的子网拥有的IP地址数量</p><p id="6c29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mu mv mw mx b">Memory in GB</code> =专用于Lambda函数的RAM</p><p id="746a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，子网10.0.70.0/24有251个可用子网。如果我们有一个分配了1.5gb内存的Lambda函数:</p><p id="a12c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">251 =项目峰值并发执行数* (1.5/3)</p><p id="b93d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">预计峰值并发(λ)执行数= 502</p><p id="4651" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为您的并发Lambda执行直接依赖于子网中可用的IP地址，所以最好使用能提供1000多个IP地址的子网。</p><p id="1152" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你不确定，你可以计算一下，确保给定子网中所有Lambda函数的RAM分配适合你的可用IP。</p><p id="b1a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">感谢阅读！如果你喜欢，一定要为它鼓掌。</strong></p><h1 id="0818" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">参考</h1><p id="c862" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">展示冷启动变体的第一张幻灯片来自AWS reinvention 2017年的演讲“成为<a class="ae kc" href="https://serverless.com" rel="noopener ugc nofollow" target="_blank">无服务器</a>黑带”。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="my mn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">AWS重塑2017:成为无服务器黑带</figcaption></figure><h2 id="110f" class="mz lc iq bd ld na nb dn lh nc nd dp ll ko ne nf lp ks ng nh lt kw ni nj lx nk bi translated">有用的链接</h2><p id="95dd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><a class="ae kc" href="https://github.com/awslabs/serverless-application-model" rel="noopener ugc nofollow" target="_blank">GitHub上的AWS无服务器应用模型</a>。</p><p id="7905" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://github.com/nathanmalishev/go-lambda-vpc-experiment" rel="noopener ugc nofollow" target="_blank">我在GitHub上的λVPC实验</a>。</p></div></div>    
</body>
</html>