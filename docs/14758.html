<html>
<head>
<title>Data Analysis with Strava</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Strava进行数据分析</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/data-analysis-with-strava-7251327698e3?source=collection_archive---------4-----------------------#2022-12-22">https://levelup.gitconnected.com/data-analysis-with-strava-7251327698e3?source=collection_archive---------4-----------------------#2022-12-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d82b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何利用数据和机器学习提高跑步成绩？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e34504dc848c8cd6d53729b9d8961d26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GnCTO0ueBDpHg1rBVu-7Sw.png"/></div></div></figure><p id="d027" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我一直非常喜欢跑步，从很小的时候我就参加比赛，目的是提高我的速度和距离，但是有几个因素影响着跑步，从心理因素到外部因素。然而，随着小工具、可穿戴设备和应用程序(如<a class="ae ln" href="https://strava.com/" rel="noopener ugc nofollow" target="_blank"> Strava </a>)的使用，已经有可能捕捉指标并执行有助于性能提升的分析。</p><h1 id="d226" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">摘要</h1><ul class=""><li id="152d" class="mg mh iq kt b ku mi kx mj la mk le ml li mm lm mn mo mp mq bi translated">访问数据；</li><li id="6457" class="mg mh iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">数据清洗；</li><li id="47ec" class="mg mh iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">见解；</li><li id="975f" class="mg mh iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">特征选择；</li><li id="1707" class="mg mh iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">机器学习；</li><li id="965e" class="mg mh iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">结论；</li><li id="00d7" class="mg mh iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">参考文献。</li></ul><h1 id="9771" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">访问数据</h1><p id="7c3e" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">作为一个数据源，我们将使用Strava，它是一个Fremium应用程序，有一个API，允许轻松捕获数据。</p><p id="9823" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里提到的在API中插入的步骤也可以从官方文档中获得，但是如果您想客观一些，本文将描述主要步骤。</p><div class="mz na gp gr nb nc"><a href="https://developers.strava.com/docs/getting-started/" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">Strava开发商</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">欢迎来到Strava API！这是如何使用我们的API的简要概述。任何流汗的人都是运动员，所以…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">developers.strava.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq kp nc"/></div></div></a></div><p id="5215" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">访问数据的第一步是创建一个Strava帐户，登录然后创建一个应用程序，可以使用<a class="ae ln" href="https://www.strava.com/settings/api" rel="noopener ugc nofollow" target="_blank">这个链接</a>来完成。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/442bef3f9614120147284191ac67a5a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gZW7X60KxMn4odz9z2wKXg.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">Strava API仪表板，客户端id字段以绿色突出显示，客户端密码字段以蓝色突出显示。</figcaption></figure><p id="dcc2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">创建应用程序后，我们将主要使用<strong class="kt ir">客户端ID </strong>(以绿色突出显示)和<strong class="kt ir">客户端秘密</strong>(以蓝色突出显示)。它将被放在项目将被执行的存储库或文件夹的一个<code class="fe nw nx ny nz b">.env</code>文件中。</p><p id="1b6a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，您需要访问以下链接，将[CLIENT_ID]字段更改为您的应用程序中可用的值，在上图中以绿色显示。</p><blockquote class="oa ob oc"><p id="fd07" class="kr ks od kt b ku kv jr kw kx ky ju kz oe lb lc ld of lf lg lh og lj lk ll lm ij bi translated"><a class="ae ln" href="http://www.strava.com/oauth/authorize?client_id=[CLIENT_ID]&amp;response_type=code&amp;redirect_uri=http://localhost/exchange_token&amp;approval_prompt=force&amp;scope=profile:read_all,activity:read_all" rel="noopener ugc nofollow" target="_blank">http://www.strava.com/oauth/authorize?CLIENT _ ID =[CLIENT _ ID]&amp;response _ type = code&amp;redirect _ uri = http://localhost/exchange _ token&amp;approval _ prompt = force&amp;scope = profile:read _ all，activity:read_all </a></p></blockquote><p id="0f76" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">访问此链接时，选择您希望应用程序有权访问的数据(如下图所示)，然后单击授权。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/02c8bd5819710b3481911ee741caeba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PQIfOGt7xA8YXhnmyK-7_Q.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">Strava应用程序授权仪表板。</figcaption></figure><p id="df91" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该操作将生成一个不同的URI，需要从<strong class="kt ir">代码</strong>参数中复制代码并粘贴到前述的<code class="fe nw nx ny nz b">.env</code>中。下面是URI授权后，以及。env文件应该是这样的。</p><blockquote class="oa ob oc"><p id="c1fa" class="kr ks od kt b ku kv jr kw kx ky ju kz oe lb lc ld of lf lg lh og lj lk ll lm ij bi translated"><a class="ae ln" href="http://localhost/exchange_token?state=&amp;code=2e9fuhef9f2jd293jqd0g8erqt84r802jqd0137q&amp;scope=read,activity:read_all,profile:read_all" rel="noopener ugc nofollow" target="_blank">http://本地主机/exchange_token？state =&amp;code = 2e 9 Fuhe F9 F2 JD 293 jqd 0g 8 erqt 84 r 802 jqd 0137 q&amp;scope = read，activity:read_all，profile:read_all </a></p></blockquote><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="3ff0" class="om lp iq nz b be on oo l op oq">client_id=36431<br/>client_secret=fasfjsfajfjie8293u2jf2j92jf232ije0jje92j<br/>strava_code=2e9fuhef9f2jd293jqd0g8erqt84r802jqd0137q</span></pre><p id="8393" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">执行完这些步骤后，有必要在与<code class="fe nw nx ny nz b">.env</code>文件相同的环境中运行下面的Python脚本。这个脚本将更新捕获数据所需的令牌，并将使用请求返回的数据生成一个JSON文件。我把这个脚本命名为<code class="fe nw nx ny nz b">create_token.py</code>。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="1c9c" class="om lp iq nz b be on oo l op oq">import os<br/>import json<br/>import requests<br/>from dotenv import load_dotenv<br/><br/>load_dotenv()<br/><br/>response = requests.post(<br/>    url='https://www.strava.com/oauth/token',<br/>    data={<br/>        'client_id': int(os.environ.get('client_id')),<br/>        'client_secret': os.environ.get('client_secret'),<br/>        'code': os.environ.get('strava_code'),<br/>        'grant_type': 'authorization_code'<br/>    }<br/>)<br/>strava_tokens = response.json()<br/>with open('strava_tokens.json', 'w', encoding='utf-8') as outfile:<br/>    json.dump(strava_tokens, outfile)<br/>print(strava_tokens)</span></pre><p id="3a77" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更新了令牌和环境变量后，只需运行代码从API中捕获数据，如下所示。这里可能会注意到捕获是按页进行的，所以会执行一个循环，直到响应为空或出现错误。值得一提的是，在运行脚本之前，我在同一个工作区创建了两个文件夹，分别名为<strong class="kt ir">数据</strong>和<strong class="kt ir">结果</strong>来存储捕获的CSV，下面的脚本命名为<code class="fe nw nx ny nz b">get_activities.py</code>。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="bd5b" class="om lp iq nz b be on oo l op oq">import os<br/>import json<br/>import glob<br/>import time<br/>import requests<br/>import pandas as pd<br/>from dotenv import load_dotenv<br/><br/>load_dotenv()<br/><br/>def main():<br/>    url = "https://www.strava.com/api/v3/activities"<br/>    access_token = get_credentials()<br/>    page = 1<br/>    print('Getting data from Strava')<br/>    while True:<br/>        response = get_data(url, access_token, 200, page)<br/>        if 'message' in response.columns:<br/>            raise Exception('Authorization Error')<br/>        if response.empty:<br/>            break<br/>        save_csv(response, f'data/strava_activities_page_{page}.csv')<br/>        page += 1<br/>    merge_files('data/', 'result/strava_all_activities.csv')<br/>    print('Done Successfully')<br/>def get_credentials():<br/>    with open('strava_tokens.json', encoding='utf-8') as json_file:<br/>        strava_tokens = json.load(json_file)<br/>    if 'expires_at' not in strava_tokens.keys() or strava_tokens['expires_at'] &lt; time.time():<br/>        strava_tokens = refresh_credentials(strava_tokens)<br/>    return strava_tokens['access_token']<br/>def refresh_credentials(strava_tokens):<br/>    response = requests.post(<br/>        url='https://www.strava.com/oauth/token',<br/>        data={<br/>            'client_id': int(os.environ.get('client_id')),<br/>            'client_secret': os.environ.get('client_secret'),<br/>            'grant_type': 'refresh_token',<br/>            'refresh_token': strava_tokens['refresh_token']<br/>        }<br/>    )<br/>    strava_tokens = response.json()<br/>    with open('strava_tokens.json', 'w', encoding='utf-8') as outfile:<br/>        json.dump(strava_tokens, outfile)<br/>    with open('strava_tokens.json', encoding='utf-8') as check:<br/>        data = json.load(check)<br/>    return data<br/>def get_data(url, access_token, numb_item_page, page):<br/>    print(f'Getting data from page {page}')<br/>    response = requests.get(<br/>        f'{url}?access_token={access_token}&amp;per_page={numb_item_page}&amp;page={page}'<br/>    )<br/>    response = response.json()<br/>    dataframe = pd.json_normalize(response)<br/>    return dataframe<br/>def save_csv(dataframe, filename):<br/>    print(f'Saving {filename}')<br/>    dataframe.to_csv(filename)<br/>def merge_files(path, filename):<br/>    print('Merging files')<br/>    csv_files = [pd.read_csv(_file)<br/>                 for _file in glob.glob(os.path.join(path, "*.csv"))]<br/>    final_df = csv_files.pop(len(csv_files)-1)<br/>    final_df = final_df.append(csv_files)<br/>    save_csv(final_df, filename)<br/>if __name__ == '__main__':<br/>    main()</span></pre><p id="24c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了数据，让我们开始分析，为了完成这一壮举，我们将使用Jupyter笔记本。</p></div><div class="ab cl or os hu ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="ij ik il im in"><h1 id="f607" class="lo lp iq bd lq lr oy lt lu lv oz lx ly jw pa jx ma jz pb ka mc kc pc kd me mf bi translated">数据清理</h1><p id="f9b3" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">第一步是导入将用于执行数据分析的库，这些库可以分为用于支持脚本的通用库、用于分析和绘制数据帧的库，以及最后用于执行机器学习技术的库。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="e508" class="om lp iq nz b be on oo l op oq"># general<br/>import subprocess<br/>import calendar<br/>from geopy.geocoders import Nominatim<br/><br/># df and plotting<br/>import pandas as pd<br/>import numpy as np<br/>import seaborn as sns<br/>import matplotlib.pyplot as plt<br/>import matplotlib.dates as mdates<br/><br/># machine learning<br/>from sklearn import preprocessing<br/>from sklearn import metrics<br/>from sklearn.cluster import KMeans<br/>from sklearn.feature_selection import chi2<br/>from sklearn.feature_selection import SelectKBest<br/>from sklearn.feature_selection import RFE<br/>from sklearn.linear_model import LinearRegression<br/>from sklearn.linear_model import SGDClassifier<br/>from sklearn.metrics import accuracy_score<br/>from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.pipeline import make_pipeline<br/>from sklearn.preprocessing import StandardScaler<br/><br/><br/>df = pd.read_csv('result/strava_all_activities.csv')<br/>print('Dataframe Shape:', df.shape)<br/>df.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/394616bc0888014d98e8929bf0d9063a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UOwqjutKGNup5U7I-HKXkw.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">数据集形状和包含数据集数据的表。</figcaption></figure><p id="fdfb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一次接触后，阅读产生的CSV显示，我们的数据框架有大约58列和一些行，可以根据每个运动员的记录变化。但是当我们查看数据质量时，我们注意到许多数据是空的或者对分析没有贡献，所以我们将只选择研究感兴趣的列。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="2004" class="om lp iq nz b be on oo l op oq">null_df = [[col, df[col].isnull().sum()] for col in df.columns]<br/>print('Null Data:', df.isnull().sum().sum())<br/>list(filter(lambda x: x[1]&gt;0, null_df))</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/71694b2889506c22b3a81837bfbd94b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CIYsA66czoVodIB68gKyYw.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">空数据的总量和按数据集列。</figcaption></figure><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="4a36" class="om lp iq nz b be on oo l op oq">selected_columns = ['distance', 'moving_time', 'elapsed_time',<br/>                    'total_elevation_gain', 'type','sport_type', 'id', 'start_date',<br/>                    'start_date_local','location_country', 'achievement_count', 'kudos_count',<br/>                    'comment_count','athlete_count', 'start_latlng',<br/>                    'end_latlng', 'average_speed', 'max_speed', 'average_cadence',<br/>                    'average_heartrate', 'max_heartrate', 'elev_high','elev_low',<br/>                    'upload_id', 'external_id', 'pr_count', 'map.summary_polyline']<br/>df = df[selected_columns]</span></pre><p id="95a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我决定提取数据集提供的最大值，并尝试删除尽可能少的数据，因此我根据日期生成了一些数据，用零值、未知标签或平均值填写了一些空字段，最后，我生成了一些数据，标准化了以公里为单位的距离和以分钟为单位的时间。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="4241" class="om lp iq nz b be on oo l op oq">df['start_date_local'] = pd.to_datetime(df['start_date_local'], errors='coerce')<br/>df = df.sort_values(by='start_date_local')<br/><br/>df['weekday'] = df['start_date_local'].map(lambda x: x.weekday)<br/>df['start_time'] = df['start_date_local'].dt.time<br/>df['start_time'] = df['start_time'].astype(str)<br/>df['start_date'] = df['start_date_local'].dt.date<br/><br/>df = df.drop('start_date_local', 1)<br/>df.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/aaff238bb460e3f717bc9fcd3662311f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lv77GWGRYEVE1LVzPypxeA.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">转换产生的数据集。</figcaption></figure><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="ff25" class="om lp iq nz b be on oo l op oq">df = df.drop(df[(df.distance &lt; 1) &amp; (df.type == 'Run')].index)<br/>df = df.drop(df[(df.distance &lt; 1) &amp; (df.type == 'Ride')].index)<br/>df = df.drop(df[df.average_speed &gt; 30].index)<br/>df = df.reset_index(drop=True)<br/><br/>df['elev_high'] = df['elev_high'].fillna(value=0)<br/>df['elev_low'] = df['elev_low'].fillna(value=0)<br/>df['upload_id'] = df['upload_id'].fillna(value='unknown')<br/>df['external_id'] = df['external_id'].fillna(value='unknown')<br/>df['map.summary_polyline'] = df['map.summary_polyline'].fillna(value='unknown')<br/>df['average_cadence'] = df['average_cadence'].fillna(value=df['average_cadence'].mean())<br/>df['average_heartrate'] = df['average_heartrate'].fillna(value=df['average_heartrate'].mean())<br/>df['max_heartrate'] = df['max_heartrate'].fillna(value=df['max_heartrate'].mean())<br/><br/>df['moving_time_minutes'] = round(df['moving_time']/60, 2)<br/>df['distance_km'] = round(df['distance'] / 1000, 2)<br/>df['pace'] = df['moving_time_minutes'] / df['distance_km']<br/>df['avg_speed_kmh'] = round(60/df['pace'], 2)<br/>df['max_speed_kmh'] = round(df['max_speed']*3.6, 2)<br/><br/>df['elev'] = df['elev_high'] - df['elev_low']<br/>df['year']= df['start_date'].map(lambda x: x.year)</span></pre><p id="93a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">需要强调的一个例子是，我想要完成城市和州字段，因为在最初的训练中，列中还有纬度和经度字段。所以在这种情况下，使用了<a class="ae ln" href="https://geopy.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> geopy </a>库。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="3bdc" class="om lp iq nz b be on oo l op oq">def get_city_state_from_value(value):<br/>    value = value.replace('[','').replace(']','').split(',')<br/>    if value != ['']:<br/>        location = geolocator.reverse(', '.join(value))<br/>        result = f'{location[0].split(",")[1]}, {location[0].split(",")[4]}'<br/>    else:<br/>        result = 'unknown'<br/>    return result</span></pre><pre class="pf oi nz oj bn ok ol bi"><span id="933a" class="om lp iq nz b be on oo l op oq">geolocator = Nominatim(user_agent="strava_exploration_data")<br/>df['location'] = df['start_latlng'].map(get_city_state_from_value)</span></pre><p id="bad0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，创建了一个基于低于5分钟/公里的配速的过滤器，也就是说，创建了一个显示所有平均速度为12公里/小时的比赛的列，并可以在未来的分析中使用该列作为响应变量。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="65c8" class="om lp iq nz b be on oo l op oq">df['pace_sub_5'] = np.where(df['pace']&lt;=5, True, False)<br/>df.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pg"><img src="../Images/b01b698fa28d7d7c10b93facbb030af6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dgn8ownNNiIDEvodtORm_w.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">列pace_sub_5位于最后一个位置的数据集。</figcaption></figure><p id="5b9c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们运行<code class="fe nw nx ny nz b">df.info()</code>和<code class="fe nw nx ny nz b">df.describe().transpose()</code>时，可以获得以下数据:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/0848c3ffb0cb600675ec88842fec7d52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BHkZwtZlDlwh8kJI58Y0yg.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">关于数据集的信息。</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/85854b4f24d3d138e1550e2bec53b6f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kAKKqDDaPbFH7swJkgbN7g.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">数据集描述。</figcaption></figure></div><div class="ab cl or os hu ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="ij ik il im in"><h1 id="3c87" class="lo lp iq bd lq lr oy lt lu lv oz lx ly jw pa jx ma jz pb ka mc kc pc kd me mf bi translated">洞察力</h1><p id="624b" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">现在，有了干净和充分的数据，我们可以进行一系列的分析，试图回答这样的问题:每年注册的数量是多少？根据下面的方框，有可能回答这个问题。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="ef07" class="om lp iq nz b be on oo l op oq">fig = sns.catplot(x='year', hue='type', data=df, kind='count')<br/>fig.fig.suptitle('Exercices by Years')<br/>fig.set_xlabels('Year')<br/>fig.set_ylabels('Effortments')<br/>fig</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/a8d15aa82e8d1b0a446d60e7e79ac928.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*Uee5ucfTAFO6iomVEuxwpA.png"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">每年练习量的柱状图。</figcaption></figure><p id="b02a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">记住，Strava记录不同类型的活动，但在这种情况下，我们将<strong class="kt ir">仅强调跑步</strong>，因此在影响跑步表现的变量(本质上)中，我强调海拔、心率和与速度相关的因素，所以我想将它们与其他领域联系起来。</p><p id="b3c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一项分析是将活动时间与道路的海拔高度相关联，其中可以得出结论，海拔高度往往会根据活动时间甚至根据距离而上升。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="2c82" class="om lp iq nz b be on oo l op oq">runs = df.loc[df['type'] == 'Run']<br/>sns.regplot(x='moving_time_minutes', y = 'elev', data=runs).set_title("Exercice Time vs Elevation")</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/004ffbfb1163f8afb070c4d1ff10d5ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*79FP8MhGtTY_mZYEb3ECzw.png"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">运动时间与海拔高度的回归分布图。</figcaption></figure><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="e85a" class="om lp iq nz b be on oo l op oq">sns.regplot(x='distance', y = 'elev', data=runs).set_title("Distance vs Elevation")</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/7209b82262b8557d7b17258f37f949d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*928loi8wYfyALOA0cIRFyQ.png"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">距离和海拔之间的回归分布图。</figcaption></figure><p id="a8cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但这不应被视为一种规则，因为在一些情况下，无论活动时间或距离如何，都会出现低海拔，这在赛道上进行训练时非常常见。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/848506faceaf6aa4c18d02a1838542d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gcfz9VxfSwm2CFtEQh95hw.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">图形高亮显示以低海拔运行。</figcaption></figure><p id="26a5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于运动时间和距离的另一个观察，值得一提的是，最长和最耗时的训练日通常发生在周日，因为训练的时间更长。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="0e63" class="om lp iq nz b be on oo l op oq">runs.groupby('weekday').mean()['moving_time_minutes'].plot.bar()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/147b9d64ba0e9024c65afce870f5c69c.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*UWCVBCok5kyco_aCkX4FeA.png"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">显示一周中每天锻炼时间的图表。</figcaption></figure><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="edb6" class="om lp iq nz b be on oo l op oq">runs.groupby('weekday').mean()['distance'].plot.bar()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/631c616f628a55e26f3f2e6dbfe949a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*KLDY4zDzJuOyzRqnsaGRxA.png"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">按一周中的每一天显示距离的图表。</figcaption></figure><p id="4e4f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于平均速度(km/h)，可以观察到活动时间越长，平均速度越低，因为疲劳等因素开始影响表现，但当我们观察平均速度与距离的关系时，可以说这种趋势有所增长，即使规模很小。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="23e8" class="om lp iq nz b be on oo l op oq">sns.regplot(x='moving_time_minutes', y = 'avg_speed_kmh', data=runs).set_title("Average Speed vs Moving Time")</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi po"><img src="../Images/07bf293b18528159d8d6750fef03806a.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*MBo-nPbHO4cnhYqkmMRygA.png"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">平均速度和锻炼时间之间的回归分布图。</figcaption></figure><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="5ff3" class="om lp iq nz b be on oo l op oq">sns.regplot(x='distance', y = 'avg_speed_kmh', data=runs).set_title("Average Speed vs Distance")</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/58dcd3dab2525ee45d3a99985d1ba692.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*K1MctkfR_WXRoCuaFgXqIA.png"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">平均速度和距离之间的回归分布图。</figcaption></figure><p id="0a41" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，在我的情况下，值得一提的是，平均速度随着时间的推移而增加，这是训练和所有致力于这项运动的努力的结果，如下图所示。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="f338" class="om lp iq nz b be on oo l op oq">fig = plt.figure()<br/>ax1 = fig.add_subplot(111)<br/><br/>x = np.asarray(runs.start_date)<br/>y = np.asarray(runs.average_speed)<br/><br/>ax1.plot_date(x, y)<br/>ax1.set_title('Average Speed over Time')<br/><br/>x2 = mdates.date2num(x)<br/>z=np.polyfit(x2,y,1)<br/>p=np.poly1d(z)<br/>plt.plot(x,p(x2),'r--')<br/>fig.autofmt_xdate(rotation=45)<br/>fig.tight_layout()<br/>fig.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/cd9742a5b13862bfb139bd7561534f45.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*zGGXCYOjPm83BTQkl_p_8g.png"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">多年平均速度之间的回归分布图。</figcaption></figure></div><div class="ab cl or os hu ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="ij ik il im in"><h1 id="1d3e" class="lo lp iq bd lq lr oy lt lu lv oz lx ly jw pa jx ma jz pb ka mc kc pc kd me mf bi translated">特征选择</h1><p id="32fb" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">至于特征选择，值得一提的是，这是后面机器学习模型应用的重要一步。统计方法可用于选择，这将揭示对于模型的良好性能来说哪些是最重要的特征(或特性)。这样，我们也将能够确认经验引用的特征是否真的好。</p><p id="bc44" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">了解更多关于特征及其如何与响应变量交互的第一种方法是通过相关矩阵，在pandas中使用以下命令可以轻松访问相关矩阵。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="39ad" class="om lp iq nz b be on oo l op oq">corr = runs.corr()<br/>plt.figure(figsize = (12,8))<br/>sns.heatmap(corr, fmt=".2f");<br/>plt.title('Correlation between dataset variables')<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pr"><img src="../Images/5234ab07bef8ae62f4fb90cc8b09bd30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZG3Zl47-62PPpNfuP_jJAg.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">运行数据集变量之间的相关矩阵。</figcaption></figure><p id="0faf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">根据该矩阵，可以定义最接近+1的值具有正相关性，最接近-1的值具有负相关性。</p><p id="d0dd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了继续分析，运行的数据帧将被打乱，从而防止与偏差和数据帧序列学习相关的问题。此外，分类特征以及运行的<code class="fe nw nx ny nz b">id</code>将从分析中移除，因为这些字段对于模型训练无效，并且这些字段不会对预测有所贡献，因为它们是在运行结束后形成的。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="7d00" class="om lp iq nz b be on oo l op oq">runs = runs.sample(frac=1).reset_index(drop=True)<br/><br/>categorical_cols = [col for col in runs.columns if runs[col].dtypes == 'O']<br/><br/>useless_vars = ['id', 'achievement_count', 'kudos_count', 'comment_count', 'pr_count']<br/>tweak_runs = runs.drop(categorical_cols+useless_vars, axis=1)<br/>tweak_runs</span></pre><p id="8862" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此时，响应变量和那些将用于训练的变量将被分离，因此在此操作之后，可以应用使用<code class="fe nw nx ny nz b">chi2</code>(或其他单变量统计测试)的<code class="fe nw nx ny nz b">SelectKBest</code>方法来选择最重要的K特征，以获得良好的模型性能。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="4273" class="om lp iq nz b be on oo l op oq">y = tweak_runs['pace']<br/>X = tweak_runs.drop('pace',1)<br/><br/>best_features = SelectKBest(chi2, k=7).fit_transform(X, y.astype(int))<br/>best_features</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pg"><img src="../Images/160ecc5fe9f9ca4dbcc0135889f7c739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Zo6mUO2nUf_zt48TVUdFA.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">由SelectKBest选择的特性值。</figcaption></figure><p id="4fe1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">特征选择的另一种选择是递归特征消除(RFE)的应用，它训练所选择的模型，并根据特征重要性的缺乏递归地消除特征。但是如上所述，此时必须已经为本次运行选择了模型，因此我们将运行一个模型来执行线性回归，另一个模型来执行随机梯度下降(SGD ),因此这两个模型的响应变量是不同的。</p><p id="059d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">值得一提的是，RFE对于高维数据集来说是一个沉重的方法，所以一个替代方案是使用<a class="ae ln" href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.SelectFromModel.html" rel="noopener ugc nofollow" target="_blank"> SelectFromModel </a>。下面是执行RFE的函数的定义，以及它分别用于线性回归和SGD的情况。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="ebf5" class="om lp iq nz b be on oo l op oq">def get_best_rfe_features(X,y, model):<br/>    rfe = RFE(model, step=0.05).fit(X, y)<br/>    selected_features = [i for i, j in zip(X.columns, rfe.support_) if j]<br/>    return selected_features</span></pre><pre class="pf oi nz oj bn ok ol bi"><span id="7050" class="om lp iq nz b be on oo l op oq">y = tweak_runs['pace']<br/>X = tweak_runs.drop('pace',1)<br/><br/>encoded_y = preprocessing.LabelEncoder().fit_transform(y)<br/>model = LinearRegression()<br/>linear_feats = get_best_rfe_features(X, encoded_y, model)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/022f38ed154ae9c726ab2af25e301cd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6307-MXag0-WGB5_CMQQQQ.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">为回归选择的最佳变量。</figcaption></figure><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="8480" class="om lp iq nz b be on oo l op oq">y = tweak_runs['pace_sub_5']<br/>X = tweak_runs.drop('pace_sub_5',1)<br/><br/>model = SGDClassifier(loss="hinge", penalty="l2", max_iter=5)<br/>class_feats = get_best_rfe_features(X, y, model)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pg"><img src="../Images/2df9cd825f41384ad1853439bf8608ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AMS6Fh5U7yTnUKmKMPkKWw.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">为分类选择的最佳变量。</figcaption></figure><p id="0138" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可以应用的其他方法和组合，例如，改变SGD模型的<code class="fe nw nx ny nz b">loss</code>或者甚至改变RFE中的<code class="fe nw nx ny nz b">steps</code>的数量，但是由于本文的目的不是要深入研究这种方式，所以这些方法的介绍足以为我们带来好的结果</p></div><div class="ab cl or os hu ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="ij ik il im in"><h1 id="1c9e" class="lo lp iq bd lq lr oy lt lu lv oz lx ly jw pa jx ma jz pb ka mc kc pc kd me mf bi translated">机器学习</h1><p id="e0e3" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">在机器学习技术中，我们将在这个项目中使用三种，用于聚类、回归和分类。</p><h2 id="bb99" class="ps lp iq bd lq pt pu dn lu pv pw dp ly la px py ma le pz qa mc li qb qc me qd bi translated">使聚集</h2><p id="7f52" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">在可以实现的机器学习技术中，我们提到一种用于执行聚类的无监督学习领域，称为K-means。因此，在实践中，这种技术会将相似的比赛记录分组。值得一提的是，这种方法是随机的，所以每次执行可能会产生不同的结果。</p><p id="1c50" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要运行K-means，只需将响应变量与其他变量分开，其中我们将使用熊猫函数<code class="fe nw nx ny nz b">get_dummies</code>来利用分类变量，分类变量将被转换为其他虚拟变量。分离变量后，只需选择聚类的数量，然后继续进行K-means类，以及特征数据集中的拟合。为了找出每个样本属于哪个分类，我们将复制原始运行数据集，并向记录中添加一个分类标识符。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="58da" class="om lp iq nz b be on oo l op oq">X = runs.drop('pace',1)<br/>X = pd.get_dummies(X)<br/><br/>model = KMeans(n_clusters=4).fit(X)<br/>clusterin_runs = runs.copy()<br/>clusterin_runs['Cluster'] = model.labels_</span></pre><p id="1c40" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完成后，我们可以查看每个分类中的记录数、平均值、标准偏差、记录数等指标，如下例所示。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="0285" class="om lp iq nz b be on oo l op oq">clustering_runs['Cluster'].value_counts()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/690300c81494344ffee114a3f8887a7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LcLeRT7PIxtfadWvobAbsg.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">集群的划分及其各自的数量。</figcaption></figure><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="fd71" class="om lp iq nz b be on oo l op oq">clustering_runs.groupby('Cluster').mean()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/a527b1a8e2e25943c4bbe89155d98db3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bb3dRpHshCEcNH9sIwHZrQ.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">每个聚类中的平均值。</figcaption></figure><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="36f0" class="om lp iq nz b be on oo l op oq">clustering_runs.groupby('Cluster').std()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qe"><img src="../Images/d7d80466fcfc696307dd1b2eb116a7a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zoLuI135DZlh_Sqv0AY13w.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">每个聚类中的标准差。</figcaption></figure><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="5a97" class="om lp iq nz b be on oo l op oq">clustering_runs[clustering_runs['Cluster'] == 2]</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qf"><img src="../Images/8ddea21bc4de3d8ff0fc53a1411aa77a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-msJxQyrLMuEHVOE8ZMHUw.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">分类2中的记录。</figcaption></figure><h2 id="0c36" class="ps lp iq bd lq pt pu dn lu pv pw dp ly la px py ma le pz qa mc li qb qc me qd bi translated">回归</h2><p id="8d42" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">在进行回归时，模型会在给定一组要素x的情况下预测值y，也就是说，模型会了解哪些值构成了线的方程，从而调整要素图中的几条线并返回两点之间误差最小的线。</p><p id="9e81" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于线性回归的应用，我们将只使用在先前选择中获得并存储在<code class="fe nw nx ny nz b">linear_feats</code>变量中的特征。此外，我们将数据集分为80%用于训练阶段，20%用于测试阶段，以便我们可以在训练阶段之后测量算法的性能。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="60b9" class="om lp iq nz b be on oo l op oq">y = runs['pace']<br/>X = runs[linear_feats]<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)</span></pre><p id="2272" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦划分完成，只需将训练数据集提交给线性回归拟合函数，并执行与测试基础相关的预测。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="b2b2" class="om lp iq nz b be on oo l op oq">model = LinearRegression()<br/>model.fit(X_train,y_train)<br/>y_pred = model.predict(X_test)</span></pre><p id="ae13" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了预测值和实际值，就可以计算均方误差(MSE，或均方误差)来证明模型有多大的误差，也可以通过下面的代码以图形方式查看预测值与实际值的关系。均方误差为0.271。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="9ef8" class="om lp iq nz b be on oo l op oq">print('MSE:', metrics.mean_squared_error(y_test, y_pred))<br/><br/>plt.figure(figsize=(10,10))<br/>plt.scatter(y_test, y_pred, c='crimson')<br/>plt.yscale('log')<br/>plt.xscale('log')<br/><br/>p1 = max(max(y_pred), max(y_test))<br/>p2 = min(min(y_pred), min(y_test))<br/>plt.plot([p1, p2], [p1, p2], 'b-')<br/>plt.xlabel('True Values', fontsize=15)<br/>plt.ylabel('Predictions', fontsize=15)<br/>plt.axis('equal')<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/ffd62357a84f5d68a814ad181cd3daf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*Y1DUBis5wkh7sGWATtrr-w.png"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">MSE值以及预测值和实际值分布图。</figcaption></figure><p id="91b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">举例来说，假设我在2022年以1488秒(24.8分钟)跑完5公里，平均速度为4米/秒(14.4公里/小时)，最大速度为5.6米/秒(20.16公里/小时)，节奏为84，配速低于5，我的配速预计等于<strong class="kt ir"> 4.1752分钟/公里</strong>。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="df00" class="om lp iq nz b be on oo l op oq">model.predict(<br/>    pd.DataFrame(data={<br/>        'moving_time': 1488,<br/>        'average_speed': 4.0,<br/>        'max_speed': 5.6,<br/>        'average_cadence': 84.0,<br/>        'moving_time_minutes': 24.8,<br/>        'distance_km': 5.0,<br/>        'avg_speed_kmh': 14.4,<br/>        'max_speed_kmh': 20.16 ,<br/>        'year': 2022,<br/>        'pace_sub_5': True},<br/>    index=[0]<br/>    )<br/>)</span></pre><h2 id="d6a8" class="ps lp iq bd lq pt pu dn lu pv pw dp ly la px py ma le pz qa mc li qb qc me qd bi translated">分类</h2><p id="d631" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">反过来，分类用于区分类别，也就是说，响应变量具有标记样本的特征，因此我们可以根据其特征来预测给定样本将接受哪个标记。</p><p id="6a36" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了执行此操作，我们将执行与回归阶段类似的操作，将基础分为80%用于训练，20%用于测试，以及具有推荐特征和响应变量的样本划分，在这种情况下，响应变量将是二元的，表示比赛速度是否低于5。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="2810" class="om lp iq nz b be on oo l op oq">y = runs['pace_sub_5']<br/>X = runs[class_feats]<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)</span></pre><p id="bcc8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在进行了基底的划分之后，我们将拟合来自SKLearn库的<code class="fe nw nx ny nz b">SGDClassifier</code>分类器，该分类器使用随机梯度下降以迭代方式进行参数优化来实现线性模型的正则化，旨在最小化感兴趣的函数。在下面的代码片段中，预测也是针对测试数据集执行的。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="e58d" class="om lp iq nz b be on oo l op oq">model = SGDClassifier()<br/>model.fit(X_train,y_train)<br/>y_pred = model.predict(X_test)</span></pre><p id="4b8a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与回归不同，对于分类系统，我们可以使用其他指标，如精度，这是正确精度与执行的总精度之间的比率，在我们的情况下是95.12%。要了解真阳性(实际值为正，预测为正)、真阴性(实际值为负，预测为负)、假阳性(实际值为负，预测为正)和假阴性(实际值为正，预测为负)，我们可以开发一个混淆矩阵，如下面的代码所示。</p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="bc74" class="om lp iq nz b be on oo l op oq">print('Accuracy:', accuracy_score(y_test, y_pred))<br/><br/>cm = confusion_matrix(y_test, y_pred, labels=model.classes_)<br/>disp = ConfusionMatrixDisplay(confusion_matrix=cm,display_labels=model.classes_)<br/><br/>disp.plot()<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qh"><img src="../Images/b13a81723ae75bdd70abbeada9bdb005.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*PhWXCbz6GEwjuJ_Szo_Opw.png"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">精度值和混淆矩阵。</figcaption></figure><p id="0619" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，为了举例说明实际情况，假设我跑5000米，总活动时间等于1488秒(24.8分钟)，运动时间为1440秒，高度增益为25米，高度差为10米(最大高度为547米，最小高度为237米)，最大速度为25公里/小时，最大速度为210 bpm，<strong class="kt ir">我可以以低于5分钟/公里的平均配速进行比赛。</strong></p><pre class="kg kh ki kj gt oi nz oj bn ok ol bi"><span id="be3c" class="om lp iq nz b be on oo l op oq">model.predict(<br/>    pd.DataFrame(data={<br/>        'distance': 5000 ,<br/>        'moving_time': 1440,<br/>        'elapsed_time': 1488,<br/>        'total_elevation_gain': 25,<br/>        'max_heartrate': 210,<br/>        'elev_high': 547,<br/>        'elev_low': 537,<br/>        'moving_time_minutes': 24.8,<br/>        'max_speed_kmh': 25,<br/>        'elev': 10<br/>    },<br/>        index=[0]<br/>    )<br/>)</span></pre></div><div class="ab cl or os hu ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="ij ik il im in"><h1 id="b192" class="lo lp iq bd lq lr oy lt lu lv oz lx ly jw pa jx ma jz pb ka mc kc pc kd me mf bi translated">结论</h1><p id="67cd" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">当数据存在时，探索数据和应用不同类型的模型的可能性是无数的。在本文中，有可能对其中一些进行测试，并获得与比赛的见解和预测相关的出色结果，需要考虑的一点是，数据基于单个运动员，即，为了使结论更具一般性，需要与组成数据集的运动员相关的更大的多样性，但是，如果遵循初始步骤，每个运动员都可能有与他们自己的数据相关的预测和想法。</p><p id="d291" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您想要检查所使用的测试和代码，请随意访问下面的存储库:</p><div class="mz na gp gr nb nc"><a href="https://github.com/Lucs1590/strava-analysis" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">GitHub-lucs 1590/strava-analysis:使用strava进行个人分析并练习数据…</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">使用strava进行个人分析并练习数据科学家技能。更新环境上的strava代码。运行…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">github.com</p></div></div><div class="nl l"><div class="qi l nn no np nl nq kp nc"/></div></div></a></div><h1 id="e218" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">参考</h1><p id="e92b" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">[1]拉马丁，S. <a class="ae ln" href="https://medium.com/@lamartine_sl/regress%C3%A3o-linear-com-sklearn-modelo-de-previs%C3%A3o-de-custos-com-plano-de-sa%C3%BAde-5e963e590f4c" rel="noopener">线性回归研究:概念与应用</a> (2020)。中等。</p><p id="1035" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">[2] Stojiljkovi，M. <a class="ae ln" href="https://realpython.com/gradient-descent-algorithm-python/" rel="noopener ugc nofollow" target="_blank">用Python和NumPy实现的随机梯度下降算法</a> (2020)，Real Python。</p><p id="19c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">[3] Vasconcellos，p .<a class="ae ln" href="https://paulovasconcellos.com.br/como-selecionar-as-melhores-features-para-seu-modelo-de-machine-learning-2e9df83d062a" rel="noopener ugc nofollow" target="_blank">Como sele cionar as melhores features para seu modelo de Machine Learning</a>(2019)，Paulo Vasconcellos-Cientista de Dados Brasileiro，</p></div><div class="ab cl or os hu ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="ij ik il im in"><h1 id="c8d1" class="lo lp iq bd lq lr oy lt lu lv oz lx ly jw pa jx ma jz pb ka mc kc pc kd me mf bi translated">分级编码</h1><p id="54ae" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="0e6d" class="mg mh iq kt b ku kv kx ky la qj le qk li ql lm mn mo mp mq bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="7fbe" class="mg mh iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">📰查看<a class="ae ln" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="a075" class="mg mh iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">🔔关注我们:<a class="ae ln" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae ln" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae ln" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="6140" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">🚀👉<a class="ae ln" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>