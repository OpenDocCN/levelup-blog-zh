<html>
<head>
<title>Automate Your Go Applications With Gradle &amp; Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Gradle &amp; Docker自动化您的Go应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/automate-your-go-applications-with-gradle-docker-3c4aa4ddd9bb?source=collection_archive---------10-----------------------#2021-04-07">https://levelup.gitconnected.com/automate-your-go-applications-with-gradle-docker-3c4aa4ddd9bb?source=collection_archive---------10-----------------------#2021-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1209" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用构建自动化和容器化简化部署。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/339e9cf4494d8bc25aadc15868be433e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X3ok7w_ExXtH6TSt"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://images.unsplash.com/photo-1580028468862-6895981d7a67?ixlib=rb-1.2.1&amp;ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;auto=format&amp;fit=crop&amp;w=1950&amp;q=80" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="ec03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">在开发软件解决方案时，对速度和效率的需求是一致的。不仅您的应用程序需要完美地编译，而且今天的现代技术空间已经迫使“它在我的机器上工作”成为一种粗俗的说法。今天的应用程序几乎总是需要容器化和可复制的形式，这样你的团队和你的客户就可以随时随地与你的产品进行交互。</p><p id="2f00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将介绍使用Gradle为Go应用程序自动构建Docker的基础知识。我将介绍每种技术的基础知识，以便更好地了解它们是如何相互作用的。</p><p id="607a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来编码吧！</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="9e20" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">一个基本的围棋服务器</h1><p id="dd9d" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">我非常喜欢simple Go在设置一个简单的服务器时所做的事情——我们只用22行代码就可以做到！这里我们定义了我们的<code class="fe ni nj nk nl b">main</code>函数，首先初始化一个新的<code class="fe ni nj nk nl b">http.HandleFunc()</code>方法，该方法为一个<code class="fe ni nj nk nl b">handler</code>获取一个路由和一个函数。所以当我们点击默认的<code class="fe ni nj nk nl b">"/"</code>路径时，我们将调用<code class="fe ni nj nk nl b">handler()</code>方法，该方法给我们的<code class="fe ni nj nk nl b">http.ResponseWriter</code>写一个编程笑话。然后我们只需调用端口<code class="fe ni nj nk nl b">8080</code>上的<code class="fe ni nj nk nl b">http.ListenAndServe()</code>，然后嘣，我们的服务器就准备好了！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="b182" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">准备出发的文件</h1><p id="4320" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">对于一个简单的Go程序，我们可以使用一个简单的docker文件。<strong class="lb iu"> Docker是一个虚拟化平台</strong>，<strong class="lb iu">将您的应用程序放在最小化的环境中，称为容器。Docker containers不像虚拟机那样包含一个完整的操作系统，而是引导你的应用程序只运行最基本的必需品。这减少了开销，创建了可重用的Docker容器，并大大提高了部署过程的速度。以下是docker如何最小化您的应用程序的可视化表示:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/225cbea898373725f7ada34cca9365f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VfZGV86b5sre9kwg.jpg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">虚拟机(左)与容器基础架构(右)。来源:<a class="ae ky" href="https://www.infoworld.com/article/3204171/what-is-docker-the-spark-for-the-container-revolution.html" rel="noopener ugc nofollow" target="_blank">信息世界</a></figcaption></figure><p id="9b08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<strong class="lb iu"> Docker容器</strong>是应用程序的<strong class="lb iu">运行实例。</strong>为了执行Docker容器的实例，<strong class="lb iu">您首先需要一个Docker映像</strong>。Docker映像定义了要构建的应用程序的基础结构。您可以从一个Docker容器中运行多个容器实例。要生成Docker图像，<strong class="lb iu">您需要一个相应的Docker文件。</strong>这是一个可以定义容器规格的文件。</p><p id="7a5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们将用于Go服务器应用程序的<code class="fe ni nj nk nl b">Dockerfile</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ab22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第1行，我们声明了将要使用的Docker图像的类型。这里我们说的是获取最新版本的<a class="ae ky" href="https://hub.docker.com/_/golang" rel="noopener ugc nofollow" target="_blank"> Go Docker图片</a>。在第3行，我们将带有服务器逻辑的<code class="fe ni nj nk nl b">main.go</code>文件复制到Docker映像中。然后在第5行我们运行命令<code class="fe ni nj nk nl b">go build main.go</code>来获得我们的可执行Go文件。最后，我们运行命令<code class="fe ni nj nk nl b">"./main"</code>来运行Go可执行文件。<code class="fe ni nj nk nl b">RUN</code>和<code class="fe ni nj nk nl b">CMD</code>的区别在于<code class="fe ni nj nk nl b">RUN</code>指令是在实例化图像之前<strong class="lb iu">使用的，而<code class="fe ni nj nk nl b">CMD</code>指令是在</strong>容器被实例化之后<strong class="lb iu">运行的。如果一个Go可执行文件还没有构建好，你就不会想去运行它。</strong></p><blockquote class="np nq nr"><p id="45ec" class="kz la ns lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated"><em class="it">现在，</em> <strong class="lb iu"> <em class="it">通常情况下</em> </strong> <em class="it">您需要完成</em> <strong class="lb iu"> <em class="it">附加步骤，创建您的Docker映像，定义运行容器的端口，并部署容器本身。</em> </strong> <em class="it">这还不包括您是否想为构建版本或推送至Docker Hub等外部仓库的映像添加标签。</em></p><p id="659f" class="kz la ns lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated">这就是格雷尔的用武之地！</p></blockquote></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="83e3" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">使用Gradle实现自动化部署</h1><p id="98f0" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">Gradle是一个构建自动化工具，可用于定义使您的项目可重复的过程。虽然Docker已经增加了一层可复制性和容器化，但是您仍然需要处理Docker映像和容器的配置和部署。Gradle提供的插件可以以可复制的格式扩展您的项目的功能。然后，您可以定义Gradle任务来让这些插件工作。</p><p id="f419" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步是在你的应用程序的根目录下启动你的项目。首先你需要<a class="ae ky" href="https://gradle.org/install/" rel="noopener ugc nofollow" target="_blank">安装Gradle </a>，然后你可以简单地使用命令<code class="fe ni nj nk nl b">gradle init</code>启动Gradle。对于这个例子，您可以在配置选项上点击enter，因为我们只需要默认设置就可以了。</p><pre class="kj kk kl km gt nw nl nx ny aw nz bi"><span id="fde9" class="oa mm it nl b gy ob oc l od oe">$ gradle init</span><span id="7b0c" class="oa mm it nl b gy of oc l od oe">Select type of project to generate:<br/>  1: basic<br/>  2: application<br/>  3: library<br/>  4: Gradle plugin<br/>Enter selection (default: basic) [1..4]</span><span id="524f" class="oa mm it nl b gy of oc l od oe">Select build script DSL:<br/>  1: Groovy<br/>  2: Kotlin<br/>Enter selection (default: Groovy) [1..2]</span><span id="b05b" class="oa mm it nl b gy of oc l od oe">Project name (default: test_gradle):</span><span id="86db" class="oa mm it nl b gy of oc l od oe">&gt; Task :init<br/>Get more help with your project: Learn more about Gradle by exploring our samples at <a class="ae ky" href="https://docs.gradle.org/6.8.3/samples" rel="noopener ugc nofollow" target="_blank">https://docs.gradle.org/6.8.3/samples</a></span><span id="5207" class="oa mm it nl b gy of oc l od oe">BUILD SUCCESSFUL in 7s<br/>2 actionable tasks: 2 executed</span></pre><p id="7202" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在我们文件的根目录中，我们可以创建<code class="fe ni nj nk nl b">build.gradle</code>文件，在这里我们定义Gradle插件和任务。以下是我们示例的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="48e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们定义我们希望应用程序使用的<code class="fe ni nj nk nl b">plugins</code>。这里我们使用了<a class="ae ky" href="https://github.com/palantir/gradle-docker" rel="noopener ugc nofollow" target="_blank"> Palantir Gradle插件</a>来为我们的项目添加构建自动化。第2行的第一个插件负责构建我们的Docker图像，第二个插件自动将图像作为容器运行。</p><p id="cc63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在第6行定义应用程序的版本。然后我们定义我们的第一个任务<code class="fe ni nj nk nl b">docker</code>，在这里我们可以指定项目的名称，包括项目版本，并在我们的映像中包含任何我们想要的文件。在这种情况下，我们只需要我们的Go服务器<code class="fe ni nj nk nl b">main.go</code>。</p><p id="ff23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个任务<code class="fe ni nj nk nl b">dockerRun</code>定义了要运行的Docker映像的名称，这与我们在<code class="fe ni nj nk nl b">docker</code>构建任务中定义的名称相同。然后我们定义要使用的端口，其中第一个端口与容器将要运行的端口相匹配。第二个端口是Docker容器中的内部应用程序正在运行的端口。最后，<code class="fe ni nj nk nl b">clean true</code>语法很有用，因为一旦你停止了它，它会自动删除容器。</p><p id="e99a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以运行这两个任务来构建docker映像，并使用Palantir Gradle插件无缝地运行Docker容器。我们可以使用Windows的<code class="fe ni nj nk nl b">gradle.bat</code>或Linux/Mac的<code class="fe ni nj nk nl b">gradlew</code>来实现。</p><pre class="kj kk kl km gt nw nl nx ny aw nz bi"><span id="8c88" class="oa mm it nl b gy ob oc l od oe">$ ./gradlew docker</span><span id="0bcf" class="oa mm it nl b gy of oc l od oe">&gt; Task :docker<br/>#1 [internal] load build definition from Dockerfile<br/>#1 sha256:38360e6e661fcb820486172d0c310d8bf39798e04b341c1be678deca41c15464<br/>#1 transferring dockerfile: 115B 0.0s done<br/>#1 DONE 0.0s</span><span id="eb00" class="oa mm it nl b gy of oc l od oe">..........</span><span id="5b0b" class="oa mm it nl b gy of oc l od oe">BUILD SUCCESSFUL in 2s<br/>3 actionable tasks: 3 executed</span></pre><p id="32db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将Docker映像作为容器运行，我们可以调用第二个Gradle任务。</p><pre class="kj kk kl km gt nw nl nx ny aw nz bi"><span id="561a" class="oa mm it nl b gy ob oc l od oe">$ ./gradlew dockerRun</span><span id="5d39" class="oa mm it nl b gy of oc l od oe">&gt; Task :dockerRun<br/>c453511861afeeb38ce1c67d730fdf12f951e1f75f9cb2f287b69c7e93b55130</span><span id="a118" class="oa mm it nl b gy of oc l od oe">BUILD SUCCESSFUL in 1s<br/>1 actionable task: 1 executed</span></pre><p id="4c3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用<code class="fe ni nj nk nl b">curl</code>点击端口<code class="fe ni nj nk nl b">8081</code>，我们会得到一个小小的编程笑话。</p><pre class="kj kk kl km gt nw nl nx ny aw nz bi"><span id="4c47" class="oa mm it nl b gy ob oc l od oe">$ curl localhost:8081<br/>Why did the programmer quit his job?<br/>Because he didn't get arrays.</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og nn l"/></div></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="de32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这个教程，并学到一些有用的东西。如果你觉得这篇文章有趣或者想了解更多，我鼓励你在下面留下评论。感谢阅读！</p></div></div>    
</body>
</html>