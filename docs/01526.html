<html>
<head>
<title>JWT Architecture for Modern Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代应用的JWT架构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/secure-jwts-with-backend-for-frontend-9b7611ad2afb?source=collection_archive---------3-----------------------#2020-01-10">https://levelup.gitconnected.com/secure-jwts-with-backend-for-frontend-9b7611ad2afb?source=collection_archive---------3-----------------------#2020-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="599b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用后端保护前端的jwt</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/28a81903b2585b6f7c55b632e722b70a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JIIy55Yc3N2ZQJpetelssQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">身份验证服务、GraphQL API和Web客户端之间前端的后端概述。</figcaption></figure><p id="4e78" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我和我的团队开始在IBM Watson Media开发基于React的web应用程序。我们选择了<a class="ae lr" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>作为一个中端框架，为开箱即用的生产应用程序提供了一个出色的构建管道。我们最近面临两个难以解决的问题:</p><ol class=""><li id="48ed" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">以安全的方式使用jwt进行身份验证。</li><li id="8f48" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">构建我们的Next.js应用程序一次，并通过运行时配置在不同的环境(<em class="mg"> dev/staging/beta/prod </em>)中重用它。建议为特定环境构建(在构建时传递配置)，但是我们希望避免为每个应用程序版本构建四个映像。</li></ol><p id="825a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">幸运的是，有一篇关于JWT最佳实践的精彩文章。它建议在HTTP主体中接收访问令牌，在一个<code class="fe mh mi mj mk b">HttpOnly</code>，<code class="fe mh mi mj mk b">secure</code> cookie中刷新令牌，酷！Cookie处理可以在认证服务中实现，但是cookie只在浏览器中可用。非基于浏览器的客户机不想摆弄cookies，在HTTP主体中接收和发送这两个令牌对它们来说要简单得多。此外，我们希望避免处理<code class="fe mh mi mj mk b">CORS</code>策略和<code class="fe mh mi mj mk b">CSRF tokens</code>来减轻认证服务的<code class="fe mh mi mj mk b">CSRF</code>攻击面(在HTTP主体中发送令牌而不是cookies =没有<code class="fe mh mi mj mk b">CSRF</code>攻击面)。</p><p id="e023" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们为我们的前端<em class="mg">(从现在开始的BFF)</em>引入了一个处理cookies的后端。Next.js支持自定义服务器，所以非常简单！这是同一个域上的同一个服务，服务于我们的静态React web应用程序，因此我们不需要允许<code class="fe mh mi mj mk b">CORS</code> ( <code class="fe mh mi mj mk b">SOP</code>就足够了)，我们可以为我们的cookie启用<code class="fe mh mi mj mk b">SameSite=strict</code>属性。如果用户的浏览器不支持<code class="fe mh mi mj mk b">SameSite</code> cookie属性，恶意站点仍然可以发送请求(因此旋转或清除<code class="fe mh mi mj mk b">refreshToken</code>，但是无法从HTTP响应中读取返回的<code class="fe mh mi mj mk b">accessToken</code>和<code class="fe mh mi mj mk b">refreshToken</code>(因为没有定义<code class="fe mh mi mj mk b">CORS</code>头)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/a75eb390a3dbe1e8dca3b1fbe0e1c4f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SJWEBYv-MK3oDsaqbzohTA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">带有API处理程序和NEXT的Express server。JS作为后备。</figcaption></figure><p id="a07f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们创建一个<code class="fe mh mi mj mk b">express</code>服务器，附加API处理程序和Next.js作为后备处理程序。这实际上解决了我们正在努力解决的两个问题。</p><ol class=""><li id="580a" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">我们有安全的JWT处理。认证服务不需要处理cookies，我们的BFF需要！</li><li id="5e51" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">所有API调用都在我们站点的域中代理。React可以调用相对API URLs，运行时可配置的BFF会将其代理给适当的服务(这些实际上是Kubernetes集群中的微服务，因此开销非常小)。</li></ol><h1 id="1e1a" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">注册</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/77d2d8ef13025f5a89f7673d06b42d24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S8GY5y-XPOFHLuDD3gCUZQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">节点上的代理/API/v1/登录。JS BFF。</figcaption></figure><p id="95ff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我解释一下认证流程:</p><ol class=""><li id="ecd8" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">我们的<strong class="kx ir"> web客户端</strong>通过相对<code class="fe mh mi mj mk b">/api/v1/login</code>路径将HTTP主体中的凭证发送给我们的<strong class="kx ir"> BFF </strong>。</li><li id="3f7d" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">BFF 将该请求转发给<strong class="kx ir">授权服务</strong>而不做修改。</li><li id="84b8" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><strong class="kx ir"> Auth service </strong>在HTTP正文中用<code class="fe mh mi mj mk b">accessToken</code>、<code class="fe mh mi mj mk b">refreshToken</code>和<code class="fe mh mi mj mk b">refreshAge</code>响应。</li><li id="73ed" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><strong class="kx ir"> BFF </strong>从年龄为<code class="fe mh mi mj mk b">refreshAge</code>的<code class="fe mh mi mj mk b">refreshToken</code>创建一个<code class="fe mh mi mj mk b">HttpOnly</code> cookie。然后它响应<strong class="kx ir"> web客户端</strong>设置这个cookie并在HTTP主体中返回<code class="fe mh mi mj mk b">accessToken</code>。</li></ol><p id="0848" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将这种想法转化为代码，我们在登录处理程序中得到类似的东西:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/af4d0e1af5142090c687ce7b22f786d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q6N4BZr9nKLrgVvgWswN1g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">BFF的/API/v1/登录处理程序实现概要。</figcaption></figure><h1 id="5657" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">GraphQL API</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/1f0354a3bd7c044912679c7ac10075e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IcLHPZ9lOS5dhFTSrIsYRg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">节点上的代理/api/v1/graphql。JS BFF。</figcaption></figure><p id="5687" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">代理一个GraphQL请求非常简单，我们不加修改就把它转发给适当的API。不直接进入GraphqlQL API的唯一原因是我上面提到的Next.js的运行时配置问题(我们不能在运行时传递API的URL，只能在构建时传递)。</p><p id="c825" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">相应代码的摘要:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/9b70f4e4fa3b15388c1efb5c97529d22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N80NQTnBptWnVLYBhMIP9A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">BFF的/api/v1/graphql处理程序实现概要。</figcaption></figure><h1 id="c9fe" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">令牌刷新</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/4aa56b64326d521aa42eba00210c9919.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WyG7Xkag2BRiSKKCJHU2sg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">节点上的代理/API/v1/刷新。JS BFF。</figcaption></figure><p id="2d32" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">刷新令牌流类似于身份验证流:</p><ol class=""><li id="4737" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">我们的<strong class="kx ir"> web客户端</strong>通过相对<code class="fe mh mi mj mk b">/api/v1/token/refresh</code>路径将<code class="fe mh mi mj mk b">refreshToken</code>通过<code class="fe mh mi mj mk b">HttpOnly</code> cookie发送到我们的<strong class="kx ir"> BFF </strong>。</li><li id="0d46" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><strong class="kx ir"> BFF </strong>从cookie中提取<code class="fe mh mi mj mk b">refreshToken</code>并转发给HTTP主体中的<strong class="kx ir"> Auth服务</strong>。</li><li id="45a9" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><strong class="kx ir">认证服务</strong>在HTTP主体中用新的<code class="fe mh mi mj mk b">accessToken</code>、<code class="fe mh mi mj mk b">refreshToken</code>和<code class="fe mh mi mj mk b">refreshAge</code>进行响应。</li><li id="3f64" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><strong class="kx ir"> BFF </strong>从年龄为<code class="fe mh mi mj mk b">refreshAge</code>的<code class="fe mh mi mj mk b">refreshToken</code>创建一个<code class="fe mh mi mj mk b">HttpOnly</code> cookie。然后它响应<strong class="kx ir"> web客户端</strong>设置这个cookie并在HTTP主体中返回<code class="fe mh mi mj mk b">accessToken</code>。</li></ol><p id="b9ab" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">相应代码的摘要:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/5c2e76e0008570364b1479b9a9560a67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1k7N9bVd4X7dFHT1Qw4Fng.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">BFF的/api/v1/token/refresh处理程序实现概要。</figcaption></figure><h1 id="ce78" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">令牌失效</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/7ee8c641d95e5a4d5af2e90c90170fee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nBV1Bk4L_zaP3jHi5GuKAA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">节点上的代理/api/v1/invalidate。JS BFF。</figcaption></figure><p id="dda1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">auth服务将<code class="fe mh mi mj mk b">refreshToken</code>保存在存储中，供一次性使用和可能的失效。因此，我们必须从Auth service的<code class="fe mh mi mj mk b">refreshToken</code>存储中删除它，并从浏览器cookie中清除它(无论如何，它都是无效的，但我们最好完全删除它)。</p><ol class=""><li id="0922" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">我们的<strong class="kx ir"> web客户端</strong>通过<code class="fe mh mi mj mk b">HttpOnly</code> cookie发送<code class="fe mh mi mj mk b">refreshToken</code>到我们的<strong class="kx ir"> BFF </strong>通过相对<code class="fe mh mi mj mk b">/api/v1/invalidate</code>路径。</li><li id="a4a5" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><strong class="kx ir"> BFF </strong>从cookie中提取<code class="fe mh mi mj mk b">refreshToken</code>并转发给HTTP主体中的<strong class="kx ir"> Auth service </strong>。</li><li id="da74" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><strong class="kx ir">授权服务</strong>从商店中清除<code class="fe mh mi mj mk b">refreshToken</code>。</li><li id="def8" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><strong class="kx ir"> BFF </strong>从浏览器cookie中清除<code class="fe mh mi mj mk b">refreshToken</code>。</li></ol><p id="a076" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">相应代码的摘要:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/a87669885bd816ad20f304b6d4efa94f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V51dFqUGjTrsc3NP4-8bFQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">BFF的/api/v1/token/invalidate处理程序实现概要。</figcaption></figure><h1 id="c651" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">结论</h1><p id="f4bb" class="pw-post-body-paragraph kv kw iq kx b ky ng jr la lb nh ju ld le ni lg lh li nj lk ll lm nk lo lp lq ij bi translated">前端的专用后端给了你客户端很大的灵活性。到目前为止，我很喜欢这个设置，请在评论中告诉我你对它的看法！</p><p id="0eeb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另外，如果你喜欢这篇文章，请考虑分享它。</p><p id="f147" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在这里找到BFF的例子来源。</p></div></div>    
</body>
</html>