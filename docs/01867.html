<html>
<head>
<title>More About Routing with Express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于使用Express路由的更多信息</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/more-about-routing-with-express-9e0ce012bccc?source=collection_archive---------15-----------------------#2020-02-03">https://levelup.gitconnected.com/more-about-routing-with-express-9e0ce012bccc?source=collection_archive---------15-----------------------#2020-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6a2d84f861a904edfab3813b46d19921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b4radUQHCUPojlP8"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">马特·邓肯在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9837" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">路由是后端应用程序最重要的部分。Express允许我们轻松地将URL路由到我们的路由处理程序代码。</p><p id="08a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将了解如何使用Express创建不同种类的路线。</p><h1 id="f976" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">处理所有请求</h1><p id="975e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">app.all</code>方法来处理所有请求方法。要使用它，我们可以编写如下内容:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0612" class="mt lf it mk b gy mu mv l mw mx">const express = require('express')<br/>const app = express()</span><span id="feb9" class="mt lf it mk b gy my mv l mw mx">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="b8fc" class="mt lf it mk b gy my mv l mw mx">app.all('*', (req, res, next) =&gt; {<br/>  console.log('route called');<br/>  next();<br/>})</span><span id="2fce" class="mt lf it mk b gy my mv l mw mx">app.get('/', (req, res) =&gt; {<br/>  res.send('hi');<br/>})</span><span id="f108" class="mt lf it mk b gy my mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="37ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当发送任何方法或URL时，将调用上面的<code class="fe mh mi mj mk b">app.all</code>调用。它将记录<code class="fe mh mi mj mk b">'route called'</code>，然后调用<code class="fe mh mi mj mk b">next</code>来调用该路线的特定路线处理程序。</p><h1 id="a93b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">非字母符号</h1><p id="944f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Express可以匹配带有非字母符号的路线。例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="231c" class="mt lf it mk b gy mu mv l mw mx">const express = require('express')<br/>const app = express()</span><span id="d87b" class="mt lf it mk b gy my mv l mw mx">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="94b8" class="mt lf it mk b gy my mv l mw mx">app.get('/foo.bar', (req, res) =&gt; {<br/>  res.send('hi');<br/>})</span><span id="dd36" class="mt lf it mk b gy my mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="4376" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们向<code class="fe mh mi mj mk b">foo.bar</code>发出GET请求时，我们得到<code class="fe mh mi mj mk b">hi</code>。</p><h1 id="ac83" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">特殊字符</h1><h2 id="60e7" class="mt lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">可选字符</h2><p id="fb88" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果<code class="fe mh mi mj mk b">?</code>在URL路径中，那么它被认为是可选字符。比如<code class="fe mh mi mj mk b">ab?c</code>匹配<code class="fe mh mi mj mk b">ac</code>或者<code class="fe mh mi mj mk b">abc</code>。</p><p id="30f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1533" class="mt lf it mk b gy mu mv l mw mx">const express = require('express')<br/>const app = express()</span><span id="7638" class="mt lf it mk b gy my mv l mw mx">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="9160" class="mt lf it mk b gy my mv l mw mx">app.get('/ab?c', (req, res) =&gt; {<br/>  res.send('hi');<br/>})</span><span id="7b4f" class="mt lf it mk b gy my mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="d43f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后当我们向<code class="fe mh mi mj mk b">/ac</code>或<code class="fe mh mi mj mk b">/abc</code>发出请求时，我们得到<code class="fe mh mi mj mk b">hi</code>。</p><h2 id="22f1" class="mt lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">一个或多个字符</h2><p id="8b71" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果一个URL有一个<code class="fe mh mi mj mk b">+</code>符号，那么它将匹配它前面的一个或多个字符。</p><p id="85d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5940" class="mt lf it mk b gy mu mv l mw mx">const express = require('express')<br/>const app = express()</span><span id="cbdb" class="mt lf it mk b gy my mv l mw mx">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="3423" class="mt lf it mk b gy my mv l mw mx">app.get('/ab+c', (req, res) =&gt; {<br/>  res.send('hi');<br/>})</span><span id="ad11" class="mt lf it mk b gy my mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="06ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后当向<code class="fe mh mi mj mk b">/abc</code>、<code class="fe mh mi mj mk b">/abbc</code>、<code class="fe mh mi mj mk b">/abbbc</code>等发出请求时，我们会得到<code class="fe mh mi mj mk b">hi</code>。</p><h2 id="1896" class="mt lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">通配符</h2><p id="f415" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">URL中的<code class="fe mh mi mj mk b">*</code>是通配符。</p><p id="267a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="db56" class="mt lf it mk b gy mu mv l mw mx">const express = require('express')<br/>const app = express()</span><span id="30ef" class="mt lf it mk b gy my mv l mw mx">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="59ff" class="mt lf it mk b gy my mv l mw mx">app.get('/ab*c', (req, res) =&gt; {<br/>  res.send('hi');<br/>})</span><span id="893d" class="mt lf it mk b gy my mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="033b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们在URL中的<code class="fe mh mi mj mk b">ab</code>和<code class="fe mh mi mj mk b">c</code>之间输入任何内容，并得到<code class="fe mh mi mj mk b">hi</code>响应。</p><h2 id="cc02" class="mt lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">可选字符组</h2><p id="a0ea" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果一个字符组用括号括起来，并且后面有一个<code class="fe mh mi mj mk b">?</code>，那么它就是可选的。</p><p id="badd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="abb0" class="mt lf it mk b gy mu mv l mw mx">const express = require('express')<br/>const app = express()</span><span id="37c2" class="mt lf it mk b gy my mv l mw mx">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="4d73" class="mt lf it mk b gy my mv l mw mx">app.get('/ab(cd)?ef', (req, res) =&gt; {<br/>  res.send('hi');<br/>})</span><span id="e589" class="mt lf it mk b gy my mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="6048" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后当我们到<code class="fe mh mi mj mk b">/abcdef</code>或<code class="fe mh mi mj mk b">/abef</code>时，我们得到<code class="fe mh mi mj mk b">hi</code>。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/a246c259bca272b4e734b0bc568820e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8-HgaoX8Lajnr1eJ"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Patrick Brinksma 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="1c81" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">正则表达式</h1><p id="f626" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们也可以使用正则表达式作为路由路径。例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a408" class="mt lf it mk b gy mu mv l mw mx">const express = require('express')<br/>const app = express()</span><span id="ba63" class="mt lf it mk b gy my mv l mw mx">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="d449" class="mt lf it mk b gy my mv l mw mx">app.get(/\/a/, (req, res) =&gt; {<br/>  res.send('hi');<br/>})</span><span id="fcf7" class="mt lf it mk b gy my mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="0b3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后当我们向<code class="fe mh mi mj mk b">/a</code>发出请求时，我们得到<code class="fe mh mi mj mk b">hi</code>。</p><p id="eadb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们用以<code class="fe mh mi mj mk b">foo</code>结尾的路径发出任何请求时，为了得到<code class="fe mh mi mj mk b">hi</code>，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="19ac" class="mt lf it mk b gy mu mv l mw mx">const express = require('express')<br/>const app = express()</span><span id="04f3" class="mt lf it mk b gy my mv l mw mx">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="b647" class="mt lf it mk b gy my mv l mw mx">app.get(/\/.*foo$/, (req, res) =&gt; {<br/>  res.send('hi');<br/>})</span><span id="3038" class="mt lf it mk b gy my mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));</span></pre><h1 id="2479" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">路线参数</h1><p id="a2c5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过在参数的键名前写一个冒号来指定参数。</p><p id="306e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d061" class="mt lf it mk b gy mu mv l mw mx">const express = require('express')<br/>const app = express()</span><span id="1ccb" class="mt lf it mk b gy my mv l mw mx">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="2e91" class="mt lf it mk b gy my mv l mw mx">app.get('/:name/:age', (req, res) =&gt; {<br/>  res.send(req.params);<br/>})</span><span id="5aa1" class="mt lf it mk b gy my mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="3da8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到以下响应:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4ea2" class="mt lf it mk b gy mu mv l mw mx">{"name":"Mary","age":"10"}</span></pre><p id="8188" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">:name</code>和<code class="fe mh mi mj mk b">:age</code>被解释为路线占位符。<code class="fe mh mi mj mk b">req.params</code>将它们用作不带冒号的键。那么无论在占位符的位置设置什么，都将是相应的值。</p><h1 id="cd38" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">路线处理程序</h1><p id="8a69" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">上面<code class="fe mh mi mj mk b">app.get</code>的第二个参数中的回调是路由处理程序。通过分别用<code class="fe mh mi mj mk b">app.post</code>、<code class="fe mh mi mj mk b">app.put</code>和<code class="fe mh mi mj mk b">app.delete</code>替换<code class="fe mh mi mj mk b">app.get</code>，可以对POST、PUT和DELETE请求进行同样的操作。</p><p id="6ac5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用<code class="fe mh mi mj mk b">next</code>函数将多个处理程序链接在一起。例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b7da" class="mt lf it mk b gy mu mv l mw mx">const express = require('express')<br/>const app = express()</span><span id="0b71" class="mt lf it mk b gy my mv l mw mx">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="df90" class="mt lf it mk b gy my mv l mw mx">app.get('/',<br/>  (req, res, next) =&gt; {<br/>    console.log('handler 1 called');<br/>    next()<br/>  },<br/>  (req, res) =&gt; {<br/>    console.log('handler 2 called');<br/>    res.send();<br/>  })</span><span id="e38e" class="mt lf it mk b gy my mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="6987" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们应该看到:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="249c" class="mt lf it mk b gy mu mv l mw mx">handler 1 called<br/>handler 2 called</span></pre><p id="f5c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mh mi mj mk b">console.log</code>输出中。</p><p id="9d46" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们调用源自路由处理器参数的<code class="fe mh mi mj mk b">next</code>函数来调用下一个路由处理器函数。</p><h1 id="d58a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="52eb" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">使用Express进行路由很简单。我们可以使用字符串或正则表达式来指定路由路径。</p><p id="3653" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">字符串路径中的一些字符如<code class="fe mh mi mj mk b">?</code>、<code class="fe mh mi mj mk b">+</code>或<code class="fe mh mi mj mk b">*</code>是带有可选字符或通配符的路径的特殊字符。</p><p id="50d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过在占位符名称前使用冒号来指定管线参数的占位符。</p><p id="91d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们调用<code class="fe mh mi mj mk b">next</code>将多个路由处理器链接在一起。</p></div></div>    
</body>
</html>