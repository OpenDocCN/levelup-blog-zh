<html>
<head>
<title>Generics in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin中的泛型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/generics-in-kotlin-49da16031de4?source=collection_archive---------4-----------------------#2020-08-12">https://levelup.gitconnected.com/generics-in-kotlin-49da16031de4?source=collection_archive---------4-----------------------#2020-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="6746" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">泛型是泛型编程的工具，允许类、接口和方法对各种类型的对象进行操作。它基本上允许类型作为方法、类和接口的参数。</p><p id="61a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">泛型通过限制可接受的类型来消除类型转换的需要，从而保证运行时类型安全。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><p id="5c11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">类型参数</strong></p><p id="b07d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类型参数用于实现泛型。类型参数是与类、接口或方法一起使用的实际类型的占位符。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><p id="1049" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">保存字符串类型变量的容器类示例:</p><p id="b243" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">类</strong>String container {<br/>T5】var item:String？=<strong class="js iu">null<br/>fun</strong>set(item:String){<br/>T11】this。<strong class="js iu">项目</strong> =项目<br/> } <br/> }</p><p id="6da9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在假设，我们想要一个类似的类，它可以保存Int类型的项，而不是String。然后，我们将不得不为Int创建类似的类。</p><p id="37f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">class</strong>Int container {<br/><strong class="js iu">var item</strong>:Int？=<strong class="js iu">null<br/>fun</strong>set(item:Int){<br/><strong class="js iu">this</strong>。<strong class="js iu">项目</strong> =项目<br/> } <br/> }</p><p id="e9df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这使得我们为每个这样的需求创建一个新的类型。这就是泛型的用武之地。我们可以如下创建一个泛型类，并通过放置实际类型来代替类型参数(在本例中为T)来实现各种类型的功能，如String、Int等，如下所示</p><p id="2839" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">val</strong>Container = Container&lt;Int&gt;()或val Container = Container&lt;String&gt;等。</p><p id="f9ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">类</strong>容器&lt;T&gt;{<br/><strong class="js iu">var item</strong>:T？=<strong class="js iu">null<br/>fun</strong>set(item:T){<br/><strong class="js iu">this</strong>。<strong class="js iu">项目</strong> =项目<br/> } <br/> }</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><p id="065e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">泛型类型的不变性</strong></p><p id="a6d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像Java一样，Kotlin中的泛型类型是不变的。这意味着超类型列表不是其子类型列表的超类型。例如，列表<animal>不是列表<dog>的超类型。同样，列表<any>也不是列表<string>的超类型。</string></any></dog></animal></p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi kv"><img src="../Images/7675d602f91c9d7e34cef95067f9ad95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MzPHEjPfjaiPfxkq2Bu-Vg.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">列表<dog>不是列表<animal>的子类型</animal></dog></figcaption></figure><pre class="kw kx ky kz gt ll lm ln lo aw lp bi"><span id="a5fe" class="lq lr it lm b gy ls lt l lu lv"><strong class="lm iu">val </strong>listString : ArrayList&lt;String&gt; = ArrayList()<br/><br/><strong class="lm iu">val </strong>listObjects : ArrayList&lt;Any&gt; = listString;     // A compile time error – Type mismatch, occurs here and saves from runtime exception</span></pre><p id="0653" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的第2行引发了一个编译时错误，禁止将字符串列表赋值给对象列表。如果不是这种情况，那么当用户试图分配给错误的类型时，可能会出现运行时异常，如下所示:</p><pre class="kw kx ky kz gt ll lm ln lo aw lp bi"><span id="7250" class="lq lr it lm b gy ls lt l lu lv">listObjects.add(1);<br/><br/><strong class="lm iu">var </strong>firstItem : String = listObjects.get(0);  // Class Cast exception - Cannot cast Integer to String</span></pre><p id="1856" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，不变性保证了运行时的安全性。然而，这禁止了安全和直观的操作，例如将字符串列表复制到对象列表中，因为列表<string>不是列表<object>的子类型。</object></string></p><p id="d756" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">差异</strong></p><p id="2119" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Kotlin中的Variance解决了由于泛型类型的不变性而引发的问题。它与Java中的通配符类型相同。下面给出了一个在Java中使用通配符的例子:</p><p id="bb24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接口集合<e> … {</e></p><p id="1169" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">void addAll(集合 extends E&gt;项)；</p><p id="d66e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi">}</p><p id="5af2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">？扩展E称为通配符类型参数。这里的addAll方法有一个E对象或E子类型对象的集合作为参数。</p><p id="f718" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在这克服了上面提到的限制。列表<string>是列表 extends Object&gt;的子类型。集合 extends E&gt;是一个生产者，我们只能读取它，不能写入它，也就是说，我们不能对它调用add()或set()。</string></p><p id="c14f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，列表 super String&gt;是列表&lt;对象&gt;的<strong class="js iu">超类型</strong>，因为它表示字符串对象的列表或者是字符串超类型的对象的列表。</p><p id="37e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">集合 Super String&gt;是一个消费者，我们只能写入它，不能从中读取。</p><p id="6bec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">前者称为协方差，后者称为逆变。</p><p id="9c7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在KotlIn中，我们可以分别使用out和in关键字实现协方差和逆变。</p><p id="9a59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">举个例子，</p><p id="54b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接口样本生成器<out e=""> {</out></p><p id="f7a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">fun getE(): E</p><p id="791b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi">}</p><p id="b603" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，SampleProducer是E的生产者，因为它只生产E，不消费E。SampleProducer类在参数e中是协变的。</p><p id="11e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接口样本消费者<in e=""> {</in></p><p id="2fc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有趣的takeE</p><p id="cbb0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi">}</p><p id="0af0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，SampleConsumer是E的消费者，因为它只消费E而不生产。</p><p id="0c10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">SampleConsumer类在e。</p><p id="6fc0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“出”和“入”修饰符称为方差注释。和什么一样？在Java中扩展E，如果类/接口也使用E，我们就不能使用out。至于用什么？在Java中，如果类/接口也产生E，我们就不能使用in。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><p id="dff9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">申报场地差异和使用场地差异</strong></p><p id="c50f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Kotlin中，可以通过两种不同的方式使用out和in修饰符来实现变化。上面显示的第一个例子称为声明站点方差，因为它用在类型参数的声明站点。</p><p id="e375" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用位置差异是通过在参数的使用位置使用输出和输入修改器实现的。</p><p id="2b9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">举个例子，</p><p id="0ad0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">趣味副本(to: List <in string="">，item: String){}</in></p><p id="39ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我们可以传递一个字符串列表、一个CharSequence列表或一个对象列表，因为如上所述，<in string="">对应于Java的 super String&gt;。</in></p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><p id="5188" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">星形投影:*代替原始类型</strong></p><p id="5d6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Java允许使用原始类型。比如ArrayList list = new ArrayList()；</p><p id="bd90" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可能导致运行时出现ClassCastException。</p><pre class="kw kx ky kz gt ll lm ln lo aw lp bi"><span id="9ee4" class="lq lr it lm b gy ls lt l lu lv">list.add(<strong class="lm iu">"Hello"</strong>);</span><span id="93d2" class="lq lr it lm b gy lw lt l lu lv">list.add(1); <br/><br/>Integer first = (Integer) collection.get(0);  // ClassCastException</span></pre><p id="8044" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Kotlin不允许使用原始类型参数。然而，类似于原始类型，然而安全，科特林有星形投影。</p><p id="f873" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">举个例子，</p><pre class="kw kx ky kz gt ll lm ln lo aw lp bi"><span id="70e6" class="lq lr it lm b gy ls lt l lu lv"><strong class="lm iu">val </strong>listAlphabet : ArrayList&lt;String&gt; = <em class="lx">arrayListOf</em>(<strong class="lm iu">"A"</strong>,<strong class="lm iu">"B"</strong>)<br/><br/><strong class="lm iu">val </strong>listCode     : ArrayList&lt;Int&gt;    = <em class="lx">arrayListOf</em>(65,66)<br/><br/><strong class="lm iu">val </strong>list : List&lt;*&gt; =<br/><br/> <strong class="lm iu">if</strong>(showCode)<br/><br/>     listAlphabet<br/><br/><strong class="lm iu">else<br/><br/>     </strong>listCode</span></pre><p id="6b27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于ArrayList 等同于ArrayList <out any="">，所以可以从star projected list中读取。但是不可能在一个星型链表中写任何东西，因为它相当于数组列表<in nothing="">。简单地说，由于我们对实际类型一无所知，我们可以从列表中读取对any类的对象执行的任何操作，因为Any是Kotlin中所有对象的超类型。并且我们不能在star projected列表中写入任何内容，因为我们不知道实际使用的类型。</in></out></p><p id="6ff3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">类型擦除</strong></p><p id="7932" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在运行时，任何关于泛型类实例使用的实际类型参数的信息都会被删除，并简化为*。类型安全检查已经在编译时执行了。例如，在Kotlin中，ArrayList <string>在运行时被简化为ArrayList 。因此，我们不能在运行时执行is检查。对于上述例子，</string></p><p id="2f92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">if(list是ArrayList <string> ) //编译器报错:无法检查擦除类型的实例。</string></p><p id="ad84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们只能使用*进行检查，即，</p><p id="c00d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">list是ArrayList 是合法的。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><p id="2bb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">参考文献</strong></p><p id="a466" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ly" href="https://kotlinlang.org/docs/reference/generics.html" rel="noopener ugc nofollow" target="_blank">https://kotlinlang.org/docs/reference/generics.html</a></p></div></div>    
</body>
</html>