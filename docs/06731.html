<html>
<head>
<title>Micro-FEs Simplified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简化的微型FEs</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/micro-fes-simplified-361dff983c27?source=collection_archive---------3-----------------------#2020-12-23">https://levelup.gitconnected.com/micro-fes-simplified-361dff983c27?source=collection_archive---------3-----------------------#2020-12-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b1fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">微前端有巨大的潜力，但实现它们的机制会阻碍实现这一价值。在这篇文章中，以及其附带的视频<a class="ae kl" href="https://youtu.be/tFDvEITdJZ8" rel="noopener ugc nofollow" target="_blank">中，我将介绍如何使用Webpack 5的内置模块联合特性来简化微前端代码的共享。</a></p><p id="df6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上，模块联合使得共享组件变得如此容易，以至于我们开始考虑微FEs带来的两个后续问题:</p><ol class=""><li id="7f24" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">如何让Micro-FEs共享状态，而不需要宿主页面添加提供者或将状态混合到Redux存储中。</li><li id="c041" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">如何使所有主机页面订阅或改变支持页面上实例化的微FEs的数据存储。</li></ol><p id="f17e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想要一个完整的示例三应用程序Micro-FE演示设置，其中React组件与另一个React应用程序和一个普通JS应用程序共享，请查看相关视频。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">微FEs简化版YouTube视频</figcaption></figure><p id="37cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章将更详细地解释视频中的三个核心概念。</p><h1 id="3630" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">一个小陷阱</h1><p id="1139" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">已完成的<a class="ae kl" href="https://github.com/jherr/micro-fes-simplified-done" rel="noopener ugc nofollow" target="_blank">微型FEs简化项目</a>包含三个与销售咆哮者相关的不同应用。</p><blockquote class="mo mp mq"><p id="c083" class="jn jo mr jp b jq jr js jt ju jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj kk ij bi translated">咆哮者是PNW的传统。它们是可以重复灌装的大瓶子，我们可以往里面装啤酒、苏打水、咖啡、康普茶等。</p></blockquote><p id="bda7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一个“咆哮者”应用程序，它有三个共享的微FE组件。有一个<code class="fe mv mw mx my b">Taps</code>组件显示了所有可以倒入咆哮者的不同饮料。有一个<code class="fe mv mw mx my b">Search</code>组件允许您对可用的饮料进行搜索，结果会立即显示在<code class="fe mv mw mx my b">Taps</code>组件中。然后有一个<code class="fe mv mw mx my b">Cart</code>组件显示用户按下<code class="fe mv mw mx my b">Add to Cart</code>按钮时选择的饮料列表。下面显示的是<code class="fe mv mw mx my b">growlers</code>应用程序:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mz"><img src="../Images/fb52869acc7a950ccbf4382d9c754083.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Awak4UQg1NdZDac_XUqxQ@2x.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">Growlers应用程序有三个微FEs，用红色虚线表示</figcaption></figure><p id="c8db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">左边是<code class="fe mv mw mx my b">Search</code>组件，中间是<code class="fe mv mw mx my b">Taps</code>组件，右边是<code class="fe mv mw mx my b">Cart</code>组件。</p><p id="31a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，这些组件在两个不同的应用程序中使用；<code class="fe mv mw mx my b">host-react</code>使用React，而<code class="fe mv mw mx my b">host-vanilla</code>只在页面上使用普通的JS。下面显示的是<code class="fe mv mw mx my b">host-react</code>:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi ng"><img src="../Images/e504f2114400c4f232ef940aa7ef1afa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tm_5F4YHLsAlz614qzrQjw@2x.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">react-host应用程序显示了Micro-FEs及其自己的连接组件</figcaption></figure><p id="2d45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mv mw mx my b">host-react</code>应用程序以不同的布局显示了三个微型FEs，并使用了不同的<a class="ae kl" href="https://chakra-ui.com/" rel="noopener ugc nofollow" target="_blank"> Chakra-UI </a>黑暗主题。此外，在左侧还有一个额外的UI，它写在连接到Micro-FE商店的<code class="fe mv mw mx my b">host-react</code>中，并显示与当前搜索参数匹配的饮料的更紧凑的表示。模块联合使主机页面和微FEs之间的这种更深层次的集成成为可能。</p><p id="6330" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们对演示应用程序有了更好的理解，让我们深入了解一下其中的机制。</p><h1 id="8f2c" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">使用微FEs的模块联合</h1><p id="4273" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">在模块联盟术语中，<code class="fe mv mw mx my b">growlers</code>应用程序是<code class="fe mv mw mx my b">exposing</code>模块。你可以在项目的 <code class="fe mv mw mx my b"><a class="ae kl" href="https://github.com/jherr/micro-fes-simplified-done/blob/master/growlers/webpack.config.js#L50-L75" rel="noopener ugc nofollow" target="_blank">webpack.config.js</a></code> <a class="ae kl" href="https://github.com/jherr/micro-fes-simplified-done/blob/master/growlers/webpack.config.js#L50-L75" rel="noopener ugc nofollow" target="_blank">文件</a>中找到<a class="ae kl" href="https://github.com/jherr/micro-fes-simplified-done/blob/master/growlers/webpack.config.js#L50-L75" rel="noopener ugc nofollow" target="_blank">机制。使用Webpack 5，只需导入<code class="fe mv mw mx my b">ModuleFederationPlugin</code>并进行配置即可。</a></p><pre class="la lb lc ld gt nh my ni nj aw nk bi"><span id="f87e" class="nl lm iq my b gy nm nn l no np">new ModuleFederationPlugin({<br/>  name: "growlers",<br/>  filename: "remoteEntry.js",<br/>  remotes: {},<br/>  exposes: {<br/>    "./DataComponent": "./src/components/DataComponent",<br/><strong class="my ir">    "./Cart": "./src/components/Cart",<br/>    "./Search": "./src/components/Search",<br/>    "./Taps": "./src/components/Taps",<br/></strong>    "./store": "./src/store",<br/>    "./VanillaCart": "./src/vanilla/VanillaCart",<br/>    "./VanillaSearch": "./src/vanilla/VanillaSearch",<br/>    "./VanillaTaps": "./src/vanilla/VanillaTaps",<br/>  },<br/>  ...</span></pre><p id="9fe7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里最重要的字段是联邦模块容器的<code class="fe mv mw mx my b">name</code>，我们将其指定为<code class="fe mv mw mx my b">growlers</code>。后面是暴露模块的列表。开始时，我们只暴露了<code class="fe mv mw mx my b">Cart</code>、<code class="fe mv mw mx my b">Search</code>和<code class="fe mv mw mx my b">Taps</code>组件，以及我们用来指定我们希望显示哪些客户端数据的<code class="fe mv mw mx my b">store</code>。</p><p id="d694" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，演示应用程序继续公开一个<code class="fe mv mw mx my b">DataComponent</code>，基于React的主机可以使用它来显示商店的当前状态。以及普通版本的Micro-FE组件，它们管理将每个组件安装到指定的选择器上(这使得普通的JS应用程序可以轻松地使用看起来像函数的React组件。</p><p id="0ae8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在主机应用程序中，我们通过再次使用<code class="fe mv mw mx my b"><a class="ae kl" href="https://github.com/jherr/micro-fes-simplified-done/blob/master/host-react/webpack.config.js#L42-L60" rel="noopener ugc nofollow" target="_blank">ModuleFederationPlugin</a></code><a class="ae kl" href="https://github.com/jherr/micro-fes-simplified-done/blob/master/host-react/webpack.config.js#L42-L60" rel="noopener ugc nofollow" target="_blank"/><a class="ae kl" href="https://github.com/jherr/micro-fes-simplified-done/blob/master/host-react/webpack.config.js#L42-L60" rel="noopener ugc nofollow" target="_blank">使用<code class="fe mv mw mx my b">growlers</code>遥控器</a>:</p><pre class="la lb lc ld gt nh my ni nj aw nk bi"><span id="1899" class="nl lm iq my b gy nm nn l no np">new ModuleFederationPlugin({<br/>  name: "hostreact",<br/>  filename: "remoteEntry.js",<br/>  remotes: {<br/><strong class="my ir">    growlers: "growlers@</strong><a class="ae kl" href="http://localhost:8080/remoteEntry.js" rel="noopener ugc nofollow" target="_blank"><strong class="my ir">http://localhost:8080/remoteEntry.js</strong></a><strong class="my ir">",<br/></strong>  },<br/>  exposes: {},<br/>  ...</span></pre><p id="4358" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，<code class="fe mv mw mx my b">host-react</code>应用程序指定在指定的URL上有一个名为<code class="fe mv mw mx my b">growlers</code>的遥控器。</p><p id="ca38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从那以后，消费和使用组件就像使用进口产品一样简单:</p><pre class="la lb lc ld gt nh my ni nj aw nk bi"><span id="13ac" class="nl lm iq my b gy nm nn l no np">import Search from "growlers/Search";<br/>import Cart from "growlers/Cart";<br/>import Taps from "growlers/Taps";<br/>import DataComponent from "growlers/DataComponent";<br/>import { load } from "growlers/store";</span><span id="6a91" class="nl lm iq my b gy nq nn l no np">load("hv-taplist");</span></pre><p id="59e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mv mw mx my b">host-react</code>的这段代码中，我们导入了React微FE组件，就像我们导入其他React组件一样。以及用我们的客户ID初始化商店，以便微型企业知道使用什么饮料数据。</p><p id="ca8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有这些都是可行的，因为模块联邦为您提供了真正的Javascript React代码来运行。不是用微铁容器包着的。模块联合适用于任何类型的可被wepbacked的代码；React、Vue、Angular、vanilla JS、JSON、transpiled Typescript等。无论你想要什么。</p><p id="59a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的三个关键优势是:</p><ol class=""><li id="08d9" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">您的Micro-FE代码不需要从托管它的应用程序中单独提取和部署。</li><li id="c031" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">您的微FE代码不需要以任何方式包装或捆绑。</li><li id="030f" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">您可以公开任何类型的代码，而不仅仅是可视组件。</li></ol><p id="f5ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有这些都伴随着一个很大的警告；模块联合不提供与视图平台无关的兼容层。它不会帮助您在Vue应用程序中嵌入React组件，反之亦然。如果你正在寻找，你会想看看类似于<a class="ae kl" href="https://single-spa.js.org/" rel="noopener ugc nofollow" target="_blank"> SingleSPA </a>(它也<a class="ae kl" href="https://single-spa.js.org/docs/recommended-setup/#module-federation" rel="noopener ugc nofollow" target="_blank">推荐使用模块联合</a>作为代码传输层。)但是，如果您的所有应用程序都是React，或者您对本例中所示的超薄JS垫片之类的东西没有问题，那么您就可以开始了。</p><h1 id="6fdb" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">微FEs之间共享状态</h1><p id="ff9e" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">由于使用模块联合在应用程序之间共享代码非常容易，所以我们的示例设置要考虑的下一件事是如何在不同的微FEs之间共享状态，即使它们位于主机页面的不同部分。</p><p id="5f51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使它更有趣，我将坚持这样一个约束，即宿主页面不应该实现任何类型的全局状态提供者来使它工作。主机应用程序应该能够导入组件并将其按原样放在页面上，并且应该可以工作(一旦指定了客户端存储)。</p><p id="4724" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现这一点，我将使用一个名为<a class="ae kl" href="https://github.com/pmndrs/valtio" rel="noopener ugc nofollow" target="_blank"> Valtio </a>的革命性的新微状态管理器，原因有二。首先，它非常容易使用。其次，因为它不需要提供商。</p><p id="02e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要在<code class="fe mv mw mx my b">growlers</code>应用程序中设置商店，我们只需<a class="ae kl" href="https://github.com/jherr/micro-fes-simplified-done/blob/master/growlers/src/store.ts#L1-L18" rel="noopener ugc nofollow" target="_blank">从Valtio导入</a> <code class="fe mv mw mx my b"><a class="ae kl" href="https://github.com/jherr/micro-fes-simplified-done/blob/master/growlers/src/store.ts#L1-L18" rel="noopener ugc nofollow" target="_blank">proxy</a></code> <a class="ae kl" href="https://github.com/jherr/micro-fes-simplified-done/blob/master/growlers/src/store.ts#L1-L18" rel="noopener ugc nofollow" target="_blank">，然后用初始状态</a>创建一个商店。</p><pre class="la lb lc ld gt nh my ni nj aw nk bi"><span id="2630" class="nl lm iq my b gy nm nn l no np">import { proxy, ... } from "valtio";<br/>import { Beverage } from "./types";</span><span id="3237" class="nl lm iq my b gy nq nn l no np">export interface TapStore {<br/>  taps: Beverage[];<br/>  searchText: string;<br/>  alcoholLimit: number;<br/>  filteredTaps: Beverage[];<br/>  cart: Beverage[];<br/>}</span><span id="e604" class="nl lm iq my b gy nq nn l no np">const store = proxy&lt;TapStore&gt;({<br/>  taps: [],<br/>  searchText: "",<br/>  alcoholLimit: 5,<br/>  filteredTaps: [],<br/>  cart: [],<br/>});</span></pre><p id="6580" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">状态包含所有可用饮料的数组、搜索参数、匹配这些过滤器的饮料(或龙头)以及购物车。</p><p id="2406" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了消费商店，我们<a class="ae kl" href="https://github.com/jherr/micro-fes-simplified-done/blob/master/growlers/src/components/Cart.tsx" rel="noopener ugc nofollow" target="_blank">在任何组件</a>中使用 <code class="fe mv mw mx my b"><a class="ae kl" href="https://github.com/jherr/micro-fes-simplified-done/blob/master/growlers/src/components/Cart.tsx" rel="noopener ugc nofollow" target="_blank">useProxy</a></code> <a class="ae kl" href="https://github.com/jherr/micro-fes-simplified-done/blob/master/growlers/src/components/Cart.tsx" rel="noopener ugc nofollow" target="_blank">钩子。</a></p><pre class="la lb lc ld gt nh my ni nj aw nk bi"><span id="c090" class="nl lm iq my b gy nm nn l no np">import React from "react";<br/><strong class="my ir">import { useProxy } from "valtio";</strong></span><span id="be4a" class="nl lm iq my b gy nq nn l no np">import store from "../store";</span><span id="fd49" class="nl lm iq my b gy nq nn l no np">const Cart = () =&gt; {<br/><strong class="my ir">  const snapshot = useProxy(store);<br/></strong>  return (<br/>    &lt;Box border={MFE_BORDER}&gt;<br/>      {snapshot.cart.map((beverage) =&gt; (<br/>        ...<br/>      ))}<br/>      ...<br/>   &lt;/Box&gt;<br/>  );<br/>};</span><span id="bceb" class="nl lm iq my b gy nq nn l no np">export default Cart;</span></pre><p id="4798" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您不需要在视图层次结构的顶部指定任何类型的提供者。您只需在共享文件中创建一个代理，然后使用<code class="fe mv mw mx my b">useProxy</code>消费它。</p><p id="c9e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">设置值也一样简单，我们可以回到<code class="fe mv mw mx my b">store</code>和<a class="ae kl" href="https://github.com/jherr/micro-fes-simplified-done/blob/master/growlers/src/store.ts#L39-L42" rel="noopener ugc nofollow" target="_blank">看看</a>和<code class="fe mv mw mx my b"><a class="ae kl" href="https://github.com/jherr/micro-fes-simplified-done/blob/master/growlers/src/store.ts#L39-L42" rel="noopener ugc nofollow" target="_blank">setSearchText</a></code>的实现，简单来说就是:</p><pre class="la lb lc ld gt nh my ni nj aw nk bi"><span id="ed63" class="nl lm iq my b gy nm nn l no np">export const setSearchText = (text: string) =&gt; {<br/><strong class="my ir">  store.searchText = text;<br/></strong>  store.filteredTaps = filter();<br/>};</span></pre><p id="fdda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要设置商店的价值，您只需设置它。没有比这更干净的了。</p><h1 id="418a" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">将主页面与微FEs状态连接</h1><p id="6e6c" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">因为Valtio是如此简单，所以我们可以做更酷的事情，推动微FEs的边界及其与主页的连接。例如，我们可以<a class="ae kl" href="https://github.com/jherr/micro-fes-simplified-done/blob/master/growlers/src/components/DataComponent.tsx" rel="noopener ugc nofollow" target="_blank">创建一个新的DataProvider组件</a>。</p><pre class="la lb lc ld gt nh my ni nj aw nk bi"><span id="6912" class="nl lm iq my b gy nm nn l no np">import React, { ReactElement } from "react";<br/>import { useProxy } from "valtio";<br/>import store, { TapStore } from "../store";</span><span id="7ea0" class="nl lm iq my b gy nq nn l no np">const DataComponent: React.FC&lt;{<br/>  children: (state: TapStore) =&gt; ReactElement&lt;any, any&gt;;<br/>}&gt; = ({ children }) =&gt; {<br/><strong class="my ir">  const state = useProxy(store);<br/>  return children(state);<br/></strong>};</span><span id="ddf7" class="nl lm iq my b gy nq nn l no np">export default DataComponent;</span></pre><p id="4e0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中，使用React的宿主页面可以提供一个子函数，以宿主页面想要的任何方式呈现存储状态。例如，<code class="fe mv mw mx my b">host-react</code>演示用它来展示小得多的饮料卡:</p><pre class="la lb lc ld gt nh my ni nj aw nk bi"><span id="2116" class="nl lm iq my b gy nm nn l no np">&lt;DataComponent&gt;<br/><strong class="my ir">  {({ filteredTaps }) =&gt;<br/>    filteredTaps.slice(0, 5).map((beverage) =&gt; (<br/>      &lt;SimpleGrid ...&gt;<br/>         ...<br/>      &lt;/SimpleGrid&gt;<br/>     ))<br/>  }<br/></strong>&lt;/DataComponent&gt;</span></pre><p id="9c30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从微铁客户的角度来看，这很好。我不仅已经准备好使用可以放在页面上任何地方的微FE组件，而不需要使用提供者。而且，如果我不喜欢一个或多个微FEs提供的UI，我有我需要的所有扩展点来创建我自己的组件，这些组件与微FEs使用的同一商店一起工作。</p><h1 id="ae8c" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">提供普通的JS兼容性</h1><p id="ec1b" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">我们在视频中解决的另一个问题是在VanillaJS页面上显示这些组件的能力，这就像<a class="ae kl" href="https://github.com/jherr/micro-fes-simplified-done/blob/master/growlers/src/vanilla/VanillaCart.tsx" rel="noopener ugc nofollow" target="_blank">围绕React-DOM </a>提供函数包装一样简单:</p><pre class="la lb lc ld gt nh my ni nj aw nk bi"><span id="b416" class="nl lm iq my b gy nm nn l no np">import React from "react";<br/>import ReactDOM from "react-dom";<br/>import { ChakraProvider } from "<a class="ae kl" href="http://twitter.com/chakra" rel="noopener ugc nofollow" target="_blank">@chakra</a>-ui/react";</span><span id="732d" class="nl lm iq my b gy nq nn l no np">import Cart from "../components/Cart";</span><span id="84aa" class="nl lm iq my b gy nq nn l no np">const App = () =&gt; (<br/>  &lt;ChakraProvider&gt;<br/>    &lt;Cart /&gt;<br/>  &lt;/ChakraProvider&gt;<br/>);</span><span id="2c4e" class="nl lm iq my b gy nq nn l no np"><strong class="my ir">export default (selector: string): void =&gt; {<br/>  ReactDOM.render(&lt;App /&gt;, document.querySelector(selector));<br/>};</strong></span></pre><p id="da8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要被<code class="fe mv mw mx my b">ChakraProvider</code>所迷惑，它只是为组件提供CSS。</p><p id="0f4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在VanillaJS端，我们可以简单地导入这些函数，然后在选择器上调用它们:</p><pre class="la lb lc ld gt nh my ni nj aw nk bi"><span id="0db2" class="nl lm iq my b gy nm nn l no np">import "./index.css";</span><span id="2548" class="nl lm iq my b gy nq nn l no np"><strong class="my ir">import createTaps from "growlers/VanillaTaps";<br/>import createCart from "growlers/VanillaCart";<br/>import createSearch from "growlers/VanillaSearch";<br/></strong>import { load, subscribe } from "growlers/store";</span><span id="db9d" class="nl lm iq my b gy nq nn l no np">// load("growlers-tap-station");<br/>load("hv-taplist");</span><span id="b015" class="nl lm iq my b gy nq nn l no np">...</span><span id="e02c" class="nl lm iq my b gy nq nn l no np"><strong class="my ir">createTaps(".taps");<br/>createCart(".cart");<br/>createSearch(".search");</strong></span></pre><p id="41a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些微FEs是如何实现的？谁说的？从普通JS应用程序的角度来看，这些是它们调用的函数，UI出现在这些选择器上。</p><p id="2193" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，模块联合不仅处理将微FE代码发送到页面，还处理<code class="fe mv mw mx my b">react</code>和<code class="fe mv mw mx my b">react-dom</code>以便代码可以运行。更好的是，如果你偷懒加载你的微FEs，那也很好。模块联合将把<code class="fe mv mw mx my b">remoteEntry.js</code>文件带到页面上，但是如果您决定导入和调用它们，该文件只是对所需块的引用。所以这个系统天生就是可延迟加载的。</p><h1 id="ef7f" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">从这里去哪里</h1><p id="5865" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">这个例子比我在这里介绍的要多得多，更广泛地说，模块联合也是如此。你可以在<a class="ae kl" href="https://www.youtube.com/user/jherr2006" rel="noopener ugc nofollow" target="_blank">我的YouTube频道</a>上查看我在模块联盟视频上的<a class="ae kl" href="https://www.youtube.com/playlist?list=PLNqp92_EXZBLr7p7hn6IYa1YPNs4yJ1t1" rel="noopener ugc nofollow" target="_blank">播放列表。或者你可以看看</a><a class="ae kl" href="https://module-federation.myshopify.com/products/practical-module-federation" rel="noopener ugc nofollow" target="_blank">实用模块联盟</a>，这是我和Zack Jackson写的一本书，涵盖了这种令人着迷的共享代码的新技术的实际应用和内部机制。</p></div></div>    
</body>
</html>