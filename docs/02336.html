<html>
<head>
<title>JavaScript Clean Code — Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript干净代码—类</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-clean-code-classes-82e8f42f6235?source=collection_archive---------13-----------------------#2020-03-06">https://levelup.gitconnected.com/javascript-clean-code-classes-82e8f42f6235?source=collection_archive---------13-----------------------#2020-03-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/749e3ed18410150490b32112ed8ada69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p_Ie-NHbK6lVXZ7n"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@productschool?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">产品学院</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="b449" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript中的类是语言原型继承特性之上的语法糖。然而，就编写干净的代码而言，这些原则仍然适用，因为它们与基于类的语言中的类具有相同的结构。</p><p id="a553" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看如何以一种简洁且可维护的方式编写JavaScript类。</p><h1 id="24c8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">班级组织</h1><p id="d1b2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">类应该从构造函数开始，构造函数内部有一个变量成员列表。</p><p id="6922" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该类的方法可以跟在构造函数和变量列表之后。</p><h1 id="8bb8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">包装</h1><p id="e646" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该将私有变量保存在类内部的块中，而不是作为<code class="fe mh mi mj mk b">this</code>的属性。</p><p id="09ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，类之外的代码就不能访问它们并意外地更改它们的值。</p><p id="8cba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该定义getters和setters来获取和设置不属于<code class="fe mh mi mj mk b">this</code>的变量，或者将它们用于计算属性。</p><p id="f56e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也有助于隐藏实现，这样类就不会意外地使用它们，这就造成了代码的紧密耦合。</p><h1 id="1670" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">班级应该很小</h1><p id="ac0f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">班级应该很小。他们不应该有一个以上的责任。我们不希望有做多件事的类。神级是我们不想要的。</p><p id="e3b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类的名字应该告诉我们它履行什么职责。如果一个方法没有类名中没有的东西，那么它就不应该在那里。</p><p id="0fd8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该能够不用“如果”、“和”、“或”或“但是”这样的词来描述我们的类做了什么。</p><p id="1997" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，下面是一个具有一项职责的类的示例:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2719" class="mt lf it mk b gy mu mv l mw mx">class Rectangle {<br/>  constructor(length, width) {<br/>    this.length = length;<br/>    this.width = width;<br/>  }</span><span id="14df" class="mt lf it mk b gy my mv l mw mx">  get area() {<br/>    return this.length * this.width;<br/>  }<br/>}</span></pre><p id="37ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的<code class="fe mh mi mj mk b">Rectangle</code>类只有一个责任，那就是表示一个矩形。</p><p id="23b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，如果我们有如下的<code class="fe mh mi mj mk b">createCircle</code>方法，那么没有这些连接词我们就无法描述我们的类，因为我们的<code class="fe mh mi mj mk b">Rectangle</code>类有不止一个责任:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="38cc" class="mt lf it mk b gy mu mv l mw mx">class Rectangle {<br/>  constructor(length, width) {<br/>    this.length = length;<br/>    this.width = width;<br/>  }</span><span id="7f62" class="mt lf it mk b gy my mv l mw mx">  get area() {<br/>    return this.length * this.width;<br/>  }</span><span id="4437" class="mt lf it mk b gy my mv l mw mx">  createCircle(radius) {</span><span id="50ba" class="mt lf it mk b gy my mv l mw mx">  }<br/>}</span></pre><h1 id="5cf4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">单一责任原则</h1><p id="ce70" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">班级应该有一个责任和一个改变的理由。这个原则给了我们一个很好的班级规模的指导方针。如果它有一个以上的责任，那它就太大了。</p><p id="242d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">识别责任让我们在代码中创建更好的抽象。我们应该将<code class="fe mh mi mj mk b">createCircle</code>方法移到它自己的类<code class="fe mh mi mj mk b">Circle</code>中，因为圆形和矩形没有任何关系。</p><p id="3885" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们可以这样写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b33a" class="mt lf it mk b gy mu mv l mw mx">class Circle {<br/>  constructor(radius) {<br/>    this.radius = radius;<br/>  }<br/>  get area() {<br/>    return Math.PI * (this.radius ** 2);<br/>  }<br/>}</span></pre><p id="b251" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">单一责任原则是面向对象设计的重要原则之一。也很好理解。</p><p id="085a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不幸的是，这也是更多被忽视的原则之一。人们只是让他们的程序工作，却忘记清理它们。</p><p id="4a68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦他们的代码开始工作，他们就会转移到下一个问题上，只是懒得去清理它。</p><p id="841d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一些人还担心，建立更小的、单一责任的班级会增加理解全局的难度。他们认为从一个类到另一个类的导航会使他们更难了解系统的全貌。</p><p id="5667" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，这是不正确的，因为他们有移动部件的数量。如果我们把所有的东西都放在一个类中，那么我们仍然必须在类中而不是在不同的文件中挖掘它们。没什么不同。</p><p id="7b0a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">较小的类包含较少的代码，因此更容易阅读。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/33db2d2ac3b58d5c14649af4d16c8b74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vgxAMVT1G3G6lH34"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kf" href="https://unsplash.com/@neonbrand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NeONBRAND </a>拍摄</figcaption></figure><h1 id="70c4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">内聚力</h1><p id="13d5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">类应该有少量的实例变量。每个方法都应该操作一个或多个实例变量。每个方法都使用每个变量的类是最大内聚的。</p><p id="9b7d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们喜欢内聚性高，这样方法和实例变量就相互依赖，并作为一个整体保持在一起。</p><p id="d874" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">高内聚使得阅读代码变得容易，因为它只围绕一个单一的概念。他们也不经常改变，因为每个类不做太多。</p><p id="dce0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">比如我们的<code class="fe mh mi mj mk b">Circle</code>类:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b825" class="mt lf it mk b gy mu mv l mw mx">class Circle {<br/>  constructor(radius) {<br/>    this.radius = radius;<br/>  }<br/>  get area() {<br/>    return Math.PI * (this.radius ** 2);<br/>  }<br/>}</span></pre><p id="d8bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是内聚的，因为我们在<code class="fe mh mi mj mk b">area</code> getter方法中使用了<code class="fe mh mi mj mk b">radius</code>实例变量，所以我们在方法中使用了每个实例变量。</p><h1 id="65e3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">保持凝聚力意味着许多小班</h1><p id="209b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">正如我们所看到的，创建小型的内聚类是很容易的。它们有较少的实例变量，所以很容易在方法中使用它们。</p><p id="9f76" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">较大的类在保持内聚性方面有问题，因为我们不断添加只有少数方法使用的新实例变量。</p><p id="15a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着当类失去凝聚力时，我们应该把它们分开。所以与其写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6ed1" class="mt lf it mk b gy mu mv l mw mx">class Shape {<br/>  constructor(radius, length, width) {<br/>    this.radius = radius;<br/>    this.length = length;<br/>    this.width = width;<br/>  }</span><span id="aec1" class="mt lf it mk b gy my mv l mw mx">  get circleArea() {<br/>    return Math.PI * (this.radius ** 2);<br/>  }</span><span id="f02c" class="mt lf it mk b gy my mv l mw mx">  get rectangleArea() {<br/>    return this.length * this.width;<br/>  }<br/>}</span></pre><p id="4483" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该把它们分成<code class="fe mh mi mj mk b">Rectangle</code>和<code class="fe mh mi mj mk b">Circle</code>类，因为实例变量和方法放在一起没有意义。</p><p id="2ef3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以最好这样写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7964" class="mt lf it mk b gy mu mv l mw mx">class Rectangle {<br/>  constructor(length, width) {<br/>    this.length = length;<br/>    this.width = width;<br/>  }</span><span id="53bf" class="mt lf it mk b gy my mv l mw mx">  get area() {<br/>    return this.length * this.width;<br/>  }<br/>}</span><span id="67a9" class="mt lf it mk b gy my mv l mw mx">class Circle {<br/>  constructor(radius) {<br/>    this.radius = radius;<br/>  }<br/>  get area() {<br/>    return Math.PI * (this.radius ** 2);<br/>  }<br/>}</span></pre><h1 id="d463" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="43bb" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JavaScript类应该遵循干净代码原则，即使它只是其原型继承模型之上的语法糖。</p><p id="6ec0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该有内聚类，其中方法使用所有定义的实例变量。</p><p id="7a99" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，每个类应该有一个单一的责任。这一点和内聚性使得阅读代码变得容易，因为它们只围绕一个单一的概念。他们也不经常改变，因为每个类不做太多。</p><p id="c692" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">小班比大班好，因为他们没有超过一个单一的责任，他们更有凝聚力。</p></div></div>    
</body>
</html>