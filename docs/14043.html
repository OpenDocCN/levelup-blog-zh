<html>
<head>
<title>Biased? Here is How to Write Better Software</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有偏见？以下是如何编写更好的软件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/biased-here-is-how-to-write-better-software-13320edbc245?source=collection_archive---------3-----------------------#2022-10-27">https://levelup.gitconnected.com/biased-here-is-how-to-write-better-software-13320edbc245?source=collection_archive---------3-----------------------#2022-10-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/54bb51e74eae7f8f941c7f3a91b4fdd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jmM5iHiRfSfNS-J47q5wwA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@victoriano" rel="noopener ugc nofollow" target="_blank">维多利亚诺·伊斯基耶多</a>在<a class="ae kf" href="https://unsplash.com/photos/n52RFcd-4KU" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="6513" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的大脑在存储方面是有限的，并且已经发展出决定什么需要记住，什么可以忘记的策略。</p><p id="f08f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有这么多丰富多彩的事物争夺我们的注意力，我们很自然地会陷入这些思维捷径:</p><ul class=""><li id="3ef0" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">我们将事件和列表简化为它们的关键元素</li><li id="9b90" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">我们抛弃细节以形成一般性</li></ul><p id="2246" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这两种思维模式都会影响我们阅读软件的方式。</p><p id="961e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">我们花在阅读上的时间比写软件的时间多得多</strong>——我想这个比例大约是1:10，在某些地方要高得多，1:100甚至更高。</p><p id="ff0c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们通过提高可读性来帮助我们软件的读者吧！</p><p id="6bc7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有哪些好的遵循我们自然思维模式的编码结构？我们怎样才能写出更容易理解的代码？</p><p id="c418" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，<strong class="ki iu">我将向你展示一个简单的策略来提高你的软件</strong>的可读性，这样你就可以向你的客户交付更高的价值。</p><h1 id="f153" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">人类偏见</h1><p id="9dfc" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">我们人类充满了偏见，基本上是对一件事、一个人或一群人的偏见。这些偏见是我们认知局限性的结果，它们在很大程度上决定了我们的行为方式，尤其是在压力下。</p><p id="129f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑这个经典的例子<strong class="ki iu">——风险规避:</strong></p><blockquote class="mv mw mx"><p id="0e38" class="kg kh my ki b kj kk kl km kn ko kp kq mz ks kt ku na kw kx ky nb la lb lc ld im bi translated">我们不喜欢不确定性，通常坚持我们所知道的。</p></blockquote><p id="02ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于软件开发总是有一些时间压力，我们自然倾向于将决策推迟到以后。如果我们已经实现了一个基本版本，为什么还要重新构建代码以使其可读性更好呢？</p><h1 id="9394" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">代码示例</h1><p id="f1dc" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">让我们从下面的实现开始讨论:</p><figure class="nc nd ne nf gt ju"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="f881" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码看起来很好，但是当仔细观察时，我们注意到一些代码味道:</p><h1 id="faf1" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak"> 1)嵌套的if-else语句</strong></h1><p id="0c71" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">该函数包含三个嵌套的if-else语句。</p><pre class="nc nd ne nf gt ni nj nk nl aw nm bi"><span id="44dc" class="nn lt it nj b gy no np l nq nr">if (...)<br/>{<br/>    ...<br/>    if (...)<br/>    {<br/>        ...<br/>        if (...)<br/>        {</span></pre><p id="ac86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们能不能用不同的编码风格把它拉平？</p><p id="90ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">深度嵌套的代码结构产生了巨大的决策树，每一个新的代码分支都引入了可能出错的边缘情况。建立心智模型需要时间和精力，而且会增加认知负荷。</p><figure class="nc nd ne nf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/ecb77e175dd00e33748e9a24d3a59d2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eP1LlBSF-FOgDJYI8sGUYA.png"/></div></div></figure><h1 id="915b" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak"> 2)不同层次的抽象</strong></h1><pre class="nc nd ne nf gt ni nj nk nl aw nm bi"><span id="df3d" class="nn lt it nj b gy no np l nq nr"><strong class="nj iu">Computer computer = GetComputer(...);<br/>string serverAddress = GetServerAddress(...);</strong></span><span id="170e" class="nn lt it nj b gy nt np l nq nr">if (...)<br/>{<br/>   ...<br/>}<br/>else<br/>{<br/>    <strong class="nj iu">job.Status = "Failed, site server not found.";</strong><br/>}</span></pre><p id="b487" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nu nv nw nj b">GetComputer()</code>和<code class="fe nu nv nw nj b">GetServerAddress()</code>在更高的抽象层次上，交流更高的业务逻辑。</p><p id="033c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面,<code class="fe nu nv nw nj b">job.Status = "..."</code>在一个较低的抽象层次上，描述一些更详细的东西。它甚至在错误处理方面混合了一些技术方面。</p><p id="ad99" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个星座违反了<strong class="ki iu">单一抽象层次</strong> — SLA。</p><p id="65bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我把它比作报纸结构:两个业务功能代表标题，<code class="fe nu nv nw nj b">job.Status</code>代表段落级别的细节。</p><p id="9e1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不同抽象层次的问题在于，它让我们的思维来回跳跃。将业务方面与技术细节混在一起会使阅读代码更加困难。</p><h1 id="173b" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak"> 3)多关注点函数</strong></h1><p id="528f" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated"><strong class="ki iu">单一责任原则</strong>规定:</p><blockquote class="mv mw mx"><p id="9b30" class="kg kh my ki b kj kk kl km kn ko kp kq mz ks kt ku na kw kx ky nb la lb lc ld im bi translated">把因为同样的原因而改变的东西聚集在一起。把那些因为不同原因而改变的东西分开。罗伯特·马丁</p></blockquote><p id="5045" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意函数名中的<strong class="ki iu">和</strong>关键字以及<strong class="ki iu"> if-else </strong>结构:</p><pre class="nc nd ne nf gt ni nj nk nl aw nm bi"><span id="81bc" class="nn lt it nj b gy no np l nq nr">List&lt;JobAction&gt; actions = await CheckForRelease<strong class="nj iu">And</strong>CreateAction(...);<br/>if (!actions.Any())<br/>{<br/>    actions = await CheckForBundle<strong class="nj iu">And</strong>CreateActions(...);<br/>}<br/>if (!actions.Any())<br/>{<br/>    actions = await CheckForCollection<strong class="nj iu">And</strong>CreateActions(...);<br/>}<br/>if (!actions.Any())<br/>{<br/>    actions = await CheckForApplication<strong class="nj iu">And</strong>CreateActions(...);<br/>}<br/>foreach (JobAction action in actions)<br/>{<br/>    ...<br/>}</span></pre><p id="759e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有四个函数遵循相同的模式——它们检查某些东西，<strong class="ki iu">和</strong>它们创建动作。还要注意这些函数是如何嵌入到控制顺序的不寻常的if-else结构中的。</p><p id="5d25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">多个方面混合在一起，由于不同的原因可能会发生代码更改——<strong class="ki iu">人员A </strong>可能想要更改顺序，而<strong class="ki iu">人员B </strong>可能要更改特定的操作。</p><p id="e1cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们编写软件时，我们希望确保当请求更改时，这些更改只能来自一个人。</p><p id="b190" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码片段违反了这个原则。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="5c9b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果软件开发团队完全没有关于干净代码原则的意识，那么代码库迟早会受损。</p><blockquote class="mv mw mx"><p id="c71e" class="kg kh my ki b kj kk kl km kn ko kp kq mz ks kt ku na kw kx ky nb la lb lc ld im bi translated">大事始于小事，先生。—阿拉伯的劳伦斯</p></blockquote><p id="bc06" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码气味就像给即将成为又大又丑的怪物提供美味的食物。祝你好运驯服这个不断增长的复杂性野兽。</p><figure class="nc nd ne nf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/5106cd0b7660c4f041d6f3be1c5eab7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*28wcb5oi21-b5U_eA1SxUQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<em class="of"> </em> <a class="ae kf" href="https://www.shutterstock.com/g/memoangeles" rel="noopener ugc nofollow" target="_blank"> <em class="of">备忘录矶</em> </a> <em class="of">上</em><a class="ae kf" href="https://www.shutterstock.com/image-vector/flying-spaghetti-monster-vector-clip-art-188441972" rel="noopener ugc nofollow" target="_blank"><em class="of">Shutterstock.com</em></a></figcaption></figure><h1 id="35e9" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">让我们做一些重构</h1><p id="8bde" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">但是我们可以做得更好。现在考虑以下实现:</p><figure class="nc nd ne nf gt ju"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="f461" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你觉得怎么样？那更容易阅读吗？它是否更好地传达了业务领域？</p><p id="b547" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是我们为提高代码可读性而应用的基本原则:</p><h1 id="c397" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak"> 1)“您先请”</strong></h1><p id="93f2" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">通过让<strong class="ki iu">业务领域</strong>和<strong class="ki iu">技术方面</strong>同样成为你的软件结构的强大驱动力，来展示一种礼貌的姿态。</p><p id="bf86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">技术是一种强大的力量，经常支配着我们的软件实现。确保你尊重他们两个。</p><p id="3c43" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">隐藏技术细节，尽可能突出业务领域。<strong class="ki iu">读代码应该更像读故事。</strong></p><h1 id="ceda" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak"> 2)减少名单</strong></h1><p id="cafa" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">注意<code class="fe nu nv nw nj b">CheckForReleaseAndCreateAction()</code>函数——它有多种功能。它将“检查”和“创建”某些东西(业务领域)，并且它与更广泛的if-else结构(技术)纠缠在一起。因此，业务领域方面和技术方面交织在一起。</p><p id="b460" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当关注可读性时，最好是一次关注一个方面，突出相关信息，隐藏当前不重要的信息——减少信息并对信息进行优先排序。</p><h1 id="6c6d" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak"> 3)形成共性</strong></h1><p id="7133" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">我们的大脑擅长标记和假设，所以让我们利用这一点，创造一些抽象概念。</p><p id="3dbe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以隐藏不重要的信息，把它们推到更低的抽象层次，在那里它们更相关。</p><p id="0940" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将控制结构(if-else语句)在函数的层次结构中向下推会导致一个更线性的故事线，并且需要记住的并行案例更少。</p><p id="c65b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们喜欢跟踪一个线性故事，跟踪多个平行的故事就像一次或以错误的顺序观看《星球大战》电影。这将导致对所发生的事情的混淆，并使人们难以判断它们的整体重要性。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h1 id="db4e" class="ls lt it bd lu lv og lx ly lz oh mb mc md oi mf mg mh oj mj mk ml ok mn mo mp bi translated">集成操作隔离原则(IOSP)</h1><p id="3402" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">为了更容易记住和思考潜在的认知偏见，有一个清晰的代码原则可以帮助你。</p><p id="2e8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">IOSP清洁准则原则要求明确划分为两类职能:</p><blockquote class="mv mw mx"><p id="299f" class="kg kh my ki b kj kk kl km kn ko kp kq mz ks kt ku na kw kx ky nb la lb lc ld im bi translated"><strong class="ki iu">集成:</strong>一个函数只包含对<strong class="ki iu">相同</strong>代码库<br/> <strong class="ki iu">操作中函数的调用:</strong>一个函数只包含对<strong class="ki iu">另一个</strong>代码库函数的调用</p><p id="13d5" class="kg kh my ki b kj kk kl km kn ko kp kq mz ks kt ku na kw kx ky nb la lb lc ld im bi translated">拉尔夫·韦斯特法尔(2012年)。<a class="ae kf" href="https://ralfwestphal.substack.com/p/integration-operation-segregation" rel="noopener ugc nofollow" target="_blank">作为编程模型的消息传递。</a></p></blockquote><p id="fb77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(操作符和控制流结构是另一个代码库中的函数，它的易访问性被认为是语法上的优势。)</p><p id="d7d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">集成— </strong>(基本上是一个调用其他函数的函数):</p><figure class="nc nd ne nf gt ju"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="68da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">操作</strong>——(包含逻辑的功能):</p><figure class="nc nd ne nf gt ju"><div class="bz fp l di"><div class="ng nh l"/></div></figure><ul class=""><li id="0c2c" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">IOSP提倡单一层次的抽象</li><li id="26e2" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">它沿着函数的层次结构向下推动分支逻辑</li><li id="f174" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">并且更容易阅读。</li></ul><p id="5e6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从原作者<strong class="ki iu"> Ralf Westphal处了解更多关于<strong class="ki iu"> IOSP </strong>的。</strong></p><h1 id="5035" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">实践中的IOSP</h1><p id="b033" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">与IOSP一起工作时，代码分支会很有挑战性。以下是我用来保持代码结构扁平的一些便利策略:</p><ul class=""><li id="4c23" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated"><a class="ae kf" href="https://gist.github.com/fnbk/c4c6ca17536933109caa64a858e6e95d" rel="noopener ugc nofollow" target="_blank">试抓</a></li><li id="5cf4" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae kf" href="https://gist.github.com/fnbk/0ee794e1dcf82e394e7abfae31ebe4e2" rel="noopener ugc nofollow" target="_blank"> if-else </a></li><li id="00f1" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae kf" href="https://gist.github.com/fnbk/2ea9b6253c11005fb88be10985c25719" rel="noopener ugc nofollow" target="_blank">本地功能</a></li><li id="317d" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae kf" href="https://gist.github.com/fnbk/d993d3829827fe10d89ef0de7836deca" rel="noopener ugc nofollow" target="_blank">单子</a></li></ul><h1 id="95df" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">我的干净代码备忘单</h1><p id="eb90" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">如果你想在你的团队中为干净代码实践建立一个好的基线，那么看看我的<a class="ae kf" href="https://florianboehmak.com/" rel="noopener ugc nofollow" target="_blank">干净代码备忘单</a>。</p><p id="8e49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我把它简化为13条原则，这就是你在团队中进行专业代码讨论所需要的。你会更快达成协议，看到情绪化的讨论消失。</p><h1 id="98ad" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="c6b6" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">我们的大脑在存储方面是有限的，并使用不同的策略来解决这一限制。我们将信息简化为关键事实，并很快贴上标签和做出假设，这使我们产生偏见。</p><p id="0186" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这对我们阅读和理解软件有很大的影响。</p><p id="a4e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们花在阅读软件上的时间比写软件的时间多得多，所以让代码更容易阅读是一项不错的投资。</p><p id="7f3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">干净代码原则<strong class="ki iu"> IOSP </strong>将帮助你做到这一点。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><div class="nc nd ne nf gt ol"><a href="https://betterprogramming.pub/there-just-isnt-enough-time-f7bb069411f" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">时间不够了</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">以及为什么写“脏代码”是一个好的开始</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">better编程. pub</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz jz ol"/></div></div></a></div></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h2 id="bab6" class="nn lt it bd lu pa pb dn ly pc pd dp mc kr pe pf mg kv pg ph mk kz pi pj mo pk bi translated"><strong class="ak">参考文献</strong></h2><p id="b887" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">[1]:巴斯特·本森(2016年9月1日)。认知偏见备忘单<a class="ae kf" href="https://betterhumans.pub/cognitive-bias-cheat-sheet-55a472476b18" rel="noopener ugc nofollow" target="_blank">https://better humans . pub/cognitive-bias-cheat-sheet-35a 472476 b18</a></p><p id="0c4f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">罗伯特·马丁:单一责任原则<br/><a class="ae kf" href="https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html" rel="noopener ugc nofollow" target="_blank">https://blog . clean coder . com/uncle-bob/2014/05/08/singlerepointibility Principle . html</a></p><p id="7aea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">拉尔夫·威斯特法尔:一体化运作隔离原则(IOSP)<br/><a class="ae kf" href="https://ralfwestphal.substack.com/p/integration-operation-segregation" rel="noopener ugc nofollow" target="_blank">https://ralfwestphal . substack . com/p/Integration-Operation-Segregation</a></p></div></div>    
</body>
</html>