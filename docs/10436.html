<html>
<head>
<title>Bad Code to Better Code: An Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">糟糕的代码变得更好:一个例子</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/bad-code-to-better-code-an-example-5fe034f448f6?source=collection_archive---------7-----------------------#2021-12-06">https://levelup.gitconnected.com/bad-code-to-better-code-an-example-5fe034f448f6?source=collection_archive---------7-----------------------#2021-12-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5517" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">学习编程</h2><div class=""/><div class=""><h2 id="7048" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">一个绘制漂亮的自动纱舞动画的例子</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e73df83f0278ca189d2cea7ccfdb71e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MHRfsww9rHq2lHkA"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://www.pexels.com/@cristian-rojas" rel="noopener ugc nofollow" target="_blank">洛斯莫尔托斯剧组</a>在<a class="ae lh" href="https://www.pexels.com/photo/wood-art-creative-mexican-7205817/" rel="noopener ugc nofollow" target="_blank">像素</a>拍摄的照片</figcaption></figure><p id="5e3b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di"> R </span>最近我<a class="ae lh" href="https://medium.com/mobile-app-development-publication/jetpack-compose-animation-under-50-lines-using-k5-compose-playground-bef35060c471" rel="noopener">在玩Kotlin Jetpack作曲K5游乐场</a>。用它，我编写了各种即兴程序来生成一些漂亮的动画。其中一个我称之为自动纱线舞蹈如下。</p><p id="f79b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这里，我将解释画出下图的代码，并展示我们如何将糟糕的代码改进成可读性更好的代码。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/2206713dd8936e94d6d116fa20b722d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*fu0Y8PyCul72OL4E.gif"/></div></figure><p id="ad1d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">只有不到50行代码。但我不认为很多人会喜欢读它。所以我做了一个更好的(下图之后)。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="9cb2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">与其看上面的，下面的在可读性方面不是好很多吗？</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="e146" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它隐藏了所有的细节，但在绘制纱线线条时却有着很高的层次。从这里我们知道</p><ol class=""><li id="cb92" class="mq mr it lk b ll lm lo lp lr ms lv mt lz mu md mv mw mx my bi translated">它为随机的纱线线产生一些噪声参数。</li><li id="9bb8" class="mq mr it lk b ll mz lo na lr nb lv nc lz nd md mv mw mx my bi translated">当鼠标X坐标向右移动时，它会绘制尽可能多的纱线。</li></ol><p id="e7a2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面是代码是如何转换的，hope是如何提高代码可读性的一个案例。</p><h1 id="1ef5" class="ne nf it bd ng nh ni nj nk nl nm nn no ki np kj nq kl nr km ns ko nt kp nu nv bi translated">将附带功能提取到不同的类中</h1><p id="cf94" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">在原始代码中，除了画线，我们还有生成噪声参数值的代码。这些代码扰乱了代码的清晰性。</p><p id="08f8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它有两部分</p><h2 id="5d7a" class="ob nf it bd ng oc od dn nk oe of dp no lr og oh nq lv oi oj ns lz ok ol nu iz bi translated">提取升降计数器</h2><p id="d00e" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">从代码中，您可以看到它有一个值，当达到最大值时，该值会上下波动。这里使用的技术是</p><ul class=""><li id="5ea8" class="mq mr it lk b ll lm lo lp lr ms lv mt lz mu md om mw mx my bi translated">类和变量的名字解释了意图</li><li id="942c" class="mq mr it lk b ll mz lo na lr nb lv nc lz nd md om mw mx my bi translated">函数名使它们更加清晰。</li></ul><pre class="ks kt ku kv gt on oo op oq aw or bi"><span id="6808" class="ob nf it oo b gy os ot l ou ov">class UpDownCounter(private val maxValue: Int) {<br/>    var incrementalValue = 0<br/>    private var isUp = true<br/><br/>    fun change() {<br/>        if (isUp) {<br/>            if (isReachingMax()) {<br/>                reverseChange()<br/>            } else {<br/>                incrementalValue++<br/>            }<br/>        } else {<br/>            if (isReachingMin()) {<br/>                reverseChange()<br/>            } else {<br/>                incrementalValue--<br/>            }<br/>        }<br/>    }<br/><br/>    private fun reverseChange() { isUp = !isUp }<br/>    private fun isReachingMin() = incrementalValue &lt;= 0<br/>    private fun isReachingMax() = incrementalValue &gt; maxValue<br/>}</span></pre><h2 id="70ce" class="ob nf it bd ng oc od dn nk oe of dp no lr og oh nq lv oi oj ns lz ok ol nu iz bi translated">提取噪声参数生成器</h2><p id="0b54" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">该类用于生成决定纱线拉伸随机性的噪声参数。它可以从绘图功能中分离出来。这个类还利用UpDownCounter来生成噪声参数</p><pre class="ks kt ku kv gt on oo op oq aw or bi"><span id="46ca" class="ob nf it oo b gy os ot l ou ov">lass NoiseParamsGenerator(<br/>    private val constantLooper: Int = 10000,<br/>    private val constantNoiseWeight: Float = 0.002f) {<br/><br/>    private val upDownCounter = <br/>        UpDownCounter(constantLooper * constantLooper)<br/><br/>    private val incrementalValue: Int<br/>        get() = upDownCounter.incrementalValue<br/><br/>    private val noise2Dparam: Int<br/>        get() = iterateZeroToLoop()<br/>    private val noise3Dparam: Int<br/>        get() = iterateZeroToHalfLoopAndReverse()<br/><br/>    fun change() = upDownCounter.change()<br/><br/>    private fun iterateZeroToHalfLoopAndReverse() =<br/>        <em class="ow">abs</em>(<em class="ow">abs</em>(<br/>            incrementalValue % constantLooper - constantLooper / 2) <br/>                - constantLooper / 2)<br/>    private fun iterateZeroToLoop() = <br/>        incrementalValue / constantLooper<br/><br/><br/>    operator fun component1(): Double {<br/>        return (noise2Dparam * constantNoiseWeight).toDouble()<br/>    }<br/><br/>    operator fun component2(): Double {<br/>        return (noise3Dparam * constantNoiseWeight).toDouble()<br/>    }<br/>}</span></pre><p id="4e6f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了清楚起见，我们再次使用了类名、变量名和函数名。然而，你可能和我想的一样，仅仅用名字不能很好地表达上下文，需要更多的帮助。</p><p id="5cd2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我使用以下两种方法来提供更多的背景</p><h2 id="f1bb" class="ob nf it bd ng oc od dn nk oe of dp no lr og oh nq lv oi oj ns lz ok ol nu iz bi translated">在提交消息中存储额外的相关信息</h2><p id="7802" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">NoiseParamsGenerator中有相当多的上下文。一种方法是在函数之上编写代码注释。但是代码注释的缺点是，每当类被改变时，它必须总是记得保持一致。</p><p id="31cd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一种方法是将信息存储到Git Commit中，以提供尽可能多的上下文，而不用担心代码混乱。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ox"><img src="../Images/7796690af477bd45f2ba8404a8e28d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z5olQHrYeX5zNJNY9fWP-Q.png"/></div></div></figure><p id="00be" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Git Commit消息的另一个优点是，无论何时发生变化，我们都需要提供一个新的上下文，覆盖以前的上下文。Git提交消息是有时间限制的，因此它总是最新的。</p><p id="1eed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，我将下面的代码从</p><pre class="ks kt ku kv gt on oo op oq aw or bi"><span id="8fb0" class="ob nf it oo b gy os ot l ou ov">private fun iterateZeroToHalfLoopAndReverse() =<br/>    <em class="ow">abs</em>(incrementalValue % constantLooper - constantLooper / 2)</span></pre><p id="a07e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">到下面…</p><pre class="ks kt ku kv gt on oo op oq aw or bi"><span id="9547" class="ob nf it oo b gy os ot l ou ov">private fun iterateZeroToHalfLoopAndReverse() =<br/>    <em class="ow">abs</em>(<em class="ow">abs</em>(incrementalValue % constantLooper - constantLooper / 2) - constantLooper / 2)</span></pre><p id="c2e5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我必须放入一个新的提交消息，它很好地反映了变化。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oy"><img src="../Images/298cf8ca39f58c2efe17bc0ac4e94afc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sr4g8zOWjKdsRniZQY92FQ.png"/></div></div></figure><h2 id="26ac" class="ob nf it bd ng oc od dn nk oe of dp no lr og oh nq lv oi oj ns lz ok ol nu iz bi translated">为场景说明创建相关的测试用例</h2><p id="7a36" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">当我们提取新的类时，我们可以创建测试来提供更多的上下文，而不是围绕它写很长的上下文。</p><pre class="ks kt ku kv gt on oo op oq aw or bi"><span id="1264" class="ob nf it oo b gy os ot l ou ov">class NoiseParamsGeneratorTest {<br/><br/>    @Test<br/>    fun `Test Noise Value Generator Loop Value`() {<br/>        lateinit var  noiseParamsGenerator: NoiseParamsGenerator<br/>        var resultString = ""<br/><br/>        fun given() {<br/>            noiseParamsGenerator = NoiseParamsGenerator(10, 1f)<br/>        }<br/>        fun whenever() {<br/>            <em class="ow">repeat</em>(16) <strong class="oo jd">{<br/>                </strong>val (x, y) = noiseParamsGenerator<br/>                resultString += "($x: $y) "<br/>                noiseParamsGenerator.change()<br/>            <strong class="oo jd">}<br/>        </strong>}<br/>        fun then() {<br/>            val expectedResult = "(0.0: 0.0) (0.0: 1.0) (0.0: 2.0) (0.0: 3.0) (0.0: 4.0) (0.0: 5.0) (0.0: 4.0) (0.0: 3.0) (0.0: 2.0) (0.0: 1.0) (1.0: 0.0) (1.0: 1.0) (1.0: 2.0) (1.0: 3.0) (1.0: 4.0) (1.0: 5.0)"<br/>            Assert.assertEquals(<br/>                "Result is not incremented as expected",<br/>                expectedResult,<br/>                resultString.<em class="ow">trim</em>()<br/>            )<br/>        }<br/><br/>        given()<br/>        whenever()<br/>        then()<br/>    }<br/>}</span></pre><p id="1699" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这样做有两个好处</p><ul class=""><li id="8fbb" class="mq mr it lk b ll lm lo lp lr ms lv mt lz mu md om mw mx my bi translated">用用例场景提供更好的代码上下文。</li><li id="70b1" class="mq mr it lk b ll mz lo na lr nb lv nc lz nd md om mw mx my bi translated">未来的代码重构可以被测试，以确保没有任何破坏。</li></ul><p id="a058" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在测试用例中，我们还展示了两个避免注释的巧妙技巧</p><ol class=""><li id="92c8" class="mq mr it lk b ll lm lo lp lr ms lv mt lz mu md mv mw mx my bi translated">编写有意义的测试名称。在科特林使用反勾号。因此测试函数名可以有空格<code class="fe oz pa pb oo b">`testing function name`()</code></li><li id="d7bd" class="mq mr it lk b ll mz lo na lr nb lv nc lz nd md mv mw mx my bi translated">使用局部范围函数而不是注释。例如，我们不再需要使用<code class="fe oz pa pb oo b">//given</code>、<code class="fe oz pa pb oo b">//when</code>或<code class="fe oz pa pb oo b">//then</code>，但是它们每个都是一个函数本身</li><li id="b953" class="mq mr it lk b ll mz lo na lr nb lv nc lz nd md mv mw mx my bi translated">当失败时，使用带有适当消息的测试断言来更好地描述失败。</li></ol><h1 id="e363" class="ne nf it bd ng nh ni nj nk nl nm nn no ki np kj nq kl nr km ns ko nt kp nu nv bi translated">将长函数分割成较小的部分</h1><p id="4131" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">至于绘图本身，我也把它提取出来作为函数来代替。虽然有些可读性，但还是包含了太多的细节。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="28af" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">相反，也许让我们把函数分解成更小的部分，在函数名中有更清晰的意图。如果你看下面，可读性更强，不是吗？</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="cb78" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每个小功能进一步扩展如下。它们有助于</p><ul class=""><li id="2106" class="mq mr it lk b ll lm lo lp lr ms lv mt lz mu md om mw mx my bi translated">每个都有一个函数名，很好地解释了意图(不需要使用注释)。</li><li id="2dcc" class="mq mr it lk b ll mz lo na lr nb lv nc lz nd md om mw mx my bi translated">代码块越小，它本身就越容易消化和理解。</li></ul><h2 id="c5c4" class="ob nf it bd ng oc od dn nk oe of dp no lr og oh nq lv oi oj ns lz ok ol nu iz bi translated">生成纱线线坐标</h2><pre class="ks kt ku kv gt on oo op oq aw or bi"><span id="e11d" class="ob nf it oo b gy os ot l ou ov">private fun generateYarnLineCoordinates(<br/>    size: Size,<br/>    m2d: Double,<br/>    m3d: Double,<br/>    offset: Double<br/>): Pair&lt;FloatArray, FloatArray&gt; {<br/>    fun noiseX(variant: Double) = <br/>        2 * size.width * <em class="ow">noise3D</em>(variant, m2d, m3d)<br/>    fun noiseY(variant: Double) = <br/>        2 * size.height * <em class="ow">noise3D</em>(offset + variant, m2d, m3d)<br/>    val x = FloatArray(4) <strong class="oo jd">{ <br/>        </strong>index <strong class="oo jd">-&gt; </strong>noiseX(offset + 5 + index * 10).toFloat() <br/>    <strong class="oo jd">}<br/>    </strong>val y = FloatArray(4) <strong class="oo jd">{ <br/>        </strong>index <strong class="oo jd">-&gt; </strong>noiseY(offset + 5 + index * 10).toFloat() <br/>    <strong class="oo jd">}<br/>    </strong>return Pair(x, y)<br/>}</span></pre><h2 id="169c" class="ob nf it bd ng oc od dn nk oe of dp no lr og oh nq lv oi oj ns lz ok ol nu iz bi translated">从给定坐标生成纱线路径</h2><pre class="ks kt ku kv gt on oo op oq aw or bi"><span id="a76f" class="ob nf it oo b gy os ot l ou ov">private fun createYarnLinePathFromCoordinates(<br/>    x: FloatArray,<br/>    y: FloatArray<br/>): Path {<br/>    val path = <em class="ow">Path</em>()<br/>    path.moveTo(x[0], y[0])<br/>    path.cubicTo(x[1], y[1], x[2], y[2], x[2], y[2])<br/>    return path<br/>}</span></pre><h2 id="89bc" class="ob nf it bd ng oc od dn nk oe of dp no lr og oh nq lv oi oj ns lz ok ol nu iz bi translated">生成纱线线条颜色</h2><pre class="ks kt ku kv gt on oo op oq aw or bi"><span id="9fec" class="ob nf it oo b gy os ot l ou ov">private fun generateYarnLineColor(<br/>    m2d: Double,<br/>    m3d: Double,<br/>    offset: Double<br/>): Triple&lt;Int, Int, Int&gt; {<br/>    fun color(variant: Double) = <br/>        0xFF - (0xFF * <em class="ow">noise3D</em>(variant, m2d, m3d)).toInt()<br/>    val red = color(offset + 35)<br/>    val green = color(offset + 25)<br/>    val blue = color(offset + 15)<br/>    return Triple(red, green, blue)<br/>}</span></pre><h2 id="db29" class="ob nf it bd ng oc od dn nk oe of dp no lr og oh nq lv oi oj ns lz ok ol nu iz bi translated">获取鼠标Y坐标</h2><pre class="ks kt ku kv gt on oo op oq aw or bi"><span id="3209" class="ob nf it oo b gy os ot l ou ov">private fun getMouseYCoordinate(mouseVector: Vector2D, size: Size) =<br/>    max(min(mouseVector.y / size.height, 1f), 0f)</span></pre><p id="5e42" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这在绘制路径的代码中用来设置绘图的不透明性</p><pre class="ks kt ku kv gt on oo op oq aw or bi"><span id="5108" class="ob nf it oo b gy os ot l ou ov">drawScope.drawPath(<br/>    path,<br/>    <em class="ow">Color</em>(red, green, blue),<br/>    alpha = <strong class="oo jd"><em class="ow">getMouseYCoordinate</em></strong>(mouseVector, size),<br/>    style = Stroke(width = 0.3f)<br/>)</span></pre><h2 id="b388" class="ob nf it bd ng oc od dn nk oe of dp no lr og oh nq lv oi oj ns lz ok ol nu iz bi translated">获取鼠标X坐标</h2><pre class="ks kt ku kv gt on oo op oq aw or bi"><span id="f46c" class="ob nf it oo b gy os ot l ou ov">private fun getMouseXCoordinate(mouseVector: Vector2D) =<br/>    max(0f, mouseVector.x - 2).toInt()</span></pre><p id="2b7f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这在顶部代码中使用，以确定我们需要绘制多少条纱线线。</p><pre class="ks kt ku kv gt on oo op oq aw or bi"><span id="2b00" class="ob nf it oo b gy os ot l ou ov">for (i in 0 <em class="ow">until </em><strong class="oo jd"><em class="ow">getMouseXCoordinate</em></strong>(mouseVector)) {<br/>    <em class="ow">drawYarnLine</em>(dimensFloat, offset, m2d, m3d, this, mouseVector)<br/>    offset += 0.002<br/>}</span></pre><p id="397b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个可能的问题是为什么我们有负2的<code class="fe oz pa pb oo b">mouseVector.x — 2</code>。</p><p id="23f1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样，为了提供上下文，我在Git commit消息中对它进行了大量描述，这样就不会弄乱代码。如果将来发生变化，就需要一个新的Git commit消息，这样消息就不会过时。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pc"><img src="../Images/e18842eed2cdd97e5759a165bd2d55ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dAA6vFZ4-ssHPR8nmtMdEg.png"/></div></div></figure></div><div class="ab cl pd pe hx pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="im in io ip iq"><h1 id="8be5" class="ne nf it bd ng nh pk nj nk nl pl nn no ki pm kj nq kl pn km ns ko po kp nu nv bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="fa51" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">从上面我们了解到，为了提高代码的可读性，我们可以做以下事情</p><ol class=""><li id="6501" class="mq mr it lk b ll lm lo lp lr ms lv mt lz mu md mv mw mx my bi translated">将侧面功能提取到不同的类中</li><li id="45d3" class="mq mr it lk b ll mz lo na lr nb lv nc lz nd md mv mw mx my bi translated">使用类名和变量名来解释意图</li><li id="67cb" class="mq mr it lk b ll mz lo na lr nb lv nc lz nd md mv mw mx my bi translated">将长函数分割成较小的函数</li><li id="c8de" class="mq mr it lk b ll mz lo na lr nb lv nc lz nd md mv mw mx my bi translated">函数名使每个上下文更加清晰</li><li id="dfa8" class="mq mr it lk b ll mz lo na lr nb lv nc lz nd md mv mw mx my bi translated">在Git提交消息中存储额外的相关信息</li><li id="58a9" class="mq mr it lk b ll mz lo na lr nb lv nc lz nd md mv mw mx my bi translated">为场景说明创建相关的测试用例</li><li id="f065" class="mq mr it lk b ll mz lo na lr nb lv nc lz nd md mv mw mx my bi translated">使用带有适当消息的测试断言来提供更好的失败环境</li></ol><h2 id="1be7" class="ob nf it bd ng oc od dn nk oe of dp no lr og oh nq lv oi oj ns lz ok ol nu iz bi translated">完整的更好的代码</h2><p id="2a16" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">比原来的长多了。这都是因为现在它包含了代码本身的大部分上下文。</p><p id="428f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">需要花时间去思考如何架构，比较长，但是值得。将来再读一遍也不会后悔</p><blockquote class="pp pq pr"><p id="9895" class="li lj ow lk b ll lm kd ln lo lp kg lq ps ls lt lu pt lw lx ly pu ma mb mc md im bi translated">我们将来可能仍然会后悔，不是因为太多的上下文，而是给出的上下文仍然不够…因此我不敢说这是一个好代码。从来没有完美的代码，最多只有足够好的代码。</p></blockquote><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mo mp l"/></div></figure></div></div>    
</body>
</html>