<html>
<head>
<title>More JavaScript Mistakes — Objects, Async Code, and Event Listeners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更多JavaScript错误——对象、异步代码和事件监听器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/more-javascript-mistakes-objects-async-code-and-event-listeners-ec478018a996?source=collection_archive---------5-----------------------#2020-01-27">https://levelup.gitconnected.com/more-javascript-mistakes-objects-async-code-and-event-listeners-ec478018a996?source=collection_archive---------5-----------------------#2020-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ab4dca5211792b04184566f4f4d2a25c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*08JD49KJiIIWZa0g"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@hakonbrakon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">hkon Helberg</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="3a08" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种比世界上许多其他编程语言更友好的语言。然而，在编写JavaScript代码时，由于误解或忽略我们已经知道的东西，仍然很容易犯错误。通过避免下面的一些错误，我们可以通过防止代码中的错误和错别字让我们的生活变得更容易，这些错误和错别字会让我们陷入意想不到的结果。在本文中，我们将会看到将对象键误认为数组索引，不理解异步代码，误用事件监听器。</p><h1 id="3eff" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">混淆对象键和数组索引</h1><p id="ef7b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在JavaScript中，括号可以用来接受一个对象，该对象可以接受一个包含属性名的字符串，然后从中获取值。例如，如果我们有以下对象:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="bcb1" class="mq lf it mm b gy mr ms l mt mu">const obj = {<br/>  foo: 1,<br/>  bar: 2<br/>}</span></pre><p id="353f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以通过编写以下内容之一来访问<code class="fe mv mw mx mm b">foo</code>属性的值:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0ecc" class="mq lf it mm b gy mr ms l mt mu">obj.foo</span></pre><p id="7caf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者我们可以使用括号符号并写下:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0733" class="mq lf it mm b gy mr ms l mt mu">obj['foo']</span></pre><p id="5cdf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">括号符号也用于通过索引访问数组条目。例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="67b1" class="mq lf it mm b gy mr ms l mt mu">const arr = [1, 2, 3];</span></pre><p id="4966" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9b79" class="mq lf it mm b gy mr ms l mt mu">arr[0]</span></pre><p id="820d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">来获取<code class="fe mv mw mx mm b">arr</code>数组的第一个条目。</p><p id="656f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们必须小心，不要混淆普通对象和数组，因为它们的值可以用括号符号访问，JavaScript解释器不会区分这两者。这意味着像这样的代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="70a1" class="mq lf it mm b gy mr ms l mt mu">arr['foo']</span></pre><p id="ac36" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中仍然是允许的。它不能阻止我们犯访问数组的错误——就像我们访问常规对象一样。如果我们记录下<code class="fe mv mw mx mm b">arr[‘foo’]</code>的值，我们只得到<code class="fe mv mw mx mm b">undefined</code>。</p><p id="783c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们不知道一个变量是一个常规对象，一个数组还是其他什么，那么我们可以使用<code class="fe mv mw mx mm b">Array.isArray</code>方法来检查我们传入的值是否是一个数组。它有一个参数，是我们想要检查的任何对象，看它是否是一个数组。</p><p id="51a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过使用<code class="fe mv mw mx mm b">Array.isArray</code>方法，如果<code class="fe mv mw mx mm b">Array.isArray</code>返回<code class="fe mv mw mx mm b">true</code>，我们将确保我们正在访问一个数组。例如，我们可以将其用作以下代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7201" class="mq lf it mm b gy mr ms l mt mu">const arr = [1, 2, 3]</span><span id="8dd5" class="mq lf it mm b gy my ms l mt mu">if (Array.isArray(arr)) {<br/>  console.log(arr[0]);<br/>}</span></pre><p id="40b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，在尝试访问数组条目之前，我们可以确定<code class="fe mv mw mx mm b">arr</code>是一个数组。</p><h1 id="9121" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不理解异步代码</h1><p id="a441" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">由于JavaScript的单线程特性，许多代码将会是异步的，因为如果等待需要一些时间的东西，比如来自HTTP请求的响应，那么一直一行行地运行代码将会使计算机挂起。</p><p id="d7f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于异步代码，我们经常会运行回调函数中的代码，它的运行时间是不确定的。它们不能像同步代码那样逐行运行。</p><p id="7862" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们想从get请求中获取一些数据，我们通常必须使用一个HTTP客户端，该客户端异步发出请求，并在不确定的时间内获得响应。</p><p id="bd40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们使用大多数现代浏览器内置的Fetch API，我们将异步获得响应数据。例如，我们会有如下所示的代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c528" class="mq lf it mm b gy mr ms l mt mu">fetch('<a class="ae kf" href="https://jsonplaceholder.typicode.com/todos/1'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/1'</a>)<br/>  .then((response) =&gt; {<br/>    return response.json()<br/>  })<br/>  .then((responseBody) =&gt; {<br/>    console.log(responseBody);<br/>  })</span></pre><p id="e38a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们看到的，我们有多个回调函数做不同的事情。如果我们写下如下内容:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6503" class="mq lf it mm b gy mr ms l mt mu">const response = fetch('<a class="ae kf" href="https://jsonplaceholder.typicode.com/todos/1'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/1'</a>)</span><span id="642f" class="mq lf it mm b gy my ms l mt mu">const responseBody = response.json()<br/>console.log(responseBody);</span></pre><p id="d9e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是行不通的，因为正确的代码不会一行一行地运行。在正确的代码中，调用了<code class="fe mv mw mx mm b">fetch</code>函数，该函数返回一个承诺，然后在第一个<code class="fe mv mw mx mm b">then</code>方法的回调函数中，我们返回了<code class="fe mv mw mx mm b">response.json()</code>对象的结果，该对象返回另一个承诺，该承诺解析为响应的JSON主体。然后在第二个<code class="fe mv mw mx mm b">then</code>方法的回调函数中，我们记录了通过解析<code class="fe mv mw mx mm b">response.json()</code>调用返回的承诺得到的<code class="fe mv mw mx mm b">responseBody</code>。</p><p id="765c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过链接，承诺可以按顺序运行，但它们不会瞬间运行，因此它们不像同步代码那样运行。</p><p id="e8d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一种看起来更像同步代码的简写方式是使用ES2017中引入的<code class="fe mv mw mx mm b">async</code>和<code class="fe mv mw mx mm b">await</code>关键字。我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e99d" class="mq lf it mm b gy mr ms l mt mu">fetch('<a class="ae kf" href="https://jsonplaceholder.typicode.com/todos/1'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/1'</a>)<br/>  .then((response) =&gt; {<br/>    return response.json()<br/>  })<br/>  .then((responseBody) =&gt; {<br/>    console.log(responseBody);<br/>  })</span></pre><p id="4b2f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">收件人:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7ead" class="mq lf it mm b gy mr ms l mt mu">(async () =&gt; {<br/>   const response = await fetch('<a class="ae kf" href="https://jsonplaceholder.typicode.com/todos/1'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/1'</a>);<br/>   const responseBody = await response.json();<br/>   console.log(responseBody);<br/> })();</span></pre><p id="7df0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个<code class="fe mv mw mx mm b">async</code>函数看起来像是逐行运行的，但它只是内部传递回调的<code class="fe mv mw mx mm b">then</code>方法调用的简写。除了在<code class="fe mv mw mx mm b">async</code>函数中的承诺，我们不能返回任何东西。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/3c7bfd38fcc465da27346079148daacd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gpyGLcFs2CbPAmU6"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@jademasri?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jade Masri </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="0571" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">添加太多事件侦听器</h1><p id="bc8c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们有下面的HTML代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3ad5" class="mq lf it mm b gy mr ms l mt mu">&lt;input type="checkbox" /&gt;</span><span id="d63d" class="mq lf it mm b gy my ms l mt mu">&lt;button&gt;Click&lt;/button&gt;</span></pre><p id="9403" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以及相应的JavaScript代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e544" class="mq lf it mm b gy mr ms l mt mu">const checkbox = document.querySelector('input[type=checkbox]');<br/>const button = document.querySelector('button');</span><span id="0db6" class="mq lf it mm b gy my ms l mt mu">checkbox.addEventListener('change', () =&gt; {<br/>  if (checkbox.checked) {<br/>    button.addEventListener('click', () =&gt; {<br/>      alert('Alert');<br/>    });<br/>  }<br/>});</span></pre><p id="d66b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们会看到，如果我们打开和关闭复选框几次，然后单击按钮，我们会看到“警报”弹出多次。这是因为我们在<code class="fe mv mw mx mm b">button</code>对象上使用了<code class="fe mv mw mx mm b">addEventListener</code>方法，该对象表示HTML中的按钮元素。每次复选框被选中时，<code class="fe mv mw mx mm b">addEventListener</code>方法都会附加一个新的点击事件监听器。这意味着我们有多个事件监听器监听按钮的click事件。当单击按钮最终触发click事件时，我们附加到按钮的所有click事件侦听器函数都将运行，导致“Alert”弹出窗口出现多次。</p><p id="e581" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们在按钮上附加了太多的事件监听器。</p><p id="6e23" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正确的做法是用相同的事件监听器函数来设置<code class="fe mv mw mx mm b">button</code>的<code class="fe mv mw mx mm b">onclick</code>属性。同样，我们也可以对<code class="fe mv mw mx mm b">checkbox</code>对象做同样的事情，即使我们没有相同的一致性问题。我们可以改为写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="60a8" class="mq lf it mm b gy mr ms l mt mu">const checkbox = document.querySelector('input[type=checkbox]');<br/>const button = document.querySelector('button');</span><span id="27b9" class="mq lf it mm b gy my ms l mt mu">checkbox.onchange = () =&gt; {<br/>  if (checkbox.checked) {<br/>    button.onclick = () =&gt; {<br/>      alert('Alert');<br/>    };<br/>  }<br/>};</span></pre><p id="b7ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过这种方式，我们一直覆盖分配给<code class="fe mv mw mx mm b">button.onclick</code>属性的<code class="fe mv mw mx mm b">onclick</code>事件监听器，而不是一直给它附加新的点击事件监听器。</p><p id="7ec0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中，括号可以用来接受一个对象，该对象可以接受一个包含属性名的字符串，然后从中获取值。对于数组，我们可以使用括号符号通过索引来访问数组元素。仅仅通过查看代码，没有办法区分一个对象是否有数组。因此，在试图通过索引访问项之前，我们应该检查一个对象实际上是否是一个数组。</p><p id="a0c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript中的许多代码都是异步的，因为JavaScript是单线程的，所以让所有代码一行一行地运行会使浏览器停止。这意味着我们必须使用异步代码，通过让没有立即返回结果的代码在后台等待来避免计算机停止工作。我们必须意识到代码在异步函数的回调函数中，因为它们不能存在于回调函数之外。</p><p id="e044" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们不应该过于频繁地使用<code class="fe mv mw mx mm b">addEventListener</code>,因为它会不断地向DOM对象添加新的事件监听器，而不会丢弃旧的。相反，我们可以使用将事件监听器函数设置为DOM对象的属性，该对象监听我们想要监听的事件。例如，如果我们想监听click事件，那么我们可以用我们定义的事件处理函数来设置DOM对象的<code class="fe mv mw mx mm b">onclick</code>属性。</p></div></div>    
</body>
</html>