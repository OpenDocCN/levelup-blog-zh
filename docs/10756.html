<html>
<head>
<title>Using Python’s Multiprocessing Library to Improve Algorithm Runtime</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python的多重处理库提高算法运行时间</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-pythons-multiprocessing-library-to-improve-algorithm-runtime-fd87e1f528c?source=collection_archive---------2-----------------------#2022-01-08">https://levelup.gitconnected.com/using-pythons-multiprocessing-library-to-improve-algorithm-runtime-fd87e1f528c?source=collection_archive---------2-----------------------#2022-01-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/efb3058e9cbcb0babe8a900834fa4fde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1-ykjBqen3CbcUfG"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">安德鲁·伍尔夫在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="b0bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<a class="ae kf" href="https://medium.com/star-gazers/a-primer-on-latin-squares-with-some-research-objectives-5f3ecb560544" rel="noopener">的上一篇文章</a>中，我写了一个被称为拉丁方块的组合物体。我还讨论了我以前做过的一些研究，以及使用这些对象的一些研究方向。特别是，我提到需要有效的算法来生成和处理这些对象。我对未来工作的一个目标是找到一个映射，它将获取一个<em class="le"> n x n </em>拉丁方的值，其中<em class="le"> n </em>是拉丁方的阶，并将它们映射到一个数字，理想情况下是一个可以用相对较少的位来表示的数字。</p><p id="be62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最近，我一直在尝试不同的公式来确定这样一个数字，并创建了一个Python脚本来测试不同的公式。对于拉丁方块的小订单，没有那么多，这工作得很好，直到订单5，表现还算合理(在大约8分钟内完成这个过程)。然而，有许多阶为6的拉丁方(根据我们的定义，超过1，000，000个<a class="ae kf" href="https://medium.com/star-gazers/a-primer-on-latin-squares-with-some-research-objectives-5f3ecb560544" rel="noopener">简化的拉丁方)花了大约6.5小时来检查。这导致我寻找快速加速算法的方法，我可以用Python的多重处理库来完成。</a></p><p id="077e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我将用一个非常简单的例子来介绍Python中的多重处理库，这个例子给出了它的用法的一个概述。我还将包括我的Python脚本的串行和多处理版本，以展示如何在任何应用程序中轻松实现这一点。</p><h1 id="8d7e" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">简单看一下多重处理库</h1><p id="16c4" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated"><a class="ae kf" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank"> Python3多重处理库</a>是一个用来产生进程的包，类似于线程库。出于本文的考虑，只有<a class="ae kf" href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool" rel="noopener ugc nofollow" target="_blank">池</a>将用于并行，因为它易于使用，并使基本线程化易于实现。例如，假设需要对从0开始的前10，000，000个整数求平方。要串行实现这一点，Python代码可能如下所示</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">对从0开始的前10，000，000个数字进行平方的串行脚本。</figcaption></figure><p id="fc2a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<em class="le">多重处理。池</em>让这个并行运行只需要很少的额外工作。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">使用8个进程并行实现平方问题。</figcaption></figure><p id="e879" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如这里所看到的，通过添加几行代码，我们已经成功地使它成为一个多处理应用程序。主要区别在于这两行的修改</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9ff4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在后一种代码(即多重处理代码)中，出现了<em class="le">多重处理。创建Pool </em>对象时传递了一个数字来表示要生成的进程的数量。然后调用<em class="le"> Pool.map() </em>将数字列表中的值(<em class="le"> values </em>)映射到要调用的函数(<em class="le"> square </em>)。其他一切都由多处理库和操作系统来处理。</p><p id="195b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">需要注意的一点是<em class="le">if _ _ name _ _ = = ' _ _ main _ _ ':</em>或多或少是必需的，因为由于处理进程和衍生进程的方式，脚本会出错，至少当我在Windows系统上运行它时会出错。</p><p id="943a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行10，000，000个数字的串行脚本大约需要。1.69秒。并行脚本大约在。1.98秒。这突出了应用并行化的一个重要方面:不是所有的应用都应该使用多线程/进程运行。虽然这个简单的例子很好地说明了如何快速使用多处理库来实现性能提升，但是多线程带来的开销比生成多个进程节省的时间要多。</p><h1 id="1da2" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">真正的应用</h1><p id="0752" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">正如介绍中提到的，我最近在自己创建的Python工具中使用了多处理库，与上面的例子不同，我看到了巨大的性能提升。下面是我使用的序列号</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">我用来检查我的映射对于每个拉丁方块是否唯一的算法的串行实现。</figcaption></figure><p id="1513" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面代码的性质并不重要。由于大多数读者不知道(或不关心)什么是拉丁方，我将试着把重点放在多处理的实现和性能增益的讨论上。对于那些感兴趣的人，我在整个代码中添加了一些稀疏的注释来帮助描述正在发生的事情。</p><p id="acee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在多处理实现中，有两件事是贯穿始终的:确定代表每个拉丁方块的值，以及确定每个值是否唯一的处理，后者要耗时得多。</p><p id="0024" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<em class="le">多重处理。Pool </em>类，我们必须有函数，使<em class="le"> Pool.map() </em>可以将提供的列表中的值映射到这些函数。因此，首先，我们将希望与多个进程一起运行的代码部分提取到单独的函数中</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">这两个函数将被<em class="mo">多重处理使用。Pool.map() </em>函数运行尽可能多的进程。</figcaption></figure><p id="dd49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的第一个函数确定拉丁方块映射到的数字，第二个函数将结果聚集到一个字典中，并检查重复的内容。</p><p id="bcc5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，通过将这种功能分解成函数，我们可以使用多处理库来加速算法。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">实现多重处理的拉丁方数唯一性检查算法。</figcaption></figure><p id="f335" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这相当多的代码，所以我将分解出最重要的部分，即多处理的实现</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">上面实现多重处理的代码部分。</figcaption></figure><p id="a282" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">再一次，多重处理。池对象被创建，这一次有20个进程可供池使用，因为我是在<a class="ae kf" href="https://medium.com/swlh/building-an-affordable-home-server-with-old-server-hardware-600-4670f685ad45" rel="noopener">我的服务器</a>上运行的。注释非常好，但是为了彻底，相同的进程池被用来将<em class="le"> get_value </em>函数映射到文件中的每个方块(<em class="le"> lines </em> object =代表拉丁方块的字符串列表)并通过<em class="le"> build_dict </em>函数创建一个字典列表。后一个函数实际上占用了串行脚本的大部分处理时间。</p><h1 id="c4b4" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">绩效结果</h1><p id="97d6" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">下表显示了串行脚本的结果</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">串行脚本的结果，大约需要。400分钟(6个多小时)完成。</figcaption></figure><p id="3941" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个脚本花费了令人难以置信的时间！不仅如此，随着订单的增加(略有增加),完成订单的时间会变得更长。这是由于拉丁方块的数量随着拉丁方块顺序的增加而增加<a class="ae kf" href="https://medium.com/@TorBair/exponential-growth-isn-t-cool-combinatorial-growth-is-85a0b1fdb6a5" rel="noopener"/>，想象一下必须对顺序8、9或10运行此操作！(为这些订单中的任何一个运行脚本都可能需要很长时间，因此不切实际。)让我们来看看添加多处理后的结果</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="6ed8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">生成20个进程使得这个检查脚本的运行时更加易于管理。对于在连续运行中花费了6个多小时的订单6，脚本在2.14分钟内完成，这是一个实质性的改进。订单5也是如此，它的运行时间从大约。8分钟缩短至3.75秒。我们在这里还可以看到，当运行时间从0.025秒增加到0.13秒时，多处理开销大于使用4阶进程所带来的速度提升。在这两种情况下，运行时间足够快，不会产生太大的差异。</p><h1 id="3c84" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="2cdd" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">在这篇文章中，我简要介绍了Python的多重处理库，特别是<em class="le">多重处理。池</em>对象。Pool允许任何开发人员快速改进慢速(er)算法的运行时，通常只需添加几行代码。我提供了一个小例子(它没有从多处理中受益)以及一个现实世界的应用程序，该应用程序只需对其实现进行小的调整就能受益匪浅。我还以类似的方式使用多处理库来处理我的股票研究网站ntrinsically.com的新闻文章，该网站每小时对数千篇新闻文章进行情感分析。这个易于使用的库的应用程序比比皆是，我希望这篇文章已经帮助您实现了多处理，或者至少演示了如何在野外使用它。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="f42a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">原载于2022年1月8日https://www.anthonymorast.com</em><a class="ae kf" href="https://www.anthonymorast.com/blog/2022/01/08/using-pythons-multiprocessing-library-to-improve-algorithm-runtime/" rel="noopener ugc nofollow" target="_blank"><em class="le"/></a><em class="le">。</em></p></div></div>    
</body>
</html>