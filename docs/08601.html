<html>
<head>
<title>Adapter Design Pattern Implementation in Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Typescript中的适配器设计模式实现</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/adapter-design-pattern-implementation-in-typescript-a33f481b9aff?source=collection_archive---------5-----------------------#2021-05-16">https://levelup.gitconnected.com/adapter-design-pattern-implementation-in-typescript-a33f481b9aff?source=collection_archive---------5-----------------------#2021-05-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9630" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">适配器设计将一个接口转换成另一个接口</h2></div><p id="0d7c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将学习适配器设计模式以及这种设计模式的用法。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/57e27e7019cc70d010fc6591f6bf0291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bOFlW-vowviqn4vWncflqg.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">适配器设计模式</figcaption></figure><p id="09bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">适配器设计模式是<strong class="kh ir">结构设计模式</strong>。</p><p id="92e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">结构设计模式</strong>关注的是如何组合类和对象，以形成更大的结构。</p><h2 id="01ed" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">适配器设计模式定义</h2><p id="e5e6" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">基于GoF，适配器模式用于将一个类的接口转换成另一个接口。这意味着我们可以让由于接口不兼容而无法协同工作的类协同工作。<br/> <strong class="kh ir">简而言之</strong>当我们只有很少的类(或者Javascript中的函数)并且这些类是不兼容的但是应该被用来满足相同的目标时，我们可以使用这种模式。换句话说，你可以<strong class="kh ir">包装</strong>一个不兼容的类，并创建一个适配器来按照你想要的方式使用它。</p><p id="3aca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设你有一张<strong class="kh ir">卡</strong>，你想用你的笔记本电脑<strong class="kh ir">读取</strong>那张卡，问题是你的卡<strong class="kh ir">与<strong class="kh ir"> USB端口</strong>不兼容</strong>，所以你需要一个<strong class="kh ir">读卡器</strong>来做这件事。<strong class="kh ir">读卡器</strong>就是这里的<strong class="kh ir">适配器</strong>！它让你读你的卡。</p><p id="a264" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">适配器设计模式的另一个众所周知的例子是将一个人的话翻译给另一个人的翻译器。</p><p id="36a3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种设计模式也被称为<strong class="kh ir">包装器设计模式。</strong></p><h2 id="01bc" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">这种设计模式的真实例子有哪些？</h2><ul class=""><li id="9751" class="mp mq iq kh b ki mk kl ml ko mr ks ms kw mt la mu mv mw mx bi translated">当新组件需要集成并与应用程序中的现有组件一起工作时。</li><li id="2916" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">用改进的接口重写了部分程序，但是旧代码仍然期望原始接口。</li><li id="6e75" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">当你有第三方API时，它有可能会改变。</li></ul><p id="c326" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在评论部分<strong class="kh ir">随意添加更多使用<strong class="kh ir">适配器设计模式的例子。</strong></strong></p><h2 id="740f" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">设计模式UML</h2><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nd"><img src="../Images/4f3e7a239ebea91cf32df183ae9204a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dvydbVU1LpRyIoeV980yaA.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">适配器设计模式</figcaption></figure><p id="f917" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">客户端</strong>是包含我们的应用程序逻辑的类</p><p id="3e4a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">适配器</strong>是与目标接口不兼容的类。</p><p id="0221" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">适配器</strong>是让客户端使用Adaptee类的类。</p><h1 id="e351" class="ne ls iq bd lt nf ng nh lw ni nj nk lz jw nl jx mc jz nm ka mf kc nn kd mi no bi translated">空谈不值钱！</h1><p id="6cf9" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">假设我们在应用程序中使用<strong class="kh ir"> Redis </strong>来存储一些对象，但是现在我们想在某些部分使用<strong class="kh ir"> MongoDB </strong> <em class="np">。</em></p><p id="1ca1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一种方法是添加MongoDB，并在所有我们希望使用MongoDB的地方重写代码。</p><p id="d1d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一种方法是使用一个<em class="np">适配器设计模式</em>来确保我们可以轻松地使用MongoDB。</p><p id="a097" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在使用Redis，我们有一个名为<strong class="kh ir"> IStore </strong>的界面</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">我们的存储界面</figcaption></figure><p id="463e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的Redis客户端实现是这样的(最简单的方式。请记住，<code class="fe ns nt nu nv b">ioredis</code>本身实现了set和get以及所有其他方法，我们可以直接使用Redis客户端，但只是想访问这两个方法):</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">Redis客户端实现</figcaption></figure><p id="685c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里是<strong class="kh ir">客户端</strong>，它是这里的用户。我们想知道其他人查看了此人的个人资料多少次，并且我们还想在有人访问此个人资料时增加这个数字:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="1558" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们正在使用Redis客户端，但我们想使用MongoDB。我们知道MongoDB与当前的结构不兼容。因此，解决方案是使用适配器:</p><p id="de49" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个MongoDB客户端，我们可以在数据库上执行查询，我们有这些方法<code class="fe ns nt nu nv b">insertOne</code>和<code class="fe ns nt nu nv b">findOne</code>。我们将实现<code class="fe ns nt nu nv b">IStore</code>接口，并使用MongoDB方法来存储和检索数据。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">MongoDB适配器</figcaption></figure><p id="f477" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们返回“OK ”,因为这是操作成功时Redis响应的样子。</p><p id="a89c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一部分是在客户机类中使用这个适配器类:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">使用MongoDB的客户端</figcaption></figure><p id="f7e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想一起检查这些部分并测试这个示例，这是MongoDB连接器文件:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="1aa5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经知道这可能不是一个完美的例子，但是我想你可以通过这个例子理解这个设计模式的目的。</p><div class="nw nx gp gr ny nz"><a href="https://refactoring.guru/design-patterns/adapter" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ir gy z fp oe fr fs of fu fw ip bi translated">适配器</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">适配器是一种结构化设计模式，它允许接口不兼容的对象进行协作。想象一下…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">重构大师</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ll nz"/></div></div></a></div><div class="nw nx gp gr ny nz"><a href="https://dofactory.com/javascript/design-patterns/adapter" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ir gy z fp oe fr fs of fu fw ip bi translated">适配器</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">适配器模式将一个接口(对象的属性和方法)转换成另一个接口。适配器允许…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">dofactory.com</p></div></div><div class="oi l"><div class="oo l ok ol om oi on ll nz"/></div></div></a></div><div class="nw nx gp gr ny nz"><a href="https://www.javatpoint.com/structural-design-patterns" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ir gy z fp oe fr fs of fu fw ip bi translated">结构设计模式-Java point</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">结构设计模式关注的是如何组合类和对象，以形成更大的结构。的…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">www.javatpoint.com</p></div></div></div></a></div></div></div>    
</body>
</html>