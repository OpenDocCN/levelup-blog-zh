# 探索编程语言中不同的垃圾收集方法

> 原文：<https://levelup.gitconnected.com/garbage-collectors-6ea8f00153f0>

![](img/72ba8f46670cfaf263eee4fc16f8f9b8.png)

洛伦·比瑟在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

# 介绍

垃圾收集器是一个自动释放程序不再需要的内存的程序。许多编程语言都使用垃圾收集器来自动管理内存，这可以简化编写代码的过程，并有助于防止常见的编程错误。

垃圾收集器是这样工作的:

1.  垃圾收集器跟踪程序正在使用的内存位置。
2.  当程序不再需要一块内存时，垃圾收集器会将它标记为可供重用。
3.  垃圾收集器定期扫描程序的内存，寻找不再使用的内存块。
4.  当垃圾收集器发现不再使用的内存块时，它会释放它以供重用。

垃圾收集器可以是引用计数，也可以是标记-清除。引用计数垃圾收集器跟踪每个内存块的引用数量，当引用计数达到零时，它们释放内存。标记和清除垃圾收集器定期扫描程序的内存，寻找不再使用的内存块，并释放这些内存块。

# 垃圾收集器的发展

随着编程语言和计算环境的变化，垃圾收集器已经有了很大的发展。下面是垃圾收集器发展的简要概述:

1.  **早期的垃圾收集器**:第一个垃圾收集器是在 20 世纪 60 年代为 Lisp 编程语言开发的。这些垃圾收集器是简单的引用计数收集器，跟踪对每块内存的引用数量，当引用计数达到零时，它们释放内存。
2.  标记并清除垃圾收集器:在 20 世纪 70 年代，标记并清除垃圾收集器是为 Smalltalk 编程语言开发的。这些垃圾收集器定期扫描程序的内存，寻找不再使用的内存块，并释放这些内存块。
3.  分代垃圾收集器:在 20 世纪 80 年代，分代垃圾收集器是为自编程语言开发的。这些垃圾收集器根据对象的年龄将程序的内存分成不同的代，他们分别收集每代中的垃圾。
4.  **并发垃圾收集器**:20 世纪 90 年代，并发垃圾收集器是为 Java 编程语言开发的。这些垃圾收集器与程序同时运行，允许程序在收集垃圾的同时继续运行。
5.  **实时垃圾收集器**:在 21 世纪初，实时垃圾收集器是为 Eiffel 编程语言开发的。这些垃圾收集器被设计成满足实时性能约束，允许程序运行而不被垃圾收集器中断。

# 垃圾收集方法

让我们更深入地了解随着时间的推移而发展起来的不同方法:

## 引用计数

引用计数:在引用计数垃圾收集中，垃圾收集器跟踪每个内存块的引用数量，当引用计数达到零时，它释放内存。这种方法简单而有效，但它可能会遇到一个称为“引用循环”的问题，在这个问题中，两个对象相互引用，并且这两个对象的引用计数永远不会达到零。

在 Python 中，当不再有对对象的引用时，对象的引用计数变为零。这可能以几种不同的方式发生:

1.  **当引用一个对象的变量超出作用域**:当一个变量超出作用域时，程序就不能再访问它了，变量所引用的对象的引用计数减一。如果对象的引用计数达到零，垃圾收集器将释放该对象占用的内存。
2.  **当一个变量被重新分配**:如果一个变量被重新分配来引用一个不同的对象，那么原始对象的引用计数会减一。如果原始对象的引用计数达到零，垃圾收集器将释放该对象占用的内存。
3.  **当一个对象被显式删除**:您可以使用`del`语句显式删除一个变量或对象，这将使对象的引用计数减一。如果对象的引用计数达到零，垃圾收集器将释放该对象占用的内存。

## 标记和清扫

在标记-清除垃圾收集中，垃圾收集器定期扫描程序的内存，寻找不再使用的内存块，并释放这些内存块。这种方法比引用计数更彻底，但是在垃圾收集时会导致程序执行暂停。

下面是标记和清除垃圾收集的工作原理:

1.  **标记阶段**:垃圾收集器从标记程序内存中所有仍在使用的对象开始。为了标记一个对象，垃圾收集器在对象的头中设置一个特殊的标志，表示该对象仍在使用中。
2.  **清扫阶段**:当所有仍在使用的对象都被标记后，垃圾收集器开始清扫阶段。在扫描阶段，垃圾收集器扫描程序的内存，寻找没有标记的内存块。这些内存块被认为是垃圾，它们被释放出来供重用。
3.  **压缩**:在清扫阶段完成后，垃圾收集器可以执行压缩，以更有效的方式重新安排程序的内存。在压缩过程中，垃圾收集器将仍在使用的对象移动到连续的内存块中，这可以提高程序的性能。

## 生育的

在分代垃圾收集中，垃圾收集器根据对象的年龄将程序的内存分成不同的代，并分别收集每代中的垃圾。这种方法比标记-清除法更有效，因为它专注于收集年轻一代中的垃圾，年轻一代更有可能是垃圾。

## 同时发生的

在并发垃圾收集中，垃圾收集器与程序并发运行，允许程序在收集垃圾的同时继续运行。这种方法比标记-清除方法更有效，因为它不会导致程序执行暂停，但它需要更复杂的实现。

下面是并发垃圾收集的工作原理:

1.  **并发收集**:垃圾收集器从与程序并发运行开始，扫描程序内存中不再使用的内存块。当垃圾收集器找到不再使用的内存块时，它会释放这些内存块以供重用。
2.  **停止世界**:当垃圾收集器需要执行某些需要程序停止的任务时，它会暂时停止程序并执行任务。这就是所谓的“停止世界”。例如，垃圾收集器可能需要停止程序来更新指向在压缩期间被移动的对象的指针，或者更新与其他线程共享的对象的引用计数。
3.  **并发压缩**:一些并发垃圾收集器也支持并发压缩，它允许垃圾收集器在程序运行时以更有效的方式重新安排程序的内存。这可以提高程序的性能，但需要更复杂的实现。

## 实时

在实时垃圾收集中，垃圾收集器被设计成满足实时性能约束，允许程序运行而不被垃圾收集器中断。这种方法对于需要可预测性能的程序很有用，但是实现起来可能更困难。

以下是实时垃圾收集的工作原理:

1.  **可预测的收集时间**:垃圾收集器被设计成在可预测的时间执行垃圾收集，这样程序就可以满足它的实时性能约束。例如，垃圾收集器可以被设计成以固定的时间间隔执行垃圾收集，或者它可以被设计成在程序空闲时执行垃圾收集。
2.  **最小化停止世界**:实时垃圾收集器被设计成在垃圾收集期间最小化程序必须停止的时间。这就是所谓的“停止世界”。例如，垃圾收集器可以被设计成执行增量收集，其中它在一段时间内以小增量收集垃圾，而不是一次全部收集。
3.  **可预测的暂停时间**:实时垃圾收集器也被设计成最小化由于停止运行而导致的暂停时间。这有助于确保程序满足其实时性能约束。

总的来说，在编程语言中有几种不同的垃圾收集方法。每种方法都有自己的优缺点，合适的方法取决于程序的要求。

# Python 中的垃圾收集

在 Python 中，垃圾收集是由`gc`(垃圾收集器)模块执行的，它是一个内置模块，是 Python 标准库的一部分。`gc`模块提供控制垃圾收集器和访问垃圾收集器信息的功能。

下面是 Python 如何使用垃圾收集器的:

1.  Python 使用引用计数垃圾收集器来自动管理内存。这意味着 Python 会跟踪对每个内存块的引用数量，当引用计数达到零时，它会释放内存。
2.  当对象的引用计数达到零时，Python 的垃圾收集器会自动触发。当这种情况发生时，垃圾收集器会释放该对象占用的内存，并使其可供重用。
3.  Python 的垃圾收集器也有一个标记-清除阶段，它会定期触发，或者在垃圾收集器认为有必要时触发。在标记和清除阶段，垃圾收集器扫描程序的内存，寻找不再使用的内存块，并释放这些内存块。
4.  Python 的垃圾收集器可以使用`gc`模块来控制。例如，您可以使用`gc.enable()`和`gc.disable()`函数来启用或禁用垃圾收集器。您还可以使用`gc.collect()`函数来强制垃圾收集器立即运行。

总的来说，Python 使用引用计数垃圾收集器来自动管理内存，确保代码的效率和可靠性。`gc`模块提供了控制垃圾收集器和访问垃圾收集器信息的功能。

# 编程语言设计中垃圾收集的未来方向

以下是编程语言设计中垃圾收集的一些潜在未来方向:

1.  **连续垃圾收集**:一些编程语言正在探索使用连续垃圾收集，垃圾收集器在后台连续运行，而不是周期性运行。这可以让垃圾收集器更高效，更快地释放内存。
2.  **增量垃圾收集**:垃圾收集的另一个方向是使用增量垃圾收集，垃圾收集器在一段时间内以小增量收集垃圾，而不是一次全部收集。这有助于最小化垃圾收集对程序性能的影响。
3.  **并行垃圾收集**:一些编程语言正在探索使用并行垃圾收集，其中垃圾收集器使用多个线程或内核并发执行垃圾收集。这可以让垃圾收集器更高效，更快地释放内存。
4.  **可预测的垃圾收集**:垃圾收集的另一个方向是使用可预测的垃圾收集，其中垃圾收集器被设计成满足特定的性能约束或者在可预测的时间执行垃圾收集。这对于需要可预测性能的程序很有用，例如控制关键系统或与用户实时交互的程序。
5.  **混合垃圾收集**:一些编程语言正在探索混合垃圾收集的使用，其中垃圾收集器结合了多种垃圾收集技术，以达到最佳性能。这可以让垃圾收集器更高效，更快地释放内存。

我希望你喜欢读这篇文章。如果你愿意支持我成为一名作家，考虑注册[成为一名媒体成员](https://medium.com/@smohajer85/membership)。每月只需 5 美元，你就可以无限制地使用 Medium。

# 分级编码

感谢您成为我们社区的一员！在你离开之前:

*   👏为故事鼓掌，跟着作者走👉
*   📰更多内容请查看[升级编码刊物](https://levelup.gitconnected.com/?utm_source=pub&utm_medium=post)
*   🔔关注我们:[推特](https://twitter.com/gitconnected) | [LinkedIn](https://www.linkedin.com/company/gitconnected) | [时事通讯](https://newsletter.levelup.dev)

🚀👉 [**加入升级人才集体，找到一份神奇的工作**](https://jobs.levelup.dev/talent/welcome?referral=true)