<html>
<head>
<title>On Lambdas, Anonymous Classes and Serialization in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的Lambdas、匿名类和序列化</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/on-lambdas-anonymous-classes-and-serialization-in-java-72173e345492?source=collection_archive---------9-----------------------#2020-01-13">https://levelup.gitconnected.com/on-lambdas-anonymous-classes-and-serialization-in-java-72173e345492?source=collection_archive---------9-----------------------#2020-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f7c5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">或者，使用lambdas的另一个原因</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bb02da7a4134be101c407880fd7106fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p5iMWpmZ7HjMaMQUyk4aNg.jpeg"/></div></div></figure><h1 id="97f1" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">Java中的序列化</h1><p id="2115" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Java中的序列化是一种机制，通过这种机制，对象可以在字节流之间进行封送，例如，允许它们在套接字中发送或存储在文件中。作为一个例子，考虑一个远程服务，它通过套接字发送一个要在别处执行的任务(使用特定代码或现有的框架，如RMI):</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="aa67" class="ml ks iq mh b gy mm mn l mo mp">public void execute(Runnable task) throws IOException {<br/>  // sends the task somewhere to be executed<br/>}</span></pre><p id="fd78" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">实现了<code class="fe mv mw mx mh b">Runnable</code>和<code class="fe mv mw mx mh b">java.io.Serializable</code>接口的任务对象可以用作这个远程服务的目标。它们将在方法<code class="fe mv mw mx mh b">execute</code>中被序列化，字节被发送到别处并在那里被反序列化以重新创建要执行的任务。任务的远程执行类似于<code class="fe mv mw mx mh b">service.execute(new SomeTask(...)</code>，其中<code class="fe mv mw mx mh b">SomeTask</code>被定义为:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="e667" class="ml ks iq mh b gy mm mn l mo mp">class SomeTask implements Runnable, Serializable {<br/>  private final String name;<br/> <br/>  public SomeTask(String <em class="mf">name</em>) {<br/>    this.name = <em class="mf">name</em>;<br/>  }<br/><br/>  public void run() { /* do something */ }<br/>}</span></pre><p id="8695" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">序列化的一个重要方面是，它不适用于单个实例，而是适用于对象的图。在不发送相应的<code class="fe mv mw mx mh b">String</code>对象<code class="fe mv mw mx mh b">name</code>的情况下，发送构成<code class="fe mv mw mx mh b">SomeTask</code>实例的字节没有什么价值。因此，序列化过程遵循对象中的所有字段，并递归地序列化被引用的对象。</p><p id="4382" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">如果此图中的对象无法序列化，这将导致问题。如果进程遇到不可序列化的字段，它将在运行时失败。例如，<code class="fe mv mw mx mh b">SomeTask</code>的这种变体将不起作用:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="5950" class="ml ks iq mh b gy mm mn l mo mp">class SomeTask implements Runnable, Serializable {<br/>  private final String name;<br/>  private Timer timer = new Timer();<br/> <br/>  public SomeTask(String <em class="mf">name</em>) {<br/>    this.name = <em class="mf">name</em>;<br/>  }<br/><br/>  public void run() { /* do something */ }<br/>}</span></pre><p id="cfb1" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">当将此类的实例提供给远程服务时，会出现错误:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="fe5a" class="ml ks iq mh b gy mm mn l mo mp">Exception in thread "main" java.io.NotSerializableException: java.util.Timer</span></pre><p id="b68d" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated"><code class="fe mv mw mx mh b">Timer</code>类是不可序列化的，因为它包含一个负责执行调度给计时器的任务的运行线程，而线程是不可序列化的。<code class="fe mv mw mx mh b">SomeTask</code>中任何不可序列化类型的字段都会产生类似的错误。</p><p id="7bec" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">解决这个困难的一个方法是使用<em class="mf">瞬态</em>字段，序列化过程不<em class="mf">而</em>遵循这个字段。这个修改后的声明产生了可以序列化的任务:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="594b" class="ml ks iq mh b gy mm mn l mo mp">transient private Timer timer = new Timer();</span></pre><p id="ec8f" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">因为有了<code class="fe mv mw mx mh b">transient</code>关键字，所以在序列化过程中会跳过<code class="fe mv mw mx mh b">timer</code>字段。然而，实际上，在远程站点上通过反序列化重新创建的任务在其计时器字段中会有<code class="fe mv mw mx mh b">null</code>。为了避免这种情况，可以定制反序列化过程，以便在从字节流创建任务对象时重新创建新的计时器:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="e61c" class="ml ks iq mh b gy mm mn l mo mp">private void readObject(ObjectInputStream <em class="mf">in</em>) throws IOException, ClassNotFoundException {<br/>  <em class="mf">in</em>.defaultReadObject(); // recreate a task object from bytes<br/>  timer = new Timer();    // replace null with a new timer<br/>}</span></pre><h1 id="8110" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">匿名类</h1><p id="0b43" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">对于足够简单和小的任务，通常情况下可以在匿名类中实现<code class="fe mv mw mx mh b">Runnable</code>接口。人们可能会写道:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="16aa" class="ml ks iq mh b gy mm mn l mo mp">service.execute(new Runnable() {<br/>  public void run() { /* do something */ }<br/>});</span></pre><p id="47c5" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">这不起作用，因为匿名类的实例没有实现<code class="fe mv mw mx mh b">Serializable</code>接口。由于匿名类不能在Java中实现多个接口，因此有必要定义一个中间接口，如下所示:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="c71b" class="ml ks iq mh b gy mm mn l mo mp">interface SerializableRunnable extends Runnable, Serializable {}</span></pre><p id="7a9e" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">使用它，可以编译和执行以下代码:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="cbfc" class="ml ks iq mh b gy mm mn l mo mp">service.execute(new SerializableRunnable() {<br/>  public void run() { /* do something */ }<br/>});</span></pre><p id="0d32" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">但是，即使匿名类不包含不可序列化的字段，它也很可能会因序列化异常而失败。原因是匿名类的实例包含了对定义匿名类的外部类实例的隐式引用(如果<code class="fe mv mw mx mh b">Outer</code>是外部类的名称，则称为<code class="fe mv mw mx mh b">Outer.this</code>)。序列化将遵循这个引用(它不能成为<code class="fe mv mw mx mh b">transient</code>)，这在一般情况下是不可序列化的(即使是可序列化的，也可能会产生大量的字节流)。例如，上面的代码摘录可以在一个更大的<code class="fe mv mw mx mh b">BigApp</code>类中定义:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="6814" class="ml ks iq mh b gy mm mn l mo mp">class BigApp {<br/>  // non serializable stuff, e.g., <br/>  private Timer mainTimer = ...;</span><span id="a7f0" class="ml ks iq mh b gy my mn l mo mp">  void someMethod(RemoteService <em class="mf">service</em>) throws IOException {<br/>    <em class="mf">service</em>.execute(new SerializableRunnable() {<br/>      public void run() { /* do something */ }<br/>    });<br/>  }</span></pre><p id="caaa" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">匿名类实例<code class="fe mv mw mx mh b">execute</code>的参数包含一个隐式引用<code class="fe mv mw mx mh b">BigApp.this</code>，该引用指向<code class="fe mv mw mx mh b">BigApp</code>的封闭实例，包括一个计时器和许多其他不可序列化的组件。代码因序列化错误而失败:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="5418" class="ml ks iq mh b gy mm mn l mo mp">Exception in thread "main" java.io.NotSerializableException: BigApp</span></pre><p id="78ae" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">目的是将一个小任务发送到远程服务，而不是将整个应用程序转换成字节流！</p><h1 id="b648" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">使用lambdas</h1><p id="be63" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Java 8引入了<em class="mf"> lambdas </em>，在很多场景下已经取代了匿名类。Java的lambdas没有与之关联的类型。相反，它们可以用作各种<em class="mf">函数类型</em>的目标值，这些函数类型是具有单一方法的接口，如<code class="fe mv mw mx mh b">Runnable</code>。下面的调用可以编译:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="c29d" class="ml ks iq mh b gy mm mn l mo mp">service.execute(() -&gt; /* do something */);</span></pre><p id="3faf" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">但是它在运行时会产生一个错误，因为lambda被赋予了<code class="fe mv mw mx mh b">execute</code>方法的参数类型— <code class="fe mv mw mx mh b">Runnable</code> —这是不可序列化的。</p><p id="4d30" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">为了解决这个问题，必须重新定义<code class="fe mv mw mx mh b">execute</code>以使用类型<code class="fe mv mw mx mh b">SerializableRunnable</code>来代替:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="4255" class="ml ks iq mh b gy mm mn l mo mp">public void execute(SerializableRunnable <em class="mf">task</em>) throws IOException {<br/>  ...<br/>}</span></pre><p id="4dea" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">因为<code class="fe mv mw mx mh b">Serializable</code>接口是空的(它只是一个<em class="mf">标记</em>接口)，<code class="fe mv mw mx mh b">SerializableRunnable</code>只包含一个方法<code class="fe mv mw mx mh b">run</code>，因此可以是lambda的目标类型。调用<code class="fe mv mw mx mh b">service.execute(() -&gt; ...)</code>仍然是可能的，但是lambda现在被分配了类型<code class="fe mv mw mx mh b">SerializableRunnable</code>而不是<code class="fe mv mw mx mh b">Runnable</code>。以下代码在远程站点上工作并打印<code class="fe mv mw mx mh b">hello</code>:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="8f4d" class="ml ks iq mh b gy mm mn l mo mp">class BigApp implements Serializable {<br/>  // non serializable stuff<br/>  private Timer mainTimer = ...;<br/><br/>  void someMethod(RemoteService <em class="mf">service</em>) throws IOException {<br/>    <em class="mf">service</em>.execute(() -&gt; System.<em class="mf">out</em>.println("hello"));<br/>  }<br/>}</span></pre><h1 id="b816" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">对外对象的隐式引用发生了什么变化？</h1><p id="af8b" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">此时，敏锐的读者可能会想:“等一下。由于对外部对象的隐式引用，它对匿名类不起作用。如果使用lambda，它为什么会工作？”</p><p id="eb22" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">事实证明，在Java中，lambdas的实现不同于匿名类(使用一个字节码指令<code class="fe mv mw mx mh b">INVOKEDYNAMIC</code>),并且可以在不隐式引用外部对象的情况下创建。</p><p id="afb9" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">但是这种解释不会让我们精明的读者满意，他们现在在想:“匿名类维护对外部对象的引用是有原因的。如果一个lambda实际上使用了外部实例呢？”事实上，以下代码在运行时尝试序列化外部对象时会失败:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="736a" class="ml ks iq mh b gy mm mn l mo mp"><em class="mf">service</em>.execute(() -&gt; System.<em class="mf">out</em>.println(mainTimer));</span></pre><p id="25ae" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">这是因为<code class="fe mv mw mx mh b">mainTimer</code>实际上是<code class="fe mv mw mx mh b">BigApp.this.mainTimer</code>，并且需要<code class="fe mv mw mx mh b">BigApp</code>实例的序列化。</p><p id="00d2" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">简而言之，在Java中——撰写本文时是Java 13——lambda的实现比匿名类更智能。如果需要，它们只包含对外部对象的引用。如果一个lambda引用一个(非静态)字段(如<code class="fe mv mw mx mh b">mainTimer</code>)或外部类的一个(非静态)方法(从而导致一个<em class="mf">闭包</em>，那么这个引用就变得必要并被生成。但除此之外，默认情况下并不包含它，这使得一些lambdas可以序列化，而匿名类则不能。与lambdas同时引入的<em class="mf">方法引用</em>也是如此。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="ae33" class="ml ks iq mh b gy mm mn l mo mp"><em class="mf">service</em>.execute(BigApp::<em class="mf">doSomething</em>)</span></pre><p id="14bd" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">如果<code class="fe mv mw mx mh b">doSomething</code>是类<code class="fe mv mw mx mh b">BigApp.</code>的一个静态方法，这就有效</p><h1 id="4425" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">避免<code class="fe mv mw mx mh b">SerializableRunnable</code></h1><p id="cde6" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">对于要用作可序列化对象的lambdas，我们必须引入一个<code class="fe mv mw mx mh b">SerializableRunnable</code>目标类型作为接口。这是不可取的，因为它改变了<code class="fe mv mw mx mh b">execute</code>方法的签名，因此需要像<code class="fe mv mw mx mh b">SomeTask</code>这样的类来显式实现<code class="fe mv mw mx mh b">SerializableRunnable</code>接口。这可以通过使用<em class="mf">交集类型</em>来避免，要么在调用点类型转换中，要么在方法<code class="fe mv mw mx mh b">execute</code>的参数化变体中。</p><p id="7029" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">类型转换的想法是使用类型转换强制lambda获得<code class="fe mv mw mx mh b">Runnable</code> <em class="mf">和</em> <code class="fe mv mw mx mh b">Serializable</code>类型:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="95a2" class="ml ks iq mh b gy mm mn l mo mp">public void execute(Runnable <em class="mf">task</em>) throws IOException { ... }</span><span id="c391" class="ml ks iq mh b gy my mn l mo mp">service.execute((Serializable &amp; Runnable) () -&gt; ...);</span><span id="8327" class="ml ks iq mh b gy my mn l mo mp"><em class="mf">service</em>.execute((Serializable &amp; Runnable) BigApp::<em class="mf">doSomething</em>);</span></pre><p id="15ca" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">lambda和方法引用在被类型转换为交集类型<code class="fe mv mw mx mh b">Serializable &amp; Runnable</code>后，都可以用作方法<code class="fe mv mw mx mh b">execute</code>的目标。注意<code class="fe mv mw mx mh b">execute</code>又回到了在它的签名中使用<code class="fe mv mw mx mh b">Runnable</code>。</p><h1 id="3d02" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">避免类型转换</h1><p id="5408" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">最后，因为类型参数化(泛型)比类型转换更好，所以可以在方法<code class="fe mv mw mx mh b">execute</code>的定义中使用交集类型，以允许直接使用lambdas和方法引用:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="f634" class="ml ks iq mh b gy mm mn l mo mp">public &lt;R extends Serializable &amp; Runnable&gt;<br/>  void execute(R <em class="mf">task</em>) throws IOException { ... }</span><span id="6ae9" class="ml ks iq mh b gy my mn l mo mp">service.execute(() -&gt; ...);</span><span id="152e" class="ml ks iq mh b gy my mn l mo mp"><em class="mf">service</em>.execute(BigApp::<em class="mf">doSomething</em>);</span></pre><p id="e40f" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">这种方法不需要任何类型转换(至少在Java 11和更高版本中是这样；它过去不能与早期版本的Java一起工作)。来自远程服务的方法<code class="fe mv mw mx mh b">execute</code>由类型<code class="fe mv mw mx mh b">R</code>参数化，类型<code class="fe mv mw mx mh b">R</code>表示可序列化任务的类型，并且要求是<code class="fe mv mw mx mh b">Serializable</code>和<code class="fe mv mw mx mh b">Runnable</code>的子类型。代码依赖于<code class="fe mv mw mx mh b">extends</code>关键字，在Java中用于类型上限。</p><h1 id="2029" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">结论</h1><p id="8991" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在Java中，lambdas不是匿名类上的语法糖。它们独立于匿名类实现(比匿名类更智能)。特别是，只有当代码中的闭包需要这样做时，它们才维护对外部对象的引用。否则，它们会避免这种情况，因此可以在匿名类的实例不可序列化的情况下进行序列化。</p><p id="9a02" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">本文主要关注序列化(作者首先意识到lambda和匿名类的行为不同)，但是lambda避免了对外部对象的不必要引用，这一事实也有利于垃圾收集，与序列化问题无关。另一个更喜欢lambdas而不是匿名类的原因。</p><p id="27d2" class="pw-post-body-paragraph lj lk iq ll b lm mq jr lo lp mr ju lr ls ms lu lv lw mt ly lz ma mu mc md me ij bi translated">Java 8中引入的交集类型，在我们需要一个类型为<code class="fe mv mw mx mh b">Serializable</code>的lambda以及一些函数类型(如<code class="fe mv mw mx mh b">Runnable</code>)时，帮了我们大忙。交集类型不是Java的一个常用特性，但是当需要一个方法参数来实现多个不相关的超类型时，应该记住它们。</p></div></div>    
</body>
</html>