<html>
<head>
<title>CICD for frontend with Firebase and GitHub Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有Firebase和GitHub操作的前端CICD</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/cicd-for-frontend-with-firebase-and-github-actions-2a2575acce2b?source=collection_archive---------10-----------------------#2020-08-09">https://levelup.gitconnected.com/cicd-for-frontend-with-firebase-and-github-actions-2a2575acce2b?source=collection_archive---------10-----------------------#2020-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6e20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">GitHub Actions让CICD变得简单了。将它与Firebase提供的免费托管服务结合起来，你马上就可以为你的前端应用程序准备好一个完全免费的功能齐全的CICD管道。</p><p id="3eea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为前端开发人员，我们可能经常需要向团队的其他成员演示我们的应用程序，以获得他们对应用程序的设计和用户体验的意见。然而，仅仅用投影仪或缩放会议给他们演示你的应用程序可能是不够的。</p><p id="f2b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">毕竟，除非你自己摆弄app，否则很难形成合格的意见。建立一个CICD管道来不断地将你的更改推送到网络上的一个工作应用程序中，这将会派上用场。</p><p id="7c60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">GitHub Actions允许你用几个<code class="fe kl km kn ko b">yaml</code>文件建立一个CICD管道。更重要的是，GitHub Actions是GitHub的一部分，你不必使用外部工具来设置CICD。</p><h1 id="4c00" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">管道</h1><p id="b573" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">因此，让我们深入了解情况，部署我们的CICD管道。这就是我们将要做的。</p><ol class=""><li id="751b" class="ls lt iq jp b jq jr ju jv jy lu kc lv kg lw kk lx ly lz ma bi translated">创建基于React的前端应用程序</li><li id="5e4b" class="ls lt iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">使用GitHub动作来自动化部署过程</li></ol><p id="eb36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的应用程序将部署在两种不同的环境中，即暂存和生产。创建拉请求时，应该构建应用程序来检查是否有任何构建错误。一旦拉请求被合并，那么，再一次，应用程序应该被构建，然后被部署到登台环境。一旦部署，应用程序的补丁版本应该被取消。</p><p id="1273" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当发布应用程序的预发布版本时，应该构建应用程序并将其部署到生产环境中。当最终版本发布时，应该构建应用程序并将其部署到生产环境中，之后应该删除应用程序的次要版本。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/315364054c818c30492daba9cf56e8db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/0*ClI5mWGghuzqSB3w"/></div></figure><h1 id="7929" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">创建React应用程序</h1><p id="2d6c" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">首先，让我们创建一个React应用程序。我将使用以下命令，使用Create React App环境引导一个简单的应用程序。</p><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="a1be" class="ms kq iq ko b gy mt mu l mv mw">npx create-react-app my-app</span></pre><p id="2691" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个简单的React应用程序，我们将使用GitHub操作将它部署到web上。在设置管道之前，我们需要创建两个环境。</p><h1 id="f912" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">安装Firebase工具</h1><p id="b201" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">为了在网络上托管应用程序，我决定在这里使用Firebase。但是你也可以试试其他免费的主机服务，比如Heroku。</p><p id="e027" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Firebase为我们提供了一个CLI应用程序，帮助我们轻松地将应用程序发布到Firebase。要使用它，让我们先安装它。</p><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="3056" class="ms kq iq ko b gy mt mu l mv mw">npm install -g firebase-tools</span></pre><p id="1fed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦安装，我们将不得不登录到我们的谷歌帐户。由于Firebase是谷歌提供的服务，我们需要一个谷歌帐户来访问他们的服务。使用以下命令登录。</p><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="a040" class="ms kq iq ko b gy mt mu l mv mw">firebase login</span></pre><p id="3c64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦您输入这个命令，您的浏览器将会打开Google登录表单。输入您的凭据，并授予Firebase CLI必要的权限。</p><h1 id="f485" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">初始化Firebase项目</h1><p id="3672" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">然后，我们可以使用下面的命令用Firebase启动我们的应用程序。</p><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="e422" class="ms kq iq ko b gy mt mu l mv mw">firebase init</span></pre><p id="a5a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦您输入这个命令，您将看到下面的屏幕。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/409571bfe25f9b37752e8836f291b87c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/0*C7Jz0sTxv49o0p4h"/></div></figure><p id="7c7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Firebase提供了很多服务，从虚拟主机到实时非SQL数据库。因为我们只想托管我们的web应用程序，所以我们需要从显示的服务列表中选择托管。选择它后，我们将进入下一个屏幕。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/e64fcae275bdb0554961ab9a3aaf6527.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/0*A3QiVpbXZaSCji9h"/></div></figure><p id="85d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们必须选择一个项目或创建一个新项目。因为我们没有项目，所以我们需要选择Create a new project选项。一旦选择，您将被要求提供一个项目的唯一id。提供一个。接下来，将要求您输入项目的名称。输入一个名称，然后按回车键。</p><p id="adf6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CLI可能需要几秒钟来创建项目。一旦完成，您将被要求设置<code class="fe kl km kn ko b">public</code>目录。<code class="fe kl km kn ko b">public</code>目录是应该提供静态文件的目录。大多数情况下，它是捆绑器捆绑JavaScript文件的目录。由于<code class="fe kl km kn ko b">Create React App</code>将文件输出到“构建”目录中，那应该是我们的公共目录。</p><p id="eab0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，输入<code class="fe kl km kn ko b">build</code>并回车。</p><p id="064e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一步中，您将被询问是否要重写所有的URL到<code class="fe kl km kn ko b">index.html</code>。因为我们的是单页应用程序，我们需要它。所以，说yes来完成初始化过程。</p><h1 id="ed68" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">创建Firebase站点</h1><p id="802a" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">完成后，我们必须转到Firebase控制台来创建另一个站点。创建托管项目时，Firebase已经创建了一个站点。但是，由于我们需要两个站点——一个用于试运行，一个用于生产，所以我们需要创建一个额外的站点。</p><p id="6533" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，请转到<a class="ae mx" href="https://console.firebase.google.com/" rel="noopener ugc nofollow" target="_blank">https://console.firebase.google.com/</a>并选择您刚才创建的项目。然后，从侧面板中选择主机。您可能需要单击“Get Started ”,并按照逐步说明进入控制台视图。</p><p id="4a2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在控制台视图中，靠近视图底部，有一个名为Add another site的按钮。点击它创建一个额外的网站。我们将使用该站点进行试运行，所以我们称之为“样品试运行”。添加后，新站点应该出现在域部分下。</p><p id="d641" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Firebase提供了“web.app”和“firebaseapp.com”两个域，因此您将看到每个站点有两个域。此时，最好记下已经存在的站点的名称。</p><h1 id="bf2c" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">部署到多个站点</h1><p id="46fd" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">现在，让我们回到我们的应用程序。由于我们有两个应用程序，我们现在需要告诉Firebase将我们的应用程序部署到哪个站点。我们可以通过使用目标名称，然后将目标名称映射到一个站点来做到这一点。</p><p id="4bc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要设置目标名称，请转到根目录下的<code class="fe kl km kn ko b">firebase.json</code>文件。在这里，您会发现<code class="fe kl km kn ko b">hosting</code>属性被分配了一个对象。我们需要用一组对象来替换它。为此，复制对象并将其传递到一个数组中。然后，复制对象，使数组有两个对象。在这两个对象中创建一个名为<code class="fe kl km kn ko b">target</code>的键，并将其中一个命名为“登台”,另一个命名为“生产”。</p><p id="590f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，你应该有这样的东西。</p><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="af98" class="ms kq iq ko b gy mt mu l mv mw">{ <br/>    "hosting": [ <br/>        { <br/>            "target": "staging", <br/>            "public": "build", <br/>            "ignore": [<br/>               "firebase.json", <br/>               "**/.*", <br/>               "**/node_modules/**"<br/>            ], <br/>            "rewrites": [ <br/>                { <br/>                    "source": "**", <br/>                    "destination": "/index.html" <br/>                } <br/>            ] <br/>         }, <br/>         { <br/>             "target": "production", <br/>             "public": "build", <br/>             "ignore": [<br/>                 "firebase.json",  <br/>                 "**/.*", <br/>                 "**/node_modules/**"<br/>             ], <br/>             "rewrites": [ <br/>                 { <br/>                     "source": "**", <br/>                     "destination": "/index.html" <br/>                 } <br/>             ] <br/>          } ] <br/>}</span></pre><p id="bdb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们需要将这些目标映射到正确的站点。为此，让我们使用下面的命令。</p><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="141f" class="ms kq iq ko b gy mt mu l mv mw">firebase target:apply &lt;service&gt; &lt;target&gt; &lt;site&gt;</span></pre><p id="4725" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">Service</code>指Firebase提供的不同服务。因为我们在这里使用的服务是托管，它应该是托管。<code class="fe kl km kn ko b">target</code>指的是我们在<code class="fe kl km kn ko b">firebase.json</code>文件中定义的目标名称。站点是我们希望目标映射到的站点的名称。</p><p id="20b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要将<code class="fe kl km kn ko b">staging</code>目标映射到我们的集结地。因此，使用下面的命令。</p><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="9033" class="ms kq iq ko b gy mt mu l mv mw">firebase target:apply hosting staging staging-github-actions</span></pre><p id="e948" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，让我们将生产目标映射到生产现场。</p><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="445d" class="ms kq iq ko b gy mt mu l mv mw">firebase target:apply hosting production production-github-actions</span></pre><p id="6d86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成后，我们可以使用下面的命令将我们的应用程序部署到Firebase。但我们不会在本地做，因为我们希望应用程序由GitHub Actions部署。</p><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="2801" class="ms kq iq ko b gy mt mu l mv mw">firebase deploy --only hosting:staging</span></pre><p id="9c7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，我们可以使用此命令部署到生产环境中:</p><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="1515" class="ms kq iq ko b gy mt mu l mv mw">firebase deploy --only hosting:production</span></pre><h1 id="7185" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">生成Firebase令牌</h1><p id="ae7b" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">请记住，我们的应用程序应该部署到GitHub Actions的Firebase。GitHub Actions所做的是在云中运行容器，按照我们的配置执行部署过程。因此，当从容器部署时，我们将无法通过通常的登录流程。请注意，部署过程是完全自动化的，因此您不能以任何方式进行干预。</p><p id="0e7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，应该有另一种方法来用Firebase验证我们自己。Firebase通过为我们提供令牌来帮助我们，我们可以使用这些令牌让GitHub Actions代表我们登录。因此，让我们通过输入以下命令来创建一个Firebase令牌。</p><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="b3ea" class="ms kq iq ko b gy mt mu l mv mw">firebase login:ci</span></pre><p id="ed27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可能会要求您再次登录。登录并授予必要的权限后，令牌应该会出现在终端上。复制一份。</p><p id="7a23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就完成了应用程序级的配置。现在，提交所有内容，并将其推送到GitHub repo。现在，让我们转到GitHub。</p><h1 id="bac6" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">GitHub秘密</h1><p id="98c0" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">首先，我们需要安全地存储我们的Firebase令牌。我们可以将它直接粘贴到配置文件中，但是这样做很危险，因为令牌会变成公共的。相反，我们应该使用GitHub提供的secrets选项来安全地存储秘密。在你的回购，到“设置”标签，并选择“秘密”从垂直菜单。</p><p id="098a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在“机密”页面上，单击“新建机密”按钮。为密码提供一个名称，并将我们刚刚复制的令牌粘贴到值文本区域，然后单击Add secret。我用了<code class="fe kl km kn ko b">FIREBASE_TOKEN</code>作为名字。</p><h1 id="9d71" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">创建个人访问令牌</h1><p id="d3c5" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">要创建个人访问令牌，请转到<a class="ae mx" href="https://github.com/settings/profile" rel="noopener ugc nofollow" target="_blank">https://github.com/settings/profile</a>并点击菜单底部的开发者设置。然后，从菜单中选择个人访问令牌，并单击生成新令牌。您可能需要在这里提供您的密码。使用注释文本框为令牌提供一个名称，并在repo下选择public_repo范围。这是我们唯一需要的范围。</p><p id="2024" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成后，复制令牌并将其存储在GitHub secrets中，就像我们之前处理Firebase令牌一样。请注意，您不能再次读取此令牌，这一点很重要。</p><h1 id="e6b7" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">配置GitHub动作</h1><p id="62d1" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">现在，是时候配置GitHub动作了。点击GitHub repo上的Actions选项卡，并从显示的工作流列表中选择“Node.js”。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/37b8f6ea581154b3cc6d1779227cbcba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/0*n-zlE23UbXIujpCK"/></div></figure><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="9dea" class="ms kq iq ko b gy mt mu l mv mw">on: push: branches: [ master ] pull_request: branches: [ master ]</span></pre><p id="69b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe kl km kn ko b">jobs-&gt;build-&gt;strategy-&gt;matrix</code>中，我们可以指定构建应该运行的节点版本。默认情况下，将选择10.x、12.x、14.x。当选择了三个版本时，GitHub Actions会同时运行三次动作。由于我们还想将我们的应用程序部署到Firebase，这也将同时部署三次，从而导致不可预测的行为。因此，建议只选择一个版本。我决定用10.x。</p><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="1f48" class="ms kq iq ko b gy mt mu l mv mw">strategy: matrix: node-version: [10.x]</span></pre><h1 id="0838" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">向GitHub操作添加步骤</h1><p id="5862" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">在样板文件中，你会看到使用了<code class="fe kl km kn ko b"><a class="ae mx" href="https://www.thearmchaircritic.org/cdn-cgi/l/email-protection" rel="noopener ugc nofollow" target="_blank">[email protected]</a></code>和<code class="fe kl km kn ko b"><a class="ae mx" href="https://www.thearmchaircritic.org/cdn-cgi/l/email-protection" rel="noopener ugc nofollow" target="_blank">[email protected]</a></code>。这些操作分别用于签出repo的分支和安装节点。在市场上可以找到更多这样的行动。</p><h1 id="40d6" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">使用GitHub操作配置登台</h1><p id="ad12" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">这些是我们在试运行期间需要执行的步骤。</p><p id="0849" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您观察样板文件，第一个文件应该已经配置好了。但是这将是设置节点的步骤的一部分。让我们把它分解成一个单独的步骤。因此，使用连字符创建一个步骤，然后将名称设置为<code class="fe kl km kn ko b">Build Project</code>。<code class="fe kl km kn ko b">run</code>属性用于运行命令。通过使用管道(<code class="fe kl km kn ko b">|</code>)操作符并在它下面的行中输入命令，可以运行多个命令。</p><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="e2d1" class="ms kq iq ko b gy mt mu l mv mw">- name: Build Project run: | npm ci npm run build --if-present npm test</span></pre><h1 id="be44" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">从GitHub Actions部署到Firebase</h1><p id="8b2c" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">现在让我们创建下一步。我们必须安装firebase工具，然后将应用程序部署到Firebase。为了能够部署，我们应该首先进行身份验证。为此，我们需要使用存储在GitHub secrets中的令牌。可以通过以下方式访问GitHub机密。</p><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="6244" class="ms kq iq ko b gy mt mu l mv mw">${{secrets.FIREBASE_TOKEN}}</span></pre><p id="dac0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，<code class="fe kl km kn ko b">secrets</code>后面都是秘密的名称。我们需要将秘密设置为一个环境变量。我们可以使用<code class="fe kl km kn ko b">env</code>属性来做到这一点。然后，我们可以在部署时使用令牌标志来引用这个环境变量。</p><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="5f53" class="ms kq iq ko b gy mt mu l mv mw">- name: Install Firebase CLI <br/>env: FIREBASE_TOKEN: ${{secrets.FIREBASE_TOKEN}} <br/>run: | <br/>   sudo npm install -g firebase-tools <br/>   firebase deploy --token $FIREBASE_TOKEN --only hosting:staging --non-interactive</span></pre><p id="ea28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，我们希望我们的应用程序仅在合并了拉请求时才被部署。但是，当发出拉请求和合并请求时，都会触发此操作。我们可以使用<code class="fe kl km kn ko b">if</code>属性有条件地运行这个步骤。</p><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="14ab" class="ms kq iq ko b gy mt mu l mv mw">if: github.event_name=='push'</span></pre><p id="391c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只有当事件是推送时，才会运行此步骤。值得注意的是，当一个拉请求被合并时，我们实际上是把合并提交推给了回购。</p><h1 id="4ee1" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">碰撞版本</h1><p id="5566" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">现在，让我们撞版本。既然git已经安装好了，我们只需要配置git并撞上版本。但是为了能够推送提交，我们需要已经被认证。我们可以使用个人访问令牌来验证自己。</p><p id="2d82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们配置的第一步是使用<code class="fe kl km kn ko b"><a class="ae mx" href="https://www.thearmchaircritic.org/cdn-cgi/l/email-protection" rel="noopener ugc nofollow" target="_blank">[email protected]</a></code>动作检查我们的回购。您可以使用属性传递令牌，让操作在签出之前登录到我们的repo。</p><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="32c9" class="ms kq iq ko b gy mt mu l mv mw">- uses: actions/<a class="ae mx" href="https://www.thearmchaircritic.org/cdn-cgi/l/email-protection" rel="noopener ugc nofollow" target="_blank">c</a>heckout@v2 <br/>with: token: ${{secrets.PERSONAL_ACCESS_TOKEN}}]</span></pre><p id="496c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用git config命令配置用户名和电子邮件。然后，使用<code class="fe kl km kn ko b">npm version</code>命令修改补丁版本。</p><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="5c43" class="ms kq iq ko b gy mt mu l mv mw">npm version patch</span></pre><p id="5fa0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该命令将删除版本，并将其提交给repo。所以，现在，我们需要推动它。</p><p id="27a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这也应该仅在合并拉请求时运行。所以，让我们用同样的条件。</p><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="95de" class="ms kq iq ko b gy mt mu l mv mw">- name: Version Bumping <br/>run: | <br/>   git config --global user.email "<a class="ae mx" href="https://www.thearmchaircritic.org/cdn-cgi/l/email-protection" rel="noopener ugc nofollow" target="_blank">c</a>hecout@v2" <br/>   git config --   global user.name "Version Bumping" <br/>   npm version patch git push <br/>if: github.event_name=='push'</span></pre><h1 id="a08b" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">忽略路径</h1><p id="77a6" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">现在，这引起了一个新的问题。每当有东西被推送到主分支时，就触发这个动作。当我们修改版本并提交时，这将再次触发动作。所以，我们将会在一个无止境的循环中结束。</p><p id="3f1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe kl km kn ko b">on</code>和<code class="fe kl km kn ko b">push</code>下的<code class="fe kl km kn ko b">paths-ignore</code>属性来忽略这些文件。</p><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="a883" class="ms kq iq ko b gy mt mu l mv mw">on: <br/>   push: <br/>      branches: <br/>         - master <br/>      paths-ignore: <br/>         - 'package.json' <br/>         - 'package-lock.json'</span></pre><p id="af3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的分级配置已经完成。让我们保存文件并为生产创建一个新的工作流。保存后，您可以在根目录下的<code class="fe kl km kn ko b">.github/workflows</code>目录中找到配置文件。</p><h1 id="b19f" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">使用GitHub操作配置生产</h1><p id="cbc9" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">对于生产，应该在应用预发布和发布时触发操作。因此，在<code class="fe kl km kn ko b">on</code>属性下，让我们使用<code class="fe kl km kn ko b">release</code>属性并将<code class="fe kl km kn ko b">released</code>和<code class="fe kl km kn ko b">prereleased</code>都指定为值。</p><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="c719" class="ms kq iq ko b gy mt mu l mv mw">on: release: types: [released, prereleased]</span></pre><p id="2bf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以按照相同的步骤将部署配置为Firebase。您只需更改站点名称并将目标设置为生产。</p><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="5caa" class="ms kq iq ko b gy mt mu l mv mw">- name: Install Firebase CLI <br/>env: FIREBASE_TOKEN: ${{secrets.FIREBASE_TOKEN}} <br/>run: | <br/>   sudo npm install -g firebase-tools <br/>   firebase deploy --token $FIREBASE_TOKEN --only hosting:production --non-interactive</span></pre><p id="22b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">版本碰撞也遵循类似的步骤。然而，由于该动作是在释放时触发的，<code class="fe kl km kn ko b"><a class="ae mx" href="https://www.thearmchaircritic.org/cdn-cgi/l/email-protection" rel="noopener ugc nofollow" target="_blank">[email protected]</a></code>动作检出一个ref而不是一个分支。所以，我们将无法推进我们的变革。为了防止这种情况，在版本碰撞步骤中，我们需要在提交之前强制检出主分支。在此之前，最好更新远程repos并获取一个fetch。</p><pre class="mh mi mj mk gt mo ko mp mq aw mr bi"><span id="f98e" class="ms kq iq ko b gy mt mu l mv mw">- name: Version Bumping <br/>run: | <br/>   git config --global user.email "<a class="ae mx" href="https://www.thearmchaircritic.org/cdn-cgi/l/email-protection" rel="noopener ugc nofollow" target="_blank">[email protected]</a>" <br/>   git config --   global user.name "Version Bumping" <br/>   git remote update <br/>   git fetch <br/>   git checkout --progress --force -B master refs/remotes/origin/master <br/>   npm version minor <br/>   git push <br/>if: github.event.action=='released'</span></pre><p id="2462" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就结束了生产配置。现在，您可以保存它并测试流是否如预期的那样工作。您可以找到一个配置了GitHub操作的示例存储库。</p><p id="e201" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原来你在这里！现在，我们需要做的就是合并拉取请求，并发布我们的应用程序，以便将其部署到试运行和生产环境中。经过最少的努力，现在我们有了一个功能完整的CICD流。此外，我们的团队现在可以实时跟踪我们的工作，并提供急需的反馈。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="6070" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nf">原载于2020年8月9日【https://www.thearmchaircritic.org】<a class="ae mx" href="https://www.thearmchaircritic.org/tech-journals/cicd-for-frontend-with-firebase-and-github-actions" rel="noopener ugc nofollow" target="_blank"><em class="nf"/></a><em class="nf">。</em></em></p></div></div>    
</body>
</html>