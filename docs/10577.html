<html>
<head>
<title>Go 1.18 Beta 1: More Generic Gifts for The Holidays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go 1.18 Beta 1:更通用的节日礼物</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/go-1-18-beta-1-more-generic-gifts-for-the-holidays-4a22aab9fa68?source=collection_archive---------10-----------------------#2021-12-22">https://levelup.gitconnected.com/go-1-18-beta-1-more-generic-gifts-for-the-holidays-4a22aab9fa68?source=collection_archive---------10-----------------------#2021-12-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/d402d37872048677a1d68633953b3b2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*1Rtx2yB11ogTHDe42_nEWw.jpeg"/></div></figure><p id="2ade" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好了，我在这里放不下我说的<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/go-1-18-beta-1-a-generic-gift-for-the-holidays-be9e7461362">的</a><a class="ae ks" href="https://github.com/nwillc/genfuncs" rel="noopener ugc nofollow" target="_blank"> genfuncs </a>回购！我一直在添加更多的通用功能，清理，记录，和…</p><h2 id="636a" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">各种各样的！</h2><p id="b046" class="pw-post-body-paragraph ju jv iq jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">我引入了自己的基于泛型的堆，并添加了插入排序、堆排序和快速排序。</p><p id="5a45" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了实现所有这些，并避免今天在Go中排序的混乱，我显然使用了泛型。我从一个比较器<em class="lv">开始，而不是像<code class="fe lr ls lt lu b">sort</code>包那样有一堆类型变化:</em></p><pre class="lw lx ly lz gt ma lu mb mc aw md bi"><span id="0c02" class="kt ku iq lu b gy me mf l mg mh">type Comparator[T any] func(a, b T) ComparedOrder</span></pre><p id="1fce" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">其中<em class="lv">compare order</em>是传统的:</p><pre class="lw lx ly lz gt ma lu mb mc aw md bi"><span id="d9f0" class="kt ku iq lu b gy me mf l mg mh">var (<br/>    LessThan    ComparedOrder = -1<br/>    EqualTo     ComparedOrder = 0<br/>    GreaterThan ComparedOrder = 1<br/>)</span></pre><p id="ce9e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，给定一个<em class="lv">比较器</em>函数作为参数，堆和排序变得完全通用化:</p><pre class="lw lx ly lz gt ma lu mb mc aw md bi"><span id="c8e5" class="kt ku iq lu b gy me mf l mg mh">func NewHeap[T any](comparator Comparator[T]) *Heap[T]<br/>func HeapSort[T any](slice []T, comparator Comparator[T])<br/>func InsertionSort[T any](slice []T, comparator Comparator[T])<br/>func QuickSort[T any](slice []T, comparator Comparator[T])</span></pre><p id="a922" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，等一下你会问，你总是要实现一个比较器<em class="lv">吗</em>即使对于已知的类型Go说是<code class="fe lr ls lt lu b">constrants.Ordered</code>？不，我抓住你了！</p><pre class="lw lx ly lz gt ma lu mb mc aw md bi"><span id="cb2c" class="kt ku iq lu b gy me mf l mg mh">var numericOrdered = genfuncs.OrderedComparator[int]()</span></pre><p id="4213" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它再次使用泛型和<code class="fe lr ls lt lu b">constraints.Ordered</code>约束为浮点类型、整型和字符串创建一个<em class="lv">比较器</em>。</p><p id="0fc6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以一个基本的升序或降序排序应该是这样的:</p><pre class="lw lx ly lz gt ma lu mb mc aw md bi"><span id="07f4" class="kt ku iq lu b gy me mf l mg mh">alphaOrder := genfuncs.OrderedComparator[string]()<br/>letters := strings.Split("example", "")<br/><br/>genfuncs.QuickSort(letters, alphaOrder)<br/>fmt.Println(letters) // [a e e l m p x]<br/>genfuncs.QuickSort(letters, genfuncs.ReverseComparator(alphaOrder))<br/>fmt.Println(letters) // [x p m l e e a]</span></pre><p id="14f6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是如果你有一个复杂的类型，有疯狂的词法规则，只需要为它实现一个特定的比较器。</p><p id="da0f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">看一看Go的<code class="fe lr ls lt lu b">sort</code>包，你会对它为不同类型的人所做的体操感到不悦。Go还在挑选合适的排序方面变了一些魔术，它的排序实现稍微优化了一些，但我敢打赌，如果我给它添加这些功能，它的大小会减少50%，并且更加灵活和易于理解。</p><h2 id="9be3" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">我真的很喜欢这个</h2><p id="d017" class="pw-post-body-paragraph ju jv iq jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">到目前为止，我真的很喜欢1.18泛型。编写和使用函数，摒弃样板类型的特定代码是天堂。我甚至收到了人们的商业使用请求，这很好，但是我提醒他们，正如我在文档中所说的，我很确定Go将很快得到这个<em class="lv">的官方形式</em>。对他们来说，这是一场太容易、太大的胜利，不容错过。但是直到他们享受！</p></div></div>    
</body>
</html>