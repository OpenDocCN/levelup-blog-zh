<html>
<head>
<title>JavaScript Best Practices — Data and Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—数据和对象</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-data-and-objects-b0b8673bcec9?source=collection_archive---------4-----------------------#2020-05-20">https://levelup.gitconnected.com/javascript-best-practices-data-and-objects-b0b8673bcec9?source=collection_archive---------4-----------------------#2020-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/25f06fbccadf006db3b7ff2b5d57004b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lj5URIlibivunfYJ"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Claudio Guglieri 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="2668" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="4274" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究处理不同类型的数据和对象时的最佳实践。</p><h1 id="caf1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">原始类型</h1><p id="900c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JavaScript中有不同种类的原语类型。它们是字符串，数字。布尔人。空，未定义。符号和bigint。</p><p id="6256" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">符号数据类型对ES6来说是新的，所以我们应该确保将它们转换成ES5代码。它不能被聚合填充，所以它必须被转换成与我们在最终构建工件中的目标平台兼容的代码。</p><p id="589d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Bigint也是新的，不能多填充。如果我们使用它，我们也应该在最终的构建工件中将它转换成与我们的目标平台兼容的东西。</p><h1 id="00fd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用const而不是var</h1><p id="3559" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">让我们在JavaScript代码中定义常量。从ES6开始就有了。一旦它被定义，它就不能被赋予新的值。然而，赋值仍然是可变的。</p><p id="5987" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它也是块范围的，所以我们只能访问块内的常量。与用<code class="fe mh mi mj mk b">var</code>声明的变量不同，它没有被提升，所以我们可以在定义它之前引用它。</p><p id="cd2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">var</code>也是函数作用域，所以可以在块外访问。</p><p id="9f63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，<code class="fe mh mi mj mk b">const</code>比<code class="fe mh mi mj mk b">var</code>好。</p><p id="051b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们不需要重新分配不同的值，那么使用<code class="fe mh mi mj mk b">const</code>。</p><p id="3075" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，使用<code class="fe mh mi mj mk b">let</code>。</p><p id="bb2f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以如下使用它们:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="eb36" class="mt lf it mk b gy mu mv l mw mx">const a = 1;<br/>let b = 1;<br/>b = 2;</span></pre><p id="fe17" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不应该在代码中编写类似下面这样的内容:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7577" class="mt lf it mk b gy mu mv l mw mx">var c = 1;</span></pre><h1 id="1e70" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">目标</h1><p id="327e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当我们创建新对象时，我们应该使用对象字面语法，而不是<code class="fe mh mi mj mk b">Object</code>构造函数。它要短得多，做同样的事情。</p><p id="8d52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们都创建从<code class="fe mh mi mj mk b">Object</code>构造函数继承的对象。</p><p id="b045" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="cdf2" class="mt lf it mk b gy mu mv l mw mx">const obj = new Object();</span></pre><p id="4021" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们使用了带有<code class="fe mh mi mj mk b">Object</code>构造函数的<code class="fe mh mi mj mk b">new</code>操作符来创建一个对象，这是不必要的。</p><p id="0b44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们改为编写以下内容:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9473" class="mt lf it mk b gy mu mv l mw mx">const obj = {};</span></pre><p id="e261" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用构造函数让我们在代码中输入更多我们不需要的字符。</p><h1 id="4e8c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用计算的属性名创建动态属性名</h1><p id="c924" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">从ES6开始，我们可以在定义的对象中使用动态属性名。我们用括号将计算出的属性键括起来。</p><p id="68bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写以下代码来实现这一点:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="24a4" class="mt lf it mk b gy mu mv l mw mx">const getKey = (k) =&gt; {<br/>  return `foo ${k}`;<br/>}</span><span id="6470" class="mt lf it mk b gy my mv l mw mx">const obj = {<br/>  [getKey('bar')]: 1<br/>}</span></pre><p id="e327" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，有一个<code class="fe mh mi mj mk b">getKey</code>函数，用于返回一个计算出的键，我们将该键放入<code class="fe mh mi mj mk b">obj</code>对象中，用作属性键。</p><p id="7201" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们可以用最短和最清晰的方式定义一个带有计算属性键的对象。</p><p id="6b98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这比在定义对象后使用括号符号要好。例如，我们不想写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a695" class="mt lf it mk b gy mu mv l mw mx">const getKey = (k) =&gt; {<br/>  return `foo ${k}`;<br/>}</span><span id="a02d" class="mt lf it mk b gy my mv l mw mx">const obj = {};<br/>obj[getKey('bar')] = 1;</span></pre><p id="1d48" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为它比较长，而且我们要多次写<code class="fe mh mi mj mk b">obj</code>。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/c8c284776079b23a2bcab49c869b8da7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UZAy8xs0M1DrOyee"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">米哈伊尔·瓦西里耶夫在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="545c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用对象方法速记</h1><p id="c6ee" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">ES6的另一个伟大特性是对象方法简写。它允许我们在不使用<code class="fe mh mi mj mk b">function</code>关键字的情况下创建一个方法。</p><p id="05d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在旧的方法中，我们在对象中创建一个方法，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="385d" class="mt lf it mk b gy mu mv l mw mx">const cat = {<br/>  name: 'james',<br/>  greet: function() {<br/>    return `hi ${this.name}`;<br/>  }<br/>}</span></pre><p id="8094" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们使用了<code class="fe mh mi mj mk b">function</code>关键字来定义<code class="fe mh mi mj mk b">cat</code>对象中的<code class="fe mh mi mj mk b">greet</code>方法。</p><p id="a75b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更好的方法是用object方法简写，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="53d6" class="mt lf it mk b gy mu mv l mw mx">const cat = {<br/>  name: 'james',<br/>  greet() {<br/>    return `hi ${this.name}`;<br/>  }<br/>}</span></pre><p id="ba1b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码和前面的例子做了同样的事情，但是我们省略了<code class="fe mh mi mj mk b">function</code>关键字。</p><p id="0bae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以对生成器函数做同样的事情。而不是写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a90c" class="mt lf it mk b gy mu mv l mw mx">const foo = {<br/>  gen: function*() {<br/>    yield 2;<br/>  }<br/>}</span></pre><p id="2fd6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7738" class="mt lf it mk b gy mu mv l mw mx">const foo = {<br/>  * gen() {<br/>    yield 2;<br/>  }<br/>}</span></pre><p id="2361" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们都有<code class="fe mh mi mj mk b">gen</code>生成器方法，但是我们在第二个例子中省略了<code class="fe mh mi mj mk b">function</code>关键字。</p><h1 id="9aab" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="85b5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该尽可能使用ES6特性。我们应该使用的好特性包括对象方法简写、计算属性键(如果我们需要动态生成的对象键名)和关键字<code class="fe mh mi mj mk b">const</code>。</p><p id="28dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们使用像符号和bigints这样的新数据类型，我们应该确保它们能在我们的目标平台上工作。</p></div></div>    
</body>
</html>