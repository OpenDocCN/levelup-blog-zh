<html>
<head>
<title>Practical SOLID in Golang: Interface Segregation Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">戈朗实用固体:界面分离原理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/practical-solid-in-golang-interface-segregation-principle-f272c2a9a270?source=collection_archive---------2-----------------------#2021-11-17">https://levelup.gitconnected.com/practical-solid-in-golang-interface-segregation-principle-f272c2a9a270?source=collection_archive---------2-----------------------#2021-11-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7f25" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">坚实的原则</h2><div class=""/><div class=""><h2 id="7dab" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">我们通过介绍对代码设计影响最大的原则——接口分离原则，继续我们坚实的原则之旅。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/6c61a5d4362d342741855b20c0c79a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L0ssfLVZwCARoI17"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@ahmeyer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克·温克勒</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="aa60" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每当有人开始第一次编程课程时，程序总是相似的:在最初的几周甚至几个月，都是关于算法和重新连接大脑以接受这种思维方式。</p><p id="d31f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在某个时候，我们开始介绍面向对象编程。如果教师对这种转换等待太久，可能很难切断与函数式编程的联系。</p><p id="55dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，在某些时候，我们接受使用对象。我们开始在需要的地方使用它们，当然，在不需要的地方。然后我们开始学习抽象以及如何让我们的代码越来越可重用。</p><p id="e326" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，我们可能开始以错误的方式使用抽象，将它们添加到任何地方。为了使我们的代码更加通用，我们进行了泛化，这减缓了我们未来的开发。</p><p id="1c90" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">或早或晚，我们开始意识到我们应该为这么多的概括划一条线。幸运的是，已经有人做到了——通过引入接口分离原理，它代表单词<em class="me"> SOLID </em>中的字母<em class="me"> I </em>。</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="6eeb" class="mk ml it mg b gy mm mn l mo mp">Other articles from the SOLID series:</span><span id="bf52" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">1. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-solid-in-golang-single-responsibility-principle-20afb8643483"><strong class="mg jd">Practical SOLID in Golang: Single Responsability Principle</strong></a></span><span id="48ff" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-solid-in-golang-open-closed-principle-1dd361565452"><strong class="mg jd">Practical SOLID in Golang: Open/Closed Principle</strong></a></span><span id="5b2c" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">3. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-solid-in-golang-liskov-substitution-principle-e0d2eb9dd39"><strong class="mg jd">Practical SOLID in Golang: Liskov Substitution Principle</strong></a></span><span id="b2b8" class="mk ml it mg b gy mq mn l mo mp">Some articles from the DDD series:</span><span id="9f83" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">1.</strong> <a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-value-object-4fc97bcad70"><strong class="mg jd">Practical DDD in Golang: Value Object</strong></a></span><span id="a559" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-entity-40d32bdad2a3"><strong class="mg jd">Practical DDD in Golang: Entity</strong></a></span><span id="e0b4" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">3. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-aggregate-de13f561e629"><strong class="mg jd">Practical DDD in Golang: Aggregate</strong></a></span><span id="b17a" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">4. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-repository-d308c9d79ba7"><strong class="mg jd">Practical DDD in Golang: Repository</strong></a></span><span id="7ea4" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">5. ...</strong></span></pre><div class="mr ms gp gr mt mu"><a href="https://blog.ompluscator.com/membership" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd jd gy z fp mz fr fs na fu fw jc bi translated">通过我的推荐链接加入媒体——马尔科·米洛耶维奇</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">blog.ompluscator.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni lb mu"/></div></div></a></div><h1 id="2a03" class="nj ml it bd nk nl nm nn no np nq nr ns ki nt kj nu kl nv km nw ko nx kp ny nz bi translated">当我们不尊重界面分离时</h1><blockquote class="oa ob oc"><p id="08f2" class="li lj me lk b ll lm kd ln lo lp kg lq od ls lt lu oe lw lx ly of ma mb mc md im bi translated">保持小界面，这样用户就不会依赖他们不需要的东西。</p></blockquote><p id="5b0a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">鲍勃叔叔创造了这个原则，你可以在他的博客上找到更多的细节。这个原则清楚地定义了它的要求，可能是所有其他坚实的原则中最好的。</p><p id="6567" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">保持接口尽可能小的简单声明我们不应该仅仅理解为一个方法接口，而应该更多地考虑接口所拥有的特性的内聚性。</p><p id="2cdd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们检查下面的代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="3e3f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设我们想要交付一个购物应用程序。其中一种方法是定义一个接口<code class="fe oi oj ok mg b">User</code>，就像我们在代码示例中所做的那样。这个界面拥有用户可以拥有的许多特性。</p><p id="51cc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们平台上的一个<code class="fe oi oj ok mg b">User</code>可以给<code class="fe oi oj ok mg b">ShoppingCart</code>加一个<code class="fe oi oj ok mg b">Product</code>。他们可以买。他们可以在特定的<code class="fe oi oj ok mg b">Product</code>上获得折扣。唯一的问题是，只有一个特定的<code class="fe oi oj ok mg b">User</code>可以做到这一切。</p><p id="2b7d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个接口的实际实现是三个结构。第一个是<code class="fe oi oj ok mg b">Guest</code>结构。应该是一个没有登录我们系统的<code class="fe oi oj ok mg b">User</code>，但至少他们可以在<code class="fe oi oj ok mg b">ShoppingCart</code>上加一个<code class="fe oi oj ok mg b">Product</code>。</p><p id="15ac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第二个实现是<code class="fe oi oj ok mg b">NormalCustomer</code>。它能做任何<code class="fe oi oj ok mg b">Guest</code>能做的事情，外加买一个<code class="fe oi oj ok mg b">Product</code>。第三个实现是<code class="fe oi oj ok mg b">PremiumCustomer</code>，它可以使用我们系统的所有特性。</p><p id="10b6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，看看这三个结构。只有<code class="fe oi oj ok mg b">PremiumCustomer</code>需要所有三种方法。也许我们可以将它们全部分配给<code class="fe oi oj ok mg b">NormalCustomer</code>，但肯定的是，我们几乎不需要超过两个给<code class="fe oi oj ok mg b">Guest</code>。</p><p id="8b59" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">方法<code class="fe oi oj ok mg b">HasPremium</code>和<code class="fe oi oj ok mg b">HasDiscountFor</code>对<code class="fe oi oj ok mg b">Guest</code>没有任何意义。如果该结构表示未登录的<code class="fe oi oj ok mg b">User</code>,我们为什么还要考虑实现折扣的方法呢？</p><p id="0d00" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这里，我们甚至可以调用panic方法，并显示错误“<em class="me">方法未实现</em>”—这在这段代码中会更真实。在通常的场景中，我们甚至不应该从<code class="fe oi oj ok mg b">Guest</code>中调用方法<code class="fe oi oj ok mg b">HasPremium</code>。</p><p id="e6f7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们所做的一切都是为了在UserService中添加泛化功能，以便在同一个地方用相同的代码处理所有类型的<code class="fe oi oj ok mg b">Users</code>。但是，正因为如此，我们需要实现一堆未使用的方法。</p><p id="00fd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，为了更好地概括，我们得到:</p><ol class=""><li id="27c9" class="ol om it lk b ll lm lo lp lr on lv oo lz op md oq or os ot bi translated">许多结构有未使用的方法。</li><li id="92f5" class="ol om it lk b ll ou lo ov lr ow lv ox lz oy md oq or os ot bi translated">我们需要以某种方式标记的方法，以便其他人不使用它们。</li><li id="4dfb" class="ol om it lk b ll ou lo ov lr ow lv ox lz oy md oq or os ot bi translated">单元测试的许多额外代码。</li><li id="6388" class="ol om it lk b ll ou lo ov lr ow lv ox lz oy md oq or os ot bi translated">不自然的多态性。</li><li id="62d1" class="ol om it lk b ll ou lo ov lr ow lv ox lz oy md oq or os ot bi">…</li></ol><p id="5862" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，让我们来重构这个混乱。</p><h1 id="6d13" class="nj ml it bd nk nl nm nn no np nq nr ns ki nt kj nu kl nv km nw ko nx kp ny nz bi translated">我们如何尊重界面隔离</h1><blockquote class="oa ob oc"><p id="cdc3" class="li lj me lk b ll lm kd ln lo lp kg lq od ls lt lu oe lw lx ly of ma mb mc md im bi translated">围绕最小内聚的功能组构建接口。</p></blockquote><p id="7acb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们不需要在这里发明一些空间科学。唯一需要的是定义一个最小的接口来提供一套完整的特性。让我们检查下面的代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="5dae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们有三个界面，而不是一个。<code class="fe oi oj ok mg b">PremiumUser</code>嵌入<code class="fe oi oj ok mg b">LoggedInUser</code>，后者嵌入<code class="fe oi oj ok mg b">User</code>。此外，他们每个人都介绍了一种方法。</p><p id="384f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe oi oj ok mg b">User</code>现在只代表那些在我们的平台上还没有被认证的客户。对于这样的类型，我们知道他们可以使用<code class="fe oi oj ok mg b">ShoppingCart</code>的特性。</p><p id="46a2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">新的<code class="fe oi oj ok mg b">LoggedInUser</code>界面代表我们所有经过认证的客户，而<code class="fe oi oj ok mg b">PremiumUser</code>界面代表所有拥有付费高级账户的经过认证的客户。</p><p id="1ff0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意:我们确实增加了两个接口，但是我们删除了两个方法:<code class="fe oi oj ok mg b">IsLoggedIn</code>和<code class="fe oi oj ok mg b">HasPremium</code>。那些方法不是我们接口签名的一部分。但是没有他们我们怎么工作呢？</p><p id="3ca7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如您在<code class="fe oi oj ok mg b">UserService</code>中看到的，我们没有使用带有布尔结果的方法，而是澄清了<code class="fe oi oj ok mg b">User</code>接口的子类型。如果<code class="fe oi oj ok mg b">User</code>实现了<code class="fe oi oj ok mg b">LoggedInUser</code>，我们知道我们谈论的是经过认证的客户。</p><p id="e09c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样，如果<code class="fe oi oj ok mg b">User</code>实现了<code class="fe oi oj ok mg b">PremiumUser</code>，我们知道我们谈论的是具有高级帐户的客户。因此，通过造型，我们已经检查了一些业务规则。</p><p id="b638" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">除了这两个方法之外，以前的所有结构现在都更加轻量级了。他们不是每个人都有五个方法，其中许多根本没有被使用，现在他们只是有他们真正需要的方法。</p><h1 id="ebae" class="nj ml it bd nk nl nm nn no np nq nr ns ki nt kj nu kl nv km nw ko nx kp ny nz bi translated">更多的例子</h1><p id="01e2" class="pw-post-body-paragraph li lj it lk b ll oz kd ln lo pa kg lq lr pb lt lu lv pc lx ly lz pd mb mc md im bi translated">尽管提供小而灵活的接口总是好的，但是我们应该考虑它们的用途来引入它们。添加小接口使它们更简单，但仍然在同一个结构中一起实现它们没有太大意义。</p><p id="4c10" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看下面的例子:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="d107" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是我们把界面分割得太多的情况。是的，我们可以为每个方法提供一个接口，现在将它们定义为角色接口。这种单一方法接口有时是好的，但在这里不是。</p><p id="dfa4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">显然，如果客户在我们的平台上注册，他们将需要提供他们的名字和姓氏，以便计费。因此，我们的<code class="fe oi oj ok mg b">User</code>将同时需要<code class="fe oi oj ok mg b">FirstName</code>和<code class="fe oi oj ok mg b">LastName</code>两种方法，自然也就需要<code class="fe oi oj ok mg b">FullName</code>。</p><p id="9a2d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，将这三个方法分成三个接口是没有意义的，因为这三个方法总是在一起。所以，这不是一个单一方法接口的正确例子。</p><p id="2673" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，有什么好的例子呢？</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="1034" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Go中最完美的例子就是<a class="ae lh" href="https://pkg.go.dev/io" rel="noopener ugc nofollow" target="_blank"> IO </a>包。它提供了许多处理I/O操作的代码和接口，可能所有的Go开发者都至少使用过这个包一次。</p><p id="798c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">提供接口<code class="fe oi oj ok mg b">Reader</code>、<code class="fe oi oj ok mg b">Writer</code>、<code class="fe oi oj ok mg b">Closer</code>、<code class="fe oi oj ok mg b">Seeker</code>。它们中的每一个都只定义了一个方法，<code class="fe oi oj ok mg b">Read</code>、<code class="fe oi oj ok mg b">Write</code>、<code class="fe oi oj ok mg b">Close</code>和<code class="fe oi oj ok mg b">Seek</code>。我们使用它们来读取、写入、搜索特定源的一部分字节，并关闭该源。</p><p id="dc4d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了让这些资源更加灵活，所有的功能都放在它们的接口中。后来，他们一起构建更复杂的接口，像<code class="fe oi oj ok mg b">WriteCloser</code>、<code class="fe oi oj ok mg b">ReadWriteCloser</code>等等。</p><h1 id="11af" class="nj ml it bd nk nl nm nn no np nq nr ns ki nt kj nu kl nv km nw ko nx kp ny nz bi translated">摘要</h1><p id="996a" class="pw-post-body-paragraph li lj it lk b ll oz kd ln lo pa kg lq lr pb lt lu lv pc lx ly lz pd mb mc md im bi translated">界面分离原理是第四个立体原理，它代表单词<em class="me">立体</em>中的字母<em class="me"> I </em>。它教会我们把界面做得尽可能小。</p><p id="146c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每当我们想要覆盖更多的类型时，我们应该用不同的接口来保护它们。我们应该避免把界面做得太小，但是要提供完整的功能。</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="2c4b" class="mk ml it mg b gy mm mn l mo mp">Other articles from the SOLID series:</span><span id="1d4e" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">1. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-solid-in-golang-single-responsibility-principle-20afb8643483"><strong class="mg jd">Practical SOLID in Golang: Single Responsability Principle</strong></a></span><span id="34fd" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-solid-in-golang-open-closed-principle-1dd361565452"><strong class="mg jd">Practical SOLID in Golang: Open/Closed Principle</strong></a></span><span id="9ee6" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">3. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-solid-in-golang-liskov-substitution-principle-e0d2eb9dd39"><strong class="mg jd">Practical SOLID in Golang: Liskov Substitution Principle</strong></a></span><span id="2bce" class="mk ml it mg b gy mq mn l mo mp">Some articles from the DDD series:</span><span id="c5ce" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">1.</strong> <a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-value-object-4fc97bcad70"><strong class="mg jd">Practical DDD in Golang: Value Object</strong></a></span><span id="4be7" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-entity-40d32bdad2a3"><strong class="mg jd">Practical DDD in Golang: Entity</strong></a></span><span id="9bfc" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">3. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-aggregate-de13f561e629"><strong class="mg jd">Practical DDD in Golang: Aggregate</strong></a></span><span id="de03" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">4. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-repository-d308c9d79ba7"><strong class="mg jd">Practical DDD in Golang: Repository</strong></a></span><span id="47d7" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">5. ...</strong></span></pre></div></div>    
</body>
</html>