<html>
<head>
<title>Go 1.18 Beta 1: A Generic Gift for The Holidays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go 1.18 Beta 1:节日通用礼物</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/go-1-18-beta-1-a-generic-gift-for-the-holidays-be9e7461362?source=collection_archive---------10-----------------------#2021-12-18">https://levelup.gitconnected.com/go-1-18-beta-1-a-generic-gift-for-the-holidays-be9e7461362?source=collection_archive---------10-----------------------#2021-12-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/d402d37872048677a1d68633953b3b2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*1Rtx2yB11ogTHDe42_nEWw.jpeg"/></div></figure><p id="2706" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我一直在急切地等待Go中的泛型，并在可能的情况下与它们一起玩，但现在<a class="ae kv" href="https://go.dev/blog/go1.18beta1" rel="noopener ugc nofollow" target="_blank"> Go 1.18 Beta 1 </a>可用了！所以我立刻通过<a class="ae kv" href="https://github.com/kennyp/asdf-golang" rel="noopener ugc nofollow" target="_blank"> asdf </a>抓取了它，并实现了一个<a class="ae kv" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/" rel="noopener ugc nofollow" target="_blank"> Kotlin Sequences </a>启发的围棋子包。</p><h2 id="92a6" class="kw kx it bd ky kz la dn lb lc ld dp le ki lf lg lh km li lj lk kq ll lm ln lo bi translated">GenFuncs</h2><p id="dc3b" class="pw-post-body-paragraph jx jy it jz b ka lp kc kd ke lq kg kh ki lr kk kl km ls ko kp kq lt ks kt ku im bi translated">你可以在这里看到完整的genfuncs包<a class="ae kv" href="https://github.com/nwillc/genfuncs" rel="noopener ugc nofollow" target="_blank"/>。我用最少的努力实现了所有我喜欢的通用函数:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="f8ee" class="kw kx it lz b gy md me l mf mg">func All[T any](slice []T, predicate Predicate[T]) bool<br/>func Any[T any](slice []T, predicate Predicate[T]) bool<br/>func Associate[T any, K comparable, V any](slice []T, transform TransformKV[T, K, V]) map[K]V<br/>func AssociateWith[K comparable, V any](slice []K, valueSelector ValueSelector[K, V]) map[K]V<br/>func Contains[T comparable](slice []T, element T) bool<br/>func Distinct[T comparable](slice []T) []T<br/>func Filter[T any](slice []T, predicate Predicate[T]) []T<br/>func Find[T any](slice []T, predicate Predicate[T]) (T, bool)<br/>func FindLast[T any](slice []T, predicate Predicate[T]) (T, bool)<br/>func FlatMap[T, R any](slice []T, transform Transform[T, []R]) []R<br/>func Fold[T, R any](slice []T, initial R, operation Operation[T, R]) R<br/>func GroupBy[T any, K comparable](slice []T, keySelector KeySelector[T, K]) map[K][]T<br/>func JoinToString[T any](slice []T, stringer Stringer[T], separator string, prefix string, postfix string) string<br/>func Map[T, R any](slice []T, transform Transform[T, R]) []R</span></pre><p id="172f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">并附有所有用法的例子。</p><h2 id="aa65" class="kw kx it bd ky kz la dn lb lc ld dp le ki lf lg lh km li lj lk kq ll lm ln lo bi translated">去蝙蝠战车，我们走！</h2><p id="1edc" class="pw-post-body-paragraph jx jy it jz b ka lp kc kd ke lq kg kh ki lr kk kl km ls ko kp kq lt ks kt ku im bi translated">想要从切片中提取不同的集合？没有更多的<em class="mh">用于/range/map </em>样板代码！</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="3f3a" class="kw kx it lz b gy md me l mf mg">values := []int{1, 2, 2, 3, 1, 3}<br/>fmt.Println(genfuncs.Distinct(values)) // [1 2 3]</span></pre><p id="b819" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">或者您可能想测试一个切片中的所有值是否都是正的？</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="9e62" class="kw kx it lz b gy md me l mf mg">numbers := []int{1, 2, 3, 4}<br/>positive := func(i int) bool { return i &gt; 0 }<br/>fmt.Println(genfuncs.All(numbers, positive)) // true</span></pre><p id="ef67" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这些都是通用类型函数，所以不仅仅是<em class="mh"> []int </em>它可以与任何可比较的类型一起工作，下面是与floats相同的<em class="mh"> All </em>:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="962d" class="kw kx it lz b gy md me l mf mg">numbers := []float32{1, 2.2, 3.0, 4}<br/>positive := <em class="mh">func</em>(i float32) bool { <em class="mh">return </em>i &gt; 0 }<br/>fmt.Println(genfuncs.All(numbers, positive)) <em class="mh">// true</em></span></pre><p id="7cd3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">想要将一部分数字按奇偶分组吗？</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="0195" class="kw kx it lz b gy md me l mf mg">oddEven := <em class="mh">func</em>(i int) string {<br/>   <em class="mh">if </em>i%2 == 0 {<br/>      <em class="mh">return </em>"EVEN"<br/>   }<br/>   <em class="mh">return </em>"ODD"<br/>}<br/>numbers := []int{1, 2, 3, 4}<br/>grouped := genfuncs.GroupBy(numbers, oddEven)<br/>fmt.Println(grouped["ODD"]) <em class="mh">// [1 3]</em></span></pre><p id="dc0c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">创建一个连接除字符串之外的<em class="mh">片段的字符串？</em></p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="4f7c" class="kw kx it lz b gy md me l mf mg">values := []bool{true, false, true}<br/>fmt.Println(genfuncs.JoinToString(<br/>   values,<br/>   strconv.FormatBool,<br/>   ", ",<br/>   "{",<br/>   "}",<br/>)) <em class="mh">// {true, false, true}</em></span></pre><p id="e39d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我就讲到这里，因为回购协议有各种例子。要知道，使用泛型，你可能会编写更少的样板代码，使用的<em class="mh"> range </em>关键字也会更少。我相信你很伤心。</p><h2 id="aafe" class="kw kx it bd ky kz la dn lb lc ld dp le ki lf lg lh km li lj lk kq ll lm ln lo bi translated">好人</h2><ul class=""><li id="66f3" class="mi mj it jz b ka lp ke lq ki mk km ml kq mm ku mn mo mp mq bi translated">语法清晰，易于理解。</li><li id="5338" class="mi mj it jz b ka mr ke ms ki mt km mu kq mv ku mn mo mp mq bi translated">类型约束按预期工作，很容易编写干净的代码，适当地约束类型，但却是通用的。</li><li id="8d77" class="mi mj it jz b ka mr ke ms ki mt km mu kq mv ku mn mo mp mq bi translated">没碰上什么我想不通的挠头情况。</li></ul><h2 id="1f4f" class="kw kx it bd ky kz la dn lb lc ld dp le ki lf lg lh km li lj lk kq ll lm ln lo bi translated">坏事</h2><ul class=""><li id="3a99" class="mi mj it jz b ka lp ke lq ki mk km ml kq mm ku mn mo mp mq bi translated">我的IDE确实有1.18的实验支持，但它并不完全工作，我不得不忽略各种错误的警告并运行代码。</li><li id="19a3" class="mi mj it jz b ka mr ke ms ki mt km mu kq mv ku mn mo mp mq bi translated">他们没有完全实现提议的<em class="mh">契约</em>和使用类似<em class="mh"> fmt的接口。纵梁</em>作为一种类型不是替代品。</li><li id="58f6" class="mi mj it jz b ka mr ke ms ki mt km mu kq mv ku mn mo mp mq bi translated">随着时间的推移，仿制药的提议发生了实质性的变化，所以甚至一些官方文件使用了错误的语法和/或误导。</li></ul><h2 id="9453" class="kw kx it bd ky kz la dn lb lc ld dp le ki lf lg lh km li lj lk kq ll lm ln lo bi translated">和丑陋的</h2><p id="c582" class="pw-post-body-paragraph jx jy it jz b ka lp kc kd ke lq kg kh ki lr kk kl km ls ko kp kq lt ks kt ku im bi translated">我没有遇到任何真正丑陋的东西:-)</p></div></div>    
</body>
</html>