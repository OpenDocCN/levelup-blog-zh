<html>
<head>
<title>How to Handle Deadlock in DBMS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理数据库管理系统中的死锁</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-handle-deadlock-in-dbms-e708f88edf2c?source=collection_archive---------3-----------------------#2022-12-02">https://levelup.gitconnected.com/how-to-handle-deadlock-in-dbms-e708f88edf2c?source=collection_archive---------3-----------------------#2022-12-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/674c1456c4fcc9d2eedb0d4bc75dce66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xaX2_Vv4rkmKyXDtNt-T0A.png"/></div></div></figure><p id="49ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当数据库系统中的两个或多个事务正在等待被另一个事务锁定的数据项时，就会发生死锁。等待图中的循环可以指示死锁。这是一个有向图，顶点表示事务，边表示对数据项的等待。</p><p id="aadb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，在下面的<a class="ae kw" href="https://en.wikipedia.org/wiki/Wait-for_graph" rel="noopener ugc nofollow" target="_blank">等待图</a>中，事务P1正在等待数据项X，该数据项被P3锁定。P3在等被P2锁定的Z，P2在等被P1锁定的Y。因此，会生成一个等待循环，并且没有一个事务可以执行。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kx"><img src="../Images/fa8143aecf0608c9189c21957c74601f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LlggrjzBLZm-hycgyKOlTw.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">进程处于死锁状态</figcaption></figure><h1 id="ba89" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">什么是数据库管理系统中的死锁？</strong></h1><p id="ad47" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated"><a class="ae kw" href="https://www.ibm.com/docs/en/zos-basic-skills?topic=zos-what-is-database-management-system" rel="noopener ugc nofollow" target="_blank"> DBMS </a>中的死锁是一种不希望出现的状态，当一个进程无限期等待另一个进程占用的资源时，就会出现这种状态。</p><p id="de2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了更好地理解死锁的概念，假设事务T1锁定了表Employee中的几行，并且必须更改另一个表Salary中的某些行。</p><p id="3c4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有另一个事务T2，它锁定了Salary表，需要更新Employee表中的几行，该表已经被事务T1持有。</p><p id="863c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，事务和进程都在等待对方释放锁，而进程也在等待对方释放资源。作为前面场景的结果，没有完成任何作业，这被称为死锁。</p><h1 id="a95e" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">DBMS中为什么会出现死锁？</strong></h1><p id="92bf" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">当两个事务无休止地等待对方解锁数据时，就会出现死锁。</p><p id="cd4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当P1和P2两个事务以下列模式存在时，就会出现死锁:</p><p id="4028" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">P1 =访问数据项X和Y</p><p id="ff87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">P2 =访问数据项Y和X</p><p id="6334" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果P1没有解锁数据项Y，P2不能开始，如果P2没有解锁数据项x，P1不能继续</p><p id="feb7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果，P1和P2都在等待对方解锁所需的数据项。这种类型的死锁也被描述为致命的拥抱。下表显示了在DBMS中死锁条件是如何发生的。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/1c6aaa9fb10635e2254e6445aee1a363.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gh_k6VSbB4P7VrEiKz5Wgw.png"/></div></div></figure><h2 id="4d47" class="mk lh iq bd li ml mm dn lm mn mo dp lq kj mp mq lu kn mr ms ly kr mt mu mc mv bi translated"><strong class="ak">集中式系统中的死锁处理</strong></h2><p id="7b2f" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">在DBMS中有三种处理死锁的传统方法:</p><ul class=""><li id="9c48" class="mw mx iq ka b kb kc kf kg kj my kn mz kr na kv nb nc nd ne bi translated">死锁预防。</li><li id="126a" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated">避免死锁。</li><li id="5567" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated">死锁检测和消除。</li></ul><p id="7a14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有这三种方法都可以在集中式和<a class="ae kw" href="https://www.scaler.com/topics/dbms/distributed-database-in-dbms/" rel="noopener ugc nofollow" target="_blank">分布式数据库系统</a>中用来处理死锁情况。</p><h1 id="cff6" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">死锁预防</strong></h1><p id="1188" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">死锁预防策略禁止任何事务获取会导致死锁的锁。根据约定，当多个事务请求锁定同一个数据项时，只有其中一个事务被授予锁定。</p><p id="769b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">预先获取所有锁是最流行的死锁预防策略之一。在这种方法中，事务在开始执行之前获得所有锁，并在事务期间保持这些锁。</p><p id="84fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果另一个事务需要任何以前获得的锁，它必须等待，直到所有需要的锁都可以访问。这种策略可以防止系统堵塞，因为没有等待的事务持有任何锁。</p><p id="2228" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在DBMS中有两种避免死锁的算法。</p><ul class=""><li id="fad4" class="mw mx iq ka b kb kc kf kg kj my kn mz kr na kv nb nc nd ne bi translated"><strong class="ka ir"> Wait/Die: </strong>当一个事务需要一个已经被另一个事务锁定的资源时，DBMS会比较两个事务的时间戳，并强制较旧的事务等待，直到资源可以执行为止。</li><li id="cd6e" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated"><strong class="ka ir">wind/Wait:</strong>当一个较老的事务需要一个已经被一个较年轻的事务锁定的资源(一个较晚启动的事务)时，较年轻的事务被迫终止/停止它的处理，并释放锁定的资源以供较老的事务自己执行。较新的事务在一分钟的延迟后重新启动，但是<a class="ae kw" href="https://www.youtube.com/watch?v=27NtGV1vNoY" rel="noopener ugc nofollow" target="_blank">时间戳</a>保持不变。如果一个较年轻的事务需要一个较老的事务持有的资源，则该较年轻的事务被迫等待，直到较老的事务释放该资源。</li></ul><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/ccd1b219691b32a99f4dac298baca7e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yeGoWov2h2fiqqQhR8u-yA.png"/></div></div></figure><p id="d808" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，假设有两个事务，T1和T2，其中T1试图锁定一个已经被T2锁定的数据项。算法如下:</p><ul class=""><li id="fe7a" class="mw mx iq ka b kb kc kf kg kj my kn mz kr na kv nb nc nd ne bi translated"><strong class="ka ir"> <em class="nl">等死</em></strong><em class="nl">—</em>T1如果比T2大，就允许等。如果T1比T2年轻，则该过程中止，然后重新开始。</li><li id="8a08" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated"><strong class="ka ir"> <em class="nl">伤口等待</em></strong><em class="nl">—</em>如果T1比T2早，T2被取消并重新启动。如果T1比T2年轻，则允许等待。</li></ul><h1 id="f36e" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">死锁避免</strong></h1><p id="c127" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">当数据库被死锁时，避免死锁总是比重新启动或中止数据库更可取。这完全是浪费时间和资源。避免策略适用于较小的数据集，但预防方法更适用于较大的数据库。</p><p id="1f71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">死锁避免可以总结如下。</p><p id="03e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事务开始执行，并需要必须锁定的数据项。锁管理器确定锁是否可用。如果可用，锁管理将数据项分配给事务，事务获得锁。</p><p id="6165" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果该项被另一个处于不兼容模式的事务锁定，锁管理将执行一个算法来确定将事务保持在等待状态是否会导致死锁。因此，该算法确定事务是否可以等待，或者是否应该取消其中一个事务。</p><h1 id="a666" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">死锁检测和消除</strong></h1><p id="b5a8" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">死锁检测和消除策略定期运行死锁检测算法，如果存在死锁，则消除死锁。当事务请求锁时，它不检查死锁，而锁管理器确定锁是否可用。如果可用，事务可以锁定数据项；否则，事务可能会等待。</p><p id="820c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于在授予锁请求时没有采取任何措施，一些事务可能会被死锁。锁管理定期检查等待图的周期，以检测死锁。如果系统停滞，锁管理从每个周期选择一个牺牲事务。受害者被中止、回滚，然后重新启动。</p><p id="2a6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当发现死锁时，使用以下方法解决它:</p><ul class=""><li id="3083" class="mw mx iq ka b kb kc kf kg kj my kn mz kr na kv nb nc nd ne bi translated"><strong class="ka ir">终止死锁所涉及的进程:</strong>终止死锁所涉及的所有进程或者逐个终止进程直到死锁被解决都是可行的方法，但是这两种方法都不好。终止所有进程的成本是相当大的，并且进程完成的部分工作会丢失。终止每个进程需要很长时间，因为每次进程被终止时，它都必须验证死锁是否已经解决。最佳策略是在死锁情况下终止进程，同时考虑它们的年龄和重要性。</li><li id="da3e" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated"><strong class="ka ir">抢占资源:</strong>另一种策略是抢占资源，并将它们分配给其他进程，直到死锁被解决。</li><li id="d0a8" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated"><strong class="ka ir">等待图表:</strong>检测死锁的一种方法是使用等待图表。这种方法适用于较小的数据库。在这种策略中，基于事务及其对资源的锁定来构建图。如果构造的图包含一个闭环或循环，则存在死锁。</li></ul><h1 id="ccae" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结论</h1><ul class=""><li id="3b15" class="mw mx iq ka b kb me kf mf kj nm kn nn kr no kv nb nc nd ne bi translated">死锁是一种不希望出现的状态，它会使整个系统停止，因为没有任务完成，并且无限期地处于等待状态。如果任何一个事务有可能导致死锁，它就永远不会完成。</li><li id="5e8a" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated">死锁处理和避免是处理该问题的方法，而等待死亡和等待受伤方案是避免死锁的两种流行方法。</li></ul></div></div>    
</body>
</html>