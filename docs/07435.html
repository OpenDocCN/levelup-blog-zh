<html>
<head>
<title>First Party Data And Server-Side Analytics For Everyone: The Hybrid Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向所有人的第一方数据和服务器端分析:混合模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/first-party-data-and-server-side-analytics-for-everyone-the-hybrid-model-a4e293641c9b?source=collection_archive---------3-----------------------#2021-02-18">https://levelup.gitconnected.com/first-party-data-and-server-side-analytics-for-everyone-the-hybrid-model-a4e293641c9b?source=collection_archive---------3-----------------------#2021-02-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="997b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将说明如何在服务器端移动大量的分析实现，从而显著提高数据准确性和数据控制:</p><ul class=""><li id="fc34" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">使用您现有的客户端标记设置</li><li id="1c19" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">不需要使用服务器端的Google Tag Manager，也不需要使用任何Google服务器</li><li id="07c4" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">通过简单的实现</li></ul><p id="e23f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">人们可以称之为混合模式，结合了两个世界的优点。<br/>客户端数据采集。<br/>服务器端数据准备和调度。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/b6da0a204c8ac50160b486beb2721112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ouYZzOzSPFQDFcsSGtRmNA.png"/></div></div></figure><p id="ac3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">面向所有人的第一方数据收集—只需最少的实施工作。</strong>这里的目标既不是创建您自己的数据管道和处理，也不是纯粹依赖服务器端的日志数据。目标是:<br/> →在客户端收集数据(使用任何客户端分析JS库)<br/> →在您自己的服务器上收集、准备和清理数据(我使用的是PHP文件)<br/> →将其转发给互联网上的Google Analytics/Adobe Analytics/或选择的供应商</p><p id="671c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">服务器端实现和标签管理以难以部署而闻名。虽然这无疑给流程增加了额外的步骤，但是服务器上的工作可以被简化到最基本的部分。虽然GTM服务器端是一个大规模简化配置的伟大产品，但我想展示第一方服务器端分析也可以以一种非常容易理解的方式实现。这将有助于更好地理解它实际上是如何工作的，阐明利弊，并消除那些没有太多服务器端实现接触点的人对未知事物的恐惧。</p><pre class="la lb lc ld gt lm ln lo lp aw lq bi"><span id="28d4" class="lr ls iq ln b gy lt lu l lv lw"><strong class="ln ir">In Short</strong></span><span id="6b85" class="lr ls iq ln b gy lx lu l lv lw"><a class="ae ly" href="#1dc7" rel="noopener ugc nofollow">What You Gain</a> <br/>→ Data accuracy, first party server-side cookies, full data control<br/><a class="ae ly" href="#0c48" rel="noopener ugc nofollow">What You Lose</a> <br/>→ Reliable geolocation, vendor-side bot detection, cookie ID on first event<br/><a class="ae ly" href="#7c8e" rel="noopener ugc nofollow">What You Need</a> <br/>→ Access to web hosting server, basic server-side programming<br/><a class="ae ly" href="#0afb" rel="noopener ugc nofollow">What You Must Consider</a> <br/>→ Privacy compliance, consent management<br/><a class="ae ly" href="#f166" rel="noopener ugc nofollow">What It Looks Like in Practise</a> <br/><em class="ll">→ </em><a class="ae ly" href="https://measure.hinternesch.com/" rel="noopener ugc nofollow" target="_blank"><em class="ll">https://measure.hinternesch.com/</em></a></span></pre><h1 id="1dc7" class="lz ls iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">你得到了什么</h1><h2 id="f8f3" class="lr ls iq bd ma mw mx dn me my mz dp mi jy na nb mm kc nc nd mq kg ne nf mu ng bi translated">数据准确性</h2><p id="71af" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk ij bi translated">广告/跟踪拦截器或浏览器隐私工具不会阻止跟踪请求。给点背景知识，阻止工具和安全浏览器会阻止分析请求有几个原因:</p><ul class=""><li id="e4bb" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">调用托管跟踪库的CDN，如谷歌的<em class="ll"> analytics.js </em>或互联网的<em class="ll"> smarttag.js <br/> </em> →解决方案:不要使用CDN。相反，将库作为本地JS文件托管在服务器上。你甚至不必使用供应商库。您还可以编写自己的脚本来捕获和传输选定的客户端数据。</li><li id="8b51" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">调用客户端标签管理系统<br/> →解决方案:不要使用TMS。在本地JS文件中编写实现代码。</li><li id="eebb" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">呼叫已知的分析供应商收集域<br/> →解决方案:不要直接请求供应商端点。取而代之的是，向<em class="ll">https://myDomain.com/measure</em>申请你自己的文件</li></ul><p id="3b29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，你仍然必须获得同意(参见<a class="ae ly" href="#0afb" rel="noopener ugc nofollow"> <em class="ll">你必须考虑什么</em> </a>)。像这样的配置不会非法绕过广告拦截器并侵犯用户隐私，这一点怎么强调都不为过。然而，我确实相信，许多合法的分析正在被任意丢失。在征得同意的情况下对网站使用情况进行负责任的测量不应受到影响，原因很简单，因为用户希望阻止侵犯隐私的第三方广告跟踪解决方案，这是可以理解的。<strong class="jp ir">立法、公众理解和隐私工具如ITP、cookie同意弹出窗口和广告拦截器缺乏细微差别</strong>。这就是像这样的设置可以通过重新获得当前因错误原因丢失的数据来帮助提高数据准确性的地方。</p><h2 id="1861" class="lr ls iq bd ma mw mx dn me my mz dp mi jy na nb mm kc nc nd mq kg ne nf mu ng bi translated">来自您自己域的服务器端第一方Cookies</h2><p id="4344" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk ij bi translated">没有第三方饼干。没有客户端JavaScript cookies(同意管理除外)。只需一个安全的第一方服务器端<em class="ll"> measure-cookie </em>，带有匿名ID，您可以独立设置、管理和控制。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nm"><img src="../Images/851d8001f11e8d40edd30a201a959d21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TNozRpQ0qEw_U4usRI60nQ.png"/></div></div></figure><h2 id="7aa0" class="lr ls iq bd ma mw mx dn me my mz dp mi jy na nb mm kc nc nd mq kg ne nf mu ng bi translated">完全数据控制</h2><p id="f02d" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk ij bi translated">在将数据发送给供应商之前，清理并准备好服务器端的数据。这包括管理IP地址、ID哈希和用户代理，以及在需要时防止指纹识别。对于哪些信息发送到哪里以及用于什么目的，始终对用户透明。</p><h1 id="0c48" class="lz ls iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">你失去了什么</h1><h2 id="a8a7" class="lr ls iq bd ma mw mx dn me my mz dp mi jy na nb mm kc nc nd mq kg ne nf mu ng bi translated">可靠的地理定位和IPs</h2><p id="43a1" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk ij bi translated">最终的供应商请求将来自你的服务器的IP。在下面的<a class="ae ly" href="#f166" rel="noopener ugc nofollow">示例中，我实现了一个变通方法来展示在许多情况下IP仍然可以被转发，但是这里有一些注意事项需要考虑。</a></p><h2 id="675d" class="lr ls iq bd ma mw mx dn me my mz dp mi jy na nb mm kc nc nd mq kg ne nf mu ng bi translated">供应商端Bot检测</h2><p id="2a0b" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk ij bi translated">当服务器发送最终请求时，它默认拥有服务器的用户代理和IP，这两者通常是供应商用来检测僵尸程序的主要标识符。这里有几个备选解决方案:</p><ul class=""><li id="2919" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">客户端方法:<a class="ae ly" href="https://developers.google.com/recaptcha/docs/v3" rel="noopener ugc nofollow" target="_blank">Google reCAPTCHAv3</a>(Simo Ahava<a class="ae ly" href="https://www.simoahava.com/analytics/improve-google-analytics-bot-detection-with-recaptcha/" rel="noopener ugc nofollow" target="_blank">在此</a>)或<a class="ae ly" href="https://github.com/LouisKlimek/HeadlessDetectJS" rel="noopener ugc nofollow" target="_blank">其他客户端库</a>应该能够过滤掉大量内容，而不需要用户输入</li><li id="fb76" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">服务器端的方法:你可以<a class="ae ly" href="https://checkingcreditcard.com/bot-detection-with-php" rel="noopener ugc nofollow" target="_blank">用潜在可疑用户代理的自定义列表创建自己的逻辑</a>(很难编译和管理)，使用类似<a class="ae ly" href="https://developers.cloudflare.com/bots/bot-fight-mode" rel="noopener ugc nofollow" target="_blank"> Cloudflare Bot Fight Mode </a>的服务，甚至使用官方的<a class="ae ly" href="https://www.iab.com/guidelines/iab-abc-international-spiders-bots-list/" rel="noopener ugc nofollow" target="_blank"> IAB列表</a>进行Bot分类(费用昂贵)。请注意，如果用户代理和IP被成功转发(参见下面的<a class="ae ly" href="#f166" rel="noopener ugc nofollow">示例)，在某些情况下，您仍然可以依赖供应商端的bot检测，在大多数情况下，这最终只不过是与IAB列表进行比较。</a></li></ul><h2 id="edb1" class="lr ls iq bd ma mw mx dn me my mz dp mi jy na nb mm kc nc nd mq kg ne nf mu ng bi translated">第一个事件没有Cookie-ID</h2><p id="f21c" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk ij bi translated">这主要是由于PHP cookie逻辑和请求的顺序。需要第一个页面视图来请求PHP脚本处理cookie，以防它还不存在。但是，在大多数情况下，这种影响将被这样一个事实所消除，即无论如何，您都不应该在第一个事件中删除或使用cookie值预同意。</p><h1 id="7c8e" class="lz ls iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">你需要什么</h1><p id="cbd9" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk ij bi translated">访问您的内容托管服务器和域文件夹(包含跟踪逻辑的脚本需要粘贴在这里)以及服务器端脚本和cookie管理的一些基本知识。</p><h1 id="0afb" class="lz ls iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">你必须考虑的是</h1><h2 id="c19b" class="lr ls iq bd ma mw mx dn me my mz dp mi jy na nb mm kc nc nd mq kg ne nf mu ng bi translated">合规和同意管理</h2><p id="1e1a" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk ij bi translated">跟踪信息的发送现在是秘密进行的，即在您的服务器上进行，对用户是不可见的。因此，对于您收集的数据的最终用途，获得同意甚至更为重要。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nn"><img src="../Images/0e165648f50a42655e6a3824c297d246.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nn-xVn-RyS0bg5MyLH4mJA.png"/></div></div></figure><p id="8506" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于<a class="ae ly" href="#f166" rel="noopener ugc nofollow">示例站点</a>，我编写了自己的同意管理脚本。内容托管服务器正在发布和读取带有匿名ID的<em class="ll">度量</em> cookie。<strong class="jp ir">然而，</strong>我只是在用户同意的情况下，将此ID转发给供应商，作为访客识别的一种方式。根据用户的选择，我将放置一个<em class="ll">同意</em> cookie:</p><ul class=""><li id="e9f3" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">如果同意=是→在我的服务器端脚本中使用<em class="ll">度量</em> cookie ID。</li><li id="2d4e" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">如果同意=否→不要使用<em class="ll">度量</em> cookie ID。<a class="ae ly" href="https://developers.atinternet-solutions.com/javascript-en/advanced-features-javascript-en/privacy-javascript-en/#activating-the-no-consent-mode_15" rel="noopener ugc nofollow" target="_blank"> AT Internet有一个<em class="ll">不同意</em>模式</a>，在没有同意的情况下，排除整个跟踪事件和所有相关信息。谷歌的隐私沙箱也会有类似的选项。此选项也是我的所有请求的默认选项，仅在获得同意后才会在服务器上被覆盖。</li></ul><h1 id="f166" class="lz ls iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">它实际上是什么样子</h1><p id="6c8c" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk ij bi translated">我的示例站点有三个页面和一个要跟踪的按钮:<a class="ae ly" href="https://measure.hinternesch.com/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="ll">https://measure.hinternesch.com</em></strong></a></p><h2 id="a0e9" class="lr ls iq bd ma mw mx dn me my mz dp mi jy na nb mm kc nc nd mq kg ne nf mu ng bi translated">客户端逻辑</h2><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi no"><img src="../Images/1d632f9b5caa82bdc5b391fb6ab29002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L0y4-e_fnkBE37fJqgvVEg.png"/></div></div></figure><ul class=""><li id="1f59" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">您可以使用任何类型的定制JavaScript或供应商库来获取客户端信息并创建跟踪请求。这是与<em class="ll">全功能</em>服务器端实现的区别。数据仍在客户端收集。这里最大的好处是我们仍然能够在浏览器中捕获客户端信息和用户交互，比如按钮点击。</li><li id="6dbe" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">更改请求URL的默认集合域和路径。<br/> GA默认:<code class="fe np nq nr ln b">https://www.google-analytics.com/g/collect</code> <br/> ATI默认:<code class="fe np nq nr ln b">https://logs.xiti.com/hit.xiti</code> <br/>我用自己服务器上某个文件的地址替换了:<br/> <code class="fe np nq nr ln b">https://measure.hinternesch.com/measure.php</code></li><li id="f9c4" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">我不是从供应商收集服务器请求一个像素，而是从我自己的服务器请求一个PHP文件。请注意，跟踪请求的所有信息仍将被传输:<br/> -)查询字符串中的客户端信息，由我的标记库组装<br/> -)请求报头中的用户代理、IP、cookie信息</li></ul><h2 id="3b7a" class="lr ls iq bd ma mw mx dn me my mz dp mi jy na nb mm kc nc nd mq kg ne nf mu ng bi translated">服务器端逻辑</h2><ul class=""><li id="ea09" class="kl km iq jp b jq nh ju ni jy ns kc nt kg nu kk kq kr ks kt bi translated">我的服务器上的PHP文件从不在客户端呈现，它有两个目的:<br/> 1)它是跟踪信息的载体——就像像素是<br/>一样2)它处理数据准备并分派给供应商收集端点</li><li id="d1f1" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">注意，这个PHP文件的内容和它做的事情并不适用于每一个实现。这在很大程度上取决于您准备数据的方式、您管理合规性的方式以及您希望将哪些数据转发到哪个端点。作为参考，下面是我的服务器端PHP脚本的注释示例:</li></ul><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nv nw l"/></div></figure><ul class=""><li id="a81a" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">Et voilà:跟踪请求和访问者标识cookie永远不会被阻止。既没有广告拦截器，也没有任何浏览器跟踪预防，如勇敢的隐私盾牌。它们甚至没有被像Omnibug这样的神奇工具发现。</li></ul><p id="a6e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，我们刚刚将很大一部分测量活动转移到了服务器端，因此在数据准确性、合规性和数据准备的可能性方面做出了重大改进——只需做两件事:更改hit的收集地址和向我们的服务器添加单个文件。</p><p id="2130" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ll"> —如果你对流程有疑问，需要帮助实现，发现代码中的错误，或者如果你只是想讨论分析:请随时联系</em><a class="ae ly" href="https://hinternesch.com/?at_medium=affiliate&amp;at_campaign=Medium&amp;at_creation=TheHybridModel&amp;at_format=link" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="ll"/></strong></a><strong class="jp ir"><em class="ll">。</em></strong><em class="ll">——</em></p></div></div>    
</body>
</html>