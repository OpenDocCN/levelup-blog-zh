# 提高你的编程技能

> 原文：<https://levelup.gitconnected.com/build-up-your-programming-skills-152dd5e24d58>

## 在大多数职业中，都有持续改进的兴趣，编程也不例外——它有一个特点，一方面需要推理技能，另一方面需要创造力。

我会试着从我的经验和思考方式中收集想法——毕竟，内省鼓励改进。因此，有些观点是主观的，许多观点有例外，这是很自然的。目标是思考和促进讨论。

![](img/4fac8ed7f62ae3ce16d1685bd869c549.png)

## 牵连

*   **了解您可以支配的资源**，尤其是正在使用的 API。例如，快速浏览一下 [jQuery API](https://api.jquery.com) 在未来会有很大的不同(例如，“是的，这是可能的，我在哪里见过这个”)。另一个例子是，您应该在 IDE 和代码编辑器中试验大部分功能。
*   **了解项目**:路线图、目标、参与人员和大图。只有具备良好的意识，你才能做出明智的决定。知道“为什么”会对发展方向产生很大影响。提议公司举办关于该领域的研讨会。
*   **促进沟通**避免类似“你已经解决了！?"或者“我不知道它已经被废弃了”。
*   **了解需求**:参与需求收集。确保他们符合 [SMART 标准](https://en.wikipedia.org/wiki/SMART_criteria)。
*   **不要只是一个表演者。不要在没有提出疑问的情况下就接受一切(但要适度)。**
*   **由用户/客户驱动**。你工作就是为了他们。理想不是你想的那样，而是用户/客户需要的那样。你可以发表意见，但总是把重点放在他们身上，而不是技术或你。
*   了解规则，这样你就可以打破它们。如果最终结果对公司更有利，你可以冒一点风险，打破一些规则或提出新的做事方式。
*   **积极向上**:避免对没有按计划发生的事情或你无法改变的事情感到恼怒。
*   [**提问**。愚蠢的问题是那些没有被问到的问题。不要害怕问或承认你不知道。即便如此，先调查，学会提问，避免](https://stackoverflow.blog/2018/04/26/stack-overflow-isnt-very-welcoming-its-time-for-that-to-change/) [XY 问题](http://xyproblem.info/)。

## 简单化

*   **简化文本**:尽量用最少的段落、句子和单词来表达相同的意思(例如在电子邮件、聊天、跟踪系统等中)。).顺便说一句，更喜欢文本链接而不是硬编码链接。[干](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)。
*   **不要** [**重复**](https://en.wikipedia.org/wiki/KISS_principle) **代码**:(复制/粘贴多行应引发报警)；考虑可重用的过程，在项目之间创建/共享库，使用[模板](https://en.wikipedia.org/wiki/Web_template_system)等等。[干](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)。

> "简单——最大化工作量的艺术——至关重要."
> 
> [敏捷项目管理快速入门指南，Ed Stark](https://www.goodreads.com/work/quotes/42812570-agile-project-management-quickstart-guide-a-simplified-beginners-guide)

*   **以减少代码为目标**:尽量使用最少的函数/方法、类、代码行等。，但不牺牲可读性和架构。
*   **清理代码**:去除死代码和重复代码。修复 IDE 警告。缩进/格式化代码。删除注释的代码(这就是源代码管理的作用)。你的大部分代码应该反映特性的解决；也就是说，删除日志和类似的。[保持代码的整洁，让人们在自我反馈的循环中更加关心它。](https://en.wikipedia.org/wiki/Broken_windows_theory)
*   [**让代码自己说话**](https://medium.com/codex/towards-self-documenting-code-371364bdccbb) 。其他程序员应该能够理解和修改你的代码。如果他们没有，很可能是你的错。问问自己“如果我在一个月后看到这段代码，我会很快得到它吗？”如果没有，重新考虑它的设计。
*   [**不要评论**](https://medium.com/codex/towards-self-documenting-code-371364bdccbb) 的代码，尤其是带有“列表中又增加了一个元素”等明显的句子。代码不应该依赖注释来理解。最多，您可以留下一些罕见的注释来将代码与其业务特性联系起来。
*   **减少技术依赖**:使用完成相同任务所需的最少技术(如库、框架、数据库、服务)。
*   **分而治之**:永远像工程师一样思考；将问题分成子问题，直到它们变得简单和可管理。
*   [**留意任务开销**](https://medium.com/codex/towards-lean-software-development-24460340b11a) (例如计划、讨论)——所有这些都不是像编码一样在做实际工作；试着平衡开销(问问你自己 it 的投资回报率是多少？).
*   [](https://medium.com/@lsoares/choosing-a-software-library-or-framework-57cfa98f321b)**不要多此一举:很可能你正在解决的问题已经被别人解决了；先搜索。但是要小心框架/库的重量(问问你自己你会用多少)。**
*   ****确保解决方案适合问题**。不要想出比问题本身更复杂的解决方案。这并不意味着为未来准备代码是无效的(因此参与和意识到这一点很重要)。**
*   ****不要拘泥于你达成的第一个方案**；很可能更多的迭代会使解决方案更简单。迭代重构。**

## **技术**

*   ****不要迷恋技术**:不要在没有逻辑论证的情况下使用技术。避免类似“我们用这个吧，因为苹果在用”、“现在每个人都在用”、“因为我很好奇想试试”这样的争论。**
*   **[**不要盲目使用框架/库**](https://medium.com/codex/choosing-a-software-library-or-framework-57cfa98f321b)**，而是要看是否得不偿失。总是试图知道他们在“引擎盖下”做什么。不要试图强迫使用它，因为没有框架/库适合所有问题。****
*   ****重新考虑使用你已经习惯的技术，尤其是当你开始一个新项目或任务的时候。这些可能已经过时或不适合本案。每一种都有其优点、适用性和领域。****
*   ****不要反对你不熟悉的技术(它们可能有其他用途)。保持对竞争技术的了解，至少要有一个观点。不要相信承诺解决一切问题的技术。****
*   ****不学习概念就不要学习技术:技术是短暂的:它们出生，生存，死亡；这些概念依然存在。懂编码并不是懂某种编程语言。****
*   ******自动化可以自动化的东西**减少人为依赖。如果一件事可以由机器来做，那么也许它应该；将人类(程序员和用户)从重复、易遗忘或易出错的任务中解放出来。****
*   ******理想的工具并不是最好的工具** —理想的工具是合适的工具。选择适合您需求的工具。当心技术狂热(例如，当笔记本足够用时，使用电子文档)。****
*   ******不要强加技术**——接受每种技术都有其优点。避免 Win/Mac 或 Android/iOS 讨论；多样性和竞争是积极的。重要的不是系统，而是你用它做什么。****
*   ****[**不要被技术驱动**](https://medium.com/codex/technology-is-a-detail-4b1edd341060) 。在充分了解问题之前，千万不要选择技术。不要强迫人们去适应它们。相反，技术应该遵循人的需求。****

****![](img/bda19ea3a59a45521df50c4df16aadfc.png)****

## ****好习惯****

*   ****[**把问题说出来**](https://en.wikipedia.org/wiki/Rubber_duck_debugging) **:** 把它们用语言表达出来迫使你去构建它们。很多时候你解决了它们却听不到答案。****
*   ******创建灵活的** [**宽容的软件**](http://usabilitypost.com/2009/04/15/8-characteristics-of-successful-user-interfaces/#forgiving) 。不要只是为了理想的情况而准备；增加它不会失败的情况；处理错误，优雅地恢复和后退。****
*   ******以不变应万变**。好的代码是为业务自然遭受的变化而准备的。不要等稳定了…****
*   ****制作可伸缩的、有弹性的代码:想象特殊的场景(例如，“如果这增加了很多呢？”，“如果有很多文件呢？”，“如果出现了 [DoS 攻击](https://en.wikipedia.org/wiki/Denial-of-service_attack)怎么办？它会恢复吗？”，“如果重新启动该服务会怎么样？”).****
*   ****开发自给自足的界面:一个好的界面，无论是 GUI 还是 API，都应该“不言自明”，而不应该依赖于文档。****
*   ******不要做表演狂**。除此之外，还要考虑开发时间和可读性。有时几毫秒并不能证明对项目的影响。性能必须相对化。****
*   ******阅读你正在开发的系统的 UI 指南**(例如[苹果设计](https://developer.apple.com/design/human-interface-guidelines/)、[安卓设计](https://developer.android.com/design/)、 [Windows 设计](https://developer.microsoft.com/en-us/windows/apps/design))。了解并应用[交互设计模式](https://en.wikipedia.org/wiki/Interaction_design_pattern)。****

## ****你的角色****

*   ****接受对你的代码和工作的批评。你的代码不是你的，而是属于公司和每个人的。我们总是可以学习的，大三大四都有。****
*   ******重新思考** [**程序员的角色**](http://www.itworld.com/article/2823759/enterprise-software/124383-Arg-The-9-hardest-things-programmers-have-to-do.html) **。不要以为你是精通 if/else、循环和函数的伟大程序员。编程涉及分析、算法、解决问题、设计、架构、管理、标准、团队合作、质量保证、集成等。******
*   ******提防** [**假设**](https://www.youtube.com/watch?v=wg4trPZFUwc) **和先入为主的想法**。以自由开放的心态开始新的任务。利用你的经验，但不要成为它的受害者:在决策中保持公正和客观。****
*   ******制作图纸**。不要假装你很聪明，不需要列表、流程图、伪代码、模型等等。很好地理解一个问题及其解决方案可以防止重复做几次。半小时的分析/谈话可以节省数小时的代码[迭代](https://en.wikipedia.org/wiki/Iterative_and_incremental_development)。先在纸上迭代。****
*   ******不怪用户**。如果用户不能做某事或者抱怨很多，那不是他/她的错——是你的错。****

## ****持续改进****

*   ******自测**:在 [HackerRank](https://www.hackerrank.com/) 注册，测试/提高自己的算法技能。使用 [StackOverflow](http://stackoverflow.com/) 帮助社区并获得地位。参与开源 [GitHub](https://github.com/) 项目。****
*   ******为 bug 创建测试—** 创建自动化测试来覆盖 bug 和类似的情况。****
*   ******瞄准理想的解决方案**。即使需要更长的时间，从中长期来看也是值得的。不仅代码变得更好，你的技能也变得更好。****
*   ******解析** [**算法复杂度**](http://discrete.gr/complexity/) 学习[大 O 记数法](https://www.interviewcake.com/article/python/big-o-notation-time-and-space-complexity?)；比在指令级优化更好的是在算法级优化。****
*   ****不要滥用书面语言。你在计算机中工作，但你不必写错误——你与外界打交道，你用大量文本制作用户界面，所以要避免错误。****
*   ****尝试与你开发的软件相似的软件，这样你就可以比较了。尝试识别趋势和模式。****
*   ****[**学习**](https://www.udemy.com) **一些新的**:一种编程语言或环境(例如 Android 应用、Chrome 应用、Go 应用)。****
*   ****关注科技博客。一个好的程序员将理论与实践相结合，并且在日常工作中了解新技术。关注你所在地区重要的/有影响力的人/公司的博客和频道。****
*   ******参加** [**碰头会**](https://www.meetup.com)；有许多是免费或低成本的。除了学习，你还做社交。****
*   ****创建你自己的科技博客。写一个主题迫使你去思考它，从而在你的头脑中构建和巩固它。****

## ****TL；速度三角形定位法(dead reckoning)****

*   ****了解环境:客户/用户/项目；****
*   ****将代码和依赖性减少到最低限度，并使用逻辑参数进行选择；****
*   ****重新思考你作为程序员的角色；****
*   ****当心假设和先入之见；****
*   ****保持好奇心，以持续改进为目标。****

****[*本文最初发表于 Pplware，葡萄牙语。*](http://pplware.sapo.pt/informacao/opiniao/saiba-como-ser-um-melhor-programador/)****