<html>
<head>
<title>Streams and how they fit into Node.js async nature.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">流以及它们如何适应Node.js的异步特性。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/streams-and-how-they-fit-into-node-js-async-nature-a08723055a67?source=collection_archive---------5-----------------------#2022-09-12">https://levelup.gitconnected.com/streams-and-how-they-fit-into-node-js-async-nature-a08723055a67?source=collection_archive---------5-----------------------#2022-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0f73" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Node.js中的流介绍和性能测试。</h2></div><p id="ff53" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你从<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/how-to-handle-blockers-in-node-js-1966d0399703">以前的文章</a>中已经知道的，异步服务器的基本思想是一个接一个地处理微小的工作。流理想地代表了这个概念，所以让我们在Node.js中揭开流的神秘面纱。</p><h2 id="9159" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">Node.js中的流是什么？</h2><p id="7b92" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">如果我们去掉细节，流就只是一个数据缓冲区，用来消费或产生小块的数据。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ma"><img src="../Images/e0d6b6f847718256d1322a640c1e0ee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oqWToKVG_wfareGp32ayKg.png"/></div></div></figure><p id="1ab4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么流有什么好处呢？要回答这个问题，让我们来谈谈我们拥有的不同类型的流，第一个是…</p><h2 id="5ef5" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">可读流</h2><p id="82a4" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">创建可读流是为了从源中“读取”数据。我们也可以说<strong class="kh ir">可读流是数据生产者。</strong></p><p id="bd82" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可读流有两种工作模式，暂停和流动。在第一种模式中，流只有在您要求时才会返回数据，而在后一种模式中，它会不断发出带有数据块的<code class="fe mm mn mo mp b"><a class="ae lb" href="https://nodejs.org/api/stream.html#event-data" rel="noopener ugc nofollow" target="_blank">data</a></code>事件。下面你可以看到一个可读流的状态机图。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mq"><img src="../Images/5d4bf8990cf16334a62af5b378ef1462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xY4WufdBM9x_ETKe_dta3A.png"/></div></div></figure><p id="7f53" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您所看到的，默认情况下，流处于暂停状态，一旦您订阅了<code class="fe mm mn mo mp b"><a class="ae lb" href="https://nodejs.org/api/stream.html#event-data" rel="noopener ugc nofollow" target="_blank">data</a></code>事件，它就会转变为流动状态。然后你可以通过<code class="fe mm mn mo mp b"><a class="ae lb" href="https://nodejs.org/api/stream.html#readablepause" rel="noopener ugc nofollow" target="_blank">pause</a></code>方法暂停它。</p><p id="3471" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能想知道为什么我们需要两种模式。我们将在本文的后面回到这个主题。</p><p id="6551" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们进入服务器的性能测试，我们将比较两台服务器。一种是使用异步文件读取向客户端提供大文件(220 MB)…</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="6eb7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…另一个将使用可读流向客户端提供文件。</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="4527" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一如既往，我将使用<a class="ae lb" href="https://github.com/wg/wrk" rel="noopener ugc nofollow" target="_blank"> wrk </a>基准测试，我们将从读取完整文件的服务器开始。我们将在30秒内为服务器加载100个并发连接。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mt"><img src="../Images/719e8ccaae9dbd2c5a18ab34b19320bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hfSQ8tlKvtd57yb9k1N1Mw.png"/></div></div></figure><p id="0156" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，服务器每秒只能处理0.17个请求，更重要的是，服务器在峰值时消耗了高达20 GB的RAM。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mu"><img src="../Images/58e063cf7b0bb16c8f9a79af3ce32873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wERHcrFHy3d4G2VGV0BFYQ.png"/></div></div></figure><p id="d396" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们测试使用流的服务器。正如您在下图中看到的，服务器平均每秒可以处理13个请求。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mv"><img src="../Images/f7ce756589b58c0218058dd6de6d845f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8BgGpdBkdzp2BhW3UPtg3g.png"/></div></div></figure><p id="d4f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用流的服务器平均只使用200 MB的RAM。<strong class="kh ir">我们能够将内存消耗减少近100倍</strong>！这意味着您可以在同一台机器上放置更多的应用程序实例，并处理更多的请求。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mu"><img src="../Images/20c31687412234cf86aeca092ae67ce3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5sJalVIMqoLo1CuP0jMZUA.png"/></div></div></figure><p id="9709" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">值得提醒你的是，在异步服务器中处理阻塞的方法之一是使用分区，正如你从<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/how-to-handle-blockers-in-node-js-1966d0399703">上一篇文章</a>中所知道的。流是分区方法的一个很好的实现。</p><p id="babb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然有一个生产者，就应该有可以消费这些数据的东西，这就是为什么我们需要…</p><h2 id="15e3" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">可写流</h2><p id="2e5c" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">如果可读流是生产者，那么<strong class="kh ir">可写流就是消费者。</strong>与任何其他流一样，它有一个内部缓冲区，这个内部缓冲区用于保存“待处理”的数据，这些数据将被发送到我们想要存放这些数据的目标存储器。</p><p id="2b9a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可写流也有不同的状态，您可以在下图中看到它们的表示。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mw"><img src="../Images/39325b02448814bc7693a0924dc05863.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*74Vydeb5Lp5AVz9pXXfuZg.png"/></div></div></figure><p id="9360" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">流是用空缓冲区创建的，生产者可以将数据推送到流中，但当缓冲区满了时，<code class="fe mm mn mo mp b"><a class="ae lb" href="https://nodejs.org/api/stream.html#writablewritechunk-encoding-callback" rel="noopener ugc nofollow" target="_blank">write()</a></code>方法会将<code class="fe mm mn mo mp b">false</code>返回给你，你需要等到缓冲区变空并发出<code class="fe mm mn mo mp b"><a class="ae lb" href="https://nodejs.org/api/stream.html#event-drain" rel="noopener ugc nofollow" target="_blank">drain</a></code>事件。</p><h2 id="1596" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">反压力</h2><p id="1e9d" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">你有没有想过，如果一个可读的流产生的数据比一个可写的流所能处理的多，会发生什么？是的，我们已经知道流有一个内部缓冲区，所以数据将被存储在缓冲区中，但是如果缓冲区满了会发生什么呢？</p><p id="2a70" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JS是一种非常动态的语言，因此流会尝试为其内部缓冲区分配更多的内存来处理这种情况。但是，这可能会导致内存不足的异常。</p><p id="f92b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是背压派上用场的时候了。这是为处理此类案件而设立的机制。你还记得不同流的状态机吗？因此，可读流将数据推入可写流，直到缓冲区满了，然后进入暂停模式。之后，等待<code class="fe mm mn mo mp b"><a class="ae lb" href="https://nodejs.org/api/stream.html#event-drain" rel="noopener ugc nofollow" target="_blank">drain</a></code>事件再次进入流动模式。</p><p id="4d56" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见<strong class="kh ir">，背压是可读流需要两种模式的唯一原因。通过这种方式，我们可以处理可读流产生的数据多于可写流所能处理的数据的情况。</strong></p><p id="4764" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能想知道每次使用streams时是否需要处理这个问题，答案是不需要。有一个名为<code class="fe mm mn mo mp b"><a class="ae lb" href="https://nodejs.org/api/stream.html#streampipelinestreams-callback" rel="noopener ugc nofollow" target="_blank">pipeline</a></code>的功能可以帮你处理这个问题。</p><p id="4117" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们知道了可读和可写的流，是时候谈谈第三种类型的流了，它被称为…</p><h2 id="3815" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">双重流</h2><p id="4cd7" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">双工流是同时表示可读和可写流的流。因为它是一个可读写的流，所以它在内部维护两个缓冲区，一个用于读取数据，另一个用于写入数据。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mx"><img src="../Images/885cfdd59126c9eefabeba836b1abed9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AXSKpL99possbe2Qvb6vEw.png"/></div></div></figure><p id="b1d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种类型的流可能对双向通信有用，例如，来自<code class="fe mm mn mo mp b"><a class="ae lb" href="https://nodejs.org/api/net.html" rel="noopener ugc nofollow" target="_blank">net</a></code>核心模块的<code class="fe mm mn mo mp b"><a class="ae lb" href="https://nodejs.org/api/net.html#class-netsocket" rel="noopener ugc nofollow" target="_blank">Socket</a></code>是双工流。</p><p id="196e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">转换流是双工流的一个特例。顾名思义，转换流在将数据从一个地方传输到另一个地方的过程中修改数据。转换流的一个例子可以是来自<code class="fe mm mn mo mp b"><a class="ae lb" href="https://nodejs.org/api/zlib.html" rel="noopener ugc nofollow" target="_blank">zlib</a></code>核心模块的任何流，比如Gzip类。</p><h2 id="0c0a" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">摘要</h2><p id="ed16" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">Node.js非常擅长处理小块工作，而Streams就是这种想法的代表。使用流可以提高Node.js服务器的性能，并显著减少RAM消耗。</p><p id="9e89" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管您很少在您的日常工作中实现定制的流，但是在我们以这种或那种方式构建的每个应用程序中都涉及到流。</p><p id="3088" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在<a class="ae lb" href="https://github.com/Ayzrian/streams-in-nodejs" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>中找到本文使用的源代码。</p><h2 id="98cf" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">接下来呢？</h2><p id="b7e5" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">爱Node.js？你可以看看我关于它的其他文章</p><ul class=""><li id="6dbb" class="my mz iq kh b ki kj kl km ko na ks nb kw nc la nd ne nf ng bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/is-bun-js-the-node-js-killer-ffeb0f89196a">bun . js是Node.js杀手吗？</a></li><li id="3b39" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/how-to-handle-blockers-in-node-js-1966d0399703">如何处理Node.js中的拦截器？</a></li><li id="0b8d" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated"><a class="ae lb" href="https://medium.com/gitconnected/why-asynchronous-is-a-trend-c9892667e245" rel="noopener">为什么异步是一种趋势？</a></li></ul></div></div>    
</body>
</html>