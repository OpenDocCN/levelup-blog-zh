<html>
<head>
<title>A Basic Guide to JavaScript Regular Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript正则表达式基础指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/basic-guide-to-javascript-regular-expressions-6c8ad542043a?source=collection_archive---------13-----------------------#2020-01-28">https://levelup.gitconnected.com/basic-guide-to-javascript-regular-expressions-6c8ad542043a?source=collection_archive---------13-----------------------#2020-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/05a09052aaa79a2051fdc61e6f0c2b8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*67_Dn-gt7PkNuBDe"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">安德烈·瓦瑟伯格在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4201" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正则表达式让我们可以轻松地操作字符串。它们是让我们以我们想象的任何方式匹配文本的模式。没有它，我们在搜索复杂模式的文本时会有很大的困难。根据正则表达式检查输入对于表单验证也很有用。</p><p id="4ce9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中，有一个正则表达式对象。我们可以用正则表达式来定义它，或者使用<code class="fe le lf lg lh b">RegExp</code>构造函数来定义一个正则表达式对象。</p><p id="719f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了定义正则表达式文字，我们用斜线包围正则表达式模式。例如，我们可以写:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="80a9" class="lq lr it lh b gy ls lt l lu lv">const re = /a/</span></pre><p id="4568" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">定义一个正则表达式对象来查找字母“a”。或者，我们可以使用正则表达式构造函数来定义正则表达式对象，方法是向<code class="fe le lf lg lh b">RegExp</code>构造函数传递一个字符串，如下所示:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="05a5" class="lq lr it lh b gy ls lt l lu lv">const re = new RegExp('a');</span></pre><p id="f69e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用上面提到的字母或数字对于搜索像数字和字母这样的简单模式很有用。如果我们想要搜索更复杂的模式，我们必须使用特殊字符来构建一个正则表达式，让我们搜索更复杂的模式。它们中的大多数对于大多数编程语言都是相同的，但是也可能有特定于语言的扩展。</p><h1 id="51ee" class="lw lr it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">特殊字符</h1><p id="3fd4" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">以下是我们可以在JavaScript对象中使用的特殊字符:</p><h2 id="09ab" class="lq lr it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi">\</h2><p id="edfb" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">非特殊字符前面的反斜杠表示下一个字符是特殊字符，不能按字面意思解释。例如，<code class="fe le lf lg lh b">\b</code>表示单词边界，而<code class="fe le lf lg lh b">b</code>匹配字母‘b’。</p><p id="c8e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">特殊字符前面的反斜杠表示下一个字符不特殊，应该按字面意思解释。例如，<code class="fe le lf lg lh b">\^</code>将搜索'^'字符。</p><h2 id="703a" class="lq lr it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi">^</h2><p id="7ec0" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">^字符匹配输入的开头。如果multiline标志设置为true，它还会紧跟在换行符之后进行匹配。</p><p id="dc57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，<code class="fe le lf lg lh b">/^a/</code>匹配字符串<code class="fe le lf lg lh b">abc</code>中的‘a ’,但不匹配<code class="fe le lf lg lh b">cba</code>中的‘a’。</p><h2 id="fe09" class="lq lr it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi">$</h2><p id="d040" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">$匹配输入的结尾。如果multiline标志设置为true，它还会紧跟在换行符之后进行匹配。</p><p id="9493" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，<code class="fe le lf lg lh b">/t$/</code>匹配<code class="fe le lf lg lh b">bat</code>中的‘t’，但不匹配<code class="fe le lf lg lh b">tab</code>中的‘t’。</p><h2 id="62cb" class="lq lr it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi">*</h2><p id="2070" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">*匹配前面的表达式0次或更多次。和<code class="fe le lf lg lh b">{0*}</code>一样。</p><p id="e9cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，<code class="fe le lf lg lh b">/o*/</code>与<code class="fe le lf lg lh b">moo</code>中的‘oo’匹配，但与<code class="fe le lf lg lh b">tab</code>中的‘oo’不匹配。</p><h2 id="81a7" class="lq lr it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi">+</h2><p id="1fdb" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">该字符与它前面的表达式匹配1次或多次。和<code class="fe le lf lg lh b">{1,}</code>一样。</p><p id="614d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，<code class="fe le lf lg lh b">/b+/</code>与<code class="fe le lf lg lh b">cabbage</code>中的<code class="fe le lf lg lh b">bb</code>匹配，但与<code class="fe le lf lg lh b">moo</code>中的<code class="fe le lf lg lh b">bb</code>不匹配。</p><h2 id="4275" class="lq lr it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi">?</h2><p id="f019" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">问号与它前面的表达式匹配0或1次。和<code class="fe le lf lg lh b">{0,1}</code>一样。</p><p id="ee52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">比如<code class="fe le lf lg lh b">/b?a/</code>匹配<code class="fe le lf lg lh b">bat</code>中的<code class="fe le lf lg lh b">ba</code>，匹配<code class="fe le lf lg lh b">cat</code>中的<code class="fe le lf lg lh b">a</code>。</p><p id="d762" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果用在任何字符*、+、？或者{}，那么它使<code class="fe le lf lg lh b">?</code>非贪婪，这意味着它匹配最少的可能字符。这与默认的贪婪相反，贪婪匹配尽可能多的字符。</p><p id="efe8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">比如<code class="fe le lf lg lh b">[a-z]+</code>匹配<code class="fe le lf lg lh b">abc</code>但是<code class="fe le lf lg lh b">[a-z]+?</code>匹配<code class="fe le lf lg lh b">a</code>。</p><h2 id="6fb4" class="lq lr it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi">.</h2><p id="4ee1" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">默认情况下，句点匹配除换行符以外的任何单个字符。</p><p id="ccf4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如<code class="fe le lf lg lh b">.a</code>与<code class="fe le lf lg lh b">ba</code>中的<code class="fe le lf lg lh b">ba</code>或<code class="fe le lf lg lh b">bat</code>相匹配。</p><h2 id="dd52" class="lq lr it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">(十)</h2><p id="ae64" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">匹配括号中的任何模式，并记住该匹配。括号被称为捕获括号。那么整个模式称为捕获群。</p><p id="bdcf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有<code class="fe le lf lg lh b">(abc)(def) \1</code>，那么如果我们得到几个<code class="fe le lf lg lh b">abcdef abcdef</code>的匹配。我们得到<code class="fe le lf lg lh b">abcdef abc</code>、<code class="fe le lf lg lh b">abc</code>和<code class="fe le lf lg lh b">def</code>。<code class="fe le lf lg lh b">\1</code>用于表示第一个子串匹配，即<code class="fe le lf lg lh b">abc</code>。</p><p id="510f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在一个正则表达式中有多个捕获组，例如如果我们有<code class="fe le lf lg lh b">(abc) (def) \1 \2</code>，那么我们得到匹配<code class="fe le lf lg lh b">abc def abc def</code>、<code class="fe le lf lg lh b">abc</code>和<code class="fe le lf lg lh b">def</code>。正如我们所看到的，任何与每个捕获组中的模式相匹配的东西以及它们的组合都被认为是匹配的。<code class="fe le lf lg lh b">\1</code>是代表与上例相同的东西，<code class="fe le lf lg lh b">\2</code>代表第二个子串，也就是<code class="fe le lf lg lh b">def</code>。</p><h2 id="f0e1" class="lq lr it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated"><code class="fe le lf lg lh b">(?:x)</code></h2><p id="14fe" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">这个类似于<code class="fe le lf lg lh b">(x)</code>但是不记得比赛。</p><p id="a422" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有模式<code class="fe le lf lg lh b">(?:abc){1,2}</code>，那么如果我们有字符串<code class="fe le lf lg lh b">abc def abc def</code>，那么第一个<code class="fe le lf lg lh b">abc</code>将被匹配。</p><h2 id="321e" class="lq lr it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated"><code class="fe le lf lg lh b">x(?=y)</code></h2><p id="3eca" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">只有当<code class="fe le lf lg lh b">x</code>在<code class="fe le lf lg lh b">y</code>之前时，模式才与<code class="fe le lf lg lh b">x</code>匹配。这叫做前瞻模式。</p><p id="74b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有模式<code class="fe le lf lg lh b">x(?=y)</code>和字符串<code class="fe le lf lg lh b">xy</code>，那么我们得到<code class="fe le lf lg lh b">x</code>作为匹配。</p><h2 id="288f" class="lq lr it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated"><code class="fe le lf lg lh b">x(?!y)</code></h2><p id="35a5" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">仅当<code class="fe le lf lg lh b">x</code>后面没有<code class="fe le lf lg lh b">y</code>时，该模式才匹配<code class="fe le lf lg lh b">x</code>。这叫做回顾。</p><p id="dce7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如<code class="fe le lf lg lh b">x(?!y)</code>不会与<code class="fe le lf lg lh b">xylophone</code>匹配，但会与<code class="fe le lf lg lh b">axe</code>中的<code class="fe le lf lg lh b">x</code>匹配。</p><h2 id="ce5c" class="lq lr it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">(?</h2><p id="fed9" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">这个模式只匹配<code class="fe le lf lg lh b">x</code>是<code class="fe le lf lg lh b">x</code>前面没有<code class="fe le lf lg lh b">y</code>。这被称为否定的前瞻。</p><p id="6df2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有模式<code class="fe le lf lg lh b">(?&lt;=b)a</code>和字符串<code class="fe le lf lg lh b">bat</code>，那么它将匹配<code class="fe le lf lg lh b">bat</code>中的<code class="fe le lf lg lh b">a</code>。然而，同样的模式不会匹配单词<code class="fe le lf lg lh b">cat</code>，因为<code class="fe le lf lg lh b">b</code>不在<code class="fe le lf lg lh b">a</code>之前。</p><h2 id="86f5" class="lq lr it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">(?</h2><p id="d547" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">仅当<code class="fe le lf lg lh b">x</code>前面没有<code class="fe le lf lg lh b">y</code>时，该模式才匹配<code class="fe le lf lg lh b">x</code>。这被称为否定后视。</p><p id="8088" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有模式<code class="fe le lf lg lh b">(?&lt;!b)a</code>和字符串<code class="fe le lf lg lh b">cat</code>，那么它将匹配<code class="fe le lf lg lh b">cat</code>中的<code class="fe le lf lg lh b">a</code>。但是，不会和<code class="fe le lf lg lh b">bat</code>里的任何东西匹配。</p><h2 id="602b" class="lq lr it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated"><code class="fe le lf lg lh b">x|y</code></h2><p id="c3c9" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">匹配<code class="fe le lf lg lh b">x</code>或<code class="fe le lf lg lh b">y</code>。例如，如果我们有图案<code class="fe le lf lg lh b">x|y</code>和单词<code class="fe le lf lg lh b">xylophone</code>，那么它将匹配<code class="fe le lf lg lh b">x</code>。</p><h2 id="f46a" class="lq lr it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">{n}</h2><p id="2ec7" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">精确匹配表达式的<code class="fe le lf lg lh b">n</code>次出现。例如，如果我们有<code class="fe le lf lg lh b">a{2}</code>，那么我们匹配<code class="fe le lf lg lh b">baa</code>中的<code class="fe le lf lg lh b">aa</code>。</p><h2 id="c6e1" class="lq lr it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">{n，}</h2><p id="e7c7" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">这个模式至少匹配前面表达式中出现的<code class="fe le lf lg lh b">n</code>，其中<code class="fe le lf lg lh b">n</code>是一个正整数。</p><p id="4ca6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">比如<code class="fe le lf lg lh b"> b{2,}</code>匹配<code class="fe le lf lg lh b">bb</code>、<code class="fe le lf lg lh b">bbb</code>、<code class="fe le lf lg lh b">bbbb</code>等等。</p><h2 id="f0cb" class="lq lr it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">{a，b}</h2><p id="5c90" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">匹配在此之前从<code class="fe le lf lg lh b">a</code>到<code class="fe le lf lg lh b">b</code>次的表达式。例如，如果我们有<code class="fe le lf lg lh b">b{2,4}</code>，它将匹配字符串<code class="fe le lf lg lh b">bb</code>、<code class="fe le lf lg lh b">bbb</code>、<code class="fe le lf lg lh b">bbbb</code>而不匹配其他。</p><h2 id="a6ff" class="lq lr it bd lx my mz dn mb na nb dp mf kr nc nd mj kv ne nf mn kz ng nh mr ni bi translated">[xyz]</h2><p id="b180" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">匹配括号中的某个字符的模式，包括转义序列。例如，<code class="fe le lf lg lh b">[xyz]</code>将匹配<code class="fe le lf lg lh b">xylophone</code>中的<code class="fe le lf lg lh b">x</code>，匹配<code class="fe le lf lg lh b">yawn</code>中的<code class="fe le lf lg lh b">y</code>。</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/5be1a654e50b8825d66cc7188ab860ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NKUfX1IWiZllriEM"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@pizbern?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">宝琳·伯恩菲尔德</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="cc55" class="lw lr it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">组合特殊字符以形成复杂的图案</h1><p id="f891" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">我们可以结合这些特殊表达式来寻找更复杂的模式。一个常见的例子是验证电子邮件地址。</p><p id="cadf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">电子邮件的简单正则表达式可以是:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="21d9" class="lq lr it lh b gy ls lt l lu lv">[a-z0-9.]+@[a-z0-9.]+.[a-z]</span></pre><p id="6d89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的正则表达式中，我们有<code class="fe le lf lg lh b">[a-z0–9.]+</code>，它匹配任何数字、字母或出现任意次的句点。接下来是一个<code class="fe le lf lg lh b">@</code>符号，它出现在每个电子邮件地址中，将用户名和域名分开。然后，我们再次使用<code class="fe le lf lg lh b">[a-z0–9.]+</code>来匹配出现任意次的任何字母、数字或句点。这后面跟着一个句号。然后<code class="fe le lf lg lh b">[a-z]</code>匹配域名。</p><h1 id="f233" class="lw lr it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">结论</h1><p id="c6a1" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">在本文中，我们刚刚开始研究JavaScript中的正则表达式。定义正则表达式可以用文字表达式或<code class="fe le lf lg lh b">RegExp</code>构造函数来完成。我们可以用表示特定模式的特殊字符来构造正则表达式。然后，我们可以将它们组合成更大的正则表达式，以搜索更复杂的模式，如电子邮件。</p></div></div>    
</body>
</html>