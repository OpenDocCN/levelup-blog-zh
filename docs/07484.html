<html>
<head>
<title>Creating an RSS Feed with a Netlify Serverless Function + Contentful</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Netlify无服务器函数+ Contentful创建RSS提要</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-an-rss-feed-with-a-netlify-serverless-function-contentful-21b26049f933?source=collection_archive---------12-----------------------#2021-02-21">https://levelup.gitconnected.com/creating-an-rss-feed-with-a-netlify-serverless-function-contentful-21b26049f933?source=collection_archive---------12-----------------------#2021-02-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f0f4493a58cf1a2cdffa0f817719b055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2H2f0Tsnky6eaDwwXGT4Yw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">打造你的天线。</figcaption></figure><p id="fa42" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">早在2020年10月，Brightcove <a class="ae la" href="https://www.brightcove.com/en/blog/brightcove-video-means-business" rel="noopener ugc nofollow" target="_blank">推出了我们的新品牌</a>——同时推出了新的<a class="ae la" href="https://www.brightcove.com/en" rel="noopener ugc nofollow" target="_blank">www.brightcove.com</a>——采用<a class="ae la" href="https://contentful.com" rel="noopener ugc nofollow" target="_blank"> Contentful </a>和<a class="ae la" href="https://www.netlify.com" rel="noopener ugc nofollow" target="_blank"> Netlify </a>的盖茨比风格。一月份，我们把我们的英文博客搬了过来，所以inso不得不寻找一个feed视图的替代品(最初是通过Node/sail js/Pug提供的)。谢天谢地，这是Netlify的函数和Contentful的JavaScript SDK的轻而易举的事情。</p><p id="561a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">RSS提要本质上是一个很长的XML文件，包含读者获取的内容。这个函数只需要做三件事:</p><ol class=""><li id="368b" class="lb lc iq ke b kf kg kj kk kn ld kr le kv lf kz lg lh li lj bi translated">获取内容</li><li id="d50e" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated">汇编和格式化提要</li><li id="aed0" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated">返回格式化的提要</li></ol><p id="5f60" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，在部署到Netlify的Gatsby项目中，创建一个/functions/文件夹(如果还没有的话)。在该文件夹中，创建一个名为rss-feed.js的文件。</p><p id="1b4f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在rss-feed.js中，首先导入内容丰富的javascript内容交付API，并使用您的凭证配置客户端:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="5281" class="ly lz iq lu b gy ma mb l mc md">const contentful = require(“contentful”);<br/>const client = contentful.createClient({<br/>  space: "SPACE_ID",<br/>  accessToken: process.env.GATSBY_CONTENTFUL_ACCESS_TOKEN<br/>});</span></pre><p id="8946" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可以使用与您的应用程序的其余部分相同的env变量来访问Contentful—rad。</p><p id="31b5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接下来，我们可以设置实际响应请求的处理程序。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="d0c0" class="ly lz iq lu b gy ma mb l mc md">exports.handler = async (event, context) =&gt; {<br/>  // get posts from contentful and do stuff<br/>  return {<br/>    statusCode: 200,<br/>    body: "MY FEED WILL GO HERE"<br/>  };<br/>};</span></pre><p id="d27d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Netlify函数需要返回一个状态和主体。在我们的例子中，主体将是带有大量数据的格式化的XML。但是首先，让我们添加对Contentful的调用。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="db54" class="ly lz iq lu b gy ma mb l mc md">const posts = await client.getEntries({<br/>    content_type: "post",<br/>    locale: "en-US",<br/>    order: "-fields.publishedAt"<br/> });</span></pre><p id="4bd2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是对上面配置的内容丰富的客户端的异步调用。我们的内容类型被定义为“post ”,我们正在寻找英文的帖子，所以我们将通过“en-US”地区。为了确保他们首先返回最新的帖子，我们添加了“-fields.publishedAt”的订单查询(您可以根据自己的内容模型使用任何想要的参数)。</p><p id="6c67" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">既然我们得到了帖子，是时候构建提要了。下面的两个方法可以做到这一点:为整个提要设置开始和结束标记，以及每个条目的特定于项目的格式。感谢模板文字让这个<em class="me">超级</em>变得简单。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="fb9e" class="ly lz iq lu b gy ma mb l mc md">const sanitize = (string) =&gt; {<br/>  const newString = string.replace(/\&amp;/g, "&amp;amp;");<br/>  return newString;<br/>};<br/>const dateString = (dstring) =&gt; {<br/>  const target = new Date(dstring);<br/>  return target.toUTCString();<br/>};</span><span id="fe69" class="ly lz iq lu b gy mf mb l mc md">const feedWrapper = (contents) =&gt; {<br/>  return `&lt;?xml version="1.0" encoding="utf-8" ?&gt;<br/>    &lt;rss version="2.0" xml:base="<a class="ae la" href="https://site.com/en/blog/feed" rel="noopener ugc nofollow" target="_blank">https://site.com/en/blog/feed</a>" xmlns:dc="<a class="ae la" href="http://purl.org/dc/elements/1.1/" rel="noopener ugc nofollow" target="_blank">http://purl.org/dc/elements/1.1/</a>"&gt;<br/>    &lt;channel&gt;<br/>        &lt;title&gt;My Blog - The Leading Blog&lt;/title&gt;<br/>        &lt;link&gt;<a class="ae la" href="https://site.com/en/blog" rel="noopener ugc nofollow" target="_blank">https://site.com/en/blog</a>&lt;/link&gt;<br/>        &lt;description&gt;Superior Posts&lt;/description&gt;<br/>        &lt;language&gt;en&lt;/language&gt;<br/>        ${contents}<br/>    &lt;/channel&gt;<br/>    &lt;/rss&gt;<br/>    `;<br/>};</span><span id="534c" class="ly lz iq lu b gy mf mb l mc md">const stringify = (obj) =&gt; {<br/>  const template = (entry, id) =&gt; `<br/>        &lt;item&gt;<br/>            &lt;title&gt;${sanitize(entry.title) || ""}&lt;/title&gt;<br/>            &lt;link&gt;<a class="ae la" href="https://site.com/en/blog/${entry.slug" rel="noopener ugc nofollow" target="_blank">https://site.com/en/blog/${entry.slug</a> || ""}&lt;/link&gt;<br/>            &lt;category&gt;<a class="ae la" href="https://www.brightcove.com/en/blog/${" rel="noopener ugc nofollow" target="_blank">https://site.com/en/blog/${</a><br/>              entry.category.fields.slug<br/>            }&lt;/category&gt;<br/>            &lt;pubDate&gt;${dateString(entry.publishedAt)}&lt;/pubDate&gt;<br/>            &lt;description&gt;${sanitize(entry.body)}&lt;/description&gt;<br/>            &lt;dc:creator&gt;${entry.author.fields.name}&lt;/dc:creator&gt;<br/>            &lt;guid&gt;<a class="ae la" href="https://site.com/en/blog/${entry.slug" rel="noopener ugc nofollow" target="_blank">https://site.com/en/blog/${entry.slug</a>}&lt;/guid&gt;<br/>        &lt;/item&gt;<br/>    `;<br/>  if (obj &amp;&amp; obj.fields &amp;&amp; Object.keys(obj.fields).length &gt; 0) {<br/>    return template(obj.fields, obj.sys.id);<br/>  } else {<br/>    return "";<br/>  }<br/>};</span></pre><p id="8e7d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">好了，让我们来谈谈其中的一些。sanitize和dateString方法只是清理从Contentful返回的内容；不好的HTML字符(特别是“&amp;”)会让feed读者生气，所以santize替换了它们。为了将一个以毫秒为单位的时间戳转换成清晰的日期/时间，dateString方法返回一个UTC字符串，这也是为了使<pubdate>值有效。</pubdate></p><p id="a260" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">feedWrapper方法包含开始和结束feed标签，并接受一个<em class="me">内容</em>参数——该参数将是由<em class="me"> stringify </em>方法生成的条目列表。让我们建立这个列表:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="4873" class="ly lz iq lu b gy ma mb l mc md">const buildFeed = (posts) =&gt; {<br/>  let entries = "";<br/>  posts.items.forEach((item, index) =&gt; {<br/>    if (item.fields &amp;&amp; Object.keys(item.fields).length &gt; 0) {<br/>      entries += stringify(item);<br/>    }<br/>  });<br/>  return feedWrapper(entries);<br/>};</span></pre><p id="7ec4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们已经设置了一个空的<em class="me">条目</em>字符串，它被追加到我们从contentful响应传递的方法的post项的forEach循环中。我们检查post对象是否有包含我们需要的内容的字段，并为每个字段生成一个模板字符串。然后，该方法移交已构建的&lt;项目列表&gt; …..&lt; /item &gt;字符串关闭到feedWrapper方法，并返回编译后的XML提要。</p><p id="ddc1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">综合起来，它看起来像这样:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="a8f1" class="ly lz iq lu b gy ma mb l mc md">const contentful = require("contentful");<br/>const client = contentful.createClient({<br/>  space: "SPACE_ID",<br/>  accessToken: process.env.GATSBY_CONTENTFUL_ACCESS_TOKEN<br/>});</span><span id="9ce5" class="ly lz iq lu b gy mf mb l mc md">const feedWrapper = (contents) =&gt; {<br/>  return `&lt;?xml version="1.0" encoding="utf-8" ?&gt;<br/>    &lt;rss version="2.0" xml:base="<a class="ae la" href="https://site.com/en/blog/feed" rel="noopener ugc nofollow" target="_blank">https://site.com/en/blog/feed</a>" xmlns:dc="<a class="ae la" href="http://purl.org/dc/elements/1.1/" rel="noopener ugc nofollow" target="_blank">http://purl.org/dc/elements/1.1/</a>"&gt;<br/>    &lt;channel&gt;<br/>        &lt;title&gt;My Blog - The Leading Blog&lt;/title&gt;<br/>        &lt;link&gt;<a class="ae la" href="https://site.com/en/blog" rel="noopener ugc nofollow" target="_blank">https://site.com/en/blog</a>&lt;/link&gt;<br/>        &lt;description&gt;Superior Posts&lt;/description&gt;<br/>        &lt;language&gt;en&lt;/language&gt;<br/>        ${contents}<br/>    &lt;/channel&gt;<br/>    &lt;/rss&gt;<br/>    `;<br/>};<br/>const sanitize = (string) =&gt; {<br/>  const newString = string.replace(/\&amp;/g, "&amp;amp;");<br/>  return newString;<br/>};<br/>const dateString = (dstring) =&gt; {<br/>  const target = new Date(dstring);<br/>  return target.toUTCString();<br/>};<br/>const stringify = (obj) =&gt; {<br/>  const template = (entry, id) =&gt; `<br/>        &lt;item&gt;<br/>            &lt;title&gt;${sanitize(entry.title) || ""}&lt;/title&gt;<br/>            &lt;link&gt;<a class="ae la" href="https://site.com/en/blog/${entry.slug" rel="noopener ugc nofollow" target="_blank">https://site.com/en/blog/${entry.slug</a> || ""}&lt;/link&gt;<br/>            &lt;category&gt;<a class="ae la" href="https://www.brightcove.com/en/blog/${" rel="noopener ugc nofollow" target="_blank">https://site.com/en/blog/${</a><br/>              entry.category.fields.slug<br/>            }&lt;/category&gt;<br/>            &lt;pubDate&gt;${dateString(entry.publishedAt)}&lt;/pubDate&gt;<br/>            &lt;description&gt;${sanitize(entry.body || "")}&lt;/description&gt;<br/>            &lt;dc:creator&gt;${entry.author.fields.name}&lt;/dc:creator&gt;<br/>            &lt;guid&gt;<a class="ae la" href="https://site.com/en/blog/${entry.slug" rel="noopener ugc nofollow" target="_blank">https://site.com/en/blog/${entry.slug</a>}&lt;/guid&gt;<br/>        &lt;/item&gt;<br/>    `;<br/>  if (obj &amp;&amp; obj.fields &amp;&amp; Object.keys(obj.fields).length &gt; 0) {<br/>    return template(obj.fields, obj.sys.id);<br/>  } else {<br/>    return "";<br/>  }<br/>};<br/>const buildFeed = (posts) =&gt; {<br/>  let entries = "";<br/>  posts.items.forEach((item, index) =&gt; {<br/>    if (item.fields &amp;&amp; Object.keys(item.fields).length &gt; 0) {<br/>      entries += stringify(item);<br/>    }<br/>  });<br/>  return feedWrapper(entries);<br/>};</span><span id="f5a4" class="ly lz iq lu b gy mf mb l mc md">exports.handler = async (event, context) =&gt; {<br/>  // get posts from contentful<br/>  const posts = await client.getEntries({<br/>    content_type: "post",<br/>    locale: "en-US",<br/>    order: "-fields.publishedAt"<br/>  });<br/>  const formatted = posts ? buildFeed(posts) : "";<br/>  return {<br/>    statusCode: 200,<br/>    body: formatted<br/>  };<br/>};</span></pre><p id="6e04" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该函数等待posts，通过遍历条目构建提要，然后将条目粘贴到XML包装器中，并将其作为响应体返回。现在，要在您的netlify应用程序中创建一个路由，您可以创建一个Netlify重定向。在我们的例子中，我们已经大量使用了<code class="fe mg mh mi lu b">/static/_redirects</code>文件，所以我们只需要添加新的一行:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="f1a6" class="ly lz iq lu b gy ma mb l mc md">/en/blog/feed/all   /.netlify/functions/rss-feed  200!</span></pre><p id="895d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我们可以将用户指向<code class="fe mg mh mi lu b">en/blog/feed/all</code>的URL，它将执行函数来获取帖子并返回XML:<a class="ae la" href="https://www.brightcove.com/en/blog/feed/all" rel="noopener ugc nofollow" target="_blank">https://www.brightcove.com/en/blog/feed/all</a></p><p id="206b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是一个相当快速的端口，我相信还有更多的可以添加到feed(媒体资产等)，但它让我们的feed启动并运行，几乎没有任何问题。我已经删除了一些我们必须用来清理响应数据的额外库，但值得注意的是，如果您从CMS获得Markdown，应该对其进行解析和清理——我发现<a class="ae la" href="https://www.npmjs.com/package/markdown-it" rel="noopener ugc nofollow" target="_blank"> markdown-it </a>和<a class="ae la" href="https://www.npmjs.com/package/string" rel="noopener ugc nofollow" target="_blank"> string </a>有助于将数据规范化为RSS解析器更喜欢的内容。</p><p id="12ba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我应该在这里添加更多内容，请大声说出！感谢阅读！</p></div></div>    
</body>
</html>