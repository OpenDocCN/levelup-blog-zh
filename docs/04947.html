<html>
<head>
<title>Learn the basics of GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解GraphQL的基础知识</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learn-the-basics-of-graphql-4740d76d5e8a?source=collection_archive---------0-----------------------#2020-07-26">https://levelup.gitconnected.com/learn-the-basics-of-graphql-4740d76d5e8a?source=collection_archive---------0-----------------------#2020-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="ce0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并使用MongoDB + GraphQL + React + Node.js栈构建全栈App</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/7abaa7b70ebfaaa71d1b1f3b533713ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L8oUFX8g5EmVpEgL"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@kaitlynbaker?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯特琳·贝克</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="4a54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将学习GraphQL的基础知识，以及为什么它会成为REST API的流行替代品。</p><p id="e709" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们将从头开始构建一个全栈应用程序，我们将使用GraphQL API存储和访问存储在<code class="fe lf lg lh li b">MongoDB</code>数据库中的数据，并在前端使用React。</p><p id="74af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，让我们从这个多部分系列的第一部分开始吧。</p><p id="1763" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">GraphQL是什么？</p><blockquote class="lj lk ll"><p id="1a1c" class="jq jr lm js b jt ju jv jw jx jy jz ka ln kc kd ke lo kg kh ki lp kk kl km kn im bi translated">GraphQL是脸书开发的一种查询语言，在这种语言中，客户端决定获取哪些数据，而REST API则由服务器决定提供哪些数据。</p></blockquote><p id="d39e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">GraphQL为什么这么受欢迎？</p><ul class=""><li id="e6b7" class="lq lr it js b jt ju jx jy kb ls kf lt kj lu kn lv lw lx ly bi translated"><strong class="js iu"> GraphQL很快:</strong> <br/>使用GraphQL的应用程序很快，因为客户端确切地决定需要什么数据。因此，从API返回的数据将只包含客户机所需的数据，而不包含额外的数据。</li><li id="764b" class="lq lr it js b jt lz jx ma kb mb kf mc kj md kn lv lw lx ly bi translated"><strong class="js iu">GraphQL API自文档化:<br/> </strong>这是graph QL如此受欢迎的主要原因之一。如果我们使用REST APIs，那么我们需要提供文档来描述提供了哪些API，它接受什么输入，它生成什么输出，等等。但是在GraphQL的情况下，不需要文档。在创建GraphQL APIs时，我们自己提供的模式描述了所有这些信息。</li><li id="62c7" class="lq lr it js b jt lz jx ma kb mb kf mc kj md kn lv lw lx ly bi translated"><strong class="js iu"> GraphQL只有一个端点:<br/> </strong>我们知道，REST API有多个端点，例如<code class="fe lf lg lh li b">/users</code>、<code class="fe lf lg lh li b">/users/user_id</code>、<code class="fe lf lg lh li b">/posts</code>、<code class="fe lf lg lh li b">/posts/post_id/comments</code>、<code class="fe lf lg lh li b">/posts/post_id/likes</code>等。<br/>所以最初我们为<code class="fe lf lg lh li b">/posts</code>端点发出一个API请求。然后，为了获得该帖子的所有<code class="fe lf lg lh li b">likes</code>和<code class="fe lf lg lh li b">comments</code>，我们需要发出类似<code class="fe lf lg lh li b">/posts/post_id/comments</code>和<code class="fe lf lg lh li b">/posts/post_id/likes</code>的额外请求。<br/>在GraphQL的情况下，有一个端点，例如<code class="fe lf lg lh li b">/graphql</code>，为了获取数据，客户端编写一个GraphQL查询，我们可以在一个查询中获取所有的<code class="fe lf lg lh li b">posts</code>、<code class="fe lf lg lh li b">likes</code>和<code class="fe lf lg lh li b">comments</code>，并且只获取那些所需的细节。不多也不少。</li></ul><blockquote class="lj lk ll"><p id="f464" class="jq jr lm js b jt ju jv jw jx jy jz ka ln kc kd ke lo kg kh ki lp kk kl km kn im bi translated">创建像GraphQL这样的工具的主要原因之一是为了限制从服务器到客户机的不必要的数据传输。</p></blockquote><p id="65e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们有一个大型应用程序，例如一个电子商务应用程序，它有桌面和移动版本，我们使用REST APIs，那么我们通常有相同的桌面和移动端点。</p><p id="3741" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设有<code class="fe lf lg lh li b">/products</code> REST API来获取所有产品信息，包括<code class="fe lf lg lh li b">ratings</code>、<code class="fe lf lg lh li b">reviews</code>、<code class="fe lf lg lh li b">product images</code>、<code class="fe lf lg lh li b">icons</code>等。</p><p id="a0d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这对于桌面网站来说没问题，但是如果我们在移动设备上访问网站，那么我们必须下载那么多不必要的数据，即使我们没有为移动设备显示相同的用户界面，这将花费你一些额外的移动数据字节。</p><p id="bcdc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在GraphQL的情况下，客户端决定请求什么数据，因此我们可以根据我们正在浏览的设备只请求需要的数据，从而节省一些额外的字节。</p><blockquote class="lj lk ll"><p id="66a7" class="jq jr lm js b jt ju jv jw jx jy jz ka ln kc kd ke lo kg kh ki lp kk kl km kn im bi translated">重要的是要知道，GraphQL只是一种规范，每种语言都有不同的实现，就像ECMAScript是一种规范一样，也有不同的实现，如Javascript、ActionScript、JScript等。</p></blockquote><p id="2605" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">介绍到这里就够了。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="5ee3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们来了解一下如何使用GraphQL。</p><p id="23f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">GraphQL提供了3个主要的东西。</p><ol class=""><li id="334f" class="lq lr it js b jt ju jx jy kb ls kf lt kj lu kn ml lw lx ly bi translated"><code class="fe lf lg lh li b">Queries:</code>它允许我们请求我们需要的数据。</li><li id="8b11" class="lq lr it js b jt lz jx ma kb mb kf mc kj md kn ml lw lx ly bi translated"><code class="fe lf lg lh li b">Mutations:</code>它允许我们对数据进行更改，如创建、更新或删除操作。</li><li id="6b4b" class="lq lr it js b jt lz jx ma kb mb kf mc kj md kn ml lw lx ly bi translated">它允许我们订阅变更，并在发生变化时得到通知。</li></ol><h2 id="9f29" class="mm mn it bd mo mp mq dn mr ms mt dp mu kb mv mw mx kf my mz na kj nb nc nd ne bi translated"><strong class="ak"> GraphQL数据类型</strong></h2><p id="dd2d" class="pw-post-body-paragraph jq jr it js b jt nf jv jw jx ng jz ka kb nh kd ke kf ni kh ki kj nj kl km kn im bi translated">GraphQL提供了以下标量数据类型</p><ol class=""><li id="2593" class="lq lr it js b jt ju jx jy kb ls kf lt kj lu kn ml lw lx ly bi translated"><code class="fe lf lg lh li b">ID:</code>它指定了唯一的标识符。它可以在ID类型下存储整数或字符串值。</li><li id="3a72" class="lq lr it js b jt lz jx ma kb mb kf mc kj md kn ml lw lx ly bi translated"><code class="fe lf lg lh li b">Int:</code>它指定了32位有符号整数值。</li><li id="6e11" class="lq lr it js b jt lz jx ma kb mb kf mc kj md kn ml lw lx ly bi translated"><code class="fe lf lg lh li b">Float:</code>指定双精度浮点数。</li><li id="8703" class="lq lr it js b jt lz jx ma kb mb kf mc kj md kn ml lw lx ly bi translated"><code class="fe lf lg lh li b">String:</code>它指定了一个UTF 8字符集的字符串。</li><li id="f737" class="lq lr it js b jt lz jx ma kb mb kf mc kj md kn ml lw lx ly bi translated"><code class="fe lf lg lh li b">Boolean:</code>指定一个布尔值<code class="fe lf lg lh li b">true</code>或<code class="fe lf lg lh li b">false</code>。</li></ol><h2 id="a31a" class="mm mn it bd mo mp mq dn mr ms mt dp mu kb mv mw mx kf my mz na kj nb nc nd ne bi translated"><strong class="ak">graph QL的本地设置</strong></h2><p id="4435" class="pw-post-body-paragraph jq jr it js b jt nf jv jw jx ng jz ka kb nh kd ke kf ni kh ki kj nj kl km kn im bi translated">我们将使用一个非常流行的GraphQL服务器<a class="ae le" href="https://github.com/prisma-labs/graphql-yoga" rel="noopener ugc nofollow" target="_blank"> graphql-yoga </a>来创建GraphQL APIs，因为它提供了一个全功能的graphql服务器，就像<code class="fe lf lg lh li b">create-react-app</code>提供了一种轻松创建React应用程序的方法。</p><p id="1b0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建一个名为<code class="fe lf lg lh li b">graphql-fullstack-app</code>的新文件夹，并在其中创建一个新文件夹<code class="fe lf lg lh li b">server</code>。</p><p id="6ab4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从命令行/终端导航到<code class="fe lf lg lh li b">server</code>文件夹，执行以下命令</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="0a67" class="mm mn it li b gy no np l nq nr">yarn init -y</span></pre><p id="3950" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将创建一个<code class="fe lf lg lh li b">package.json</code>文件。</p><p id="d017" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，从<code class="fe lf lg lh li b">server</code>文件夹中安装所需的依赖项</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="fe1b" class="mm mn it li b gy no np l nq nr">yarn add graphql-yoga nodemon uuid</span></pre><p id="8fbb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe lf lg lh li b">server</code>文件夹中创建一个名为<code class="fe lf lg lh li b">src</code>的新文件夹，并在<code class="fe lf lg lh li b">src</code>文件夹中创建一个文件<code class="fe lf lg lh li b">index.js</code>。</p><p id="3a40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe lf lg lh li b">package.json</code>文件中添加名为<code class="fe lf lg lh li b">start</code>的脚本。</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="f6c2" class="mm mn it li b gy no np l nq nr">"scripts": {<br/> "start": "nodemon src/index.js"<br/>}</span></pre><p id="1b30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您的<code class="fe lf lg lh li b">package.json</code>文件现在将看起来像这样</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ns"><img src="../Images/5d24130f54a91cc444909982e60aa3ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LECJPNO1HQFehb8-Kzsq7g.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">package.json文件</figcaption></figure><p id="dd96" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，打开<code class="fe lf lg lh li b">src/index.js</code>文件，在其中添加以下内容</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="ff98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如您在上面的代码中看到的，<code class="fe lf lg lh li b">GraphQLServer</code>构造函数将一个对象作为参数，并将<code class="fe lf lg lh li b">typeDefs</code>和<code class="fe lf lg lh li b">resolvers</code>作为该对象的属性。</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="9a9a" class="mm mn it li b gy no np l nq nr">const server = new GraphQLServer({<br/>  typeDefs,<br/>  resolvers<br/>});</span></pre><p id="36e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们使用<code class="fe lf lg lh li b">GraphQLServer</code>提供的<code class="fe lf lg lh li b">start</code>方法启动服务器</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="122e" class="mm mn it bd mo mp mq dn mr ms mt dp mu kb mv mw mx kf my mz na kj nb nc nd ne bi translated"><strong class="ak">查询</strong></h2><p id="7db0" class="pw-post-body-paragraph jq jr it js b jt nf jv jw jx ng jz ka kb nh kd ke kf ni kh ki kj nj kl km kn im bi translated"><code class="fe lf lg lh li b">typeDefs</code>定义了GraphQL的模式，该模式指定了我们提供的查询以及每个查询的返回类型。</p><p id="4b40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用反斜线<code class="fe lf lg lh li b">(``)</code>使用ES6模板文字语法来定义typeDefs模式。</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="d55e" class="mm mn it li b gy no np l nq nr">const typeDefs = `<br/>  type Query {<br/>    name: String!<br/>    age: Int!<br/>    isSingle: Boolean<br/>  }<br/>`;</span></pre><p id="c552" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们指定了3个查询<code class="fe lf lg lh li b">name</code>、<code class="fe lf lg lh li b">age</code>和<code class="fe lf lg lh li b">isSingle</code>，这些查询的返回值的数据类型在它们前面。例如</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="470d" class="mm mn it li b gy no np l nq nr">name: String!</span></pre><p id="70e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，<code class="fe lf lg lh li b">name</code>指定当我们查询<code class="fe lf lg lh li b">name</code>时返回的值是一个<code class="fe lf lg lh li b">String</code>和感叹号(！)指定它将始终是一个<code class="fe lf lg lh li b">String</code>。</p><p id="b3f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们不在数据类型后添加感叹号，比如对于<code class="fe lf lg lh li b">isSingle</code>查询</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="1be7" class="mm mn it li b gy no np l nq nr">isSingle: Boolean</span></pre><p id="0289" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么我们查询<code class="fe lf lg lh li b">isSingle</code>时返回的值可以是null。</p><p id="7bfe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以感叹号(！)指定该值将始终不可为空。</p><p id="2dcd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们添加了解析器，为这些查询提供实现</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="ba79" class="mm mn it li b gy no np l nq nr">const resolvers = {<br/>  Query: {<br/>    name() {<br/>      return 'Dan';<br/>    },<br/>    age() {<br/>      return 50;<br/>    },<br/>    isSingle() {<br/>      return null;<br/>    }<br/>  }<br/>};</span></pre><p id="9b54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以当我们查询<code class="fe lf lg lh li b">name</code>时，来自<code class="fe lf lg lh li b">resolvers</code>的<code class="fe lf lg lh li b">name</code>函数将被执行，我们将得到<code class="fe lf lg lh li b">Dan</code>作为返回值。</p><p id="a6d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们使用ES6速记语法来定义函数。因此，</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="ce06" class="mm mn it li b gy no np l nq nr">name: function() {<br/>  return 'Dan';<br/>}</span></pre><p id="182d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与相同</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="d279" class="mm mn it li b gy no np l nq nr">name() {<br/>  return 'Dan';<br/>}</span></pre><p id="07ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，从终端执行<code class="fe lf lg lh li b">yarn start</code>命令启动服务器。</p><p id="52ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦服务器启动，导航到<a class="ae le" href="http://localhost:4000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:4000/ </a>并检查应用程序</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nv"><img src="../Images/fd680cf5c70d36eba0ff6dcac40c528c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5JnMG2vxBw6X347qGI-DSA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">初始GraphQL操场屏幕</figcaption></figure><p id="0dd1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是由<code class="fe lf lg lh li b">graphql-yoga</code>提供的UI，我们可以在这里查询我们的API并查看结果。</p><p id="b9ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就像浏览器一样，我们可以为每个查询打开多个选项卡，从而简化API的管理。</p><p id="d858" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你能注意到，屏幕右侧有一个<code class="fe lf lg lh li b">DOCS</code>按钮。您可以通过单击它来展开和折叠它，以查看所有可用的GraphQL APIs。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nw"><img src="../Images/3b11ad0ef594b06b3817260cb54259b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V_AacWirpsdxTMJ0aecppA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">GraphQL模式</figcaption></figure><p id="bd46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，GraphQL APIs是自文档化的。</p><p id="2424" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们不需要编写额外的文档来描述应用程序提供了哪些API。</p><p id="e51a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们有3个查询可以访问，<code class="fe lf lg lh li b">name</code>、<code class="fe lf lg lh li b">age</code>和<code class="fe lf lg lh li b">isSingle</code>。</p><p id="6786" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了查询这些API，我们需要以如下方式编写查询</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="53d8" class="mm mn it li b gy no np l nq nr">query {<br/>  name<br/>  age<br/>  isSingle<br/>}</span></pre><p id="c57d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要的每个查询都写在一个单独的行上，没有任何逗号，在操场的左侧，当我们点击大的play按钮时，它会在右侧显示该查询的输出。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nx"><img src="../Images/2432c0c1bdee30328058612b1d379ebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EsyYvPd9h337W-BugI6a1Q.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">查询结果</figcaption></figure><p id="4be8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我们已经查询了所有的字段，但是我们只能查询那些我们想要的字段，例如<code class="fe lf lg lh li b">name</code>和<code class="fe lf lg lh li b">age</code>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ny"><img src="../Images/f82c5094cf759d089552a661cfbc243f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XAdumSsxAtwoHbd3-6xAHQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">选定的查询</figcaption></figure><p id="2502" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是使用GraphQL相对于REST API的优势，在REST API中，客户端指定需要什么数据，而不是像REST API那样由服务器发送所有数据。</p><p id="017d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们以随机用户API为例，您可以使用<a class="ae le" href="https://randomuser.me/api/?page=1&amp;results=10" rel="noopener ugc nofollow" target="_blank">这个url </a>来访问它</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nz"><img src="../Images/cb98163069dc856f8c1b8fed213f263f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XiZtmoQ6pSRqkmlwfR4QXw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">REST API示例</figcaption></figure><p id="db30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您检查上面格式化的响应，您可以看到每个对象有12个属性，即，<code class="fe lf lg lh li b">gender</code>、<code class="fe lf lg lh li b">name</code>、<code class="fe lf lg lh li b">location</code>、<code class="fe lf lg lh li b">email</code>、<code class="fe lf lg lh li b">login</code>等，有些属性有嵌套的属性，例如位置。</p><p id="e5de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，即使我们只希望每个用户的<code class="fe lf lg lh li b">name</code>和<code class="fe lf lg lh li b">email</code>显示在我们的应用程序中，我们也获得了所有的数据，这需要一些额外的字节。当我们在桌面上浏览时，这很好，但在移动设备上，如果用户在3G或较慢的连接上浏览，将需要一些时间来加载数据。</p><p id="3031" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，当使用GraphQL时，我们可以只从服务器查询姓名和电子邮件，而不是下载所有的数据，这使得应用程序很快。</p><p id="6b92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，我们只是返回了标量类型的数据。</p><p id="6ed2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看如何获得数组或对象作为查询的结果。</p><h2 id="9e2c" class="mm mn it bd mo mp mq dn mr ms mt dp mu kb mv mw mx kf my mz na kj nb nc nd ne bi translated"><strong class="ak">从查询结果返回数组</strong></h2><p id="f6c0" class="pw-post-body-paragraph jq jr it js b jt nf jv jw jx ng jz ka kb nh kd ke kf ni kh ki kj nj kl km kn im bi translated">在<code class="fe lf lg lh li b">typeDefs</code>中增加一个新的<code class="fe lf lg lh li b">numbers</code>查询，在<code class="fe lf lg lh li b">resolvers</code>中增加一个<code class="fe lf lg lh li b">numbers</code>函数</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="a546" class="mm mn it li b gy no np l nq nr">const typeDefs = `<br/>  type Query {<br/>    name: String!<br/>    age: Int!<br/>    isSingle: Boolean<br/>    <strong class="li iu">numbers: [Int!]!</strong><br/>  }<br/>`;</span><span id="48a6" class="mm mn it li b gy oa np l nq nr">const resolvers = {<br/>  Query: {<br/>    name() {<br/>      return 'Dan';<br/>    },<br/>    age() {<br/>      return 50;<br/>    },<br/>    isSingle() {<br/>      return null;<br/>    },<br/>    <strong class="li iu">numbers() {<br/>      return [10, 20, 30, 40];<br/>    }</strong><br/>  }<br/>};</span></pre><p id="5d0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您可以保存文件并查询<code class="fe lf lg lh li b">numbers</code>数组。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/376174afec9b35e79c0b841ca6fd333e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EJJHpS96pOd61PuhlzfrlA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">查询数组</figcaption></figure><p id="b5d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您也可以通过按键盘上的<code class="fe lf lg lh li b">Control + Space</code>或<code class="fe lf lg lh li b">Command + Space (Mac)</code>键来查看所有可用的查询。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oc"><img src="../Images/0f8d7e51eaad91dd2b897dc4598ea695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QNCk2XRXvCKlQY14kuDa1w.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">GraphQL游戏中的自动建议</figcaption></figure><p id="c521" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们使用指定数字数组只包含整数值</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="cf5a" class="mm mn it li b gy no np l nq nr">numbers: [Int!]!</span></pre><p id="df29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">括号内的感叹号指定如果数组中有元素，数组将始终是类型<code class="fe lf lg lh li b">Int</code>，但数组也可以是空的，外部的感叹号指定查询<code class="fe lf lg lh li b">numbers</code>的结果将始终返回不可为null的值，因此我们不能从<code class="fe lf lg lh li b">numbers</code>函数返回null。像这样返回一个空数组<code class="fe lf lg lh li b">[]</code>也是有效的</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="aa13" class="mm mn it li b gy no np l nq nr">numbers() {<br/> return [];<br/>}</span></pre><p id="1488" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是如果数组中有元素，它必须是类型<code class="fe lf lg lh li b">Int</code>。</p><p id="2d57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们试图从函数<code class="fe lf lg lh li b">resolver</code>的数组中返回字符串，就像这样</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="f2dd" class="mm mn it li b gy no np l nq nr">numbers() {<br/>  return ["a", "b", "c", "d"];<br/>}</span></pre><p id="5b45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么当我们访问查询时，我们将得到一个错误</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nx"><img src="../Images/c6ac432eddeb46e7a70deee3eedf126b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VaMnaPT4llQVOh2sRfrUZA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">架构错误</figcaption></figure><h2 id="db2c" class="mm mn it bd mo mp mq dn mr ms mt dp mu kb mv mw mx kf my mz na kj nb nc nd ne bi translated">从查询结果中返回对象</h2><p id="6bc3" class="pw-post-body-paragraph jq jr it js b jt nf jv jw jx ng jz ka kb nh kd ke kf ni kh ki kj nj kl km kn im bi translated">我们也可以从解析器返回一个对象，但是GraphQL中没有对象类型来指定<code class="fe lf lg lh li b">typeDefs</code>中的返回类型。因此，我们需要创建一个自定义类型，并指定其中每个字段的属性。</p><p id="81a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe lf lg lh li b">typeDefs</code>中添加一个新的<code class="fe lf lg lh li b">location</code>对象进行查询，在<code class="fe lf lg lh li b">resolvers</code>中添加一个函数</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="fb48" class="mm mn it li b gy no np l nq nr">const typeDefs = `<br/>  type Query {<br/>    name: String!<br/>    age: Int!<br/>    isSingle: Boolean<br/>    numbers: [Int!]!<br/>    <strong class="li iu">location: Location</strong><br/>  }</span><span id="0baa" class="mm mn it li b gy oa np l nq nr">  <strong class="li iu">type Location {<br/>    state: String!<br/>    city: String!<br/>  }</strong><br/>`;</span><span id="12b9" class="mm mn it li b gy oa np l nq nr">const resolvers = {<br/>  Query: {<br/>    name() {<br/>      return 'Dan';<br/>    },<br/>    age() {<br/>      return 50;<br/>    },<br/>    isSingle() {<br/>      return null;<br/>    },<br/>    numbers() {<br/>      return [10, 20, 30, 40];<br/>    },<br/>    <strong class="li iu">location() {<br/>      return {<br/>        state: 'New York',<br/>        city: 'Albany'<br/>      };<br/>    }</strong><br/>  }<br/>};</span></pre><p id="ff17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe lf lg lh li b">typeDefs</code>中，我们已经将位置查询的返回类型指定为<code class="fe lf lg lh li b">Location</code>，然后在一个单独的类型中定义它将包含的内容</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="127c" class="mm mn it li b gy no np l nq nr">type Location {<br/>  state: String!<br/>  city: String!<br/>}</span></pre><p id="7df5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，保存文件并查询位置。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi od"><img src="../Images/12377de3098ace4614cc92a34db83a1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jneODTy5D3VqhZeqFuqyAw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">查询对象</figcaption></figure><p id="0b3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您将得到一个错误，因为我们不能从该位置获取所有数据，因为这将违背使用GraphQL的目的，在graph QL中，客户端指定需要什么数据，而不是服务器返回所有数据。</p><p id="4f00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，为了让它工作，我们需要从位置对象中指定我们想要的属性，它将按预期工作。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oe"><img src="../Images/32b1295b9c404750dedd5b6cd2dce06b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PTiEI4WADQNnSnCnYxp6Bw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">对象的查询响应</figcaption></figure><h2 id="1a21" class="mm mn it bd mo mp mq dn mr ms mt dp mu kb mv mw mx kf my mz na kj nb nc nd ne bi translated"><strong class="ak">从查询结果中返回对象数组</strong></h2><p id="6fcf" class="pw-post-body-paragraph jq jr it js b jt nf jv jw jx ng jz ka kb nh kd ke kf ni kh ki kj nj kl km kn im bi translated">正如我们可以从查询中获得数组和对象一样，我们也可以从查询中获得对象的数组。</p><p id="4205" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，让我们创建一个由<code class="fe lf lg lh li b">user</code>对象组成的数组，我们将从<code class="fe lf lg lh li b">resolver</code>函数中返回它。</p><p id="ef3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在文件顶部声明一个<code class="fe lf lg lh li b">users</code>数组</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="55db" class="mm mn it li b gy no np l nq nr">const users = [<br/>  {<br/>    name: 'John',<br/>    age: 30,<br/>    location: {<br/>      state: 'New York',<br/>      city: 'Albany'<br/>    }<br/>  },<br/>  {<br/>    name: 'Mike',<br/>    age: 35,<br/>    location: {<br/>      state: 'North Karelia',<br/>      city: 'Ylitornio'<br/>    }<br/>  },<br/>  {<br/>    name: 'Jessica',<br/>    age: 25,<br/>    location: {<br/>      state: 'Roraima',<br/>      city: 'Formosa'<br/>    }<br/>  }<br/>];</span></pre><p id="8ec4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">给它加上<code class="fe lf lg lh li b">typeDefs</code>和<code class="fe lf lg lh li b">resolvers</code>。</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="064f" class="mm mn it li b gy no np l nq nr">const typeDefs = `<br/>  type Query {<br/>    name: String!<br/>    age: Int!<br/>    isSingle: Boolean<br/>    numbers: [Int!]!<br/>    location: Location<br/>    <strong class="li iu">users: [User!]!</strong><br/>  }</span><span id="c9c8" class="mm mn it li b gy oa np l nq nr">  type Location {<br/>    state: String!<br/>    city: String!<br/>  }</span><span id="5f99" class="mm mn it li b gy oa np l nq nr">  <strong class="li iu">type User {<br/>    name: String!<br/>    age: Int!<br/>    location: Location<br/>  }</strong><br/>`;</span><span id="5d40" class="mm mn it li b gy oa np l nq nr">const resolvers = {<br/>  Query: {<br/>    name() {<br/>      return 'Dan';<br/>    },<br/>    age() {<br/>      return 50;<br/>    },<br/>    isSingle() {<br/>      return null;<br/>    },<br/>    numbers() {<br/>      return [10, 20, 30, 40];<br/>    },<br/>    location() {<br/>      return {<br/>        state: 'New York',<br/>        city: 'Albany'<br/>      };<br/>    },<br/>    <strong class="li iu">users() {<br/>      return users;<br/>    }</strong><br/>  }<br/>};</span></pre><p id="eea9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，保存文件并检查应用程序。</p><p id="e33a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae le" href="http://localhost:4000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:4000/ </a>访问应用程序，让我们点击浏览器中的<strong class="js iu"> + </strong>图标，在一个新的选项卡中尝试这个查询。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi of"><img src="../Images/c76027d4544751d312b59221b567540d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_6Bbvc4mhvHBuo5QMQl4PA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">查询用户数组</figcaption></figure><p id="066a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，我们只从<code class="fe lf lg lh li b">users</code>数组中请求了<code class="fe lf lg lh li b">id</code>、<code class="fe lf lg lh li b">name</code>和<code class="fe lf lg lh li b">location</code>属性，并且只从<code class="fe lf lg lh li b">location</code>对象中请求了<code class="fe lf lg lh li b">state</code>属性。</p><p id="681a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，我们也可以从<code class="fe lf lg lh li b">users</code>数组的对象中访问所有属性。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/4d439f5f072af4cb0e753c3aa972bb0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xj4sMyIoGrcJ1O1YwiTCLw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">查询用户的所有详细信息</figcaption></figure><p id="3b40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们也可以选择跳过<code class="fe lf lg lh li b">location</code>，只访问用户的<code class="fe lf lg lh li b">id</code>、<code class="fe lf lg lh li b">name</code>和<code class="fe lf lg lh li b">age</code></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/e98a466a0fc7c18c03a09c4c60376e85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lif0YBaUiqDsgnLW69IipA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">查询用户的选定详细信息</figcaption></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="3d4d" class="mm mn it bd mo mp mq dn mr ms mt dp mu kb mv mw mx kf my mz na kj nb nc nd ne bi translated"><strong class="ak">突变</strong></h2><p id="6b9a" class="pw-post-body-paragraph jq jr it js b jt nf jv jw jx ng jz ka kb nh kd ke kf ni kh ki kj nj kl km kn im bi translated">我们现在已经看到了如何使用GraphQL查询来查询数据。</p><p id="629b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看如何使用GraphQL <code class="fe lf lg lh li b">Mutation</code>来修改数据。</p><p id="b465" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe lf lg lh li b">typeDefs</code>中添加一个新的<code class="fe lf lg lh li b">Mutation</code>类型</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="91dd" class="mm mn it li b gy no np l nq nr">type Mutation {<br/>  addUser(name: String!, age: Int!): [User!]!<br/>}</span></pre><p id="839b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们添加了<code class="fe lf lg lh li b">addUser</code>突变，它将接受来自用户的名称和<code class="fe lf lg lh li b">age</code>，并返回一个添加了用户的数组。</p><p id="f6d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，我们没有为<code class="fe lf lg lh li b">addUser</code>突变添加<code class="fe lf lg lh li b">location</code>参数，因为它在User的类型定义中被声明为可选的(可空的)(因为末尾没有感叹号)</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="8ea9" class="mm mn it li b gy no np l nq nr">type User {<br/>  id: ID!<br/>  name: String!<br/>  age: Int!<br/>  location: Location<br/>}</span></pre><p id="9fb5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，在向<code class="fe lf lg lh li b">users</code>数组添加新用户时，我们只需要<code class="fe lf lg lh li b">id</code>、<code class="fe lf lg lh li b">name</code>和<code class="fe lf lg lh li b">age</code>。</p><blockquote class="lj lk ll"><p id="a089" class="jq jr lm js b jt ju jv jw jx jy jz ka ln kc kd ke lo kg kh ki lp kk kl km kn im bi translated">传递给<code class="fe lf lg lh li b">addUser</code>突变的参数在GraphQL中通常被称为“操作参数”</p></blockquote><p id="6dd0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了定义<code class="fe lf lg lh li b">addUser</code>变异的解析器，我们需要像这样在<code class="fe lf lg lh li b">Query</code>属性旁边添加新的<code class="fe lf lg lh li b">Mutation</code>属性</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="4bb1" class="mm mn it li b gy no np l nq nr">const resolvers = {<br/>  Query: {<br/>    ...<br/>  },<br/>  Mutation: {<br/>    ...<br/>  }<br/>};</span></pre><p id="e856" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以用<code class="fe lf lg lh li b">addUser</code>突变添加一个新的突变属性</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="8666" class="mm mn it li b gy no np l nq nr">const resolvers = {<br/>  Query: {<br/>    name() {<br/>      return 'Dan';<br/>    },<br/>    age() {<br/>      return 50;<br/>    },<br/>    isSingle() {<br/>      return null;<br/>    },<br/>    numbers() {<br/>      return [10, 20, 30, 40];<br/>    },<br/>    location() {<br/>      return {<br/>        state: 'New York',<br/>        city: 'Albany'<br/>      };<br/>    },<br/>    users() {<br/>      return users;<br/>    }<br/>  },<br/>  <strong class="li iu">Mutation: {<br/>    addUser(parent, args, ctx, info) {}<br/>  }</strong><br/>};</span></pre><p id="8273" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lf lg lh li b">addUser</code>变异接收4个自变量，即<code class="fe lf lg lh li b">parent</code>、<code class="fe lf lg lh li b">args</code>(T8的简称)、<code class="fe lf lg lh li b">ctx</code>(T10的简称)和<code class="fe lf lg lh li b">info</code>。</p><p id="9ed5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我们传递的输入值在<code class="fe lf lg lh li b">args</code>对象下可用，每个参数在一个单独的属性上，例如在我们的例子中是<code class="fe lf lg lh li b">args = { name: some_value, age: some_value }</code>。</p><p id="595d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们添加代码，将用户添加到<code class="fe lf lg lh li b">addUsers</code>变异中的<code class="fe lf lg lh li b">users</code>列表。</p><p id="24e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是首先，在文件的顶部添加对<code class="fe lf lg lh li b">uuid</code>库的导入，这将允许我们为每个用户生成唯一的id。</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="55bf" class="mm mn it li b gy no np l nq nr">const { v4: uuidv4 } = require('uuid');</span></pre><p id="d625" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，添加<code class="fe lf lg lh li b">addUser</code>突变代码</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="bfa1" class="mm mn it li b gy no np l nq nr">Mutation: {<br/>  addUser(parent, args, ctx, info) {<br/>    const { name, age } = args;</span><span id="3959" class="mm mn it li b gy oa np l nq nr">    users.push({<br/>      id: uuidv4(),<br/>      name,<br/>      age<br/>    });</span><span id="7db9" class="mm mn it li b gy oa np l nq nr">    return users;<br/>  }<br/>}</span></pre><p id="2900" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行<code class="fe lf lg lh li b">yarn start</code>命令重启应用程序，并检查应用程序。</p><p id="f46b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在传递参数时，我们需要按照<code class="fe lf lg lh li b">typeDefs</code>中指定的顺序和格式传递。</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="04bf" class="mm mn it li b gy no np l nq nr">type Mutation {<br/>  addUser(name: String!, age: Int!): [User!]!<br/>}</span></pre><p id="3add" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">突变添加新用户:</strong></p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="e899" class="mm mn it li b gy no np l nq nr">mutation {<br/>  addUser(name: "James", age: 24) {<br/>    name<br/>    age<br/>  }<br/>}</span></pre><p id="11a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建一个新的选项卡，使用<code class="fe lf lg lh li b">mutation</code>添加新用户，而不是使用<code class="fe lf lg lh li b">query</code></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oh"><img src="../Images/1627283daccacf2fdc75f88357d607f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JvnIa1fVnaYgRW4FxWTkfA.gif"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">添加用户突变</figcaption></figure><p id="b777" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，我们已经将<code class="fe lf lg lh li b">name</code>和<code class="fe lf lg lh li b">age</code>参数指定为不可空，所以我们必须提供这两个参数。</p><p id="b686" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们只指定其中一个或者不指定任何一个，那么我们将得到一个错误</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nx"><img src="../Images/09028f5019dd9feac6c147d480e4e39a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*papgM5QaW6EPiq2qyW9ndw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">缺少参数错误</figcaption></figure><blockquote class="lj lk ll"><p id="9a89" class="jq jr lm js b jt ju jv jw jx jy jz ka ln kc kd ke lo kg kh ki lp kk kl km kn im bi translated">这就是GraphQL的美妙之处。因为<code class="fe lf lg lh li b">name</code>和<code class="fe lf lg lh li b">age</code>参数都在<code class="fe lf lg lh li b">typeDefs</code>中声明为不可空，如果参数中有任何不匹配，GraphQL将在自身之前抛出一个错误，而不执行我们的变异代码，因此我们不需要在<code class="fe lf lg lh li b">addUser </code>变异中添加额外的检查来检查用户是否提供了输入值。</p></blockquote><p id="754b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们添加更多的突变来更新用户和删除用户</p><p id="a465" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将<code class="fe lf lg lh li b">updateUser</code>突变添加到<code class="fe lf lg lh li b">typeDefs</code></p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="4a7e" class="mm mn it li b gy no np l nq nr">type Mutation {<br/>  addUser(name: String!, age: Int!): [User!]!<br/>  <strong class="li iu">updateUser(id: ID!, name: String, age: Int): User!</strong><br/>}</span></pre><p id="83df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们将传递<code class="fe lf lg lh li b">id</code>、<code class="fe lf lg lh li b">name</code>和<code class="fe lf lg lh li b">age</code>作为操作参数，如果有一个用户具有匹配的id，那么我们将更新用户的<code class="fe lf lg lh li b">name</code>和<code class="fe lf lg lh li b">age</code>。</p><p id="10b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，这里只有id是必需的参数，用户可以只传递姓名或年龄进行更新。所以<code class="fe lf lg lh li b">name</code>和<code class="fe lf lg lh li b">age</code>论证之后就没有<code class="fe lf lg lh li b">!</code>了。</p><p id="a303" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe lf lg lh li b">addUser</code>突变旁边的解析器中添加一个新的<code class="fe lf lg lh li b">updateUser</code>突变。</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="8d89" class="mm mn it li b gy no np l nq nr">Mutation: {<br/>  addUser(parent, args, ctx, info) {<br/>    const { name, age } = args;</span><span id="22e6" class="mm mn it li b gy oa np l nq nr">    users.push({<br/>      id: uuidv4(),<br/>      name,<br/>      age<br/>    });</span><span id="f611" class="mm mn it li b gy oa np l nq nr">    return users;<br/>  },<br/>  <strong class="li iu">updateUser(parent, args, ctx, info) {<br/>    const { id, name, age } = args;<br/>    const user = users.find((user) =&gt; user.id === id);</strong></span><span id="1742" class="mm mn it li b gy oa np l nq nr"><strong class="li iu">    if (!user) {<br/>      throw new Error(`user with id ${id} does not exist.`);<br/>    }</strong></span><span id="d03e" class="mm mn it li b gy oa np l nq nr"><strong class="li iu">    if (name) {<br/>      user.name = name;<br/>    }</strong></span><span id="d849" class="mm mn it li b gy oa np l nq nr"><strong class="li iu">    if (age) {<br/>      user.age = age;<br/>    }</strong></span><span id="6c3f" class="mm mn it li b gy oa np l nq nr"><strong class="li iu">    return user;<br/>  }</strong><br/>}</span></pre><p id="90b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe lf lg lh li b">updateUser</code> resolver函数中，我们首先使用数组<code class="fe lf lg lh li b">find</code>方法检查具有所提供id的用户是否存在。如果没有这样的用户，那么我们将抛出一个错误。</p><p id="5c1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们找到提供了<code class="fe lf lg lh li b">id</code>的用户，那么我们将更新<code class="fe lf lg lh li b">name</code>和<code class="fe lf lg lh li b">age</code>并返回更新后的用户。</p><p id="5735" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们通过提供一个无效的id来检查应用程序。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oi"><img src="../Images/616b683762c258be333fbb252be77419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VKh7A7DAmrl7N0sRcjegOw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">更新用户突变错误</figcaption></figure><p id="bb79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，我们得到一个错误，因为在id为<code class="fe lf lg lh li b">134</code>的<code class="fe lf lg lh li b">users</code>数组中没有用户。</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="bbc4" class="mm mn it li b gy no np l nq nr">mutation {<br/>  updateUser(id: "134", name: "Johny", age: 31) {<br/>    id<br/>    name<br/>    age<br/>  }<br/>}</span></pre><p id="7134" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦我们传递了出现在<code class="fe lf lg lh li b">users</code>数组中的正确id，那么用户就被更新了，我们正在获取更新后的用户详细信息。</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="24a9" class="mm mn it li b gy no np l nq nr">mutation {<br/>  updateUser(id: "1", name: "Johny", age: 31) {<br/>    id<br/>    name<br/>    age<br/>  }<br/>}</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/b1be0d48ac9ca742dd14c01e2290120f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LZrXed7QRINH9p4u0kr0Zg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">更新用户成功</figcaption></figure><p id="7131" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您还可以验证<code class="fe lf lg lh li b">users</code>数组在成功更新后是否也被更新。</p><p id="3ad2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于<code class="fe lf lg lh li b">name</code>和<code class="fe lf lg lh li b">age</code>是可选参数，我们可以跳过其中任何一个。这就是为什么我们在<code class="fe lf lg lh li b">name</code>和<code class="fe lf lg lh li b">age</code>的<code class="fe lf lg lh li b">updateUser</code>解析器函数中添加了if条件。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi of"><img src="../Images/af83c6449fc5cd3e77ce764c78333419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FrFCecICIiwuTUCFYZOkow.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">跳过更新可选年龄</figcaption></figure><p id="d2c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如你所见，我们现在没有超过<code class="fe lf lg lh li b">age</code>，所以只有<code class="fe lf lg lh li b">name</code>被更新，而<code class="fe lf lg lh li b">age</code>仍然是30。</p><p id="724e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们添加删除用户的突变</p><p id="480a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将<code class="fe lf lg lh li b">deleteUser</code>突变添加到<code class="fe lf lg lh li b">typeDefs</code></p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="ed82" class="mm mn it li b gy no np l nq nr">type Mutation {<br/>  addUser(name: String!, age: Int!): [User!]!<br/>  updateUser(id: ID!, name: String, age: Int): User!<br/>  <strong class="li iu">deleteUser(id: ID!): User!</strong><br/>}</span></pre><p id="7b64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们将<code class="fe lf lg lh li b">id</code>作为操作参数传递，这是一个强制字段，如果有一个用户具有匹配的<code class="fe lf lg lh li b">id</code>，那么我们将删除该用户并返回已删除的用户。</p><p id="d2fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在解析器中添加一个新的<code class="fe lf lg lh li b">deleteUser</code>变异功能</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="ffbc" class="mm mn it li b gy no np l nq nr">Mutation: {<br/>  addUser(parent, args, ctx, info) {<br/>    // add user code<br/>  },<br/>  updateUser(parent, args, ctx, info) {<br/>    // update user code<br/>  },<br/>  <strong class="li iu">deleteUser(parent, args, ctx, info) {<br/>    const index = users.findIndex((user) =&gt; user.id === args.id);<br/>    if (index === -1) {<br/>      throw new Error(`User with id ${args.id} does not exist.`);<br/>    }</strong></span><span id="5776" class="mm mn it li b gy oa np l nq nr"><strong class="li iu">    const deletedUser = users.splice(index, 1);<br/>    return deletedUser[0];<br/>  }</strong><br/>}</span></pre><p id="8fcd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe lf lg lh li b">deleteUser</code>突变中，我们首先检查具有所提供的<code class="fe lf lg lh li b">id</code>的用户是否存在，然后使用数组<code class="fe lf lg lh li b">splice</code>方法删除该用户。</p><p id="9e00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">数组拼接方法接受3个参数。</p><ul class=""><li id="bc8f" class="lq lr it js b jt ju jx jy kb ls kf lt kj lu kn lv lw lx ly bi translated">从何处删除元素的索引</li><li id="b5d5" class="lq lr it js b jt lz jx ma kb mb kf mc kj md kn lv lw lx ly bi translated">要删除的元素数量</li><li id="cbac" class="lq lr it js b jt lz jx ma kb mb kf mc kj md kn lv lw lx ly bi translated">要添加到已删除元素位置的元素</li></ul><p id="4cc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们没有添加新元素，所以我们只提供了两个参数。</p><p id="afbe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在对象数组上使用splice方法时，将返回包含已删除用户对象的数组。所以我们使用<code class="fe lf lg lh li b">deletedUser[0]</code>来返回被删除的用户。</p><p id="1b50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们可以检查应用程序并验证用户是否被删除。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oh"><img src="../Images/5c1467b7b87481e873924dc6a2efe954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*MoJRF4qbCbJpwmtGGSnSHA.gif"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">删除用户突变</figcaption></figure><p id="ec95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，我们删除了id为<code class="fe lf lg lh li b">2</code>的用户，并恢复了被删除的用户，我们通过检查<code class="fe lf lg lh li b">users</code>查询的结果确认了该用户确实被删除了。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="d115" class="mm mn it bd mo mp mq dn mr ms mt dp mu kb mv mw mx kf my mz na kj nb nc nd ne bi translated"><strong class="ak">订阅量</strong></h2><p id="1686" class="pw-post-body-paragraph jq jr it js b jt nf jv jw jx ng jz ka kb nh kd ke kf ni kh ki kj nj kl km kn im bi translated">现在，我们已经完成了GraphQL的<code class="fe lf lg lh li b">Query</code>和<code class="fe lf lg lh li b">Mutation</code>功能。</p><p id="f20a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们来了解一下GraphQL中的<code class="fe lf lg lh li b">Subscriptions</code>有哪些。</p><blockquote class="lj lk ll"><p id="91f2" class="jq jr lm js b jt ju jv jw jx jy jz ka ln kc kd ke lo kg kh ki lp kk kl km kn im bi translated">订阅允许我们订阅更改，并在更改发生时得到通知。</p></blockquote><p id="b8af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，当有人在你的文章中添加评论或者当你的朋友在他的社交媒体账户上分享一些帖子时，你会收到通知。</p><p id="ac72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">GraphQL <code class="fe lf lg lh li b">Subscriptions</code>在后台使用WebSockets来通知什么时候发生了变化。</p><p id="5122" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们通过一个例子来了解一下。</p><p id="2532" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设，我们想在用户使用<code class="fe lf lg lh li b">updateUser</code>变异更新他的信息时得到通知。</p><p id="d3fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，首先，我们需要在<code class="fe lf lg lh li b">typeDefs</code>中添加<code class="fe lf lg lh li b">Subscription</code>类型以及<code class="fe lf lg lh li b">Query</code>和<code class="fe lf lg lh li b">Mutation</code></p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="1c3c" class="mm mn it li b gy no np l nq nr">const typeDefs = `<br/> type Query {<br/>  // type definitions<br/> }</span><span id="74b6" class="mm mn it li b gy oa np l nq nr"> type Mutation {<br/>  // type definitions<br/> }</span><span id="a8ea" class="mm mn it li b gy oa np l nq nr"> <strong class="li iu">type Subscription {<br/>  update: User!<br/> }</strong><br/>`;</span></pre><p id="5591" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们已经定义了一个<code class="fe lf lg lh li b">update</code>订阅，当更新发生时，我们将取回更新后的用户。</p><p id="05c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在解析器中添加一个新的<code class="fe lf lg lh li b">Subscription</code>对象</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="255a" class="mm mn it li b gy no np l nq nr">const resolvers = {<br/>  Query: {<br/>    // resolver functions for Query<br/>  },<br/>  Mutation: {<br/>    // resolver functions for Mutation<br/>  },<br/>  <strong class="li iu">Subscription: {<br/>    update: { // this name('update') has to match with subscription added in typeDef      <br/>      subscribe(parent, args, ctx, info) {}<br/>    }<br/>  }</strong><br/>};</span></pre><p id="865c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，在<code class="fe lf lg lh li b">Subscription</code>的情况下，我们不直接获取<code class="fe lf lg lh li b">update</code>的操作参数，但是我们需要定义<code class="fe lf lg lh li b">subscribe</code>方法来接收操作参数。</p><p id="f162" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，为了订阅和发布更新，我们需要从<code class="fe lf lg lh li b">graphql-yoga</code>库中导入<code class="fe lf lg lh li b">PubSub</code>。</p><p id="305d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以从<code class="fe lf lg lh li b">graphql-yoga</code>中抓取<code class="fe lf lg lh li b">PubSub</code>，并在<code class="fe lf lg lh li b">index.js</code>文件的开头创建它的一个实例。</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="1465" class="mm mn it li b gy no np l nq nr">const { GraphQLServer, PubSub } = require('graphql-yoga');</span><span id="01d5" class="mm mn it li b gy oa np l nq nr">const pubsub = new PubSub();</span></pre><p id="a7c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后调用<code class="fe lf lg lh li b">subscribe</code>函数中的<code class="fe lf lg lh li b">asyncIterator</code>函数，传递一些唯一的名字，我们可以用这个名字在以后发布修改。</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="a7b9" class="mm mn it li b gy no np l nq nr">return pubsub.asyncIterator('update_user');</span></pre><p id="b476" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您的订阅现在将看起来像这样</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="15b4" class="mm mn it li b gy no np l nq nr">Subscription: {<br/>  update: {<br/>    subscribe(parent, args, ctx, info) {<br/>      return pubsub.asyncIterator('update_user');<br/>    }<br/>  }<br/>}</span></pre><p id="26ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以现在，我们创造了一个可以观看的<code class="fe lf lg lh li b">Subscription</code>。</p><p id="70f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们在更新用户时发布更改</p><p id="39c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe lf lg lh li b">updateUser</code>变异函数内部，在返回用户之前，调用<code class="fe lf lg lh li b">pubsub.publish</code>方法。</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="0f0a" class="mm mn it li b gy no np l nq nr">pubsub.publish('update_user', {<br/>  user<br/>});</span></pre><p id="3c54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你的<code class="fe lf lg lh li b">updateUser</code>变异现在会是这个样子</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="c27e" class="mm mn it li b gy no np l nq nr">updateUser(parent, args, ctx, info) {<br/>  const { id, name, age } = args;</span><span id="8415" class="mm mn it li b gy oa np l nq nr">  const user = users.find((user) =&gt; user.id === id);</span><span id="f4d6" class="mm mn it li b gy oa np l nq nr">  if (!user) {<br/>    throw new Error(`user with id ${id} does not exist.`);<br/>  }</span><span id="64c4" class="mm mn it li b gy oa np l nq nr">  if (name) {<br/>    user.name = name;<br/>  }</span><span id="fad2" class="mm mn it li b gy oa np l nq nr">  if (age) {<br/>    user.age = age;<br/>  }</span><span id="5d8a" class="mm mn it li b gy oa np l nq nr">  <strong class="li iu">pubsub.publish('update_user', {<br/>    update: user<br/>  });</strong></span><span id="9e17" class="mm mn it li b gy oa np l nq nr">  return user;<br/>}</span></pre><p id="ccdd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们使用了创建<code class="fe lf lg lh li b">Subscription</code>时使用的相同名称(<code class="fe lf lg lh li b">'update_user'</code>)，并作为第一个参数传递，要发布的数据作为第二个参数作为对象传递。</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="c061" class="mm mn it li b gy no np l nq nr">pubsub.publish('update_user', {<br/>  update: user <br/>  // update here is the subscription name we defined in <!-- -->typeDefs<br/>});</span></pre><p id="a4c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们先在一个选项卡中添加<code class="fe lf lg lh li b">Subscription</code>来测试一下</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="8396" class="mm mn it li b gy no np l nq nr">subscription {<br/>  update {<br/>    id<br/>    name<br/>    age<br/>  }<br/>}</span></pre><p id="5785" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后在<code class="fe lf lg lh li b">Subscription</code>选项卡中更新任何用户以获得更新的用户数据。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oh"><img src="../Images/82a727eb008d18ab17e20bb0de0c437d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iPAorZLtl6aIs7a2X_hGJA.gif"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">GraphQL订阅演示</figcaption></figure><p id="5de2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，我们最初添加了一个<code class="fe lf lg lh li b">Subscription</code>，它将持续监听变化。</p><p id="dbc1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们更新了用户，一旦用户更新了，我们就会在<code class="fe lf lg lh li b">Subscription</code>选项卡中获得更新的用户信息。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="8661" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，你已经掌握了Graphql的基础知识<code class="fe lf lg lh li b">Queries</code>、<code class="fe lf lg lh li b">Mutations</code>和<code class="fe lf lg lh li b">Subscriptions</code>，它们是GraphQL中的主要内容。</p><p id="3b02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您检查<code class="fe lf lg lh li b">src/index.js</code>文件，您会注意到该文件越来越大，随着我们向其中添加更多数据，它将变得难以管理。</p><p id="1cef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，在使用GraphQL时，通常的做法是将所有相关的内容分离到单独的文件中，而不是将所有内容添加到一个文件中。</p><p id="eaeb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">学习时将代码放在一个文件中是很好的，但是在实际项目中，所有相关的数据都被分离到自己的文件中。</p><p id="a408" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们重构<code class="fe lf lg lh li b">index.js</code>。</p><p id="2bd7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe lf lg lh li b">src</code>文件夹中创建一个新文件<code class="fe lf lg lh li b">schema.graphql</code>，并将typeDefs的内容移入其中。</p><blockquote class="lj lk ll"><p id="9fba" class="jq jr lm js b jt ju jv jw jx jy jz ka ln kc kd ke lo kg kh ki lp kk kl km kn im bi translated">对于GraphQL文件，我们可以使用<strong class="js iu">。图表ql </strong>或<strong class="js iu">。gql </strong>分机可<strong class="js iu">。graphql </strong>扩展是使用最广泛的，所以我们将坚持使用它。</p></blockquote><p id="393f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你的<code class="fe lf lg lh li b">schema.graphql</code>文件现在看起来会像这样</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="6435" class="mm mn it li b gy no np l nq nr">type Query {<br/>  name: String!<br/>  age: Int!<br/>  isSingle: Boolean<br/>  numbers: [Int!]!<br/>  location: Location<br/>  users: [User!]!<br/>}</span><span id="3eef" class="mm mn it li b gy oa np l nq nr">type Mutation {<br/>  addUser(name: String!, age: Int!): [User!]!<br/>  updateUser(id: ID!, name: String, age: Int): User!<br/>  deleteUser(id: ID!): User!<br/>}</span><span id="99c3" class="mm mn it li b gy oa np l nq nr">type Subscription {<br/>  update: User!<br/>}</span><span id="4c8e" class="mm mn it li b gy oa np l nq nr">type Location {<br/>  state: String!<br/>  city: String!<br/>}</span><span id="9914" class="mm mn it li b gy oa np l nq nr">type User {<br/>  id: ID!<br/>  name: String!<br/>  age: Int!<br/>  location: Location<br/>}</span></pre><p id="e043" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe lf lg lh li b">src</code>文件夹中创建一个新文件夹<code class="fe lf lg lh li b">resolvers</code>，并在其中添加一个新文件<code class="fe lf lg lh li b">Query.js</code>。</p><p id="d1ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建一个<code class="fe lf lg lh li b">Query</code>变量，将<code class="fe lf lg lh li b">Query</code>解析器的内容赋给它，并从文件中导出。</p><p id="a332" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您的<code class="fe lf lg lh li b">Query.js</code>文件现在将看起来像这样</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="d60b" class="mm mn it li b gy no np l nq nr">const Query = {<br/>  name() {<br/>    return 'Dan';<br/>  },<br/>  age() {<br/>    return 50;<br/>  },<br/>  isSingle() {<br/>    return null;<br/>  },<br/>  numbers() {<br/>    return [10, 20, 30, 40];<br/>  },<br/>  location() {<br/>    return {<br/>      state: 'New York',<br/>      city: 'Albany'<br/>    };<br/>  },<br/>  users() {<br/>    return users;<br/>  }<br/>};</span><span id="01c0" class="mm mn it li b gy oa np l nq nr">module.exports = Query;</span></pre><p id="132b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe lf lg lh li b">resolvers</code>文件夹中创建一个新文件<code class="fe lf lg lh li b">Mutation.js</code>。</p><p id="5b4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建一个<code class="fe lf lg lh li b">Mutation</code>变量，将<code class="fe lf lg lh li b">Mutation</code>解析器的内容赋给它，并从文件中导出。</p><p id="e1eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外，在文件的顶部添加对<code class="fe lf lg lh li b">uuid</code>的导入。</p><p id="8b0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您的<code class="fe lf lg lh li b">Mutation.js</code>文件现在将看起来像这样。</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="e30d" class="mm mn it li b gy no np l nq nr">const { v4: uuidv4 } = require('uuid');</span><span id="457d" class="mm mn it li b gy oa np l nq nr">const Mutation = {<br/>  addUser(parent, args, ctx, info) {<br/>    const { name, age } = args;</span><span id="f747" class="mm mn it li b gy oa np l nq nr">    users.push({<br/>      id: uuidv4(),<br/>      name,<br/>      age<br/>    });</span><span id="5ece" class="mm mn it li b gy oa np l nq nr">    return users;<br/>  },<br/>  updateUser(parent, args, ctx, info) {<br/>    const { id, name, age } = args;</span><span id="d0d0" class="mm mn it li b gy oa np l nq nr">    const user = users.find((user) =&gt; user.id === id);</span><span id="c6d6" class="mm mn it li b gy oa np l nq nr">    if (!user) {<br/>      throw new Error(`user with id ${id} does not exist.`);<br/>    }</span><span id="514e" class="mm mn it li b gy oa np l nq nr">    if (name) {<br/>      user.name = name;<br/>    }</span><span id="3cb9" class="mm mn it li b gy oa np l nq nr">    if (age) {<br/>      user.age = age;<br/>    }</span><span id="ca54" class="mm mn it li b gy oa np l nq nr">    pubsub.publish('update_user', {<br/>      update: user<br/>    });</span><span id="b12b" class="mm mn it li b gy oa np l nq nr">    return user;<br/>  },<br/>  deleteUser(parent, args, ctx, info) {<br/>    const index = users.findIndex((user) =&gt; user.id === args.id);<br/>    if (index === -1) {<br/>      throw new Error(`User with id ${args.id} does not exist.`);<br/>    }</span><span id="7878" class="mm mn it li b gy oa np l nq nr">    const deletedUser = users.splice(index, 1);<br/>     return deletedUser[0];<br/>    }<br/>};</span><span id="e456" class="mm mn it li b gy oa np l nq nr">module.exports = Mutation;</span></pre><p id="3057" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe lf lg lh li b">resolvers</code>文件夹中创建一个新文件<code class="fe lf lg lh li b">Subscription.js</code>。</p><p id="27d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建一个<code class="fe lf lg lh li b">Subscription</code>变量，将<code class="fe lf lg lh li b">Subscription</code>解析器的内容赋给它，并从文件中导出。</p><p id="5c7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您的<code class="fe lf lg lh li b">Subscription.js</code>文件现在将看起来像这样</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="62f2" class="mm mn it li b gy no np l nq nr">const Subscription = {<br/>  update: {<br/>    subscribe(parent, args, ctx, info) {<br/>      return pubsub.asyncIterator('update_user');<br/>    }<br/>  }<br/>};</span><span id="44d9" class="mm mn it li b gy oa np l nq nr">module.exports = Subscription;</span></pre><p id="9f65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe lf lg lh li b">src</code>文件夹中新建一个<code class="fe lf lg lh li b">utils</code>文件夹，并在其中添加一个名为<code class="fe lf lg lh li b">users.js</code>的新文件，将<code class="fe lf lg lh li b">users</code>数组移入其中，并从该文件中导出。</p><p id="c51b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你的<code class="fe lf lg lh li b">users.js</code>文件现在会是这个样子</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="fc34" class="mm mn it li b gy no np l nq nr">const users = [<br/>  {<br/>    id: '1',<br/>    name: 'John',<br/>    age: 30,<br/>    location: {<br/>      state: 'New York',<br/>      city: 'Albany'<br/>    }<br/>  },<br/>  {<br/>    id: '2',<br/>    name: 'Mike',<br/>    age: 35,<br/>    location: {<br/>      state: 'North Karelia',<br/>      city: 'Ylitornio'<br/>    }<br/>  },<br/>  {<br/>    id: '3',<br/>    name: 'Jessica',<br/>    age: 25,<br/>    location: {<br/>      state: 'Roraima',<br/>      city: 'Formosa'<br/>    }<br/>  }<br/>];</span><span id="06a5" class="mm mn it li b gy oa np l nq nr">module.exports = users;</span></pre><p id="3cd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你的<code class="fe lf lg lh li b">index.js</code>文件现在看起来简单多了。</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="6ed4" class="mm mn it li b gy no np l nq nr">const { GraphQLServer, PubSub } = require('graphql-yoga');<br/>const { v4: uuidv4 } = require('uuid');</span><span id="7eda" class="mm mn it li b gy oa np l nq nr">const pubsub = new PubSub();</span><span id="50f5" class="mm mn it li b gy oa np l nq nr">const server = new GraphQLServer({<br/>  typeDefs,<br/>  resolvers<br/>});</span><span id="2f3f" class="mm mn it li b gy oa np l nq nr">const options = {<br/>  port: 4000,<br/>  endpoint: '/graphql'<br/>};</span><span id="55a7" class="mm mn it li b gy oa np l nq nr">server.start(options, ({ port }) =&gt;<br/>  console.log(`server started on port ${port}.`)<br/>);</span></pre><p id="2a85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们在<code class="fe lf lg lh li b">index.js</code>文件的顶部添加我们创建的所有文件的导入。</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="937b" class="mm mn it li b gy no np l nq nr">const Query = require('./resolvers/Query');<br/>const Mutation = require('./resolvers/Mutation');<br/>const Subscription = require('./resolvers/Subscription');<br/>const users = require('./utils/users');</span></pre><p id="fb79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将<code class="fe lf lg lh li b">GraphQLServer</code>构造函数从</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="d73f" class="mm mn it li b gy no np l nq nr">const server = new GraphQLServer({<br/>  typeDefs,<br/>  resolvers<br/>});</span></pre><p id="13a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="bb76" class="mm mn it li b gy no np l nq nr">const server = new GraphQLServer({<br/>  typeDefs: './src/schema.graphql',<br/>  resolvers: {<br/>    Query,<br/>    Mutation,<br/>    Subscription<br/>  },<br/>  context: {<br/>    users,<br/>    pubsub<br/>  }<br/>});</span></pre><p id="2158" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们添加的额外内容是<code class="fe lf lg lh li b">context</code>属性，它将作为第三个参数传递给在<code class="fe lf lg lh li b">Mutation.js</code>文件中定义的每个GraphQL变异。</p><p id="2f0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">而现在在<code class="fe lf lg lh li b">Mutation.js</code>文件中，不是直接引用<code class="fe lf lg lh li b">users</code>数组，而是需要引用为<code class="fe lf lg lh li b">ctx.users</code>。所以你可以析构<code class="fe lf lg lh li b">ctx</code>来得到<code class="fe lf lg lh li b">users</code>数组或者直接引用<code class="fe lf lg lh li b">ctx.users</code>并使用<code class="fe lf lg lh li b">ctx.pubsub.</code>来代替<code class="fe lf lg lh li b">pubsub</code></p><p id="94f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您的<code class="fe lf lg lh li b">Mutation.js</code>文件现在将看起来像这样</p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="0abe" class="mm mn it li b gy no np l nq nr">const { v4: uuidv4 } = require('uuid');</span><span id="65e2" class="mm mn it li b gy oa np l nq nr">const Mutation = {<br/>  addUser(parent, args, ctx, info) {<br/>    const { name, age } = args;<br/><strong class="li iu">    const { users } = ctx;</strong></span><span id="685e" class="mm mn it li b gy oa np l nq nr">    users.push({<br/>      id: uuidv4(),<br/>      name,<br/>      age<br/>    });</span><span id="793d" class="mm mn it li b gy oa np l nq nr">    return users;<br/>  },<br/>  updateUser(parent, args, ctx, info) {<br/>    const { id, name, age } = args;<br/><strong class="li iu">    const { users, pubsub } = ctx;</strong></span><span id="c636" class="mm mn it li b gy oa np l nq nr">    const user = users.find((user) =&gt; user.id === id);</span><span id="d3f9" class="mm mn it li b gy oa np l nq nr">    if (!user) {<br/>      throw new Error(`user with id ${id} does not exist.`);<br/>    }</span><span id="2260" class="mm mn it li b gy oa np l nq nr">    if (name) {<br/>      user.name = name;<br/>    }</span><span id="7993" class="mm mn it li b gy oa np l nq nr">    if (age) {<br/>      user.age = age;<br/>    }</span><span id="455d" class="mm mn it li b gy oa np l nq nr">    pubsub.publish('update_user', {<br/>      update: user<br/>    });</span><span id="917c" class="mm mn it li b gy oa np l nq nr">    return user;<br/>  },<br/>  deleteUser(parent, args, ctx, info) {<br/><strong class="li iu">    const { users } = ctx;</strong></span><span id="3caf" class="mm mn it li b gy oa np l nq nr">    const index = users.findIndex((user) =&gt; user.id === args.id);<br/>    if (index === -1) {<br/>      throw new Error(`User with id ${args.id} does not exist.`);<br/>    }</span><span id="c790" class="mm mn it li b gy oa np l nq nr">    const deletedUser = users.splice(index, 1);<br/>    return deletedUser[0];<br/>  }<br/>};</span><span id="3c17" class="mm mn it li b gy oa np l nq nr">module.exports = Mutation;</span></pre><p id="d0b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe lf lg lh li b">Subscription.js</code>文件中也从<code class="fe lf lg lh li b">ctx</code>中取<code class="fe lf lg lh li b">pubsub</code></p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="b891" class="mm mn it li b gy no np l nq nr">const Subscription = {<br/>  update: {<br/>    subscribe(parent, args, ctx, info) {<br/><strong class="li iu">      const { pubsub } = ctx;</strong></span><span id="28ac" class="mm mn it li b gy oa np l nq nr">      return pubsub.asyncIterator('update_user');<br/>    }<br/>  }<br/>};</span><span id="9e4c" class="mm mn it li b gy oa np l nq nr">module.exports = Subscription;</span></pre><p id="db9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe lf lg lh li b">Query.js</code>文件中，从<code class="fe lf lg lh li b">ctx</code>中取出<code class="fe lf lg lh li b">users</code></p><pre class="kp kq kr ks gt nk li nl nm aw nn bi"><span id="7c62" class="mm mn it li b gy no np l nq nr">const Query = {<br/>  name() {<br/>    return 'Dan';<br/>  },<br/>  age() {<br/>    return 50;<br/>  },<br/>  isSingle() {<br/>    return null;<br/>  },<br/>  numbers() {<br/>    return [10, 20, 30, 40];<br/>  },<br/>  location() {<br/>    return {<br/>      state: 'New York',<br/>      city: 'Albany'<br/>    };<br/>  },<br/>  users(parent, args, ctx, info) {<br/>    <strong class="li iu">const { users } = ctx;</strong><br/>    return users;<br/>  }<br/>};</span><span id="a53a" class="mm mn it li b gy oa np l nq nr">module.exports = Query;</span></pre><p id="f9d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们完成了代码重构。</p><p id="e686" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过执行<code class="fe lf lg lh li b">yarn start</code>命令运行该应用程序，您可以看到该应用程序与以前一样工作，但代码没有很好地组织。</p><p id="c7c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是这个多部分系列的第一部分。</p><p id="a6e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以在这个分支中找到这个应用程序的完整源代码。</p><p id="fd14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">点击查看本系列的下一部分<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/part-2-build-a-full-stack-app-using-graphql-as-backend-api-a1231753cdd4?source=friends_link&amp;sk=72994322563130fc174b05b55020b33c"/></p><div class="oj ok gp gr ol om"><a rel="noopener  ugc nofollow" target="_blank" href="/part-2-build-a-full-stack-app-using-graphql-as-backend-api-a1231753cdd4"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">使用GraphQL作为后端API构建一个全栈应用程序(第2部分)</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">使用MongoDB + GraphQL + React + Node.js栈构建App。</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa ky om"/></div></div></a></div><p id="be0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">今天到此为止。我希望你学到了新东西。</p><p id="d7d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">别忘了订阅我的每周时事通讯，里面有惊人的技巧、诀窍和文章，直接在这里的收件箱</strong> <a class="ae le" href="https://yogeshchavan.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">订阅。</strong> </a></p></div></div>    
</body>
</html>