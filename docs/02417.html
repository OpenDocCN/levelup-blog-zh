<html>
<head>
<title>JavaScript Clean Code — Law of Demeter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript干净代码——德米特里定律</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-clean-code-law-of-demeter-735320fe0506?source=collection_archive---------8-----------------------#2020-03-11">https://levelup.gitconnected.com/javascript-clean-code-law-of-demeter-735320fe0506?source=collection_archive---------8-----------------------#2020-03-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/77681a094ba2bb2db16b575c80b38a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ph1DXS9LL_9gB2Ng"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">卡莱布·伍兹在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="e5da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">德米特里定律指出，我们应该尽可能隐藏代码的实现细节。这确保了我们的代码之间的松散耦合。</p><p id="651e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看如何将德米特法则应用到我们的代码中。</p><h1 id="46bb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">为什么我们需要松耦合？</h1><p id="ff22" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">松耦合意味着当一段代码发生变化时，我们不必担心要修改很多代码。</p><p id="c1b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个单元对其他单元只有有限的了解，因此只引用了其他单元的一小部分。</p><p id="1916" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们只和直系朋友说话，这样就不会和其他不相关的部分说话了。</p><p id="8c26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以这意味着如果我们有两个类<code class="fe mh mi mj mk b">A</code>和<code class="fe mh mi mj mk b">B</code>，那么<code class="fe mh mi mj mk b">A</code>只引用必须被引用的<code class="fe mh mi mj mk b">B</code>的方法。其他成员和其他实现细节都是私有的。</p><h1 id="7569" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">我们如何应用得墨忒耳定律？</h1><p id="6a07" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以将Demeter定律应用到我们的JavaScript代码中，尽可能地引用一些类和它们的成员。</p><p id="5745" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是相互引用过多的类的一个例子:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="70f7" class="mt lf it mk b gy mu mv l mw mx">class PostalCode {<br/>  constructor(postalCode) {<br/>    this.postalCode = postalCode;<br/>  }</span><span id="fb4a" class="mt lf it mk b gy my mv l mw mx">  setPostalCode(postalCode) {<br/>    this.postalCode = postalCode;<br/>  }<br/>}</span><span id="32fa" class="mt lf it mk b gy my mv l mw mx">class Address {<br/>  constructor(streetName) {<br/>    this.streetName = streetName;<br/>  }</span><span id="4410" class="mt lf it mk b gy my mv l mw mx">  getPostalCode() {<br/>    return this.postalCode;<br/>  }</span><span id="f79f" class="mt lf it mk b gy my mv l mw mx">  setPostalCode(postalCode) {<br/>    this.postalCode = new PostalCode(postalCode);<br/>  }<br/>}</span><span id="8f68" class="mt lf it mk b gy my mv l mw mx">class Person {<br/>  constructor(name, age) {<br/>    this.name = name;<br/>    this.age = age;<br/>  }</span><span id="390e" class="mt lf it mk b gy my mv l mw mx">  setAddress(address) {<br/>    this.address = new Address(address);<br/>  }</span><span id="87fa" class="mt lf it mk b gy my mv l mw mx">  getAddress() {<br/>    return this.address;<br/>  }<br/>}</span></pre><p id="a4ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有引用<code class="fe mh mi mj mk b">PostalCode</code>的<code class="fe mh mi mj mk b">Address</code>类和引用<code class="fe mh mi mj mk b">Address</code>和<code class="fe mh mi mj mk b">Occupation</code>的<code class="fe mh mi mj mk b">Person</code>类。</p><p id="1e52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果<code class="fe mh mi mj mk b">Address</code>和<code class="fe mh mi mj mk b">PostalCode</code>中的任何一个发生变化，那么我们必须改变<code class="fe mh mi mj mk b">Person</code>和<code class="fe mh mi mj mk b">Address</code>类。</p><p id="220a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们必须通过编写以下代码来设置一个<code class="fe mh mi mj mk b">Person</code>的邮政编码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3914" class="mt lf it mk b gy mu mv l mw mx">person.getAddress().getPostalCode().setPostalCode('12345');</span></pre><p id="edf7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这需要大量的链接，包括返回不同类的实例。如果这些方法中的任何一个发生变化，那么整个链都必须重写。</p><p id="e365" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该做的是将所有的引用合并到一个方法中，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="614a" class="mt lf it mk b gy mu mv l mw mx">class PostalCode {<br/>  constructor(postalCode) {<br/>    this.postalCode = postalCode;<br/>  }</span><span id="0628" class="mt lf it mk b gy my mv l mw mx">  setPostalCode(postalCode) {<br/>    this.postalCode = postalCode;<br/>  }<br/>}</span><span id="4c88" class="mt lf it mk b gy my mv l mw mx">class Address {<br/>  constructor(streetName) {<br/>    this.streetName = streetName;<br/>  }</span><span id="9095" class="mt lf it mk b gy my mv l mw mx">  getPostalCode() {<br/>    return this.postalCode;<br/>  }</span><span id="d4e4" class="mt lf it mk b gy my mv l mw mx">  setPostalCode(postalCode) {<br/>    this.postalCode = new PostalCode(postalCode);<br/>  }<br/>}</span><span id="31cc" class="mt lf it mk b gy my mv l mw mx">class Person {<br/>  constructor(name, age) {<br/>    this.name = name;<br/>    this.age = age;<br/>  }</span><span id="5cbd" class="mt lf it mk b gy my mv l mw mx">  setAddress(address) {<br/>    this.address = new Address(address);<br/>  }</span><span id="3186" class="mt lf it mk b gy my mv l mw mx">  getAddress() {<br/>    return this.address;<br/>  }</span><span id="a65b" class="mt lf it mk b gy my mv l mw mx">  getPostalCode() {<br/>    return this.postalCode;<br/>  }</span><span id="7d95" class="mt lf it mk b gy my mv l mw mx">  setPostalCode(postalCode) {<br/>    this.postalCode = new PostalCode(postalCode);<br/>  }<br/>}</span></pre><p id="c3ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，如果<code class="fe mh mi mj mk b">PostalCode</code>类发生变化，我们只需更新<code class="fe mh mi mj mk b">Person</code>类，而不是在<code class="fe mh mi mj mk b">PostalCode</code>类发生变化时更新整个调用链来获取和设置邮政编码。</p><p id="c349" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关键是，我们必须了解整个系统，才能有所作为。</p><p id="b48e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">PostalCode</code>不必连接到<code class="fe mh mi mj mk b">Address</code>，因为它们可以单独改变。</p><p id="1fa5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们将它们耦合在一起，那么我们必须在改变<code class="fe mh mi mj mk b">PostalCode</code>之前了解<code class="fe mh mi mj mk b">Address</code>。</p><p id="5682" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的例子显示了可以避免并且应该避免的耦合。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/344f00b114728f1670d2ffed0fa8381d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N03XBB_wMh6yD9v0"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@coryb?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">科里·布特莱特</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="025b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">立面图案</h1><p id="f9ac" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们还可以使用facade模式来隐藏系统的复杂性，这样我们就不必了解它们。</p><p id="d3dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以将多个类隐藏在facade类后面，然后使用facade类与隐藏在facade类后面的多个类间接交互，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="73f1" class="mt lf it mk b gy mu mv l mw mx">class ClassA {</span><span id="e27c" class="mt lf it mk b gy my mv l mw mx">}</span><span id="03ae" class="mt lf it mk b gy my mv l mw mx">class ClassB {</span><span id="8fdb" class="mt lf it mk b gy my mv l mw mx">}</span><span id="62ca" class="mt lf it mk b gy my mv l mw mx">class ClassC {</span><span id="c771" class="mt lf it mk b gy my mv l mw mx">}</span><span id="beb9" class="mt lf it mk b gy my mv l mw mx">class Facade {<br/>  constructor() {<br/>    this.a = new ClassA();<br/>    this.b = new ClassB();<br/>    this.c = new ClassC();<br/>  }<br/>}</span><span id="b02b" class="mt lf it mk b gy my mv l mw mx">class Foo {<br/>  constructor() {<br/>    this.facade = new Facade();<br/>  }</span><span id="9418" class="mt lf it mk b gy my mv l mw mx">}</span></pre><p id="b0d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，<code class="fe mh mi mj mk b">Foo</code>类不知道<code class="fe mh mi mj mk b">Facade</code>类后面有什么。<code class="fe mh mi mj mk b">Facade</code>类保存了<code class="fe mh mi mj mk b">ClassA</code>、<code class="fe mh mi mj mk b">ClassB</code>和<code class="fe mh mi mj mk b">ClassC</code>的实例。</p><p id="1b00" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它为由<code class="fe mh mi mj mk b">ClassA</code>、<code class="fe mh mi mj mk b">ClassB</code>和<code class="fe mh mi mj mk b">ClassC</code>组成的复杂系统提供了一个简单的接口。</p><p id="e5b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当<code class="fe mh mi mj mk b">Facace</code>后面的任何一个类改变时，我们只需要改变<code class="fe mh mi mj mk b">Facade</code>类。</p><p id="6afe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它是我们想用这些类做的所有事情的一个切入点。我们用一个统一的界面来处理所有的引用，而不是单独引用它们并创建一堆引用。</p><p id="ee38" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这满足了Demeter定律，因为我们只访问<code class="fe mh mi mj mk b">Facade</code>类来处理<code class="fe mh mi mj mk b">ClassA</code>、<code class="fe mh mi mj mk b">ClassB</code>和<code class="fe mh mi mj mk b">ClassC</code>的任何事情。我们不必知道它们的底层实现。</p><p id="9424" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这使得软件易于使用、理解和测试，因为我们只需要使用和测试<code class="fe mh mi mj mk b">Facade</code>来与所有底层的类进行交互。</p><p id="9bf1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它消除了引用复杂系统的多个部分的需要，因为<code class="fe mh mi mj mk b">Facade</code>类提供了我们所需要的一切。</p><p id="87b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果facade类下面的代码设计得不好，我们还可以用一个设计良好的API来包装它，帮助使用facade类的人以一种简单的方式使用它。</p><p id="249a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最重要的是，消除了紧密耦合，因为除了facade类之外，没有任何东西引用它下面的复杂代码。</p><h1 id="d4f4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="db69" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Demeter法则就是尽可能地将实现隐藏在代码之外，这样他们就不必引用代码的不同部分来完成某件事情。</p><p id="40b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该只创建与密切相关的类对话的类，而不是与所有东西对话的类。</p><p id="8372" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们需要更改代码时，与所有东西交谈会产生一堆很难弄清楚的引用。</p><p id="e46b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实现德米特里定律的一个好方法是使用Facade模式。该模式声明我们有一个facade类，作为复杂系统中其他类的入口点。</p><p id="c672" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它用来提供一个易于使用的API，它隐藏了底层的实现。因此，如果我们确实需要更改底层代码，我们只需更新facade类，而不是所有引用底层实现代码的内容。</p></div></div>    
</body>
</html>