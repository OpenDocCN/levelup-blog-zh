<html>
<head>
<title>Build a Blender Add-on Ready to Scale</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">建立一个搅拌机附加准备规模</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-a-blender-add-on-ready-to-scale-8c285f9f0a5?source=collection_archive---------10-----------------------#2021-05-04">https://levelup.gitconnected.com/build-a-blender-add-on-ready-to-scale-8c285f9f0a5?source=collection_archive---------10-----------------------#2021-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5386" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">安装并运行一个基本的附加组件，为实现飞跃创造动力</h2></div><p id="cd27" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">这是记录Blender 3D插件创建的系列文章的第3部分，该插件将在模块化系统中动态生成3D可打印组件。该系统是仿照这种广泛分叉的</em> <a class="ae lc" href="https://www.thingiverse.com/thing:1936196" rel="noopener ugc nofollow" target="_blank"> <em class="lb"> 6”机架式机箱</em> </a> <em class="lb">。</em></p><p id="6ef5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">到目前为止，所有的帖子都可以自行阅读。</em> <a class="ae lc" rel="noopener ugc nofollow" target="_blank" href="/configure-blender-for-3d-printing-via-python-ecf729e4099b"> <em class="lb">第1部分</em> </a> <em class="lb">介绍了一个基本的Blender Python脚本，它可以自动配置3D打印的环境，而</em> <a class="ae lc" rel="noopener ugc nofollow" target="_blank" href="/rapidly-spawn-printable-meshes-via-blender-python-9ff5c3af6379"> <em class="lb">第2部分</em> </a> <em class="lb">展示了如何使用</em> <code class="fe ld le lf lg b"><em class="lb">BMesh</em></code> <em class="lb">模块来创建自定义网格几何图形。从这里开始，简单地将第2部分的要点</em>  <em class="lb">复制到本文第1步创建的项目目录中，作为</em> <code class="fe ld le lf lg b"><em class="lb">standoff_mesh.py</em></code> <em class="lb">。</em></p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><p id="7604" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完全成熟的Blender 3D插件是令人惊讶的事情。作为Python和Blender的相对新手，我经常发现自己被社区中人们制作的非常强大的东西吓呆了。坦率地说，这些软件包中的一些看起来有点不可思议，当自我怀疑或冒名顶替综合症的唠叨声被打破时，人们很容易想到“要是有人能做出能做<em class="lb"> X. </em>的东西就好了”</p><p id="4ce9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我记得，通过将好奇心和固执与良好的文档相结合，某人可以是任何人，并且<em class="lb"> X </em>可以变成<em class="lb"> X、Y和z。</em>甚至最难的部分也可以解决——特别是因为所有固执和好奇的人确保Blender的Python <a class="ae lc" href="https://docs.blender.org/api/current/index.html" rel="noopener ugc nofollow" target="_blank">文档</a>和<a class="ae lc" href="https://blender.stackexchange.com" rel="noopener ugc nofollow" target="_blank">堆栈交换</a>就像它让我们创建的gee whiz图形一样好。</p><p id="b59c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，已经存在的文档和模型为从头开始编写Blender附加组件打下了良好的基础，在开始时为该附加组件提供可伸缩的结构有助于更清楚地展示Python API的各个部分是如何结合在一起的。换句话说，它使新编写的代码比实际情况更好，同时也使现有的代码更容易学习。</p><p id="374a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文结束时，我们将创建一个功能完整的已安装的附加组件，它提供了一个自定义UI元素来将<code class="fe ld le lf lg b">Standoff</code>硬件挂载点添加到Blender场景中，并带有界面控件来调整将要创建的网格的直径和高度。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/cb2d5cb3f6fd269c11af97fc53aa7faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*41fRq1xefrSmuLhbLlULRQ.jpeg"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">最终目标:UI面板有一个按钮来添加支架网格，并控制调整大小。和新的僵局。</figcaption></figure><h1 id="0109" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">步骤1:文件结构</h1><p id="9353" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">考虑到这一点，这里有一个完整的目录和文件结构，它将存在于这篇文章的末尾，可以在开始时使用<code class="fe ld le lf lg b">mkdir</code>和<code class="fe ld le lf lg b">touch</code>来创建。然后就是填空的游戏了。我调用项目<code class="fe ld le lf lg b">DemoRack</code>，并将它设置为我用于Python项目的文件夹中的顶级目录名——它不一定是特定于Blender的。</p><pre class="lp lq lr ls gt nb lg nc nd aw ne bi"><span id="18b8" class="nf mf iq lg b gy ng nh l ni nj">DemoRack<br/>|-- README.md <br/>|-- DemoRack.zip &lt;-- will (re)compile via 'zip -r DemoRack.zip src'<br/>|-- src<br/>|-- |-- __init__.py<br/>|-- |-- standoff_mesh.py &lt;-- from Part 2, not modified in this post <br/>|-- |-- standoff_operator.py<br/>|-- |-- standoff_panel.py<br/>|-- |-- standoff_props.py</span></pre><p id="8a30" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些文件中的每一个都将在一个单独的步骤中介绍，但是首先，这里有一个它们的功能的快速列表:</p><ul class=""><li id="2951" class="nk nl iq kh b ki kj kl km ko nm ks nn kw no la np nq nr ns bi translated"><strong class="kh ir"> DemoRack.zip: </strong>编译过的<code class="fe ld le lf lg b">src</code>，安装在Blender里的文件。</li><li id="9ec8" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir"> __init__。py: </strong>为附加组件注册所有必要的信息和类。</li><li id="6d8c" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir"> standoff_mesh.py: </strong>用于生成目标几何/网格数据的模块。</li><li id="5f59" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir"> standoff_operator.py: </strong>可供用户界面使用的“do-er”。</li><li id="c20e" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir"> standoff_panel.py: </strong>在UI元素上添加Add-on将… add on。</li><li id="32ed" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir"> standoff_props.py: </strong>定义<code class="fe ld le lf lg b">Panel</code>和<code class="fe ld le lf lg b">Operator</code>需要的数据对象。</li></ul><p id="fe44" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简而言之，每个新的<code class="fe ld le lf lg b">standoff_</code>模块都将包括<code class="fe ld le lf lg b">register()</code>和<code class="fe ld le lf lg b">unregister()</code>功能。<code class="fe ld le lf lg b">__init__</code>模块将导入这些模块，并将两种类型的函数捆绑到单个迭代器中。Blender Python文档描述了这些函数扮演的角色:</p><blockquote class="ny nz oa"><p id="4ec6" class="kf kg lb kh b ki kj jr kk kl km ju kn ob kp kq kr oc kt ku kv od kx ky kz la ij bi translated"><code class="fe ld le lf lg b">register</code>是仅在启用插件时运行的功能，这意味着无需激活插件即可加载模块。</p><p id="01c4" class="kf kg lb kh b ki kj jr kk kl km ju kn ob kp kq kr oc kt ku kv od kx ky kz la ij bi translated"><code class="fe ld le lf lg b">unregister</code>是卸载<code class="fe ld le lf lg b">register</code>设置的任何东西的功能，当插件被禁用时调用。</p></blockquote><h1 id="7cce" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">第二步:__init__。巴拉圭</h1><p id="352f" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">有了这样的背景，并且因为<code class="fe ld le lf lg b">__init__</code>模块中的大部分代码都与<code class="fe ld le lf lg b">sys</code>和<code class="fe ld le lf lg b">importlib</code>包有关，所以我将在这里包括要点，而不是试图脱离描述Python模块导入的杂草。需要特别注意的附加组件是<code class="fe ld le lf lg b">module_names</code>列表，声明为<code class="fe ld le lf lg b">register</code>和<code class="fe ld le lf lg b">unregister</code>函数引入的文件名，以及打开的<code class="fe ld le lf lg b">bl_info</code>字典。如<a class="ae lc" href="https://docs.blender.org/manual/en/latest/advanced/scripting/addon_tutorial.html" rel="noopener ugc nofollow" target="_blank">官方插件介绍</a>教程中所述，<code class="fe ld le lf lg b">bl_info</code>包含了在首选项面板中可以找到的所有信息:</p><blockquote class="ny nz oa"><p id="6db6" class="kf kg lb kh b ki kj jr kk kl km ju kn ob kp kq kr oc kt ku kv od kx ky kz la ij bi translated"><code class="fe ld le lf lg b">bl_info</code>是一个包含附加元数据的字典，例如要在首选项附加列表中显示的标题、版本和作者。它还指定了运行脚本所需的最低Blender版本；旧版本不会在列表中显示加载项</p></blockquote><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="fc96" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">第三步:standoff_props.py</h1><p id="334b" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">这个模块将是这个系列中涉及最多的，但是它也为其他模块提供了主干，并且实现了一个可以被广泛重用的模式。它依赖于导入<code class="fe ld le lf lg b">PropertyGroup</code>类型(<a class="ae lc" href="https://docs.blender.org/api/current/bpy.types.PropertyGroup.html?highlight=propertygroup#bpy.types.PropertyGroup" rel="noopener ugc nofollow" target="_blank"> docs </a>)，用来捆绑一组<a class="ae lc" href="https://docs.blender.org/api/current/bpy.props.html" rel="noopener ugc nofollow" target="_blank">属性定义</a>、<code class="fe ld le lf lg b">bpy.props</code>。一旦向Blender注册了一个<code class="fe ld le lf lg b">PropertyGroup</code>,它就在Python可脚本化数据对象的指针和底层C分配的执行Blender繁重任务的内存之间提供了一座桥梁。</p><p id="488b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe ld le lf lg b">standoff_props.py</code>中，将定义一个类，从<code class="fe ld le lf lg b">bpy.types.PropertyGroup</code>继承，并跟踪3个属性特性:</p><ul class=""><li id="2f58" class="nk nl iq kh b ki kj kl km ko nm ks nn kw no la np nq nr ns bi translated"><code class="fe ld le lf lg b">metric_diameter: FloatProperty(**kwargs)</code></li><li id="a3ff" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><code class="fe ld le lf lg b">height: FloatProperty(**kwargs)</code></li><li id="6b78" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><code class="fe ld le lf lg b">mesh: PointerProperty(type=Mesh)</code></li></ul><p id="4f1c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">前两个应该是不言自明的，在实现中会有更多的参数细节。第三，一个<code class="fe ld le lf lg b">PointerProperty</code>指向内存中的一个对象，并要求这个对象的类型在定义时指定，并且它是<code class="fe ld le lf lg b">PropertyGroup</code>或<code class="fe ld le lf lg b">bpy.struct.ID</code>的子类(即一个网格)。这意味着任何将值设置为任何其他数据类型的实例(在本例中，任何不是<code class="fe ld le lf lg b">bpy.types.Mesh</code>的实例)的尝试都将抛出错误，任何将值传递给期望任何其他数据类型的参数的尝试也是如此。</p><p id="86da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，<code class="fe ld le lf lg b">mesh</code>属性<code class="fe ld le lf lg b">PointerProperty</code>将用于保存在<a class="ae lc" rel="noopener ugc nofollow" target="_blank" href="/rapidly-spawn-printable-meshes-via-blender-python-9ff5c3af6379">第2部分</a> ( <code class="fe ld le lf lg b">standoff_mesh.py</code>)中创建的<code class="fe ld le lf lg b">Standoff.mesh()</code>类方法的返回值，并实例化用<code class="fe ld le lf lg b">metric_diameter</code>和<code class="fe ld le lf lg b">height</code>后面存储的值修改的&amp;。这三个属性的完整定义如下:</p><pre class="lp lq lr ls gt nb lg nc nd aw ne bi"><span id="4ab7" class="nf mf iq lg b gy ng nh l ni nj">class PG_Standoff(PropertyGroup):<br/>    metric_diameter: FloatProperty(<br/>        name="Inner Diameter (Metric)",<br/>        min=2,<br/>        max=5,<br/>        step=50,<br/>        precision=1,<br/>        set=prop_methods("SET", "metric_diameter"),<br/>        get=prop_methods("GET", "metric_diameter"),<br/>        update=prop_methods("UPDATE"))<br/>    height: FloatProperty(<br/>        name="Standoff Height",<br/>        min=2,<br/>        max=6,<br/>        step=25,<br/>        precision=2,<br/>        set=prop_methods("SET", "height"),<br/>        get=prop_methods("GET", "height"),<br/>        update=prop_methods("UPDATE"))<br/>    mesh: PointerProperty(type=Mesh)</span></pre><p id="4ac5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单独的<code class="fe ld le lf lg b">set</code>、<code class="fe ld le lf lg b">get</code>和<code class="fe ld le lf lg b">update</code>参数都指向<code class="fe ld le lf lg b">prop_methods</code>函数的返回值。这些值<em class="lb">必须</em>是函数，分别带参数<code class="fe ld le lf lg b">(self, value)</code>、<code class="fe ld le lf lg b">(self)</code>和<code class="fe ld le lf lg b">(self, context)</code>。这个闭包工厂可能看起来非常复杂，但是它将显著减少重复，并为与<code class="fe ld le lf lg b">PropertyGroup</code>数据属性的交互提供更大的灵活性。</p><p id="d65c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要理解的一个重要区别是，每当属性改变时，就会调用<code class="fe ld le lf lg b">update</code>函数——它不是作为更新定义它的属性的一种方式而被调用的。相反，它提供了一种将特定属性的更改传递给程序其他部分的方法；这必须小心使用，以避免无声的副作用，因为没有检查来避免无限递归(即，如果更新程序更新它所附加的属性，或者如果它包含的逻辑触发另一个修改其父属性的更新程序)。</p><p id="a3a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一件要注意的事情是，使用<code class="fe ld le lf lg b">set</code>和<code class="fe ld le lf lg b">get</code>函数意味着任何<code class="fe ld le lf lg b">default</code>值都必须通过一个显式的<code class="fe ld le lf lg b">set</code>调用来设置(而不是作为一个<code class="fe ld le lf lg b">kwarg</code>)，但这也提供了一个在必要时挂钩<code class="fe ld le lf lg b">on_load</code>方法的机会。最后，<code class="fe ld le lf lg b">prop_methods</code>函数必须在调用它的任何<code class="fe ld le lf lg b">PropertyGroup</code>类之前<em class="lb">定义。</em></p><p id="72b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ld le lf lg b">prop_methods</code>功能的半肉骨架看起来像这样:</p><pre class="lp lq lr ls gt nb lg nc nd aw ne bi"><span id="3f65" class="nf mf iq lg b gy ng nh l ni nj">def prop_methods(call, prop=None):<br/>    def getter(self):<br/>        # getter function must check if prop attr has a value yet<br/>            # if no value, will throw error, so must set default<br/>            # can hook on load here<br/>        # and either way, return self[prop] value</span><span id="a30e" class="nf mf iq lg b gy og nh l ni nj">    def setter(self, value):<br/>        self[prop] = value</span><span id="ceba" class="nf mf iq lg b gy og nh l ni nj">    def updater(self, context):<br/>        self.update(context)</span><span id="f491" class="nf mf iq lg b gy og nh l ni nj">    methods = {<br/>        "GET": getter,<br/>        "SET": setter,<br/>        "UPDATE": updater<br/>        }</span><span id="1966" class="nf mf iq lg b gy og nh l ni nj">    return methods[call]</span></pre><p id="9196" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完整的实现可以写成:</p><pre class="lp lq lr ls gt nb lg nc nd aw ne bi"><span id="a845" class="nf mf iq lg b gy ng nh l ni nj">def prop_methods(call, prop=None):<br/>    def getter(self):<br/>        try:<br/>            value = self[prop]<br/>        except:<br/>            set_default = prop_methods("SET", prop)<br/>            set_default(self, self.defaults[prop])<br/>            if hasattr(self, "on_load"):<br/>                self.on_load()<br/>            value = self[prop]<br/>        finally:<br/>            return value</span><span id="d0fc" class="nf mf iq lg b gy og nh l ni nj">    def setter(self, value):<br/>        self[prop] = value<br/>            <br/>    def updater(self, context):<br/>        self.update(context)</span><span id="116c" class="nf mf iq lg b gy og nh l ni nj">    methods = {<br/>        "GET": getter,<br/>        "SET": setter,<br/>        "UPDATE": updater,<br/>        }</span><span id="b081" class="nf mf iq lg b gy og nh l ni nj">    return methods[call]</span></pre><p id="4beb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要做到这一点，任何具有调用<code class="fe ld le lf lg b">prop_methods</code> <em class="lb">属性的类都需要</em>一个名为<code class="fe ld le lf lg b">defaults</code>的字典对象和一个名为<code class="fe ld le lf lg b">update</code>的方法(该函数提供了一个<code class="fe ld le lf lg b">on_load</code>方法，但并不要求)。在<code class="fe ld le lf lg b">PG_Standoff</code>类中，这些调用将用于在加载时以及在<code class="fe ld le lf lg b">metric_diameter</code>或<code class="fe ld le lf lg b">height</code>属性被修改时附加<code class="fe ld le lf lg b">Standoff.mesh()</code>的返回值。也就是说，<code class="fe ld le lf lg b">PG_Standoff</code>类的其余部分可以写成:</p><pre class="lp lq lr ls gt nb lg nc nd aw ne bi"><span id="2d07" class="nf mf iq lg b gy ng nh l ni nj">class PG_Standoff(PropertyGroup):<br/>    # ...</span><span id="1b41" class="nf mf iq lg b gy og nh l ni nj">    defaults = { "metric_diameter": 2.5, "height": 3 }</span><span id="ca23" class="nf mf iq lg b gy og nh l ni nj">    standoff = Standoff()</span><span id="8a94" class="nf mf iq lg b gy og nh l ni nj">    def on_load(self):<br/>        if self.height and self.metric_diameter:<br/>            self.__set_mesh()</span><span id="ab37" class="nf mf iq lg b gy og nh l ni nj">    def update(self, context):<br/>        self.__set_mesh()</span><span id="5dfc" class="nf mf iq lg b gy og nh l ni nj">    def __set_mesh(self):<br/>        self.mesh = self.standoff.mesh(<br/>           self.height, self.metric_diameter)</span></pre><p id="d683" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样就只剩下安装附加组件时让Blender知道<code class="fe ld le lf lg b">PG_Standoff</code>类所需的<code class="fe ld le lf lg b">import</code>语句和<code class="fe ld le lf lg b">register</code>和<code class="fe ld le lf lg b">unregister</code>函数。在register函数中，我们还将从一个<code class="fe ld le lf lg b">PointerProperty</code>实例中指向<code class="fe ld le lf lg b">PG_PropertyGroup</code>类，引用自Blender <code class="fe ld le lf lg b">Scene</code>类型的一个新属性，这将使从附加组件的其余部分访问变得简单。这就形成了一个完整的<code class="fe ld le lf lg b">standoff_props.py</code>模块，如下图所示:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="fcb0" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">步骤4: standoff_operator.py</h1><p id="7be3" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">最后两个模块都是短文件，实现起来非常简单，因为构建和修改数据的繁重工作已经以简化其与Blender Python API的交互的方式完成了。在<code class="fe ld le lf lg b">standoff_operator</code>模块中，我们将定义(并注册)一个新的<code class="fe ld le lf lg b">bpy.types.Operator</code>类，它可以附加到任何UI按钮上。</p><p id="cade" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于如何定义新的<code class="fe ld le lf lg b">Operator</code>有一些要求，但是这些都有很好的文档记录并且很简单，通过从CLI启动Blender，错误配置的<code class="fe ld le lf lg b">Operator</code>类的有用警告和错误消息将会立即变得显而易见。新<code class="fe ld le lf lg b">Operators</code>的预期定义详见本手册<a class="ae lc" href="https://docs.blender.org/api/current/bpy.types.Operator.html" rel="noopener ugc nofollow" target="_blank">章节</a>。这个脚本将定义<code class="fe ld le lf lg b">docstring</code>、<code class="fe ld le lf lg b">bl_idname</code>、<code class="fe ld le lf lg b">bl_label</code>和<code class="fe ld le lf lg b">bl_options</code>属性的值。它还将定义一个<code class="fe ld le lf lg b">execute</code>方法，该方法需要<code class="fe ld le lf lg b">self</code>和<code class="fe ld le lf lg b">context</code>参数，并且包含逻辑和事件，这些逻辑和事件将被附加到调用在<code class="fe ld le lf lg b">bl_idname</code>下注册的<code class="fe ld le lf lg b">Operator</code>的任何UI按钮。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="3e82" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">步骤5: standoff_panel.py</h1><p id="31cf" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">定义一个新的<code class="fe ld le lf lg b">Panel</code>类实际上遵循与定义一个新的<code class="fe ld le lf lg b">Operator</code>相同的模式，从概念上讲，简单地将最后一步中的<code class="fe ld le lf lg b">execute</code>方法替换为这一步中的<code class="fe ld le lf lg b">draw</code>方法是有意义的。相关的<a class="ae lc" href="https://docs.blender.org/api/current/bpy.types.Panel.html?highlight=panel#bpy.types.Panel" rel="noopener ugc nofollow" target="_blank">面板手册章节</a>给出了几个有用的例子，还有更多包含在<em class="lb"> UI脚本&gt;模板&gt; Python菜单中。</em>在<code class="fe ld le lf lg b">bpy.types.UILayout</code> <a class="ae lc" href="https://docs.blender.org/api/current/bpy.types.UILayout.html" rel="noopener ugc nofollow" target="_blank">手册章节</a>中可以找到更多的可能性，它记录了<code class="fe ld le lf lg b">Panel</code>对象的导入子对象。在<code class="fe ld le lf lg b">draw</code>方法中，这是一个简单(并且非常开放)的过程:</p><ol class=""><li id="d841" class="nk nl iq kh b ki kj kl km ko nm ks nn kw no la oh nq nr ns bi translated">从<code class="fe ld le lf lg b">context</code>访问相关数据对象</li><li id="076f" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la oh nq nr ns bi translated">为任何需要按钮的<code class="fe ld le lf lg b">Operator</code>调用创建<code class="fe ld le lf lg b">layout.operator</code>对象</li><li id="77de" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la oh nq nr ns bi translated">为用户可写的数据属性创建<code class="fe ld le lf lg b">layout.prop</code>对象</li></ol><p id="aaa4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，对于该模式和更复杂的数据类型，还有很多扩展和变化的空间。但是在基础上，这是API通过遵循使用<code class="fe ld le lf lg b">bpy.props</code>和<code class="fe ld le lf lg b">bpy.types.PropertyGroup</code>实例的内置模式来处理繁重工作的另一个地方。由于这种简单性，这是另一个模块，可以直接将整个脚本视为一个要点:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="53f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一的额外变化是<code class="fe ld le lf lg b">DemoRackPanel</code>的类定义，<code class="fe ld le lf lg b">StandoffPanel</code>继承了<code class="fe ld le lf lg b">bpy.types.Panel</code>的类定义。因为这将不是<code class="fe ld le lf lg b">DemoRack</code>附加组件中唯一的<code class="fe ld le lf lg b">Panel</code>，并且它们都将在View 3D侧抽屉中的单个选项卡下，所以消除3行重复很简单。<code class="fe ld le lf lg b">layout.prop</code>和相关函数中的模式是将一个数据对象作为第一个参数，将该对象中属性的字符串标识符作为第二个参数。</p><p id="f8c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">剩下要做的就是从<code class="fe ld le lf lg b">DemoRack/src/</code>目录中编译<code class="fe ld le lf lg b">DemoRack.zip</code>文件，然后将该本地文件安装在<em class="lb">Edit&gt;Preferences&gt;Add-ons</em>中，就像其他文件一样。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><p id="5ca5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">感谢您全程支持这篇文章，当然也感谢您对代码或文章的任何反馈/批评。幸运的话，这将是这个系列中最长的一篇文章。至于其余的，我的目标是把事情分解成更小的块。要一次查看所有要点，</em> <a class="ae lc" href="https://gist.github.com/ocommaj/d9b2e0b68f300f9afe9f559d660b2b23" rel="noopener ugc nofollow" target="_blank"> <em class="lb">点击此链接</em> </a> <em class="lb">。在</em> <a class="ae lc" href="https://github.com/ocommaj/DemoRack" rel="noopener ugc nofollow" target="_blank"> <em class="lb">德莫瑞</em> </a> <em class="lb">有一个完整的项目回购。</em></p></div></div>    
</body>
</html>