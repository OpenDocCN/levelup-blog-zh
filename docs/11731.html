<html>
<head>
<title>How to simultaneously run the client and server instances of your full-stack app in one folder.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在一个文件夹中同时运行您的全栈应用的客户端和服务器实例。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-simultaneously-run-the-client-and-server-of-your-full-stack-app-in-one-folder-ef5a988d56d7?source=collection_archive---------2-----------------------#2022-04-11">https://levelup.gitconnected.com/how-to-simultaneously-run-the-client-and-server-of-your-full-stack-app-in-one-folder-ef5a988d56d7?source=collection_archive---------2-----------------------#2022-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6b57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你有没有想过如何同时运行你的全栈应用的前端和后端部分？拿着我的咖啡，让我们开始喝吧。</p><p id="e6cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设您正在构建一个全栈应用程序，在前端使用React，在后端使用Nodejs &amp; ExpressJs。第一步是创建您希望项目所在的目录。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/eafc0b9a1f9e7ce3849f6429ab410b95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*Q8jTxPnLiFDUGu4LPEqEdQ.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">用于创建工作目录的Shell命令</figcaption></figure><p id="fdee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成后，您可以继续编写下一系列命令，或者用代码编辑器打开目录。您可以通过使用命令“cd folder-name”检查目录，然后输入“code”来做到这一点</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/e6e1563692d82798c9a20f12c3032a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*2DwkVWdH_I5cnF7F-TT3BA.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">如何用代码编辑器(已经安装)打开目录</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi ky"><img src="../Images/6c24956a4d7cb6a5b4c0184d14ff62ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WUhdrdVd3udfqbARDCINdQ.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">用代码编辑器打开的目录</figcaption></figure><p id="6a9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是在代码编辑器中打开终端，为此，同时按住CTRL + J。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi ld"><img src="../Images/20d9524b91b82e23b957bb5da191e745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qPfn56pc2OfC-cTUZ9xhjg.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">航站楼开放了</figcaption></figure><p id="dfdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来要做的是初始化我们的项目，在您的终端中，输入“npm init -y”</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi le"><img src="../Images/4ac55b2a2a748022a965e87566433a24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fQYwSw75DIPGXXma7v-Vqw.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">项目已初始化</figcaption></figure><p id="d63a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以稍后编辑package.json文件，因此对于我们的前端，让我们使用React。在同一个目录下，输入以下命令:“npx create-react-app @ latest frontend”。“前端”是一个任意的词，我想用它来命名我们的前端应用程序，你可以随意命名。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lf"><img src="../Images/46282bfa51f6d7d69114567452d20a30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oVbF9QEEoNySRUZCxbMLig.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">启动我们的前端应用程序。</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lg"><img src="../Images/b6daef41f925eec3f015a90ecae5f6ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jCG-py-Vv-DvVK1AdAy1Hg.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">前端应用程序已创建，控制台已清空</figcaption></figure><p id="c040" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出于本教程的目的，我们不会创建一个具有API和特性的全栈应用程序，目标是让后端和前端同时运行。注意，让我们创建一个后端文件夹，在项目根文件夹中，输入“mkdir backend”。“后端”再次是一个任意的词。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lh"><img src="../Images/18f2116fa31f6e102ddde1e94c942c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LWEOkSpPh1Ty3CjTdXCBiA.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">后端文件夹已创建</figcaption></figure><p id="64ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就像我们在根目录中所做的一样，让我们初始化后端文件夹，</p><p id="ba8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查后端目录并输入“npm init -y”</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi li"><img src="../Images/8869d4a095874a095118fb20b0775468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1SR3as-8UkxlkDHqp5a5xg.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">后端应用程序已初始化</figcaption></figure><p id="4d85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只是为了让它正常工作。在后端文件夹中创建一个文件，命名为index.js并在其中写一些东西，简单的如“Hello World”。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lj"><img src="../Images/5ce350796ce9e2e1dfe11754c1720246.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BkYhXCEWP79-1B3F00qSig.png"/></div></div></figure><p id="39e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以通过在终端中运行“node index.js”来测试它是否工作，正如您在上面的图像中看到的，它运行了。现在完成了，让我们进入后端文件夹中的package.json文件，而不是根目录中的文件，添加一个启动脚本，如下所示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lk"><img src="../Images/0e5a11cfb31c70284d60876bdce5aaea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VePSwxSQjOgNJyzMrZexgQ.png"/></div></div></figure><p id="054b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要测试它，在后端文件夹中，输入“npm start”。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi ll"><img src="../Images/9dc950448002f8be6052491de58a952c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QPv2NO2agDdf-Vz7LdYh8w.png"/></div></div></figure><p id="0188" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，让我们创建一个简单的连接，安装express和nodemon，express将是一个依赖项，nodemon将是一个devdependency，要检查依赖项和devdependency之间的区别，请检查以下链接:<a class="ae lm" href="https://stackoverflow.com/questions/18875674/whats-the-difference-between-dependencies-devdependencies-and-peerdependencies" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/18875674/whats-the-difference-between-dependencies-dev dependencies-and-peer dependencies</a></p><p id="540c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们安装express和nodemon，对于express，“npm i express”就足够了，对于nodemon，“npm i nodemon -D”将安装它，确保您仍然在后端目录中。您将看到以下结果:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi ln"><img src="../Images/1ab40c4c2da21f2cb6e0c243ec23feab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6O6_32gLsdP7vXyLxU7Lvg.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">已安装的依赖项反映在package.json文件中</figcaption></figure><p id="360c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在index.json文件中，键入以下代码:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/da8cb0351c0d2c3590264da1bcf2c04d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*YAOviDeV2cdUTa-fdsuMkA.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">启动我们服务器的简单代码</figcaption></figure><p id="e5f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第16 -18行简单地为我们创建了一个简单的API，在localhost:5000上有一个响应消息，为了测试这个简单的API，让我们在我们的浏览器上转到localhost:5000，您应该看到以下内容:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/43426f06473dff94caaa82c9c517da2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*aFdxkIN-elRn1lZdL6X_4A.png"/></div></figure><p id="8248" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们使用nodemon，nodemon只是用于热重载，热重载在我们保存文件或在开发过程中进行更改时重启我们的服务器，而不是每次都必须手动重启。要实现它，请转到package.json，将启动脚本中的“node”替换为“nodemon”。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/97b98f72092499326df12818896777f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*zJjLEuM61LW0P8KV7l2zaA.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">Nodemon已实现</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lg"><img src="../Images/13c55cb5ff482139174bd2847dfc91fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VVj4_cKvEYtNMfX5jnSrvw.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">活动中的节点</figcaption></figure><p id="99bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然已经解决了，让我们集中精力同时启动后端和前端。我省略了前端的操作，因为“create-react-app”附带了一个我们可以使用的脚本模板，“npm start”适用于react。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/de3ae3be5dddfdc6e28a7c1c326c1d1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*DCgsIat39Kz99ggQJWLz7A.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">React应用包. json</figcaption></figure><p id="8d63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们转到项目的根目录，为此，输入以下内容:“cd../"在后端目录中，这将引导我们到根目录。</p><p id="669b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在根目录下，让我们“并发”安装，npm包将帮助我们同时运行后端和前端。完成后，转到根文件夹中的package.json，并在脚本部分键入以下内容:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/61bc74ff9f84cc35d0e334cf2a9b53cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*2jSd9pKjU1FVbYOozkgJ5Q.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">同时运行前端和后端的脚本。</figcaption></figure><p id="afc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将解释服务器，客户端和开发脚本同步意味着什么。</p><p id="1260" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“服务器”脚本代表启动服务器的命令，在backend package.json中，我们已经指定了它，前缀“-”指示代码在后端目录中运行命令，同样的事情发生在“客户端”脚本中，该命令是为了确保前端应用程序启动。命令“npm run dev”将运行“dev”脚本，它使用“concurrently”关键字同时运行两个脚本，如下所示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/48adc380ce9fd0784106a29b6d9f6628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*tC80xb6GFZYTi87ZUwi1-w.png"/></div></figure><p id="5e7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于React，默认端口是3000，我们为后端服务器选择了5000。运行脚本后，在浏览器中分别检查http://localhost:3000和<a class="ae lm" href="http://localhost:5000" rel="noopener ugc nofollow" target="_blank"> http://localhost:5000 </a>，您将看到前端和后端实例同时运行。</p><p id="30bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我是威廉·派普，谢谢你来听我的Ted演讲。😃♥️</p></div></div>    
</body>
</html>