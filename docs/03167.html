<html>
<head>
<title>Dispatching Async Actions with Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Redux调度异步操作</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dispatching-async-actions-with-redux-40d984f63338?source=collection_archive---------4-----------------------#2020-04-23">https://levelup.gitconnected.com/dispatching-async-actions-with-redux-40d984f63338?source=collection_archive---------4-----------------------#2020-04-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3a5672c716e1526fe0a69305f75075f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DWk14fepbn8ZEcGw"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@quinoal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Quino Al </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="0def" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了Redux，我们可以用它在JavaScript应用程序的中央位置存储数据。它可以单独工作，当与React-Redux结合使用时，它也是一个受欢迎的React应用程序状态管理解决方案。</p><p id="0f44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究如何异步分派动作。</p><h1 id="a344" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">异步操作</h1><p id="299b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在JavaScript中，很多事情必须异步完成，以避免阻塞主执行线程。</p><p id="89cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Redux可以调度异步动作，这样我们就不必总是同步改变状态。</p><p id="1ee6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们使用Redux-Thunk中间件。我们可以通过使用Redux的<code class="fe mh mi mj mk b">applyMiddleware</code>函数来应用中间件。</p><p id="859a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们可以传入调用<code class="fe mh mi mj mk b">dispatch</code>而不是普通对象的函数。我们需要这种能力来运行调用<code class="fe mh mi mj mk b">dispatch</code>的异步动作，并用它填充存储。</p><p id="0864" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以这样做:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6f5e" class="mt lf it mk b gy mu mv l mw mx">import { createStore, applyMiddleware } from "redux";<br/>import thunkMiddleware from "redux-thunk";</span><span id="1ab9" class="mt lf it mk b gy my mv l mw mx">function jokeReducer(state = {}, action) {<br/>  switch (action.type) {<br/>    case "SET_JOKE":<br/>      return action.joke;<br/>    default:<br/>      return state;<br/>  }<br/>}</span><span id="bbfc" class="mt lf it mk b gy my mv l mw mx">let store = createStore(jokeReducer, applyMiddleware(thunkMiddleware));</span><span id="8ab5" class="mt lf it mk b gy my mv l mw mx">function fetchJoke() {<br/>  return async dispatch =&gt; {<br/>    const response = await fetch("<a class="ae kf" href="https://api.icndb.com/jokes/random" rel="noopener ugc nofollow" target="_blank">https://api.icndb.com/jokes/random</a>");<br/>    const joke = await response.json();<br/>    dispatch({ type: "SET_JOKE", joke });<br/>  };<br/>}</span><span id="fcbf" class="mt lf it mk b gy my mv l mw mx">(async () =&gt; {<br/>  await store.dispatch(fetchJoke());<br/>  console.log(store.getState().value.joke);<br/>})();</span></pre><p id="f111" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有<code class="fe mh mi mj mk b">jokeReducer</code>，它和我们之前的代码一样。</p><p id="34dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在创建商店时，我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="62f8" class="mt lf it mk b gy mu mv l mw mx">let store = createStore(jokeReducer, applyMiddleware(thunkMiddleware));</span></pre><p id="015a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与只采取普通对象动作的商店不同的是，我们在<code class="fe mh mi mj mk b">thunkMiddleware</code>中传递了<code class="fe mh mi mj mk b">applyMiddleware</code>函数。</p><p id="248b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">thunkMiddleware</code>让我们传递函数来分派，而不是传递一个没有函数的普通对象。</p><p id="7590" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们传入的函数中，我们可以用普通对象调用<code class="fe mh mi mj mk b">dispatch</code>来执行同步操作。</p><p id="a29d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们定义了<code class="fe mh mi mj mk b">fetchJoke</code>函数，它是or动作创建器，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="210e" class="mt lf it mk b gy mu mv l mw mx">function fetchJoke() {<br/>  return async dispatch =&gt; {<br/>    const response = await fetch("<a class="ae kf" href="https://api.icndb.com/jokes/random" rel="noopener ugc nofollow" target="_blank">https://api.icndb.com/jokes/random</a>");<br/>    const joke = await response.json();<br/>    dispatch({ type: "SET_JOKE", joke });<br/>  };<br/>}</span></pre><p id="606e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个函数中，我们返回了一个异步函数，它将Redux <code class="fe mh mi mj mk b">dispatch</code>函数作为参数。</p><p id="5688" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后一旦我们用Fetch API得到这个笑话，我们就调用参数中提供的<code class="fe mh mi mj mk b">dispatch</code>。</p><p id="e74b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，Thunk中间件可以在返回的函数中调用<code class="fe mh mi mj mk b">dispatch</code>。</p><p id="9799" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以返回任何函数，但是我们需要对异步函数使用thunks，因为它们不返回普通对象。</p><p id="2c91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">普通的动作创建者必须返回普通对象，但是如果我们使用Redux Thunk中间件，我们可以返回一个调用<code class="fe mh mi mj mk b">dispatch</code>和<code class="fe mh mi mj mk b">getState</code>的函数。</p><p id="67da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们调度我们的异步操作，并从中获取值，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2f09" class="mt lf it mk b gy mu mv l mw mx">(async () =&gt; {<br/>  await store.dispatch(fetchJoke());<br/>  console.log(store.getState().value.joke);<br/>})();</span></pre><p id="276c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在上面所做的就是调用<code class="fe mh mi mj mk b">dispatch</code>,并保证<code class="fe mh mi mj mk b">fetchJoke</code>函数按照我们上面的定义返回。然后我们使用<code class="fe mh mi mj mk b">store.getState().value.joke</code>从商店获取笑话的值。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/c9f9bdfb6e0792fa9a49b8e7d9afab37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Wp42Wf-cEaM7-87s"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@sincerelymedia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">真诚媒体</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="f8dd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在我们的异步动作创建器中分派同步动作之前检查状态</h1><p id="1ddd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以写一个函数在获取数据之前检查状态。为此，我们可以在保持其他一切不变的情况下进行以下更改:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="696e" class="mt lf it mk b gy mu mv l mw mx">function shouldFetchJoke(state) {<br/>  return !state.value || !state.value.joke;<br/>}</span><span id="b8ca" class="mt lf it mk b gy my mv l mw mx">function fetchJoke() {<br/>  return async (dispatch, getState) =&gt; {<br/>    if (shouldFetchJoke(getState())) {<br/>      const response = await fetch("<a class="ae kf" href="https://api.icndb.com/jokes/random" rel="noopener ugc nofollow" target="_blank">https://api.icndb.com/jokes/random</a>");<br/>      const joke = await response.json();<br/>      dispatch({ type: "SET_JOKE", joke });<br/>    }<br/>  };<br/>}</span></pre><p id="b77d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们定义了<code class="fe mh mi mj mk b">shouldFetchJoke</code>函数，该函数检查<code class="fe mh mi mj mk b">state.value</code>和<code class="fe mh mi mj mk b">state.value.joke</code>以查看值是否已被设置。</p><p id="66cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们把<code class="fe mh mi mj mk b">fetchJoke</code>改成叫<code class="fe mh mi mj mk b">shouldFetchJoke</code>。然后，我们利用<code class="fe mh mi mj mk b">getState</code>参数获取状态，并检查带有<code class="fe mh mi mj mk b">shouldFetchJoke</code>的商店中是否已经存在笑话。</p><p id="6061" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果没有，那么我们就开始理解这个笑话。</p><h1 id="0f63" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="46c8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">使用Redux Thunk中间件，我们可以将不是普通对象的动作传递给<code class="fe mh mi mj mk b">dispatch</code>。</p><p id="1419" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要使用它，我们必须用<code class="fe mh mi mj mk b">thunkMiddleware</code>作为参数来调用<code class="fe mh mi mj mk b">applyMiddleware</code>。</p><p id="ff10" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以创建一个动作创建器，它返回一个函数，函数的第一个和第二个参数分别是<code class="fe mh mi mj mk b">dispatch</code>和<code class="fe mh mi mj mk b">getState</code>，然后我们可以像往常一样用<code class="fe mh mi mj mk b">getState</code>得到状态。</p></div></div>    
</body>
</html>