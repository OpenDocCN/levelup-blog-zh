<html>
<head>
<title>Smart Typescript Bulk Property Assignment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">智能类型脚本批量属性分配</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/smart-typescript-bulk-property-assignment-52162c1031da?source=collection_archive---------15-----------------------#2020-08-24">https://levelup.gitconnected.com/smart-typescript-bulk-property-assignment-52162c1031da?source=collection_archive---------15-----------------------#2020-08-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/18b1f59b84b2288ff2db76480aad761f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gfiEu4u8P8OlLslUnXaokw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">马特·施瓦茨在<a class="ae kc" href="https://unsplash.com/s/photos/bulk?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="6ee5" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">目标</h1><p id="0ed1" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我希望我在TypeScript代码中使用的对象允许我一次对它们设置多个属性。我的对象必须有一个方法<code class="fe lz ma mb mc b">setProps</code>,这样当给定一个正确类型的属性映射时，该方法在对象上设置相应的属性。</p><h1 id="8faa" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">方法</h1><p id="2d43" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我有一个基类，比如说<code class="fe lz ma mb mc b">BaseObject</code>，它有公共的<code class="fe lz ma mb mc b">setProps</code>方法。<code class="fe lz ma mb mc b">setProps</code>必须采用与从BaseClass派生的类的实例兼容的参数。这是通过泛型实现的。该方法将类似于下面这段代码:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="af8c" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">我使用语法<code class="fe lz ma mb mc b">&lt;T extends BaseObject&gt;</code>约束类型参数<code class="fe lz ma mb mc b">T</code>来表示从<code class="fe lz ma mb mc b">BaseObject</code>继承的类型。</p><p id="3147" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">现在，我想将传递的参数的属性赋给调用了<code class="fe lz ma mb mc b">setProps</code>的对象。为了实现这一点，我按照下面的摘录进行操作:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="6096" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated"><code class="fe lz ma mb mc b">for in </code>循环获取<code class="fe lz ma mb mc b">values </code>中的所有键，对于每个这样的属性，如果它的值不为空，就将其分配给调用对象上的相同属性。</p><p id="0c39" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">现在我想确定在<code class="fe lz ma mb mc b">for in</code>循环中没有考虑方法。出于这个原因，我将使用<a class="ae kc" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types" rel="noopener ugc nofollow" target="_blank">映射类型</a>和npm包<a class="ae kc" href="https://github.com/piotrwitek/utility-types" rel="noopener ugc nofollow" target="_blank">实用类型</a>，顾名思义，它提供了TypeScript实用类型。我将使用由<code class="fe lz ma mb mc b">utility-types</code>提供的<code class="fe lz ma mb mc b">NonFunctionKeys</code>来定义以下内容:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="8727" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">上面，我们使用类型级编程和表达式<code class="fe lz ma mb mc b">{[P in NonFunctionKeys&lt;T&gt;]:T[P]}</code>来简单说明应用于类型参数T的<code class="fe lz ma mb mc b">OnlyProperties</code>是一个仅由T的非方法键组成的类型。如果您还没有这样做，我强烈建议您熟悉TypeScript <a class="ae kc" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types" rel="noopener ugc nofollow" target="_blank">映射类型</a>。它们真的很有用。</p><p id="bde0" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">我们新创建的类型将同样用于<code class="fe lz ma mb mc b">setProps</code>:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="3263" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">通过说我想要属性的批量设置，我也暗示了所述属性的<strong class="ld ir">部分</strong>设置。为了实现这一点，我将利用Typescript提供的<a class="ae kc" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype" rel="noopener ugc nofollow" target="_blank">部分</a>实用程序类型的帮助。对于传递给它的任何类型，它使该对象的所有属性都是可选的。使用<code class="fe lz ma mb mc b">Partial,</code>我将能够编写以下类型:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="41f8" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">因此，我们现在把<code class="fe lz ma mb mc b">setProps</code>定义为:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="91de" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">下面是<code class="fe lz ma mb mc b">setProps</code>的用法示例:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="5ab7" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">请注意，如果<code class="fe lz ma mb mc b">setProps</code>的参数不是O类型，它将无法通过编译器检查，因为我提供了O类型参数。</p><h1 id="f7ed" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">奖金</h1><p id="7144" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当我们几乎可以免费获得一个<strong class="ld ir">批量属性赋值构造函数</strong>时，为什么要止步于此呢？在从<code class="fe lz ma mb mc b">BaseObject</code>派生的任何类上，可以使用<code class="fe lz ma mb mc b">setProps</code>获得批量属性赋值构造函数，如下所示:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><h1 id="3970" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="74bc" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">使用泛型和映射类型，我们可以在TypeScript对象上实现<strong class="ld ir">类型安全的批量赋值</strong>。当一个对象的属性数量变得很大，并且编写所有的赋值变得很繁琐时，这一点特别有用。</p><p id="5e0a" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated"><em class="mo">本条代码见https://github.com/kanian/setProps</em><a class="ae kc" href="https://github.com/kanian/setProps" rel="noopener ugc nofollow" target="_blank"><em class="mo"/></a><em class="mo">。</em></p><p id="60a4" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">你可以通过gmail.com联系到我</p></div></div>    
</body>
</html>