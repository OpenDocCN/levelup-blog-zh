# 使用 React 时我如何编码

> 原文：<https://levelup.gitconnected.com/how-i-code-when-i-work-with-react-5f8a554fd68a>

![](img/6277ae06963462b7e4c8d4186d81d27c.png)

图片摘自:[http://blog.desafiolatam.com/conociendo-mas-sobre-react/](http://blog.desafiolatam.com/conociendo-mas-sobre-react/)

我喜欢 React，我甚至可以说我很擅长用它编码。我既不是专家，也不是初学者。除了弄清楚如何使用 API 之外，你在使用 React 时可能会遇到的一个困难是，你必须记住你现在和将来可能一起工作的人。在我看来，当我使用 React 时，最重要的是尽可能保持一切清晰、整洁和易读(我也考虑性能)。

# 总是在函数中思考

这一点你可能已经知道了。我见过一些同事在查看代码时遇到困难。他们搞不清什么是组件，什么是控制器，因为有太多代码很难遵循您公司使用的某种模式。

在函数中思考意味着:开始编写一个简单的函数，如果它变得太冗长，就转到一个类，但是尽量避免这样做。此外，如果你需要对一个组件的生命周期有更多的控制，一定要选择一个类。但是总是从函数开始思考。

我们可以用不同的方式将组件声明为一个函数。我想区分作为组件的函数和需要处理一些数据并返回结果或触发一些动作的函数。我声明属性的方式和开始使用析构的地方对我来说也很重要。

当我处理无状态组件时，我喜欢使用匿名函数和析构括号之间的属性。我为什么要这么做？：

*   一个无状态组件和一个可能是控制器的组件之间的区别。
*   **代码更少:**这只是视觉上的东西，是我在代码上做的事情。易于阅读和维护。

可能还有另一种情况，这个组件管理它内部的一些状态。在这种情况下，我遵循一些规则，它们也适用于由函数组成的容器，而不是从`Component`或`PureComponent`扩展而来的容器。

*   组件中的任何函数必须**不是**是匿名函数，只是普通的函数声明。
*   我在需要的地方使用析构，并认为总是在作用域内。
*   我将所有内容保存在**块**中。挂钩/功能/道具/组件。
*   如果我使用`useState`，我更喜欢保留众所周知的变量和函数`state`和`setState`。
*   I **不要**对状态使用析构。我喜欢知道哪些变量来自道具，哪些来自状态。
*   就是你在用`useState`，你的状态长大了，你应该转到`useReducer`。

# 命名功能

有时用通用名称命名函数是简单明了的。但是我们可以有很多功能，我们需要在它们之间创造差异。

对于由**事件**触发的功能——点击一个按钮——我所做的是从**一般**到**特定**使功能易于理解。这很重要；代码不仅仅是算法，更是用文字解释思想。

*   **一般:**开始使用事件名称作为前缀:`onClick`、`onMouseDown`、`onChange`等。
*   **具体:**是哪里触发了这些行动？我经常使用组件或其一部分的名称。有时候是要触发功能的动作:`onClickNewUser`、`onChangeTitle`、`onClickDeleteAccount`。
*   **有所作为:**在函数末尾添加 Handler。这是你可以在很多教程、视频、文章等等中找到的东西。这是一个很好的实践，有助于我们区分事件功能和正常事件。

# 不要重复装载和卸载

在某些情况下隐藏或显示一个**组件**是很常见的。这对于小型应用程序来说没什么大不了的，但是对于大型应用程序来说，这可能是节省内存和使应用程序流畅的一种方式。当然，这并不是一条黄金法则，有时我们实际上需要卸载一个组件并重新安装它。我们需要知道**何时**去做，以及**要做什么。我的建议是考虑像警告或模态这样的组件，或者带有动画的东西。您可以使用 CSS 类来隐藏它们，而不需要不断地卸载和安装组件。这个 CSS 类可以有:`display: none;`或者`opacity: 0;`甚至`visibility: hidden;`。用最适合自己的就好。**

# 一个组件内不超过 10 个函数

由于钩子的存在，我们可以在函数中使用状态，所以我们一直在用它们来制作轻便快速的组件。但是，我们**必须**记住，这个组件中的函数将由每次渲染使用内存空间再次创建。对于这种情况，我开发了一个心理指南。

*   如果我在一个无状态组件中有超过 10 个函数，并且它们有很多复杂的逻辑，我更喜欢使用从 T0 或 T1 扩展的组件。
*   如果我**有超过 10 个**函数，但是有些函数很简单，而**只有几个**，比如 2 个或 3 个函数很复杂，我将组件保持为无状态，但是我在复杂函数中使用了`useCallback`钩子。

# 如果它没有改变，只需创建一次并重复使用它

假设在一个数组中有一个世界上所有国家的列表。这可能会保持不变。如果您的组件也有一个城市列表，并且每次您选择一个不同的国家时这个列表都会被过滤，那该怎么办？这个流将不断地呈现我的组件。当然，如果您正在映射一个列表组件，那么**需要**使用一个惟一的 ID 并将其传递给`key`属性。但是，**在**之前，我们正在过滤城市列表，制作一个新的数组；这很好，因为我们有不变性，但是我们使用了额外的内存。对于这种情况，我们有很多解决方案。我要展示我更喜欢的那个。我利用`useMemo`钩。

> …仅当其中一个依赖关系发生变化时，才会重新计算记忆值。这种优化有助于避免每次渲染时进行昂贵的计算。… —摘自 React 文档。

*这只是一个例子*😅

`useMemo`的好处在于它返回我们之前过滤的内容，并且只在发生变化时创建一个新的对象或数组，否则它会一直使用相同的对象或数组。

# 各个击破

我们最终肯定会有一个大集装箱。导入这个容器或者多个容器可能会导致应用程序缓慢地渲染组件，出现几秒钟甚至更长时间的白屏。对于这种情况，我使用 React Lazy Load。React 为我们提供了一个函数和一个组件:`lazy`和`Suspense`。惰性函数用于**代码分割**，而暂挂组件帮助我们挂载这个“分割”的容器或组件，并在**不阻塞**其余容器或组件的情况下呈现它。

*   *`*React.lazy*`*功能可让您将动态导入渲染为常规组件。…然后惰性组件应该呈现在一个* `*Suspense*` *组件中，这允许我们在等待惰性组件加载时显示一些后备内容(如加载指示器)。—摘自 React 文档。**

*你可能想知道为什么我说你应该把它用于容器而不是组件。我个人这样做是因为按照上面的规则，我的组件会更小，没有功能或者只有几个功能。但是一个容器可以有更多的容器，它可以有很多功能。因此，这个文件将是一个很大的包，需要时间来处理请求。分割这个大文件将有助于你更快地加载代码，因为你将分派小块的代码。🚀*

# *检查你的道具类型*

*尽可能使用[道具类型库](https://www.npmjs.com/package/prop-types)检查道具类型。这将有助于你防止不一致通过你的道具。例如，如果您正在处理数据，并且您的组件必须接收某些类型的数据或结构(如对象数组),这将非常有用。使用道具类型的另一个好处是，当你使用 Storybook 和 addon-doc 来记录你的组件时，这将生成一个你的组件可以接收的道具类型的很好的文档。
( *增加:2020 年 6 月 15 日—世界末日之前💥)**

# *我非常个人的一个，我的目录:级联下降😁*

*我必须坚持。你的代码看起来怎么样很重要。在这段时间里，我开发了一些关于代码的 TOC。我一直在将它应用于 JS 和 CSS，我认为它很好，很干净，最重要的是，易于阅读。这不会改变您的编码能力或代码运行的效率。我再说一遍，**只是视觉上的东西。***

*   *所有变量都是按降序声明的。*
*   *使用`from`关键字作为参考，所有的进口都以降序声明。除了**主**库之外，它必须只有**一个**像 React，并且它总是在最前面。*
*   *析构也是按降序进行的。*
*   *变量在一起但不混合。*
*   *利用新的线路。不要把所有的代码紧密地放在一起。想象你正在写一本书，有人会去读它。*
*   *编写简单的代码。复杂不一定意味着“更好”和“更酷”。简单干净最好。(没错，我算是一个极简主义者)。*

*我给你看一个例子，你可以自己判断。*

*一些人告诉我他们更喜欢升序。我认为升序和降序都是很好的选择，肯定比让所有的导入和变量都变得混乱要好。感谢您的反馈！😃*

*所有这些我都试图应用到我的代码中。如果你检查我的 Github，我的一些项目可能不会遵循这一点，这是因为它们是旧的，我当时对编码有其他想法。但是我认为，阅读文章、书籍、与人交往、阅读他人的代码以及与许多不同的人一起工作，使我成为了一名更好的程序员。*

*感谢我的丈夫 J. Drake 帮我审阅这篇文章。❤️*

*我希望你喜欢它。干杯！*