<html>
<head>
<title>Setting Up a RabbitMQ Cluster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设置RabbitMQ集群</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/setting-up-rabbitmq-cluster-c247d61385ed?source=collection_archive---------0-----------------------#2021-01-23">https://levelup.gitconnected.com/setting-up-rabbitmq-cluster-c247d61385ed?source=collection_archive---------0-----------------------#2021-01-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/0e4b4f06a39faaf9f5a080db7b1ae51e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*4u72bulnveTqRWLR.png"/></div></figure><h1 id="7bbf" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">概观</h1><p id="d799" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在本文中，我们将在基于docker的环境中设置RabbitMQ集群。我们将从设置单个实例开始，之后，我们将添加更多配置以向集群添加更多节点，我们还将使用RabbitMQ的管理标记docker映像，因为它提供了管理插件。我们还将设置发布者和消费者来观看rabbitmq的运行。我们将设置一个3节点群集。</p><blockquote class="lq lr ls"><p id="935c" class="ks kt lt ku b kv lu kx ky kz lv lb lc lw lx lf lg ly lz lj lk ma mb ln lo lp ij bi translated"><strong class="ku ir"> <em class="iq">查看我的</em> </strong> <a class="ae mc" href="https://www.udemy.com/course/learn-to-deploy-hyperledger-fabric-v22-on-multihost/?referralCode=8AF12D11DDC9A3D5B636" rel="noopener ugc nofollow" target="_blank"> <strong class="ku ir"> <em class="iq">科目关于Hyperledger Fabric的部署关于多主机</em> </strong> </a></p></blockquote><h1 id="df78" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">1.建立工作关系网</h1><p id="8a9f" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">RabbitMQ节点由节点名标识。节点名由两部分组成，前缀(通常是<code class="fe md me mf mg b">rabbit</code>)和主机名。例如，<code class="fe md me mf mg b">rabbit@node1.messaging.svc.local</code>是一个节点名，前缀为<code class="fe md me mf mg b">rabbit</code>，主机名为<code class="fe md me mf mg b">node1.messaging.svc.local</code>。</p><p id="982a" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">群集中的节点名称必须唯一。如果给定主机上运行多个节点(这通常是开发和QA环境中的情况)，它们必须使用不同的前缀，例如<code class="fe md me mf mg b">rabbit1@hostname</code>和<code class="fe md me mf mg b">rabbit2@hostname</code>。</p><p id="b317" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">在集群中，节点使用节点名称来识别和联系彼此。这意味着每个节点名称的主机名部分都必须解析。</p><p id="170f" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">我们将保留主机名作为容器名，因此我们的节点名将是<code class="fe md me mf mg b">rabbit@rabbit-1</code>、<code class="fe md me mf mg b">rabbit@rabbit-2</code>、<code class="fe md me mf mg b">rabbit@rabbit-3</code>来运行我们的rabbitmq实例。</p><p id="b8a6" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">我们需要建立一个docker网络，以便我们的rabbitmq实例可以相互通信。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="5783" class="mp jv iq mg b gy mq mr l ms mt">docker network create rabbit</span></pre><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mu"><img src="../Images/32a80504374c0ed8173c4974e89f3da6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_iXL-UEo7mpDpGBWrRLLpw.png"/></div></div></figure><h1 id="b728" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">2.证明</h1><p id="f65b" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">RabbitMQ节点和CLI工具(例如<code class="fe md me mf mg b">rabbitmqctl</code>)使用cookie来确定它们是否被允许相互通信。为了让两个节点能够通信，它们必须拥有相同的共享秘密，称为<strong class="ku ir"> Erlang cookie </strong>。cookie只是一个最多255个字符的字母数字字符串。每个群集节点必须有相同的cookie。实例之间的通信也需要它。</p><p id="c46b" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">我们可以通过启动rabbitmq的一个实例来获取Erlang cookie，然后这个cookie需要与其他rabbitmq实例共享</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="122b" class="mp jv iq mg b gy mq mr l ms mt"># run a standalone instance<br/>docker run -d --rm --net rabbits --hostname rabbit-1 --name rabbit-1 rabbitmq:3.8<br/># how to grab existing erlang cookie<br/>docker exec -it rabbit-1 cat /var/lib/rabbitmq/.erlang.cookie<br/># clean up<br/>docker rm -f rabbit-1</span></pre><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mz"><img src="../Images/f0fd0e8aba7c02b6861a5c6aad76633f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UpxHhBdHf-7ltRI7jBWAyg.png"/></div></div></figure><h1 id="e11d" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">3.使聚集</h1><p id="5c39" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">RabbitMQ集群可以通过多种方式形成:</p><ul class=""><li id="288a" class="na nb iq ku b kv lu kz lv ld nc lh nd ll ne lp nf ng nh ni bi translated">通过在<a class="ae mc" href="https://www.rabbitmq.com/configure.html" rel="noopener ugc nofollow" target="_blank">配置文件</a>中列出集群节点</li><li id="69ec" class="na nb iq ku b kv nj kz nk ld nl lh nm ll nn lp nf ng nh ni bi translated">以声明方式使用基于DNS的发现</li><li id="39f9" class="na nb iq ku b kv nj kz nk ld nl lh nm ll nn lp nf ng nh ni bi translated">声明性地使用<a class="ae mc" href="https://github.com/rabbitmq/rabbitmq-peer-discovery-aws" rel="noopener ugc nofollow" target="_blank"> AWS (EC2)实例发现</a>(通过插件)</li><li id="e559" class="na nb iq ku b kv nj kz nk ld nl lh nm ll nn lp nf ng nh ni bi translated">声明性地使用<a class="ae mc" href="https://github.com/rabbitmq/rabbitmq-peer-discovery-k8s" rel="noopener ugc nofollow" target="_blank"> Kubernetes发现</a>(通过插件)</li><li id="6f0c" class="na nb iq ku b kv nj kz nk ld nl lh nm ll nn lp nf ng nh ni bi translated">声明性地使用<a class="ae mc" href="https://github.com/rabbitmq/rabbitmq-peer-discovery-consul" rel="noopener ugc nofollow" target="_blank">基于Consul的发现</a>(通过插件)</li><li id="bebc" class="na nb iq ku b kv nj kz nk ld nl lh nm ll nn lp nf ng nh ni bi translated">声明性地使用<a class="ae mc" href="https://github.com/rabbitmq/rabbitmq-peer-discovery-etcd" rel="noopener ugc nofollow" target="_blank">基于etcd的发现</a>(通过插件)</li><li id="17f2" class="na nb iq ku b kv nj kz nk ld nl lh nm ll nn lp nf ng nh ni bi translated">用<code class="fe md me mf mg b">rabbitmqctl</code>手动</li></ul><p id="8f6a" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">我们将使用第一种方法，即使用配置文件，也称为<strong class="ku ir">自动集群</strong>。</p><p id="e67f" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">因为我们是在基于容器的环境中运行实例，所以我们需要某种持久性，以便如果任何rabbitmq实例(容器)死亡，它不会丢失其状态并返回到先前的状态。为了实现持久性，我们需要将配置文件作为一个卷挂载到容器中。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/5cb2c34569214c43cfc5d25b908982df.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/1*OMNlL6kyOZfOffWqKfoYQA.png"/></div></figure><p id="d166" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">所有配置文件都包含相同的配置，详细信息包括发现方法的类型和节点名称。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="57ec" class="mp jv iq mg b gy mq mr l ms mt"><strong class="mg ir">loopback_users.guest</strong> = false</span><span id="8ab4" class="mp jv iq mg b gy np mr l ms mt"><strong class="mg ir">listeners.tcp.default</strong> = 5672</span><span id="8087" class="mp jv iq mg b gy np mr l ms mt"><strong class="mg ir">cluster_formation.peer_discovery_backend</strong> = rabbit_peer_discovery_classic_config</span><span id="157b" class="mp jv iq mg b gy np mr l ms mt"><strong class="mg ir">cluster_formation.classic_config.nodes.1</strong> = rabbit@rabbit-1</span><span id="be7e" class="mp jv iq mg b gy np mr l ms mt"><strong class="mg ir">cluster_formation.classic_config.nodes.2</strong> = rabbit@rabbit-2</span><span id="ef68" class="mp jv iq mg b gy np mr l ms mt"><strong class="mg ir">cluster_formation.classic_config.nodes.3</strong> = rabbit@rabbit-3</span></pre><p id="6b53" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">创建多个配置文件而不是一个文件的原因是rabbitmq需要对配置文件的读写权限，这些实例将会覆盖配置文件。为了避免这种覆盖问题，我们需要多个文件。</p><p id="4d27" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">现在，我们可以使用我们生成的<strong class="ku ir"> Erlang Cookie </strong>以及挂载<strong class="ku ir">配置文件</strong>来启动所有三个节点。</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ns"><img src="../Images/fb12532f9e0651a31fa9f1a4bf769cfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H7yc_S41bx0DlLwAtlj9JA.png"/></div></div></figure><p id="3da8" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">现在，如果我们访问管理控制台(http://localhost:8081)，我们可以将所有3个节点连接在一起，形成一个集群。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nt"><img src="../Images/6f531d3a7eaf091e9131959a6383d5de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5g_47GLpVcdQxEBpnmpVVA.png"/></div></div></figure><h1 id="3d5a" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">4.分身术</h1><p id="144d" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">RabbitMQ代理操作所需的所有数据/状态都在所有节点上复制。一个例外是消息队列，默认情况下，消息队列驻留在一个节点上，尽管它们在所有节点上都是可见和可达的。若要跨群集中的节点复制队列，请使用支持复制的队列类型。</p><p id="1059" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">这意味着，如果任何消费者应用程序连接到任何节点，并且如果该节点死亡，则队列中存在的消息也将消失。</p><p id="4280" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">为了解决这个问题<strong class="ku ir">镜像</strong>出现了。</p><h1 id="7da1" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak"> 5。镜子</strong></h1><p id="beb0" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">默认情况下，RabbitMQ集群中队列的内容位于单个节点上(声明队列的节点)。这与交换和绑定相反，交换和绑定总是可以被认为是在所有节点上。队列可以有选择地在多个节点上被镜像。</p><p id="8738" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">每个镜像队列由一个<em class="lt">主</em>和一个或多个<em class="lt">镜像</em>组成。主节点位于一个通常称为主节点的节点上。每个队列都有自己的主节点。给定队列的所有操作首先应用于队列的主节点，然后传播到镜像。镜像允许我们将队列和数据镜像到所有节点。</p><p id="9ad7" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">可以使用策略设置镜像。策略按名称匹配一个或多个队列(使用正则表达式模式)，并包含一个定义(可选参数的映射),该定义被添加到匹配队列的总属性集中。</p><p id="b2d7" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">让我们为所有节点设置镜像，但在此之前，我们需要启用联盟插件。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="37d6" class="mp jv iq mg b gy mq mr l ms mt">docker exec -it rabbit-1 rabbitmq-plugins enable rabbitmq_federation</span><span id="4f8c" class="mp jv iq mg b gy np mr l ms mt">docker exec -it rabbit-2 rabbitmq-plugins enable rabbitmq_federation</span><span id="4e7d" class="mp jv iq mg b gy np mr l ms mt">docker exec -it rabbit-3 rabbitmq-plugins enable rabbitmq_federation</span></pre><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nu"><img src="../Images/62bfb1e9a1cddca99950315eecef8f7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7etLGQDS-Jg6AvTPV9e4LA.png"/></div></div></figure><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="1aac" class="mp jv iq mg b gy mq mr l ms mt">docker exec -it rabbit-1 bash<br/>rabbitmqctl set_policy ha-fed \<br/>    ".*" '{"federation-upstream-set":"all","ha-sync-mode":"automatic", "ha-mode":"nodes", "ha-params":["rabbit@rabbit-1","rabbit@rabbit-2","rabbit@rabbit-3"]}' \<br/>    --priority 1 \<br/>    --apply-to queues</span></pre><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nv"><img src="../Images/ffed6f1dd47aabf9aab4cde0a4da99ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z8neM02p9A0X1puhDGAUuw.png"/></div></div></figure><h1 id="7252" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">6.应用</h1><p id="8799" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">现在我们将创建两个应用程序，一个是发布者，另一个是消费者。发布者将负责向队列提供数据。消费者将在终端消费数据。</p><p id="ae1e" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">执行这些操作的队列的名称将是<code class="fe md me mf mg b">publisher</code>。</p><p id="1aa8" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">我已经在golang上创建了publisher应用程序。发布者将消息放入队列，然后使用者从队列中读取消息。消费者应用程序构建在NodeJS之上。</p><p id="3f1f" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">要构建和运行publisher应用程序，请运行:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="af7a" class="mp jv iq mg b gy mq mr l ms mt">docker build ./applications/publisher -t aditya/rabbitmq-publisher:v1.0.0</span><span id="71f5" class="mp jv iq mg b gy np mr l ms mt">docker run -it --rm --net rabbits -e RABBIT_HOST=rabbit-1 -e RABBIT_PORT=5672 -e RABBIT_USERNAME=guest -e RABBIT_PASSWORD=guest -p 80:80 aditya/rabbitmq-publisher:v1.0.0</span></pre><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nw"><img src="../Images/90c8e863f0538bde211607276898fc13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cnc9XaGxU90IuG61J7gfqw.png"/></div></div></figure><p id="63f5" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">要构建和运行消费者应用程序，请打开一个新的终端窗口并运行:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="ba42" class="mp jv iq mg b gy mq mr l ms mt">docker build ./applications/consumer -t aditya/rabbitmq-consumer:v1.0.0</span><span id="fcb4" class="mp jv iq mg b gy np mr l ms mt">docker run -it --rm --net rabbits -e RABBIT_HOST=rabbit-1 -e RABBIT_PORT=5672 -e RABBIT_USERNAME=guest -e RABBIT_PASSWORD=guest aditya/rabbitmq-consumer:v1.0.0</span></pre><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nx"><img src="../Images/cb82260eccc7f90fc9945cd1e06d81c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ApwwNsJxQkOxTZ4VaaQ7A.png"/></div></div></figure><p id="af59" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">现在要测试应用程序，打开另一个终端并运行:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="75c1" class="mp jv iq mg b gy mq mr l ms mt">curl -X POST localhost:80/publish/hello</span></pre><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ny"><img src="../Images/131f2f3c07799a64a24ab911bbfa9a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TdNv_zJKKVkFXot3Esh4Lg.png"/></div></div></figure><p id="8d4b" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">您可以看到消费者应用程序已经收到了通过发布者应用程序发送的消息。</p><h1 id="da7d" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">7.摘要</h1><p id="6831" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在本文中，我们学习了如何设置一个3节点rabbitmq集群，首先使用Erlang Cookie设置身份验证，然后设置复制和队列镜像，最后设置发布者和消费者应用程序。你可以在这里找到<a class="ae mc" href="https://github.com/adityajoshi12/rabbitmq-clustering" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p><p id="cdab" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">如果你觉得这篇文章很有帮助，请点击拍手按钮，并跟随我阅读更多这样的信息丰富的文章。</p><p id="8916" class="pw-post-body-paragraph ks kt iq ku b kv lu kx ky kz lv lb lc ld lx lf lg lh lz lj lk ll mb ln lo lp ij bi translated">你可以在<a class="ae mc" href="https://linkedin.com/in/adityajoshi12" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上找到我或者在<a class="ae mc" href="https://github.com/adityajoshi12" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上跟踪我？如果这对你来说太社交化了，如果你想和我讨论技术，就给adityaprakashjoshi1@gmail.com发封邮件。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nz"><img src="../Images/4449684cd6936a1044add35f91907b49.png" data-original-src="https://miro.medium.com/v2/resize:fit:292/0*Su-xfnCZXENoakwc.gif"/></div></div></figure></div></div>    
</body>
</html>