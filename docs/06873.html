<html>
<head>
<title>Building One of the Fastest PHP Routers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建最快的PHP路由器之一</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-one-of-the-fastest-php-routers-dd466e51b04f?source=collection_archive---------2-----------------------#2021-01-10">https://levelup.gitconnected.com/building-one-of-the-fastest-php-routers-dd466e51b04f?source=collection_archive---------2-----------------------#2021-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6df814c2b39fe9fff79fc604161c71d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nYRcPVDDPlMMfHZ-"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@marcojodoin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马克-奥利维尔·乔多因</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9e18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">免责声明:</strong>几乎所有的PHP路由库都快<em class="lb">够</em>。它们几乎不会成为应用程序的瓶颈，这意味着您应该更多地关注路由器的功能，而不是速度。这不仅仅是对Aphiria路由器背后的算法的有趣探索。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="631f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两年前，我开始做一个PHP路由器。我之前已经为<a class="ae kc" href="https://www.opulencephp.com/docs/1.1/routing" rel="noopener ugc nofollow" target="_blank">populance</a>构建了一个，但是我对额外的功能感兴趣，比如<a class="ae kc" href="https://www.aphiria.com/docs/1.x/routing.html#route-constraints" rel="noopener ugc nofollow" target="_blank">自定义约束</a>，它允许你匹配头文件(对于基于头文件的API版本控制很有用)。我对速度并不感兴趣，直到我读到尼基塔·波波夫对他的基于正则表达式的图书馆快捷路线的精彩分析。我最初采用了与FastRoute非常相似的匹配方法，但无法摆脱一个我认为可能与他的算法竞争的想法——基于树的路由。</p><p id="19dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，假设我的API中有以下路线:</p><ul class=""><li id="9a0e" class="lj lk iq kf b kg kh kk kl ko ll ks lm kw ln la lo lp lq lr bi translated"><code class="fe ls lt lu lv b">users</code></li><li id="a811" class="lj lk iq kf b kg lw kk lx ko ly ks lz kw ma la lo lp lq lr bi translated"><code class="fe ls lt lu lv b">users/:id</code></li><li id="6b02" class="lj lk iq kf b kg lw kk lx ko ly ks lz kw ma la lo lp lq lr bi translated"><code class="fe ls lt lu lv b">users/:id/avatar</code></li><li id="48cb" class="lj lk iq kf b kg lw kk lx ko ly ks lz kw ma la lo lp lq lr bi translated"><code class="fe ls lt lu lv b">users/:id/email</code></li></ul><p id="4117" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望为匹配生成以下树结构:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/ad54adcae5686e8b16325ed0bf5ffec3.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*Z029Nmy3qpg5ZF8jumCrDw.png"/></div></figure><p id="7f5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在计算机科学中，这种数据结构被称为“<a class="ae kc" href="https://en.wikipedia.org/wiki/Trie" rel="noopener ugc nofollow" target="_blank"> trie </a>”(发音就像“树”)。每个节点与所有其他兄弟节点共享相同的前缀。</p><h1 id="bebf" class="mg mh iq bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">该算法</h1><p id="5d01" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">我的算法使用<a class="ae kc" href="https://en.wikipedia.org/wiki/Depth-first_search" rel="noopener ugc nofollow" target="_blank">深度优先搜索</a>在trie中寻找匹配路径。对于静态的，即不可变的段，我使用一个简单的哈希表对每个段进行O(1)查找，如果没有找到匹配，我迭代可变段进行匹配，得到O(n ),其中n是在该trie级别的可变节点的数量。我继续向下搜索trie，直到找到匹配的候选对象或者找不到，结果是404。最后一步是遍历匹配候选项上的任何路由约束，例如确保匹配候选项接受请求HTTP方法。如果所有约束都通过，那么这就是匹配路线。否则，我<a class="ae kc" href="https://www.php.net/manual/en/language.generators.syntax.php" rel="noopener ugc nofollow" target="_blank">返回</a>任何其他匹配候选项，直到我找到一个，或者返回404或415，这取决于是否用不同的HTTP方法找到了任何匹配候选项。Yield returns很有用，因为我不必在选择一个之前先收集所有可能的匹配候选，这样<em class="lb">会产生</em>轻微的性能改进。</p><p id="18fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">算法的运行时间取决于路径中的线段数(我们称之为n)。在所有静态路由的最佳情况下，运行时间为O(n ),在最差情况下为O(nm ),其中m是每个段的可变段的平均数量。</p><h1 id="c4b4" class="mg mh iq bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">一个例子</h1><p id="f9cb" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">假设请求路径是<code class="fe ls lt lu lv b">/users/123/email</code>。我将扫描我们的路由trie寻找<code class="fe ls lt lu lv b">users</code>，并在O(1)中找到一个匹配，因为它作为静态段存在于trie中。然后，我将从<code class="fe ls lt lu lv b">users</code>节点搜索<code class="fe ls lt lu lv b">123</code>，但是没有找到静态匹配。所以，我会迭代变量节点，直到找到匹配。在这种情况下，<code class="fe ls lt lu lv b">:id</code>节点没有任何<a class="ae kc" href="https://www.aphiria.com/docs/1.x/routing.html#route-variable-constraints" rel="noopener ugc nofollow" target="_blank">变量约束</a>，所以它将匹配任何值。然后，我在<code class="fe ls lt lu lv b">:id</code>的子节点中搜索<code class="fe ls lt lu lv b">email</code>，再次在O(1)中找到一个匹配的静态节点。trie将告诉我们,<code class="fe ls lt lu lv b">email</code>节点映射到特定的路由，并且是匹配的候选。在这种情况下，我假设路径约束全部通过，并返回此路径作为匹配。</p><h1 id="a376" class="mg mh iq bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">基准测试结果</h1><p id="2023" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">那么，这个算法与FastRoute相比如何呢？我看了看网上的几个基准测试，但发现它们都有问题，例如，不切实际的长URIs有9个路段，或者只测试匹配集合中的第一条或最后一条路线。我决定<a class="ae kc" href="https://github.com/aphiria/aphiria/blob/1.x/src/Router/bin/benchmarks.php" rel="noopener ugc nofollow" target="_blank">写一个基准</a>，匹配<em class="lb">400条路径中的每一条路径</em>。结果是:Aphiria的算法比FastRoute的快175%,但是落后于Symfony的优秀路由器大约相同的差距。</p><p id="1895" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我确信我可以做一些微优化来稍微提高Aphiria的速度(例如尝试一次匹配多个静态段)，但是它们几乎肯定会以增加复杂性为代价。Aphiria的路由器目前有3976条线路(仅匹配就有123条)，而Symfony的路由器有6727条(不包括测试)。然而，考虑到这三个库的速度都足够快，我对缩小与Symfony的差距并不特别感兴趣。也就是说，尼古拉斯·格雷卡斯和社区取得了这样的速度。</p><h1 id="ffcf" class="mg mh iq bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">结论</h1><p id="5ab7" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">重申一下——几乎所有的PHP路由器都足够快。为什么我觉得你应该用Aphiria的？它支持:</p><ul class=""><li id="d8b1" class="lj lk iq kf b kg kh kk kl ko ll ks lm kw ln la lo lp lq lr bi translated">PHP 8.0 <a class="ae kc" href="https://www.aphiria.com/docs/1.x/routing.html#route-attributes" rel="noopener ugc nofollow" target="_blank">属性</a> <strong class="kf ir">和</strong> <a class="ae kc" href="https://www.aphiria.com/docs/1.x/routing.html#route-builders" rel="noopener ugc nofollow" target="_blank">流畅生成器</a>语法</li><li id="3f4d" class="lj lk iq kf b kg lw kk lx ko ly ks lz kw ma la lo lp lq lr bi translated">匹配路径和主机</li><li id="9d13" class="lj lk iq kf b kg lw kk lx ko ly ks lz kw ma la lo lp lq lr bi translated"><a class="ae kc" href="https://www.aphiria.com/docs/1.x/routing.html#versioned-api-example" rel="noopener ugc nofollow" target="_blank">自定义路由约束</a>可以使用请求的任何部分来匹配路由，例如API版本控制的报头匹配</li><li id="5d30" class="lj lk iq kf b kg lw kk lx ko ly ks lz kw ma la lo lp lq lr bi translated"><a class="ae kc" href="https://www.aphiria.com/docs/1.x/routing.html#route-attributes-groups" rel="noopener ugc nofollow" target="_blank">路线分组</a></li><li id="129c" class="lj lk iq kf b kg lw kk lx ko ly ks lz kw ma la lo lp lq lr bi translated">将与框架无关的中间件绑定到路由</li><li id="6e48" class="lj lk iq kf b kg lw kk lx ko ly ks lz kw ma la lo lp lq lr bi translated"><a class="ae kc" href="https://www.aphiria.com/docs/1.x/routing.html#creating-route-uris" rel="noopener ugc nofollow" target="_blank">根据路线名称创建URIs</a></li><li id="74b2" class="lj lk iq kf b kg lw kk lx ko ly ks lz kw ma la lo lp lq lr bi translated">除了Aphiria的<a class="ae kc" href="https://www.aphiria.com/docs/1.x/reflection.html" rel="noopener ugc nofollow" target="_blank">反射库</a>之外，没有任何框架库</li></ul><p id="3268" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想试用Aphiria的路由器，你可以<a class="ae kc" href="https://www.aphiria.com/docs/1.x/installation.html" rel="noopener ugc nofollow" target="_blank">安装框架应用程序</a>来快速启动并运行，或者<a class="ae kc" href="https://packagist.org/packages/aphiria/router" rel="noopener ugc nofollow" target="_blank">通过Composer只安装库</a>。</p><p id="09e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢<a class="ae kc" href="https://www.obsessedcoder.com/" rel="noopener ugc nofollow" target="_blank">詹姆斯·拉普</a>倾听我对算法的无尽思考，并作为优化的共鸣板。</p><h1 id="3517" class="mg mh iq bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">链接</h1><ul class=""><li id="c3d8" class="lj lk iq kf b kg ne kk nf ko nj ks nk kw nl la lo lp lq lr bi translated"><a class="ae kc" href="https://www.aphiria.com/docs/1.x/routing.html" rel="noopener ugc nofollow" target="_blank"> Aphiria路由器文档</a></li><li id="0ec6" class="lj lk iq kf b kg lw kk lx ko ly ks lz kw ma la lo lp lq lr bi translated"><a class="ae kc" href="https://github.com/aphiria/aphiria/blob/1.x/src/Router/src/Matchers/TrieRouteMatcher.php" rel="noopener ugc nofollow" target="_blank">路径匹配器来源</a></li><li id="3435" class="lj lk iq kf b kg lw kk lx ko ly ks lz kw ma la lo lp lq lr bi translated"><a class="ae kc" href="https://github.com/aphiria/aphiria/blob/1.x/src/Router/src/UriTemplates/Compilers/Tries/TrieCompiler.php" rel="noopener ugc nofollow" target="_blank"> Trie编译器源代码</a></li><li id="e9b9" class="lj lk iq kf b kg lw kk lx ko ly ks lz kw ma la lo lp lq lr bi translated"><a class="ae kc" href="https://github.com/aphiria/aphiria/blob/1.x/src/Router/src/UriTemplates/Lexers/UriTemplateLexer.php" rel="noopener ugc nofollow" target="_blank"> URI模板词法分析器来源</a></li><li id="d00c" class="lj lk iq kf b kg lw kk lx ko ly ks lz kw ma la lo lp lq lr bi translated"><a class="ae kc" href="https://github.com/aphiria/aphiria/blob/1.x/src/Router/src/UriTemplates/Parsers/UriTemplateParser.php" rel="noopener ugc nofollow" target="_blank"> URI模板解析器源码</a></li></ul></div></div>    
</body>
</html>