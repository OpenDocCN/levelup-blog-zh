<html>
<head>
<title>Abstraction vs Encapsulation: Can You Quickly Tell What the Difference Is?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">抽象vs封装:你能很快看出区别吗？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/abstraction-vs-encapsulation-can-you-quickly-tell-whats-the-difference-f676dfae1751?source=collection_archive---------0-----------------------#2022-09-25">https://levelup.gitconnected.com/abstraction-vs-encapsulation-can-you-quickly-tell-whats-the-difference-f676dfae1751?source=collection_archive---------0-----------------------#2022-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1778" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">C#示例。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5e8e9a85671ce8e47907087008fee6ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IPfeIN4w5xn4oH82"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@safarslife?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">萨法尔·萨法罗夫</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3883" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">封装和抽象是基本的编程概念。理解并定期应用它们可以极大地提高软件的质量，并使其更易于维护。然而，这两个术语经常互换使用，尽管它们之间有明显的界限。</p><p id="0313" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我建议理解封装和抽象概念之间的区别，而不求助于任何维基百科的定义或聪明的词语，而是简单地使用小代码示例。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cd94" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">封装到底是什么？</h1><p id="9c75" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">封装有助于将对象的状态保持在<strong class="lb iu">有效</strong>和<strong class="lb iu">一致</strong>的状态。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2d2b" class="ne md it na b gy nf ng l nh ni">public class Email<br/>{<br/>   public string EmailAddress { get; set; }<br/>}</span></pre><p id="3db5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">Email</code>对象是否被正确封装？绝对不是。<code class="fe nj nk nl na b">Email</code> object的消费者<em class="nm">(任何处理对象的代码)</em>不仅可以将<code class="fe nj nk nl na b">EmailAddress</code>属性设置为有效的电子邮件地址，还可以设置为C#中的<code class="fe nj nk nl na b">string</code>类型允许的任何值:null、空字符串、‘qwerty’等。</p><p id="95d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个问题，因为任何使用<code class="fe nj nk nl na b">Email</code>类型的人都必须总是验证<code class="fe nj nk nl na b">EmailAddress</code>属性，以确保总是有一个有效值。即使<code class="fe nj nk nl na b">Email</code>对象现在包含一个有效的电子邮件地址，也不能保证以后没有人会设置一个无效的值。</p><p id="d77d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">允许对象在创建时只初始化一次，这样就没有人能在对象创建后更改它的属性，这样如何？</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f6dc" class="ne md it na b gy nf ng l nh ni">public class Email<br/>{<br/>    public Email(string emailAddress)<br/>    {<br/>        EmailAddress = emailAddress;<br/>    }</span><span id="8d6d" class="ne md it na b gy nn ng l nh ni">    public string EmailAddress { get; <strong class="na iu">private </strong>set; }<br/>}</span></pre><p id="9dfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">setter是私有的，初始化对象的唯一方法是向构造函数传递一个电子邮件地址。这比public setter要好，但是仍然没有实现封装。消费者仍然可以在对象创建期间设置无效的电子邮件值。</p><p id="3fd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，为了实现正确的封装，<code class="fe nj nk nl na b">Email</code>类型本身必须以正确和一致的状态维护其数据，如下例所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1f78" class="ne md it na b gy nf ng l nh ni">public class Email<br/>{<br/>    public Email(string emailAddress) <br/>    {<br/>        if (!IsValid(emailAddress))<br/>        {<br/>           throw new ArgumentException("Email address is invalid.");<br/>        }<br/>    <br/>        EmailAddress = emailAddress;<br/>    }</span><span id="b33b" class="ne md it na b gy nn ng l nh ni">    public string EmailAddress { get; private set; }</span><span id="2eb0" class="ne md it na b gy nn ng l nh ni">    private bool IsValid(string emailAddress)<br/>    {<br/>        var match = Regex.Match(<br/>            emailAddress,<br/>            "^\\S+@\\S+$",<br/>            RegexOptions.IgnoreCase);</span><span id="87c8" class="ne md it na b gy nn ng l nh ni">        return match.Success;<br/>    }<br/>}</span></pre><blockquote class="no np nq"><p id="1d32" class="kz la nm lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated">封装完成！现在，不能在无效状态下创建对象，并且在对象的生存期内，外部代码不能将状态从有效更改为无效。</p></blockquote><p id="6c79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对象不一定要验证构造函数中的数据，如果数据是坏的就抛出异常。还有一些其他方法来维护对象的有效和一致状态，比如接受已经有效的数据，返回<code class="fe nj nk nl na b">true/false</code>或<code class="fe nj nk nl na b">Result&lt;T&gt;</code>而不是抛出异常，在方法中验证数据，等等。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9787" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">抽象到底是什么？</h1><p id="53cc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">抽象的原则是创建一个简单的接口并向消费者公开，并向他们隐藏不必要的细节。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a3eb" class="ne md it na b gy nf ng l nh ni">public interface IJsonFileParser<br/>{<br/>    bool Exists(string filePath);<br/>    Stream GetFileStream(string filePath);<br/>    T Parse&lt;T&gt;(Stream stream);<br/>    Dispose(Stream stream);<br/>}</span></pre><p id="31e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">IFileParser</code>接口可以被需要解析一些JSON文件内容到一个对象的消费者使用。然而，这个接口并不真正方便，因为消费者可能忘记调用<code class="fe nj nk nl na b">Exists</code>方法，或者将错误的<code class="fe nj nk nl na b">Stream</code>对象传递给<code class="fe nj nk nl na b">Parse&lt;T&gt;</code>方法，忘记调用<code class="fe nj nk nl na b">Dispose</code>方法，混淆调用顺序等等。</p><p id="65e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，该接口向消费者公开了文件解析的不必要的实现细节，比如关于<code class="fe nj nk nl na b">Stream</code>类型的知识。</p><p id="3feb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该接口可能从消费者那里抽象出一些细节，比如打开文件、读取文件内容、将文件反序列化为对象。然而，这里有更多的空间进行适当的抽象，所以让我们改进一下<code class="fe nj nk nl na b">IJsonFileParser</code>接口:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b602" class="ne md it na b gy nf ng l nh ni">public interface IJsonFileParser<br/>{<br/>    T Parse&lt;T&gt;(string filePath); <br/>}</span></pre><p id="7a9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在只有一种方法<code class="fe nj nk nl na b">Parse&lt;T&gt;</code>是消费者应该处理的。在一个<code class="fe nj nk nl na b">Parse&lt;T&gt;</code>方法的实现中，旧的接口暴露的所有其他细节，比如检查文件的存在，创建/处理流，应该对消费者完全隐藏。这将大大简化消费者代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6ba1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">总结抽象和封装之间的区别</h1><ul class=""><li id="dde4" class="nu nv it lb b lc mu lf mv li nw lm nx lq ny lu nz oa ob oc bi translated">封装确保对象的状态总是有效和一致的。抽象确保消费者拥有尽可能简单的接口来处理对象。</li><li id="a3f8" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">抽象可以在不实现封装的情况下实现，反之亦然。</li><li id="b40c" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">封装是一个定性单位<em class="nm">(对象被封装了吗？—是或否)</em>，而抽象是量化的<em class="nm">(界面使用起来有多容易？—容易，不那么容易，难，相当难……)。</em></li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="236e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。如果你喜欢你所读到的，看看下面这个故事:</p><div class="oi oj gp gr ok ol"><a href="https://betterprogramming.pub/5-ways-to-implement-factory-design-pattern-in-c-382c0992a3ff" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">在C#中实现工厂设计模式的5种方法</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">静态、异步、参数化、内部和抽象工厂</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">better编程. pub</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div><p id="48ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有，考虑成为<a class="ae ky" href="https://esashamathews.medium.com/membership" rel="noopener">中等会员</a>。</p></div></div>    
</body>
</html>