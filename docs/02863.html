<html>
<head>
<title>Optional Chaining with JavaScript and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript和TypeScript的可选链接</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/optional-chaining-with-javascript-and-typescript-2de847950425?source=collection_archive---------24-----------------------#2020-04-07">https://levelup.gitconnected.com/optional-chaining-with-javascript-and-typescript-2de847950425?source=collection_archive---------24-----------------------#2020-04-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8f1e244ef7a69534fc102572f79d1b73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IbemIJeWOGcQX3v9"/></div></div></figure><p id="3821" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可能以前都遇到过以下问题——对象中的可选属性，如果它存在，就需要使用，如果不存在，就做其他事情或中断。</p><p id="2d4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当对象嵌套时，这有时会变得令人沮丧，因为在尝试访问下一个嵌套属性之前，我们需要确保路径上的每个属性都存在。让我们看看如何更容易地确定一个可选属性是否存在。</p><h1 id="aca5" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">可选链接</h1><p id="f34b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们现在在链接中有了一个非常有用的操作符，<code class="fe lz ma mb mc b">?</code>操作符允许我们对正在访问的属性是否存在进行内联检查。让我们看看这是如何工作的。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="7bf3" class="ml kx iq mc b gy mm mn l mo mp">const foo = {<br/>  bar: 'data'<br/>}<br/>console.log(foo?.bar) // 'data'<br/>console.log(foo.a) // undefined</span></pre><p id="4584" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面这个简单的例子中，我们看到<code class="fe lz ma mb mc b">foo</code>有一个属性<code class="fe lz ma mb mc b">bar</code>，它只是一个字符串。如果我们尝试访问<code class="fe lz ma mb mc b">bar</code>，它将显示数据。如果我们试图访问一个不存在的属性，它会显示<code class="fe lz ma mb mc b">undefined</code>。</p><p id="87eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这被认为是预期的结果。</p><p id="d16d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来让我们看一个更复杂的例子。假设我们有一个嵌套了几层的响应。在这种情况下，可选的链接将如何帮助我们呢？</p><p id="7b17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们假设我们从一个API请求中得到一个响应，这个响应将包含一个<code class="fe lz ma mb mc b">data</code>属性，可能包含也可能不包含一个<code class="fe lz ma mb mc b">meta</code>属性，这取决于它是否附加在请求上。我们可以很容易地使用可选的链接来检查响应对象上是否存在<code class="fe lz ma mb mc b">meta</code>。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="fecd" class="ml kx iq mc b gy mm mn l mo mp">const response = {<br/>  data: {<br/>    id: 123<br/>  }<br/>}</span><span id="5ba0" class="ml kx iq mc b gy mq mn l mo mp">console.log(response.meta.requestId) // Uncaught TypeError: Cannot read property of 'requestId' of undefined</span><span id="cae5" class="ml kx iq mc b gy mq mn l mo mp">console.log(response?.meta?.requestId) // undefined</span></pre><p id="9f84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可以很容易地在条件中使用，以触发不同的流或执行一些附加功能。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="0918" class="ml kx iq mc b gy mm mn l mo mp">if (response?.meta?.requestId) {<br/>  return {<br/>    ...response.data,<br/>    requestId: response.meta.requestId // We know this exists<br/>  }<br/>}</span><span id="b282" class="ml kx iq mc b gy mq mn l mo mp">// Old method<br/>if (response &amp;&amp; response.meta &amp;&amp; response.meta.requestId)</span></pre><p id="8018" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们从上面的例子中看到的，我们可以使用更少的评估和代码完成完全相同的结果。我们不再需要担心那些烦人的<code class="fe lz ma mb mc b">&amp;</code>来确保在访问一个属性之前它是存在的。</p><h1 id="0fae" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">这和函数一起工作吗？</h1><p id="04cf" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">嗯，是的。如果我们有一个接受可选回调参数的函数，我们可以使用可选链接来确保它在试图调用它之前存在。让我们看看这是怎么回事，好吗？</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="f492" class="ml kx iq mc b gy mm mn l mo mp">function foo(data, callback) {<br/>  console.log(data)<br/>  callback?.(data)<br/>}</span><span id="da91" class="ml kx iq mc b gy mq mn l mo mp">const cb = () =&gt; console.log('called')</span><span id="0947" class="ml kx iq mc b gy mq mn l mo mp">foo('bar', cb)</span><span id="7750" class="ml kx iq mc b gy mq mn l mo mp">// 'bar'<br/>// 'called'</span></pre><p id="cfa3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从上面我们可以看到，如果定义了<code class="fe lz ma mb mc b">callback</code>参数，它会将<code class="fe lz ma mb mc b">data</code>属性传递给它并调用它。然而，如果<code class="fe lz ma mb mc b">callback</code>是<em class="mr">而不是</em>定义的，那么它将不会被调用。</p><p id="eebb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当重载函数签名以允许JavaScript中的可选回调时，了解这一点会很有用。值得注意的是，TypeScript还允许我们在函数签名中使用<code class="fe lz ma mb mc b">?</code>将参数定义为“可选的”</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="21b9" class="ml kx iq mc b gy mm mn l mo mp">function foo(bar?: string) {} // 'bar' is optional here</span></pre><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/21367f860e6bd1f034f062462ff6bd1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_PHG8JVxRNin40dr"/></div></div></figure><h1 id="2719" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">可选链接何时起作用？</h1><p id="9d4d" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">每当我们在试图访问一个属性或函数之前需要确保它的存在时，可选链接就会起作用，并且可以防止在属性或函数不存在时抛出错误。</p><p id="fe7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是要小心，如果函数的要求是当属性不存在时抛出一个错误，那么我们将希望确保丢失的属性得到正确处理。</p><p id="e24a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们快速看一下最后一个例子。我们已经看到了如何确保嵌套属性的存在，以及如何确保函数已经被定义，那么JavaScript的其他一些特性，比如<code class="fe lz ma mb mc b">Map</code>呢？</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="0180" class="ml kx iq mc b gy mm mn l mo mp">const method = () =&gt; console.log('bar')<br/>const data = new Map()<br/>data.set('foo', method)</span><span id="7263" class="ml kx iq mc b gy mq mn l mo mp">data.get('foo')?.() // invokes the function IF present</span></pre><p id="1281" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们可以看到，通过使用<code class="fe lz ma mb mc b">?</code>操作符，我们可以在<code class="fe lz ma mb mc b">foo</code>存在时随意调用函数。然而，如果<code class="fe lz ma mb mc b">foo</code>不包含函数，这将抛出一个‘类型错误’。</p><p id="bfda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意:可选链接不验证数据的类型，只验证它是否存在。所有的类型验证仍然应该独立于这个步骤来处理。这只是允许我们以安全的方式提取或访问数据。</p><p id="252a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">额外的好处——这也将与TypeScript的nullish合并一起工作。Nullish合并是一个条件表达式，它确定一个值的存在，并在该值存在时返回它，或者退回到我们可以提供的预置。</p><p id="56a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mt" rel="noopener ugc nofollow" target="_blank" href="/using-the-ternary-operator-and-nullish-coalescing-b315237770fa">你可以在这里阅读更多关于nullish合并的信息</a></p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="b99f" class="ml kx iq mc b gy mm mn l mo mp">const countryCode = person?.country?.countryCode ?? 'Unknown'</span></pre><p id="7218" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们可以选择链接到person的“countryCode”属性。然后，我们使用nullish合并作为条件表达式来确定属性是否存在以及如何处理它。如果存在，则<code class="fe lz ma mb mc b">countryCode</code>将被设置为<code class="fe lz ma mb mc b">person.country.countryCode</code>，如果未设置，则在评估后<code class="fe lz ma mb mc b">countryCode</code>将变为<code class="fe lz ma mb mc b">unknown</code>。简单。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/97fbb7e004a2455d2be276744a86424e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7laxg7XNaJMPyyy-"/></div></div></figure><h1 id="6142" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">那将是所有的人！</h1><p id="1f7f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这里有一些参考资料，如果你想了解更多或者开始在你的代码库中实现可选的链接，这些资料可能会引起你的兴趣。</p><p id="d759" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mt" rel="noopener ugc nofollow" target="_blank" href="/using-the-ternary-operator-and-nullish-coalescing-b315237770fa">中等无效合并</a></p><p id="482a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" rel="noopener ugc nofollow" target="_blank"> MDN可选链接</a> <br/> <a class="ae mt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator" rel="noopener ugc nofollow" target="_blank"> MDN无效合并</a> <br/> <a class="ae mt" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#optional-chaining" rel="noopener ugc nofollow" target="_blank">打字脚本可选链接</a> <br/> <a class="ae mt" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#nullish-coalescing" rel="noopener ugc nofollow" target="_blank">打字脚本无效合并</a></p><p id="77a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢你的阅读，我希望你喜欢并学到了一些东西。如果你碰巧有任何反馈、批评或贡献，请随意写在下面的评论区。</p><p id="ff06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再见韦德森。</p></div></div>    
</body>
</html>