<html>
<head>
<title>Understanding JavaScript Prototypes for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者理解JavaScript原型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-javascript-prototypes-for-beginners-c1ccc41c62f1?source=collection_archive---------3-----------------------#2019-08-05">https://levelup.gitconnected.com/understanding-javascript-prototypes-for-beginners-c1ccc41c62f1?source=collection_archive---------3-----------------------#2019-08-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a8e0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">JavaScript原型的基础知识和解释</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2750c86589cfa830cc8af8c49bbbecb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gP9ERuTF12f9CKANnnq-Ew.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@transonhoang?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">黄川</a>在<a class="ae ky" href="https://unsplash.com/@transonhoang?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1650" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章是关于困扰我很久的JavaScript原型的。在本文中，我将按照下面的大纲解释JavaScript原型:</p><ol class=""><li id="6a51" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">什么是JavaScript原型</li><li id="1349" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">它是如何工作的</li><li id="1ffa" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">__proto__和原型</li><li id="6a78" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">例子</li><li id="b190" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用原型和没有原型有什么区别</li><li id="c59c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">性能问题</li></ol><p id="39d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多类似的内容，请查看<a class="ae ky" href="https://betterfullstack.com/stories/" rel="noopener ugc nofollow" target="_blank">https://betterfullstack.com</a></p><h1 id="a669" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">什么是JavaScript原型</h1><p id="2b93" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">与许多其他面向对象的语言不同，JavaScript使用原型与其他对象共享功能性——这意味着什么？</p><blockquote class="nh ni nj"><p id="4b34" class="kz la mj lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">原型是JavaScript对象相互继承特性的机制。它们共享根原型对象中定义的数据和方法。</p></blockquote><p id="9464" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更简单的是，所有JavaScript对象都从原型对象继承属性和方法。</p><h1 id="49eb" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">它是如何工作的</h1><p id="a93b" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated"><em class="mj">在我看来，JavaScript中的一切都是对象</em>。功能是一个<strong class="lb iu">对象</strong>。字符串、布尔和数字是<strong class="lb iu">对象</strong>(它们是封装在提供<code class="fe nn no np nq b">string.length</code>等功能的对象中的原语)。数组也是一个对象。只有<code class="fe nn no np nq b">undefined</code>不是对象。</p><p id="8d34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">耐心地读完这篇文章，然后你会同意我的观点。</p><p id="db94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了提供继承，对象可以有一个<strong class="lb iu">原型对象</strong>，它作为一个模板对象来继承方法和属性。</p><p id="338b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字符串的父亲是<strong class="lb iu"> String.prototype </strong>，数字的父亲是<strong class="lb iu"> Number.prototype </strong>，数组的父亲是<strong class="lb iu"> Array.prototype. </strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/76ac81cf1bdec1bbd76f982abb0d5223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*9ins34E2yUWBsQ9Lqf79BQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">控制台上的String.prototype</figcaption></figure><p id="1c6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个对象的原型也可以有一个原型对象，它从原型对象继承方法和属性。我们称之为<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">原型链</strong> </a>。这就是为什么有时您会注意到不同的对象在您的项目中对它们可用的其他对象上定义了属性和方法。</p><p id="457b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们使用字符串<em class="mj"> "abc@gmail.com" </em>，那么您可以使用一些功能，如<code class="fe nn no np nq b">toUpperCase</code> <em class="mj">、</em> <code class="fe nn no np nq b">trim</code> <em class="mj">、</em>或<code class="fe nn no np nq b">split</code> <em class="mj"> </em>，因为它存在于<code class="fe nn no np nq b">String.prototype</code> <em class="mj">上。</em></p><h1 id="09ec" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">__proto__和原型</h1><p id="a07e" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated"><code class="fe nn no np nq b">__proto__</code>是在查找链中用于解析方法的实际对象。</p><p id="23e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">prototype</code>是用<code class="fe nn no np nq b">new</code>创建对象时用来构建<code class="fe nn no np nq b">__proto__</code>的对象。</p><p id="140e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更具体地说，属性和方法是在对象的构造函数的<code class="fe nn no np nq b">prototype</code>属性上定义的，而不是对象实例本身。</p><p id="9845" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看这个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/554d4e4ccfc90b105707b809b1eb1dab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*qliqzwJL8VRxnjVwmJQ83g.png"/></div></figure><p id="1075" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你声明了上面的函数，就在内部创建了<code class="fe nn no np nq b">FuncPrototype.prototype</code>。函数<code class="fe nn no np nq b">increment</code>将添加到由使用<code class="fe nn no np nq b">new FuncPrototype()</code>创建的<code class="fe nn no np nq b">FuncPrototype</code>实例共享的<code class="fe nn no np nq b">FuncPrototype.prototype</code>中。</p><p id="72ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nn no np nq b">new FuncPrototype()</code>创建的每个实例都有一个指向<code class="fe nn no np nq b">FuncPrototype.prototype</code>的<code class="fe nn no np nq b">__proto__</code>属性。这是用于遍历以查找特定对象的属性的链。</p><p id="958d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt nt nq nu nv aw nw bi"><span id="417f" class="nx ml it nq b gy ny nz l oa ob">( new FuncPrototype ).__proto__ === FuncPrototype.prototype; // true<br/>( new FuncPrototype ).prototype === undefined; //true</span></pre><p id="43ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:<code class="fe nn no np nq b">__proto__</code>不是访问原型链的标准方法，标准但相似的方法是使用<code class="fe nn no np nq b">Object.getPrototypeOf(object_name)</code>。</p><h1 id="011f" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">例子</h1><p id="e832" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">添加新属性:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/7aabd5521eff6dfa4a6ffd9b49dafcd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*9TAN0X1YBdOFd7eWAuZQqg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">添加新属性</figcaption></figure><p id="4528" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加新方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/284e3571dcfa27715bcc862a7e7d8bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*BCKw-9bSbgEnKrJg17WJVQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">添加新方法</figcaption></figure><p id="f07b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看控制台:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/491bfe3630fae8f9ec7c8f1e46554de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*lVhGW8urvw6WR1I55sp7gA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">控制台. log person.prototype</figcaption></figure><p id="cbc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以从<code class="fe nn no np nq b">console.log</code>你可以看到<code class="fe nn no np nq b">name()</code>和<code class="fe nn no np nq b">nationality</code>。</p><h1 id="b15a" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">使用原型和没有原型有什么区别</h1><p id="e1e0" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">当您不应用<strong class="lb iu">原型时，</strong>每次您创建一个人的新实例(上面的例子)，每个属性和方法都被分配给那个实例。这意味着它们将指向不同的内存引用。</p><p id="1d6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用原型有助于更快地创建对象，因为不必在每次创建新对象时都重新创建该函数。</p><h1 id="0bce" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">性能问题</h1><p id="1fc9" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在这一部分中，我将通过应用<code class="fe nn no np nq b">prototype</code>和不使用<code class="fe nn no np nq b">prototype</code>来比较我们创建1000个实例时的性能。然后调用他们的函数<code class="fe nn no np nq b">increment()</code>，看看需要多长时间。</p><p id="fd12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们先看看这个</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/fb591bf0efdbfb07ec12c22f06e30f60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/1*fKiPbvtkqMdQMwkOwAeEVg.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">创建1000个实例时的演示</figcaption></figure><p id="0fad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我重新加载页面时，你可以看到90%我们从<code class="fe nn no np nq b">funcPrototype</code>创建1000个实例的时间总是低于<code class="fe nn no np nq b">funcNoPrototype</code>。</p><p id="188f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是源代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">要测试的源代码</figcaption></figure><h1 id="3e45" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">摘要</h1><p id="fb6d" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">JavaScript prototype对于在前端项目中用JavaScript和实用程序构建库仍然很重要。这是JavaScript语言的基础。我们必须清楚地理解原型，才能决定何时使用原型来提高代码的性能。</p><p id="bbc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章对你有用！可以跟着我上<a class="ae ky" href="https://medium.com/@transonhoang?source=post_page---------------------------" rel="noopener">中</a>。我也在<a class="ae ky" href="https://twitter.com/transonhoang" rel="noopener ugc nofollow" target="_blank">推特</a>上。欢迎在下面的评论中留下任何问题。我很乐意帮忙！</p><h1 id="f626" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">资源/参考资料</h1><p id="43f2" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">[1]:对象原型<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Learn/JavaScript/Objects/Object _ Prototypes</a></p><p id="dd8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2]:对象原型<a class="ae ky" href="https://www.w3schools.com/js/js_object_prototypes.asp" rel="noopener ugc nofollow" target="_blank">https://www.w3schools.com/js/js_object_prototypes.asp</a></p></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><div class="kj kk kl km gt op"><a href="https://gitconnected.com/learn/javascript" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">学习JavaScript -最佳JavaScript教程(2019) | gitconnected</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">JavaScript是世界上最流行的编程语言之一——它随处可见。JavaScript是一种…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">gitconnected.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ks op"/></div></div></a></div><div class="pe pf gp gr pg op"><a href="https://betterfullstack.com/stories/" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">故事-更好的全栈</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">所有的故事故事为我们写指南提交故事到更好的编程博客1。故事指南避免什么…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">betterfullstack.com</p></div></div><div class="oy l"><div class="ph l pa pb pc oy pd ks op"/></div></div></a></div></div></div>    
</body>
</html>