<html>
<head>
<title>8 coding hacks for Go that I wish I’d known when I started</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我希望在开始时就知道的8个Go编码技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/8-code-hacks-for-go-that-i-wish-id-known-when-i-started-56a6f4399acf?source=collection_archive---------1-----------------------#2021-04-27">https://levelup.gitconnected.com/8-code-hacks-for-go-that-i-wish-id-known-when-i-started-56a6f4399acf?source=collection_archive---------1-----------------------#2021-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/395ce8626a268d273c2e399085dc02c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XshAidZO5edUS04Z7gVCrA.jpeg"/></div></div></figure><p id="e429" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我使用Go已经很多年了，偶尔我会遇到一个小小的代码黑客，它让我的生活变得更好。所以我决定和你分享！</p><h1 id="a7df" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">1.检查键是否在映射中</h1><p id="19dc" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">这可能是众所周知的，但我经常使用它，我觉得应该提到它。如果您想检查一个键是否在映射中，您可以调用:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="6c86" class="mm lb it mi b gy mn mo l mp mq">_, keyIsInMap := myMap["keyToCheck"]<br/>if !keyIsInMap {<br/>  fmt.Println("key not in map")<br/>}</span></pre><h1 id="3d2e" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">2.在转换变量时检查。</h1><p id="e3c2" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">有时你需要将变量从一种类型转换成另一种类型。不利的一面是，如果你输入错误，你的代码将会崩溃。例如，下面的代码尝试将变量“data”转换为字符串。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="4bb1" class="mm lb it mi b gy mn mo l mp mq">value := data.(string)</span></pre><p id="835c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，如果“数据”不能被转换成字符串，代码将会出错。但是有更好的办法！类似于检查键是否在映射中，您可以在转换时获取一个布尔值来检查转换是否成功。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="c47a" class="mm lb it mi b gy mn mo l mp mq">value, ok := data.(string)</span></pre><p id="c41a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本例中,“ok”是一个布尔值，它告诉您转换是否成功。这样，您可以比直接死机更优雅地处理类型不匹配。</p><h1 id="8f00" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">3.使用append时指定数组的大小。</h1><p id="696b" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">如果需要向数组中添加项目，定位选项是“append”。例如:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="c577" class="mm lb it mi b gy mn mo l mp mq">for _, v := range inputArray {<br/>  myArray = append(myArray, v)<br/>}</span></pre><p id="1fb6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，这在大型数组上可能会很慢，因为append将不断需要增加“myArray”的大小来容纳新值。更好的方法是先指定数组的长度，然后直接给每个值赋值:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="2a75" class="mm lb it mi b gy mn mo l mp mq">myArray := make([]int, len(inputArray))<br/> for i, v := range inputArray {<br/>  myArray[i] = v<br/> }<br/>}</span></pre><p id="c3b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我更喜欢第三种选择，那就是将两者结合起来！对我来说，它的可读性稍微好一点，但是也没有速度上的损失，因为你在开始的时候就指定了大小。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="fb84" class="mm lb it mi b gy mn mo l mp mq">myArray := make([]int, 0, len(inputArray))<br/>for _, v := range inputArray {<br/>  myArray = append(myArray, v)<br/>}</span></pre><p id="8ef0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，您将数组的大小设置为0，但是将最大大小设置为输入数组的长度。因此append不需要在运行过程中调整大小。如果您比较由1亿个整数组成的数组的时间，您可以看到速度差异:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="95e3" class="mm lb it mi b gy mn mo l mp mq">normal array append took   3782.1423ms<br/>presized array took        549.8333ms<br/>presized array append took 685.9402ms</span></pre><h1 id="f8fd" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">4.使用“追加”和<strong class="ak">省略号</strong>来连接一个数组。</h1><p id="3a23" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">有时你需要连接两个数组，一个很好的简单方法是利用“append”是一个变量函数的事实。因此，虽然一个普通的追加调用可能看起来像这样:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="09f8" class="mm lb it mi b gy mn mo l mp mq">myArray = append(myArray, value1)</span></pre><p id="7ace" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">“追加”还允许一次追加多个元素:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="0b7e" class="mm lb it mi b gy mn mo l mp mq">myArray = append(myArray, value1, value2)</span></pre><p id="c2ab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然这很有用，但这并不是真正酷的部分。最酷的是，在将数组传递给函数时，可以使用“…”来扩展数组。假设您想将“inputArray”连接到“myArray ”,您需要做的就是:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="e219" class="mm lb it mi b gy mn mo l mp mq">myArray <!-- -->= append(<!-- -->myArray<!-- -->, <!-- -->inputArray<!-- -->...)</span></pre><p id="876d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将扩展“inputArray”的所有值，并将它们传递给append。</p><h1 id="b50a" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">5.打印时显示参数名称和值。</h1><p id="ab45" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">这个方法花了很长时间才学会，但是现在我知道了，我一直在使用它。最初，当我想在结构中显示参数名和值时，我会封送到JSON并记录下来。然而，有一个简单得多的方法。当进行Printf时，在格式中添加一个+。例子</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="5305" class="mm lb it mi b gy mn mo l mp mq">fmt.Printf("%+v \n", structToDisplay)</span></pre><p id="7032" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您还可以通过将+改为a #，以Go语法表示将其打印出来。示例:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="1681" class="mm lb it mi b gy mn mo l mp mq">fmt.Printf("%#v \n", structToDisplay)</span></pre><p id="853f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">各种输出的比较:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="626f" class="mm lb it mi b gy mn mo l mp mq">Without params:       {first value 2}<br/>With params:          {Value1:first value Value2:2}<br/>As go representation: main.MyStruct{Value1:"first value", Value2:2}</span></pre><h1 id="7fed" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">6.枚举时将“iota”与自定义类型一起使用</h1><p id="e74b" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在Go中枚举某物时，最好使用“iota”。“iota”是Go中的一个关键字，每次调用时都会分配递增的整数。你可以想象这对创造枚举来说是很棒的。然后，您可以将它与自定义整数类型相结合，这样编译器将确保您的代码的用户只使用指定的枚举。示例:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="fb26" class="mm lb it mi b gy mn mo l mp mq">type PossibleStates int</span><span id="a75c" class="mm lb it mi b gy mr mo l mp mq">const (<br/> State1 PossibleStates = iota<br/> State2<br/> State3<br/>)</span><span id="62f5" class="mm lb it mi b gy mr mo l mp mq">func UpdateState(newState PossibleStates) error {</span></pre><p id="5a09" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，您创建了一个自定义类型“PossibleStates”，然后每个枚举都是一个“PossibleState”类型，其值由“iota”指定。然后，当任何人调用“UpdateState”时，编译器将确保只发送可能的状态，而不发送任何旧的int。</p><h1 id="b255" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">7.模拟接口时，将与接口函数匹配的函数作为参数。</h1><p id="981f" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">这是Mat Ryer 提供的，它改变了我的游戏规则。假设您有一个想要模仿的接口:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="60a7" class="mm lb it mi b gy mn mo l mp mq">type DataPersistence interface {<br/> SaveData(string, string) error<br/> GetData(string) (string, error)<br/>}</span></pre><p id="ba85" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这可能是几种不同类型的持久性的接口。您想要测试您的代码，所以您将创建一个可以在您的测试中使用的模拟DataPersistence结构。然而，不用编写复杂的模拟结构，您可以简单地创建一个带有参数的结构，这些参数是与接口函数匹配的函数。这是一个读起来令人困惑的句子，所以一个好的例子会有所帮助！您的模拟应该是这样的:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="e609" class="mm lb it mi b gy mn mo l mp mq">type MockDataPersistence struct {<br/> SaveDataFunc func(string, string) error<br/> GetDataFunc func(string) (string, error)<br/>}</span><span id="c907" class="mm lb it mi b gy mr mo l mp mq">// SaveData just calls the parameter SaveDataFunc<br/>func (mdp MockDataPersistence) SaveData(key, value string) error {<br/> return mdp.SaveDataFunc(key, value)<br/>}</span><span id="c531" class="mm lb it mi b gy mr mo l mp mq">// GetData just calls the parameter GetDataFunc<br/>func (mdp MockDataPersistence) GetData(key string) (string, error) {<br/> return mdp.GetDataFunc(key)<br/>}</span></pre><p id="7f14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这意味着当您测试时，您可以设置函数在测试本身中做您需要的任何事情:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="b9f4" class="mm lb it mi b gy mn mo l mp mq">func TestMyStuff(t *testing.T) {<br/> mockPersistor := MockDataPersistence{}<br/> // here we set SaveData to just return an error<br/> mockPersistor.SaveDataFunc = func(key, value string) error {<br/>  return fmt.Errorf("error to check how your code handles an error")<br/> }</span><span id="369d" class="mm lb it mi b gy mr mo l mp mq"> // now we can check how thingToTest handles it when <br/> // SaveData return an error<br/> err := thingToTest(mockPersistor)<br/> assert.Nil(t, err)<br/>}</span></pre><p id="df34" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这确实有助于可读性，因为您可以清楚地看到每个测试中的模拟内容。这也意味着您可以访问模拟函数中的测试数据，而不需要维护外部数据文件。</p><h1 id="f5e9" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">8.如果有人没有创建接口，就创建你自己的接口。</h1><p id="e481" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">这个也是由<a class="ae kz" href="https://medium.com/@matryer" rel="noopener">马特瑞尔</a>提供的。如果你正在使用另一个Go库，他们有一个struct，但是从来没有使它成为一个接口，你可以只做一个来匹配它。假设他们的结构如下所示:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="1a9c" class="mm lb it mi b gy mn mo l mp mq">type OtherLibsStruct struct {}</span><span id="fdc1" class="mm lb it mi b gy mr mo l mp mq">func (ols OtherLibsStruct) DoCoolStuff(input string) error {<br/> return nil<br/>}</span></pre><p id="3cad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在你的代码中，创建一个可以实现的接口:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="7fa9" class="mm lb it mi b gy mn mo l mp mq">type InterfaceForOtherLibsStruct interface {<br/> DoCoolStuff(string) error<br/>}</span></pre><p id="a688" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，您可以编写代码来接受这个接口。使用另一个库的结构时传入它。然后当你想测试它的时候，从上面开始做模拟接口的把戏。</p><h1 id="f4b6" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">奖励:实例化嵌套的匿名结构</strong></h1><p id="ae19" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我在使用生成代码时遇到过几次这种情况。有时当代码生成时，你会得到一个嵌套的匿名结构。示例:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="484f" class="mm lb it mi b gy mn mo l mp mq">type GeneratedStuct struct {<br/>  Value1 string `json:"value1"`<br/>  Value2 int `json:"value2"`<br/>  Value3 *struct {<br/>    NestedValue1 string `json:"NestedValue1"`<br/>    NestedValue2 string `json:"NestedValue2"`<br/>  } `json:"value3,ommitempty"`<br/>}</span></pre><p id="7245" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，假设您想要创建这个结构的一个实例来使用，您将如何着手呢？Value1和Value2很简单，但是如何实例化一个指向匿名结构(Value3)的指针呢？我的第一个解决方案是用JSON编写它，然后将它封送到struct中，但是这样做很糟糕。事实证明，在实例化它时，您需要使用另一个匿名结构:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="028e" class="mm lb it mi b gy mn mo l mp mq">myGeneratedStruct := GeneratedStuct{<br/>  Value3: &amp;struct {<br/>   NestedValue1 string `json:"NestedValue1"`<br/>   NestedValue2 string `json:"NestedValue2"`<br/>  }{<br/>   NestedValue1: "foo",<br/>   NestedValue2: "bar",<br/>  },<br/> }</span></pre><p id="3e5c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这似乎是显而易见的，但是要注意，它需要与<em class="ms">完全匹配</em>，甚至是JSON标签。虽然上面的代码可以工作，但是由于类型不匹配，下面的代码将无法编译:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="025f" class="mm lb it mi b gy mn mo l mp mq">myGeneratedStruct := GeneratedStuct{<br/>  Value3: &amp;struct {<br/>   NestedValue1 string `json:"nestedValue1"`<br/>   NestedValue2 string `json:"nestedValue2"`<br/>  }{<br/>   NestedValue1: "foo",<br/>   NestedValue2: "bar",<br/>  },<br/> }</span></pre><p id="3121" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">看看你是否能发现不同之处！</p></div></div>    
</body>
</html>