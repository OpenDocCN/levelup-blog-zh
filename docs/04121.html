<html>
<head>
<title>LeetCode Problems with Rust: Median of Two Sorted Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust的LeetCode问题:两个排序数组的中值</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/leetcode-problems-median-of-two-sorted-arrays-9e72f9186b93?source=collection_archive---------4-----------------------#2020-06-10">https://levelup.gitconnected.com/leetcode-problems-median-of-two-sorted-arrays-9e72f9186b93?source=collection_archive---------4-----------------------#2020-06-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e581b9b5ed29251bc2c2d2cbf36eb5b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-H2WUc3LU4EUTOupFUmrNQ.png"/></div></div></figure><h1 id="6af2" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">问题陈述</h1><p id="7f71" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">有两个大小分别为<code class="fe lu lv lw lx b">n</code>和<code class="fe lu lv lw lx b">m</code>的排序数组<code class="fe lu lv lw lx b">nums1</code>和<code class="fe lu lv lw lx b">nums2</code>。求两个排序数组的中间值。你可能认为<code class="fe lu lv lw lx b">nums1</code>和<code class="fe lu lv lw lx b">nums2</code>不能都为空。</p><h1 id="1f2e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">例子</h1><h2 id="468e" class="ly jz iq bd ka lz ma dn ke mb mc dp ki lh md me km ll mf mg kq lp mh mi ku mj bi translated">示例1</h2><pre class="mk ml mm mn gt mo lx mp mq aw mr bi"><span id="1d6a" class="ly jz iq lx b gy ms mt l mu mv">nums1 = [1, 3] nums2 = [2] The median is 2.0</span></pre><h2 id="80ec" class="ly jz iq bd ka lz ma dn ke mb mc dp ki lh md me km ll mf mg kq lp mh mi ku mj bi translated">示例2</h2><pre class="mk ml mm mn gt mo lx mp mq aw mr bi"><span id="4d59" class="ly jz iq lx b gy ms mt l mu mv">nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5</span></pre><h1 id="9662" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">方法1:合并数组</h1><p id="51c9" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">由于两个输入数组都已经排序，一个简单的解决方案是通过遍历每个数组并将条目插入一个新数组来合并数组。然后计算中位数。</p><h2 id="26ce" class="ly jz iq bd ka lz ma dn ke mb mc dp ki lh md me km ll mf mg kq lp mh mi ku mj bi translated">算法</h2><pre class="mk ml mm mn gt mo lx mp mq aw mr bi"><span id="34bf" class="ly jz iq lx b gy ms mt l mu mv">initialize i and j to 0<br/>initialize length of new array to the sum of the length the input arrays<br/>initialize an empty array</span><span id="471b" class="ly jz iq lx b gy mw mt l mu mv">while i is less then length of nums1 or j is less than length of nums2<br/>    if all elements from nums1 have been merged<br/>        merge element nums2[j]<br/>        increment j<br/>    else if all elements from nums2 have been merged<br/>        merge element nums1[i]<br/>        increment i<br/>    else<br/>        if element nums1[i] &lt;= element nums2[j]<br/>            merge element nums1[i]<br/>            increment i<br/>        else<br/>            merge element nums2[j]<br/>            increment j</span><span id="ffa8" class="ly jz iq lx b gy mw mt l mu mv">find midpoint (length / 2)<br/>if length is even<br/>    return the average of merged_array[mid] and merged_array[mid - 1]<br/>else<br/>    return merged_array[mid]</span></pre><h2 id="9aee" class="ly jz iq bd ka lz ma dn ke mb mc dp ki lh md me km ll mf mg kq lp mh mi ku mj bi translated">履行</h2><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/81c27508abb9455027e15ea652e7fdf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LJX6oO5lOJEGp-8q.png"/></div></div></figure><h2 id="cc3a" class="ly jz iq bd ka lz ma dn ke mb mc dp ki lh md me km ll mf mg kq lp mh mi ku mj bi translated">复杂性</h2><ul class=""><li id="f2e6" class="my mz iq ky b kz la ld le lh na ll nb lp nc lt nd ne nf ng bi translated">时间复杂度:O(m + n) -&gt; O(n)</li><li id="921c" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">空间复杂度:O(m + n) -&gt; O(n)</li></ul><h1 id="aa40" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">方法2:分区</h1><p id="a066" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">线性运行时还不错，但是如果数组的大小显著增加，就会出现一些性能问题。另一个问题是额外的空间需求。即使我们假设输入数组适合内存，如果数组的大小足够大，合并后的数组也可能不适合。这种方法的目标是减少总的运行时间和额外的空间需求。</p><p id="2322" class="pw-post-body-paragraph kw kx iq ky b kz nm lb lc ld nn lf lg lh no lj lk ll np ln lo lp nq lr ls lt ij bi translated">最终目标是找到两个排序数组的中间值。中位数有效地将一组数字分成两半。因此，不要把数组看作两个独立的数据集，而是把它们看作一个恰好被分成两部分的数组。那么目标就是找到更大数组的中间。</p><p id="1e37" class="pw-post-body-paragraph kw kx iq ky b kz nm lb lc ld nn lf lg lh no lj lk ll np ln lo lp nq lr ls lt ij bi translated">为此，首先要对两个输入数组进行分区。分区的前半部分将包含输入数组开头的一些元素，后半部分将包含输入数组的其余元素。每个分区应该有相同数量的元素，否则第一个分区将比第二个分区多包含一个元素。一旦分区就位，我们必须调整分区索引，直到前半部分的每个元素都小于或等于后半部分的每个元素。</p><p id="e6da" class="pw-post-body-paragraph kw kx iq ky b kz nm lb lc ld nn lf lg lh no lj lk ll np ln lo lp nq lr ls lt ij bi translated">这里有一个例子。</p><p id="c7de" class="pw-post-body-paragraph kw kx iq ky b kz nm lb lc ld nn lf lg lh no lj lk ll np ln lo lp nq lr ls lt ij bi translated">假设我们有两个输入数组:</p><pre class="mk ml mm mn gt mo lx mp mq aw mr bi"><span id="97f9" class="ly jz iq lx b gy ms mt l mu mv">nums1 = [2, 3]<br/>nums2 = [1, 4, 5]</span></pre><p id="1a4a" class="pw-post-body-paragraph kw kx iq ky b kz nm lb lc ld nn lf lg lh no lj lk ll np ln lo lp nq lr ls lt ij bi translated">下一步是对阵列进行分区。<code class="fe lu lv lw lx b">nums1</code>的初始分区索引是<code class="fe lu lv lw lx b">n / 2</code>，其中<code class="fe lu lv lw lx b">n</code>是<code class="fe lu lv lw lx b">nums1</code>的长度。<code class="fe lu lv lw lx b">nums2</code>的初始分区索引为<code class="fe lu lv lw lx b">(n + m + 1) / 2 - i</code>，其中<code class="fe lu lv lw lx b">n</code>为<code class="fe lu lv lw lx b">nums1</code>的长度，<code class="fe lu lv lw lx b">m</code>为<code class="fe lu lv lw lx b">nums2</code>的长度，<code class="fe lu lv lw lx b">i</code>为<code class="fe lu lv lw lx b">nums1</code>的分区索引。</p><p id="f970" class="pw-post-body-paragraph kw kx iq ky b kz nm lb lc ld nn lf lg lh no lj lk ll np ln lo lp nq lr ls lt ij bi translated">初始分区如下所示:</p><pre class="mk ml mm mn gt mo lx mp mq aw mr bi"><span id="1911" class="ly jz iq lx b gy ms mt l mu mv">i = 1 --&gt; (n / 2) = (2 / 2) <br/>j = 2 --&gt; (n + m + 1) / 2 - i = (2 + 3 + 1) / 2 - 1 <br/>nums1 = [2    | 3] --&gt; The pipe delimits the partition <br/>nums2 = [1, 4 | 5]</span></pre><p id="2482" class="pw-post-body-paragraph kw kx iq ky b kz nm lb lc ld nn lf lg lh no lj lk ll np ln lo lp nq lr ls lt ij bi translated">您可能会发现这些值不在正确的分区中。分区的前半部分包含<code class="fe lu lv lw lx b">nums2</code>中的值4，分区的后半部分包含<code class="fe lu lv lw lx b">nums1</code>中的值3。所以我们需要调整分区索引，直到每个值都在正确的一半。</p><p id="8375" class="pw-post-body-paragraph kw kx iq ky b kz nm lb lc ld nn lf lg lh no lj lk ll np ln lo lp nq lr ls lt ij bi translated">我们知道值3属于第一个分区，所以我们可以将分区索引<code class="fe lu lv lw lx b">i</code>向右移动，再次执行分区。</p><pre class="mk ml mm mn gt mo lx mp mq aw mr bi"><span id="7100" class="ly jz iq lx b gy ms mt l mu mv">i = 2 <br/>j = 1 --&gt; (n + m + 1) / 2 - i = (2 + 3 + 1) / 2 - 2 <br/>nums1 = [2, 3 |     ] <br/>nums2 = [1    | 4, 5]</span></pre><p id="eddb" class="pw-post-body-paragraph kw kx iq ky b kz nm lb lc ld nn lf lg lh no lj lk ll np ln lo lp nq lr ls lt ij bi translated">现在所有的值都在正确的分区中。两个分区都包含值，两个数组的总长度都是奇数。这意味着中值是第一个分区的最大值:<code class="fe lu lv lw lx b">max(nums1[i - 1], nums2[j - 1])</code>。在这个例子中，中位数是3。</p><p id="04a2" class="pw-post-body-paragraph kw kx iq ky b kz nm lb lc ld nn lf lg lh no lj lk ll np ln lo lp nq lr ls lt ij bi translated">在这个例子中，两个数组的长度都是奇数，但是如果长度是偶数，那么需要计算两个中间值的平均值。例如:</p><pre class="mk ml mm mn gt mo lx mp mq aw mr bi"><span id="ea7a" class="ly jz iq lx b gy ms mt l mu mv">i = 2<br/>j = 1<br/>nums1 = [2, 3 |        ] <br/>nums2 = [1    | 4, 5, 6]</span></pre><p id="b3cd" class="pw-post-body-paragraph kw kx iq ky b kz nm lb lc ld nn lf lg lh no lj lk ll np ln lo lp nq lr ls lt ij bi translated">本例中的中值是第一个分区中最大值<code class="fe lu lv lw lx b">max(nums1[i - 1], nums2[j - 1])</code>和第二个分区中最小值<code class="fe lu lv lw lx b">min(nums1[i - 1], nums2[j - 1])</code>的平均值。</p><p id="9d71" class="pw-post-body-paragraph kw kx iq ky b kz nm lb lc ld nn lf lg lh no lj lk ll np ln lo lp nq lr ls lt ij bi translated">这种方法的一个假设是<code class="fe lu lv lw lx b">nums1</code>的长度小于<code class="fe lu lv lw lx b">nums2</code>的长度。如果不实施该假设，那么分区索引<code class="fe lu lv lw lx b">j</code>可能是负的。一个简单的解决方案是用一个包装函数来检查数组的长度，并将数组以正确的顺序传递给这个函数。</p><p id="3346" class="pw-post-body-paragraph kw kx iq ky b kz nm lb lc ld nn lf lg lh no lj lk ll np ln lo lp nq lr ls lt ij bi translated">另一个问题是，其中一个输入数组可能是空的，但不是两个都是空的。如果我们假设最短的数组总是<code class="fe lu lv lw lx b">nums1</code>，那么我们可以在分区索引<code class="fe lu lv lw lx b">i</code>周围添加约束，这样分区索引永远不会小于0或大于<code class="fe lu lv lw lx b">n</code>。这也意味着我们永远不必直接移动分区索引<code class="fe lu lv lw lx b">i</code>。A <code class="fe lu lv lw lx b">min</code>和<code class="fe lu lv lw lx b">max</code>可以替换。这意味着我们之前的示例将如下所示:</p><pre class="mk ml mm mn gt mo lx mp mq aw mr bi"><span id="cb3d" class="ly jz iq lx b gy ms mt l mu mv">Iteration 1 <br/>min = 0<br/>max = n<br/>i = 1 --&gt; (min + max / 2) = (2 / 2)<br/>j = 2 --&gt; (n + m + 1) / 2 - i = (2 + 3 + 1) / 2 - 1<br/>nums1 = [2    | 3] --&gt; The pipe delimits the partition<br/>nums2 = [1, 4 | 5]</span><span id="8338" class="ly jz iq lx b gy mw mt l mu mv">Iteration 2<br/>min = 2 --&gt; Shifted to the right (i + 1)<br/>max = 2 <br/>i = 2 --&gt; (min + max / 2) = (4 / 2)<br/>j = 1 --&gt; (n + m + 1) / 2 - i = (2 + 3 + 1) / 2 - 2 <br/>nums1 = [2, 3 |        ] <br/>nums2 = [1    | 4, 5, 6]</span></pre><p id="2a50" class="pw-post-body-paragraph kw kx iq ky b kz nm lb lc ld nn lf lg lh no lj lk ll np ln lo lp nq lr ls lt ij bi translated">考虑到所有这些因素，可以推导出一种算法来解决这个问题。</p><h2 id="2e0a" class="ly jz iq bd ka lz ma dn ke mb mc dp ki lh md me km ll mf mg kq lp mh mi ku mj bi translated">算法</h2><pre class="mk ml mm mn gt mo lx mp mq aw mr bi"><span id="f911" class="ly jz iq lx b gy ms mt l mu mv">initialize n to length of nums1<br/>initialize m to length of nums2<br/>initialize median to 0<br/>initialize min and max to 0 and n respectively<br/>initialize i and j to 0</span><span id="b896" class="ly jz iq lx b gy mw mt l mu mv">while min is less than or equal to max<br/>    set i to the partition index for nums1 - (min + max) / 2<br/>    set j to the partition index for nums2 - (n + m + 1) / 2 - i<br/>    if i &lt; n and j &gt; 0 and nums2[j - 1] &gt; nums1[i]<br/>        set min = i + 1<br/>    else if i &gt; 0 and j &lt; m and nums2[j] &gt; nums1[i - 1]<br/>        set max = i - 1<br/>    else<br/>        if i equals 0<br/>            set median = nums2[j - 1]<br/>        else if j equals 0<br/>            set median = nums1[i - 1]<br/>        else<br/>            set median to the max of nums1[i - 1] and nums2[j - 1]<br/>        break</span><span id="3d71" class="ly jz iq lx b gy mw mt l mu mv">if the length of nums1 and nums2 is odd<br/>    return median<br/>else if i equals n<br/>    return the average of the median and nums2[j]<br/>else if j equals m<br/>    return the average of the median and nums1[i]<br/>else<br/>    return the average of the median and the max of nums1[i] and nums2[j]</span></pre><h2 id="389c" class="ly jz iq bd ka lz ma dn ke mb mc dp ki lh md me km ll mf mg kq lp mh mi ku mj bi translated">履行</h2><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/ca02f33231ee3decbf53e94648981365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9B7dkN3GFMZV_JL0.png"/></div></div></figure><h1 id="43a1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">复杂性</h1><ul class=""><li id="a193" class="my mz iq ky b kz la ld le lh na ll nb lp nc lt nd ne nf ng bi translated">时间复杂度:O(log(min(n，m)))</li><li id="4ee7" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">空间复杂度:O(1)</li></ul><h1 id="d33a" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">回顾</h1><p id="f8fd" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">就解决方案而言，与合并数组相比，对数组进行分区可以提高运行时性能，并显著提高空间效率。随着输入数组大小的增加，O(log(min(n，m)))运行时具有更大的优势。就空间效率而言，只要输入数组能够适合内存，我们就可以有把握地认为我们的解决方案应该按照预期执行。这个问题的源代码可以在我的GitHub上找到。</p><p id="df44" class="pw-post-body-paragraph kw kx iq ky b kz nm lb lc ld nn lf lg lh no lj lk ll np ln lo lp nq lr ls lt ij bi translated">对我来说，解决这个问题的关键是不要太专注于个人细节，而忘记了全局，森林换树木的问题。单个数组很重要，但它们是寻找中位数的更大解决方案的一部分。</p><h1 id="e32f" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">谢谢</h1><p id="5dc6" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">感谢阅读！如果您想联系我或想提供反馈，请随时使用主页或“关于”页面上横幅中的链接与我联系。</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="dd8c" class="pw-post-body-paragraph kw kx iq ky b kz nm lb lc ld nn lf lg lh no lj lk ll np ln lo lp nq lr ls lt ij bi translated"><em class="oa">原载于2020年6月10日</em><a class="ae ns" href="https://andrewleverette.github.io/median-of-two-sorted-arrays/" rel="noopener ugc nofollow" target="_blank"><em class="oa">https://andrewleverette . github . io</em></a><em class="oa">。</em></p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/2683b9f8b8766fdf390a456bcd63ab22.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*3N6R_9KQPVOHCiYG66Iytg.png"/></div></figure></div></div>    
</body>
</html>