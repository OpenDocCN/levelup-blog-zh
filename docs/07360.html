<html>
<head>
<title>How To Replace Docker on Your Raspberry Pi With Containerd</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Containerd替换你的树莓派上的Docker</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/replace-docker-on-your-raspberry-pi-with-containerd-df5d025f497e?source=collection_archive---------2-----------------------#2021-02-12">https://levelup.gitconnected.com/replace-docker-on-your-raspberry-pi-with-containerd-df5d025f497e?source=collection_archive---------2-----------------------#2021-02-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="12e5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用containerd迈出第一步，像往常一样运行docker映像</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5260838cf60a9caa2ceb1d5de9eb0ecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZvHQhUt8tmJyNtTv"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@inesmills?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> ines mills </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="233d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2020年12月，<a class="ae ky" href="https://kubernetes.io/blog/2020/12/02/dont-panic-kubernetes-and-docker/" rel="noopener ugc nofollow" target="_blank"> Kubernetes项目已经弃用docker </a>。通过这堂课，我们将先回顾一下历史，以理解这种贬值的原因。这将使我们下一步发现<code class="fe lv lw lx ly b">containerd</code>并找出它的优势。</p><p id="f4c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将把<code class="fe lv lw lx ly b">containerd</code>安装在树莓派上来练习。这个目标平台是深入研究使用<code class="fe lv lw lx ly b">containerd</code>所需的不同组件的好场景。没有可用的二进制文件，所以我们将从源代码中构建它们。一旦安装完毕，我们将会看到如何使用<code class="fe lv lw lx ly b">ctr</code>命令与它交互，以及可以做些什么。</p><h1 id="9f54" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">Docker软件历史</h1><p id="a45b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">Docker软件创建于2013年，为集装箱化的出名和普及做出了贡献。然而，人们经常混淆<code class="fe lv lw lx ly b">docker</code>和集装箱化。</p><h2 id="03c5" class="mw ma it bd mb mx my dn mf mz na dp mj li nb nc ml lm nd ne mn lq nf ng mp nh bi translated">码头工≠集装箱</h2><p id="a17d" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">有了这两个Linux内核特性，Linux中的容器化成为可能:</p><ul class=""><li id="9684" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated"><strong class="lb iu"> Linux内核命名空间</strong>定义了一个进程的边界，它知道周围还有什么在运行。</li><li id="fa39" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><strong class="lb iu">控制组(cgroups) </strong>是管理和隔离受进程影响的资源(CPU、内存)的内核特性。</li></ul><p id="79f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Linux容器(<a class="ae ky" href="https://linuxcontainers.org/lxc/introduction/" rel="noopener ugc nofollow" target="_blank"> <em class="nw"> LXC </em> </a>)于2008年发布，依赖于之前的两个内核特性。它提供了一个API来轻松创建和管理容器应用系统。</p><p id="39f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最初，<code class="fe lv lw lx ly b">docker</code>使用LXC堆栈来隔离应用程序资源。强大之处在于创建了一个标准的软件单元，用户可以在其中定义图像并在容器中轻松启动它们。</p><h2 id="3d46" class="mw ma it bd mb mx my dn mf mz na dp mj li nb nc ml lm nd ne mn lq nf ng mp nh bi translated">软件体系结构演变</h2><p id="21c0" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><code class="fe lv lw lx ly b">docker</code>立足于LXC，真正依赖于它的发展。为了补救这一点，<code class="fe lv lw lx ly b">docker</code>开始实现<a class="ae ky" href="https://github.com/docker-archive/libcontainer" rel="noopener ugc nofollow" target="_blank"><em class="nw">lib containers</em></a>来发布没有LXC的容器。</p><p id="534e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与此同时，对包含CLI和守护进程的整体架构<code class="fe lv lw lx ly b">docker</code>有许多批评。考虑到这些反馈，<code class="fe lv lw lx ly b">docker</code>开始在<code class="fe lv lw lx ly b">docker</code>中删除守护进程和命令行界面。</p><p id="4e9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2015年，开放容器计划(<a class="ae ky" href="https://opencontainers.org/" rel="noopener ugc nofollow" target="_blank"> <em class="nw"> OCI </em> </a>)成立，旨在创建应用容器标准。Docker公司是其定义中的一个主要参与者。这一举措产生了两个标准，构成了OCI模式:</p><ul class=""><li id="14a5" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated"><a class="ae ky" href="https://github.com/opencontainers/runtime-spec" rel="noopener ugc nofollow" target="_blank"> <em class="nw"> runtime-spec </em> </a>定义如何运行容器:</li></ul><div class="nx ny gp gr nz oa"><a href="https://github.com/opencontainers/runtime-spec" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">open containers/运行时规范</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">开放容器倡议制定了操作系统过程和应用标准的规范…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo ks oa"/></div></div></a></div><ul class=""><li id="5d36" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated"><a class="ae ky" href="https://github.com/opencontainers/image-spec" rel="noopener ugc nofollow" target="_blank"> <em class="nw">图像规格</em> </a>定义图像创建:</li></ul><div class="nx ny gp gr nz oa"><a href="https://github.com/opencontainers/image-spec" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">open containers/图像规格</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">OCI图像格式项目创建并维护软件海运集装箱图像格式规范(OCI图像…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="op l ol om on oj oo ks oa"/></div></div></a></div><p id="af9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker公司向OCI捐赠了<code class="fe lv lw lx ly b">libcontainers</code>。它现在是OCI运行时的<a class="ae ky" href="https://github.com/opencontainers/runc" rel="noopener ugc nofollow" target="_blank"> <em class="nw"> runc </em> </a>项目的一部分。如今，<code class="fe lv lw lx ly b">docker</code>不再是过去的铁板一块。它使用<code class="fe lv lw lx ly b">containerd</code>和<code class="fe lv lw lx ly b">runc</code>来管理容器的运行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/7a4303486518abb19a355ff317350b7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*R0HezvoETK9g1zuWI3CO4g.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">实际的docker架构</figcaption></figure><h2 id="b093" class="mw ma it bd mb mx my dn mf mz na dp mj li nb nc ml lm nd ne mn lq nf ng mp nh bi translated">集装箱d</h2><p id="7cf9" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><code class="fe lv lw lx ly b">containerd</code>脱胎于<code class="fe lv lw lx ly b">docker</code>，从1.11版本开始包含:</p><div class="nx ny gp gr nz oa"><a href="https://www.docker.com/blog/docker-engine-1-11-runc/" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">Docker 1.11:第一个基于containerd和OCI技术的运行时</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">我们很高兴推出Docker Engine 1.11，这是我们基于runC和containerd的第一个版本。在此版本中…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">www.docker.com</p></div></div><div class="oj l"><div class="or l ol om on oj oo ks oa"/></div></div></a></div><p id="8966" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它是一个实现容器运行时接口(CRI)的运行时，为托管系统提供了有趣的资产:</p><blockquote class="os ot ou"><p id="1d93" class="kz la nw lb b lc ld ju le lf lg jx lh ov lj lk ll ow ln lo lp ox lr ls lt lu im bi translated">“containerd是一个行业标准的容器运行时，强调简单性、健壮性和可移植性。它作为Linux和Windows的守护程序提供，可以管理其主机系统的完整容器生命周期:映像传输和存储、容器执行和监督、底层存储和网络附件等。”来自<a class="ae ky" href="https://github.com/containerd/containerd" rel="noopener ugc nofollow" target="_blank">https://github.com/containerd/containerd</a></p></blockquote><h2 id="af12" class="mw ma it bd mb mx my dn mf mz na dp mj li nb nc ml lm nd ne mn lq nf ng mp nh bi translated">Docker和Kubernetes</h2><p id="0087" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在1.20版本之前，<code class="fe lv lw lx ly b">kubernetes</code>使用<code class="fe lv lw lx ly b">docker</code>与容器通信。<code class="fe lv lw lx ly b">docker</code>本身调用containerd来管理容器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/dd011797e3f376fc5f1b010fb7856fd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*srOLKxfWTzOUU1cDgmPexA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">与Docker的Kubernetes</figcaption></figure><p id="e8d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从v1.20开始，<code class="fe lv lw lx ly b">kubernetes</code>弃用<code class="fe lv lw lx ly b">docker</code>，转而使用容器运行时接口(CRI)，如<code class="fe lv lw lx ly b">containerd</code>和<code class="fe lv lw lx ly b">cri-o</code>。如果您在这个版本中仍然使用<code class="fe lv lw lx ly b">docker</code>，您将会收到警告。这一更改将在1.22版中生效。之前的图表现在看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/ae28523eb2be9b99ed1a80d9f644a089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*Mx22g06H11E9JBG2WYtDMA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">没有码头工人的Kubernetes</figcaption></figure><p id="199b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管有这个<code class="fe lv lw lx ly b">kubernetes</code>变化，你可以继续在你的CI/CD中使用Docker或者用于开发目的。<code class="fe lv lw lx ly b">docker</code>带来了许多用户体验功能，使交互更加简单。然而，像<code class="fe lv lw lx ly b">kubernetes</code>这样的容器编排器只需要一个容器运行时来管理容器。处理一个额外的层会带来更多的复杂性，但不会创造更多的价值。</p></div><div class="ab cl pa pb hx pc" role="separator"><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf"/></div><div class="im in io ip iq"><h1 id="9a36" class="lz ma it bd mb mc ph me mf mg pi mi mj jz pj ka ml kc pk kd mn kf pl kg mp mq bi translated"><strong class="ak">装在树莓皮上</strong></h1><h2 id="6564" class="mw ma it bd mb mx my dn mf mz na dp mj li nb nc ml lm nd ne mn lq nf ng mp nh bi translated">装置</h2><p id="28dc" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我用的是一个Raspberry Pi，armv6l处理器架构，Raspbian OS。您应该使用<code class="fe lv lw lx ly b">uname</code>检查您的处理器架构，并根据您的架构调整源代码。</p><p id="73c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们确保系统是最新的:</p><pre class="kj kk kl km gt pm ly pn po aw pp bi"><span id="416d" class="mw ma it ly b gy pq pr l ps pt">$ sudo apt update<br/>$ sudo apt full-upgrade<br/>$ sudo rpi-update</span></pre><p id="8f90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一些编译工具来编译源代码:</p><pre class="kj kk kl km gt pm ly pn po aw pp bi"><span id="3874" class="mw ma it ly b gy pq pr l ps pt">$ sudo apt install autoconf automake libtool curl unzip gcc make</span></pre><p id="4cef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要安装一个最新的<code class="fe lv lw lx ly b">golang</code>版本:</p><pre class="kj kk kl km gt pm ly pn po aw pp bi"><span id="2370" class="mw ma it ly b gy pq pr l ps pt">$ wget <a class="ae ky" href="https://golang.org/dl/go1.15.8.linux-armv6l.tar.gz" rel="noopener ugc nofollow" target="_blank">https://golang.org/dl/go1.15.8.linux-armv6l.tar.gz</a><br/>$ sudo tar -C /usr/local -xzf <a class="ae ky" href="https://golang.org/dl/go1.15.8.linux-armv6l.tar.gz" rel="noopener ugc nofollow" target="_blank">go1.15.8.linux-armv6l.tar.gz</a><br/>$ echo 'PATH="$PATH:/usr/local/go/bin"' | tee -a $HOME/.profile<br/>$ <!-- -->echo "export GOPATH=$(go env GOPATH)" | tee -a $HOME/.profile<br/>$ source $HOME/.profile<br/>$ go version<br/># version should be 1.15.8</span></pre><p id="8378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为seccomp支持安装<code class="fe lv lw lx ly b">libseccomp</code>包:</p><pre class="kj kk kl km gt pm ly pn po aw pp bi"><span id="273b" class="mw ma it ly b gy pq pr l ps pt">$ sudo apt install <!-- -->libseccomp2 libseccomp-dev</span></pre><p id="a16a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装<code class="fe lv lw lx ly b">runc</code>:</p><pre class="kj kk kl km gt pm ly pn po aw pp bi"><span id="b89a" class="mw ma it ly b gy pq pr l ps pt">$ go get -v github.com/opencontainers/runc<br/>$ cd $GOPATH/src/github.com/opencontainers/runc<br/>$ make -j`nproc`<br/>$ sudo env PATH="$PATH" make install</span></pre><p id="acbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要<code class="fe lv lw lx ly b">btrfs</code>包来准备<code class="fe lv lw lx ly b">protobuf</code>安装:</p><pre class="kj kk kl km gt pm ly pn po aw pp bi"><span id="9633" class="mw ma it ly b gy pq pr l ps pt">sudo apt install btrfs-progs libbtrfs-dev</span></pre><p id="ef8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们下载<code class="fe lv lw lx ly b">protobuf</code>源代码并构建它们:</p><pre class="kj kk kl km gt pm ly pn po aw pp bi"><span id="0423" class="mw ma it ly b gy pq pr l ps pt">$ wget <a class="ae ky" href="https://github.com/protocolbuffers/protobuf/archive/v3.14.0.tar.gz" rel="noopener ugc nofollow" target="_blank">https://github.com/protocolbuffers/protobuf/archive/v3.14.0.tar.gz</a> -O protobuf_v3.14.0.tar.gz<br/>$ tar xzf protobuf_v3.14.0.tar.gz<br/>$ cd protobuf-3.14.0/<br/>$ ./autogen.sh<br/>$ <!-- -->./configure<br/>$ make -j`nproc`<br/>$ make -l2 -j`nproc` check<br/>$ sudo make install</span></pre><p id="729a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们下载<code class="fe lv lw lx ly b">containerd</code>源代码并构建它们:</p><pre class="kj kk kl km gt pm ly pn po aw pp bi"><span id="7749" class="mw ma it ly b gy pq pr l ps pt">$ go get -v github.com/containerd/containerd<br/>$ cd $GOPATH/src/github.com/containerd/containerd<br/>$ make -j`nproc`<br/>$ sudo env PATH="$PATH" make install</span></pre><p id="06f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建完成后，我们可以检查二进制文件:</p><pre class="kj kk kl km gt pm ly pn po aw pp bi"><span id="936f" class="mw ma it ly b gy pq pr l ps pt">$ containerd --version<br/>containerd github.com/containerd/containerd v1.5.0-beta.1 cfa842c278694860a7e32917066f4a24978f80d0</span></pre><p id="5ff3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们部署提供的<code class="fe lv lw lx ly b">systemd</code>服务文件，将<code class="fe lv lw lx ly b">containerd</code>作为守护进程运行:</p><pre class="kj kk kl km gt pm ly pn po aw pp bi"><span id="eb5e" class="mw ma it ly b gy pq pr l ps pt">cd $GOPATH/src/github.com/containerd/containerd<br/>sudo cp containerd.service /etc/systemd/system/<br/>sudo systemctl daemon-reload<br/>sudo systemctl enable containerd.service<br/>sudo systemctl start containerd.service</span></pre><h2 id="9055" class="mw ma it bd mb mx my dn mf mz na dp mj li nb nc ml lm nd ne mn lq nf ng mp nh bi translated">与containerd交互</h2><p id="fad1" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们将使用<code class="fe lv lw lx ly b">ctr</code>命令与<code class="fe lv lw lx ly b">containerd</code>进行交互。它包含在<code class="fe lv lw lx ly b">containerd</code>安装中:</p><pre class="kj kk kl km gt pm ly pn po aw pp bi"><span id="6280" class="mw ma it ly b gy pq pr l ps pt">NAME:<br/>   ctr -<br/>        __<br/>  _____/ /______<br/> / ___/ __/ ___/<br/>/ /__/ /_/ /<br/>\___/\__/_/</span><span id="9a8d" class="mw ma it ly b gy pu pr l ps pt">containerd CLI</span><span id="a260" class="mw ma it ly b gy pu pr l ps pt">USAGE:<br/>   ctr [global options] command [command options] [arguments...]</span><span id="d24a" class="mw ma it ly b gy pu pr l ps pt">VERSION:<br/>   v1.5.0-beta.1</span><span id="73ba" class="mw ma it ly b gy pu pr l ps pt">DESCRIPTION:</span><span id="3d38" class="mw ma it ly b gy pu pr l ps pt">ctr is an unsupported debug and administrative client for interacting<br/>with the containerd daemon. Because it is unsupported, the commands,<br/>options, and operations are not guaranteed to be backward compatible or<br/>stable from release to release of the containerd project.</span><span id="d19e" class="mw ma it ly b gy pu pr l ps pt">COMMANDS:<br/>   plugins, plugin            provides information about containerd plugins<br/>   version                    print the client and server versions<br/>   containers, c, container   manage containers<br/>   content                    manage content<br/>   events, event              display containerd events<br/>   images, image, i           manage images<br/>   leases                     manage leases<br/>   namespaces, namespace, ns  manage namespaces<br/>   pprof                      provide golang pprof outputs for containerd<br/>   run                        run a container<br/>   snapshots, snapshot        manage snapshots<br/>   tasks, t, task             manage tasks<br/>   install                    install a new package<br/>   oci                        OCI tools<br/>   shim                       interact with a shim directly<br/>   help, h                    Shows a list of commands or help for one command</span><span id="dd41" class="mw ma it ly b gy pu pr l ps pt">GLOBAL OPTIONS:<br/>   --debug                      enable debug output in logs<br/>   --address value, -a value    address for containerd's GRPC server (default: "/run/containerd/containerd.sock") [$CONTAINERD_ADDRESS]<br/>   --timeout value              total timeout for ctr commands (default: 0s)<br/>   --connect-timeout value      timeout for connecting to containerd (default: 0s)<br/>   --namespace value, -n value  namespace to use with commands (default: "default") [$CONTAINERD_NAMESPACE]<br/>   --help, -h                   show help<br/>   --version, -v                print the version</span></pre><p id="0cdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">containerd</code>可以从一个容器注册表中拉图片，它支持标签。我们使用<code class="fe lv lw lx ly b">ctr</code>来拉动<code class="fe lv lw lx ly b">nginx</code>图像:</p><pre class="kj kk kl km gt pm ly pn po aw pp bi"><span id="9562" class="mw ma it ly b gy pq pr l ps pt">$ sudo ctr image pull docker.io/library/nginx:latest</span></pre><p id="a4d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">ctr</code>我们可以得到图像列表。我们可以确保已经提取了<code class="fe lv lw lx ly b">nginx</code>图像:</p><pre class="kj kk kl km gt pm ly pn po aw pp bi"><span id="9b27" class="mw ma it ly b gy pq pr l ps pt">$ sudo ctr image ls<br/>$ sudo ctr image ls -q<br/>docker.io/library/nginx:latest</span></pre><p id="d2ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有了<code class="fe lv lw lx ly b">nginx</code>图像，现在我们可以使用它运行一个容器:</p><pre class="kj kk kl km gt pm ly pn po aw pp bi"><span id="43b8" class="mw ma it ly b gy pq pr l ps pt">$ sudo ctr container create docker.io/library/nginx:latest webdemo</span></pre><p id="bee0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">容器在运行吗？让我们通过列出容器来确认:</p><pre class="kj kk kl km gt pm ly pn po aw pp bi"><span id="1612" class="mw ma it ly b gy pq pr l ps pt">$ sudo ctr container list<br/>CONTAINER    IMAGE                             RUNTIME<br/>webdemo      docker.io/library/nginx:latest    io.containerd.runc.v2</span></pre><p id="df6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们删除映像，容器仍在运行:</p><pre class="kj kk kl km gt pm ly pn po aw pp bi"><span id="4116" class="mw ma it ly b gy pq pr l ps pt">$ sudo ctr image remove docker.io/library/nginx:latest<br/>docker.io/library/nginx:latest<br/>$ sudo ctr image ls -q<br/>$ sudo ctr container list<br/>CONTAINER    IMAGE                             RUNTIME<br/>webdemo      docker.io/library/nginx:latest    io.containerd.runc.v2</span></pre><p id="15cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以移除容器了:</p><pre class="kj kk kl km gt pm ly pn po aw pp bi"><span id="00ec" class="mw ma it ly b gy pq pr l ps pt">sudo ctr container delete webdemo</span></pre></div><div class="ab cl pa pb hx pc" role="separator"><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf"/></div><div class="im in io ip iq"><h1 id="6e2f" class="lz ma it bd mb mc ph me mf mg pi mi mj jz pj ka ml kc pk kd mn kf pl kg mp mq bi translated">结论</h1><p id="40bd" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们对<code class="fe lv lw lx ly b">docker</code>的历史进行了概述。我们已经看到它是一个整体软件。Docker为定义OCI的集装箱标准做出了贡献。结果，<code class="fe lv lw lx ly b">docker</code>的建筑发生了变化。</p><p id="e14a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最初，<code class="fe lv lw lx ly b">kubernetes</code>使用的是<code class="fe lv lw lx ly b">docker</code>，但在1.20版本中决定弃用它。我们已经看到<code class="fe lv lw lx ly b">docker</code>与<code class="fe lv lw lx ly b">containerd</code>和<code class="fe lv lw lx ly b">runc</code>通信来运行容器。它的附加价值是为开发人员管理图像和资源提供良好的用户体验。</p><p id="8f17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<code class="fe lv lw lx ly b">kubernetes</code>这样的分布式系统，可以直接调用容器运行时。额外的一层是不需要的，并且会产生复杂性和跨软件层的更多调用。</p><p id="c794" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们通过在Raspberry Pi上安装和配置它来练习<code class="fe lv lw lx ly b">containerd</code>。这是一个测试<code class="fe lv lw lx ly b">containerd</code>的好目标，因为它的资源有限，而且大多数时候你不会在它上面构建映像。您只想提取图像并将其放入容器中。我们发现我们可以像往常一样用<code class="fe lv lw lx ly b">containerd</code>提取<code class="fe lv lw lx ly b">docker</code>图像和启动容器。</p><p id="7d54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl pa pb hx pc" role="separator"><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf"/></div><div class="im in io ip iq"><h1 id="f05a" class="lz ma it bd mb mc ph me mf mg pi mi mj jz pj ka ml kc pk kd mn kf pl kg mp mq bi translated">资源</h1><div class="nx ny gp gr nz oa"><a href="https://kubernetes.io/blog/2020/12/02/dont-panic-kubernetes-and-docker/" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">不要惊慌:Kubernetes和Docker</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">作者:豪尔赫卡斯特罗，达菲库利，凯特科斯格罗维，贾斯汀加里森，诺亚坎特罗威茨，鲍勃基伦，雷伊莱亚诺，丹“流行”…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">kubernetes.io</p></div></div><div class="oj l"><div class="pv l ol om on oj oo ks oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a href="https://github.com/containerd/containerd" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">集装箱/集装箱</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">containerd是一个行业标准的容器运行时，强调简单性、健壮性和可移植性。这是…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="pw l ol om on oj oo ks oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a href="https://www.docker.com/blog/what-is-containerd-runtime/" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">什么是containerd？- Docker博客</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">我们在过去已经谈过几次containerd的不同特性，它是如何设计的，以及一些问题…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">www.docker.com</p></div></div><div class="oj l"><div class="px l ol om on oj oo ks oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a href="https://opencontainers.org/" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">开放集装箱倡议</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">尽管世界在2020年面临挑战，但OCI社区齐心协力，取得了一些令人兴奋的新进展…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">opencontainers.org</p></div></div><div class="oj l"><div class="py l ol om on oj oo ks oa"/></div></div></a></div></div></div>    
</body>
</html>