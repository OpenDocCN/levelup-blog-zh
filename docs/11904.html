<html>
<head>
<title>What’s Mediastreamer2. Ticker load management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是Mediastreamer2。跑马灯负载管理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/whats-mediastreamer2-ticker-load-management-62d0efc9a9f0?source=collection_archive---------16-----------------------#2022-04-26">https://levelup.gitconnected.com/whats-mediastreamer2-ticker-load-management-62d0efc9a9f0?source=collection_archive---------16-----------------------#2022-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/12a83b61623358045d23e6557024dbff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cyHLOZuBPQ9zKaFcqXxJ2g.png"/></div></figure><p id="833a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">(上一篇文章<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/whats-mediastreamer2-debugging-craft-filters-83a07192c341">什么是Mediastreamer2。调试<br/>精心制作的过滤器</a></p><p id="f3b5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Ticker负载的计算方法是，处理连接到此tickser的图形的所有过滤器所花费的时间与tick之间的时间间隔之比。默认情况下，时间间隔为10ms，但如果您更改采样速率，则会根据您设置的值进行计算。计算是根据跑马灯在运行过程中积累的信息进行的。Mediastreamer提供了一个函数，该函数返回多次测量的平均值，以百分比表示:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="88c3" class="lc ld iq ky b gy le lf l lg lh">MS2_PUBLIC float ms_ticker_get_average_load(MSTicker *ticker);</span></pre><p id="e7dc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果返回值接近100%，这意味着在下一个tick开始之前，这个tick只能勉强跟上它的工作。如果我们有一个不需要实时工作的应用程序(例如，它只是将声音写入一个文件)，那么下一次ticker调用被推迟了多长时间对我们来说并不重要。但在实时应用中，处理延迟会影响发送RTP包的时刻，进而影响声音或视频的质量。在某些情况下，可以通过在接收端使用分组缓冲器(所谓的抖动缓冲器)来消除单个分组的延迟影响。在这种情况下，您的声音将无缺陷地播放，但延迟与缓冲区长度成比例。在音频信号用于控制实时过程的情况下，这是不可接受的。</p><p id="a325" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当ticker负载超过80%限制时，您应该开始采取行动。有了这样的负载，ticker开始处理时会有一定的时钟周期延迟。股票延迟是指下一次股票上市被推迟的时间。如果跑马灯延迟超过某个值，则生成一个事件<em class="li"> MSTickerLateEvent </em>:</p><p id="58f3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">清单7.1:结构MSTickerLateEvent</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="aa70" class="lc ld iq ky b gy le lf l lg lh">struct _MSTickerLateEvent{<br/>  int lateMs; /* The last time delay, in milliseconds. */<br/>  uint64_t time; /* The time the event occurred, in milliseconds. */<br/>int current_late_ms; /* Delay at the current tick, in milliseconds. */<br/>};</span><span id="1ea2" class="lc ld iq ky b gy lj lf l lg lh">typedef struct _MSTickerLateEvent MSTickerLateEvent;</span></pre><p id="289f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它会向控制台显示如下所示的消息:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="0802" class="lc ld iq ky b gy le lf l lg lh">ortp-warning-MSTicker: We are late of 164 miliseconds</span></pre><p id="44f3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用函数</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="8226" class="lc ld iq ky b gy le lf l lg lh">void ms_ticker_get_last_late_tick(MSTicker *ticker, MSTickerLateEvent *ev);</span></pre><p id="6ede" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">可以找到上一次此类事件的详细信息。</p><h1 id="26dd" class="lk ld iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">7.1<br/>降低负载的方法</h1><p id="23d6" class="pw-post-body-paragraph ju jv iq jw b jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ij bi translated">这里我们有两个选择。第一个是更改ticker的优先级，第二个是将ticker的部分任务转移到另一个线程。让我们考虑这些选择。</p><h1 id="701b" class="lk ld iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">改变优先级</h1><p id="73e3" class="pw-post-body-paragraph ju jv iq jw b jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ij bi translated">Ticker优先级有三个等级，在枚举<br/> <em class="li"> MSTickerPrio </em>中定义:</p><p id="8f55" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">清单7.2:枚举MSTickerPrio</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="e2a8" class="lc ld iq ky b gy le lf l lg lh">enum _MSTickerPrio{</span><span id="0a1d" class="lc ld iq ky b gy lj lf l lg lh">MS_TICKER_PRIO_NORMAL, /* The priority corresponding to the default value for the given OS. */</span><span id="13b7" class="lc ld iq ky b gy lj lf l lg lh">MS_TICKER_PRIO_HIGH, /* The increased priority is set under Linux/MacOS using setpriority() or sched_setschedparams(), the SCHED_RR policy is set. */</span><span id="9466" class="lc ld iq ky b gy lj lf l lg lh">MS_TICKER_PRIO_REALTIME /* The highest priority, for it under Linux the SCHED_FIFO policy is used. */<br/>};</span><span id="7cbb" class="lc ld iq ky b gy lj lf l lg lh">typedef enum _MSTickerPrio MSTickerPrio;</span></pre><p id="6d1d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了试验ticker负载，我们需要一个电路，在运行期间提升负载，并在负载达到99%时关断。我们将使用以下方案作为负载:通过在<em class="li"> dtmfgen </em>和<em class="li"> voidsink </em>之间添加新的信号电平控制(滤波器类型MS_VOLUME)来增加负载，增益不等于1，这样滤波器就不会偷懒。如图<a class="ae ks" href="#fig____________________" rel="noopener ugc nofollow"> 7.1 </a>所示。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="56aa" class="lc ld iq ky b gy le lf l lg lh">ticker -&gt; voidsource -&gt; dtmfgen -&gt; voidsink</span></pre><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/8bf9e8ad1f752d06e270ca816d5d62ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*FREZda0V78zkO78OkonloA.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">图7.1:滚动条加载</figcaption></figure><p id="826e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">清单<a class="ae ks" href="#lis__________________________________1" rel="noopener ugc nofollow"> 7.3 </a>中显示了源代码，并提供了注释，因此很容易理解:</p><p id="ea8f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">清单7.3:可变的计算负载</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="5243" class="lc ld iq ky b gy le lf l lg lh">/* File mstest13.c Variable computational load. */</span><span id="2901" class="lc ld iq ky b gy lj lf l lg lh">#include &lt;stdio.h&gt;<br/>#include &lt;signal.h&gt;</span><span id="8c7d" class="lc ld iq ky b gy lj lf l lg lh">#include &lt;Mediastreamer2/msfilter.h&gt;<br/>#include &lt;Mediastreamer2/msticker.h&gt;<br/>#include &lt;Mediastreamer2/dtmfgen.h&gt;<br/>#include &lt;Mediastreamer2/mssndcard.h&gt;<br/>#include &lt;Mediastreamer2/msvolume.h&gt;</span><span id="36de" class="lc ld iq ky b gy lj lf l lg lh">/*----------------------------------------------------------*/<br/>struct _app_vars<br/>{<br/>    int  step;              /* The number of filters to add at a time. */<br/>    int  limit;             /* The number of filters on which to finish the job. */<br/>    int  ticker_priority;   /* Ticker priority. */<br/>    char* file_name;        /* Output file name. */<br/>    FILE *file;<br/>};</span><span id="9863" class="lc ld iq ky b gy lj lf l lg lh">typedef struct _app_vars app_vars;<br/>/*----------------------------------------------------------*/<br/>/* Function to convert command line arguments to   program settings. */<br/>void  scan_args(int argc, char *argv[], app_vars *v)<br/>{<br/>    char i;<br/>    for (i=0; i&lt;argc; i++)<br/>    {<br/>        if (!strcmp(argv[i], "--help"))<br/>        {<br/>            char *p=argv[0]; p=p + 2;<br/>            printf("  %s computational load\n\n", p);<br/>            printf("--help      List of options.\n");<br/>            printf("--version   Version of application.\n");<br/>            printf("--step      Filters count per step.\n");<br/>            printf("--tprio     Ticker priority:\n"<br/>                    "            MS_TICKER_PRIO_NORMAL   0\n"<br/>                    "            MS_TICKER_PRIO_HIGH     1\n"<br/>                    "            MS_TICKER_PRIO_REALTIME 2\n");<br/>            printf("--limit     Filters count limit.\n");<br/>            printf("-o          Output file name.\n");<br/>            exit(0);<br/>        }</span><span id="65d9" class="lc ld iq ky b gy lj lf l lg lh">        if (!strcmp(argv[i], "--version"))<br/>        {<br/>            printf("0.1\n");<br/>            exit(0);<br/>        }</span><span id="acd4" class="lc ld iq ky b gy lj lf l lg lh">        if (!strcmp(argv[i], "--step"))<br/>        {<br/>            v-&gt;step = atoi(argv[i+1]);<br/>            printf("step: %i\n", v-&gt;step);<br/>        }</span><span id="435d" class="lc ld iq ky b gy lj lf l lg lh">        if (!strcmp(argv[i], "--tprio"))<br/>        {<br/>            int prio = atoi(argv[i+1]);<br/>            if ((prio &gt;=MS_TICKER_PRIO_NORMAL) &amp;&amp; (prio &lt;= MS_TICKER_PRIO_REALTIME))<br/>            {<br/>                v-&gt;ticker_priority = atoi(argv[i+1]);<br/>                printf("ticker priority: %i\n", v-&gt;ticker_priority);<br/>            }<br/>            else<br/>            {<br/>                printf(" Bad ticker priority: %i\n", prio);<br/>                exit(1);<br/>            }<br/>        }</span><span id="dd04" class="lc ld iq ky b gy lj lf l lg lh">        if (!strcmp(argv[i], "--limit"))<br/>        {<br/>            v-&gt;limit = atoi(argv[i+1]);<br/>            printf("limit: %i\n", v-&gt;limit);<br/>        }</span><span id="3100" class="lc ld iq ky b gy lj lf l lg lh">        if (!strcmp(argv[i], "-o"))<br/>        {<br/>            v-&gt;file_name=argv[i+1];<br/>            printf("file namet: %s\n", v-&gt;file_name);<br/>        }<br/>    }<br/>}</span><span id="9f52" class="lc ld iq ky b gy lj lf l lg lh">/*----------------------------------------------------------*/<br/>/* Structure for storing program settings. */<br/>app_vars vars;</span><span id="51ab" class="lc ld iq ky b gy lj lf l lg lh">/*----------------------------------------------------------*/<br/>void saveMyData()<br/>{<br/>    // We close the file.<br/>    if (vars.file) fclose(vars.file);<br/>    exit(0);<br/>}</span><span id="1b4a" class="lc ld iq ky b gy lj lf l lg lh">void signalHandler( int signalNumber )<br/>{<br/>    static pthread_once_t semaphore = PTHREAD_ONCE_INIT;<br/>    printf("\nsignal %i received.\n", signalNumber);<br/>    pthread_once( &amp; semaphore, saveMyData );<br/>}</span><span id="4b59" class="lc ld iq ky b gy lj lf l lg lh">/*----------------------------------------------------------*/<br/>int main(int argc, char *argv[])<br/>{<br/>    /* We set the default settings. */<br/>    app_vars vars={100, 100500, MS_TICKER_PRIO_NORMAL, 0};</span><span id="1e25" class="lc ld iq ky b gy lj lf l lg lh">    // We connect the handler Ctrl-C.<br/>    signal( SIGTERM, signalHandler );<br/>    signal( SIGINT,  signalHandler );</span><span id="0b71" class="lc ld iq ky b gy lj lf l lg lh">    /* We set the program settings to <br/>       according to the command line arguments. */<br/>    scan_args(argc, argv, &amp;vars);</span><span id="4b58" class="lc ld iq ky b gy lj lf l lg lh">    if (vars.file_name)<br/>    {<br/>        vars.file = fopen(vars.file_name, "w");<br/>    }</span><span id="0fe4" class="lc ld iq ky b gy lj lf l lg lh">    ms_init();<br/>    /* We create instances of filters. */<br/>    MSFilter  *voidsource=ms_filter_new(MS_VOID_SOURCE_ID);<br/>    MSFilter  *dtmfgen=ms_filter_new(MS_DTMF_GEN_ID);</span><span id="a304" class="lc ld iq ky b gy lj lf l lg lh">    MSSndCard *card_playback=ms_snd_card_manager_get_default_card(ms_snd_card_manager_get());<br/>    MSFilter  *snd_card_write=ms_snd_card_create_writer(card_playback);<br/>    MSFilter  *voidsink=ms_filter_new(MS_VOID_SINK_ID);</span><span id="5142" class="lc ld iq ky b gy lj lf l lg lh">    MSDtmfGenCustomTone dtmf_cfg;</span><span id="3a8e" class="lc ld iq ky b gy lj lf l lg lh">    /* We set the name of our signal, keeping in mind that in the array       we must leave room for a zero that marks the end strings. */<br/>    strncpy(dtmf_cfg.tone_name, "busy", sizeof(dtmf_cfg.tone_name));<br/>    dtmf_cfg.duration=1000;<br/>    dtmf_cfg.frequencies[0]=440; /* We will generate one tone, set the frequency of the second tone to 0. */<br/>    dtmf_cfg.frequencies[1]=0;<br/>    dtmf_cfg.amplitude=1.0; /*This sine amplitude should correspond to a measurement result of 0.707.*/<br/>    dtmf_cfg.interval=0.;<br/>    dtmf_cfg.repeat_count=0.;</span><span id="79af" class="lc ld iq ky b gy lj lf l lg lh">    /* We set variables to store the result. */<br/>    float load=0.;<br/>    float latency=0.;<br/>    int filter_count=0;</span><span id="ce5b" class="lc ld iq ky b gy lj lf l lg lh">    /* Create a ticker. */<br/>    MSTicker *ticker=ms_ticker_new();<br/>    ms_ticker_set_priority(ticker, vars.ticker_priority);</span><span id="e2e2" class="lc ld iq ky b gy lj lf l lg lh">    /* We connect filters in a chain. */<br/>    ms_filter_link(voidsource, 0, dtmfgen, 0);<br/>    ms_filter_link(dtmfgen, 0, voidsink, 0);</span><span id="873a" class="lc ld iq ky b gy lj lf l lg lh">    MSFilter* previous_filter=dtmfgen;<br/>    int gain=1;<br/>    int i;</span><span id="2fb3" class="lc ld iq ky b gy lj lf l lg lh">    printf("# filters load\n");<br/>    if (vars.file)<br/>    {<br/>        fprintf(vars.file, "# filters load\n");<br/>    }</span><span id="daf8" class="lc ld iq ky b gy lj lf l lg lh">    while ((load &lt;= 99.) &amp;&amp; (filter_count &lt; vars.limit))<br/>    {<br/>        // Temporarily disable the packet absorber from the circuit.<br/>        ms_filter_unlink(previous_filter, 0, voidsink, 0);<br/>        MSFilter  *volume;<br/>        for (i=0; i&lt;vars.step; i++)<br/>        {<br/>            volume=ms_filter_new(MS_VOLUME_ID);<br/>            ms_filter_call_method(volume, MS_VOLUME_SET_DB_GAIN, &amp;gain);<br/>            ms_filter_link(previous_filter, 0, volume, 0);<br/>            previous_filter = volume;<br/>        }<br/>        // We return the "absorber" of packets to the schema.<br/>        ms_filter_link(volume, 0, voidsink, 0);</span><span id="9eef" class="lc ld iq ky b gy lj lf l lg lh">        /* We connect the clock source. */<br/>        ms_ticker_attach(ticker,voidsource);</span><span id="a077" class="lc ld iq ky b gy lj lf l lg lh">        /* We turn on the sound generator. */<br/>        ms_filter_call_method(dtmfgen, MS_DTMF_GEN_PLAY_CUSTOM, (void*)&amp;dtmf_cfg);</span><span id="be51" class="lc ld iq ky b gy lj lf l lg lh">        /* We give time 100 milliseconds to accumulate data for averaging. */<br/>        ms_usleep(500000);</span><span id="d5eb" class="lc ld iq ky b gy lj lf l lg lh">        /* We read the measurement result. */<br/>        load=ms_ticker_get_average_load(ticker);</span><span id="581c" class="lc ld iq ky b gy lj lf l lg lh">        filter_count=filter_count + vars.step;</span><span id="9e18" class="lc ld iq ky b gy lj lf l lg lh">        /* Disable the clock source. */<br/>        ms_ticker_detach(ticker,voidsource);</span><span id="903d" class="lc ld iq ky b gy lj lf l lg lh">        printf("%i  %f\n", filter_count, load);<br/>        if (vars.file) fprintf(vars.file,"%i  %f\n", filter_count, load);<br/>    }<br/>    if (vars.file) fclose(vars.file);<br/>}</span></pre><p id="909a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以名称<em class="li"> mstest13.c </em>保存它，并使用以下命令编译它:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="67e6" class="lc ld iq ky b gy le lf l lg lh">$ gcc mstest13.c -o mstest13 `pkg-config Mediastreamer2 - -libs - -cflags`</span></pre><p id="b84e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，我们启动我们的工具来估计优先级最低的ticker的负载:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="7f05" class="lc ld iq ky b gy le lf l lg lh">$ ./mstest13 - -step 100 - -limit 40000 - -tprio 0 -o log0.txt</span><span id="f5c4" class="lc ld iq ky b gy lj lf l lg lh">$ ./mstest13 - -step 100 - -limit 40000 - -tprio 1 -o log1.txt</span><span id="1384" class="lc ld iq ky b gy lj lf l lg lh">$ ./mstest13 - -step 100 - -limit 40000 - -tprio 2 -o log2.txt</span></pre><p id="126c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，我们将生成的文件<em class="li"> log0.txt、log1.txt、log2.txt </em>馈送到优秀的<em class="li"> gnuplot </em>实用程序:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="e7d7" class="lc ld iq ky b gy le lf l lg lh">$ gnuplot -e "set terminal png; set output 'load.png'; plot 'log0.txt' using 1:2 with lines , 'log1.txt' using 1:2 with lines, 'log2.txt' using 1:2 with lines"</span></pre><p id="f2f0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">作为程序工作的结果，将创建<em class="li">load.png</em>文件，其中的图形将如<a class="ae ks" href="#fig____________________" rel="noopener ugc nofollow"> 7.2 </a>所示。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/eb424abed67def2106a9bc83bc945031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uv59oEs-bTDbPcWXkthRJg.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">图7.2:不同优先级的跑马灯负载</figcaption></figure><p id="9d21" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">垂直显示ticker负载百分比，水平显示添加的负载过滤器数量。在该图中，我们看到，正如预期的那样，对于优先级2(蓝线)，连接6000个滤波器时观察到第一个明显的过冲，而对于优先级0(紫色)和1(绿色)，过冲出现得更早，分别有1000个和3000个滤波器。分别是。</p><p id="aff3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了获得平均结果，您需要执行更多的程序运行，但是在这个图表中我们已经看到，ticker负载与过滤器的数量成比例地线性增长。</p><h1 id="0363" class="lk ld iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">7.1.2将部分作业<br/>转移到另一个线程</h1><p id="7893" class="pw-post-body-paragraph ju jv iq jw b jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ij bi translated">如果你的任务可以分成两个或多个线程，那么一切都很简单——创建一个或多个新的tickers，并将你的过滤器连接到每个图。如果任务不能并行化，那么可以通过将过滤器链分成几个片段来“跨越”划分任务，每个片段将在单独的线程中工作(即，具有自己的跑马灯)。接下来，您需要“缝合”数据流，以便第一个片段的输出可以到达下一个片段的输入。线程间的这种数据传输是使用两个特殊的过滤器MS_ITC_SINK和MS_ITC_SOURCE来执行的，它们统称为“intertickers”。</p><h2 id="b16a" class="lc ld iq bd ll mw mx dn lp my mz dp lt kf na nb lx kj nc nd mb kn ne nf mf ng bi translated">Intertickers</h2><p id="ab1f" class="pw-post-body-paragraph ju jv iq jw b jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ij bi translated">过滤器MS _ ITC _提供线程的数据输出，它只有一个输入，没有输出。过滤器MS_ITC_SOURCE提供异步数据进入线程，它有一个输出，它没有输入。就媒体流而言，这一对过滤器使得在从不同跑马灯操作的过滤器之间传输数据成为可能。</p><p id="eba6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要开始数据传输，需要连接这些过滤器，但连接方式不同于普通过滤器，即使用<em class="li"> ms_filter_link() </em>功能。在这种情况下，使用MS_ITC_SINK筛选器的MS_ITC_SINK_CONNECT方法:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="0759" class="lc ld iq ky b gy le lf l lg lh">ms_filter_call_method (itc_sink, MS_ITC_SINK_CONNECT, itc_src)</span></pre><p id="b7f3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该方法使用异步队列连接两个筛选器。没有分离内部贴纸的方法。</p><h2 id="2633" class="lc ld iq bd ll mw mx dn lp my mz dp lt kf na nb lx kj nc nd mb kn ne nf mf ng bi translated">使用intertikers的示例</h2><p id="a30e" class="pw-post-body-paragraph ju jv iq jw b jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ij bi translated">下面，在图<a class="ae ks" href="#fig_______________________" rel="noopener ugc nofollow"> 7.3 </a>中，展示了一个使用图的例子。三箭头显示了两个线程之间的异步队列。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/49062ccc5460525a2bdfd749c7ad8d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*9dct-70_g59nOQ0jguBOHA.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">图7.3:交互滚动条应用程序</figcaption></figure><p id="b666" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，我们根据这个方案修改我们的测试程序，以便由intertikers连接的两个线程在其中工作，如图所示。每个线程都有一个插入点，在那里可以添加新的加载过滤器实例，如图<a class="ae ks" href="#fig__________________________" rel="noopener ugc nofollow"> 7.4 </a>所示。添加的过滤器数量将在线程之间精确地分成两半。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi ni"><img src="../Images/3dcba017ec27bd04be574e1578718b68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*80RFEwUWPM1llbJfwJt8Ew.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">图7.4:在两个线程之间分担负载</figcaption></figure><p id="e052" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">相应的程序代码如清单<a class="ae ks" href="#lis_________________________________" rel="noopener ugc nofollow"> 7.4 </a>所示。</p><p id="58be" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">清单7.4:inter ticker的可变计算负载</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="21e6" class="lc ld iq ky b gy le lf l lg lh">/* File mstest14.c Variable computational load with inter-stickers. */</span><span id="c625" class="lc ld iq ky b gy lj lf l lg lh">#include &lt;stdio.h&gt;<br/>#include &lt;signal.h&gt;</span><span id="98be" class="lc ld iq ky b gy lj lf l lg lh">#include &lt;Mediastreamer2/msfilter.h&gt;<br/>#include &lt;Mediastreamer2/msticker.h&gt;<br/>#include &lt;Mediastreamer2/dtmfgen.h&gt;<br/>#include &lt;Mediastreamer2/mssndcard.h&gt;<br/>#include &lt;Mediastreamer2/msvolume.h&gt;<br/>#include &lt;Mediastreamer2/msitc.h&gt;</span><span id="cf41" class="lc ld iq ky b gy lj lf l lg lh">/*----------------------------------------------------------*/<br/>struct _app_vars<br/>{<br/>    int  step;              /* The number of filters to add at a time. */<br/>    int  limit;             /* The number of filters on which law to work. */<br/>    int  ticker_priority;   /* Ticker priority. */<br/>    char* file_name;        /* Output file name. */<br/>    FILE *file;<br/>};</span><span id="2aa8" class="lc ld iq ky b gy lj lf l lg lh">typedef struct _app_vars app_vars;</span><span id="a233" class="lc ld iq ky b gy lj lf l lg lh">/*----------------------------------------------------------*/<br/>/* Function to convert command line arguments to    program settings. */<br/>void  scan_args(int argc, char *argv[], app_vars *v)<br/>{<br/>    char i;<br/>    for (i=0; i&lt;argc; i++)<br/>    {<br/>        if (!strcmp(argv[i], "--help"))<br/>        {<br/>            char *p=argv[0]; p=p + 2;<br/>            printf("  %s computational load diveded for two threads.\n\n", p);<br/>            printf("--help      List of options.\n");<br/>            printf("--version   Version of application.\n");<br/>            printf("--step      Filters count per step.\n");<br/>            printf("--tprio     Ticker priority:\n"<br/>                    "            MS_TICKER_PRIO_NORMAL   0\n" <br/>                    "            MS_TICKER_PRIO_HIGH     1\n"<br/>                    "            MS_TICKER_PRIO_REALTIME 2\n");<br/>            printf("--limit     Filters count limit.\n");<br/>            printf("-o          Output file name.\n");<br/>            exit(0);<br/>        }</span><span id="333a" class="lc ld iq ky b gy lj lf l lg lh">        if (!strcmp(argv[i], "--version"))<br/>        {<br/>            printf("0.1\n");<br/>            exit(0);<br/>        }</span><span id="ac62" class="lc ld iq ky b gy lj lf l lg lh">        if (!strcmp(argv[i], "--step"))<br/>        {<br/>            v-&gt;step = atoi(argv[i+1]);<br/>            printf("step: %i\n", v-&gt;step);<br/>        }</span><span id="bb50" class="lc ld iq ky b gy lj lf l lg lh">        if (!strcmp(argv[i], "--tprio"))<br/>        {<br/>            int prio = atoi(argv[i+1]);<br/>            if ((prio &gt;=MS_TICKER_PRIO_NORMAL) &amp;&amp; (prio &lt;= MS_TICKER_PRIO_REALTIME))<br/>            { <br/>                v-&gt;ticker_priority = atoi(argv[i+1]);<br/>                printf("ticker priority: %i\n", v-&gt;ticker_priority);<br/>            }<br/>            else<br/>            {<br/>                printf(" Bad ticker priority: %i\n", prio);<br/>                exit(1);<br/>            }<br/>        }</span><span id="7c34" class="lc ld iq ky b gy lj lf l lg lh">        if (!strcmp(argv[i], "--limit"))<br/>        {<br/>            v-&gt;limit = atoi(argv[i+1]);<br/>            printf("limit: %i\n", v-&gt;limit);<br/>        }</span><span id="2a64" class="lc ld iq ky b gy lj lf l lg lh">        if (!strcmp(argv[i], "-o"))<br/>        {<br/>            v-&gt;file_name=argv[i+1];<br/>            printf("file namet: %s\n", v-&gt;file_name);<br/>        }<br/>    }<br/>}</span><span id="4810" class="lc ld iq ky b gy lj lf l lg lh">/*----------------------------------------------------------*/<br/>/* Structure for storing program settings. */<br/>app_vars vars;</span><span id="8b02" class="lc ld iq ky b gy lj lf l lg lh">/*----------------------------------------------------------*/<br/>void saveMyData()<br/>{<br/>    // We close the file.<br/>    if (vars.file) fclose(vars.file);<br/>    exit(0);<br/>}</span><span id="8bee" class="lc ld iq ky b gy lj lf l lg lh">void signalHandler( int signalNumber )<br/>{<br/>    static pthread_once_t semaphore = PTHREAD_ONCE_INIT;<br/>    printf("\nsignal %i received.\n", signalNumber);<br/>    pthread_once( &amp; semaphore, saveMyData );<br/>}</span><span id="4918" class="lc ld iq ky b gy lj lf l lg lh">/*----------------------------------------------------------*/<br/>int main(int argc, char *argv[])<br/>{<br/>    /* We set the default settings. */<br/>    app_vars vars={100, 100500, MS_TICKER_PRIO_NORMAL, 0};</span><span id="a8a3" class="lc ld iq ky b gy lj lf l lg lh">    // We connect the handler Ctrl-C.<br/>    signal( SIGTERM, signalHandler );<br/>    signal( SIGINT,  signalHandler );</span><span id="c47b" class="lc ld iq ky b gy lj lf l lg lh">    /* We set the program settings to according to the command line arguments. */<br/>    scan_args(argc, argv, &amp;vars);</span><span id="f662" class="lc ld iq ky b gy lj lf l lg lh">    if (vars.file_name)<br/>    {<br/>        vars.file = fopen(vars.file_name, "w");<br/>    }</span><span id="453c" class="lc ld iq ky b gy lj lf l lg lh">    ms_init();</span><span id="f3f5" class="lc ld iq ky b gy lj lf l lg lh">    /* Create filter instances for the first thread. */<br/>    MSFilter  *voidsource = ms_filter_new(MS_VOID_SOURCE_ID);<br/>    MSFilter  *dtmfgen    = ms_filter_new(MS_DTMF_GEN_ID);<br/>    MSFilter  *itc_sink   = ms_filter_new(MS_ITC_SINK_ID);</span><span id="97c3" class="lc ld iq ky b gy lj lf l lg lh">    MSDtmfGenCustomTone dtmf_cfg;</span><span id="31d3" class="lc ld iq ky b gy lj lf l lg lh">    /* We set the name of our signal, remembering that in the array we must        leave room for a zero, which marks the end of the line. */<br/>    strncpy(dtmf_cfg.tone_name, "busy", sizeof(dtmf_cfg.tone_name));<br/>    dtmf_cfg.duration=1000;<br/>    dtmf_cfg.frequencies[0]=440; /* We will generate one tone, set the frequency of the second tone to 0. */<br/>    dtmf_cfg.frequencies[1]=0;<br/>    dtmf_cfg.amplitude=1.0; /* This sine amplitude should correspond to a measurement result of 0.707. */<br/>    dtmf_cfg.interval=0.;<br/>    dtmf_cfg.repeat_count=0.;</span><span id="608d" class="lc ld iq ky b gy lj lf l lg lh">    /* We set variables to store the result. */<br/>    float load=0.;<br/>    float latency=0.;<br/>    int filter_count=0;</span><span id="191b" class="lc ld iq ky b gy lj lf l lg lh">    /*Create a ticker. */<br/>    MSTicker *ticker1=ms_ticker_new();<br/>    ms_ticker_set_priority(ticker1, vars.ticker_priority);</span><span id="ce30" class="lc ld iq ky b gy lj lf l lg lh">    /* We connect filters in a chain. */<br/>    ms_filter_link(voidsource, 0, dtmfgen, 0);<br/>    ms_filter_link(dtmfgen, 0, itc_sink , 0);</span><span id="6a26" class="lc ld iq ky b gy lj lf l lg lh">    /* Create filter instances for the second thread. */<br/>    MSTicker *ticker2=ms_ticker_new();<br/>    ms_ticker_set_priority(ticker2, vars.ticker_priority);<br/>    MSFilter *itc_src   = ms_filter_new(MS_ITC_SOURCE_ID);<br/>    MSFilter *voidsink2 = ms_filter_new(MS_VOID_SINK_ID);<br/>    ms_filter_call_method (itc_sink, MS_ITC_SINK_CONNECT, itc_src);<br/>    ms_filter_link(itc_src, 0, voidsink2, 0);</span><span id="20c5" class="lc ld iq ky b gy lj lf l lg lh">    MSFilter* previous_filter1=dtmfgen;<br/>    MSFilter* previous_filter2=itc_src;<br/>    int gain=1;<br/>    int i;</span><span id="b763" class="lc ld iq ky b gy lj lf l lg lh">    printf("# filters load\n");<br/>    if (vars.file)<br/>    {<br/>        fprintf(vars.file, "# filters load\n");<br/>    }<br/>    while ((load &lt;= 99.) &amp;&amp; (filter_count &lt; vars.limit))<br/>    {</span><span id="deab" class="lc ld iq ky b gy lj lf l lg lh">        // Temporarily disable the packet “absorbers” from the schemes.<br/>        ms_filter_unlink(previous_filter1, 0, itc_sink, 0);<br/>        ms_filter_unlink(previous_filter2, 0, voidsink2, 0);<br/>        MSFilter  *volume1, *volume2;</span><span id="3bfb" class="lc ld iq ky b gy lj lf l lg lh">        // We divide the new load filters between the two threads.<br/>        int new_filters = vars.step&gt;&gt;1;<br/>        for (i=0; i &lt; new_filters; i++)<br/>        {<br/>            volume1=ms_filter_new(MS_VOLUME_ID);<br/>            ms_filter_call_method(volume1, MS_VOLUME_SET_DB_GAIN, &amp;gain);<br/>            ms_filter_link(previous_filter1, 0, volume1, 0);<br/>            previous_filter1 = volume1;<br/>        }</span><span id="5ef3" class="lc ld iq ky b gy lj lf l lg lh">        new_filters = vars.step - new_filters;<br/>        for (i=0; i &lt; new_filters; i++)<br/>        {<br/>            volume2=ms_filter_new(MS_VOLUME_ID);<br/>            ms_filter_call_method(volume2, MS_VOLUME_SET_DB_GAIN, &amp;gain);<br/>            ms_filter_link(previous_filter2, 0, volume2, 0);<br/>            previous_filter2 = volume2;<br/>        }</span><span id="b970" class="lc ld iq ky b gy lj lf l lg lh">        // We return the packet “absorbers” to the schemas.<br/>        ms_filter_link(volume1, 0, itc_sink, 0);<br/>        ms_filter_link(volume2, 0, voidsink2, 0);</span><span id="69ef" class="lc ld iq ky b gy lj lf l lg lh">        /* We connect the clock source. */<br/>        ms_ticker_attach(ticker2, itc_src);<br/>        ms_ticker_attach(ticker1, voidsource);</span><span id="7990" class="lc ld iq ky b gy lj lf l lg lh">        /* We turn on the sound generator. */<br/>        ms_filter_call_method(dtmfgen, MS_DTMF_GEN_PLAY_CUSTOM, (void*)&amp;dtmf_cfg);</span><span id="8ea9" class="lc ld iq ky b gy lj lf l lg lh">        /* We give time to accumulate data for averaging. */<br/>        ms_usleep(500000);</span><span id="5b56" class="lc ld iq ky b gy lj lf l lg lh">        /* We read the measurement result. */<br/>        load=ms_ticker_get_average_load(ticker1);</span><span id="41d6" class="lc ld iq ky b gy lj lf l lg lh">        filter_count=filter_count + vars.step;</span><span id="8b1b" class="lc ld iq ky b gy lj lf l lg lh">        /* Disable the clock source. */<br/>        ms_ticker_detach(ticker1, voidsource);</span><span id="be92" class="lc ld iq ky b gy lj lf l lg lh">        printf("%i  %f\n", filter_count, load);<br/>        if (vars.file) fprintf(vars.file,"%i  %f\n", filter_count, load);<br/>    }<br/>    if (vars.file) fclose(vars.file);<br/>}</span></pre><p id="67b8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，我们编译并运行我们的程序，tickers以最低优先级工作:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="b75e" class="lc ld iq ky b gy le lf l lg lh">$ ./mstest14 - -step 100 - -limit 40000 - -tprio 0 -o log4.txt</span></pre><p id="757e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">获得的测量结果如图所示。<a class="ae ks" href="#fig_____________________1" rel="noopener ugc nofollow"> 7.5 </a></p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/303b31e244441566b3ba3f6fa4621722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*UPnIoi94-KScJD7hauwYhw.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">图7.5:使用额外线程时的Ticker加载</figcaption></figure><p id="7ea4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了方便起见，从第一版程序中得到的曲线已经加到了图上。橙色曲线显示了程序的“双线程”版本的结果。从图中可以看出,“双线程”方案的跑马灯负载增长率较低。没有示出第二跑马灯上的负载。</p><p id="753f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如有必要，您可以连接在不同主机上运行的线程，只是在这种情况下，不要使用intertikers，而是使用RTP会话(就像我们在前面创建内部通信时所做的那样)，这里您还需要考虑RTP数据包的大小受到MTU值的限制。</p><p id="58c4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">根据本章的结果，我们可以得出结论，改变跑马灯的优先级不会影响其性能，增加优先级只会降低跑马灯延迟的可能性。提高电路整体性能的方法是将处理图分成几组，每组都有各自的指示器。在这种情况下，减少跑马灯负载的代价是增加了从电路输入到输出的数据传输时间。</p></div></div>    
</body>
</html>