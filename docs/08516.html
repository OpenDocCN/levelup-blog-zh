<html>
<head>
<title>How Terraform and GitHub Actions can be used for Continuous Validation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Terraform和GitHub动作如何用于连续验证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/continuous-validation-using-terraform-and-github-actions-3c012cd198d5?source=collection_archive---------4-----------------------#2021-05-08">https://levelup.gitconnected.com/continuous-validation-using-terraform-and-github-actions-3c012cd198d5?source=collection_archive---------4-----------------------#2021-05-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ec93208ccf478f399ccac239e5e236ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bVKXNoxPIZwPM03JlHATug.png"/></div></div></figure><h2 id="862a" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">持续验证？</h2><p id="dca5" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">就像我们有持续集成和交付一样，我认为持续验证是介于这两个步骤之间的一个合适的名字，坦率地说，“持续QA”听起来不那么吸引人。</p><h2 id="c8e5" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">什么是Terraform？</h2><p id="eaad" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">要事第一，对吗？</p><p id="bbbb" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><a class="ae lu" href="https://www.terraform.io/intro/index.html" rel="noopener ugc nofollow" target="_blank"> Terraform是一个强大的“基础设施即代码”工具</a>——他们这样称呼它。总之，这意味着您可以使用Terraform的HCL语法声明性地定义您的云资源，并使用Terraform更新/区分您的云资源，最重要的是:以可重复的方式这样做。</p><h2 id="4a91" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">这对我有什么好处？</h2><p id="d5dc" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">简而言之，这意味着您可以在一个完全隔离和镜像的特性环境中测试和验证新特性，该环境遵循您的特性分支，而不必担心特性标志之类的事情以及会增加代码和工作流的复杂性。</p><p id="ad7f" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">理想情况下，这将允许您拥有如下工作流:</p><ol class=""><li id="a64d" class="lv lw iq kw b kx lp lb lq kh lx kl ly kp lz lo ma mb mc md bi translated">创建特征分支</li><li id="02e6" class="lv lw iq kw b kx me lb mf kh mg kl mh kp mi lo ma mb mc md bi translated">在所述分支上开发一些新功能，并推动您的更改</li><li id="8b31" class="lv lw iq kw b kx me lb mf kh mg kl mh kp mi lo ma mb mc md bi translated">创建拉式请求</li><li id="ef6a" class="lv lw iq kw b kx me lb mf kh mg kl mh kp mi lo ma mb mc md bi translated">让你的同事对你的代码进行代码评审<em class="mj">——以及基础设施变更</em></li><li id="0594" class="lv lw iq kw b kx me lb mf kh mg kl mh kp mi lo ma mb mc md bi translated">让QA以他们自己的速度在隔离环境中验证您的实施</li><li id="b1af" class="lv lw iq kw b kx me lb mf kh mg kl mh kp mi lo ma mb mc md bi translated">合并并关闭拉取请求</li><li id="c0a0" class="lv lw iq kw b kx me lb mf kh mg kl mh kp mi lo ma mb mc md bi translated">您的更改现已投入生产，特征环境已不存在</li></ol><h2 id="a6db" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">这与传统的做事方式有何不同？</h2><p id="a5d2" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">我一次又一次地看到“开发”分支被使用，并且这个分支存在的根本原因是将代码放入QA环境，甚至更多——所以只有一个这样的环境。这可能会在开发/发布过程中导致无数的问题。</p><p id="b380" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">我观察到的最大问题是，当驻留在开发分支中的特性被认为已经准备好生产时，还没有准备好生产的特性被推送到开发分支；从而在新功能被认为准备就绪之前阻止生产就绪功能上线。</p><p id="2ad0" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">根据团队和项目的规模，这可能会导致发布之间不期望的差距。每2个月部署一次<em class="mj">不是很敏捷</em>吧？</p><h2 id="f443" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">我的看法</h2><p id="8626" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">当您创建一个pull请求时，我的实现就开始了，就像您通常会让您的更改出现在生产中一样。</p><p id="59aa" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">使用GitHub Actions，我已经使用pull请求触发器创建了一个流，所以当一个pull请求打开时，我的管道就会运行，这就是神奇的地方。</p><p id="69df" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">一旦你打开了pull请求，管道就会运行一些Terraform魔法来查看<code class="fe mk ml mm mn b">terraform plan</code>,并在pull请求上留下一个注释。当一切顺利时，一个新的环境将使用<code class="fe mk ml mm mn b">terraform apply</code>在Azure上启动。</p><p id="062f" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">在这个简化的例子中，这意味着在Azure上部署了一个新的Azure函数，然后我用它来部署我的hello-world函数。然而，使用Terraform可以实现更多功能。我建议<a class="ae lu" href="https://www.terraform.io/docs/index.html" rel="noopener ugc nofollow" target="_blank">认真看看文档</a>。</p><h1 id="a565" class="mo jz iq bd ka mp mq mr kd ms mt mu kg mv mw mx kk my mz na ko nb nc nd ks ne bi translated">好吧，我知道了，给我钱！</h1><p id="ab82" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">代码可以在https://github.com/MartinAnder/ContinuousValidation的<a class="ae lu" href="https://github.com/MartinAnder/ContinuousValidation" rel="noopener ugc nofollow" target="_blank">找到，下图的拉动请求也可以在那里找到。</a></p><figure class="ng nh ni nj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/95999508cc5ce75be66e17662aa8bac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TfnvndDTLWhlyPjpVZCFQQ.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">【https://github.com/MartinAnder/ContinuousValidation/pull/5 T4】</figcaption></figure><p id="6204" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">我不会过多地探究实际的实现，因为这不是本文的主题。示例拉请求本身和项目以及代码本身都很简单。</p><h1 id="7ad9" class="mo jz iq bd ka mp mq mr kd ms mt mu kg mv mw mx kk my mz na ko nb nc nd ks ne bi translated">概括起来</h1><p id="9419" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">我展示了如何使用terraform按需构建环境来验证您的实现，以及如何让它们遵循您的拉式请求生命周期。</p><p id="bc96" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">发布的项目是一个由Azure函数组成的非常简化的例子，因为它是更便宜和更容易的选择。它可能是Azure上的一个应用服务，或者任何其他可以想象的东西——甚至是在另一个云中。</p><p id="ea86" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">在所有的实用性中，它不一定是地形；也可以是Pulumi，或者您可以使用Kubernetes和Helm，在您的staging-cluster中旋转图表。持续集成工具可以是除GitHub之外的任何工具，只要它支持拉请求触发器。</p><p id="a108" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">在将其投入生产之前，需要考虑的事情包括数据库等等。如何提供这些，测试数据从哪里来？也许为所有的特征环境共享一个数据库？只是要小心模式变化之类的东西。</p><p id="02af" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">如果你正在运行一个微服务架构，你会从你的特性环境中选择哪个版本的服务呢？</p></div></div>    
</body>
</html>