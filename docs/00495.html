<html>
<head>
<title>Introduction to Quantum Computing using Qiskit and IBM Q</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Qiskit和IBM Q介绍量子计算</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-quantum-computing-using-qiskit-and-ibm-q-a4c4fead6344?source=collection_archive---------1-----------------------#2019-03-31">https://levelup.gitconnected.com/introduction-to-quantum-computing-using-qiskit-and-ibm-q-a4c4fead6344?source=collection_archive---------1-----------------------#2019-03-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/82ebc12aa3339923a44cfdeb54bdbe58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vGbdSD3cGWJ0wVWoWGxTow.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片来源:<a class="ae kf" href="https://i.ytimg.com/vi/2B680d-qvhI/maxresdefault.jpg" rel="noopener ugc nofollow" target="_blank">https://i.ytimg.com/vi/2B680d-qvhI/maxresdefault.jpg</a></figcaption></figure><p id="8869" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本教程结束时，您将能够使用Qiskit在您的计算机上模拟量子电路的行为。您还将能够连接到IBM Q后端，并通过云访问IBM的量子计算机(信不信由你，它是免费的，每个人都可以访问)。</p><p id="c6c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们开始真正的工作之前，我想提出一些要求，以及如何达到这些要求:</p><p id="8e38" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您将需要Python(版本&gt; 3.5)、Anaconda和Jupyter控制台。您可以同时安装所有这些组件，只需获得Anaconda发行版。你可以在这里找到<a class="ae kf" href="https://www.anaconda.com/distribution" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="0ea9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，您需要安装Qiskit库。为了做到这一点，您可以使用任何包管理系统，但是为了本教程的目的，我将演示使用PIP的步骤。现在，你需要获得PIP，它是Python的一个包管理系统。使用此命令安装PIP:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="eebc" class="ln lo it lj b gy lp lq l lr ls">sudo apt install python-pip</span></pre><p id="e4da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后使用pip安装Qiskit，使用以下命令:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="dc28" class="ln lo it lj b gy lp lq l lr ls">pip install qiskit</span></pre><p id="bd3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你就快到了。现在你需要做的就是打开一个终端窗口。然后，键入:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="aa95" class="ln lo it lj b gy lp lq l lr ls">jupyter console</span></pre><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lt"><img src="../Images/5401fcdc6819cf801bb5b73a34d013b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UckZu4d0ycPiWYPJlnsbvA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">您应该有一个与此类似的屏幕。</figcaption></figure><p id="7d2c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">恭喜你，现在你已经准备好开始执行命令，探索量子电路的行为。</p><p id="10b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想介绍我们将要做的实验背后的理论，但是首先，知道量子位和常规位之间的区别是有好处的。如果你还没有听说，量子计算机使用量子比特而不是经典比特来执行任务。量子位是量子力学系统，可以产生0或1或它们的某种叠加。这里有一个很好的图片来说明:</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lu"><img src="../Images/9bc43a5912d0088f41b9bfec62434fd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cc_v65OipU5-EsCi7XeU2A.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">参考:【https://sureshemre.wordpress.com/2016/11/27/qubit/ T4】</figcaption></figure><p id="5b6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在最后一张图中，你可以看到左边是经典比特的可能值，而右边是量子比特的可能值。这些值可以用在一个叠加态或另一个叠加态中找到量子位的相对概率的百分比来表示。该概率可以由单位球内位置中心的距离给出。所以基本上，如果它更靠近底部(相对于图片)，那么它将是1，否则它将是0。</p><p id="932f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了避免混淆，我想强调，量子位元就像经典位元一样，结果总是0或1。他们没有任何其他不同的价值观。但是它们是如何到达那里的，这就是与经典比特不同的地方，这就是它的强大之处。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="1bc9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回到理论上。因此，我们在本教程中要做的主要工作是试图产生一个纠缠态(也称为<a class="ae kf" href="https://en.wikipedia.org/wiki/Bell_state" rel="noopener ugc nofollow" target="_blank">贝尔态</a>)。抛开流行词汇，看看过去的领域:沿着从0到1的轴的状态本质上是经典状态。现在想象两个量子位的位置正好在球体的赤道上(与两极等距)。有50%的几率是0或1，这是一个纠缠态。在这样的叠加状态下，每个量子位都具有相关性，使得如果不参考另一个量子位的状态，任何一个量子位的状态都不能被完全描述。这是展示量子计算机和经典计算机之间区别的最简单的方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="34b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在确保您在首选目录下工作后，让我们开始编码。让我们首先创建一个由量子寄存器和经典寄存器组成的量子电路。为此，您需要导入qiskit，并定义一些变量。如果你熟悉Python，你会发现这样做很容易，因为在幕后，我们只是用Python编码。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="8c42" class="ln lo it lj b gy lp lq l lr ls">import qiskit as qk</span><span id="1627" class="ln lo it lj b gy mc lq l lr ls">qr = qk.QuantumRegister(2)</span><span id="07a0" class="ln lo it lj b gy mc lq l lr ls">cr = qk.ClassicalRegister(2)</span><span id="0b2d" class="ln lo it lj b gy mc lq l lr ls">qc = qk.QuantumCircuit(qr,cr)</span></pre><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/ea75b6650fb2b9aa8dc923d87349276f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aF61aKdqq-y4_kJGXcxNHg.png"/></div></div></figure><p id="2d93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，我想介绍一款手机应用，名为Hello Quantum。它是由IBM制造的，看起来很像一个益智游戏。然而，它很好地解释了量子门的工作原理及其行为。如果您有兴趣了解更多关于电路组成的信息，我建议您先玩一会儿。该应用程序的图标如下所示:</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi me"><img src="../Images/50bec40967c5035734b7b4393324b461.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VAnwbmAP-KtjjfQx8S5bOw.png"/></div></div></figure><p id="c1fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回到代码，现在我们可以添加操作到我们的电路。我们之前定义了两个寄存器(一个量子寄存器和一个经典寄存器)并用它们制作了一个电路。接下来，让我们在量子寄存器上应用Hadamard门，在经典寄存器上应用cnot(受控非)门。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="9294" class="ln lo it lj b gy lp lq l lr ls">qc.h(qr[0])</span><span id="807b" class="ln lo it lj b gy mc lq l lr ls">qc.cx(qr[0],qr[1])</span></pre><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mf"><img src="../Images/dd86188d7830d4bf1e0f86a2f1ba3ef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D7etrxKAbpaId4ZzslFBJQ.png"/></div></div></figure><p id="2aea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们将测量值添加到刚刚创建的电路中。由于我们希望事先在有和没有哈达玛门的情况下进行测量，因此为测量创建单独的电路并将其与我们的缠绕电路相结合会更容易。</p><p id="aa18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">measure_Z电路将在标准基础上进行测量。然后，我们使用qiskit函数将结果存储在经典寄存器中</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="d23e" class="ln lo it lj b gy lp lq l lr ls">measure_Z = qk.QuantumCircuit(qr,cr)<br/>measure_Z.measure(qr,cr)</span></pre><p id="c51c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将我们的第二个测量称为measure_X，我们将在测量之前对其应用哈达玛门。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="6a6c" class="ln lo it lj b gy lp lq l lr ls">measure_X = qk.QuantumCircuit(qr,cr)<br/>measure_X.h(qr)<br/>measure_X.measure(qr,cr)</span></pre><p id="7e1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然我们已经定义了我们的测量电路，我们可以将它们附加到我们的缠绕电路，创建两个新的电路，我们将标记为test_Z和test_X。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="28e9" class="ln lo it lj b gy lp lq l lr ls">test_Z = qc + measure_Z<br/>test_X = qc + measure_X</span></pre><p id="d08f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些都是之前成功执行的命令，有助于确保您找到它们。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mg"><img src="../Images/807a21a5fd71eeeb82eac193e205a35e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wOpAN1OHNgnUChRnN8T65g.png"/></div></div></figure><p id="228f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们开始更令人兴奋的东西！真正的量子计算机连接！</p><p id="f4c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">导航至<a class="ae kf" href="https://quantumexperience.ng.bluemix.net/qx/login" rel="noopener ugc nofollow" target="_blank">https://quantumexperience.ng.bluemix.net/qx</a>，创建账户并登录。登录后，点击右上角的头像图片，进入账户，然后进入高级。您将能够看到与此类似的屏幕。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/e7d1903f3865f1d4caf8330135a12a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wj2mMqm0Csz_gawQG3YhOg.png"/></div></div></figure><p id="488c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">复制您的API令牌，我们将很快使用它。</p><p id="2d95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来导入IBMQ，准备连接量子计算机！</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="1d80" class="ln lo it lj b gy lp lq l lr ls">from qiskit import execute, IBMQ</span><span id="c509" class="ln lo it lj b gy mc lq l lr ls">IBMQ.enable_account("Paste your APItoken here")</span></pre><p id="15c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">确保将APItoken作为字符串传递。现在，如果您运行IBMQ.backend()，您应该能够看到IBM提供给您的所有后端。如果你仔细看，它们在你的IBM Q账户的IBM Q后端访问下。现在让我们为后端定义一个变量，并开始在QC上执行一些代码。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="b8c3" class="ln lo it lj b gy lp lq l lr ls">backend = IBMQ.get_backend('ibmqx4')</span></pre><p id="77c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于这个例子，我选择了ibmqx4，但是这完全取决于您使用什么。有时一些后端会继续维护，所以我总是在选择一个后端之前检查有哪些后端可用。这里是后端连接的快速总结。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mi"><img src="../Images/b2385bb58ad18fd59ab0d50c3bf4b515.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CM9nXsOzskqRgdOQVVO_KA.png"/></div></div></figure><p id="08f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还记得我们之前在赛道外准备的测试工作吗？现在我们要用它们了！让我们以这种方式创建一个作业:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="ce06" class="ln lo it lj b gy lp lq l lr ls">job= qk.execute([test_Z, test_X], backend = backend, shots = 1000)</span></pre><p id="8cb5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，让我们执行几次job.status()来监视作业的状态。如果大量使用量子机器(或者如果您选择了一个繁忙的机器，一个快速的解决方法是返回并使用不同的提供者为后端重新定义变量！)，再过一点，应该就成功了。这是我从跟踪中得到的。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mj"><img src="../Images/3565c9ff60504ad6c08a9d68282abba1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cw6MKwrOcm7WWb7Pmk8HYA.png"/></div></div></figure><p id="b167" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此时，下一步是获取作业执行的结果。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="e185" class="ln lo it lj b gy lp lq l lr ls">result = job.result()<br/>result.get_counts(test_Z)<br/>result.get_counts(test_X)</span><span id="8645" class="ln lo it lj b gy mc lq l lr ls">from qiskit.tools.visualization import plot_histogram</span><span id="f71f" class="ln lo it lj b gy mc lq l lr ls">plot_histogram(result.get_counts(test_Z))</span></pre><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mk"><img src="../Images/62fdf13b5f94d2f8ac677dfda47bc878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tEk7su68KFwKUBHc6HQbKg.png"/></div></div></figure><p id="21fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些是我行刑的结果。您的可能会有所不同。对此的解释是，由于在量子计算机上的执行，我们已经证明了“贝尔态”的存在，即当一个量子位处于0和1之间的中间位置时，并且只发生在量子系统中。这是x轴上的中间值(01和10)给我们的，它代表“贝尔态”，也称为纠缠态。</p><p id="928a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不相信我？自己看吧！让我们通过在本地模拟器(不是quantum)上执行相同的作业来总结一下。这些是您将需要连接到Aer并使用他们的本地模拟器，并重新执行过去的工作的命令:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="7806" class="ln lo it lj b gy lp lq l lr ls">from qiskit import Aer</span><span id="b540" class="ln lo it lj b gy mc lq l lr ls">backend = Aer.get_backend('qasm_simulator')</span><span id="36c8" class="ln lo it lj b gy mc lq l lr ls">job = qk.execute([test_Z, test_X], backend= backend, shots=1000)</span><span id="e7c3" class="ln lo it lj b gy mc lq l lr ls">result = job.result()</span><span id="8af4" class="ln lo it lj b gy mc lq l lr ls">plot_histogram(result.get_counts(test_Z))</span></pre><p id="56e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果如下:</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/d339c98c18c1dfc8e32b230b683b305a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EmXXFdlhDf-MSq_Qn-U_ew.png"/></div></div></figure><p id="fc37" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从图中可以看出，没有纠缠态。所有无聊的常规0和1位。然而，这只是你使用量子计算机的证明！</p><p id="88b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您已经走了这么远，并且能够连接到ibm Q后端并执行您的第一个作业，那么恭喜您！</p><p id="8ae2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我要感谢麦克卢尔先生，他是我撰写这篇文章的最大资源。我用了很多他的Youtube视频，我建议你去看看！</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure></div></div>    
</body>
</html>