<html>
<head>
<title>Changing my approach to dependency injection in a React app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React应用程序中改变我的依赖注入方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/changing-my-approach-to-dependency-injection-in-a-react-app-4f73e1efe82f?source=collection_archive---------8-----------------------#2022-09-29">https://levelup.gitconnected.com/changing-my-approach-to-dependency-injection-in-a-react-app-4f73e1efe82f?source=collection_archive---------8-----------------------#2022-09-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/47f523872b0716d531eb4f2008c5a967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PqdeQZCHWdWpFaFV87rXDw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">戴安娜·波列希纳在Unsplash上的照片</figcaption></figure><p id="634e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我最近从下面的帖子中受到启发，使用<a class="ae la" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React Context </a>将一种依赖注入形式合并到ReactJS应用程序中。</p><div class="lb lc gp gr ld le"><a href="https://blog.testdouble.com/posts/2021-03-19-react-context-for-dependency-injection-not-state/" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">为依赖注入而不是状态管理反应上下文</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">在React应用程序架构的讨论中，React上下文经常被作为一种实现“状态……</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">blog.testdouble.com</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls jw le"/></div></div></a></div><div class="lb lc gp gr ld le"><a href="https://dev.to/dansolhan/simple-dependency-injection-functionality-for-react-518j" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">React的依赖注入/服务模式(受Angular启发)</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">在Angular-development团队中工作了几年之后，学习React对我来说是一件令人兴奋的事情，而且它更…</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">开发到</p></div></div><div class="ln l"><div class="lt l lp lq lr ln ls jw le"/></div></div></a></div><p id="4238" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，我最终简化了方法，并且<em class="lu">而不是</em>合并了上面的模式。让我们从我最初的实现开始，它非常接近其他作者:</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="6f37" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，为了使用我的服务，我将它包装在一个子组件中，如EmployeeSearchForm:</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="922f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我在EmployeeSearchForm组件中使用它:</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="9a08" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这一切都很好，我很高兴在React中获得了类似依赖注入的感觉，那么我为什么要把它去掉呢？</p><p id="51a2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在使用它之后，我并没有感觉到我比仅仅将我的服务作为一个常规文件导入然后像上面那样使用得到了更多。我担心未来的应用程序开发者会被这种模式所迷惑，最终会把它剥离出来，或者至少不会复制它，把这种孤儿模式留在应用程序中。</p><p id="b979" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以最终我将我的employee_data_client拆分成一个EmployeeDataClient服务，并简单地导入它。该服务看起来像这样:</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="0a31" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，我只需导入该服务，并在需要获取结果时调用EmployeeDataClient.get_results()。我仍然能够隔离和测试/模拟客户端，尽管这并不是真正的“依赖注入”。</p></div></div>    
</body>
</html>