<html>
<head>
<title>Using Pub-Sub Pattern In Svelte</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在苗条中使用发布-订阅模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-pub-sub-pattern-in-svelte-f58ce6a0afdd?source=collection_archive---------6-----------------------#2022-10-22">https://levelup.gitconnected.com/using-pub-sub-pattern-in-svelte-f58ce6a0afdd?source=collection_archive---------6-----------------------#2022-10-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="29e0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解解耦的和可伸缩的组件通信模式。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f12e315564867e8ac9e828de43fbac81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W2P_NQQLx8zaBOIks9VvGg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">标题按作者发布订阅图像</figcaption></figure><p id="b03b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在软件架构模式中，当我们的数据需要与多个组件共享时，数据发布者并不关心订阅特定事件的组件。我们需要一个中介来用正确的信息交流每个组件。所以我们称这个中介为发布订阅。</p><blockquote class="lr"><p id="592c" class="ls lt iq bd lu lv lw lx ly lz ma lq dk translated">问题不在于“问题”，问题在于你对待问题的态度——杰克·斯派洛</p></blockquote><p id="b41f" class="pw-post-body-paragraph kv kw iq kx b ky mb jr la lb mc ju ld le md lg lh li me lk ll lm mf lo lp lq ij bi translated">发布-订阅被称为发布者和订阅者模式。它也被称为事件驱动编程。当事件在发布服务器上发生时，所有订阅服务器组件都应该侦听该事件，并在有消息或没有消息的情况下被调用。</p><p id="f00e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种模式的一个例子是聊天应用程序。在聊天app中，有不同的渠道<code class="fe mg mh mi mj b">(events)</code>发送<code class="fe mg mh mi mj b">(publish)</code>消息。在那些频道上的人<code class="fe mg mh mi mj b">(subscribers)</code>可以听到信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/35d2606db7efa37f257d58ebcb617c64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fyBHsJ-cvZ5HLBRoYhVrzw.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">作者的聊天消息插图和动画</figcaption></figure><p id="068e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们来看看代码。在Svelte中，我们将使用两个默认方法<code class="fe mg mh mi mj b">publish()</code>和<code class="fe mg mh mi mj b">subscribe()</code>创建一个<em class="ml"> pubsub.js </em>文件。订阅还返回了<code class="fe mg mh mi mj b">unsubscribe()</code>方法，将事件从组件中分离出来。</p><p id="cbb9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">可以使用默认参数在<em class="ml"> project-events.js </em>上定义事件。</p><p id="6fdb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ml"> project-events.js </em></p><pre class="kg kh ki kj gt mm mj mn mo aw mp bi"><span id="b39a" class="mq mr iq mj b gy ms mt l mu mv">export class OnMessageEvent{<br/> constructor(message){<br/>  this.args = message;<br/> }<br/>}</span></pre><p id="d0f8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事件类被用作传递消息的通道，类的名称将被用作两个<code class="fe mg mh mi mj b">publish() and subscribe()</code>方法中的事件名称。</p><p id="b31c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ml"> pubsub.js </em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f4cf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mg mh mi mj b">subscribe()</code>通过在基于映射的集合中添加事件名称来附加事件，并存储回调监听器。当<code class="fe mg mh mi mj b">publish()</code>被调用时，基于事件名执行存储的回调。</p><p id="b28d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ml">组件级的实现:</em></p><pre class="kg kh ki kj gt mm mj mn mo aw mp bi"><span id="587a" class="mq mr iq mj b gy ms mt l mu mv">&lt;script&gt;<br/>  import {publish, subscribe} from './pubsub'<br/>  import {onMessageEvent} from './project-events'<br/>  import {onMount} from 'svelte'</span><span id="4ed5" class="mq mr iq mj b gy my mt l mu mv">let message = '';</span><span id="507d" class="mq mr iq mj b gy my mt l mu mv">//Listen the event onMount and unsubscribe when return.<br/>  onMount(()=&gt;{<br/>    let onMsg = subscribe(onMessageEvent, (msg)=&gt;{<br/>      console.log('Received:', msg); <br/>    });</span><span id="b224" class="mq mr iq mj b gy my mt l mu mv">    return()=&gt;{ onMsg.unsubscribe(); }<br/>  });</span><span id="3ed9" class="mq mr iq mj b gy my mt l mu mv">//Send message using publish event<br/>  const onSend = ()=&gt;{<br/>    publish(new onMessageEvent({message}));<br/>  };<br/>&lt;/script&gt;</span><span id="8857" class="mq mr iq mj b gy my mt l mu mv">&lt;input bind:value={messgae}/&gt;<br/>&lt;button on:click={onSend}&gt; Send &lt;/button&gt;</span></pre><p id="2c66" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上述示例在用于理解实现的同一个组件上发送和接收消息。让我们深入到一个使用同一个<em class="ml"> pubsub.js </em>文件的具有多个事件和组件的真实cart应用程序中。</p><h2 id="85dd" class="mq mr iq bd mz na nb dn nc nd ne dp nf le ng nh ni li nj nk nl lm nm nn no np bi translated">应用程序</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/d8020a46265ab1eb6119bec2b7be7268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*400mz_fRMCN1kUzUpzUxDQ.png"/></div></figure><p id="6130" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">简单的购物车应用程序，左边是产品，右边是购物车列表。具有解耦递送组件的购物车列表，用于计算递送费用。</p><p id="ef8e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当添加或删除活动项目时，购物车列表会更新，并且会计算正确的运费。如果购物车总额超过10美元，送货费将是免费的。</p><p id="0f9d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个想法是以一种分离的方式制造所有三个组件。通信不是由道具、上下文或存储完成的。所有组件通信都将通过发布-订阅事件发生。</p><h2 id="4839" class="mq mr iq bd mz na nb dn nc nd ne dp nf le ng nh ni li nj nk nl lm nm nn no np bi translated">设计</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/57e9398a22e8eff2c330110a9fba7b68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*difvtOimRb57kSuyOAPQ3g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">作者发布-订阅组件设计图像</figcaption></figure><p id="0724" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个产品条目将发布两个事件<code class="fe mg mh mi mj b">ItemAddEvent</code>和<code class="fe mg mh mi mj b">ItemRemoveEvent</code>。购物车列表将监听(订阅)商品事件，更新购物车并发布<code class="fe mg mh mi mj b">CartChangesEvent</code>。最后，delivery将监听(订阅)这个<code class="fe mg mh mi mj b">CartChangesEvent</code>，并用购物车总额更新运费。</p><h2 id="272c" class="mq mr iq bd mz na nb dn nc nd ne dp nf le ng nh ni li nj nk nl lm nm nn no np bi translated">演示</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/3cbd0d287afaf1421d6387a591f968cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*syteY59UDqMC0l3UAjvLog.gif"/></div></figure><p id="f2bb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">添加控制台语句是为了验证每个用户操作背后的事件和数据。</p><h2 id="e89a" class="mq mr iq bd mz na nb dn nc nd ne dp nf le ng nh ni li nj nk nl lm nm nn no np bi translated">密码</h2><p id="d8c4" class="pw-post-body-paragraph kv kw iq kx b ky nt jr la lb nu ju ld le nv lg lh li nw lk ll lm nx lo lp lq ij bi translated">我们知道如何创建一个带有参数的事件类。让我们看看下面三个类似<code class="fe mg mh mi mj b">ProductItem, CartList</code>和<code class="fe mg mh mi mj b">Delivery</code>的组件的代码。</p><p id="4675" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ml"> ProductItem.svelte </em></p><pre class="kg kh ki kj gt mm mj mn mo aw mp bi"><span id="7b67" class="mq mr iq mj b gy ms mt l mu mv">&lt;script&gt;<br/> import {publish} from './pubsub'<br/> import {ItemAddEvent, ItemRemoveEvent} from './project-events'<br/> export let name;<br/> export let id;<br/> export let price = '0.0';<br/> <br/> const addCart = () =&gt;{<br/>  publish(new ItemAddEvent({id,name,price}));<br/> }<br/> const delCart = () =&gt;{<br/>  publish(new ItemRemoveEvent({id}));<br/> }<br/>&lt;/script&gt;<br/>&lt;button on:click={addCart} title="Add"&gt;+&lt;/button&gt; <br/>&lt;button on:click={delCart} title="Remove"&gt;✕&lt;/button&gt; {name} $&lt;b&gt;{price}&lt;/b&gt;&lt;br&gt;</span></pre><p id="e5b0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当<code class="fe mg mh mi mj b">addCart()</code>和<code class="fe mg mh mi mj b">delCart()</code>起作用时，产品项目组件发布两个不同的事件。</p><p id="d70d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ml"> CartList.svelte </em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f00b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">购物车列表组件订阅两个产品事件并发布<code class="fe mg mh mi mj b">CartChangesEvent</code>。它使用cart类来管理购物车中的商品，并有意不使用苗条的商店。</p><p id="8c63" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ml">delivery . svelite</em></p><pre class="kg kh ki kj gt mm mj mn mo aw mp bi"><span id="fdf6" class="mq mr iq mj b gy ms mt l mu mv">&lt;script&gt;<br/> import {subscribe} from './pubsub';<br/> import {onMount} from 'svelte';<br/> import {CartChangesEvent} from './project-events'<br/> <br/> let defaultFee = 5.50;<br/> let total = 0.0;<br/> <br/> onMount(() =&gt; {<br/>  let changer = subscribe(CartChangesEvent, (item) =&gt;{   <br/>   total = item.total;<br/>  }) <br/>  <br/>  return () =&gt;{<br/>   changer.unsubscribe();<br/>  }<br/> });<br/> <br/>&lt;/script&gt;<br/>{#if total &gt; 0}<br/> {#if total &gt;= 10}<br/>  &lt;br&gt; Delivery Fee : Free Delivery | Total : {total}<br/> {:else}<br/>  &lt;br&gt; Delivery Fee : ${defaultFee} | Total : ${total + defaultFee}<br/> {/if}<br/>{/if}</span></pre><p id="787c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">交付组件监听<code class="fe mg mh mi mj b">CartList</code>发布<code class="fe mg mh mi mj b">CartChangesEvent</code>。<code class="fe mg mh mi mj b">CartChangesEvent</code>还发送购物车总数据，用于进一步扩展应用程序。</p><h1 id="06c3" class="ny mr iq bd mz nz oa ob nc oc od oe nf jw of jx ni jz og ka nl kc oh kd no oi bi translated">赞成的意见</h1><ol class=""><li id="4c6e" class="oj ok iq kx b ky nt lb nu le ol li om lm on lq oo op oq or bi translated"><strong class="kx ir">松耦合</strong> —发布者不关心订阅者。</li><li id="be3f" class="oj ok iq kx b ky os lb ot le ou li ov lm ow lq oo op oq or bi translated"><strong class="kx ir">可伸缩性</strong> —允许系统伸缩，无论它在负载上如何弯曲。</li><li id="f6d9" class="oj ok iq kx b ky os lb ot le ou li ov lm ow lq oo op oq or bi translated"><strong class="kx ir">干净的设计</strong> —解耦使得组件交互干净。</li><li id="b82a" class="oj ok iq kx b ky os lb ot le ou li ov lm ow lq oo op oq or bi translated"><strong class="kx ir">灵活性</strong>——在一份合同下工作具有灵活性。</li><li id="d7b2" class="oj ok iq kx b ky os lb ot le ou li ov lm ow lq oo op oq or bi translated"><strong class="kx ir">测试很简单</strong> —只测试发布或订阅上的数据。</li></ol><h1 id="68ce" class="ny mr iq bd mz nz oa ob nc oc od oe nf jw of jx ni jz og ka nl kc oh kd no oi bi translated">骗局</h1><p id="ae99" class="pw-post-body-paragraph kv kw iq kx b ky nt jr la lb nu ju ld le nv lg lh li nw lk ll lm nx lo lp lq ij bi translated">组件松散耦合是最大的优点，也是最大的缺点。发布者不知道订阅者的状态，反之亦然。出版商和订阅者的增加导致不稳定，它在负荷下弯曲。</p><p id="6847" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">恶意出版商可以入侵系统并破坏它。消息规范和参与者规则增加了系统的复杂性。</p><h2 id="5372" class="mq mr iq bd mz na nb dn nc nd ne dp nf le ng nh ni li nj nk nl lm nm nn no np bi translated">苗条的REPL</h2><p id="480a" class="pw-post-body-paragraph kv kw iq kx b ky nt jr la lb nu ju ld le nv lg lh li nw lk ll lm nx lo lp lq ij bi translated">完整的代码请查看苗条的REPL <a class="ae ox" href="https://svelte.dev/repl/5f44424999674986b79f02d94efaedf6?version=3.50.1" rel="noopener ugc nofollow" target="_blank">链接</a>。尝试使用REPL代码，并通过添加其他组件(如优惠券、促销和折扣)来扩展应用程序。</p><h1 id="b3c6" class="ny mr iq bd mz nz oa ob nc oc od oe nf jw of jx ni jz og ka nl kc oh kd no oi bi translated">结论</h1><p id="5fa8" class="pw-post-body-paragraph kv kw iq kx b ky nt jr la lb nu ju ld le nv lg lh li nw lk ll lm nx lo lp lq ij bi translated">Svelte有许多方式的组件通信技术，如道具，背景，和商店。使用发布-订阅模式有它自己的优点和缺点。没有灵丹妙药，但是发布-订阅是设计松散耦合系统的一种很好的方式。</p></div></div>    
</body>
</html>