<html>
<head>
<title>Perfect Forwarding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">完美转发</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/perfect-forwarding-647e1caaf879?source=collection_archive---------5-----------------------#2022-08-13">https://levelup.gitconnected.com/perfect-forwarding-647e1caaf879?source=collection_archive---------5-----------------------#2022-08-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3f69" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">C++中的完美转发</h2></div><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="ab gu cl kk"><img src="../Images/2b5b0734555e1d84a96c3b425f69a9f7.png" data-original-src="https://miro.medium.com/v2/0*ECSuFOH_4vkqGL58"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">照片由<a class="ae kr" href="https://unsplash.com/@two_tees?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈特·沃尔什</a>在<a class="ae kr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a486" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">完美转发是什么意思？</p><p id="52f8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">“转发”是一个函数<em class="lo">将其参数转发给另一个函数</em>的过程。当它完美时，该函数应该接收从执行转发的函数传递的相同对象。</p><p id="f933" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">换句话说，完美转发意味着我们不仅仅转发对象，我们还转发它们的显著属性，不管它们是左值还是右值，常量还是易变的。</p><p id="dc88" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">不要太担心定义，我们将通过一些简单的例子。</p><p id="13a2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">假设我们有一个简单的类如下</p><pre class="kf kg kh ki gt lp lq lr ls aw lt bi"><span id="4af0" class="lu lv iq lq b gy lw lx l ly lz">class Object {<br/> public:<br/>  Object() = default;<br/><br/>  void SetName(const std::string &amp;name) { name_ = std::move(name); }<br/>  std::string GetName() const { return name_; }<br/><br/> private:<br/>  std::string name_;<br/>};</span></pre><p id="5711" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们还有几个名为<code class="fe ma mb mc lq b">UseObject</code>的重载函数</p><pre class="kf kg kh ki gt lp lq lr ls aw lt bi"><span id="040c" class="lu lv iq lq b gy lw lx l ly lz">void UseObject(Object &amp;) {<br/>  std::cout &lt;&lt; "calling UseObject(Object &amp;)" &lt;&lt; std::endl;<br/>}<br/><br/>void UseObject(const Object &amp;) {<br/>  std::cout &lt;&lt; "calling UseObject(const Object &amp;)" &lt;&lt; std::endl;<br/>}<br/><br/>void UseObject(Object &amp;&amp;) {<br/>  std::cout &lt;&lt; "calling UseObject(Object &amp;&amp;)" &lt;&lt; std::endl;<br/>}</span></pre><p id="042a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在我们有了主要的</p><pre class="kf kg kh ki gt lp lq lr ls aw lt bi"><span id="5876" class="lu lv iq lq b gy lw lx l ly lz">int main() {<br/>  Object object;<br/>  const Object const_object;<br/>  UseObject(object);<br/>  UseObject(const_object);<br/>  UseObject(std::move(object));<br/>}</span></pre><p id="d551" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这将产生如下输出</p><pre class="kf kg kh ki gt lp lq lr ls aw lt bi"><span id="6ec9" class="lu lv iq lq b gy lw lx l ly lz">calling UseObject(Object &amp;)<br/>calling UseObject(const Object &amp;)<br/>calling UseObject(Object &amp;&amp;)</span></pre><p id="8d4d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在，假设我们有一个简单的模板函数，它试图将参数传递给<code class="fe ma mb mc lq b">UseObject</code>函数</p><pre class="kf kg kh ki gt lp lq lr ls aw lt bi"><span id="726a" class="lu lv iq lq b gy lw lx l ly lz">template &lt;typename T&gt;<br/>void NotForwardToUseObject(T x) {<br/>  UseObject(x);<br/>}</span></pre><p id="f222" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在，运行代码</p><pre class="kf kg kh ki gt lp lq lr ls aw lt bi"><span id="4db2" class="lu lv iq lq b gy lw lx l ly lz">int main() {<br/>  Object object;<br/>  const Object const_object;<br/>  NotForwardToUseObject(object);<br/>  NotForwardToUseObject(const_object);<br/>  NotForwardToUseObject(std::move(object));<br/>}</span></pre><p id="7227" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">会导致</p><pre class="kf kg kh ki gt lp lq lr ls aw lt bi"><span id="2a44" class="lu lv iq lq b gy lw lx l ly lz">calling UseObject(Object &amp;)<br/>calling UseObject(Object &amp;)<br/>calling UseObject(Object &amp;)</span></pre><p id="6778" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">其中函数没有像我们之前预期的那样被相应地调用。</p><p id="5513" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这是因为<code class="fe ma mb mc lq b">const</code>和<code class="fe ma mb mc lq b">rvalueness</code>被<code class="fe ma mb mc lq b">void NotForwardToUseObject(T x)</code>的模板推演忽略了。</p><p id="3d69" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为了处理引用参数，我们必须使用通用引用，因为只有通用引用参数对传递给它们的参数的左值和右值进行编码。</p><p id="6524" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果我们使用模板参数的通用引用，</p><pre class="kf kg kh ki gt lp lq lr ls aw lt bi"><span id="513e" class="lu lv iq lq b gy lw lx l ly lz">template &lt;typename T&gt;<br/>void HalfForwardToUseObject(T &amp;&amp;x) {  // universal reference<br/>  UseObject(x);<br/>}</span></pre><p id="accf" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">代码运行</p><pre class="kf kg kh ki gt lp lq lr ls aw lt bi"><span id="f634" class="lu lv iq lq b gy lw lx l ly lz">int main() {<br/>  Object object;<br/>  const Object const_object;<br/>  HalfForwardToUseObject(object);<br/>  HalfForwardToUseObject(const_object);<br/>  HalfForwardToUseObject(std::move(object));<br/>}</span></pre><p id="b43e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">会导致</p><pre class="kf kg kh ki gt lp lq lr ls aw lt bi"><span id="c5f7" class="lu lv iq lq b gy lw lx l ly lz">calling UseObject(Object &amp;)<br/>calling UseObject(const Object &amp;)<br/>calling UseObject(Object &amp;)</span></pre><p id="b033" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">差不多！转发<code class="fe ma mb mc lq b">const</code>似乎有效，但参数的<code class="fe ma mb mc lq b">rvalueness</code>仍未正确转发。</p><p id="52c7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为了实现真正完美的转发，我们必须将<code class="fe ma mb mc lq b">x</code>转换为其原始类型和左值或右值</p><pre class="kf kg kh ki gt lp lq lr ls aw lt bi"><span id="9746" class="lu lv iq lq b gy lw lx l ly lz">template &lt;typename T&gt;<br/>void ForwardToUseObject(T &amp;&amp;x) {<br/>  UseObject(static_cast&lt;T &amp;&amp;&gt;(x));<br/>}</span></pre><p id="a395" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在，运行代码</p><pre class="kf kg kh ki gt lp lq lr ls aw lt bi"><span id="89d7" class="lu lv iq lq b gy lw lx l ly lz">int main() {<br/>  Object object;<br/>  const Object const_object;<br/>  ForwardToUseObject(object);<br/>  ForwardToUseObject(const_object);<br/>  ForwardToUseObject(std::move(object));<br/>}</span></pre><p id="6ae0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">会导致</p><pre class="kf kg kh ki gt lp lq lr ls aw lt bi"><span id="48b8" class="lu lv iq lq b gy lw lx l ly lz">calling UseObject(Object &amp;)<br/>calling UseObject(const Object &amp;)<br/>calling UseObject(Object &amp;&amp;)</span></pre><p id="4ce0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">完美！我们已经成功地正确传递了对象。为了简化代码，我们可以使用C++ <code class="fe ma mb mc lq b">&lt;utility&gt;</code>库中的<code class="fe ma mb mc lq b">std::forward</code>，</p><pre class="kf kg kh ki gt lp lq lr ls aw lt bi"><span id="75ec" class="lu lv iq lq b gy lw lx l ly lz">template &lt;typename T&gt;<br/>void PerfectForwardToUseObject(T &amp;&amp;x) {<br/>  UseObject(std::forward&lt;T&gt;(x));<br/>}</span></pre><p id="7738" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我希望上面的例子，现在你已经明白什么是完美的转发。像往常一样，上面的代码可以从我的<a class="ae kr" href="https://github.com/pllee4/blog-public/tree/master/posts/003/files" rel="noopener ugc nofollow" target="_blank"> github </a>中获得</p><p id="415c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">感谢阅读到帖子末尾！</p></div></div>    
</body>
</html>