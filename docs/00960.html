<html>
<head>
<title>Managing state in Flutter using Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Redux管理颤振状态</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/managing-state-in-flutter-using-redux-7eeb686c108c?source=collection_archive---------6-----------------------#2019-09-30">https://levelup.gitconnected.com/managing-state-in-flutter-using-redux-7eeb686c108c?source=collection_archive---------6-----------------------#2019-09-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="33fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Flutter允许我们单独管理小部件的状态。然而，随着应用程序复杂性的增加，以及允许不同的小部件访问彼此状态的需求的增加，需要将应用程序的状态存储在一个普通的容器中。Redux完全符合这一特殊需求。这篇文章解释了Redux如何与Flutter一起使用。</p><p id="033e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Redux模式通常与React一起使用，可以在这种情况下使用。这使我们能够在整个应用程序中获得单一的真实来源。但是在我们学习使用Redux和Flutter之前，了解Redux的工作原理是有帮助的。</p><h1 id="843a" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">Redux架构</h1><p id="4f02" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated"><a class="ae lr" href="https://redux.js.org/basics/data-flow" rel="noopener ugc nofollow" target="_blank"> Redux有四大组成部分</a>:</p><ol class=""><li id="6387" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">国家</li><li id="e5d6" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">行动</li><li id="29db" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">分配器</li><li id="9471" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">还原剂</li></ol><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/01c5ba7c73964a8fc4b0f1757f14a6ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/0*3KZHmqd2Pui0b5ex"/></div></figure><p id="85d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">状态是存储应用程序状态(所有数据)的地方。Redux库通常为我们提供所谓的提供者，帮助我们将状态绑定到视图。然而，修改存储并不简单(这很好),这有助于我们获得单向的数据流。</p><p id="161b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了修改存储，dispatcher(由Redux提供)必须触发一个动作。这个动作有一个类型和我们想要用来修改存储的数据。一旦动作被触发，reducer就制作一个存储的副本，用新数据更新副本，并返回新的状态。然后，用新数据更新视图。</p><p id="8942" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过将这个Redux模式合并到一个Flutter应用程序中，我们可以确保我们有一个公共的应用程序状态，可以通过触发动作来改变。尽管我说状态是突变的，但请注意Redux存储在设计上是不可变的，每次触发一个动作时，都会返回一个新状态，旧状态保持不变。</p><h1 id="c943" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">安装Redux</h1><p id="13cd" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">有两个flutter包<a class="ae lr" href="https://pub.dev/packages/redux" rel="noopener ugc nofollow" target="_blank"> redux </a>和<a class="ae lr" href="https://pub.dev/packages/flutter_redux" rel="noopener ugc nofollow" target="_blank"> flutter_redux </a>帮助我们使用redux搭配Flutter，应该先安装。因此，在<code class="fe mo mp mq mr b">pubspec.yaml</code>文件中，在dependencies下面列出这两个包。</p><pre class="mh mi mj mk gt ms mr mt mu aw mv bi"><span id="7126" class="mw kp it mr b gy mx my l mz na">dependencies: flutter: sdk: flutter flutter_redux: ^0.5.3 redux: ^3.0.0</span></pre><p id="7109" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您需要运行<code class="fe mo mp mq mr b">flutter pub get</code>来安装这些包。一旦完成，我们就可以开始在我们的Flutter应用程序中使用Redux了。为了演示这一点，我将使用由<code class="fe mo mp mq mr b">flutter create</code>命令创建的默认演示应用程序。</p><p id="2e73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认应用程序有一个计数器，可以通过按下浮动操作按钮来增加。计数器包含在<code class="fe mo mp mq mr b">MyHomePage</code>小部件的状态中。让我们尝试将它移动到Redux存储中，并通过调度操作来增加它。</p><h1 id="0a7d" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">创建模型</h1><p id="64af" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">在创建商店之前，我们需要创建一个柜台模型。为此，创建一个名为model的dart文件，并创建一个名为<code class="fe mo mp mq mr b">Counter</code>的类。这个类将有一个名为<code class="fe mo mp mq mr b">counter</code>的属性，顾名思义，它将存储计数器。创建一个接受整数作为参数的构造函数，并将其赋给<code class="fe mo mp mq mr b">counter</code>属性。这可以在Dart中很容易地完成，方法是传递属性的名称——我们希望将传递的参数赋给它——前面加上<code class="fe mo mp mq mr b">this.</code>作为参数。现在，我们有了一个柜台模型。</p><pre class="mh mi mj mk gt ms mr mt mu aw mv bi"><span id="b806" class="mw kp it mr b gy mx my l mz na">class Counter{ int counter; Counter(this.counter); }</span></pre><h1 id="4a90" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">创建一个国家</h1><p id="8fa1" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">接下来，让我们创建应用程序的状态。创建一个名为state的Dart文件，并创建一个名为<code class="fe mo mp mq mr b">AppState</code>的类。这个类的一个实例将保存我们应用程序的状态。现在，我们需要将计数器存储在应用程序的状态中。因此，将<code class="fe mo mp mq mr b">Counter</code>模型导入状态文件，并创建一个名为<code class="fe mo mp mq mr b">counter</code>的<code class="fe mo mp mq mr b">Counter</code>类型的属性。然后，创建一个接受一个<code class="fe mo mp mq mr b">Counter</code>对象作为参数的构造函数，并将其分配给<code class="fe mo mp mq mr b">counter</code>属性。</p><p id="a3a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了初始化应用程序的状态，建议创建一个命名的构造函数，将<code class="fe mo mp mq mr b">counter</code>的值设置为零。</p><pre class="mh mi mj mk gt ms mr mt mu aw mv bi"><span id="4b9a" class="mw kp it mr b gy mx my l mz na">import 'package:sample/model.dart'; class AppState { final Counter counter; AppState(this.counter); AppState.initial():counter=new Counter(0); }</span></pre><h1 id="f610" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">创建操作</h1><p id="80ef" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">现在我们已经创建了我们的<code class="fe mo mp mq mr b">AppState</code>类，让我们创建一个动作来修改状态。创建一个名为<code class="fe mo mp mq mr b">action.dart</code>的新文件，并创建一个名为<code class="fe mo mp mq mr b">IncrementAction</code>的新类。该操作将携带reducer用来修改状态的数据。因为我们想增加计数器，我们需要在这个类中有一个<code class="fe mo mp mq mr b">counter</code>属性。因此，创建一个名为<code class="fe mo mp mq mr b">counter</code>的整数属性，并使用构造函数初始化它。</p><pre class="mh mi mj mk gt ms mr mt mu aw mv bi"><span id="3608" class="mw kp it mr b gy mx my l mz na">class IncrementAction{ final int count; IncrementAction(this.count); }</span></pre><h1 id="12a5" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">创建一个减速器</h1><p id="a3ab" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">接下来，我们需要创建一个返回更新状态的reducer。因此，创建一个名为<code class="fe mo mp mq mr b">reducer.dart</code>的新文件，并创建一个函数来返回我们的<code class="fe mo mp mq mr b">AppState</code>类的一个实例。这个函数接受状态对象和被触发动作的对象作为参数。当一个动作被触发时，Redux调用这个reducer函数，并将应用程序的当前状态和被触发的动作的一个实例作为参数传递。</p><p id="4a49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以用action对象中的数据修改传递的state对象，用修改后的state对象创建一个新的<code class="fe mo mp mq mr b">AppState</code>实例，并返回它。但是这个reducer函数会在每次触发一个动作时被调用。不同的动作携带不同的数据，应该以不同的方式修改状态。那么，我们如何根据触发的动作执行不同的功能呢？由于每个动作都是一个动作类的实例，我们可以检查动作对象的数据类型，然后决定后续的动作过程。</p><p id="0972" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以通过使用<code class="fe mo mp mq mr b">is</code>语法来检查Dart中变量的类型。因此，我们可以编写一个条件语句来查看某个动作是否属于某种类型，并执行必要的动作。</p><pre class="mh mi mj mk gt ms mr mt mu aw mv bi"><span id="8598" class="mw kp it mr b gy mx my l mz na">AppState appStateReducer (AppState state, dynamic action){ if(action is IncrementAction){ return new AppState(new Counter(action.count)); } return state; }</span></pre><p id="d7fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如上所示，我们可以编写一个reducer函数来检查所触发的动作是否是我们的动作类IncrementAction的实例，并返回一个用更新后的<code class="fe mo mp mq mr b">counter</code>对象初始化的新的<code class="fe mo mp mq mr b">AppState</code>实例。</p><h1 id="2d62" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">视图模型</h1><p id="6edb" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">现在，我们已经创建了一个动作、一个app状态和一个reducer。剩下要做的就是创建一个按钮点击事件来触发这个动作。但是在我们这样做之前，我们需要创建一个视图模型。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/3086ce20b7e3ca65412568756dfb1c8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/0*_PevVX4EqCb55uQU"/></div></figure><p id="a5b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">视图模型并不复杂。它在我们的应用程序的状态和应用程序的用户界面之间充当表示层。现在，我们希望在应用程序状态下存储数据的方式不一定是我们希望显示的方式。例如，我们可以将用户的名和姓存储在州的不同变量中。但是当显示用户名时，我们可能希望同时显示名字和姓氏。我们可以使用视图模型对数据进行这样的修饰。换句话说，我们使用视图模型来帮助状态和UI相互交互。它只是作为一个过滤器。</p><h1 id="6f1a" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">创建视图模型</h1><p id="1aa6" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">让我们继续创建一个名为<code class="fe mo mp mq mr b">viewModel.dart</code>的新文件，并创建一个名为<code class="fe mo mp mq mr b">ViewModel</code>的类。现在，我们希望我们的UI做两件事:显示计数器值和触发我们的<code class="fe mo mp mq mr b">IncrementAction</code>动作。因此，我们的视图模型应该包括一个存储计数器值的变量和一个触发动作的方法。</p><p id="2f9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，让我们创建一个名为<code class="fe mo mp mq mr b">counter</code>的整数和一个名为<code class="fe mo mp mq mr b">onIncrement</code>的方法。让我们也创建一个构造函数来初始化这两个。</p><p id="35a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们需要创建一个工厂构造函数来返回一个<code class="fe mo mp mq mr b">ViewModel</code>类的实例。工厂构造函数确保如果<code class="fe mo mp mq mr b">ViewModel</code>类的实例已经存在，那么返回该实例，而不是创建并返回它的新实例。</p><p id="44ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个构造函数应该接受一个存储对象作为参数。然后，我们将实例化<code class="fe mo mp mq mr b">ViewModel</code>类并返回它。但在此之前，我们需要获取计数器的值，并实现一个函数来触发<code class="fe mo mp mq mr b">IncrementAction</code>动作。</p><p id="2d81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以从作为参数传递的store对象中获取计数器值。应用程序的状态存储在名为state的属性中。因此，我们可以通过使用<code class="fe mo mp mq mr b">store.state.counter.counter</code>来访问计数器值。状态有一个类型为<code class="fe mo mp mq mr b">Counter</code>的计数器属性，它有一个名为counter的整数属性。</p><p id="e80e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后创建一个分派操作的方法。dispatch方法附加到store对象上，可以通过<code class="fe mo mp mq mr b">store.dispatch()</code>访问。为了分派一个动作，我们需要创建一个action类的对象，并将其作为参数传递给dispatch方法。您可能还记得，这个action类还携带必要的数据。在我们的例子中，我们的action类中有一个名为counter的属性，它将携带计数器的更新值。</p><h1 id="9863" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">从我们的视图模型中递增计数器</h1><p id="5fa6" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">因此，我们可以通过用新的计数器值实例化我们的action类来更改计数器值。因为我们试图增加我们的计数器值，我们可以从存储中获取计数器的现有值，将它增加1，并将其作为参数传递给我们的action类构造函数。我们可以将返回的对象传递给dispatch方法。</p><p id="372b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您必须导入redux包、动作和状态文件。</p><pre class="mh mi mj mk gt ms mr mt mu aw mv bi"><span id="4034" class="mw kp it mr b gy mx my l mz na">import 'package:redux/redux.dart'; import 'package:sample/actions.dart'; import 'package:sample/state.dart'; class ViewModel{ int count; final Function () onIncrement; ViewModel(this.count,this.onIncrement); factory ViewModel.create(Store&lt;AppState&gt; store){ _onIncrement(){ print("Incrementing"); print(store.state.counter.counter.toString()); store.dispatch(new IncrementAction(store.state.counter.counter+1)); } return ViewModel(store.state.counter.counter,_onIncrement); } }</span></pre><h1 id="fd18" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">创建一个商店对象，并将其传递到Flutter小部件树中</h1><p id="d8c9" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我们差不多完成了。现在，我们需要创建一个store对象，并将其传递给我们的小部件树。然后，我们可以使用商店连接器在小部件中访问我们的商店。</p><p id="6d7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，让我们创建一个<code class="fe mo mp mq mr b">store</code>对象。我们可以通过实例化redux包提供的store类来做到这一点。当创建store对象时，我们需要将状态属性的类型(我们的状态对象的类)指定为一般类型参数。然后，传递reducer函数和初始状态作为参数。我们可以通过调用state类的初始构造函数来获得初始状态。</p><p id="4e3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们有了一个store对象，我们需要将它向下传递给小部件树。flutter redux包为我们提供了一个<code class="fe mo mp mq mr b">StoreProvider</code>,它会将我们的商店对象传递到小部件树中。我们需要做的就是用<code class="fe mo mp mq mr b">StoreProvider</code>包装我们的根小部件。将<code class="fe mo mp mq mr b">MaterialApp</code>作为子对象，并将我们的<code class="fe mo mp mq mr b">store</code>对象赋给<code class="fe mo mp mq mr b">store</code>参数。</p><pre class="mh mi mj mk gt ms mr mt mu aw mv bi"><span id="dc76" class="mw kp it mr b gy mx my l mz na">class MyApp extends StatelessWidget { // This widget is the root of your application. @override Widget build(BuildContext context) { final Store&lt;AppState&gt; store = new Store&lt;AppState&gt;(appStateReducer, initialState: AppState.initial()); return StoreProvider&lt;AppState&gt;( store: store, child: MaterialApp( title: 'Flutter Demo', theme: ThemeData( // This is the theme of your application. // // Try running your application with "flutter run". You'll see the // application has a blue toolbar. Then, without quitting the app, try // changing the primarySwatch below to Colors.green and then invoke // "hot reload" (press "r" in the console where you ran "flutter run", // or simply save your changes to "hot reload" in a Flutter IDE). // Notice that the counter didn't reset back to zero; the application // is not restarted. primarySwatch: Colors.blue, ), home: MyHomePage(title: 'Flutter Demo Home Page'), )); } }</span></pre><h1 id="e720" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">从Flutter小部件访问Redux商店</h1><p id="3436" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">现在，我们可以使用<code class="fe mo mp mq mr b">StoreConnector</code>在应用程序的任何地方访问商店对象。首先，让我们显示计数器值。</p><p id="9a69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe mo mp mq mr b">_MyHomePageState</code>小部件中，让我们将<code class="fe mo mp mq mr b">StoreConnector</code>小部件分配给body参数。指定<code class="fe mo mp mq mr b">AppState</code>类和<code class="fe mo mp mq mr b">ViewModel</code>类作为通用参数。这个<code class="fe mo mp mq mr b">StoreConnector</code>小部件有两个属性:<code class="fe mo mp mq mr b">connector</code>和<code class="fe mo mp mq mr b">builder</code>。<code class="fe mo mp mq mr b">connector</code>接受一个函数，该函数接受一个存储对象作为参数，并返回一个视图模型对象。我们可以通过使用工厂构造函数来创建一个<code class="fe mo mp mq mr b">ViewModel</code>对象。<code class="fe mo mp mq mr b">builder</code>参数接受一个函数，该函数接受一个<code class="fe mo mp mq mr b">BuildContext</code>对象和一个<code class="fe mo mp mq mr b">ViewModel</code>对象作为参数，并返回一个小部件。</p><p id="9358" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以使用<code class="fe mo mp mq mr b">viewModel</code>参数来显示计数器值。记住，<code class="fe mo mp mq mr b">viewModel</code>对象有一个名为<code class="fe mo mp mq mr b">counter</code>的属性，用于存储计数器值。我们可以使用<code class="fe mo mp mq mr b">viewModel.counter.toString()</code>显示计数器值。</p><p id="79f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要调度一个动作，我们可以使用<code class="fe mo mp mq mr b">viewModel.onIncrement()</code>方法。将其分配给浮动动作按钮的<code class="fe mo mp mq mr b">onPressed</code>参数。</p><pre class="mh mi mj mk gt ms mr mt mu aw mv bi"><span id="a405" class="mw kp it mr b gy mx my l mz na">class _MyHomePageState extends State&lt;MyHomePage&gt; { int _counter = 0; void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: StoreConnector&lt;AppState, ViewModel&gt;( converter: (Store&lt;AppState&gt; store) =&gt; ViewModel.create(store), builder: (BuildContext context, ViewModel viewModel) =&gt; Center( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( 'You have pushed the button this many times:', ), Text( viewModel.count.toString(), style: Theme.of(context).textTheme.display1, ), ], ), )), floatingActionButton: StoreConnector&lt;AppState, ViewModel&gt;( converter:(Store&lt;AppState&gt; store)=&gt;ViewModel.create(store), builder:(BuildContext context, ViewModel viewModel)=&gt; FloatingActionButton( onPressed: ()=&gt;viewModel.onIncrement(), tooltip: 'Increment', child: Icon(Icons.add), ), // This trailing comma makes auto-formatting nicer for build methods. )); } }</span></pre><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/e6d96dcbc8185e18bd102cde1e43d22e.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/0*aIDw1RLZ6iOgHNGs"/></div></figure><p id="54c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当你点击浮动动作按钮时，它调用<code class="fe mo mp mq mr b">viewModel</code>对象的<code class="fe mo mp mq mr b">onIncrement</code>方法。该方法将计数器值递增1，并将其传递给<code class="fe mo mp mq mr b">IncrementAction</code>类构造函数。这将调用reducer并将状态和创建的对象作为参数传递给<code class="fe mo mp mq mr b">IncrementAction</code>类。然后reducer从action对象中获取新的计数器值，并用新的计数器值创建一个<code class="fe mo mp mq mr b">Counter</code>对象。然后，这个对象被传递到<code class="fe mo mp mq mr b">AppState</code>构造函数中，以创建一个新的状态对象，该对象由reducer函数返回。当返回新的状态对象时，<code class="fe mo mp mq mr b">viewModel</code>的counter属性得到更新，视图也用新的计数器值更新。</p><p id="c12f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在那里！我们已经将使用Redux构建的状态连接到Futter应用程序的视图。现在，我们有了单一的事实来源，不需要担心在组件之间传递数据。</p><p id="5c1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完整的源代码可以在这里找到:<a class="ae lr" href="https://github.com/thivi/FlutterReduxSample" rel="noopener ugc nofollow" target="_blank">https://github.com/thivi/FlutterReduxSample</a></p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="48dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="nj">原载于2019年9月30日</em><a class="ae lr" href="https://www.thearmchaircritic.org/tech-journals/managing-state-in-flutter-using-redux" rel="noopener ugc nofollow" target="_blank"><em class="nj">【https://www.thearmchaircritic.org</em></a><em class="nj">。</em></p></div></div>    
</body>
</html>