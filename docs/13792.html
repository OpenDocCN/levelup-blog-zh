<html>
<head>
<title>Mastering Flutter Animations: Tweens &amp; Curves</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握颤动动画:补间动画和曲线</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/mastering-flutter-animations-63c0c29f8e1a?source=collection_archive---------2-----------------------#2022-10-06">https://levelup.gitconnected.com/mastering-flutter-animations-63c0c29f8e1a?source=collection_archive---------2-----------------------#2022-10-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="93ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你刚刚开始你的颤振动画之旅，我鼓励你先看看这个由颤振团队制作的短片<a class="ae ko" href="https://www.youtube.com/watch?v=GXIJJkq_H8g&amp;list=PLjxrf2q8roU2v6UqYlt_KPaXlnjbYySua" rel="noopener ugc nofollow" target="_blank">系列</a>。这是6个30分钟多一点的视频。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="484a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，如果你以前在Flutter中看过、研究过或工作过动画，你应该熟悉两种主要类型:<strong class="js iu">隐式</strong>和<strong class="js iu">显式</strong>。这两者之间的区别非常简单。隐式动画使用<strong class="js iu"> AnimatedWidgets </strong>在值改变和重建发生时自动制作动画(即通过<em class="kw"> setState </em>)。另一方面，显式动画需要一个<code class="fe kx ky kz la b"><strong class="js iu">AnimationController</strong></code>。当事件发生时，例如按下按钮，您有责任控制动画。使用显式动画，您可以控制动画的方向，重复播放动画，以及在任何时间点停止播放动画。还有一些由Flutter提供的<strong class="js iu">动画</strong>类，让我们在执行常见的显式动画时，生活变得更加轻松。</p><p id="1881" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，所有这些都包含在之前的播放列表和网络上无数的地方。然而，即使我理解了这些关键概念，我对自己正确实现颤动动画的能力并不完全满意。我觉得自己有能力，但我觉得还有更多东西需要理解。<em class="kw">什么是Tween？我的意思是，我知道它定义了两个值之间的转换，但是怎么定义呢？为什么有不同种类的补间动画？<em class="kw">这些曲线是关于什么的？我知道它们在某种程度上影响了动画的时间，但是到底发生了什么呢？它是如何工作的？<em class="kw">这</em><strong class="js iu"><em class="kw">vsync</em></strong><em class="kw">和</em><strong class="js iu"><em class="kw">ticker provider</em></strong><em class="kw">到底是怎么回事废话？</em></em></em></p><p id="a305" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，我可以接受这些是Flutter的动画框架使用的类，并坚持使用提供的标准动画来将我的对象从A点移动到b点。但这不是我的风格。我相信要正确使用一个工具，你必须对它的工作原理和原因有所了解。所以我更深入地钻研这些神秘的课程，并自信地以我想要的方式制作任何我想要的动画。今天，我们也将这样做。我们将讨论上面提出的每个问题。然后，我们将创建我们自己的补间动画和曲线，最终只用几行代码就完成了一个真正的自定义动画。准备好了吗？让我们开始吧。</p><h1 id="f99d" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">ticker供应商</h1><p id="b79c" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">我们从TickerProvider开始，因为一旦我们理解了它，我们就可以使用它了。我们的自定义动画不需要实现任何东西。首先，<code class="fe kx ky kz la b"><strong class="js iu">vsync</strong></code>在这里被用作参数名称，因为vsync或垂直同步是指以屏幕刷新率同步帧更新的术语。vsync参数接受一个<code class="fe kx ky kz la b"><strong class="js iu">TickerProvider</strong></code>，负责创建和提供一个<code class="fe kx ky kz la b"><strong class="js iu">Ticker</strong></code>。Ticker的工作是在发生帧更新时向任何侦听器提供通知。这允许监听器在绘制框架之前更新任何小部件。Flutter提供了<code class="fe kx ky kz la b"><strong class="js iu">SingleTickerProviderStateMixin</strong></code>&amp;<strong class="js iu"/><code class="fe kx ky kz la b"><strong class="js iu">TickerProviderStateMixin</strong></code><strong class="js iu"/>来简化在类中提供一个或多个Ticker，允许我们mixin然后将<code class="fe kx ky kz la b"><em class="kw">this</em></code> <em class="kw"> </em>传递给vsync参数。</p><p id="4dbb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是我所知道的全部。我以前写过一篇<a class="ae ko" href="https://medium.com/geekculture/flutter-case-study-timer-precision-a1154b431e8" rel="noopener">文章</a>，讲述使用TickerProvider在每一帧上执行一个动作，比使用Dart的<code class="fe kx ky kz la b">Timer</code>类回调更精确。它将让您对Ticker类的用途以及如何直接使用它有更多的了解。</p><h1 id="0655" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">图汶</h1><p id="59b1" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">简单地说，<code class="fe kx ky kz la b">Tween</code>定义了两个值之间的转换。要执行此任务，补间需要一个开始值、一个结束值和一个告诉它如何在这两个值之间转换的方法。这种方法叫做<code class="fe kx ky kz la b"><strong class="js iu">lerp</strong></code>，是<em class="kw">线性插补</em>的简称。线性插值实际上是一种在两个给定点之间定义多个点的方法。分解起来很简单。Tween类也有一个<code class="fe kx ky kz la b"><strong class="js iu">transform</strong></code>方法。它是在使用补间时实际调用的方法，但它的工作只是在动画时间线为0时返回开始值，在动画时间线为1时返回结束值。否则，它将时间传递给lerp并返回结果。所以，我们没有必要去碰它。</p><p id="40e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">补间使用<strong class="js iu">运算符+ </strong>、<strong class="js iu"> - </strong>、<strong class="js iu"> * </strong>进行线性插值。因此，补间动画可以使用任何实现这些运算符的类。还有专门为特定类设计的特殊补间，如ColorTween。我们将很快扩展ColorTween来定义我们自己的行为。</p><h1 id="7bc7" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">曲线</h1><p id="e504" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">一个动画只是一段时间内从A到b的视觉变化。<code class="fe kx ky kz la b">Curve</code>类定义了它变化的速率。从A到B是平滑的线性过渡，还是开始缓慢变化并加速，或者相反？这些典型的行为就是颤振提供的<a class="ae ko" href="https://api.flutter.dev/flutter/animation/Curves-class.html" rel="noopener ugc nofollow" target="_blank">曲线类型，但是一条曲线可以定义从A到B随时间<em class="kw"> t </em>(从0.0到1.0)的任何速率。我们很快就会把这个事实推到极限。</a></p><pre class="kp kq kr ks gt me la mf mg aw mh bi"><span id="e6c0" class="mi lc it la b gy mj mk l ml mm"><strong class="la iu">NOTE:</strong> A Linear Curve would simply pass along the value t that it receives without transforming it. All others are performing some transformation.</span></pre><p id="5d20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于Curve的实现，有几个关键点需要理解。它扩展了<code class="fe kx ky kz la b"><strong class="js iu">ParametricCurve</strong></code>，后者提供了一个<code class="fe kx ky kz la b"><strong class="js iu">transformInternal</strong></code>方法，在实现定制曲线时应该被覆盖。它还提供了一个不应该被覆盖的<code class="fe kx ky kz la b"><strong class="js iu">transform</strong></code>方法。如果<em class="kw"> t </em>为0.0或1.0，该方法返回<em class="kw"> t </em>。否则，它叫<code class="fe kx ky kz la b">transformInternal</code>。这一点很重要，因为它允许在起始值和结束值之间设置动画，同时确保动画实际上在各自的值处开始和结束。</p><h1 id="d50d" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">把所有的放在一起</h1><p id="710a" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">因此，如果我们看看所有这些是如何一起工作的，<code class="fe kx ky kz la b">AnimationController</code>给出一个时间<em class="kw">t₁</em>【0.0–1.0】<em class="kw"/><code class="fe kx ky kz la b">Curve</code>(通过一个<code class="fe kx ky kz la b">Animation</code>)，它根据<code class="fe kx ky kz la b">transform</code>将其映射到一个新值<em class="kw">t₂</em>【0.0–1.0】，并将其传递给<code class="fe kx ky kz la b">Tween</code>。然后，基于在<code class="fe kx ky kz la b">lerp</code>中定义的线性插值，Tween计算<code class="fe kx ky kz la b">begin</code>和<code class="fe kx ky kz la b">end</code>之间的值。当屏幕被绘制时，这个值被一个<code class="fe kx ky kz la b">Widget</code>使用，这就是我们如何从动画的任何给定点得到应该在屏幕上绘制的值。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mn"><img src="../Images/fbd80dcb94154536e4ff067e2d8eb828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LUq3z108CPXRZ7r7DSCi0A.jpeg"/></div></div></figure><h1 id="7333" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建眨眼动画</h1><p id="54de" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">我知道你在想什么…我们不需要自定义的补间动画或曲线来闪烁灯光。这是正确的。我们可以向前驱动一个动画，然后向后驱动打开和关闭灯光，并重复一遍又一遍地闪烁。但是，如果我们想用一个动画控制器来驱动一系列的灯，依次闪烁呢？也许你也已经想出了一个更好的方法来处理这个问题，但我们在这里是想亲自动手，更好地理解Flutter的动画框架。这就是为什么我们要用自定义补间来解决这个问题。但是，嘿，我们想让我们的手真的脏，以确保我们有一个伟大的把握，对不对？对！因此，首先，我们将尝试使用自定义曲线创建相同的效果，并了解为什么这不是正确的方法。别担心，之后我们会创造出一个很棒的工作曲线！</p><p id="6a3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但首先，我们要创造什么。像这样的怎么样？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/0ec833ee1ec26f000a5db4f1ec994a0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*JlfSAvLKrcVfrd6KI_b_Vg.gif"/></div></figure><h2 id="6943" class="mi lc it bd ld mv mw dn lh mx my dp ll kb mz na lp kf nb nc lt kj nd ne lx nf bi translated">代码</h2><p id="fbe1" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">这个项目的代码可以在<code class="fe kx ky kz la b">tweens_and_curves</code>目录下的<a class="ae ko" href="https://github.com/theLee3/mastering_flutter_animations.git" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我鼓励你克隆它，并使用<code class="fe kx ky kz la b">starter</code>文件夹跟随它。<code class="fe kx ky kz la b">complete</code>文件夹包含了完成的项目。</p><pre class="kp kq kr ks gt me la mf mg aw mh bi"><span id="b9bf" class="mi lc it la b gy mj mk l ml mm"><strong class="la iu">NOTE:</strong> The classes we create in this project are small, so you can add them to the file alongside the Widgets that use them. That is how the project is setup in the complete directory as well.</span></pre><p id="5960" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你看一下起始代码，你会看到我们有一个包含2个按钮的登录页面。每个按钮将我们带到一个页面，在那里我们将实现我们不同的动画。这些页面的设置都很相似，手势检测器填充了<code class="fe kx ky kz la b">Scaffold</code>的主体。当前，当轻击屏幕时，灯泡<code class="fe kx ky kz la b">Icon</code>切换开和关，线性动画，并在<code class="fe kx ky kz la b">blink.dart</code>的情况下重复。我们将只更新这些动画。不会对布局进行任何更改。</p><pre class="kp kq kr ks gt me la mf mg aw mh bi"><span id="f63f" class="mi lc it la b gy mj mk l ml mm"><strong class="la iu">PRO TIP:</strong> Take a look at the on/off colors used. Our off color is the same RGB value as on, but with full transparency. When animating transparency, you should always do so in this fashion. Colors.transparent is specifically a transparent black, and therefore is not purely a transition between transparent &amp; opaque but also between black &amp; whatever color you are using.</span></pre><p id="3852" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看着<code class="fe kx ky kz la b">blink.dart</code>，你会看到我们有一个动画列表被填入<code class="fe kx ky kz la b">initState</code>。</p><pre class="kp kq kr ks gt me la mf mg aw mh bi"><span id="7a53" class="mi lc it la b gy mj mk l ml mm">@override<br/>void initState() {<br/>  super.initState();<br/>  final interval = 1 / numberOfLights;<br/>  for (var i = 0; i &lt; numberOfLights; i++) {<br/>    final begin = interval * i;<br/>    final end = interval * (i + 1);<br/>    animations.add(<br/>      ColorTween(begin: offColor, end: onColor).animate(<br/>        CurvedAnimation(<br/>          parent: controller,<br/>          curve: Interval(begin, end),<br/>        ),<br/>      ),<br/>    );<br/>  }<br/>}</span></pre><p id="b812" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里需要注意的是，我们使用了一个<code class="fe kx ky kz la b">ColorTween</code>(现在)，和一个叫做<code class="fe kx ky kz la b">Interval</code>的<code class="fe kx ky kz la b">Curve</code>。如果你对<code class="fe kx ky kz la b">Interval</code>不熟悉，它是一条曲线，允许我们只在<code class="fe kx ky kz la b">AnimationController</code>的整个持续时间的某个间隔内制作特定的动画。这允许我们创建交错的动画。这是如何工作的？如果你回想一下我们对曲线的讨论，你会记得曲线只是将时间<em class="kw"> t₁ </em>映射到新的值<em class="kw"> t₂ </em>，然后由<code class="fe kx ky kz la b">Tween</code>使用该值来计算由<code class="fe kx ky kz la b">Widget</code>使用的值。一条<code class="fe kx ky kz la b">Interval</code>曲线将<em class="kw"> t₁ </em> ≤ <code class="fe kx ky kz la b">begin</code>的任意值映射到<em class="kw"> 0 </em>，将<em class="kw"> t₁ </em> ≥ <code class="fe kx ky kz la b">end</code>的任意值映射到<em class="kw"> 1 </em>。<code class="fe kx ky kz la b">begin</code>和<code class="fe kx ky kz la b">end</code>之间的任何值都被<em class="kw">归一化</em>并根据默认情况下传递给<code class="fe kx ky kz la b">Interval</code>、<em class="kw">线性</em>的曲线映射。现在让我们在一个单一的正向动画中使灯光闪烁。</p><h2 id="03ce" class="mi lc it bd ld mv mw dn lh mx my dp ll kb mz na lp kf nb nc lt kj nd ne lx nf bi translated">曲线闪烁</h2><p id="e7c6" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">首先，让我们来思考一个眨眼动画随着时间的推移应该如何定义。它应该从关闭位置(t=0.0时为0.0)开始，在中点处达到开启峰值(t=0.5时为1.0)，并在结束时返回关闭状态(t=1.0时为0.0)。为了简单起见，我们把它做成线性的。在图表中看起来如何？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/e173d29c2fdf38451609309dcb62b035.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*2K8QyVM6UW_GjspxLisbaA.jpeg"/></div></figure><p id="661f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们考虑这样一个图形的公式…当t ≤ 0.5时，值就是2t。当t &gt; 0.5时，该值为2(1-t)。因此，我们的<code class="fe kx ky kz la b">Blink</code>类应该覆盖<code class="fe kx ky kz la b">transformInternal</code>，如下所示:</p><pre class="kp kq kr ks gt me la mf mg aw mh bi"><span id="8397" class="mi lc it la b gy mj mk l ml mm">class Blink extends Curve {<br/>  const Blink();</span><span id="0bb7" class="mi lc it la b gy nh mk l ml mm">  @override<br/>  double transformInternal(double t) {<br/>    if (t &gt; 0.5) return 2 * (1 - t);<br/>    return 2 * t;<br/>  }<br/>}</span></pre><p id="825a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在只需通过更新<code class="fe kx ky kz la b">Interval</code>来使用我们的<code class="fe kx ky kz la b">Blink</code>曲线。</p><pre class="kp kq kr ks gt me la mf mg aw mh bi"><span id="1946" class="mi lc it la b gy mj mk l ml mm">curve: Interval(begin, end, curve: const Blink()),</span></pre><p id="0e4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">跑去看看会发生什么。这里慢了下来。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/429b83ce43a320b1e8dc8f941ec15c1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*q9Xz2vN5G9o3snHikAzPOQ.gif"/></div></figure><p id="ef72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是怎么回事？嗯，您可能还记得，<code class="fe kx ky kz la b">Curve</code>也有一个我们没有覆盖的<code class="fe kx ky kz la b">transform</code>方法。正如我们所讨论的，它总是将0.0映射到0.0，将1.0映射到1.0，然后将任何其他值传递给我们覆盖的<code class="fe kx ky kz la b">transformInternal</code>方法。这意味着曲线必须始终以值1.0结束。不是我们正在寻找的，因为我们需要在我们开始的地方结束(0.0)。如前所述，我们永远不应该覆盖这个方法。动画框架要求0.0和1.0映射到自身。那么我们能做什么呢？我们如何确保每盏灯在动画结束时保持关闭？嗯，考虑到我们目标的独特需求，定制<code class="fe kx ky kz la b">Curve</code>实际上并不是一个合适的解决方案。相反，我们应该创造一种习俗<code class="fe kx ky kz la b">Tween</code>。</p><h2 id="0ac1" class="mi lc it bd ld mv mw dn lh mx my dp ll kb mz na lp kf nb nc lt kj nd ne lx nf bi translated">用补间动画眨眼</h2><p id="17c7" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">正如我们所讨论的，一个<code class="fe kx ky kz la b">Tween</code>可以在提供必要的<code class="fe kx ky kz la b">operators</code>的任何属性之间进行插值。有些类，比如<code class="fe kx ky kz la b">Color</code>，可能需要独特的实现。因为我们在这里使用了<code class="fe kx ky kz la b">Color</code>，我们不会重新发明轮子，而是扩展<code class="fe kx ky kz la b">ColorTween</code>并实现我们想要的行为。创建下面的<code class="fe kx ky kz la b">LightTween</code>类。</p><pre class="kp kq kr ks gt me la mf mg aw mh bi"><span id="94f6" class="mi lc it la b gy mj mk l ml mm">class LightTween extends ColorTween {<br/>  LightTween({required this.off, required this.on})<br/>      : super(begin: off, end: off);</span><span id="f745" class="mi lc it la b gy nh mk l ml mm">  final Color off, on;</span><span id="2279" class="mi lc it la b gy nh mk l ml mm">  @override<br/>  Color? lerp(double t) {<br/>    if (t &gt; 0.5) return Color.lerp(on, off, 2 * t - 1);<br/>    return Color.lerp(off, on, 2 * t);<br/>  }<br/>}</span></pre><p id="2ce4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我们的构造函数接受一个<code class="fe kx ky kz la b">on</code> &amp; <code class="fe kx ky kz la b">off</code>颜色进行插值。它将关闭颜色传递给<code class="fe kx ky kz la b">super</code>构造函数的<code class="fe kx ky kz la b">begin</code> &amp; <code class="fe kx ky kz la b">end</code>参数，因为我们希望以关闭灯光开始和结束。然后，我们覆盖<code class="fe kx ky kz la b">lerp</code>方法来实现我们的计算。我们使用<code class="fe kx ky kz la b">Color</code>的静态<code class="fe kx ky kz la b">lerp</code>方法返回<code class="fe kx ky kz la b">t</code>处<code class="fe kx ky kz la b">on</code> &amp; <code class="fe kx ky kz la b">off</code>之间的线性插值颜色。我们计算<code class="fe kx ky kz la b">t</code>的方式与之前计算<code class="fe kx ky kz la b">Blink</code>曲线的方式相同。我们只是将这一计算移到了<code class="fe kx ky kz la b">Tween</code>中。这有一个额外的好处，允许我们在补间中使用其他曲线。</p><p id="9449" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们需要将<code class="fe kx ky kz la b">initState</code>中的<code class="fe kx ky kz la b">ColorTween</code>替换为我们的<code class="fe kx ky kz la b">LightTween</code>。</p><pre class="kp kq kr ks gt me la mf mg aw mh bi"><span id="3399" class="mi lc it la b gy mj mk l ml mm">animations.add(<br/>  LightTween(off: offColor, on: onColor).animate(<br/>    CurvedAnimation(<br/>      parent: controller,<br/>      curve: Interval(begin, end),<br/>    ),<br/>  ),<br/>);</span></pre><p id="d5bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们来看看最后的结果。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/0ec833ee1ec26f000a5db4f1ec994a0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*JlfSAvLKrcVfrd6KI_b_Vg.gif"/></div></figure><p id="0a9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们做到了！创建自定义补间的工作做得很好！但是使用自定义曲线来完成动画目标不是很好吗？我同意。我们开始吧！</p><h1 id="02b5" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建闪烁动画</h1><p id="07df" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">我碰巧发现这条曲线很棒，并看到了很大的使用潜力，以及为进一步的应用而进行的调整。你有没有打开旧灯的开关，看到它闪烁着点亮？如果没有，你一定在恐怖电影里见过别人这样做，对吗？这就是我们想要的效果。我们将通过用几条线定义一条曲线来实现这个目标。最终结果看起来会像这样。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/0e59d7424e2a7e58ea9639b261da712c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*S3z8BZp1w9sQK1JEikwtGg.gif"/></div></figure><p id="40de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看一看<code class="fe kx ky kz la b">flicker.dart</code>。目前，当轻击屏幕时，灯泡会线性地闪烁。动画每个方向1秒。让我们首先定义我们的<code class="fe kx ky kz la b">Flicker</code>曲线如下。</p><pre class="kp kq kr ks gt me la mf mg aw mh bi"><span id="27bb" class="mi lc it la b gy mj mk l ml mm">class Flicker extends Curve {<br/>  Flicker();</span><span id="aa60" class="mi lc it la b gy nh mk l ml mm">  final rand = Random();</span><span id="aba9" class="mi lc it la b gy nh mk l ml mm">  @override<br/>  double transformInternal(double t) {<br/>    if (t &gt; 0.3) return t;<br/>    return (t - rand.nextDouble()).abs();<br/>  }<br/>}</span></pre><p id="459e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像以前一样，我们覆盖了<code class="fe kx ky kz la b">transformInternal</code>方法。这一次我们使用<code class="fe kx ky kz la b">Random</code>来创造随机振荡，以创造闪烁的效果。在动画的前30%中，我们通过从当前的<code class="fe kx ky kz la b">t</code>中减去一个0.0到1.0之间的随机值来创建闪烁效果。然后我们返回绝对值，因为<code class="fe kx ky kz la b">transformInternal</code>也必须返回0.0到1.0之间的值。在剩下的70%的动画中，我们简单地返回<code class="fe kx ky kz la b">t</code>。这将在闪烁后产生线性辉光到最大亮度的效果。</p><p id="a59b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们只是更新我们的动画来使用我们的<code class="fe kx ky kz la b">Flicker</code>曲线。旧的灯光不会闪烁，它们只是逐渐消失，所以我们也将为反向动画使用不同的曲线，并调整每个的持续时间，以获得更真实的效果。进行以下更改。</p><pre class="kp kq kr ks gt me la mf mg aw mh bi"><span id="a1e7" class="mi lc it la b gy mj mk l ml mm">late final controller = AnimationController(<br/>  vsync: this,<br/>  duration: const Duration(milliseconds: 2000),<br/>  reverseDuration: const Duration(milliseconds: 1000),<br/>);</span><span id="238d" class="mi lc it la b gy nh mk l ml mm">late final animation = ColorTween(begin: offColor, end: onColor).animate(<br/>  CurvedAnimation(<br/>    parent: controller,<br/>    curve: Flicker(),<br/>    reverseCurve: Curves.easeOut,<br/>  ),<br/>);</span></pre><p id="ba79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在你知道了！一个古老的，怪异的灯泡图标动画。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/0e59d7424e2a7e58ea9639b261da712c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*S3z8BZp1w9sQK1JEikwtGg.gif"/></div></figure><p id="f4ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为这是用曲线完成的，所以你可以把它应用到你想要的任何其他动画上。虽然，对大多数人来说这可能很不和谐。您还可以为重复的动画实现恒定的闪烁效果。你还能想出哪些很酷的效果或创意？请在评论中分享！</p><h1 id="e85a" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="09ed" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">为了更好地理解Flutter的动画框架，我们讨论了一些非常深入的话题。希望现在使用隐式和显式动画不再那么令人畏惧。让我们复习一下今天学过的概念。</p><ul class=""><li id="629d" class="ni nj it js b jt ju jx jy kb nk kf nl kj nm kn nn no np nq bi translated">提供给<code class="fe kx ky kz la b">vsync</code>的<code class="fe kx ky kz la b">TickerProvider</code>负责通知<code class="fe kx ky kz la b">AnimationController</code>屏幕即将被重绘，因此应该计算新的动画值。</li><li id="4b80" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated">基于0.0和1.0之间的时间<em class="kw"> t </em>，简单地计算开始&amp;结束值之间的值。</li><li id="eed9" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated">简单地通过一个<code class="fe kx ky kz la b">transformation</code>公式将时间<em class="kw"> t₁ </em>映射到新的值<em class="kw"> t₂ </em>。这个新值就是<code class="fe kx ky kz la b">Tween</code>使用的<em class="kw"> t </em>。</li></ul><p id="e99f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总之，这些类最终组成了屏幕上绘制的每一个动画。理解了这个概念，我们就可以制作任何我们能想到的动画，有时只需要几行代码！</p><p id="f113" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望你离开这篇文章时对使用Flutter动画更有信心。如果你觉得它有帮助，请留下一些掌声，让我知道。如果你有任何意见或问题，他们总是很感激。我会回复你，它们可能会启发我的下一篇文章。一如既往的感谢您的阅读！更多文章将很快推出，请继续关注。</p></div></div>    
</body>
</html>