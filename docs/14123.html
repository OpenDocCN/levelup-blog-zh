<html>
<head>
<title>There Are Some Bugs in ConcurrentHashMap in JDK-8</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JDK-8中的ConcurrentHashMap有一些bug</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-there-are-some-bugs-in-concurrenthashmap-de168de084a8?source=collection_archive---------12-----------------------#2022-11-02">https://levelup.gitconnected.com/what-there-are-some-bugs-in-concurrenthashmap-de168de084a8?source=collection_archive---------12-----------------------#2022-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1b7a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是的，你没看错。在JDK-8中，ConcurrentHashMap中有一些bug，可能会给你带来麻烦。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/bf13bbbd60983fb08b9ba4d4424ccabf.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*RvYkrm7K1Hqj7mBn94d5mw.jpeg"/></div></figure><p id="4043" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ConcurrentHashMap是我们日常工作中最常用的集合类之一。其特点是高性能和线程安全。然而，有两个错误影响了这个熟悉的地图的性能。问题在<code class="fe kw kx ky kz b">computeIfAbsent()</code>。</p><ul class=""><li id="3c04" class="la lb it js b jt ju jx jy kb lc kf ld kj le kn lf lg lh li bi translated"><code class="fe kw kx ky kz b">computeIfAbsent()</code>多线程获取同一个键时阻塞。</li><li id="9519" class="la lb it js b jt lj jx lk kb ll kf lm kj ln kn lf lg lh li bi translated">在<code class="fe kw kx ky kz b">computeIfAbsent()</code>中，ConcurrentHashMap可能会陷入死循环。</li></ul><h1 id="8f6c" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated"><em class="mm">性能Bug </em></h1><p id="a475" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">我们都知道<code class="fe kw kx ky kz b">computeIfAbsent()</code>可以把下面两个操作合二为一，并保证它的线程安全。</p><ul class=""><li id="16e0" class="la lb it js b jt ju jx jy kb lc kf ld kj le kn lf lg lh li bi translated">确定一个键是否为空。</li><li id="44a9" class="la lb it js b jt lj jx lk kb ll kf lm kj ln kn lf lg lh li bi translated">否则，执行逻辑就像put方法一样。</li></ul><p id="dfd5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样做是使用synchronized，但是如果用相同的键重复invoke computeIfAbsent方法，它总是被阻塞。换句话说，当多个线程获取同一个键时，computeIfAbsent会阻塞，这会影响性能(https://<a class="ae ms" href="http://http" rel="noopener ugc nofollow" target="_blank">bugs.opnejdk.java.net/browse/JDK-8161372</a>)。幸运的是，此问题已在JDK-9中得到解决。如果你仍然使用JDK-8，我们找到一个变通办法。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="d031" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">计算机中的无限循环不存在</h1><p id="a100" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">这是一个致命的错误。问题是，我们在另一个computeifaxine中用一个偶然相同的hash码(在附加的例子中,“AaAa”和“BBBB”也有相同的hash code)进行computeifaxine。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mv"><img src="../Images/37bbf1680f7760a7225d3640bc8f1c2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CBVO_gt_-hxQB97JoLeGWA.png"/></div></div></figure><p id="b152" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们仔细看看这段代码会发生什么。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi na"><img src="../Images/8073ca1e25df57df504bb45c8c2a9b5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_RPSsWGImepK0bjJNBTudQ.png"/></div></div></figure><p id="d261" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这张图片可以清楚地解释为什么会出现这个bug。</p><ul class=""><li id="25dc" class="la lb it js b jt ju jx jy kb lc kf ld kj le kn lf lg lh li bi translated">第一个if为真，因为f = tabAt(…)等于null</li><li id="7fc4" class="la lb it js b jt lj jx lk kb ll kf lm kj ln kn lf lg lh li bi translated">然后创建一个hashcode为-3的ReservationNode</li><li id="5839" class="la lb it js b jt lj jx lk kb ll kf lm kj ln kn lf lg lh li bi translated">显然，第二个if <em class="nb"> ((fh = f.hash) == MOVED) </em>不满足</li><li id="618a" class="la lb it js b jt lj jx lk kb ll kf lm kj ln kn lf lg lh li bi translated">tabAt(tab，i) == f为真</li><li id="d3ae" class="la lb it js b jt lj jx lk kb ll kf lm kj ln kn lf lg lh li bi translated">if (fh&gt;= 0)不满足，因为fh = -3</li><li id="1438" class="la lb it js b jt lj jx lk kb ll kf lm kj ln kn lf lg lh li bi translated">if(binCount！=0)不满足，因为binCount==0</li><li id="b2f2" class="la lb it js b jt lj jx lk kb ll kf lm kj ln kn lf lg lh li bi translated">并返回到for循环</li></ul><p id="d68e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些错误已经在JDK-9中得到修复。如果你还在使用JDK-8，强烈建议你升级到JDK-9。</p><p id="b9eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢阅读。</p></div></div>    
</body>
</html>