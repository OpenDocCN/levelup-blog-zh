<html>
<head>
<title>Receiving messages from Amazon SQS in a Spring Boot application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Spring Boot应用程序中接收来自亚马逊SQS的消息</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/receiving-messages-from-amazon-sqs-in-a-spring-boot-application-6e8a2d7583be?source=collection_archive---------1-----------------------#2020-01-16">https://levelup.gitconnected.com/receiving-messages-from-amazon-sqs-in-a-spring-boot-application-6e8a2d7583be?source=collection_archive---------1-----------------------#2020-01-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="79e2" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">原载于<a class="ae kp" href="https://blog.contactsunny.com/tech/receiving-messages-from-amazon-sqs-in-a-spring-boot-application" rel="noopener ugc nofollow" target="_blank">我的个人博客</a>2020年1月16日。</p></blockquote><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/56c05f888238b094e019dcf32e99a6c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lh0PjtjZ2ceAX-TI"/></div></div></figure><p id="4f0c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">在本帖中，我们将了解如何在Spring Boot应用程序中接收来自亚马逊SQS队列的消息。这是上一篇文章的延续，在上一篇文章中，我们讨论了如何<a class="ae kp" href="https://blog.contactsunny.com/tech/sending-messages-to-amazon-sqs-from-a-spring-boot-application" rel="noopener ugc nofollow" target="_blank">向SQS队列</a>发送消息。很明显，接下来的问题是我们如何接收这些信息。所以在这篇文章中，我们会这样做。</p><p id="e49c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">如果您还没有创建SQS队列，请查看之前关于如何创建的帖子。这里，我假设您已经有了管道设置。所以我要跳过帖子的这一部分。我们将直接进入代码。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="3741" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">代码</h1><p id="a20b" class="pw-post-body-paragraph jq jr iq jt b ju mk jw jx jy ml ka kb lc mm ke kf ld mn ki kj le mo km kn ko ij bi translated">我们需要在Spring Boot应用程序中添加的第一件事是SQS依赖。幸运的是，Maven中央存储库中提供了依赖关系。因此，我们只需在我们的<em class="js"> pom.xml </em>文件的<em class="js">依赖关系</em>块中添加以下内容:</p><pre class="kr ks kt ku gt mp mq mr ms aw mt bi"><span id="c356" class="mu ln iq mq b gy mv mw l mx my">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-cloud-aws-messaging&lt;/artifactId&gt;<br/>    &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="6d0d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">接下来，我们必须处理好属性。对于这个例子，我们将使用AWS的静态凭证提供者。所以我们需要访问密钥和秘密密钥。我假设你已经有这些东西了。所以我将跳过如何设置它的说明。在我们的<em class="js"> application.properties </em>文件中，我们将拥有以下属性:</p><pre class="kr ks kt ku gt mp mq mr ms aw mt bi"><span id="4fb8" class="mu ln iq mq b gy mv mw l mx my">sqs.url=https://sqs.us-east-2.amazonaws.com/1234/abcd<br/><br/>aws.accessKey=<br/>aws.secretKey=<br/>aws.region=</span></pre><p id="706a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">填写属性文件中的空白。我们必须在Java代码中获取这些值。因为我们使用的是Spring Boot，所以使用<em class="js"> @Value </em>注释可以很容易地将这些值写入我们的代码:</p><pre class="kr ks kt ku gt mp mq mr ms aw mt bi"><span id="0467" class="mu ln iq mq b gy mv mw l mx my">@Value("${sqs.url}")<br/>private String sqsUrl;<br/><br/>@Value("${aws.accessKey}")<br/>private String awsAccessKey;<br/><br/>@Value("${aws.secretKey}")<br/>private String awsSecretKey;<br/><br/>@Value("${aws.region}")<br/>private String awsRegion;</span></pre><p id="0e86" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">在这之后，我们必须为AWS cred greates和SQS分别创建一个对象。我们可以使用下面的代码片段来做到这一点:</p><pre class="kr ks kt ku gt mp mq mr ms aw mt bi"><span id="7915" class="mu ln iq mq b gy mv mw l mx my">AWSCredentialsProvider awsCredentialsProvider = new AWSStaticCredentialsProvider(<br/>        new BasicAWSCredentials(awsAccessKey, awsSecretKey)<br/>);<br/><br/>AmazonSQS amazonSQS = AmazonSQSClientBuilder.standard().withCredentials(awsCredentialsProvider).build();</span></pre><p id="d78c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">现在我们必须开始阅读信息。我们在一个<em class="js"> while(true) {} </em>循环中这样做。这是因为我们不想停止收听新信息。我们必须持续不断地这样做。但是在我们进入循环之前，我们必须创建一个请求对象来周期性地从SQS请求消息。在这个请求中，我们可以指定每个响应中需要多少消息，以及连续请求之间的时间间隔。这个请求对象是<em class="js"> ReceiveMessageRequest </em>类的一个实例，我们是这样创建它的:</p><pre class="kr ks kt ku gt mp mq mr ms aw mt bi"><span id="1117" class="mu ln iq mq b gy mv mw l mx my">final ReceiveMessageRequest receiveMessageRequest = new ReceiveMessageRequest(sqsUrl)<br/>        .withMaxNumberOfMessages(1)<br/>        .withWaitTimeSeconds(3);</span></pre><p id="7ae8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">现在我们进入循环。在循环中，我们使用之前创建的SQS客户端实例来请求消息。一旦我们这样做了，我们就会得到一个消息列表作为回报。然后，我们可以继续处理每条消息。该循环如下所示:</p><pre class="kr ks kt ku gt mp mq mr ms aw mt bi"><span id="9085" class="mu ln iq mq b gy mv mw l mx my">while (true) {<br/><br/>    final List&lt;Message&gt; messages = amazonSQS.receiveMessage(receiveMessageRequest).getMessages();<br/><br/>    for (Message messageObject : messages) {<br/>        String message = messageObject.getBody();<br/><br/>        logger.info("Received message: " + message);<br/>    }<br/>}</span></pre><p id="d06c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">我在这里保持处理简单，只是打印出消息体。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="7147" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">一个队列有多个消息使用者</h1><p id="408a" class="pw-post-body-paragraph jq jr iq jt b ju mk jw jx jy ml ka kb lc mm ke kf ld mn ki kj le mo km kn ko ij bi translated">如果您来自Apache Kafka领域，您会知道我们可以让多个消费者使用相同的组ID来并行处理一个主题中的消息。这里显而易见的问题是，我们能对SQS做同样的事情吗？</p><p id="179e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">简单的回答是，是的，我们可以。但是，这里没有组ID的概念，或者类似的概念。如果有多个服务在监听同一个SQS队列，那么进入该队列的消息将分布在所有这些服务中。没有两个服务会得到相同的消息。如果你想模仿卡夫卡的消费者，为同一个主题使用多个群组id，你需要结合使用SNS(亚马逊的简单通知服务)和SQS。如果你们感兴趣的话，也许我会再写一篇关于如何做的文章。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="3c90" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">在SQS确认一个信息</h1><p id="c0a8" class="pw-post-body-paragraph jq jr iq jt b ju mk jw jx jy ml ka kb lc mm ke kf ld mn ki kj le mo km kn ko ij bi translated">在Apache Kafka中，一旦我们使用了来自某个主题的消息，并处理了该消息，我们就通过提交偏移量来确认该消息。一旦你这样做了，这条消息将不会在你下次请求消息时发送给你。如果您提交了偏移量，这意味着您已经处理完了该消息，并且您在告诉系统不要再向您发送该消息。在这里有可能做同样的事情吗？</p><p id="def8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">这个问题的答案也是肯定的。在SQS世界里有一种叫做<em class="js">能见度超时</em>的东西。Visibility timeout是消息对任何使用者可见的时间。因此，如果在可见性超时期限内多次查询消息，很可能会得到相同的消息。因此，SQS的“提交偏移量”等同于从队列中删除消息。在我们前面看到的代码片段中的<em class="js"> for </em>循环中，我们可以在阅读完消息后删除它。我为此编写了一个简单的方法:</p><pre class="kr ks kt ku gt mp mq mr ms aw mt bi"><span id="9ba9" class="mu ln iq mq b gy mv mw l mx my">private void deleteMessage(Message messageObject) {<br/><br/>    final String messageReceiptHandle = messageObject.getReceiptHandle();<br/>    amazonSQS.deleteMessage(new DeleteMessageRequest(sqsUrl, messageReceiptHandle));<br/><br/>}</span></pre><p id="8a60" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">我们将更改前面代码片段中的循环，以便在处理消息后调用此方法:</p><pre class="kr ks kt ku gt mp mq mr ms aw mt bi"><span id="48f1" class="mu ln iq mq b gy mv mw l mx my">while (true) {<br/><br/>    final List&lt;Message&gt; messages = amazonSQS.receiveMessage(receiveMessageRequest).getMessages();<br/><br/>    for (Message messageObject : messages) {<br/>        String message = messageObject.getBody();<br/><br/>        logger.info("Received message: " + message);<br/><br/>        deleteMessage(messageObject);<br/>    }<br/>}</span></pre><p id="0a39" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">我写的SQS相关代码是一个名为SQSUtil的类。这个类被注释为一个<em class="js">@组件</em>，这样我就可以在代码库中的任何地方<em class="js"> @Autowire </em>它。该类如下所示:</p><pre class="kr ks kt ku gt mp mq mr ms aw mt bi"><span id="4b87" class="mu ln iq mq b gy mv mw l mx my">@Component<br/>public class SQSUtil {<br/><br/>    @Value("${sqs.url}")<br/>    private String sqsUrl;<br/><br/>    @Value("${aws.accessKey}")<br/>    private String awsAccessKey;<br/><br/>    @Value("${aws.secretKey}")<br/>    private String awsSecretKey;<br/><br/>    @Value("${aws.region}")<br/>    private String awsRegion;<br/><br/>    private AmazonSQS amazonSQS;<br/><br/>    private static final Logger logger = LoggerFactory.getLogger(SQSUtil.class);<br/><br/>    @PostConstruct<br/>    private void postConstructor() {<br/><br/>        logger.info("SQS URL: " + sqsUrl);<br/><br/>        AWSCredentialsProvider awsCredentialsProvider = new AWSStaticCredentialsProvider(<br/>                new BasicAWSCredentials(awsAccessKey, awsSecretKey)<br/>        );<br/><br/>        this.amazonSQS = AmazonSQSClientBuilder.standard().withCredentials(awsCredentialsProvider).build();<br/>    }<br/><br/>    public void startListeningToMessages() {<br/><br/>        final ReceiveMessageRequest receiveMessageRequest = new ReceiveMessageRequest(sqsUrl)<br/>                .withMaxNumberOfMessages(1)<br/>                .withWaitTimeSeconds(3);<br/><br/>        while (true) {<br/><br/>            final List&lt;Message&gt; messages = amazonSQS.receiveMessage(receiveMessageRequest).getMessages();<br/><br/>            for (Message messageObject : messages) {<br/>                String message = messageObject.getBody();<br/><br/>                logger.info("Received message: " + message);<br/><br/>                deleteMessage(messageObject);<br/>            }<br/>        }<br/>    }<br/><br/>    private void deleteMessage(Message messageObject) {<br/><br/>        final String messageReceiptHandle = messageObject.getReceiptHandle();<br/>        amazonSQS.deleteMessage(new DeleteMessageRequest(sqsUrl, messageReceiptHandle));<br/><br/>    }<br/>}</span></pre><p id="ad4c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">如果你很好奇，想看看Apache Kafka的生产者和消费者的代码有多大的不同，看看<a class="ae kp" href="https://blog.contactsunny.com/tech/simple-apache-kafka-producer-and-consumer-using-spring-boot" rel="noopener ugc nofollow" target="_blank">这篇文章</a>，在那里我也谈到了同样的问题。你可以在<a class="ae kp" href="https://github.com/contactsunny/AmazonSQSConsumerPOC" rel="noopener ugc nofollow" target="_blank">我的Githup repo </a>上获得这个帖子的完整工作项目。</p></div></div>    
</body>
</html>