<html>
<head>
<title>Operating System — Scheduling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">操作系统—调度</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/operating-system-scheduling-fb7dc14b8c0a?source=collection_archive---------6-----------------------#2021-08-03">https://levelup.gitconnected.com/operating-system-scheduling-fb7dc14b8c0a?source=collection_archive---------6-----------------------#2021-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6ed6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">仅用5分钟了解日程安排</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/24c8f80b78e5f909378f43eeaa6066c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DfGRNybrhM4A4KAv"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">卢卡斯·布拉塞克在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1626" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您的计算机每天同时执行成百上千个任务。你有没有想过它是如何稳定有序地处理这么多事情的？</p><h1 id="b0c8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是排班？</h1><p id="e584" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir">调度</strong>是决定下一个运行哪个进程并分配资源给它执行任务的过程。我们在讨论调度的时候经常会提到“<strong class="ky ir">上下文切换</strong>”。它是从一个过程到另一个过程的实际切换过程。</p><h2 id="4722" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">上下文切换什么时候发生？</h2><p id="9916" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">下图显示了流程的生命周期。如果你想了解更多关于过程管理的知识，可以看看我以前的文章。</p><div class="nb nc gp gr nd ne"><a rel="noopener  ugc nofollow" target="_blank" href="/operating-system-process-management-26c73901166"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">操作系统—流程管理</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">关于过程的基础、中级和高级知识</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns kp ne"/></div></div></a></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/a2826f71f7734ee9e6e900d64357b30e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*gqAX5VTFvuQUl2GC7D1qOA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">流程生命周期</figcaption></figure><p id="ae78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有许多方法可以实现上下文切换:</p><ol class=""><li id="6f11" class="nu nv iq ky b kz la lc ld lf nw lj nx ln ny lr nz oa ob oc bi translated">每当进程进入阻塞/等待状态(wait()/sleep())时</li><li id="95d9" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated">当POSIX信号到达时(SIGCHLD)</li><li id="8a06" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated">当中断到达时(击键)</li><li id="1104" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated">当操作系统调度程序中断并停止进程时(循环调度，优先级循环调度)</li></ol><h2 id="6364" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">深入了解上下文切换</h2><p id="a234" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">你可能想知道<strong class="ky ir">上下文切换</strong>实际上在做什么。</p><p id="798b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设一个进程放弃在CPU上运行。比如调用sleep()。</p><p id="1b4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，调度程序将选择下一个要运行的进程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/883f0b13fefc175fdffffd9587823252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QPqcXMauJiMtY1ejVdVatA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">备份所有当前上下文</figcaption></figure><p id="2ddd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，在调度程序能够获得CPU的控制权之前，CPU必须将该进程的所有当前上下文备份到内核空间内存中:</p><ul class=""><li id="4d48" class="nu nv iq ky b kz la lc ld lf nw lj nx ln ny lr oj oa ob oc bi translated">当前寄存器值</li><li id="ede7" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr oj oa ob oc bi translated">程序计数器(当前程序在代码的哪一行)</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/9c1bd0595ebe7ba88e85718eaa838166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kHPuqLyPpGrCu_g_-u2lyg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">从主存储器加载进程上下文</figcaption></figure><p id="2dbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果调度程序决定调度就绪队列中的另一个进程，该调度程序必须将该进程的上下文从主内存加载到CPU。</p><p id="faed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这整个操作被称为“<strong class="ky ir">上下文切换</strong>”。</p><h2 id="8244" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">上下文切换开销很大</h2><p id="5132" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">内核中的直接成本:</p><ul class=""><li id="6196" class="nu nv iq ky b kz la lc ld lf nw lj nx ln ny lr oj oa ob oc bi translated">保存和恢复寄存器等。</li><li id="0229" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr oj oa ob oc bi translated">交换地址空间(昂贵的指令)</li></ul><p id="efcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">间接成本:</p><ul class=""><li id="1541" class="nu nv iq ky b kz la lc ld lf nw lj nx ln ny lr oj oa ob oc bi translated">隐藏物</li><li id="ed95" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr oj oa ob oc bi translated">缓冲缓存</li><li id="2426" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr oj oa ob oc bi translated">TLB失手了</li></ul><h1 id="a9e2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是进程调度？</h1><p id="5bcd" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">调度是必需的，因为计算资源(CPU)的数量是有限的。</p><p id="da57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当调度程序选择一个进程时，该进程将拥有CPU，直到:</p><ul class=""><li id="2713" class="nu nv iq ky b kz la lc ld lf nw lj nx ln ny lr oj oa ob oc bi translated">该进程主动等待I/O</li><li id="4dfe" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr oj oa ob oc bi translated">进程主动释放CPU(例如exit())</li><li id="8c91" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr oj oa ob oc bi translated">该过程检测特定类型的中断(例如周期性时钟中断)</li></ul><p id="c50e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">古时候叫“<strong class="ky ir">分时</strong>”。现在，所有的系统都是分时的。</p><p id="6325" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于进程调度，有不同的调度算法。</p><h1 id="1fbe" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">调度算法</h1><h2 id="71fd" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">最短作业优先(SJF)</h2><p id="c754" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">每当一个新的进程到达系统时，调度程序就会介入并根据剩余的CPU需求选择下一个任务。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/70ad77009b6e326d99529458ee5c995b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XrsrXNPlkk9noo1XVwMfDw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">由于只有一个进程，调度程序将首先处理进程A</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/989c91834071031bdbae11d0bbe68802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*spLvr5sBKXUenkpYqFX4tw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">调度程序将首先分配CPU来处理新进程(进程B ),因为它需要的资源最少</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/f93502f64bf1b71e0d663398e7b67033.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qc_dFOhmD2nO_am0CDwM1w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在运行进程B之后，CPU将继续处理进程A</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/dcc4a66eabc979a966778a75c72bff02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DzL5P3FYtTaxADXMBXzGYg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">如果有资源需求较低的新进程(进程C)出现，CPU将首先切换到处理它</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/20485d2d208fe972cabe3e736c9312a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kmwZN_gNdcn8SRpEM3uzhg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">运行进程C后，CPU将继续处理进程A</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/b4c8aa7b37f162e04f6ebd2f1b18b27c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x0tzCa0sreVzfv1lnvRzUw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">现在将忽略进程D，因为进程A需要的资源较少</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/c13e58b5fc457049b2770491e2ffd8f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XHKMyy5Oj9VMDLWnBbC6Xg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">流程D将在流程A完成后处理</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/17abf7f55620844ecb860c84a4d9b492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*boUFzAnPnjRa9UerWvAqtg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">完成的</figcaption></figure><p id="0d28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该算法的缺点是上下文切换的次数可能很高，因为<strong class="ky ir">上下文切换是昂贵的</strong>。</p><h2 id="5b51" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">循环赛</h2><p id="e8ed" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">循环调度是抢占式的。</p><p id="c7a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">进程作为一个循环队列一个接一个地运行，没有优先级。</p><ul class=""><li id="1c2e" class="nu nv iq ky b kz la lc ld lf nw lj nx ln ny lr oj oa ob oc bi translated">新进程被添加到就绪队列的尾部</li><li id="d4ac" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr oj oa ob oc bi translated">新流程的到来不会触发新的选择决策</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/c318f4e68a77e2bb641a522c3b32dd5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YJPA3QjaqMjJusnuLBuGQg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">每个进程被赋予一个量程2，即允许执行的时间量</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/066e0de27b3d6761cc83bebb4cb645b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G54reQ_pekEH3APinCoaEA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">CPU将首先处理进程A，并且只处理给定的quantun</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/2831694af7d1dd7e2e02b0ae81328416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mVa7DcpfIl5ydGdSDHc8ow.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在进程A用完量程后，调度程序将分配CPU来处理下一个进程，即进程B</figcaption></figure><p id="1db1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当一个进程的量用完时，该进程就释放CPU，这就是抢占。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/1f1d4026f3bed2fc1fefa20f8d4efe99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4dAyFzZSWXcgdsxJGNClLQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">进程B将消耗量程</figcaption></figure><p id="f78b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，调度程序介入并选择下一个具有非零量程的进程来运行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/a1e141780a578241638b3912eaf4073f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6x0mdjxluj9DgLsFC3fY4Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在进程BHA用完量程后，调度程序将分配CPU来处理下一个进程，即进程C</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/e91d599b0615e406377d9ae27d51dc2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-wy-fds8022LhJTCsDrZcw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在完成进程C之后，CPU将处理进程D</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/1a35060b615373d8acc609fa0eaa73a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uOS1omMkeUIXXSCWFEmR6A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">一轮之后，进程的数量被重置</figcaption></figure><p id="8b68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果系统中的所有进程都用完了量程，它们将被重新充电到初始值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/3c9b03c867abbefbc4892a442e6b3714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XJ5SBjm8isD1Mpn3NwDHDQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">CPU将处理进程A</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/59cfb3922df500a96a90d0ac79c93525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QVEyRkAsxOQjWeqPiptrJA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">CPU已经完成处理进程B</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/11a1bed7313a086a1c01addfba9393a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4-_cHcCsOmLKdHiPuomrQQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">同时，进程A的数量被重置</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/f9f9a061c99a210ea8e3fff24f830d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9nObvL9rq-zFA6U2CmKeNg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">完成的</figcaption></figure><h2 id="4358" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">优先级调度</h2><p id="4a22" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一个任务有一个优先级，通常是一个整数。</p><ul class=""><li id="f83e" class="nu nv iq ky b kz la lc ld lf nw lj nx ln ny lr oj oa ob oc bi translated">调度程序根据优先级选择下一个进程</li><li id="d2a6" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr oj oa ob oc bi translated">更高优先级的进程+循环=优先级队列+新进程到达触发新的选择</li></ul><p id="e3e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">静态优先级调度</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/e235683b14fe7679250fd117b3201254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CZ3bWfSK7_1RkwBgUphb0g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">静态优先级调度</figcaption></figure><p id="3589" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当进程被提交到系统时，它们被分配一个固定的优先级。将选择最高优先级的类别。这些任务通常是短暂的，但是重要的</p><p id="e3fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了防止高优先级任务无限期运行，只有当高优先级类没有任务时，才会调度低优先级类。</p><p id="d435" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">多队列优先级调度</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/228902b40923aa304f16c377a9d0b3cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*twECmPIZiMhT9U4BOe9wKw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">多队列优先级调度</figcaption></figure><p id="a185" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它仍然是一个优先级调度程序。但是，在每个优先级，可以部署不同的调度器。优先级可以是静态和动态的混合。</p></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><h2 id="a209" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">后续步骤</h2><p id="05be" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果你正在读这一行，恭喜你！！！你做到了。您已经学习了调度的基础知识和最常见的调度算法。</p><p id="9d12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请随意查看下面关于操作系统的其他文章:</p><div class="nb nc gp gr nd ne"><a href="https://mattchw.medium.com/overview-of-operating-system-cc3f6f6bb062" rel="noopener follow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">操作系统概述</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">操作系统一般是如何工作的？</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">mattchw.medium.com</p></div></div><div class="nn l"><div class="ou l np nq nr nn ns kp ne"/></div></div></a></div><p id="81b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解更多关于我的后端学习路径，请点击这里查看我的旅程:</p><div class="nb nc gp gr nd ne"><a href="https://mattchw.medium.com/my-backend-developer-learning-journey-%E6%88%91%E7%9A%84%E5%BE%8C%E7%AB%AF%E5%AD%B8%E7%BF%92%E4%B9%8B%E6%97%85-5315fe2fefc2" rel="noopener follow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi">My Backend Developer Learning Journey 我的後端學習之旅</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">毕业一年多了。拥有2年以上的前端和后端工作经验…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">mattchw.medium.com</p></div></div><div class="nn l"><div class="ov l np nq nr nn ns kp ne"/></div></div></a></div></div></div>    
</body>
</html>