<html>
<head>
<title>JavaScript Mistakes — Async, Type Checking, and Values</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript错误—异步、类型检查和值</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-mistakes-async-type-checking-and-values-a10f9d0ce29a?source=collection_archive---------10-----------------------#2020-04-06">https://levelup.gitconnected.com/javascript-mistakes-async-type-checking-and-values-a10f9d0ce29a?source=collection_archive---------10-----------------------#2020-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f5e548f94143600bb64b281d04b02e00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JJMqUg3NcAdTOvaO"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@rotalex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alexandru Rotariu </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="0f2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="2fda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究如何在运行多个承诺时避免竞态条件等等。</p><h1 id="f8ab" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">由于让步和等待，可能导致竞争条件的赋值</h1><p id="db4e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当使用承诺时，如果我们没有恰当地组合多个承诺，很容易产生竞争条件。</p><p id="a339" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5626" class="mq lf it mm b gy mr ms l mt mu">let total = 0;</span><span id="564b" class="mq lf it mm b gy mv ms l mt mu">const getNum = async (num) =&gt; {<br/>  return num;<br/>}</span><span id="eb5a" class="mq lf it mm b gy mv ms l mt mu">const add = async (num) =&gt; {<br/>  total += await getNum(num);<br/>}</span><span id="7a4d" class="mq lf it mm b gy mv ms l mt mu">Promise.all([add(1), add(2)]).then(() =&gt; {<br/>  console.log(total);<br/>});</span></pre><p id="7104" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们调用<code class="fe mw mx my mm b">add</code>异步函数，该函数从<code class="fe mw mx my mm b">getNum</code>承诺中获取结果，并将其添加到<code class="fe mw mx my mm b">total</code>中。</p><p id="2b66" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们调用<code class="fe mw mx my mm b">Promise.all</code>，它并行运行代码。在此期间，分配给<code class="fe mw mx my mm b">total</code>的第一个值将被覆盖，因为<code class="fe mw mx my mm b">total</code>在每个承诺被解析之前仍被设置为初始值。</p><p id="4915" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们将看到2，而不是我们预期的3。</p><p id="bf4a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过将<code class="fe mw mx my mm b">add</code>中的解析值赋给一个变量，然后将它们添加到<code class="fe mw mx my mm b">total</code>中来修复这个错误，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6e52" class="mq lf it mm b gy mr ms l mt mu">const add = async (num) =&gt; {<br/>  const res = await getNum(num);<br/>  total += res;<br/>}</span></pre><p id="ed4d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者我们可以等待两者都解决，然后将结果相加:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ed9c" class="mq lf it mm b gy mr ms l mt mu">const getNum = async (num) =&gt; {<br/>  return num;<br/>}</span><span id="d3ac" class="mq lf it mm b gy mv ms l mt mu">const add = async (num) =&gt; {<br/>  return await getNum(num);<br/>}</span><span id="6a35" class="mq lf it mm b gy mv ms l mt mu">Promise.all([add(1), add(2)]).then((nums) =&gt; {<br/>  const total = nums.reduce((a, b) =&gt; a + b, 0);<br/>  console.log(total);<br/>});</span></pre><h1 id="1747" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不使用isNaN检查NaN</h1><p id="9eef" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mw mx my mm b">NaN</code>是JavaScript中的一个特殊值。与<code class="fe mw mx my mm b">==</code>或<code class="fe mw mx my mm b">===</code>相比，它不等于它自己。例如，以下内容:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="186a" class="mq lf it mm b gy mr ms l mt mu">NaN === NaN<br/>NaN == NaN</span></pre><p id="c0b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">返回<code class="fe mw mx my mm b">false</code>和:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="61e2" class="mq lf it mm b gy mr ms l mt mu">NaN !== NaN<br/>NaN != NaN</span></pre><p id="2cfb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">返回<code class="fe mw mx my mm b">true</code>。</p><p id="3a9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">NaN</code>检查与<code class="fe mw mx my mm b">indexOf</code>和<code class="fe mw mx my mm b">lastIndexOf</code>也不起作用:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5a92" class="mq lf it mm b gy mr ms l mt mu">const arr = [NaN];<br/>console.log(arr.indexOf(NaN));<br/>console.log(arr.<!-- -->lastIndexOf<!-- -->(NaN));</span></pre><p id="c3ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们将从控制台日志中返回-1。</p><p id="523d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该用<code class="fe mw mx my mm b">isNaN</code>功能检查<code class="fe mw mx my mm b">NaN</code>，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="14ad" class="mq lf it mm b gy mr ms l mt mu">const foo = NaN;<br/>if (isNaN(foo)){<br/>  console.log('is NaN');<br/>}</span></pre><p id="ab0a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以使用<code class="fe mw mx my mm b">Object.is</code>方法来检查<code class="fe mw mx my mm b">NaN</code>，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="717b" class="mq lf it mm b gy mr ms l mt mu">const foo = NaN;<br/>if (Object.is(foo, NaN)) {<br/>  console.log('is NaN');<br/>}</span></pre><p id="c645" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要检查<code class="fe mw mx my mm b">NaN</code>是否在一个数组中，我们可以编写自己的函数来完成:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4d0f" class="mq lf it mm b gy mr ms l mt mu">const arr = [NaN];<br/>console.log(arr.some(a =&gt; isNaN(a)));</span></pre><h1 id="4c02" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将表达式类型与无效字符串进行比较</h1><p id="5ef0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">写字符串很容易出现错别字。因此，我们应该检查我们用<code class="fe mw mx my mm b">typeof</code>检查的类型是否正确。</p><p id="c230" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，下面的代码在字符串中有错别字，这将导致<code class="fe mw mx my mm b">typeof</code>不像我们预期的那样工作:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a80f" class="mq lf it mm b gy mr ms l mt mu">typeof foo === "strnig"<br/>typeof foo == "undefimed"<br/>typeof bar === "nunber"<br/>typeof bar === "fucntion"</span></pre><p id="8186" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该确保我们比较的字符串拼写正确，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d529" class="mq lf it mm b gy mr ms l mt mu">typeof foo === "string"<br/>typeof foo == "undefined"<br/>typeof bar === "number"<br/>typeof bar === "function"</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/0d24bd59abea3a58822645e838a36bef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FVFPeaWctwsYOunj"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Victor Grabarczyk 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="ff6f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在对象和类中，Getters和Setters应该在一起</h1><p id="7e91" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">没有相应的getter，setter就没什么用。例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6c09" class="mq lf it mm b gy mr ms l mt mu">const obj = {<br/>  set foo(val) {<br/>    this._foo = val<br/>  }<br/>}</span></pre><p id="7b4a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么就没有办法得到<code class="fe mw mx my mm b">foo</code>的值，即使我们设置了值，当我们引用<code class="fe mw mx my mm b">obj.foo</code>时也会得到<code class="fe mw mx my mm b">undefined</code>。</p><p id="9a41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该给对象添加一个相应的getter来返回值。例如，我们应该这样写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5c88" class="mq lf it mm b gy mr ms l mt mu">const obj = {<br/>  get foo() {<br/>    return this._foo;<br/>  },<br/>  set foo(val) {<br/>    this._foo = val<br/>  }<br/>}</span></pre><p id="5ff2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要用带有getters和setters的<code class="fe mw mx my mm b">defineProperty</code>定义一个新属性，我们可以编写如下代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0d48" class="mq lf it mm b gy mr ms l mt mu">const obj = {};<br/>Object.defineProperty(obj, 'foo', {<br/>  get() {<br/>    return this._foo;<br/>  },<br/>  set(val) {<br/>    this._foo = val<br/>  }<br/>});</span></pre><p id="79f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后如果我们给<code class="fe mw mx my mm b">foo</code>赋值，就可以得到<code class="fe mw mx my mm b">foo</code>属性的值。同样，我们可以对类做同样的事情，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="33ee" class="mq lf it mm b gy mr ms l mt mu">class Obj {<br/>  get foo() {<br/>    return this._foo;<br/>  }</span><span id="2720" class="mq lf it mm b gy mv ms l mt mu">  set foo(val) {<br/>    this._foo = val;<br/>  }<br/>}</span><span id="ef63" class="mq lf it mm b gy mv ms l mt mu">const obj = new Obj();<br/>obj.foo = 1;</span></pre><p id="aaf4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这与object示例的工作方式相同，只是我们必须先用<code class="fe mw mx my mm b">new</code>实例化它。</p><h1 id="2c3d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="4c5f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不应该用像<code class="fe mw mx my mm b">+=</code>这样的操作进行赋值，用<code class="fe mw mx my mm b">await</code>或<code class="fe mw mx my mm b">yield</code>作为右操作数，因为值将被覆盖，而不是与现有值组合。</p><p id="ead3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们应该使用<code class="fe mw mx my mm b">isNaN</code>来检查<code class="fe mw mx my mm b">NaN</code>而不是使用<code class="fe mw mx my mm b">===</code>或<code class="fe mw mx my mm b">==</code>操作员来检查。</p><p id="e60e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当使用<code class="fe mw mx my mm b">typeof</code>时，我们应该检查字符串中的错别字。</p><p id="d401" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有getters的Setters也不是很有用，因为我们不能得到我们设置的值。</p></div></div>    
</body>
</html>