<html>
<head>
<title>Dependency Injection in Dart/Flutter Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dart/Flutter应用中的依赖注入</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dependency-injection-in-dart-flutter-apps-3332f1a61041?source=collection_archive---------3-----------------------#2020-02-25">https://levelup.gitconnected.com/dependency-injection-in-dart-flutter-apps-3332f1a61041?source=collection_archive---------3-----------------------#2020-02-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/414209347cc7ddd7dd023bfdb51673e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JjfByJtt_WLPLutX"/></div></div></figure><p id="6012" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">依赖注入是一种使一个对象的依赖关系通过另一个对象可用的方法，这些依赖关系通常被称为服务。</p><p id="8923" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些服务可以是包含不同功能的代码块，可以在项目的不同部分轻松重用。</p><p id="036e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">依赖项是部分项目成功运行所需的功能。在许多情况下，您会导入文件并在其中使用类或方法，这样使用这些导入的类就依赖于它们。</p><p id="8681" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在dart中，处理依赖注入的最基本方法是通过构造函数将服务传递给类。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="67dc" class="lf lg iq lb b gy lh li l lj lk">class MyClass {<br/><br/>//MyClass is dependent on OtherClass<br/>OtherClass service;<br/><br/>  MyClass(this.service)<br/>}</span></pre><p id="3989" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法初看起来可能并不坏(没什么问题)，但是在小部件树的深处传递值就很成问题了，而且在处理许多依赖项时，事情会变得很混乱。</p><h1 id="c39f" class="ll lg iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">颤振的依赖注入选择</h1><p id="1e94" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">我们可以在flutter应用中使用许多DI方法和包，我们将在本帖中了解一些:</p><ul class=""><li id="0711" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated">继承的小部件—开箱即用。</li><li id="ca41" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">IOC dart包——一个易于使用的包<a class="ae nb" href="https://pub.dev/packages/ioc#-readme-tab-" rel="noopener ugc nofollow" target="_blank">可从发布网站</a>获得</li><li id="0bfa" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">获取它飞镖包—可以在pub.dev上的<a class="ae nb" href="https://pub.dev/packages/get_it" rel="noopener ugc nofollow" target="_blank">这里</a>找到</li></ul><blockquote class="nc nd ne"><p id="2063" class="jy jz nf ka b kb kc kd ke kf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku kv ij bi translated"><em class="iq">在本文中，示例将会很简单，目的是作为对DI的介绍。我将撰写其他详细的文章，展示如何在真实的应用程序中使用这些概念。</em></p></blockquote><h1 id="99fd" class="ll lg iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">继承的小部件</h1><p id="0844" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">继承的小部件允许您轻松地沿着小部件树传递数据。显示了一个继承的小部件的示例:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="8004" class="lf lg iq lb b gy lh li l lj lk">import 'package:flutter/material.dart';<br/><br/>class InheritedHomeWidget extends InheritedWidget {<br/>  InheritedHomeWidget({Key key, this.child}) : super(key: key, child: child);<br/><br/>  final Widget child;<br/><br/>  static InheritedHomeWidget of(BuildContext context) {<br/>    return (context.inheritFromWidgetOfExactType(InheritedHomeWidget)<br/>        as InheritedHomeWidget);<br/>  }<br/><br/>  @override<br/>  bool updateShouldNotify(InheritedHomeWidget oldWidget) {<br/>    return true;<br/>  }<br/>}</span></pre><p id="9092" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个自动生成的继承自flutter VS代码扩展的小部件，让我们看看代码包含了什么。</p><ul class=""><li id="5cb0" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated">传入一个名为child(可以取任何名字)的部件，这是放置子部件树的地方。</li><li id="2b23" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">下一个代码块查找小部件树，找到最接近的<code class="fe nj nk nl lb b">InheritedWidget</code>，并向该小部件注册BuildContext，以便当小部件发生任何变化时，它可以重建树。</li><li id="0718" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated"><code class="fe nj nk nl lb b">updateShouldNotify()</code>返回一个boolean值，该值表明当InheritedWidget发生更改时，是否应重新构建子树小工具。</li></ul><h2 id="c8e1" class="lf lg iq bd lm nm nn dn lq no np dp lu kj nq nr ly kn ns nt mc kr nu nv mg nw bi translated">在小部件中使用</h2><p id="3a21" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">为了使你的依赖关系在这个窗口小部件树中可用，你可以通过继承的窗口小部件的构造函数来发送依赖关系，或者使用一个getter，或者任何适合你的用例的方式，你仍然可以在树的深处使用它。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="7c36" class="lf lg iq lb b gy lh li l lj lk">InheritedHomeWidget({Key key, this.child, this.homeText})<br/>      : super(key: key, child: child);<br/><br/>final Widget child;<br/>//add the new dependency<br/>final String homeText;</span></pre><p id="325e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您希望您的依赖关系沿着整个树向下传播，那么用您创建的继承的小部件来包装您的整个小部件树。在这种情况下，我将简单地向构造函数传递一个文本，这可能是一个服务的实例。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="5258" class="lf lg iq lb b gy lh li l lj lk">class FunApp extends StatelessWidget {<br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return InheritedHomeWidget(<br/>      homeText: 'This is printed on the screen',<br/>      child: MaterialApp(<br/>        title: 'Inherited Widget',<br/>        home: FunHomePage(),<br/>      ),<br/>    );<br/>  }<br/>}</span></pre><p id="6c14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，您可以通过在继承的小部件上调用<code class="fe nj nk nl lb b">.of(context)</code>来使用该文本，如下所示:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="044a" class="lf lg iq lb b gy lh li l lj lk">class FunHomePage extends StatelessWidget {<br/>  const FunHomePage({Key key}) : super(key: key);<br/><br/>  @override<br/>  Widget build(BuildContext context) {<br/>    var homeText = InheritedHomeWidget.of(context).homeText;<br/>    return Container(<br/>      color: Colors.white,<br/>      child: Center(<br/>        child: Text(homeText),<br/>      ),<br/>    );<br/>  }<br/>}</span></pre><h1 id="4a85" class="ll lg iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">国际奥委会套餐</h1><p id="4534" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">IOC代表控制反转，它是一种模式，表明服务/依赖关系应该在一个单独的类中创建，并且是依赖关系注入背后的基本原则。</p><p id="23db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae nb" href="https://pub.dev/packages/ioc#-readme-tab-" rel="noopener ugc nofollow" target="_blank">这个包</a>非常容易使用，它允许你将你的服务初始化为一个<a class="ae nb" href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="noopener ugc nofollow" target="_blank"> singleton </a>并且你可以将你的依赖绑定到任何你选择的数据类型。</p><p id="140a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要使用这个包，首先需要将它添加到pubspec.yaml文件中，如下所示:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="acd1" class="lf lg iq lb b gy lh li l lj lk">dependencies:<br/>  ioc: ^0.3.0</span></pre><p id="37e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，创建一个dart文件来绑定您的所有服务。我叫我的<code class="fe nj nk nl lb b">ioc_locator.dart</code>，你想怎么叫都行。这个文件的内容是:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="420c" class="lf lg iq lb b gy lh li l lj lk">import 'package:ioc/ioc.dart';<br/><br/>void iocLocator() {<br/>  Ioc().bind('service1', (ioc) =&gt; InfoService());<br/>}<!-- --> </span></pre><ul class=""><li id="90f2" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated">在这里，我将类(service) <code class="fe nj nk nl lb b">InfoService</code>绑定到一个字符串“service1 ”,它的作用有点像一个键，并且是动态的。<code class="fe nj nk nl lb b">Ioc().bind(key, (ioc) =&gt; Service());</code></li><li id="aa40" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated"><code class="fe nj nk nl lb b">InfoService</code>是另一个非常简单的类，其中只有一个名为<strong class="ka ir"> infoText </strong>的字符串。</li></ul><p id="70e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您希望在应用程序运行之前运行主文件中的<code class="fe nj nk nl lb b">iocLocator()</code>函数，因此导入它并将其添加到您的<code class="fe nj nk nl lb b">runApp()</code>函数之上，如下所示:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="8f56" class="lf lg iq lb b gy lh li l lj lk">void main() {<br/>  iocLocator();<br/>  runApp(MyApp());<br/>}</span></pre><p id="a965" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，您可以在小部件和文件中使用来自该服务的数据，我将尝试打印出infoText的值。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="ce23" class="lf lg iq lb b gy lh li l lj lk">import 'package:flutter/material.dart';<br/>import 'package:ioc/ioc.dart';<br/><br/>class IocView extends StatelessWidget {<br/>  final infoService = Ioc().use('service1');<br/><br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return Scaffold(<br/>      body: Center(<br/>        child: Text(infoService.infoText),<br/>      ),<br/>    );<br/>  }<br/>}</span></pre><p id="e2b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要查看IoC包的其他酷功能，请查看他们的<a class="ae nb" href="https://pub.dev/packages/ioc#-readme-tab-" rel="noopener ugc nofollow" target="_blank">发布与开发页面</a>。</p><h1 id="aae1" class="ll lg iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">得到它</h1><p id="b103" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated"><a class="ae nb" href="https://pub.dev/packages/get_it" rel="noopener ugc nofollow" target="_blank"> Get it </a>是在flutter应用中处理DI比较流行的方法之一。您还可以将您的依赖项注册为单例、惰性单例或工厂。</p><ul class=""><li id="bb0e" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated">单例将总是返回该服务的同一个实例。</li><li id="3d61" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">惰性单例将在第一个实例被调用时创建对象。当您有一个需要时间才能启动的服务，并且应该只在需要时才启动时，这很有用。</li><li id="f0bc" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">工厂将在任何时候调用服务时返回服务的新实例。</li></ul><h2 id="a536" class="lf lg iq bd lm nm nn dn lq no np dp lu kj nq nr ly kn ns nt mc kr nu nv mg nw bi translated">使用</h2><p id="141d" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">首先，将get_it添加到您的pubspec.yaml文件中:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="695c" class="lf lg iq lb b gy lh li l lj lk">get_it: ^3.1.0</span></pre><p id="f1b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您可以创建一个文件来注册您的所有对象，我将调用我的service_locator.dart，并在其中放置一个名为<code class="fe nj nk nl lb b">getServices()</code>的函数。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="8419" class="lf lg iq lb b gy lh li l lj lk">import 'package:get_it/get_it.dart';<br/><br/>GetIt getIt = GetIt.instance;<br/><br/>void getServices() {<br/>  getIt.registerFactory(() =&gt; InfoService());<br/>  getIt.registerSingleton(() =&gt; MyService());<br/>  getIt.registerLazySingleton(() =&gt; OtherService());<br/>}</span></pre><p id="1bf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从版本2.0.0开始，get_it被改造成了一个singleton，你现在可以用<code class="fe nj nk nl lb b">GetIt.instance</code>或<code class="fe nj nk nl lb b">GetIt.I</code>得到相同的get_it实例。</p><p id="d579" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在运行应用程序之前，将<code class="fe nj nk nl lb b">getServices()</code>函数放在main.dart文件中:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="1e21" class="lf lg iq lb b gy lh li l lj lk">void main() {<br/>  setupLocator();<br/>  runApp(MyApp());<br/>}</span></pre><p id="f813" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要在小部件中使用注册的对象，只需调用<code class="fe nj nk nl lb b">locator.get&lt;Type&gt;()</code>或<code class="fe nj nk nl lb b">locator&lt;Type&gt;()</code>，这里的类型，在我们的例子中，是InfoService。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="85d1" class="lf lg iq lb b gy lh li l lj lk">class InfoView extends StatelessWidget {<br/>  final infoService = getIt.get&lt;InfoService&gt;();<br/><br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return Scaffold(<br/>      body: Center(<br/>        child: Text(infoService.infoText),<br/>      ),<br/>    );<br/>  }<br/>}</span></pre><h1 id="84ba" class="ll lg iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">为什么我应该使用依赖注入？</h1><ul class=""><li id="4d1e" class="mn mo iq ka b kb mi kf mj kj nx kn ny kr nz kv ms mt mu mv bi translated">DI有助于更好的开发体验。</li><li id="9cf2" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">给你的项目增加一点结构。</li><li id="4753" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">非常适合在编写测试时模仿对象。</li></ul><p id="e586" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文到此为止！你可以通过<a class="ae nb" href="https://twitter.com/txe_bert" rel="noopener ugc nofollow" target="_blank">推特</a>联系我，查看我的其他文章。</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="65a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nf">原载于</em><a class="ae nb" href="https://berthacks.com/dependency-injection-in-dartflutter-apps-ck71x93uu06fqd9s1zuosczgn" rel="noopener ugc nofollow" target="_blank"><em class="nf"/></a><em class="nf">。</em></p></div></div>    
</body>
</html>