<html>
<head>
<title>Create your first game using Canvas API and Javascript: Plane Attack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Canvas API和Javascript创建你的第一个游戏:平面攻击</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/plane-attack-create-your-first-simple-game-using-canvas-api-and-javascript-96eafe7801e2?source=collection_archive---------9-----------------------#2020-02-10">https://levelup.gitconnected.com/plane-attack-create-your-first-simple-game-using-canvas-api-and-javascript-96eafe7801e2?source=collection_archive---------9-----------------------#2020-02-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f115" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">目前，我们都习惯于看到令人惊讶的游戏与惊人的图形，但是，你有没有玩过那些古老的2D简单的游戏，你必须通过不同的水平？你有没有想过自己造一个类似的东西？如果是这样的话，敬请关注，继续阅读！👀</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/5fff12949ae1114a1712f0d5837d52b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kSC-tFe6OlxWDVCd3UuyiA.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">高质量的飞机图像</figcaption></figure><p id="29b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个想法并不是要创造一个复杂的游戏，而是提供一个建立简单游戏所需步骤的例子，同时解释这个过程中涉及的主要概念。</p><p id="d12f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，我们将使用<strong class="js iu"> HTML 5 </strong>(使用<strong class="js iu"> Canvas API </strong>)、<strong class="js iu"> Javascript </strong>，几乎不用CSS。为了简单起见，我们将在一个JavaScript文件中实现全部功能，并直接在浏览器中执行</p><blockquote class="le lf lg"><p id="57e0" class="jq jr lh js b jt ju jv jw jx jy jz ka li kc kd ke lj kg kh ki lk kk kl km kn im bi translated">例如，如果我们想要ES5的结果，我们可以使用一些捆绑工具，比如<a class="ae ll" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>、<a class="ae ll" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>、<a class="ae ll" href="https://parceljs.org/" rel="noopener ugc nofollow" target="_blank">package</a>等等。此外，<strong class="js iu">如果我们创造一个更复杂的游戏</strong>，这也是一个好主意<strong class="js iu">为我们的游戏建模并把它分成不同的模块</strong></p></blockquote><p id="1fa5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在给定的时间内，你能抓到多少只鸟？😎</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/372f2b481a1105eb235afacae81e4034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/1*DC1wNiSCDLcmbwO3-jppjQ.gif"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">飞机攻击画布游戏</figcaption></figure><h1 id="0e6a" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">HTML结构</h1><p id="d197" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">HTML非常简单。创建一个<strong class="js iu"><em class="lh">planeAttack.html</em></strong>文件如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">HTML游戏代码</figcaption></figure><p id="3e63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们基本上需要三个元素:一个用于显示分数(最佳分数和当前分数)，一个用于附加canva，s的元素，最后一个用于计时器。</p><blockquote class="le lf lg"><p id="f38d" class="jq jr lh js b jt ju jv jw jx jy jz ka li kc kd ke lj kg kh ki lk kk kl km kn im bi translated">我们还链接了样式文件<strong class="js iu"> planeAttack.css </strong>,在那里我们基本上只是将游戏居中并格式化分数和计时器信息</p></blockquote><p id="d10e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦我们的UI完成，我们创建一个包含所有所需逻辑的<strong class="js iu"><em class="lh">plane attack . js</em></strong>文件。</p><h1 id="52cf" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">初始化主要元素</h1><p id="d228" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">首先，通过<code class="fe ms mt mu mv b"><a class="ae ll" href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onload" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">onload</strong></a></code>窗口事件，我们初始化主要元素:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">第一步。初始化元素</figcaption></figure><p id="3b21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有两件主要的事情:初始化分数和计时器值，创建画布并将其添加到我们的board容器中。</p><blockquote class="le lf lg"><p id="f9a3" class="jq jr lh js b jt ju jv jw jx jy jz ka li kc kd ke lj kg kh ki lk kk kl km kn im bi translated">您也可以使用<strong class="js iu">&lt;canvas&gt;</strong><em class="it"/>标签将画布直接定义到html中</p></blockquote><p id="3ab8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">HTML<strong class="js iu"/><a class="ae ll" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">Canvas</strong></a>元素提供了一个将图形绘制到web中的API，但只是充当一个容器，所以您需要javascript来实际绘制图形。它有一个相当不错的浏览器<a class="ae ll" href="https://caniuse.com/#feat=canvas" rel="noopener ugc nofollow" target="_blank"> <em class="lh">支持</em> </a></p><p id="c673" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的例子中，我们创建了一个二维画布，设置宽度和高度。</p><blockquote class="le lf lg"><p id="c304" class="jq jr lh js b jt ju jv jw jx jy jz ka li kc kd ke lj kg kh ki lk kk kl km kn im bi translated"><code class="fe ms mt mu mv b"><a class="ae ll" href="https://developer.mozilla.org/es/docs/Web/API/HTMLCanvasElement/getContext" rel="noopener ugc nofollow" target="_blank"><strong class="js iu"><em class="it">getContext</em></strong></a></code>方法给了我们在画布上绘图的上下文。它还通过实验性的<a class="ae ll" href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API" rel="noopener ugc nofollow" target="_blank"> <em class="it"> WebGL </em> </a>实现支持三维渲染上下文</p></blockquote><blockquote class="mw"><p id="7c68" class="mx my it bd mz na nb nc nd ne nf kn dk translated">从现在开始，所有的定位参考都将以像素表示，而像素/秒则以速度表示</p></blockquote><h1 id="0425" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly ng ma mb mc nh me mf mg ni mi mj mk bi translated">计算第一个位置</h1><p id="8703" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">计算飞机和鸟的第一个位置将是下一步。为此，我们将创建两个具有所需属性的对象:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">飞机和鸟的物体。计算第一个位置</figcaption></figure><p id="0d12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">飞机和鸟的物体被建模成一幅图像所描绘的几何形状(分别是正方形<strong class="js iu"> <em class="lh"> 80x80 </em> </strong>和长方形<strong class="js iu"> <em class="lh"> 60x32 </em> </strong>)，所以它们基本上有相同的属性:<code class="fe ms mt mu mv b"><strong class="js iu">width</strong></code>、<code class="fe ms mt mu mv b"><strong class="js iu">height</strong></code>、<strong class="js iu">、</strong>和<code class="fe ms mt mu mv b"><strong class="js iu">image</strong></code></p><blockquote class="le lf lg"><p id="7622" class="jq jr lh js b jt ju jv jw jx jy jz ka li kc kd ke lj kg kh ki lk kk kl km kn im bi translated"><em class="it">平面对象还包含一个额外的</em> <code class="fe ms mt mu mv b"><strong class="js iu">speed</strong></code> <em class="it">属性，因为它是我们要控制的对象，因此，我们需要计算每个时间间隔所走过的距离</em></p></blockquote><p id="1ce8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个鸟的位置(<em class="lh">和被平面</em>击中后的后续位置)将是随机的，平面一一开始就在我们画布上下文的中间。</p><blockquote class="mw"><p id="84c5" class="mx my it bd mz na nj nk nl nm nn kn dk translated">请记住，我们还没有在画布上绘制任何东西。我们只是计算两个对象的第一个位置，以便在接下来的步骤中绘制它们</p></blockquote><h1 id="1d80" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly ng ma mb mc nh me mf mg ni mi mj mk bi translated">添加侦听器</h1><p id="5d07" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">我们将用箭头键控制飞机，所以我们需要添加合适的监听器:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">箭头键监听器</figcaption></figure><p id="8884" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个<code class="fe ms mt mu mv b"><strong class="js iu">keyActions</strong></code> <strong class="js iu"> <em class="lh"> </em> </strong>对象将在整个游戏过程中跟踪所有被按下的键，帮助我们稍后绘制平面运动。</p><p id="c0c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">按下的第一个箭头键将触发游戏，所以我们使用<code class="fe ms mt mu mv b"><strong class="js iu">firstMove</strong></code> <strong class="js iu"> <em class="lh"> </em> </strong>变量来定位它，并设置计时器来帮助我们控制游戏的持续时间。</p><h1 id="88a8" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">游戏计时器</h1><p id="f780" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">为此，我们将定义1秒(<em class="lh">1000毫秒</em>)的时间间隔:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">控制游戏持续时间的间隔</figcaption></figure><p id="3d07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每次执行<code class="fe ms mt mu mv b"><strong class="js iu">clock</strong></code>间隔时，我们都会减少<code class="fe ms mt mu mv b"><strong class="js iu">interval</strong></code> <strong class="js iu"> <em class="lh"> </em> </strong>变量，让我们控制游戏持续时间。一旦游戏在10秒后结束，我们重置间隔和所有变量，重新计算新游戏的初始位置。</p><blockquote class="le lf lg"><p id="b887" class="jq jr lh js b jt ju jv jw jx jy jz ka li kc kd ke lj kg kh ki lk kk kl km kn im bi translated">用<code class="fe ms mt mu mv b"><strong class="js iu">clearInterval(clock)</strong></code>重置时钟和所有的变量迫使停止当前的游戏，并为新的游戏做好准备，我们将再次听到第一个箭头键被按下</p></blockquote><blockquote class="mw"><p id="7c5f" class="mx my it bd mz na nb nc nd ne nf kn dk translated">到目前为止一切正常，但是，我们如何将元素绘制到画布上呢？这个游戏实际上是如何运作的？</p></blockquote><p id="4d0c" class="pw-post-body-paragraph jq jr it js b jt no jv jw jx np jz ka kb nq kd ke kf nr kh ki kj ns kl km kn im bi translated">我们已经在上面定义了设置游戏基础所需的主要步骤，但是我们缺少定义控制游戏执行所需的所有任务的<strong class="js iu"><em class="lh"/></strong><a class="ae ll" href="https://www.gamecareerguide.com/features/529/what_is_a_game.php" rel="noopener ugc nofollow" target="_blank"><strong class="js iu"><em class="lh">游戏引擎</em></strong></a><strong class="js iu"><em class="lh"/></strong>或<strong class="js iu"><em class="lh">【main】</em></strong>程序。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/457bfa5c026e8b24e05435a533b50c11.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*WTfk8Q4KwLrmGcrmJawMPg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">游戏流程图</figcaption></figure><h1 id="35c7" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">主要的</h1><p id="a3a7" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated"><code class="fe ms mt mu mv b"><strong class="js iu">main</strong></code>函数将包含执行逻辑:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">游戏引擎。主程序</figcaption></figure><p id="2086" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如刚才解释的，基于更新之间的<code class="fe ms mt mu mv b"><strong class="js iu">elapsed</strong></code>时间(以秒为单位的<em class="lh"/>)我们更新鸟和飞机的位置，将它们绘制到画布中，刷新分数并更新上次执行时间。</p><p id="5d65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是我们需要不断地检查这个逻辑来运行这个游戏，我们该怎么做呢？在初始步骤之后设置定时器，该定时器将周期性地执行主逻辑。</p><pre class="kp kq kr ks gt nu mv nv nw aw nx bi"><span id="a80b" class="ny lo it mv b gy nz oa l ob oc">// Calculate positions<br/>calculateFirstPositions()</span><span id="de8b" class="ny lo it mv b gy od oa l ob oc">// Add key event listeners<br/>addEventListeners()</span><span id="b24d" class="ny lo it mv b gy od oa l ob oc">// Execute main program every 16 ms<br/><strong class="mv iu">setInterval(main, 16)</strong></span></pre><blockquote class="mw"><p id="546c" class="mx my it bd mz na nb nc nd ne nf kn dk translated">为什么要每16毫秒设置一次呢？</p></blockquote><p id="36ec" class="pw-post-body-paragraph jq jr it js b jt no jv jw jx np jz ka kb nq kd ke kf nr kh ki kj ns kl km kn im bi translated">间隔功能会模拟游戏的<a class="ae ll" href="https://www.techsmith.com/blog/frame-rate-beginners-guide/" rel="noopener ugc nofollow" target="_blank"><strong class="js iu"/></a><strong class="js iu"><em class="lh">(每秒帧数)</em> </strong>。我们越频繁地执行该逻辑(<em class="lh">，因此位置更新越多</em>，我们在游戏中体验到的性能和流畅行为就越好(<em class="lh">，对CPU的要求也越高</em>)。在那种情况下我们渲染<strong class="js iu">60 fps</strong><strong class="js iu"><em class="lh">(1000毫秒/60fps ~ 16毫秒)</em> </strong>对人眼来说足够好的速率。</p><blockquote class="le lf lg"><p id="bb8b" class="jq jr lh js b jt ju jv jw jx jy jz ka li kc kd ke lj kg kh ki lk kk kl km kn im bi translated">更高的时间值会产生我们在玩游戏时都讨厌的“滞后”效果。将间隔改为<strong class="js iu">33毫秒(30fps) </strong> <em class="it"> </em>，您会注意到不同之处</p></blockquote><h2 id="71fe" class="ny lo it bd lp oe of dn lt og oh dp lx kb oi oj mb kf ok ol mf kj om on mj oo bi translated">1.更新元素</h2><p id="ae77" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">我们将创建一个函数<code class="fe ms mt mu mv b"><strong class="js iu">updateElements</strong></code>,接受经过的时间作为参数:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">更新职位逻辑</figcaption></figure><p id="4ceb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先我们需要的是被覆盖的平面<code class="fe ms mt mu mv b"><strong class="js iu">distance</strong></code> <strong class="js iu"> <em class="lh">，</em> </strong>所以我们得到它乘以平面速度<em class="lh">(定义为</em> <strong class="js iu"> <em class="lh"> 400像素/秒</em> </strong> <em class="lh">)在平面对象中</em></p><p id="0e8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">飞机将越过画布的边界，穿过所有的边，从对面出来，所以我们用最大的平面尺寸和边界来计算<code class="fe ms mt mu mv b"><strong class="js iu">planeLimit</strong></code>、<code class="fe ms mt mu mv b"><strong class="js iu">heighLimit</strong></code>和<code class="fe ms mt mu mv b"><strong class="js iu">widthLimit</strong></code>变量，直到它实际穿过边界，一直可见。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi op"><img src="../Images/bc30fdc026785ffc446e2da853b798aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8sD92ARNTmr0nDdgPEFbDQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">帆布结构</figcaption></figure><p id="30e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">逻辑总是遵循相同的模式:如果平面在画布范围内，我们总是用新的<code class="fe ms mt mu mv b"><strong class="js iu">distance</strong></code>值更新它的位置，但是如果它穿过任何边界，我们就根据边来更新位置。</p><pre class="kp kq kr ks gt nu mv nv nw aw nx bi"><span id="e14c" class="ny lo it mv b gy nz oa l ob oc">// UP key. Crossing top limit<br/>if (keyActions.hasOwnProperty(UP)) {<br/>(planeObj.y &gt; -planeLimit) <br/>    ? planeObj.y -= distance <br/>    : planeObj.y = heightLimit<br/>}</span></pre><p id="d8a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，如果向上的平面仍然可见(<em class="lh">至少10个像素</em>)，我们基于新的距离值更新位置，如果不可见，我们将其放置在底部画布限制(<em class="lh">少10个像素，所以它已经可见)</em></p><blockquote class="le lf lg"><p id="b059" class="jq jr lh js b jt ju jv jw jx jy jz ka li kc kd ke lj kg kh ki lk kk kl km kn im bi translated">我们使用独立的if语句<strong class="js iu"> </strong>作为<strong class="js iu"> </strong>我们不希望平面只在4个方向上移动，所以同时按下向上和向右键将沿对角线移动平面(与向上和向下相同，将保持平面在画布上静止)</p></blockquote><p id="a4e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，当平面物体到达鸟中间时，我们检测到碰撞，更新一个点的当前分数，并计算鸟的新位置</p><blockquote class="le lf lg"><p id="97b5" class="jq jr lh js b jt ju jv jw jx jy jz ka li kc kd ke lj kg kh ki lk kk kl km kn im bi translated">执行<code class="fe ms mt mu mv b"><strong class="js iu">calculateFirstPositions</strong></code>只会为小鸟生成一个新的位置，因为平面一是在游戏开始时计算和更新的</p></blockquote><h2 id="1803" class="ny lo it bd lp oe of dn lt og oh dp lx kb oi oj mb kf ok ol mf kj om on mj oo bi translated">2.绘画元素</h2><p id="a965" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">更新完元素后，我们终于可以将它们绘制到画布上了:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">将元素绘制到画布中</figcaption></figure><p id="02b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每次执行<code class="fe ms mt mu mv b"><strong class="js iu">paintElements</strong></code>方法时，我们总是画出飞机和鸟的位置。为此，我们使用Canvas 2D API提供的<code class="fe ms mt mu mv b"><a class="ae ll" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">drawImage</strong></a></code>方法。</p><blockquote class="mw"><p id="f4b2" class="mx my it bd mz na nj nk nl nm nn kn dk translated">但是如果你只有一张纸，并且每5秒钟就在不同的位置画一张新的画，那该怎么办呢？一段时间后，你可能会用尽空间，产生一个大的draw mark</p></blockquote><figure class="or os ot ou ov kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oq"><img src="../Images/2ea754e9d5aeaacda87ea78938e8b9e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9iR9rGiwVt4R-ZGBldOrsQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">未正确刷新时的示例</figcaption></figure><p id="eddb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">帆布也一样。如果我们只是在每个主循环中画一个新的平面位置，我们会在整个画布上留下大量的平面标记，而这并不是游戏的目的。我们想要绘制一个新的平面位置，但是删除了之前的位置，这样就一直只有一个平面图。</p><p id="bcec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是<code class="fe ms mt mu mv b"><strong class="js iu">backgroundObj</strong></code>发挥作用的地方。</p><p id="2ec9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在游戏开始时，我们只需在画布上的初始位置绘制背景图像:</p><pre class="kp kq kr ks gt nu mv nv nw aw nx bi"><span id="6c3d" class="ny lo it mv b gy nz oa l ob oc">// Position (0, 0) (x, y)<br/>ctx.drawImage(backgroundObj.image, 0, 0, backgroundObj.image.width, backgroundObj.image.height)</span></pre><p id="38bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦游戏开始，我们将有一个动态背景图像以<strong class="js iu"><em class="lh"><code class="fe ms mt mu mv b"><strong class="js iu">backgroundObj.speed</strong></code>每秒100像素的速度不断向左移动，</em> </strong>帮助我们刷新平面位置，如下所示:</p><ul class=""><li id="3f3c" class="ow ox it js b jt ju jx jy kb oy kf oz kj pa kn pb pc pd pe bi translated">基于从开始起<em class="lh">经过的时间</em>、背景速度<em class="lh">和带有</em>的<em class="lh">我们计算出背景在每个循环中将向左移动多少<code class="fe ms mt mu mv b"><strong class="js iu">xpos</strong></code>个像素</em></li><li id="eae6" class="ow ox it js b jt pf jx pg kb ph kf pi kj pj kn pb pc pd pe bi translated">我们<code class="fe ms mt mu mv b"><a class="ae ll" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/save" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">save</strong></a></code>画布上下文，所以当前的绘图状态(<em class="lh">和第一个初始位置</em>)在任何改变之前被保存</li><li id="3e3b" class="ow ox it js b jt pf jx pg kb ph kf pi kj pj kn pb pc pd pe bi translated">我们基于<code class="fe ms mt mu mv b">xpos</code>将画布<code class="fe ms mt mu mv b"><a class="ae ll" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/translate" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">translate</strong></a></code>放在左边</li><li id="9c24" class="ow ox it js b jt pf jx pg kb ph kf pi kj pj kn pb pc pd pe bi translated">我们基于<code class="fe ms mt mu mv b"><strong class="js iu">numImages</strong></code> ( <em class="lh">删除最后一个平面位置</em>)在新翻译的画布上绘制一些新的背景图像</li></ul><blockquote class="mw"><p id="9c05" class="mx my it bd mz na nb nc nd ne nf kn dk translated">但是为什么我们需要一个for循环来绘制不止一个背景图像呢？</p></blockquote><figure class="or os ot ou ov kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pk"><img src="../Images/3cb470f214e51dbf82e4510bd5f15b12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7QWzTnBXKATjzw1-ukrG0Q.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">翻译了背景图像的画布</figcaption></figure><p id="2838" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们想要无限的背景效果，所以在将第一个背景图像画在翻译过的画布上之后，我们用一个新的图像填充它的剩余部分。</p><blockquote class="le lf lg"><p id="884f" class="jq jr lh js b jt ju jv jw jx jy jz ka li kc kd ke lj kg kh ki lk kk kl km kn im bi translated">根据其计算，<code class="fe ms mt mu mv b">xpos</code>变量将具有画布宽度的最大值(之后从初始位置0重新开始)，因此两幅图像足以完成背景过渡</p></blockquote><ul class=""><li id="b895" class="ow ox it js b jt ju jx jy kb oy kf oz kj pa kn pb pc pd pe bi translated">最后，我们<code class="fe ms mt mu mv b"><a class="ae ll" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/restore" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">restore</strong></a></code>画布上下文，这样我们将再次拥有相同的初始状态，因此，每次我们翻译和修改画布时都有相同的位置参考</li></ul><p id="f040" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在所有这些过程之后，画布上有了新的背景图像，我们重新绘制新的飞机和鸟的位置。</p><blockquote class="mw"><p id="df05" class="mx my it bd mz na nj nk nl nm nn kn dk translated">这就是我们开始玩游戏所需要的一切！</p></blockquote><p id="6e07" class="pw-post-body-paragraph jq jr it js b jt no jv jw jx np jz ka kb nq kd ke kf nr kh ki kj ns kl km kn im bi translated">接下来需要改进的地方？增加鸟的动作，有几个不同的挑战水平，包括一些障碍迫使飞机避开它们，不要坠毁等等。</p><p id="7936" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以在这里查看项目<a class="ae ll" href="https://github.com/adrigardi90/plane-attack" rel="noopener ugc nofollow" target="_blank"><strong class="js iu"/></a></p><p id="fb71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我已经用GitHub页面托管了游戏，所以你也可以直接玩<a class="ae ll" href="https://adrigardi90.github.io/plane-attack/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">这里</strong> </a></p><p id="9acb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">希望你喜欢它！</p></div></div>    
</body>
</html>