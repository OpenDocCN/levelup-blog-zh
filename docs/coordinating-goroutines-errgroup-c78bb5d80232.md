# 协调 goro routines-err group

> 原文：<https://levelup.gitconnected.com/coordinating-goroutines-errgroup-c78bb5d80232>

协调不同的路线以实现单一目标

![](img/708e782193bfaf426f91066e3760b00f.png)

由[亨特·哈里特](https://unsplash.com/@hharritt?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

在之前的一篇文章中，我谈到了我们如何使用上下文。上下文用于共享数据和分组不同 goroutines 的结构。这篇文章遗漏了一件事，那就是如何同步这一组事物。同步并发任务意味着要么等待所有任务完成后再做其他事情，要么取消所有任务以防出错。这就是`sync/errgroup`出现的地方。这是这个包的官方文件。包名传达了两件事:用于同步，我们将处理`errors`。这与上面提到的非常吻合，对吗？作为同步 goroutines 的机制，`errgroup`这个名字听起来可能有点奇怪，但是请原谅我，以后它会变得有意义。本质上，您将向该组注册 goroutines，并以某种方式等待它们完成。包内的主结构是`errgroup.Group`。

要创建一个新组，您可以调用`errgroup.WithContext`，它将接收一个`context.Context`作为参数，并返回一个指向新组和新上下文的指针。

您将在此结构中使用两种方法:

*   `(*errgroup.Group).Go` —向群组注册一个功能，并将其作为新的 goroutine 启动；
*   `(*errgroup.Group).Wait` —等待所有注册的 goroutine 完成或组中的任何 go routine 出现错误。这就是它使用`error`作为同步机制的原因。如果出现错误，上下文(由`errgroup.WithContext`返回的那个)被取消，并返回错误。这里需要注意的一点是，已经开始执行的 goroutine 将继续执行，因此将上下文传递给 goroutine 并检查它是否在 go routine 中被取消是很重要的(通常这是用`select`语句很容易实现的)；

这对于“分散和聚集”类型的问题非常有用。例如，当您收到一个请求时，您需要从不同的外部来源获取该请求的不同信息。为了提高性能，您可以在一个 goroutine 中从每个数据源获取数据。这将受益于并发性，并在等待外部资源响应的同时执行多项任务。这是一个获取用户电子邮件相关数据的小程序的例子。我们从名称服务获取用户名，从内部映射(模拟数据库或内存缓存)获取忠诚度积分。你可以在我的 [github](https://github.com/RicardoLinck/scatter-gather) 上查看完整的实现。不过，我会在相关部分添加一些片段，并解释发生了什么。

我将从`main`函数开始，然后我们将深入研究实际的获取功能。

第一步是确定如何存储从这些 goroutines 返回的数据。在本例中，我们将获取数据并将结果存储到一个[缓冲通道](/goroutines-and-channels-concurrent-programming-in-go-9f9f8495c34d)，这是一种非常常见的模式。为了让它工作，我们需要创建将要使用的上下文(当然，为了增加趣味，需要超时)、结果通道和实际的组。

PS:我也在一个 goroutine 中解雇了`nameservice.StartServer()`,只是因为我想让它成为一个外部服务，而且我也懒得做任何花哨的事情🤷‍♂.

我们还将配置我们想要使用的所有获取器，我已经为此创建了一个接口和一个助手装饰器，只是为了减少样板文件，并准确地关注我们想要获取什么以及如何获取。

现在我们可以使用`g.Go`运行每个提取器。它将注册我们的 fetchers 并在单独的 goroutines 中执行它们。

在触发我们的 fetchers 之后，我们现在等待它们完成，不管有没有错误。就处理结果(和错误)而言，我只是将它们打印到`stdout`。显然，在一个真实的应用程序中，你会想用它做些什么，但是对于这个测试，这就足够了。

这是 fetcher 接口和 helper 方法。

这个助手只是在一个 goroutine 中触发底层的 fetcher，并选择先发生的事情:

1.  所提供的上下文被取消(或者是由于组中的另一个 goroutine 返回错误，或者是由于我们设置的超时)；
2.  提取器实际上完成了任务，并在结果通道上发送了一些东西；
3.  或者取出器出错。

我使用了多种渠道，以便更容易了解发生了什么。`select`语句将等待，直到任何一个被使用的通道返回一些东西。一旦发生这种情况，它将继续前进。

重要的是要注意，如果底层提取器内部发生了错误，我们只记录它，而不会将该错误返回给组。这意味着当错误发生时，我们不会中止该组的其他 goroutines 的执行，我们只会忽略我们无法获得结果并继续前进。在各种情况下，有一些数据总比没有数据好。如果您想在出现任何错误时中止执行，只需在第 38 行返回错误。

这里是`NameFetcher`的样子:

这很简单。我们只向已配置的名称服务发出 HTTP 请求，并将响应反序列化为一个结构。这里唯一重要的事情是我们正在传递提供给实际 HTTP 请求的`context.Context`。这在上下文在请求中途被取消的情况下很有用，因为 HTTP 客户端会在没有任何额外代码的情况下正确地关闭它。

我所说的`PartnerFetcher`要简单得多。只是在地图上查找。有一个`time.Sleep`用来模拟通话时间。这很有用，因为我们可以在`main`中将上下文超时设置为少于一秒，并看到响应中不存在获取器的输出，以及超时错误。输出应该是这样的:

```
{name {ricardo linck}}
{loyalty_points 20}
```

例如，如果我们将超时设置为 500 毫秒，输出将如下所示:

```
{name {ricardo linck}}
2020/12/13 12:51:20 context deadline exceeded
exit status 1
```

请注意，由于在 goroutines 中事情是并发运行的，所以在实际结果打印之后，会出现错误的输出，即在 Fetcher 中打印出来的输出。

## 结束语

我们经常需要使用并发编程来提高应用程序的性能。这并不总是一项容易的任务。但是，我们需要更进一步，同步这些并发的事情。这可能更难。`sync/errgroup`包简化了这项任务。围绕您希望您的应用程序如何运行，您仍然需要做出相当多的设计决策。该软件包带来了很大的灵活性，并消除了一些必须手动完成的样板文件和复杂性。

有许多应用程序需要同步并发任务。我们关注的是分布式系统中常见的一种。其他例子可能包括启动多个长期服务，这些服务需要在收到信号或发生严重错误时正常关闭。并行做事通常也需要同步。这种技术在许多不同的场景中都很有用。