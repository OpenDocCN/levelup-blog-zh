<html>
<head>
<title>Python: Unfolding the power of fold</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python:展现折叠的力量</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-unfolding-the-power-of-fold-bdfbdf14e63?source=collection_archive---------1-----------------------#2022-07-20">https://levelup.gitconnected.com/python-unfolding-the-power-of-fold-bdfbdf14e63?source=collection_archive---------1-----------------------#2022-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/838f8d29f159abddf61eebfd49e37bde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nofPWq4MVoP8v4AFmLgpeQ.png"/></div></div></figure><div class=""/><div class=""><h2 id="f7ba" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">或者:如何花式循环</h2></div><p id="5132" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这一次我们将讨论循环以及如何以函数的方式使用它们。“我们为什么要这么做？”，你可能会问。因为我们可以。我们可以用一种非常奇特和灵活的方式做到这一点，只需使用函数和表达式，而不是重复命令语句。</p><p id="db98" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">随着深入挖掘，我们将逐渐揭开有史以来最具争议的功能之一。吉多·范·罗苏姆本人曾发帖称:“我一直最讨厌的人…”。所以，我的文章——17年后——试图把这句话变成类似“我非常欣赏的那句话……”。</p><p id="7251" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">注意:本文中给出的示例有意保持尽可能简单，并且可以在您的Python REPL中轻松执行。</p></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><p id="d163" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我假设您听说过内置的sum()函数:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="42fd" class="mc md jb ly b gy me mf l mg mh">&gt;&gt;&gt; sum([1, 2, 3, 4, 5])<br/>15</span></pre><p id="9209" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们如何编写自己的(简化的)sum版本呢？</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="6883" class="mc md jb ly b gy me mf l mg mh">def sum_(xs):<br/>    result = 0<br/>    for x in xs:<br/>        result += x<br/>    return result</span><span id="fbe4" class="mc md jb ly b gy mi mf l mg mh">&gt;&gt;&gt; sum_([1, 2, 3, 4, 5])<br/>15</span></pre><p id="91b2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">简单。如果我们需要product_()？</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="ebc8" class="mc md jb ly b gy me mf l mg mh">def product_(xs):<br/>    result = 1<br/>    for x in xs:<br/>        result *= x<br/>    return result</span><span id="732f" class="mc md jb ly b gy mi mf l mg mh">&gt;&gt;&gt; product_([1, 2, 3, 4, 5])<br/>120</span></pre><p id="4f60" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">简单。如果我们想编写一个函数，通过连接列表元素的单个字符串表示来创建一个字符串，会怎么样呢？</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="2201" class="mc md jb ly b gy me mf l mg mh">def concat_(xs):<br/>    result = ""<br/>    for x in xs:<br/>        result += str(x)<br/>    return result</span><span id="0903" class="mc md jb ly b gy mi mf l mg mh">&gt;&gt;&gt; concat_([1, 2, 3, 4, 5])<br/>'12345'</span></pre><p id="f271" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">简单。如果我们想把元组列表转换成字典呢？</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="cef1" class="mc md jb ly b gy me mf l mg mh">def dictify_(xs):<br/>    result = {}<br/>    for k, v in xs:<br/>        result.update({k: v})<br/>    return result</span><span id="2d37" class="mc md jb ly b gy mi mf l mg mh">&gt;&gt;&gt; dictify_([("A", 1), ("B", 2), ("C", 3)])<br/>{'A': 1, 'B': 2, 'C': 3}</span></pre><p id="7b51" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">简单。如果……会怎么样？简单。如果…简单…</p></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><p id="7099" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">尽管非常简单，但仔细看看我们的实现，我们会发现，我们一次又一次地产生了许多样板代码。模式是这样的:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="b7f7" class="mc md jb ly b gy me mf l mg mh">def some_looping_function(iterable):<br/>    result = some_initial_value<br/>    for item in iterable:<br/>       result = operation(result, item)<br/>    return result</span></pre><p id="5787" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们在编程初级班学过，要把常用的部分分解成一个函数，把可变的部分(一个初始值，一个运算，一个可迭代)作为参数传递，就是为了坚持干原理。让我们这样做:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="5f6e" class="mc md jb ly b gy me mf l mg mh">def fold(initial_value, operation, iterable):<br/>    result = initial_value<br/>    for item in iterable:<br/>        result = operation(result, item)<br/>    return result</span></pre><p id="93c2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这就是:自豪地介绍我们的超级函数，称为<strong class="ks jc"> fold() </strong>，作为编写循环的功能性的通用方法。</p><blockquote class="mj mk ml"><p id="3cc0" class="kq kr mm ks b kt ku kc kv kw kx kf ky mn la lb lc mo le lf lg mp li lj lk ll ij bi translated">备注:在纯函数世界中，fold() —像任何其他循环一样—将使用递归实现。但是，正如我们所知，Python和递归不是最好的朋友，所以我们在这里坚持使用命令式fold()实现。话虽如此，但在本文中您再也不会遇到任何for语句了:-)</p></blockquote><p id="b61c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">该函数有3个参数。初始值、一个运算和一个迭代。首先，让我们注意一下操作:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="b1d2" class="mc md jb ly b gy me mf l mg mh">result = operation(result, item)</span></pre><p id="ea96" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">该操作正好需要(！)2个参数，并通过以某种方式组合它们来产生一个结果，不多也不少。fold()对iterable中的每一项重复调用这个函数，总是将计算结果作为第一个参数传递给下一次迭代。这样，随着迭代的进行，结果会随着时间而“积累”。因为我们需要一些东西来开始，我们用初始值来预置累积状态。</p><blockquote class="mj mk ml"><p id="e927" class="kq kr mm ks b kt ku kc kv kw kx kf ky mn la lb lc mo le lf lg mp li lj lk ll ij bi translated">因为该操作通过组合两个参数返回单个值，所以它也被称为“reducer”函数。</p><p id="56db" class="kq kr mm ks b kt ku kc kv kw kx kf ky mn la lb lc mo le lf lg mp li lj lk ll ij bi translated">重要提示:reducer函数从不改变累积状态，它总是返回一个新的(！idspnonenote)状态。)版态！</p></blockquote><p id="b6b8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">让我们一步一步地想象sum_()函数的这个过程。该操作是一个简单的add()函数:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="e706" class="mc md jb ly b gy me mf l mg mh">def add(a, b):<br/>    return a + b</span><span id="4e56" class="mc md jb ly b gy mi mf l mg mh">&gt;&gt;&gt; result1 = add(0,       1) # = 0 + 1<br/>&gt;&gt;&gt; result2 = add(result1, 2) # = 1 + 2<br/>&gt;&gt;&gt; result3 = add(result2, 3) # = 3 + 3<br/>&gt;&gt;&gt; result4 = add(result3, 4) # = 6 + 4<br/>&gt;&gt;&gt; result5 = add(result4, 5) # = 10 + 5</span></pre><p id="7e91" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们最终会得到一些方程式。如果我们现在将结果代入它们的右边，我们得到以下表示:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="d3cc" class="mc md jb ly b gy me mf l mg mh">&gt;&gt;&gt; result5 = add(add(add(add(add(0, 1), 2), 3), 4), 5)<br/>&gt;&gt;&gt; result5<br/>15</span></pre><p id="5a90" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">或者，反过来，当用相应的“+”运算符替换add()时，我们得到以下等式:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="f8d1" class="mc md jb ly b gy me mf l mg mh">&gt;&gt;&gt; result5 = (((((0 + 1) + 2) + 3) + 4) + 5)<br/>&gt;&gt;&gt; result5<br/>15</span></pre><p id="bdab" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在很清楚了，fold()是一个左关联操作，也就是说，最终结果是从左边开始计算的(就像吃豆人从左到右吃怪物……)。这就是为什么fold()也被称为foldLeft(在Scala中)或foldl(在Haskell中)。</p><p id="afd0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这就是fold()的全部魔力。我们现在能够根据fold()将我们的函数重新定义为简单的一行程序:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="9a33" class="mc md jb ly b gy me mf l mg mh">def sum_(xs):<br/>    return fold(0, lambda acc, item: acc + item, xs)</span><span id="457c" class="mc md jb ly b gy mi mf l mg mh">def product(xs):<br/>    return fold(1, lambda acc, item: acc * item, xs)</span><span id="3ba6" class="mc md jb ly b gy mi mf l mg mh">def concat_(xs):<br/>    return fold("", lambda acc, item: acc + str(item), xs)</span><span id="6dc8" class="mc md jb ly b gy mi mf l mg mh">def dictify_(xs):<br/>    return fold({}, lambda acc, item: {**acc, item[0]: item[1]}, xs)</span></pre><p id="0681" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">除了lambdas，我们可以使用任何其他“可调用”对象，只要它的签名符合reducer函数的特征:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="b88e" class="mc md jb ly b gy me mf l mg mh">&gt;&gt;&gt; fold(0, add, [1, 2, 3, 4, 5])<br/>15</span></pre></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><p id="e4c0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">最后，让我们花点心思在初始元素上。这里，我们要回答两个问题:初始元素的类型是什么，初始元素的值是什么？</p><p id="5762" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">通常，初始元素的类型与reducer函数所期望的第一个参数的类型相同。类型注释有助于可视化以下内容:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="18d3" class="mc md jb ly b gy me mf l mg mh">from typing import Callable, Iterable, TypeVar</span><span id="0f9a" class="mc md jb ly b gy mi mf l mg mh">A = TypeVar("A")<br/>B = TypeVar("B")</span><span id="2138" class="mc md jb ly b gy mi mf l mg mh">def fold(<br/>         initial_value: B,<br/>         reducer: Callable[[B, A], B],<br/>         iterable: Iterable[A]<br/>) -&gt; B:<br/>    ...</span></pre><p id="4e89" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">初始元素的值取决于第一次调用reducer函数时预期返回的内容。对于算术运算，就归约函数的运算而言，初始元素通常等于“中性元素”(或单位元素)。</p><p id="3ab2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">例如，加法的中性元素是0，因为0 + x = x。乘法的中性元素是1，因为1 * x = x。对于字符串连接，它是空字符串("+ "a string" = "a string ")，而对于列表连接，它是空列表([] + [a，b，c] = [a，b，c])。你明白了。</p><p id="0714" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有时我们想从更复杂的东西开始:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="a33d" class="mc md jb ly b gy me mf l mg mh">def add_mapping(d, item):<br/>   return {**d, item.upper(): ord(item.upper())}</span><span id="dfea" class="mc md jb ly b gy mi mf l mg mh">&gt;&gt;&gt; fold({"@": 64}, add_mapping, ["A", "b", "C"])<br/>{'@': 64, 'A': 65, 'B': 66, 'C': 67}</span></pre><p id="61ec" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这个不可否认是人为设计的例子中，我们用一些值预设了初始字典。</p><p id="e05e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">下一个问题可能是:有没有这样的情况，我们不需要一个显式的初始值，只需要iterable的第一个元素作为初始值？这是一个有效的问题，答案是:是的，这基本上是我们心爱的<strong class="ks jc"> reduce() </strong>函数的原始想法，它只不过是fold()的一种特殊形式。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="3435" class="mc md jb ly b gy me mf l mg mh">from typing import Callable, TypeVar, Iterable</span><span id="f3b1" class="mc md jb ly b gy mi mf l mg mh">B = TypeVar("B")</span><span id="db33" class="mc md jb ly b gy mi mf l mg mh">def reduce_(reducer: Callable[[B, B], B], iterable: Iterable[B]):<br/>    it = iter(iterable)<br/>    result = next(it)<br/>    for item in it:<br/>        result = reducer(result, item)<br/>    return result</span><span id="b130" class="mc md jb ly b gy mi mf l mg mh">&gt;&gt;&gt; reduce_(add, [1, 2, 3, 4, 5])<br/>15</span></pre><p id="0eda" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">查看类型注释，我们注意到reduce()只处理一个类型b。例如，减少List[int]类型的iterable将总是产生一个int值。</p><p id="de97" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因此，计算总和(或乘积)完全可以在不显式传递中性元素的情况下进行，而从整数列表创建字符串在没有显式初始值的情况下无法进行:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="d868" class="mc md jb ly b gy me mf l mg mh">&gt;&gt;&gt; reduce_(lambda acc, item: acc + str(item), [1, 2, 3, 4, 5])<br/>...<br/>TypeError: unsupported operand type(s) for +: 'int' and 'str'</span></pre><p id="6907" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">原因是在lambda的初始调用中，acc的类型是int(序列中的初始1)，我们试图添加str(2)。这正是错误消息告诉我们的。</p><p id="4256" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">那么，什么时候指定一个专用的初始值呢？每当结果类型不同于iterable的元素类型时，您很可能需要一个与结果类型相同的初始值。</p></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><p id="2fb8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">注意，在Python中，只有reduce()可以作为标准functools包的成员，但是我们没有fold()。Python的reduce()将初始值作为可选参数，默认值为None。因此，如果您将一个初始值传递给reduce()，它的行为类似于fold()。</p><p id="4636" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">从现在开始，我将在代码示例中使用Python的原生functools.reduce()。为了节省空间，我将functools作为“f”导入。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="5cb6" class="mc md jb ly b gy me mf l mg mh">import functools as f</span><span id="296f" class="mc md jb ly b gy mi mf l mg mh">&gt;&gt;&gt; f.reduce(lambda acc, item: acc + item, [1, 2, 3, 4, 5])<br/>15</span><span id="1499" class="mc md jb ly b gy mi mf l mg mh">&gt;&gt;&gt; f.reduce(lambda acc, item: acc + str(item), [1, 2, 3, 4, 5], "")<br/>'12345'</span></pre><blockquote class="mj mk ml"><p id="8624" class="kq kr mm ks b kt ku kc kv kw kx kf ky mn la lb lc mo le lf lg mp li lj lk ll ij bi translated">就我个人而言，我更喜欢总是传递一个初始值给reduce()，因为这使得预期的结果类型更加明确。</p></blockquote><p id="dc53" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们现在可以总结一下reduce()的基本属性:</p><ul class=""><li id="d27c" class="mq mr jb ks b kt ku kw kx kz ms ld mt lh mu ll mv mw mx my bi translated">reduce本身的实现非常简单，因为它将“reduce”委托给了另一个函数。这使得<strong class="ks jc"> reduce() </strong>成为一个高阶函数。</li><li id="8911" class="mq mr jb ks b kt mz kw na kz nb ld nc lh nd ll mv mw mx my bi translated">reducer函数通过随后将累积状态与可迭代序列的每一项相结合来计算新的状态。</li><li id="84e3" class="mq mr jb ks b kt mz kw na kz nb ld nc lh nd ll mv mw mx my bi translated">reducer函数的返回类型与其第一个参数的类型相同。</li><li id="6fe7" class="mq mr jb ks b kt mz kw na kz nb ld nc lh nd ll mv mw mx my bi translated">标准reduce()函数中的初始值是可选的。如果省略，该函数将iterable的第一项作为初始值。</li></ul><h1 id="bf44" class="ne md jb bd nf ng nh ni nj nk nl nm nn kh no ki np kk nq kl nr kn ns ko nt nu bi translated">何时使用reduce()</h1><p id="aa8b" class="pw-post-body-paragraph kq kr jb ks b kt nv kc kv kw nw kf ky kz nx lb lc ld ny lf lg lh nz lj lk ll ij bi translated">一般来说，reduce()可以被认为是一种通用的、函数式的编写循环的方法，这种方法旨在通过迭代一个集合来产生一个结果。</p><p id="8fa9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我猜，你听说过<strong class="ks jc">地图()</strong>和<strong class="ks jc">滤镜()</strong>。map()接受一个函数和一个iterable，将函数应用于iterable的元素，并返回一个“投影的”iterable。</p><p id="933a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">相反，filter()接受一个“谓词函数”(返回bool的函数)和一个iterable，并返回一个新的iterable，其中包含谓词函数包含的元素。</p><p id="5231" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在，为什么我要将map()和filter()与reduce()结合在一起呢？嗯，和reduce()一样，两者都是以一个函数和一个iterable作为输入。听起来熟悉吗？为了演示reduce()的一般性质，让我展示如何根据reduce()实现map()和filter()。</p><p id="0072" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">下面是列表的<strong class="ks jc"> map() </strong>:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="0cc4" class="mc md jb ly b gy me mf l mg mh">from typing import List</span><span id="3391" class="mc md jb ly b gy mi mf l mg mh">A = TypeVar("A")<br/>B = TypeVar("B")</span><span id="0b57" class="mc md jb ly b gy mi mf l mg mh">def map_(f: Callable[[A], B], seq: List[A]) -&gt; List[B]:<br/>    return f.reduce(lambda state, item: state + [f(item)], seq, [])</span><span id="cee3" class="mc md jb ly b gy mi mf l mg mh">&gt;&gt;&gt; map_(lambda x: x * x, [1, 2, 3, 4, 5])<br/>[1, 4, 9, 16, 25]</span></pre><p id="5f27" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">还有<strong class="ks jc">滤镜()</strong>:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="1b2d" class="mc md jb ly b gy me mf l mg mh">def filter_(<br/>    predicate: Callable[[A], bool], seq: List[A]<br/>) -&gt; List[A]:</span><span id="9097" class="mc md jb ly b gy mi mf l mg mh">    return f.reduce(<br/>        lambda state, item: <br/>            state + [item] if predicate(item) else state,<br/>        seq, [])</span><span id="df6b" class="mc md jb ly b gy mi mf l mg mh">&gt;&gt;&gt; filter_(lambda x: len(x) &gt; 2, ["abc", "de", "fghi"])<br/>['abc', 'fghi']</span></pre><blockquote class="mj mk ml"><p id="e3da" class="kq kr mm ks b kt ku kc kv kw kx kf ky mn la lb lc mo le lf lg mp li lj lk ll ij bi translated">注意，在这两种情况下，我都使用一个空列表作为初始值，因为我们想要返回一个列表。</p></blockquote><p id="cdc5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">使用reduce还可以实现更多众所周知的功能。</p><p id="1e78" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc"> max(): </strong></p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="b53e" class="mc md jb ly b gy me mf l mg mh">import math</span><span id="7491" class="mc md jb ly b gy mi mf l mg mh">def max_(seq: Iterable[int]) -&gt; int:<br/>    return f.reduce(<br/>        lambda state, item: item if item &gt; state else state,<br/>        seq, -math.inf)</span><span id="4593" class="mc md jb ly b gy mi mf l mg mh">&gt;&gt;&gt; max_([10, 20, 30])<br/>30</span></pre><p id="2dff" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc">反转()</strong>:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="df0b" class="mc md jb ly b gy me mf l mg mh">def reversed_(seq: List[A]) -&gt; List[A]:<br/>    return f.reduce(lambda state, item: [item] + state, seq, [])</span><span id="0f06" class="mc md jb ly b gy mi mf l mg mh">&gt;&gt;&gt; reversed_([10, 20, 30])<br/>[30, 20, 10]</span></pre><blockquote class="mj mk ml"><p id="02f4" class="kq kr mm ks b kt ku kc kv kw kx kf ky mn la lb lc mo le lf lg mp li lj lk ll ij bi translated">同样，当我们创建输入列表的反向版本时，我们将中性元素设置为空列表([] + [n] = [n])。</p></blockquote><p id="23a0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc"> accumulate(): </strong></p><p id="2467" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">示例摘自<a class="ae oa" href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3/library/ITER tools . html # ITER tools . accumulate</a></p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="75d8" class="mc md jb ly b gy me mf l mg mh">import operator as op</span><span id="7a6a" class="mc md jb ly b gy mi mf l mg mh">def accumulate_(seq: List[A], f=op.add) -&gt; List[A]:<br/>    return f.reduce(<br/>        lambda state, item:<br/>            [item] if not state else state + [f(state[-1], item)],<br/>        seq, [])</span><span id="9d02" class="mc md jb ly b gy mi mf l mg mh">&gt;&gt;&gt; accumulate_([1, 2, 3, 4, 5])<br/>[1, 3, 6, 10, 15]</span><span id="b21a" class="mc md jb ly b gy mi mf l mg mh">&gt;&gt;&gt; accumulate_([1, 2, 3, 4, 5], op.mul)<br/>[1, 2, 6, 24, 120]</span><span id="9a11" class="mc md jb ly b gy mi mf l mg mh">&gt;&gt;&gt; cashflows = [1000, -90, -90, -90, -90]<br/>&gt;&gt;&gt; accumulate_(cashflows, lambda bal, pmt: bal*1.05 + pmt)<br/>[1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001]</span></pre><p id="b89d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc">功能组成:</strong></p><p id="4497" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一个更复杂的例子是用reduce()实现的函数组合:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="4992" class="mc md jb ly b gy me mf l mg mh">from typing import Any</span><span id="6181" class="mc md jb ly b gy mi mf l mg mh">C = TypeVar("C")</span><span id="9b7d" class="mc md jb ly b gy mi mf l mg mh">def compose2(<br/>    g: Callable[[B], C], f: Callable[[A], B]<br/>) -&gt; Callable[[A], C]:<br/>    return lambda x: g(f(x))</span><span id="4afd" class="mc md jb ly b gy mi mf l mg mh">def compose(*f: Callable[[Any], Any]) -&gt; Callable[[Any], Any]:<br/>    return f.reduce(compose2, f, lambda x: x)</span><span id="74ea" class="mc md jb ly b gy mi mf l mg mh">&gt;&gt;&gt; complexlen = compose(str, complex, len)<br/>&gt;&gt;&gt; complexlen("42")<br/>'(2+0j)'</span></pre><p id="4168" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">首先，我们定义一个函数<strong class="ks jc"> compose2(g，f) </strong>，它在f之后返回一个新的函数(g . f)“g”。然后，我们使用reduce()为任意数量的函数定义<strong class="ks jc"> compose() </strong>。</p><blockquote class="mj mk ml"><p id="8a4a" class="kq kr mm ks b kt ku kc kv kw kx kf ky mn la lb lc mo le lf lg mp li lj lk ll ij bi translated">这里，中性元素是恒等函数<strong class="ks jc">λx:x</strong>。用identity函数组合一个函数返回原始函数:(f . id) = f</p></blockquote><h2 id="c18c" class="mc md jb bd nf ob oc dn nj od oe dp nn kz of og np ld oh oi nr lh oj ok nt ol bi translated">reduce()的其他应用</h2><p id="064a" class="pw-post-body-paragraph kq kr jb ks b kt nv kc kv kw nw kf ky kz nx lb lc ld ny lf lg lh nz lj lk ll ij bi translated">我假设你听说过<a class="ae oa" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> ReduxJS </a>，它本质上是基于reduce()的原理。</p><p id="bd73" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">MapReduce中的Reduce步骤使用reducer函数来合并中间结果。</p><p id="33c5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">还有更多…</p><h1 id="193e" class="ne md jb bd nf ng nh ni nj nk nl nm nn kh no ki np kk nq kl nr kn ns ko nt nu bi translated">结论</h1><p id="f337" class="pw-post-body-paragraph kq kr jb ks b kt nv kc kv kw nw kf ky kz nx lb lc ld ny lf lg lh nz lj lk ll ij bi translated">你看，fold()和reduce()的应用无处不在，reduce()和fold()显然是以函数方式将可迭代集合的元素转换成其他元素的两把瑞士军刀。</p><p id="bb91" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">以我的经验来看，减速器功能是人们在接触reduce()和fold()时最纠结的东西。这肯定需要一些实践(和CodeKata)。一旦你有了这个想法，这些功能将成为你功能库中不可或缺的工具。</p><p id="2452" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">永远记住，reducer就像任何其他函数一样，被重复应用于一系列值。所以，绝对不需要憎恨或焦虑。</p></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><p id="2858" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">本文到此为止。我希望我能够揭开fold()/reduce()的神秘面纱，并阐明它的应用程序和功能。如果你觉得这篇文章有用，请留下你的评论并分享。</p><h1 id="1028" class="ne md jb bd nf ng nh ni nj nk nl nm nn kh no ki np kk nq kl nr kn ns ko nt nu bi translated">奖励材料:-)</h1><h2 id="e7fd" class="mc md jb bd nf ob oc dn nj od oe dp nn kz of og np ld oh oi nr lh oj ok nt ol bi translated">嵌套循环呢？</h2><p id="87d6" class="pw-post-body-paragraph kq kr jb ks b kt nv kc kv kw nw kf ky kz nx lb lc ld ny lf lg lh nz lj lk ll ij bi translated">有人问我如何使用reduce()实现嵌套循环。这里尝试从纯功能的角度来解决这个问题。考虑如下所示的嵌套循环:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="8227" class="mc md jb ly b gy me mf l mg mh">result = []<br/>for pfx in range(1, 4):<br/>    for code in range(65, 68):<br/>        result.append(str(pfx) + ":" + chr(code))</span><span id="da60" class="mc md jb ly b gy mi mf l mg mh">&gt;&gt;&gt; result<br/>['1:A', '1:B', '1:C', '2:A', '2:B', '2:C', '3:A', '3:B', '3:C']</span></pre><p id="ab4f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">除了这样一个事实，你可以通过写…</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="fb22" class="mc md jb ly b gy me mf l mg mh">&gt;&gt;&gt; [str(pfx) + ":" + chr(code)<br/>    for pfx in range(1, 4)<br/>    for code in range(65, 68)]<br/>['1:A', '1:B', '1:C', '2:A', '2:B', '2:C', '3:A', '3:B', '3:C']</span></pre><p id="e999" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">…让我们尝试使用功能。我们从创建reducer操作开始，它只是将一个类似“1:A”的字符串追加到一个列表中:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="e6f4" class="mc md jb ly b gy me mf l mg mh">def add_prefix(pfx: int, code: int) -&gt; str:<br/>    return str(pfx) + ":" + chr(code)</span><span id="2653" class="mc md jb ly b gy mi mf l mg mh">def prefix_reducer(<strong class="ly jc">pfx</strong>):<br/>    return lambda result, code: result + [add_prefix(<strong class="ly jc">pfx</strong>, code)]</span><span id="6f69" class="mc md jb ly b gy mi mf l mg mh">&gt;&gt;&gt; f.reduce(prefix_reducer(1), range(65, 68), [])<br/>['1:A', '1:B', '1:C']</span></pre><p id="2721" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有趣的是，我们必须在reducer函数中注入前缀变量‘pfx ’,但是我们不能有一个带3个参数的reducer函数。记住:一个减速器只能带2个；-)</p><p id="4d87" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们利用‘闭包’！我们不返回值，而是返回reducer函数(即lambda ),它从周围的作用域中捕获变量‘pfx’。</p><p id="4c21" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这样，我们现在可以创建一个函数，为单个前缀创建子列表:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="42f2" class="mc md jb ly b gy me mf l mg mh">def range_prefixer(pfx, rng):<br/>    return functools.reduce(prefix_reducer(pfx), rng, [])</span><span id="202f" class="mc md jb ly b gy mi mf l mg mh">&gt;&gt;&gt; range_prefixer(2, range(65, 68))<br/>['2:A', '2:B', '2:C']</span></pre><p id="1db5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">最后，我们需要一个缩减器，它从range_prefixer()调用生成的列表中生成一个列表。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="a255" class="mc md jb ly b gy me mf l mg mh">def range_reducer(<strong class="ly jc">rng</strong>):<br/>    return lambda state, pfx: state + range_prefixer(pfx, <strong class="ly jc">rng</strong>)</span><span id="bd6e" class="mc md jb ly b gy mi mf l mg mh">&gt;&gt;&gt; functools.reduce(<br/>        range_reducer(range(65, 68)), <br/>        range(1, 4), <br/>        [])<br/>['1:A', '1:B', '1:C', '2:A', '2:B', '2:C', '3:A', '3:B', '3:C']</span></pre><p id="5b9c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">乍一看，要将一个4行嵌套的for循环转换成一些功能性的东西还真不容易，是吧？但是，我们获得了许多可重复使用的(！)就纯函数而言的功能性，每个函数都是一行程序，具有清晰的功能性，很容易推理，并且可以很好地测试。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="fdff" class="mc md jb ly b gy me mf l mg mh">def add_prefix(pfx: int, code: int) -&gt; str:<br/>    return str(pfx) + ":" + chr(code)</span><span id="ffb4" class="mc md jb ly b gy mi mf l mg mh">def prefix_reducer(<strong class="ly jc">pfx</strong>):<br/>    return lambda result, code: result + [add_prefix(<strong class="ly jc">pfx</strong>, code)]</span><span id="e245" class="mc md jb ly b gy mi mf l mg mh">def range_prefixer(pfx, rng):<br/>    return f.reduce(prefix_reducer(pfx), rng, [])</span><span id="b9e2" class="mc md jb ly b gy mi mf l mg mh">def range_reducer(<strong class="ly jc">rng</strong>):<br/>    return lambda state, pfx: state + range_prefixer(pfx, <strong class="ly jc">rng</strong>)</span></pre><p id="1c8c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">还要注意，一切都只是表达式，没有语句(除了return)。</p><p id="cfe5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">下面是进行嵌套计算的最后一个单行函数:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="7455" class="mc md jb ly b gy me mf l mg mh">def nested_prefixer(prefix_rng, code_rng):<br/>    return f.reduce(range_reducer(code_rng), prefix_rng, [])</span><span id="2ac2" class="mc md jb ly b gy mi mf l mg mh">&gt;&gt;&gt; nested_prefixer(range(1, 4), range(65, 68))<br/>['1:A', '1:B', '1:C', '2:A', '2:B', '2:C', '3:A', '3:B', '3:C']</span></pre><p id="b44d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">通过将add_prefix()函数作为参数注入nested_prefixer()，我们可以使我们的解决方案更加灵活，这样我们就可以参数化格式，例如“1__A”或“1xA”或其他任何格式。我将此作为读者的一个练习；-)</p></div></div>    
</body>
</html>