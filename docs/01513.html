<html>
<head>
<title>Functional Programming in OOP Concept: The Overkill</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OOP概念中的函数式编程:矫枉过正</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/functional-programming-in-oop-concept-the-overkill-fb940f63c6d5?source=collection_archive---------17-----------------------#2020-01-08">https://levelup.gitconnected.com/functional-programming-in-oop-concept-the-overkill-fb940f63c6d5?source=collection_archive---------17-----------------------#2020-01-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a80266a1384a9998260d4b23c9aa6ec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*00b0l56nmApSj0rU"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">格伦·卡丽在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="be8e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有许多遵循不同编程范例的语言。其中一些严格地强迫你遵循它的范式，而另一些给你更多的灵活性。但是灵活性是有代价的。如果开发人员缺乏一些技能和经验，那么一切都会变得混乱。这种工作产生了糟糕的可读性、复杂的业务领域、难以维护和测试的代码库。另一方面，如果它被明智地使用，那么我们可以看到语言提供的力量。</p><p id="5f3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在此之前，我先解释几个术语。然后，我将像我在上一篇文章中所做的那样展示真实世界的例子。在这些例子中，我将使用PHP作为编码语言。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="e00b" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">一流的功能</h2><blockquote class="me"><p id="c258" class="mf mg it bd mh mi mj mk ml mm mn ld dk translated">在计算机科学中，如果一种编程语言将函数视为一等公民，则称该语言具有一等函数。这意味着该语言支持将函数作为参数传递给其他函数，将它们作为其他函数的值返回，并将它们赋给变量或存储在数据结构中。<a class="ae kf" href="https://en.wikipedia.org/wiki/First-class_function" rel="noopener ugc nofollow" target="_blank"> </a></p></blockquote><p id="456b" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">首先，作为一等公民意味着他们可以是函数的参数，他们可以从函数返回，你可以在语句中给它们赋值。想象一下最原始的类型，比如integer和float。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="aec4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你所看到的，我们使用整数值作为参数，函数也返回一个整数值。第四行有一个赋值语句。它声明integer是PHP中的一等公民。函数呢？</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5324" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如图所示，我们可以像使用其他类型的函数一样使用函数。现在很明显他们在PHP里是一流的。</p><h2 id="f13c" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">更好的功能</h2><p id="9bee" class="pw-post-body-paragraph kg kh it ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">从5.4版本开始，PHP引入了一种新类型，称为<strong class="ki iu">闭包类</strong> <a class="ae kf" href="https://www.php.net/manual/en/class.closure.php" rel="noopener ugc nofollow" target="_blank"> </a>。值得一提的是，匿名函数也是闭包。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f428" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于变得更好，这个类为我们提供了一个"<strong class="ki iu"> use </strong>"语句。我们使用这个语句从内部作用域访问外部作用域。通过这种方法，我们可以捕获全局变量、父作用域变量，甚至父函数参数。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="1516" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">概念证明</h2><p id="cb01" class="pw-post-body-paragraph kg kh it ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">在一开始，我提到了一个现实世界的例子。我相信提供它们对于像这篇文章一样的文章是必不可少的。因为对这些术语一无所知的读者可能想知道他/她为什么要用它。此外，它给了一个实验的机会。所以，我创造了一个场景。假设我们正在进行游戏开发，我们的游戏包含不同类型的角色，比如鸟和人。并假设这些角色需要撤销他们的动作。我们可以遵循面向对象的原则，同时从函数式编程原则中获益。</p><p id="55e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="ne">要求</em> </strong></p><ul class=""><li id="95e1" class="nf ng it ki b kj kk kn ko kr nh kv ni kz nj ld nk nl nm nn bi translated">所有的角色应该能够在X和Y轴上移动。</li><li id="e3ea" class="nf ng it ki b kj no kn np kr nq kv nr kz ns ld nk nl nm nn bi translated">所有类型的角色都应该有一个速度属性。</li><li id="9e19" class="nf ng it ki b kj no kn np kr nq kv nr kz ns ld nk nl nm nn bi translated">角色需要撤销他们的动作，比如后退或者变回速度等等。</li></ul><p id="43e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="ne">设计</em> </strong></p><p id="81de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">设计是软件开发的一个重要部分，然而一些开发人员倾向于忽略或低估它。在我们的例子中，起初有两个实体，鸟类和人类类。它们的行为几乎相同，这意味着它们需要实现相同的接口。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/72b7facbeffcc142409b864ac5e26041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w7zP0iY450AskukEVOPbRA.png"/></div></div></figure><p id="bc96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，他们需要处理撤销他们的行为。但是如果我们把这个责任推到他们身上，显然我们违反了单一责任原则。相反，我们打算用一个装饰图案来解决这个问题。这种模式修饰一个类，赋予它额外的能力，并保持实体的纯净。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/245a3d8a71c8a81334e888643b63cccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1fzFqTRiOG41CD3wV7QcqA.png"/></div></div></figure><p id="4751" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有另一件事要解决。我们不能立即执行撤销功能。因为这取决于用户，而用户何时需要它们是不可预测的。一种方法是存储它的状态，每当用户想要撤销上一个动作时，就返回前一个状态。但有时这还不够，问题可能需要更灵活的解决方案。在这种情况下，我们可以利用一流的功能。我们针对实体的每个常规函数创建一个反向函数，然后将它们存储在堆栈中。无论何时需要它们，都可以从堆栈中弹出。这种方法提供了在任何需要的时候执行它们的自由。</p><p id="2325" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="ne">实现</em> </strong></p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f80e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到目前为止，它是一个普通的实现。为了简单起见，我尽量保持它们的纯净和直白。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1a98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有几件事我不得不提一下。这个修饰类就像其他实现“字符接口”的类一样。它可以做他们做的事情，但也有额外的能力。在我们的例子中，它们是私有撤销函数和公共“撤销”方法。在私有方法中，我们提供对常规方法的反作用。我们将这些计数器函数存储在堆栈中。每当客户端调用公共撤销方法时，我们从堆栈中弹出最后一个函数。</p><p id="6534" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="ne">用法</em> </strong></p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7fd3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">和预期的结果一样:</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/ab39e54783c136e5f71b110cb58b28c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*oGN5-d0UEe_oUoE4BTyIKA.jpeg"/></div></div></figure></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="74d2" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">过度杀戮</h2><p id="3bca" class="pw-post-body-paragraph kg kh it ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">尤其是来自前端开发的人更倾向于这样做。滥用这种灵活性会导致不必要的工作量，从而影响生产率。描述这种情况的最佳方式是举例说明:</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1074" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">想象一下那些本地函数(strtoupper，strtolower)就是我们的定义。如果我们决定重构它们会发生什么。即使你使用相当先进的编辑器，它也无法检测到它。此外，这项工作不属于那种方法。相反，当您需要在控制器或其他地方使用该姓氏时；</p><blockquote class="me"><p id="d4e5" class="mf mg it bd mh mi mj mk ml mm mn ld dk translated">return strtoupper((新人())-&gt; getSurname())；</p></blockquote><p id="0f39" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">这种说法更有道理。我可以举出很多例子，但希望我已经触及了主要思想。</p></div></div>    
</body>
</html>