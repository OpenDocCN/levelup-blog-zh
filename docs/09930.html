<html>
<head>
<title>Taylor Series in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的泰勒级数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/taylor-series-in-python-4354e448c1cc?source=collection_archive---------9-----------------------#2021-10-03">https://levelup.gitconnected.com/taylor-series-in-python-4354e448c1cc?source=collection_archive---------9-----------------------#2021-10-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="8e3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">函数的<a class="ae ko" href="https://en.wikipedia.org/wiki/Taylor_series" rel="noopener ugc nofollow" target="_blank">泰勒级数</a>是一个无穷多项的和，它使用关于函数导数的信息来创建一个逼近该函数的多项式。更精确的近似可以通过取高阶导数和使用高阶多项式来确定。许多<a class="ae ko" href="https://medium.com/search?q=taylor%20series" rel="noopener">关于<a class="ae ko" href="https://www.cantorsparadise.com/taylor-series-and-the-power-of-approximation-7d2c16596f89" rel="noopener ugc nofollow" target="_blank">泰勒级数</a>的帖子</a>(以及<a class="ae ko" href="https://www.youtube.com/watch?v=3d6DsjIBzJ4&amp;ab_channel=3Blue1Brown" rel="noopener ugc nofollow" target="_blank">一些YouTube视频</a>)通过展示高阶项如何提供更接近基础函数的近似值(假设级数收敛)来帮助建立对无穷级数的直觉。然而，没有多少表明为什么我们真的应该关心。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/5fc1a4b1ad954d4698f6df78210c21e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WkU0zvwEHUMtu1xF"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">照片由<a class="ae ko" href="https://unsplash.com/@lysanderyuen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">吕山德·袁</a>在<a class="ae ko" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="601a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我在攻读本科学位期间第一次面对泰勒级数时，它们似乎只是另一回事。最近，在准备GRE数学科目考试时，我对泰勒级数有了更深的理解，并决定用Python实现它们。这种实现只需要被逼近的函数的定义，其余的用数字处理。在这篇文章中，我们将讨论和展示Python的实现，以及泰勒级数的一些潜在用途。</p><h1 id="8e5e" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">履行</h1><p id="3b23" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">函数的泰勒级数项<em class="mi"> f(x) </em>需要连续的高阶导数f^(n)(x来确定多项式的系数。因此，一个泰勒级数只有对<em class="mi"> f(x) </em>无穷可微才能确定。级数的项由下式给出</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mj"><img src="../Images/33c36783846f71340f207566330c2e25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*84eKJx79i4PyGvYFiOWtzQ.png"/></div></div></figure><p id="9c00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中<em class="mi"> a </em>是泰勒级数的中心。当级数的中心为0，即<em class="mi"> a=0 </em>时，该级数也称为马克劳林级数。</p><p id="4b45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了能够以编程方式确定函数的泰勒级数，我们真正需要做的就是确定系数</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/3f2c8ee719ddafd613728629c925b48c.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*TwGJoEnu-DXASoLy8_MODQ.png"/></div></figure><p id="896f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于足够多的术语。请注意，我们在泰勒级数中使用的项越多，近似值就越精确。幸运的是，在<a class="ae ko" href="https://docs.scipy.org/doc/scipy/getting_started.html" rel="noopener ugc nofollow" target="_blank"> scipy Python包</a>中，有一个内置函数，用于计算函数在指定点的导数。我们将使用这个函数来确定多项式的系数。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="b697" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的逻辑中，我们首先定义一个类来存储泰勒级数信息。构造函数将一个指针指向一个<em class="mi">函数</em>，我们正在为其寻找泰勒级数、泰勒级数的<em class="mi">阶</em>(即项数)，以及级数的<em class="mi">中心</em>，该级数默认为Maclaurin级数。在<a class="ae ko" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.derivative.html" rel="noopener ugc nofollow" target="_blank"><em class="mi">scipy . misc . derivative</em>函数</a>中使用了一些动态计算的变量。立即调用私有的<em class="mi"> __find_coefficients(…) </em>方法来确定泰勒级数中每一项的系数值。这是通过在数值上确定泰勒级数的每一项的导数并除以阶乘来实现的，如上所述。</p><p id="e863" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际上，这就是用Python表示泰勒级数所需要做的全部工作。泰勒级数的其余能力将仅仅使用这些系数来执行不同的运算。在此之前，让我们通过确定一些多项式的系数来验证这是可行的(泰勒级数应该是精确的函数)。为了验证这一点，定义了两个打印函数来查看系数和表示泰勒级数的结果方程。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="015c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个函数，<em class="mi"> print_equation(…) </em>，将泰勒级数打印为以级数中心为中心的方程。<em class="mi"> print_coefficients(…) </em>将只打印代表系数的列表，而<em class="mi"> get_coefficients(…) </em>将返回该列表。</p><p id="b413" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面的代码用于查找代表Python函数<em class="mi"> f(x) </em>中函数的泰勒级数的系数</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="f41a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行此逻辑将产生一个大小为15的列表，其中包含泰勒级数的系数，还将打印多项式方程。在这种情况下，用15项泰勒级数“逼近”的函数为</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mn"><img src="../Images/ad1d2df4b1d7ba56ee0ade6cfc086d62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_D7bkKNVKTnYkku3bEwWEA.png"/></div></div></figure><p id="eb27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于这只是一个多项式，泰勒级数应该能够通过第一个系数(常数)为2.0、索引2、3和7处的系数为1.0以及其他所有地方的系数为0.0来准确表示。这将代表上面所示的多项式。实际上，运行该脚本会产生以下输出</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/49d05745fb8471de43abd3d61aca9f1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/0*vJyrNVhHt3VB8Hv_.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">上面Python脚本的输出显示系数确定正确，原始多项式由泰勒级数生成。</figcaption></figure><p id="509f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为不同的多项式更改上面Python脚本中的函数<em class="mi"> f(x) </em>会产生相同的结果，每个多项式都精确地用泰勒级数表示。这不是很有趣，但这是验证逻辑是否如预期那样工作的好方法。泰勒级数广为人知的更有趣的函数，例如sin(x)，cos(x)，e^x等。，也通过这种实现提供正确的结果。这些功能将在以下应用中使用。</p><h1 id="1e42" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">应用程序</h1><p id="b98c" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">因为多项式通常比大多数函数更容易处理，所以泰勒级数近似有助于确定与这些函数相关的不同运算的近似值。</p><h1 id="f2b7" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">无效的</h1><h2 id="e070" class="mp lg it bd lh mq mr dn ll ms mt dp lp kb mu mv lt kf mw mx lx kj my mz mb na bi translated">区别</h2><p id="1f83" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">函数的泰勒级数可以用来逼近函数在特定点的导数。泰勒级数中的各项可以单独微分，其形式如下</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nb"><img src="../Images/ddcdd437ef074d6974890ced216e6989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ST_MtPltQMBFhwIIt61g-g.png"/></div></div></figure><p id="ac80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其简单地是通过幂法则的多项式项的导数乘以泰勒级数的系数。请注意，在代码中，这将剔除泰勒级数未表示的项，因为系数将为0。</p><p id="4b3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些计算是在Python逻辑中用下面的函数完成的</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="8c0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个函数中，函数的导数的近似值是通过迭代系数，如上所述计算导数值，并将它们相加得到的。将值插入到该函数中提供了基础函数的导数的精确近似值，如下所示用于<em class="mi"> cos(x) </em></p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="6b8c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如此处所示，使用值0、pi/6、pi/4、pi/3、pi/2、pi，并显示函数值cos(x)和近似导数(注意，实际导数为-sin(x))。观察几个点，我们发现，一般来说，这给出了cos(x)在这些点的导数的良好近似值。例如，在点pi/4处，函数值是0.707 = sqrt(2)/2是正确的，因为它的导数是-0.707。</p><p id="f272" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不幸的是，这基本上是无用的，因为泰勒级数需要关于导数的信息来确定其系数。当我们需要知道<em class="mi">f’(x)</em>的一般形式(即实际值)来确定这个近似值时，为什么我们想要一个<em class="mi">f’(x)</em>的近似值呢？此外，有许多不同的数值方法可以近似计算导数，而不需要通过分析找到函数的导数(例如有限差分方法)，这些方法更适合这项任务。</p><h1 id="9f74" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">更有用</h1><h2 id="1fcf" class="mp lg it bd lh mq mr dn ll ms mt dp lp kb mu mv lt kf mw mx lx kj my mz mb na bi translated">价值逼近</h2><p id="67df" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">泰勒级数的一个广泛使用的目的是逼近基础函数的值。为了逼近函数值，该值被插入到泰勒级数项中，这些项相加在一起。这是在下面的Python逻辑中完成的。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="6db6" class="mp lg it bd lh mq mr dn ll ms mt dp lp kb mu mv lt kf mw mx lx kj my mz mb na bi translated">定积分</h2><p id="b5d8" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">泰勒级数可以用来近似基本函数的积分，因为泰勒级数的各项可以单独积分，就像微分一样。积分近似值中的各项将采取以下形式</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nc"><img src="../Images/5495aa372f6cc5a279c72abd046282d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o9Og-kxWBUiGLVHA-N8ixg.png"/></div></div></figure><p id="e14d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里再一次，这只是积分的幂律乘以泰勒级数系数。</p><p id="d37e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，在数值上，我们只能确定函数的定积分，否则，缺少积分常数的值会导致不正确的结果。考虑以0为中心的泰勒级数f(x) = sin(x) </p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nd"><img src="../Images/2dc5fb3e3084b05aeafe5987eb00666b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2yQAMSjBSI_ImgZi_xskvw.png"/></div></div></figure><p id="99c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将这一项一项地积分得到以下多项式</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ne"><img src="../Images/933b0d89dab9f2012ccddfd4d119298c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SVC_YZeoOMzP_c4VOaxa6Q.png"/></div></div></figure><p id="afb7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，假设这是对<em class="mi"> sin(x) </em>(我们知道实际积分是<em class="mi"> -cos(x) </em>)的积分的适当近似，并尝试在0处评估该函数。这样做的价值是0。在这种情况下，这可以通过设置积分常数<em class="mi"> C=-1 </em>来弥补，但我们必须为函数定义域中的每个值确定该常数，以“修复”积分，这使得不定积分变得毫无用处。</p><p id="7345" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，定积分可以通过对泰勒级数逐项积分并插入积分极限来轻松计算，如下面的Python代码所示。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="b430" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对几个值运行该函数，可以得到sin(x)、cos(x)、x + x、e^x以及一个更难积分的e^x*sin(x).的理想结果由于这篇文章的长度，这些结果将被省略。对于那些好奇的人来说，下面可以使用完整的代码，并且可以更改<em class="mi"> def f(x) </em>函数来亲自查看这些结果。</p><h2 id="be33" class="mp lg it bd lh mq mr dn ll ms mt dp lp kb mu mv lt kf mw mx lx kj my mz mb na bi translated">限制</h2><p id="250e" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我不会展示如何用数字来近似极限并在Python中实现它，而是仅仅看一个极限的例子，这个例子可能很难通过分析来确定，但可以通过代入泰勒级数很容易地找到。</p><p id="544d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑极限</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/f15bebe36d2a6cd8a7f4011a388b63d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*wwGNnbrFnWL4_x8Yzg_uhg.png"/></div></figure><p id="9ed9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个极限可以很容易地通过重复应用L'Hospitals规则来确定，因为它具有0/0的形式，但是让我们假设我们不知道这个(或者我们对L ' hospitals规则一无所知)，那么我们将如何确定这个极限呢？事实证明，泰勒级数可以通过用近似值代替极限中的<em class="mi"> sin(x) </em>来帮助我们解决这个问题。对于这个例子，将使用一个三项泰勒级数</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/7986e4257b4181dbb3443e6a55ecd7fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*b7jxQJ-5o_u_NbrdzgXJow.png"/></div></figure><p id="526e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于极限中的x /120项变为0，因此结果为-1/6，如果通过L'Hospitals进行评估，结果与预期一致。</p><h1 id="2295" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="a86c" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">上面介绍的是泰勒级数的概念，这是一种数学工具，用于仅使用关于函数导数的信息，用多项式逼近任何连续可微函数。提供了一个Python实现，并讨论了泰勒级数的一些应用。下面提供了带有一些示例用法的完整代码，我鼓励对该工具感兴趣的任何人复制并使用它，以进一步了解泰勒级数。</p><h1 id="585b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">完整代码</h1><h2 id="140f" class="mp lg it bd lh mq mr dn ll ms mt dp lp kb mu mv lt kf mw mx lx kj my mz mb na bi translated">用法. py</h2><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="5347" class="mp lg it bd lh mq mr dn ll ms mt dp lp kb mu mv lt kf mw mx lx kj my mz mb na bi translated">泰勒系列. py</h2><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ml mm l"/></div></figure></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="f41e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mi">原载于2021年10月3日</em><a class="ae ko" href="https://www.anthonymorast.com/blog/2021/10/03/taylor-series-in-python/" rel="noopener ugc nofollow" target="_blank"><em class="mi">【https://www.anthonymorast.com】</em></a><em class="mi">。</em></p></div></div>    
</body>
</html>