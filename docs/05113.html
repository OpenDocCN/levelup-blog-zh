<html>
<head>
<title>ROS Spinning, Threading, Queuing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ROS旋转、穿线、排队</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ros-spinning-threading-queuing-aac9c0a793f?source=collection_archive---------1-----------------------#2020-08-05">https://levelup.gitconnected.com/ros-spinning-threading-queuing-aac9c0a793f?source=collection_archive---------1-----------------------#2020-08-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d3a0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有效使用多个旋转线程，ROS中的不同队列</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f50950e79c0a196f03935896afafd3be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lsbkF4ybE4jDj2eOsqgeSg.png"/></div></div></figure><p id="4a8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">机器人操作系统(ROS)是开发机器人应用程序的流行框架。ROS提供的主要功能之一是发布者-订阅者通信，用于组件之间的消息传递。虽然实现发布者-订阅者很容易，但是并不清楚在它下面发生了什么，以及我们如何在实践中使它适合我们的特定问题。在这篇文章中，我将讨论ROS中发布者-订阅者背后的机制，比如它的执行模型、线程、排队机制。为了保持讨论的实际水平，我将使用简单的参考程序，这些程序来自ROS的原始教程。希望在本文结束时，您已经理解了这些概念和权衡，这样您就可以决定哪种方法最适合您的应用程序。</p><h1 id="cffd" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">订户队列</h1><p id="e8c1" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">如我所说，我将使用ROS教程中的一个示例包作为其余讨论的基础，并在我们继续讨论时对其进行修改。我们的例子有两个节点，一个称为“谈话者”，另一个称为“听众”。</p><h2 id="a4e0" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">空谈者</h2><p id="cb0c" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">谈话者节点发布主题“chatter ”,而收听者节点订阅该主题。谈话者的实现如下所示，</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3d25" class="mn lr it na b gy ne nf l ng nh">#include &lt;sstream&gt;<br/>#include "ros/ros.h"<br/>#include "std_msgs/String.h"</span><span id="e132" class="mn lr it na b gy ni nf l ng nh">int main(int argc, char **argv) {<br/>  ros::init(argc, argv, "talker");<br/>  ros::NodeHandle n;</span><span id="9922" class="mn lr it na b gy ni nf l ng nh">  ros::Publisher chatter_pub =     <br/>  n.advertise&lt;std_msgs::String("chatter", 1000);</span><span id="35c0" class="mn lr it na b gy ni nf l ng nh">  int chatter_count = 0;</span><span id="e8a4" class="mn lr it na b gy ni nf l ng nh">  ros::Timer timer = n.createTimer(ros::Duration(0.01),<br/>  [&amp;](const ros::TimerEvent&amp;) {<br/>    std_msgs::String msg;<br/>    std::stringstream ss;<br/>    ss &lt;&lt; "chatter messages: " &lt;&lt; chatter_count;<br/>    msg.data = ss.str();<br/>    ROS_INFO("%s", msg.data.c_str());<br/>    chatter_pub.publish(msg);<br/>    chatter_count++;<br/>  });<br/>  <br/>  ros::spin();</span><span id="24f1" class="mn lr it na b gy ni nf l ng nh">  return 0;<br/>}</span></pre><p id="862d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我修改了原始示例代码，在这里使用了一个<code class="fe nj nk nl na b">ros::Timer</code>来解释它。如下图，当我们创建一个定时器时，它会创建一个新的线程(姑且称之为“定时器线程”)。计时器线程不断将给定的回调添加到在初始化期间自动创建的回调队列中。在这个例子中，给定的回调被指定为lambda⁴函数。然后，当我们调用<code class="fe nj nk nl na b">ros::spin()</code>时，它不断从回调队列中获取回调，并在无限循环中逐个执行它们(充当“旋转”线程)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/9272f0aee6ba2e2e043617940083e50f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xc4BrVJqVW9OebNdoU5i6g.png"/></div></div></figure><p id="bf5e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在给定的回调函数(lambda函数)中，它创建一条消息，并使用计数器值发布该消息，该计数器值在每次调用回调函数时递增。计时器的频率设置为100赫兹(持续时间为0.01秒)。因此，计时器线程将每隔0.01秒将回调函数放入回调队列。请注意，在发布主题时，发布者队列的大小被指定为1000。如下图所示，发布者队列是另一个类似回调队列的队列，但是这个队列是用来对发布的消息进行排队的，每次调用<code class="fe nj nk nl na b">publish()</code>函数都会填充这个队列。</p><p id="f208" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有一个单独的线程负责从发布者队列获取消息，并将其发送给主题的订阅者(如果有订阅者的话)。如果调用<code class="fe nj nk nl na b">publish()</code>的速度比发布者线程发送消息的速度快，消息就会在发布者队列中堆积起来，如果超过了指定的队列大小(在本例中为1000)，旧消息就会被新消息覆盖。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/51c72472f1b4f20457b9f64ca57857ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SjZV0kE5s3o0npVPvORLIA.png"/></div></div></figure><h2 id="c773" class="mn lr it bd ls mo mp dn lw mq mr dp ma ld ms mt mc lh mu mv me ll mw mx mg my bi translated">听众</h2><p id="0bc1" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">侦听器节点实现的第一个版本如下所示。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4e3f" class="mn lr it na b gy ne nf l ng nh">#include "ros/ros.h"<br/>#include "std_msgs/String.h"</span><span id="9fb8" class="mn lr it na b gy ni nf l ng nh">void ChatterCallback(const std_msgs::String::ConstPtr&amp; msg) {<br/>  ROS_INFO(" I heard: [%s]", msg-&gt;data.c_str());<br/>}</span><span id="f386" class="mn lr it na b gy ni nf l ng nh">int main(int argc, char **argv) {<br/>  ros::init(argc, argv, "listener");<br/>  ros::NodeHandle n;</span><span id="cd6c" class="mn lr it na b gy ni nf l ng nh">  ros::Subscriber sub = n.subscribe("chatter", 1, ChatterCallback);<br/>  ros::spin();</span><span id="fa88" class="mn lr it na b gy ni nf l ng nh">  return 0;<br/>}</span></pre><p id="bd93" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如下所示，当侦听器节点初始化时，它会创建一个线程，负责接收它订阅的消息。每个订户都有一个队列，用于对传入消息进行排队。然后，注册到订户的相应回调与来自订户队列的消息一起被放入回调队列。</p><p id="b46e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有一个单独的线程(姑且称之为“Spinner thread”)负责从回调队列中取出回调，并逐个执行回调。与上面提到的发布者队列的情况类似，如果订阅者队列接收消息的频率比旋转者线程处理回调的频率高，则接收到的消息开始在订阅者队列中堆积。如果超过了指定的队列大小，订阅者队列中的旧消息将被新接收的消息覆盖。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/818efa4c853b5d360647d768e8a279c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wR402t0dola1RGfGqNQw-w.png"/></div></div></figure><p id="3318" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在此示例中，订户队列大小设置为1。这意味着它不将传入的消息排队，而是仅将单个最新的消息保存在订户队列中。如果您需要始终只处理延迟最小的最新消息(不需要等到队列中较旧的消息处理完毕)，并且如果您希望节省内存使用(对于订阅者队列)以换取丢弃消息的风险，那么这种方法是有效的。</p><p id="3dbd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这似乎是一种可以避免的折衷，但实际上，通过使用多线程(在下一节中讨论)，我们可以防止消息丢失，同时保持小订阅者队列的优势。</p><h1 id="451b" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">多旋转螺纹</h1><p id="801f" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在ROS中，我们可以增加spinner线程的数量，以便监听器节点可以更快地处理来自回调队列的回调，如下所示。这也意味着它可以更快地处理订户队列中的消息，因此我们可以防止旧消息被覆盖。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/1d6394af05b512be4d6e48ddc515a8e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*exyCqmQGl6y9CsQw3An77A.png"/></div></div></figure><p id="8b84" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要增加微调器线程的数量，您可以在监听器节点中使用如下所示的<code class="fe nj nk nl na b">ros::MultiThreadedSpinner</code>。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="34ad" class="mn lr it na b gy ne nf l ng nh">void ChatterCallback(const std_msgs::String::ConstPtr&amp; msg) {<br/>  ROS_INFO(" I heard: [%s]", msg-&gt;data.c_str());<br/>  std::this_thread::sleep_for(0.02s);<br/>}</span><span id="5f45" class="mn lr it na b gy ni nf l ng nh">int main(int argc, char **argv) {<br/>  ros::init(argc, argv, "listener");<br/>  ros::NodeHandle n;</span><span id="c23a" class="mn lr it na b gy ni nf l ng nh">  ros::Subscriber sub = n.subscribe("chatter", 1, ChatterCallback);<br/>  <br/>  <strong class="na iu">ros::MultiThreadedSpinner spinner(2);<br/>  spinner.spin();</strong></span><span id="c536" class="mn lr it na b gy ni nf l ng nh">  return 0;<br/>}</span></pre><p id="867c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">规定使用两个旋转器螺纹。理论上，这应该可以防止消息丢失。然而，如果我们再次执行谈话者和收听者节点，收听者节点仍然会丢弃一些消息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/135021a99633352a313259daca186d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3pWg7ri0w-oJHHfYrvDfMA.png"/></div></div></figure><p id="88f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">原因是因为ROS默认防止一个注册在一个订阅者的回调被多个线程同时调用。因此，即使有2个spinner线程处理来自回调队列的回调，它们也不能同时执行<code class="fe nj nk nl na b">ChatterCallback</code>。一个spinner线程总是必须等待另一个线程完成执行，这就是为什么它没有提高处理回调的吞吐量。</p><p id="ccd5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了解决这个问题，我们可以指定让<code class="fe nj nk nl na b">ChatterCallback</code>可以被并发调用。所需更改后的实现如下所示。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f729" class="mn lr it na b gy ne nf l ng nh">void ChatterCallback(const std_msgs::String::ConstPtr&amp; msg) {<br/>  ROS_INFO(" I heard: [%s]", msg-&gt;data.c_str());<br/>  std::this_thread::sleep_for(0.02s);<br/>}</span><span id="7bfa" class="mn lr it na b gy ni nf l ng nh">int main(int argc, char **argv) {<br/>  ros::init(argc, argv, "listener");<br/>  ros::NodeHandle n;</span><span id="f24d" class="mn lr it na b gy ni nf l ng nh">  <strong class="na iu">ros::SubscribeOptions ops;<br/>  ops.template init&lt;std_msgs::String&gt;("chatter", 1, ChatterCallback);<br/>  ops.allow_concurrent_callbacks = true;<br/>  ros::Subscriber sub1 = n.subscribe(ops);</strong></span><span id="448e" class="mn lr it na b gy ni nf l ng nh">  ros::MultiThreadedSpinner spinner(2);<br/>  spinner.spin();</span><span id="9b49" class="mn lr it na b gy ni nf l ng nh">  return 0;<br/>}</span></pre><p id="d8c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过这种改变，两个spinner线程可以同时执行<code class="fe nj nk nl na b">ChatterCallback</code>，因此listener节点可以处理消息而不会丢弃任何消息。</p><h1 id="36e0" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">多个回调队列</h1><p id="867f" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">到目前为止，我们讨论了侦听器节点只订阅一个主题的情况。然而，在实践中，一个典型的节点订阅多个主题，因此它有多个订阅者队列，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/c09880a8703b18c4935120b379b1a7f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zEBn_D7IOZlTWf-bnr3nuA.png"/></div></div></figure><p id="64bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这可能会带来新的问题，当侦听器节点只订阅一个主题时，我们不会面临这个问题。让我们假设监听器节点订阅主题A和B，如上所示。并且假设消息A是重要消息，一旦监听器节点接收到它，就必须对其进行处理。另一方面，消息B是比消息a更频繁发送的不太重要的消息</p><p id="5675" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如下所示，如果只有一个回调队列是FIFO队列(先进先出)，则在消息B的所有三个回调都被处理之前，消息A的回调不能被处理。如前所述，这个问题可以通过创建多个spinner线程来缓解，但是它不能完全解决由单个回调队列引起的问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/df7fb2ecd7d49e4d1c12780179492ed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JJr0rLOESf7xVA-t9sY24A.png"/></div></div></figure><p id="b394" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了解决这个问题，我们可以创建一个单独的回调队列和spinner线程，它专用于消息A，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/80aee7bef2ede9c4970c6ed622581c56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KyskEVrKEWY3PN9mDNvJXQ.png"/></div></div></figure><p id="3838" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过拥有专用的回调队列和spinner线程，消息A的回调将得到处理，而不会被不太重要的其他消息的回调所阻塞。</p><p id="783b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实现如下所示，</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bab6" class="mn lr it na b gy ne nf l ng nh">#include &lt;thread&gt;<br/>#include &lt;ros/callback_queue.h&gt;<br/>#include "ros/ros.h"<br/>#include "std_msgs/String.h"</span><span id="55fa" class="mn lr it na b gy ni nf l ng nh">void CallbackA(const std_msgs::String::ConstPtr&amp; msg) {<br/>  ROS_INFO(" I heard: [%s]", msg-&gt;data.c_str());<br/>}</span><span id="d9b2" class="mn lr it na b gy ni nf l ng nh">void CallbackB(const std_msgs::String::ConstPtr&amp; msg) {<br/>  ROS_INFO(" I heard: [%s]", msg-&gt;data.c_str());<br/>}</span><span id="a89b" class="mn lr it na b gy ni nf l ng nh">int main(int argc, char **argv) {<br/>  ros::init(argc, argv, "listener");<br/>  ros::NodeHandle n;<br/>  ros::Subscriber sub_b = n.subscribe("MessageB", 1, CallbackB);<br/>  <br/><strong class="na iu">  ros::NodeHandle n_a;</strong></span><span id="34d8" class="mn lr it na b gy ni nf l ng nh"><strong class="na iu">  ros::CallbackQueue callback_queue_a;<br/>  n_a.setCallbackQueue(&amp;callback_queue_a);<br/>  ros::Subscriber sub_a = n_a.subscribe("MessageA", 1, CallbackA);</strong></span><span id="f630" class="mn lr it na b gy ni nf l ng nh"><strong class="na iu">  std::thread spinner_thread_a([&amp;callback_queue_a]() {<br/>    ros::SingleThreadedSpinner spinner_a;<br/>    spinner_a.spin(&amp;callback_queue_a);<br/>  });</strong></span><span id="d6e9" class="mn lr it na b gy ni nf l ng nh">  ros::spin();<br/>  <strong class="na iu">spinner_thread_a.join();</strong></span><span id="1a7e" class="mn lr it na b gy ni nf l ng nh">  return 0;<br/>}</span></pre><p id="a2f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它为消息A创建一个单独的节点句柄。然后，它为节点句柄设置一个新创建的回调队列，该队列专用于消息A。此外，它使用节点句柄创建一个订阅者，并最终创建一个处理回调队列的独立线程，充当一个专用于消息a的独立旋转线程。</p><h1 id="568b" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">摘要</h1><p id="4b53" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在这篇文章中，我解释了ROS中使用的执行模型、线程、队列的概念，尤其是与它的发布者-订阅者模式相关的概念。我们还讨论了队列大小、旋转线程数量、队列数量及其影响的不同可能配置。没有放之四海而皆准的解决方案，但是理解这些概念和权衡是很重要的，这样您就可以决定什么最适合您的应用。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="8456" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">[1]:<a class="ae ob" href="https://www.ros.org/" rel="noopener ugc nofollow" target="_blank">https://www.ros.org/</a></p><p id="4058" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">[2]:<a class="ae ob" href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Publish % E2 % 80% 93 subscribe _ pattern</a></p><p id="2bc9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">[3]:<a class="ae ob" href="http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber%28c%2B%2B%29" rel="noopener ugc nofollow" target="_blank">http://wiki . ROS . org/ROS/Tutorials/writing publisher subscriber % 28c % 2B % 2B % 29</a></p><p id="b71b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">【4】:<a class="ae ob" href="https://en.cppreference.com/w/cpp/language/lambda" rel="noopener ugc nofollow" target="_blank">https://en.cppreference.com/w/cpp/language/lambda</a></p><p id="57d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae ob" href="https://github.com/rjhcnf/ros_tutorial" rel="noopener ugc nofollow" target="_blank">帖子中使用的示例代码的链接。</a></p></div></div>    
</body>
</html>