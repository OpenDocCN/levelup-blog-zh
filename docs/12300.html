<html>
<head>
<title>How to Deploy a Lambda Function as a Container Image: Docker + SAM + ECR</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将Lambda函数部署为容器映像:Docker + SAM + ECR</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-deploy-a-lambda-function-as-a-container-image-docker-sam-ecr-2846809f90e1?source=collection_archive---------1-----------------------#2022-05-30">https://levelup.gitconnected.com/how-to-deploy-a-lambda-function-as-a-container-image-docker-sam-ecr-2846809f90e1?source=collection_archive---------1-----------------------#2022-05-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/024113dad37b0c8e7d85e8f93554b6e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t49-NZsv-8SyG4iZcTiRdA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@carrier_lost?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">伊恩·泰勒</a>在<a class="ae kc" href="https://unsplash.com/s/photos/container?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="a38f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如标题所示，这篇文章将演示如何使用Docker、SAM(无服务器应用程序模型)和ECR(弹性容器注册中心)将Lambda函数部署为容器映像。</p><p id="5873" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇教程将建立在<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/deploy-a-python-cron-job-to-aws-lambda-with-sam-5d05f0c17a89">之前的文章</a>的基础上。因此，建议遵循，否则将假设AWS Lambda和SAM的先决知识。</p><p id="1b27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们继续吧。</p><h1 id="d088" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">先决条件:</h1><ul class=""><li id="8cb4" class="lz ma iq kf b kg mb kk mc ko md ks me kw mf la mg mh mi mj bi translated">IDE(即PyCharm)</li><li id="2ed4" class="lz ma iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated"><a class="ae kc" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-welcome.html" rel="noopener ugc nofollow" target="_blank">安装并配置AWS CLI</a></li><li id="3828" class="lz ma iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated"><a class="ae kc" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html" rel="noopener ugc nofollow" target="_blank">安装和配置AWS SAM CLI</a></li><li id="887b" class="lz ma iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated"><a class="ae kc" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank"> Docker安装和配置</a></li><li id="5d61" class="lz ma iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated">本地编码的Lambda函数/应用程序</li></ul><h1 id="b2cf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">步骤1:创建Dockerfile文件</h1><p id="9ff1" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">让我们假设你的回购目录结构看起来像这样(从<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/deploy-a-python-cron-job-to-aws-lambda-with-sam-5d05f0c17a89">这篇文章中可以看出)</a>:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="bee2" class="nb lc iq mx b gy nc nd l ne nf">.<br/>├── app.py<br/>├── requirements.txt<br/>├── samconfig.toml<br/>└── template.yaml</span></pre><p id="6fb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，与<a class="ae kc" href="https://awstip.com/deploy-a-lambda-layer-and-function-together-via-sam-e95e29194ef7" rel="noopener ugc nofollow" target="_blank">这篇文章</a>不同，我们不会创建子目录或排除requirements.txt文件。</p><p id="ff5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在同一个目录中，我们将创建一个Dockerfile文件。</p><p id="bdaa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个Dockerfile可以叫做<strong class="kf ir"> Dockerfile </strong>(不需要文件扩展名)。</p><p id="dc4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在此Dockerfile文件中，粘贴以下内容:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="3991" class="nb lc iq mx b gy nc nd l ne nf">FROM public.ecr.aws/lambda/python:3.9</span><span id="da84" class="nb lc iq mx b gy ng nd l ne nf">ARG wd=/var/task/</span><span id="a5e2" class="nb lc iq mx b gy ng nd l ne nf">COPY app.py requirements.txt ${wd}</span><span id="1bf6" class="nb lc iq mx b gy ng nd l ne nf">RUN python3.9 -m pip install -r requirements.txt -t "${wd}"</span><span id="fde7" class="nb lc iq mx b gy ng nd l ne nf"># Command can be overwritten by providing a different command in the template directly.<br/>CMD ["app.lambda_handler"]</span></pre><p id="981d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的目录现在应该是这样的:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="571d" class="nb lc iq mx b gy nc nd l ne nf">.<br/>├── Dockerfile<br/>├── app.py<br/>├── requirements.txt<br/>├── samconfig.toml<br/>└── template.yaml</span></pre><p id="ca1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，回到文档。里面发生了什么事？</p><p id="306d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">FROM命令从Amazon的ECR(弹性容器注册表)中拉出“base”<a class="ae kc" href="https://gallery.ecr.aws/lambda/python" rel="noopener ugc nofollow" target="_blank">图像</a>。</p><p id="bc33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ARG命令不是必需的，但我插入它是为了给COPY和RUN命令创建一个变量。</p><p id="9d0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">COPY命令将引用的文件(<a class="ae kc" href="http://app.py" rel="noopener ugc nofollow" target="_blank"> app.py </a>和requirements.txt)“复制”到指定的路径，该路径为<strong class="kf ir">/var/task</strong>(<strong class="kf ir">wd</strong>变量的值)。在AWS文档的<a class="ae kc" href="https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-create-from-base" rel="noopener ugc nofollow" target="_blank">中，您可能会发现它被引用为LAMBDA_TASK_ROOT环境变量。</a></p><p id="5fd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我特别需要用ARG命令创建自己的变量，这是有原因的，我们稍后会了解。</p><h1 id="ff7f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">步骤2:构建Docker映像</h1><p id="9844" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">现在，如果您运行<code class="fe nh ni nj mx b">sam build -u</code>来构建您的部署包，docker文件实际上将被忽略。这是因为我们需要在我们的<strong class="kf ir"> template.yaml </strong>中指定我们的包是一个图像。</p><p id="e166" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面显示了修改后的<strong class="kf ir"> template.yaml </strong>的一个片段:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="6c5c" class="nb lc iq mx b gy nc nd l ne nf">Resources:<br/>  Function:<br/>    Type: 'AWS::Serverless::Function'<br/>    Properties:<br/>      FunctionName: Weekly_Pocket_Readtime_Tagger<br/>      Description: &gt;<br/>        Lambda function which tags unread articles (saved in the last 7 days) in my Pocket based on read-time.<br/>      PackageType: Image<br/>      Timeout: 300</span></pre><p id="c231" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以前，当我们的包是一个Zip文件时，相同的<strong class="kf ir"> template.yaml </strong>片段看起来像这样:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="800f" class="nb lc iq mx b gy nc nd l ne nf">Resources:<br/>  Function:<br/>    Type: 'AWS::Serverless::Function'<br/>    Properties:<br/>      FunctionName: Weekly_Pocket_Readtime_Tagger<br/>      Description: &gt;<br/>        Lambda function which tags unread articles (saved in the last 7 days) in my Pocket based on read-time.<br/>      Handler: app.lambda_handler<br/>      Runtime: python3.9<br/>      Timeout: 300</span></pre><p id="1392" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不同的是我们增加了<em class="nk">的</em>和<strong class="kf ir">的</strong>和<em class="nk">的</em>和<strong class="kf ir">的句柄和运行时。</strong></p><p id="17cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除此之外，我们实际上需要引用我们的DockerFile，这将通过下面的<strong class="kf ir"> template.yaml </strong>片段来完成:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="f424" class="nb lc iq mx b gy nc nd l ne nf">Metadata:<br/>  Dockerfile: Dockerfile<br/>  DockerContext: .</span></pre><p id="d6bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将放在模板的函数层下。</p><p id="ef4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Dockerfile参数指定Dockerfile的名称，DockerContext指定Dockerfile的路径。</p><p id="d398" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在您可以再次运行<code class="fe nh ni nj mx b">sam build -u</code>，并且您应该看到(在您的终端输出中)从docker文件构建的图像。</p><p id="ec46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它可能看起来像这样:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="1678" class="nb lc iq mx b gy nc nd l ne nf">Building image for Function function<br/>Setting DockerBuildArgs: {} for Function function<br/>Step 1/5 : FROM public.ecr.aws/lambda/python:3.9<br/> ---&gt; f1904097ad08<br/>Step 2/5 : ARG wd=/var/task/<br/> ---&gt; Using cache<br/> ---&gt; 82b27994b22d<br/>Step 3/5 : COPY app.py requirements.txt ${wd}<br/> ---&gt; Using cache<br/> ---&gt; 53814baeed22<br/>Step 4/5 : RUN python3.9 -m pip install -r requirements.txt -t "${wd}"<br/> ---&gt; Using cache<br/> ---&gt; 10f84558dd04<br/>Step 5/5 : CMD ["app.lambda_handler"]<br/> ---&gt; Using cache<br/> ---&gt; ae0d33704abe<br/>Successfully built ae0d33704abe<br/>Successfully tagged function:latest</span></pre><p id="da14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了在本地测试这个函数，运行<code class="fe nh ni nj mx b">sam local invoke</code>,就像我们对待一个Zip包一样。</p><h1 id="c118" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">步骤3:创建ECR存储库</h1><p id="02a8" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">因此，我们已经构建并测试了我们的映像，现在我们需要创建一个存储库，我们将在其中上传这个映像。</p><p id="6952" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要创建repo，请键入如下命令:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="44ef" class="nb lc iq mx b gy nc nd l ne nf">aws ecr create-repository --repository-name &lt;REPO_NAME&gt;</span></pre><p id="c50e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于稍后您将需要使用repo URI，您还可以在上面的命令后面附加一些JMESpath来解析响应中的URI，如下所示:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="a92b" class="nb lc iq mx b gy nc nd l ne nf">aws ecr create-repository --repository-name &lt;REPO_NAME&gt; --query 'repository.repositoryUri' &gt; repoUri.txt</span></pre><p id="8849" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将把<strong class="kf ir">存储库yUri </strong>输出到一个名为repoUri.txt的文件中。</p><p id="572d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在部署中使用这个储存库尤里。</p><h1 id="52fd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">步骤4:部署Docker映像</h1><p id="93cc" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">运行<code class="fe nh ni nj mx b">sam deploy -g</code>。您将会看到大多数相同的提示，就好像我们正在部署一个Zip一样，但是您还会<strong class="kf ir">和</strong>看到以下内容:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="8cb8" class="nb lc iq mx b gy nc nd l ne nf">Looking for resources needed for deployment:<br/>Managed S3 bucket: &lt;SOME_BUCKET&gt;<br/>A different default S3 bucket can be set in samconfig.toml<br/>Image repositories: Not found.<br/>#Managed repositories will be deleted when their functions are removed from the template and deployed<br/>Create managed ECR repositories for all functions? [Y/n]:</span></pre><p id="f732" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意最后一行的提示是:</p><p id="3ed3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nh ni nj mx b">Create managed ECR repositories for all functions? [Y/n]:</code></p><p id="1e62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在这里，我们可以用<strong class="kf ir"> Y、</strong>来响应，在这种情况下，AWS将为我们创建一个ECR回购(使用一个不太好的名称)，或者我们可以用<strong class="kf ir"> N </strong>来响应，并输入我们自己的回购URI。我们将执行后者，因此输入<strong class="kf ir"> N. </strong></p><p id="7288" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一个提示将是<code class="fe nh ni nj mx b">ECR repository for Function:</code>,这是您粘贴之前的<strong class="kf ir">储存库yUri </strong>的地方。</p><p id="e29c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">进入URI并继续部署后，您可能会看到类似下面的内容:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="0615" class="nb lc iq mx b gy nc nd l ne nf">092e319c29f0: Pushed <br/>a655d2aa16d4: Pushed <br/>d6b9d3aa40bb: Pushed <br/>a7690775ba55: Pushed <br/>159cfb847db8: Pushed <br/>4bc74a3077fd: Pushed <br/>4465b476f1b1: Pushed <br/>e5bfcec20402: Pushed <br/>function-ae0d33704abe-latest: digest: sha256:dcaa0ba9c4a7bf554e2eb2a9095e907853cf11d07dd8c0e5f43fc0bf8dad1303 size: 2000</span></pre><p id="e3e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些sha中的每一个都是映像的不同层。</p><p id="3088" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据的解释:</p><blockquote class="nl nm nn"><p id="9418" class="kd ke nk kf b kg kh ki kj kk kl km kn no kp kq kr np kt ku kv nq kx ky kz la ij bi translated"><em class="iq"> Docker图像由几层组成。每一层对应你</em> <code class="fe nh ni nj mx b"><em class="iq">Dockerfile</em></code> <em class="iq">中的某些指令。下面的指令创建一个图层:</em><code class="fe nh ni nj mx b"><em class="iq">RUN</em></code><em class="iq"/><code class="fe nh ni nj mx b"><em class="iq">COPY</em></code><em class="iq"/><code class="fe nh ni nj mx b"><em class="iq">ADD</em></code><em class="iq">。其他指令将创建中间层，不会影响图像的大小。</em></p></blockquote><p id="9479" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我推断前6层(共8层)是Dockerfile中的<code class="fe nh ni nj mx b">FROM public.ecr.aws/lambda/python:3.9</code>命令的结果(通过运行<code class="fe nh ni nj mx b">sam build</code>和<code class="fe nh ni nj mx b">sam deploy</code>而不是本文前面的COPY或RUN命令)。反过来，我们可以假设第7层和第8层<strong class="kf ir">分别来自复制和运行命令</strong>。</p><p id="1372" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，在图像标签上，我们可以从上面的终端输出看到是<code class="fe nh ni nj mx b">function-ae0d33704abe-latest</code>。</p><p id="a1cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一部分，<code class="fe nh ni nj mx b">function</code> <strong class="kf ir">，</strong>只是template.yaml中<strong class="kf ir">函数</strong>参数的小写形式。</p><p id="722a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nh ni nj mx b">ae0d33704abe</code>段是一个SHA片段，根据<a class="ae kc" href="https://github.com/aws/aws-sam-cli/issues/2600#issuecomment-776129692" rel="noopener ugc nofollow" target="_blank">Github问题注释</a>，它将始终是标签的一部分。</p><p id="4a4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，<code class="fe nh ni nj mx b">latest</code>是我们可以在template.yaml中指定的Dockertag，但默认为<strong class="kf ir"> latest。</strong></p><p id="afd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您通过Docker构建和部署您的映像(我指的是运行Docker命令，而不是SAM)，您将能够只使用最后一部分(即<strong class="kf ir">最新</strong>或另一个名称)来标记您的映像。这不在这篇文章的讨论范围之内。</p><p id="1a81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">将</strong>在这篇文章的范围内是如何指定一个Dockertag <strong class="kf ir">在</strong>模板. yaml之外</p><p id="06d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们预见到有几个标签对应于不同的图像，每次编辑template.yaml是不方便的。</p><p id="9379" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，什么是替代方案呢？</p><h1 id="2926" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">步骤5:手动标记图像</h1><p id="1254" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在template.yaml中，在<strong class="kf ir">资源</strong>之前(在<strong class="kf ir">描述</strong>之后)，输入以下内容:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="41eb" class="nb lc iq mx b gy nc nd l ne nf">Parameters:<br/>  Tag:<br/>    Type: String<br/>    Default: latest<br/>    Description: Docker tag to build and deploy.</span></pre><p id="9ec8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这创建了一个名为<strong class="kf ir">标签</strong>的参数，它可以在模板的其他地方被引用。</p><p id="b585" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<a class="ae kc" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-ref.html" rel="noopener ugc nofollow" target="_blank">在DockerTag部分引用它</a>作为<strong class="kf ir">元数据的一部分，如下所示:</strong></p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="47fa" class="nb lc iq mx b gy nc nd l ne nf">Metadata:<br/>  Dockerfile: Dockerfile<br/>  DockerContext: .<br/>  DockerTag: !Ref Tag</span></pre><p id="f931" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能还记得，在这篇文章中，我们从来没有在模板中使用过<strong class="kf ir"> DockerTag </strong>。因为它不在那里，默认为前面提到的<strong class="kf ir">最新</strong>，并且作为我们指定的新<strong class="kf ir">标签</strong>参数的一部分，我们也可以指定我们自己的<strong class="kf ir">默认</strong>标签(我们将保留它为<strong class="kf ir">最新</strong>)。</p><p id="ecf0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">覆盖<strong class="kf ir">标签</strong>参数将是构建的一部分，我们的命令看起来像这样:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="f812" class="nb lc iq mx b gy nc nd l ne nf">sam build -u --parameter-overrides 'Tag=TAG_GOES_HERE'</span></pre><p id="49d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">标记的名称将代替上面代码片段中的<strong class="kf ir"> TAG_GOES_HERE </strong>。你可以在这里阅读更多关于<code class="fe nh ni nj mx b">sam build</code>选项<a class="ae kc" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-cli-command-reference-sam-build.html" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="60bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个构建之后，您将像往常一样运行<code class="fe nh ni nj mx b">sam deploy</code>,将函数部署为带有被覆盖标签的图像。</p><h1 id="bcb0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="e6c8" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">嗯，我们做到了！我们已经部署了一个Lambda函数作为容器映像，这将允许我们上传更大的部署包(即更大的函数或更大的依赖项)。我在使用像Numpy和Pandas这样的库部署一个函数时遇到了问题，所以这是一个很好的方法，如果你也在做同样的事情，它会派上用场，而且你还需要学习一些关于容器化的知识！</p><p id="17c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读，我希望这有所帮助，并找到下面的参考资料，以探索更多！</p><h1 id="a8b3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">参考资料:</h1><ul class=""><li id="87f3" class="lz ma iq kf b kg mb kk mc ko md ks me kw mf la mg mh mi mj bi translated"><a class="ae kc" href="https://aws.amazon.com/de/blogs/aws/new-for-aws-lambda-container-image-support/?nc1=b_rp" rel="noopener ugc nofollow" target="_blank">AWS Lambda的新增功能—容器图像支持</a></li><li id="55d4" class="lz ma iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated"><a class="ae kc" href="https://aws.amazon.com/blogs/compute/using-container-image-support-for-aws-lambda-with-aws-sam/?utm_source=pocket_mylist" rel="noopener ugc nofollow" target="_blank">通过AWS SAM对AWS Lambda使用容器映像支持</a></li><li id="1a48" class="lz ma iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated">亚马逊弹性容器注册公共:一个新的公共容器注册</li><li id="a4a8" class="lz ma iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated"><a class="ae kc" href="https://docs.aws.amazon.com/lambda/latest/dg/images-test.html" rel="noopener ugc nofollow" target="_blank">在本地测试Lambda容器映像</a></li><li id="e4ce" class="lz ma iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated"><a class="ae kc" href="https://docs.aws.amazon.com/lambda/latest/dg/python-image.html" rel="noopener ugc nofollow" target="_blank">用容器映像部署Python Lambda函数</a></li><li id="7ff3" class="lz ma iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated"><a class="ae kc" href="https://github.com/aws/aws-lambda-base-images" rel="noopener ugc nofollow" target="_blank"> AWS Lambda基础图片Github </a></li><li id="c7fc" class="lz ma iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated"><a class="ae kc" href="https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-create-from-base" rel="noopener ugc nofollow" target="_blank">从AWS基础图像创建图像</a></li><li id="5506" class="lz ma iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated"><a class="ae kc" href="https://docs.docker.com/engine/reference/commandline/build/" rel="noopener ugc nofollow" target="_blank"> Docker构建</a></li><li id="1a23" class="lz ma iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated"><a class="ae kc" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-usage-filter.html#cli-usage-filter-client-side" rel="noopener ugc nofollow" target="_blank">过滤AWS CLI输出</a></li><li id="609b" class="lz ma iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated"><a class="ae kc" href="https://jmespath.org/" rel="noopener ugc nofollow" target="_blank">JMS path</a></li><li id="9e51" class="lz ma iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated"><a class="ae kc" href="https://github.com/aws/aws-sam-cli/issues/2600#issuecomment-776129692" rel="noopener ugc nofollow" target="_blank">带SHA的SAM图像标签</a></li><li id="abd4" class="lz ma iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated"><a class="ae kc" href="https://dzone.com/articles/docker-layers-explained" rel="noopener ugc nofollow" target="_blank">Docker图像中的图层</a></li><li id="641a" class="lz ma iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated"><a class="ae kc" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-cli-command-reference-sam-build.html" rel="noopener ugc nofollow" target="_blank">山姆建造选项</a></li><li id="2750" class="lz ma iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated"><a class="ae kc" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-ref.html" rel="noopener ugc nofollow" target="_blank"> Ref固有函数</a></li></ul></div></div>    
</body>
</html>