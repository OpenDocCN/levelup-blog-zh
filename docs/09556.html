<html>
<head>
<title>Practical DDD in Golang: Entity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">戈朗的实用DDD:实体</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/practical-ddd-in-golang-entity-40d32bdad2a3?source=collection_archive---------0-----------------------#2021-08-22">https://levelup.gitconnected.com/practical-ddd-in-golang-entity-40d32bdad2a3?source=collection_archive---------0-----------------------#2021-08-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="bf37" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">领域驱动设计</h2><div class=""/><div class=""><h2 id="b9d5" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">围棋中关于DDD的故事继续呈现了一个最常见的积木——实体。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/c661a0ecec01e59189e2085f9a3b9fe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NGNu70uSWdUz13ysJAP5Rg.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">乔治·普伦查斯在<a class="ae lh" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>的照片</figcaption></figure><p id="7b90" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-value-object-4fc97bcad70">的上一篇文章</a>中，我试图给出一些关于价值对象设计模式的见解，以及我们应该如何在Go中使用它。在这一个中，故事继续着一个叫做实体的设计模式。</p><p id="812f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">许多开发人员听说过实体上千次，即使他们从未使用过DDD的方法。一些例子在PHP <a class="ae lh" href="https://symfony.com/doc/3.3/doctrine.html#creating-an-entity-class" rel="noopener ugc nofollow" target="_blank">框架</a>中，一些在<a class="ae lh" href="https://docs.oracle.com/javaee/6/tutorial/doc/bnbqa.html" rel="noopener ugc nofollow" target="_blank"> Java </a>中。虽然看起来一样，但它在DDD的目的是不同的。</p><p id="b899" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">了解它在DDD的目的对我来说是一种突破。这看起来有点奇怪，特别是对于有PHP MVC框架背景的人来说，但是今天DDD的方法似乎更符合逻辑。</p><h1 id="660e" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">它不是ORM的一部分。</h1><p id="5b0d" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">正如我们在PHP和Java框架的例子中看到的，实体扮演了许多构建模块的角色，从<a class="ae lh" href="https://www.martinfowler.com/eaaCatalog/rowDataGateway.html" rel="noopener ugc nofollow" target="_blank">行数据网关</a>到<a class="ae lh" href="https://www.martinfowler.com/eaaCatalog/activeRecord.html" rel="noopener ugc nofollow" target="_blank">活动记录</a>。由于这个事实，导致了实体模式的误用。</p><p id="be88" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">实体的目的不是反映表方案，而是保持基本的业务逻辑。每当我在某个应用程序上工作时，我的实体并不镜像数据库。</p><p id="20a9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">说到实现，首先，我总是提供域层。在那里，我想把完整的业务逻辑耦合在一起，用实体、值对象和服务来构造。</p><p id="da8d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦我完成了业务逻辑并覆盖了单元测试，我就开始为基础设施层提供技术细节，比如到数据库的连接。</p><p id="286c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就像你在下面的例子中看到的，我们将实体从它在数据库中的表示中分离出来。镜像数据库模式的对象是独立的，它们更尊重<a class="ae lh" href="https://www.martinfowler.com/eaaCatalog/dataTransferObject.html" rel="noopener ugc nofollow" target="_blank">数据传输对象</a>。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">实体与数据库分离的示例</figcaption></figure><p id="1bac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的例子是我们可以提供的许多变化之一。尽管实体和DTO的结构可以不同，这取决于我们想要的商业案例(比如每个<code class="fe nd ne nf ng b">BankAccount</code>有更多的<code class="fe nd ne nf ng b">Wallets</code>),但想法总是相同的。</p><p id="b7ba" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们总是在领域层保留<a class="ae lh" href="https://www.martinfowler.com/eaaCatalog/repository.html" rel="noopener ugc nofollow" target="_blank">存储库</a>接口。在这一层(我使用的分层架构中的底层)，一些域服务可能依赖于它们。所以，他们至少应该意识到自己的存在。</p><p id="733e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">存储库提供了一个契约，保证我们将从我们的领域层处理实体对象，至少在外部。在Repository中，我们可以处理任何我们想要的东西，只要我们提供准确的结果。</p><p id="0d9d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有了这种结构，我总是设法将我的业务逻辑从下面的存储中分离出来。只要我需要对数据库进行一些更改，就必须更改映射方法，该方法将d to转换为实体，反之亦然。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">实体的一些例子</figcaption></figure><p id="0bcc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有时候，实体会反映复杂的业务逻辑，数据来自多个地方，比如数据库、<a class="ae lh" href="https://aws.amazon.com/nosql/" rel="noopener ugc nofollow" target="_blank"/>和一些外部API。特别是在那些情况下，将业务层从技术细节中分离出来的想法是非常值得的。</p><h1 id="13b9" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">身份</h1><p id="905b" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">与值对象的主要区别是身份。实体有身份。身份是实体的唯一属性，可以定义每个实体的唯一性。</p><p id="45d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">两个实体在其一个或多个领域中可能只有一个微小的差异。如果他们有相同的身份，那么我们谈论的是同一个实体。为此，当我们检查它们的相等性时，我们只检查它们的身份。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="93f2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有三种身份。它们可以是应用程序生成的。这意味着，在将它们发送到存储设备进行创建之前，我们会为它们创建一个新的身份。在这种情况下，我使用<a class="ae lh" href="https://duo.com/labs/tech-notes/breaking-down-uuids" rel="noopener ugc nofollow" target="_blank">uuid</a>。</p><p id="dfe1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第二种可能是使用自然身份。每当我们想与现实世界中具有某种独特属性的人或物打交道时，我们都可以操纵他们的生物标识符。例如，这可以是社会安全号码。</p><p id="e8de" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第三，最常见的方式是数据库生成的身份。即使当我处于实施前两种解决方案的位置时，我也采用这种方法。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">不同类型的身份</figcaption></figure><p id="242f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于索引和查询，我喜欢只用数字。在许多情况下，当处理应用程序生成的键或自然键时，我们应该处理文本或找到某种方法将这些文本正确地映射到数据库中的数值。</p><p id="000b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于同一性是实体和价值对象之间的主要区别，你可能会猜测这条分界线我们可以很容易地抹去。事实上，根据<a class="ae lh" href="https://martinfowler.com/bliki/BoundedContext.html" rel="noopener ugc nofollow" target="_blank">有界上下文</a>，一个对象可以很容易地从实体切换到值对象。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">相同的目标但有两个目的</figcaption></figure><p id="0521" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就像上面的例子一样，<code class="fe nd ne nf ng b">Currency</code>可以在一个有界的上下文中扮演中心实体的角色。那可以是一个<code class="fe nd ne nf ng b">Transaction Service</code>或者<code class="fe nd ne nf ng b">Exchange Service</code>。但是，在我们需要在UI中格式化的地方，<code class="fe nd ne nf ng b">Currency</code>可以作为一个简单的值对象使用。</p><h1 id="42e3" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">确认</h1><p id="857c" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">与值对象相反，实体可以在其生命周期内改变其状态。这意味着每当我们想要改变一个实体时，它需要不断的验证检查。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">简单验证示例</figcaption></figure><p id="a6e3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">是的，我知道。在上面的例子中，我们可以直接访问<code class="fe nd ne nf ng b">Wallet</code>，并通过避免方法<code class="fe nd ne nf ng b">Add</code>来改变它。我不太喜欢围棋里的<a class="ae lh" href="https://www.freecodecamp.org/news/java-getters-and-setters/" rel="noopener ugc nofollow" target="_blank">getter和setter</a>。我发现让许多函数返回或设置值是不可维护的。</p><p id="80d8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这些情况下，我更依赖所有工程师的理智来认识到如果方法已经存在，他们应该如何改变实体的状态。</p><p id="3254" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不过，这是我留给每个开发人员自己决定的话题。使用带有私有字段的getters和setters也是成功的解决方案。</p><h1 id="ae2b" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">推动行为</h1><p id="96aa" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">DDD的全部目的是尽可能地反映业务流程。正因为如此，当我们看到许多方法是我们领域层的一部分时，我们不会感到惊讶。</p><p id="bfd8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些方法可以属于不同的对象。由于实体将最复杂的状态保留在所有其他代码块之外，因此它们也可能拥有最多的函数来表示其丰富的行为。</p><p id="2ba9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在某些情况下，我们可能会注意到实体中的几个字段经常相互作用。每当我们在一个业务不变量中使用其中一个时，我们可能也需要另一个。</p><p id="0305" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这些情况下，我们总是可以将这样的字段组合成一个单独的值对象，并将其交给实体来处理。我们需要小心地这样做，以避免实体和值对象之间的关注点分离不清楚的情况。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">逻辑分离不清晰</figcaption></figure><p id="c187" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，我们可以检查从<code class="fe nd ne nf ng b">Wallet</code>值对象中承担更多责任的<code class="fe nd ne nf ng b">BankAccount</code>实体。当我们问<code class="fe nd ne nf ng b">BankAccount</code>是否被锁定时，这部分是清楚的。但是，检查<code class="fe nd ne nf ng b">Currency</code>是否相等以及<code class="fe nd ne nf ng b">Wallet</code>中是否有足够的数量是一种代码气味。</p><p id="eb9c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这些情况下，我将完整的演绎逻辑转移到值对象，当然，除了检查<code class="fe nd ne nf ng b">BankAccount</code>是否被锁定。就像这样，Wallet得到它的那部分代码来验证和扣除金额。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">实体与价值对象之间逻辑的适当分离</figcaption></figure><p id="11d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">像这样，<code class="fe nd ne nf ng b">Wallet</code>值对象可以属于任何其他实体或值对象，它仍然可以支持演绎，这取决于它的内部状态。另一方面，<code class="fe nd ne nf ng b">BankAccount</code>可以为锁定帐户提供额外的金额扣除方法，而无需复制相同的逻辑。</p><p id="edd4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个实体可以将其行为推送到其他构建模块，如<a class="ae lh" href="http://gorodinski.com/blog/2012/04/14/services-in-domain-driven-design-ddd/" rel="noopener ugc nofollow" target="_blank">域服务</a>(将在下一篇文章中介绍)。我在两种情况下将这些方法转移到服务中。</p><p id="dd1d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第一种情况是当行为过于复杂时。它可能需要使用<a class="ae lh" href="https://en.wikipedia.org/wiki/Specification_pattern" rel="noopener ugc nofollow" target="_blank">规范</a>、<a class="ae lh" href="https://www.codeproject.com/Tips/1175911/Domain-Policy-for-Domain-Driven-Design" rel="noopener ugc nofollow" target="_blank">策略</a>或其他实体和值对象。它可能依赖于来自存储库或其他服务的结果。</p><p id="a01e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第二种情况是不太复杂的行为，但是仍然不清楚逻辑属于哪里。它可能属于一个实体，也可能属于另一个实体，或者某个值对象。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">对单个实体来说责任太大</figcaption></figure><p id="3132" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，<code class="fe nd ne nf ng b">Currency</code>实体拥有方法<code class="fe nd ne nf ng b">Exchange</code>。此方法已经接受了太多的参数。问题是这个方法在这里是属于<code class="fe nd ne nf ng b">Wallet</code>值对象还是<code class="fe nd ne nf ng b">ExchangeRate</code>实体。</p><p id="c8cd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">更不用说，由于政治纠纷或经济原因，可能会暂时禁止兑换特定货币。这样，我们将为<code class="fe nd ne nf ng b">Currency</code>实体带来更多的业务不变量。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">引入可以处理复杂逻辑的领域服务</figcaption></figure><p id="74b9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当业务逻辑太大时，我总是将它转移到一个单独的域服务中，就像上面例子中的<code class="fe nd ne nf ng b">ExchangeRatesService</code>。使用这种方法，我总是能够通过提供新的域策略来调整我的域层。</p><p id="ead9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有时候将行为推给其他构建模块看起来是一件很自然的事情。然而，我们应该非常小心地处理它。将太多的行为从实体转移到域服务会导致另一种代码味道，即<a class="ae lh" href="https://martinfowler.com/bliki/AnemicDomainModel.html" rel="noopener ugc nofollow" target="_blank">贫血的域模型</a>。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">贫血域模型</figcaption></figure><p id="eb26" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的例子显示了<code class="fe nd ne nf ng b">TransactionService</code>域服务。该服务从<code class="fe nd ne nf ng b">BankAccount</code>实体那里接管责任。如果我们不需要检查复杂的业务不变量，这种行为就不属于领域服务。</p><p id="aa2f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为特定行为找到合适的位置更像是一项练习，在乞求时可能看起来很复杂，但随着时间的推移，它会变得更加直观。即使在今天，我有时仍然很难找到合适的地方。但是，更多的时候，我可以按照它应该的样子构造代码。</p><h1 id="b8ca" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">结论</h1><p id="8555" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">尽管我们在许多框架中使用它们，但它们的用法并不总是正确的。它们应该代表我们的状态和行为，而不是镜像数据库模式。</p><p id="447a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">实体给了我们额外的机会来描述现实世界中的有状态对象。在许多情况下，它们是我们应用程序的主要目的，或者至少我们的业务逻辑没有它们就无法工作。</p><h1 id="cab2" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">有用的资源:</h1><ul class=""><li id="e33a" class="nh ni it lk b ll mw lo mx lr nj lv nk lz nl md nm nn no np bi translated"><a class="ae lh" href="https://martinfowler.com/" rel="noopener ugc nofollow" target="_blank">https://martinfowler.com/</a></li><li id="be3b" class="nh ni it lk b ll nq lo nr lr ns lv nt lz nu md nm nn no np bi translated"><a class="ae lh" href="https://www.domainlanguage.com/" rel="noopener ugc nofollow" target="_blank">https://www.domainlanguage.com/</a></li></ul></div></div>    
</body>
</html>