<html>
<head>
<title>The correct way to make API requests in an Angular application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Angular应用程序中发出API请求的正确方式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-correct-way-to-make-api-requests-in-an-angular-application-22a079fe8413?source=collection_archive---------0-----------------------#2020-03-08">https://levelup.gitconnected.com/the-correct-way-to-make-api-requests-in-an-angular-application-22a079fe8413?source=collection_archive---------0-----------------------#2020-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="95b2" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">有角的</h2><div class=""/><div class=""><h2 id="27d2" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">角度拦截器，HttpClient vs HttpBackend，捕捉错误，召回API，防止XSRF攻击。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/c94983372ce3f614e380b30d1d1ba49d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wcaLfXMizsLOHangaLJZmQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">彼得·塞夫科维奇在<a class="ae lh" href="https://unsplash.com/s/photos/coffee?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="7ea5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我将讨论如何在Angular应用程序中执行请求。</p><ol class=""><li id="5586" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">使用拦截器来修饰请求</li><li id="1513" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">HttpClient vs HttpBackend</li><li id="1336" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">其他方法</li></ol><p id="6363" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">【https://betterfullstack.com查看 <a class="ae lh" href="https://betterfullstack.com" rel="noopener ugc nofollow" target="_blank"> <em class="ms">更多类似内容</em></a></p><p id="6448" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我写这篇文章是基于我多年从事前端工作的经验(在Angular工作了4年)。如果我做错了，请随时纠正我。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="13e1" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">使用拦截器来修饰请求</h1><p id="c929" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">当我们使用API时，HTTP拦截是一个主要的特性。使用拦截，您可以声明<em class="ms">拦截器</em>，这些拦截器检查并转换从您的应用程序到服务器的HTTP请求，以及从服务器返回到应用程序的响应。</p><p id="dd9c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">简单来说:</strong></p><p id="3ea9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在现实世界中，用户登录后，发送到后端的每个API都需要在头中添加授权，以验证用户身份验证和授权。</p><p id="f5e3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">示例1:使用拦截器向请求添加一个JWT</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">使用拦截器将jwt从状态添加到请求中</figcaption></figure><p id="1416" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">示例2:使用拦截器来控制应用程序上的微调器</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">使用拦截器控制应用程序上的微调器</figcaption></figure><p id="3a6e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">示例3:使用拦截器缓存请求</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">使用拦截器缓存请求</figcaption></figure><p id="57ae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以做更多与请求相关的事情:</p><ul class=""><li id="b97e" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md nz mk ml mm bi translated">在API失败时显示一个模态。</li><li id="f084" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nz mk ml mm bi translated">根据响应后的状态代码添加更多逻辑</li><li id="c2da" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nz mk ml mm bi translated">覆盖请求URL或请求正文</li></ul><p id="d921" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">拦截器会影响你所有的请求。那么如何在Angular中定制请求并禁用拦截器呢？让我们来看看</p><h1 id="f861" class="na nb it bd nc nd oa nf ng nh ob nj nk ki oc kj nm kl od km no ko oe kp nq nr bi translated">HttpClient vs HttpBackend</h1><p id="4ec1" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">我观察到许多开发人员只在Angular项目中使用<a class="ae lh" href="https://angular.io/api/common/http/HttpClient" rel="noopener ugc nofollow" target="_blank"> HttpClient </a>，每次他们需要向后端发送请求。这是不正确的。</p><p id="9dc4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为什么？</p><p id="b9c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为我们通过HttpClient发送的请求总是要经过Angular的拦截器。为了解决这个问题，一些开发人员将编写更多的代码来处理这个问题，我称之为“欺骗代码”来禁用拦截器。一些开发人员不会对请求使用拦截器，而是给每个请求添加一个头。</p><p id="2dfa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们的代码将充满代码气味和技术债务。开发人员必须通过使用上面两个选项中的一个来做更多的工作。</p><p id="c3d6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你正在读这篇文章，你就是解决这种情况的正确方法。</p><p id="5f74" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">解决方案</strong>:同时使用<a class="ae lh" href="https://angular.io/guide/http#http-interceptors" rel="noopener ugc nofollow" target="_blank"> HttpClient </a>和<a class="ae lh" href="https://angular.io/api/common/http/HttpBackend" rel="noopener ugc nofollow" target="_blank">http backen</a>来发送请求。</p><p id="6b68" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里唯一不同的是<a class="ae lh" href="https://angular.io/api/common/http/HttpBackend" rel="noopener ugc nofollow" target="_blank"> HttpBackend </a>将请求直接发送到后端，而不经过拦截器链。</p><p id="2ad8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">示例HttpService:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">使用httpclient和httpbackend的示例http服务</figcaption></figure><p id="e595" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您将做出决定，哪个通过拦截器，哪个不通过。</p><p id="4700" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一些需要不同头或者添加额外信息的特定API，可以使用<a class="ae lh" href="https://angular.io/api/common/http/HttpBackend" rel="noopener ugc nofollow" target="_blank"> HttpBackend </a>手动定制。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="7d50" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">其他方法</h1><p id="9519" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">我使用这个标题是因为这些都是应用程序中可能有也可能没有的小用例。</p><p id="3603" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">失败后如何调用API？</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">重试失败的请求最多3次</figcaption></figure><p id="ce86" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果请求失败，使用<code class="fe of og oh oi b">retry()</code>添加尝试请求的时间。</p><p id="9365" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">如何捕捉错误？</strong></p><p id="1da7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我建议您在拦截器的<code class="fe of og oh oi b">next()</code>方法中捕捉一个错误。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">如何在拦截器上捕捉错误的示例</figcaption></figure><p id="69e6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">如何防范</strong> <a class="ae lh" href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> XSRF攻击</strong> </a> <strong class="lk jd">？</strong></p><p id="5613" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当执行HTTP请求时，拦截器从cookie中读取一个令牌，默认为<code class="fe of og oh oi b">XSRF-TOKEN</code>，并将其设置为HTTP头<code class="fe of og oh oi b">X-XSRF-TOKEN</code>。因为只有在您的域上运行的代码才能读取cookie，所以后端可以确定HTTP请求来自您的客户端应用程序，而不是攻击者。</p><p id="c7e6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您的后端服务对XSRF令牌cookie或头使用不同的名称，使用<code class="fe of og oh oi b"><a class="ae lh" href="https://angular.io/api/common/http/HttpClientXsrfModule#withOptions" rel="noopener ugc nofollow" target="_blank">HttpClientXsrfModule.withOptions()</a></code>来覆盖。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">使用<code class="fe of og oh oi b"><a class="ae lh" href="https://angular.io/api/common/http/HttpClientXsrfModule#withOptions" rel="noopener ugc nofollow" target="_blank">HttpClientXsrfModule</a> to overrite XSRF token</code></figcaption></figure><h1 id="3f87" class="na nb it bd nc nd oa nf ng nh ob nj nk ki oc kj nm kl od km no ko oe kp nq nr bi translated">结论</h1><p id="304b" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">本文包含了我们在使用Angular应用程序的API时需要的所有信息，包括:</p><ul class=""><li id="a5cc" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md nz mk ml mm bi translated">使用拦截器来管理请求和响应</li><li id="4806" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nz mk ml mm bi translated">如何使用HttpClient和HttpBackend</li><li id="ba01" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nz mk ml mm bi translated">如何在请求失败时重新调用请求、捕捉错误并防止XSRF攻击。</li></ul><p id="d8e7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望这篇文章对你有用！你可以在<a class="ae lh" href="https://medium.com/@transonhoang?source=post_page---------------------------" rel="noopener">媒体</a>上关注我。我也在<a class="ae lh" href="https://twitter.com/transonhoang" rel="noopener ugc nofollow" target="_blank">推特</a>上。欢迎在下面的评论中留下任何问题。我很乐意帮忙！</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><div class="ks kt ku kv gt oj"><a href="https://betterfullstack.com/stories/" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd jd gy z fp oo fr fs op fu fw jc bi translated">故事-更好的全栈</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">关于JavaScript、Python和Wordpress的有用文章，有助于开发人员减少开发时间并提高…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">betterfullstack.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox lb oj"/></div></div></a></div></div></div>    
</body>
</html>