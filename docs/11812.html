<html>
<head>
<title>How to Program Simply by Not Using Object-Oriented Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过不使用面向对象编程来简单地编程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-program-simply-by-not-using-object-oriented-programming-368de601fc26?source=collection_archive---------2-----------------------#2022-04-19">https://levelup.gitconnected.com/how-to-program-simply-by-not-using-object-oriented-programming-368de601fc26?source=collection_archive---------2-----------------------#2022-04-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8e9b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">OOP很棒，但是它悄悄地让你的简单程序变得复杂</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/87c6cfe43e282376b38e43eb3ffe5405.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HM4hYQ9MNfpKaWnML_1tOg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Joshua Aragon 在<a class="ae ky" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片，由Canva编辑</figcaption></figure><p id="4723" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">程序员使用各种编程范例来开发软件系统。有几种流行的编程范例:结构化的、过程化的、函数式的、模块化的和面向对象的。这些范例帮助程序员通过使用一种特定的编码风格来组织他们的源代码，这种风格先于众所周知的软件开发原则和模式。例如，我们可以通过将语句安排到几个过程(函数)中来使用过程范式，我们可以使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干</a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it" rel="noopener ugc nofollow" target="_blank"> YAGNI </a>原则来进一步改进源代码。</p><p id="e5b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现代程序员往往倾向于使用OOP(面向对象编程),甚至没有考虑项目领域、需求、规模和扩展需求。OOP无疑是很好地组织代码库的一个很好的范例，但是它会让你的简单程序无声地变得复杂。</p><p id="0883" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个故事中，我将解释另一种基于过程的编程范例，您可以用它来简化您的软件开发项目。除了OOP之外，这种可选的编程范式借用了现有范式中的几个概念。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9362" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">OOP如何使简单的项目复杂化</h1><p id="788c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">CPU是遵循<a class="ae ky" href="https://en.wikipedia.org/wiki/Turing_machine" rel="noopener ugc nofollow" target="_blank">图灵机</a>概念的计算设备。换句话说，CPU理论上可以执行一个程序的无限系列的线性汇编指令。最初，程序员用原始汇编指令编写软件程序，但后来他们引入了对人类友好的编程语言，以提高生产率和代码可移植性。我在下面的故事中解释了这些低级编程概念:</p><div class="mz na gp gr nb nc"><a rel="noopener  ugc nofollow" target="_blank" href="/5-computer-hardware-concepts-that-every-programmer-should-know-32711c759dc0"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">每个程序员都应该知道的5个计算机硬件概念</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">多亏了这些概念，你的计算机执行了你编写的程序</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq ks nc"/></div></div></a></div><p id="76d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如今，我们可以使用各种范式的人类友好的编程语言——这要归功于类似英语的语法和现代语言功能。OOP范例激励开发人员将源代码语句分解成类，并用动作创建有状态对象。OOP是解决面向业务问题的好选择，因为我们可以很容易地将业务实体隔离为类。例如，看看基于Python的<a class="ae ky" href="https://github.com/frappe/erpnext" rel="noopener ugc nofollow" target="_blank"> ERPNext </a>开源平台如何使用带有<code class="fe nr ns nt nu b">TransactionBase</code>父类的<code class="fe nr ns nt nu b">Customer</code>业务实体的继承:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/987e8c405317255d342b1d7d4c8dfe7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*hFkl3CE7jyTwDsI8Z_vU5g.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">ERPNext平台的<a class="ae ky" href="https://github.com/frappe/erpnext/blob/4b2521c9f3b79619db30cd1bb456f9ae60889c01/erpnext/selling/doctype/customer/customer.py#L29" rel="noopener ugc nofollow" target="_blank">客户</a>类实现，作者截图</figcaption></figure><p id="41f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用基本的面向对象方法编程不会使程序变得复杂，但是与面向对象(OO)相关的概念，如继承、多态和基于OO的设计模式通常会使程序变得复杂。另一方面，如果没有这样的概念，我们无法做出更好的实用的基于OOP的源代码。因此，基于OOP的软件项目经常会过度使用OOP原则和设计模式。结果，你的软件程序的简单逻辑流程会因为多个对象和分散的状态而变得复杂。由于这个原因，像Golang这样的现代编程语言不提供复杂的OOP概念支持。</p><blockquote class="nw nx ny"><p id="a759" class="kz la nz lb b lc ld ju le lf lg jx lh oa lj lk ll ob ln lo lp oc lr ls lt lu im bi translated">此外，缺少类型层次结构使得Go中的“对象”比C++或Java等语言中的“对象”要轻得多。—转到<a class="ae ky" href="https://go.dev/doc/faq#Is_Go_an_object-oriented_language" rel="noopener ugc nofollow" target="_blank">常见问题解答</a></p></blockquote><p id="03fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，您甚至必须为不需要多个实例的实体(例如，应用程序、服务器、配置等)创建类和对象。)来坚持OO风格。这种情况经常发生在非面向业务的项目中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ab05" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">软件项目的过程化编程范例</h1><p id="3050" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果OOP经常使项目复杂化，那么哪种替代范式适合开发软件系统？函数式编程？—我们可以使用函数式编程中的一些概念，但不是全部——因为纯函数式编程为非通用用例提供了解决方案，如复杂的数据操作和数学计算。</p><p id="8bb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你第一次学习计算机算法是什么时候，怎么学的？—您可能是通过学习通用控制结构开始学习流程图算法的。后来，你可能通过使用那些控制语句学习了结构化编程。用结构化编程开发软件并不复杂，因为它对理论计算机科学算法没有任何抽象，对CPU本机语言的抽象也较少(<a class="ae ky" href="https://en.wikipedia.org/wiki/Instruction_set_architecture" rel="noopener ugc nofollow" target="_blank"> ISA </a> Assembly)。我们可以将结构化、模块化、过程化和函数式编程范例中的概念结合起来，为OOP提供一个简单的替代方案。</p><p id="2ac3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个面向对象的简单替代方案:</p><p id="98de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用模块代替类，用过程(函数)代替类方法(或类)，用记录代替有状态对象，用自定义代码风格代替访问修饰符，用模块级变量代替持久类状态。例如，请看我如何根据模块化编程原理将一个CLI程序代码分解成几个<a class="ae ky" href="https://en.wikipedia.org/wiki/CommonJS" rel="noopener ugc nofollow" target="_blank"> CommonJS </a>模块:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/90e38642f8bd091d151b5b85c1516325.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*umsZt2a16euM1VFHAzJDog.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">模块化编程的一个例子，作者截图</figcaption></figure><p id="efcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在OOP中，我们经常在类方法中分布逻辑，然后我们必须检查多个类来理解特定的逻辑流。在基于OOP的大型项目中，理解一个特定的逻辑流程无疑是非常耗时的。因此，我们可以写函数而不是类方法。但是，私有方法的替代方法是什么呢？我们可以使用自定义代码风格来表示私有函数。请看下面的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/80f510292eed3e7b744f21eec8d6eea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*5M2H6fycFZin8Hoth862rw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">将大函数分解成更小的私有函数，作者截图</figcaption></figure><p id="425a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用OOP管理程序状态是简单而自然的，但是类似继承的概念会使状态处理流程变得复杂。在过程化编程中有两种管理程序状态的方法:使用全局变量或者将状态作为参数传递——根据您的偏好和需求选择一种。基于参数的状态处理产生了可测试性好且干净的代码。然而，基于全局变量的状态处理并不坏——只要我们不在许多地方改变程序状态，它也能产生好的代码。</p><p id="3962" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些非循环程序(如CLI程序、自动化脚本、实用程序等)通常不需要持久状态，因此我们可以根据函数范式的纯函数概念编写所有函数，而不会产生<a class="ae ky" href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" rel="noopener ugc nofollow" target="_blank">副作用</a>。</p><p id="aac9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种过程化编程看起来很棒，但是我们如何管理有状态对象池呢？例如，如果没有基于OOP的<code class="fe nr ns nt nu b">Process</code>类，我们如何实现进程列表？在过程化编程的世界里，一个对象变成了一条记录。请看下面的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/55b1beb454746174455424299bc7710c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*6HG8hnuBs92fgC9h1_liqg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Neutralinojs框架的扩展管理<a class="ae ky" href="https://github.com/neutralinojs/neutralinojs/blob/main/extensions_loader.cpp" rel="noopener ugc nofollow" target="_blank">模块</a>，作者截图</figcaption></figure><p id="bc46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的C++代码片段是扩展管理模块的一部分。它有一个模块级的<code class="fe nr ns nt nu b">loadedExtensions</code>变量和几个与之相关的过程。如果我们用OOP范式重写，我们可能需要创建两个类:<code class="fe nr ns nt nu b">Extension</code>和<code class="fe nr ns nt nu b">ExtensionManager</code>，但是现在，用一个最小的模块，一切都很简单。这里我们使用了一个字符串向量来保存扩展信息，但是如果扩展记录中有很多字段(不是object ),我们也可以使用struct向量。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b08b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用过程化编程范例</h1><p id="faca" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">由于C是一种过程化语言，我们确实可以使用C的过程化编程方法。例如，检查来自<a class="ae ky" href="https://en.wikipedia.org/wiki/C_standard_library" rel="noopener ugc nofollow" target="_blank"> C标准库</a>的文件处理函数，你会注意到你需要将<code class="fe nr ns nt nu b">FILE</code>指针传递给每个文件处理函数。此外，通过检查Linux内核源代码，我们可以看到过程化编程模式，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/f1916a0547dfe08785afba9091707582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*5eiBEkFatRzBjmZHAtP2bA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">示例C语言程序来自Linux内核<a class="ae ky" href="https://github.com/torvalds/linux/blob/b2d229d4ddb17db541098b83524d901257e93845/kernel/cpu.c#L2005" rel="noopener ugc nofollow" target="_blank">源码</a>，作者截图</figcaption></figure><p id="ad1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于像C++、JavaScript和Python这样的流行编程语言来说，使用纯过程范式无疑是不可能的。原因是这些语言的标准库API为程序员提供了面向对象类。例如，看看JavaScript标准库如何为创建集合提供面向对象接口:</p><pre class="kj kk kl km gt oh nu oi oj aw ok bi"><span id="5265" class="ol md it nu b gy om on l oo op">let numbers = new Set(); // constructor<br/>numbers.add(10); // class method<br/>console.log(numbers.size); // class property</span></pre><p id="3024" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，C++也提供了一组与C++标准库交互的类。然而，所有现代的稳定编程语言都是多范式语言，所以那些语言支持带有lambda函数、回调、递归和匿名函数的函数式编程。因此，通过用函数包装基于OOP的标准库接口，我们可以在任何编程语言中使用这种替代的过程范式。我们可以在我们的过程中使用基于OOP的标准库类，而不用将整个项目的范例变成OOP。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5851" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="6c85" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">OOP是解决几乎所有现实世界问题的自然编程范式，但从CPU的角度来看，它是人工的。CPU不把特定程序的指令集当作对象和引用，而是把整个程序当作一组过程和参数。因此，从技术角度来看，自然编程范式是开发软件系统的过程化范式。</p><p id="9cbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，从面向业务的角度来看，OOP很好地映射了业务逻辑和代码库——这就是为什么大多数面向业务的软件系统倾向于使用OOP而不是其他范例。此外，过程化编程方法可能会在面向业务的软件项目(例如，电子商务系统、工资软件等)中产生代码味道</p><p id="d172" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果我们试图将一些软件程序分解成类，它们就会变得复杂。此外，如果我们倾向于添加OOP原则，算法解决方案通常会变得复杂。作为程序员，我们总是需要用简单、最小和有效的解决方案来解决问题，而不是增加不必要的复杂性。因此，在绘制类图之前，为您的下一个令人惊叹的项目尝试一种过程化的、功能化的、模块化的混合方法。</p><p id="87fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个故事并不是要批评OOP——它确实向您展示了一个替代范例，通过消除过度工程化效应来提高您未来软件项目的简单性。下面的故事解释了在软件开发中保持简单性的优势:</p><div class="mz na gp gr nb nc"><a rel="noopener  ugc nofollow" target="_blank" href="/5-programming-principles-that-help-you-to-write-better-code-5d96197725cc"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">帮助你写出更好代码的5条编程原则</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">用这些编程原则编写更好的代码，给编译器和你的队友留下深刻印象</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nl l"><div class="oq l nn no np nl nq ks nc"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="8a35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>