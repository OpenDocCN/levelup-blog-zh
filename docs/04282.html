<html>
<head>
<title>Using Git Submodules to integrate code between projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Git子模块在项目间集成代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-git-submodules-to-integrate-code-between-projects-74a913a41519?source=collection_archive---------6-----------------------#2020-06-18">https://levelup.gitconnected.com/using-git-submodules-to-integrate-code-between-projects-74a913a41519?source=collection_archive---------6-----------------------#2020-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="443c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在任何涉及多个项目或多个开发人员的生态系统中，可能存在重复的公共代码段。从长远来看，这种重复的代码会导致不可维护的代码库，在这种情况下，必须将微小的更改复制到许多代码库中，以使其保持一致。</p><p id="0dbe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，维护具有公共片段的代码库以在项目间共享是一种普遍的做法，并且很少有方法来集成代码库。当在公司的项目中共享时，这个共享代码可以是私有的和特定领域的。或者，共享代码可以是公共的和开源的，其中共享常见用例的解决方案。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h2 id="448c" class="kv kw it bd kx ky kz dn la lb lc dp ld kb le lf lg kf lh li lj kj lk ll lm ln bi translated">使用Git子模块共享代码</h2><p id="5c33" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">Git子模块可以被认为是git存储库中的g <strong class="js iu"> it存储库。这个子存储库承载着需要在项目之间共享的代码。父库和子库之间有引用，所以可以在任何有Git的地方管理和重新创建它。</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/05f1afb3b9cc7307c451cf1505ed70fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*WeOhnx3ABEkEEh4HakjHYA.png"/></div></figure></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h2 id="bc85" class="kv kw it bd kx ky kz dn la lb lc dp ld kb le lf lg kf lh li lj kj lk ll lm ln bi translated">通过演示了解</h2><p id="4628" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">为了更好地理解，让我们举一个在静态网站生成器Hugo中使用的例子。(先决条件:这个需要电脑上安装<code class="fe mb mc md me b">Hugo</code>跟进demo，不过没有demo也可以理解。)</p><p id="ed6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">启动Hugo站点</strong></p><p id="95c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将在<code class="fe mb mc md me b">hugo-site</code>中创建相关的文件夹，并且父<code class="fe mb mc md me b">git</code>存储库在这里启动。让我们提交现有的内容，使工作树变得干净。</p><pre class="lu lv lw lx gt mf me mg mh aw mi bi"><span id="c10e" class="kv kw it me b gy mj mk l ml mm">$ <strong class="me iu">hugo new site hugo-site</strong><br/>$ <strong class="me iu">cd hugo-site<br/></strong>$<strong class="me iu"> git init<br/></strong>$<strong class="me iu"> git add . &amp;&amp; git commit -m "initial commit"</strong></span></pre><p id="07c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">使用Git子模块集成Hugo主题</strong></p><p id="c89e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Hugo允许我们在GitHub中集成现有的开源主题。例如可以使用<code class="fe mb mc md me b"><a class="ae mn" href="http://github.com/dzello/reveal-hugo." rel="noopener ugc nofollow" target="_blank">http://github.com/dzello/reveal-hugo</a></code>。根据Hugo的说法，主题应该存在于<code class="fe mb mc md me b">themes/</code>的母库中。</p><pre class="lu lv lw lx gt mf me mg mh aw mi bi"><span id="0ade" class="kv kw it me b gy mj mk l ml mm">$ <strong class="me iu">git submodule add </strong><a class="ae mn" href="https://github.com/dzello/reveal-hugo.git" rel="noopener ugc nofollow" target="_blank"><strong class="me iu">https://github.com/dzello/reveal-hugo.git</strong></a><strong class="me iu"> themes/reveal-hugo</strong></span></pre><p id="7183" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的命令将启动一个存储库到<code class="fe mb mc md me b">themes/reveal-hugo</code>目录中的给定目录。这将作为<code class="fe mb mc md me b">git clone</code>，在这里将创建git存储库的全部内容，比如<code class="fe mb mc md me b">.git</code>，一个工作树和设置为<code class="fe mb mc md me b">master</code>的分支。</p><div class="lu lv lw lx gt ab cb"><figure class="mo ly mp mq mr ms mt paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><img src="../Images/1039dcfc9d85878b34b3dd939a98a86c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*9PXfPq-ofc7eKCC5l9dlJA.png"/></div></figure><figure class="mo ly my mq mr ms mt paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><img src="../Images/cc55c383d189149b005064167d34fa68.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*uS1HbX0PRK6XSNpqA2SMsw.png"/></div></figure></div><p id="3b5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将在父git存储库中启动子git存储库作为子模块。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mz"><img src="../Images/f1e393de437cbfd716f6eeb9ddf6ffe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iVAGPQUxS5n46WEH4dChvw.png"/></div></div></figure><p id="73c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们使用<code class="fe mb mc md me b">git status</code>添加子模块来检查父存储库的变更。</p><div class="lu lv lw lx gt ab cb"><figure class="mo ly na mq mr ms mt paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><img src="../Images/b4f88c1ffc423814c9df6ff66deb4212.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*g-SO-QQtDHPL46Vam1KBEQ.png"/></div></figure><figure class="mo ly nb mq mr ms mt paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><img src="../Images/ef8f27798a5454e6f2c9105536aef273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*NOZiCGgA6A0JmHP4nD4nig.png"/></div></figure></div><p id="e6b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里<code class="fe mb mc md me b">.gitmodules</code>将会有关于它被克隆到的子存储库和目录的信息。注意<code class="fe mb mc md me b">themes/reveal-hugo</code>不是一个目录，因为它实际上在文件系统中，但是对于父存储库来说，它被认为是一个文件。这个新文件包含子存储库的提交散列作为引用。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nc"><img src="../Images/596711033b2b0bfbb1a5c77515aeb424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qUXaDysuHTpR5JZe0ePssg.png"/></div></div></figure><p id="d590" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此从<strong class="js iu">子储存库url </strong>，它的<strong class="js iu">提交散列</strong>和它驻留在父储存库中的<strong class="js iu">目录可以重新创建Git子模块内容。让我们提交对<code class="fe mb mc md me b">.gitmodules</code>的更改，并提交散列以集成到父存储库。</strong></p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><p id="d72b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">修改Git子模块</strong></p><p id="6c41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Git子模块实际上是父存储库中的子存储库。因此可以在本地或远程对这个子存储库进行更改。在这个场景中，这个子模块是一个主题，我们假设我们需要做出改变。</p><div class="lu lv lw lx gt ab cb"><figure class="mo ly nd mq mr ms mt paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><img src="../Images/f6533b93219aa2bba51c35518b8fee9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*6DxRS2XKl8MK46bVqc3k1w.png"/></div></figure><figure class="mo ly ne mq mr ms mt paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><img src="../Images/2f4339838925876af129639ff5b1002f.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*QvCq633wF1FWZHJhL9IOVg.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk nj di nk nl translated">使用ls-tree命令检查提交</figcaption></figure></div><p id="ebce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里可以清楚地看到父存储库对子模块的引用，注意在<code class="fe mb mc md me b">themes/reveal-hugo</code>中，git使用<code class="fe mb mc md me b">commit</code>的对象类型来标识提交id，而不是通常的<code class="fe mb mc md me b">blob</code>或<code class="fe mb mc md me b">tree</code>。</p><pre class="lu lv lw lx gt mf me mg mh aw mi bi"><span id="301b" class="kv kw it me b gy mj mk l ml mm">$ <strong class="me iu">git submodule status</strong><br/>+f6f35ef250... themes/reveal-hugo (heads/master)</span></pre><p id="d3bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">需要注意的是，这个子存储库的行为就像Git存储库一样，可以进行任何需要的更改。子存储库的任何更改也应该在父存储库的子模块中进行跟踪。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nm"><img src="../Images/2638d1a923e1807962065dfc0ebed7db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jKrXisq_YMlaEVrQStpFVQ.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">列出子存储库的最后10次提交</figcaption></figure><p id="e40d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，有一个重要的观察结果，父存储库跟踪子存储库中由<code class="fe mb mc md me b">HEAD</code>引用的提交。因此，它总是跟踪当前的提交目录，而不是这个场景中的分支或标记。</p><p id="26c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们在子存储库中提交一个新的虚拟变更，而不对演示进行任何变更。</p><pre class="lu lv lw lx gt mf me mg mh aw mi bi"><span id="f9a8" class="kv kw it me b gy mj mk l ml mm">$ <strong class="me iu">cd themes/reveal-hugo</strong></span><span id="5903" class="kv kw it me b gy nn mk l ml mm">$ <strong class="me iu">git commit -m "dummy change" --allow-empty</strong><br/>[master f6f35ef] dummy change</span><span id="e323" class="kv kw it me b gy nn mk l ml mm">$ <strong class="me iu">git log --pretty=oneline -n 3</strong><br/>f6f35e (<strong class="me iu">HEAD -&gt; master</strong>) dummy change<br/>ff9f38 (<strong class="me iu">origin/master</strong>, <strong class="me iu">origin/HEAD</strong>) Merge pull request #87<br/>f71276 Add devops training implementation</span></pre><p id="ea89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，这为子模块添加了提交，并移动了它的<code class="fe mb mc md me b">HEAD</code>。子模块中的这一变化由父存储库识别，它依赖于<code class="fe mb mc md me b">HEAD</code>引用的提交。所以这个变化可以看出来:</p><div class="lu lv lw lx gt ab cb"><figure class="mo ly no mq mr ms mt paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><img src="../Images/8a059b52c5151738011f6b6ffa4845df.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*LiFF8X97bSYLmXqgtbQnjg.png"/></div></figure><figure class="mo ly np mq mr ms mt paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><img src="../Images/622ce78cf5f5492c452d38bee73d10ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*705zbhVklLyH5z_sjsBMkw.png"/></div></figure></div><p id="3707" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果将来要将父存储库中的这个更改用作子模块，那么应该提交它。这里需要注意的一点是，父库只知道<strong class="js iu">远程子库</strong>和<strong class="js iu"> </strong>的<strong class="js iu">提交散列</strong>。对于将来在<code class="fe mb mc md me b">git clone</code>工作的子模块，这个本地提交应该可以通过<strong class="js iu">主分支</strong>中的<code class="fe mb mc md me b">git push</code>作为其<code class="fe mb mc md me b">HEAD</code>在远程储存库中获得。这同样适用于对<code class="fe mb mc md me b">git reset</code>、<code class="fe mb mc md me b">git checkout</code>或<code class="fe mb mc md me b">git commit</code>的任何更改，但要确保这些更改与<strong class="js iu">远程</strong>、<strong class="js iu">存储库</strong>同步<strong class="js iu">，并且在<code class="fe mb mc md me b"><strong class="js iu">master</strong></code>分支上作为其<code class="fe mb mc md me b"><strong class="js iu">HEAD</strong></code>可用。简单来说就是指<code class="fe mb mc md me b"><strong class="js iu">submodule/.git/HEAD</strong></code>。</strong></p><p id="9f70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简单地说，子存储库中与<code class="fe mb mc md me b">HEAD</code>相关的所有提交都应该在远程可用。以及与父存储库中的<code class="fe mb mc md me b">gitmodules</code>引用相关的所有更改都应该在远程可用。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h2 id="5646" class="kv kw it bd kx ky kz dn la lb lc dp ld kb le lf lg kf lh li lj kj lk ll lm ln bi translated">克隆时重新创建子模块</h2><p id="582a" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">一旦提交了带有子模块的父库，就知道不会复制子库工作树，但会保留对它的<strong class="js iu">引用，例如远程库url、它的提交散列以及它应该复制到的目录</strong>。</p><p id="bf91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于我的使用，我设置了一个带有<code class="fe mb mc md me b">Hugo</code>站点的存储库，其中主题<code class="fe mb mc md me b">reveal-hugo</code>作为子模块被添加。当克隆这个存储库时，我们希望有一个文件的工作副本，其中也克隆了子模块。这通过使用<code class="fe mb mc md me b">git clone</code>处的<code class="fe mb mc md me b">--recurse-submodules</code>来实现。</p><pre class="lu lv lw lx gt mf me mg mh aw mi bi"><span id="3f92" class="kv kw it me b gy mj mk l ml mm"><strong class="me iu">git clone --recurse-submodules </strong><a class="ae mn" href="https://github.com/udarabibile/code-koala-blog.git" rel="noopener ugc nofollow" target="_blank"><strong class="me iu">https://github.com/udarabibile/code-koala-slides.git</strong></a></span></pre><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nq"><img src="../Images/b13adf78d96e526581625a58a8d8ce59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*On2CXHlr3tC1cSrx-97D1g.png"/></div></div></figure><p id="884b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意子模块是如何被克隆到给定的目录并检查给定的提交的。该<code class="fe mb mc md me b">git clone</code>产生完整的文件和文件夹，包括子模块。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><p id="c1cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">使用分支或标签来简化版本控制</strong></p><p id="fef2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里可以看到，子模块的引用是使用提交id完成的，这对于管理或用于版本控制可能是一个挑战。因此也可以使用git标签或分支。</p><p id="6a87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们添加一个指定了分支的临时子模块:</p><pre class="lu lv lw lx gt mf me mg mh aw mi bi"><span id="8354" class="kv kw it me b gy mj mk l ml mm">$ <strong class="me iu">git submodule add -b dzello-patch-1 https://github.com/dzello/reveal-hugo.git themes-temp/</strong></span><span id="9cdd" class="kv kw it me b gy nn mk l ml mm">$ <strong class="me iu">less .gitmodules</strong><br/>[submodule "themes-temp"]<br/>path = themes-temp<br/>url = <a class="ae mn" href="https://github.com/dzello/reveal-hugo.git" rel="noopener ugc nofollow" target="_blank">https://github.com/dzello/reveal-hugo.git</a><br/>branch = dzello-patch-1</span><span id="ac1a" class="kv kw it me b gy nn mk l ml mm">$ <strong class="me iu">git submodule status</strong><br/>f86d93... themes-temp (heads/dzello-patch-1)<br/>+f6f35e... themes/reveal-hugo (v1.0)</span></pre><p id="c6f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这表明<code class="fe mb mc md me b">themes-temp</code>将指向来自指定分支的提交id。这里，分支在<code class="fe mb mc md me b">.gitmodules</code>中指定，因此可以在克隆时正确地重新创建。</p><p id="8554" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，标签也可以用在附加了<code class="fe mb mc md me b">themes/reveal-hugo</code>标签的地方，但是它总是指向提交id，而不是像branch那样指向标签本身。</p><pre class="lu lv lw lx gt mf me mg mh aw mi bi"><span id="8ef0" class="kv kw it me b gy mj mk l ml mm">$ <strong class="me iu">cd themes/reveal-hugo/</strong><br/>$ <strong class="me iu">git tag -a v1.0 -m "version 1"</strong></span></pre></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><p id="df26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">同步子模块的重要命令</strong></p><ul class=""><li id="028c" class="nr ns it js b jt ju jx jy kb nt kf nu kj nv kn nw nx ny nz bi translated"><code class="fe mb mc md me b">git submodule update</code> →在每个子模块中执行<code class="fe mb mc md me b">git pull</code>。有<code class="fe mb mc md me b">--init</code>、<code class="fe mb mc md me b">--recursive</code>、<code class="fe mb mc md me b">--remote</code>等多个标志。</li><li id="c119" class="nr ns it js b jt oa jx ob kb oc kf od kj oe kn nw nx ny nz bi translated"><code class="fe mb mc md me b">git submodule sync</code> →更新有关子模块的元数据，如URL更改，只需用更新后的<code class="fe mb mc md me b">.gitmodules</code>重新同步<code class="fe mb mc md me b">.git/config</code>。</li></ul><p id="7af0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如需更多详细信息，请跟进:</p><div class="of og gp gr oh oi"><a href="https://git-scm.com/docs/git-submodule" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">git-git-子模块文档</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">不带参数，显示现有子模块的状态。有几个子命令可用于对…执行操作</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">git-scm.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow lz oi"/></div></div></a></div></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><p id="4b69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">Git子模块的缺点</strong></p><p id="ddeb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当公开或私下共享代码时，Git模块没有被广泛采用。这可能是由于多个开发者共享时<strong class="js iu">涉及同步子模块</strong>的复杂性。简单来说<strong class="js iu"> git用于</strong> <strong class="js iu">管理源代码，而不是用于解析依赖关系</strong>。因此，许多开发人员或公司倾向于使用包管理器来共享依赖关系的代码。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><p id="d84f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">库包管理器</strong></p><p id="eb1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如开始提到的，你们都知道，Git子模块不是集成代码的唯一方式，包管理器更有名。</p><p id="fd8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每种语言或技术栈可能都配备了自己的包管理器，不像git子模块，技术不是问题。</p><ul class=""><li id="ff87" class="nr ns it js b jt ju jx jy kb nt kf nu kj nv kn nw nx ny nz bi translated"><strong class="js iu"> Java </strong>使用<strong class="js iu"> Maven仓库</strong>来共享库/插件<strong class="js iu"> jar </strong>文件。</li><li id="b650" class="nr ns it js b jt oa jx ob kb oc kf od kj oe kn nw nx ny nz bi translated"><strong class="js iu">。NET </strong>使用<strong class="js iu"> Nuget包管理器</strong>来共享<strong class="js iu"> dll </strong> exe文件。</li><li id="30be" class="nr ns it js b jt oa jx ob kb oc kf od kj oe kn nw nx ny nz bi translated"><strong class="js iu"> JavaScript </strong>使用<strong class="js iu"> NPM注册表</strong>共享<strong class="js iu">节点模块</strong>文件。</li></ul><p id="25b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的一个重要变化是这些包管理器大多由<strong class="js iu">编译或构建代码组成，而不是源代码。</strong>所有这些选项都允许在公司内部使用私有包来获得更安全的、特定于域的包。</p><p id="b694" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看一个如何在javascript世界中使用npm registry的例子:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ox"><img src="../Images/a537a7bc283157088ae7934200d9e51f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-IvHJw9n6jy4k3D6Yw6pEg.png"/></div></div></figure></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><p id="b289" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总之，我希望你们都熟悉使用Git子模块来<strong class="js iu">整合项目之间的代码</strong>或者<strong class="js iu">以开源的方式</strong>公开共享代码。</p></div></div>    
</body>
</html>