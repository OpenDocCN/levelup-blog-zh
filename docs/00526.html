<html>
<head>
<title>Design patterns in modern JavaScript development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript开发中的设计模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/design-patterns-in-modern-javascript-development-ec84d8be06ca?source=collection_archive---------0-----------------------#2019-04-10">https://levelup.gitconnected.com/design-patterns-in-modern-javascript-development-ec84d8be06ca?source=collection_archive---------0-----------------------#2019-04-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3bd3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于软件项目设计中有效沟通的思考</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/34216673154e0968f738dddc56203c42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nfNi7oUIZBakAdyXXcmirw.jpeg"/></div></div></figure><h1 id="ae35" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">模式？设计？我们还在谈论软件开发吗？</h1><p id="be46" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">毫无疑问。</p><p id="669e" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">就像面向对象编程的情况一样，我们这些开发人员正试图对我们周围的世界进行建模。因此，尝试使用我们周围的世界作为工具来描述我们的工艺是有意义的。</p><p id="f4ea" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在这种情况下，我们从《建筑》( the one with buildings and bridges)和开创性的建筑书籍《A Pattern Language: Towns，buildings，Construction<em class="mk"/>by<strong class="ll ir"><em class="mk"/></strong><em class="mk">Christopher Alexander，Sara Ishikawa，Murray银色啤酒杯乐队</em>那里的模式描述如下:</p><blockquote class="ml mm mn"><p id="d342" class="lj lk mk ll b lm mf jr lo lp mg ju lr mo mh lu lv mp mi ly lz mq mj mc md me ij bi translated">每个模式描述了一个在我们的环境中反复出现的问题，然后描述了该问题解决方案的核心，以这样一种方式，你可以使用这个解决方案一百万次，而不必以同样的方式做两次。</p></blockquote><p id="f80b" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在软件开发中，架构是以健康、健壮和可维护的方式构建应用程序的过程，模式提供了一种为常见问题的解决方案命名的方式。这些解决方案的范围从抽象/概念到非常精确和技术性，并允许开发人员有效地相互交流。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/9d32c19db3498f3c2eb0f9c71f0d32dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pdCoxUhmMHI5tBnGVdnNJQ.jpeg"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">高效。</figcaption></figure><p id="5874" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">如果一个团队中有两个或更多的开发人员了解模式，那么讨论问题的解决方案会变得非常有效。如果只有一个开发人员了解模式，向团队的其他成员解释它们通常很容易。</p><p id="b2c8" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><strong class="ll ir">本文的目标是通过向您介绍软件设计模式的概念，并展示几个有趣的模式，来激发您对软件开发知识的某种形式表示的兴趣，因为它们在现代JavaScript项目中得到了广泛的使用。</strong></p><h1 id="94a8" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">单一模式</h1><h2 id="395f" class="mw ks iq bd kt mx my dn kx mz na dp lb ls nb nc ld lw nd ne lf ma nf ng lh nh bi translated">什么</h2><p id="217f" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">单例模式不是使用最广泛的模式之一，但是我们从这里开始，因为它相对容易掌握。</p><p id="445f" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">单例模式源于单例的数学概念，即:</p><blockquote class="ml mm mn"><p id="f355" class="lj lk mk ll b lm mf jr lo lp mg ju lr mo mh lu lv mp mi ly lz mq mj mc md me ij bi translated">在数学中，<strong class="ll ir">单元素</strong>，也称为<strong class="ll ir">单位集</strong>，是恰好有一个元素的集合。例如，集合{null}是一个单例。</p></blockquote><p id="ac9b" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在软件中，这仅仅意味着我们将一个类的实例化限制到一个对象。实现singleton模式的类的对象第一次被实例化时，它实际上会被实例化。任何后续尝试都将返回第一个实例。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/fe511be3c6f4abe517312f2fde549dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JsnR25Uewd4wZLzZ-a9frg.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">有了蝙蝠侠谁还需要两个超级英雄？</figcaption></figure><h2 id="deae" class="mw ks iq bd kt mx my dn kx mz na dp lb ls nb nc ld lw nd ne lf ma nf ng lh nh bi translated">为什么</h2><p id="92a1" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">除了允许我们只能有一个超级英雄(很明显是蝙蝠侠)，我们为什么要使用单身模式呢？</p><p id="c806" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">尽管单身模式并非没有问题(它以前被称为邪恶，单身者被称为病态说谎者)，但它仍然有其用途。最值得注意的是实例化配置对象。您可能只希望您的应用程序有一个配置实例，除非您的应用程序的一个特性是提供多个配置。</p><h2 id="378f" class="mw ks iq bd kt mx my dn kx mz na dp lb ls nb nc ld lw nd ne lf ma nf ng lh nh bi translated">哪里</h2><p id="6abf" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Angular的服务是大型流行框架中使用单例模式的主要例子。Angular的文档中有一个<a class="ae nj" href="https://angular.io/guide/singleton-services" rel="noopener ugc nofollow" target="_blank">专用页面</a>解释了如何确保一个服务总是作为单例提供。</p><p id="26a6" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">服务是单例的很有意义，因为服务被用作存储状态、配置和允许组件之间通信的地方，并且您希望确保没有多个实例混淆这些概念。</p><p id="f66f" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">例如，假设您有一个简单的应用程序，用于计算按钮被点击的次数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/3a6a53f04214bc1cb6a72fbe7598f658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZpt4afyPY10CnuRADJx5w.png"/></div></div></figure><p id="96b9" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">您应该跟踪一个对象中按钮按下的次数，该对象提供:</p><ul class=""><li id="720a" class="nl nm iq ll b lm mf lp mg ls nn lw no ma np me nq nr ns nt bi translated">计数的功能</li><li id="a579" class="nl nm iq ll b lm nu lp nv ls nw lw nx ma ny me nq nr ns nt bi translated">并提供当前的点击次数。</li></ul><p id="8877" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">如果该对象不是单例对象(每个按钮都有自己的实例)，那么点击计数就不正确。此外，您将向显示当前计数的组件提供哪个计数实例？</p><h1 id="0565" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">观察者模式</h1><h2 id="0203" class="mw ks iq bd kt mx my dn kx mz na dp lb ls nb nc ld lw nd ne lf ma nf ng lh nh bi translated">什么</h2><p id="ee5b" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">观察者模式定义如下:</p><blockquote class="ml mm mn"><p id="1fea" class="lj lk mk ll b lm mf jr lo lp mg ju lr mo mh lu lv mp mi ly lz mq mj mc md me ij bi translated"><strong class="ll ir">观察者模式</strong>是一种软件设计模式，其中一个名为<strong class="ll ir">主题</strong>的对象维护一个名为<strong class="ll ir">观察者</strong>的依赖者列表，并自动通知它们任何状态变化，通常是通过调用它们的方法之一。</p></blockquote><p id="55a3" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">如果我们尝试将观察者模式与现实世界中的一个例子——报纸订阅进行比较，就很容易理解观察者模式。</p><p id="25fb" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">买报纸时通常的情况是，你走到报摊前，询问你最喜欢的报纸的新一期是否出版了。如果不是，这是一个可悲的低效率的事情，你不得不走回家，稍后再试。用JavaScript术语来说，这就相当于循环，直到得到想要的结果。<br/>当你最终拿到报纸时，你可以做你一直想做的事情——坐下来喝杯咖啡，享受你的报纸(或者，用JavaScript术语来说，执行你一直想做的回调函数)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/be9a07014581d0f451266e979c98c926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*arrsn5kxG1GRbVpn7tlZkw.jpeg"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">最后。</figcaption></figure><p id="fda9" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">明智的做法是订阅报纸(并且每天都能得到你喜爱的报纸)。这样，出版公司会在新一期报纸发行时通知你，并把它送到你手中。再也不用跑去报摊了。不再失望。极乐世界。<br/>用JavaScript的术语来说，在你运行一个函数之前，你不会循环并询问结果。相反，您应该让主题知道您对事件(消息)感兴趣，并提供一个回调函数，当新数据准备好时应该调用该函数。那么，你就是观察者。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/e025e466bb1ee65845edb40614bf0c2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Umz-GYQk5skILT07e0Kr4A.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">再也不要错过你的晨报。</figcaption></figure><p id="5ce7" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">好的一面是——你不必是唯一的订户。正如你会因为错过报纸而失望一样，其他人也会失望。这就是为什么多个观察者可以订阅该主题。</p><h2 id="add6" class="mw ks iq bd kt mx my dn kx mz na dp lb ls nb nc ld lw nd ne lf ma nf ng lh nh bi translated">为什么</h2><p id="a222" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">observer模式有许多用例，但通常，当您想要在非紧密耦合的对象之间创建一对多的依赖关系，并且有可能让数量不限的对象知道状态何时发生变化时，应该使用它。</p><p id="919e" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">JavaScript是可观察模式的好地方，因为一切都是事件驱动的，而不是总是询问事件是否发生，你应该让事件通知你(就像古老的谚语<em class="mk">“不要打电话给我们，我们会打电话给你”</em>)。很可能你已经做了一些看起来像观察者模式的事情。将事件侦听器添加到元素中具有观察者模式的所有特征:</p><ul class=""><li id="5ed3" class="nl nm iq ll b lm mf lp mg ls nn lw no ma np me nq nr ns nt bi translated">您可以订阅该对象，</li><li id="19d5" class="nl nm iq ll b lm nu lp nv ls nw lw nx ma ny me nq nr ns nt bi translated">您可以取消订阅该对象，</li><li id="204e" class="nl nm iq ll b lm nu lp nv ls nw lw nx ma ny me nq nr ns nt bi translated">并且该对象可以向其所有订户广播事件。</li></ul><p id="cfe6" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">学习观察者模式的最大收获是，您可以更快地实现自己的主题或掌握一个已经存在的解决方案。</p><h2 id="0f68" class="mw ks iq bd kt mx my dn kx mz na dp lb ls nb nc ld lw nd ne lf ma nf ng lh nh bi translated">哪里</h2><p id="8b59" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">实现一个基本的observable应该不会太难，但是有一个很棒的库被许多项目使用，那就是<a class="ae nj" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank">react vex</a>，其中<a class="ae nj" href="https://github.com/ReactiveX/rxjs" rel="noopener ugc nofollow" target="_blank"> RxJS </a>是它的JavaScript对应物。</p><p id="3470" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">RxJS不仅允许您订阅主题，还允许您以任何可以想象的方式转换数据，组合多个订阅，使异步工作更易于管理。如果您想将数据处理和转换水平提高到一个更高的水平，RxJS将是一个很好的学习库。</p><p id="3130" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">除了观察者模式之外，ReactiveX还以实现迭代器模式而自豪，迭代器模式使主体有可能让其订阅者知道订阅何时结束，有效地从主体端结束订阅。在本文中，我不打算解释迭代器模式，但是对你来说，学习更多的迭代器模式，看看它是如何适应observable模式的，将是一个很好的练习。</p><h1 id="1b1b" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">立面图案</h1><h2 id="21f5" class="mw ks iq bd kt mx my dn kx mz na dp lb ls nb nc ld lw nd ne lf ma nf ng lh nh bi translated">什么</h2><p id="6f82" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">facade模式是一种以建筑学命名的模式。在建筑领域:</p><blockquote class="ml mm mn"><p id="c27d" class="lj lk mk ll b lm mf jr lo lp mg ju lr mo mh lu lv mp mi ly lz mq mj mc md me ij bi translated">立面通常是建筑物的一面，通常是正面。这是一个外来词，来自法语<em class="iq">faade</em>，意思是“正面”或“脸”。</p></blockquote><p id="ba31" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">由于架构中的外观是建筑物的外部，隐藏了其内部工作，因此软件开发中的外观模式试图将底层的复杂性隐藏在前面，有效地允许您使用更容易掌握的API，同时提供了按照您想要的方式更改底层代码的可能性。</p><h2 id="8499" class="mw ks iq bd kt mx my dn kx mz na dp lb ls nb nc ld lw nd ne lf ma nf ng lh nh bi translated">为什么</h2><p id="3318" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">您可以在许多情况下使用facade模式，但最值得注意的是使您的代码更容易理解(隐藏复杂性)并使依赖尽可能松散耦合。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/40696a7beaf2a5b7f3291461a812dad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Unh3rSLKfaMzs3gweZF7UQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">Fus Ro Dah！</figcaption></figure><p id="c664" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">很容易理解为什么一个facade对象(或者包含多个对象的层)是一个好东西。如果可以避免的话，你不会想和龙打交道。facade对象将为您提供一个很好的API，并自己处理所有的dragon恶作剧。</p><p id="50e7" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们在这里可以做的另一件大事是在不影响应用程序其余部分的情况下从背景中改变龙。假设你想用一只小猫把龙换出来。它仍然有爪子，但更容易喂养。改变它就是在不改变任何依赖对象的情况下重写外观中的代码。</p><h2 id="40c1" class="mw ks iq bd kt mx my dn kx mz na dp lb ls nb nc ld lw nd ne lf ma nf ng lh nh bi translated">哪里</h2><p id="43a5" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">一个地方，你会看到门面往往是角使用其服务作为一种简化背景逻辑的手段。但它不一定只是有角的，你将在下一个例子中看到。</p><p id="90df" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">假设您想在应用程序中添加状态管理。你可以选择Redux、NgRx、Akita、MobX、Apollo或任何一款新上市的产品。那么，为什么不把它们都选出来，带它们去兜风呢？</p><p id="f328" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">状态管理库将为你提供什么基本功能？</p><p id="1c52" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">大概是:</p><ul class=""><li id="3bbe" class="nl nm iq ll b lm mf lp mg ls nn lw no ma np me nq nr ns nt bi translated">一种让状态管理知道您想要状态改变的方式</li><li id="4433" class="nl nm iq ll b lm nu lp nv ls nw lw nx ma ny me nq nr ns nt bi translated">以及获取当前(部分)状态的方法。</li></ul><p id="03df" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">那听起来不太坏。</p><p id="3a85" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">现在，有了facade模式的强大功能，您可以为状态的每个部分编写facade，它们将为您提供一个很好的API类似于<code class="fe ob oc od oe b">facade.startSpinner()</code>、<code class="fe ob oc od oe b">facade.stopSpinner()</code>和<code class="fe ob oc od oe b">facade.getSpinnerState()</code>。这些方法很容易理解和推理。</p><p id="bf7a" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">之后，您可以处理外观并编写代码，该代码将转换您的代码，以便它可以与Apollo一起工作(使用GraphQL管理状态——现在非常热门)。你可能会注意到它根本不适合你的编码风格，或者单元测试的编写方式真的不适合你。没问题，写一个新的facade来支持MobX。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/24a85808503c7f3d272664e27ee25baa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O3pSZ9xOfBkk7lO0CtGCPA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">还不如是龙…</figcaption></figure><h1 id="60f8" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">从这里去哪里</h1><p id="0e8a" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">您可能已经注意到，我谈到的设计模式没有任何代码或实现。这是因为这些设计模式中的每一个都至少可以成为一本书中的一章。</p><p id="70a8" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">既然我们在谈论书籍，深入研究一下一两本关于设计模式的书不会有什么坏处。</p><p id="979e" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">第一个也是最大的推荐是<a class="ae nj" href="http://wiki.c2.com/?DesignPatternsBook" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir">设计模式:可重用面向对象软件的元素</strong> </a> <em class="mk"> </em>由<em class="mk"> Erich Gamma </em>、<em class="mk"> Richard Helm </em>、<em class="mk"> Ralph Johnson </em>和<em class="mk"> John Vlisside </em>组成，也被称为<em class="mk">四人组</em>。这本书是一座金矿，也是软件设计模式事实上的圣经。</p><p id="2705" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">如果你正在寻找更容易消化的东西，有<a class="ae nj" href="https://www.goodreads.com/book/show/58128.Head_First_Design_Patterns" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir">头先设计图案</strong> </a>由<em class="mk">伯特贝茨</em><em class="mk">凯西塞拉</em><em class="mk">埃里克弗里曼</em>和<em class="mk">伊丽莎白罗布森</em>。这是一本非常好的书，它试图通过视觉视角传达设计模式的信息。</p><p id="7eb5" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">最后但同样重要的是，没有什么比谷歌搜索、阅读和尝试不同的方法更好的了。即使你最终从未使用过某个模式或技术，你也会学到一些东西，并以你意想不到的方式成长。</p><p id="d254" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><em class="mk">插图中使用的语音气泡由</em><a class="ae nj" href="https://www.freepik.com/free-photos-vectors/frame" rel="noopener ugc nofollow" target="_blank"><em class="mk">starline—www.freepik.com</em></a><em class="mk">制作。</em></p></div><div class="ab cl oh oi hu oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt oo"><a href="https://gitconnected.com/learn/javascript" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">学习JavaScript -最佳JavaScript教程(2019) | gitconnected</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">50大JavaScript教程-免费学习JavaScript。课程由开发人员提交并投票，从而实现…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">gitconnected.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc kp oo"/></div></div></a></div></div></div>    
</body>
</html>