<html>
<head>
<title>Train/Test Complexity and Space Complexity of Logistic Regression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逻辑回归的训练/测试复杂度和空间复杂度</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/train-test-complexity-and-space-complexity-of-logistic-regression-2cb3de762054?source=collection_archive---------3-----------------------#2020-08-23">https://levelup.gitconnected.com/train-test-complexity-and-space-complexity-of-logistic-regression-2cb3de762054?source=collection_archive---------3-----------------------#2020-08-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/373b331b2e7689e3fb7630800abce94e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8qaJdIH1ZAR1Ybuw.png"/></div></div></figure><p id="0b8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">任何机器学习算法的工作流程都很简单。然而，如果训练数据似乎永远在运行，这个工作流可能会变得复杂！当您拥有大数据时，就会出现这种情况。大数据的挑战体现在推理和计算两个方面。然而，你不能抛弃数据。在分析中，<strong class="ka ir">永远没有“充足”的数据</strong>。当你获得越来越多的数据时，你可以开始细分数据以获得更好的洞察力。解决这种问题的唯一方法是比较各种机器学习算法的计算复杂性，这些算法可以为您的问题提供解决方案，并在这些算法中找到最好的，可以产生及时、准确和精确的分析和决策。</p><p id="56b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文描述了逻辑回归的计算复杂性。逻辑回归用于线性可分数据或几乎线性可分数据的二元分类。在深入研究逻辑回归的计算复杂性之前，我建议你浏览一下我关于<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/train-test-complexity-and-space-complexity-of-linear-regression-26b604dcdfa3">线性回归的训练/测试复杂性和空间复杂性</a>的博客。这篇博客描述了时间和空间的复杂性以及大O的概念。您还将了解线性回归的计算复杂性。所以，如果你对这些概念不熟悉，那么在阅读本文之前，你必须先看看我以前的博客。</p><h1 id="e554" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">逻辑回归入门</h1><p id="df63" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">每种机器学习算法在给定的一组条件下工作得最好。确保您的算法符合卓越性能的假设/要求非常重要。你不能在任何条件下使用任何算法。例如:我们不能对分类因变量使用线性回归。因为我们不会因为得到极低的调整后R值和F1值而得到赞赏。相反，在这种情况下，我们应该尝试使用逻辑回归、决策树、支持向量机(SVM)、随机森林等算法。</p><p id="e458" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">逻辑回归</strong>是一种机器学习分类算法，用于预测分类因变量的概率。在逻辑回归中，因变量是一个二元变量，包含编码为1的数据(是，成功，等等)。)或0(否，失败等。).换句话说，逻辑回归模型预测P(Y=1)是x的函数。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/f81ec3e1fc54a7f1915117d3910b6dde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RSRb9G0TA-fwPojO2pYkWA.png"/></div></div></figure><h1 id="ee61" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">平面方程</h1><p id="4632" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">穿过3D空间中的点A = (x1，y1，z1)的平面的方程，其法向量n = (a，b，c)定义为:</p><p id="ce65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">a(x-x1)+b(y-y1)+c(z-Z1)+b = 0</strong></p><p id="2b11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> ax + by + cz + b= 0其中b = -(ax1+by1+cz1) </strong></p><p id="4ddd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了简单起见，我们也可以把它写成:</p><p id="6d89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> w1x1 +w2x2 + w3x3 + b= 0 </strong></p><p id="0f37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这与<strong class="ka ir"> w^t * xi + b= 0 </strong>相同，其中xi是第I个观测值。</p><p id="1ffc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果平面通过原点，那么方程变成<strong class="ka ir"> w^t *xi = 0。</strong>其中<strong class="ka ir"> w^t( </strong> w转置<strong class="ka ir"> ) </strong>为行向量<strong class="ka ir"> xi </strong>为列向量，b(截距)为标量。如果我们有二维空间，那么等式变成w1x1 + w2x2 + b = 0，如果我们有n维空间，那么等式变成w0 + w1x1 + w2x2 + w3x3 +……..….wnxn = 0。</p><h1 id="316b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">逻辑回归背后的几何直觉</h1><p id="28b6" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">设一个数据集(D)由x(特征/自变量)和y(目标/因变量)组成，即n个数据点的D ∈ {xi，易}。每个xi是一个实值d维特征向量，每个yi是1或-1。逻辑回归的基本假设是数据几乎是线性可分的(即一些+ve类点在-ve类中，反之亦然)或完全线性可分的(没有点与其他类混合)(如下图所示)。我们的主要目标是找到一条线(在2D中)或平面/超平面(在3D或更多维中),它可以尽可能完美地将两个类点分开，这样当它遇到任何新点时，它可以很容易地分类，它属于哪个类点。由于x和y是在训练数据中给定的，所以如果我们可以找到w(法线)和b (y截距)，那么我们可以很容易地找到一条线或平面，也称为决策边界，它几乎可以线性地分隔这两个类。这里，我们将只关注两个特性(x1和x2 ),这样直觉就变得容易了。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/cd3c453a9f034e676eac77ebaf91e7e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iZUlMmFleYNMHKtAcUAkxw.png"/></div></div></figure><p id="463e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们取+ve类的任意一个点，计算一个点到平面的最短距离(如下图所示)。最短距离由下式给出:</p><p id="93ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">迪= w^t*xi/||w|| </strong></p><p id="8b94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">设，||w||=1。然后，</p><p id="842d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">迪= w^t*xi </strong></p><p id="f6a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于w和xi位于决策边界的同一侧，因此距离将为+ve。现在计算dj = w^t*xj.因为xj是w的对边，所以距离是-ve。由此我们可以得出结论，与w方向相同的点都是+ve点，与w方向相反的点都是-ve点。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/58d7d5c3922f513593b0547a250216c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*XCVZ20ewk9N33inNIgaiYA.png"/></div></figure><p id="8f8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以很容易地对-ve和+ve点进行分类。如果w^t*xi&gt;0，那么y =+1，如果w^t*xi &lt; 0 then y = -1.</p><p id="c7a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">观察:</strong></p><p id="b6c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">查看上图并观察下面列出的所有要点:</p><ul class=""><li id="5931" class="mh mi iq ka b kb kc kf kg kj mj kn mk kr ml kv mm mn mo mp bi translated">如果yi = +1且w^t*xi &gt; 0，那么分类器(一种数学函数，由分类算法实现，将输入数据映射到一个类别)将其分类为+ve个点。那么，如果yi*w^t*xi &gt; 0，会发生什么？那么它就是正确分类的点，因为两个+ve数相乘总是大于0。</li><li id="0e68" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated">如果yi = -1并且w^t*xi &lt; 0, then classifier classifies it as -ve point. If yi * w^t*xi &gt; 0，那么它是正确分类的点，因为两个ve数相乘将总是大于0。所以对于+ve和-ve点，yi* w^t*xi &gt; 0。这意味着模型正确地对xi点进行了分类。</li><li id="f3f7" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated">如果yi = +1并且w^t*xi &lt; 0, i.e, yi is +ve point but classifier is saying it is -ve then we will get -ve value. Which means actual class label is +ve but it is classified as -ve then this is miss-classified point.</li><li id="0237" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated">If yi = -1 and w^t*xi &gt; 0，这意味着实际类标签是-ve但是被分类为+ve，那么它是误分类点(yi*w^t*xi &lt; 0).</li></ul><p id="ea47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">From above observations, we want our classifier to minimize miss-classification error, i.e, we want yi*w^t*xi to be greater than 0. Here, xi, yi are fixed because these are coming from data-set. As we change w, and b the sum will change and we want to find such w and b that maximize the sum given below. w and b can be calculated using Gradient Descent.</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/2ca343910d975a80d5d8252fba376b98.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*HmnuwrF0YUx72WNkdUhSUw.png"/></div></figure><p id="8371" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Now that you have understood Logistic Regression let’s move on to train/test complexity and space complexity of Logistic Regression.</p><h1 id="6b07" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Train complexity of Logistic Regression</h1><p id="548b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">As discussed earlier to train a Logistic Regression model, we just need w and b to find a line(in 2D) or plane/hyperplane(in 3D or more dimension) that can separate both the classes point as perfect as possible so that when it encounter with any new point, it can easily classify, from which class point it belongs to. The value of w and b should be such that it maximize the sum yi*w^t*xi &gt; 0。</p><p id="85b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们用大O来计算:</p><ol class=""><li id="edca" class="mh mi iq ka b kb kc kf kg kj mj kn mk kr ml kv mw mn mo mp bi translated">w是大小为d的向量。执行yi*w^t*xi运算需要O(d)步。</li><li id="5e24" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mw mn mo mp bi translated">在n个数据点上迭代并找到最大和需要n步。</li></ol><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/2ca343910d975a80d5d8252fba376b98.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*HmnuwrF0YUx72WNkdUhSUw.png"/></div></figure><p id="79de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在训练逻辑回归模型期间的时间复杂度是n(O(d))=O(nd)。</p><h1 id="2496" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">逻辑回归的测试/运行时复杂性</h1><p id="f2a3" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">运行时复杂性非常重要，因为在训练结束时，我们在看不见的数据上测试我们的模型，并计算我们模型的准确性。在逻辑回归的情况下，在训练模型后，我们得到w和b。给定任何新的点，我们只需执行w^t * xi运算。如果是w^t*xi&gt;0，点是+ve，如果是w^t*xi&lt;0，点是负的。由于w是一个大小为d的向量，如前所述，执行w^t*xi运算需要O(d)步。所以，逻辑回归的运行时间复杂度是O(d)。因此，逻辑回归非常适用于低延迟应用，即数据规模较小的应用。</p><h1 id="aa5a" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">逻辑回归的空间复杂性</h1><p id="efa7" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在训练一个逻辑回归模型的过程中，我们需要在内存中存储四样东西:x，y，w和b。由于b是一个常数，所以存储b只是一个步骤，即O(1)运算。x和y分别是(n×d)和(n×1)阶的两个矩阵。存储这两个矩阵需要O(nd + n)步。最后，w是一个大小为d的向量，将它存储在内存中需要O(d)步。所以，训练时的空间复杂度为O(nd + n +d)。</p><p id="1a15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在训练模型之后，我们只需要在内存中保存w。我们只需要执行w^t*x1来分类这些点。因此，运行时的空间复杂度为d，即O(d)。</p><p id="0617" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">结论:<br/> </strong>如果你的数据量很大，选择算法是基于你要解决的问题。如果你对一个问题有不同的解决方案，你可以比较它们的运行时间来得到答案。然而，时间复杂性并不是你应该考虑的唯一因素。您还应该考虑您的代码是否足够易读，以及您的代码将消耗多少内存。</p><p id="b9a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mx">如果你觉得这很有帮助，别忘了点击</em>👏图标<em class="mx">。这对你的手指是一个很好的锻炼，并且会帮助其他人看到这个故事。谢谢大家！</em>😊</p></div></div>    
</body>
</html>