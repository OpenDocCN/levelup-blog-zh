<html>
<head>
<title>React/React Native: 6 Ways To Optimize React Performance + How To Test Component Render Speed</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React/React Native:优化React性能的6种方法+如何测试组件渲染速度</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-react-native-optimizing-react-component-performance-16a82efaa4af?source=collection_archive---------1-----------------------#2020-10-08">https://levelup.gitconnected.com/react-react-native-optimizing-react-component-performance-16a82efaa4af?source=collection_archive---------1-----------------------#2020-10-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1740" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">作者:杰夫·刘易斯</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d14c40eb818fa74d0adada668859eefd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gY0_nL_cQOItA8P18fJDMw.png"/></div></div></figure><p id="87ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">备注:</strong></p><ul class=""><li id="7c92" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">本指南假设你知道<strong class="kt ir">反应</strong>和<strong class="kt ir">反应本土。</strong></li></ul><h1 id="18c3" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">1.使用useEffect()挂钩最小化渲染</h1><p id="fe67" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">在下面的例子中，<code class="fe mt mu mv mw b">useEffect()</code>钩子有3个参数:<code class="fe mt mu mv mw b">dropdownSetting</code>、<code class="fe mt mu mv mw b">props.maricopaCountyDates</code>、<code class="fe mt mu mv mw b">props.unitedStatesDates</code>。每当这些参数中的一个改变时，<code class="fe mt mu mv mw b">useEffect()</code>钩子将运行，它将使用<code class="fe mt mu mv mw b">setDates</code>修改状态。</p><p id="a904" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是优化的切入点。当组件状态更改时，组件会重新呈现，但这些重新呈现的内容可以最小化。这个 <strong class="kt ir">意味着更快的渲染，更少的计算，最少的API调用，等等。在下面的示例中，我们将了解为什么示例A没有优化，而示例B却优化了。</strong></p><h2 id="ad12" class="mx lx iq bd ly my mz dn mc na nb dp mg la nc nd mi le ne nf mk li ng nh mm ni bi translated">示例A: useEffect()钩子(状态改变3次= 3次呈现)</h2><ul class=""><li id="d4b1" class="ln lo iq kt b ku mo kx mp la nj le nk li nl lm ls lt lu lv bi translated"><strong class="kt ir">该组件渲染3次，因为每次</strong>都会设置状态:一次为<code class="fe mt mu mv mw b">dropdownSetting</code>，一次为API调用结束并传递数据时<code class="fe mt mu mv mw b">props.maricopaCountyDates</code>，一次为API调用结束并传递数据时<code class="fe mt mu mv mw b">props.unitedStatesDates</code>。</li><li id="dc9e" class="ln lo iq kt b ku nm kx nn la no le np li nq lm ls lt lu lv bi translated">值得注意的是，在我的应用程序中，我有<strong class="kt ir"> 2个API调用，在父组件中有一个空数组[]的默认状态。</strong>父组件和子组件将同时挂载。然而，API请求需要300到500毫秒。此时，子组件的<code class="fe mt mu mv mw b">useEffect</code>用一个<strong class="kt ir">空数组(默认状态是[])钩住<code class="fe mt mu mv mw b">setsDates</code>，并将道具传递给子组件。</strong>一旦API请求完成，<strong class="kt ir">父组件将再次传递道具</strong>，这是一个充满字符串的数组<code class="fe mt mu mv mw b">[‘item1,’ ‘item2', ‘item3’, ‘item4', ‘item5']</code>。</li><li id="696f" class="ln lo iq kt b ku nm kx nn la no le np li nq lm ls lt lu lv bi translated">由于<code class="fe mt mu mv mw b">useEffect</code>在参数之一(<code class="fe mt mu mv mw b">dropdownSetting</code>、<code class="fe mt mu mv mw b">props.maricopaCountyDates</code>、<code class="fe mt mu mv mw b">props.unitedStatesDates</code>)每次改变时运行，因此当属性从<code class="fe mt mu mv mw b">[]</code>和<code class="fe mt mu mv mw b">[‘item1,’ ‘item2', ‘item3’, ‘item4', ‘item5']</code>改变时，它将运行两次。</li></ul><p id="4e1b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">父组件:</strong></p><pre class="kg kh ki kj gt nr mw ns nt aw nu bi"><span id="a88f" class="mx lx iq mw b gy nv nw l nx ny"><strong class="mw ir">// React Hooks: State<br/></strong>const [ maricopaCountyDates, setMaricopaCountyDates ] = useState([]);<br/>const [ unitedStatesDates, setUnitedStatesDates ] = useState([]);</span><span id="60df" class="mx lx iq mw b gy nz nw l nx ny"><strong class="mw ir"><em class="oa">// React Hooks: Lifecycle Methods<br/></em></strong>useEffect(() =&gt; {<br/><strong class="mw ir">  <em class="oa">// Get United States Data<br/></em></strong><em class="oa">  </em>const getUnitedStatesData = async () =&gt; {<br/>    try {<br/><strong class="mw ir">      <em class="oa">// Axios: API<br/></em></strong><em class="oa">      </em>const response = await axios.get('URL_HERE');</span><span id="75b0" class="mx lx iq mw b gy nz nw l nx ny"><strong class="mw ir">      // Set State<br/></strong>      setUnitedStatesDates(response.data);<br/>    }<br/>    catch (error) {<br/>      console.log(error);<br/>    }<br/>  };</span><span id="21d0" class="mx lx iq mw b gy nz nw l nx ny"><strong class="mw ir"><em class="oa">  // Get United States Data<br/></em></strong><em class="oa">  </em>getUnitedStatesData();<br/>}, []);</span></pre><p id="bee7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">子组件:</strong></p><pre class="kg kh ki kj gt nr mw ns nt aw nu bi"><span id="d0e5" class="mx lx iq mw b gy nv nw l nx ny"><strong class="mw ir"><em class="oa">// React Hooks: Lifecycle Methods</em></strong><em class="oa"><br/></em>useEffect(() =&gt; {<br/><strong class="mw ir">  <em class="oa">// Dropdown Setting: Maricopa County<br/></em></strong><em class="oa">  </em>if (dropdownSetting === 'Maricopa County') {<br/><strong class="mw ir">    <em class="oa">// Set Dates<br/></em></strong><em class="oa">    </em>setDates(props.maricopaCountyDates);<br/>  }<br/><strong class="mw ir">  <em class="oa">// Dropdown Setting: United States<br/></em></strong><em class="oa">  </em>else if (dropdownSetting === 'United States') {<br/><strong class="mw ir">    <em class="oa">// Set Dates<br/></em></strong><em class="oa">    </em>setDates(props.unitedStatesDates);<br/>  }<br/>}, [dropdownSetting, props.maricopaCountyDates, props.unitedStatesDates]);</span></pre><h2 id="e2ce" class="mx lx iq bd ly my mz dn mc na nb dp mg la nc nd mi le ne nf mk li ng nh mm ni bi translated">示例B:优化的useEffect()钩子(状态改变1次= 1次渲染)</h2><ul class=""><li id="bc5c" class="ln lo iq kt b ku mo kx mp la nj le nk li nl lm ls lt lu lv bi translated">下面优化的<code class="fe mt mu mv mw b">useEffect()</code>钩子执行得更好是由于当我们在 <code class="fe mt mu mv mw b"><strong class="kt ir">useEffect()</strong></code> <strong class="kt ir">钩子子组件内<code class="fe mt mu mv mw b">// Check If Data Exists</code> <strong class="kt ir">的时候。</strong></strong></li></ul><pre class="kg kh ki kj gt nr mw ns nt aw nu bi"><span id="fc0c" class="mx lx iq mw b gy nv nw l nx ny"><strong class="mw ir"><em class="oa">// React Hooks: Lifecycle Methods</em></strong><em class="oa"><br/></em>useEffect(() =&gt; {<br/><strong class="mw ir">  <em class="oa">// Check If Data Exists<br/></em></strong><em class="oa">  </em>if (props.maricopaCountyDates.length &gt;= 1 &amp;&amp; props.unitedStatesDates.length &gt;= 1) {<br/><strong class="mw ir">    <em class="oa">// Dropdown Setting: Maricopa County<br/></em></strong><em class="oa">    </em>if (dropdownSetting === 'Maricopa County') {<br/><strong class="mw ir">      <em class="oa">// Set Dates<br/></em></strong><em class="oa">      </em>setDates(props.maricopaCountyDates);<br/>    }<br/><strong class="mw ir">    <em class="oa">// Dropdown Setting: United States<br/></em></strong><em class="oa">    </em>else if (dropdownSetting === 'United States') {<br/><strong class="mw ir">      <em class="oa">// Set Dates<br/></em></strong><em class="oa">      </em>setDates(props.unitedStatesDates);<br/>    }<br/>  }<br/>}, [dropdownSetting, props.maricopaCountyDates, props.unitedStatesDates]);</span></pre><ul class=""><li id="b192" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">检查<code class="fe mt mu mv mw b">props.maricopaCountyDates.length &gt;= 1 &amp;&amp; props.unitedStatesDates.length &gt;= 1</code>是我们可以<strong class="kt ir">管理和最小化我们运行</strong> <code class="fe mt mu mv mw b"><strong class="kt ir">setDates</strong></code> <strong class="kt ir">，</strong>的次数的地方，它设置状态以降低组件重新渲染的性能。</li><li id="4b79" class="ln lo iq kt b ku nm kx nn la no le np li nq lm ls lt lu lv bi translated">由于<code class="fe mt mu mv mw b">props.maricopaCountyDates</code>和<code class="fe mt mu mv mw b">props.unitedStatesDates</code>的初始状态是空数组，<strong class="kt ir">我们可以通过检查这两个数组的长度是否都大于等于1</strong>(<code class="fe mt mu mv mw b">props.maricopaCountyDates.length &gt;= 1 &amp;&amp; props.unitedStatesDates.length &gt;= 1</code>)来减少任何重新渲染。</li><li id="5597" class="ln lo iq kt b ku nm kx nn la no le np li nq lm ls lt lu lv bi translated"><strong class="kt ir">代码已优化为仅设置一次状态，这将导致1次渲染，而不是3次渲染。</strong>如果你是道具钻取，这个数字甚至会更高，这会重新渲染嵌套组件。</li></ul><h1 id="f674" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">2.useMemo()挂钩</h1><p id="a2e9" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">React允许开发人员使用一个<code class="fe mt mu mv mw b">useMemo()</code>钩子，<strong class="kt ir">在这里我们可以使用内存化的优化技术。</strong></p><h2 id="f6bd" class="mx lx iq bd ly my mz dn mc na nb dp mg la nc nd mi le ne nf mk li ng nh mm ni bi translated"><strong class="ak">记忆化:</strong></h2><p id="4633" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">在代码中，<strong class="kt ir">记忆化通过存储昂贵的函数调用的结果并在相同的输入再次出现时返回缓存的结果来加速计算机程序。</strong>在记忆化中，当相同的精确参数随后被传入时，结果被记忆。如果我们有一个函数compute 1 + 1，它将返回2。但是如果我们使用<strong class="kt ir"> useMemo() </strong>钩子，下一次我们通过函数运行1时，它不会把它们加起来，它只会记住答案是2，而不会执行加法函数。</p><h2 id="fb2b" class="mx lx iq bd ly my mz dn mc na nb dp mg la nc nd mi le ne nf mk li ng nh mm ni bi translated">useMemo只应在某些情况下使用:</h2><p id="0fd9" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">但是，<code class="fe mt mu mv mw b"><strong class="kt ir">useMemo()</strong></code> <strong class="kt ir">只应在特定情况下使用。</strong>即使我们用它来加1 + 1作为例子，<strong class="kt ir">加1 + 1不是一个昂贵的函数，</strong> <code class="fe mt mu mv mw b"><strong class="kt ir">useMemo()</strong></code> <strong class="kt ir">不应该使用。</strong>这只是为了演示，但在考虑<code class="fe mt mu mv mw b">useMemo()</code>时，这里有一些事情需要考虑。</p><ul class=""><li id="b19e" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">当考虑实现<code class="fe mt mu mv mw b">useMemo()</code> hook时，<strong class="kt ir">确定它是否真的是一个昂贵的函数，它会消耗内存等资源。</strong></li><li id="2d84" class="ln lo iq kt b ku nm kx nn la no le np li nq lm ls lt lu lv bi translated">你正在<strong class="kt ir">render</strong>的函数中定义大量的变量，用<code class="fe mt mu mv mw b">useMemo()</code>钩子来记忆可能是最佳的。</li><li id="10a3" class="ln lo iq kt b ku nm kx nn la no le np li nq lm ls lt lu lv bi translated">如果<code class="fe mt mu mv mw b">useMemo()</code>钩子依赖数组为空，<strong class="kt ir">这意味着不可能记忆</strong>，它将在每次渲染时计算一个新值。那将违背<code class="fe mt mu mv mw b">useMemo</code>的目的。</li></ul><h2 id="0ed0" class="mx lx iq bd ly my mz dn mc na nb dp mg la nc nd mi le ne nf mk li ng nh mm ni bi translated">示例A:标准值</h2><pre class="kg kh ki kj gt nr mw ns nt aw nu bi"><span id="0267" class="mx lx iq mw b gy nv nw l nx ny"><strong class="mw ir">// Standard Value</strong><br/>const standardValue = computeExpensiveValue(a, b);</span></pre><h2 id="7492" class="mx lx iq bd ly my mz dn mc na nb dp mg la nc nd mi le ne nf mk li ng nh mm ni bi translated">示例B:优化的useMemo()值</h2><pre class="kg kh ki kj gt nr mw ns nt aw nu bi"><span id="ea40" class="mx lx iq mw b gy nv nw l nx ny"><strong class="mw ir">// Memoized Value</strong><br/>const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</span></pre><h1 id="7432" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">3.useCallback()挂钩</h1><p id="6f50" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">与<code class="fe mt mu mv mw b">useMemo()</code>类似，<code class="fe mt mu mv mw b">useCallback()</code> <strong class="kt ir">也采用记忆化，只是方式不同。</strong></p><p id="8908" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mt mu mv mw b"><strong class="kt ir">useCallback()</strong></code> <strong class="kt ir">不是保存从函数返回的记忆化值，而是返回回调的记忆化版本，该版本仅在其中一个依赖关系改变时才会改变。</strong></p><h2 id="7f4f" class="mx lx iq bd ly my mz dn mc na nb dp mg la nc nd mi le ne nf mk li ng nh mm ni bi translated"><strong class="ak">例子A:回调函数</strong></h2><pre class="kg kh ki kj gt nr mw ns nt aw nu bi"><span id="7d41" class="mx lx iq mw b gy nv nw l nx ny"><strong class="mw ir">// Increment<br/></strong>const increment = (() =&gt; {<br/>  setCount(count + 1);<br/>});</span><span id="2ffd" class="mx lx iq mw b gy nz nw l nx ny"><strong class="mw ir">// Decrement<br/></strong>const decrement = (() =&gt; {<br/>  setCount(count - 1);<br/>});</span></pre><h2 id="dfda" class="mx lx iq bd ly my mz dn mc na nb dp mg la nc nd mi le ne nf mk li ng nh mm ni bi translated">示例B:优化的useCallback()函数</h2><pre class="kg kh ki kj gt nr mw ns nt aw nu bi"><span id="de21" class="mx lx iq mw b gy nv nw l nx ny"><strong class="mw ir">// Increment</strong><br/>const increment = useCallback(() =&gt; {<br/>  setCount(count + 1);<br/>}, [count]);</span><span id="dca1" class="mx lx iq mw b gy nz nw l nx ny"><strong class="mw ir">// Decrement</strong><br/>const decrement = useCallback(() =&gt; {<br/>  setCount(count - 1);<br/>}, [count])</span></pre><h1 id="f60c" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">4.格式化日期</h1><p id="afbc" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">如果您在应用程序中使用日期，很可能需要设置日期的格式。<strong class="kt ir">现在大多数人会立即直奔</strong><a class="ae ob" href="https://www.npmjs.com/package/moment" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">moment . js</strong></a><strong class="kt ir">而去，但那会给你的项目增加一个额外的库(App大小)，而且很可能有一个比</strong><a class="ae ob" href="https://www.npmjs.com/package/moment" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">moment . js</strong></a><strong class="kt ir">更快的原生解决方案。</strong></p><p id="d875" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设我有一个格式为<code class="fe mt mu mv mw b">06/23/2020</code>的日期，并希望日期被格式化为<code class="fe mt mu mv mw b">6/23</code>。在下面的例子中，我们将看看为什么例子A没有被优化而例子B被优化了。</p><p id="b033" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另外，查看示例C和D，了解如何用不同的格式(日期、纪元/Unix时间戳)正确格式化日期。</p><h2 id="5735" class="mx lx iq bd ly my mz dn mc na nb dp mg la nc nd mi le ne nf mk li ng nh mm ni bi translated">示例A:使用Helper函数格式化日期</h2><ul class=""><li id="e4e8" class="ln lo iq kt b ku mo kx mp la nj le nk li nl lm ls lt lu lv bi translated">我没有选择<a class="ae ob" href="https://www.npmjs.com/package/moment" rel="noopener ugc nofollow" target="_blank"> moment.js </a>，而是首先选择创建一个助手函数(<code class="fe mt mu mv mw b">formatDate</code>)。它将在每个找到的<code class="fe mt mu mv mw b">/</code>处分割字符串，我将提取月和日。之后，我会查找是否有任何0，如果需要的话删除它们，并返回一个新的字符串。</li><li id="8b76" class="ln lo iq kt b ku nm kx nn la no le np li nq lm ls lt lu lv bi translated">然而，<strong class="kt ir">由于额外的代码，这可能会变得非常昂贵，但主要是由于</strong> <code class="fe mt mu mv mw b"><strong class="kt ir">string.split</strong></code>。<code class="fe mt mu mv mw b">string.split</code>的时间复杂度是<code class="fe mt mu mv mw b">0(n)</code>，其中字符串越大，在字符串上迭代完成这个过程需要的时间就越多。</li><li id="1346" class="ln lo iq kt b ku nm kx nn la no le np li nq lm ls lt lu lv bi translated">在我的应用程序中，我格式化了大约500个日期，这样额外的时间加起来就是运行额外的代码+迭代500个日期，长度为10 ( <code class="fe mt mu mv mw b">06/23/2020</code> ) = <strong class="kt ir">最少5000次不必要的迭代</strong>。</li></ul><p id="5ea5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> formatDate.js </strong></p><pre class="kg kh ki kj gt nr mw ns nt aw nu bi"><span id="3ef1" class="mx lx iq mw b gy nv nw l nx ny"><strong class="mw ir"><em class="oa">// Helper Function: Format Date</em></strong><em class="oa"><br/></em>export const formatDate = (string) =&gt; {<br/><strong class="mw ir">  <em class="oa">// Check If String Exists<br/></em></strong><em class="oa">  </em>if (string) {<br/><strong class="mw ir"><em class="oa">    // Splitted String<br/></em></strong><em class="oa">    </em>let splittedString = string.split('/');</span><span id="9d1a" class="mx lx iq mw b gy nz nw l nx ny"><strong class="mw ir"><em class="oa">    // Month + Day<br/></em></strong><em class="oa">    </em>let month = splittedString[0];<br/>    let day = splittedString[1];</span><span id="8a7a" class="mx lx iq mw b gy nz nw l nx ny"><strong class="mw ir"><em class="oa">    // Check For Zeros<br/></em></strong><em class="oa">    </em>if (month.charAt(0) === '0') {<br/>      month = month.charAt(1);<br/>    }</span><span id="a31c" class="mx lx iq mw b gy nz nw l nx ny"><strong class="mw ir"><em class="oa">    // Check For Zeros<br/></em></strong><em class="oa">    </em>if (day.charAt(0) === '0') {<br/>      day = day.charAt(1);<br/>    }</span><span id="8500" class="mx lx iq mw b gy nz nw l nx ny"><strong class="mw ir">    // Return Date String (6/23)<br/></strong>    return `${month}/${day}`;<br/>  }<br/>  else {<br/>    console.warn('removeZeros: String is not valid');<br/>  }<br/>};</span></pre><h2 id="30de" class="mx lx iq bd ly my mz dn mc na nb dp mg la nc nd mi le ne nf mk li ng nh mm ni bi translated"><strong class="ak">示例B:优化的日期格式</strong></h2><ul class=""><li id="360e" class="ln lo iq kt b ku mo kx mp la nj le nk li nl lm ls lt lu lv bi translated">这里我们用<a class="ae ob" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">原生新日期()</strong> </a>与<code class="fe mt mu mv mw b">dateOptions</code>来格式化<code class="fe mt mu mv mw b">06/23/2020</code>到<code class="fe mt mu mv mw b">6/23</code>。<strong class="kt ir">代码已经过优化，可以格式化500个日期，使用更少的代码，0个额外的库，减少5000次迭代(500个日期x字符串长度(10))。</strong></li></ul><pre class="kg kh ki kj gt nr mw ns nt aw nu bi"><span id="8fc9" class="mx lx iq mw b gy nv nw l nx ny"><strong class="mw ir"><em class="oa">// Date Options</em></strong><em class="oa"><br/></em>const dateOptions = {<br/>  day: 'numeric',<br/>  month: 'numeric',<br/>  year: 'numeric', // Optional if you want the date 6/2/2020<br/>  timeZone: 'UTC',<br/>};</span><span id="c840" class="mx lx iq mw b gy nz nw l nx ny"><strong class="mw ir"><em class="oa">// Formatted Start Date (Format: 9/25 | 10/7)</em></strong><em class="oa"><br/></em>const formattedStartDate = new Date(startDate).toLocaleDateString('en-US', dateOptions);</span></pre><h2 id="23ac" class="mx lx iq bd ly my mz dn mc na nb dp mg la nc nd mi le ne nf mk li ng nh mm ni bi translated"><strong class="ak">示例C:优化的日期格式(附加日期类型)</strong></h2><ul class=""><li id="e958" class="ln lo iq kt b ku mo kx mp la nj le nk li nl lm ls lt lu lv bi translated">现在假设我们有一个格式为<code class="fe mt mu mv mw b">2020–06–23T12:00:00.000Z</code>或Epoch/Unix Time <code class="fe mt mu mv mw b">1592913600</code>的日期？<strong class="kt ir">可以不用</strong><a class="ae ob" href="https://www.npmjs.com/package/moment" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">moment . js</strong></a><strong class="kt ir">来格式化这些日期。以下是不同的日期类型以及我们如何在没有</strong><a class="ae ob" href="https://www.npmjs.com/package/moment" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">moment . js</strong></a><strong class="kt ir">的情况下格式化它们。</strong></li></ul><h2 id="d49e" class="mx lx iq bd ly my mz dn mc na nb dp mg la nc nd mi le ne nf mk li ng nh mm ni bi translated">2020年6月23日12时00分至2020年6月23日:</h2><pre class="kg kh ki kj gt nr mw ns nt aw nu bi"><span id="637e" class="mx lx iq mw b gy nv nw l nx ny"><strong class="mw ir">// Formatted Date<br/></strong>const date = new Date('06/23/2020').toLocaleDateString();</span><span id="9250" class="mx lx iq mw b gy nz nw l nx ny">console.log(date);  // <!-- -->6/23/2020</span></pre><h2 id="a524" class="mx lx iq bd ly my mz dn mc na nb dp mg la nc nd mi le ne nf mk li ng nh mm ni bi translated">1592913600(纪元/Unix格式)到“2020年6月23日”:</h2><ul class=""><li id="563f" class="ln lo iq kt b ku mo kx mp la nj le nk li nl lm ls lt lu lv bi translated"><strong class="kt ir">注意:</strong>日期应该是毫秒的格式，所以我们需要将秒乘以1000。</li></ul><pre class="kg kh ki kj gt nr mw ns nt aw nu bi"><span id="c3ba" class="mx lx iq mw b gy nv nw l nx ny"><strong class="mw ir">// Formatted Date<br/></strong>const date = new Date(<!-- -->1592913600 * 1000<!-- -->).toLocaleDateString();</span><span id="4eab" class="mx lx iq mw b gy nz nw l nx ny">console.log(date);  // <!-- -->6/23/2020</span></pre><h2 id="11c1" class="mx lx iq bd ly my mz dn mc na nb dp mg la nc nd mi le ne nf mk li ng nh mm ni bi translated">2020年6月23日12:00:00.000至2020年6月23日星期四:</h2><pre class="kg kh ki kj gt nr mw ns nt aw nu bi"><span id="87d6" class="mx lx iq mw b gy nv nw l nx ny"><strong class="mw ir">// Formatted Date<br/></strong>const date = new Date('06/23/2020').toDateString();</span><span id="fa68" class="mx lx iq mw b gy nz nw l nx ny">console.log(date);  // Tue Jun 23 2020</span></pre><h2 id="3449" class="mx lx iq bd ly my mz dn mc na nb dp mg la nc nd mi le ne nf mk li ng nh mm ni bi translated">2020–06–23t 12:00:00.000 z至2020–06–23t 12:00:00.000 z:</h2><pre class="kg kh ki kj gt nr mw ns nt aw nu bi"><span id="177c" class="mx lx iq mw b gy nv nw l nx ny"><strong class="mw ir">// Formatted Date<br/></strong>const date = new Date('06/23/2020').toISOString();</span><span id="4f1e" class="mx lx iq mw b gy nz nw l nx ny">console.log(date);  // 2020–06–23T12:00:00.000Z</span></pre><h1 id="ce79" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">5.let vs. const</h1><ul class=""><li id="503a" class="ln lo iq kt b ku mo kx mp la nj le nk li nl lm ls lt lu lv bi translated"><code class="fe mt mu mv mw b"><strong class="kt ir">let</strong></code> <strong class="kt ir"> : </strong>表示<strong class="kt ir">变量</strong> <strong class="kt ir">可能被重新分配</strong>的信号，如循环中的计数器，或算法中的值交换。</li><li id="317a" class="ln lo iq kt b ku nm kx nn la no le np li nq lm ls lt lu lv bi translated"><code class="fe mt mu mv mw b"><strong class="kt ir">const</strong></code>:不会重新分配<strong class="kt ir">标识符的信号</strong>。</li></ul><p id="ed42" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这只是一个小进步，但小进步就是小进步。它在代码质量和代码可读性方面也有所改进。</p><p id="e68b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当使用时，您应该<strong class="kt ir">只使用</strong> <code class="fe mt mu mv mw b"><strong class="kt ir">const</strong></code> <strong class="kt ir">来标识不会被重新分配的常量</strong>，但是花费额外的时间有一些好处:</p><h2 id="3f1a" class="mx lx iq bd ly my mz dn mc na nb dp mg la nc nd mi le ne nf mk li ng nh mm ni bi translated">JavaScript引擎速度:</h2><p id="82a1" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">对于<code class="fe mt mu mv mw b">const</code>，<strong class="kt ir">代码明确告诉JavaScript引擎值不能改变</strong>。因此，它可以自由地做任何它想要的优化，包括对使用它的代码发出一个文字而不是变量引用，知道这些值是不能改变的。</p><h2 id="9b73" class="mx lx iq bd ly my mz dn mc na nb dp mg la nc nd mi le ne nf mk li ng nh mm ni bi translated"><strong class="ak">代码质量:</strong></h2><p id="76be" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">使用<code class="fe mt mu mv mw b">const</code>将导致<strong class="kt ir"> VS代码突出显示值被不恰当地重新分配的问题</strong>，这可能是偶然的错误或错误。</p><h2 id="a993" class="mx lx iq bd ly my mz dn mc na nb dp mg la nc nd mi le ne nf mk li ng nh mm ni bi translated">代码可读性:</h2><p id="99eb" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">声明一个<code class="fe mt mu mv mw b">const</code> <strong class="kt ir">通知读者，当浏览代码时，它不会在以后被重新赋值为不同的值</strong>。</p><h1 id="f606" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">6.碎片</h1><p id="422a" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated"><a class="ae ob" href="https://reactjs.org/docs/fragments.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> React片段</strong> </a>在React 16.2中被引入，让开发者可以选择使用，而不是React中的<code class="fe mt mu mv mw b">&lt;div&gt;&lt;/div&gt;</code>和React Native中的<code class="fe mt mu mv mw b">&lt;View&gt;&lt;/View&gt;</code>。</p><p id="cf7f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这也只是一个微小的改进，但微小的改进就是微小的改进。这主要对深度树有好处，但是渲染少一个DOM节点仍然是这个过程中少一个步骤。另一个好处是DOM检查器会稍微少一些混乱。</p><h2 id="b5ef" class="mx lx iq bd ly my mz dn mc na nb dp mg la nc nd mi le ne nf mk li ng nh mm ni bi translated"><strong class="ak">未优化渲染:</strong></h2><pre class="kg kh ki kj gt nr mw ns nt aw nu bi"><span id="4074" class="mx lx iq mw b gy nv nw l nx ny">&lt;div&gt;<br/>  &lt;p&gt;Hello world&lt;/p&gt;<br/>&lt;/div&gt;</span></pre><h2 id="6ccf" class="mx lx iq bd ly my mz dn mc na nb dp mg la nc nd mi le ne nf mk li ng nh mm ni bi translated"><strong class="ak">例题A(长语法):</strong></h2><pre class="kg kh ki kj gt nr mw ns nt aw nu bi"><span id="b6af" class="mx lx iq mw b gy nv nw l nx ny">&lt;React.Fragment&gt;<br/>  <!-- -->&lt;p&gt;Hello world&lt;/p&gt;<br/>&lt;/React.Fragment&gt;</span></pre><h2 id="5a0c" class="mx lx iq bd ly my mz dn mc na nb dp mg la nc nd mi le ne nf mk li ng nh mm ni bi translated"><strong class="ak">例子B(短语法):</strong></h2><pre class="kg kh ki kj gt nr mw ns nt aw nu bi"><span id="cdf6" class="mx lx iq mw b gy nv nw l nx ny">&lt;&gt;<br/>  &lt;p&gt;Hello world&lt;/p&gt;<br/>&lt;/&gt;</span></pre><h1 id="169d" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated"><strong class="ak">测量渲染速度的性能测试</strong></h1><p id="d3eb" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">下面是测试一个组件的格式，我们用<code class="fe mt mu mv mw b">timeStart</code>和<code class="fe mt mu mv mw b">timeEnd</code>来跟踪它。<code class="fe mt mu mv mw b"><strong class="kt ir">timeStart</strong></code> <strong class="kt ir">应该从第一个</strong> <code class="fe mt mu mv mw b"><strong class="kt ir">useEffect()</strong></code> <strong class="kt ir">钩子</strong>的顶端开始，<code class="fe mt mu mv mw b"><strong class="kt ir">timeEnd</strong></code> <strong class="kt ir">应该在最后一个</strong> <code class="fe mt mu mv mw b"><strong class="kt ir">useEffect()</strong></code> <strong class="kt ir">钩子</strong>的末端。</p><pre class="kg kh ki kj gt nr mw ns nt aw nu bi"><span id="e7fc" class="mx lx iq mw b gy nv nw l nx ny"><strong class="mw ir"><em class="oa">// Performance Testing: Time Start</em></strong><em class="oa"><br/></em>let timeStart = 0;</span><span id="e9bb" class="mx lx iq mw b gy nz nw l nx ny"><strong class="mw ir"><em class="oa">// React Hooks: Lifecycle Methods</em></strong><em class="oa"><br/></em>useEffect(() =&gt; {<br/><strong class="mw ir">  <em class="oa">// Performance Testing: Begin<br/></em></strong><em class="oa">  </em>timeStart = performance.now();</span><span id="d430" class="mx lx iq mw b gy nz nw l nx ny"><strong class="mw ir">  // Do Something<br/></strong>}, []);</span><span id="baeb" class="mx lx iq mw b gy nz nw l nx ny"><strong class="mw ir"><em class="oa">// React Hooks: Lifecycle Methods</em></strong><em class="oa"><br/></em>useEffect(() =&gt; {<br/><strong class="mw ir">  // Do Something<br/></strong>}, []);</span><span id="9a4a" class="mx lx iq mw b gy nz nw l nx ny"><strong class="mw ir"><em class="oa">// React Hooks: Lifecycle Methods</em></strong><em class="oa"><br/></em>useEffect(() =&gt; {<br/><strong class="mw ir">  // Do Something</strong></span><span id="3219" class="mx lx iq mw b gy nz nw l nx ny"><strong class="mw ir"><em class="oa">  // Performance Testing: Time End</em></strong><em class="oa"><br/>  </em>const timeEnd: number = performance.now();<br/>  console.log(`Render Speed: ${((timeEnd - timeStart) / 1000).toFixed(2)} seconds`);<br/>}, []);</span></pre><h1 id="67e9" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated"><strong class="ak">结论</strong></h1><p id="742f" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">这些是优化React/React本机应用程序性能和减少代码的几种方法。</p><p id="b784" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">没有人是完美的。如果您发现了任何错误，想要提出改进建议，或者扩展某个主题，请随时给我发消息。我一定会包括任何改进或纠正任何问题。</p></div></div>    
</body>
</html>