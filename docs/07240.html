<html>
<head>
<title>Learning JavaScript: Singly Linked Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习JavaScript:单链表</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-javascript-singly-linked-lists-ce0dd47aacb7?source=collection_archive---------15-----------------------#2021-02-02">https://levelup.gitconnected.com/learning-javascript-singly-linked-lists-ce0dd47aacb7?source=collection_archive---------15-----------------------#2021-02-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7f74d4252d32b7ddced3b5233bb79d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1LEJGhdU641LiIYh"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> JJ英</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="5311" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">链表是一种顺序数据结构，旨在提高其他顺序数据结构的效率。让我来解释一下。考虑一个数组。数组是一组可以存储数据的连续内存位置。假设您有一个如下所示的数组:</p><p id="a119" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi">[1,2,3,4,6,7,8,9,10]</p><p id="54ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你需要在4和6之间插入数字5呢？为此，您必须将7、8、9和10向右移动一个位置，以便为5腾出空间。现在想象一下，如果您必须移动数千个数据元素来为一个数字腾出空间。那是非常低效的。</p><p id="7d65" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者想象你有这样一个数组:</p><p id="bab4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi">[1,2,3,4,5,5,6,7,8,9,10]</p><p id="2ca5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你决定去掉多余的5美元呢？现在，您必须将元素6，7，8，9，10向左移动一个位置，以消除移除额外的5时留下的空间。同样，想象一下，如果您必须对数千个数据元素而不仅仅是5个数据元素执行这种转换。</p><p id="af56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个问题的解决方案是使用一个链表。链表是一组存储数据的对象，它们通过一个从一个对象指向序列中下一个对象的链接而相关联。有些链表只提供向前的链接，称为单向链表，而另一些链表提供向前和向后两个方向的链接，称为双向链表。</p><p id="0bea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下图显示了这两种类型的链表:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi le"><img src="../Images/739d6c59ce24a9a80cee349d6201c814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*5wRMqVjLatOGX88VrZgacA.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">单向和双向链表图</figcaption></figure><p id="fb2a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我将演示如何创建单向链表，并在以后的文章中讨论双向链表。</p><h1 id="3b6c" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">实现一个链表</h1><p id="5e5b" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">为了简化我的输入，我把单链表叫做链表。链表中的每个对象被称为一个节点。节点是一个有两个字段的对象——一个存储数据的字段和一个链接到链表中下一个节点的字段。下面是一个链表节点的类定义:</p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="040c" class="ms lk it mo b gy mt mu l mv mw">class Node {<br/>  constructor(data, link) {<br/>    this.data = data;<br/>    this.next = link;<br/>  }</span><span id="4a17" class="ms lk it mo b gy mx mu l mv mw">  show() {<br/>    return this.data;<br/>  }<br/>}</span></pre><p id="0f44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个测试这个类定义的简短程序:</p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="c587" class="ms lk it mo b gy mt mu l mv mw">let n3 = new Node("Danny", null);<br/>let n2 = new Node("Jonathan", n3);<br/>let n1 = new Node("Cynthia", n2);<br/>let header = new Node("head", n1);<br/>let currentNode = header;<br/>while (currentNode.next != null) {<br/>  currentNode = currentNode.next;<br/>  print(currentNode.show());<br/>}</span></pre><p id="e355" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="631f" class="ms lk it mo b gy mt mu l mv mw">Cynthia<br/>Jonathan<br/>Danny</span></pre><p id="a961" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不能对一个链表单独使用这个代码，因为我们需要有在现有节点之间插入新节点的方法和从列表中删除节点的方法。我们需要一个链表类定义，所以让我们继续这个定义。</p><h1 id="3343" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">链表类</h1><p id="b27c" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">为了实现一个链表类(<code class="fe my mz na mo b">LList</code>)，我将在定义中使用<code class="fe my mz na mo b">Node</code>类。一个<code class="fe my mz na mo b">LList </code>对象将由节点以及在这些节点上执行的操作组成，比如插入一个新节点、删除一个现有节点以及显示节点列表。</p><p id="c0fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一步是为类定义一个构造函数。构造函数将初始化一个用来“锚定”链表的头节点。下面是构造函数方法的定义以及类本身的标题:</p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="9798" class="ms lk it mo b gy mt mu l mv mw">class LList {<br/>  constructor() {<br/>    Node header = null;<br/>  }<br/>}</span></pre><p id="fd9f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要添加的下一个方法是向链表添加数据。对于这个应用程序，我们将在列表的前面添加数据。<code class="fe my mz na mo b">addFront</code>方法创建一个新节点，将数据分配给该节点，将头的下一个链接分配给新节点的下一个链接，然后将新节点分配为头的下一个链接，这样当通过头进入列表时，添加到前面的节点是遇到数据的第一个节点。代码如下:</p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="fd26" class="ms lk it mo b gy mt mu l mv mw">addFront(data) {<br/>  let n = new Node(undefined, undefined);<br/>  n.data = data;<br/>  n.next = this.header.next;<br/>  this.header.next = n;<br/>}</span></pre><p id="9684" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我需要定义一个显示方法，这样我们就可以确保我们的链表被正确构建:</p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="0670" class="ms lk it mo b gy mt mu l mv mw">display() {<br/>  let currentNode = this.header.next;<br/>  while (currentNode != null) {<br/>    print(currentNode.data);<br/>    currentNode = currentNode.next;<br/>  }<br/>}</span></pre><p id="9eeb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是对我们目前所知的一个测试:</p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="c6c6" class="ms lk it mo b gy mt mu l mv mw">let list = new LList();<br/>list.addFront("Cynthia");<br/>list.addFront("Jonathan");<br/>list.display();</span></pre><p id="3016" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出是:</p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="2bf8" class="ms lk it mo b gy mt mu l mv mw">Jonathan<br/>Cynthia</span></pre><p id="efc0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以包含的另一个方法是<code class="fe my mz na mo b">front</code>，它将显示链表的第一个元素:</p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="a2db" class="ms lk it mo b gy mt mu l mv mw">front() {<br/>  return this.header.next.data;<br/>}</span></pre><p id="0e7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们需要一个方法来从链表中移除前面的元素。为此，我们需要创建一个<code class="fe my mz na mo b">Node</code>对象，并给它分配一个头节点。然后，我们将头节点的下一个链接分配给新创建的节点，然后删除该节点。我们有效地将标题的下一个链接重新分配给前一个节点之后的节点。下面是方法定义:</p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="53bb" class="ms lk it mo b gy mt mu l mv mw">removeFront() {<br/>  let old = this.header;<br/>  this.header = old.next;<br/>  old = null;<br/>}</span></pre><p id="e227" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个测试程序:</p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="ec8f" class="ms lk it mo b gy mt mu l mv mw">let list = new LList();<br/>print("Current list:");<br/>list.addFront("Cynthia");<br/>list.addFront("Jonathan");<br/>list.addFront("Danny");<br/>list.display();<br/>list.removeFront();<br/>print("Current list after removing front:");<br/>list.display();</span></pre><p id="94f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是输出:</p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="d9f1" class="ms lk it mo b gy mt mu l mv mw">Current list:<br/>Danny<br/>Jonathan<br/>Cynthia<br/>Current list after removing front:<br/>Jonathan<br/>Cynthia</span></pre><p id="f4ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要的另一个方法是<code class="fe my mz na mo b">empty</code>，它让我们知道一个链表除了头节点之外是否还有其他节点。下面是这个方法的代码:</p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="f1d4" class="ms lk it mo b gy mt mu l mv mw">empty() {<br/>  return this.header.next == null;<br/>}</span></pre><p id="d63f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们把这些代码放在一起看看完整的<code class="fe my mz na mo b">LList</code>类定义:</p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="fd9d" class="ms lk it mo b gy mt mu l mv mw">class LList {<br/>  constructor() {<br/>    this.header = new Node("null", null);<br/>  }</span><span id="abd1" class="ms lk it mo b gy mx mu l mv mw">  addFront(data) {<br/>    let n = new Node(undefined, undefined);<br/>    n.data = data;<br/>    n.next = this.header.next;<br/>    this.header.next = n;<br/>  }</span><span id="8f21" class="ms lk it mo b gy mx mu l mv mw">  display() {<br/>    let currentNode = this.header.next;<br/>    while (currentNode != null) {<br/>      print(currentNode.data);<br/>      currentNode = currentNode.next;<br/>    }<br/>  }</span><span id="6a6d" class="ms lk it mo b gy mx mu l mv mw">  front() {<br/>    return this.header.next.data;<br/>  }</span><span id="4f44" class="ms lk it mo b gy mx mu l mv mw">  removeFront() {<br/>    let old = this.header;<br/>    this.header = old.next;<br/>    old = null;<br/>  }</span><span id="565c" class="ms lk it mo b gy mx mu l mv mw">  empty() {<br/>    return this.header.next == null;<br/>  }<br/>}</span></pre><p id="fce2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不要忘记你需要<code class="fe my mz na mo b">Node</code>类定义和<code class="fe my mz na mo b">LList</code>类定义来拥有一个工作的<code class="fe my mz na mo b">LList</code>类。</p><p id="800e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一些你可以使用<code class="fe my mz na mo b">LList</code>类解决的问题:</p><p id="a02c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">1.使用<code class="fe my mz na mo b">LList </code>类编写一个程序，存储一个游戏的前十名分数。</p><p id="a1b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.写一个程序，接受两个名字链表，并将它们合并成第三个链表。</p><p id="53c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">3.创建两个包含5个等级的链表，等级按降序存储。创建第三个链接列表，该列表合并了另外两个链接列表，但合并后的分数仍按降序排列。</p><p id="0a42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你对这些问题的解决方案感兴趣，给我发邮件，我会回复你程序。</p><p id="07cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请回复本文或给我发电子邮件，提出您的意见和建议。</p></div></div>    
</body>
</html>