<html>
<head>
<title>Promise with timeout in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript中带有超时的承诺</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/promise-with-timeout-in-javascript-e42911ba23e1?source=collection_archive---------3-----------------------#2020-03-15">https://levelup.gitconnected.com/promise-with-timeout-in-javascript-e42911ba23e1?source=collection_archive---------3-----------------------#2020-03-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fbe0b60c2a4179774458206dcbd83a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*c0fwkZ6mAavv9ypl"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@marceloleal80?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Marcelo Leal </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d47f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时我们发出的API请求没有得到服务器的任何响应。我们创建一个加载状态向用户展示，然后它永远不会消失。现在我们陷入了一种状态，表明应用程序正在等待什么...</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="1c39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，最好拒绝这个请求，并告诉用户有问题。解决这个问题的一个方法是创建一个带有超时的承诺。</p><p id="1e2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，我所说的“超时承诺”是什么意思呢？为了继续下去，有必要知道什么是承诺以及它是如何工作的，我在这里写了一篇关于这个的文章。</p><p id="d127" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果发送了请求，我们就等待响应。如果回应给了我们想要的东西，也许是一些数据，那就是成功的回应。我们还可以得到一个错误响应，这可能是一个类似于“你不允许这样做”的文本。这很好，因为我们仍然得到一个响应，有了它，我们实际上有了一个事件，可以触发一个动作。</p><p id="c320" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们发送了一个请求却没有得到响应怎么办？然后我们只是等待，等待不是一个事件，所以我们不能从中触发一个动作。因此，我们需要设置一个计时器来告诉我们，我们已经等待了足够长的时间，是时候做些别的事情了。这就是我所说的“有时限的承诺”。让我们看看如何做到这一点。</p><p id="5820" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有几种方法可以解决这个问题，但我认为最简单的方法是使用<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" rel="noopener ugc nofollow" target="_blank"> Promise.race </a>和setTimeout。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="0c04" class="lr ls iq ln b gy lt lu l lv lw">const promiseWithTimeout = <strong class="ln ir"><em class="lx">promise</em></strong> =&gt; {<br/>  let <strong class="ln ir">timeoutId</strong>; <br/>  const <strong class="ln ir">timeoutPromise</strong> = new Promise((<em class="lx">_</em>, <em class="lx">reject</em>) =&gt; {<br/>    <strong class="ln ir">timeoutId</strong> = setTimeout(() =&gt; {<br/>      reject(new Error('Request timed out'));<br/>    }, 4000);<br/>  })</span><span id="9bf3" class="lr ls iq ln b gy ly lu l lv lw">  return {<br/>    promiseOrTimeout: Promise.race([<strong class="ln ir"><em class="lx">promise</em></strong>, <strong class="ln ir">timeoutPromise</strong>]),<br/>    timeoutId,<br/>  };<br/>};</span></pre><p id="aa31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们声明函数，函数带一个名为<code class="fe lz ma mb ln b"><strong class="kf ir">promise</strong></code> <strong class="kf ir"> </strong>的参数，表示我们要传递的东西是一个JavaScript承诺。创建了一个名为<code class="fe lz ma mb ln b"><strong class="kf ir">timeoutId</strong></code>的变量，它将用于获取对超时的引用。</p><p id="1626" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">于是一个承诺产生了，它被称为<code class="fe lz ma mb ln b"><strong class="kf ir">timeoutPromise</strong></code>。不会使用resolve部分，所以我用了一个“<code class="fe lz ma mb ln b">_</code>”来表示。</p><p id="36e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该部分<code class="fe lz ma mb ln b">setTimeout(()=&gt;{reject(new Error(‘Request timed out’))}, 4000)</code>使用<strong class="kf ir"> setTimeout </strong>创建一个超时，该超时在4000ms后接受一个触发<strong class="kf ir">拒绝</strong>承诺的回调。</p><p id="6379" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数<code class="fe lz ma mb ln b"><strong class="kf ir">promiseWithTimeout</strong></code>返回一个具有两个属性的对象，<code class="fe lz ma mb ln b"><strong class="kf ir">promiseOrTimeout</strong></code>和<code class="fe lz ma mb ln b"><strong class="kf ir">timeoutId</strong></code>。<code class="fe lz ma mb ln b">promiseOrTimeout</code>的值是<code class="fe lz ma mb ln b">Promise.race</code>。</p><p id="6887" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Race函数接受一系列承诺。在这种情况下，它是两个承诺，并将返回第一个解决或拒绝的承诺的值。这意味着如果我们将我们的请求(包装在承诺中)作为这个函数的输入参数，我们将在请求和超时之间进行一场比赛。</p><p id="4446" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果响应返回，我们将使用响应，但是如果超时的回调被触发，<code class="fe lz ma mb ln b">timeoutPromise</code>将执行它的<code class="fe lz ma mb ln b">reject</code>。拒绝被设置为创建一个错误，稍后我们可以使用一个try-catch并以一种简单的方式处理拒绝。</p><p id="2afc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的例子说明了如何解决请求没有得到响应的问题。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="93c1" class="lr ls iq ln b gy lt lu l lv lw">let isLoading = false;<br/>let data = [];</span><span id="1c93" class="lr ls iq ln b gy ly lu l lv lw">const <strong class="ln ir">fetchData</strong> = async url =&gt; {<br/>  const { <strong class="ln ir">promiseOrTimeout</strong>, <strong class="ln ir">timeoutId</strong> } =          <br/>  <strong class="ln ir">promiseWithTimeout</strong>(fetch(url)); </span><span id="4766" class="lr ls iq ln b gy ly lu l lv lw">try {<br/>    isLoading = true<br/>    const result = await <strong class="ln ir">promiseOrTimeout</strong>;<br/>    data = await result.json();<br/>  } catch (error) { <br/>    console.log(error);<br/>    isLoading = false;<br/>    data = [];<br/>  } finally {<br/>    clearTimeout(<strong class="ln ir">timeoutId</strong>);<br/>  }<br/>};</span><span id="4c6b" class="lr ls iq ln b gy ly lu l lv lw"><strong class="ln ir">fetchData</strong>('api/some/endpoint');<br/>console<strong class="ln ir">.</strong>log(data, isLoading);</span></pre><p id="d378" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe lz ma mb ln b">catch</code>中的<code class="fe lz ma mb ln b">console.log(error)</code>记录“错误:请求超时”，那么是我们被拒绝的承诺触发了错误。这里，超时的处理方式与所有其他可能发生的错误相同。</p><h2 id="2f6d" class="lr ls iq bd mc md me dn mf mg mh dp mi ko mj mk ml ks mm mn mo kw mp mq mr ms bi translated">概括起来</h2><p id="191f" class="pw-post-body-paragraph kd ke iq kf b kg mt ki kj kk mu km kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">我已经讨论了如何使用<code class="fe lz ma mb ln b">Promise.race</code>解决陷入挂起状态的请求。</p><p id="7270" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在撰写本文时，有一个名为<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort" rel="noopener ugc nofollow" target="_blank"> AbortController </a>的实验特性，它有一个名为<code class="fe lz ma mb ln b">abort</code>的方法，可以用来解决这样的问题。</p></div></div>    
</body>
</html>