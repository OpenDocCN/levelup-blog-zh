<html>
<head>
<title>How to Monitor File System Events in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中监控文件系统事件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-monitor-file-system-events-in-python-e8e0ed6ec2c?source=collection_archive---------5-----------------------#2020-06-08">https://levelup.gitconnected.com/how-to-monitor-file-system-events-in-python-e8e0ed6ec2c?source=collection_archive---------5-----------------------#2020-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5ee3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用看门狗模块，一个跨平台的API来监控对文件的修改。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5075f2968b8549ce8301d64199ad4f77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n-1u4Hg_OcpXs5bJtUklYg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@urre?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">都市三登</a>在<a class="ae ky" href="https://unsplash.com/s/photos/watchdog?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="235f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过阅读这篇文章，您将学会检测对Python应用程序中现有文件的更改。我们将使用一个维护良好的模块，名为<code class="fe lv lw lx ly b">watchdog</code>。根据官方文件，<code class="fe lv lw lx ly b">watchdog</code>是</p><blockquote class="lz ma mb"><p id="dfdf" class="kz la mc lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated">“…用于监控文件系统事件的Python API库和shell实用程序。”</p></blockquote><p id="bcdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它同时支持Python 2.7和3.4+。但是，建议您对旧版本使用小于0.10.0的看门狗。在本教程中，我将只介绍Python API库。让我们继续下一部分，开始安装必要的模块。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="8856" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">设置</h1><p id="8861" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">pip install</code>进行设置非常简单明了。强烈建议您在继续之前设置一个虚拟环境。有两种方法可用</p><h2 id="df3b" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">从PyPI安装</h2><p id="490e" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在终端中运行以下命令。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="dd5c" class="nk mo it ly b gy oa ob l oc od">pip install watchdog</span></pre><p id="a82e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在撰写本文时，它将安装PyPI的最新版本0.10.2。</p><h2 id="b7cd" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">从代码库中安装</h2><p id="6121" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">此外，您可以在本地文件夹中克隆存储库并正常安装。首先，让我们用下面的命令克隆它。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="d10b" class="nk mo it ly b gy oa ob l oc od">git clone --recursive git://github.com/gorakhargosh/watchdog.git</span></pre><p id="8f47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用以下命令更改工作目录。确保它在工作目录中包含一个名为<code class="fe lv lw lx ly b">setup.py</code>的文件。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="3fdf" class="nk mo it ly b gy oa ob l oc od">cd watchdog</span></pre><p id="ef12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过运行以下命令来安装它。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="aec1" class="nk mo it ly b gy oa ob l oc od">pip install -e.</span></pre><p id="51b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直接从存储库中克隆它的一个主要优点是，您可以获得具有附加特性的最新版本。</p><p id="8368" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过在终端中运行以下命令来验证安装。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="4c4c" class="nk mo it ly b gy oa ob l oc od">pip show watchdog</span></pre><p id="50dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们进入下一节，开始编写Python代码。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="38d9" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">履行</h1><p id="366f" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated"><code class="fe lv lw lx ly b">watchdog</code>的主要构建模块基于以下几个类:</p><ul class=""><li id="4563" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated">观察者</li><li id="71e7" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">事件处理程序</li></ul><p id="f71f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，实现非常简单:</p><ol class=""><li id="c6fb" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu os ok ol om bi translated">创建一个<code class="fe lv lw lx ly b">watchdog.observers.Observer</code>线程类的实例。</li><li id="b993" class="oe of it lb b lc on lf oo li op lm oq lq or lu os ok ol om bi translated">用您自己的实现定义一个<code class="fe lv lw lx ly b">Event handler</code>的子类，并从中创建一个实例。</li><li id="b229" class="oe of it lb b lc on lf oo li op lm oq lq or lu os ok ol om bi translated">通过附加事件处理程序的<code class="fe lv lw lx ly b">Observer</code>实例调用调度函数。它接受一些其他输入参数，比如要监控的目录的路径。</li><li id="d16c" class="oe of it lb b lc on lf oo li op lm oq lq or lu os ok ol om bi translated">启动<code class="fe lv lw lx ly b">Observer</code>线程，等待它生成触发事件处理程序中代码的事件。</li></ol><h2 id="bd6b" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">事件处理程序</h2><p id="0e55" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">该模块中目前有4种类型的事件处理程序可用:</p><ol class=""><li id="96de" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu os ok ol om bi translated"><code class="fe lv lw lx ly b">FileSystemEventHandler</code> —基本文件系统事件处理程序，您可以从其覆盖方法。</li><li id="208c" class="oe of it lb b lc on lf oo li op lm oq lq or lu os ok ol om bi translated"><code class="fe lv lw lx ly b">PatternMatchingEventHandler</code> —将给定模式与和发生的事件相关联的文件路径进行匹配。</li><li id="5669" class="oe of it lb b lc on lf oo li op lm oq lq or lu os ok ol om bi translated"><code class="fe lv lw lx ly b">RegexMatchingEventHandler </code> —匹配给定的正则表达式和与发生的事件相关的文件路径。</li><li id="4e56" class="oe of it lb b lc on lf oo li op lm oq lq or lu os ok ol om bi translated"><code class="fe lv lw lx ly b">LoggingEventHandler</code> —记录所有捕获的事件。</li></ol><p id="a37c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其余的类继承自<code class="fe lv lw lx ly b">FileSystemEventHandler</code>，它提供了下面的函数供我们覆盖。</p><ul class=""><li id="37b9" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated"><code class="fe lv lw lx ly b">on_any_event</code> —无所不包事件处理程序。</li><li id="a24e" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><code class="fe lv lw lx ly b">on_created</code> —创建文件或目录时调用。</li><li id="6e2a" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><code class="fe lv lw lx ly b">on_deleted</code> —删除文件或目录时调用。</li><li id="c4d8" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><code class="fe lv lw lx ly b">on_modified</code> —当文件或目录被修改时调用。</li><li id="74f7" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><code class="fe lv lw lx ly b">on_moved</code> —当文件或目录被移动或重命名时调用。</li></ul><h2 id="4a23" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">导入</h2><p id="9ae2" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">创建一个新的Python文件，并添加以下导入声明。我就叫它<code class="fe lv lw lx ly b">test.py</code>。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="e5c4" class="nk mo it ly b gy oa ob l oc od">from watchdog.observers import Observer<br/>from watchdog.events import FileSystemEventHandler</span></pre><h2 id="d51c" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">FileSystemEventHandler的子类</h2><p id="34e8" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">创建一个继承自<code class="fe lv lw lx ly b">FileSystemEventHandler</code>的新类，并根据您的用例相应地覆盖函数。我将把它命名为<code class="fe lv lw lx ly b">MyHandler</code>，但是你可以随意命名它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="def9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用您实现的逻辑替换<code class="fe lv lw lx ly b">print</code>语句。对于每个函数，它都有一个名为event的输入参数，该参数包含以下变量:</p><ul class=""><li id="a65f" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated"><code class="fe lv lw lx ly b">event_type</code> —字符串形式的事件类型。默认为无。</li><li id="3063" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><code class="fe lv lw lx ly b">is_directory</code> —如果为目录发出事件，则为真；否则为假。</li><li id="f97d" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><code class="fe lv lw lx ly b">src_path</code> —触发此事件的文件系统对象的源路径。</li></ul><p id="f76e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最有用的参数是<code class="fe lv lw lx ly b">src_path</code>，在运行相应的逻辑之前，您可以使用它来确定哪个文件被修改了。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="9231" class="nk mo it ly b gy oa ob l oc od">if(event.src_path == "./path/file.txt"):<br/>    print("Execute your logic here!")</span></pre><h2 id="5c1e" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">观察者和事件处理器</h2><p id="6110" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">一旦创建了子类，就可以安全地创建它和<code class="fe lv lw lx ly b">Observer</code>类的实例。为监控过程指定您选择的路径。我将检查一个新创建的名为<code class="fe lv lw lx ly b">json</code>的文件夹。可以根据自己的喜好随意修改。</p><p id="0f15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以设置<code class="fe lv lw lx ly b">recursive</code>参数，但强烈建议预定义层次结构并将其设置为false，以防止权限不足或无法访问子文件夹的问题。</p><p id="13fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用<code class="fe lv lw lx ly b">start</code>将运行线程，并且当您在相应的路径中进行修改时，将会生成一个事件。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="57b1" class="nk mo it ly b gy oa ob l oc od">event_handler = MyHandler()<br/>observer = Observer()<br/>observer.schedule(event_handler, path='./json/', recursive=False)<br/>observer.start()</span></pre><h2 id="ae05" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">试验</h2><p id="fc8c" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">为了测试它，您必须实现一个运行循环来防止它退出。从<code class="fe lv lw lx ly b">KeyboardInterrupt</code>异常中退出后，调用stop函数来清理资源。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="d550" class="nk mo it ly b gy oa ob l oc od">while True:<br/>    try:<br/>        pass<br/>    except KeyboardInterrupt:<br/>        observer.stop()</span></pre><p id="b4bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保存Python文件并在您的终端中运行它。根据您设置的名称修改名称。</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="03c4" class="nk mo it ly b gy oa ob l oc od">python test.py</span></pre><p id="b35b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过创建一个新文档、修改其中的内容并从目录中删除它来轻松测试它。以下是示例输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/9120a43e56cd18cda81731ec893f6e11.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*-iuFb1AJKo_VVIhoRDELOg.png"/></div></figure><p id="01a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，根据您使用的编辑器，行为和结果可能会有所不同。例如，已知Vim对于<code class="fe lv lw lx ly b">modified</code>事件存在以下问题:</p><blockquote class="lz ma mb"><p id="951b" class="kz la mc lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated">“除非得到指示，否则Vim不会修改文件。它会创建备份文件，然后将它们换入以替换您正在磁盘上编辑的文件。这意味着如果您使用Vim来编辑您的文件，watchdog将不会触发这些文件的修改事件。您可能需要适当地配置Vim来禁用此功能。</p></blockquote></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="86bd" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="5364" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">让我们回顾一下今天所学的内容。</p><p id="4248" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从通过<code class="fe lv lw lx ly b">pip install</code>或直接从代码库中安装看门狗模块开始。</p><p id="dbbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们继续深入探索可用的特性，并尝试了它的一个基本实现。我们从<code class="fe lv lw lx ly b">FileSystemEventHandler</code>创建了一个子类，并将其作为输入参数分配给一个<code class="fe lv lw lx ly b">Observer</code>对象。当目录中的文件或文件夹被修改时，它会生成事件并调用相应的函数。</p><p id="436e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们通过创建新文件、修改文件内容和从目录中删除文件来测试我们的实现。</p><p id="bea1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢你阅读这篇文章。希望在下一篇文章中再见到你！</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="7d9f" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">参考</h1><ol class=""><li id="7b77" class="oe of it lb b lc nf lf ng li ow lm ox lq oy lu os ok ol om bi translated"><a class="ae ky" href="https://github.com/gorakhargosh/watchdog" rel="noopener ugc nofollow" target="_blank">看门狗Github </a></li><li id="73b7" class="oe of it lb b lc on lf oo li op lm oq lq or lu os ok ol om bi translated"><a class="ae ky" href="https://python-watchdog.readthedocs.io/en/v0.10.2/index.html" rel="noopener ugc nofollow" target="_blank">看门狗文档</a></li></ol></div></div>    
</body>
</html>