<html>
<head>
<title>Micro-frontends with AWS Amplify (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带AWS放大器的微前端(第一部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/micro-frontends-with-aws-amplify-50c2e2dc4222?source=collection_archive---------1-----------------------#2021-03-26">https://levelup.gitconnected.com/micro-frontends-with-aws-amplify-50c2e2dc4222?source=collection_archive---------1-----------------------#2021-03-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cb7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个故事是系列教程的第一部分，从一个微不足道的<a class="ae kl" href="https://martinfowler.com/articles/micro-frontends.html" rel="noopener ugc nofollow" target="_blank">微前端</a> (MFE)应用程序开始，我将深入研究<a class="ae kl" href="https://aws.amazon.com/amplify/" rel="noopener ugc nofollow" target="_blank"> AWS Amplify </a>，这是一个非常有前途的框架，允许开发人员(我会说是初创企业)轻松构建和部署由AWS管理的全栈应用程序。</p><h1 id="c81a" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">目标</h1><p id="da74" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">这个迷你系列将由不同部分组成:</p><ul class=""><li id="eb11" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">这个故事，<em class="ly">第一部分，</em>将介绍如何构建一个React / Angular微前端应用程序，所以这将是一个“前端重”的故事。</li><li id="43c7" class="lp lq iq jp b jq lz ju ma jy mb kc mc kg md kk lu lv lw lx bi translated">然后，我们将在第2部分中使用Amplify将其部署到AWS。</li></ul><div class="me mf gp gr mg mh"><a href="https://alatech.medium.com/micro-frontends-with-aws-amplify-part-2-f69acf518287" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd ir gy z fp mm fr fs mn fu fw ip bi translated">带AWS放大器的微前端(二)</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">在前面的故事中，我们利用微前端架构创建了一个简单的web应用程序。现在是时候将我们的应用部署到…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">alatech.medium.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv mw mh"/></div></div></a></div><ul class=""><li id="40dc" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">我们将在第3部分中基于GraphQL和DynamoDB <a class="ae kl" href="https://alatech.medium.com/micro-frontends-with-aws-amplify-part-3-4eb5dcfdb856" rel="noopener">构建多租户CRUD支付功能。</a></li></ul><div class="me mf gp gr mg mh"><a href="https://alatech.medium.com/micro-frontends-with-aws-amplify-part-3-4eb5dcfdb856" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd ir gy z fp mm fr fs mn fu fw ip bi translated">带AWS放大器和GraphQL的微前端</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">在之前发表的两篇文章中，通过Amplify建立了微前端架构及其部署，现在是时候关注…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">alatech.medium.com</p></div></div><div class="mq l"><div class="mx l ms mt mu mq mv mw mh"/></div></div></a></div><ul class=""><li id="a491" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">最后，<a class="ae kl" href="https://alatech.medium.com/micro-frontends-with-aws-amplify-part-4-3790f4fc1677" rel="noopener">第4部分</a>将展示如何用Api Gateway、Aurora RDS和PostgresQL实现RESTful API。</li></ul><div class="me mf gp gr mg mh"><a href="https://alatech.medium.com/micro-frontends-with-aws-amplify-part-4-3790f4fc1677" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd ir gy z fp mm fr fs mn fu fw ip bi translated">集成AWS Amplify和Aurora RDS的微前端</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">在之前的故事中，支付团队设法交付了基于GraphQL和DynamoDB的多租户功能。现在是时候了…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">alatech.medium.com</p></div></div><div class="mq l"><div class="my l ms mt mu mq mv mw mh"/></div></div></a></div><p id="e8e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">整体架构将如下所示:</p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi mz"><img src="../Images/62a0453ad965f7af99566b44eb33ca5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4qENhZ91nGC24QK7hdrSWg.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">整体AWS架构</figcaption></figure><p id="ae40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用户流程非常简单:一旦登录，用户就可以通过登陆一个shell应用程序来访问该应用程序，这是一个基于React的父微前端应用程序，充当两个子微前端应用程序的容器，这两个子微前端应用程序分别负责帐户和支付领域。</p><p id="332b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">父/壳应用程序将通过引用index.html页面中生成的包来包含两个子应用程序。你可能已经在争论基于React的应用程序如何与Angular的应用程序愉快地生活在一起。答案(众多答案之一)是<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank"> Web组件</a>，它将您的框架特定模块转换成普遍理解的基本定制HTML元素。微前端网络应用还有很多其他的方法，比如烤iframe、<a class="ae kl" href="https://single-spa.js.org/" rel="noopener ugc nofollow" target="_blank"> javascript库</a>和<a class="ae kl" href="https://webpack.js.org/concepts/module-federation/" rel="noopener ugc nofollow" target="_blank"> javascript bundlers </a>的特殊功能。出于演示目的，我选择Web组件<a class="ae kl" href="https://www.interaction-design.org/literature/topics/keep-it-simple-stupid" rel="noopener ugc nofollow" target="_blank">保持简单</a>。</p><h1 id="eebb" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">先决条件</h1><p id="d281" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">要跟随这个演示，请确保已经安装或有权访问以下最新的节点和NPM。对于未来的故事，请确保您创建了一个免费的AWS帐户(不要使用root帐户来玩！).</p><h1 id="84fb" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">让我们从客户团队开始</h1><p id="3e28" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">让我们戴上“帐户团队”的帽子，通过起诉Angular 11，从头开始创建Angular 11应用程序。如果您还没有，请安装它:</p><pre class="na nb nc nd gt no np nq nr aw ns bi"><span id="d932" class="nt kn iq np b gy nu nv l nw nx">npm install -g @angular/cli<br/>ng new mfe-accounts<br/>cd mfe-accounts<br/>ng serve</span></pre><p id="bc02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在创建了一个基本的Angular11应用程序(当在提示中要求选择其他功能时，如路由和样式表格式，请按enter键)。让我们删除一些多余的html，让我们在localhost:4200启动客户端。</p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/d4c03cc6277a12b1642a6c7a74de1fc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*T3Jch-EDQNyrf05pJ3jPuw.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">本地主机上显示的帐户应用程序</figcaption></figure><p id="ac99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们关注两个问题:</p><ul class=""><li id="6143" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">因为我们将从父shell应用程序中引用生成的包，所以我们需要确保每个应用程序都有一个包。</li><li id="b0c0" class="lp lq iq jp b jq lz ju ma jy mb kc mc kg md kk lu lv lw lx bi translated">我们如何将这个应用程序编译成web组件？</li></ul><h1 id="81ea" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">单束生成</h1><p id="c4cf" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">为了解决第一个挑战，我们将使用<em class="ly"> ngx-build-plus </em>包，键入:</p><pre class="na nb nc nd gt no np nq nr aw ns bi"><span id="ebdb" class="nt kn iq np b gy nu nv l nw nx">ng add ngx-build-plus</span></pre><p id="80dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上述命令扩展了Angular CLI命令的额外功能，修改了<em class="ly"> angular.json </em>文件。我们将使用下面的命令生成一个包，我们可以将它添加到<em class="ly"> package.json </em>中的脚本部分:</p><pre class="na nb nc nd gt no np nq nr aw ns bi"><span id="f122" class="nt kn iq np b gy nu nv l nw nx">"scripts": {<br/>   "ng": "ng",<br/>   "start": "ng serve",<br/>   <strong class="np ir">"build": "ng build --prod --single-bundle",</strong><br/>   "test": "ng test",<br/>   "lint": "ng lint",<br/>   "e2e": "ng e2e"<br/>}</span></pre><h1 id="9115" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">作为Web组件的应用程序</h1><p id="6d51" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">从Angular 6开始，角度元素允许将角度组件作为自定义元素发布，方法是将其公开为web组件。</p><pre class="na nb nc nd gt no np nq nr aw ns bi"><span id="6cf6" class="nt kn iq np b gy nu nv l nw nx">ng add @angular/elements</span></pre><p id="1317" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这公开了将我们的应用程序包装在自定义元素中的实用程序。如下所示修改<em class="ly"> app.module.ts </em>文件，以便简单地将AppModule公开为Web组件。</p><figure class="na nb nc nd gt ne"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">作为Web组件公开的Angular应用程序模块</figcaption></figure><h1 id="ddc6" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">对付款团队重复上述步骤</h1><p id="45a7" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">要创建一个支付微前端，只需重复上述步骤，但适用于支付。确保更改端口号，并将自定义元素调用为app-payments。</p><pre class="na nb nc nd gt no np nq nr aw ns bi"><span id="0bae" class="nt kn iq np b gy nu nv l nw nx">ng new mfe-payments<br/>cd mfe-payments<br/>ng serve --port 4201</span></pre><p id="9470" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过适当的小改动，应用程序应该看起来像:</p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/64ca311e565d6e38ff166c9655621522.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*qF20-kp7aDKvmlzv3yyZBg.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">在本地主机上运行的支付应用程序</figcaption></figure><h1 id="d52e" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">让核心团队粘合一切</h1><p id="b3a2" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">现在，作为核心团队成员，是时候在父应用程序下显示新创建的微前端了。为了让您相信Angular应用程序是作为自定义元素公开的，我们将创建父应用程序作为React应用程序，并在http://localhost:3000:</p><pre class="na nb nc nd gt no np nq nr aw ns bi"><span id="5fb7" class="nt kn iq np b gy nu nv l nw nx">npx create-react-app mfe-parent<br/>cd mfe-parent<br/>yarn start</span></pre><p id="be6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在React应用程序中显示新创建的应用程序的最快方法是添加对accounts和payments主包的引用。这可以通过以下命令实现:</p><pre class="na nb nc nd gt no np nq nr aw ns bi"><span id="7392" class="nt kn iq np b gy nu nv l nw nx">npm install copyfiles -g<br/>cd mfe-accounts<br/>npm run build<br/>copyfiles "./dist/mfe-accounts/main*js" ../mfe-parent/public<br/>cd ..<br/>cd mfe-payments<br/>npm run build<br/>copyfiles "./dist/mfe-payments/main*js" ../mfe-parent/public</span></pre><p id="143d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过执行上述命令，您应该会看到如下所示的文件夹结构:</p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/6ccd69bf53203bd7ff04a9980dc9e168.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*BG7Mnzt_OIcwDSWohmAmQA.png"/></div></figure><p id="8fd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，在<em class="ly">index.html</em>文件中引用两个生成的主包(还需要Zone.js):</p><figure class="na nb nc nd gt ne"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">用微前端引用索引HTML</figcaption></figure><p id="113f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:如果您想避免为包名生成散列，只需更新<em class="ly"> angular.json </em>并将<em class="ly"> outputHashing </em>字段设置为<em class="ly">“none</em>”而不是“<em class="ly"> all </em>”。</p><p id="febb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，访问React <em class="ly"> App.js </em>文件，修改外观并添加在mfe-accounts和mfe-payments模块中定义的自定义HTML元素:</p><figure class="na nb nc nd gt ne"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">添加到App.js的自定义HTML元素</figcaption></figure><p id="1c75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">刷新后，React应用程序将如下所示:</p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div class="gh gi od"><img src="../Images/752a476fb05f9cd6602141a1c865b0c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*YrFlv2Tk2kK1OY1e5kL5GA.png"/></div></figure><p id="8e5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">恭喜你。我们刚刚将两个虚拟的基于角度的微前端应用程序显示到一个父级React应用程序中。</p><h1 id="b7a4" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">摘要</h1><p id="bd38" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">这个故事展示了一个使用Angular和React的微前端应用程序的概念验证。实现是基于Web组件的，它代表了一种可移植的选择，可以让不同的框架互相交流。</p><p id="e2cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我意识到，在现实生活中，事情可能而且将会比上面更复杂，在捆绑策略和构建过程中可以进行改进，这里仅举几个例子。尽管如此，请将此作为接近这种新建筑风格的人的概念证明，希望能给你一些尝试、评估利弊和享受乐趣的动力。在<a class="ae kl" href="https://alatech.medium.com/micro-frontends-with-aws-amplify-part-2-f69acf518287" rel="noopener">第2部分</a>中，我们将在AWS中部署这个应用程序，以便用户可以访问它。谢谢大家！</p><h1 id="4fd9" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">参考文献</strong></h1><ul class=""><li id="bf19" class="lp lq iq jp b jq lk ju ll jy oe kc of kg og kk lu lv lw lx bi translated"><a class="ae kl" href="https://aws.amazon.com/blogs/architecture/micro-frontend-architectures-on-aws/" rel="noopener ugc nofollow" target="_blank">AWS上的微前端</a></li><li id="3d3d" class="lp lq iq jp b jq lz ju ma jy mb kc mc kg md kk lu lv lw lx bi translated"><a class="ae kl" href="https://javascript.plainenglish.io/create-micro-frontends-using-web-components-with-support-for-angular-and-react-2d6db18f557a" rel="noopener ugc nofollow" target="_blank">使用Web组件创建微前端</a></li></ul></div></div>    
</body>
</html>