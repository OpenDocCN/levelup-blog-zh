<html>
<head>
<title>Flutter Splash Screen — A simple way to handle async dependencies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter闪屏——处理异步依赖的简单方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/flutter-splash-screen-a-simple-way-to-handle-async-dependencies-7a9f559eb280?source=collection_archive---------4-----------------------#2020-01-30">https://levelup.gitconnected.com/flutter-splash-screen-a-simple-way-to-handle-async-dependencies-7a9f559eb280?source=collection_archive---------4-----------------------#2020-01-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f8a0188e1ae0a2a8ffc0c5206d23548b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sDGakkMVZ9fxuDNs"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Gabriel Laroche 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="719a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">说实话，这年头谁有大把时间？等待事情发生并不好玩。因此，我们总是希望一切都是即时的，或者用我们开发人员的话说:同步的。</p><p id="b1f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果你在开始做某件事之前需要等一个人，你会怎么做呢？所谓的异步依赖性。</p><p id="8551" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不记得上一次我写的应用程序在启动时没有某种形式的异步依赖是什么时候了。这就是闪屏的用途。</p><p id="4180" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Flutter中实现一个非常简单。把你的<code class="fe lb lc ld le b">MaterialApp</code>改成<code class="fe lb lc ld le b">StatefulWidget</code>，在顶部加上<code class="fe lb lc ld le b">bool _isInitialized = false;</code>，然后在<code class="fe lb lc ld le b">initState()</code>函数中初始化你的依赖关系，对吗？</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="f842" class="ln lo iq le b gy lp lq l lr ls">bool <strong class="le ir">_isInitialized</strong> = false;<br/><br/>@override<br/>void initState<em class="lt">() {<br/>  </em>super.initState<em class="lt">()</em>;<br/>  <strong class="le ir">_initializeAsyncDependencies<em class="lt">()</em></strong>;<br/><em class="lt">}<br/><br/></em>Future<em class="lt">&lt;</em>void<em class="lt">&gt; </em>_initializeAsyncDependencies<em class="lt">() </em>async <em class="lt">{<br/>  </em>// <strong class="le ir">do initialization</strong><br/>  setState<em class="lt">(() {<br/>    </em><strong class="le ir">_isInitialized = true;</strong><br/>  <em class="lt">})</em>;<br/><em class="lt">}</em></span></pre><blockquote class="lu lv lw"><p id="0ce2" class="kd ke lt kf b kg kh ki kj kk kl km kn lx kp kq kr ly kt ku kv lz kx ky kz la ij bi translated">那有什么问题呢？</p></blockquote><p id="af71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一开始，什么都没有。但是当您的应用程序和需求增长时，您可能会很快遇到这种方法的可维护性问题。</p><p id="0065" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我目前正在开发的应用程序中，我们是这样开始的，但过了一段时间，我们有太多的东西在那里进行，以至于很难理解在哪里、做什么以及如何初始化。我们有</p><ul class=""><li id="abda" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">来自服务器的翻译</li><li id="6292" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">一个需要为cookie同步目的初始化的网络视图(这是一个完全不同的话题，相信我，这并不有趣)</li><li id="9359" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">为了呈现我们的主要内容，我们需要一个配置文件</li><li id="536d" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">远程配置</li></ul><p id="bff8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦所有的东西都被加载，我们希望在主屏幕上显示一个漂亮的reveal过渡。</p><blockquote class="lu lv lw"><p id="c5e4" class="kd ke lt kf b kg kh ki kj kk kl km kn lx kp kq kr ly kt ku kv lz kx ky kz la ij bi translated">同样，所有这些都是可能的，我们做到了。一起工作简直是一场噩梦。</p></blockquote><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/8a25be8806fa2fe9ac4ff11a9e7811ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*do6J9blZVl44Bi8F"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@punttim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Tim Gouw </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="70f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我坐下来想了想……如果这件事可以用完全不同的方式来做呢？</p><p id="d13b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的目标是将主应用程序转换成一个<code class="fe lb lc ld le b"><strong class="kf ir">StatelessWidget</strong></code>，并在某个解耦的地方完成我们所有的初始化。从用户的角度来看，行为是不可改变的。</p><p id="2ab2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实证明，解决方案既简单又优雅。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="09f7" class="mw lo iq bd mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns bi translated">第一步也是唯一的一步</h1><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="ad18" class="ln lo iq le b gy lp lq l lr ls">void <strong class="le ir">main()</strong> {<br/>  <strong class="le ir">runApp</strong>(<br/>    <strong class="le ir">SplashApp</strong>(<br/>      key: UniqueKey(),<br/>      onInitializationComplete: () =&gt; <strong class="le ir">runMainApp()</strong>,<br/>    ),<br/>  );<br/>}<br/><br/>void <strong class="le ir">runMainApp()</strong> {<br/>  <strong class="le ir">runApp</strong>(<br/>    <strong class="le ir">MainApp()</strong>,<br/>  );<br/>}</span></pre><p id="cc3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要阐述？</p><p id="0eb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的……创建一个<code class="fe lb lc ld le b"><strong class="kf ir">SplashApp</strong></code>,它除了初始化你的异步依赖之外什么也不做，同时显示一个漂亮的闪屏。问你最喜欢的用户界面的人。</p><p id="3c01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">向<code class="fe lb lc ld le b"><strong class="kf ir">SplashApp</strong></code>传递一个回调函数，一旦所有东西都被加载，这个函数就会被执行。</p><h1 id="fe07" class="mw lo iq bd mx my nt na nb nc nu ne nf ng nv ni nj nk nw nm nn no nx nq nr ns bi translated">SplashApp</h1><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="6092" class="ln lo iq le b gy lp lq l lr ls">class <strong class="le ir">SplashApp extends StatefulWidget</strong> {<br/>  final VoidCallback onInitializationComplete;<br/><br/>  const SplashApp({<br/>    Key key,<br/>    @required this.onInitializationComplete,<br/>  }) : super(key: key);<br/><br/>  @override<br/>  _SplashAppState createState() =&gt; _SplashAppState();<br/>}<br/><br/>class <strong class="le ir">_SplashAppState extends State&lt;SplashApp&gt;</strong> {<br/>  bool _hasError = false;<br/><br/>  @override<br/>  void initState() {<br/>    super.initState();<br/>    <strong class="le ir">_initializeAsyncDependencies()</strong>;<br/>  }<br/><br/>  Future&lt;void&gt; <strong class="le ir">_initializeAsyncDependencies()</strong> async {<br/><strong class="le ir">    // &gt;&gt;&gt; initialize async dependencies &lt;&lt;&lt;<br/>    // &gt;&gt;&gt; register favorite dependency manager &lt;&lt;&lt;<br/>    // &gt;&gt;&gt; reap benefits &lt;&lt;&lt;</strong><br/>    Future.delayed(<br/>      Duration(milliseconds: 1500),<br/>      () =&gt; <strong class="le ir">widget.onInitializationComplete()</strong>,<br/>    );<br/>  }<br/><br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return MaterialApp(<br/>      title: 'Splash Screen',<br/>      theme: ThemeData(<br/>        primarySwatch: Colors.blue,<br/>      ),<br/>      home: _buildBody(),<br/>    );<br/>  }<br/><br/>  Widget _buildBody() {<br/>    if (_hasError) {<br/>      return Center(<br/>        child: RaisedButton(<br/>          child: Text('<strong class="le ir">retry</strong>'),<br/>          onPressed: () =&gt; <strong class="le ir">main()</strong>,<br/>        ),<br/>      );<br/>    }<br/>    return Center(<br/>      child: CircularProgressIndicator(),<br/>    );<br/>  }<br/>}</span></pre><p id="c658" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回调只是为不同的应用程序执行<code class="fe lb lc ld le b">run</code>函数，在这个例子中是<code class="fe lb lc ld le b"><strong class="kf ir">MainApp</strong></code>。</p><p id="505f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你这样做，那么你的<code class="fe lb lc ld le b"><strong class="kf ir">SplashApp</strong></code>将被清理，你只剩下一个<code class="fe lb lc ld le b"><strong class="kf ir">MainApp</strong></code>，在其中你可以同步访问所有东西。</p><h1 id="28ad" class="mw lo iq bd mx my nt na nb nc nu ne nf ng nv ni nj nk nw nm nn no nx nq nr ns bi translated">主应用程序</h1><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="564c" class="ln lo iq le b gy lp lq l lr ls">class <strong class="le ir">MainApp extends StatelessWidget</strong> {<br/>  @override<br/>  Widget build(BuildContext context) {<br/><strong class="le ir">    // &gt;&gt;&gt; use any dependency from your dependency manager &lt;&lt;&lt;<br/></strong><br/>    return MaterialApp(<br/>      title: 'Flutter Demo',<br/>      theme: ThemeData(<br/>        primarySwatch: Colors.blue,<br/>      ),<br/>      home: HomePage(title: 'Flutter Demo Home Page'),<br/>    );<br/>  }<br/>}</span></pre><p id="bc57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看，在<code class="fe lb lc ld le b"><strong class="kf ir">MainApp</strong></code>中没有复杂性。因此，我们可以得出结论:</p><p id="715d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目标实现。</p><p id="70f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你有任何意见，请告诉我！</p><p id="477f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在GitHub上找到完整的例子。下载它，使用它，享受它。</p><div class="ny nz gp gr oa ob"><a href="https://github.com/grAPPfruit/flutter-smooth-splash-screen" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">葡萄柚/颤动-平滑-闪屏</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">说实话，这年头谁有大把时间？等待事情发生并不好玩。所以我们总是想…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">github.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op jw ob"/></div></div></a></div></div></div>    
</body>
</html>