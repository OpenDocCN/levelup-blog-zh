<html>
<head>
<title>Explained: How does async work in Rust?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释:异步在Rust中是如何工作的？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/explained-how-does-async-work-in-rust-c406f411b2e2?source=collection_archive---------0-----------------------#2019-04-02">https://levelup.gitconnected.com/explained-how-does-async-work-in-rust-c406f411b2e2?source=collection_archive---------0-----------------------#2019-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="49be" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这篇文章将概述<strong class="ak">异步</strong>在Rust中存在的原因和方式。并发性、并行性和异步代码之间的区别将不被讨论。</h2></div><h1 id="d7ac" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">异步概念</h1><p id="fa00" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">异步编程是一个概念，它允许在等待某些动作的结果时不阻塞程序工作流。所以你可以打开一个大文件或者查询一个数据库，但是你的程序会继续处理每一行。</p><p id="488e" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这个概念首先是在内核级别上需要的，因为您希望能够在键盘上打字的同时听音乐。在软件层面，这是通过多线程实现的。在CPU方面，您可以在每个内核上同时运行多个进程。</p><p id="6e8c" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">后来，web服务器开始发挥作用，它需要在执行I/O任务时能够支持数百万个连接。为了能够以非阻塞的方式做到这一点，我们可以在内核级使用线程，或者实现我们自己处理线程和事件的方式。</p><h1 id="1c06" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">需要什么，为什么</h1><p id="24af" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">内核已经实现了这个概念(通过线程和其他概念)，但是它们非常“昂贵”，这意味着可用的资源是有限的，在操作系统级别处理这个问题增加了全新的复杂性。</p><p id="c6aa" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">因此，在程序级别上处理我们的内部异步流会很好。我们需要一个所谓的运行时，它可以处理异步代码，并能够与内核通信。</p><p id="39a6" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">总的想法是:</p><ul class=""><li id="00a4" class="ly lz iq kz b la lt ld lu lg ma lk mb lo mc ls md me mf mg bi translated">在程序级别上实现自己处理线程和队列的方式(绿色线程)</li><li id="f268" class="ly lz iq kz b la mh ld mi lg mj lk mk lo ml ls md me mf mg bi translated">在你的语言中加入语法糖，这样运行时/编译器可以识别代码的异步部分</li><li id="5809" class="ly lz iq kz b la mh ld mi lg mj lk mk lo ml ls md me mf mg bi translated">添加异步类型，以便它们可以在“完成”时发出通知</li></ul><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/c8117f939d3e36d7be05a89120fc2fd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/0*fip8SGfgHanOzQal.png"/></div></figure><p id="efa5" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">例如，与处理字符串不同，异步类型需要有特定的状态(正在处理和完成)。运行时可以处理这些类型并在其中设置状态。之后，您可以在代码中稍后访问该值，或者等待它们完成后再继续。</p><h1 id="e8fc" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">工作流程</h1><p id="4a9a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您在代码中将一个方法标记为async，在这个async方法中，您现在可以使用您的async类型。您可以等待它们完成(“从GitHub获取数据……”)或者您“启动”它们，继续您的流程，稍后检查它们是否完成并使用它们的值。</p><p id="36fe" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">一旦完成了代码的编写，你就需要一个运行时来获取代码的异步部分并实际运行它。运行时还需要从队列中取出进程，并将其交给操作系统，因为真正的工作发生在那里。</p><p id="aee2" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">在操作系统完成处理后，它将通知运行时，运行时反过来将设置异步类型内部的状态，并将其交还给程序工作流。</p><h1 id="b7f1" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">NodeJS vs. Go。对比铁锈</h1><p id="5858" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们看看Node、Go和Rust是如何实现我们讨论过的概念的，即:语法、类型和运行时。</p><h1 id="1e40" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">NodeJS</h1><p id="4f9e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在NodeJS中，有<code class="fe mu mv mw mx b">async/await</code>语法和<code class="fe mu mv mw mx b">Promises</code>。你可以<code class="fe mu mv mw mx b">await</code>一个<code class="fe mu mv mw mx b">Promise</code>也就是一个可能需要更多时间处理的动作。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/fe43f5f721c5aa21f470fdb0d571bf53.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/0*HCnpbPSv8ZnFPLz9.png"/></div></figure><pre class="mn mo mp mq gt my mx mz na aw nb bi"><span id="4c99" class="nc kg iq mx b gy nd ne l nf ng">const async_method = async () =&gt; {<br/>    const dbResults = await dbQuery();<br/>    const results = await serviceCall(dbResults);<br/>    console.log(results);<br/>}</span></pre><h1 id="1deb" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">去</h1><p id="495f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在围棋中，你开始<code class="fe mu mv mw mx b">goroutines</code>而不是<code class="fe mu mv mw mx b">Promises</code>。你可以简单地写下<code class="fe mu mv mw mx b">go method_name()</code>，而不是<code class="fe mu mv mw mx b">async/await</code>。代替V8，Go自带Go运行时。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/a598c703e04109cae9817239d8f8bffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/0*QDZWzVXre_o-H5or.png"/></div></figure><pre class="mn mo mp mq gt my mx mz na aw nb bi"><span id="2b0b" class="nc kg iq mx b gy nd ne l nf ng">func f(greeting string) {<br/>    fmt.Println(greeting, ", World!")<br/>}</span><span id="7c11" class="nc kg iq mx b gy nh ne l nf ng">go f("Hello")</span></pre><h1 id="51f6" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">锈</h1><p id="06a8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Rust Async生态系统仍在发展中，尚未最终成型。这里的建议是也使用<code class="fe mu mv mw mx b">async/await</code>，而不是<code class="fe mu mv mw mx b"><a class="ae ni" href="https://github.com/rust-lang-nursery/futures-rs" rel="noopener ugc nofollow" target="_blank">Futures</a></code>中的<code class="fe mu mv mw mx b">Promises</code>和<code class="fe mu mv mw mx b">Goroutines</code>。</p><p id="f639" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">Rust语言团队决定<a class="ae ni" href="https://github.com/rust-lang/rfcs/blob/0806be4f282144cfcd55b1d20284b43f87cbe1c6/text/0230-remove-runtime.md" rel="noopener ugc nofollow" target="_blank">不包含</a>任何运行时。Rust希望尽可能小，并且能够根据需要更换零件。因此你需要依靠crates来为你提供合适的运行时间。</p><p id="5cb3" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">最流行的是<code class="fe mu mv mw mx b"><a class="ae ni" href="https://tokio.rs/" rel="noopener ugc nofollow" target="_blank">tokio</a></code>，它在内部使用<code class="fe mu mv mw mx b"><a class="ae ni" href="https://github.com/carllerche/mio" rel="noopener ugc nofollow" target="_blank">mio</a></code>作为它的事件队列。甚至其他运行时也在使用<code class="fe mu mv mw mx b">mio</code>,因为它提供了对epoll、kqueue和IOCP等内核方法的抽象。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/8bde84eda77d4670c9caac5b3595fc99.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/0*yV7CvORSa9Xhe5RZ.png"/></div></figure><p id="2b6b" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">Rust的一个特点是你必须“开始”一个未来。因此，仅仅像在NodeJS或写<code class="fe mu mv mw mx b">go name_of_goroutine()</code>中的承诺一样宣布它还不会触发未来做某事。因此，如果您使用tokio，您需要:</p><pre class="mn mo mp mq gt my mx mz na aw nb bi"><span id="5114" class="nc kg iq mx b gy nd ne l nf ng">let response = client.get("http://httpbin.org")</span><span id="381d" class="nc kg iq mx b gy nh ne l nf ng">let response_is_ok = response<br/>    .and_then(|resp| {<br/>        println!("Status: {}", resp.status());<br/>        Ok(())</span><span id="a94c" class="nc kg iq mx b gy nh ne l nf ng">tokio::run(response_is_ok);</span></pre><p id="0b26" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">在不久的将来，你可以像这样在Rust中使用<code class="fe mu mv mw mx b">async</code>:</p><pre class="mn mo mp mq gt my mx mz na aw nb bi"><span id="0e84" class="nc kg iq mx b gy nd ne l nf ng">#[async]<br/>fn async_function_name(...) -&gt; Result&lt;ReturnType, ErrorType&gt; {<br/>    let db_results = await!(query_database());<br/>    let more_data = await!(fetch_another_service(db_resukts));<br/>    process(more_data)<br/>}</span></pre><p id="9e24" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><a class="ae ni" href="https://github.com/alexcrichton/futures-await" rel="noopener ugc nofollow" target="_blank"/><code class="fe mu mv mw mx b"><a class="ae ni" href="https://github.com/alexcrichton/futures-await" rel="noopener ugc nofollow" target="_blank">async/await</a></code><a class="ae ni" href="https://github.com/alexcrichton/futures-await" rel="noopener ugc nofollow" target="_blank">语法</a>仍在进行中，需要被批准、合并，部分语言需要调整到新的形式。</p><h1 id="7c9f" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">Rust异步详细信息</h1><p id="eebf" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们放大一点，看看运行时是如何工作的:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nk"><img src="../Images/d5dc78528d8ebeb01eb3051a5ce885e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*M1X1q4LXLT9o1Zu0.png"/></div></div></figure><p id="2a41" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">东京电力正在内部使用<a class="ae ni" href="https://tokio.rs/docs/going-deeper/building-runtime/" rel="noopener ugc nofollow" target="_blank"/><a class="ae ni" href="https://www.puncsky.com/blog/2015/01/13/understanding-reactor-pattern-for-highly-scalable-i-o-bound-web-server/" rel="noopener ugc nofollow" target="_blank">反应堆-执行器模式</a>。</p><p id="0dd9" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">tokio和其他运行时想要实现的是一个高原始数据吞吐量的高可伸缩服务器。他们不想在做I/O操作时阻塞。这里我们基本上有两种选择:基于线程的或者事件驱动的架构。简而言之:基于线程是有局限性的，因为物理资源有限。</p><p id="5a40" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">所以事件驱动对我们来说是最好的。它正在注册未来传入的请求，并保存一个指向异步函数处理程序的指针。然后它在内核中触发一个事件。一旦I/O操作完成，我们调用指针并使用来自I/O(内核)的结果执行异步方法。</p><p id="ab54" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">为此，我们需要一个反应器，它通知数据是否通过网络传入或者文件写操作是否正在进行，还需要一个执行器，它接收这些数据并执行异步函数(未来的)。</p><p id="5a77" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">此外，每个运行时都需要理解启动I/O操作的内核方法(如<a class="ae ni" href="https://people.eecs.berkeley.edu/~sangjin/2012/12/21/epoll-vs-kqueue.html" rel="noopener ugc nofollow" target="_blank"> epoll </a>)。对于Rust，有一个名为<a class="ae ni" href="https://github.com/carllerche/mio" rel="noopener ugc nofollow" target="_blank"> mio </a>的机箱实现了这些内核方法。Tokio正在内部使用mio。</p><h1 id="f4dd" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">有用吗？</h1><p id="7f14" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">目前在异步Rust世界中发生了很多事情。要有一个易于使用和理解的最终版本还需要一点时间。在此之前，您可以像以前一样使用web框架，因为它们已经附带了运行时。</p><p id="1495" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">例如，Dropbox将Futures与生产中的<code class="fe mu mv mw mx b">tokio</code>结合使用，从Dropbox服务器的磁盘上提供数据。Futures在0.1版本中是Rust stable，在0.3版本中是Rust nightly。运行时<code class="fe mu mv mw mx b">tokio</code>依赖于Rust stable，所以它使用Futures 0.1。</p><p id="a67e" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">您可以通过<a class="ae ni" href="https://rust-lang-nursery.github.io/futures-api-docs/0.3.0-alpha.9/futures/compat/index.html" rel="noopener ugc nofollow" target="_blank"> compat模块</a>将0.3期货转换为0.1期货，反之亦然。</p><p id="a222" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">Rust还需要几个月的时间来为其易用和强大的未来做准备。它们不像其他语言那样昂贵，你可以有一个瘦或厚的运行时，这完全取决于你。</p><h1 id="1726" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">开始</h1><p id="ecd3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如前所述，tokio是您可以使用的运行时之一。另一个是罗米奥和T2的组合。</p><p id="0969" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果您正在构建web应用程序，有一个名为<a class="ae ni" href="https://hyper.rs/" rel="noopener ugc nofollow" target="_blank"> hyper </a>的机箱，其中已经包含了tokio。因此，您可以在应用程序中使用Futures 0.1。</p><h1 id="9491" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">跟上时代</h1><p id="cf8b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">你可以登陆网站<a class="ae ni" href="https://areweasyncyet.rs/" rel="noopener ugc nofollow" target="_blank">areweasynctyet</a>关注异步Rust的进展。类似地，<a class="ae ni" href="http://www.arewewebyet.org/" rel="noopener ugc nofollow" target="_blank"> arewewebyet </a>正在跟踪围绕构建web应用程序的框架和工具的进展。</p><p id="a7c7" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">进一步阅读</p><ol class=""><li id="5a91" class="ly lz iq kz b la lt ld lu lg ma lk mb lo mc ls np me mf mg bi translated"><a class="ae ni" href="https://manishearth.github.io/blog/2018/01/10/whats-tokio-and-async-io-all-about/" rel="noopener ugc nofollow" target="_blank">Tokio和Async IO是怎么回事？</a></li><li id="2e15" class="ly lz iq kz b la mh ld mi lg mj lk mk lo ml ls np me mf mg bi translated"><a class="ae ni" href="https://slides.com/wraithm/async-io-in-rust-and-haskell/#/" rel="noopener ugc nofollow" target="_blank">期货在拉斯特和哈斯克尔</a></li><li id="a180" class="ly lz iq kz b la mh ld mi lg mj lk mk lo ml ls np me mf mg bi translated"><a class="ae ni" href="https://v8.dev/blog/fast-async" rel="noopener ugc nofollow" target="_blank">节点中的快速异步</a></li><li id="3fee" class="ly lz iq kz b la mh ld mi lg mj lk mk lo ml ls np me mf mg bi translated"><a class="ae ni" href="https://gobyexample.com/goroutines" rel="noopener ugc nofollow" target="_blank">举例说明:Goroutines </a></li><li id="7103" class="ly lz iq kz b la mh ld mi lg mj lk mk lo ml ls np me mf mg bi translated"><a class="ae ni" href="https://tokio.rs/docs/going-deeper/building-runtime/" rel="noopener ugc nofollow" target="_blank"> Tokio:构建运行时</a></li></ol></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><div class="mn mo mp mq gt nx"><a href="https://gitconnected.com/learn/rust" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">学习Rust -最佳Rust教程(2019) | gitconnected</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">14大铁锈教程-免费学习铁锈。课程由开发者提交并投票，使您能够找到…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">gitconnected.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ms nx"/></div></div></a></div></div></div>    
</body>
</html>