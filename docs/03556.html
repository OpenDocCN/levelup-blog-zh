<html>
<head>
<title>How to build a generic-reusable-synchronous-like confirmation dialog in React.js using Hooks and Context API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用钩子和上下文API在React.js中构建一个通用的、可重用的、类似同步的确认对话框</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-a-generic-reusable-synchronous-like-confirmation-dialog-in-react-js-71e32dfa495c?source=collection_archive---------1-----------------------#2020-05-16">https://levelup.gitconnected.com/how-to-build-a-generic-reusable-synchronous-like-confirmation-dialog-in-react-js-71e32dfa495c?source=collection_archive---------1-----------------------#2020-05-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="1860" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">序言</h1><p id="a86c" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我玩JavaScript已经有一段时间了，几乎浏览了所有主要的库/框架，vanilla-JS、jQuery、Angular、Backbone、Ember、React、Vue等等。</p><p id="678d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">有一点我可以肯定，当我试图在JavaScript中实现“<strong class="kq iu">同步流</strong>”时，它一直困扰着我，尤其是当我试图在其上添加一些UI时。</p><p id="53a3" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">现在，我知道你在想什么，什么<strong class="kq iu">同步</strong>和JavaScript有什么关系？这样想难道不是错的吗？你是对的，嗯，在某种程度上…</p><p id="cf46" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">让我们看一个非常简单的例子，执行<code class="fe lr ls lt lu b">XHR</code>从服务器获取数据，这是显而易见的，每个JavaScript新手都知道它是如何进行的；</p><ol class=""><li id="4195" class="lv lw it kq b kr lm kv ln kz lx ld ly lh lz ll ma mb mc md bi translated">你异步地做一些事情</li><li id="f1d8" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">您添加回拨</li><li id="a739" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">你<em class="mj">等一下</em></li><li id="b706" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">当回调被调用时，您继续</li></ol><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7c38" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">然后我们学会了使用<code class="fe lr ls lt lu b"><strong class="kq iu">Promises</strong></code>，这是一种更简单的方法，可以让我们避免臭名昭著的“<strong class="kq iu">地狱回调”</strong>(真的吗？)</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="cfa6" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">但是，我们仍然像以前一样等待回应，即使这样会更方便一点。</p><p id="22e8" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">然后…</p><p id="6e8e" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我们学会了使用<code class="fe lr ls lt lu b"><strong class="kq iu">Async/Await</strong></code></p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="1aeb" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu"> O-M-G </strong>，刚刚发生了什么？！</p><p id="868c" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu"> JavaScript </strong>变得同步了吗？</p><p id="e346" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">当然不是，在没有深入了解<code class="fe lr ls lt lu b"><strong class="kq iu">Async/Await</strong></code>到底是怎么回事的情况下，这看起来很有希望，给人一种同步流的感觉，所以让我们看看我将如何根据我的需要来处理它。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="be3d" class="jq jr it bd js jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn bi translated">挑战</h1><p id="a890" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，对于我的问题，我到底想实现什么。让我们看看下面的例子</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nd"><img src="../Images/a6cfbd46b1f265d1374ae2c4b5f57b84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rxxFRSH1VkkqDStIyqDXIw.png"/></div></div></figure><p id="72ba" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我有一个人的列表，可以选择删除任何项目，点击删除键可以从列表中删除一个人。<br/>我想向用户显示一个确认对话框，询问类似这样的问题</p><blockquote class="nk"><p id="2371" class="nl nm it bd nn no np nq nr ns nt ll dk translated">“你确定…？”</p></blockquote><p id="fdf0" class="pw-post-body-paragraph ko kp it kq b kr nu kt ku kv nv kx ky kz nw lb lc ld nx lf lg lh ny lj lk ll im bi translated">只有这样，完成删除以避免任何错误，这听起来并不复杂，这有什么大不了的？</p><p id="89b1" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">嗯，我想打开对话框，并以一段代码的形式获得响应，类似于我们可以用这里描述的<a class="ae nz" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/confirm" rel="noopener ugc nofollow" target="_blank">本地确认API做的事情。</a></p><p id="f8a1" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">但是这个对话框看起来就像你在访问恶意网站时经常看到的对话框，说你刚刚赢得了1，000，000，000美元，来吧…</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi oa"><img src="../Images/e631fb2e7b2f42556495dc56a6d074db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D4m04nLZl7jSSbk14-afHQ.png"/></div></div></figure><p id="f21b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我可以做得更好。</p><h1 id="15c2" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">构建应用程序</h1><p id="4681" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我使用<a class="ae nz" href="https://react-bootstrap.github.io/" rel="noopener ugc nofollow" target="_blank"> react-bootstrap </a>用于所有的样式和现成的组件，如Table、Modal等，以及最新版本的<a class="ae nz" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React.js </a></p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="9d82" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我使用了一个功能组件，在<code class="fe lr ls lt lu b"><strong class="kq iu">useState</strong></code> hook中填充了一个静态人员列表。<br/>通过一个简单的映射，我将数组的每个元素转换成一个表行，并附加click listener来移除元素，没什么特别的。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ob"><img src="../Images/8cc0dd21bec9676cb8a2e6b9f6b4ce52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*IoMwDTusAgacY6OwVF-7XQ.gif"/></div></div></figure><p id="0a36" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这样，点击删除按钮将立即删除元素并重新填充列表。</p><h1 id="6b81" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">添加简单的确认对话框</h1><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="050e" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">好的，所以我在我的桌子旁边添加了一个反应引导<code class="fe lr ls lt lu b"><strong class="kq iu">Modal</strong></code>和另一个<code class="fe lr ls lt lu b"><strong class="kq iu">useState</strong></code>钩子来保持它的可见性状态。</p><p id="8e85" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">现在点击删除按钮将显示确认对话框，在里面我显示了两个按钮，一个用于批准，另一个用于取消，现在，两个按钮都将隐藏它。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ob"><img src="../Images/58040ad4c0182520c864834788e0c972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Sz7x77HiZycDU_ANSa-zfg.gif"/></div></div></figure><h1 id="3111" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">确认后完成删除操作</h1><p id="9e3f" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">所以如果你考虑一下，在我的确认对话框中点击<strong class="kq iu"> Ok </strong>按钮应该做几件事，首先，它需要隐藏对话框，其次，它需要删除我点击的表格行中的元素，为此我需要保存另一条信息</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="f25f" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这里需要注意的是，首先，我使用了<code class="fe lr ls lt lu b"><strong class="kq iu">useRef</strong></code>钩子来存储我想要删除的元素，显然还有其他的方法，但是这个钩子可以和其他钩子一起流畅地工作，并且在重新呈现组件和显示正确的数据时有一些性能上的好处。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ob"><img src="../Images/576dd69051c33b7fe859592e0cab07c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*SqkQqceyZhqRE40KqBRXaQ.gif"/></div></div></figure><p id="dcc5" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这似乎工作得很好，事实上这就是我开始的地方；</p><p id="ffcd" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">起初，它是足够好的，但是</p><ul class=""><li id="6be2" class="lv lw it kq b kr lm kv ln kz lx ld ly lh lz ll oc mb mc md bi translated">我必须将对话框导入到我想要使用的每个组件中</li><li id="180c" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll oc mb mc md bi translated">对话流程是显示对话和等待响应的两步，我不喜欢这样</li><li id="2f78" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll oc mb mc md bi translated">我发现这个对话框与操作本身耦合得很好，删除、编辑、批准等等。</li></ul><p id="4551" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">随着我的项目变得越来越大，有了更多的组件和我必须展示对话框的地方(真正的快乐:)，我必须想出一些更好、更通用和可重用的东西...</p><p id="3b9d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">如果我能够封装整个确认对话框逻辑并在任何地方重用，会怎么样呢？如果你想一想，每个操作组件(删除、编辑、批准)都需要使用相同的确认对话框，但使用不同的消息，而操作本身的消费者只需要添加一个点击监听器。</p><p id="7791" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">让我们看看如何…</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="b31f" class="jq jr it bd js jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn bi translated">解决方案</h1><p id="4c57" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，我需要把所有东西分开，而不是使用一个普通的按钮(或者react-bootstrap按钮),我要用一个组件来包装它，以暗示这个按钮的功能，在我的例子中是<code class="fe lr ls lt lu b"><strong class="kq iu">DeleteButton</strong></code>,但可以是我喜欢的任何名称</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7706" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">然后在我的主人员表中，我可以这样使用它</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">c</figcaption></figure><p id="3874" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这将让我在将动作转发给调用者之前拦截点击；</p><p id="8d10" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">理想情况下，当用户点击<strong class="kq iu"> Ok </strong>或<strong class="kq iu"> Cancel </strong>来决定是否将点击动作转发给正在使用这个<code class="fe lr ls lt lu b"><strong class="kq iu">DeleteButton</strong></code>的用户时，<code class="fe lr ls lt lu b"><strong class="kq iu">handleOnClick</strong></code>函数应该以某种方式调出确认对话框并得到通知。</p><p id="312b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">如果这是可能的，那么每个使用my <code class="fe lr ls lt lu b"><strong class="kq iu">DeleteButton</strong></code>的组件都将能够把它当作一个<strong class="kq iu">“截取的类似按钮”</strong>，并让它自己运行要求用户确认的逻辑。</p><p id="3295" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">不可知的操作本身，纯粹的关注点分离，听起来不错。</p><h1 id="8286" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">添加保存确认对话框的全局位置</h1><p id="e78d" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，因为我希望我的应用程序中的每个组件都有这个很酷的功能，所以我还需要将我的对话框实现移到其他地方。</p><p id="67ff" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这听起来像是<code class="fe lr ls lt lu b"><strong class="kq iu">Context</strong></code>和<code class="fe lr ls lt lu b"><strong class="kq iu">ContextProvider</strong></code>的工作</p><p id="0781" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">上下文将让任何组件显示确认对话框</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ccf9" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">好吧，这是怎么回事？需要注意的几件事</p><ul class=""><li id="e59d" class="lv lw it kq b kr lm kv ln kz lx ld ly lh lz ll oc mb mc md bi translated">我正在使用React的<strong class="kq iu"> createContext </strong> API创建一个新的上下文。</li><li id="d3cd" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll oc mb mc md bi translated">我正在创建一个新的组件来使用我的上下文中的<code class="fe lr ls lt lu b"><strong class="kq iu">Provider</strong></code>，这是一个非常有用的模式；这也是我将要实现确认对话框的地方，因此你可以在第4行看到<code class="fe lr ls lt lu b"><strong class="kq iu">useState</strong></code>钩子来显示它的可见性状态。</li><li id="278d" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll oc mb mc md bi translated">暴露单一功能<code class="fe lr ls lt lu b"><strong class="kq iu">showConfirmation</strong></code></li></ul><p id="e7e0" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><code class="fe lr ls lt lu b"><strong class="kq iu">showConfirmation</strong></code>函数将负责两件事</p><ol class=""><li id="826a" class="lv lw it kq b kr lm kv ln kz lx ld ly lh lz ll ma mb mc md bi translated">更改模态可见性状态并显示它</li><li id="9bed" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">使用<code class="fe lr ls lt lu b"><strong class="kq iu">useRef</strong></code>钩子创建、存储并返回一个新的<code class="fe lr ls lt lu b"><strong class="kq iu">Promise</strong></code>(这是真正的魔法所在)，以便它可以在以后被调用。</li></ol><p id="8681" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">因此，当我的上下文函数<code class="fe lr ls lt lu b"><strong class="kq iu">showConfirmation</strong></code>被调用时，我将显示对话框并返回一个承诺，当用户单击对话框动作时，该承诺将被解析(<strong class="kq iu"> OK/CANCEL </strong>)。</p><p id="8ab6" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">现在，从理论上讲，我可以修改我的<code class="fe lr ls lt lu b"><strong class="kq iu">DeleteButton</strong></code>点击处理程序，使之类似于</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="1c8d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我将能够在同一行代码中显示确认对话框并得到它的响应！</p><p id="cadb" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">为了让它真正发挥作用，我要做两件事</p><ol class=""><li id="d7a7" class="lv lw it kq b kr lm kv ln kz lx ld ly lh lz ll ma mb mc md bi translated">让任何组件消耗我的对话上下文。<br/>为此，我在我的<code class="fe lr ls lt lu b"><strong class="kq iu">Context</strong></code>定义(同一个文件)旁边添加了一个导出声明，这是React中使用上下文的一个非常有用的模式，调用者将永远不需要知道/导入我的<code class="fe lr ls lt lu b"><strong class="kq iu">ContextDefinition</strong></code>对象，而只需要调用<code class="fe lr ls lt lu b"><strong class="kq iu">useConfirmationModalContext</strong></code>并得到它。</li><li id="288e" class="lv lw it kq b kr me kv mf kz mg ld mh lh mi ll ma mb mc md bi translated">为了让<code class="fe lr ls lt lu b"><strong class="kq iu">useContext</strong></code>工作，我需要用我的<code class="fe lr ls lt lu b"><strong class="kq iu">ContextProvider</strong></code>包装我的整个应用程序，这样任何子组件都可以使用它。</li></ol><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="e422" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">最后，在<code class="fe lr ls lt lu b"><strong class="kq iu">DeleteButton</strong></code>内部我可以导入我的<code class="fe lr ls lt lu b"><strong class="kq iu">modalContext</strong></code>并使用它，就是这样！</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="b905" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="8551" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这个故事中，我试图展示如何结合一堆技术来实现预期的行为。</p><p id="3038" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">显示一个对话框非常简单，甚至可以创建一个上下文来显示它，但是使用<code class="fe lr ls lt lu b"><strong class="kq iu">Async/Await</strong></code>让我能够以某种同步流的方式构建它，现在我可以显示我的对话框并在同一行上期待响应，这让我可以利用我的开发经验。</p><p id="8f83" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">当然，我假设在某一时刻只有一个对话框打开，这符合我的需要。</p><p id="3f99" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">下一步是用更多的细节来丰富它，比如传递一个对话框标题和消息来定制它。</p><p id="96cd" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">希望你和我一样喜欢它:)</p><h1 id="2cbb" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">存储库链接</h1><p id="fd3f" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">你可以在下面的github链接中找到完整的代码库和一个工作示例:<a class="ae nz" href="https://github.com/royeeshemesh/confirmation-dialog-react-hooks" rel="noopener ugc nofollow" target="_blank">https://github . com/royeeshemesh/confirmation-dialog-react-hooks</a></p></div></div>    
</body>
</html>