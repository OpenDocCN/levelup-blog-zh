<html>
<head>
<title>How to launch a pgbouncer container</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何启动pgbouncer容器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-launch-pgbouncer-container-140be66776eb?source=collection_archive---------1-----------------------#2022-01-25">https://levelup.gitconnected.com/how-to-launch-pgbouncer-container-140be66776eb?source=collection_archive---------1-----------------------#2022-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4982" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">安全地横向扩展应用服务器，同时保持最小数量的数据库连接</h2></div><h1 id="2aa1" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">什么是pgbouncer</h1><p id="5418" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> pgbouncer是应用服务器之间的连接池中间件软件</strong>&amp;Postgres DB实例。连接池的目的是<strong class="lc iu">让应用程序高效地连接到Postgres实例</strong>。pgbouncer是如何做到这一点的？通过重用到数据库的连接。</p><p id="ce2f" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在Postgres中(通常是大多数数据库)，建立一个连接是非常昂贵的，每个连接花费大约1.5-14.5 MB的<strong class="lc iu">。</strong>如果你有100个打开的数据库连接，仅仅维护这些连接就需要大约1.45GB的内存，这是一种浪费。记住，任何浪费的资源都会转化为金钱损失。此外，目前大多数DBaaS产品都限制了每个数据库实例的连接数。例如，定价为50美元的Heroku Postgres标准0实例最多只允许120个连接。当您需要向外扩展后端服务器超过这个限制时，就需要在应用服务器和Postgres实例之间使用连接池。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mb"><img src="../Images/e8e2270a0763c1bac27e8b102a26fc77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NPRuMSZZ3PQK6JLgb6KUEg.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">有和没有连接池的系统之间的比较</figcaption></figure><p id="0752" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">从应用服务器的角度来看，它认为自己连接到了一个普通的Postgres服务器。它没有连接池概念。这里的应用服务器指的是你的后端软件，无论它们是用Laravel PHP、Python Django、Ruby on Rails等编写的。</p><h2 id="a237" class="mr kj it bd kk ms mt dn ko mu mv dp ks lj mw mx ku ln my mz kw lr na nb ky nc bi translated">优势</h2><ul class=""><li id="0a6f" class="nd ne it lc b ld le lg lh lj nf ln ng lr nh lv ni nj nk nl bi translated">您可以很好地扩展您的应用服务器。以我的经验，并不是说你可以无限制的扩展你的服务器；相反，它解除了限制。例如，以前，您的Postgres实例最多可以支持100台服务器。有了pgbouncer，它大概可以支持多达500台服务器。这个数字取决于你的工作量。</li><li id="88c6" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated"><strong class="lc iu"> pgbouncer可以充当数据库路由</strong>。您可以将单个pgbouncer实例连接到多个不同的数据库实例。从那里，您可以相应地设置路由。</li><li id="a6f1" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated"><strong class="lc iu">它可以保护您的数据库实例免受大量连接建立的影响。</strong>在pgbouncer中，可以设置Postgres服务器的最大连接数和应用服务器的最大连接数。如果您的系统试图打开超过最大允许连接数的连接，pgbouncer将在连接到达上游数据库服务器之前拒绝该连接。</li></ul><h2 id="9acb" class="mr kj it bd kk ms mt dn ko mu mv dp ks lj mw mx ku ln my mz kw lr na nb ky nc bi translated">不足之处</h2><p id="10e3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一切都是有代价的。</p><ul class=""><li id="07df" class="nd ne it lc b ld lw lg lx lj nr ln ns lr nt lv ni nj nk nl bi translated"><strong class="lc iu">它为你现有的系统增加了一个新元素。</strong>这意味着你的系统复杂性增加了。操作一个新的软件需要技能和努力来保持其正确运行。</li><li id="a714" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated"><strong class="lc iu">这可能是您系统中的单点故障</strong>，除非您使用HAproxy或AWS网络负载平衡器建立高可用性模型。同样，高可用性设置不是一件容易的事情。</li></ul><h2 id="70e4" class="mr kj it bd kk ms mt dn ko mu mv dp ks lj mw mx ku ln my mz kw lr na nb ky nc bi translated">不要与应用程序级连接池混淆</h2><p id="d9e5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您可能已经注意到，现在许多ORM、数据库适配器和web框架都有内置的连接池特性。在他们的文档中可以看到:<a class="ae nu" href="https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/ConnectionPool.html" rel="noopener ugc nofollow" target="_blank"> Ruby on Rails </a>、<a class="ae nu" href="https://docs.djangoproject.com/en/4.0/ref/databases/#persistent-connections" rel="noopener ugc nofollow" target="_blank"> Django </a>、<a class="ae nu" href="https://sequelize.org/master/manual/connection-pool.html" rel="noopener ugc nofollow" target="_blank"> Sequelize.js </a>、<a class="ae nu" href="https://www.prisma.io/docs/concepts/components/prisma-client/working-with-prismaclient/connection-pool" rel="noopener ugc nofollow" target="_blank"> Prisma </a>、<a class="ae nu" href="https://hexdocs.pm/phoenix/ecto.html#repo-configuration" rel="noopener ugc nofollow" target="_blank">elixin Ecto</a>、<a class="ae nu" href="https://go.dev/doc/database/manage-connections" rel="noopener ugc nofollow" target="_blank"> Go Database </a>等。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nv"><img src="../Images/9903e06f7ca675d3d38bc6417cfc39df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O1_Kau2H64sIimj_yZYhEg.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">应用程序级连接池</figcaption></figure><p id="6af0" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu">应用级连接池只管理服务器级线程中的线程</strong>。如果您启动了数百台服务器，每台服务器都将建立到数据库服务器的连接，从而导致大量的连接。这并不能解决向系统添加服务器时的高连接数问题。</p><h2 id="2136" class="mr kj it bd kk ms mt dn ko mu mv dp ks lj mw mx ku ln my mz kw lr na nb ky nc bi translated">何时使用pgbouncer</h2><p id="32ee" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在我看来，只有在您向外扩展应用程序服务器，并且您的数据库连接很累的时候，您才应该使用pgbouncer。例如，您的数据库最多允许100个连接，但是您有200个应用服务器(并且每个服务器运行多个线程)。理论上，您的数据库实例将无法处理来自应用服务器的200多个数据库连接，这是pgbouncer的理想用例。</p><p id="12ff" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">如果您不需要很多服务器来支持您的用户，您最好不要使用连接池，因为它的好处是最小的。</p><h2 id="5bed" class="mr kj it bd kk ms mt dn ko mu mv dp ks lj mw mx ku ln my mz kw lr na nb ky nc bi translated">何时不使用pgbouncer</h2><p id="df5e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">你不应该使用pgbouncer来加速你的查询</strong>。考虑先做容易实现的优化，比如添加相关的表索引、构建物化视图、扩展数据库服务器等。，然后在您的系统中实际安装pgbouncer。</p><p id="6278" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">如果您的查询速度很慢，安装pgbouncer不会有太大帮助。</p><h2 id="fff3" class="mr kj it bd kk ms mt dn ko mu mv dp ks lj mw mx ku ln my mz kw lr na nb ky nc bi translated">哪些公司在用pgbouncer</h2><p id="aede" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">它们在大型互联网公司中很受欢迎</p><div class="nw nx gp gr ny nz"><a href="https://blog.twitch.tv/how-twitch-uses-postgresql-c34aa9e56f58" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">Twitch如何使用PostgreSQL</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">Twitch拥有大约125台数据库主机，为生产中的OLTP工作负载提供服务，通常作为集群的一部分…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">博客. twitch.tv</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ml nz"/></div></div></a></div><div class="nw nx gp gr ny nz"><a href="https://about.gitlab.com/blog/2017/10/02/scaling-the-gitlab-database/" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">扩展GitLab数据库</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">长期以来，GitLab.com使用一台PostgreSQL数据库服务器和一个副本进行灾难恢复…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">about.gitlab.com</p></div></div><div class="oi l"><div class="oo l ok ol om oi on ml nz"/></div></div></a></div><div class="nw nx gp gr ny nz"><a href="https://github.com/PostHog/posthog-cloud" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">GitHub-post hog/post hog-cloud:post hog多租户环境的内部脚本</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">这个库用于运行PostHog Cloud (app.posthog.com)。它使任何人都可以注册一个帐户，并创建…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">github.com</p></div></div><div class="oi l"><div class="op l ok ol om oi on ml nz"/></div></div></a></div><div class="nw nx gp gr ny nz"><a href="https://mattermost.com/blog/optimizing-database-connection-loads-with-pgbouncer-and-testwick/" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">使用PgBouncer和Testwick优化数据库连接负载</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">大多数工程师都知道，一个小的错误配置可能会导致一些大麻烦。通常，我们倾向于…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">mattermost.com</p></div></div><div class="oi l"><div class="oq l ok ol om oi on ml nz"/></div></div></a></div><h1 id="0974" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">我们开始吧</h1><h2 id="89ee" class="mr kj it bd kk ms mt dn ko mu mv dp ks lj mw mx ku ln my mz kw lr na nb ky nc bi translated">#1发布Postgres容器(可选)</h2><pre class="mc md me mf gt or os ot ou aw ov bi"><span id="9124" class="mr kj it os b gy ow ox l oy oz">$ docker run \<br/>    -e POSTGRES_PASSWORD=password <br/>    --network=host<br/>    --name postgres<br/>    postgres</span></pre><p id="7e20" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">如果您已经有一个运行在笔记本电脑或云中的数据库，您可以跳过这一步。</p><p id="b451" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">注意，我们在启动这个Docker容器时使用主机网络，以便步骤#2中的pgbouncer容器可以到达它。</p><h2 id="510a" class="mr kj it bd kk ms mt dn ko mu mv dp ks lj mw mx ku ln my mz kw lr na nb ky nc bi translated">#2启动pgbouncer容器</h2><p id="6059" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">要启动pgbouncer容器，您需要以下环境变量:</p><pre class="mc md me mf gt or os ot ou aw ov bi"><span id="d1bd" class="mr kj it os b gy ow ox l oy oz">$ docker run \<br/>    -e "POSTGRESQL_HOST=localhost" \<br/>    -e "POSTGRESQL_USERNAME=postgres" \<br/>    -e "POSTGRESQL_PASSWORD=password" \<br/>    -e "POSTGRESQL_DATABASE=postgres" \<br/>    -e "PGBOUNCER_POOL_MODE=transaction" \<br/>    -e "PGBOUNCER_PORT=6432" \<br/>    --network=host \<br/>    --name=pgbouncer \<br/>    bitnami/pgbouncer</span></pre><p id="0d95" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在这段代码中，我们使用了<code class="fe pa pb pc os b">transaction pool mode</code>。一般来说，这是你想要的，因为这是一个有效的方法，但这有一个警告。事务池模式确实支持预处理语句，这是Ruby on Rails的默认设置。如果你使用Ruby on Rails，<a class="ae nu" href="https://stackoverflow.com/questions/22813750/how-to-disable-prepared-statement-in-heroku-with-postgres-database" rel="noopener ugc nofollow" target="_blank">你可以在database.yml </a>中禁用它。</p><p id="fc8c" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">有多个pgbouncer Docker图像可用。就我个人而言，我更喜欢Bitnami pgbouncer Docker图像，因为它们比其他图像更具时代感。</p><h2 id="d282" class="mr kj it bd kk ms mt dn ko mu mv dp ks lj mw mx ku ln my mz kw lr na nb ky nc bi translated">#3连接到数据库</h2><pre class="mc md me mf gt or os ot ou aw ov bi"><span id="4bc7" class="mr kj it os b gy ow ox l oy oz">$ psql -h localhost -U postgres -d postgres -p 6432 -W<br/>$ &lt;PASSWORD&gt;</span></pre><p id="db18" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">记住将数据库设置为<code class="fe pa pb pc os b">postgres</code>,因为这是Docker容器中指定的默认数据库名称。</p><h2 id="9ce5" class="mr kj it bd kk ms mt dn ko mu mv dp ks lj mw mx ku ln my mz kw lr na nb ky nc bi translated">#4拆卸</h2><p id="fb54" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">要删除创建的容器，请运行以下命令</p><pre class="mc md me mf gt or os ot ou aw ov bi"><span id="8d4a" class="mr kj it os b gy ow ox l oy oz">$ docker rm -f pgbouncer postgres</span></pre><h1 id="ebbc" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">下一步是什么</h1><p id="ca5c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果您只想对单个数据库实例使用pgbouncer，那么您可以这样做。然而，pgbouncer提供了更多的东西。请考虑学习如何手动配置<code class="fe pa pb pc os b">pgbouncer.ini</code>文件。从那里，您可以更改它的日志配置、管理员用户凭证、上游数据库用户凭证等。了解哪种<code class="fe pa pb pc os b">pool mode</code>适合您的工作量也很重要。</p><p id="78cc" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">请记住，还有其他几种连接池软件可供选择。对于Postgres，可以查看<a class="ae nu" href="https://www.pgpool.net/mediawiki/index.php/Main_Page" rel="noopener ugc nofollow" target="_blank"> pgpool </a>和<a class="ae nu" href="https://github.com/yandex/odyssey" rel="noopener ugc nofollow" target="_blank">Yandex odessy</a>。如果你使用的是MySQL，你可以查看一下<a class="ae nu" href="https://proxysql.com/" rel="noopener ugc nofollow" target="_blank">的ProxySQL </a>和<a class="ae nu" href="https://vitess.io/docs/12.0/overview/whatisvitess/" rel="noopener ugc nofollow" target="_blank">的Vitess </a>。</p><h1 id="7b5d" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated"><strong class="ak">奖励:连接pgbouncer和Heroku </strong></h1><p id="f1e7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">要连接到Heroku Postgres，我们需要使用从pgbouncer到Postgres服务器的SSL连接。</p><pre class="mc md me mf gt or os ot ou aw ov bi"><span id="6f65" class="mr kj it os b gy ow ox l oy oz">$ docker run \<br/>    -e "POSTGRESQL_HOST=&lt;HEROKU PG HOST&gt;" \<br/>    -e "POSTGRESQL_USERNAME=&lt;HEROKU PG USERNAME&gt;" \<br/>    -e "POSTGRESQL_PASSWORD=&lt;HEROKU PG PASSWORD&gt;" \<br/>    -e "POSTGRESQL_DATABASE=&lt;HEROKU PG DBNAME&gt;" \<br/>    -e "PGBOUNCER_POOL_MODE=transaction" \<br/>    -e "PGBOUNCER_SERVER_TLS_SSLMODE=require" \<br/>    -e "PGBOUNCER_SERVER_TLS_PROTOCOLS=secure" \<br/>    -p 6432:6432 \<br/>    --name=pgbouncer \<br/>    bitnami/pgbouncer</span></pre><h2 id="c4ed" class="mr kj it bd kk ms mt dn ko mu mv dp ks lj mw mx ku ln my mz kw lr na nb ky nc bi translated">我是怎么发现的</h2><p id="0ca0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><em class="pd">这部分更多的是讲述我第一次使用pgbouncer容器的经历。如果你不感兴趣，可以跳过这一部分。</em></p><p id="3894" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">最近，我遇到了一个可伸缩性问题，我需要将我的Sidekiq workers扩展到一个特定的数量，但是这个数量太大了，足以损害我的Heroku Postgres实例。为了进行测试，我想从我的笔记本电脑上启动pgbouncer并连接到远程Heroku Postgres实例。</p><p id="37b4" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">经过几个小时的搜索，我发现Heroku确实提供了一个pgbouncer buildpack。然而，我不想在我的Heroku Dyno上启动pgbouncer，而是在我的本地笔记本电脑上。我以前一直想使用连接池软件，但一直都不是时候。</p><p id="9b5a" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">经过几个小时的调试，我想知道为什么我不能在我的pgbouncer和Heroku之间建立连接。好在Github上有源代码。</p><div class="nw nx gp gr ny nz"><a href="https://github.com/heroku/heroku-buildpack-pgbouncer" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">GitHub-heroku/heroku-build pack-pgbouncer:在dyno中运行pg bouncer以及您的应用程序</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">这是一个Heroku buildpack，允许在dyno中运行pgbouncer和应用程序代码。这是命中注定的…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">github.com</p></div></div><div class="oi l"><div class="pe l ok ol om oi on ml nz"/></div></div></a></div><p id="72f0" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在<a class="ae nu" href="https://github.com/heroku/heroku-buildpack-pgbouncer/blob/main/bin/gen-pgbouncer-conf.sh" rel="noopener ugc nofollow" target="_blank"> gen-pgbouncer-conf.sh </a>文件中，我们可以看到它正在使用安全的服务器连接。</p><pre class="mc md me mf gt or os ot ou aw ov bi"><span id="b76b" class="mr kj it os b gy ow ox l oy oz">server_tls_sslmode = prefer<br/>server_tls_protocols = secure<br/>server_tls_ciphers = HIGH:!ADH:!AECDH:!LOW:!EXP:!MD5:!3DES:!SRP:!PSK:@STRENGTH</span></pre><p id="d534" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">结果是我需要加强与Heroku服务器的SSL连接。从那里，我可以在我的本地Docker容器中复制相同的设置，然后瞧！它工作得非常好！</p><h1 id="2656" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">了解更多关于pgbouncer的信息</h1><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="pf pg l"/></div></figure><div class="nw nx gp gr ny nz"><a href="https://stackoverflow.blog/2020/10/14/improve-database-performance-with-connection-pooling/" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">使用连接池提高数据库性能</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">我们倾向于依靠缓存解决方案来提高数据库性能。在内存中缓存频繁访问的查询或…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">stackoverflow.blog</p></div></div><div class="oi l"><div class="ph l ok ol om oi on ml nz"/></div></div></a></div><div class="nw nx gp gr ny nz"><a href="https://www.enterprisedb.com/blog/taking-advantage-write-only-and-read-only-connections-pgbouncer-django" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">利用Django中的pgBouncer的只写和只读连接</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">我们来设定场景。我们有以下要素:一个流中的三个或更多PostgreSQL服务器的集群…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">www.enterprisedb.com</p></div></div><div class="oi l"><div class="pi l ok ol om oi on ml nz"/></div></div></a></div><div class="nw nx gp gr ny nz"><a href="https://sudhir.io/understanding-connections-pools" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">了解连接和池</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">什么是连接，它们如何影响我们的系统，以及如何和为什么池工作-注意如何流行的应用程序…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">sudhir.io</p></div></div></div></a></div><div class="nw nx gp gr ny nz"><a href="http://hans.io/blog/2014/02/19/postgresql_connection" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">PostgreSQL连接的开销</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">这篇博文解释了PostgreSQL连接的成本。TLDR；保持低数量的PostgreSQL连接…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">hans.io</p></div></div></div></a></div></div></div>    
</body>
</html>