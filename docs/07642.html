<html>
<head>
<title>WatchTower — The Missing Piece in Streamlining Amazon Cloudwatch and Python Application Logs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">瞭望塔——简化Amazon Cloudwatch和Python应用程序日志的缺失部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/watchtower-the-missing-piece-in-streamlining-amazon-cloudwatch-and-application-logs-d18f990b133f?source=collection_archive---------12-----------------------#2021-03-02">https://levelup.gitconnected.com/watchtower-the-missing-piece-in-streamlining-amazon-cloudwatch-and-application-logs-d18f990b133f?source=collection_archive---------12-----------------------#2021-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d755f5d15859accdb811d4bebafecd9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tVB9RG7dIdjNT7tU"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@vinomamba24?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Vino Li </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="4751" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我的假设是，如果有一件事是我们所有数据人员都同意的，那就是日志对于任何数据应用程序都是至关重要的。如果设置正确，日志可以揭示关于应用程序操作的许多信息。如果应用程序运行正常，日志是确认其运行情况以及是否按预期运行的首选资源。如果遇到任何问题或异常，日志会提供很多关于哪里出了问题的见解。正是由于这一点以及其他各种优点，日志记录策略是数据应用程序操作化的关键考虑因素之一。</p><p id="243e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你对<a class="ae kf" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank">亚马逊网络服务</a> (AWS)中的多功能和不断增长的服务有所了解，你可能知道Cloudwatch是那里的去因子日志服务。虽然Cloudwatch不仅仅是一个日志服务，但该服务的关键特性之一是存储和提供对日志的访问。作为AWS生态系统的一部分，它与其他服务紧密集成，许多(如果不是全部)服务将它们的日志发送到Cloudwatch。同样，您也可以将自己应用的遥测/日志发送到Cloudwatch。一旦日志出现在Cloudwatch中，就可以进一步利用它们根据定义的规则设置警报，从日志中生成指标，然后可以进一步分析这些指标以收集见解(例如，使用Cloudwatch的内置可视化和查询功能—告诉你，它不仅仅是一个简单的日志记录服务)。</p><p id="fa1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有这些在纸面上看起来都不错，但是当涉及到确定应用程序的日志并将其发送到Cloudwatch时，也有很多问题。如果您正在使用Python，您可能已经投入了大量资金来调整其传奇的“日志”模块以满足您的需求，方法是定义您希望将日志发送到哪里(例如，发送到文件、标准输出)以及这些日志应该如何格式化。另一方面，如果您想将日志发送到Cloudwatch，也有许多选项可供您选择:</p><ol class=""><li id="fe31" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">设置Cloudwatch代理—这包括在您的操作系统中安装Cloudwatch代理，定义它的配置以指定它应该监视哪些日志文件。一旦完成，它将开始向Cloudwatch发送日志文件的内容。因此，如果您已经在应用程序中按照自己的喜好设置了Python的日志模块，并且日志已经被写入系统中的特定位置，那么您可以指示代理将这些日志文件的内容流式传输到Cloudwatch。使用基于代理的方法的一个很酷的好处是，您还可以通过在代理的配置(表示为JSON)中添加几行配置，向Cloudwatch发送有趣的指标，例如CPU和内存利用率。如果除了代理发送的日志之外，您还想监视其他资源，这将非常方便。</li><li id="912a" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">使用boto3——Python中与AWS的任何编程交互都以boto3开始(和结束), boto 3是用于Python的AWS SDK。使用boto3，您可以定义Cloudwatch日志的客户端，并使用可用的函数将日志发送到那里。这种方法肯定是可行的，并且考虑到它是程序化的，它赋予了高度的灵活性。但是，为了能够向Cloudwatch发送日志事件，仍然需要遵循一些步骤。例如，考虑下面的代码片段，它利用boto3向Cloudwatch发送日志:</li></ol><figure class="ls lt lu lv gt ju"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="1714" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述代码片段的要点如下:</p><ul class=""><li id="945a" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld ly lk ll lm bi translated">在第4行创建一个使用boto3.session.Session对象的Cloudwatch日志客户端。</li><li id="194a" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld ly lk ll lm bi translated">首先在第8行描述Cloudwatch日志流。这将返回一个JSON对象，其中包含关于日志流的元数据。这是必需的，因为您需要在下一次调用put_log_events函数时包含响应中指定的SequenceToken。如果要将日志发送到新的日志流，但要将更多日志发送到现有日志流，则不需要提供有效的SequenceToken。</li><li id="0793" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld ly lk ll lm bi translated">第13到21行创建一个合格对象，然后作为关键字参数提供给log_put_events函数。</li></ul><p id="d599" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您在上面的例子中可能观察到的，向Cloudwatch发送单个日志事件确实需要几个步骤。当然，你可以有一个包装器函数，在这里或那里抽象出很多东西，但仍然会有一些开销。最后，它也将与您使用日志模块记录消息隔离开来。</p><p id="b564" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果有一种方法，您可以只使用日志记录模块，它还应该负责将日志发送到Cloudwatch，以及将日志发送到您配置的处理程序，那会怎么样？(例如文件、标准输出)利用配置(例如格式化程序)。这就是<em class="lz">了望塔</em>发挥作用的地方，它充当Cloudwatch和Python的日志模块之间的适配器。</p><p id="a478" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从技术上讲，PyPi上有一个<a class="ae kf" href="https://pypi.org/project/watchtower/" rel="noopener ugc nofollow" target="_blank"> Python模块</a>,您可以很容易地将它集成到您现有的数据应用程序中。开始使用watchtower非常简单，几乎不需要额外配置，就可以让您的应用程序在无缝使用日志记录模块的同时向Cloudwatch发送日志。</p><p id="af4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，将它安装在您的Python环境中(如果您喜欢虚拟环境，也可以使用venv):</p><pre class="ls lt lu lv gt ma mb mc md aw me bi"><span id="758a" class="mf mg it mb b gy mh mi l mj mk">pip install watchtower</span></pre><p id="1180" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">安装后，您应该能够在Python脚本中导入瞭望塔。</p><p id="aca8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在此之前，让我们考虑一个演示使用日志模块的基本示例:</p><figure class="ls lt lu lv gt ju"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="7561" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然代码是不言自明的，但这里有几个要点:</p><ul class=""><li id="4816" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld ly lk ll lm bi translated">导入日志模块后，我们实例化一个logger对象(使用<em class="lz"> logging.getLogger </em>方法)</li><li id="f3eb" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld ly lk ll lm bi translated">然后，我们将日志级别设置为INFO。如果您还不知道日志记录模块中的其他日志记录级别，最好自己了解一下</li><li id="134a" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld ly lk ll lm bi translated">然后，我们向日志记录器添加一个处理程序，它将定义日志将被路由到哪里。日志模块中有许多本机可用的处理程序，例如StreamHandler(它将输出发送到流，如sys.stdout、sys.stderr或任何类似文件的对象)，FileHandler(它将输出发送到磁盘上的文件)。(<em class="lz">提示:那是了望塔将自己插入日志模块的地方，稍后会解释)</em></li><li id="056f" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld ly lk ll lm bi translated">然后我们通过LOGGER.info()方法发送日志消息。在我们的示例中，我们刚刚配置了一个处理程序，即StreamHandler，因此它将显示在您的控制台输出/屏幕上。</li></ul><p id="b1ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，要将日志消息也发送到Cloudwatch，可以方便地实现如下操作:</p><figure class="ls lt lu lv gt ju"><div class="bz fp l di"><div class="lw lx l"/></div></figure><ul class=""><li id="b135" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld ly lk ll lm bi translated">您将瞭望塔导入到您的脚本中</li><li id="ea60" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld ly lk ll lm bi translated">瞭望塔模块定义了一个名为CloudWatchHandler的处理程序。当配置并添加到您的Logger对象时，它将负责将日志发送到Cloudwatch。它接受一些在<a class="ae kf" href="https://watchtower.readthedocs.io/en/latest/#module-watchtower" rel="noopener ugc nofollow" target="_blank">文档</a>中突出显示的参数。我使用了最少的参数，即日志应该发送到哪个日志组和日志流。</li><li id="8ecd" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld ly lk ll lm bi translated">配置完成后，您可以将其添加到logger对象中。完成后，您通过logger对象生成的每个日志消息，例如</li></ul><pre class="ls lt lu lv gt ma mb mc md aw me bi"><span id="43f4" class="mf mg it mb b gy mh mi l mj mk">LOGGER.info("some message")</span></pre><p id="52e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此类消息将被发送到您现有的处理程序(如StreamHandler)以及Cloudwatch和❤</p><p id="6eb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是完成此任务的代码片段的完整视图:</p><figure class="ls lt lu lv gt ju"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="bdd2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如前所述，上述示例是一个最简单的示例，并没有突出与日志记录相关的许多概念，例如格式化程序、设置不同的日志程序而不仅仅是使用root等。但关键的想法是，所有这些概念都与了望塔协同工作。</p><p id="7a55" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一些号召:</p><ul class=""><li id="d66c" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld ly lk ll lm bi translated">瞭望塔。CloudWatchHandler还接受boto3会话，这增加了很大的灵活性，即如果您有一个应用了一些自定义配置(例如代理设置)的boto3会话，它可以利用这一点。</li><li id="0945" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld ly lk ll lm bi translated">如果不指定log_group参数，默认情况下，它会将日志发送到Cloudwatch中的“瞭望塔”日志组。这可能是你想要的，也可能不是。</li><li id="5a50" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld ly lk ll lm bi translated">CloudWatchHandler还有一个名为create_log_group的参数，当该参数设置为True时，如果日志组不存在，它将创建日志组。(假设boto3会话使用的IAM用户拥有执行此操作所需的权限)</li></ul><p id="4c95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">差不多了。希望这篇文章对你有所帮助。编码快乐！</p></div></div>    
</body>
</html>