<html>
<head>
<title>How to build an Alexa Skill to add Objects to your Cosmic JS Bucket via Voice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何建立一个Alexa技能，通过语音向你的宇宙JS桶添加对象</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-an-alexa-skill-to-add-objects-to-your-cosmic-js-bucket-via-voice-ab64aa3e9cb8?source=collection_archive---------0-----------------------#2018-09-05">https://levelup.gitconnected.com/how-to-build-an-alexa-skill-to-add-objects-to-your-cosmic-js-bucket-via-voice-ab64aa3e9cb8?source=collection_archive---------0-----------------------#2018-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/eb501e1674f3b97eb53dfd225c8eb262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ePEjpp5s8joAu-npp3Tdg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Regan McFarlan为Cosmic JS开发人员文章撰写的故事。</figcaption></figure><h1 id="825d" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="3c68" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><a class="ae ly" href="https://github.com/cosmicjs/alexa-to-do" rel="noopener ugc nofollow" target="_blank">查看源代码</a></p><h1 id="69f7" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">介绍</h1><p id="b62b" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在这篇文章中，我们将通过语音命令，使用Alexa技能，向您的宇宙JS桶中添加、删除和列出对象。我们将在本教程中使用的技能是一个家务/任务跟踪器，它允许你说类似于<em class="lz">“Alexa，告诉家务跟踪器添加修剪草坪”</em>，<em class="lz">“Alexa，让家务跟踪器列出我的家务”</em>，<em class="lz">“Alexa，告诉家务跟踪器取消修剪草坪”</em>。我们将利用一个定制的宇宙JS桶来存储这些杂务。</p><h1 id="f47f" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">设置</h1><h2 id="dadb" class="ma kd iq bd ke mb mc dn ki md me dp km ll mf mg kq lp mh mi ku lt mj mk ky ml bi translated">先决条件</h2><ul class=""><li id="78e5" class="mm mn iq lc b ld le lh li ll mo lp mp lt mq lx mr ms mt mu bi translated">亚马逊AWS帐户</li><li id="20e1" class="mm mn iq lc b ld mv lh mw ll mx lp my lt mz lx mr ms mt mu bi translated">亚马逊开发者账户</li><li id="bd11" class="mm mn iq lc b ld mv lh mw ll mx lp my lt mz lx mr ms mt mu bi translated">节点&gt; = 4.5版</li></ul><h1 id="d250" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">安装ASK CLI</h1><p id="c351" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">首先，我们需要安装ASK CLI。这个工具将允许我们在将来轻松地将我们的技能部署到我们的开发人员门户和AWS Lambda实例中进行测试。</p><p id="50ae" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated"><code class="fe nf ng nh ni b">npm install -g ask-cli</code></p><p id="76ab" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated"><em class="lz">注:AWS配置基于</em> <a class="ae ly" href="https://medium.com/@rajeeva/getting-started-with-alexa-skill-kit-command-line-interface-ask-cli-2555bcfefbd1" rel="noopener"> <em class="lz"> @rajeeva的奇妙中篇</em> </a> <em class="lz">，一定要去查查他。</em></p><h1 id="5454" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">在AWS IAM中创建CLI策略</h1><p id="38e6" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我们需要一个对我们的AWS帐户拥有完全访问权限的用户，以便从命令行轻松部署我们的技能。为此，请转到AWS控制台中的<strong class="lc ir"> IAM </strong>选项卡，导航到<em class="lz">策略</em>，并选择<strong class="lc ir">创建策略</strong>。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/9456b9d45bf85cb04556cfa06640e758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xRp-o1023L4DFUO7.png"/></div></div></figure><p id="a060" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">您可以给这个策略起任何名字，但是我将坚持使用<strong class="lc ir"> AWS_CLI_FULL_ACCESS </strong>。接下来，我们要添加实际的策略内容，您可以复制下面的JSON用于策略配置。</p><pre class="nk nl nm nn gt no ni np nq aw nr bi"><span id="9ae9" class="ma kd iq ni b gy ns nt l nu nv">{<br/>    "Version": "2012-10-17",<br/>    "Statement": [<br/>        {<br/>            "Effect": "Allow",<br/>            "Action": [<br/>                "iam:CreateRole",<br/>                "iam:GetRole",<br/>                "iam:AttachRolePolicy",<br/>                "iam:PassRole"<br/>            ],<br/>            "Resource": "arn:aws:iam::*:role/ask-*"<br/>        },<br/>        {<br/>            "Effect": "Allow",<br/>            "Action": [<br/>                "lambda:AddPermission",<br/>                "lambda:CreateFunction",<br/>                "lambda:GetFunction",<br/>                "lambda:UpdateFunctionCode",<br/>                "lambda:ListFunctions"<br/>            ],<br/>            "Resource": "arn:aws:lambda:*:*:function:ask-*"<br/>        },<br/>        {<br/>            "Effect": "Allow",<br/>            "Action": [<br/>                "logs:FilterLogEvents",<br/>                "logs:getLogEvents",<br/>                "logs:describeLogStreams"<br/>            ],<br/>            "Resource": "arn:aws:logs:*:*:log-group:/aws/lambda/ask-*"<br/>        }<br/>    ]<br/>}</span></pre><p id="bb0d" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">在这之后，按照提示并按下<strong class="lc ir">创建策略</strong>如果一切正常，您应该会得到这个警告。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/fcbcb0c06a5e6db52b3b1c0f869f44e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rGV1KYJGpEgeWSax.png"/></div></div></figure><h1 id="98e3" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">在AWS IAM中创建CLI用户</h1><p id="2555" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">现在我们已经创建了一个新策略，我们需要将该策略附加到一个用户。回到AWS控制台中的<strong class="lc ir"> IAM </strong>选项卡，导航到<em class="lz">用户</em>，选择<strong class="lc ir">添加</strong> &gt; <strong class="lc ir">用户</strong>。</p><p id="8e19" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated"><em class="lz">注意:我已经有一个名为AWS_CLI_FULL_ACCESS的用户，但你不应该。</em></p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/8d076171e8f1b0ca553566442a3afe66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gmOkntXqw0U-kpoQ.png"/></div></div></figure><p id="214f" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">接下来，按照提示命名用户。你可以给它起任何你想要的名字，但是我将坚持使用<strong class="lc ir"> AWS_CLI_FULL_ACCESS </strong>。当提示输入访问类型时，确保选择<strong class="lc ir">编程访问</strong>。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/db83ff97218c5adf9de67def91b89800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lqfSyhYfk9KBD6d4.png"/></div></div></figure><p id="786f" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">它将要求为用户附加一个策略，并确保选择我们之前创建的<strong class="lc ir"> AWS_CLI_FULL_ACCESS </strong>策略。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/c5df198794548ebc275a6c3c5601c829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_hwclJIKJ3W-wA-V.png"/></div></div></figure><p id="85c6" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">现在按照提示操作，直到显示用户和他们的<strong class="lc ir">访问密钥ID </strong>和<strong class="lc ir">秘密密钥</strong>。这些<strong class="lc ir">非常</strong>重要，我们下一步会用到它们，所以一定要把它们写在某个地方。</p><h1 id="8d52" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">将我们的IAM用户添加到本地机器</h1><p id="fc73" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">现在已经创建了IAM用户，我们需要将他添加到我们的<strong class="lc ir"> AWS本地配置</strong>。根据您的操作系统，它位于不同的位置。</p><ul class=""><li id="f9a7" class="mm mn iq lc b ld na lh nb ll nw lp nx lt ny lx mr ms mt mu bi translated">macOS: <em class="lz"> ~/。AWS/凭证</em></li><li id="45c6" class="mm mn iq lc b ld mv lh mw ll mx lp my lt mz lx mr ms mt mu bi translated">Windows: <em class="lz"> %USERPROFILE%。aws\credentials.txt </em></li></ul><p id="30a4" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">我们希望将我们的AWS IAM用户添加到该文件中。添加以下几行并保存文件。</p><pre class="nk nl nm nn gt no ni np nq aw nr bi"><span id="06d7" class="ma kd iq ni b gy ns nt l nu nv">[AWS_CLI_FULL_ACCESS] <br/>aws_access_key_id=&lt;YOUR_ACCESS_KEY_ID&gt; <br/>aws_secret_access_key=&lt;YOUR_SECRET_ACCESS_KEY&gt;</span></pre><h1 id="6dea" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">正在初始化ASK配置文件</h1><p id="ff56" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我们需要为IAM用户配置一个ASK配置文件。为此，我们需要运行以下命令。</p><p id="fc2a" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated"><code class="fe nf ng nh ni b">ask init -p ASK_CLI_FULL_ACCESS</code></p><p id="6f6e" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">系统会提示您使用您的Amazon帐户登录，如果您通过了身份验证，它会让您知道配置文件已成功初始化。</p><h1 id="3d60" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">部署技能</h1><p id="bbe1" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">导航到<strong class="lc ir">项目</strong>，并运行以下命令。</p><p id="63a4" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated"><code class="fe nf ng nh ni b">ask deploy</code></p><p id="f09e" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">如果出现以下错误:<strong class="lc ir">【错误】:无法解析配置文件【默认】</strong>，请进入位于<em class="lz"> ~/的配置文件。ask/cli/config </em>并将<strong class="lc ir">【默认】</strong>改为<strong class="lc ir">【AWS _ CLI _ FULL _ ACCESS】</strong>。</p><p id="b94b" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">就这样，您的技能部署了相应的AWS Lambda实例和技能。你现在可以通过导航到<a class="ae ly" href="https://developer.amazon.com/alexa/console/ask" rel="noopener ugc nofollow" target="_blank">亚马逊开发者网站</a>上的<em class="lz"> Alexa技能工具包</em>页面来测试技能。在那里，你可以通过点击<em class="lz">测试</em>部分来测试技能。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/40fdf3c46d35ad9672f5293396c95056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qV2LzSE68XngRYsg.png"/></div></div></figure><p id="ecf5" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">当你想测试新功能时，确保每次都重新部署技能！</p><h1 id="63c7" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">代码</h1><p id="8652" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">目前没有任何文件可供我们放入对Cosmic JS的API调用。所以，我们做一个吧。继续在<strong class="lc ir"> lambda/custom </strong>目录下创建一个名为<strong class="lc ir"> api.js </strong>的文件。我们先来补充一些基本的Cosmic JS设置。</p><pre class="nk nl nm nn gt no ni np nq aw nr bi"><span id="a484" class="ma kd iq ni b gy ns nt l nu nv">//import CosmicJS Library<br/>const Cosmic = require('cosmicjs');</span><span id="1e0a" class="ma kd iq ni b gy nz nt l nu nv">//import our local Config<br/>const config = require('./config');</span><span id="d0a8" class="ma kd iq ni b gy nz nt l nu nv">//Fetch our Chore bucket<br/>const choreBucket = Cosmic.bucket({<br/>  slug: config.BUCKET_SLUG,<br/>  read: config.API_READ_ACCESS_KEY,<br/>  write: config.API_WRITE_ACCESS_KEY<br/>});</span></pre><p id="cecc" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">这很简单。前两部分是基本的require语句，一部分用于Cosmic JS npm模块，第二部分用于我们的<strong class="lc ir"> config.js </strong>文件，以便我们访问我们的Bucket Slug和API键。然后我们创建一个对家务桶的引用供以后使用。</p><h1 id="2ff9" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">从我们的桶中读取对象</h1><p id="31ed" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">现在，我们想添加一个功能来检索添加到桶中的所有家务，这样我们的Alexa技能可以在用户想要检索它们时将它们列出来。</p><p id="d276" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">首先，让我们更新我们的<strong class="lc ir"> api.js </strong>文件</p><pre class="nk nl nm nn gt no ni np nq aw nr bi"><span id="6372" class="ma kd iq ni b gy ns nt l nu nv">/**<br/> * Retrieve all chores from the bucket<br/> */<br/>const getChores = async function() {<br/>  const choreData = await choreBucket<br/>    .getObjects({})<br/>    .then(data =&gt; {<br/>      return data;<br/>    })<br/>    .catch(err =&gt; {<br/>      console.log(err);<br/>      return null;<br/>    });<br/>  let chores = [];<br/>  if (!choreData) {<br/>    return [];<br/>  } else {<br/>    choreData.objects.map(item =&gt; {<br/>      chores.push(item.title);<br/>    });<br/>    return chores;<br/>  }<br/>};</span><span id="61fd" class="ma kd iq ni b gy nz nt l nu nv">//update module.exports<br/>module.exports = {<br/>  getChores<br/>}</span></pre><p id="6623" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">这是一个简单的函数，它将从我们之前创建的引用中返回所有对象。当<strong class="lc ir"> getObjects() </strong>返回一个承诺时，我们用传统的<strong class="lc ir"> then() </strong>和<strong class="lc ir"> catch() </strong>来处理。最后，我们映射choreData中所有的<strong class="lc ir">杂务</strong>，并将标题添加到一个数组中并返回它。</p><p id="e50b" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">我们还需要更新我们在<strong class="lc ir"> index.js </strong>中的<strong class="lc ir"> ListChoresIntentHandler </strong>，以调用我们的<strong class="lc ir"> API </strong>文件中的<strong class="lc ir">get feathers()</strong>。</p><pre class="nk nl nm nn gt no ni np nq aw nr bi"><span id="2078" class="ma kd iq ni b gy ns nt l nu nv">/**<br/> * Handler for the ListChoresIntent<br/> */<br/>const ListChoresIntentHandler = {<br/>  canHandle(handlerInput) {<br/>    const { request } = handlerInput.requestEnvelope;<br/>    return (<br/>      request.type === Requests.INTENT_REQUEST &amp;&amp;<br/>      request.intent.name === Intents.LIST_CHORES_INTENT<br/>    );<br/>  },<br/>  async handle(handlerInput) {<br/>    let speakOutput = 'There are no chores in your bucket';<br/>    const chores = await API.getChores();<br/>    if (chores.length &gt; 0) {<br/>      speakOutput = 'Your chores are ' + chores.join(', ');<br/>    }<br/>    return handlerInput.responseBuilder.speak(speakOutput).getResponse();<br/>  }<br/>};</span></pre><p id="075a" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">确保使用<strong class="lc ir"> require() </strong>语句将api.js包含在index.js的顶部。另外，请记住，我们给<strong class="lc ir"> handle() </strong>添加了<strong class="lc ir"> async </strong>修饰符。为了允许我们使用<strong class="lc ir"> await </strong>关键字，必须添加这一点。</p><p id="0fba" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">现在，当你问Alexa <em class="lz">“让家务跟踪器列出我的家务吗？”</em>，它应该回说<em class="lz">“你的家务活是割草。”</em></p><h1 id="d9f0" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">将对象写入我们的桶</h1><p id="fb6e" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">既然我们有了检索所有添加的家务的方法，让我们添加一个允许我们添加新家务的函数。</p><p id="f953" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">首先，让我们用下面的函数更新我们的<strong class="lc ir"> api.js </strong>文件。</p><pre class="nk nl nm nn gt no ni np nq aw nr bi"><span id="fa1f" class="ma kd iq ni b gy ns nt l nu nv">/**<br/> * Add a chore to the bucket<br/> */<br/>const addChore = async function(chore) {<br/>  const params = {<br/>    title: chore,<br/>    type_slug: 'chores',<br/>    content: null<br/>  };<br/>  var returnData = await choreBucket<br/>    .addObject(params)<br/>    .then(data =&gt; {<br/>      return data;<br/>    })<br/>    .catch(err =&gt; {<br/>      console.log(err);<br/>      return null;<br/>    });<br/>  return !!returnData;<br/>};</span><span id="98ac" class="ma kd iq ni b gy nz nt l nu nv">//Update module.exports<br/>module.exports = {<br/>  getChores,<br/>  addChore<br/>}</span></pre><p id="2a38" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">这是一个简单的函数，它将把一个对象类型为<strong class="lc ir">的对象添加到我们的家务桶中。类似于<strong class="lc ir"> getObjects() </strong>，我们用<strong class="lc ir"> then() </strong>和<strong class="lc ir"> catch() </strong>处理承诺。最后，无论响应是否为空，我们都返回一个布尔值，表明操作成功。</strong></p><p id="3f2e" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">我们还需要更新<strong class="lc ir"> index.js </strong>中的<strong class="lc ir"> AddChoreIntentHandler </strong>来调用<strong class="lc ir">add jare()</strong>。</p><pre class="nk nl nm nn gt no ni np nq aw nr bi"><span id="f55a" class="ma kd iq ni b gy ns nt l nu nv">/**<br/> * Handler for the AddChoreIntent<br/> */<br/>const AddChoreIntentHandler = {<br/>  canHandle(handlerInput) {<br/>    const { request } = handlerInput.requestEnvelope;<br/>    return (<br/>      request.type === Requests.INTENT_REQUEST &amp;&amp;<br/>      request.intent.name === Intents.ADD_CHORE_INTENT<br/>    );<br/>  },<br/>  async handle(handlerInput) {<br/>    const { request } = handlerInput.requestEnvelope;</span><span id="f35c" class="ma kd iq ni b gy nz nt l nu nv">    //Retrieve the chore said by the user<br/>    const choreSlot = request.intent.slots.Chore;<br/>    let choreName;<br/>    if (choreSlot &amp;&amp; choreSlot.value) {<br/>      choreName = choreSlot.value.toLowerCase();<br/>    }</span><span id="3109" class="ma kd iq ni b gy nz nt l nu nv">    let speakOutput = Messages.ERROR_NO_CHORE_SLOT;<br/>    if (choreName) {<br/>      const success = await API.addChore(choreName);<br/>      if (!success) {<br/>        speakOutput = Messages.ERROR_ADDING_CHORE;<br/>      }<br/>      speakOutput = `Added ${choreName} to your chores list!`;<br/>    }<br/>    return handlerInput.responseBuilder.speak(speakOutput).getResponse();<br/>  }<br/>};</span></pre><p id="5b3a" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">这比上一个处理程序稍长，因为我们必须通过阅读<strong class="lc ir"> choreSlot </strong>来检索用户所说的杂务的名称。接下来，我们调用<strong class="lc ir">add Jerome()</strong>并检查操作是否成功，然后返回相应的消息。</p><p id="ce66" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">现在，当你问Alexa <em class="lz">“要求家务跟踪器添加清洗碗碟”</em>时，它应该回说<em class="lz">“将清洗碗碟添加到你的家务清单”</em>，以及向你的桶添加一个新对象。</p><h1 id="676e" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">从我们的桶中取出物品</h1><p id="5b54" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">但是，如果我们想去除杂务呢？像以前一样，我们需要首先将<strong class="lc ir">remove Jerry()</strong>添加到我们的<strong class="lc ir"> api.js </strong>文件中，并更新<strong class="lc ir"> index.js </strong>中的<strong class="lc ir">RemoveChoreIntentHandler</strong>。</p><p id="7855" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">首先，我们最后一次更新<strong class="lc ir"> api.js </strong>文件。</p><pre class="nk nl nm nn gt no ni np nq aw nr bi"><span id="6f57" class="ma kd iq ni b gy ns nt l nu nv">/**<br/> * Remove a chore from the bucket<br/> */<br/>const removeChore = async function(chore) {<br/>  const params = {<br/>    slug: chore<br/>      .split(' ')<br/>      .join('-')<br/>      .toLowerCase()<br/>  };<br/>  var returnData = await choreBucket<br/>    .deleteObject(params)<br/>    .then(data =&gt; {<br/>      return data;<br/>    })<br/>    .catch(err =&gt; {<br/>      console.log(err);<br/>      return null;<br/>    });<br/>  return !!returnData;<br/>};</span><span id="4881" class="ma kd iq ni b gy nz nt l nu nv">module.exports = {<br/>  getChores,<br/>  addChore,<br/>  removeChore<br/>};</span></pre><p id="95cd" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">这个函数几乎与<strong class="lc ir">add jore()</strong>相同，但是我们修改了参数，并在我们的Chore Bucket上调用了<strong class="lc ir"> deleteObject() </strong>。我们还必须用连字符替换杂务中的所有空格，因为这是对象存储在桶中的方式。这还会返回一个布尔值，表明操作是否成功。</p><p id="cea8" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">同时更新<strong class="lc ir"> index.js </strong>中的<strong class="lc ir"> RemoveChoreIntentHandler </strong></p><pre class="nk nl nm nn gt no ni np nq aw nr bi"><span id="2a1d" class="ma kd iq ni b gy ns nt l nu nv">/**<br/> * Handler for the RemoveChoreIntent<br/> */<br/>const RemoveChoreIntentHandler = {<br/>  canHandle(handlerInput) {<br/>    const { request } = handlerInput.requestEnvelope;<br/>    return (<br/>      request.type === Requests.INTENT_REQUEST &amp;&amp;<br/>      request.intent.name === Intents.REMOVE_CHORE_INTENT<br/>    );<br/>  },<br/>  async handle(handlerInput) {<br/>    const { request } = handlerInput.requestEnvelope;</span><span id="a12f" class="ma kd iq ni b gy nz nt l nu nv">    const choreSlot = request.intent.slots.choreName;<br/>    let choreName;<br/>    if (choreSlot &amp;&amp; choreSlot.value) {<br/>      choreName = choreSlot.value.toLowerCase();<br/>    }</span><span id="676b" class="ma kd iq ni b gy nz nt l nu nv">    let speakOutput = Messages.ERROR_NO_CHORE_SLOT;<br/>    if (choreName) {<br/>      const success = await API.removeChore(choreName);<br/>      speakOutput = Messages.ERROR_REMOVING_CHORE;<br/>      if (success) {<br/>        speakOutput = `Successfully removed ${choreName}`;<br/>      }<br/>    }<br/>    return handlerInput.responseBuilder.speak(speakOutput).getResponse();<br/>  }<br/>};</span></pre><p id="8c91" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">这也非常类似于<strong class="lc ir"> AddChoreIntentHandler </strong>，但是消息和API调用不同。</p><p id="84e6" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">所以，当你问Alexa <em class="lz">“问家务追踪器移除割草”</em>时，它应该回说<em class="lz">“成功移除割草”</em>，以及从桶中移除相应的物体。</p><h1 id="7d20" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="330b" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">这就对了。你现在有一个工作的Alexa技能，你可以用它来跟踪你在家里必须做的任何家务或任务。通过修改<strong class="lc ir"> en-US.json </strong>模型文件和通过修改<strong class="lc ir"> Messages.js </strong>文件来添加您自己的杂务。</p><p id="a3b4" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated">如果您有任何问题或遇到任何困难，请随时在<a class="ae ly" href="https://github.com/cosmicjs/alexa-to-do" rel="noopener ugc nofollow" target="_blank">完整源代码GitHub库</a>上提出问题，我将非常乐意回应</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/adfb8bd8ad94c8c6920e73829c2d0490.png" data-original-src="https://miro.medium.com/v2/resize:fit:144/format:webp/0*RwqZQIaAHI_2tYKk.png"/></div></figure><p id="8a78" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi">.</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><p id="6657" class="pw-post-body-paragraph la lb iq lc b ld na lf lg lh nb lj lk ll nc ln lo lp nd lr ls lt ne lv lw lx ij bi translated"><em class="lz">原载于【cosmicjs.com】<a class="ae ly" href="https://www.codementor.io/reaganmcfarland/how-to-build-an-alexa-skill-to-add-objects-to-your-bucket-via-voice-n3ce2kq1s" rel="noopener ugc nofollow" target="_blank"><em class="lz"/></a><em class="lz">。</em></em></p></div></div>    
</body>
</html>