<html>
<head>
<title>Мessy Route Handling in Golang and how to avoid it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang中的简单路线处理以及如何避免</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/messy-route-handling-in-golang-and-how-to-avoid-it-736e7d5e216b?source=collection_archive---------12-----------------------#2022-03-30">https://levelup.gitconnected.com/messy-route-handling-in-golang-and-how-to-avoid-it-736e7d5e216b?source=collection_archive---------12-----------------------#2022-03-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8fc1a0fcc022a560fe6aa36b134fb4c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Mq299lpf1GTbfzhe2q_tQ.png"/></div></div></figure><p id="c022" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的例子是用Go编写的，但是同样的原则很容易适用于多种语言。</p><p id="476b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在处理路线方面，Go有一个非常简单易懂的方法。开发人员会看到http <strong class="ka ir"> </strong>包中的默认处理程序，因此我们可以立即开始响应请求。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="e9de" class="lf lg iq lb b gy lh li l lj lk">func (w http.ResponseWriter, r *http.Request) {<br/>    _, err := w.Write(w, []byte("hello there!"))<br/>    if err != nil {<br/>        w.WriteHeader(http.StatusInternalServerError)<br/>    }<br/>}</span></pre><p id="424e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我见过很多这样构建的API，但它们迟早会遇到同样的问题——不一致、责任纠缠、不当行为和脆弱的代码。</p><h1 id="ecc7" class="ll lg iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">使用默认处理程序的有效场景</h1><p id="b57e" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">著名的<strong class="ka ir">中间件</strong>链接模式是处理多种场景的有效方式，因此默认处理程序是该任务的绝佳候选。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="3c7f" class="lf lg iq lb b gy lh li l lj lk">func (w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {<br/>    if something {<br/>        w.WriteHeader(http.StatusUnauthorized)<br/>        return<br/>    }</span><span id="be24" class="lf lg iq lb b gy mn li l lj lk">    next(w, r)<br/>}</span></pre><p id="1899" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">中间件链规则规定，处理程序要么写入响应对象，要么调用链中的下一个对象。因此，写入响应对象是路由处理程序的责任。这是好的，直到它不是。</p><h1 id="1149" class="ll lg iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><strong class="ak">哪里出错了</strong></h1><p id="6fdf" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">使用路由处理程序编写响应是一项额外的责任，会带来以下令人不快的后果。</p><h2 id="2afe" class="lf lg iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">代码复制</h2><p id="7847" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">在每个路由处理程序中，设置正确的头、编码有效负载和写入响应对象的逻辑都必须重复。</p><h2 id="477f" class="lf lg iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">不保证一致性</h2><p id="b4f0" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">一个API应该在它的所有端点上保持一致。用InternalServerError响应，有时返回纯文本，有时返回JSON对象，有时什么也不返回，这是不自然的。</p><p id="97e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您用NoContent <strong class="ka ir"> </strong>状态进行响应，同时在响应体中放置一个JSON <strong class="ka ir"> </strong>对象，会怎么样？</p><p id="9137" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然使用默认处理程序允许您创建您能想到的任何荒谬的组合，但它注定会变得混乱。</p><h2 id="7213" class="lf lg iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">关注点分离</h2><p id="253d" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">一旦路由处理程序处理完结果，它需要选择适当的方式来写入响应。这不是一个好的关注点分离。结果已经准备好被返回，这就足够了。</p><h2 id="aebc" class="lf lg iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">脆弱代码</h2><p id="5ed0" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">在实践中，在整个代码库中创建新路线的每个人都必须熟悉必须做的每件事，并且他们应该练习这样做。否则，我们将打破前面的任何一点，这是一个不能总是及时发现的错误。项目越大，就越难发现这样的错误。</p><h1 id="786c" class="ll lg iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">简单的“修复”</h1><p id="e171" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">如果我们正在处理代码复制和标准化，自然会考虑使用<strong class="ka ir">助手函数</strong>。因此，我们可能会在代码库中添加一个名为httputil，<strong class="ka ir"> </strong>的包，并开始描述有效响应的样子。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="01f0" class="lf lg iq lb b gy lh li l lj lk">func WriteCreated(w http.ResponseWriter, payload interface{}) {<br/>    w.Header().Set("Content-Type", "application/json")<br/>    w.WriteHeader(http.StatusCreated)<br/>    <br/>    if err := json.NewEncoder(w).Encode(payload); err != nil {<br/>        w.WriteHeader(http.StatusInternalServerError)<br/>    }<br/>}</span></pre><p id="e3fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这是一个进步，但问题仍然存在——没有人强迫路由处理程序使用这个或任何其他帮助函数。他们可以干脆决定耍无赖，自己写响应对象。</p><h1 id="0307" class="ll lg iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">理解真正的问题</h1><p id="a3b4" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">如果我们期望从函数中得到一个结果，我们自然会使用返回函数。通过这种方式，我们确切地知道我们将得到什么，并且我们可以确保它总是以我们需要的格式出现。</p><p id="88d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，void函数没有单一的返回场景。他们没有义务返回任何东西。不能强迫他们做任何与将结果传递回调用者相关的事情。</p><h2 id="32b2" class="lf lg iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">使用void函数返回值</h2><p id="3a25" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">根据定义，Go中的默认路由处理程序是<strong class="ka ir"> void函数</strong>。因此，他们不受任何约束，也不能期望或要求他们以任何方式行事。他们只是做他们认为最好的事情。</p><h1 id="5b4a" class="ll lg iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">如何解决这个问题</h1><p id="7fdd" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">路由处理器的职责是接受和验证输入，调用业务逻辑，然后返回正确的结果。</p><p id="c9ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个路由处理器执行其工作所需要的就是<strong class="ka ir">请求对象</strong>。writer对象只是一个需要以某种方式管理的额外负担。</p><p id="9e79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以使用简单的struct对象来描述响应。那么，为什么不让路由处理器成为返回这样一个结构的返回函数呢？</p><h2 id="4080" class="lf lg iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">标准化响应</h2><p id="fd85" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">首先，我们创建一个<strong class="ka ir">响应</strong>包，并在其中定义以下内容:</p><p id="991a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> response.go </strong></p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="53b9" class="lf lg iq lb b gy lh li l lj lk">type PayloadType int</span><span id="8801" class="lf lg iq lb b gy mn li l lj lk">var(<br/>    PayloadEmpty PayloadType = iota<br/>    PayloadText<br/>    PayloadJSON<br/>)</span><span id="3aab" class="lf lg iq lb b gy mn li l lj lk">type HttpResponse struct {<br/>    statusCode int<br/>    payload    interface{}<br/>    payloadType PayloadType<br/>    еrrMessage string<br/>}</span></pre><p id="5285" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有意将这些字段保持私有，因此只能通过使用一个标准化的响应构造函数来创建对象。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="8112" class="lf lg iq lb b gy lh li l lj lk">func Created(payload interface{}) HttpResponse {<br/>    return HttpResponse{<br/>        statusCode: http.StatusCreated,<br/>        payload: payload,<br/>    }<br/>}</span><span id="6282" class="lf lg iq lb b gy mn li l lj lk">// all needed response types...</span></pre><p id="8625" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一步是实现一个写函数。这将是一个单点故障，因为它将用于编写整个代码库的所有响应。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="5ef3" class="lf lg iq lb b gy lh li l lj lk">func Write(w http.ResponseWriter, response HttpResponse) error {<br/>    // write the response<br/>}</span></pre><h2 id="73d0" class="lf lg iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">符合路线处理程序</h2><p id="6f77" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">现在可以使用我们创建的<strong class="ka ir"> HttpResponse </strong>结构来描述响应。我们所要做的就是修改路由处理程序，这样它们就可以开始返回一个标准化的值。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="a8e6" class="lf lg iq lb b gy lh li l lj lk">func(a *api) DoSomething (r *http.Request) response.HttpResponse {<br/>    id := getParam(r, "id")<br/>    if isValidID(id) == false {<br/>        return response.BadRequest(ErrMsgInvalidID)<br/>    }</span><span id="f69f" class="lf lg iq lb b gy mn li l lj lk">    result, err := a.service.DoSomething(id)<br/>    if err != nil {<br/>        msg := "do something was unable to complete"<br/>        return response.InternalServerError(msg)<br/>    }</span><span id="5ea5" class="lf lg iq lb b gy mn li l lj lk">    return response.OK(payload)<br/>}</span></pre><p id="1575" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以将它包装在一个标准的处理器中，并在任何路由器和中间件中使用它。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="016d" class="lf lg iq lb b gy lh li l lj lk">type RouteHandler func (*http.Request) response.HttpResponse</span><span id="6788" class="lf lg iq lb b gy mn li l lj lk">func Wrap (handler RouteHandler) http.HandlerFunc {<br/>    return func(w http.ResponseWriter, r *http.Request) {<br/>        resp := handler(r)<br/>        <br/>        if err := response.Write(w, resp); err != nil {<br/>            logger.Error(err)<br/>        }<br/>    }<br/>}</span></pre><h1 id="796f" class="ll lg iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">结论</h1><p id="c383" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">这篇文章中的观点远非革命性的。然而，它们解决了仍然存在于任何地方的代码库中的问题。我已经看过很多了。</p><p id="627a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码库往往会随着时间的推移而增长。从事这项工作的人数也在增加。如果标准化的行为和一致性得不到执行，那么混乱就会慢慢接管。</p><p id="962a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然在开始时加快速度并避免事情过于复杂是很诱人的，但响应是每个API的重要部分，我相信它们应该做得正确。</p><p id="3195" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望本文中的信息可以帮助人们提出自己的想法，这样我们就可以创建令人愉快的API。</p><p id="8c58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">欢迎评论和提问。</p></div></div>    
</body>
</html>