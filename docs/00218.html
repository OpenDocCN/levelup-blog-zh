<html>
<head>
<title>Managing Microcopy with React and Contentful</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用反应和满足来管理缩微拷贝</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/managing-microcopy-with-react-and-contentful-acae948141ea?source=collection_archive---------0-----------------------#2018-09-30">https://levelup.gitconnected.com/managing-microcopy-with-react-and-contentful-acae948141ea?source=collection_archive---------0-----------------------#2018-09-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="69a9" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">这篇博文现在在我的个人博客上。</p></blockquote><p id="f376" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">让我们摆脱文字变化✍️开发票</p><p id="d634" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">每个网站都有。微型文本——这些小文本让网站变得生动，可以让浏览用户点击更多或者离开页面。它是标题、错误信息或联系表单中的小提示。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/82884f796aaff0a36ef23e3de126101c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sEIigbETlNgzdSwGdq1LIg.jpeg"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">由<a class="ae kp" href="https://unsplash.com/photos/OhJmwB4XWLE?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">布鲁诺·马丁斯</a>在<a class="ae kp" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ba20" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">但是编写网站代码的开发人员(通常)并不是擅长编写microcopy的人。是来自公共关系、业务、产品或设计部门的同事——没有开发人员知识或权限进行代码更改的人。这意味着文本中几个音节的简单变化需要作者和开发者之间的沟通——在最坏的情况下，还需要以JIRA或特雷罗的开发票的形式进行优先排序。</p><p id="51c1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">问题:我们如何在代码之外管理microcopy，让没有开发人员权限的人可以轻松地修改文本？</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><p id="0110" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated"><strong class="jt ir">解决方案</strong>:一个前端应用程序从一个无头CMS中提取microcopy。在这个例子中，我将使用<strong class="jt ir"> React和</strong><a class="ae kp" href="https://www.contentful.com/" rel="noopener ugc nofollow" target="_blank"><strong class="jt ir">Contentful</strong></a><strong class="jt ir">。</strong></p><h1 id="477f" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">步骤1:在Contentful中建立内容模型</h1><p id="0b87" class="pw-post-body-paragraph jq jr iq jt b ju mo jw jx jy mp ka kb kq mq ke kf kr mr ki kj ks ms km kn ko ij bi translated">存储副本最简单的方法是一个键和值对。但是随着添加的元素越来越多，这个翻译键和实际文本的列表会变得难以维护。由于React将UI分离成组件，我们可以基于这些组件对microcopy进行聚类，并保持对存储文本的良好概述。</p><p id="acd1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">在Contentful中设置了一个新空间后，我创建了内容类型<strong class="jt ir"> <em class="js">全局副本</em> </strong>，它引用了几个<strong class="jt ir"> <em class="js">组件副本。</em> </strong>内容类型<strong class="jt ir"> <em class="js">组件副本</em> </strong>保存了组件的名称和几个<strong class="jt ir"> <em class="js">单个副本。</em> </strong>然后内容类型<strong class="jt ir"> <em class="js">单份拷贝</em> </strong>包括拷贝id和拷贝文本的字段。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi mt"><img src="../Images/a39e7c3e92a945e6dc0f13958737353b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LZ1uq5QulQRifXh8RievaQ.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">Contentful中的内容类型</figcaption></figure><h1 id="cbb7" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">第二步:添加内容</h1><p id="1194" class="pw-post-body-paragraph jq jr iq jt b ju mo jw jx jy mp ka kb kq mq ke kf kr mr ki kj ks ms km kn ko ij bi translated">作为一个例子，我现在创建一个<strong class="jt ir"> <em class="js">全局副本</em> </strong>条目，其中一个<strong class="jt ir"> <em class="js">组件副本</em> </strong>条目被称为<em class="js">头</em>。然后我添加两个<strong class="jt ir"> <em class="js">单副本</em> </strong>条目，id为该组件的<em class="js"> HEADLINE </em>和<em class="js"> SUB_HEADLINE t </em>。让我们为每个条目点击发布。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi mu"><img src="../Images/6111f85103ba148ddc406e07d8c2d0b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*drBTn21PmSXz7OaYzcTg0Q.png"/></div></div></figure><h1 id="0e44" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">步骤3:在React应用程序中获取缩微副本</h1><p id="df1e" class="pw-post-body-paragraph jq jr iq jt b ju mo jw jx jy mp ka kb kq mq ke kf kr mr ki kj ks ms km kn ko ij bi translated">在这个例子中，我使用<a class="ae kp" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>初始化一个新的React应用程序。然后我用<code class="fe mv mw mx my b">yarn add contentful</code>安装<a class="ae kp" href="https://www.npmjs.com/package/contentful" rel="noopener ugc nofollow" target="_blank">满意的</a>。这个节点模块提供了对Contentful Delivery API的简单访问，通过它我们可以将内容放入React应用程序中。</p><p id="3d3c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我们需要三个文件:主文件<em class="js"> App.js </em>，一个包含带有Contentful的副本处理的文件(<em class="js"> copyHandling.js </em>)和一个使用microcopy的示例组件(<em class="js"> Header.js </em>)。</p><p id="f3db" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">在<em class="js"> App.js </em>中，全局副本存储在状态中，副本的获取在componentDidMount方法中触发。一旦async <em class="js"> getAllCopy </em>方法成功返回副本，状态被更新，并且在<em class="js"> render </em>方法中，<em class="js"> Header </em>组件接收该组件的副本作为道具。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6294" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">在<em class="js"> copyHandling.js </em>中，来自Contentful客户端的<em class="js"> getEntries </em>方法用于通过内容交付API获取全局<strong class="jt ir"> <em class="js"> </em> </strong>条目。</p><p id="0696" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">参数<code class="fe mv mw mx my b">include: 2</code>确保在这个调用中不仅解析了全局条目，而且还返回了组件和单一副本条目(向下两层链接)。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7550" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">然后，来自Contentful的响应在<em class="js"> getAllCopy </em>函数中被转换成以下形式的对象:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="2f42" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">标题组件通过其props接收特定于该组件的缩微副本，并显示带有副本id的副本。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><p id="9bde" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">如果你想在多种语言中处理副本，这个例子也可以使用。在Contentful中，您可以添加另一个区域设置，并为每个内容类型启用字段本地化。然后，您将参数<code class="fe mv mw mx my b">locale: *</code>添加到<em class="js"> getEntries </em>方法中，不仅提取默认设置，还提取所有地区。您也可以在状态中保存当前选择的语言，并立即更改该语言。</p><p id="ae8a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">这个例子也可以扩展到与<strong class="jt ir"> redux </strong>一起使用。则全局副本对象不存储在应用状态中，而是存储在redux存储中。显示microcopy的每个组件都通过mapStateToProps函数提取相关的副本。</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h2 id="7cba" class="nb lr iq bd ls nc nd dn lw ne nf dp ma kq ng nh me kr ni nj mi ks nk nl mm nm bi translated">更多资源:</h2><ul class=""><li id="51c4" class="nn no iq jt b ju mo jy mp kq np kr nq ks nr ko ns nt nu nv bi translated"><a class="ae kp" href="https://github.com/kristinbaumann/react-contentful-microcopy" rel="noopener ugc nofollow" target="_blank">Github上这篇博文的代码链接</a></li><li id="dfe4" class="nn no iq jt b ju nw jy nx kq ny kr nz ks oa ko ns nt nu nv bi translated">我最初的<a class="ae kp" href="https://twitter.com/kristin_baumann/status/1043408627204276227" rel="noopener ugc nofollow" target="_blank">推特</a>关于这个话题的想法来自<a class="ae kp" href="https://twitter.com/stefanjudis" rel="noopener ugc nofollow" target="_blank">斯蒂芬·朱迪斯</a></li><li id="cbc8" class="nn no iq jt b ju nw jy nx kq ny kr nz ks oa ko ns nt nu nv bi translated"><a class="ae kp" href="https://uxplanet.org/microcopy-tiny-words-with-a-huge-ux-impact-90140acc6e42" rel="noopener ugc nofollow" target="_blank">关于如何编写microcopy的精彩文章</a></li><li id="42e9" class="nn no iq jt b ju nw jy nx kq ny kr nz ks oa ko ns nt nu nv bi translated">关于<a class="ae kp" href="https://www.contentful.com/r/knowledgebase/dynamic-microcopy/" rel="noopener ugc nofollow" target="_blank">动态缩微副本</a>的内容</li></ul><p id="8f06" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated"><em class="js">感谢您阅读本文！请留下问题或反馈，关注我的</em><a class="ae kp" href="https://twitter.com/kristin_baumann" rel="noopener ugc nofollow" target="_blank"><em class="js">Twitter</em></a><em class="js">获取更多JavaScript和React相关帖子。</em></p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><figure class="ku kv kw kx gt ky gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi ob"><img src="../Images/ff5028ba5a0041d2d76d2a155f00f05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaoZbi7tTKJ5vL7i2OAYMQ.png"/></div></a></figure><div class="oc od gp gr oe of"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">前45名React教程。课程由开发人员提交并投票，使您能够找到最佳反应…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">gitconnected.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot ld of"/></div></div></a></div></div></div>    
</body>
</html>