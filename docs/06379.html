<html>
<head>
<title>How to unit-test a private (non-exported) function in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中对私有(非导出)函数进行单元测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-unit-test-a-private-non-exported-function-in-javascript-14acc9d83216?source=collection_archive---------11-----------------------#2020-11-19">https://levelup.gitconnected.com/how-to-unit-test-a-private-non-exported-function-in-javascript-14acc9d83216?source=collection_archive---------11-----------------------#2020-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/74fcda31272aefa87e2783811b8b28fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/0*Q5oobWVA1SV6hkiy.jpeg"/></div></figure></div><div class="ab cl ju jv hu jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ij ik il im in"><p id="5641" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated"><em class="kz">原载于2020年11月19日</em><a class="ae la" href="https://www.wisdomgeek.com/development/web-development/javascript/how-to-unit-test-private-non-exported-function-in-javascript/" rel="noopener ugc nofollow" target="_blank"><em class="kz">【https://www.wisdomgeek.com】</em></a><em class="kz">。</em></p><p id="337e" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">在为JavaScript模块编写单元测试时，我们经常会遇到一个两难的问题，即模块有一些私有函数没有被导出。测试一个已经被导出的函数是很容易的，因为它可以被导入到单元测试框架中，并且功能可以被测试。但是如何对私有(非导出)函数进行单元测试呢？</p><h1 id="2265" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">测试导出的函数</h1><p id="60be" class="pw-post-body-paragraph kb kc iq kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky ij bi translated">在讨论私有函数之前，让我们先熟悉一下如何在JavaScript中测试导出的函数。我们将使用<a class="ae la" href="https://www.wisdomgeek.com/development/web-development/how-to-setup-jest-typescript-babel-webpack-project/" rel="noopener ugc nofollow" target="_blank"> Jest </a>来编写这个单元测试。让我们假设函数foo为:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2834" class="mn lc iq mj b gy mo mp l mq mr">// foo.js<br/>export function foo() {<br/>  return 'bar';<br/>}</span></pre><p id="b8c1" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">然后，我们将编写相应的单元测试用例来测试导出函数的功能，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5fc1" class="mn lc iq mj b gy mo mp l mq mr">// foo.test.js<br/>import { foo } from './foo.js'<br/><br/>describe('testing foo', () =&gt; {<br/>  expect(foo()).toBe('bar');<br/>});</span></pre><p id="d99d" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">现在我们已经熟悉了导出的函数，让我们进入下一部分。让我们先看看问题是什么。</p><h1 id="a91d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">非导出(私有)函数</h1><p id="a14c" class="pw-post-body-paragraph kb kc iq kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky ij bi translated">非导出函数类似于此文件中的secret函数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3ae8" class="mn lc iq mj b gy mo mp l mq mr">// foo.js<br/>let secret = () =&gt; '🤫'<br/>export function foo() {<br/>  return secret();<br/>}</span></pre><p id="137b" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">现在，如果我们要在单元测试中测试baz，</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6d7c" class="mn lc iq mj b gy mo mp l mq mr">// foo.test.js<br/>import secret from './foo.js'<br/><br/>// secret is undefined</span></pre><p id="a54f" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated"><strong class="kd ir">注意:</strong>我们一般不要单独测试私有函数。它们是实现细节的一部分。如果一个私有函数行为不正确，那么使用它的公开函数也会行为不正确。这样，通过测试公共接口，我们也在测试私有函数。但是有些情况下，比如私有函数太复杂，可能需要这样做。另一个场景可能是在一个公共函数中一个接一个地调用多个私有函数，我们需要单独测试它们。</p><p id="7171" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">既然我们知道问题是什么，让我们想想可能的解决办法。</p><p id="334b" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">最明显的一个方法是不要将“secret”作为私有函数，而是从模块foo中导出它。虽然这是解决这个问题的快捷方法，但不是正确的方法。为了对我们的模块进行单元测试，我们公开了很多功能，这可能会带来很多安全风险。</p><h1 id="3e56" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Rewire简介</h1><p id="b411" class="pw-post-body-paragraph kb kc iq kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky ij bi translated">用其他语言编写过单元测试之后，我知道应该有更好的解决方案。我在寻找一些东西，让我将私有函数作为模块的私有成员，但仍然使它们可测试。而<a class="ae la" href="https://www.npmjs.com/package/rewire" rel="noopener ugc nofollow" target="_blank"> Rewire </a>给我提供了这个功能。</p><p id="052a" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">虽然Rewire是作为单元测试的猴子补丁解决方案引入的，但官方描述称:</p><p id="6e8a" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">Rewire为模块添加了一个特殊的setter和getter，这样你就可以修改它们的行为来进行更好的单元测试。您可以:</p><ul class=""><li id="181e" class="ms mt iq kd b ke kf ki kj km mu kq mv ku mw ky mx my mz na bi translated">像流程一样为其他模块或全局注入模拟</li><li id="a06c" class="ms mt iq kd b ke nb ki nc km nd kq ne ku nf ky mx my mz na bi translated">检查私有变量</li><li id="98d9" class="ms mt iq kd b ke nb ki nc km nd kq ne ku nf ky mx my mz na bi translated">覆盖模块中的变量。"</li></ul><p id="c9cc" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">第二点是我们需要什么来解决我们的问题！</p><h1 id="7efd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Rewire和ES6</h1><p id="d373" class="pw-post-body-paragraph kb kc iq kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky ij bi translated">rewire的常见js实现不支持ES6。由于我们在项目中使用ES6导入，我们希望使用一个包将概念转移到ES6。这就是rewire的babel插件发挥作用的地方。</p><p id="544c" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">babel-plugin-rewire的灵感来自rewire.js，并使用babel将概念转移到ES6。因此，我们将使用npm/yarn在我们的项目中安装它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3cf9" class="mn lc iq mj b gy mo mp l mq mr">npm install babel-plugin-rewire --save-dev<br/><br/>or<br/><br/>yarn add --dev babel-plugin-rewire</span></pre><p id="69cf" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">在babel配置文件中，我们需要导入它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c214" class="mn lc iq mj b gy mo mp l mq mr">// babel.config.js<br/>module.exports = {<br/>  plugins: ['babel-plugin-rewire'],<br/>  ...<br/>};</span></pre><h1 id="641f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对私有函数进行单元测试</h1><p id="a3fc" class="pw-post-body-paragraph kb kc iq kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky ij bi translated">现在我们已经使用babel-plugin进行了Rewire，我们可以使用__get__方法访问私有/非导出函数。模块上的这个方法充当了一个getter，允许我们提取私有函数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fbb7" class="mn lc iq mj b gy mo mp l mq mr">// foo.test.js<br/>import foo from './foo.js'<br/><br/>describe('testing foo', () =&gt; {<br/>  const secret = foo.__get__('secret'); // rewire magic happens here<br/>  expect(secret()).toBe('🤫');<br/>});</span></pre><p id="395e" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">这样，我们就可以鱼和熊掌兼得了。我们能够神奇地调用私有函数，而不用从模块中导出它们。我们不再需要求助于黑客来获取对未导出的JavaScript函数的引用，并且可以确保函数保持私有。</p><p id="ec04" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">我们希望这篇文章能帮助你理解如何使用Rewire对JavaScript中的私有(非导出)函数进行单元测试。上面讨论的方法不仅适用于Jest，也适用于其他单元测试框架。我们不需要做任何代码重构或者仅仅为了测试而导出我们的私有函数。如果您正在为JavaScript编写单元测试用例，您可能也会对我们在Jasmine 博客文章中的<a class="ae la" href="https://www.wisdomgeek.com/development/web-development/javascript/running-specific-test-cases-in-jasmine/" rel="noopener ugc nofollow" target="_blank">运行特定的单元测试用例感兴趣。</a></p><p id="d9d1" class="pw-post-body-paragraph kb kc iq kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ij bi translated">如果你有什么想补充的，或者你认为我们接下来应该报道的，请在下面留言告诉我们。</p></div></div>    
</body>
</html>