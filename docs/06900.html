<html>
<head>
<title>A journey along Lambda Calculus with Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Go进行Lambda微积分之旅</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-journey-along-lambda-calculus-with-go-62c2f5135b78?source=collection_archive---------20-----------------------#2021-01-11">https://levelup.gitconnected.com/a-journey-along-lambda-calculus-with-go-62c2f5135b78?source=collection_archive---------20-----------------------#2021-01-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="938c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">类型化世界中的λ演算</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a4b4c2a3ca78dcc7b7e1edd9a206ca71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VF1iSMguQcfJRrUo58BalA.png"/></div></div></figure><p id="23fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">λCalculus is a<a class="ae lq" href="https://en.wikipedia.org/wiki/Lambda_calculus" rel="noopener ugc nofollow" target="_blank">是数理逻辑中表达计算</a>的形式系统，基于函数的概念，由<a class="ae lq" href="https://en.wikipedia.org/wiki/Alonzo_Church" rel="noopener ugc nofollow" target="_blank">阿隆佐·邱奇</a>于1936年定义。</p><p id="286a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">艾伦·图灵证明了λ演算和图灵机是等价的，因此λ演算是图灵完备的。这意味着任何计算都可以使用Lambda演算来执行。</p><p id="fe3a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有些人可能觉得用纸和笔来研究Lambda微积分会很困难，非常抽象，很乏味。</p><p id="d51d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">酷的是，正如我们所说，Lambda演算是基于函数的概念，这是程序员非常熟悉的东西。事实上，我们可以用任何支持“函数作为一等公民”的编程语言来实现Lambda演算，也就是说，用任何语言，函数可以作为参数传递给其他函数，也可以作为函数的结果返回。</p><p id="a4ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，每当我们使用这样的表达方式时</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="4f34" class="lw lx it ls b gy ly lz l ma mb">// g and h are functions<br/>function f(g) {<br/>  ...<br/>  return h<br/>}</span></pre><p id="bd0a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以实现Lambda演算。</p><p id="323a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go是一种支持“一等公民”功能的语言，因此易于实现Lambda演算。在这篇文章中，我们将会看到开发一个具体的计算例子意味着什么。</p><p id="90e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇博客中展示的代码和更多Go中Lambda演算的例子可以在这篇报告中找到<a class="ae lq" href="https://github.com/EnricoPicci/LambdaCalculus-Go-Typescript" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="bff3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:Javascript也是一种语言，即使它的本质与Go完全不同，它也是一种我们可以实现Lambda演算的语言，如<a class="ae lq" href="https://medium.com/p/36806ebc2857?source=post_stats_page-------------------------------------" rel="noopener">让我们编写函数式编程的根:用Typescript实现的Lambda演算</a>和用Javascript实现的Y和Z组合子<a class="ae lq" href="https://medium.com/p/31f25be934ec?source=post_stats_page-------------------------------------" rel="noopener">——用真实代码实现的Lambda演算</a>中所述。</p><h1 id="785c" class="mc lx it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">问题:计算数字的阶乘</h1><p id="6441" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">我们想要用来说明λ演算的例子是阶乘。</p><p id="a57c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在一种伪代码中，计算一个数的阶乘的函数是</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="3df5" class="lw lx it ls b gy ly lz l ma mb">function factorial(n) {<br/>   if (n == 0) {<br/>     return 1<br/>   }<br/>   return n * factorial(n-1)<br/>}</span></pre><p id="39c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了实现这个逻辑，我们需要执行一些步骤</p><ol class=""><li id="ad76" class="my mz it kw b kx ky la lb ld na lh nb ll nc lp nd ne nf ng bi translated">定义什么是数字<code class="fe nh ni nj ls b">n</code>。我们保持简单，我们将只定义自然数。</li><li id="0dcd" class="my mz it kw b kx nk la nl ld nm lh nn ll no lp nd ne nf ng bi translated">定义如何做减法(<code class="fe nh ni nj ls b">n-1</code>)</li><li id="610a" class="my mz it kw b kx nk la nl ld nm lh nn ll no lp nd ne nf ng bi translated">定义如何做乘法(<code class="fe nh ni nj ls b">n * factorial(n-1)</code>)。</li><li id="50c3" class="my mz it kw b kx nk la nl ld nm lh nn ll no lp nd ne nf ng bi translated">定义如何做条件逻辑(<code class="fe nh ni nj ls b">if(n == 0) ...</code>)。</li><li id="93b9" class="my mz it kw b kx nk la nl ld nm lh nn ll no lp nd ne nf ng bi translated">定义如何执行递归，即函数<code class="fe nh ni nj ls b">factorial</code>调用自身。</li></ol><p id="eab5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们开始吧。</p><h1 id="c153" class="mc lx it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">简而言之，程序员的Lambda演算机制</h1><p id="bf94" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">Lambda演算围绕着Lambda抽象的概念旋转，这就是程序员所说的<em class="np">“只需要一个参数并返回一个值的匿名函数”</em>。</p><p id="a7cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Lambda演算为Lambda抽象引入了一种特定的符号</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="92ee" class="lw lx it ls b gy ly lz l ma mb"><em class="np">λx.y  // function that defines a parameter x and returns a value y</em></span></pre><p id="c4f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以注意到，在上面的例子中，我们不知道<code class="fe nh ni nj ls b">y</code>是什么。它可以是任何东西，但这仍然是一个有效的Lambda抽象。一个更具体的例子是恒等函数，即接受参数<code class="fe nh ni nj ls b">x</code>并返回不变的<code class="fe nh ni nj ls b">x</code>的函数。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="f840" class="lw lx it ls b gy ly lz l ma mb"><em class="np">λx.x  // the Identity function</em></span></pre><p id="ce3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">翻译过来，身份功能是</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="4352" class="lw lx it ls b gy ly lz l ma mb">func I(x interface{}) interface{} {<br/>  return x<br/>}</span></pre><p id="80fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我同意乍一看不是很有用，但绝对是一个有效的Lambda抽象的Go表示。</p><p id="2e5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们实际上可以定义一个<code class="fe nh ni nj ls b">type alias</code>来描述Go中的Lambda抽象</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="b71b" class="lw lx it ls b gy ly lz l ma mb">type Lambda = func(x interface{}) interface{}</span></pre><p id="9141" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Lambda抽象，如上所定义的，以及这个概念的一些专门化，例如一个Lambda返回另一个Lambda，将是我们在整篇文章中用来执行计算和解决问题的唯一工具。没有数字，没有布尔，没有if-then-else，没有for循环。只是Lambda抽象。</p><h1 id="b596" class="mc lx it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">λ演算中的自然数</h1><p id="ab4f" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">在λ演算中定义自然正数的一种方法是所谓的教会符号。下表描述了编码为教会自然数的前三个数字</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="3984" class="lw lx it ls b gy ly lz l ma mb">ZERO lambda calculus is      <strong class="ls iu"><em class="np">λf.λx.x<br/> </em></strong>ONE in lambda calculus is   <strong class="ls iu"><em class="np">λf.λx.fx<br/> </em></strong>TWO<strong class="ls iu"><em class="np"> </em></strong>in lambda calculus is   <strong class="ls iu"><em class="np">λf.λx.f(fx)</em></strong></span></pre><p id="6d3d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个定义必须这样理解:<em class="np">一个自然数，在教会符号中，是一个函数，它期望一个函数</em> <strong class="kw iu"> <em class="np"> f </em> </strong> <em class="np">作为其第一个参数，并返回另一个函数，该函数期望</em> <strong class="kw iu"> <em class="np"> x </em> </strong> <em class="np">作为其参数，该参数返回嵌套应用的</em> <strong class="kw iu"> <em class="np"> f </em> </strong> <em class="np">到</em> <strong class="kw iu"> <em class="np"> x </em></strong></p><p id="0641" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，如果我们把这个定义变成Go代码，我们就可以开始为教堂编码的数字定义一个类型</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="d8e3" class="lw lx it ls b gy ly lz l ma mb">type ChurchNumber func(f interface{}) Lambda</span></pre><p id="5650" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个定义说，<code class="fe nh ni nj ls b">ChurchNumber</code>是一个函数，它期望一个<code class="fe nh ni nj ls b">f</code>参数作为输入，并返回一个<code class="fe nh ni nj ls b">Lambda</code>，它本身是一个函数，接受一个<code class="fe nh ni nj ls b">x</code>泛型参数并返回一个泛型值。</p><p id="6af0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，数字<strong class="kw iu">Z<em class="np">ero</em>T41】的Go实现是</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="496c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">换句话说<strong class="kw iu"> <em class="np">零次</em> </strong>应用<code class="fe nh ni nj ls b">f</code>到<code class="fe nh ni nj ls b">x</code>。</p><p id="57c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注。有些人可能想知道为什么在<code class="fe nh ni nj ls b">ChurchNumber</code>类型中，我们将<code class="fe nh ni nj ls b">f</code>定义为一般的<code class="fe nh ni nj ls b">interface{}</code>，而不是<code class="fe nh ni nj ls b">Lambda</code>，即使<code class="fe nh ni nj ls b">f</code>是一个Lambda函数。原因是我们可以，也将会定义其他类型的特殊Lambda函数，我们可以将这些函数传递给<code class="fe nh ni nj ls b">ChurchNumber</code>作为输入。例如，我们将看到我们可以将一个<code class="fe nh ni nj ls b">ChurchNumber</code>作为参数传递给另一个<code class="fe nh ni nj ls b">ChurchNumber</code>。一个<code class="fe nh ni nj ls b">ChurchNumber</code>可以被看作是一个<code class="fe nh ni nj ls b">Lambda</code>的特殊形式。但是，在Go中，这迫使我们将<code class="fe nh ni nj ls b">ChurchNumber</code>的参数<code class="fe nh ni nj ls b">f</code>定义为泛型<code class="fe nh ni nj ls b">interface{}</code>，因为没有一种简单自然的方法来定义包含<code class="fe nh ni nj ls b">Lambda</code>和<code class="fe nh ni nj ls b">ChurchNumber</code>的类型。</strong></p><h2 id="f323" class="lw lx it bd md ns nt dn mh nu nv dp ml ld nw nx mn lh ny nz mp ll oa ob mr oc bi translated">把教堂的数字映射成我们所知道的自然数</h2><p id="1b75" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">所以教会编码数是一个函数，它采用函数<strong class="kw iu"> f </strong>和值<strong class="kw iu"> x </strong>并返回n次<strong class="kw iu">f</strong>到<strong class="kw iu"> x </strong>的应用。</p><p id="7389" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是什么是<strong class="kw iu"> f </strong>和<strong class="kw iu"> x </strong>？至于Lambda微积分，它们可以是任何东西。</p><p id="01dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，我们可以把它们定义为</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="41f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们知道把这个<code class="fe nh ni nj ls b">f</code>和这个<code class="fe nh ni nj ls b">x</code>传递给任何一个教会编码的数字，我们就得到一个我们知道的自然数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="a295" class="lw lx it bd md ns nt dn mh nu nv dp ml ld nw nx mn lh ny nz mp ll oa ob mr oc bi translated">Succ功能</h2><p id="71da" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">我们可以使用<code class="fe nh ni nj ls b">Succ</code>函数，将数字<strong class="kw iu"> <em class="np">派生出一个</em> </strong>作为数字<strong class="kw iu"> <em class="np">零</em> </strong>的后继</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="47ec" class="lw lx it ls b gy ly lz l ma mb">Succ = <em class="np">λn.λf.λx.f(nfx)</em></span></pre><p id="ab75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将Lambda演算符号翻译成程序员更熟悉的东西， 我们可以说这个定义的意思是:<em class="np"/><strong class="kw iu"><em class="np">Succ</em></strong><em class="np">函数是一个取教会编码数</em> <strong class="kw iu"> <em class="np"> n </em> </strong> <em class="np">然后一个函数</em> <strong class="kw iu"> <em class="np"> f </em> </strong> <em class="np">然后一个值</em> <strong class="kw iu"> <em class="np"> x </em> </strong> <em class="np">并返回</em> <strong class="kw iu"> <em class="np">的函数</em></strong></p><p id="ed78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> f </strong>适用于<strong class="kw iu"> n </strong>同样的应用<strong class="kw iu"> f </strong>到<strong class="kw iu"> x </strong>，意思是将<strong class="kw iu"> n+1 </strong>乘以<strong class="kw iu"> f </strong>到<strong class="kw iu"> x </strong>，这正是<strong class="kw iu"> n+1 </strong>在教会记数法中的含义。</p><p id="3030" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go中的<code class="fe nh ni nj ls b">Succ</code>函数可以表示为</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="6afb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了基本的<code class="fe nh ni nj ls b">Lambda</code>和<code class="fe nh ni nj ls b">ChurchNumber</code>类型之外，通过引入其他特殊形式的Lambda类型，这个函数可以变得更加详细，但是这是我们需要考虑的基本实现。</p><p id="f171" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们有了<code class="fe nh ni nj ls b">Zero</code>和<code class="fe nh ni nj ls b">Succ</code>函数，我们可以定义所有其他的自然数，例如</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="07e2" class="lw lx it ls b gy ly lz l ma mb">var one = Succ(Zero)<br/>var two = Succ(one)<br/>var three = Succ(two)</span></pre><h1 id="ec3e" class="mc lx it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">一个数减去1</h1><p id="0f27" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">为了定义如何计算<code class="fe nh ni nj ls b">n — 1</code>，我们从λ演算中的二元组(即包含2个值的结构)的定义开始。</p><p id="ee22" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是λ演算中的二元组:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="ce81" class="lw lx it ls b gy ly lz l ma mb">2-tuple-struct = <em class="np">λx.λy.λf.f(x)(y)</em></span></pre><p id="a07f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">什么？是的，就是这样，这实际上是一个可以包含两个值的结构的定义。我们来看看为什么。</p><p id="c314" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nh ni nj ls b">2-tuple</code>的定义是:<em class="np">一个函数取一个</em> <strong class="kw iu"> <em class="np"> x </em> </strong> <em class="np">然后一个</em> <strong class="kw iu"> <em class="np"> y </em> </strong> <em class="np">然后一个函数</em> <strong class="kw iu"> <em class="np"> f </em> </strong> <em class="np">并返回</em> <strong class="kw iu"> <em class="np"> f(x)(y) </em> </strong></p><p id="8d63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，如果我们获取<code class="fe nh ni nj ls b">2-tuple-struct</code>并且我们首先传递给它一个<strong class="kw iu"> x </strong>，然后传递给它一个<strong class="kw iu"> y </strong>，我们获得一个函数，让我们称之为<strong class="kw iu">二元组</strong>，它通过闭包概念保存了<strong class="kw iu"> x </strong>和<strong class="kw iu"> y </strong>的值，并且只是期望第三个参数，一个函数<strong class="kw iu"> f </strong>，通过它对这些值做一些事情。因此我们可以说<strong class="kw iu">二元组</strong>保存了<strong class="kw iu"> x </strong>和<strong class="kw iu"> y </strong>的值，所以它实际上是一个包含两个元素的结构:<strong class="kw iu"> x </strong>和<strong class="kw iu"> y </strong>。</p><p id="c4b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go中一个简单的<code class="fe nh ni nj ls b">2-tuple-struct</code>实现如下</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="80be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我们看到的，我们需要使用Go类型断言两次</p><p id="0710" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nh ni nj ls b">(f.(Lambda)(x)).(Lambda)(y)</code></p><p id="08e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了使被定义为泛型<code class="fe nh ni nj ls b">interface{}</code>的<code class="fe nh ni nj ls b">f</code>能够作为函数被调用，并且将<code class="fe nh ni nj ls b">x</code>和<code class="fe nh ni nj ls b">y</code>作为参数传递给它。我们将很快回到这一点。</p><p id="2ee2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同时，可以像这样创建一个保存作为第一个和第二个值的<code class="fe nh ni nj ls b">Zero</code>的<strong class="kw iu">二元组</strong>T7】</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="c882" class="lw lx it ls b gy ly lz l ma mb">p00 := Tuple2Struct(Zero)(Zero)</span></pre><h2 id="1ff0" class="lw lx it bd md ns nt dn mh nu nv dp ml ld nw nx mn lh ny nz mp ll oa ob mr oc bi translated">类型对</h2><p id="0e10" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">让我们在<code class="fe nh ni nj ls b">p00</code>看更多细节。</p><p id="2901" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nh ni nj ls b">p00</code>是2次后续操作的结果，如下图所示</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/12232dbbd5f12b4a42ba381a231f7cf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MSIMjXk1HagPdwohd30o6w.png"/></div></div></figure><p id="3fbe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一步是将<code class="fe nh ni nj ls b">Zero</code>作为参数<code class="fe nh ni nj ls b">x</code>传递给<code class="fe nh ni nj ls b">Tuple2Struct</code>，后者返回一个函数作为结果。在第二步中，我们将<code class="fe nh ni nj ls b">Zero</code>作为参数<code class="fe nh ni nj ls b">y</code>传递给第一步返回的函数。</p><p id="24ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这两个连续操作的最终结果仍然是一个期望另一个函数<code class="fe nh ni nj ls b">f</code>作为输入的函数。根据<code class="fe nh ni nj ls b">Tuple2Struct</code>的定义，<code class="fe nh ni nj ls b">f</code>将先通过<code class="fe nh ni nj ls b">x</code>，再通过<code class="fe nh ni nj ls b">y</code>。</p><p id="5e58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个完整的构造要真正工作，需要<code class="fe nh ni nj ls b">f</code>成为一个接受<code class="fe nh ni nj ls b">x</code>的函数，并返回一个接受<code class="fe nh ni nj ls b">y</code>的函数。换句话说，<code class="fe nh ni nj ls b">f</code>接受一个<code class="fe nh ni nj ls b">x</code>并返回一个<code class="fe nh ni nj ls b">Lambda</code>。</p><p id="88e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用Go术语表示，<code class="fe nh ni nj ls b">f</code>必须是类型<code class="fe nh ni nj ls b">xl</code>，其中<code class="fe nh ni nj ls b">xl</code>定义为</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="c03a" class="lw lx it ls b gy ly lz l ma mb">type Lambda = func(x interface{}) interface{}                                               type xl func(x interface{}) Lambda</span></pre><p id="7da6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是<strong class="kw iu">二元组</strong>，即保存2个值的结构，即步骤1和步骤2的执行结果，是期望类型<code class="fe nh ni nj ls b">xl</code>的参数并返回一般值的函数。如果我们调用一个二元组<code class="fe nh ni nj ls b">Pair</code>，这就是它，那么我们可以为它定义一个类型</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="1f11" class="lw lx it ls b gy ly lz l ma mb">type Pair func(f xl) interface{}</span></pre><p id="7c0d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">定义了类型<code class="fe nh ni nj ls b">xl</code>和<code class="fe nh ni nj ls b">Pair</code>之后，我们现在可以像这样重新定义一个tuple 2结构，通过使用先前定义的类型来进行一些类型检查</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="9fd6" class="lw lx it bd md ns nt dn mh nu nv dp ml ld nw nx mn lh ny nz mp ll oa ob mr oc bi translated">检索一对元素</h2><p id="bbfa" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">可以像这样通过函数<code class="fe nh ni nj ls b">first</code>访问<code class="fe nh ni nj ls b">Pair</code>的第一个元素</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="5fc5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类似地，<code class="fe nh ni nj ls b">Pair</code>的第二个元素通过函数<code class="fe nh ni nj ls b">second</code>获得，函数定义如下</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="16d9" class="lw lx it bd md ns nt dn mh nu nv dp ml ld nw nx mn lh ny nz mp ll oa ob mr oc bi translated">Prev函数</h2><p id="124f" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">利用<strong class="kw iu">二元组、</strong>类型<code class="fe nh ni nj ls b">Pair</code>和函数<code class="fe nh ni nj ls b">Succ</code>和<code class="fe nh ni nj ls b">second</code>的概念，可以创建另一个函数<code class="fe nh ni nj ls b">NextPair</code>，该函数将作为输入的<strong class="kw iu"> p </strong>作为<code class="fe nh ni nj ls b">ChurchNumber</code> s的<code class="fe nh ni nj ls b">Pair</code>，并返回作为<code class="fe nh ni nj ls b">ChurchNumber</code> s的另一个<code class="fe nh ni nj ls b">Pair</code>的<strong class="kw iu"> outP </strong>在围棋中，这看起来像</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="bb46" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们对<code class="fe nh ni nj ls b">p00</code>(包含<code class="fe nh ni nj ls b">Zero</code>和<code class="fe nh ni nj ls b">Zero</code>的<code class="fe nh ni nj ls b">Pair</code>)应用3次<code class="fe nh ni nj ls b">nextPair</code>，嵌套一次调用的结果作为下一次调用的输入，我们得到</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d497" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">概括地说，如果我们将<code class="fe nh ni nj ls b">n</code>乘以<code class="fe nh ni nj ls b">nextPair</code>到<code class="fe nh ni nj ls b">p00</code>，我们得到一个包含作为第一元素的<code class="fe nh ni nj ls b">n-1</code>和作为第二元素的<code class="fe nh ni nj ls b">n</code>的教会编码数的<code class="fe nh ni nj ls b">Pair</code>。</p><p id="5105" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是将一个函数应用于一个值<code class="fe nh ni nj ls b">n</code>次正是教会编码中自然数的定义，换句话说</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="6782" class="lw lx it ls b gy ly lz l ma mb">n(nextPair)(p00) // returns a Pair containing (n-1) and n as values</span></pre><p id="cff9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">表示将<code class="fe nh ni nj ls b">n</code>次<code class="fe nh ni nj ls b">nextPair</code>应用于<code class="fe nh ni nj ls b">p00</code>。</p><p id="4a2b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们现在将<code class="fe nh ni nj ls b">first</code>函数传递给<code class="fe nh ni nj ls b">n(nextPair)(p00)</code>的结果，我们将获得返回的<code class="fe nh ni nj ls b">Pair</code>的第一个元素，即<code class="fe nh ni nj ls b">n-1</code>。</p><p id="8d21" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，如果我们想要计算给定的<code class="fe nh ni nj ls b">n</code>我们可以使用下面的函数</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="672c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nh ni nj ls b">Prev(n ChurchNumber)</code>因此是从1减去n的函数。</p><h1 id="8ed8" class="mc lx it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">用Lambda微积分计算两个数的乘积</h1><h2 id="5109" class="lw lx it bd md ns nt dn mh nu nv dp ml ld nw nx mn lh ny nz mp ll oa ob mr oc bi translated">λ演算定义</h2><p id="841e" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">λ演算中两个Church编码的自然数的乘法可以定义为</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="0bf0" class="lw lx it ls b gy ly lz l ma mb">Mult = <strong class="ls iu"><em class="np">λn.λm.λg.n(m(g)) // </em></strong><em class="np">symbol</em><strong class="ls iu"><em class="np"> </em></strong><em class="np">g is used instead of the usual f</em><strong class="ls iu"><em class="np"> </em></strong></span></pre><p id="21c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了证明这一点，我们用一个例子，二和三的乘法。</p><p id="a2e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">教会编码的二和三的定义是这样的</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/716333e38912419c74887731f53788a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Omz-8kMPE_0t6DAeNobfIA.png"/></div></div></figure><p id="34c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意颜色。我们将使用它们使演示更容易理解，希望如此。</p><p id="ba1f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们将上面给出的<code class="fe nh ni nj ls b">Mult</code>函数的定义作为参数应用于两个和三个，我们得到以下结果</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/ef681d3a056aff7a7b59ce4c9b99c0ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-BCQ3XZpIjA_8yN8hysjew.png"/></div></div></figure><p id="c698" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在应用参数与其值的机械替换，也称为<em class="np"> β归约</em>，我们可以证明2和3相乘的结果实际上是6，当然是按照Church编码的定义。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/4e956157fe37e509e8695d04faf28728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KsiN6Hxrq-NVCvKKzUopnw.png"/></div></div><figcaption class="oh oi gj gh gi oj ok bd b be z dk translated"><em class="ol"> β减少，证明Mult函数在两个和三个的情况下正常工作</em></figcaption></figure><h2 id="f5a3" class="lw lx it bd md ns nt dn mh nu nv dp ml ld nw nx mn lh ny nz mp ll oa ob mr oc bi translated">执行Mult函数的实现</h2><p id="d883" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">使用Go实现<code class="fe nh ni nj ls b">Mult</code>功能如下</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="ea6e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我们用Lambda演算定义的Go语法的直接翻译。唯一的区别是，在这里，使用Go，我们可以定义像<code class="fe nh ni nj ls b">nm</code>这样的类型，可能会更有表现力。</p><h1 id="af72" class="mc lx it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">布尔逻辑</h1><p id="09b6" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">至于自然数和算术，同样对于布尔逻辑我们需要从Lambda演算中的<strong class="kw iu">【真】</strong><strong class="kw iu">【假】</strong>的定义开始。我们再次利用了教会定义的编码。</p><h2 id="62e4" class="lw lx it bd md ns nt dn mh nu nv dp ml ld nw nx mn lh ny nz mp ll oa ob mr oc bi translated">布尔人的直觉</h2><p id="ee45" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">“if-then-else”块可以被认为是3个参数的函数，定义为伪代码，如下所示</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="1b30" class="lw lx it ls b gy ly lz l ma mb">ifThenElse = function(condition bool, ifTrue, ifFalse) {<br/>  if (condition == true) {<br/>    return ifTrue<br/>  }<br/>  return ifFalse<br/>}</span></pre><p id="37b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是这与Lambda演算不兼容，因为“ifThenElse”是一个需要3个参数的函数，而不是一个只有1个参数的函数。尽管如此，我们可以使用currying机制将其转换为与Lambda演算兼容的形式。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="a4af" class="lw lx it ls b gy ly lz l ma mb">ifThenElse = function(condition bool) {<br/>  return function(ifTrue) {<br/>    return function (ifFalse) {<br/>      if (condition == true) {<br/>        return ifTrue<br/>      }<br/>      return ifFalse<br/>    }<br/>  }<br/>}</span></pre><p id="4853" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们将值<strong class="kw iu">“真”、</strong>传递给第二个版本的<strong class="kw iu"> ifThenElse </strong>函数，那么对条件的检查将总是通过，因此值<strong class="kw iu"> ifTrue </strong>将总是最内层函数返回的值。换句话说，将<strong class="kw iu">“真”</strong>传递给<strong class="kw iu">，如果其他的</strong>将返回这个函数</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="9fe0" class="lw lx it ls b gy ly lz l ma mb">function(ifTrue) {<br/>  return function (ifFalse) {<br/>    return ifTrue<br/>  }<br/>}</span></pre><p id="f36d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类似地，如果我们将<strong class="kw iu"> "false" </strong>传递给<strong class="kw iu"> ifThenElse </strong>我们得到如下函数作为返回</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="a5bb" class="lw lx it ls b gy ly lz l ma mb">function(ifTrue) {<br/>  return function (ifFalse) {<br/>    return ifFalse<br/>  }<br/>}</span></pre><p id="bf00" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，如果我们将<strong class="kw iu"> "true" </strong>传递给<strong class="kw iu"> ifThenElse </strong>我们将得到一个带2个参数的函数，并返回第一个参数，而如果我们将<strong class="kw iu"> "false" </strong>传递给<strong class="kw iu">，我们将得到一个带2个参数的函数，并返回第二个参数。</strong></p><h2 id="55a7" class="lw lx it bd md ns nt dn mh nu nv dp ml ld nw nx mn lh ny nz mp ll oa ob mr oc bi translated">布尔的教会编码</h2><p id="b5db" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">根据直觉，布尔的教会编码如下</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="0a0c" class="lw lx it ls b gy ly lz l ma mb">True  = <em class="np">λ</em><strong class="ls iu"><em class="np">x</em></strong><em class="np">.λy</em><strong class="ls iu"><em class="np">.x //</em></strong><em class="np"> takes 2 params and return the </em><strong class="ls iu"><em class="np">first</em></strong><em class="np"> one</em></span><span id="5f19" class="lw lx it ls b gy om lz l ma mb">False = <em class="np">λx.λ</em><strong class="ls iu"><em class="np">y.y //</em></strong><em class="np"> takes 2 params and return the </em><strong class="ls iu"><em class="np">second</em></strong><em class="np"> one</em></span></pre><p id="6ebd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Go中，我们可以为ChurchBoolean定义一个类型</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="c603" class="lw lx it ls b gy ly lz l ma mb">type ChurchBoolean func(x interface{}) Lambda</span></pre><h2 id="ed07" class="lw lx it bd md ns nt dn mh nu nv dp ml ld nw nx mn lh ny nz mp ll oa ob mr oc bi translated">IsZero函数</h2><p id="6389" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">为了进一步解决我们的问题，我们需要定义一个函数<code class="fe nh ni nj ls b">IsZero</code>，它接受一个数字<code class="fe nh ni nj ls b">n</code>，如果该数字等于<code class="fe nh ni nj ls b">Zero</code>，则返回<code class="fe nh ni nj ls b">True</code>，否则返回<code class="fe nh ni nj ls b">False</code>(如上所述，<code class="fe nh ni nj ls b">True</code>和<code class="fe nh ni nj ls b">False</code>被认为是布尔的教会编码值)。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="c213" class="lw lx it ls b gy ly lz l ma mb">IsZero = function(n ChurchNumber) {<br/>  // do something with n to make sure that the return value is <br/>  // true if n is Zero, false otherwise<br/>}</span></pre><p id="07d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nh ni nj ls b">n</code>是一个教会编号。根据ChurchNumber的定义，这意味着<code class="fe nh ni nj ls b">n</code>是一个采用函数<strong class="kw iu"> f </strong>和值<strong class="kw iu"> x </strong>并返回n次<strong class="kw iu">的函数<strong class="kw iu"> f </strong>到<strong class="kw iu"> x </strong>。</strong></p><p id="bac7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果<code class="fe nh ni nj ls b">n</code>是<code class="fe nh ni nj ls b">Zero</code>，那么<strong class="kw iu"> f </strong>永远不会应用到<strong class="kw iu"> x </strong>并且<strong class="kw iu"> x </strong>是返回值。但是如果<code class="fe nh ni nj ls b">n</code>是<code class="fe nh ni nj ls b">Zero</code>，那么<code class="fe nh ni nj ls b">IsZero</code>必须返回<code class="fe nh ni nj ls b">True</code>，所以<strong class="kw iu"> x </strong>必须是值<code class="fe nh ni nj ls b">True</code>。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="863b" class="lw lx it ls b gy ly lz l ma mb">Zero = function(f) {<br/>  return function(x) {<br/>    return x<br/>  }<br/>}</span><span id="c622" class="lw lx it ls b gy om lz l ma mb">IsZero = function(n ChurchNumber) {<br/>  return n(...)(True)  // if n == Zero then 2nd param must be True<br/>}</span></pre><p id="7d24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果<code class="fe nh ni nj ls b">n</code>不是<code class="fe nh ni nj ls b">Zero</code>，那么<strong class="kw iu"> f </strong>被应用于<strong class="kw iu"> x </strong> n次。但是我们已经看到<strong class="kw iu"> x </strong>必须具有值<code class="fe nh ni nj ls b">True</code>，因此我们需要找到一个函数<strong class="kw iu"> f </strong>，不管它被应用到<strong class="kw iu"> x </strong>(其值为<code class="fe nh ni nj ls b">True</code>)多少次，总是返回<code class="fe nh ni nj ls b">False</code>。</p><p id="6b49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们能不能定义一个函数，不管传入的值是什么，参数总是返回<code class="fe nh ni nj ls b">False</code>？是的，我们可以，使用<strong class="kw iu">常量</strong>函数来生成常量</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="e8f2" class="lw lx it ls b gy ly lz l ma mb">Constant = function(x) {<br/>  return function(y) {<br/>    return x<br/>  }<br/>}</span><span id="84ce" class="lw lx it ls b gy om lz l ma mb">ConstantFalse = Constant(False)</span><span id="d06b" class="lw lx it ls b gy om lz l ma mb">// ConstantFalse(1)       returns False<br/>// ConstantFalse('abc')   returns False<br/>// ConstantFalse(True)    returns False</span></pre><p id="8e89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以<strong class="kw iu"> ConstantFalse </strong>是一个函数，不管哪个值作为参数传递，总是返回<code class="fe nh ni nj ls b">False</code>。</p><p id="fa48" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">综上所述，<code class="fe nh ni nj ls b">IsZero</code>函数定义如下</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="86c4" class="lw lx it ls b gy ly lz l ma mb">Zero = function(f) {<br/>  return function(x) {<br/>    return x<br/>  }<br/>}</span><span id="e9a3" class="lw lx it ls b gy om lz l ma mb">Constant = function(x) {<br/>  return function(y) {<br/>    return x<br/>  }<br/>}</span><span id="519c" class="lw lx it ls b gy om lz l ma mb">ConstantFalse = Constant(False)</span><span id="aeb9" class="lw lx it ls b gy om lz l ma mb">IsZero = function(n ChurchNumber) {<br/>  return n(ConstantFalse)(True)  <br/>}</span></pre><p id="3e80" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">围棋的整个过程是这样的</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="8002" class="mc lx it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">递归</h1><p id="4058" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">Lambda演算中的递归与Haskell Curry发现的<a class="ae lq" href="https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed-point_combinators_in_lambda_calculus" rel="noopener ugc nofollow" target="_blank"> Y组合子</a>的魔力有着内在的联系(是的，Haskell语言和“currying”技术都是以他的名字命名的)。</p><h2 id="e6aa" class="lw lx it bd md ns nt dn mh nu nv dp ml ld nw nx mn lh ny nz mp ll oa ob mr oc bi translated">Y组合子</h2><p id="273f" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">这是Y组合子的定义</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="3096" class="lw lx it ls b gy ly lz l ma mb">Y = λf. (λx. f (x x)) (λx. f (x x))</span></pre><p id="0205" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以<code class="fe nh ni nj ls b">Y</code>是一个期待一个<code class="fe nh ni nj ls b">f</code>并对其做一些事情的函数。</p><p id="f86e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是为什么这个东西和递归联系在一起呢？让我们看看当我们传递一个值给<code class="fe nh ni nj ls b">Y</code>函数时会发生什么，我们称之为<code class="fe nh ni nj ls b">g</code>。正如我们对<code class="fe nh ni nj ls b">Mult</code>功能的演示一样，我们将使用称为<em class="np"> β缩减</em>的机械变换。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/114622d0f6e220472454101870eb7099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dLOh37yudY0-xLTG0Yy-hA.png"/></div></div></figure><p id="c6e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，我们发现</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="eee3" class="lw lx it ls b gy ly lz l ma mb">Y(g) = g(Y(g))</span></pre><h2 id="62b4" class="lw lx it bd md ns nt dn mh nu nv dp ml ld nw nx mn lh ny nz mp ll oa ob mr oc bi translated">y组合子和递归</h2><p id="4abf" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">现在魔法来了。</p><p id="1405" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们回到最初的问题</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="e266" class="lw lx it ls b gy ly lz l ma mb">function factorial(n) {<br/>   if (n == 0) {<br/>     return 1<br/>   }<br/>   return n * factorial(n-1)<br/>}</span></pre><p id="8a6f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以将函数<code class="fe nh ni nj ls b">factorial</code>提取(抽象)到参数<code class="fe nh ni nj ls b">f</code>中，并获得以下表达式</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="31a6" class="lw lx it ls b gy ly lz l ma mb">function F(<strong class="ls iu">f</strong>) {<br/>   return function(n) { // anonymous function returned by F<br/>      if (n == 0) {<br/>        return 1<br/>      }<br/>      return n * <strong class="ls iu">f</strong>(n-1)<br/>   }<br/>}</span></pre><p id="6ff5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，如果我们将<code class="fe nh ni nj ls b">F</code>传递到<code class="fe nh ni nj ls b">Y</code>，根据<code class="fe nh ni nj ls b">Y</code>的定义，我们得到</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="15a0" class="lw lx it ls b gy ly lz l ma mb">Y(F) = F(Y(F))</span></pre><p id="1c8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们可以定义一个新的函数<code class="fe nh ni nj ls b">factorial'</code>,以下为真</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="9309" class="lw lx it ls b gy ly lz l ma mb">factorial' = Y(F) = F(Y(F)) = F(factorial')</span></pre><p id="d856" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是<code class="fe nh ni nj ls b">F(factorial')</code>可以开发成这样</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="4922" class="lw lx it ls b gy ly lz l ma mb">F(factorial') = (function F(<strong class="ls iu">f</strong>) {<br/>              |     return function(n) { <br/>              |       if (n == 0) {<br/>              |          return 1<br/>              |       }<br/>              |       return n * <strong class="ls iu">f</strong>(n-1)<br/>              |     }<br/>              |  })(<strong class="ls iu">factorial'</strong>)<br/>              |<br/>              = function(n) { <br/>              |   if (n == 0) {<br/>              |      return 1<br/>              |   }<br/>              |   return n * <strong class="ls iu">factorial'</strong>(n-1)<br/>              | }</span></pre><p id="bdb8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，我们来试着计算一下<code class="fe nh ni nj ls b">factorial'(2)</code></p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="d6a9" class="lw lx it ls b gy ly lz l ma mb">factorial'(2) = (F(<strong class="ls iu">factorial'</strong>))(2)<br/>              |<br/>              = (function(<strong class="ls iu">n</strong>) { <br/>              |   if (<strong class="ls iu">n</strong> == 0) {<br/>              |      return 1<br/>              |   }<br/>              |   return <strong class="ls iu">n</strong> * <strong class="ls iu">factorial'</strong>(n-1)<br/>              | })(<strong class="ls iu">2</strong>)<br/>              |<br/>              = if (<strong class="ls iu">2</strong> == 0) {  // 2 is NOT equal to 0<br/>              |    return 1<br/>              | }<br/>              | return <strong class="ls iu">2</strong> * <strong class="ls iu">factorial'</strong>(<strong class="ls iu">2</strong>-1)<br/>              |<br/>              = <strong class="ls iu">2</strong> * <strong class="ls iu">factorial'</strong>(<strong class="ls iu">2</strong>-1)</span></pre><p id="1b90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，最后，我们得到的是</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="61e6" class="lw lx it ls b gy ly lz l ma mb">factorial'(2) = <strong class="ls iu">2</strong> * <strong class="ls iu">factorial'</strong>(<strong class="ls iu">2</strong>-1)</span></pre><p id="e53a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这正是我们在寻找的递归类型。</p><h2 id="e55e" class="lw lx it bd md ns nt dn mh nu nv dp ml ld nw nx mn lh ny nz mp ll oa ob mr oc bi translated">Z组合子</h2><p id="0870" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">当我们想用一种“严格”编程语言(维基百科中的<a class="ae lq" href="https://en.wikipedia.org/wiki/Fixed-point_combinator" rel="noopener ugc nofollow" target="_blank">:<em class="np">严格编程语言也被称为eager语言，其中应用性求值顺序被应用</em> </a>)按照Lambda演算实现递归时，我们被迫回到Z组合子，它可能是Y组合子的一个不太优雅的兄弟。Go是一种“严格的”语言，所以我们将使用Z组合子。博客“<a class="ae lq" href="https://medium.com/swlh/y-and-z-combinators-in-javascript-lambda-calculus-with-real-code-31f25be934ec" rel="noopener">Javascript中的Y和Z组合子—带实代码的Lambda演算</a>”中描述了关于为什么“严格”语言需要使用Z组合子的更多细节。</p><p id="a5dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Z组合子定义为</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="d57b" class="lw lx it ls b gy ly lz l ma mb">Z = λg.(λx.g(λv.xxv))(λx.g(λv.xxv))</span></pre><p id="c734" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它在围棋中的实现是</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="d809" class="mc lx it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">包装它</h1><p id="f6aa" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">从简单的定义开始</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="75de" class="lw lx it ls b gy ly lz l ma mb">type Lambda = func(x interface{}) interface{}</span></pre><p id="f533" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">仅使用Lambda函数，我们已经定义了自然数(<code class="fe nh ni nj ls b">Zero</code>和<code class="fe nh ni nj ls b">Succ</code>)、乘和减这些数的函数(<code class="fe nh ni nj ls b">Mult</code>和<code class="fe nh ni nj ls b">Prev</code>)、条件逻辑(<code class="fe nh ni nj ls b">IsZero</code>)以及最终实现递归的方法(<code class="fe nh ni nj ls b">Z</code>组合子)。我们已经具备了创建一个函数的所有要素，该函数使用Go中实现的纯Lambda演算术语来计算一个数的阶乘。</p><h2 id="7033" class="lw lx it bd md ns nt dn mh nu nv dp ml ld nw nx mn lh ny nz mp ll oa ob mr oc bi translated">阶乘函数</h2><p id="80ad" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">用λ演算术语实现的阶乘函数是这样的</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="780f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并且可以用这样的测试用例进行测试</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="7319" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以在这里看到<a class="ae lq" href="https://github.com/EnricoPicci/LambdaCalculus-Go-Typescript/blob/master/go/src/lambdacalculusexpanded/factorialExpanded_test.go" rel="noopener ugc nofollow" target="_blank"/>一旦我们用匿名函数版本替换所有Go变量，这看起来是什么样子，例如用</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="e3a5" class="lw lx it ls b gy ly lz l ma mb">func(f interface{}) Lambda { <br/>   return func(x interface{}) interface{} {<br/>     return x <br/>   } <br/>}</span></pre><h1 id="ca0a" class="mc lx it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结论</h1><p id="3d07" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">这是一段漫长的旅程。我们从<code class="fe nh ni nj ls b">Lambda</code>的基本定义开始，最后只使用匿名函数和泛型<code class="fe nh ni nj ls b">interface{}</code>来计算一个数的阶乘。</p><p id="4005" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想了解Lambda微积分实际上是如何工作的，这有用吗？大概是的。</p><p id="4cbe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些代码可以在现实世界的开发中重用吗？大概不会。但是，在Go中作为“类型化的一等公民”使用函数可能是一个有趣的练习，这绝对是值得了解的事情。</p><p id="d34a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇文章中展示的全部Go代码，以及Typescript中的一个实现，可以在这个报告中找到。</p></div></div>    
</body>
</html>