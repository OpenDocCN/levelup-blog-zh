<html>
<head>
<title>Webpack explained from scratch (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零开始解释Webpack(第1部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/webpack-explained-from-scratch-part-1-7872379424a1?source=collection_archive---------3-----------------------#2022-04-04">https://levelup.gitconnected.com/webpack-explained-from-scratch-part-1-7872379424a1?source=collection_archive---------3-----------------------#2022-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="4d64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">大多数FE开发人员使用Webpack，这在开始时可能是一个挑战。配置可能会很快变得疯狂。在这个系列中，我们将探索Webpack做什么以及它是如何工作的。从“hello world”示例到高级装载机。</p><h1 id="1e4a" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">为什么我们首先需要Webpack？</h1><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/127aac2d52e303377a0f243980d6fb96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NM8513AV_erMGV6IYqk0aw.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">资料来源:webpack.js.org</figcaption></figure><p id="b931" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Webpack是一个捆绑工具，它接受多个不同的源(js、ts、css、scss、vue、react、angular、images)，如果需要的话对它们进行调整，并捆绑到浏览器可以理解的结果文件中。前端开发已经变得相当先进。我们不再仅仅编写简单的JS函数来移动滑块或打开弹出窗口。FE应用程序很复杂，可以做多种不同的事情。以即时通讯工具、谷歌文档、在线绘图工具为例。</p><p id="53ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">复杂的应用程序需要更高级的工具和框架来简化开发。在开发过程中，我们使用浏览器无法理解的工具，如TypeScript或SCSS。VueJs这样的框架使用单个文件组件，将模板、JavaScript和样式组合在一个文件中，浏览器不知道如何阅读。捆绑器(或一些专门的加载器)获取所有这些源，并为浏览器准备一个有意义的结果。生成的文件也以各种方式进行了优化，以减小文件大小，延迟加载等。</p><h1 id="d456" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">网络包的“你好，世界”</h1><p id="e9a3" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">当你打开Webpack文档时，你可能会感到迷茫。文档很大，每个部分都有很多页面，每个函数/加载器/插件都有另一个定制配置。刚开始的时候是非常压倒性的。配置文件也会很快变大。</p><p id="475d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一些框架，比如NuxtJs，将Webpack的设置打包到Nuxt config中，所以在很多情况下你并不需要真正理解webpack是如何工作的。它隐藏在NuxtJs后面。但是，如果需要，您可以扩展它。</p><h2 id="33be" class="mh kp it bd kq mi mj dn ku mk ml dp ky kb mm mn lc kf mo mp lg kj mq mr lk ms bi translated">好吧好吧，给我看看代码！</h2><p id="cf34" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">为了测试下面的例子，你只需要安装一些依赖关系的npm。</p><p id="360a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mt"> package.json </em>:</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="6f34" class="mh kp it mv b gy mz na l nb nc">{<br/>  "name": "webpack-5-examples",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "build": "webpack",<br/>  },<br/>  "repository": {},<br/>  "keywords": [],<br/>  "devDependencies": {<br/>    "@types/webpack": "^5.28.0",<br/>    "@types/core-js": "^2.5.5",<br/>    "@types/node": "^17.0.18",<br/>    "clean-webpack-plugin": "^4.0.0",<br/>    "css-loader": "^6.5.1",<br/>    "path": "^0.12.7",<br/>    "postcss": "^8.4.6",<br/>    "sass": "1.49.7",<br/>    "sass-loader": "^12.6.0",<br/>    "ts-loader": "^9.2.6",<br/>    "ts-node": "^10.7.0",<br/>    "typescript": "^4.6.2",<br/>    "vue": "^3.2.31",<br/>    "webpack": "^5.70.0",<br/>    "webpack-cli": "^4.9.1",<br/>    "webpack-dev-server": "^4.4.0",<br/>    "webpack-nano": "^1.1.1",<br/>    "webpack-node-externals": "^3.0.0"<br/>  }<br/>}</span></pre><p id="40da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们需要<em class="mt"> webpack.config.js </em>:</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="bb75" class="mh kp it mv b gy mz na l nb nc"><strong class="mv iu">const </strong><em class="mt">path </em><strong class="mv iu">= </strong><em class="mt">require</em>('path');<br/><strong class="mv iu">const </strong>{CleanWebpackPlugin} <strong class="mv iu">= </strong><em class="mt">require</em>("clean-webpack-plugin");<br/><br/><em class="mt">module</em>.<em class="mt">exports </em><strong class="mv iu">= </strong>{<br/>  mode<strong class="mv iu">: </strong>'development',<br/><br/>  devtool<strong class="mv iu">: </strong>false,<br/><br/>  entry<strong class="mv iu">: </strong>{<br/>    main<strong class="mv iu">: </strong>'./index.js',<br/>  },<br/><br/>  output<strong class="mv iu">: </strong>{<br/>    path<strong class="mv iu">: </strong><em class="mt">path</em>.join(__dirname, 'public'),<br/>    filename<strong class="mv iu">: </strong>'[name].js',<br/>  },<br/><br/>  module<strong class="mv iu">: </strong>{<br/>    rules<strong class="mv iu">: </strong>[],<br/>  },<br/><br/>  plugins<strong class="mv iu">: </strong>[<br/>    new CleanWebpackPlugin({<br/>      cleanOnceBeforeBuildPatterns<strong class="mv iu">: </strong>[<br/>        '**/*.js',<br/>      ],<br/>    }),<br/>  ],<br/>};</span></pre><p id="2000" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后是一个<em class="mt"> index.js </em>。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="4ecd" class="mh kp it mv b gy mz na l nb nc">let <em class="mt">long_variable_name </em>= 1;<br/><br/>for(let iiii = 0; iiii &lt; 10; iiii++) {<br/>  <em class="mt">long_variable_name</em>++<br/>}<br/><br/><em class="mt">console</em>.log(<em class="mt">long_variable_name</em>)</span></pre><p id="4082" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们对文件或配置进行任何更改后，我们将始终运行“<em class="mt"> npm run build </em>”。结果将在<em class="mt">中。/public </em>文件夹。</p><p id="c5af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Webpack配置只有几个强制设置。我们必须告诉web pack<strong class="js iu">入口文件</strong>是什么。在我们的例子中<em class="mt"> index.js </em>。这是Webpack开始处理的第一个文件。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="c1da" class="mh kp it mv b gy mz na l nb nc">entry<strong class="mv iu">: </strong>{<br/>    main<strong class="mv iu">: </strong>'./index.js',<br/>},</span></pre><p id="8a00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们也可以有多个入口文件。可以是js/ts/scss/less等。如果我们有多个入口文件，也会有多个输出。为此，我们必须指定结果的去向:</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="1e6e" class="mh kp it mv b gy mz na l nb nc">output<strong class="mv iu">: </strong>{<br/>    path<strong class="mv iu">: </strong><em class="mt">path</em>.join(__dirname, 'public'),<br/>    filename<strong class="mv iu">: </strong>'[name].js',<br/>},</span></pre><p id="e1bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">目前，我们不使用任何模块，因此相应的部分是空的。我们甚至不需要使用任何插件。但是，在构建新文件之前删除public是有益的。这样，我们可以确定，我们在输出文件夹中看到的所有内容都是用最近的构建生成的，而不是从之前就被遗忘了。对于这个任务，我们使用<em class="mt"> clean-webpack-plugin </em>。插件就像一个独立的应用程序，Webpack称之为。它可以从git存储库中下载。通常，插件是由不同的团队开发的。每个插件都有自己的配置，所以必须查看文档以获取详细信息。经常有多个插件在做同一件事，所以对于一个特定的任务总是只选择一个。</p><p id="f0ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在配置文件的开头，我们有两行:</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="756d" class="mh kp it mv b gy mz na l nb nc">mode<strong class="mv iu">: </strong>'development',  // or 'production'<br/><br/>devtool<strong class="mv iu">: </strong>false, // or 'eval'</span></pre><p id="887b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">模式</strong>告诉webpack如何构建结果文件。它应该对人类可读吗？应该优化吗？它应该被浏览器开发工具使用吗？这两个选项是<em class="mt">生产</em>或<em class="mt">开发</em>。我们将看看有什么不同。浏览器的开发工具需要使用<strong class="js iu"> devtool </strong>选项才能正常工作。在大多数情况下，我们会关闭这个选项，因为它会增加输出文件的复杂性，而这并不是我们真正需要的。</p><p id="0a91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们运行简单的例子。js不做任何困难的事情。我们有一个长名称的变量、一个循环和一个console.log命令来显示结果。</p><p id="019b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们运行构建之后，我们在。/公共文件夹。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="232f" class="mh kp it mv b gy mz na l nb nc">/******/ (() <strong class="mv iu">=&gt; </strong>{ // webpackBootstrap<br/><strong class="mv iu">var </strong>__webpack_exports__ <strong class="mv iu">= </strong>{};<br/>/*!******************!*\<br/>  !*** ./index.js ***!<br/>  \******************/<br/><strong class="mv iu">let </strong>long_variable_name <strong class="mv iu">= </strong>1;<br/><br/><strong class="mv iu">for</strong>(<strong class="mv iu">let </strong>iiii <strong class="mv iu">= </strong>0; iiii <strong class="mv iu">&lt; </strong>10; iiii<strong class="mv iu">++</strong>) {<br/>  long_variable_name<strong class="mv iu">++<br/></strong>}<br/><br/><em class="mt">console</em>.log(long_variable_name)<br/><br/>/******/ })()<br/>;</span></pre><p id="f966" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，与我们的原始文件相比，没有太大的变化。Webpack创建一个自动运行的全局函数。在这个全局函数中:</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="a2a0" class="mh kp it mv b gy mz na l nb nc">/******/ (() <strong class="mv iu">=&gt; </strong>{ // webpackBootstrap<br/><strong class="mv iu">var </strong>__webpack_exports__ <strong class="mv iu">= </strong>{};<br/><strong class="mv iu"><em class="mt">.... our code ....</em></strong><br/>/******/ })<strong class="mv iu">()</strong></span></pre><p id="9280" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的代码没有改变。末尾的粗体括号告诉JS engine在加载后运行这个函数。</p><p id="261e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您在任何html文件中包含<em class="mt"> main.js </em>，它将在加载后执行。</p><p id="35dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">开发工具开启</strong></p><p id="e3ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们允许使用开发工具，构建会有什么变化？</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="b800" class="mh kp it mv b gy mz na l nb nc">/*<br/> * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").<br/> * This devtool is neither made for production nor for readable output files.<br/> * It uses "eval()" calls to create a separate source file in the browser devtools.<br/> * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)<br/> * or disable the default devtool with "devtool: false".<br/> * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).<br/> */<br/>/******/ (() <strong class="mv iu">=&gt; </strong>{ // webpackBootstrap<br/>/******/   <strong class="mv iu">var </strong>__webpack_modules__ <strong class="mv iu">= </strong>({<br/><br/>/***/ "./index.js"<strong class="mv iu">:<br/></strong>/*!******************!*\<br/>  !*** ./index.js ***!<br/>  \******************/<br/>/***/ (() <strong class="mv iu">=&gt; </strong>{<br/><br/><em class="mt">eval</em>("let long_variable_name = 1;\r\n\r\nfor(let iiii = 0; iiii &lt; 10; iiii++) {\r\n  long_variable_name++\r\n}\r\n\r\n<em class="mt">console</em>.log(long_variable_name)\r\n\n\n//# sourceURL=webpack://webpack-5-example/./index.js?");<br/><br/>/***/ })<br/><br/>/******/   });<br/>/************************************************************************/<br/>/******/   <br/>/******/   // startup<br/>/******/   // Load entry module and return exports<br/>/******/   // This entry module can't be inlined because the eval devtool is used.<br/>/******/   <strong class="mv iu">var </strong>__webpack_exports__ <strong class="mv iu">= </strong>{};<br/>/******/   __webpack_modules__["./index.js"]();<br/>/******/   <br/>/******/ })()<br/>;</span></pre><p id="5413" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，结果可能有点难以阅读。与前一个例子的主要区别在于使用了<em class="mt"> eval </em>函数。这个函数基本上接受一个被认为是有效javascript代码的字符串并执行它。这有助于浏览器的开发工具附加到代码上，并为开发人员提供额外的功能和工具。从现在开始我们将保持devtools <strong class="js iu">为假</strong>。</p><h2 id="bbb2" class="mh kp it bd kq mi mj dn ku mk ml dp ky kb mm mn lc kf mo mp lg kj mq mr lk ms bi translated">为生产而制造</h2><p id="d208" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">当我们伟大的小项目准备好了，我们想准备一个生产构建。这里的主要区别是，我们不希望代码中有任何不必要的东西。例如，注释、开发工具、调试特性等。Webpack也可以做mangling——这意味着将变量名减少到最少。在我们的<em class="mt"> index.js </em>中我们有一个名为“<em class="mt"> long_variable_name </em>的变量，但是对于js引擎来说，变量名是什么并不重要。因为JS主要用于客户端应用程序，所以我们希望通过网络传输尽可能少的数据。Webpack自动帮助我们。让我们来看看结果:</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="1ce0" class="mh kp it mv b gy mz na l nb nc">(()<strong class="mv iu">=&gt;</strong>{<strong class="mv iu">let </strong>l<strong class="mv iu">=</strong>1;<strong class="mv iu">for</strong>(<strong class="mv iu">let </strong>o<strong class="mv iu">=</strong>0;o<strong class="mv iu">&lt;</strong>10;o<strong class="mv iu">++</strong>)l<strong class="mv iu">++</strong>;<em class="mt">console</em>.log(l)})();</span></pre><p id="3bf6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与以前的结果相比，这个结果似乎小得惊人。如你所见，“<em class="mt"> long_variable_name </em>”被缩短为“<em class="mt"> l </em>”，“iiii”被缩短为“o”，所有的注释都被删除，不必要的空格被删除。</p><p id="00ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu">#第2部分</strong>见，我们将介绍进口产品！</p></div></div>    
</body>
</html>