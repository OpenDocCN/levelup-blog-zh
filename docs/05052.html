<html>
<head>
<title>Intro to Monkey Patching in Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby中的Monkey补丁简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-is-monkey-patching-a4fd58bb8d39?source=collection_archive---------16-----------------------#2020-07-31">https://levelup.gitconnected.com/what-is-monkey-patching-a4fd58bb8d39?source=collection_archive---------16-----------------------#2020-07-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/3730019f854dd1e2b67f4decca2a8ee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*cxnIKu9YOyRuiC3Gvntrag.jpeg"/></div></figure><p id="25b8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://en.wikipedia.org/wiki/Monkey_patch" rel="noopener ugc nofollow" target="_blank"> Monkey Patching </a>包括“在运行时对类或模块的动态修改，其动机是修补现有的第三方代码，作为对未按预期运行的bug或功能的变通办法”，因此，Monkey补丁不会改变软件本身，而只会改变运行时的本地副本。</p><p id="1cc4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在日常生活中，monkey patching会在运行时改变类方法(内置的或用户创建的)的行为。对于刚开始学习编程的人来说，这似乎需要消化很多东西，但事实并非如此(我保证)！</p><p id="c29a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Ruby中的每个类都有自己的内置方法列表。例如，一个字符串有一个完整的方法列表:包括#reverse，它将反转字符串的顺序，#count，它将计算字符串中有多少个字符，#empty？它会通过返回true或false来告诉你字符串是否为空，等等…</p><p id="2ea2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您明白了Ruby有许多内置方法。我们试着用猴子修补这些内置的字符串方法之一，来展示猴子修补实际上是多么简单和强大，怎么样？让我们先回顾一下我们所知道的:</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi kt"><img src="../Images/69c2768f63977e5052c5ac3ff4685cce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K05Bzkz0bpTOEGDakFEZvQ.png"/></div></div></figure><p id="8e53" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">很简单的东西，对吧？现在让我们调用#clear函数…</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi lc"><img src="../Images/f5b6037386b927399faeda4aa336c1dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rgN_KA_EOrUt1xjmyeAVTw.png"/></div></div></figure><p id="8c48" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如预期的那样，字符串被清除，<em class="ld">测试</em>现在包含一个空字符串。但是如果我们可以改变String#clear方法的工作方式会怎么样呢？让它打印一个重复的新字符串，而不是清除数组。</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi le"><img src="../Images/2b1ad88ccbb702d994ec6f3afb1f6def.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3K3FH7dDrWuplz2HzPICGw.png"/></div></div></figure><p id="cbd7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，我们如何让string类访问这个新的String#clear方法呢？你可能认为我们可能需要花大量的时间来整理你系统上的Ruby库，并改变这个方法，对吗？不对！</p><p id="b217" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们只需要创建一个新的String类并放入我们的方法。</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi lf"><img src="../Images/e061e013251c70ff580ad05ef76a2965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uEVxKWuPXPgTDXrw8E1_KA.png"/></div></div></figure><p id="7149" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个新的String#clear方法将覆盖我们系统上现有的内置于Ruby中的String#clear方法，只要它包含在我们当前正在进行的项目中。</p><p id="0cc5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这意味着这不是一个会影响我们任何其他项目的永久更改——只有当文件包含在Ruby项目中时，通过显式编写以下内容，它才可用:</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi lg"><img src="../Images/359b983184070b44893176082568351d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_NFTm1hiLkugasMeLUVJKA.png"/></div></div></figure><p id="24bc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们现在已经有了新的String#clear方法，让我们试一试。</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi lh"><img src="../Images/079298b74314d00c66d653e2660492de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t_nfpYzniPIx5PEAVl1Y5A.png"/></div></div></figure><p id="7f09" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">#clear方法不再执行其默认行为。很神奇，是吧？您不仅可以更改现有方法的行为，还可以创建自己的方法在类上执行。</p><p id="c4a2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如，Rails有一个array方法，它扩展了array类，将一个数组转换成一个句子(<a class="ae ks" href="https://apidock.com/rails/Array/to_sentence" rel="noopener ugc nofollow" target="_blank"> Array#to_sentence </a>)。如果您真的想使用这种方法，但不一定需要Rails提供的其余部分，该怎么办？</p><p id="ea30" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">只需从Rails文档中复制该方法的源代码，将其放入一个数组类中，就像我们对上面的String类所做的那样，瞧！</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi li"><img src="../Images/f2df98d88c41d13575a4a8f1f3f711a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*19rU6KzcbZFsCGywMR8ePw.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">数组#to_sentence的来源来自apidock.com</figcaption></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="a69a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">综上所述，monkey patching是我们很少使用或手动实现的东西(Rails monkey为我们将方法修补到默认的Ruby库中)。在一些语言中，也就是Python，非常不鼓励猴子打补丁。Ruby似乎比其他人更喜欢它，但是你应该知道它也有自己的缺陷。</p><p id="cbc2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">改变方法的默认行为会产生意想不到的难以解决的错误。改变一个内置的Ruby方法的行为(即使是很小的改变)都会产生灾难性的结果，尤其是在团队开发的时候。</p><p id="5296" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">想象一下，如果在一个基于1的系统中使用Array#count enumerate，而不是默认的基于0的系统，其他开发人员会遇到什么样的错误。一个可笑的例子，但你明白了。</p><p id="2e66" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在某些情况下，尽管它可能是最干净的选择，或者是对尚未被该框架的开发者更新的错误的临时修复，但它不应该是你对一个棘手问题的修复；这是一个你可以随意使用的工具，但是应该谨慎使用。</p><p id="748a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">引用<a class="ae ks" href="https://culttt.com/2015/06/17/what-is-monkey-patching-in-ruby/" rel="noopener ugc nofollow" target="_blank">菲利普·布朗</a>的博客帖子帮助我更好地理解了这个概念，“Ruby就像一把锋利的刀，它可以非常有效，但如果你割伤了自己，那通常是你自己的错。”</p></div></div>    
</body>
</html>