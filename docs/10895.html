<html>
<head>
<title>Haskell Journey: Creating Type</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Haskell之旅:创建类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/haskell-journey-creating-type-1bf808bf5400?source=collection_archive---------3-----------------------#2022-01-21">https://levelup.gitconnected.com/haskell-journey-creating-type-1bf808bf5400?source=collection_archive---------3-----------------------#2022-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8b0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">新年到了，关于我穿越Haskell之旅的最后一篇帖子也到了！🚀让我们学习如何在Haskell中创建自定义类型！</p><p id="41d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在学习我的第一门函数式语言时有一次惊人的经历，它非常具有挑战性，实际上我已经有一段时间没有把我的学习时间投入到新的事物中了！一种我从未真正使用过的语言和范式…😵</p><p id="2480" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然关于FP领域有更复杂的概念——比如单子和函子——但是我想结束这个系列的帖子，这样我就可以写其他主题了👽</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/294fa3ab7e86157b88de02d8e53455fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*piNtfMP7wcfjoBW9"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">邓肯·基德在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="5736" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在学习中一直使用的一些有用的链接:<br/> <strong class="jp ir"> (1) </strong>学习基于这些书的概念:<a class="ae lb" href="https://www.casadocodigo.com.br/products/livro-haskell" rel="noopener ugc nofollow" target="_blank"> <em class="lc"> Haskell </em>函数式编程简介</a> g和<a class="ae lb" href="http://learnyouahaskell.com/chapters" rel="noopener ugc nofollow" target="_blank">为了更好的效果，学习一个<em class="lc"> Haskell </em>！</a>📚<br/> <strong class="jp ir"> (2) </strong>对该<a class="ae lb" href="https://www.notion.so/Haskell-29aac2ea56274d67bde03a529e8e4f09" rel="noopener ugc nofollow" target="_blank">意见</a>文件做笔记📝<br/> <strong class="jp ir"> (3) </strong>在我的<a class="ae lb" href="https://github.com/jennifertakagi/haskell-projects-study" rel="noopener ugc nofollow" target="_blank"> GitHub库</a> 🗃上编写一些练习</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="f97b" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">创建类型</h1><p id="157c" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">我已经在以前的帖子中写过关于<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/haskell-journey-types-and-data-structures-322bd1392a89"> <em class="lc"> Haskell </em> <em class="lc">数据类型</em>…但是这种语言很酷的一点是我们可以创建一个新的<em class="lc">类型</em>！也许乍一看，这个特性没有意义，但是让我们跳到一个例子。</a></p><p id="67be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们想建立一个程序<strong class="jp ir">将温度从一个单位转换为摄氏度，</strong>使用<em class="lc"> Haskell </em>解决这个问题的一个好方法是<strong class="jp ir">将自定义<em class="lc">类型</em>与<em class="lc">模式匹配</em> </strong>结合起来。我们可以按如下方式解决这个问题:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/e98d39d3ee0e7d7445ac2ba3aa576941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*ObgH-h9j4Hh8i2JcWtestA.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">程序转换任何温度单位为摄氏度。</figcaption></figure><p id="b5ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理解魔法:<br/> <strong class="jp ir"> (1) </strong>在第一行我使用<em class="lc">关键字</em> <strong class="jp ir"> <em class="lc">【数据】</em> </strong>创建了新的<em class="lc">类型</em>；<br/> <strong class="jp ir"> (2) </strong>一种新的<em class="lc">型</em>叫做<strong class="jp ir"> <em class="lc">【求和型】</em></strong>；<br/> <strong class="jp ir"> (3) </strong>所创建的<em class="lc"/>类型的值称为<strong class="jp ir"> <em class="lc">【值构造函数】</em> </strong>，在本例中，它们是:“摄氏或华氏或开尔文”——<strong class="jp ir"><em class="lc">“|”</em></strong>可读作“或”；<br/> (4)然后我可以使用<em class="lc">模式匹配</em>并创建<em class="lc">函数</em>将一个单位转换为摄氏度。注意，我得到的<em class="lc">双</em>和<strong class="jp ir"> <em class="lc">【温度】</em> </strong>值- <strong class="jp ir"> <em class="lc">模式匹配</em>正被应用到<em class="lc">【温度】</em>值</strong>。</p><p id="398a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只是澄清一下，在下面的shell命令中，当我创建新的"<strong class="jp ir"> <em class="lc">温度"</em> </strong> <em class="lc">数据</em> <em class="lc">类型</em>时，我可以验证<strong class="jp ir">的<em class="lc">值构造函数</em> <em class="lc">类型</em>“摄氏度”是温度！🌡</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/7a87bf03b775e5ebefd1c5c61c227ed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*VsfZ2WsDEstcBovw_MFnYw.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">显示“值构造函数”类型的外壳</figcaption></figure><h1 id="aa8b" class="lk ll iq bd lm ln mp lp lq lr mq lt lu lv mr lx ly lz ms mb mc md mt mf mg mh bi translated">构造函数的字段</h1><p id="0fed" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">再深入一点<strong class="jp ir"> <em class="lc">【值构造函数】</em> </strong>，它们也可以有<em class="lc">字段</em>！为了在实践中理解这一点，让我们考虑需要创建一个程序<strong class="jp ir">来验证任何名称是否有效——验证非常简单，只需检查收到的<em class="lc">参数</em>不是空的<em class="lc">字符串</em> : </strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/75fd31f59a13c82553858189b8098323.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*-RW74A5CS_eAKZuZhWaH1Q.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">验证名称是否有效的程序。</figcaption></figure><p id="5e23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从每一行得到的想法:<br/> <strong class="jp ir"> (1) </strong>在第一行我创建了一个新的<em class="lc"/><strong class="jp ir"><em class="lc">【有效】</em></strong>；<br/> <strong class="jp ir"> (2) </strong>这个新的<em class="lc">类型</em>有两个<em class="lc">值构造函数</em>，但是第一个<strong class="jp ir">有一个<em class="lc">字符串</em> <em class="lc">字段</em> </strong>，它可以带一个<em class="lc">参数</em>！；<br/> <strong class="jp ir"> (3) </strong>检查<strong class="jp ir"><em class="lc">【isValidaName】</em></strong><em class="lc">函数:</em>第一个<em class="lc">模式</em>取一个名称(作为<em class="lc">字符串</em>)<em class="lc">返回</em><em class="lc">值</em> <strong class="jp ir">【收到的是名称】</strong>；<br/> <strong class="jp ir"> (4) </strong>第二种<em class="lc">模式:</em>如果函数没有收到有效的<em class="lc">字符串</em>值(一个数字，一个空字符串……)，则<em class="lc">返回</em>值“否”。🙈</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="b9d7" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">记录语法</h1><p id="0fd8" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">还有另一种方法来声明新的<em class="lc">类型</em>，使用<strong class="jp ir"> <em class="lc">记录语法</em></strong>——这种方法在有大量值的情况下，或者如果您只是想更清楚地了解新类型会带来什么，这种方法会更加复杂和有用。</p><p id="b3f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个<em class="lc">语法</em>允许我们从<em class="lc">值</em> <em class="lc">构造函数</em>中提取<em class="lc">字段</em>，就像一个<strong class="jp ir"> <em class="lc"> getter </em> </strong>。看起来有点混乱，但实际上很简单，<strong class="jp ir">我们只需要命名<em class="lc">构造函数</em>的<em class="lc">字段</em>。</strong></p><p id="4fb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了尽可能简化，我们的代码要解决的新问题是:<strong class="jp ir">创建一个程序，将一定数量的货币从一种货币转换为美元:🤑</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mv"><img src="../Images/11b8a034c89aaa3ae57568b0f8076bba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FPQDG7JOMf3g37j2iSUAxA.png"/></div></div></figure><p id="3690" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理清思路:<br/> <strong class="jp ir"> (1) </strong>在创建了<strong class="jp ir"><em class="lc"/></strong><em class="lc">类型</em>之后，我创建了<strong class="jp ir"> <em class="lc">【金钱】</em> </strong> <em class="lc">类型</em><em class="lc">记录语法，</em>它看起来像一个对象或者字典或者hash—<strong class="jp ir"><em class="lc">关键字</em>(值，货币</strong> <br/> <strong class="jp ir"> (2) </strong>使用<em class="lc">模式匹配</em>有一点不同:我们得到了<strong class="jp ir"> <em class="lc">货币</em> </strong> <em class="lc">类型</em>并且我们可以访问这个<em class="lc">类型</em>的每个<em class="lc">键</em>，我使用货币匹配并得到<em class="lc">值</em>作为<strong class="jp ir"> <em class="lc"><br/><strong class="jp ir">【③】</strong>最后，要使用这个程序我们调用函数为:</em></strong></p><pre class="km kn ko kp gt mw mx my mz aw na bi"><span id="a3d8" class="nb ll iq mx b gy nc nd l ne nf"><strong class="mx ir">convertDollar Money{value = 2, currency = Real}</strong></span></pre></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="7034" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">奖金:类型类</h1><p id="8a23" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">你可能已经注意到，在这篇文章的所有例子中，在创建一个新的<em class="lc">类型</em>的末尾有一个<strong class="jp ir"> <em class="lc">【衍生秀】</em> </strong>。</p><blockquote class="ng nh ni"><p id="3532" class="jn jo lc jp b jq jr js jt ju jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj kk ij bi translated">“Show”是一个“Typeclass”，我们可以把它看作一个接口——因为它最终为某些东西提供了一些通用的行为。</p><p id="0876" class="jn jo lc jp b jq jr js jt ju jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj kk ij bi translated"><strong class="jp ir">简而言之，如果一个类型是“类型类”的一部分，这意味着它支持并实现了“类型类”所描述的行为。</strong></p></blockquote><p id="0ce3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"><em class="lc">【type class】</em></strong>还有很多，比如<em class="lc"> Eq，Show，Read，Num，Fractional，Real，Integral，Enum，Ord </em>等等…</p><p id="3691" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是为了理解为什么所有创建的<em class="lc">类型</em>都是从<strong class="jp ir"><em class="lc"/></strong>中派生出来的，这个<strong class="jp ir"><em class="lc">【Typeclass】</em></strong>涵盖了到目前为止除函数之外的所有<em class="lc">类型——它取一个<em class="lc">值</em>，其<em class="lc">类型</em>是"<strong class="jp ir"><em class="lc">Show</em></strong><em class="lc"/>的成员，并将其表示为📖</em></p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><blockquote class="nm"><p id="f62e" class="nn no iq bd np nq nr ns nt nu nv kk dk translated">就是这样，伙计们！我真的希望这一系列的帖子已经帮助你迈出了使用Haskell的第一步！我在写作和学习这门神奇的语言中学到了很多。🥳</p><p id="388d" class="nn no iq bd np nq nr ns nt nu nv kk dk translated">我对可能作为下一篇帖子的建议出现的主题持开放态度…我相信我会继续写关于JavaScript和有助于我作为开发人员的职业生涯的主题。</p><p id="4583" class="nn no iq bd np nq nr ns nt nu nv kk dk translated">再见，保重🤓</p></blockquote></div></div>    
</body>
</html>