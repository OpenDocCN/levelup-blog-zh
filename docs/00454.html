<html>
<head>
<title>Why just cache when you can memoize (with expiration and consistency)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当您可以记忆时，为什么只缓存(有到期和一致性)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-just-cache-when-you-can-memoize-with-expiration-and-guaranteed-consistency-97dbb504deda?source=collection_archive---------1-----------------------#2019-03-09">https://levelup.gitconnected.com/why-just-cache-when-you-can-memoize-with-expiration-and-guaranteed-consistency-97dbb504deda?source=collection_archive---------1-----------------------#2019-03-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/692e3dae61ad0d1fb4345538bf6f5e08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*04bLT3Nk4Xttioq7GxKZAQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">谷歌图片，WP火箭</figcaption></figure><p id="1a60" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">记忆化是一种特殊类型的缓存，用作软件优化技术。</strong></p><p id="bf1d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">缓存是一种常用的软件优化技术，在所有形式的软件开发中都有使用，无论是web还是移动，甚至是桌面。缓存存储操作的结果以备后用。例如，如果您将来通过存储以下资源再次访问这个博客，您的web浏览器很可能会使用缓存来更快地加载它。js，。css和图像。</p><p id="cfc5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以，当我谈到记忆化时，我指的是在执行软件的机器的内存中记忆或缓存复杂操作的输出。记忆化在“备忘录”中找到了它的词根，意思是“被记住”</p><p id="668f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">缓存是一个强大的工具，但与内存化不同，它通常是运行在网络调用访问的其他服务器上的另一个进程。缓存系统总是很快，但是网络调用增加了总响应时间的瓶颈。在一个封闭的vpc设置中，添加多个通过同一网络同时进行呼叫的进程，缓存需要随着组件的变化而扩展。内存化在这方面有优势，因为数据被缓存在机器的内存中，从而避免了网络延迟。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi la"><img src="../Images/2e1b09f11e907cf821486e60fb851426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*404VB9nQdXHAC7LwlhKalA.png"/></div></figure><p id="8682" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">更喜欢使用缓存的最强大的方面是:</p><p id="6bfa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">1.<strong class="ke ir"> ttl </strong>(生存时间)—缓存数据在预先指定的时间间隔后自动过期</p><p id="650a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2.当从不同的进程读取数据时，数据总是相同的——在当今云优先的架构中，多个应用服务器或后台进程是一种常态。</p><p id="84ff" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这使得缓存是新鲜的(由于ttl而经常失效和刷新),并且是一致的(因为它是真实的单一来源)。然而，记忆化就不一样了，你很少会发现记忆化、多进程一致性和过期一起使用。</p><p id="73be" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，在这篇博客中，你将看到如何以及何时一起运用这些简单而强大的技术，来优化你自己的程序，使它们在某些情况下运行得更快。</p><blockquote class="lf lg lh"><p id="cb72" class="kc kd li ke b kf kg kh ki kj kk kl km lj ko kp kq lk ks kt ku ll kw kx ky kz ij bi translated">介绍<a class="ae lm" href="https://github.com/ritikesh/memoize_until" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> memoize_until </strong> </a>。一种强大而简单的内存化技术，关注多进程环境中所有缓存系统的动态特性和一致性，并将其引入内存化领域。</p></blockquote><p id="4d2e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe ln lo lp lq b">MemoizeUntil</code>记忆(记住)值，直到预定的时间度量开始——这可以是分钟、小时、天甚至一周。到期时，存储会自动清除以前的数据，以避免内存膨胀，并通过请求源来刷新数据。由于流程会在预定义的时间指标开始时自动提取数据，因此可以保证流程之间的一致性。</p><p id="7ca6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，简单地说，通过npm安装软件包:</p><pre class="lb lc ld le gt lr lq ls lt aw lu bi"><span id="8c96" class="lv lw iq lq b gy lx ly l lz ma">npm install memoize_until</span></pre><p id="eb70" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后需要这个模块，用你的用例初始化它，并在需要的地方使用它。</p><pre class="lb lc ld le gt lr lq ls lt aw lu bi"><span id="b2bd" class="lv lw iq lq b gy lx ly l lz ma">const MemoizeUntil = require('memoize_until').MemoizeUntil</span><span id="ea9d" class="lv lw iq lq b gy mb ly l lz ma">MemoizeUntil.init({ <br/>    day: ['custom1', 'custom2']<br/>})</span><span id="ff11" class="lv lw iq lq b gy mb ly l lz ma">MemoizeUntil.fetch('min', 'default', () =&gt; { <br/>    return 'SomeComplexOperation'; <br/>})</span></pre><p id="8e19" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">举个简单的例子，假设您的生产就绪型应用程序有一个面向公众的API，您想要实现一个FUP(公平使用策略)并因此设置适当的速率限制。但是你几乎可以预见到你的一些客户会时不时地抱怨并希望提高API限制。这要求您的API限制是动态的。</p><p id="a9b0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">传统上，开发人员会将其作为配置保存在配置数据库中，并在每次请求时加载一次。但随着时间的推移，这种配置已经转移到保留在Redis等缓存存储中，这些存储传统上非常快，但网络延迟仍然存在。为了避免对每个web请求进行缓存调用，您可能希望在本地记住API限制，并对每个请求都使用它，而且还要经常检查缓存存储是否已经更新。这似乎是使用<code class="fe ln lo lp lq b">memoize_until</code>的完美用例。缓存的数据需要刷新，但不是立即刷新。示例用法可在以下要点中找到:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="6c79" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae lm" href="https://github.com/ritikesh/memoize_until#memoizeuntil" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">自述文件</strong> </a>涵盖了额外的文档，比如如何扩展<code class="fe ln lo lp lq b">memoize_until</code>以实现真正的动态行为——动态键和值——等等。</p><p id="f9a8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注意:</strong> <code class="fe ln lo lp lq b">memoize_until</code>不是缓存存储的替代品，它只是一种优化技术，通过保证一致性的记忆化来减少对缓存存储或数据库的网络调用。因为一切都存储在内存中，所以还需要考虑远程服务器上的内存限制——尽管由于有了云，这不再像过去那样是个大问题。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><figure class="lb lc ld le gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi ml"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure><div class="mm mn gp gr mo mp"><a href="https://gitconnected.com/learn" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd ir gy z fp mu fr fs mv fu fw ip bi translated">了解如何编码-查找编码教程| gitconnected</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">使用我们完整的编码资源列表学习任何编程语言或框架。我们分享、汇总和排名…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">gitconnected.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd jw mp"/></div></div></a></div></div></div>    
</body>
</html>