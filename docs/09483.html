<html>
<head>
<title>“Static is Bad”, “Async Code is Fast” and Other Programming Misconceptions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“静态不好”、“异步代码快”等编程误区</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/only-interfaces-can-be-mocked-asynchronous-code-is-fast-and-other-programming-misconceptions-2e19b0e94a8?source=collection_archive---------2-----------------------#2021-08-15">https://levelup.gitconnected.com/only-interfaces-can-be-mocked-asynchronous-code-is-fast-and-other-programming-misconceptions-2e19b0e94a8?source=collection_archive---------2-----------------------#2021-08-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1c87" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你需要尽快打破它。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2dce4002c2599542e13a83c5266cd817.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VMRf4Nb_27DkrX50"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">乌代·米塔尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="89e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">软件开发是一个复杂的过程，有如此多的细微差别，以至于几乎每个开发人员在面向对象设计、单元测试、异步编程或其他领域都曾经或目前有一个或多个误解。</p><p id="c094" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然一些误解可能是无辜的，但其他误解甚至可能会妨碍开发人员正确地完成工作，所以最好现在就消除它们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="53a0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">只有接口才有可能模仿</h1><p id="d668" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">类之间的紧密耦合会导致可测试性问题。让我们看一个演示紧耦合问题的例子:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7f2d" class="ne md it na b gy nf ng l nh ni">public class Storage<br/>{<br/>    public string GetData() =&gt; "Data from the storage.";<br/>}</span><span id="5f2c" class="ne md it na b gy nj ng l nh ni">public class Parser<br/>{<br/>    public string Parse()<br/>    {<br/>        var storage = new Storage();<br/>        var data = storage.GetData();<br/>        <strong class="na iu">//Parse the data</strong><br/>        return data;<br/>    }<br/>}</span></pre><p id="cb3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm na b">Parser</code>类与<code class="fe nk nl nm na b">Storage</code>类紧密耦合，这使得很难在与外界隔离的情况下测试解析逻辑。</p><p id="1e01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">避免紧密耦合的常见解决方案是提取依赖关系的接口，并将其注入构造函数。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0100" class="ne md it na b gy nf ng l nh ni">public class Parser<br/>{<br/>    private readonly IStorage _storage;</span><span id="fcac" class="ne md it na b gy nj ng l nh ni">    public Parser(<strong class="na iu">IStorage </strong>storage) =&gt; _storage = storage;<br/>}</span></pre><p id="9073" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在可以使用<a class="ae ky" href="https://github.com/Moq/moq4/wiki/Quickstart" rel="noopener ugc nofollow" target="_blank"> Moq </a>库轻松模仿<code class="fe nk nl nm na b">GetData</code>方法，如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="144b" class="ne md it na b gy nf ng l nh ni">[Fact]<br/>public void Test()<br/>{<br/>   var mock = new Mock&lt;<strong class="na iu">IStorage</strong>&gt;();<br/>   mock.Setup(m =&gt; m.GetData()).Returns("Data for unit test.");<br/>   <br/>}</span></pre><p id="7b66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Moq框架生成一个实现<code class="fe nk nl nm na b">IStorage</code>接口的代理(模拟)对象。</p><p id="22a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个常见的误解是只能为接口创建模仿。如果某些类是<strong class="lb iu">公共的</strong>并且它们被模仿的方法是<strong class="lb iu">虚拟的</strong>，那么模仿它们也是可能的。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8afa" class="ne md it na b gy nf ng l nh ni">public class Storage<br/>{<br/>    public <strong class="na iu">virtual </strong>string GetData() =&gt; "Data from the storage.";<br/>}</span><span id="25a4" class="ne md it na b gy nj ng l nh ni">[Fact]<br/>public void Test()<br/>{<br/>   var mock = new Mock&lt;<strong class="na iu">Storage</strong>&gt;();<br/>   mock.Setup(m =&gt; m.GetData()).Returns("Data for unit test.");<br/>   <br/>}</span></pre><p id="a725" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Moq框架将生成从<code class="fe nk nl nm na b">Storage</code>继承的代理对象，并覆盖<code class="fe nk nl nm na b">GetData</code>方法。</p><p id="ba95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nn">“这是否意味着我不应该再使用接口了？”</em></p><p id="a3a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然不是。接口支持应用程序中的松散耦合，这使得它在运行时非常灵活。然而，为已经有虚方法的类提取接口是一个多余的步骤。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5e4e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将接口注入构造函数意味着依赖倒置</h1><p id="4a88" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">根据我的主观观察，依赖倒置原则最常被开发人员误解。</p><p id="d8ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种常见的面向对象编程技术是将接口注入到类构造函数中，这通常被视为遵循了依赖倒置原则。</p><p id="2dd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，将接口注入构造函数并不一定意味着依赖倒置。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="522d" class="ne md it na b gy nf ng l nh ni">public class CreateUserCommandHandler<br/>{<br/>    private readonly ITcpClient _tcpClient;</span><span id="c3a9" class="ne md it na b gy nj ng l nh ni">    public CreateUserCommandHandler(ITcpClient tcpClient)<br/>        =&gt; _tcpClient = tcpClient;<br/>}</span></pre><p id="093b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，依赖是通过接口注入到构造函数中的，但是仍然违反了依赖反转原则。</p><p id="1f52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">高层策略<code class="fe nk nl nm na b">CreateUserCommandHandler</code>依赖于低层细节<code class="fe nk nl nm na b">ITcpClient</code>，这些细节表示中间缺少抽象。</p><p id="69d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依赖倒置的思想不是关于使用接口。你可以查看我的另一篇文章了解详情:</p><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/you-are-simply-injecting-a-dependency-thinking-that-you-are-following-the-dependency-inversion-32632954c208"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">你只是简单地注入一个依赖，认为你在遵循依赖倒置…</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">澄清差异。</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ks nr"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="07d7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">异步代码比同步代码快</h1><p id="3b6e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">开发人员可以同步或异步运行方法。下面是同步执行的简单示例:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="526a" class="ne md it na b gy nf ng l nh ni">public class OrderRepository<br/>{<br/>    private readonly DbContext _context;</span><span id="15e5" class="ne md it na b gy nj ng l nh ni">    public OrderRepository(DbContext context) =&gt; <br/>        _context = context;<br/>    <br/>    public void Insert(Order order)<br/>    {<br/>        _context.Orders.Add(order);<br/>        _context.SaveChanges(); <strong class="na iu">// &lt;- Synchronous call</strong><br/>    }<br/>}</span></pre><p id="12d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码以同步方式编写:方法签名中没有<code class="fe nk nl nm na b">async</code>关键字，方法<code class="fe nk nl nm na b">SaveChanges</code>是同步的。执行<code class="fe nk nl nm na b">Insert</code>操作的线程将在<code class="fe nk nl nm na b">SaveChanges</code>方法期间被阻塞。</p><p id="e84a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码可以很容易地用异步方式重写，因为<code class="fe nk nl nm na b">SaveChanges</code>有一个名为<code class="fe nk nl nm na b">SaveChangesAsync.</code>的异步实现</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8d55" class="ne md it na b gy nf ng l nh ni">public async Task Insert(Order order)<br/>{<br/>    _context.Orders.Add(order);<br/>    _context.<strong class="na iu">SaveChangesAsync</strong>(); <br/>}</span></pre><p id="a01f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异步编程允许我们在线程发起类似数据库调用的操作后解除对线程的阻塞，这样它就可以服务于其他请求。</p><p id="b60f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异步调用可以减少<code class="fe nk nl nm na b">Insert</code>方法的执行时间吗？不会。如果同步<code class="fe nk nl nm na b">Insert</code>方法需要1秒钟将订单插入数据库，那么异步<code class="fe nk nl nm na b">Insert</code>方法需要同样长的时间。</p><p id="5aa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们通过编写异步代码实现了什么呢？我们实现了可扩展性。当数据库保存更改时，未阻塞的线程可以为应用程序的其他请求提供服务。使用异步编程模型，应用程序可以处理更多的请求。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f233" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">延迟加载总能解决性能问题</h1><p id="41fb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">实体框架核心中的延迟加载允许您推迟加载对象的某些部分，直到客户端代码请求它们。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e2ce" class="ne md it na b gy nf ng l nh ni">public class User <br/>{     <br/>    public int Id { get; set; }     <br/>    public string Name { get; set; }      <br/>    public virtual ICollection&lt;UserDetail&gt; UserDetails { get; set; } <br/>}</span></pre><p id="4142" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关键字<code class="fe nk nl nm na b">virtual</code>具有与延迟加载相关的魔力。从数据库中检索博客记录不会导致读取相关的<code class="fe nk nl nm na b">UserDetails</code>记录，直到调用代码明确请求它们。事实上，延迟加载可以提高应用程序的性能，但另一方面，它会导致很大的性能问题。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3c4b" class="ne md it na b gy nf ng l nh ni">var context = new DbContext();</span><span id="2616" class="ne md it na b gy nj ng l nh ni">var users = context<br/>       .Users<br/>       .Where(u =&gt; u.IsActive)<br/>       .ToList(); //Database call here</span><span id="5ed6" class="ne md it na b gy nj ng l nh ni">foreach (var user in users)<br/>{<br/>    var details = user.UserDetails; //Database call here<br/>    //logic<br/>}</span></pre><p id="a4ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的例子演示了N+1问题，它导致每次迭代都要往返一次数据库。将有一个获取活动用户的数据库调用和一个获取列表中每个用户的详细信息的数据库调用。这极大地影响了应用程序的性能。</p><p id="88df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免性能问题，应该在一次数据库调用中加载数据。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4c8a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">静态类是不好的</h1><p id="2c0f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">静态类的主要“问题”是与消费者的紧密耦合和可测试性问题。</p><p id="9c8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，静态类就像任何其他编程工具一样，既不好也不坏。它们可以简单地被正确或错误地使用。</p><p id="03aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么时候静态类是好的？</p><ul class=""><li id="4aed" class="og oh it lb b lc ld lf lg li oi lm oj lq ok lu ol om on oo bi translated">静态类是无状态的。</li><li id="22d4" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated">静态类总是产生确定性的结果(静态类包含纯函数)。</li><li id="d9a1" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated">没有必要脱离静态依赖来测试类。</li></ul><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/static-classes-and-methods-are-they-terrible-c9c611a921b3"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">静态类和方法——它们很糟糕吗？</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">从设计角度探索C#静态类和方法。</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oa l"><div class="ou l oc od oe oa of ks nr"/></div></div></a></div><p id="6010" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当静态类不好的时候。</p><ul class=""><li id="a634" class="og oh it lb b lc ld lf lg li oi lm oj lq ok lu ol om on oo bi translated">静态类声明应用程序可以改变，因此它会意外地影响应用程序的其他部分。</li><li id="90ab" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated">静态类用于设计处理外部环境(如数据库、文件系统等)的依赖关系。在这种情况下，对使用这种静态类的应用程序的逻辑进行单元测试就会出现问题。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="95d1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="a87a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">开发人员头脑中错误概念的寿命应该尽可能的短。通过阅读基础书籍、好文章和所有其他可用的权威知识来源来分解它们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="3371" class="ne md it bd me ov ow dn mi ox oy dp mm li oz pa mo lm pb pc mq lq pd pe ms pf bi translated">我的其他文章</h2><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-create-an-object-in-c-and-when-to-choose-which-one-4aabea5c3e40"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">用C#创建对象的5种方法以及何时选择哪一种</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">当创建一个对象时，像建筑师一样思考。</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oa l"><div class="pg l oc od oe oa of ks nr"/></div></div></a></div><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/50-software-engineering-best-practices-for-technical-leaders-and-seniors-cfcdf6a17e44"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">面向技术领导者和资深人士的50个软件工程最佳实践</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">最佳工程师的最佳实践。</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oa l"><div class="ph l oc od oe oa of ks nr"/></div></div></a></div><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/treat-if-else-as-a-code-smell-until-proven-otherwise-3bd2c4c577bf"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">将If-Else视为代码气味，直到被证明并非如此</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">C#中If-Else重构技术</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oa l"><div class="pi l oc od oe oa of ks nr"/></div></div></a></div></div></div>    
</body>
</html>