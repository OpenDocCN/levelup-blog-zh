<html>
<head>
<title>Increasing Test Reliability in Python through Object Mocking</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过对象模拟增加Python中测试的可靠性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/increasing-test-reliability-in-python-through-object-mocking-325c00f15139?source=collection_archive---------19-----------------------#2021-05-04">https://levelup.gitconnected.com/increasing-test-reliability-in-python-through-object-mocking-325c00f15139?source=collection_archive---------19-----------------------#2021-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/301968ad4a4ed5387c8a7f1d4f9944df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O2DzA90qPZj2Gmzb"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@altumcode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> AltumCode </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9339" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">在软件开发生命周期中，测试已经成为确保我们创建的软件满足用户需求和期望的最重要的活动之一。在软件发布供公众使用之前，测试在识别潜在问题方面起着至关重要的作用。因此，软件的测试套件足够可靠和有效是很重要的。</p><p id="b3ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然也存在手动测试方法，但是一些测试是使用库自动进行的，这显著减少了每次测试所需的时间并增加了所述测试的可靠性。然而，自动化测试库通常由一组严格的指令组成，这带来了一些问题，例如:</p><ol class=""><li id="be26" class="lk ll iq kf b kg kh kk kl ko lm ks ln kw lo la lp lq lr ls bi translated">依赖于随机化或外部因素的程序可能会使任何此类试验在不断变化的条件下不可重复。</li><li id="5905" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">依赖于其他程序的程序可能会因为其他程序的改变而破坏测试套件。</li></ol><p id="82a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些场景似乎否定了创建自动化测试套件的好处。由于测试套件很容易产生不可重复的结果，甚至完全崩溃，它不能被充分依赖，尤其是对于大型项目。然而，我们确实需要记住，最佳实践编程原则之一是<strong class="kf ir">依赖倒置</strong>(程序不应该/应该减少对具体实现的依赖)。</p><p id="fd26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决依赖问题，程序必须以这样一种方式来规划，即它依赖于一个抽象，而不是一个具体的实现。在Java和Kotlin等语言中，这很容易通过使用接口来实现，这些接口的实现可以在测试期间交换。然而，Python并不了解接口。因此，Python的内置测试库提供了一套方法来<strong class="kf ir">在测试</strong>中创建和使用 <strong class="kf ir">模拟对象。</strong></p><h1 id="32db" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">创建模拟对象</h1><p id="31ef" class="pw-post-body-paragraph kd ke iq kf b kg mw ki kj kk mx km kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">模拟对象有助于减少被测程序对其他类/对象的依赖性。模拟对象可以站在所有对象的位置上(因为Python无论如何都不执行静态类型检查),并且可以模拟任何对象的行为。可以随意添加属性，也可以用特定的返回值配置对象方法，所有这些都不需要定义或使用实际的对象本身。这些专长可以通过Python中<code class="fe nb nc nd ne b">unittest.mock</code>模块下的<strong class="kf ir"> Mock </strong>类来实现。</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="77f0" class="nn lz iq ne b gy no np l nq nr">from unittest.mock import Mock</span><span id="08db" class="nn lz iq ne b gy ns np l nq nr">mock_object = Mock()</span></pre><p id="145d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重要的是要注意，模拟对象不需要模拟特定对象的所有方面，以便能够在该对象的位置上使用。我们只能模拟测试程序所需的方面。</p><p id="a59f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们以Django中的一个HttpRequest对象为例。下面的方法是一个视图函数，用于创建用户和他/她正在处理的项目之间的关系:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="8fa5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，所需的输入只是用户的ID和帐户类型(包含在<code class="fe nb nc nd ne b">request</code>有效负载中)以及项目的ID(通过<code class="fe nb nc nd ne b">registration_data</code>参数包含在请求体中)。因为用户的ID和帐户类型是从传递给这个函数的HttpRequest对象中获得的，所以这个函数的任何测试要么必须提供这个对象，要么必须找到模拟它的方法。</p><p id="0419" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">仅供参考，HttpRequest对象是一个复杂的对象，它包括客户机用户代理、IP地址等属性。我们在测试这个功能的时候不需要这样的属性。我们只需要对象有适当的用户ID字段，它嵌入在<code class="fe nb nc nd ne b">request.auth</code>字段中。因此，我们可以在请求对象的位置上使用模拟对象，只让特定的字段可用。结果如下所示:</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="7a3c" class="nn lz iq ne b gy no np l nq nr">request_mock = mock.Mock()<br/>request_mock.auth = mock.Mock()<br/>request_mock.auth.id = self.annotator_user.id<br/>request_mock.auth.account_type = User.ANNOTATOR</span></pre><p id="2d9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的模拟对象中，我们正在创建一个名为<code class="fe nb nc nd ne b">request_mock</code>的模拟请求对象。在对象内部，我们使用另一个模拟对象注入<code class="fe nb nc nd ne b">auth</code>字段，该对象稍后也由测试用户的ID和帐户类型注入。因为这是函数需要的唯一信息，所以我们不需要模仿任何其他字段，只需将对象作为函数的参数传递。我们现在可以执行测试，就像传递了一个实际的请求对象一样。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="5429" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种技术可以应用于任何对象，只要你确切地知道程序的哪一部分将被使用。在Java和Kotlin中，这些可以很容易地通过接口指定。然而，在Python中，开发人员提前计划对象用法的意识很重要。</p></div></div>    
</body>
</html>