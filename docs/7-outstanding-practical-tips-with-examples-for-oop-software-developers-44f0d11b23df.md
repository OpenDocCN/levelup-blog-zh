# 7 面向对象编程和设计实用技巧(附例子)

> 原文：<https://levelup.gitconnected.com/7-outstanding-practical-tips-with-examples-for-oop-software-developers-44f0d11b23df>

## 改进软件应用程序设计的实践。

![](img/118113f467b3780abe2ac8a2bde6a0ae.png)

克拉克·蒂布斯在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

面向对象编程与设计不是一个可以很快学会的东西。这就是艺术，这个题目要求软件开发人员阅读基础书籍，定期练习，解决现实世界的问题，向更有经验的队友学习，做其他事情。

这篇 5 分钟的文章不会让你成为 OOP 和 OOP 专家。然而，这篇文章收集了最常见的无效设计选择的例子和它们的更好的替代方案，你可以用它们来填补知识空白，并可能成为比现在稍微好一点的面向对象编程和设计的软件开发人员。

# 1.使用返回值进行输入验证，而不是抛出异常

异常可用于通知调用代码该方法的输入参数无效。这种方法有几个缺点:

*   异常损害了代码的可读性，因为要回答问题*“方法抛出什么类型的异常或者它到底抛出什么类型的异常？”*开发者需要分析方法的整体。
*   不正确地使用异常作为工具。异常应该只在异常情况下抛出，也就是说，在应用程序的正常流程中不应该出现的情况:没有数据库连接、空引用…
*   抛出异常通常会影响应用程序的性能，因此应该尽可能少地只在异常情况下抛出异常。
*   基于异常的代码更难分析和调试。每当你看到`throw`时，找到合适的`catch`语句可能需要时间。您可能需要分析整个调用堆栈，直到应用程序的入口点。因此，异常通常等同于`goto`陈述。

## 严重的

## 好的

来自上传错误文件的用户的无效输入绝对不是例外情况，因此返回`Result`对象是与调用代码交流验证结果的更好方式。

此外，与基于异常的实现相反，使用`Result`对象允许代码积累错误消息。

# 2.将贫乏的领域模型重构为丰富的领域模型

贫血的域模型看起来像一个只有 getters 和 setters 的类，不包含任何逻辑。

与贫血的领域模型相关的业务逻辑被放在单独的类中，这些类的名称末尾通常有“Service”或“Manager”。这种方法会导致应用程序的不同服务之间的业务逻辑重复。

贫血领域建模的另一个大问题是违反封装。贫血模型必须有公共设置器，因为可以改变模型状态的逻辑在一个单独的类中。

当一个类有公共设置器时，迟早有人会因为不小心赋错值而违反它的不变量。

贫血的领域模型可以重构为丰富的领域模型。

## 严重的

## 好的

# 3.使用自动计算的属性

自动计算的只读属性是一种强大、简单且优雅的方式，可以简化外部客户端的类契约。

## 严重的

## 好的

计算雇员收入的业务规则封装在`Employee`类中，因此它提高了代码的重用性，因为外部客户不再需要自己实现计算收入的逻辑。

# 4.对外部客户端隐藏实现细节

开发人员应该以这样一种方式设计该类，即对于外部客户端来说，该类易于正确使用，而难以错误使用。这个原则是通过对外界隐藏实现细节来实现的，并且只提供客户端需要的最少功能。

## 严重的

一个反问:方法`NormalizeComment`被创建`Comment`实例的每个客户端 100%调用的可能性有多大？

## 好的

方法`NormalizeComment`是一个外部客户端甚至不需要知道的实现细节，所以该方法现在是私有的，每当一个值被赋给一个`text`属性时就会被隐式调用。

# 5.在值对象中包装表示领域概念的基本类型

原始数据类型，如字符串、整数等。可以在对域实体建模时使用。

然而，使用原语可能需要开发人员定期验证它们，以确保它们包含正确的值。

解决[原语困扰](https://blog.ploeh.dk/2011/05/25/DesignSmellPrimitiveObsession/)问题的方法是用值对象替换原语。

## 严重的

## 好的

与`double`数据类型不同的是，`Discount`数据类型将始终包含预期的值范围，这是由于验证逻辑的缘故，因此在成功创建`Discount`对象后，您不再需要对其进行验证。

# 6.使用 DI 容器创建单例，而不是传统的单例实现

经典的单例实现有几个缺点，下面是主要的几个:

*   实现 singleton 的类违反了单一责任原则，因为除了它的主要功能责任之外，它还负责创建自己。
*   不可能以多态的方式用另一个对象类型替换单例对象。
*   使用单例，很容易在代码中获得隐式依赖。

## 严重的

然而，开发人员可以从对象中移除所有与单例相关的逻辑，并使用依赖注入容器来实现相同的结果。

## 好的

您可以查看我的这篇文章，了解对单例优缺点的更详细的分析，以及实现它的各种方法:

[](/5-ways-to-implement-the-singleton-design-anti-pattern-in-c-68bb664c31f2) [## 在 C#中实现单例设计反模式的 5 种方法

### 各有利弊

levelup.gitconnected.com](/5-ways-to-implement-the-singleton-design-anti-pattern-in-c-68bb664c31f2) 

# 7.仅在 Void 方法中改变状态

遵循以下简单的规则可以极大地提高代码的可维护性、可读性和可重用性:

*   Void 方法会改变应用程序的状态。
*   非 void 方法应该只返回值而不改变应用程序的状态。

## 严重的

## 好的

坏例子中的方法违反了单一责任原则，因为它检查和更新用户的状态，但是将方法一分为二解决了这个问题。

每个更小的方法负责一项任务。从实用的角度来看，这种分离允许我们独立地重用它们。

# 结论

读完这篇文章后，你可能会立刻觉得有必要重构你的项目。但是等一下。想一想在你的特殊情况下选择一个解决方案而不是另一个解决方案会给你带来什么好处。写下当前和新解决方案的所有利弊。然后做一个重构，当然，如果你还觉得值得的话。

## 我的其他文章

[](/how-to-fix-bugs-and-not-introduce-new-ones-9f35e625673a) [## 如何在不破坏应用程序的情况下修复 Bug

### 更改源代码时更自信的步骤。

levelup.gitconnected.com](/how-to-fix-bugs-and-not-introduce-new-ones-9f35e625673a) [](/how-to-professionally-to-do-a-code-review-of-a-bug-fix-f17de72d42e0) [## 如何专业地对 Bug 修复进行代码审查

### 审查 bug 修复时要问的几个重要问题。

levelup.gitconnected.com](/how-to-professionally-to-do-a-code-review-of-a-bug-fix-f17de72d42e0) [](/5-ways-to-improve-the-performance-of-c-code-for-free-c89188eba5da) [## 5 种免费提高 C#代码性能的方法

### 慢速代码是可选的。

levelup.gitconnected.com](/5-ways-to-improve-the-performance-of-c-code-for-free-c89188eba5da)