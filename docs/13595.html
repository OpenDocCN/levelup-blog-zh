<html>
<head>
<title>Encrypting Data with Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Golang加密数据</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/encrypting-data-with-golang-f54f0f02123d?source=collection_archive---------0-----------------------#2022-09-19">https://levelup.gitconnected.com/encrypting-data-with-golang-f54f0f02123d?source=collection_archive---------0-----------------------#2022-09-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="de71" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">3d fosi/gocrypt——Golang加密辅助模块</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3fe7b441aab0202e993cc5da7496ac20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DztGaHnavBUE-DSF2NE5ZQ.png"/></div></div></figure><p id="a163" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最近，我在审查为移动应用程序存储的工作数据实施的加密，也偶然看到了这篇关于在微软团队桌面应用程序中发现的漏洞的<a class="ae lq" href="https://www.bleepingcomputer.com/news/security/microsoft-teams-stores-auth-tokens-as-cleartext-in-windows-linux-macs/" rel="noopener ugc nofollow" target="_blank">文章</a>，其中访问令牌以明文形式存储在用户的计算机上。这促使我回顾我以前编写的一些敏感数据存储应用程序，我想用可能更现代、更安全的方式来更新这些应用程序上的数据加密方式。在这样做的时候，我也意识到我经常以不同的方式实现对称加密，这是非常低效的。为什么我每次都要重新发明轮子？也许我只是想借此机会让自己精通不同的数据加密方式，但真正让我感动的是，我发现有时我甚至实现了相同的数据加密方式，但从头开始使用略有不同的代码，这真的很愚蠢。</p><p id="875f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在做了一些阅读和刷新我的记忆后，首先，不是<a class="ae lq" href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard" rel="noopener ugc nofollow" target="_blank"> AES </a> -128，即使它可能对大多数标准情况仍然足够好，以我们的硬件状态，我觉得<a class="ae lq" href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard" rel="noopener ugc nofollow" target="_blank"> AES </a> -256不会对性能造成太大的影响，因此我可能会选择走这条路。我还想选择<a class="ae lq" href="https://en.wikipedia.org/wiki/Galois/Counter_Mode" rel="noopener ugc nofollow" target="_blank">伽罗瓦/计数器模式(GCM) </a>，因为与流行的同类产品相比，它似乎仍然在安全性、隐私和性能之间取得了最大的平衡。</p><p id="fed0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，如果我能生成一个相当难破解的散列作为256位加密密钥来提高它的抗暴力攻击能力，那将是最好的。虽然<a class="ae lq" href="https://en.wikipedia.org/wiki/Argon2" rel="noopener ugc nofollow" target="_blank"> Argon2 </a>、<a class="ae lq" href="https://en.wikipedia.org/wiki/Bcrypt" rel="noopener ugc nofollow" target="_blank"> Bcrypt </a>和<a class="ae lq" href="https://en.wikipedia.org/wiki/Scrypt" rel="noopener ugc nofollow" target="_blank"> Scrypt </a>都是这方面的现代候选产品，但我最终选择了Scrypt (128位salt，32768 cpu/mem成本，8 r，1 p，32密钥长度)，顺便提一下，它最初是为其创建者为在线备份服务派生密钥而设计的，后来，它的简化版本被许多人用作工作证明方案</p><p id="d3ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我开始在一个包含6个主要函数的main.go文件中写下上述内容作为测试，因为我总是在确认研究得出的理论是可行的之前做这样的测试。当我满意地结束我的黑客会议时，我对自己说，嘿，为什么我不把它变成一个容易访问和记录的Go模块，这样我就可以重用它来解决我的“重新发明轮子”的问题？为什么我不把它也开源，这样其他人就可以查看它并提供反馈，或者告诉我任何潜在的疏忽？于是出现了一个超级简单的围棋模块，<a class="ae lq" href="https://github.com/3dfosi/gocrypt" rel="noopener ugc nofollow" target="_blank">github.com/3dfosi/gocrypt</a>:</p><div class="lr ls gp gr lt lu"><a href="https://github.com/3dfosi/gocrypt" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd iu gy z fp lz fr fs ma fu fw is bi translated">GitHub - 3dfosi/gocrypt:一个为使用scrypt提供简化的帮助函数的包…</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">一个为使用scrypt (128位salt，N=32768，r=8，p=1)生成的提供简化帮助函数的包…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">github.com</p></div></div><div class="md l"><div class="me l mf mg mh md mi ks lu"/></div></div></a></div><p id="d2ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">及其随附的<a class="ae lq" href="https://pkg.go.dev/github.com/3dfosi/gocrypt@v0.0.0-20220919050132-73b9f718fcb9" rel="noopener ugc nofollow" target="_blank">文件</a>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3fe7b441aab0202e993cc5da7496ac20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DztGaHnavBUE-DSF2NE5ZQ.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated"><a class="ae lq" href="https://pkg.go.dev/github.com/3dfosi/gocrypt@v0.0.0-20220919050132-73b9f718fcb9" rel="noopener ugc nofollow" target="_blank">https://pkg . go . dev/github . com/3d fosi/gocrypt @ v 0 . 0 . 0-20220919050132-73b 9 f 718 fcb 9</a></figcaption></figure><p id="49d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于你们中的专家来说，我希望你们联系我，让我知道你们的想法，对于你们中有兴趣尝试的人来说，即使可能有一堆模块以他们自己的方式做类似的事情，你们所要做的就是在你们的代码中导入它:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="ca40" class="ms mt it mo b gy mu mv l mw mx">import (<br/>   ...<br/>   "github.com/3dfosi/gocrypt"<br/>)   </span></pre><p id="1c86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，您可以加密和解密数据，如下例所示:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="5ac8" class="ms mt it mo b gy mu mv l mw mx">package main<br/><br/>import (<br/>   "log"<br/>   "github.com/3dfosi/gocrypt"<br/>)</span><span id="6677" class="ms mt it mo b gy my mv l mw mx">var pass = "SOME-CRAZY-LONG-PASSPHRASE"<br/><br/>func main() {<br/><br/>	// Encrypt Data<br/>	e_data, salt, err := gocrypt.Encrypt([]byte("secret"), pass)<br/>	if err != nil {<br/>		log.Println(err)<br/>		return<br/>	}<br/><br/><br/>	// Decrypt Data<br/>	plaintext, err := gocrypt.Decrypt(e_data, salt, passphrase)<br/>	if err != nil {<br/>		log.Println(err)<br/>		return<br/>	}<br/><br/>}</span></pre><p id="88a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还可以执行以下操作:</p><ul class=""><li id="55b2" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp ne nf ng nh bi translated">加密数据并将其写入一个新文件(我让开发人员决定在这里存储salt的位置)</li><li id="bb6a" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">用相关的salt解密现有文件的加密内容</li><li id="f975" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">加密各种格式的文件(即图像或任何东西)并输出带有存储相关盐的伴随文件的加密版本</li><li id="2f52" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">解密加密文件及其附带的salt文件，并在选择的位置创建新的解密版本</li></ul><p id="0705" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">仅此而已。像往常一样，我们非常欢迎任何问题或反馈。</p></div></div>    
</body>
</html>