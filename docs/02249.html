<html>
<head>
<title>Asynchronous Javascript Part 4: Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步Javascript第4部分:承诺</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/asynchronous-javascript-part-4-promises-6bc04d5acd0c?source=collection_archive---------5-----------------------#2020-02-29">https://levelup.gitconnected.com/asynchronous-javascript-part-4-promises-6bc04d5acd0c?source=collection_archive---------5-----------------------#2020-02-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="da86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">本文是异步Javascript系列文章的第4部分。我强烈推荐你阅读第一部分</em><a class="ae km" href="https://medium.com/@kabir4691/asynchronous-javascript-part-1-b87f263a353a" rel="noopener"><em class="kl"/></a><em class="kl">，</em> <a class="ae km" href="https://medium.com/@kabir4691/asynchronous-javascript-part-2-26ac20fc5ad7" rel="noopener"> <em class="kl">第二部分</em> </a> <em class="kl">和</em> <a class="ae km" rel="noopener ugc nofollow" target="_blank" href="/asynchronous-javascript-part-3-85390632dd1a"> <em class="kl">第三部分</em> </a> <em class="kl">，以便从这篇文章中获得最大收益。</em></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/bbbab6fc99628470add15052bb51d73c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-25KB7EbSHjv70HXrdl6w.png"/></div></div></figure><p id="cfb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将看到ES6中引入的一个有趣的Javascript特性，它可以高效地运行异步代码。在ES6之前，为了运行异步代码(例如网络请求)，我们使用回调函数。但是这种方法有很多缺点(包括<a class="ae km" href="http://callbackhell.com/" rel="noopener ugc nofollow" target="_blank">回调地狱</a>)，导致代码可读性、错误处理和调试方面的问题。为了克服这些问题，引入了一个名为<strong class="jp ir"> Promise </strong>的新Javascript对象。</p></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><h1 id="beaf" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">承诺</h1><p id="dfad" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">承诺是一种特殊类型的Javascript对象，充当异步操作最终完成或失败的占位符。它允许您将“处理程序”附加到它，当成功值或失败原因到达后一个阶段时，处理它们。这让我们可以像调用同步函数一样调用异步函数，并将它们存储在一个代理对象中，该代理对象“承诺”在稍后阶段返回输出。让我们通过一个例子来更好地理解这一点。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="521c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面给出了承诺的基本语法。一个承诺是通过一个传递给它的函数创建的，这个函数叫做<strong class="jp ir">执行者</strong>函数。executor函数包含您希望运行的异步代码。该函数包含两个参数，<code class="fe ml mm mn mo b">resolve</code>和<code class="fe ml mm mn mo b">reject</code>。这些是Javascript提供的默认回调函数。一旦创建了承诺，就会运行执行人功能。每当这个函数的代码完成运行时，我们需要调用任一个回调函数:</p><ul class=""><li id="2119" class="mp mq iq jp b jq jr ju jv jy mr kc ms kg mt kk mu mv mw mx bi translated">resolve(value):调用该函数表示成功条件，其中'<em class="kl"> value </em>'为成功完成executor函数返回的值</li><li id="024c" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated">reject(error):调用这个函数表示一个失败或者错误的情况，其中'<em class="kl"> error </em>'值是一个<code class="fe ml mm mn mo b">Error</code>对象，表示错误的细节。<em class="kl">错误</em>'不一定必须是<code class="fe ml mm mn mo b">Error</code>对象，但强烈建议使用。</li></ul><p id="d89f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">构造函数返回的promise对象也有一些内部属性:</p><ul class=""><li id="495c" class="mp mq iq jp b jq jr ju jv jy mr kc ms kg mt kk mu mv mw mx bi translated">状态:最初设置为“待定”。如果调用了“解决”,则更改为“已履行”,如果调用了“拒绝”,则更改为“已拒绝”。</li><li id="caa7" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated">结果:初始设置为<code class="fe ml mm mn mo b">undefined</code>。如果调用resolve(value ),则更改为'<em class="kl">值</em>;如果调用reject(error ),则更改为'<em class="kl">错误'</em>。</li></ul><p id="3991" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们通过一个简单的例子来看看上述特性是如何工作的。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="be0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码创建了一个承诺，生成一个从1到10的随机数，并检查它是否是偶数。我们使用了<code class="fe ml mm mn mo b">setTimeout</code>来实现1秒的延迟。创建promise对象时，其内部属性被设置为默认值。</p><pre class="ko kp kq kr gt nd mo ne nf aw ng bi"><span id="7bb6" class="nh lh iq mo b gy ni nj l nk nl">state: "pending"<br/>result: undefined</span></pre><p id="5dbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们假设第2行生成的randomNumber是一个像4这样的偶数。在这种情况下，第5行的代码被执行，并调用<code class="fe ml mm mn mo b">resolve</code>回调函数，其参数值为4。这会将承诺对象移动到“已履行”状态。这类似于说executor函数的任务返回了一个“成功”的结果。promise对象的属性现在是</p><pre class="ko kp kq kr gt nd mo ne nf aw ng bi"><span id="c93c" class="nh lh iq mo b gy ni nj l nk nl">state: "fulfilled"<br/>result: 4</span></pre><p id="a0a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果生成的randomNumber是一个奇数，比如7，那么第7行的代码将被执行，并且使用<code class="fe ml mm mn mo b">Error</code>对象作为参数调用<code class="fe ml mm mn mo b">reject</code>回调函数。这会将承诺对象移动到“拒绝”状态。promise对象的属性现在是</p><pre class="ko kp kq kr gt nd mo ne nf aw ng bi"><span id="cd08" class="nh lh iq mo b gy ni nj l nk nl">state: "rejected"<br/>result: Error("Not an even number");</span></pre><p id="6537" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，在一个承诺中，executor函数只能调用<code class="fe ml mm mn mo b">resolve</code>或<code class="fe ml mm mn mo b">reject</code>一次。第一次调用后对<code class="fe ml mm mn mo b">resolve</code>或<code class="fe ml mm mn mo b">reject</code>的任何后续调用都将被忽略。这是因为承诺只有一个结果，要么成功，要么失败。此外，<code class="fe ml mm mn mo b">resolve</code>和<code class="fe ml mm mn mo b">reject</code>都只接受一个(或零个)参数。忽略其他参数。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="7bfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要注意的一点是，当创建promise对象时，它不会立即存储异步操作的输出。输出(可能是由<code class="fe ml mm mn mo b">resolve</code>函数传递的成功值，也可能是由<code class="fe ml mm mn mo b">reject</code>函数传递的错误值)只能在以后获得。这个输出存储在“result”中，result是Promise的内部属性，不能直接访问。为了获得结果，我们给承诺附加了特殊的处理函数，我们将在下面讨论。</p><h1 id="fc94" class="lg lh iq bd li lj nm ll lm ln nn lp lq lr no lt lu lv np lx ly lz nq mb mc md bi translated">然后，接住，最后</h1><p id="fcdb" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">承诺有三个重要的功能，或者可以附加到承诺上的“处理程序”,允许我们接收或“消费”它们的输出。第一个是<code class="fe ml mm mn mo b">then</code>处理程序。<code class="fe ml mm mn mo b">then</code>的基本语法如下。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="bb8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ml mm mn mo b">then</code>处理程序最多接受两个回调函数作为参数。如果在executor函数中调用了<code class="fe ml mm mn mo b">resolve</code>，则执行第一个回调。如果在executor函数中调用了<code class="fe ml mm mn mo b">reject</code>，就会执行第二次回调。比如下面的promise，在executor函数中调用了<code class="fe ml mm mn mo b">resolve</code>函数。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="4510" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，只执行了第一个回调，忽略了第二个回调。</p><p id="1618" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在调用<code class="fe ml mm mn mo b">reject</code>函数的情况下，</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="10cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个回调被忽略，第二个回调被执行。</p><p id="2bd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们也可以有单独的处理程序来使用<code class="fe ml mm mn mo b">resolve</code>和<code class="fe ml mm mn mo b">reject</code>的结果。这就是<code class="fe ml mm mn mo b">catch</code>处理程序发挥作用的地方。它只接受一个回调函数作为参数，并在承诺被拒绝时执行。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="1287" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第三个可用的处理器是<code class="fe ml mm mn mo b">finally</code>。这类似于final在普通的try-catch场景中的工作方式。<code class="fe ml mm mn mo b">finally</code>处理程序不接受任何参数，如果它附加到一个承诺，则总是被执行，不管该承诺是被解决还是被拒绝。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mj mk l"/></div></figure></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><p id="dc49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在本文前面已经提到了引入promises的原因之一是为了克服回调地狱。实现这一点的承诺的特征是链接的能力。承诺的处理者，即<code class="fe ml mm mn mo b">then</code>、<code class="fe ml mm mn mo b">catch</code>和<code class="fe ml mm mn mo b">finally</code>，都返回一个承诺。因此，我们可以使用这些处理程序来“链接”多个承诺。让我们看一个简单的例子。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="a22f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，我们创建了一个简单的承诺，它的值为10。接下来，我们用第5行的第一个<code class="fe ml mm mn mo b">then</code>函数来使用这个结果。该函数将值“10”打印到控制台中，然后返回值10 * 2 = 20。因此，这个<code class="fe ml mm mn mo b">then</code>函数返回的承诺用值20来解析。因此，在第9行，当调用<code class="fe ml mm mn mo b">then</code>函数时，它的结果是20。结果20被打印到控制台上，然后返回20 + 5 = 25。同样，由当前的<code class="fe ml mm mn mo b">then</code>函数返回的承诺因此被解析为值25。通过重复这个过程，我们可以将任意数量的承诺链接到一个现有的承诺。有关链接的更多信息，您可以在MDN上查找这个<a class="ae km" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><p id="bd0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们已经看了承诺，你可能想知道它们在执行顺序中的位置。承诺的处理程序(<code class="fe ml mm mn mo b">then</code>、<code class="fe ml mm mn mo b">catch</code>和<code class="fe ml mm mn mo b">finally</code>)是否因为异步而进入回调队列？答案是否定的。</p><p id="2d05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它们实际上被添加到一个叫做<strong class="jp ir">微任务</strong>队列的东西中。这个队列是在ES6中专门为处理承诺(和一些其他类型的异步函数，如<code class="fe ml mm mn mo b">await</code>)而添加的。因此，每当一个承诺准备就绪时(即它的executor函数已经完成运行)，该承诺的所有<code class="fe ml mm mn mo b">then</code>、<code class="fe ml mm mn mo b">catch</code>和<code class="fe ml mm mn mo b">finally</code>处理程序都被添加到微任务队列中。</p><p id="617e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">微任务队列中的函数也被赋予比回调队列更高的优先级。这意味着每当触发事件循环时，一旦程序到达最后一行，事件循环首先检查微任务队列是否为空。如果它不为空，那么在继续检查回调队列之前，它首先将微任务队列中的所有函数添加到调用堆栈中。</p><p id="28b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有关承诺的更多信息，您可以在MDN上查找此<a class="ae km" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="b196" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的异步Javascript系列到此结束。如有任何疑问或建议，请随时回复！</p></div></div>    
</body>
</html>