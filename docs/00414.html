<html>
<head>
<title>Type-safe Frontend Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型安全前端开发</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typesafe-frontend-development-89c7600f2759?source=collection_archive---------4-----------------------#2019-02-12">https://levelup.gitconnected.com/typesafe-frontend-development-89c7600f2759?source=collection_archive---------4-----------------------#2019-02-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/dc1286ae33da596dc0cbab238898a1d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ME5N1sawV4aVm-HFDdEauQ.jpeg"/></div></div></figure><h1 id="5c1f" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">前言</h1><p id="225e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">东尼·霍尔在QCon'09 <a class="ae lu" href="http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare" rel="noopener ugc nofollow" target="_blank">上为创造了计算机科学中最灾难性的发明</a>道歉:</p><blockquote class="lz ma mb"><p id="e8a3" class="kw kx mc ky b kz md lb lc ld me lf lg mf mg lj lk mh mi ln lo mj mk lr ls lt ij bi translated">我称之为我的十亿美元错误。这是1965年零引用的发明。{…}这导致了无数的错误、漏洞和系统崩溃，在过去的四十年里，这些可能造成了十亿美元的损失。</p></blockquote><p id="3fa7" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mg lj lk ll mi ln lo lp mk lr ls lt ij bi translated">我的日常工作包括使用一种语言，这种语言有两个可能的空引用位置:T1和T2。我说的是JavaScript。虽然我确实喜欢Brendan Eich的这个宠物项目，因为它的倾斜的学习曲线、表现力和丰富的工具，但我不能允许我自己或我的同事以“纯”的形式使用它。处理类似<code class="fe lv lw lx ly b">undefined is not a function</code>、<code class="fe lv lw lx ly b">cannot call method 'foo' of null</code>等错误的代价实在太高了。我不能拿我客户的钱冒险，建议用这样的支持成本开发一个产品。</p><p id="1a86" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mg lj lk ll mi ln lo lp mk lr ls lt ij bi translated">随着我越来越深入地钻研计算机科学、范畴理论和同伦类型理论，我想要我的代码:</p><ul class=""><li id="8614" class="ml mm iq ky b kz md ld me lh mn ll mo lp mp lt mq mr ms mt bi translated">合理地说，</li><li id="432f" class="ml mm iq ky b kz mu ld mv lh mw ll mx lp my lt mq mr ms mt bi translated">为了运行时安全地执行，</li><li id="8a1b" class="ml mm iq ky b kz mu ld mv lh mw ll mx lp my lt mq mr ms mt bi translated">为了有好的表现，</li><li id="aa5b" class="ml mm iq ky b kz mu ld mv lh mw ll mx lp my lt mq mr ms mt bi translated">并且易于重构和支持。</li></ul><p id="f9e3" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mg lj lk ll mi ln lo lp mk lr ls lt ij bi translated"><strong class="ky ir">毒性警告！然而，另一方面，自由市场的存在和合格专家的明显缺乏。我在这里可能有点偏见，但是，不幸的是，大多数<em class="mc">程序员</em>不是<em class="mc">工程师</em>甚至不是数学家<em class="mc">。尽管如此，我还是需要找到一种方法来实现我的使命，并通过从市场原材料中创造出合格的资源来传播我的愿景。我希望编程世界成为一个更好的地方。</em></strong></p><p id="e7ee" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mg lj lk ll mi ln lo lp mk lr ls lt ij bi translated">考虑到这些前提，我选择了严格的函数式编程作为我的首选方法，选择了TypeScript作为我的主要语言。它两全其美:非常受欢迎(只要看看脸书等公司的成功故事就知道了)，而且有足够的额外津贴来满足我的要求。至少目前是这样。</p><h1 id="4b20" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是类型安全？</h1><p id="85b5" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">从形式的角度来看，类型安全是由编程语言语义的两个属性决定的:</p><ol class=""><li id="6fec" class="ml mm iq ky b kz md ld me lh mn ll mo lp mp lt mz mr ms mt bi translated"><strong class="ky ir">(类型)保持</strong>——程序的“良好类型化”在语言的转换规则下保持不变。</li><li id="013c" class="ml mm iq ky b kz mu ld mv lh mw ll mx lp my lt mz mr ms mt bi translated"><strong class="ky ir">进度</strong>——一个良好类型化(可类型化)的程序永远不会进入一个无法进一步转换的未定义状态。</li></ol><p id="d18d" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mg lj lk ll mi ln lo lp mk lr ls lt ij bi translated">如果从学术语言翻译过来，<strong class="ky ir">类型安全就是在编译时利用关于我们数据的信息来防止运行时的错误</strong>。</p><p id="a014" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mg lj lk ll mi ln lo lp mk lr ls lt ij bi translated">最后一点。</p><blockquote class="lz ma mb"><p id="c3fb" class="kw kx mc ky b kz md lb lc ld me lf lg mf mg lj lk mh mi ln lo mj mk lr ls lt ij bi translated">蛇，我们为什么还在这里？就为了受罪？..<br/> Kazuhira Miller，金属齿轮固体V</p></blockquote><p id="e092" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mg lj lk ll mi ln lo lp mk lr ls lt ij bi translated">我确信遵循类型安全规则的开发人员应该感到舒适，并把编译器作为他最好的朋友&amp;主要工具。但是如果开发者想写不安全的代码，<em class="mc">他就必须承受</em>。他的“错误”代码不应该编译，或者他的库设计不应该易于与系统的其余部分一起使用——这不可避免地会导致他的同事的抱怨，然后导致繁重的重构。</p><p id="178b" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mg lj lk ll mi ln lo lp mk lr ls lt ij bi translated">玩笑归玩笑，我真的很想达到错误的程序根本不能被表达的状态。这涉及到几种技术和模式的使用。</p><h1 id="d098" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">类型安全模式</h1><blockquote class="lz ma mb"><p id="f8e2" class="kw kx mc ky b kz md lb lc ld me lf lg mf mg lj lk mh mi ln lo mj mk lr ls lt ij bi translated"><strong class="ky ir"> <em class="iq">注意:</em> </strong> <em class="iq">由于我使用的是Giulio Canti的令人难以置信的</em><a class="ae lu" href="https://github.com/gcanti/fp-ts" rel="noopener ugc nofollow" target="_blank"><em class="iq">FP-ts</em></a><em class="iq">包，所以我会坚持使用它的术语。</em></p></blockquote><h1 id="9f8b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">使用<code class="fe lv lw lx ly b">const</code>进行简单的推理</h1><p id="4c25" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">你可能知道，现在JavaScript有三种声明变量的方式:<code class="fe lv lw lx ly b">var</code>、<code class="fe lv lw lx ly b">let</code>和<code class="fe lv lw lx ly b">const</code>。前者要求程序员记住所有的提升规则，所以在ES6 TC39委员会中引入了<code class="fe lv lw lx ly b">let</code>和<code class="fe lv lw lx ly b">const</code>关键字，这——多么令人惊讶！–不要提升。从这两点来看，只有<code class="fe lv lw lx ly b">const</code>允许我们自信地思考我们的代码。让我用一个简单的例子来解释一下:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="4153" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mg lj lk ll mi ln lo lp mk lr ls lt ij bi translated">有足够信心的人能说<code class="fe lv lw lx ly b">user</code>变量没有在第48行和第153行之间被重新分配，而不看那些行并跟踪所有的方法调用吗？请考虑以下情况:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c37c" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mg lj lk ll mi ln lo lp mk lr ls lt ij bi translated">好多了。</p><p id="5507" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mg lj lk ll mi ln lo lp mk lr ls lt ij bi translated">经验之谈:<strong class="ky ir">永远用</strong> <code class="fe lv lw lx ly b"><strong class="ky ir">const</strong></code>。</p><h1 id="705d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">避免<code class="fe lv lw lx ly b">null</code>和<code class="fe lv lw lx ly b">undefined</code></h1><p id="ac8c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我引用东尼·霍尔的话开始这篇文章，不仅仅是为了显得有文化。我真的，真的很讨厌和JS和TS的同事一起工作。谢天谢地，函数式编程为我们提供了一个非常棒的工具——一个<code class="fe lv lw lx ly b">Option</code>单子(也称为<code class="fe lv lw lx ly b">Maybe</code>)。</p><p id="44bb" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mg lj lk ll mi ln lo lp mk lr ls lt ij bi translated">一个简单的例子:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3e0b" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mg lj lk ll mi ln lo lp mk lr ls lt ij bi translated">所以经验之二:<strong class="ky ir">如果你需要引入一个实体，它的值在程序执行的任何时候都可以不存在，使用</strong> <code class="fe lv lw lx ly b"><strong class="ky ir">Option</strong></code> <strong class="ky ir">来编码这个想法</strong>。</p><h1 id="517b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">避免抛出异常和副作用</h1><p id="41e6" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">你知道比回一个<code class="fe lv lw lx ly b">null</code>更糟糕的是什么吗？<em class="mc">抛出异常</em>。在“传统的”JS/TS中，没有办法用一个可能崩溃的警告来标记一个方法。在普通的ol' Java中，我们有<code class="fe lv lw lx ly b">throws</code>关键字，但是它导致了另一系列的问题，并且(在我看来)应该在任何产品代码中被禁止。</p><p id="0ab1" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mg lj lk ll mi ln lo lp mk lr ls lt ij bi translated">那我们该怎么做呢？使用我们单子袋中的另一个工具— <code class="fe lv lw lx ly b">Either</code>当然是单子和它的后继者！它对一个计算进行编码，该计算可能产生一个业务结果，也可能因一个<strong class="ky ir">可恢复的</strong>错误而失败。我怎么强调这一点都不为过。如果你熟悉Scala生态系统(即使你不熟悉)，去看看John De Goes的一篇关于ScalaZ中bifunctor IO的令人难以置信的文章。约翰很好地描述了这种方法的动机。</p><p id="d3cc" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mg lj lk ll mi ln lo lp mk lr ls lt ij bi translated">在前端，引入一个<code class="fe lv lw lx ly b">IO</code>单子是很痛苦的，因为像React/Angular/Vue这样的大多数框架/库都是用传统的OOP风格的方法编写的，并且需要相当多的样板文件来引入这个概念。然而，在代码的任何部分使用一个<code class="fe lv lw lx ly b">Either</code>都是完全无干扰的，并且不需要对框架或库的代码做任何修改。</p><blockquote class="lz ma mb"><p id="df77" class="kw kx mc ky b kz md lb lc ld me lf lg mf mg lj lk mh mi ln lo mj mk lr ls lt ij bi translated"><em class="iq">顺便推荐一个很棒的模块叫做</em><a class="ae lu" href="https://github.com/devex-web-frontend/remote-data-ts" rel="noopener ugc nofollow" target="_blank"><em class="iq">remote-data-ts</em></a><em class="iq">，它对一个网络请求的状态进行编码。我已经用这种方法为我当前的客户构建了一个完整的渲染系统，开发人员对此很满意。去看看！</em></p><p id="4e17" class="kw kx mc ky b kz md lb lc ld me lf lg mf mg lj lk mh mi ln lo mj mk lr ls lt ij bi translated"><em class="iq">老实说，我已经创建了自己的</em> <code class="fe lv lw lx ly b"><em class="iq">RemoteData</em></code> <em class="iq">子类型，名为</em> <code class="fe lv lw lx ly b"><em class="iq">ApiData</em></code> <em class="iq">，它编码了</em> <strong class="ky ir"> <em class="iq">六个</em> </strong> <em class="iq">状态，而不仅仅是</em> <strong class="ky ir"> <em class="iq">四个</em> </strong> <em class="iq">，但这是我的客户的一个特例，很容易成为另一篇完整文章的主题。</em></p></blockquote><h1 id="061b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">在编译时尽可能多地计算</h1><p id="4d1a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是函数式编程中我最喜欢的话题之一——类型级编码！这意味着我们以这样的方式编码我们的数据类型，即<strong class="ky ir">它们只代表程序</strong>的有效状态，不正确的程序将不会被编译！</p><p id="fc66" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mg lj lk ll mi ln lo lp mk lr ls lt ij bi translated">我经常说我使用TDD——类型驱动开发。这显然是个笑话，但只是半个笑话。类型级编程迫使你以同样的方式考虑值和类型，你的编码从设计类型流开始——当它完成时，你的程序字面上写它自己，因为你只需要确保类型匹配。使用这种方法，您将不再看到对值操作的<em class="mc">函数和对类型参数</em>操作的<em class="mc">泛型类型之间的区别，这使得您的推理更加清晰明了。</em></p><p id="3a31" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mg lj lk ll mi ln lo lp mk lr ls lt ij bi translated">使用这种技术对所选语言的类型系统要求很高。我仍然梦想着有一天我可以用Agda或Coq之类的独立类型语言编写产品代码。但是TypeScript仍然有一些锦囊妙计——由于它的结构化类型系统，我们可以表达像<code class="fe lv lw lx ly b">NonEmptyList</code>这样的类型:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="51c0" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mg lj lk ll mi ln lo lp mk lr ls lt ij bi translated">当然，这并没有使TypeScript成为一种依赖类型的语言，但它确实是这样的:)</p><p id="e262" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mg lj lk ll mi ln lo lp mk lr ls lt ij bi translated">所以，让我分享一个例子——它可能比任何描述都更清楚:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="281f" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">最终无标签，部分评估</h1><p id="2a71" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这只是一个设计模式，但是它的重要性高得令人难以置信。使用无标签最终编码，开发人员创建了一个定制的<a class="ae lu" href="https://wiki.haskell.org/Embedded_domain_specific_language" rel="noopener ugc nofollow" target="_blank"> eDSL </a>，其中不正确的程序状态是不可能表达的。如果你想深入数学&amp;原始设计，请参考Oleg Kiselyov等人的<a class="ae lu" href="http://okmij.org/ftp/tagless-final/JFP.pdf" rel="noopener ugc nofollow" target="_blank">初始论文</a></p><p id="8f48" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mg lj lk ll mi ln lo lp mk lr ls lt ij bi translated">我在TypeScript中创建了一个实现TF的示例要点<a class="ae lu" href="https://gist.github.com/YBogomolov/03b742e68f35ee963d2097814200b269" rel="noopener ugc nofollow" target="_blank">,所以去查看一下细节吧！如果你碰巧懂一点俄语，请看</a><a class="ae lu" href="https://gist.github.com/YBogomolov/bacbb3f3acc69bf6c3f8103520ee7765" rel="noopener ugc nofollow" target="_blank">这个更详细的例子</a>关于创建浏览器存储代数，它独立于同步/异步计算模型。</p><p id="abb8" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mg lj lk ll mi ln lo lp mk lr ls lt ij bi translated">顺便说一句，有些人<a class="ae lu" href="https://typelevel.org/blog/2017/12/27/optimizing-final-tagless.html" rel="noopener ugc nofollow" target="_blank">建议称2017年为最终无标签的一年</a>，这意味着很多。然而，每一件沸沸扬扬的事情迟早都会走到尽头。2月25日，John De Goes将<a class="ae lu" href="https://skillsmatter.com/meetups/11945-scala-matters" rel="noopener ugc nofollow" target="_blank">提出他对Scala中FP </a>下一件大事的设想。看到结果我还挺激动的！</p><h1 id="b0b3" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="b4e2" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我希望我的文章能让你对函数式编程和类型级方法感兴趣。它真的拓宽了任何程序员的视野，并使企业拥有一个可靠的、高性能的、可支持的软件。当WebAssembly变得广泛可用时，我希望看到这种方法被进一步推广，我们作为前端工程师将有更多令人敬畏的工具供我们使用。谁知道呢，也许，甚至是依赖类型的语言:)</p><p id="9881" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mg lj lk ll mi ln lo lp mk lr ls lt ij bi translated">请用电报回复我<a class="ae lu" href="https://t.me/ybogomolov" rel="noopener ugc nofollow" target="_blank"> @ybogomolov </a>，用推特回复我<a class="ae lu" href="https://twitter.com/YuriyBogomolov" rel="noopener ugc nofollow" target="_blank"> @YuriyBogomolov </a>，或者通过<a class="ae lu" href="mailto:yuriy.bogomolov@gmail.com?subject=Typesafe%20Frontend%20Development%20feedback" rel="noopener ugc nofollow" target="_blank">yuriy.bogomolov@gmail.com</a>回复我。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><figure class="na nb nc nd gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi nn"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure><div class="no np gp gr nq nr"><a href="https://gitconnected.com/learn/typescript" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">学习TypeScript -最佳TypeScript教程(2019) | gitconnected</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">18大TypeScript教程-免费学习TypeScript。课程由开发人员提交并投票，从而实现…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">gitconnected.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of jw nr"/></div></div></a></div></div></div>    
</body>
</html>