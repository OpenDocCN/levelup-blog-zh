<html>
<head>
<title>From callbacks to async/await in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中从回调到异步/等待</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/from-callbacks-to-async-await-in-swift-aebd38ab0f13?source=collection_archive---------5-----------------------#2021-01-17">https://levelup.gitconnected.com/from-callbacks-to-async-await-in-swift-aebd38ab0f13?source=collection_archive---------5-----------------------#2021-01-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/98ff7f35209dcbd8e828c19cfbb81de4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZvWzuq-sDp2gvSV0"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@picoftasty?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">梅姆</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><div class=""/><p id="564c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">闭包是自包含的功能块，可以在你的代码中传递和使用。闭包可以从定义它们的上下文中获取并存储对任何常量和变量的引用。闭包让异步函数接受实际上是另一个函数的参数。闭包的代码完成后，该函数被调用，并带有一个错误或一个值。</p><p id="3575" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现代Swift开发涉及大量使用闭包和完成处理程序的异步编程。闭包是编写异步代码最简单的方法。这些都很复杂，但是功能强大且富于表现力，在iOS应用程序的开发中被广泛使用。</p><p id="eb07" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将讨论async/await，这是一种语言扩展，它使异步编程更加自然，更不容易出错。这从奥列格·安德雷耶夫写的一份早期提案中得到一些启发。</p><h1 id="149b" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">基于</strong>块的API的问题</h1><p id="1abc" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">使用基于块的API进行异步编程有很多问题。</p><h2 id="c8ba" class="mf ld jg bd le mg mh dn li mi mj dp lm ko mk ml lq ks mm mn lu kw mo mp ly mq bi translated"><strong class="ak">问题1:末日金字塔</strong></h2><p id="2131" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">我们都遇到过类似这样的嵌套网络回调:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="510f" class="mf ld jg mw b gy na nb l nc nd">func makeSandwich(completionBlock: (result: Sandwich) -&gt; Void) {<br/>    cutBread { buns in<br/>        cutCheese { cheeseSlice in<br/>            cutHam { hamSlice in<br/>                cutTomato { tomatoSlice in<br/>                    let sandwich = Sandwich([buns, cheeseSlice, hamSlice, tomatoSlice] <br/>                    completionBlock(sandwich))<br/>                }<br/>            }<br/>        }<br/>    }<br/>}<br/><br/>makeSandwich { sandwich in<br/>    eat(sandwich)<br/>}</span></pre><h2 id="1f8d" class="mf ld jg bd le mg mh dn li mi mj dp lm ko mk ml lq ks mm mn lu kw mo mp ly mq bi translated">问题2:冗长和旧式的错误处理</h2><p id="3f8c" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">错误的处理变得非常困难和冗长。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="d9d6" class="mf ld jg mw b gy na nb l nc nd">func makeSandwich(completionBlock: (result: Sandwich?, error: NSError?) -&gt; Void) {<br/>    cutBread { buns, error in<br/>        guard let buns = buns else {<br/>            completionBlock(nil, error)<br/>            return<br/>        }<br/>        cutCheese { cheeseSlice, error in<br/>            guard let cheeseSlice = cheeseSlice else {<br/>                completionBlock(nil, error)<br/>                return<br/>            }</span><span id="3364" class="mf ld jg mw b gy ne nb l nc nd">            cutHam { hamSlice, error in<br/>                guard let hamSlice = hamSlice else {<br/>                    completionBlock(nil, error)<br/>                    return<br/>                }</span><span id="bb75" class="mf ld jg mw b gy ne nb l nc nd">                cutTomato { tomatoSlice in <br/>                    guard let tomatoSlice = tomatoSlice else {<br/>                        completionBlock(nil, error)<br/>                        return<br/>                    }</span><span id="de09" class="mf ld jg mw b gy ne nb l nc nd">                    let sandwich = Sandwich([buns, cheeseSlice, hamSlice, tomatoSlice]<br/>                    completionBlock(sandwich), nil)<br/>                }<br/>            }<br/>        }<br/>    }<br/>}<br/><br/>makeSandwich { sandwich, error in<br/>    guard let sandwich = sandwich else {<br/>        error("No sandwich today")<br/>        return<br/>    }</span><span id="7a28" class="mf ld jg mw b gy ne nb l nc nd">    eat(sandwich)<br/>}</span></pre><h2 id="2643" class="mf ld jg bd le mg mh dn li mi mj dp lm ko mk ml lq ks mm mn lu kw mo mp ly mq bi translated">问题3:忘记调用完成处理程序</h2><p id="67d7" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">不调用适当的块，直接返回就可以轻松退出。一旦被遗忘，这个问题就很难调试。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="e2ac" class="mf ld jg mw b gy na nb l nc nd">func makeSandwich(completionBlock: (result: Sandwich?, error: NSError?) -&gt; Void) {<br/>    cutBread { buns, error in<br/>        guard let buns = buns else {<br/>            return // &lt;- forgot to call the block<br/>        }</span><span id="a52d" class="mf ld jg mw b gy ne nb l nc nd">        cutCheese { cheeseSlice, error in<br/>            guard let cheeseSlice = cheeseSlice else {<br/>                return <em class="lb">// &lt;- forgot to call the block</em><br/>            }<br/>            ...<br/>        }<br/>    }<br/>}</span></pre><h2 id="1528" class="mf ld jg bd le mg mh dn li mi mj dp lm ko mk ml lq ks mm mn lu kw mo mp ly mq bi translated">问题4:调用完成处理程序后忘记返回</h2><p id="0ceb" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">当你没有忘记调用block时，你仍然可以在那之后忘记返回。谢天谢地，语法在某种程度上防止了这种情况，但这并不总是相关的。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="9a6a" class="mf ld jg mw b gy na nb l nc nd">func makeSandwich(recipient: Person, completionBlock: (result: Sandwich?, error: NSError?) -&gt; Void) {<br/>    if recipient.isVegeterian {<br/>        if let sandwich = cachedVegeterianSandwich {<br/>            completionBlock(cachedVegeterianSandwich) <em class="lb">// &lt;- forgot to return after calling the block</em><br/>        }<br/>    }<br/>    ...<br/>}</span></pre><h2 id="e6a7" class="mf ld jg bd le mg mh dn li mi mj dp lm ko mk ml lq ks mm mn lu kw mo mp ly mq bi translated">问题5:在错误的队列/线程上继续</h2><p id="21f6" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">许多API在它们自己的私有队列上调用完成块。用户代码通常希望在自己的私有队列(或主线程)上运行。</p><p id="881e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">忘记将_async分派回正确的队列会导致很难调试的问题，这些问题可能会零星地出现，或者出现在程序的一些不相关的部分。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="1fc1" class="mf ld jg mw b gy na nb l nc nd">func makeSandwich(completionBlock: (result:Sandwich)-&gt;Void) {<br/>    cutBread { buns in<br/>        dispatch_async(dispatch_get_main_queue()) {<br/>            cutCheese { cheeseSlice in<br/>                dispatch_async(dispatch_get_main_queue()) {<br/>                    cutHam { hamSlice in<br/>                        dispatch_async(dispatch_get_main_queue()) {<br/>                            cutTomato { tomatoSlice in <br/>                                dispatch_async(dispatch_get_main_queue()) {<br/>                                    completionBlock(Sandwich([buns, cheeseSlice, hamSlice, tomatoSlice]))<br/>                                }<br/>                            }<br/>                        }<br/>                    }<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span></pre></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="1568" class="lc ld jg bd le lf np lh li lj nq ll lm ln nr lp lq lr ns lt lu lv nt lx ly lz bi translated">建议的解决方案:异步/等待</h1><p id="7e8a" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">对回调地狱问题最好的解决方案之一是异步/等待。<code class="fe nf ng nh mw b">async/await</code>，通常被称为<code class="fe nf ng nh mw b">Asynchronous functions</code>，允许异步代码像直线同步代码一样编写。async/await的概念很简单:允许强制执行异步代码，也就是说，当异步操作完成时，不使用回调来处理返回值，您只需从普通函数返回一个结果，编译器就会为您完成剩下的工作。</p><p id="4427" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数可以选择加入<em class="lb">异步语义</em>，方法是使用<code class="fe nf ng nh mw b">async</code>关键字并用通常的返回类型替换闭包变量:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="2b0d" class="mf ld jg mw b gy na nb l nc nd">// Before:<br/>func makeSandwich(completionHandler: (result: Sandwich) -&gt; Void)</span><span id="07a3" class="mf ld jg mw b gy ne nb l nc nd">// After:<br/>async func makeSandwich() -&gt; Sandwich</span></pre><p id="4d10" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在声明函数时，我们在返回值之前添加了单词<code class="fe nf ng nh mw b">async</code>，在调用函数之前添加了<code class="fe nf ng nh mw b">await</code>。</p><p id="d3e8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个示例可以使用async/await以更自然的方式重写，如下所示:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="4d1a" class="mf ld jg mw b gy na nb l nc nd">async func cutBread() -&gt; Bread<br/>async func cutCheese() -&gt; Cheese<br/>async func cutHam() -&gt; Ham<br/>async func cutTomato() -&gt; Vegetable<br/><br/>async func makeSandwich() -&gt; Sandwich {<br/>    let bread  = await cutBread()<br/>    let cheese = await cutCheese()<br/>    let ham    = await cutHam()<br/>    let tomato = await cutTomato()<br/>    return Sandwich([bread, cheese, ham, tomato])<br/>}</span></pre><p id="598b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">异步代码<em class="lb">以与写入相同的顺序开始</em>的执行。一些操作可能需要在其他操作完成后开始，其他操作可能需要并行运行。通过在适当的地方使用<code class="fe nf ng nh mw b">await</code>，您可以指定哪些操作等待哪些操作。</p><p id="0bda" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意<code class="fe nf ng nh mw b">await</code>并没有阻塞线程，它只是告诉编译器将剩余的调用组织成等待操作的继续。使用<code class="fe nf ng nh mw b">await</code>没有死锁的风险，也不可能用它来让当前线程等待结果。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="700f" class="lc ld jg bd le lf np lh li lj nq ll lm ln nr lp lq lr ns lt lu lv nt lx ly lz bi translated">结论</h1><p id="e8dc" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">async/await一点都不新鲜。微软已经在. Net中实现了它，JavaScript也支持这个特性。就Swift而言，开发人员多年来一直提议增加这一功能，并最终获得批准。</p><p id="470d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">异步功能对Swift开发人员来说是个好消息。这种方法的最大好处是<strong class="kf jh">异步代码的编写方式与同步代码</strong>相同，这是一个非常非常大的优势！</p><p id="9900" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望这篇文章能说服你们中的一些人去看看异步函数，从回调函数变成看起来更干净、更容易使用的函数。</p><p id="7675" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你喜欢这个简短的介绍。你可以在<a class="ae jd" href="https://www.linkedin.com/in/rahulgarg12/" rel="noopener ugc nofollow" target="_blank"> Rahul Garg </a>找到我。</p></div></div>    
</body>
</html>