<html>
<head>
<title>JavaScript Best Practices for Writing More Robust Code — Finding Items</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更健壮代码的JavaScript最佳实践——查找项目</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-for-writing-more-robust-code-finding-items-49b4ebe97d04?source=collection_archive---------18-----------------------#2020-05-05">https://levelup.gitconnected.com/javascript-best-practices-for-writing-more-robust-code-finding-items-49b4ebe97d04?source=collection_archive---------18-----------------------#2020-05-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b211b773ea1f259f4347f0e1aa86b34f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DiyNiGqcvO6ogqlC"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@r3dmax?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jonatan Pie </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="cd51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种简单易学的编程语言。编写运行并执行某些操作的程序很容易。然而，很难考虑所有的用例并编写健壮的JavaScript代码。</p><p id="faf9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究更可靠的方法来过滤和检查数组中的项目。</p><h1 id="5593" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用every方法检查数组的所有条目中是否存在某些内容</h1><p id="43d2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JavaScript数组实例的<code class="fe mh mi mj mk b">every</code>方法让我们可以很容易地检查数组的所有条目中是否存在某种东西。</p><p id="f1fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们所要做的就是传入一个回调函数，其中包含我们想要在每个条目中检查的条件。</p><p id="9362" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们想检查数组中的每个数字是否都是偶数，我们可以编写以下代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ef8b" class="mt lf it mk b gy mu mv l mw mx">const arr = [2, 4, 6];<br/>const allEven = arr.every(a =&gt; a % 2 === 0);</span></pre><p id="0957" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有一个全是偶数的<code class="fe mh mi mj mk b">arr</code>数组。然后我们使用了有一个回调函数的<code class="fe mh mi mj mk b">every</code>,该回调函数将数组条目<code class="fe mh mi mj mk b">a</code>作为参数，我们返回<code class="fe mh mi mj mk b">a % 2 === 0</code>来检查数组中的所有数字是否都是偶数。</p><p id="cf60" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为它们都是偶数，<code class="fe mh mi mj mk b">allEven</code>是<code class="fe mh mi mj mk b">true</code>，因为如果数组实例中的每个条目都满足回调中给定的条件，则<code class="fe mh mi mj mk b">every</code>返回<code class="fe mh mi mj mk b">true</code>，否则返回<code class="fe mh mi mj mk b">false</code>。</p><p id="7c2c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这比编写我们自己的循环更可靠，因为它更短并且经过了很好的测试。因此，虫子的机会就少了。</p><p id="ccf4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回调也可以接受其他参数。被循环的索引是第二个参数，如果是第三个，则是数组本身。它们都是可选的。但是，如果我们需要，那么我们可以包含它们。</p><p id="b31a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以将示例重写如下:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9052" class="mt lf it mk b gy mu mv l mw mx">const arr = [2, 4, 6];<br/>const allEven = arr.every((a, index, array) =&gt; array[index] % 2 === 0);</span></pre><p id="6d9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们需要在回调函数中引用<code class="fe mh mi mj mk b">this</code>，那么<code class="fe mh mi mj mk b">every</code>方法还接受一个对象，我们可以将该对象设置为回调函数中<code class="fe mh mi mj mk b">this</code>的值。</p><p id="f0bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写以下代码来设置<code class="fe mh mi mj mk b">this</code>的值，并在回调中使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="904d" class="mt lf it mk b gy mu mv l mw mx">const arr = [1, 2, 3];<br/>const allEven = arr.every(function(a){<br/> return a &gt;= this.min;<br/>}, { min: 2 });</span></pre><p id="7fb7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们通过将<code class="fe mh mi mj mk b">{ min: 2 }</code>作为第二个参数传入来设置回调中<code class="fe mh mi mj mk b">this</code>的值。</p><p id="8139" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们将函数切换到传统函数，这样我们就可以在回调中引用<code class="fe mh mi mj mk b">this</code>值。在回调中，我们检查了每个数组条目是否大于或等于<code class="fe mh mi mj mk b">this.min</code>，即2。</p><p id="c3db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不必担心如何设置循环，何时结束循环以及循环中的其他事情。</p><h1 id="6e1c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用filter方法创建包含已过滤条目的数组</h1><p id="18ef" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">数组实例的<code class="fe mh mi mj mk b">filter</code>方法返回一个数组，该数组的条目在包含返回数组的回调中具有给定的条件。</p><p id="568a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3470" class="mt lf it mk b gy mu mv l mw mx">const arr = [1, 2, 3];<br/>const result = arr.filter(a =&gt; a &gt; 1);</span></pre><p id="1b7b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们用回调函数<code class="fe mh mi mj mk b">a =&gt; a &gt; 1</code>在数组实例上调用了<code class="fe mh mi mj mk b">filter</code>，以返回一个新数组，其中包含了<code class="fe mh mi mj mk b">arr</code>中大于1的所有条目。</p><p id="1311" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们应该得到<code class="fe mh mi mj mk b">[2, 3]</code>作为<code class="fe mh mi mj mk b">result</code>的值。</p><p id="e243" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像<code class="fe mh mi mj mk b">every</code>一样，回调也可以带一个可选的<code class="fe mh mi mj mk b">index</code>和<code class="fe mh mi mj mk b">array</code>参数。<code class="fe mh mi mj mk b">index</code>是第二个参数，<code class="fe mh mi mj mk b">array</code>是第三个参数。</p><p id="4fb9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们也可以写下面的代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d7fa" class="mt lf it mk b gy mu mv l mw mx">const arr = [1, 2, 3];<br/>const result = arr.filter((a, index, array) =&gt; array[index] &gt; 1);</span></pre><p id="6cf8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们使用了<code class="fe mh mi mj mk b">array</code>和<code class="fe mh mi mj mk b">index</code>来引用条目，而不是使用第一个参数<code class="fe mh mi mj mk b">a</code>来引用每个条目。</p><p id="16bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该得到和以前一样的结果。</p><p id="270b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这比编写我们的循环要好，因为它附带了JavaScript的标准库，所以它已经过很好的测试，可以消除任何错误。</p><p id="e25e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，它用于过滤的算法对于生产应用来说保证足够快，因为它在标准库中。</p><p id="8758" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，它也比我们自己写循环来做同样的事情要短。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/261c21f354fa729751440bd275d6ed75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lS80KP2R4GI6-RCN"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">安迪·奇尔顿在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="c493" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="798f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">array实例的<code class="fe mh mi mj mk b">every</code>方法对于检查每个条目是否有我们要找的东西非常有用。</p><p id="68a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要用array实例中满足给定条件的条目创建一个新数组，我们可以使用array实例的<code class="fe mh mi mj mk b">filter</code>方法来简化。</p></div></div>    
</body>
</html>