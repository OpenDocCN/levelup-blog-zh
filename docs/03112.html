<html>
<head>
<title>Node.js Best Practices — Using Modern Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js最佳实践—使用现代功能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/node-js-best-practices-using-modern-features-1f5a4a189ec8?source=collection_archive---------1-----------------------#2020-04-20">https://levelup.gitconnected.com/node-js-best-practices-using-modern-features-1f5a4a189ec8?source=collection_archive---------1-----------------------#2020-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a91a377490f7e615ca72a6c81a522b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p8mkz_-foK0m1VZM"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@bel2000a?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">贝琳达·费因斯</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="64c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Node.js是编写应用程序的流行运行时。这些应用程序通常是许多人使用的生产质量应用程序。为了使维护它们变得更容易，我们必须为人们设定一些准则来遵循。</p><p id="4eb8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些现代JavaScript特性，我们应该使用它们来创建干净且易于维护的代码。</p><h1 id="4d03" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">更喜欢const而不是let。放弃var</h1><p id="daf6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">var</code>是一个过时的关键字，用于创建不应再使用的变量。范围不一致，不像<code class="fe mh mi mj mk b">let</code>和<code class="fe mh mi mj mk b">const</code>。<code class="fe mh mi mj mk b">var</code>是函数作用域，所以它可以从外部块访问，并对我们的代码产生潜在的问题。</p><p id="0837" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">let</code>和<code class="fe mh mi mj mk b">const</code>的作用域是blocked，所以它们不能在块外被访问。<code class="fe mh mi mj mk b">const</code>防止常量被重新分配为另一个值。</p><p id="97d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有以下代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b247" class="mt lf it mk b gy mu mv l mw mx">var callbacks = [];<br/>(function() {<br/>  for (var i = 0; i &lt; 5; i++) {<br/>    callbacks.push( function() { return i; } );<br/>  }<br/>})();</span><span id="4a82" class="mt lf it mk b gy my mv l mw mx">console.log(callbacks.map( function(cb) { return cb(); } ));</span></pre><p id="753d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们就把<code class="fe mh mi mj mk b">[ 5, 5, 5, 5, 5 ]</code>看成<code class="fe mh mi mj mk b">callbacks.map( function(cb) { return cb(); } )</code>的值。</p><p id="0f1e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为<code class="fe mh mi mj mk b">i</code>的值直到达到5才被传递给回调函数。然后我们用值5运行它们。上面的代码实际上与以下代码相同:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="cd9a" class="mt lf it mk b gy mu mv l mw mx">var callbacks = [];<br/>(function() {<br/>  var i<br/>  for (i = 0; i &lt; 5; i++) {<br/>    callbacks.push( function() { return i; } );<br/>  }<br/>})();<br/>console.log(callbacks.map( function(cb) { return cb(); } ));</span></pre><p id="a42b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为吊装。因此，当回调运行时，<code class="fe mh mi mj mk b">i</code>的值将是5。</p><p id="3bda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">let</code>变量不托管，所以不会有同样的问题。因此，我们不会有同样的问题:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="065d" class="mt lf it mk b gy mu mv l mw mx">var callbacks = [];<br/>(function() {<br/>  for (let i = 0; i &lt; 5; i++) {<br/>    callbacks.push( function() { return i; } );<br/>  }<br/>})();<br/>console.log(callbacks.map( function(cb) { return cb(); } ));</span></pre><p id="c365" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，<code class="fe mh mi mj mk b">var</code>是一种痛苦和困惑，所以我们永远不应该使用它。</p><h1 id="8251" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">首先需要模块，而不是内部函数</h1><p id="2471" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该在每个代码文件的顶部要求模块。这让我们可以很容易地判断出哪些依赖是必需的。</p><p id="650d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Require在Node.js中同步运行。因此，如果在函数中调用它们，它可能会阻止其他代码在更关键的时间运行。</p><p id="5927" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果任何必需的模块或依赖项抛出错误并使服务器崩溃，最好早点发现。</p><h1 id="3a44" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">通过文件夹要求模块，而不是直接文件</h1><p id="e864" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该通过文件夹而不是直接通过文件来要求模块。这是因为如果我们改变模块的文件夹结构，我们不想破坏用户应用程序中的<code class="fe mh mi mj mk b">require</code>表达式。</p><p id="cf3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，以下是好的:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0455" class="mt lf it mk b gy mu mv l mw mx">require('./foo');</span></pre><p id="acf3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是下面就不好了:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5822" class="mt lf it mk b gy mu mv l mw mx">require('./bar/foo');</span></pre><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/79d90c1c38fc67c26f6f86c32dbe3103.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_wzxYmihpYLCxOLb"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@jrcatalano?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰克·卡塔拉诺</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="81d7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用===运算符</h1><p id="b10c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">严格相等操作符<code class="fe mh mi mj mk b">===</code>比<code class="fe mh mi mj mk b">==</code>更好，因为它在比较变量之前不会强制变量的类型。使用<code class="fe mh mi mj mk b">===</code>操作符，两个操作数必须具有相同的类型才能相等。</p><p id="1288" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很好，因为它防止了比较事物时的许多错误。使用<code class="fe mh mi mj mk b">==</code>操作符是不好的，因为像下面这样的表达式都会返回<code class="fe mh mi mj mk b">true:</code></p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="62fd" class="mt lf it mk b gy mu mv l mw mx">null == undefined<br/>false == '0'<br/>0 == ''    <br/>0 == '0'</span></pre><p id="fd63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很多时候，并不是我们想要的。如果我们使用<code class="fe mh mi mj mk b">==</code>操作符，还有许多其他奇怪的边缘情况可能会导致我们的应用程序出错。因此，我们应该使用<code class="fe mh mi mj mk b">===</code>操作符。</p><h1 id="b8f5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用异步Await并避免回调</h1><p id="705a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">由于节点8是LTS，<code class="fe mh mi mj mk b">async</code>和<code class="fe mh mi mj mk b">await</code>是节点中的一个特性。因此，我们应该尽可能用它来连锁承诺。这是一个很好的连锁承诺的简写。</p><p id="17a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">旧的回调API慢慢转化为<code class="fe mh mi mj mk b">fs</code>之类的cord节点模块中的promises API。因此，现在我们可以在自己代码之外的地方使用<code class="fe mh mi mj mk b">async</code>和<code class="fe mh mi mj mk b">await</code>。</p><p id="b07f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了处理<code class="fe mh mi mj mk b">async</code>和<code class="fe mh mi mj mk b">await</code>中的错误，我们可以如下处理错误:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f101" class="mt lf it mk b gy mu mv l mw mx">(async ()=&gt;{<br/>  try {<br/>    await Promise.reject('error')<br/>  }<br/>  catch(ex){<br/>    console.log(ex);<br/>  }<br/>})();</span></pre><p id="9419" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们用<code class="fe mh mi mj mk b">catch</code>块捕获错误并记录<code class="fe mh mi mj mk b">ex</code>的值，该值应该是来自<code class="fe mh mi mj mk b">Promise.reject</code>的<code class="fe mh mi mj mk b">'error'</code>。</p><h1 id="4896" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="d33d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JavaScript中的新构造之所以存在，是因为它们很好。它们使代码更短、更干净。它们使得代码易于阅读和修改。它只是让每个人都乐于用JavaScript编码。像<code class="fe mh mi mj mk b">var</code>这样的旧结构应该从所有代码中删除。应该用<code class="fe mh mi mj mk b">===</code>代替<code class="fe mh mi mj mk b">==</code>。</p></div></div>    
</body>
</html>