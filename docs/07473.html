<html>
<head>
<title>A deep dive into authentication in Elixir Phoenix with phx.gen.auth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用phx.gen.auth深入研究Elixir Phoenix中的身份验证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-deep-dive-into-authentication-in-elixir-phoenix-with-phx-gen-auth-9686afecf8bd?source=collection_archive---------1-----------------------#2021-02-21">https://levelup.gitconnected.com/a-deep-dive-into-authentication-in-elixir-phoenix-with-phx-gen-auth-9686afecf8bd?source=collection_archive---------1-----------------------#2021-02-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5a08676192dd879ee194ed97ffe8dcbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TbwCxAZlZYd0S83IjzSONA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">卡伦·艾姆斯利在<a class="ae kc" href="https://unsplash.com/s/photos/mountains?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="03b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于Elixir，我发现很多时候我在使用一个库做一些事情和滚动自己的解决方案之间左右为难。很多时候，Elixir本身的语言和Phoenix框架的简单性非常适合于实现您自己的解决方案，而不是依赖于第三方解决方案。这与不久前在Ruby工作时的情况大相径庭，在那时，使用gem做任何事情都几乎是一种下意识的反应。你需要附件？使用<a class="ae kc" href="https://github.com/thoughtbot/paperclip" rel="noopener ugc nofollow" target="_blank">回形针</a>。授权？使用<a class="ae kc" href="https://github.com/CanCanCommunity/cancancan" rel="noopener ugc nofollow" target="_blank">康康康</a>。认证？使用<a class="ae kc" href="https://github.com/heartcombo/devise" rel="noopener ugc nofollow" target="_blank">设计</a>。</p><p id="5a18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时候，在Elixir中，没有可以满足您需求的包，或者它们已经过时了。我在过去遇到过几次这种情况，当我能够为一个特定的用例实现自己的直截了当的解决方案时，我感到惊喜。这并不是说优秀的套餐不存在长生不老药。他们确实如此。<a class="ae kc" href="https://hexdocs.pm/ecto/Ecto.html" rel="noopener ugc nofollow" target="_blank"> Ecto </a>绝对惊艳。苦艾酒太棒了。还有很多其他的也很棒。我想说的是，在《长生不老药》里做复杂的事情出奇的容易。</p><p id="ff7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">仙丹和凤凰的认证没什么不同。在我之前参与的项目中，我们用一些<a class="ae kc" href="https://github.com/ueberauth/guardian" rel="noopener ugc nofollow" target="_blank"> Guardian </a>或第三方身份提供商拼凑了自己的身份认证解决方案。在每一种情况下，解决方案都工作得很好，但是我们最终不得不自己写一堆代码。代码本身并不特别复杂，但是如果我们可以使用像devise这样的东西，它会更加复杂。那是几年前的事了，从那以后，Elixir的认证领域有了一些发展，也许最引人注目的是<a class="ae kc" href="https://powauth.com/" rel="noopener ugc nofollow" target="_blank"> Pow </a>。电费单本身是一个健壮、模块化和可扩展的认证和用户管理解决方案。我曾经在一些玩具项目中使用过Pow，它工作得非常好。它做了很多，实际上感觉类似于使用devise的所有电池。虽然Pow和devise都很容易使用，但它们的背后相当复杂。</p><p id="f285" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我不完全理解我的应用程序的核心方面时，我会有点不舒服。虽然我可以花时间钻研Pow的内部工作，但我更愿意花时间来确保我为我的用户实现了正确的解决方案。几个月前，我听说了一种针对Elixir的新身份验证解决方案，它也有同样的想法。这个解决方案起源于何塞·瓦里姆在凤凰城回购协议上的<a class="ae kc" href="https://github.com/dashbitco/mix_phx_gen_auth_demo/pull/1" rel="noopener ugc nofollow" target="_blank">拉请求。José在这篇博客文章</a>中描述了他拉请求<a class="ae kc" href="https://dashbit.co/blog/a-new-authentication-solution-for-phoenix" rel="noopener ugc nofollow" target="_blank">背后的动机，但是，从本质上来说，它是为了展示如何将一个简单、透明和直接的身份验证解决方案添加到一个具有最小外部依赖性的准系统Phoenix应用程序中，或者用他的话说:</a></p><blockquote class="lb lc ld"><p id="2450" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">我意识到最好的认证框架是<em class="iq">根本没有认证框架</em>。何塞·瓦里姆</p></blockquote><p id="6373" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从那以后，<a class="ae kc" href="https://github.com/aaronrenner" rel="noopener ugc nofollow" target="_blank"> Aaron Renner </a>把José原来的PR变成了一个包，<a class="ae kc" href="https://github.com/aaronrenner/phx_gen_auth" rel="noopener ugc nofollow" target="_blank"> phx.gen.auth </a>。</p><p id="b7a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与devise和Pow不同，phx.gen.auth是一个代码生成器。phx.gen.auth不是将模型的一部分隐藏在库的内部，而是生成一些基本文件，任何在Phoenix工作过的人都会熟悉这些文件。</p><p id="8fd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们试一试，看看它会产生什么。</p><p id="e111" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要开始，您需要一个Phoenix应用程序。只要在系统上安装了Elixir和Erlang，就可以通过运行以下命令创建一个新的Phoenix应用程序:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="6929" class="lr ls iq ln b gy lt lu l lv lw">$ mix phx.new &lt;your_app_name&gt;</span></pre><p id="8b2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，如果你正在使用<code class="fe lx ly lz ln b">asdf</code>，你可以按照这里关于<a class="ae kc" href="https://carlyleec.medium.com/create-an-elixir-phoenix-app-with-asdf-e918649b4d58" rel="noopener">如何用asdf </a>创建仙丹凤凰app的说明<a class="ae kc" href="https://carlyleec.medium.com/create-an-elixir-phoenix-app-with-asdf-e918649b4d58" rel="noopener">。</a></p><p id="0964" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在设置完Phoenix应用程序后，您可以通过将phx.gen.auth作为依赖项添加到您的<code class="fe lx ly lz ln b">mix.exs</code>中，开始向您的应用程序添加身份验证。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="e829" class="lr ls iq ln b gy lt lu l lv lw">def deps do<br/>  [<br/>    {:phx_gen_auth, "~&gt; 0.6", only: [:dev], runtime: false},<br/>    ...<br/>  ]<br/>end</span></pre><p id="f09a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后安装它，并重新编译依赖项。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="c8cd" class="lr ls iq ln b gy lt lu l lv lw">$ mix deps.get<br/>$ mix deps.compile</span></pre><p id="add7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以用下面的命令运行生成器了:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="585a" class="lr ls iq ln b gy lt lu l lv lw">$ mix phx.gen.auth Accounts User users</span></pre><p id="0128" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我们告诉生成器，我们希望将我们的认证上下文命名为<code class="fe lx ly lz ln b">Accounts</code>，我们的用户模式命名为<code class="fe lx ly lz ln b">User</code>，我们的用户表命名为<code class="fe lx ly lz ln b">users</code>。</p><p id="c5de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这会生成一些文件，并为我们更新一些现有的代码。首先，它添加了一个新的依赖项<code class="fe lx ly lz ln b">bcrypt_elixir</code>。因此，让我们在做其他事情之前先安装它:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="5d0e" class="lr ls iq ln b gy lt lu l lv lw">$ mix deps.get</span></pre><p id="d956" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了。接下来，它添加了一个迁移来创建我们的<code class="fe lx ly lz ln b">users</code>表和<code class="fe lx ly lz ln b">users_tokens</code>表。让我们运行迁移来创建这些表。如果您还没有创建数据库，请确保首先运行<code class="fe lx ly lz ln b">mix ecto create</code>，并且不要忘记确保您已经在<code class="fe lx ly lz ln b">config/dev.exs</code>和<code class="fe lx ly lz ln b">config/test.exs</code>中为您的本地数据库设置更新了数据库配置😉。要迁移数据库，请运行:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="22ba" class="lr ls iq ln b gy lt lu l lv lw">$ mix ecto.migrate</span></pre></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="3f20" class="mh ls iq bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">查看生成的UI</h1><p id="3498" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">生成器创建控制器和模板以及认证逻辑。让我们来看看我们用发电机得到了什么。您可以使用以下命令运行服务器:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="c00f" class="lr ls iq ln b gy lt lu l lv lw">$ mix phx.server</span></pre><p id="de1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你在一个新的Phoenix应用上运行生成器，你的主页应该是这样的:</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/e2249e325c411d36dc3c533f7f7e785d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IJjOhqE_tJGeCjHo5K9OHA.png"/></div></div></figure><p id="32da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，在页面顶部，我们有一些到<code class="fe lx ly lz ln b">Register</code>和<code class="fe lx ly lz ln b">Log in</code>的链接。我们可以点击<code class="fe lx ly lz ln b">Register</code>创建一个新用户。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/4feccd252430cec3fbe84dbdcf7263f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KbDu2b8Myvo2Y63i_TDjtA.png"/></div></div></figure><p id="9c34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太棒了。一张登记表！正是我一直想要的。填完表格并注册后，看看你的控制台。您应该会看到如下所示的消息:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="8c38" class="lr ls iq ln b gy lt lu l lv lw">==============================</span><span id="7328" class="lr ls iq ln b gy nl lu l lv lw">Hi <a class="ae kc" href="mailto:cam@example.com" rel="noopener ugc nofollow" target="_blank">cam@example.com</a>,</span><span id="2397" class="lr ls iq ln b gy nl lu l lv lw">You can confirm your account by visiting the URL below:</span><span id="a4f1" class="lr ls iq ln b gy nl lu l lv lw"><a class="ae kc" href="http://localhost:4000/users/confirm/2VKEJZ8L1Ms2YTZYukUplCK_lLw99RX-kcWer04f0bs" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/users/confirm/2VKEJZ8L1Ms2YTZYukUplCK_lLw99RX-kcWer04f0bs</a></span><span id="c430" class="lr ls iq ln b gy nl lu l lv lw">If you didn't create an account with us, please ignore this.</span><span id="418a" class="lr ls iq ln b gy nl lu l lv lw">==============================</span></pre><p id="6c69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那是用户确认信息。在安装了像<a class="ae kc" href="https://github.com/thoughtbot/bamboo" rel="noopener ugc nofollow" target="_blank"> Bamboo </a>这样的电子邮件服务后，你可以把它作为电子邮件发送给你的用户。请注意确认页面URL中的标记。回到网页，你应该也注意到我们在标题、<code class="fe lx ly lz ln b">Settings</code>和<code class="fe lx ly lz ln b">Log Out</code>链接中有了一些新的选项。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/5b3ef9a23c07059412c3e30d28d8fc5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zSD4t68ODraZ-Hs7YNuMCA.png"/></div></div></figure><p id="1658" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们点击<code class="fe lx ly lz ln b">Settings</code>，我们可以选择更改我们的电子邮件或密码。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/bd6530d3f8e6cda96f799459b13059ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PS9n1YUimx6qBCqMqOTmSw.png"/></div></div></figure><p id="3278" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，很酷。这是一个简单但功能强大的用户界面。接下来，我们将更详细地查看下面的代码，以理解phx.gen.auth实际上是如何实现认证逻辑的。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="1b41" class="mh ls iq bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">到代码中</h1><p id="5243" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">为了概述phx.gen.auth提供的功能，让我们看一下我们的路由器文件(<code class="fe lx ly lz ln b">lib/&lt;app_name_web&gt;/router.ex</code>)。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="a550" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它生成了许多路线和相应的控制器动作。控制器提供了一个很好的关注点分离，我们将在下面依次查看每一个是如何工作的，但是，在我们继续之前，值得指出的是，生成器已经在我们的路由器文件中创建了一些基于路由的授权。注意插头；<code class="fe lx ly lz ln b">require_authenticated_user</code>和<code class="fe lx ly lz ln b">redirect_if_user_is_authenticated</code>。这些都是从<code class="fe lx ly lz ln b">UserAuth</code>模块导入的，该模块提供了一些使用会话和<code class="fe lx ly lz ln b">%Conn{}</code>的实用函数。我们将在下面更详细地查看<code class="fe lx ly lz ln b">UserAuth</code>,但是这里值得注意的是，如果用户已经通过身份验证，某些路由(如注册和登录路由)将如何重定向。有道理，对吧？其他途径，如更改用户的设置，需要对用户进行身份验证。酷吗？好吧，继续。</p><h1 id="04dc" class="mh ls iq bd mi mj nq ml mm mn nr mp mq mr ns mt mu mv nt mx my mz nu nb nc nd bi translated">用户注册</h1><p id="a0a5" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">如果我们看一下我们的<code class="fe lx ly lz ln b">UserRegistrationController</code>模块，你可以看到它公开了两个动作:<code class="fe lx ly lz ln b">new/2</code>和一个<code class="fe lx ly lz ln b">create/2</code>。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="331c" class="lr ls iq bd mi nv nw dn mm nx ny dp mq ko nz oa mu ks ob oc my kw od oe nc of bi translated"><code class="fe lx ly lz ln b">UserRegistrationController.</code>新/2</h2><p id="d7ee" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated"><code class="fe lx ly lz ln b">new/2</code>动作非常简单。它接受一个<code class="fe lx ly lz ln b">%Conn{}</code>，从<code class="fe lx ly lz ln b">Accounts</code>上下文中获得一个带有空<code class="fe lx ly lz ln b">%User{}</code>结构的注册变更集，并在<code class="fe lx ly lz ln b">new.html</code>模板中呈现注册表单。没有什么太令人惊讶的。</p><h2 id="2b18" class="lr ls iq bd mi nv nw dn mm nx ny dp mq ko nz oa mu ks ob oc my kw od oe nc of bi translated"><code class="fe lx ly lz ln b">UserRegistrationController.</code>创建/2</h2><p id="cadd" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated"><code class="fe lx ly lz ln b">create/2</code>动作取注册表中提交的<code class="fe lx ly lz ln b">%Conn{}</code>和<code class="fe lx ly lz ln b">user_params</code>并传递给<code class="fe lx ly lz ln b">Accounts.register_user/1</code>。让我们看看<code class="fe lx ly lz ln b">Accounts.register_user/1</code>。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="253e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它用一个空的<code class="fe lx ly lz ln b">%User{}</code>结构和从注册表单提交的参数创建一个注册变更集。然后，它将一个新的用户记录插入到数据库的<code class="fe lx ly lz ln b">users</code>表中。到目前为止一切顺利。基本的凤凰元素，对吧？在我们继续之前，让我们看一下<code class="fe lx ly lz ln b">User</code>模式文件，并检查用户是如何定义的，以及<code class="fe lx ly lz ln b">User.registration_changeset/3</code>函数在做什么。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e32d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到,<code class="fe lx ly lz ln b">User</code>模式是用一个虚拟密码字段定义的，这意味着<code class="fe lx ly lz ln b">%User{}</code>结构上的<code class="fe lx ly lz ln b">password</code>字段是一个派生字段，它不会持久存储在数据库中。然而，<code class="fe lx ly lz ln b">hashed_password</code>是持久的。除此之外，我们还有一个<code class="fe lx ly lz ln b">email</code>字段和一个<code class="fe lx ly lz ln b">confirmed_at</code>字段。关于模式最后要指出的一点是，由于<code class="fe lx ly lz ln b">password</code>字段存储在<code class="fe lx ly lz ln b">%User{}</code>结构上，至少在内存中，我们需要小心不要意外泄露密码。为了在某种程度上降低风险，<code class="fe lx ly lz ln b">@derive</code>属性用于确保在<code class="fe lx ly lz ln b">%User{}</code>上执行<code class="fe lx ly lz ln b">Inspect</code>协议时，例如当您调用<code class="fe lx ly lz ln b">IO.inspect(%User{})</code>时，密码不会泄露。</p><p id="3369" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lx ly lz ln b">registration_changeset/3</code>函数接受一个<code class="fe lx ly lz ln b">%User{}</code>结构、一些属性的映射和一个选项的关键字列表。这些属性应该如下所示:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="48c6" class="lr ls iq ln b gy lt lu l lv lw">%{"email" =&gt; "me@example.com", "password" =&gt; "some_password"}</span></pre><p id="b133" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该函数将属性转换成一个变更集，然后通过<code class="fe lx ly lz ln b">validate_email/1</code>和<code class="fe lx ly lz ln b">validate_password/2</code>管道传输该变更集。这里需要注意的一件很酷的事情是<code class="fe lx ly lz ln b">opts</code>关键字列表是如何传递给<code class="fe lx ly lz ln b">validate_password/2</code>的。<code class="fe lx ly lz ln b">opts</code>关键字列表可以<em class="le">可选</em>包含<code class="fe lx ly lz ln b">[:hash_password, false]</code>。这防止了<code class="fe lx ly lz ln b">validate_password/2</code>将<code class="fe lx ly lz ln b">hashed_password</code>添加到变更集中。这种灵活性对于使用LiveView进行动态表单验证非常有用，并且不需要两个单独的变更集函数。phx.gen.auth生成器实际上并不生成任何LiveView代码，但它是一些很好的预见。如果<code class="fe lx ly lz ln b">[:hash_password, false]</code>不在<code class="fe lx ly lz ln b">opts</code>中，那么<code class="fe lx ly lz ln b">maybe_hash_password/2</code>将把散列密码作为变更集上的一个变更。<a class="ae kc" href="https://hexdocs.pm/bcrypt_elixir/Bcrypt.html" rel="noopener ugc nofollow" target="_blank"> Bcrypt </a>库的<code class="fe lx ly lz ln b">hash_pwd_salt/1</code>被用来处理随机生成的salt的散列。这里还要注意的一点是，<code class="fe lx ly lz ln b">confirmed_at</code>字段没有被修改。下面关于用户确认的部分将更多地处理这个字段，但是这个字段确实给了你为已确认和未确认的用户实现定制体验的机会。</p><p id="d6e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">酷，好的。但是，我们实际上还没有完成控制器中的<code class="fe lx ly lz ln b">create/2</code>功能。如果对<code class="fe lx ly lz ln b">Accounts.register_user/2</code>的调用由于某种原因失败，可能是数据库中已经存在一封电子邮件或者密码不够长，那么将返回一个包含变更集的<code class="fe lx ly lz ln b">:error</code>元组。在这种情况下，变更集随后被传递回视图，以便可以在模板中呈现错误。如果对<code class="fe lx ly lz ln b">Accounts.register_user/2</code>的调用成功，那么将返回一个带有<code class="fe lx ly lz ln b">%User{}</code>结构的<code class="fe lx ly lz ln b">:ok</code>元组。接下来会发生两件事。首先，调用<code class="fe lx ly lz ln b">Accounts.deliver_user_confirmation_instructions/2</code>，然后用户通过调用<code class="fe lx ly lz ln b">UserAuth.log_in_user/3</code>实际登录。</p><p id="a995" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们先看看<code class="fe lx ly lz ln b">Accounts.deliver_user_confirmation_instructions/2</code>。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="468e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该功能有<code class="fe lx ly lz ln b">%User{}</code>和<code class="fe lx ly lz ln b">confirmation_url_fun</code>功能。在这种情况下，该函数是一个围绕<code class="fe lx ly lz ln b">Routes</code>路径函数的匿名函数，该函数只返回确认页面的路径，该路径是用传递给匿名函数的任何内容参数化的，在这种情况下，该路径将是由<code class="fe lx ly lz ln b">UserToken.build_email_token/2</code>生成的令牌。😅听起来比实际情况要复杂得多。无论如何，这个函数第一次使用了我们所看到的<code class="fe lx ly lz ln b">UserToken</code>模式。简而言之，让我们看看<code class="fe lx ly lz ln b">UserToken</code>模式是如何定义的，以及用户确认令牌是如何生成的。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="6cef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lx ly lz ln b">UserToken</code>模式包含一个<code class="fe lx ly lz ln b">token</code>、一个<code class="fe lx ly lz ln b">context</code>和<code class="fe lx ly lz ln b">sent_to</code>字段。<code class="fe lx ly lz ln b">token</code>字段存储原始的或散列的随机生成的二进制令牌。<code class="fe lx ly lz ln b">context</code>字段可以包含以下任意一个字符串:<code class="fe lx ly lz ln b">["confirm", "reset_password", "session"]</code>或基于用户电子邮件的动态字符串，如<code class="fe lx ly lz ln b">"change:me@example.com"</code>。最后，<code class="fe lx ly lz ln b">sent_to</code>为电子邮箱地址。函数<code class="fe lx ly lz ln b">build_email_token/2</code>获取一个用户和一个上下文，在这种情况下是<code class="fe lx ly lz ln b">"confirm"</code>，并返回一个元组，第一项是base64 URL编码的令牌和包含该令牌的哈希版本的<code class="fe lx ly lz ln b">%UserToken{}</code>结构。令牌的哈希版本将保存在<code class="fe lx ly lz ln b">user_tokens</code>表中的数据库中，而base64 URL编码版本将包含在发送给用户的确认页面URL中。</p><p id="7fa0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们跳回<code class="fe lx ly lz ln b">Accounts.deliver_user_confirmation_instructions/2</code>，我们可以看到新创建的<code class="fe lx ly lz ln b">%UserToken{}</code>被插入到数据库中，base64 URL编码的令牌被传递给<code class="fe lx ly lz ln b">confirmation_url_fun</code>函数，其结果被传递给<code class="fe lx ly lz ln b">UserNotifier.deliver_confirmation_instructions/2</code>。生成的<code class="fe lx ly lz ln b">deliver_confirmation_instructions/2</code>函数在这一点上没有做太多事情。它只是向控制台记录一条消息，但是<code class="fe lx ly lz ln b">UserNotifier</code>中的<code class="fe lx ly lz ln b">deliver/2</code>函数可以用来调用<a class="ae kc" href="https://hexdocs.pm/bamboo/readme.html#delivering-emails-in-the-background" rel="noopener ugc nofollow" target="_blank"> Bamboo </a>的一些实现。</p><p id="c313" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，为了在用户注册控制器中实际完成<code class="fe lx ly lz ln b">create/2</code>动作，用户登录并通过调用<code class="fe lx ly lz ln b">UserAuth.log_in_user/3</code>创建一个新会话。我将在下面详细介绍这一点。</p><h1 id="cb44" class="mh ls iq bd mi mj nq ml mm mn nr mp mq mr ns mt mu mv nt mx my mz nu nb nc nd bi translated">用户会话</h1><p id="c016" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated"><code class="fe lx ly lz ln b">UserSessionController</code>模块通过创建和销毁会话来处理用户登录和退出应用程序。会话控制器公开了三个动作:<code class="fe lx ly lz ln b">new/2</code>、<code class="fe lx ly lz ln b">create/2</code>和<code class="fe lx ly lz ln b">delete/2</code>。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="3e8a" class="lr ls iq bd mi nv nw dn mm nx ny dp mq ko nz oa mu ks ob oc my kw od oe nc of bi translated"><code class="fe lx ly lz ln b">UserSessionController.</code>新/2</h2><p id="57f4" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated"><code class="fe lx ly lz ln b">new/2</code>动作除了在<code class="fe lx ly lz ln b">new.html</code>模板中呈现签到表单之外什么也不做。请注意，我们没有使用变更集来创建表单，而是在为<code class="fe lx ly lz ln b">%Conn{}</code>分配的赋值中传递了一个<code class="fe lx ly lz ln b">:error_message</code>。</p><h2 id="7c29" class="lr ls iq bd mi nv nw dn mm nx ny dp mq ko nz oa mu ks ob oc my kw od oe nc of bi translated"><code class="fe lx ly lz ln b">UserSessionController.</code>创建/2</h2><p id="fa57" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated"><code class="fe lx ly lz ln b">create/2</code>动作从登录表单中获取<code class="fe lx ly lz ln b">user_params</code>，并试图通过调用<code class="fe lx ly lz ln b">Accounts.get_user_by_email_and_password/2</code>来获得一个用户。如果找不到用户，<code class="fe lx ly lz ln b">new.html</code>模板会显示一条故意含糊的一般性错误消息。如果找到用户，则通过调用<code class="fe lx ly lz ln b">UserAuth.log_in_user/3</code>登录。在我们看这个函数之前，让我们看看如何在<code class="fe lx ly lz ln b">Accounts.get_user_by_email_and_password/2</code>中获取用户。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1a0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该函数通过用户的电子邮件在数据库中查找用户，然后通过调用<code class="fe lx ly lz ln b">User.valid_password?/2</code>检查用户的密码是否有效。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="6126" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lx ly lz ln b">User.valid_password?/2</code>中，通过调用<code class="fe lx ly lz ln b">Bcrypt.verify_pass/2</code>来验证密码。注意，如果没有找到用户，则调用<code class="fe lx ly lz ln b">Bcrypt.no_user_verify/0</code>。这是防止计时攻击的重要防御机制，计时攻击测量身份验证检查所需的时间，以确定用户是否存在。</p><p id="a6ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好，跳回<code class="fe lx ly lz ln b">create/2</code>，进入<code class="fe lx ly lz ln b">UserAuth.log_in_user/3</code>。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="5ef2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再来看<code class="fe lx ly lz ln b">Account.generate_user_session_token/1</code>和<code class="fe lx ly lz ln b">UserToken.build_session_token/1</code>。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="863e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与我们之前看到的确认令牌非常相似，其中为令牌生成了一个随机的二进制文件。但是，这次在将令牌插入数据库之前，不对其进行哈希处理。</p><p id="6fc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好，回到<code class="fe lx ly lz ln b">UserAuth.log_in_user/1</code>，用<code class="fe lx ly lz ln b">%Conn{}</code>创建一个新的会话，会话令牌被添加到会话的assigns中。请注意，还使用会话令牌将一个<code class="fe lx ly lz ln b">:live_socket_id</code>分配给会话的分配者，以便在注销时可以断开LiveView套接字。同样值得注意的是，如果用户单击登录表单上的<code class="fe lx ly lz ln b">:remember_me</code>复选框，令牌也会被签名到一个“记住我”cookie中。最后，<code class="fe lx ly lz ln b">login_in_user/1</code>将用户重定向到<code class="fe lx ly lz ln b">user_return_to</code>或<code class="fe lx ly lz ln b">signed_in_path/1</code>。<code class="fe lx ly lz ln b">user_return_to</code>从哪里来？</p><p id="0842" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还记得在<code class="fe lx ly lz ln b">Router</code>中用于保护认证路由的插头吗？其中之一就是<code class="fe lx ly lz ln b">UserAuth.require_authenticated_user/2</code>。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b308" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果用户没有通过身份验证，它会将他们重定向到登录页面，并将他们的当前路径作为<code class="fe lx ly lz ln b">:user_return_to</code>添加到会话中。这样，我们可以让用户返回到他们在通过身份验证之前试图访问的页面。很好。在我们继续之前还有一件事。您可能会想，“好吧，这就是某人登录的方式，但是我们如何检查某人是否已经登录，以及他们的会话令牌是否有效？”。很高兴你问了。在<code class="fe lx ly lz ln b">Router</code>中使用了另一个插头，我之前没有提到。如果你看一下<code class="fe lx ly lz ln b">Router</code>里的<code class="fe lx ly lz ln b">browser</code>管道，你会看到发电机增加了一个<code class="fe lx ly lz ln b">fetch_current_user</code>插头。这个插头被我们所有的路线使用，并且再次从<code class="fe lx ly lz ln b">UserAuth</code>模块导入。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ff30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该函数首先尝试从会话分配中的<code class="fe lx ly lz ln b">:user_token</code>或签名的“记住我”cookie中的<code class="fe lx ly lz ln b">%Conn{}</code>获取用户令牌。如果它确实找到了一个令牌，那么<code class="fe lx ly lz ln b">:current_user</code>就会得到<code class="fe lx ly lz ln b">%Conn{}'s</code>上的<code class="fe lx ly lz ln b">nil</code>所分配的集合。否则，如果它确实找到了一个令牌，它将尝试通过调用<code class="fe lx ly lz ln b">Accounts.get_user_by_session_token/1</code>和随后的<code class="fe lx ly lz ln b">User.verify_session_token_query/1</code>从该令牌获取一个用户。让我们看看那些函数。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1bdb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查询从<code class="fe lx ly lz ln b">user_tokens</code>表中选择<code class="fe lx ly lz ln b">token</code>匹配给定令牌且<code class="fe lx ly lz ln b">context</code>为<code class="fe lx ly lz ln b">"session"</code>的地方，然后连接<code class="fe lx ly lz ln b">users</code>表，最终返回与用户令牌相关联的用户。对于用户，<code class="fe lx ly lz ln b">fetch_current_user/2</code>将<code class="fe lx ly lz ln b">current_user</code>添加到<code class="fe lx ly lz ln b">%Conn{}'s</code>分配中。这样，管道中稍后使用<code class="fe lx ly lz ln b">%Conn{}</code>的任何东西都可以访问当前用户。好了，这就是创建会话的方法，让我们看看如何使用<code class="fe lx ly lz ln b">delete/2</code>操作来销毁会话。</p><h2 id="5c1e" class="lr ls iq bd mi nv nw dn mm nx ny dp mq ko nz oa mu ks ob oc my kw od oe nc of bi translated"><code class="fe lx ly lz ln b">UserSessionController.</code>删除/2</h2><p id="38e7" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated"><code class="fe lx ly lz ln b">delete/2</code>动作调用<code class="fe lx ly lz ln b">UserAuth.log_out_user/1</code>来破坏用户的会话。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2a9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从会话中检索当前令牌。为了清除任何会话令牌，在调用<code class="fe lx ly lz ln b">Accounts.delete_session_token/1</code>时删除<code class="fe lx ly lz ln b">user_tokens</code>表中包含会话令牌的所有行。删除会话令牌后，它会为任何LiveView套接字连接广播一条<code class="fe lx ly lz ln b">"disconnect"</code>消息。最后，它清除会话，删除remember me cookie，并将用户重定向到<code class="fe lx ly lz ln b">"/"</code>。完成后，用户将被注销，并需要重新认证才能访问任何<code class="fe lx ly lz ln b">require_authenticated_user</code>的路线。</p><p id="0711" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就结束了会话操作。希望现在您对phx.gen.auth如何处理用户进出应用程序有了一些了解。还记得在上面的注册部分，我谈到了发送给用户(或登录到控制台)的确认消息吗？下一节将讨论当用户点击确认消息中的确认链接时会发生什么。</p><h1 id="2899" class="mh ls iq bd mi mj nq ml mm mn nr mp mq mr ns mt mu mv nt mx my mz nu nb nc nd bi translated">用户确认</h1><p id="3b37" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated"><code class="fe lx ly lz ln b">UserConfirmationController</code>模块处理新用户的确认。它公开了三个动作:<code class="fe lx ly lz ln b">new/2</code>、<code class="fe lx ly lz ln b">create/2</code>和<code class="fe lx ly lz ln b">confirm/2</code>。</p><h2 id="2f31" class="lr ls iq bd mi nv nw dn mm nx ny dp mq ko nz oa mu ks ob oc my kw od oe nc of bi translated">UserConfirmationController.new/2</h2><p id="715e" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated"><code class="fe lx ly lz ln b">new/2</code>动作呈现一个页面，供用户重新发送确认电子邮件。表单发布到<code class="fe lx ly lz ln b">create/2</code>动作。</p><h2 id="0be7" class="lr ls iq bd mi nv nw dn mm nx ny dp mq ko nz oa mu ks ob oc my kw od oe nc of bi translated">UserConfirmationController.create/2</h2><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d1ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lx ly lz ln b">create/2</code>动作和我们在<code class="fe lx ly lz ln b">UserRegistrationController.create/2</code>中看到的差不多。通过用户的电子邮件地址从数据库中查找用户，并像注册时一样设置新的确认消息。</p><h2 id="b9f7" class="lr ls iq bd mi nv nw dn mm nx ny dp mq ko nz oa mu ks ob oc my kw od oe nc of bi translated">用户确认控制器.确认/2</h2><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="05bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当用户点击确认消息中的确认链接时，他们将被定向到由<code class="fe lx ly lz ln b">UserConfirmationController.confirm/2</code>动作处理的路径<code class="fe lx ly lz ln b">users/confirm/:token</code>。<code class="fe lx ly lz ln b">confirm/2</code>动作获取URL中参数化的令牌，并试图通过调用<code class="fe lx ly lz ln b">Accounts.confirm_user/1</code>将用户标记为已确认。再来看看<code class="fe lx ly lz ln b">Accounts.confirm_user/1</code>和后续的<code class="fe lx ly lz ln b">UserToken.verify_email_token_query/2</code>。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9346" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lx ly lz ln b">verify_email_token_query</code>比我们之前看到的<code class="fe lx ly lz ln b">verify_session_token_query</code>要复杂一点。在这个查询中，需要对给定的令牌进行URL解码，然后进行哈希运算，然后才能根据数据库中实际存储的内容对其进行查询。如果查询运行时没有返回用户，则返回一个<code class="fe lx ly lz ln b">:error</code>；然而，如果找到一个用户，那么它将被传递给<code class="fe lx ly lz ln b">confirm_user_multi/2</code>事务，该事务将更新用户的<code class="fe lx ly lz ln b">:confirmed_at</code>字段，并从<code class="fe lx ly lz ln b">user_tokens</code>表中删除与该用户相关的任何确认行。回到<code class="fe lx ly lz ln b">confirm/2</code>，不管确认的结果如何，用户都将被重定向到<code class="fe lx ly lz ln b">"/"</code>；但是，如果确认成功，将会显示一条适当的闪烁消息。如果用户已经得到确认，则不会显示任何消息。最后，如果出现错误，会显示相应的错误提示信息。</p><p id="f5b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是用户确认的工作原理。在下一节中，我们将了解phx.gen.auth如何为无法登录的用户重置密码。</p><h1 id="414e" class="mh ls iq bd mi mj nq ml mm mn nr mp mq mr ns mt mu mv nt mx my mz nu nb nc nd bi translated">用户密码重置</h1><p id="803e" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated"><code class="fe lx ly lz ln b">UserResetPasswordController</code>模块处理未认证用户的密码重置。它公开了四个动作:<code class="fe lx ly lz ln b">new/2</code>、<code class="fe lx ly lz ln b">create/2</code>、<code class="fe lx ly lz ln b">edit/2</code>和<code class="fe lx ly lz ln b">update/2</code>。</p><h2 id="743f" class="lr ls iq bd mi nv nw dn mm nx ny dp mq ko nz oa mu ks ob oc my kw od oe nc of bi translated">UserResetPasswordController.new/2</h2><p id="3855" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">这个操作只是呈现一个表单，用户可以通过输入他们的电子邮件请求重置密码。表单发布到<code class="fe lx ly lz ln b">create/2</code>。</p><h2 id="20d1" class="lr ls iq bd mi nv nw dn mm nx ny dp mq ko nz oa mu ks ob oc my kw od oe nc of bi translated">UserResetPasswordController.create/2</h2><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1c4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个功能和我们看到的<code class="fe lx ly lz ln b">UserConfirmationController.create/2</code>很像。它试图通过电子邮件获取用户，并创建一个散列的<code class="fe lx ly lz ln b">"reset_password"</code>令牌，该令牌在<code class="fe lx ly lz ln b">user_reset_password_url</code>中被参数化。然后，用户被重定向到<code class="fe lx ly lz ln b">"/"</code>，并在一条即时消息中得到查看电子邮件的指示。与确认消息一样，<code class="fe lx ly lz ln b">Account.deliver_user_reset_password_instructions/2</code>目前只向控制台记录一条消息。</p><h2 id="0973" class="lr ls iq bd mi nv nw dn mm nx ny dp mq ko nz oa mu ks ob oc my kw od oe nc of bi translated">UserResetPasswordController.edit/2</h2><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7697" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lx ly lz ln b">edit/2</code>动作呈现用于更改用户密码的表单。该表单包含一个<code class="fe lx ly lz ln b">:password_confirmation</code>字段，而注册时没有。这是为了减少注册过程中的摩擦。注意，一个用户正被传递给<code class="fe lx ly lz ln b">Accounts.change_user_password/2</code>。这是从哪里来的？它来自<code class="fe lx ly lz ln b">get_user_by_reset_password_token/2</code>插头，在进行<code class="fe lx ly lz ln b">edit/2</code>和<code class="fe lx ly lz ln b">update/2</code>动作之前<code class="fe lx ly lz ln b">%Conn{}</code>通过该插头。毒品。<code class="fe lx ly lz ln b">Accounts.get_user_by_reset_password_token/1</code>函数的工作方式类似于我们上面看到的通过确认令牌获取用户的方式。在查询数据库之前，必须首先通过URL解码解开给定的令牌，然后对其进行哈希处理。如果没有找到用户，那么用户被重定向到<code class="fe lx ly lz ln b">"/"</code>，显示一个有用的flash消息，并且<code class="fe lx ly lz ln b">%Conn{}</code>被暂停，以便管道中没有其他东西运行。但是，如果找到一个用户，那么更改密码表单将呈现一个由新检索到的用户生成的变更集。</p><h2 id="e86e" class="lr ls iq bd mi nv nw dn mm nx ny dp mq ko nz oa mu ks ob oc my kw od oe nc of bi translated">UserResetPasswordController.update/2</h2><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="aa8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就像<code class="fe lx ly lz ln b">edit/2</code>一样，<code class="fe lx ly lz ln b">%Conn{}</code>通过<code class="fe lx ly lz ln b">get_user_by_reset_password_token/2</code>进行管道传输，这样用户就可以在<code class="fe lx ly lz ln b">update/2</code>中使用。密码重置表中的<code class="fe lx ly lz ln b">user_params</code>被传入<code class="fe lx ly lz ln b">Accounts.reset_user_password/2</code>。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ca24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在事务内部，<code class="fe lx ly lz ln b">reset_user_password/2</code>更新用户的密码，并从<code class="fe lx ly lz ln b">user_tokens</code>表中删除与用户相关联的所有令牌，以确保清除所有会话数据。如果有错误，则将有错误的变更集返回给用户。如果交易成功，则用户被重定向到登录页面。</p><p id="b609" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一节讨论了在用户未经身份验证时重置用户密码的问题。下一节将介绍如何在用户通过身份验证后更改他们的密码和电子邮件地址。</p><h1 id="acc3" class="mh ls iq bd mi mj nq ml mm mn nr mp mq mr ns mt mu mv nt mx my mz nu nb nc nd bi translated">用户设置</h1><p id="df19" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated"><code class="fe lx ly lz ln b">UserSettingsController</code>模块处理已验证用户的电子邮件和密码的更新。它暴露了三个动作:<code class="fe lx ly lz ln b">edit/2</code>、<code class="fe lx ly lz ln b">update/2</code>、<code class="fe lx ly lz ln b">confirm_email/2</code>。</p><h2 id="2a93" class="lr ls iq bd mi nv nw dn mm nx ny dp mq ko nz oa mu ks ob oc my kw od oe nc of bi translated">UserSettingsController.edit/2</h2><p id="958f" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated"><code class="fe lx ly lz ln b">edit/2</code>动作非常简单，它只是在同一个页面上呈现两个表单。一个表单用于更改用户的电子邮件，一个用于更改用户的密码。注意，表单的变更集是用<code class="fe lx ly lz ln b">assign_email_and_password_changesets</code>插件设置的。</p><h2 id="67f4" class="lr ls iq bd mi nv nw dn mm nx ny dp mq ko nz oa mu ks ob oc my kw od oe nc of bi translated">UserSettingsController.update/2</h2><p id="cdd0" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">更新电子邮件和更新密码表单都发送到<code class="fe lx ly lz ln b">update/2</code>动作。函数模式对参数进行匹配，以确定参数来自什么形式。我们先来看看更新密码。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1c2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">发送到<code class="fe lx ly lz ln b">update/2</code>动作的表单包含用户的<code class="fe lx ly lz ln b">current_password</code>和他们想要进行的<code class="fe lx ly lz ln b">password</code>更改。这些与<code class="fe lx ly lz ln b">current_user</code>一起被传递给<code class="fe lx ly lz ln b">Accounts.update_user_password/3</code>。这与我们在上面看到的用于重置密码的<code class="fe lx ly lz ln b">Account.reset_user_password/2</code>几乎相同。这里唯一的区别是，由于用户已经登录，所以在更改密码之前会验证<code class="fe lx ly lz ln b">current_password</code>。就像上面重置密码时一样，<code class="fe lx ly lz ln b">user_tokens</code>表中与用户相关联的所有行都被删除，以确保任何会话数据都被清除。</p><p id="11f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们看一下更新用户的电子邮件。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d3f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">发送到<code class="fe lx ly lz ln b">update/2</code>动作的表单包含用户的<code class="fe lx ly lz ln b">current_password</code>和他们想要进行的<code class="fe lx ly lz ln b">email</code>更改。用户连同<code class="fe lx ly lz ln b">current_password</code>和<code class="fe lx ly lz ln b">email</code>被传递到<code class="fe lx ly lz ln b">Accounts.apply_user_email/3</code>。这个函数创建一个变更集，检查电子邮件是否真的会改变，验证新的电子邮件，并验证<code class="fe lx ly lz ln b">current_password</code>。然后，它不是使用变更集来更新<code class="fe lx ly lz ln b">users</code>表，而是对变更集应用一个<code class="fe lx ly lz ln b">:update</code>操作，返回一个更新的<code class="fe lx ly lz ln b">%User{}</code>结构。这个<code class="fe lx ly lz ln b">%User{}</code>结构和用户之前的电子邮件然后被传递到<code class="fe lx ly lz ln b">Accounts.deliver_update_email_instructions/3</code>。这个函数的行为类似于我们上面看到的其他传递函数。像其他函数一样，它创建一个令牌，该令牌在发送给用户的URL中被参数化(或者现在实际上只是登录到控制台)。但是与上面的函数不同，这个<code class="fe lx ly lz ln b">%UserToken{}</code>的上下文变成了<code class="fe lx ly lz ln b">"change:#{current_email}"</code>。例如，如果我当前的电子邮件是<code class="fe lx ly lz ln b">me@example.com</code>并且我想将其更改为<code class="fe lx ly lz ln b">yeezy@example.com</code>，那么<code class="fe lx ly lz ln b">context</code>将是<code class="fe lx ly lz ln b">change:me@example.com</code>并且<code class="fe lx ly lz ln b">:sent_to</code>字段将是<code class="fe lx ly lz ln b">yeezy@example.com</code>。然后，生成的消息被发送(或记录)到用户的新地址，并带有包含令牌的确认链接。此时，用户的电子邮件在数据库中仍然没有改变。看看<code class="fe lx ly lz ln b">confirm_email/2</code>是如何更新的。</p><h2 id="994d" class="lr ls iq bd mi nv nw dn mm nx ny dp mq ko nz oa mu ks ob oc my kw od oe nc of bi translated">user settings controller . confirm _ email/2</h2><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="79f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lx ly lz ln b">confirm_email/2</code>从参数中取出我们上面讨论过的令牌，并将其与<code class="fe lx ly lz ln b">current_user</code>一起传递给<code class="fe lx ly lz ln b">Accounts.update_user_email/2</code>。记住，<code class="fe lx ly lz ln b">current_user</code>还有旧邮件。所以在我上面的例子中，它仍然是<code class="fe lx ly lz ln b">me@example.com</code>。在<code class="fe lx ly lz ln b"> update_user_email/2</code>中，它用<code class="fe lx ly lz ln b">"change:#{user.email}"</code>构建了一个<code class="fe lx ly lz ln b">context</code>字符串，并用它和令牌一起查询<code class="fe lx ly lz ln b">%UserToken{}</code>。与我们上面看到的其他电子邮件验证查询类似，令牌必须经过URL解码和哈希处理，然后才能在查询中使用。一旦<code class="fe lx ly lz ln b">%UserToken{}</code>被取回。上面示例中的<code class="fe lx ly lz ln b">UserToken.sent_to</code>、<code class="fe lx ly lz ln b">yeezy@example.com</code>的值可以传递给一个事务函数，该函数最终更新<code class="fe lx ly lz ln b">users</code>表中的用户，并从<code class="fe lx ly lz ln b">user_tokens</code>表中删除用户和<code class="fe lx ly lz ln b">"change:#{user.email}"</code> <code class="fe lx ly lz ln b">context</code>的所有行。如果一切正常，那么用户将被重定向到用户设置页面。如果出现问题，则会显示一条带有一般错误消息的flash消息，用户仍会被重定向到用户设置页面。</p><p id="93e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用户设置到此为止。</p><h1 id="05bf" class="mh ls iq bd mi mj nq ml mm mn nr mp mq mr ns mt mu mv nt mx my mz nu nb nc nd bi translated">包扎</h1><p id="7d7d" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">这可能有点太深奥了，但是18分钟或者不管你花了多长时间读完这篇文章，真的不算太长。而且，我打赌你现在对phx.gen.auth已经有了相当好的理解；足够了，跳到你自己的代码，让你的应用程序的认证解决方案成为你自己的，让它对你的用户来说棒极了。最终，Elixir Phoenix中的phx.gen.auth和authentication真的没有那么可怕。主要是长生不老药和凤凰…这很简单😏。如果你有任何问题或意见，请在下面的评论中告诉我。</p></div></div>    
</body>
</html>