<html>
<head>
<title>Build your own Motion Detector using a Web Cam and Open CV in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用网络摄像头构建自己的运动检测器，并在Python中打开CV</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-your-own-motion-detector-using-webcam-and-opencv-in-python-ff5bdb78a55e?source=collection_archive---------1-----------------------#2020-03-31">https://levelup.gitconnected.com/build-your-own-motion-detector-using-webcam-and-opencv-in-python-ff5bdb78a55e?source=collection_archive---------1-----------------------#2020-03-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/></div><div class="ab cl jq jr hx js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="im in io ip iq"><p id="8949" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi kv translated"><span class="l kw kx ky bm kz la lb lc ld di"> M </span>运动检测是指检测物体相对于其周围环境的位置变化，反之亦然。系好安全带，和我以及你可爱的蟒蛇一起穿过这个运动探测器应用程序。</p><p id="ed43" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您可以使用该应用程序执行以下任务，尽管列表并不完整:<em class="le"> 1)在家工作时，在屏幕前寻找时间。2)监控孩子在屏幕前的时间。3)发现有人闯入你的后院。4)在你的房间/房子/小巷等周围找到不需要的公共/动物活动。</em></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/413bbfd1db7fdb2f909f176dbdf95553.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DLU-jyeLs1cKC-tF"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">照片由<a class="ae lv" href="https://unsplash.com/@williamauto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">威廉·托马斯</a>在<a class="ae lv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d268" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="le">硬件要求:安装了网络摄像头或任何类型摄像头的计算机。</em></p><p id="7fce" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="le">软件要求:Python 3以上。</em></p><p id="8e69" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="le">附加要求:30分钟的时间，对主题的热情</em></p></div><div class="ab cl jq jr hx js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="im in io ip iq"><p id="5b22" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我将指导您一步一步地构建应用程序。首先，你将通过网络摄像头捕捉第一帧。该帧将被视为<strong class="jz iu">基线帧</strong>。运动将通过<strong class="jz iu">计算该基线帧和带有一些物体的新帧之间的相位差</strong>来检测。新帧将被称为<strong class="jz iu"> <em class="le">增量帧</em> </strong>。</p><p id="e09c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后你将使用<strong class="jz iu">像素强度</strong>来优化你的delta帧。细化后的帧将被称为<strong class="jz iu"> <em class="le">阈值帧</em> </strong>。然后你将应用一些复杂的图像处理技术，如<strong class="jz iu"> <em class="le">阴影去除、膨胀、轮廓</em> </strong>等。在阈值帧上捕捉实体对象。下面是您将要实现的目标的截图:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/2495069eec2c4e23fe3fff9a557516cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*LQGtzvWVbzNoEPvzb9Rk4Q.jpeg"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">检测到的对象</figcaption></figure><p id="ecfe" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当一个物体进入和退出画面时，你将能够捕捉到<strong class="jz iu">时间戳</strong>。因此，你将能够找到屏幕上的时间。</p><blockquote class="lx ly lz"><p id="4004" class="jx jy le jz b ka kb kc kd ke kf kg kh ma kj kk kl mb kn ko kp mc kr ks kt ku im bi translated">我不会在这里嵌入我的代码，因为我希望你能改善指尖的血液循环。</p></blockquote><p id="4a6f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">从基础安装开始，请通过pip 安装python 3或以上版本、<em class="le"> pandas、</em>和<em class="le"> opencv。完成后，您就可以开始了:</em></p><blockquote class="lx ly lz"><p id="0d57" class="jx jy le jz b ka kb kc kd ke kf kg kh ma kj kk kl mb kn ko kp mc kr ks kt ku im bi translated"><strong class="jz iu">第一步:导入所需的库:</strong></p></blockquote><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi md"><img src="../Images/3e125bee3a9b1111fdd0ed8d76581720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fx6m2ackedZkuPg3pO-TAw.jpeg"/></div></div></figure><blockquote class="lx ly lz"><p id="8dc3" class="jx jy le jz b ka kb kc kd ke kf kg kh ma kj kk kl mb kn ko kp mc kr ks kt ku im bi translated"><strong class="jz iu">步骤2:初始化变量、列表、数据帧:</strong></p></blockquote><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi me"><img src="../Images/09850e3603d5d7ad20e881dbbb8dce6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RromVxquPfIzhTGLyhP7CQ.jpeg"/></div></div></figure><p id="5092" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你会知道在下面的代码中什么时候需要上面的每一个。</p><blockquote class="lx ly lz"><p id="5889" class="jx jy le jz b ka kb kc kd ke kf kg kh ma kj kk kl mb kn ko kp mc kr ks kt ku im bi translated"><strong class="jz iu">第三步:用网络摄像头捕捉视频画面:</strong></p></blockquote><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mf"><img src="../Images/d18ef834e007d40b9a975eace8f2acef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-gjlybAUKekjUttjvZcYwQ.jpeg"/></div></div></figure><p id="38f9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">OpenCV内置了打开相机和捕捉视频帧的功能。“0”表示计算机硬件端口号为0的摄像头。如果您安装了多个摄像机或外部摄像机或闭路电视系统，您可以相应地提供端口号。</p><blockquote class="lx ly lz"><p id="20a4" class="jx jy le jz b ka kb kc kd ke kf kg kh ma kj kk kl mb kn ko kp mc kr ks kt ku im bi translated"><strong class="jz iu">步骤4:将捕获的帧转换为灰度级，并应用高斯模糊来去除噪声:</strong></p></blockquote><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mg"><img src="../Images/e99cfc9bbd2f2c04ba6d142c468d22be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tcPNND18qhvgc3Zad9JOWw.jpeg"/></div></div></figure><p id="d20e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们将彩色帧转换为灰色帧，因为不需要额外的颜色层。<strong class="jz iu"> <em class="le">高斯模糊</em> </strong>用于图像平滑，进而提高检测精度。在<em class="le">高斯模糊</em>函数中，对于第二个参数，我们定义了<em class="le">高斯核</em>的宽度和高度，对于第三个参数，我们提供了<em class="le">标准偏差</em>值。这些是一组高阶微分定理，因此您可以使用内核大小的标准值(21，21)和标准差0。要了解有关平滑的更多信息，您可以参考:</p><div class="mh mi gp gr mj mk"><a href="https://docs.opencv.org/2.4/doc/tutorials/imgproc/gausian_median_blur_bilateral_filter/gausian_median_blur_bilateral_filter.html" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd iu gy z fp mp fr fs mq fu fw is bi translated">平滑图像-OpenCV 2.4.13.7文档</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">与高斯滤波器类似，双边滤波器也考虑具有权重的相邻像素…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">docs.opencv.org</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my lp mk"/></div></div></a></div><blockquote class="lx ly lz"><p id="f315" class="jx jy le jz b ka kb kc kd ke kf kg kh ma kj kk kl mb kn ko kp mc kr ks kt ku im bi translated"><strong class="jz iu">步骤5:仅捕获第一个灰色帧</strong></p></blockquote><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mz"><img src="../Images/93e66fa2c4133683d00710aff73ced78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vd3E5-FyzAk9DFeY7L6xkw.jpeg"/></div></div></figure><p id="eeb0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">该第一帧将被视为基准帧<strong class="jz iu">。将通过计算该基线帧和包含一些物体的新帧之间的相位差来检测运动。拍摄第一帧时，摄像机前方不应有<strong class="jz iu">和</strong>移动。一旦你得到了第一帧，你就不想再进一步处理第一帧了。因此，如果您想跳过接下来的步骤，请使用<em class="le"> continue </em>语句。</strong></p><blockquote class="lx ly lz"><p id="2242" class="jx jy le jz b ka kb kc kd ke kf kg kh ma kj kk kl mb kn ko kp mc kr ks kt ku im bi translated"><strong class="jz iu">步骤6:创建增量帧和阈值帧</strong></p></blockquote><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi na"><img src="../Images/60c86c30c202651aed0cbc872ec7f5f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ghFbDnWKH3fMyEQATXF-Q.jpeg"/></div></div></figure><p id="92f7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，我们必须找出第一帧和当前帧之间的差异。因此，我们应用<em class="le"> absdiff </em>函数，并将得到的不同帧称为<strong class="jz iu"> delta帧。仅仅发现差异不足以满足我们的用例，因此我们需要定义一个像素阈值，它可以被认为是一个真实的对象。</strong></p><p id="0834" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">作为标准，您可以选择30像素作为<strong class="jz iu">阈值</strong>，并将阈值的颜色定义为白色(颜色代码:255)。<em class="le"> THRESH_BINARY </em>函数返回一个元组值，其中只有第2项([0]为第1项，[1]为第2项)包含结果阈值帧。<strong class="jz iu">二元阈值</strong>函数是一个非连续函数，仅处理2个离散值:0或1。如果摄像机前面没有物体，我们将当前帧的状态视为0；如果摄像机前面有物体，我们将当前帧的状态视为1。</p><p id="502e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">要了解有关阈值图像处理的更多信息，您可以参考:</p><div class="mh mi gp gr mj mk"><a href="https://docs.opencv.org/2.4/modules/imgproc/doc/miscellaneous_transformations.html?highlight=thresh#threshold" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd iu gy z fp mp fr fs mq fu fw is bi translated">杂项图像转换-OpenCV 2.4.13.7文档</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">使用分水岭算法执行基于标记的图像分割。该函数实现了其中一个变量…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">docs.opencv.org</p></div></div><div class="mt l"><div class="nb l mv mw mx mt my lp mk"/></div></div></a></div><blockquote class="lx ly lz"><p id="4c6d" class="jx jy le jz b ka kb kc kd ke kf kg kh ma kj kk kl mb kn ko kp mc kr ks kt ku im bi translated"><strong class="jz iu">第七步:扩张阈值框，在其中寻找像素轮廓</strong></p></blockquote><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nc"><img src="../Images/ce85bd687a5acc34a3c7be43631ab49a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sMf7Te3pp9hdHZDY1BY40A.jpeg"/></div></div></figure><blockquote class="lx ly lz"><p id="4121" class="jx jy le jz b ka kb kc kd ke kf kg kh ma kj kk kl mb kn ko kp mc kr ks kt ku im bi translated"><em class="it">“眼睛总是被光捕捉，但阴影有更多的话要说。”——格莱葛利·马奎尔</em></p></blockquote><p id="fab7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对象的每个部分都会在背景上或自身的其他部分投射阴影。这可能看起来令人困惑。例如，鼻子在你的嘴唇上投下阴影，任何较大的静止物体在它旁边的较小物体上投下阴影，飘动的光源，具有不同发光强度的多个光源，你房间的窗帘，光源的方向和视角等。</p><p id="5406" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这些是在实时捕捉的帧中发现的一些干扰。因此，为了最大限度地减少这类噪声，我们需要对图像进行滤波。在<strong class="jz iu">扩张功能</strong>中，我们可以通过设置迭代次数来设置平滑度。迭代次数越高，越平滑，处理时间就越长。所以，建议保持标准化为3。扩张函数中的“None”参数表示结构化元素，这在我们的场景中是不需要的。</p><p id="21d4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">要了解更多关于扩张的信息，您可以参考:</p><div class="mh mi gp gr mj mk"><a href="https://docs.opencv.org/2.4/modules/imgproc/doc/filtering.html?highlight=dilate#cv2.dilate" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd iu gy z fp mp fr fs mq fu fw is bi translated">图像过滤-OpenCV 2.4.13.7文档</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">本节描述的函数和类用于执行各种线性或非线性过滤操作…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">docs.opencv.org</p></div></div></div></a></div><p id="fca1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一旦帧被过滤，我们必须在我们的帧中找到轮廓。<strong class="jz iu">轮廓</strong>是一条曲线，沿着这条曲线，一个函数在所有点上都有一个恒定值。我们需要当前帧中的轮廓来识别对象的大小和位置。为此，我们将过滤后的帧的副本传递给<em class="le"> findCountors </em>方法。我们使用过滤帧的副本而不是原始帧来寻找轮廓，因为我们不想干扰原始过滤帧。</p><p id="5d76" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里有点棘手，因为您必须将轮廓存储在一个元组中，并且只需要元组的第一个值。请看python 3中声明tuple的语法:(name，_)。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="284f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，我们只需要在我们的过滤层上找到物体的外部轮廓，因为就我们的用例而言，除了极端外部轮廓之外的轮廓是没有用的。我们必须使用一些近似方法来优化恢复轮廓的过程。您可以使用任何曲线近似或曲线插值方法，但我们可以使用<strong class="jz iu">简单链近似规则</strong>，它压缩水平、垂直和对角线段，只留下它们的端点。因此，我们能够非常快速地获得最佳拟合轮廓。要了解更多信息，请参考随附的PDF。</p></div><div class="ab cl jq jr hx js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="im in io ip iq"><blockquote class="lx ly lz"><p id="c6e5" class="jx jy le jz b ka kb kc kd ke kf kg kh ma kj kk kl mb kn ko kp mc kr ks kt ku im bi translated"><strong class="jz iu">步骤8:找到轮廓区域并在矩形中界定端点:</strong></p></blockquote><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nf"><img src="../Images/8fde75547ad8a0ef4f2d7a6ab840e58d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qC9xgBDQ28T4C5bYjiKPPg.jpeg"/></div></div></figure><p id="a07f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们不想捕捉像昆虫这样的小物体，而是捕捉像人/动物这样的大物体。这可以通过使用<strong class="jz iu">轮廓区域</strong>的概念来定制。这里，我们跳过那些面积小于<strong class="jz iu">10000像素</strong>的物体。对于大于此的区域轮廓，我们设置状态=1，即物体被检测到。</p><p id="b10b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">要了解图像处理中的轮廓，您可以参考:</p><div class="mh mi gp gr mj mk"><a href="https://docs.opencv.org/2.4/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html?highlight=findcontours#findcontours" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd iu gy z fp mp fr fs mq fu fw is bi translated">结构分析和形状描述符-OpenCV 2.4.13.7文档</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">绘制轮廓或填充轮廓。该函数在图像中绘制轮廓或填充区域…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">docs.opencv.org</p></div></div><div class="mt l"><div class="ng l mv mw mx mt my lp mk"/></div></div></a></div><p id="7705" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们现在使用<em class="le"> boundingRect </em>函数捕捉轮廓的坐标。然后，我们使用这些坐标在彩色框架上绘制一个所需颜色和厚度的矩形。这个矩形描绘了实际检测到的对象。</p><blockquote class="lx ly lz"><p id="e296" class="jx jy le jz b ka kb kc kd ke kf kg kh ma kj kk kl mb kn ko kp mc kr ks kt ku im bi translated"><strong class="jz iu">第九步:捕捉物体进出画面时的时间戳:</strong></p></blockquote><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nh"><img src="../Images/d8486ebbcc0a31d50fef1bb281b4c6a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fhTdcfn2JmGKw33y4SQTww.jpeg"/></div></div></figure><p id="a846" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">status_list存储值0:未检测到物体和1:检测到物体。该状态值从0变为1的时刻:对象进入帧的那一刻。类似地，当这个状态值从1变到0的时刻:物体从帧中消失的时刻。因此，我们从状态列表的最后两个值中捕获这两个<strong class="jz iu">触发事件</strong>的时间戳。</p><blockquote class="lx ly lz"><p id="c837" class="jx jy le jz b ka kb kc kd ke kf kg kh ma kj kk kl mb kn ko kp mc kr ks kt ku im bi translated"><strong class="jz iu">第十步:真正的魔术:显示所有不同的画面</strong></p></blockquote><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ni"><img src="../Images/e15cac02fbe2e370b5c91d3f2be1a306.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I-lOsrX5O5-q8ys17h9oAA.jpeg"/></div></div></figure><p id="f461" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">使用<em class="le"> imshow </em>方法，您将能够在单独的窗口中显示每一帧并比较它们。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nj"><img src="../Images/ff476b4cf3954c782e878b8db9dad1ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tapkymZqrl0hmhdAGCQ56g.jpeg"/></div></div></figure><p id="83ec" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们使用<em class="le">等待键</em>功能来延迟该过程，直到按下一个键。这里，为了从摄像机获得连续的实时反馈，我们使用waitKey(1)。当您只想停止拍摄视频时，只需按键盘上的“<strong class="jz iu"> Q </strong>键。</p><p id="6a62" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们还必须捕获按下“Q”时的最后一个时间戳，因为这将导致程序结束从摄像机捕获视频，并在稍后生成时间数据。</p><p id="fe73" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">下面是使用该应用程序生成的实际图像输出。第一幅图像表示基线帧的4种类型的帧，第二幅图像表示具有对象的帧的4种类型的帧。你能比较一下区别吗？</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nk"><img src="../Images/0316c7c85d1e50cbefb11cc46d86fc3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FMUgK4S7IvXuzHv7ENuX9g.jpeg"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">基线第一帧</figcaption></figure><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nk"><img src="../Images/cfa1a24a5cea96e34de41d128925aea4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7DQ1ntR6IdTBh-rDsq56og.jpeg"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">带有检测到的对象的帧</figcaption></figure><blockquote class="lx ly lz"><p id="4b84" class="jx jy le jz b ka kb kc kd ke kf kg kh ma kj kk kl mb kn ko kp mc kr ks kt ku im bi translated"><strong class="jz iu">步骤11:生成时间数据</strong></p></blockquote><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nl"><img src="../Images/849a513ff6e297ca8578d29d78b05773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xFC8Z9eF2_mKSHnTAEyIVQ.jpeg"/></div></div></figure><p id="ec2e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">到目前为止，所有的时间戳都存储在熊猫数据帧中。为了深入了解生成的数据，我们将把数据框导出到本地磁盘上的csv文件中。</p><blockquote class="lx ly lz"><p id="4257" class="jx jy le jz b ka kb kc kd ke kf kg kh ma kj kk kl mb kn ko kp mc kr ks kt ku im bi translated">请不要忘记释放视频变量，因为它已经占用了相当多的内存空间。还要销毁所有窗口，以避免出现任何错误。</p></blockquote><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nm"><img src="../Images/97b65bd631a2e018912dc8a498844ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DO_GJ-wCJgrcisumN0i6yQ.jpeg"/></div></div></figure><p id="0ef1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是生成的csv的样子。如你所见，在程序结束之前，这个物体已经被探测了3次。您可以看到开始和结束时间，并计算对象在摄像机前的时间。</p></div><div class="ab cl jq jr hx js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="im in io ip iq"><p id="47df" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个应用还不够刺激吗？这个应用程序不是远离典型的充满无聊的编程吗？物联网爱好者甚至可以在Raspberry-Pi服务器上部署这个程序，创造奇迹！</p><p id="fa05" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">要了解更多关于树莓派的信息，请点击这里:</p><div class="mh mi gp gr mj mk"><a href="https://projects.raspberrypi.org/en/projects/raspberry-pi-getting-started" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd iu gy z fp mp fr fs mq fu fw is bi translated">树莓派入门</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">在这个项目中，你将连接一台Raspberry Pi计算机，看看它能做什么。注意:本指南是一个…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">projects.raspberrypi.org</p></div></div><div class="mt l"><div class="nn l mv mw mx mt my lp mk"/></div></div></a></div></div></div>    
</body>
</html>