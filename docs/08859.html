<html>
<head>
<title>What is the Swift Collections Package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是Swift托收包</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-is-the-swift-collections-package-99527e2b9b8c?source=collection_archive---------12-----------------------#2021-06-12">https://levelup.gitconnected.com/what-is-the-swift-collections-package-99527e2b9b8c?source=collection_archive---------12-----------------------#2021-06-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="02ec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用双端队列、有序集和有序字典来提高性能和简化代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/66c0a9da91391d99d7f3df545ad0205b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VazNBZyaa9_6mbym"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@marcin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Marcin Nowak </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="b5a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将学习如何在一个简单的Xcode游乐场中利用苹果Swift Collections包中的有用数据结构。我们将探索并掌握这些数据结构:</p><ul class=""><li id="f18b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">双端队列</li><li id="b592" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">有序集合</li><li id="3708" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">有序字典</li></ul><h1 id="e19f" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">我们开始吧</h1><p id="d046" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">首先，我们需要将<a class="ae ky" href="https://github.com/apple/swift-collections" rel="noopener ugc nofollow" target="_blank"> Swift托收包</a>添加到我们的项目中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/2e99c30e628b2a5755e58792a4a9d76c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u7030LpYeGx-WH3Knw5xsw.png"/></div></div></figure><p id="badd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们准备将它导入Xcode Playground并开始。</p><h1 id="096c" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">双端队列</h1><p id="d97d" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">让我们创建一个包含<code class="fe nh ni nj nk b">Int</code>项的简单<code class="fe nh ni nj nk b">Deque</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="f574" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">双端队列意味着我们既可以向它追加元素，也可以向它预先添加元素:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a2d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这会产生以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/1372d0f919d98cb292985a1ba17ad22e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQ7X8vZpzbKYGqkgAt3ElQ.png"/></div></div></figure><p id="b4a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最棒的是，<code class="fe nh ni nj nk b">Deque</code>和<code class="fe nh ni nj nk b">Array</code>遵循几乎相同的协议。我们可以很容易地通过索引来更改成员:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="c626" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，该系列会根据我们的需要进行更新:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/7cc8c2d292d112c312b5150444c20952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fHfQo2KhmlAMVFpUH6Lifw.png"/></div></div></figure><p id="661c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以通过使用<code class="fe nh ni nj nk b">popFirst()</code>变异方法方便地删除出列的第一个元素:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="b391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，你可能想知道如果一个<code class="fe nh ni nj nk b">Deque</code>的行为方式和一个<code class="fe nh ni nj nk b">Array</code>一样，那么它有什么用？看看这个简单的操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="c09f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与数组相比，出列的主要优点是<em class="np">预先</em>一个元素或者<em class="np">弹出出列中的第一个元素</em>花费相同的时间，而不管集合中已经有多少元素。</p><p id="bd5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在一个数组中，有更多的元素意味着需要更多的时间来预先计划一个新的元素。</p><p id="5af8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当我们需要一个<em class="np">先进先出</em>队列，或者弹出第一个成员或者预先添加一个新元素时，使用<code class="fe nh ni nj nk b">Dequeue</code>会比<code class="fe nh ni nj nk b">Array</code>更有效。</p><h1 id="ebd5" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">有序集合</h1><p id="8e35" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们要探索的下一个数据结构是一个<code class="fe nh ni nj nk b">OrderedSet</code>。</p><p id="3df9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们初始化一个包含<code class="fe nh ni nj nk b">String</code>项的<code class="fe nh ni nj nk b">OrderedSet</code>并打印其内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="fa0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是控制台向我们展示的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/b113a6355dfb75e0fef99903db77e8df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C6OX_qk4G9TirHehMRF93w.png"/></div></div></figure><p id="0c3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们创建一个包含与上面的<code class="fe nh ni nj nk b">OrderedSet</code>相同元素的普通<code class="fe nh ni nj nk b">Set</code>，我们会看到项目的顺序是随机的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/e552345af3a5c8984577e41fd06ea249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wWBwfdC-zG5IHzqNys1Ldw.png"/></div></div></figure><p id="6cf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用与<code class="fe nh ni nj nk b">Array</code>中相同的一组操作，比如通过索引访问成员，添加新元素，以及使用<code class="fe nh ni nj nk b">.first</code>和<code class="fe nh ni nj nk b">.last </code>属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0ef6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/75b3a58fc279901e7d838158ed2a9a35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*auhVVma7KtXCEounSDaFhg.png"/></div></div></figure><p id="1848" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样方便的是，<code class="fe nh ni nj nk b">OrderedSet</code>可以使用与普通<code class="fe nh ni nj nk b">Set</code>相同的操作:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/ade49401fe5be4790f56ffbe25548db9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fwYlGSBSwiT6RshKhbJiGg.png"/></div></div></figure><p id="4f68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就性能而言，在<code class="fe nh ni nj nk b">OrderedSet</code>上完成的操作与在典型<code class="fe nh ni nj nk b">Set</code>上完成的操作花费的时间大致相同。</p><p id="a070" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当将其性能与<code class="fe nh ni nj nk b">Array</code>进行比较时，无论<code class="fe nh ni nj nk b">Set</code>或<code class="fe nh ni nj nk b">OrderedSet</code>中已经有多少元素，访问集合的成员都要花费相同的时间。</p><p id="c5ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果我们试图在随机位置插入或删除一个元素，<code class="fe nh ni nj nk b">OrderedSet</code>的性能比典型的<code class="fe nh ni nj nk b">Set</code>差。</p><p id="2a71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解更多实际的<code class="fe nh ni nj nk b">Array</code>和<code class="fe nh ni nj nk b">Set</code>有什么不同，请看安托万·范德·李·🇳🇱的<a class="ae ky" href="https://betterprogramming.pub/array-vs-set-fundamentals-in-swift-explained-9c78f3552e52" rel="noopener ugc nofollow" target="_blank">伟大指南</a>。</p><h1 id="7764" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">有序字典</h1><p id="82ee" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们将使用的最后一个数据结构是一个<code class="fe nh ni nj nk b">OrderedDictionary</code>。</p><p id="3923" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从初始化<code class="fe nh ni nj nk b">OrderedDictionary</code>开始，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9ee8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字典被排序意味着我们可以通过索引来访问它的元素。为此我们有一个<code class="fe nh ni nj nk b">elements</code>属性:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/26e75b323cd950f1a0194fe8021d3412.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uGMf906oLpi9EK3hbctgOg.png"/></div></div></figure><p id="f6b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以很容易地遍历字典，看到顺序得到了保持:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/98f80f9b3cfb8fdc2f3689bc4a6c9be8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LpGtLSWFcnh37jlajCqmeg.png"/></div></div></figure><p id="f24d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像本文前面的数据结构一样，<code class="fe nh ni nj nk b">OrderedDictionary</code>仍然可以访问我们在普通<code class="fe nh ni nj nk b">Dictionary</code>上使用的标准方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/3b9eb586e2488b22b5368e4af8ab3e77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TOaQtmRI5N_vugTolf0npw.png"/></div></div></figure></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><h1 id="8653" class="mj mk it bd ml mm og mo mp mq oh ms mt jz oi ka mv kc oj kd mx kf ok kg mz na bi translated">包扎</h1><p id="fc37" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">如需了解更多信息，请随时访问关于Swift Collections的<a class="ae ky" href="https://swift.org/blog/swift-collections/" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><p id="da61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>