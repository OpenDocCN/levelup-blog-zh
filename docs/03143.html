<html>
<head>
<title>Appreciating the ‘new’ Keyword in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">欣赏Javascript中的“新”关键字</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/appreciating-new-keyword-in-javascript-63d517459e9c?source=collection_archive---------17-----------------------#2020-04-21">https://levelup.gitconnected.com/appreciating-new-keyword-in-javascript-63d517459e9c?source=collection_archive---------17-----------------------#2020-04-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/522fd2d0c3e94adb00f95d53f64071e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*quE7TeVlEQRdObdDIznJNg.jpeg"/></div></div></figure><p id="113d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated">我回到了我的第二个博客😃在这一篇中，我将尝试解释我们如何利用“新”来编写更高效的代码。因为清晰度问题，这次我不会用手绘的图表，但是我会用很多图表😝 </p><p id="4d37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们中许多熟悉编写静态类型语言的人，如<strong class="ka ir"> C++/JAVA </strong>，对构成内存分配的<strong class="ka ir">‘new’</strong>关键字有着完全不同的理解。让我们快速修改一下C++中“new”关键字的概念，这样我们就可以完全理解两种语言中<strong class="ka ir">“new”</strong>关键字用法的不同。</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><figure class="lg lh li lj gt jr gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/f748f2d478736c0b8e130df15480212a.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*_TFWwuT-QE5CjfrHGgX5vw.jpeg"/></div></figure><ul class=""><li id="6d67" class="ln lo iq ka b kb kc kf kg kj lp kn lq kr lr kv ls lt lu lv bi translated"><strong class="ka ir"> new' </strong>从空闲存储器中为一个对象分配内存，并返回一个适当类型的非零指针指向该对象。</li><li id="abc5" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated">在我们的示例中，堆中的新内存地址(<strong class="ka ir"> 0x556e76d5fe7 </strong> 0)被分配给一个“指针”，用于存储值“<strong class="ka ir"> 13”。</strong></li><li id="a10d" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated">如果不成功或无法分配内存，则<strong class="ka ir"> new </strong>返回零或抛出异常。</li></ul></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="6755" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们已经理解了在C++中'<strong class="ka ir"> new' </strong>'是如何工作的。“博客结束”。回家吧，伙计们！😛开个玩笑！！</p><p id="45e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，现在让我们暂时把“新”这个关键词放在一边。到那时，我们可以建立一些基础并分析一些场景，这样我们不仅可以理解它，还可以理解它为什么在函数式编程中有用。让我们举一个例子:</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><ul class=""><li id="87fd" class="ln lo iq ka b kb kc kf kg kj lp kn lq kr lr kv ls lt lu lv bi translated">假设我们已经创建了一个<strong class="ka ir">工厂</strong>，用于为特定的应用程序或网站创建新用户。</li><li id="78b8" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated">我们的代码将数据和功能(用户名、密码和登录功能)捆绑在一起，就像用C++/Java编写面向对象的代码一样</li><li id="0de0" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated">一切看起来都很完美，除了这样一个事实:每一个新创建的用户都会有一个 <strong class="ka ir"> <em class="lf">【登录】</em> </strong> <em class="lf">函数的副本，这并不好，因为它每次都会使用额外的内存来存储这个函数😟</em></li></ul><p id="2393" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将尝试使用一些有趣的方法来重构上面的代码，然后我们将使用JavaScript的一些特性来实现同样的目的。</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><ul class=""><li id="188f" class="ln lo iq ka b kb kc kf kg kj lp kn lq kr lr kv ls lt lu lv bi translated">让我们浏览一下代码😃</li></ul><figure class="lg lh li lj gt jr gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/69c87960d07b8f4f8817cb87b37a34bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*aH8I2KGcYeREzErusWIiXA.png"/></div></figure><ul class=""><li id="fb03" class="ln lo iq ka b kb kc kf kg kj lp kn lq kr lr kv ls lt lu lv bi translated">内存是在全局空间中为用户和用户工具分配的</li><li id="2bff" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated">调用功能用户并创建新的<strong class="ka ir">‘执行上下文’</strong>。</li><li id="df8a" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated">Object.create()用于创建一个空对象'<strong class="ka ir"> newUser' </strong>。将' UserUtility '作为Object.create中的一个参数传递，在<strong class="ka ir"> 'newUser' </strong>(隐藏属性<strong class="ka ir"> '__proto__' </strong> ) <strong class="ka ir"> </strong>和UserUtility函数之间创建了一个隐藏链接。</li><li id="1acb" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated">返回新对象'<strong class="ka ir"> newUser' </strong>。</li></ul></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="de0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lf">就是这样。我们已经实现了我们所期待的。</em> <strong class="ka ir"> <em class="lf">干净世故！</em> </strong></p><p id="0fb7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，当我们创建不同的用户时，我们不会为'<strong class="ka ir"> login' </strong>函数分配新的内存空间。每次我们创建一个新用户并尝试调用'<strong class="ka ir"> login '，</strong>它将首先查看登录功能是否可用。如果没有，则检查'<strong class="ka ir"> __proto__' </strong>属性，该属性将链接到包含'<strong class="ka ir"> login' </strong>函数的<strong class="ka ir"> 'UserUtility' </strong>对象。</p><h1 id="1421" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">这种方法非常好，但是我们可以进一步改进</h1><p id="b775" class="pw-post-body-paragraph jy jz iq ka b kb nh kd ke kf ni kh ki kj nj kl km kn nk kp kq kr nl kt ku kv ij bi translated">众所周知，Javascript中的函数是<strong class="ka ir">对象</strong>。Javascript中的每个函数都有一个名为“<strong class="ka ir"> prototype </strong>”的属性。原型是JavaScript中的对象相互继承特性的一种方式。让我们利用这个'<strong class="ka ir">原型</strong>和<strong class="ka ir">'新'</strong>来自动化上面代码中的一些步骤。</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><ul class=""><li id="6b93" class="ln lo iq ka b kb kc kf kg kj lp kn lq kr lr kv ls lt lu lv bi translated">我们将属性<strong class="ka ir">‘登录’</strong>附加到<strong class="ka ir">‘用户’</strong>原型。</li></ul><figure class="lg lh li lj gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/65e282323cd6b010e75e7777714368ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*izn89pwVRS0TvgeeGE-2lQ.png"/></div></figure><ul class=""><li id="dbe3" class="ln lo iq ka b kb kc kf kg kj lp kn lq kr lr kv ls lt lu lv bi translated">一旦<strong class="ka ir">‘执行线程’</strong>在函数调用前遇到‘new’关键字，就会自动创建一个全新的空对象，并将其分配给<strong class="ka ir"> this。</strong></li><li id="1972" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated">属性被分配给这个空对象。(用户名和密码)</li><li id="8be7" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated">创建了一个从这个新对象的<strong class="ka ir"> '__proto__' </strong>属性到User.prototype的隐藏链接。</li><li id="89b3" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated">最后，这个新创建的对象被自动返回。</li></ul></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="e33c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就这样了，伙计们。这就是'<strong class="ka ir"> new' </strong>关键字为我们做的一切。因此，我们通过利用javascript的一些特性，使我们的代码可读性更强，更容易理解。</p><h1 id="7c65" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated"><strong class="ak">今天就到这里😃</strong></h1><p id="e799" class="pw-post-body-paragraph jy jz iq ka b kb nh kd ke kf ni kh ki kj nj kl km kn nk kp kq kr nl kt ku kv ij bi translated">我将继续撰写与JS相关的其他重要概念。也可以在评论里提建议。感谢反馈。</p><p id="adf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个我之前博客的链接，如果你还没有读过的话JavaScript中的<a class="ae nn" rel="noopener ugc nofollow" target="_blank" href="/what-exactly-is-a-closure-in-javascript-1dc6b5e6e375?source=---------2------------------">闭包</a></p><p id="c598" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你也可以和我联系，<a class="ae nn" href="https://www.linkedin.com/in/omkar-nath-mandal/" rel="noopener ugc nofollow" target="_blank">奥姆卡·纳特·曼德尔</a>:)</p></div></div>    
</body>
</html>