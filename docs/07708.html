<html>
<head>
<title>Dijkstra’s shortest path algorithm in a grid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">网格中的Dijkstra最短路径算法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dijkstras-shortest-path-algorithm-in-a-grid-eb505eb3a290?source=collection_archive---------0-----------------------#2021-03-07">https://levelup.gitconnected.com/dijkstras-shortest-path-algorithm-in-a-grid-eb505eb3a290?source=collection_archive---------0-----------------------#2021-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b841" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者如何从开普敦到马加丹</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/2fd0d5470b79d234473a3a6889440f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WSdfDna3IYH6iP4IajK8jg.png"/></div></div></figure><h1 id="a7f8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">我是怎么卷进来的</h1><p id="a60a" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">不久前，我看到脸书一家大型科技公司贴出了一个编程挑战，让人们发送简历。挑战是在一个1000x1000的棋盘上找出短路。棋盘上的每个格子都有一个编号。最短“路径”是组成从一个顶点(比如左上)到另一端(右下)的连续路径的像元值的最低总和。</p><p id="0b68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你所要做的就是提交路径的长度(作为一个单一的数字)，并有很大的机会赢得一个新的XBox或类似的东西(我不记得确切的奖励)。</p><p id="bd39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">阅读挑战让我好奇。一方面，这是一个简单的问题，任何具有基本编码技能的人都应该能够解决。但另一方面，我也明白，有大量的可能路径，一个蛮力的方法不会削减它。</p><p id="891d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以这个问题我想了一个小时左右就不了了之了。我真的希望赢得XBox的人还在享受它。</p><p id="31bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几个月过去了，我看到了一个流传了一段时间的帖子，是关于基于谷歌地图的最长路径的。这让我想起了我在那个编码挑战中看到的问题，我决定回去解决它。</p><p id="4668" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在请把那个XBox给我。</p><h2 id="7a40" class="mb ky iq bd kz mc md dn ld me mf dp lh jy mg mh ll kc mi mj lp kg mk ml lt mm bi translated">问题定义</h2><p id="6cf6" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们有一个矩阵/网格/数组，大小为X除以X(或者XxX，如果可以的话)。每个单元格由一个数字填充(让我们假设它是一个正整数，但它可以是任何数字)。起始单元格和结束单元格的值为零。你从左上角开始，需要到右下角。通过向右、向左、向上或向下滑动(不离开数组)，您只能移动到相邻的单元格。目标是找到使你传递的值的总和最小的路径。下图显示了这种10x10网格的示例。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/1bc42de1f281b5de0e7aaa67284e1761.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*vpdckKfY_ZU0Ubljm9iLRQ.png"/></div></figure><p id="ffab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以及生成该数组的Python代码(我使用了一个随机数生成器，所以您将得到相似但不完全相同的数组):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="4e8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该特定网格的解决方案是<strong class="jp ir"> 116 </strong>，路径标记在下图中:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/d4f20a4542f043e107ed2ef749052b43.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*GyoeVz4ktWr9wMaJPiksxA.png"/></div></figure><p id="2a26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一点上，你可以停止阅读，并试图找出一个解决方案。不，XBox不是承诺，但让我知道你做了什么。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="4852" class="kx ky iq bd kz la mx lc ld le my lg lh li mz lk ll lm na lo lp lq nb ls lt lu bi translated"><strong class="ak">迪杰斯特拉算法</strong></h1><p id="de36" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在地图中寻找两个节点之间的最短路径的问题(一般意义上)到目前为止并不是一个新问题。第一个，也可能是最著名的路径查找算法之一是<a class="ae ma" href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" rel="noopener ugc nofollow" target="_blank"> Dijkstra算法</a>，以其发明者荷兰计算机科学家<a class="ae ma" href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">【艾兹格·迪科斯彻】</strong> </a> <strong class="jp ir">命名。互联网上有许多关于这种算法的资源，但是当我试图找出它的时候，很难找到好的参考资料。我找到的最好的资源是YouTube上的一个由<a class="ae ma" href="https://www.youtube.com/watch?v=GazC3A4OQTE" rel="noopener ugc nofollow" target="_blank"><em class="nc">computer phile</em></a><em class="nc"/>制作的视频。我会尽力解释“Dijkstra”背后的基本概念。我将坚持矩阵问题，而不是更经典的“连通图”案例，所以请确保您观看了上述剪辑。</strong></p><h2 id="d9fc" class="mb ky iq bd kz mc md dn ld me mf dp lh jy mg mh ll kc mi mj lp kg mk ml lt mm bi translated">100字以内的Dijkstra</h2><p id="586e" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">让我们假设我们在地图/矩阵上的给定单元。从这里，我们可以去任何相邻的细胞，只要它没有被访问过。我们检查所有相邻的单元格，并将这些单元格中的数字按降序放入“堆栈”中。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/06d4e4d0dd456ed27261a694b70f53b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*FHAVKGr0bryUuwJS1P5Y7A.png"/></div></figure><p id="d8f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在左边的矩阵中，从红色单元格开始，我们将堆栈排序为3，15，15，19。我将把观察周围细胞的步骤称为“探索阶段”。</p><p id="dfa1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们移动栈顶的单元格。我们向右移动，站在值为3的单元格上。我们重复探索阶段，但现在我们将值10、13和18(这些是“3”周围的值)添加到已经获得的3中。现在我们的筹码是:13，15，15，16，19，21因为3+10，15，15，3+13，19，3+18。现在，我们再次根据堆栈顶部的值移动到值为10的3以上的单元格(位置[2，4])，因为到达那里只“花费”了13。我们将保持这种“探索”——“移动”，再一次向上一步[1，4]，再一次向上一步[0，4]。此时，我们的路径开销为3+10+2+1=16。但是我们栈中最低的数是15(看上面的栈)。因此，我们将“跳转”到值为15的单元格，并从那里继续执行“探索”阶段。</p><p id="c239" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主要思想是，我们保留路径堆栈，并不断探索最短路径，直到它不再是最短路径(在任何给定的“时间点”)，因此我们“跳转”到当前最短路径。我们保持这种探索，直到达到我们的目标，在这一点上，算法停止。</p><p id="1d4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们走的每一步都“记住”我们来自的细胞。这样，在最后我们可以原路返回，直到再次到达原点。例如，我们将“记下”我们从[3，3]移到了[3，4]，从[3，4]移到了[2，4]。</p><p id="de7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总的来说，我们有了原始的“地图”,我们还需要保存一个值的矩阵，其中包含我们到达特定单元格所用的“长度”。最后，我们需要保存一个带有“back step”的数组，它告诉我们从那个单元格移动到了一个特定的单元格。</p><h1 id="dd5e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">让我们编码</h1><p id="666f" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">所以下面是一个非常“非Python”的代码，它是这样写的，所以一切都尽可能清楚。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h2 id="caec" class="mb ky iq bd kz mc md dn ld me mf dp lh jy mg mh ll kc mi mj lp kg mk ml lt mm bi translated">我们来分解一下</h2><p id="f296" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们首先制作“距离图”矩阵、“回溯”<em class="nc">【origin map】</em>数组(为了简单起见，我们将用单个值保存单元的索引)，以及标记我们已经访问过的单元的布尔矩阵。</p><p id="71c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们来看看算法的探索部分。我们观察相邻的细胞。如果“距离图”中的值高于我们当前所在的路径，我们将更新距离图。在探索迭代的末尾，我们更新我们的位置(x，y)。</p><p id="1440" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们到达目的地，我们可以基于“originmap”数组开始回溯我们的步骤。</p><p id="1e16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们再次绘制我们的地图和我们找到的路径。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="00d3" class="kx ky iq bd kz la mx lc ld le my lg lh li mz lk ll lm na lo lp lq nb ls lt lu bi translated">好了</h1><p id="c3d8" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我(凭经验)知道，只看这个帖子你不会理解Dijkstra的算法。最好的解决方法就是自己编码。我就是这么得来的。</p><p id="96bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以生成有趣的地图并找到路径。这和从西伯利亚到南非醒来不一样，但这是一件事。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/7d479be9771ab3748920b1fd4851ced1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*o1W8b29IKRsGP_GWJVnNdQ.png"/></div></figure></div></div>    
</body>
</html>