<html>
<head>
<title>Coroutines and Tasks in Julia and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Julia和Python中的协程和任务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/coroutines-and-tasks-in-julia-and-python-c82f7ec52a9e?source=collection_archive---------3-----------------------#2019-03-19">https://levelup.gitconnected.com/coroutines-and-tasks-in-julia-and-python-c82f7ec52a9e?source=collection_archive---------3-----------------------#2019-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b66cb88bc0b1f5f79a7a6e5e724f002f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*urR1j23ArwwjpQcF"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@coffeegeek?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">咖啡极客</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="7478" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我在谈论Julia和Python 中的<a class="ae kf" href="https://medium.com/@Jernfrost/generators-and-iterators-in-julia-and-python-6c9ace18fa93" rel="noopener">生成器和迭代器时提到的一个话题。在这里，我们将更深入地了解基础知识，以及如何使用它来实现并发性。</a></p><p id="b53e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">比较Julia和Python是很有挑战性的，因为虽然它们都使用协程和任务，但它们呈现给用户的界面却完全不同。</p><p id="8cd4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">许多相同的概念在两个地方都存在，但通常存在于不同的抽象层次。</p><h2 id="15df" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">朱莉娅的例子</h2><p id="22e4" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">这是一个TCP/IP服务器和客户端的例子。这是服务器的代码，它监听来自客户端的连接，然后将从客户端收到的文本大写并写回客户端。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="a5ad" class="le lf it mh b gy ml mm l mn mo">using Sockets<br/><br/>@async begin<br/>   server = listen(2001)<br/>   while true<br/>       sock = accept(server)<br/>       @async while isopen(sock)<br/>           write(sock, uppercase(readline(sock, keep=true)))<br/>       end<br/>   end<br/>end</span></pre><p id="27c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在REPL上，我们可以连接到服务器</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="7735" class="le lf it mh b gy ml mm l mn mo">julia&gt; clientside = connect(2001)</span></pre><p id="8666" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了捕捉来自服务器的响应，我们将创建一个任务来监听回复。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="5e15" class="le lf it mh b gy ml mm l mn mo">julia&gt; @async while isopen(clientside)<br/>           write(stdout, readline(clientside, keep=true))<br/>       end</span></pre><p id="a419" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们将向服务器发送一条文本。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="e2ae" class="le lf it mh b gy ml mm l mn mo">julia&gt; println(clientside,"Hello World from the Echo Server")</span></pre><p id="d9cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它会反馈:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="fc17" class="le lf it mh b gy ml mm l mn mo">HELLO WORLD FROM THE ECHO SERVER</span></pre><p id="a3ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于那些没有读过我关于生成器的故事的人，让我解释一下宏是如何工作的。</p><p id="a61a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们不使用宏，代码必须写成这样:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="9125" class="le lf it mh b gy ml mm l mn mo">function echo_server()<br/>   server = listen(2001)<br/>   while true<br/>       sock = accept(server)<br/>       function writer()<br/>           while isopen(sock)<br/>               write(sock, uppercase(readline(sock, keep=true)))<br/>           end           <br/>       end<br/>       writer_task = Task(writer)<br/>       schedule(writer_task)<br/>   end<br/>end<br/><br/>server_task = Task(echo_server)<br/>schedule(server_task)</span></pre><p id="ef1d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们创建一个任务来监听连接。实现<code class="fe mp mq mr mh b">listen</code>函数是为了调用<code class="fe mp mq mr mh b">wait</code>函数。<code class="fe mp mq mr mh b">wait</code>类似于Python的<code class="fe mp mq mr mh b">await</code>。然而在Julia中，它通常不公开，而是一个实现细节。它用于等待各种可等待的对象，如通道和套接字。</p><p id="5ebc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当<code class="fe mp mq mr mh b">wait</code>被调用时，调度程序将选择另一个准备运行的任务。</p><p id="b3f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mp mq mr mh b">writer_task</code>中，<code class="fe mp mq mr mh b">readline</code>将调用<code class="fe mp mq mr mh b">wait</code>，T8将控制传递给其他任务，直到在正在读取的套接字上接收到一些数据。</p><h2 id="b81b" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">假想的Python示例</h2><p id="f5c9" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">比较语言的一个问题是，API是如此不同，以至于我们试图比较的关键特性很容易淹没在所有其他差异中。</p><p id="79be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我冒昧地写了一个代码示例，在这里，我想象Python可以像Julia一样访问类似的网络API。</p><p id="7f85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用Python的并发概念来使用它。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="004d" class="le lf it mh b gy ml mm l mn mo">async def echo_server():<br/>   server = listen(2001)<br/>   while True:<br/>       sock = await server.accept()<br/>       async def writer():<br/>           while sock.isopen():<br/>               data = await sock.readline()<br/>               await sock.write(data.upper())<br/>       await writer()<br/>       <br/>asyncio.run(echo_server())</span></pre><p id="67bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们没有使用<code class="fe mp mq mr mh b">@async</code>宏，而是用<code class="fe mp mq mr mh b">async</code>关键字来标记我们的函数。这使得该方法的运行返回一个协程，类似于朱莉娅<code class="fe mp mq mr mh b">Task</code>。</p><p id="5c61" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mp mq mr mh b">accept</code>、<code class="fe mp mq mr mh b">readline</code>、<code class="fe mp mq mr mh b">write</code>的设计与茱莉亚不同。Julia版本在内部调用<code class="fe mp mq mr mh b">wait</code>，并返回常规函数值。Python风格返回协程(Julia任务)。运行并等待协程完成并返回值是通过<code class="fe mp mq mr mh b">await</code>完成的。所以<code class="fe mp mq mr mh b">await</code>采用协程作为参数。</p><p id="fd37" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这解释了为什么我们不能下一个函数调用并做类似于Julia的事情:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="f617" class="le lf it mh b gy ml mm l mn mo">await sock.write(sock.readline().upper())</span></pre><p id="5fc8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为<code class="fe mp mq mr mh b">readline</code>实际上并不返回数据，而是一个协程。或许我们可以这样做:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="b6e5" class="le lf it mh b gy ml mm l mn mo">await sock.write((await sock.readline()).upper())</span></pre><h2 id="1c6f" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">真实的Python例子</h2><p id="64c5" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">当然，在现实世界中，Python网络API有些不同。</p><p id="7291" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的协程从客户端读取数据并以大写形式发送回，它必须接受一个<code class="fe mp mq mr mh b">reader</code>和<code class="fe mp mq mr mh b">writer</code>流对象，用于读取和写入客户端。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="fbdb" class="le lf it mh b gy ml mm l mn mo">import asyncio<br/>async def echo_server(reader, writer):<br/>    while True:<br/>        data = await reader.readline()<br/>        writer.write(data.upper())<br/>        await writer.drain() <br/>    writer.close()</span></pre><p id="2faa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另外<code class="fe mp mq mr mh b">write</code>没有阻塞，因为我假设它只是写入缓冲区。它正在耗尽阻塞的缓冲区。所以<code class="fe mp mq mr mh b">drain</code>将返回一个协程，我们必须等待它完成。</p><p id="a0bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">启动服务器有点不同。我们不处理套接字对象。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="1d3a" class="le lf it mh b gy ml mm l mn mo">async def main():<br/>    server = await asyncio.start_server(<br/>        echo_server, '127.0.0.1', 2001)<br/>    await server.serve_forever()<br/><br/>asyncio.run(main())</span></pre><p id="736b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">启动服务器的函数需要一个协程作为第一个参数。将为每个连接的客户端调用这个协程。</p><p id="dd24" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我不知道你如何让Python与REPL异步运行，所以调用<code class="fe mp mq mr mh b">assynio.run</code>会冻结你的REPL提示符，不像Julia。因此，为了测试这一点，您必须在另一个python REPL中设置一个客户端连接。或者您可以在命令行上使用Netcat:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="4b81" class="le lf it mh b gy ml mm l mn mo">$ nc localhost 2001<br/>Hello<br/>HELLO</span></pre><p id="4eb0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在你可以写一堆东西，让它大写。按Ctrl+C退出。</p><h2 id="b777" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">关于Julia和Python并发性之间差异的思考</h2><p id="92ff" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">Python方法把协程放得到处都是，期望它们作为参数。</p><p id="f7a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Julia APIs中很少需要直接提供任务对象。虽然可能主观上受我与Julia相处时间的影响，但我忍不住觉得这方面的Python APIs更难理解。</p><p id="fcf1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了进行比较，我研究了在Go编程语言中这是如何实现的。<a class="ae kf" href="https://coderwall.com/p/wohavg/creating-a-simple-tcp-server-in-go" rel="noopener ugc nofollow" target="_blank">这个</a>显示了与我们的Julia示例逻辑非常相似的代码。</p><p id="a112" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也恰好遵循与Swift编程语言的<a class="ae kf" href="https://github.com/swiftsocket/SwiftSocket" rel="noopener ugc nofollow" target="_blank"> SwiftSocket </a>库相似的逻辑。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><div class="mc md me mf gt mz"><a href="https://gitconnected.com/learn/julia" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd iu gy z fp ne fr fs nf fu fw is bi translated">学习朱莉娅-最佳朱莉娅教程(2019) | gitconnected</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">12大朱莉娅教程-免费学习朱莉娅。课程由开发人员提交并投票，使您能够…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">gitconnected.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn jz mz"/></div></div></a></div></div></div>    
</body>
</html>