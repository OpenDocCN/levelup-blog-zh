<html>
<head>
<title>Building My First PWA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">建造我的第一个PWA</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-my-first-pwa-d90c61013420?source=collection_archive---------0-----------------------#2017-11-20">https://levelup.gitconnected.com/building-my-first-pwa-d90c61013420?source=collection_archive---------0-----------------------#2017-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="64af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">原载于我的个人博客</em><a class="ae km" href="https://tylergaw.com/articles/building-my-first-pwa" rel="noopener ugc nofollow" target="_blank"><em class="kl">https://tylergaw.com/articles/building-my-first-pwa</em></a></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/73f2504d0e839ce2a1e62e240046f45c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MkLHt1Lz1d8wSXV8z9Mdpg.png"/></div></div></figure><p id="0352" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一段时间以来，我一直在寻找时间和沙盒来坐下来学习如何建立离线/第一网站或“渐进式网络应用”(PWA)。我通过亲身实践的方法学得最好。ColorMe是我维护的一个网站，也是离线实验的绝佳选择。这篇文章详细介绍了我采取的步骤，我遇到的问题，以及我在构建我的第一个PWA时学到的东西。</p><p id="d830" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快速笔记。这不是一个普通的“如何制作PWA”帖子。这甚至可能不是一个好的介绍。有大量的文章和教程来获得基本知识。这个帖子是专门针对制作ColorMe PWA的工作的。</p><p id="3e72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我读到的很多关于pwa的文章中，都有构建它们的通用步骤。表面上看起来很简单的过程。这是杰里米的一份清单:</p><blockquote class="kz la lb"><p id="1ea1" class="jn jo kl jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated">切换到HTTPS，</p><p id="608a" class="jn jo kl jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated">用元捕获添加一个JSON清单文件，并</p><p id="0bb6" class="jn jo kl jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated">添加服务人员。</p><p id="29ab" class="jn jo kl jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated">杰里米·基思，《发展网络》T19】</p></blockquote><p id="907f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的，这看起来很简单。除了最后一步。看起来要打开的东西太多了。他确实提供了一份免责声明:</p><blockquote class="kz la lb"><p id="1ec3" class="jn jo kl jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated">如果你是第一次接触服务人员，最后一步可能会很棘手，但也不是不可克服的。</p></blockquote><p id="5b9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我将忽略这个过程中的服务人员部分，而专注于前两项。</p><h1 id="7991" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用HTTPS</h1><p id="e874" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">ColorMe已经有了HTTPS。我在S3托管它，并通过CloudFront提供服务。我用<a class="ae km" href="https://aws.amazon.com/certificate-manager/" rel="noopener ugc nofollow" target="_blank">亚马逊的证书管理器</a>添加了一个SSL证书。HTTPS已经就位，并自发射以来一直如此。</p><h1 id="b555" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">添加清单</h1><p id="4db2" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">这是事情变得更有趣的地方。我用<a class="ae km" href="https://github.com/facebookincubator/create-react-app" rel="noopener ugc nofollow" target="_blank"> Create React App </a> (CRA)构建了ColorMe，所以我在<code class="fe mi mj mk ml b">public</code>目录下创建了一个<code class="fe mi mj mk ml b">manifest.json</code>文件。与网站图标和<code class="fe mi mj mk ml b">index.html</code>相同的目录。<code class="fe mi mj mk ml b">public</code>目录中的任何内容都被原样复制到<code class="fe mi mj mk ml b">build</code>目录中。这就是我们需要的<code class="fe mi mj mk ml b">manifest.json</code>。</p><h1 id="16f2" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">CRA做的PWA不是开箱即用的吗？</h1><p id="8e2b" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">是的。CRA在版本<code class="fe mi mj mk ml b">1.0.0</code>中增加了对PWAs的内置支持。ColorMe还在版本<code class="fe mi mj mk ml b">0.8.4</code>上。这是我创建项目时的最新版本，没有理由更新。</p><p id="49ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我本可以更新CRA来使用内置的PWA，但是我不想错过逐步学习的机会。我自己这样做，走了一条漫长而“愚蠢”的路，帮助我理解了每一步的原因和方法。在未来CRA建造的项目中，我将使用内置PWA支持的最新版本。这样一来，这就是我所有的“元剪辑”</p><p id="9f05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我知道货单上有“东西”，但我不确定具体是什么。我能用什么钥匙？每个键的示例值是什么？我应该有什么键值呢？我为第一个和第二个问题找到的最佳资源是MDN <a class="ae km" href="https://developer.mozilla.org/en-US/docs/Web/Manifest" rel="noopener ugc nofollow" target="_blank"> Web应用清单文档</a>。它列出了可用的键和示例值。</p><h1 id="b035" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">灯塔</h1><p id="2d3e" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">对于第三个问题，我求助于Chrome开发工具中的<a class="ae km" href="https://developers.google.com/web/tools/lighthouse/" rel="noopener ugc nofollow" target="_blank">灯塔审计</a>。在向清单添加任何东西之前，我进行了PWA审计。它报告了满足PWA最低要求所需的项目(根据审计)。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mm"><img src="../Images/10e85d5a9e70542d3e7ac961bcb11d62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hrxQ1Ozi4SPCdEPX.png"/></div></div></figure><p id="0f3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以审计报告为起点，我逐一检查了清单上的每一项。最重要的是，我在<code class="fe mi mj mk ml b">index.html</code>的<code class="fe mi mj mk ml b">head</code>中引用了清单。这使用了CRA特有的<code class="fe mi mj mk ml b">%PUBLIC_URL%</code>。</p><pre class="ko kp kq kr gt mn ml mo mp aw mq bi"><span id="f612" class="mr lg iq ml b gy ms mt l mu mv">&lt;link rel="manifest" href="%PUBLIC_URL%/manifest.json"&gt;</span></pre><p id="4cfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">清单中的大多数项目都很简单，所以我不会一行一行地介绍。但我会说出几个需要更多努力的项目。你可以在GitHub 和下面看到完整的文件<a class="ae km" href="https://github.com/tylergaw/colorme/blob/develop/public/manifest.json" rel="noopener ugc nofollow" target="_blank">:</a></p><pre class="ko kp kq kr gt mn ml mo mp aw mq bi"><span id="433c" class="mr lg iq ml b gy ms mt l mu mv">{<br/> "background_color": "#ffffff",<br/> "theme_color": "#B50003",<br/> "display": "standalone",<br/> "short_name": "ColorMe",<br/> "name": "ColorMe",<br/> "start_url": "/",<br/> "icons": [{<br/>  "src": "launcher-icon-48x48.png",<br/>  "type": "image/png",<br/>  "sizes": "48x48"<br/> }, {<br/>  "src": "launcher-icon-96x96.png",<br/>  "type": "image/png",<br/>  "sizes": "96x96"<br/> }, {<br/>  "src": "launcher-icon-192x192.png",<br/>  "type": "image/png",<br/>  "sizes": "192x192"<br/> }, {<br/>  "src": "launcher-icon-256x256.png",<br/>  "type": "image/png",<br/>  "sizes": "256x256"<br/> }, {<br/>  "src": "launcher-icon-384x384.png",<br/>  "type": "image/png",<br/>  "sizes": "384x384"<br/> }, {<br/>  "src": "launcher-icon-512x512.png",<br/>  "type": "image/png",<br/>  "sizes": "512x512"<br/> }]<br/>}</span></pre><h1 id="4fd8" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">图标大小</h1><p id="9d80" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">正如你在manifiest中看到的，我包括了六种不同大小的图标。审计需要两种尺寸；192x192和512x512。前者用于Android上的主屏幕图标，后者用于Android上的闪屏图标。</p><p id="6e5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不确定其他四种尺寸是否有必要，但我在例子中看到了它们，所以我认为包含它们不会有什么坏处。</p><h1 id="2777" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">主题颜色</h1><p id="8ffa" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">根据审计，一个需求是给<code class="fe mi mj mk ml b">index.html</code>添加一个<code class="fe mi mj mk ml b">theme-color</code>元标签:</p><pre class="ko kp kq kr gt mn ml mo mp aw mq bi"><span id="b103" class="mr lg iq ml b gy ms mt l mu mv">&lt;meta name="theme-color" content="#B50003"&gt;</span></pre><blockquote class="kz la lb"><p id="60ff" class="jn jo kl jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated">主题颜色meta标签确保当用户访问你的网站时，地址栏被标记为普通网页。</p></blockquote><h1 id="dfd8" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">noscript</h1><p id="d1da" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">另一个失败的审计是“当JavaScript不可用时包含一些内容。”为此，我添加了<code class="fe mi mj mk ml b">noscript</code>内容。除了为没有JavaScript就无法工作而道歉之外，它没有做任何事情。如果没有JS，拥有一些有用的经验会更好，但是我会把这个留到以后再说。想想如何让这样的网站在没有JavaScript的情况下提供价值，这很有趣。</p><h1 id="91c2" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">“根据审计”</h1><p id="38ae" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">我在这里故意使用了特定的语言，如“根据审计”和“根据审计”。其中一些并不普遍。例如，据我所知，<code class="fe mi mj mk ml b">theme_color</code>属性和<code class="fe mi mj mk ml b">theme-color</code> meta标签对iOS上的Mobile Safari或Mobile Chrome没有影响。出于这个练习的目的，我正在努力100%地进行审计。我确信不是每个项目都需要每个项目。像往常一样，看情况。</p><h1 id="e861" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Chrome开发工具清单标签</h1><p id="c79d" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">每次我对清单进行更改时，我都会重新运行PWA审计来检查结果。这太慢了。我没有意识到Chrome开发工具中有一个选项卡可以检查<code class="fe mi mj mk ml b">manifest.json</code>的结果。我在这个过程中很早就发现了这一点，这有助于加快事情的进展。它还有一个“添加到主屏幕”按钮来测试这个机制。非常感谢，因为我没有安卓设备来进行正确的测试。</p><p id="9006" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一点上，我仍然没有一个PWA。审计发现了最后一个失败之处:</p><blockquote class="kz la lb"><p id="72ce" class="jn jo kl jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated"><em class="iq">失败:站点未注册服务工作程序，服务工作程序未缓存清单start_url。</em></p></blockquote><p id="b81a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了清单的基础，我把注意力转向了服务人员。</p><h1 id="a5d3" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">服务人员</h1><p id="6267" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">就像我上面提到的，这对我来说是最大的谜团。我理解服务工作者的一般概念，但我不明白一个PWA的服务工作者的目标是什么。当然是JS，后台运行。但是那个JS应该<em class="kl">做什么</em>？在花时间学习教程、例子和摆弄之后，我有了更清晰的认识。</p><h1 id="4ec2" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">ColorMe服务人员的目标:</h1><ol class=""><li id="58f8" class="mw mx iq jp b jq md ju me jy my kc mz kg na kk nb nc nd ne bi translated">在<code class="fe mi mj mk ml b">window.caches</code>对象中存储站点的静态文件——HTML、CSS、JavaScript和图像</li><li id="d882" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">拦截所有网络请求。如果请求文件的名称在<code class="fe mi mj mk ml b">window.caches</code>中，用缓存的文件响应，而不是向服务器发出请求</li><li id="e39d" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">当缓存键改变时删除过时的缓存</li></ol><p id="a148" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最早引人注目的是全局<code class="fe mi mj mk ml b">window</code>作用域上的<code class="fe mi mj mk ml b">caches</code>成员。当我第一次看到<code class="fe mi mj mk ml b">caches</code>使用示例服务工作者时，我认为它只是服务工作者上下文中的一个全局变量。事实并非如此。<code class="fe mi mj mk ml b">window.caches</code>适用于任何JS。</p><p id="967a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个<code class="fe mi mj mk ml b">caches</code>的快速例子。转到<a class="ae km" href="https://colorme.io/" rel="noopener ugc nofollow" target="_blank"> colorme.io </a>。打开开发人员控制台并运行以下代码片段:</p><pre class="ko kp kq kr gt mn ml mo mp aw mq bi"><span id="3b49" class="mr lg iq ml b gy ms mt l mu mv">caches.keys().then(names =&gt; {console.log(names)});</span></pre><p id="9ba5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这应该输出<code class="fe mi mj mk ml b">["colorme-v7"]</code>(版本号可能不同)。看的不多，但是可以看到<code class="fe mi mj mk ml b">window.caches</code>是这个语境下的一个东西。这意味着您可以从任何客户端JavaScript访问缓存，而不仅仅是服务人员。那很酷。</p><h1 id="577b" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">目标1:缓存静态文件</h1><p id="cb55" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">为了让ColorMe离线工作，它需要缓存所有关键的静态文件。这是一个单页网站，所以只有几个；<code class="fe mi mj mk ml b">index.html</code>、<code class="fe mi mj mk ml b">main.css</code>、<code class="fe mi mj mk ml b">main.js</code>、<code class="fe mi mj mk ml b">manifest.json</code>、一个svg图像和一个Google字体样式表。</p><p id="25fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CRA构建过程创建或重命名CSS、JS和image文件。这使事情变得困难，我将在后面描述我修复它的过程。现在，我将假设文件名就是文件名，并遍历代码。</p><p id="93c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在<code class="fe mi mj mk ml b">public</code>目录中创建了<code class="fe mi mj mk ml b">service-worker.js</code>。完整文件可从GitHub 上的<a class="ae km" href="https://github.com/tylergaw/colorme/blob/03946e9540a031075f3f691356d7aa3f4e457a2d/public/service-worker.js" rel="noopener ugc nofollow" target="_blank">获得。</a></p><pre class="ko kp kq kr gt mn ml mo mp aw mq bi"><span id="be6c" class="mr lg iq ml b gy ms mt l mu mv">const STATIC_CACHE_NAME = "colorme-v1"; <br/>const STATIC_URLS = [ <br/>  "/", <br/>  "/index.html", <br/>  "/manifest.json", <br/>  "/static/css/main.css", <br/>  "/static/js/main.js", <br/>  "/static/media/bgTransparent.svg",<br/>  "https://fonts.googleapis.com/css?family=Cousine:400|Karla:400,700" <br/>]; </span><span id="b779" class="mr lg iq ml b gy nk mt l mu mv">self.addEventListener("install", event =&gt; { <br/>  event.waitUntil( <br/>    caches.open(STATIC_CACHE_NAME).then(cache =&gt; { <br/>      return cache.addAll(STATIC_URLS); <br/>    }).then(() =&gt; self.skipWaiting()) ); <br/>});</span></pre><p id="7f20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mi mj mk ml b">STATIC_CACHE_NAME</code>是该缓存的唯一键。<code class="fe mi mj mk ml b">STATIC_URLS</code>是要缓存的文件列表。我将在后面解释如何更新这个列表来考虑动态文件名。</p><p id="0645" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大致来说，下一行写着:</p><ol class=""><li id="4b8c" class="mw mx iq jp b jq jr ju jv jy nl kc nm kg nn kk nb nc nd ne bi translated">当维修工人完成安装过程时，</li><li id="c02e" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">找到或创建一个以我们的名字命名的缓存，</li><li id="ef78" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">并将我们指定的文件放入缓存中。</li></ol><p id="1869" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有安装事件和<code class="fe mi mj mk ml b">waitUntil</code>的完整描述。<a class="ae km" href="https://developer.mozilla.org/en-US/docs/Web/API/InstallEvent" rel="noopener ugc nofollow" target="_blank"> MDN </a>就是一个很棒的。</p><h2 id="29bd" class="mr lg iq bd lh no np dn ll nq nr dp lp jy ns nt lt kc nu nv lx kg nw nx mb ny bi translated">跳过等待？</h2><p id="7d96" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">我读过关于<code class="fe mi mj mk ml b">skipWaiting</code>的文档，但是我仍然不清楚它是做什么的，或者我是否需要它。很多例子推荐，所以我暂时保留。当我使用它的时候，我会了解更多。</p><p id="c817" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这些行，ColorMe的静态资产就藏在一个缓存中。尽管如此，仍有工作要做。</p><h1 id="bbdd" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">目标2:提供缓存文件</h1><p id="ffa1" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">将静态文件放入<code class="fe mi mj mk ml b">caches</code>本身是不够的。为了让ColorMe脱机工作，我们需要告诉浏览器在缓存中查找这些文件。</p><pre class="ko kp kq kr gt mn ml mo mp aw mq bi"><span id="b577" class="mr lg iq ml b gy ms mt l mu mv">self.addEventListener("fetch", event =&gt; { <br/>  event.respondWith( <br/>    caches.match(event.request)<br/>      .then(response =&gt; response || fetch(event.request))<br/>  ); <br/>});</span></pre><p id="6539" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个代码片段监听来自用户浏览器的所有HTTP请求。<code class="fe mi mj mk ml b">event.respondWith</code>阻止浏览器的默认<code class="fe mi mj mk ml b">fetch</code>处理。这允许我们检查请求的URL–<code class="fe mi mj mk ml b">event.request</code>–是否在缓存中。如果是，用缓存的文件进行响应。如果没有缓存，使用<code class="fe mi mj mk ml b">fetch()</code>继续向服务器发送请求。</p><p id="bc44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ColorMe现在可以在有或没有互联网连接的情况下工作。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nz"><img src="../Images/98b6547fb23e4ddef06e0e754addcc5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QNHL8U3vhzrZjn1w.png"/></div></div></figure><h1 id="ab31" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">目标3:删除过时的缓存</h1><p id="2c79" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">如果我停在这里，ColorMe离线工作，但我没有办法向用户发布更新。缓存的项目必须被删除——它们永远不会过期。服务人员应该删除过时的缓存。</p><pre class="ko kp kq kr gt mn ml mo mp aw mq bi"><span id="772c" class="mr lg iq ml b gy ms mt l mu mv">self.addEventListener("activate", event =&gt; { <br/>  event.waitUntil(<br/>    caches.keys().then(cacheNames =&gt; { <br/>      return Promise.all( <br/>        cacheNames.filter(name =&gt; name.includes("colorme") &amp;&amp; name !== STATIC_CACHE_NAME)<br/>      .map(name =&gt; caches.delete(name)) ) })<br/>      .then(() =&gt; self.clients.claim()) <br/>  ); <br/>});</span></pre><p id="e042" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是service worker中看起来最复杂的代码，但是它没有做太多事情。</p><ol class=""><li id="19ee" class="mw mx iq jp b jq jr ju jv jy nl kc nm kg nn kk nb nc nd ne bi translated">用<code class="fe mi mj mk ml b">caches.keys()</code>获取所有缓存键的数组，</li><li id="a825" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">删除所有不包含我们名字的关键字，并删除一个包含准确的<code class="fe mi mj mk ml b">STATIC_CACHE_NAME</code>的缓存，</li><li id="5461" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">对于剩余的每个键，删除该缓存。</li></ol><p id="906d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当服务人员激活时——每次页面加载时——检查是否有过时的缓存。如果有，就删掉。我用上面的#2来确定缓存是否过时。</p><p id="3209" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第一段代码中，我定义了缓存键<code class="fe mi mj mk ml b">const STATIC_CACHE_NAME = "colorme-v1"</code>。当我更改任何缓存文件并部署站点时，我也会更改版本号。如果用户在<code class="fe mi mj mk ml b">colorme-v1</code>是最新的时候访问了站点，然后在<code class="fe mi mj mk ml b">colorme-v7</code>是最新的时候再次访问，服务工作者删除v1并缓存v7。</p><h1 id="5128" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">缓存动态文件名</h1><p id="282e" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">至此，我已经达到了ColorMe服务人员的所有目标，并且拥有了一个正常工作的PWA。如果您访问ColorMe，然后关闭您的网络连接，您应该能够刷新页面并正常使用它。</p><p id="0c50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一个问题我上面提到过。CSS、JS和image的文件名不正确。在前面的代码片段中，我缓存了名为；</p><ul class=""><li id="f8de" class="mw mx iq jp b jq jr ju jv jy nl kc nm kg nn kk oa nc nd ne bi translated"><code class="fe mi mj mk ml b">"/static/css/main.css"</code></li><li id="d80f" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk oa nc nd ne bi translated"><code class="fe mi mj mk ml b">"/static/js/main.js"</code></li><li id="8352" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk oa nc nd ne bi translated"><code class="fe mi mj mk ml b">"/static/media/bgTransparent.svg"</code></li></ul><p id="c981" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CRA构建过程将这些文件名指纹化为类似于:</p><ul class=""><li id="fe4f" class="mw mx iq jp b jq jr ju jv jy nl kc nm kg nn kk oa nc nd ne bi translated"><code class="fe mi mj mk ml b">"/static/css/main.2ebebc14.css"</code></li><li id="bc70" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk oa nc nd ne bi translated"><code class="fe mi mj mk ml b">"/static/js/main.7e7a1a8f.js"</code></li><li id="da79" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk oa nc nd ne bi translated"><code class="fe mi mj mk ml b">"/static/media/bgTransparent.e6317315.svg"</code></li></ul><p id="4089" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是常见的缓存破坏，以便浏览器将识别新文件。</p><p id="6059" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我被这件大事耽搁了。当我无法控制文件的名称时，我如何告诉服务人员缓存文件呢？我没有找到太多关于这个话题的信息。<a class="ae km" href="https://github.com/w3c/ServiceWorker/issues/657" rel="noopener ugc nofollow" target="_blank">这个问题</a>提出了问题，讨论帮我想出了一个办法。我需要在构建过程中以某种方式生成文件名列表。我有几个选择，有几个不是很好；</p><ol class=""><li id="f0da" class="mw mx iq jp b jq jr ju jv jy nl kc nm kg nn kk nb nc nd ne bi translated">运行CRA弹出脚本，并更改默认webpack构建流程以生成服务工作进程</li><li id="ab2e" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">更新到最新的CRA，并使用其内置的PWA支持</li><li id="dc16" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">离开电脑，睡上一觉，在第二天早上遛狗的时候思考更好的解决方案</li></ol><p id="f6f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不想被逐出CRA，因为这似乎不值得。我上面提到过，更新到最新的CRA会剥夺学习的机会。选项3听起来最好。离开电脑后，我意识到我有比我意识到的更多的选择，以及一个<em class="kl">应该</em>起作用的解决方案。它不会是优雅的或可伸缩的，但它能完成工作。</p><h1 id="1388" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">借用CRA的构建脚本</h1><p id="8282" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">默认的CRA构建脚本根据webpack中的配置构建项目。我不能在不弹出的情况下更改配置，但是我可以在<code class="fe mi mj mk ml b">package.json</code>中添加构建脚本。我已经修改了脚本，加入了<code class="fe mi mj mk ml b">NODE_PATH=src</code>。这使得在不引用完整路径的情况下导入模块变得更加容易。ColorMe的起始构建脚本如下所示:</p><pre class="ko kp kq kr gt mn ml mo mp aw mq bi"><span id="9fa6" class="mr lg iq ml b gy ms mt l mu mv">NODE_PATH=src react-scripts build</span></pre><p id="ecf7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我知道一些事情。我知道构建过程会创建一个名为<code class="fe mi mj mk ml b">asset-manifest.json</code>的文件。该文件的内容包括站点中使用的所有静态资产的完整指纹名称。清单文件的内容示例:</p><pre class="ko kp kq kr gt mn ml mo mp aw mq bi"><span id="ecb7" class="mr lg iq ml b gy ms mt l mu mv">{<br/> "main.css": "static/css/main.2ebebc14.css",<br/> "main.css.map": "static/css/main.2ebebc14.css.map",<br/> "main.js": "static/js/main.7e7a1a8f.js",<br/> "main.js.map": "static/js/main.7e7a1a8f.js.map",<br/> "static/media/bgTransparent.svg": "static/media/bgTransparent.e6317315.svg"<br/>}</span></pre><p id="dcf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些是我需要用我的服务人员缓存的完整文件名。我需要将这些文件名保存到服务人员文件中。</p><p id="3c0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我做的第一件事是添加到构建脚本中。回到<code class="fe mi mj mk ml b">package.json</code>，我将脚本更新为:</p><pre class="ko kp kq kr gt mn ml mo mp aw mq bi"><span id="68cd" class="mr lg iq ml b gy ms mt l mu mv">NODE_PATH=src react-scripts build &amp;&amp; npm run generate-sw</span></pre><p id="aa81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这上面说:运行正常的构建过程，完成后运行另一个npm脚本。该脚本看起来像:</p><pre class="ko kp kq kr gt mn ml mo mp aw mq bi"><span id="9914" class="mr lg iq ml b gy ms mt l mu mv">"generate-sw": "node scripts/generate-sw.js"</span></pre><p id="3763" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了确保有效，我创建了<code class="fe mi mj mk ml b">/scripts/generate-sw.js</code>并添加了一行代码；<code class="fe mi mj mk ml b">console.log('hello')</code>。然后，我运行构建脚本<code class="fe mi mj mk ml b">npm run build</code>以确保项目构建成功，我在终端输出中看到了“hello”。到目前为止一切顺利。</p><h2 id="0142" class="mr lg iq bd lh no np dn ll nq nr dp lp jy ns nt lt kc nu nv lx kg nw nx mb ny bi translated">生成脚本</h2><p id="70d3" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">我需要将文件名从<code class="fe mi mj mk ml b">asset-manifest.json</code>中取出，放入文件名数组中，并缓存在<code class="fe mi mj mk ml b">service-worker.js</code>中。我的计划是不要幻想这个。我只需要从一个文件中取出字符串，并将它们写入另一个文件。目标文件是JavaScript这一事实对于这个过程并不重要。</p><p id="78a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">GitHub 上的<a class="ae km" href="https://github.com/tylergaw/colorme/blob/03946e9540a031075f3f691356d7aa3f4e457a2d/scripts/generate-sw.js" rel="noopener ugc nofollow" target="_blank">提供了完整的文件，我将在这里详细介绍代码。</a></p><pre class="ko kp kq kr gt mn ml mo mp aw mq bi"><span id="5664" class="mr lg iq ml b gy ms mt l mu mv">const manifest = require("../build/asset-manifest.json"); <br/>const fs = require("fs"); <br/>const swPath = "build/service-worker.js";</span></pre><p id="fd20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先是设置。<code class="fe mi mj mk ml b">asset-manifest</code>是JSON所以我把它<code class="fe mi mj mk ml b">require</code>放在这里作为对象使用。我将使用<code class="fe mi mj mk ml b">fs</code>包来读写文件。为了方便起见，我存储了服务人员的路径。</p><pre class="ko kp kq kr gt mn ml mo mp aw mq bi"><span id="b261" class="mr lg iq ml b gy ms mt l mu mv">const urlsCSV = Object.keys(manifest)<br/>  .filter(k =&gt; !k.includes(".map"))<br/>  .map(k =&gt; manifest[k]);</span></pre><p id="bca4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">越来越有趣，但仍然不花哨。这段代码的目标是构建一个文件名数组。首先，使用<code class="fe mi mj mk ml b">Object.keys</code>从清单JSON中获取键，以循环访问一个数组。</p><p id="e409" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，使用<code class="fe mi mj mk ml b">filter</code>删除包含字符串“. map”的键。如果你查看<code class="fe mi mj mk ml b">asset-manifest.json</code>，你会看到源地图。我们不想缓存这些。我不确定是否有支持或反对这种做法的最佳实践，但我认为这似乎不适合这个项目。</p><p id="77bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们只有想要缓存的文件的键，使用<code class="fe mi mj mk ml b">map</code>创建文件名数组，存储为<code class="fe mi mj mk ml b">urlsCSV</code>；</p><pre class="ko kp kq kr gt mn ml mo mp aw mq bi"><span id="ee2d" class="mr lg iq ml b gy ms mt l mu mv">[<br/>  "static/css/main.2ebebc14.css", <br/>  "static/js/main.7e7a1a8f.js",<br/>  "static/media/bgTransparent.e6317315.svg"<br/>]</span></pre><p id="da46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">短切线。根据上面的代码，你可能会问:<em class="kl">“为什么不用</em> <code class="fe mi mj mk ml b"><em class="kl">Object.values</em></code> <em class="kl">而不用</em> <code class="fe mi mj mk ml b"><em class="kl">Object.keys</em></code> <em class="kl">加</em> <code class="fe mi mj mk ml b"><em class="kl">map</em></code> <em class="kl">？”这个问题很好，回答也很快。在撰写本文时，我运行的是Node.js版本6.9.1。在版本<code class="fe mi mj mk ml b">7.0.0</code>之前，没有<code class="fe mi mj mk ml b">--harmony</code>标志，不支持<code class="fe mi mj mk ml b">Object.values</code>。我本不想为此升级Node.js。我下次会做那件事。仅此而已。</em></strong></p><p id="dcc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我需要将文件名数组放入服务工作者文件中。同样，这并不意味着花哨或可伸缩。它是用来工作的。</p><pre class="ko kp kq kr gt mn ml mo mp aw mq bi"><span id="6676" class="mr lg iq ml b gy ms mt l mu mv">fs.readFile(swPath, "utf8", (err, data) =&gt; { <br/>  if (err) { <br/>    return console.log("Error trying to read SW file", err); <br/>  } </span><span id="8f27" class="mr lg iq ml b gy nk mt l mu mv">  const result = data.replace(<br/>    "%MANIFESTURLS%",<br/>    JSON.stringify(urlsCSV)<br/>  ); </span><span id="9ce4" class="mr lg iq ml b gy nk mt l mu mv">  fs.writeFile(swPath, result, "utf8", err =&gt; { <br/>    if (err) { <br/>      return console.log("Error trying to write SW file", err); <br/>    } <br/>  }); <br/>});</span></pre><p id="300a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们来分析一下。首先，打开维修工人文件(<code class="fe mi mj mk ml b">swPath</code>)进行读取。错误条件并不重要。我把它包括进来是为了在构建过程中万一发生一些奇怪的事情时对自己好一点。</p><p id="e447" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一行是这个脚本的要点。它在服务工作者文件(<code class="fe mi mj mk ml b">data</code>)的内容中搜索唯一的字符串<code class="fe mi mj mk ml b">“%MANIFESTURLS%”</code>。当找到它时，它被替换为文件名数组的JSON字符串版本，<code class="fe mi mj mk ml b">urlsCSV</code>。然后，更新的内容被写回到服务工作者文件。</p><h1 id="9278" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">service-worker.js的更新</h1><p id="3084" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">如上所述，生成脚本需要在<code class="fe mi mj mk ml b">service-worker.js</code>中找到<code class="fe mi mj mk ml b">“%MANIFESTURLS%”</code>。我回去更新了脚本来解释这一点。</p><pre class="ko kp kq kr gt mn ml mo mp aw mq bi"><span id="13e2" class="mr lg iq ml b gy ms mt l mu mv">const STATIC_CACHE_NAME = "colorme-v1"; <br/>const BASE_STATIC_URLS = [ <br/>  "/", <br/>  "/index.html", <br/>  "/manifest.json", <br/>  "https://fonts.googleapis.com/css?family=Cousine:400|Karla:400,700" <br/>]; </span><span id="9c01" class="mr lg iq ml b gy nk mt l mu mv">const STATIC_URLS = BASE_STATIC_URLS<br/>  .concat(<br/>    JSON.parse('%MANIFESTURLS%')<br/>  ); </span><span id="219b" class="mr lg iq ml b gy nk mt l mu mv">// The install handler is the same as when we started. self.addEventListener("install", event =&gt; { <br/>  event.waitUntil(<br/>    caches.open(STATIC_CACHE_NAME).then(cache =&gt; {<br/>      return cache.addAll(STATIC_URLS); <br/>    }).then(() =&gt; self.skipWaiting()) <br/>  ); <br/>});</span></pre><p id="1c5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我把我知道的文件名移到了<code class="fe mi mj mk ml b">BASE_STATIC_URLS</code>。我不会对这些文件名进行指纹识别，所以硬编码它们是安全的。接下来是重要的变化。仍然是文件名的数组，但是现在它是两个数组的组合。我们知道的文件名和写入该文件的生成的文件名数组。</p><p id="7be6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mi mj mk ml b">STATIC_URLS</code>最终看起来像这样；</p><pre class="ko kp kq kr gt mn ml mo mp aw mq bi"><span id="b4aa" class="mr lg iq ml b gy ms mt l mu mv">[ <br/>  "/", <br/>  "/index.html", <br/>  "/manifest.json", <br/>  "https://fonts.googleapis.com/css?family=Cousine:400|Karla:400,700", "static/css/main.2ebebc14.css",<br/>  "static/js/main.7e7a1a8f.js",<br/>  "static/media/bgTransparent.e6317315.svg" <br/>]</span></pre><p id="bb91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当项目构建过程运行时，指纹文件名和<code class="fe mi mj mk ml b">asset-manifest</code>被改变。然后服务人员会得到新文件名的更新。</p><p id="d3ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有这些加起来就是一个处理指纹文件缓存的构建过程和一个支持离线的PWA。</p><h1 id="d8d1" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">新常态</h1><p id="9908" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">我看到人们详细谈论艾滋病毒感染者有多么具有变革性，但直到我经历了这个过程，我才明白。这感觉像是第一次构建一个响应式设计。这是意识到这不会是一个噱头或一个额外的或一个美好的拥有。习惯的养成和浏览器的跟上需要时间，但这将成为我建立网站时的默认设置。</p><p id="c5b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">感谢阅读</em></p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><p id="54b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">原载于</em><a class="ae km" href="https://tylergaw.com/articles/building-my-first-pwa" rel="noopener ugc nofollow" target="_blank"><em class="kl">tylergaw.com</em></a><em class="kl">。</em></p></div></div>    
</body>
</html>