<html>
<head>
<title>Dynamic Redux Reducers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态Redux减速器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dynamic-redux-reducers-f2889adb83fa?source=collection_archive---------0-----------------------#2018-01-09">https://levelup.gitconnected.com/dynamic-redux-reducers-f2889adb83fa?source=collection_archive---------0-----------------------#2018-01-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/1f3ff0993f6fbfae0ab99eeffd64b873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UdBaVQtV8XS4LDeCpGOqtA.png"/></div></div></figure><div class=""/><p id="36c8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">原载于我的个人博客</em><a class="ae kx" href="https://tylergaw.com/articles/dynamic-redux-reducers/" rel="noopener ugc nofollow" target="_blank"><em class="kw">【https://tylergaw.com/articles/dynamic-redux-reducers】</em></a></p><p id="4f34" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章是针对我最近在React / Redux项目中的一个需求而写的。这是一个常见的需求，我以前也遇到过，但这是我第一次需要为它想出一个解决方案。这对我来说很难。我不得不放慢速度，花时间去理解我想做的事情和所有相关的部分。我希望这篇文章能帮助其他使用Redux的人解决这个问题。</p><p id="48b9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将在这篇文章中详细描述我的过程。这里有一个<a class="ae kx" href="https://qk3n9xmm3w.codesandbox.io/" rel="noopener ugc nofollow" target="_blank">现场演示</a>和一个<a class="ae kx" href="https://codesandbox.io/s/qk3n9xmm3w" rel="noopener ugc nofollow" target="_blank">可编辑沙盒</a>。查看效果的最佳方式是使用Redux DevTools Chrome扩展。</p><p id="c3b1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你正在阅读这篇文章，我将假设你已经了解Redux，并且正在通过<code class="fe ky kz la lb b">react-redux</code>的方式将它与React一起使用。我还假设你正在寻找一个类似问题的解决方案。</p><h1 id="ca3d" class="lc ld jb bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">我在努力做什么，为什么？</h1><p id="b7e3" class="pw-post-body-paragraph jy jz jb ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">在标准Redux用法中，您在使用<code class="fe ky kz la lb b">createStore</code>创建存储时提供reducer函数。我想要一种随后按需添加reducer功能的方法。</p><p id="edd0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很多人需要这个，因为由于代码分裂，他们的减速器在<code class="fe ky kz la lb b">createStore</code>时间不可用。这是动力减速器的完美用途。</p><p id="7827" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的项目不使用代码分割。为此，动态减速器是首选。我不想在整个项目结构中传播关于模块的信息。我希望每个特性都存在于一个目录中，尽可能地隔离开来。这意味着共同定位异径管、组件、样式等等。我可以这样做，并且仍然将减速器导入到主减速器创建中，但是这样会将模块减速器耦合到主减速器。</p><h1 id="3500" class="lc ld jb bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">现有解决方案</h1><p id="0dbe" class="pw-post-body-paragraph jy jz jb ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">在我搜索现有解决方案时，我登陆到了<a class="ae kx" href="https://stackoverflow.com/a/33044701" rel="noopener ugc nofollow" target="_blank">这个堆栈溢出问题和答案</a>。答案来自丹·阿布拉莫夫，所以我知道这是一个不错的选择。我的解决方案使用了该答案中的大部分代码。</p><p id="9299" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在丹的回答中，直到他举例说明如何注射还原剂，我才明白。我正在使用React路由器，但我没有按照他描述的方式定义路由。我不想为此改变我对路线的定义。我也找不到他在例子中使用的方法的官方文档，所以我想避免复制/粘贴。我还想完全理解我添加到项目中的代码。</p><p id="1e18" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">值得一提的是我在搜索中遇到的两个项目:<a class="ae kx" href="https://github.com/ioof-holdings/redux-dynamic-reducer" rel="noopener ugc nofollow" target="_blank"> redux-dynamic-reducer </a>和<a class="ae kx" href="https://github.com/asteridux/paradux" rel="noopener ugc nofollow" target="_blank"> paradux </a>。我没有尝试这两种方法，因为我认为没有必要添加另一个依赖项，但是它们可能适合您。</p><h1 id="f102" class="lc ld jb bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">演示展示了什么</h1><p id="4e7c" class="pw-post-body-paragraph jy jz jb ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated"><a class="ae kx" href="https://qk3n9xmm3w.codesandbox.io/" rel="noopener ugc nofollow" target="_blank">演示</a>显示了一个简单的页面，上面有一个到<code class="fe ky kz la lb b">/records</code>的链接。当页面加载时，Redux状态树包含两个键，存储创建时引入的每个reducer函数对应一个键。</p><p id="a34a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有一个到<code class="fe ky kz la lb b">/records</code>页面的链接。当您导航到该页面时，我为记录添加了另一个reducer函数。在这篇文章的剩余部分，我将描述我是如何做到这一点的。</p><h1 id="c9a7" class="lc ld jb bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">代码</h1><p id="15de" class="pw-post-body-paragraph jy jz jb ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">你可以在<a class="ae kx" href="https://codesandbox.io/s/qk3n9xmm3w" rel="noopener ugc nofollow" target="_blank">代码沙箱</a>中跟随。我将从在<code class="fe ky kz la lb b">/rootReducer.js</code>中创建根减速器开始。</p><pre class="mh mi mj mk gt ml lb mm mn aw mo bi"><span id="55ce" class="mp ld jb lb b gy mq mr l ms mt">import { combineReducers } from "redux"; <br/>import layout from "./reducers/layout"; <br/>import home from "./reducers/home"; </span><span id="15d9" class="mp ld jb lb b gy mu mr l ms mt">/** <br/> * @param {Object} - key/value of reducer functions <br/> */ <br/>const createReducer = asyncReducers =&gt; <br/>  combineReducers({ <br/>    home, <br/>    layout, <br/>    ...asyncReducers <br/>  }<br/>); </span><span id="52d1" class="mp ld jb lb b gy mu mr l ms mt">export default createReducer;</span></pre><p id="a77d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我从丹的回答中提取了这段代码。它有两个减速器功能；<code class="fe ky kz la lb b">layout</code>和<code class="fe ky kz la lb b">home</code>。它们是全局归约器，而不是模块级的，所以它们非常适合根归约器。</p><p id="b95d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的关键细节是<code class="fe ky kz la lb b">asyncReducers</code>参数。将它的内容添加到给定给<code class="fe ky kz la lb b">combineReducers</code>的对象中，这就是我们后来添加reducers的方式。</p><p id="65e6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来是在<code class="fe ky kz la lb b">/initializeStore.js</code>创建商店。同样，大部分代码来自Dan的例子。</p><pre class="mh mi mj mk gt ml lb mm mn aw mo bi"><span id="986e" class="mp ld jb lb b gy mq mr l ms mt">import { createStore } from "redux"; <br/>import createReducer from "./rootReducer"; </span><span id="d7b8" class="mp ld jb lb b gy mu mr l ms mt">const initializeStore = () =&gt; { <br/>  const store = createStore(createReducer()); </span><span id="893a" class="mp ld jb lb b gy mu mr l ms mt">  store.asyncReducers = {}; <br/>  store.injectReducer = (key, reducer) =&gt; { <br/>    store.asyncReducers[key] = reducer;  <br/>    store.replaceReducer(createReducer(store.asyncReducers)); <br/>    return store; <br/>  }; </span><span id="d1d7" class="mp ld jb lb b gy mu mr l ms mt">  return store; <br/>}; </span><span id="8f93" class="mp ld jb lb b gy mu mr l ms mt">export default initializeStore;</span></pre><p id="36e5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ky kz la lb b">initializeStore</code>的第一行是我们用来自<code class="fe ky kz la lb b">createReducer</code>的初始减速器创建Redux商店的地方。在标准的Redux用法中，这就是你所需要的。仓库已设置好，并准备好<code class="fe ky kz la lb b">home</code>和<code class="fe ky kz la lb b">layout</code>减速器。</p><p id="dd3d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ky kz la lb b">createStore</code>返回一个普通的对象，所以我们将利用这个优势在它上面添加有用的项目。我们将使用<code class="fe ky kz la lb b">store.asyncReducers</code>安装动态减速器。<code class="fe ky kz la lb b">store.injectReducer</code>我背离了丹的榜样。该功能与他的<code class="fe ky kz la lb b">injectAsyncReducer</code>功能相同，但为了方便起见，我将其附加到了<code class="fe ky kz la lb b">store</code>对象上。我以后会展示给你看。</p><p id="b73e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ky kz la lb b">injectReducer</code>有两个职责。首先将所有动力减速器存放在<code class="fe ky kz la lb b">asyncReducers</code>。这确保了每次我们调用<code class="fe ky kz la lb b">injectReducer</code>时，我们不会丢失其他动态减少器。接下来是主要工作。<code class="fe ky kz la lb b"><a class="ae kx" href="https://redux.js.org/docs/api/Store.html#replaceReducer" rel="noopener ugc nofollow" target="_blank">replaceReducer</a></code>不是定制的，是Redux的一部分。它做它在tin上说的事情:调用它会用你给它的函数替换reducer函数。</p><h1 id="8614" class="lc ld jb bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">对我来说事情变得棘手了</h1><p id="8f21" class="pw-post-body-paragraph jy jz jb ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">在这一点上，对我来说一切都很简单，但是我很快就迷路了。我有一个存储，我有一个函数来添加新的reducers，但是我在哪里可以访问该函数来调用它呢？在我疯狂的谷歌搜索中，我找不到一个适合我的例子。所以，我坐下来想出了一个解决方案。</p><p id="b19f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我花了一段时间才想出在哪里可以访问那个<code class="fe ky kz la lb b">store</code>对象。不过，我有线索。在我的入口点文件<code class="fe ky kz la lb b">/index.js</code>中，我使用了<code class="fe ky kz la lb b">Provider</code>组件。这是reactor/Redux项目的标准要求。</p><pre class="mh mi mj mk gt ml lb mm mn aw mo bi"><span id="9799" class="mp ld jb lb b gy mq mr l ms mt">import React from "react"; <br/>import { render } from "react-dom"; <br/>import { Provider } from "react-redux"; <br/>import initializeStore from "./initializeStore"; <br/>import App from "./App"; </span><span id="ff27" class="mp ld jb lb b gy mu mr l ms mt">const store = initializeStore(); <br/>render( <br/>  &lt;Provider store={store}&gt; <br/>    &lt;App /&gt; <br/>  &lt;/Provider&gt;, <br/>  document.getElementById("root") <br/>);</span></pre><p id="e54a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将<code class="fe ky kz la lb b">store</code>赋予<code class="fe ky kz la lb b">Provider</code>使其通过<code class="fe ky kz la lb b">connect</code>功能可用于所有子组件。我读了更多关于它的东西，并且了解到<code class="fe ky kz la lb b">store</code>在每个组件的<code class="fe ky kz la lb b">context</code>中也有提供。如果你读过任何关于反应<code class="fe ky kz la lb b">context</code>的东西，你就已经读到你可能不应该使用它。对我来说，这里似乎足够孤立，可以接受。时间会证明这是对还是错。稍后会有更多关于我的<code class="fe ky kz la lb b">context</code>用法的细节。</p><h1 id="84ca" class="lc ld jb bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">把这些碎片放在一起</h1><p id="1869" class="pw-post-body-paragraph jy jz jb ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">我想用尽可能少的代码来添加减压器。我用<code class="fe ky kz la lb b">/withReducer.js</code>中的<a class="ae kx" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶成分</a>来做这个。</p><pre class="mh mi mj mk gt ml lb mm mn aw mo bi"><span id="969b" class="mp ld jb lb b gy mq mr l ms mt">import React from "react"; <br/>import { object } from "prop-types"; </span><span id="8682" class="mp ld jb lb b gy mu mr l ms mt">const withReducer = (key, reducer) =&gt; WrappedComponent =&gt; { <br/>  const Extended = (props, context) =&gt; { <br/>    context.store.injectReducer(key, reducer); <br/>    return &lt;WrappedComponent {...props} /&gt; <br/>  }; </span><span id="30c9" class="mp ld jb lb b gy mu mr l ms mt">  Extended.contextTypes = { <br/>    store: object <br/>  }; </span><span id="a4c8" class="mp ld jb lb b gy mu mr l ms mt">  return Extended;<br/>}; </span><span id="18b1" class="mp ld jb lb b gy mu mr l ms mt">export { withReducer };</span></pre><p id="39ef" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ky kz la lb b">routes/Records/Records.js</code>中的用法示例:</p><pre class="mh mi mj mk gt ml lb mm mn aw mo bi"><span id="bb27" class="mp ld jb lb b gy mq mr l ms mt">import { withReducer } from "../../withReducer"; <br/>import reducer from "./ducks"; </span><span id="4d64" class="mp ld jb lb b gy mu mr l ms mt">const Records = () =&gt; (...); </span><span id="e6c4" class="mp ld jb lb b gy mu mr l ms mt">export default withReducer("records", reducer)(Records);</span></pre><p id="d7e5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我先从<code class="fe ky kz la lb b">Records.js</code>中的用法说起。我从<code class="fe ky kz la lb b">routes/Records/ducks/index.js</code>导入记录缩减器。reducer做的不多:它设置一个硬编码的初始状态，然后按原样返回。该组件的作用类似于容器组件。我可以<code class="fe ky kz la lb b">connect</code>它，但是为了这个演示的目的，把它省略了。</p><p id="810b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相关的部分是最后一行。在那里，我调用<code class="fe ky kz la lb b">withReducer</code>，并为它提供一个“records”键和记录缩减器。然后我调用返回的函数，提供<code class="fe ky kz la lb b">Records</code>组件。</p><p id="c0db" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ky kz la lb b">Records</code>是我导入的React组件，用作React路由器<code class="fe ky kz la lb b">&lt;Route /&gt;</code>的<code class="fe ky kz la lb b">component</code>属性值。</p><h1 id="d05a" class="lc ld jb bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">withReducer组件</h1><p id="61c2" class="pw-post-body-paragraph jy jz jb ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated"><code class="fe ky kz la lb b">withReducer</code>是<a class="ae kx" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">的高阶元件</a>。<code class="fe ky kz la lb b">key</code>参数成为Redux状态树中的关键字。<code class="fe ky kz la lb b">reducer</code>参数是要添加的减速器。它返回一个接受单个参数<code class="fe ky kz la lb b">WrappedComponent</code>的函数，该参数应该是一个有效的React组件。在前面的使用示例中，那是<code class="fe ky kz la lb b">Records</code>组件。</p><p id="cdbb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将跳到<code class="fe ky kz la lb b">withReducer</code>的一个重要部分，它对我来说是新的，可能会令人困惑。</p><pre class="mh mi mj mk gt ml lb mm mn aw mo bi"><span id="28b7" class="mp ld jb lb b gy mq mr l ms mt">... <br/>Extended.contextTypes = { store: object }; <br/>...</span></pre><p id="ab7f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ky kz la lb b">Extended</code>是一个无状态组件，所以它必须定义一个<code class="fe ky kz la lb b">contextTypes</code>属性来访问<code class="fe ky kz la lb b">context</code>。从React文档中:</p><blockquote class="mv mw mx"><p id="0524" class="jy jz kw ka b kb kc kd ke kf kg kh ki my kk kl km mz ko kp kq na ks kt ku kv ij bi translated"><em class="jb">如果contextTypes被定义为函数的属性，无状态功能组件也能够引用上下文。</em></p><p id="8655" class="jy jz kw ka b kb kc kd ke kf kg kh ki my kk kl km mz ko kp kq na ks kt ku kv ij bi translated"><a class="ae kx" href="https://reactjs.org/docs/context.html#referencing-context-in-stateless-functional-components" rel="noopener ugc nofollow" target="_blank"><em class="jb">react js . org/docs/context . html # referencing-context-in-stateless-functional-components</em></a></p></blockquote><p id="3e17" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe ky kz la lb b">contextTypes</code>中，我在组件<code class="fe ky kz la lb b">store</code>中定义了我想要访问的属性。它使用了来自<code class="fe ky kz la lb b">prop-types</code>库中的<code class="fe ky kz la lb b">object</code>类型。</p><p id="de86" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当一个组件定义了一个<code class="fe ky kz la lb b">contextTypes</code>属性时，它接收第二个参数<code class="fe ky kz la lb b">context</code>。这可以从<code class="fe ky kz la lb b">Extended</code>签名中看出:</p><pre class="mh mi mj mk gt ml lb mm mn aw mo bi"><span id="b573" class="mp ld jb lb b gy mq mr l ms mt">... <br/>const Extended = (props, context) =&gt; {...} <br/>...</span></pre><p id="b7ef" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ky kz la lb b">Extended</code>现在可以访问<code class="fe ky kz la lb b">store</code>对象。这是因为<code class="fe ky kz la lb b">/index.js</code>中的<code class="fe ky kz la lb b">&lt;Provider store={store}&gt;</code>通过<code class="fe ky kz la lb b">context</code>使其对所有子组件可用。</p><p id="26df" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这发生在带有<code class="fe ky kz la lb b"><a class="ae kx" href="https://github.com/reactjs/react-redux/blob/master/src/components/Provider.js#L26" rel="noopener ugc nofollow" target="_blank">getChildContext</a></code>和<code class="fe ky kz la lb b"><a class="ae kx" href="https://github.com/reactjs/react-redux/blob/master/src/components/Provider.js#L52" rel="noopener ugc nofollow" target="_blank">childContextTypes</a></code>的<code class="fe ky kz la lb b">Provider.js</code>源中。如果你正在寻找<code class="fe ky kz la lb b">context</code>用法的例子，这段代码是很好的读物。</p><p id="9aa7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe ky kz la lb b">initializeStore.js</code>中，我在store对象上创建了一个函数<code class="fe ky kz la lb b">store.injectReducer</code>。现在，我用它来添加新的减速器:</p><pre class="mh mi mj mk gt ml lb mm mn aw mo bi"><span id="e694" class="mp ld jb lb b gy mq mr l ms mt">... <br/>const Extended = (props, context) =&gt; { <br/>  context.store.injectReducer(key, reducer); <br/>  return &lt;WrappedComponent {...props} /&gt;; <br/>}; <br/>...</span></pre><p id="49f3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">原来的成分不变。<code class="fe ky kz la lb b">Extended</code>只返回它的任何原始属性。</p><h1 id="58c0" class="lc ld jb bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">如何看待这项工作</h1><p id="be36" class="pw-post-body-paragraph jy jz jb ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">此时，代码工作了，但是这种类型的更改很难可视化。如前所述，<a class="ae kx" href="https://github.com/zalmoxisus/redux-devtools-extension" rel="noopener ugc nofollow" target="_blank"> Redux DevTools Chrome扩展</a>可以很好地实现这个目的。在<a class="ae kx" href="https://qk3n9xmm3w.codesandbox.io/" rel="noopener ugc nofollow" target="_blank">演示</a>中，我在创建商店时包含了DevTools片段。如果您安装扩展并查看Redux面板，您可以看到新的Redux改变了状态树。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nb"><img src="../Images/62edfea278de90acf2af6da4bc8013ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2F2Yo2IAUGhUTbgu.gif"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated"><em class="ng">导航到/records路线时添加记录缩减器的演示。</em></figcaption></figure><p id="dae6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了在演示中进一步展示结果，我<code class="fe ky kz la lb b">connect</code>添加了记录路径来显示来自商店的记录数据。</p><pre class="mh mi mj mk gt ml lb mm mn aw mo bi"><span id="6b3d" class="mp ld jb lb b gy mq mr l ms mt">... <br/>const mapStateToProps = (state, props) =&gt; { <br/>  const { match: { params: { id } } } = props; </span><span id="fe6d" class="mp ld jb lb b gy mu mr l ms mt">  return { <br/>    recordId: id, <br/>    record: state.records[id] || {} <br/>  }; <br/>}; </span><span id="4cb9" class="mp ld jb lb b gy mu mr l ms mt">export default connect(mapStateToProps)(Record);</span></pre><p id="8e8f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完整代码在<code class="fe ky kz la lb b">/routes/Records/routes/Record.js</code>中。</p><h1 id="e87d" class="lc ld jb bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">一个解决方案</h1><p id="43e8" class="pw-post-body-paragraph jy jz jb ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">正如我前面提到的，出于不同的原因，这是React/Redux项目中的常见需求。我过去也使用过其他类似的动态路线方法。其他人有不同的方法。也就是说，这是<em class="kw">一个</em>的解决方案，不一定是<em class="kw">一个</em>的解决方案。</p><p id="daa1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果这是有帮助的，并且你照原样使用它或者改变它以适合你的需要，让我知道。总有改进的空间。</p><p id="02c5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">感谢阅读</em></p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="0c86" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">原载于</em><a class="ae kx" href="https://tylergaw.com/articles/dynamic-redux-reducers/" rel="noopener ugc nofollow" target="_blank"><em class="kw">tylergaw.com</em></a><em class="kw">。</em></p></div></div>    
</body>
</html>