<html>
<head>
<title>Two-Pass, Two-Pointer: What’s the Difference?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二传，两分:有什么区别？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/two-pass-two-pointer-whats-the-difference-e006698db7c7?source=collection_archive---------6-----------------------#2020-08-31">https://levelup.gitconnected.com/two-pass-two-pointer-whats-the-difference-e006698db7c7?source=collection_archive---------6-----------------------#2020-08-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ea16" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">两种解决问题的技巧，以及何时使用它们。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f0158af2df52c75eb9f1c103b9b36d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dGm8C4fHf2zlw1Nr"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Emile Perron 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="d7b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">双指针技术通常用于优化字符串、数组或链表编码问题的解决方案。在简单的解决方案中，在那些数据结构之一中搜索一组元素，在最坏的情况下，可能具有多项式时间复杂度，例如O(n)，O(n)，O(n⁴等。然而，在排序数据上使用双指针技术，时间复杂度降低到O(n)。另一方面，尽管两遍方法也用于解决字符串、数组或链表编码问题，但它不一定是最佳解决方案。</p><h2 id="5cb9" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">什么是两遍法？</h2><p id="2417" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">两遍方法使用两个独立的循环来解决问题；使用的第一个循环提取一些关于输入状态的信息，第二个循环使用这些信息来解决问题。</p><p id="c4f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，排序颜色是Leetcode上提供的一个编码问题。问题的关键是将所有的对象就地排序，使相同的颜色(数字)相邻，数字从0到2排序。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="0661" class="lv lw it mu b gy my mz l na nb">Input: [2,0,2,1,1,0]<br/>Output: [0,0,1,1,2,2]</span></pre><p id="be0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然两遍方法允许我们在O(n)的最坏情况时间内解决问题，但空间复杂度也是O(n)。O(n)是因为需要在一个数据结构中存储每个数字/颜色的出现次数<em class="nc">(我使用了一个数组，但对于哈希映射也是如此，因为它仍然占用内存中的多个槽)</em>。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="ba42" class="lv lw it mu b gy my mz l na nb">/**<br/> * @param {number[]} nums<br/> * @return {void} Do not return anything, modify nums in-place instead.<br/> */<br/>var sortColors = function(nums) {<br/>    const colorMap = [0, 0, 0]<br/>    // record the number of occurences for each number/color<br/>    for (let i of nums) {<br/>        colorMap[i] += 1<br/>    }<br/>    <br/>    let start = 0<br/>    for (let key = 0; key &lt; 3; key++) {<br/>        // use colorMap to change nums in-place<br/>    }<br/>}</span></pre><p id="a0d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，存在使用两遍方法产生最佳空间复杂度的实例，例如，在Leetcode问题中移动零。在这个问题中，输入中的所有零必须在数组的末尾，并且必须就地发生。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="a9e1" class="lv lw it mu b gy my mz l na nb">Input: [0,1,0,3,12]<br/>Output: [1,3,12,0,0]</span></pre><p id="e6a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，两遍方法中的第一个循环计算输入中零出现的次数，并将数据存储为整数变量。因此，空间复杂度为O(1)。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="f6fd" class="lv lw it mu b gy my mz l na nb">/**<br/> * @param {number[]} nums<br/> * @return {void} Do not return anything, modify nums in-place instead.<br/> */<br/>var moveZeroes = function(nums) {<br/>    let count = 0<br/>    for (x of nums) {<br/>        count += x == 0 ? 1 : 0<br/>    }<br/>    <br/>    let ptr = 0<br/>    let found = 0<br/>    while (ptr &lt; nums.length &amp;&amp; found != count) {<br/>        //solve using the count<br/>    }<br/>};</span></pre><h2 id="5806" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">两点法是什么？</h2><p id="3d9f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">双指针方法使用两个变量来跟踪数据结构中的每个元素。然而，与两遍方法不同，双指针技术为我们提供了一点灵活性来预测、回顾和比较不同的数据窗口。它分析输入的状态，并在循环的每次迭代中对其进行转换。</p><p id="7270" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种类型的双指针技术。</p><p id="4aff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">同向:</strong>两个指针都从头开始，但一个是快速运行的指针，而第二个指针是慢速运行的指针。当满足某些条件时，慢速运行指针被更新。这种双指针技术可以帮助我们分析输入的不同窗口，探索和比较输入的子集，或者检测输入中的循环。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/74d155dc22952a1feb2bb573dad89df7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sQrZ6lX6Ibw7svpJOQgP6w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://algodaily.com/" rel="noopener ugc nofollow" target="_blank"> AlgoDaily </a>在<a class="ae ky" href="https://algodaily.com/lessons/using-the-two-pointer-technique/what-is-the-pattern-2?view=article" rel="noopener ugc nofollow" target="_blank">使用双指针技术</a></figcaption></figure><p id="c21f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个排序颜色的示例解决方案，使用了<strong class="lb iu">同向</strong>方法。注意，慢速指针只有在快速指针搜索了整个数组后才会更新。<em class="nc">除了我提供的这个示例之外，这个解决方案还有很多内容，但这是基本的想法。</em></p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="6920" class="lv lw it mu b gy my mz l na nb">/**<br/> * @param {number[]} nums<br/> * @return {void} Do not return anything, modify nums in-place instead.<br/> */<br/>var sortColors = function(nums) {<br/>    let slow_pointer = 0 // slow pointer<br/>    let fast_pointer = n+1 // fast pointer<br/>    // other variables ...<br/>    <br/>    while (slow_pointer &lt; nums.length) {<br/>        /// do a lot of work here .....</span><span id="54da" class="lv lw it mu b gy ne mz l na nb">fast_pointer ++; // updated on every iteration</span><span id="e5cf" class="lv lw it mu b gy ne mz l na nb">if (fast_pointer &gt;= nums.length) {<br/>            slow_pointer = nxt<br/>            nxt = slow_pointer + 1<br/>            fast_pointer = nxt<br/>            // ... other variables<br/>        }<br/>    }<br/>};</span></pre><p id="f074" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">反方向:</strong>两个指针从输入的不同端开始。它们朝着对方移动，直到满足某种条件。这种双指针技术可以帮助我们在输入中有效地移动数据，比较输入的不同端，它还可以检测循环。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/7316a2752355e5ba1f7dcab32b529ac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fPburY7bTbDwpJC9OQNAuQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用双指针技术从<a class="ae ky" href="https://algodaily.com/lessons/using-the-two-pointer-technique/what-is-the-pattern-2?view=article" rel="noopener ugc nofollow" target="_blank">中的</a><a class="ae ky" href="https://algodaily.com/" rel="noopener ugc nofollow" target="_blank">算法日报</a>得到的图像</figcaption></figure><p id="c82f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个移动零点的示例解决方案中，在给定的特定条件下，两个指针彼此相向移动。在相反方向的方法中，不一定有“快指针”或“慢指针”，其思想是两个指针以相对相同的速度移动，直到它们重叠。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="bffb" class="lv lw it mu b gy my mz l na nb">/**<br/> * @param {number[]} nums<br/> * @return {void} Do not return anything, modify nums in-place instead.<br/> */<br/>var moveZeroes = function(nums) {  <br/>    ...<br/>    let pointerA = 0<br/>    let pointerB = nums.length - 1<br/>    <br/>    while (pointerA != pointerB) {<br/>        if (nums[pointerA] == 0) {<br/>            // ... do something then, update pointer<br/>            pointerB--;<br/>        } else {<br/>            pointerA++<br/>        }<br/>    }<br/>}</span></pre><h2 id="d721" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">那么你怎么知道什么时候用什么呢？</h2><p id="8b2f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，如果你不知道你在优化什么样的解决方案，你就不可能想到一个最优的解决方案。两点技术是一种优化技术，所以我相信，除非你对你的解决方案有101%的信心，否则它可能不是最好的解决方案。</p><p id="2446" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的经验是，如果你遇到一个让你的<em class="nc">两遍方法感觉</em>刺痛的问题，那么首先选择两遍方法。用它作为你的天真的解决方案是不会错的，一旦你充实了你的答案，你就可以分析你的代码来决定你是否能削减成本。</p><p id="9e9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也是面试中的绝佳话题。<strong class="lb iu">记住，面试是为了评估你解决问题的能力，而不是你能多快想到一个最佳解决方案。</strong></p><p id="c82e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以炫耀你的技能，谈论:</p><ul class=""><li id="c145" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">最坏情况下的时间和空间复杂度</li><li id="4079" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">讨论为什么两遍方法有效或无效</li><li id="358d" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">在你天真的解决方案中讨论削减成本的方法</li><li id="47b9" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">讨论如何实现双指针技术，并可能伪代码解决方案。</li></ul><p id="05f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一名面试官，如果一个人给了我一个详细、透彻的解决方案分析，我会比一个人马上给我一个最佳解决方案印象更深刻。所以，永远不要害怕或羞于选择一个天真的解决方案，比如先采用两遍方法。</p><p id="85bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解这两种方法不会错。在你的实践中，我强烈建议使用两者来解决问题，并对两者进行彻底的分析，就像你在面试一样。你将成为一个更敏锐的问题解决者，并建立与未来团队互动所必需的关键沟通技巧。</p><p id="f966" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nc">编码快乐！</em></p></div></div>    
</body>
</html>