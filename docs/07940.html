<html>
<head>
<title>Crazy, Powerful TypeScript Tuple Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">疯狂、强大的类型脚本元组类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/crazy-powerful-typescript-tuple-types-9b121e0a690c?source=collection_archive---------6-----------------------#2021-03-23">https://levelup.gitconnected.com/crazy-powerful-typescript-tuple-types-9b121e0a690c?source=collection_archive---------6-----------------------#2021-03-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c43b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了庆祝TypeScript 4.2最近的发布和该语言的持续发展，让我们来看看元组类型和我们可以用它们做的一些高级类型操作。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/47d5b1811ddde86b9877f8b665dc1309.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*t-RNef84Bhg2UKm8.png"/></div></div></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="3320" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">基本原则</h1><p id="985f" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">一个<a class="ae mh" href="https://www.typescriptlang.org/docs/handbook/basic-types.html#tuple" rel="noopener ugc nofollow" target="_blank">元组</a>(与‘夫妇’押韵，而不是‘学生’)是一个简单的数据容器。元组对象具有固定的大小，每个元素的类型是已知的，但是类型不需要相同。</p><p id="9de6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个基本元组定义是:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="8f68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个电影元组正好有3个元素，它们必须按顺序是<code class="fe mk ml mm mn b">string</code>、<code class="fe mk ml mm mn b">number</code>和<code class="fe mk ml mm mn b">Date</code>。这些结构可以很容易地分解成它们的组成部分:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="43ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里很棒的是<code class="fe mk ml mm mn b">title</code>、<code class="fe mk ml mm mn b">rating</code>、<code class="fe mk ml mm mn b">releaseDate</code>的类型都是正确的(<code class="fe mk ml mm mn b">string</code>、<code class="fe mk ml mm mn b">number</code>、<code class="fe mk ml mm mn b">Date</code>)。但是要注意如何定义它——我们不能使用类型推断，因为元组文字的语法和数组文字的语法是一样的。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="6fe5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面，电影的类型是<code class="fe mk ml mm mn b">(string | number | Date)[]</code>，所以每个析构变量的类型是联合<code class="fe mk ml mm mn b">string | number | Date</code>。此外，要意识到在运行时，在类型脚本代码被转换成JavaScript之后，元组(和类型化数组)被实现为普通的JavaScript数组。像所有与TypeScript相关的事情一样，元组的安全性和约束只存在于编译时。</p><p id="7943" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们还可以在元组中使用<a class="ae mh" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#rest-elements-in-tuple-types" rel="noopener ugc nofollow" target="_blank"> rest元素</a>。这些允许我们创建可变元组。例如:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="3bb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，rest元素的类型本身必须是元组或数组类型——在本例中是<code class="fe mk ml mm mn b">number[]</code>。</p><h1 id="56e3" class="le lf iq bd lg lh mo lj lk ll mp ln lo lp mq lr ls lt mr lv lw lx ms lz ma mb bi translated">利益</h1><p id="febb" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我们当然可以将一部电影表现为一个类或接口，我们将永远拥有这个选项。但是，元组在以下情况下特别有用:</p><ul class=""><li id="beb7" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">从函数中返回多个值</li><li id="187a" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">析构为具有任意名称的变量</li><li id="5e5c" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">表示一个函数的参数(稍后会详细介绍)</li></ul><p id="41f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前两点的一个很好的例子就是React的<code class="fe mk ml mm mn b"><a class="ae mh" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank">useState</a></code>函数。当您调用这个函数时，它返回一个状态的当前值和一个更新该状态的函数。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="6699" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在一个元组中同时返回两者是有用的，因为您可以立即析构并使用任意名称。为了充分看到优势，想象一下如果在一个通用的<code class="fe mk ml mm mn b">State</code>对象中返回相同的数据。您需要使用更详细的析构别名或使用对象引用。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="4d02" class="le lf iq bd lg lh mo lj lk ll mp ln lo lp mq lr ls lt mr lv lw lx ms lz ma mb bi translated">元组形式的函数参数</h1><p id="35bb" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">把参数表示成元组怎么样？你可能已经见过<a class="ae mh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" rel="noopener ugc nofollow" target="_blank"> rest parameters </a>，将'<code class="fe mk ml mm mn b">...</code>'应用到函数的最后一个参数来创建变量函数。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="1f47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在调用点，我们可以使用可变数量的参数。这些被聚集到<code class="fe mk ml mm mn b">sum</code>函数中的一个数组中。</p><p id="86f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在TypeScript中，我们可以将聚集的参数表示为数组或元组。这允许用几种方式定义函数签名。考虑一个带3个参数的正态函数:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="7fb0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用类型化为元组的rest参数进行重写:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="75c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者使用参数析构:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="e694" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这很有趣，但是有用吗？它<em class="nh">是</em>有用的，因为元组是表示多个参数的单个实体。这在与泛型结合时特别有用，在泛型中，我们直到调用时才指定类型。让我们看一个实际的例子。</p><h1 id="24bb" class="le lf iq bd lg lh mo lj lk ll mp ln lo lp mq lr ls lt mr lv lw lx ms lz ma mb bi translated">正在检查<code class="fe mk ml mm mn b">Promise.all</code></h1><p id="ca6e" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated"><code class="fe mk ml mm mn b"><a class="ae mh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">Promise</a></code>类型包装了异步操作，并有一些有用的静态方法来组合多个承诺。</p><p id="e0d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mk ml mm mn b"><a class="ae mh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank">Promise.all</a></code>方法接受一个承诺数组，并返回一个新的承诺，当所有输入承诺解析时，该承诺解析所有结果。我们可以随后使用<code class="fe mk ml mm mn b">then</code>方法或<code class="fe mk ml mm mn b">async await</code>来消费结果。例如:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="de2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者通过解构:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="c266" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有趣的是<code class="fe mk ml mm mn b">name</code>、<code class="fe mk ml mm mn b">age</code>和<code class="fe mk ml mm mn b">startDate</code>都有预期的类型。输入参数类型<code class="fe mk ml mm mn b">Promise&lt;string&gt;</code>、<code class="fe mk ml mm mn b">Promise&lt;number&gt;</code>和<code class="fe mk ml mm mn b">Promise&lt;Date&gt;</code>与结果的类型相关联，即一个类型为<code class="fe mk ml mm mn b">[string, number, Date]</code>的元组。让我们看看这是如何实现的(我已经简化了定义):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="29b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，该定义使用了一系列重载，泛型参数的数量不断增加，最多可达10个。这些通用参数将输入<strong class="jp ir">承诺元组</strong>关联到元组的输出<strong class="jp ir">承诺。</strong></p><p id="28d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我说代码简化为<code class="fe mk ml mm mn b">Promise.all</code>实际上支持接受承诺对象和普通对象。此外，第一个重载实际上支持任意数量的相同类型的输入。所以实际的定义是:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="bdd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的缺点是，它需要多个重载定义(冗余)，并且最多有10个参数。如果我添加第11个参数，我会得到一个编译器错误。看看能不能改进。</p><h1 id="0e84" class="le lf iq bd lg lh mo lj lk ll mp ln lo lp mq lr ls lt mr lv lw lx ms lz ma mb bi translated">改进<code class="fe mk ml mm mn b">Promise.all</code></h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/04839cdb23a78a5491bf40534b1f9875.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*kuZyQAA21_4BPI9U.jpg"/></div></figure><p id="0a9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以创建一个函数，将元组类型捕获为单个泛型参数。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="d975" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们稍后会看到<code class="fe mk ml mm mn b">RemapPromises</code>,但是现在要意识到它会将一个<strong class="jp ir">承诺元组</strong>类型转换为元组类型的<strong class="jp ir">承诺。</strong></p><p id="00b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个函数中，通用参数<code class="fe mk ml mm mn b">T</code>被约束为任何元素的元组。类型是从用法中推断出来的，例如:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="529b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们也可以使用一个rest参数来定义我们的函数，使其可变，并从调用位置删除“<code class="fe mk ml mm mn b">[]</code>”。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="57d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最大的优势是我们有一个单一的定义，我们可以有超过10个论点。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="b8dc" class="le lf iq bd lg lh mo lj lk ll mp ln lo lp mq lr ls lt mr lv lw lx ms lz ma mb bi translated">重新映射类型</h1><p id="1261" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">其中一个复杂的位是<code class="fe mk ml mm mn b">RemapPromises</code>型。幸运的是，在上面，我们把它藏在一个别名中，这样我们直到现在才需要考虑它。这个问题的解决方案使用了我之前的一篇文章中讨论的一些概念，<a class="ae mh" href="https://medium.com/swlh/crazy-powerful-typescript-4-1-features-26036f4de6bc" rel="noopener">疯狂、强大的TypeScript 4.1特性</a>。</p><p id="ec86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们定义一个类型来获取一个<code class="fe mk ml mm mn b">Promise&lt;T&gt; | T</code>并返回<code class="fe mk ml mm mn b">T</code>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="4acb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这使用了一个<a class="ae mh" href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html" rel="noopener ugc nofollow" target="_blank">条件类型</a>和类型推断来计算输入承诺类型的内部类型。如果输入类型<code class="fe mk ml mm mn b">T</code>不是承诺类型，则直接使用。</p><p id="705d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们可以使用递归条件类型对tuple中的所有元素执行此操作，将<code class="fe mk ml mm mn b">[Promise&lt;T1&gt;, Promise&lt;T2&gt;, ..., Promise&lt;TN&gt;]</code>转换为<code class="fe mk ml mm mn b">[T1, T2, ..., TN]</code>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="9957" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们再次使用条件类型和推理来提取输入元组的<code class="fe mk ml mm mn b">Head</code>和<code class="fe mk ml mm mn b">Tail</code>。然后，我们可以使用之前定义的<code class="fe mk ml mm mn b">UnwrapPromise</code>来展开<code class="fe mk ml mm mn b">Head</code>，并递归调用<code class="fe mk ml mm mn b">UnwrapPromises</code>(注意“s”)来展开尾部。这些被组合成一个结果元组。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="890d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们可以使用这个“未包装”承诺的元组来创建我们的最终承诺元组。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="5fb9" class="le lf iq bd lg lh mo lj lk ll mp ln lo lp mq lr ls lt mr lv lw lx ms lz ma mb bi translated">为什么不这样实施？</h1><p id="928f" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">标准的<code class="fe mk ml mm mn b">Promise.all</code>定义可能最终会变成这样，但是可能会有一些我没有考虑到的问题。我只是把它作为一个实际的例子来演示，来说明你可以用元组类型、递归条件类型等做什么。您可以在自己的代码中考虑其他用例。</p><p id="02f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当对一门语言的标准库进行修改时，定义需要支持现存的所有类型脚本代码，你需要比我在这里做的更严格一些。对向后兼容性、极限情况、编译器性能等的考虑会影响任何最终的定义。我很乐意在评论中听到你对这个问题的想法。</p><h1 id="8e72" class="le lf iq bd lg lh mo lj lk ll mp ln lo lp mq lr ls lt mr lv lw lx ms lz ma mb bi translated">TypeScript 4.2增加了什么？</h1><p id="8255" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">TypeScript 4.2为元组类型带来了一个特性，那就是在前导或中间元素上扩展的能力。例如，这里我们有一个元组，其中中间的元素是一系列可变长度的<code class="fe mk ml mm mn b">number</code>:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="9e3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当与rest参数结合使用来创建前导或中间参数的可变函数时，这可能会很有用。考虑一个断言函数来测试是否所有的值都相等，如果不相等就抛出一个错误和一条特定的消息。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="0644" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个函数必须用两个或更多的数字来调用，后面跟一个字符串，我们不能用普通的rest参数来调用。</p><p id="532b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不确定你会经常创建这种形状的函数。没有办法轻松地析构元组，因为rest析构必须总是最后一个元素。所以这里我们使用切片和索引以及显式类型断言。我认为将多个函数、参数作为对象、重载或尾随rest参数通常是正确的答案。</p><p id="7260" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这对于安全地键入使用这种形状的JavaScript函数可能是有用的。</p><h1 id="76e9" class="le lf iq bd lg lh mo lj lk ll mp ln lo lp mq lr ls lt mr lv lw lx ms lz ma mb bi translated">结论</h1><p id="eff8" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">小的、基本的元组本身非常有用，但是当你深入研究并与泛型、递归条件类型和rest元素相结合时，你可以获得一些有趣的结果。</p><p id="dc21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请务必查看我的<a class="ae mh" href="https://medium.com/swlh/crazy-powerful-typescript-4-1-features-26036f4de6bc" rel="noopener"> TypeScript 4.1帖子</a>，在那里我讨论了递归条件。另外，要查看与<code class="fe mk ml mm mn b">useState</code>一起使用的元组的例子，看看我的<a class="ae mh" href="https://medium.com/swlh/crazy-powerful-typescript-4-1-features-26036f4de6bc" rel="noopener">反应教程</a>。</p><p id="91a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望你觉得这很有趣。请务必查看我们的<a class="ae mh" href="https://instil.co/courses/typescript-introduction/" rel="noopener ugc nofollow" target="_blank">打字稿</a>课程。我们也很乐意使用TypeScript提供<a class="ae mh" href="https://instil.co/courses/react-with-typescript/" rel="noopener ugc nofollow" target="_blank"> React培训</a>。我们几乎为世界各地的公司提供服务，并且很乐意根据您团队的水平和具体需求定制我们的课程。</p><p id="62b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原贴<a class="ae mh" href="https://instil.co/blog/crazy-powerful-typescript-tuple-types/" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></div></div>    
</body>
</html>