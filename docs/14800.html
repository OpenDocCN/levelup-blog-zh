<html>
<head>
<title>How To Use .groupby() Effectively As A Data Scientist</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用。groupby()有效地作为数据科学家</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-use-groupby-effectively-as-a-data-scientist-9e1d931e1619?source=collection_archive---------1-----------------------#2022-12-26">https://levelup.gitconnected.com/how-to-use-groupby-effectively-as-a-data-scientist-9e1d931e1619?source=collection_archive---------1-----------------------#2022-12-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3722" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi ko translated">作为一名数据科学家，使用正确的工具和技术来充分利用数据是非常重要的。Pandas库是一个非常棒的数据操作、分析和可视化工具，也是任何数据科学家工具箱中必不可少的一部分。然而，有效地使用熊猫是一个挑战，这会导致时间和精力的浪费。幸运的是，有一些最佳实践可以帮助数据科学家充分利用他们的熊猫体验。从使用矢量化操作到利用内置函数，这些最佳实践将帮助数据科学家使用Pandas快速准确地分析和可视化数据。了解并应用这些最佳实践将有助于数据科学家提高工作效率和准确性，从而更快地做出更好的决策。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/15c56195df0ebc653083ea7ecedbf42f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-f4WiRspjvXS_gLJ"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">由<a class="ae ln" href="https://unsplash.com/@martinsanchez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马丁·桑切斯</a>在<a class="ae ln" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="e76a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将使用如何使用<strong class="js iu">。groupby() </strong>根据特定特性的值有效地对数据帧的条目进行分组。<strong class="js iu">。groupby() </strong>方法应用于数据帧，并根据特征对其进行分组。然后，我们可以对分组的对象应用一些简单或更复杂的函数。对于每一个从事表格或结构化数据工作的<strong class="js iu">数据科学家</strong>来说，这是一个非常重要的工具，因为它将帮助你更容易、更有效地操作数据。</p><h2 id="fe49" class="lo lp it bd lq lr ls dn lt lu lv dp lw kb lx ly lz kf ma mb mc kj md me mf mg bi translated">目录:</h2><ol class=""><li id="428b" class="mh mi it js b jt mj jx mk kb ml kf mm kj mn kn mo mp mq mr bi translated"><strong class="js iu">为什么我们需要高效的编码？</strong></li><li id="0f57" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><strong class="js iu">与一起使用的常用功能。groupby() </strong></li><li id="5e7e" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><strong class="js iu">缺失值插补使用。groupby() &amp;。变换()</strong></li><li id="5983" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><strong class="js iu">数据过滤使用。groupby() &amp;。过滤器()</strong></li></ol><h2 id="4057" class="lo lp it bd lq lr ls dn lt lu lv dp lw kb lx ly lz kf ma mb mc kj md me mf mg bi translated">您可以在GitHub知识库中找到本文中使用的代码和数据集:</h2><div class="mx my gp gr mz na"><a href="https://github.com/youssefHosni/Efficient-Python-for-Data-Scientists" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">GitHub-youssefHosni/面向数据科学家的高效Python</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">作为数据科学家学习如何编写高效的python代码如何编写Python干净的代码[文章]编写高效…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">github.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no lh na"/></div></div></a></div></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="a56f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想免费学习数据科学和机器学习，看看这些资源:</p><ul class=""><li id="6d73" class="mh mi it js b jt ju jx jy kb nw kf nx kj ny kn nz mp mq mr bi translated">免费互动路线图，自学数据科学和机器学习。从这里开始:<a class="ae ln" href="https://aigents.co/learn/roadmaps/intro" rel="noopener ugc nofollow" target="_blank">https://aigents.co/learn/roadmaps/intro</a></li><li id="5ec4" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn nz mp mq mr bi translated">数据科学学习资源搜索引擎(免费)。将你最喜欢的资源加入书签，将文章标记为完整，并添加学习笔记。<a class="ae ln" href="https://aigents.co/learn" rel="noopener ugc nofollow" target="_blank">https://aigents.co/learn</a></li><li id="d26e" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn nz mp mq mr bi translated">想要在导师和学习社区的支持下从头开始学习数据科学吗？免费加入这个学习圈:【https://community.aigents.co/spaces/9010170/】T2</li></ul></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="c01f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">如果你想在数据科学&amp;人工智能领域开始职业生涯，但不知道如何开始。我提供数据科学指导课程和长期职业指导:</strong></p><ul class=""><li id="922f" class="mh mi it js b jt ju jx jy kb nw kf nx kj ny kn nz mp mq mr bi translated">长期师徒:<a class="ae ln" href="https://lnkd.in/dtdUYBrM" rel="noopener ugc nofollow" target="_blank">https://lnkd.in/dtdUYBrM</a></li><li id="c794" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn nz mp mq mr bi translated">辅导课程:<a class="ae ln" href="https://lnkd.in/dXeg3KPW" rel="noopener ugc nofollow" target="_blank">https://lnkd.in/dXeg3KPW</a></li></ul><p id="d774" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="oa">加入</em> </strong> <a class="ae ln" href="https://youssefraafat57.medium.com/membership" rel="noopener"> <strong class="js iu"> <em class="oa">中等会员</em> </strong> </a> <strong class="js iu"> <em class="oa">计划继续无限制学习。如果你使用下面的链接，我会收到一小部分会员费，不需要你额外付费。</em> </strong></p><div class="mx my gp gr mz na"><a href="https://youssefraafat57.medium.com/membership" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">加入我的介绍链接媒体-优素福胡斯尼</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">阅读Youssef Hosni(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">youssefraafat57.medium.com</p></div></div><div class="nj l"><div class="ob l nl nm nn nj no lh na"/></div></div></a></div></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="de53" class="oc lp it bd lq od oe of lt og oh oi lw oj ok ol lz om on oo mc op oq or mf os bi translated">1.为什么我们需要高效的编码？</h1><p id="8f86" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ot kd ke kf ou kh ki kj ov kl km kn im bi translated">高效代码是指执行速度更快、计算内存更少的代码。在本文中，我们将使用<strong class="js iu"> time() </strong>函数来测量计算时间。这个函数测量当前时间，所以我们将在代码执行前和执行后把它赋给一个变量，然后计算差值，就知道代码的计算时间。下面的代码显示了一个简单的例子:</p><pre class="ky kz la lb gt ow ox oy bn oz pa bi"><span id="6710" class="pb lp it ox b be pc pd l pe pf">import time<br/># record time before execution<br/>start_time = time.time()<br/># execute operation<br/>result = 5 + 2<br/># record time after execution<br/>end_time = time.time()<br/>print("Result calculated in {} sec".format(end_time - start_time))</span></pre><p id="12df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看一些应用高效代码方法将如何提高代码运行时间和降低计算时间复杂性的例子:我们将计算从零到一百万的每个数字的平方。首先，我们将使用list comprehension来执行这个操作，然后使用for循环重复相同的过程。</p><p id="5aaf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一次使用列表理解:</p><pre class="ky kz la lb gt ow ox oy bn oz pa bi"><span id="29d5" class="pb lp it ox b be pc pd l pe pf">#using List comprehension <br/><br/>list_comp_start_time = time.time()<br/>result = [i*i for i in range(0,1000000)]<br/>list_comp_end_time = time.time()<br/>print("Time using the list_comprehension: {} sec".format(list_comp_end_time -<br/>list_comp_start_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/9ab80eec9ee70a737a29a69ac4598366.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/0*GPg-J9H2qz_TZbXP.png"/></div></figure><p id="6d8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们将使用for循环来执行相同的操作:</p><pre class="ky kz la lb gt ow ox oy bn oz pa bi"><span id="1b42" class="pb lp it ox b be pc pd l pe pf"># Using For loop<br/><br/>for_loop_start_time= time.time()<br/>result=[]<br/>for i in range(0,1000000):<br/>  result.append(i*i)<br/>for_loop_end_time= time.time()<br/>print("Time using the for loop: {} sec".format(for_loop_end_time - for_loop_start_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/407ccd9e7bbc3b048164ef3a4be1cf72.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/0*vnv9AQ4zNfE4nnnP.png"/></div></figure><p id="d222" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到它们之间有很大的差异，我们可以用百分比来计算它们之间的差异:</p><pre class="ky kz la lb gt ow ox oy bn oz pa bi"><span id="1479" class="pb lp it ox b be pc pd l pe pf">list_comp_time = list_comp_end_time - list_comp_start_time<br/>for_loop_time = for_loop_end_time - for_loop_start_time<br/>print("Difference in time: {} %".format((for_loop_time - list_comp_time)/<br/>list_comp_time*100))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/6154590862e9ab639509b7495608d8b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/0*JksMrLUJc_ybNYJZ.png"/></div></figure><p id="784e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有另一个例子来展示编写高效代码的效果。我们想计算从1到100万的所有连续数字的总和。有两种方法第一种是使用蛮力，我们将一个接一个地增加到一百万。</p><pre class="ky kz la lb gt ow ox oy bn oz pa bi"><span id="4737" class="pb lp it ox b be pc pd l pe pf">def sum_brute_force(N):<br/>  res = 0<br/>  for i in range(1,N+1):<br/>    res+=i<br/>  return res<br/><br/># Using brute force<br/>bf_start_time = time.time()<br/>bf_result = sum_brute_force(1000000)<br/>bf_end_time = time.time()<br/><br/>print("Time using brute force: {} sec".format(bf_end_time - bf_start_time))</span></pre><p id="3e7e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个更有效的方法是用公式来计算。当我们想计算从1到一个数的所有整数的和时，比如说N，我们可以把N乘以N+1，然后除以2，这样就会得到我们想要的结果。这个问题实际上在19世纪就交给了德国的一些学生，一个名叫卡尔-弗里德里希·高斯的聪明学生设计了这个公式来在几秒钟内解决这个问题。</p><pre class="ky kz la lb gt ow ox oy bn oz pa bi"><span id="a7f9" class="pb lp it ox b be pc pd l pe pf">def sum_formula(N):<br/>  return N*(N+1)/2<br/>  <br/># Using the formula<br/>formula_start_time = time.time()<br/>formula_result = sum_formula(1000000)<br/>formula_end_time = time.time()<br/><br/>print("Time using the formula: {} sec".format(formula_end_time - formula_start_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/f48563bdd836401dde86b9fd5befbb9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/0*C_gpP0KZX8djtL8G.png"/></div></figure><p id="fa02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行这两种方法后，我们实现了超过160，000%的巨大改进，这清楚地表明了为什么我们需要高效和优化的代码，即使对于简单的任务也是如此。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="a9e6" class="oc lp it bd lq od oe of lt og oh oi lw oj ok ol lz om on oo mc op oq or mf os bi translated">2.与一起使用的常用函数。groupby()</h1><p id="8429" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ot kd ke kf ou kh ki kj ov kl km kn im bi translated">应用于聚合组的最简单方法之一是<strong class="js iu">。计数()。</strong>在下面的例子中，我们将把它应用于餐馆数据集。首先，我们根据顾客是否吸烟对餐馆数据进行分组。然后，我们应用<strong class="js iu">。</strong>计数()方法。我们获得了吸烟者和不吸烟者的人数。</p><pre class="ky kz la lb gt ow ox oy bn oz pa bi"><span id="a871" class="pb lp it ox b be pc pd l pe pf">restaurant = pd.read_csv('restaurant_data.csv')<br/><br/>restaurant_grouped = restaurant.groupby('smoker')<br/>print(restaurant_grouped.count())</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/b8487460c17d456e09889238ceb87905.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/0*io4FN_swTTSJ9PRH.png"/></div></figure><p id="43c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">毫不奇怪，我们得到的所有特征的结果都与<strong class="js iu">相同。count() </strong>方法统计每组在每个特征中出现的次数。因为我们的数据中没有缺失值，所以所有列中的结果应该是相同的。</p><p id="f946" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据特定特性的值对数据帧的条目进行分组后，我们可以应用我们感兴趣的任何类型的<strong class="js iu">转换</strong>。这里，我们将应用z得分，这是一种归一化变换，即每个值与平均值之间的距离除以标准差。这是统计学中非常有用的变换，通常在标准化测试中与z测试一起使用。要将这种转换应用于分组对象，我们只需调用。transform()方法包含我们定义的lambda转换。</p><p id="1e4f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这次，我们将根据<strong class="js iu">餐</strong>的类型分组:是晚餐还是午餐？由于z得分转换是与组相关的转换，因此生成的表只是原始表。对于每个元素，我们减去平均值，然后除以它所属组的标准偏差。我们还可以看到，数值变换只应用于数据帧的数值特征。</p><pre class="ky kz la lb gt ow ox oy bn oz pa bi"><span id="e512" class="pb lp it ox b be pc pd l pe pf">zscore = lambda x: (x - x.mean() ) / x.std()<br/><br/>restaurant_grouped = restaurant.groupby('time')<br/><br/>restaurant_transformed = restaurant_grouped.transform(zscore)<br/>restaurant_transformed.head()</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/6f5bbb8e0ecaf2f137eff14b56ff1574.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/0*mis7RtD_CKx8mydW.png"/></div></figure><p id="a151" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然<strong class="js iu"> transform() </strong>方法大大简化了事情，但它真的比使用原生Python代码更有效吗？正如我们之前所做的，我们首先对数据进行分组，这次是根据性别进行分组。然后，我们应用之前应用的z分数变换，测量其效率。我们在这里省略了测量每个操作时间的代码，因为您对此已经很熟悉了。我们可以看到，通过使用transform()函数，我们实现了巨大的速度提升。除此之外，我们只使用一行代码来执行感兴趣的操作。</p><pre class="ky kz la lb gt ow ox oy bn oz pa bi"><span id="c19b" class="pb lp it ox b be pc pd l pe pf">restaurant.groupby('sex').transform(zscore)<br/><br/>mean_female = restaurant.groupby('sex').mean()['total_bill']['Female']<br/>mean_male = restaurant.groupby('sex').mean()['total_bill']['Male']<br/>std_female = restaurant.groupby('sex').std()['total_bill']['Female']<br/>std_male = restaurant.groupby('sex').std()['total_bill']['Male']<br/><br/>for i in range(len(restaurant)):<br/>  if restaurant.iloc[i][2] == 'Female':<br/>    restaurant.iloc[i][0] = (restaurant.iloc[i][0] - mean_female)/std_female<br/>  else:<br/>    restaurant.iloc[i][0] = (restaurant.iloc[i][0] - mean_male)/std_male</span></pre></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="6fa9" class="oc lp it bd lq od oe of lt og oh oi lw oj ok ol lz om on oo mc op oq or mf os bi translated">3.缺失值插补使用。groupby() &amp;。转换()</h1><p id="2b8b" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ot kd ke kf ou kh ki kj ov kl km kn im bi translated">既然我们已经看到了为什么以及如何在一个分组的熊猫对象上使用<strong class="js iu"> transform() </strong>函数，我们将处理一个非常具体的任务，即输入缺失值。</p><p id="643b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们实际了解如何使用<strong class="js iu">变换()</strong>函数进行缺失值插补之前，我们将了解每组中我们感兴趣的变量中有多少缺失值。我们可以在下面看到每个“<strong class="js iu">时间”</strong>特征的数据点数，它们是176+68 = 244。</p><pre class="ky kz la lb gt ow ox oy bn oz pa bi"><span id="aa31" class="pb lp it ox b be pc pd l pe pf">prior_counts = restaurant.groupby('time')<br/>prior_counts['total_bill'].count()</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/47248556a0c6b84e91d72524cb79155f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/0*jan48gduyxbkhF1i.png"/></div></figure><p id="7ef1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们将创建一个<strong class="js iu"> restaurant_nan </strong>数据集，其中使用下面的代码将10%随机观察的总账单设置为<strong class="js iu"> NaN </strong>:</p><pre class="ky kz la lb gt ow ox oy bn oz pa bi"><span id="dd40" class="pb lp it ox b be pc pd l pe pf">import pandas as pd<br/>import numpy as np<br/><br/>p = 0.1 #percentage missing data required<br/><br/>mask = np.random.choice([np.nan,1], size=len(restaurant), p=[p,1-p])<br/>restaurant_nan = restaurant.copy()<br/>restaurant_nan['total_bill'] =  restaurant_nan['total_bill'] * mask</span></pre><p id="bc2a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们打印每个“<strong class="js iu">时间”</strong>特征中的数据点数，我们可以看到它们现在是155+62 = 217。由于我们拥有的总数据点是244个，那么丢失的数据点是24个，相当于10%。</p><pre class="ky kz la lb gt ow ox oy bn oz pa bi"><span id="a240" class="pb lp it ox b be pc pd l pe pf">prior_counts = restaurant.groupby('time')<br/>prior_counts['total_bill'].count()</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/46aeae4141e95bb17f00cef1ede009a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/0*8k0X7MDKPenFzDVh.png"/></div></figure><p id="14b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在统计了数据中缺失值的数量后，我们将展示如何用特定于组的函数来填充这些缺失值。最常见的选择是均值和中位数，选择与数据的偏斜度有关。正如我们之前所做的，我们使用<strong class="js iu"> fillna </strong>()函数定义了一个<strong class="js iu"> lambda </strong>转换，用它的组平均值替换每个缺失值。和以前一样，我们根据用餐时间对数据进行分组，然后通过应用预定义的转换来替换缺失的值。</p><pre class="ky kz la lb gt ow ox oy bn oz pa bi"><span id="ae1c" class="pb lp it ox b be pc pd l pe pf"># Missing value imputation<br/><br/>missing_trans = lambda x: x.fillna(x.mean())<br/>restaurant_nan_grouped = restaurant_nan.groupby('time')['total_bill']<br/>restaurant_nan_grouped.transform(missing_trans)</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi po"><img src="../Images/6d3890723b31caee382d0912caa26d88.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/0*E2kuLZfcEYYB_LEz.png"/></div></figure><p id="812f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们所看到的，索引0和索引4处的观察值完全相同，这意味着它们的缺失值已被它们组的均值所取代。</p><p id="c706" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，我们可以看到使用这种方法的计算时间是0.007秒。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/69b0d5ac89aa3d6985f3148ef9654671.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/0*ibkz5UIlPDV1x0aF.png"/></div></figure><p id="9e32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们将其与传统方法进行比较:</p><pre class="ky kz la lb gt ow ox oy bn oz pa bi"><span id="de28" class="pb lp it ox b be pc pd l pe pf">start_time = time.time()<br/>mean_din = restaurant_nan.loc[restaurant_nan.time =='Dinner']['total_bill'].mean()<br/>mean_lun = restaurant_nan.loc[restaurant_nan.time == 'Lunch']['total_bill'].mean()<br/><br/>for row in range(len(restaurant_nan)):<br/>  if restaurant_nan.iloc[row]['time'] == 'Dinner':<br/>    restaurant_nan.loc[row, 'total_time'] = mean_din<br/>  else:<br/>    restaurant_nan.loc[row, 'total_time'] = mean_lun<br/>print("Results from the above operation calculated in %s seconds" % (time.time() - start_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/45b9135b818cc2fa81757d83aa910516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/0*oiIT5Arlfq4Ok8Np.png"/></div></figure><p id="7406" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到使用<strong class="js iu">。transform() </strong>应用于分组对象的函数比执行此任务的原生Python代码执行速度更快。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="fb76" class="oc lp it bd lq od oe of lt og oh oi lw oj ok ol lz om on oo mc op oq or mf os bi translated">4.使用进行数据过滤。groupby() &amp;。过滤器()</h1><p id="0e87" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ot kd ke kf ou kh ki kj ov kl km kn im bi translated">现在我们将讨论如何使用？<strong class="js iu"> filter() </strong>对分组的熊猫对象执行功能。这允许我们根据一些特定的条件，只包括这些组的一个子集。</p><p id="7f73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常，在根据特定特征对数据帧的条目进行分组之后，我们感兴趣的是基于某些条件只包括那些组的子集。过滤条件的一些示例包括缺失值的数量、特定要素的平均值或组在数据集中的出现次数。</p><p id="91a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们感兴趣的是在支付给服务员的平均金额超过20美元的日子里，找到给小费的平均金额。<strong class="js iu">。filter() </strong>函数接受对每个组的数据帧进行操作的<strong class="js iu">λ</strong>函数。在本例中，lambda函数选择“total_bill”并检查<strong class="js iu"> mean() </strong>是否大于20。如果lambda函数返回真，则计算小费<strong class="js iu">平均值()</strong>。如果我们比较提示的总平均值，我们可以看到两个值之间存在差异，这意味着过滤正确执行。</p><pre class="ky kz la lb gt ow ox oy bn oz pa bi"><span id="df2c" class="pb lp it ox b be pc pd l pe pf">restaurant_grouped = restaurant.groupby('day')<br/>filter_trans = lambda x : x['total_bill'].mean() &gt; 20<br/>restaurant_filtered = restaurant_grouped.filter(filter_trans)</span></pre><pre class="pq ow ox oy bn oz pa bi"><span id="068c" class="pb lp it ox b be pc pd l pe pf">print(restaurant_filtered['tip'].mean())</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/2c20eb26a7e53d7d78e470044b4429c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/0*VLAxtEELcSdvwxrv.png"/></div></figure><pre class="ky kz la lb gt ow ox oy bn oz pa bi"><span id="c797" class="pb lp it ox b be pc pd l pe pf">print(restaurant['tip'].mean())</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/b66a71ba8b26d798edcc24fd9fb54dc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/0*o9mkY2tVKKlNZE5T.png"/></div></figure><p id="822e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们试图在不使用<strong class="js iu"> groupby() </strong>的情况下执行这个操作，我们最终会得到这个低效的代码。首先，我们使用list comprehension来提取数据帧中涉及平均膳食超过20美元的日期的条目，然后使用for循环将它们添加到一个列表中并计算平均值。这可能看起来非常直观，但正如我们所见，这也是非常低效的。</p><pre class="ky kz la lb gt ow ox oy bn oz pa bi"><span id="5b38" class="pb lp it ox b be pc pd l pe pf">t=[restaurant.loc[restaurant['day'] == i]['tip'] for i in restaurant['day'].unique()<br/>  if restaurant.loc[restaurant['day'] == i]['total_bill'].mean()&gt;20]<br/>restaurant_filtered = t[0]<br/><br/>for j in t[1:]:<br/>  restaurant_filtered=restaurant_filtered.append(j,ignore_index=True)</span></pre></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="071b" class="oc lp it bd lq od oe of lt og oh oi lw oj ok ol lz om on oo mc op oq or mf os bi translated">参考</h1><p id="af6b" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ot kd ke kf ou kh ki kj ov kl km kn im bi translated"><a class="ae ln" href="https://app.datacamp.com/learn/courses/writing-efficient-code-with-pandas" rel="noopener ugc nofollow" target="_blank">用pandas编写高效代码教程，第4章</a></p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="71f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="oa">感谢阅读！如果你喜欢这篇文章，请务必:</em> </strong></p><ul class=""><li id="987c" class="mh mi it js b jt ju jx jy kb nw kf nx kj ny kn nz mp mq mr bi translated"><strong class="js iu">👏为这个故事鼓掌(50次)并跟我来👉</strong></li><li id="37e3" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn nz mp mq mr bi translated"><strong class="js iu">📰查看我的媒体档案中的更多内容</strong></li><li id="1ce8" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn nz mp mq mr bi translated"><strong class="js iu">🔔关注我:</strong><a class="ae ln" href="https://www.linkedin.com/in/youssef-hosni-b2960b135/" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">LinkedIn</strong></a><strong class="js iu">|</strong><a class="ae ln" href="https://medium.com/@youssefraafat57" rel="noopener"><strong class="js iu">Medium</strong></a><strong class="js iu">|</strong><a class="ae ln" href="https://twitter.com/Youssef70125494" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">Twitter</strong></a><strong class="js iu">|</strong><a class="ae ln" href="https://github.com/youssefHosni" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">GitHub</strong></a></li><li id="912c" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn nz mp mq mr bi translated"><em class="oa">🚀👉</em> <strong class="js iu"> <em class="oa">加入</em> </strong> <a class="ae ln" href="https://youssefraafat57.medium.com/membership" rel="noopener"> <strong class="js iu"> <em class="oa">中等会员</em> </strong> </a> <strong class="js iu"> <em class="oa">计划继续无限制学习。如果你使用下面的链接，我会收到一小部分会员费，不需要你额外付费。</em>T59】</strong></li></ul><div class="mx my gp gr mz na"><a href="https://youssefraafat57.medium.com/membership" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">加入我的介绍链接媒体-优素福胡斯尼</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">阅读Youssef Hosni(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">youssefraafat57.medium.com</p></div></div><div class="nj l"><div class="ob l nl nm nn nj no lh na"/></div></div></a></div></div></div>    
</body>
</html>