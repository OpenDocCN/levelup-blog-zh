<html>
<head>
<title>gRPC in Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务中的gRPC</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/grpc-in-microservices-5887caef195?source=collection_archive---------0-----------------------#2019-06-05">https://levelup.gitconnected.com/grpc-in-microservices-5887caef195?source=collection_archive---------0-----------------------#2019-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="dd3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原发表<a class="ae kl" href="https://milad.dev/posts/grpc-in-microservices" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="cc5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">近一年来，我一直在使用<a class="ae kl" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> gRPC </a>作为主要的服务对服务通信机制来开发微服务应用程序。因此，我决定写一篇博文，分享我在微服务世界中如何正确完成gRPC的经验！所以，让我们开始吧！</p><h1 id="c76b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="d2e3" class="lk ll iq jp b jq lm ju ln jy lo kc lp kg lq kk lr ls lt lu bi translated">干！为您的常用信息准备一个包。</li><li id="a67a" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">为您的gRPC包选择唯一的名称。</li><li id="5fa0" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">为您的gRPC包选择单数名称。</li><li id="b085" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">用<em class="ma">前缀</em>或<em class="ma">后缀</em>来区分你的gRPC包名。</li><li id="862d" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">将健康检查探测器实现为HTTP端点。</li><li id="73e4" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">使用服务网格对gRPC请求进行负载平衡。</li><li id="fe2e" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">将您的gRPC服务定义集中在一个存储库中。</li><li id="4529" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">自动更新您的gRPC工具和依赖项。</li><li id="5108" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">自动生成源代码和其他工件。</li></ul><h1 id="aa0d" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">微服务</h1><p id="9d6e" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">定义什么是<em class="ma">微服务</em>架构以及你是否需要采用它超出了这篇文章的范围。不幸的是，微服务这个术语已经成为这些天的热门词汇之一。微服务既不是微服务的数量，不同的编程语言，也不是你的API范式！本质上，微服务架构是正确的<em class="ma">软件即服务</em>！</p><p id="1d7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正确使用微服务最重要的是<strong class="jp ir">服务合同</strong>的概念。<em class="ma">服务契约</em>是给定服务通过API范式(REST、RPC、GraphQL等)公开的API。).在微服务世界中，微服务通信和共享数据的唯一方式是通过它们的API。微服务是其拥有的有限上下文或资源的唯一真实来源。一个服务不应该破坏它的API(契约),因为其他服务依赖于它。对API当前主要版本的任何更改都应该是向后兼容的。突破性的改变应该被引入到服务的新的主要版本中(技术上是一个新的服务)。</p><p id="21da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">微服务架构的一个重要含义是它所要求和引入的组织变革！就像微服务是小型的、独立的、自给自足的，就像它们可以使用不同的技术，遵循不同的开发工作流和发布周期。每个微服务可以归一个非常小的团队所有。不同的团队(微服务)可以采用稍微不同的实践(编码风格、依赖管理等)。)只要他们不违背对其他团队(其他微服务)的承诺(服务合同或API)。</p><h1 id="6cf5" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">gRPC</h1><p id="d11d" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">gRPC是用于服务到服务通信的RPC API范例。您可以使用gRPC实现和公开您的服务API(契约)。多亏了<a class="ae kl" href="https://github.com/grpc/grpc-web" rel="noopener ugc nofollow" target="_blank"> grpc-web </a>项目，你现在也可以从你的web应用程序进行grpc调用了。gRPC和REST之间的比较或者您是否需要将您的服务API实现为gRPC之类的主题再次超出了本文的范围。</p><p id="cf68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">gRPC本身很大程度上基于<a class="ae kl" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a>。协议缓冲区是一个跨平台的语言无关的标准，用于序列化和反序列化结构化数据。因此，您将发送和接收高度优化和压缩的数据字节，而不是通过网络发送明文JSON或XML数据。协议缓冲区的第1版已经在Google内部使用了很多年。从版本2开始，协议缓冲区是公开可用的。协议缓冲区的最新和推荐版本是版本3。</p><p id="8da7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">gRPC使用协议缓冲区来定义服务合同。每个服务定义都指定了许多具有预期输入和输出消息的方法。使用主要编程语言可用的gRPC库，这些gRPC协议缓冲区可以作为服务器或客户机来实现。对于像<a class="ae kl" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>这样的编译编程语言，需要提前使用协议缓冲编译器(Protocol)生成源代码。</p><h1 id="7427" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">体系结构</h1><p id="d507" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我一直从事的微服务架构由大约40个微服务组成，所有微服务都用<a class="ae kl" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>编写，并用<a class="ae kl" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>封装。由于Go是编译型静态类型语言，所以所有的gRPC/protobuf定义都要编译，并且要提前生成源代码。API网关接收HTTP RESTful请求，后端通信通过不同微服务之间的gRPC调用来完成。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi me"><img src="../Images/04fc4c8948cd129ff16ee8afd8ca0eaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*S4byoGyzNafNU4q7.png"/></div></figure><h1 id="00cd" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">挑战</h1><h1 id="7ac5" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">健康检查</h1><p id="9854" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">对于只讨论gRPC的服务，一个直接的问题是我们如何实现健康检查？或者，如果您使用Kubernetes作为您的容器平台，我们如何实现<strong class="jp ir">活跃度</strong>和<strong class="jp ir">就绪度</strong>探测？</p><p id="4640" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们有两个选择:</p><ul class=""><li id="dbd9" class="lk ll iq jp b jq jr ju jv jy mm kc mn kg mo kk lr ls lt lu bi translated">将健康检查探测器定义和实现为gRPC调用。</li><li id="ad0f" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">在不同的端口上启动HTTP服务器，并将运行状况检查探测器作为HTTP端点来实现。</li></ul><p id="0265" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将健康检查实现为HTTP非常简单。所有外部系统都可以轻松地使用HTTP健康检查。但是，设置一个单独的HTTP服务器需要与gRPC服务器进行一些协调，以确保gRPC服务器能够成功地为请求提供服务。</p><p id="dca2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将健康检查作为另一种gRPC方法来实现本身并不是一个挑战，而是获得外部系统(AWS负载平衡器、Kubernetes等)。)与它交谈是具有挑战性的部分。这种方法具有更好的语义，因为每个gRPC服务都带有健康检查，而健康检查本身就是一个gRPC请求。</p><p id="529f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一些关于这个主题的有用资源:</p><ul class=""><li id="bdaa" class="lk ll iq jp b jq jr ju jv jy mm kc mn kg mo kk lr ls lt lu bi translated"><a class="ae kl" href="https://github.com/grpc/grpc/blob/master/doc/health-checking.md" rel="noopener ugc nofollow" target="_blank"> GRPC健康检查协议</a></li><li id="3643" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated"><a class="ae kl" href="https://kubernetes.io/blog/2018/10/01/health-checking-grpc-servers-on-kubernetes" rel="noopener ugc nofollow" target="_blank">Kubernetes上的健康检查gRPC服务器</a></li></ul><h1 id="6be3" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">负载平衡</h1><p id="53f5" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这是另一个有趣的挑战！我们如何为服务进行负载平衡？要回答这个问题，我们需要记住gRPC是如何工作的。</p><p id="5fc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">gRPC构建在<em class="ma"> HTTP/2 </em>之上，HTTP/2使用长期的TCP连接。对于gRPC来说，这意味着gRPC客户机的一个实例将打开一个到gRPC服务器的一个实例的TCP连接，向同一个连接发送请求和从同一个连接接收响应，并保持连接打开，直到连接关闭。请求在同一连接上被多路复用。这是一个很大的性能改进，因为我们不需要为每个请求建立一个tcp连接。然而，这也意味着请求不能在传输层(L3/L4)中进行负载平衡。相反，我们需要在应用层(L7)对gRPC请求进行负载平衡。</p><p id="e5d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，负载平衡器组件需要为每个实例打开一个长期连接，从正在传输的协议缓冲区数据中检索足够的信息，然后它可以对gRPC请求进行负载平衡。</p><p id="8e51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不用说，您不应该为gRPC请求实现专门的负载平衡器。您应该使用一个适用于受支持的编程语言和平台的解决方案，并解决其他需求，比如可观察性。</p><p id="cbce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些值得一读的资源:</p><ul class=""><li id="b5e2" class="lk ll iq jp b jq jr ju jv jy mm kc mn kg mo kk lr ls lt lu bi translated"><a class="ae kl" href="https://grpc.io/blog/loadbalancing" rel="noopener ugc nofollow" target="_blank"> gRPC负载均衡</a></li><li id="bdfb" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated"><a class="ae kl" href="https://kubernetes.io/blog/2018/11/07/grpc-load-balancing-on-kubernetes-without-tears" rel="noopener ugc nofollow" target="_blank">Kubernetes上的gRPC负载均衡无泪</a></li></ul><h1 id="b32b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">依赖性管理</h1><p id="32a6" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">依赖性管理是维护微服务的另一个重要主题。gRPC社区在维护不同版本协议缓冲编译器(Protocol)之间的向后兼容性方面做了大量工作。这是gRPC成为成功的RPC协议的关键因素之一。用于生成Go源代码的插件也很好地维护了不同版本的<code class="fe mp mq mr ms b">protoc</code>和<code class="fe mp mq mr ms b">go</code>之间的向后兼容性。</p><p id="79e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，我们不时会看到一些突破性的变化被引入(当然是有原因的)。我能想到的一个例子是在Go中为生成的结构引入<code class="fe mp mq mr ms b">XXX_</code>字段(<a class="ae kl" href="https://github.com/golang/protobuf/issues/276" rel="noopener ugc nofollow" target="_blank"> #276 </a>，<a class="ae kl" href="https://github.com/golang/protobuf/issues/607" rel="noopener ugc nofollow" target="_blank"> #607 </a>)。</p><p id="9bf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，如果您不定期更新您的gRPC工具链，在未来更新它们以获得新的特性和性能改进将会变得更加困难。在最坏的情况下，您可能会坚持使用特定的旧版本的gRPC编译器和插件。</p><h1 id="b6ae" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">集中还是分散协议缓冲区管理？</h1><p id="4eb5" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这是另一个有趣的话题，因为它可能看起来不是一个重要的决定。在管理gRPC协议缓冲区和生成的文件时，您有两种选择:</p><ul class=""><li id="fa18" class="lk ll iq jp b jq jr ju jv jy mm kc mn kg mo kk lr ls lt lu bi translated">将协议缓冲区和生成的文件保存在与所有者微服务相同的存储库中(分散)</li><li id="f604" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">将所有协议缓冲区和生成的文件集中在一个mono repo中。</li></ul><p id="506d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您考虑基于HTTP的API，比如REST，那么您可以为每个repo定义HTTP端点。基本上，每个repo拥有关于其HTTP APIs的所有定义。这绝对是最佳实践(自给自足的回购)，符合微服务理念(自给自足)。</p><p id="70e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，gRPC服务定义存在于自己的回购协议中也是有意义的。为给定gRPC服务实现gRPC服务器的repo拥有gRPC服务定义以及相应的生成源代码(如果需要)。想要使用给定grpc服务的其他回购，从所有者(服务器)回购导入gRPC包。</p><p id="acbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止一切顺利，对吧？但是，有一个重要的区别，特别是对于编译编程语言。HTTP协议已经非常成熟，很难想象HTTP会突然发生变化。为了让gRPC和协议缓冲区工作，需要一个用于<em class="ma">编组</em>和<em class="ma">解组</em>的中间件层。此外，编译的编程语言需要使用协议缓冲编译器和语言特定的插件来生成源代码。</p><p id="7935" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们需要确保gRPC源代码在管道中生成，作为使用相同版本的协议、协议插件和其他工具构建的工件。如果您有一个中央管道，那么您只需要在一个地方实现该功能，并且更新该功能只需要在一个地方进行更改。如果您对每个微服务都有一个repo，并且您的管道是每个repo中的一个<code class="fe mp mq mr ms b">yaml</code>文件，那么您需要实现一个模块化管道，在其中导入从单一真实来源生成gRPC源代码的功能。</p><p id="0731" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果构建模块化管道不是一项简单的任务，您可以将所有gRPC服务及其生成的代码集中在一个mono repo中。在这个repo的管道或构建作业中，您可以使用生成gRPC源代码和其他文件所需的所有工具的相同版本。至少，您可以在构建工作中重新生成gRPC源代码和其他文件，并确保这些文件和开发人员签入的文件没有区别。</p><h1 id="76bb" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">吸取的教训</h1><h1 id="dfa2" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">1.干燥的</h1><p id="7c7b" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">不要重复自己！如果您有一个公共消息，表明您需要在多个服务定义中使用它，那么您可以在一个单独的包中定义它，并在您的服务定义中导入它。</p><p id="3718" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，如果将健康检查作为gRPC请求来实现，则可以在一个公共包中为健康检查方法定义请求和响应消息。</p><h1 id="4975" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">2.使用唯一且一致的包名</h1><p id="6520" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">包的名称是gRPC服务定义的一部分。这意味着更改包的名称会破坏gRPC服务定义。</p><p id="41c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据目标编程语言的不同，为gRPC服务定义选择包名可能会有所不同。您需要确保您的包名遵循您的编程语言的约定，并且与您的其他gRPC包名一致。</p><ul class=""><li id="896d" class="lk ll iq jp b jq jr ju jv jy mm kc mn kg mo kk lr ls lt lu bi translated">为gRPC包选择唯一的名称</li><li id="514e" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">为您的gRPC包选择单数名称</li><li id="99ed" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">用<em class="ma">前缀</em>或<em class="ma">后缀</em>来区分你的gRPC包名(例如，在Go中，你可以使用<code class="fe mp mq mr ms b">PB</code>后缀)</li></ul><h1 id="ee99" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">3.将健康检查探测器实现为HTTP</h1><p id="e029" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">HTTP健康检查(包括Kubernetes <em class="ma">活跃度</em>和<em class="ma">就绪度</em>探测)可以被所有外部系统轻松使用。因此，通过这种方式，您不需要让gRPC客户机来检查您的服务健康状况，并且您的服务实现更加面向未来(您仍然可以在gRPC服务上拥有一个健康检查方法，并且您的http健康检查处理程序会调用它)。</p><h1 id="aa31" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">4.使用服务网格进行负载平衡</h1><p id="505c" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">对于负载平衡gRPC请求，使用一个<em class="ma">服务网格</em>。所有主要的服务网格(Linkerd、Istio和Consul)都支持gRPC的L7负载平衡。服务网格还为您的gRPC调用提供了可观察性功能，例如度量和跟踪。</p><h1 id="9a36" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">5.集中gRPC协议缓冲区</h1><p id="0b07" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">根据我们的经验，将所有gRPC服务定义集中在一个repo中比在每个repo中保留服务定义效果更好。您可以使用相同版本(最好总是最新版本)的协议、协议插件和其他工具来为您的所有服务定义生成源代码。您还可以确保所有gRPC服务定义在命名、格式、文档和其他约定方面保持一致。</p><p id="7b7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值得一提的是，所有这些品质也可以通过采用足够的自动化和工具来实现。</p><p id="2fea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理想情况下，您的gRPC服务定义中不应该有任何重大更改。但是，如果出于某种原因您需要这样做，将您的服务定义集中在一个repo中允许您将所有的服务定义一起进行语义版本化。因此，您不需要知道给定包的哪个版本与另一个包的哪个版本一起工作。</p><h1 id="8fcd" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">6.gRPC的自动化代码生成</h1><p id="76d6" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">不要相信您的开发人员会为您的gRPC服务定义生成源代码！您不希望每个开发人员每次进行更改时都使用本地安装的gRPC工具生成源代码。记住！一切可以自动化的东西，都必须自动化。</p><p id="a849" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在您的管道中，您应该<em class="ma"> lint </em>您的服务定义，并为您的服务定义生成源代码和其他工件，作为您构建过程的一部分。</p><h1 id="ac68" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">7.自动化您的依赖性管理</h1><p id="18ef" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">自动化依赖关系管理是一种最佳实践，并不特定于gRPC。根据目标编程语言的不同，gRPC需要其他库才能工作。确保自动更新生成源代码和运行时的工具和依赖项。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><div class="mf mg mh mi gt na"><a href="https://gitconnected.com/learn/golang" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd ir gy z fp nf fr fs ng fu fw ip bi translated">学习围棋-最佳围棋教程(2019) | gitconnected</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">22大围棋教程-免费学习围棋。课程由开发者提交和投票，使您能够找到…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">gitconnected.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no mk na"/></div></div></a></div></div></div>    
</body>
</html>