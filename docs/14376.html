<html>
<head>
<title>The Easiest Way to Upload Your Files to NestJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将文件上传到NestJS的最简单方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-easiest-way-to-upload-your-files-to-nestjs-70a70b95f856?source=collection_archive---------0-----------------------#2022-11-21">https://levelup.gitconnected.com/the-easiest-way-to-upload-your-files-to-nestjs-70a70b95f856?source=collection_archive---------0-----------------------#2022-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6e21001bfeea6508ea999b71749b3df5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zRv5TkRmhAyLnG-t.png"/></div></div></figure><h1 id="6b29" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="01ca" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">文件上传在网站或应用中非常常见。我们几乎每天都上传图片、视频和文档。</p><p id="3c0d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在互联网上，有成千上万的关于如何用多种语言和技术实现文件上传的教程。今天我将写一个简单的指南来演示如何在NestJS中处理文件上传</p><h1 id="142d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">履行</h1><p id="f9c8" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了处理文件上传，Nest为Express提供了一个基于<a class="ae lz" href="https://github.com/expressjs/multer" rel="noopener ugc nofollow" target="_blank"> Multer </a>中间件包的内置模块。Multer处理以<code class="fe ma mb mc md b">multipart/form-data</code>格式发布的数据，这主要用于通过HTTP <code class="fe ma mb mc md b">POST</code>请求上传文件。这个模块是完全可配置的，您可以根据您的应用程序需求调整它的行为。</p><p id="32e4" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">警告:Multer无法处理不支持多部分格式的数据(<code class="fe ma mb mc md b">multipart/form-data</code>)。</p><p id="484b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为了类型安全，让我们安装多类型软件包:</p><pre class="me mf mg mh gt mi md mj bn mk ml bi"><span id="f0f4" class="mm jz iq md b be mn mo l mp mq">yarn add @types/multer</span></pre><p id="5f2f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">要上传单个文件，只需将<code class="fe ma mb mc md b">FileInterceptor()</code>拦截器绑定到路由处理器，并使用<code class="fe ma mb mc md b">@UploadedFile()</code>装饰器从<code class="fe ma mb mc md b">request</code>中提取<code class="fe ma mb mc md b">file</code>。</p><pre class="me mf mg mh gt mi md mj bn mk ml bi"><span id="cdf7" class="mm jz iq md b be mn mo l mp mq">@Post('upload')<br/>@UseInterceptors(FileInterceptor('file'))<br/>uploadFile(@UploadedFile() file: Express.Multer.File) {<br/>  console.log(file);<br/>}</span></pre><p id="85f8" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe ma mb mc md b">FileInterceptor()</code>装饰器有两个参数:</p><ul class=""><li id="ad76" class="mr ms iq ky b kz lu ld lv lh mt ll mu lp mv lt mw mx my mz bi translated"><code class="fe ma mb mc md b">fieldName</code>:提供保存文件的HTML表单中的字段名称的字符串</li><li id="50a3" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated"><code class="fe ma mb mc md b">options</code>:类型<code class="fe ma mb mc md b">MulterOptions</code>的可选对象。</li></ul><h2 id="d671" class="nf jz iq bd ka ng nh dn ke ni nj dp ki lh nk nl km ll nm nn kq lp no np ku nq bi translated">确认</h2><p id="2703" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了处理验证，我们可以使用带有内置验证器的<code class="fe ma mb mc md b">UploadedFile()</code>装饰器:</p><pre class="me mf mg mh gt mi md mj bn mk ml bi"><span id="b1a4" class="mm jz iq md b be mn mo l mp mq">@UploadedFile(<br/>      new ParseFilePipe({<br/>        validators: [<br/>          new FileTypeValidator({ fileType: '.(png|jpeg|jpg)' }),<br/>          new MaxFileSizeValidator({ maxSize: 1024 * 1024 * 4 }),<br/>        ],<br/>      }),<br/>    )</span></pre><p id="6574" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我在这里使用了两个验证器</p><ul class=""><li id="a865" class="mr ms iq ky b kz lu ld lv lh mt ll mu lp mv lt mw mx my mz bi translated">我们可以传递一个字符串或者一个正则表达式。在本例中，我只指定了扩展名为<code class="fe ma mb mc md b">png</code> <code class="fe ma mb mc md b">jpeg</code>和<code class="fe ma mb mc md b">jpg</code>的文件</li><li id="895a" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated">MaxFileSizeValidator:我们可以限制的字节数，例如，我将其设置为4兆字节</li></ul><p id="8bdb" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这些验证器非常幼稚，但是对于我们的应用程序来说足够简单</p><h2 id="c82d" class="nf jz iq bd ka ng nh dn ke ni nj dp ki lh nk nl km ll nm nn kq lp no np ku nq bi translated">服务</h2><p id="047d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">虽然您可以将文件直接保存到数据库中，但我建议您不要这样做。因为前端读取你的文件会很慢很难</p><p id="a39a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这个例子中，我使用第三方图像托管服务上传我的图像，然后只保存在数据库中的网址</p><p id="4fe3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这种情况下，我们可以非常快速地访问文件，并在我们的应用程序中使用它</p><pre class="me mf mg mh gt mi md mj bn mk ml bi"><span id="24d0" class="mm jz iq md b be mn mo l mp mq">const user = await this.userModel.findById(userId);<br/>    if (!user) {<br/>      throw 'User not found';<br/>    }<br/>    const formData = new FormData();<br/>    formData.append('image', avatar.buffer.toString('base64'));<br/>    const { data: imageData } = await firstValueFrom(<br/>      this.httpService<br/>        .post(<br/>          `https://api.imgbb.com/1/upload?expiration=600&amp;key=${process.env.IMG_API_KEY}`,<br/>          formData,<br/>        )<br/>        .pipe(<br/>          catchError((error: AxiosError) =&gt; {<br/>            throw error;<br/>          }),<br/>        ),<br/>    );<br/>    user.updateOne({ avatar: imageData.data.url }).exec();</span></pre><h1 id="0092" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="136c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">有了上面的例子，你将能够在10分钟内理解并编写你自己的文件上传功能。</p><p id="d820" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我希望你能赶上这篇文章，如果没有，你可以在这里查看我的完整的<a class="ae lz" href="https://github.com/leduc1901/nestjs-jwt-auth" rel="noopener ugc nofollow" target="_blank">源代码</a></p><h1 id="bc91" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">遗言</h1><p id="bb0e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">虽然我的内容对每个人都是免费的，但是如果你觉得这篇文章有帮助，<a class="ae lz" href="https://www.buymeacoffee.com/kylele19" rel="noopener ugc nofollow" target="_blank">你可以在这里给我买杯咖啡</a></p></div></div>    
</body>
</html>