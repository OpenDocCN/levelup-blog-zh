<html>
<head>
<title>Builder Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建器模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/builder-pattern-7e18e6bb6402?source=collection_archive---------10-----------------------#2020-09-08">https://levelup.gitconnected.com/builder-pattern-7e18e6bb6402?source=collection_archive---------10-----------------------#2020-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/aeb5aea03fba02aeebdbbc41ccfae39a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*SiMsBuOUr6RtQUsFxIcg2Q.png"/></div></figure><p id="5298" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">模型是java中使用最多的类。当你想创建一个具有不同配置的对象时，如何定义模态类来轻松地创建对象呢？有三种方法可以做到这一点:<strong class="jw ir">伸缩构造器</strong>、<strong class="jw ir"> Java Bean模式</strong>和<strong class="jw ir">构建器模式</strong>，第一种方法是反模式。当模型类有可选字段时，第一种方法会创建更多的构造函数，所以我们使用builder模式来解决这个问题。下面，将逐一解释。</p></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><p id="7f71" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> 1。伸缩构造函数:</strong>传统上，程序员使用伸缩构造函数模式，在这种模式下，他们提供一个只带有必需参数的构造函数，另一个带有单个可选参数，或者一个带有两个可选参数，等等。这种方式是<strong class="jw ir">安全的</strong>，但是它创建了许多构造函数。假设您有5个字段，其中3个是可选的。所以你必须创建4个构造函数。<strong class="jw ir">伸缩构造器模式可以工作，但是很难编写，所以不是最佳的</strong>。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="d2d3" class="li lj iq le b gy lk ll l lm ln">public class UserData {<br/>    private String name;<br/>    private int nationalId;<br/>    private int age;<br/>    private String address;<br/>    private int phoneNumber;</span><span id="992f" class="li lj iq le b gy lo ll l lm ln">    public UserData(String name, int nationalId) {<br/>        this.name = name;<br/>        this.nationalId = nationalId;<br/>    }</span><span id="ba44" class="li lj iq le b gy lo ll l lm ln">    public UserData(String name, int nationalId, int age) {<br/>        this.name = name;<br/>        this.nationalId = nationalId;<br/>        this.age = age;<br/>    }</span><span id="81ea" class="li lj iq le b gy lo ll l lm ln">    public UserData(String name, int nationalId, int age, String address) {<br/>        this.name = name;<br/>        this.nationalId = nationalId;<br/>        this.age = age;<br/>        this.address = address;<br/>    }</span><span id="ec2f" class="li lj iq le b gy lo ll l lm ln">    public UserData(String name, int nationalId, int age, String address, int phoneNumber) {<br/>        this.name = name;<br/>        this.nationalId = nationalId;<br/>        this.age = age;<br/>        this.address = address;<br/>        this.phoneNumber = phoneNumber;<br/>    }<br/>}</span></pre></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><p id="c7ed" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">2.Java Bean模式:</strong>在这个模式中，您调用一个无参数的构造函数(默认构造函数)来创建对象，然后调用setter方法来设置您想要的每个必需参数和可选参数:…</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="fdc5" class="li lj iq le b gy lk ll l lm ln">public class UserData {<br/>    private String name;<br/>    private int nationalId;<br/>    private int age;<br/>    private String address;<br/>    private int phoneNumber;</span><span id="413c" class="li lj iq le b gy lo ll l lm ln">    public void setName(String name) {<br/>        this.name = name;<br/>    }</span><span id="b9f6" class="li lj iq le b gy lo ll l lm ln">    public void setNationalId(int nationalId) {<br/>        this.nationalId = nationalId;<br/>    }</span><span id="0111" class="li lj iq le b gy lo ll l lm ln">    public void setAge(int age) {<br/>        this.age = age;<br/>    }</span><span id="ed3d" class="li lj iq le b gy lo ll l lm ln">    public void setAddress(String address) {<br/>        this.address = address;<br/>    }</span><span id="3e60" class="li lj iq le b gy lo ll l lm ln">    public void setPhoneNumber(int phoneNumber) {<br/>        this.phoneNumber = phoneNumber;<br/>    }<br/>}</span></pre><p id="9d6d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">用法:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="c00f" class="li lj iq le b gy lk ll l lm ln">UserData userData = new UserData();<br/>userData.setName("Golnaz");<br/>userData.setNationalId(00000);<br/>userData.setAge(0);<br/>userData.setAddress("....");<br/>userData.setPhoneNumber(00000);</span></pre><p id="36a6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">不幸的是，并不清楚哪些参数是必需的，哪些不是。这种方式具有可读性，但是对于每5个字段，我们必须编写setter，并且我们必须调用每个字段的setter，JavaBeans模式排除了使类不可变的可能性。</p></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><p id="62b9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> 3。构建器模式:</strong>构建器模式是最好的方式。它兼具安全性和可读性。实现这种模式的方法是在模态类中创建一个静态类，并将其称为构建器类。像以前一样，我们将必需参数定义为final，将可选参数定义为optional，然后创建带有两个必需参数的构造函数，对于optional，我们为每个参数创建一个方法，并将其输出视为Builder。父类有一个带有生成器输入的构造函数。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="1801" class="li lj iq le b gy lk ll l lm ln">public class UserData {<br/>    private final String name;<br/>    private final int nationalId;<br/>    private final int age;<br/>    private final String address;<br/>    private final int phoneNumber;</span><span id="42bc" class="li lj iq le b gy lo ll l lm ln">    public static class Builder{<br/>        //required<br/>        private final String name;<br/>        private final int nationalId;<br/>        //optional<br/>        private int age;<br/>        private String address;<br/>        private int phoneNumber;</span><span id="5bfe" class="li lj iq le b gy lo ll l lm ln">        public Builder(String name, int nationalId) {<br/>            this.name = name;<br/>            this.nationalId = nationalId;<br/>        }<br/>        public Builder age(int ageVal){<br/>            age = ageVal;<br/>            return this;<br/>        }<br/>        public Builder address(String addressVal){<br/>            address = addressVal;<br/>            return this;<br/>        }<br/>        public Builder phoneNumber(int phoneNumberVal){<br/>            phoneNumber = phoneNumberVal;<br/>            return this;<br/>        }<br/>        public UserData build(){<br/>            return new UserData(this);<br/>        }</span><span id="f8ee" class="li lj iq le b gy lo ll l lm ln">    }</span><span id="4496" class="li lj iq le b gy lo ll l lm ln">    private UserData(Builder builder) {<br/>        name = builder.name;<br/>        nationalId = builder.nationalId;<br/>        age = builder.age;<br/>        address = builder.address;<br/>        phoneNumber = builder.phoneNumber;<br/>    }<br/>}</span></pre><p id="1671" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是如何使用它:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="9d09" class="li lj iq le b gy lk ll l lm ln">UserData userData = new UserData.Builder("Golnaz",00000000).age(10).build();</span></pre></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><h1 id="7510" class="lp lj iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结论:</h1><p id="d8c0" class="pw-post-body-paragraph ju jv iq jw b jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr ij bi translated">所以用几个配置实现模态类的最好方法是使用一个构建器模式来给你的代码提供安全性<strong class="jw ir">和可读性</strong>。</p><p id="0223" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">谢谢你的时间。我希望这篇文章对你有用。</p></div></div>    
</body>
</html>