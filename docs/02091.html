<html>
<head>
<title>Auto-Unsubscribing in Angular Components Like a Pro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像专业人士一样自动退订角度组件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/auto-unsubscribing-in-angular-components-like-a-pro-742220b01d0c?source=collection_archive---------2-----------------------#2020-02-18">https://levelup.gitconnected.com/auto-unsubscribing-in-angular-components-like-a-pro-742220b01d0c?source=collection_archive---------2-----------------------#2020-02-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d0d4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">快速处理unsubscribe()调用的5个技巧，用于Angular组件中的大量订阅，以及为您的项目选择哪一个组件的指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b1714601cbe43c7855640fecd1a2e8d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZTXwdxbQjamc9NAXzzsSw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@derlei?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">万德莱·隆戈</a>从<a class="ae ky" href="https://www.pexels.com/photo/silhouette-photography-of-steel-tower-2081132/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>中截取。</figcaption></figure><p id="e827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">RxJS和observables是每个认真的Angular开发者的必备技能。该框架公开了用于许多领域的可观察对象——从基本的HTTP通信到高级开发技术，如拦截器、防护器和解析器。迟早，有效处理大量订阅的<code class="fe lv lw lx ly b">unsubscribe()</code>呼叫的需求将变得显而易见。</p><h1 id="8dae" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">🧱基础</h1><p id="b733" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在角度组件的生命周期中，有时需要订阅可观察值。这样做的每一个动作都会产生一个订阅对象，当组件被Angular runtime破坏时，应该以一种不会导致JavaScript运行时内存泄漏的方式来处理这个订阅对象——这意味着调用<code class="fe lv lw lx ly b">unsubscribe()</code>，通常在组件的<code class="fe lv lw lx ly b">ngOnDestroy</code>方法内部。</p><p id="1095" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每个订阅，执行此类任务的最基本方法包括两个步骤:</p><ol class=""><li id="f518" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">将订阅保存到组件的私有/受保护成员变量，</li><li id="1b3e" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">在<code class="fe lv lw lx ly b">ngOnDestroy</code>内部，对每个声明的成员变量调用<code class="fe lv lw lx ly b">unsubscribe()</code>。</li></ol><p id="9e26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于大量这样的订阅，这变成了一件乏味的工作。以下方法可能适用于这种情况。</p><h1 id="cfc8" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">🎉@自动退订装饰</h1><p id="2ab1" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">这种方法最类似于基本的手动退订方法。您仍然必须将所有订阅声明为组件成员变量(或者将订阅添加到您选择的数组中)，但是，这种方法将节省您在<code class="fe lv lw lx ly b">ngOnDestroy</code>钩子中的一些输入。</p><p id="1f7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<code class="fe lv lw lx ly b">@AutoUnsubscribe</code>类装饰器(可以在<a class="ae ky" href="https://github.com/NetanelBasal/ngx-auto-unsubscribe" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得或者作为npm包<code class="fe lv lw lx ly b">ngx-auto-unsubscribe</code>获得)，装饰器将基于在组件中定义为成员变量的订阅，在<code class="fe lv lw lx ly b">ngOnDestroy</code>钩子中生成所有的<code class="fe lv lw lx ly b">unsubscribe()</code>调用。</p><p id="ee05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它甚至提供了额外的调整，比如订阅黑名单，定制钩子方法名来生成对订阅的成员数组的调用。查看GitHub库的自述文件。</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="b23a" class="no ma it ly b gy np nq l nr ns">@AutoUnsubscribe()<br/>@Component(...)<br/>export class MyComponent implements OnDestroy, OnInit {<br/>  protected addressSubscription: Subscription;<br/>  protected userSubscription: Subscription;<br/>  ...</span><span id="f7ed" class="no ma it ly b gy nt nq l nr ns">  public ngOnInit() {<br/>    this.addressSubscription = // subscribe here or wherever else<br/>    this.userSubscription = // subscribe here or wherever else<br/>  }  <br/>  public ngOnDestroy() {} // must be present</span><span id="eced" class="no ma it ly b gy nt nq l nr ns">  ...<br/>}</span></pre><p id="6896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案就其明确性而言是干净的——<code class="fe lv lw lx ly b">@AutoUnsubscribe()</code>正好说明了一切。另外，它不会耗尽组件的组件继承能力。并且，<em class="nu">如果您的代码库</em>需要，它会列出您的组件类中所有使用的订阅。</p><p id="934f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的缺点是您必须在组件中的某个地方定义您的<code class="fe lv lw lx ly b">ngOnDestroy</code>和成员变量/订阅数组。</p><h1 id="571c" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">✨ @UntilDestroy装饰</h1><p id="018e" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">GitHub 上的这个(或者npm包<code class="fe lv lw lx ly b">@ngneat/until-destroy</code>)是这个问题的其他解决方案中的一个<em class="nu">新手。由<em class="nu">@ auto unsubscribe decorator</em>的作者创建，这个decorator <em class="nu">利用Angular Ivy </em>的能力(但是在Angular ≤ 8中与旧的代码库一起工作，有一点参与，在<a class="ae ky" href="https://github.com/ngneat/until-destroy#readme" rel="noopener ugc nofollow" target="_blank">项目自述</a>中有描述)。</em></p><p id="a731" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案结合了类似于<em class="nu">@ auto unsubscribe decorator</em>的原理，以及一个新特性——RxJS操作符<code class="fe lv lw lx ly b">untilDestroyed</code>。</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="c7e9" class="no ma it ly b gy np nq l nr ns"><strong class="ly iu">@UntilDestroy()</strong><br/>@Component(...)<br/>export class MyComponent implements OnInit {<br/>  ...</span><span id="793e" class="no ma it ly b gy nt nq l nr ns">  public ngOnInit() {<br/>    this.userService.getUser()<br/>      .pipe(<strong class="ly iu">untilDestroyed(this)</strong>)<br/>      .subscribe();<br/>  }</span><span id="f7d8" class="no ma it ly b gy nt nq l nr ns">  // ngOnDestroy is not needed here (Angular 9+ only)!<br/>}</span></pre><p id="ea70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，<code class="fe lv lw lx ly b">untilDestroyed(this)</code>操作符工厂函数调用基本上将这个订阅标记为当组件被Angular运行时破坏时取消订阅。</p><p id="bd33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">操作符也可以在Angular组件上下文之外使用自定义的显式声明的对象析构函数工作(然而，JavaScript运行时本质上仍然必须手动调用这些析构函数)，参见<a class="ae ky" href="https://github.com/ngneat/until-destroy#readme" rel="noopener ugc nofollow" target="_blank">项目自述文件</a>以获取参考。</p><p id="7249" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用订阅成员变量赋值的旧方法(<em class="nu"> @AutoUnsubscribe-esque </em>)在向装饰工厂提供形式为<code class="fe lv lw lx ly b">{checkProperties: true}</code>的配置对象时也能工作。</p><p id="6767" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，对于Angular 9+来说，这个解决方案消除了它的前身<em class="nu">@ auto unsubscribe decorator</em>的主要缺陷。好样的，<a class="nv nw ep" href="https://medium.com/u/b889ae02aa26?source=post_page-----742220b01d0c--------------------------------" rel="noopener" target="_blank">网易基础</a>！</p><h1 id="4ee5" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">⏲自动取消订阅基本组件</h1><p id="f786" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">这种DIY纯Angular + RxJS的方式利用了组件继承。名为<code class="fe lv lw lx ly b">AutoUnsubscribeComponent</code>的基本组件可能会驻留在您的共享模块中，包含如下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="1cc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当在组件内部订阅时，只需通过调用<code class="fe lv lw lx ly b">this.addSubscriptions</code>方法来封装订阅，就万事俱备了。</p><p id="e8e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案非常棒，主要有两个原因——它不需要在目标组件中添加任何额外的成员变量，继承声明(<code class="fe lv lw lx ly b">extends AutoUnsubscribeComponent</code>)会立即让阅读您代码的人知道这个组件将执行自动退订。</p><p id="ec33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，通过在单一继承语言Typescript中使用组件继承，在组件中使用这种微小的功能将耗尽组件从其他组件继承的能力。另外，如果需要创建你自己的<code class="fe lv lw lx ly b">ngOnDestroy</code>，你必须在里面调用<code class="fe lv lw lx ly b">super.ngOnDestroy()</code>。</p><p id="fbe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，因为组件继承并不是很常见，而且一般来说继承现在也不被人喜欢(主要是因为<a class="ae ky" href="https://medium.com/@_ericelliott/why-composition-is-immune-to-fragile-base-class-problem-8dfc6a5272aa" rel="noopener">脆弱的基类问题</a>)，所以在你的组件中使用这种技术应该没问题。</p><h1 id="fdf4" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">🚰订户接收器</h1><p id="6d79" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">这种方法类似于<em class="nu">自动取消订阅基本组件</em>方法，但是利用组合而不是继承。</p><p id="510d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">订户接收器(又名。<em class="nu">子链接</em>，在<a class="ae ky" href="https://github.com/wardbell/subsink" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上可用，或者作为npm包<code class="fe lv lw lx ly b">subsink</code>有效地作为一组订阅。随着时间的推移，新的订阅将被添加到子链接中(有两种技术可以将订阅添加到子链接中，参见<a class="ae ky" href="https://github.com/wardbell/subsink#readme" rel="noopener ugc nofollow" target="_blank">项目自述文件</a>)并且为了取消订阅，子链接拥有<code class="fe lv lw lx ly b">unsubscribe()</code>方法。</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="5f89" class="no ma it ly b gy np nq l nr ns">export class MyComponent implements OnDestroy {<br/>  protected subs = new SubSink();</span><span id="c698" class="no ma it ly b gy nt nq l nr ns">  // adding the subscriptions to the sink - "setter" way<br/>  this.subs.sink = this.userService.getUser().subscribe(...);<br/>  this.subs.sink = fromEvent(...).subscribe(...);</span><span id="a029" class="no ma it ly b gy nt nq l nr ns">  // adding the subscriptions to the sink - "collection" way<br/>  this.subs.add(<br/>    this.userService.getUser().subscribe(...),<br/>    fromEvent(...).subscribe(...)<br/>  );</span><span id="db8a" class="no ma it ly b gy nt nq l nr ns">  public ngOnDestroy() {<br/>    this.subs.unsubscribe(); // yep, this must be done manually<br/>  }<br/>}</span></pre><p id="62cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的代码片段中可以看出，这种方法需要在组件的<code class="fe lv lw lx ly b">ngOnDestroy</code>钩子中进行一次手动取消订阅调用，而不是多次调用<code class="fe lv lw lx ly b">unsubscribe()</code>。如果把它放在组件类定义的第一行，这个解决方案会相当清楚，只要你的代码读者知道什么是子链接。</p><h1 id="d3b0" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">📦合并订阅</h1><p id="6de5" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">这是一个不需要任何额外库或定制基础组件的解决方案——它只是一个普通的RxJS。有一种不太为人所知的订阅方法叫做<code class="fe lv lw lx ly b">add(aSubscription)</code>，它本质上将多个订阅组合成一个<em class="nu">超级订阅</em>，可以通过在超级订阅上的单个<code class="fe lv lw lx ly b">unsubscribe()</code>调用来一次取消订阅组中的所有订阅。</p><p id="c4bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种技术可以模仿<em class="nu">订户接收器</em>，通过订阅一个空的临时可观察对象来创建初始的超级订阅——将这段代码片段与展示子接收器的前一段代码片段进行比较:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="4b0f" class="no ma it ly b gy np nq l nr ns">export class MyComponent implements OnDestroy {<br/>  protected subs = <strong class="ly iu">empty().subscribe();</strong></span><span id="05d6" class="no ma it ly b gy nt nq l nr ns">  ...<br/>  this.subs<strong class="ly iu">.add(this.userService.getUser().subscribe(...));</strong><br/>  this.subs<strong class="ly iu">.add(fromEvent(...).subscribe(...));</strong><br/>  ...</span><span id="e5bc" class="no ma it ly b gy nt nq l nr ns">  <br/>  public ngOnDestroy() {<br/>    this.subs.unsubscribe(); // yep, this must be done manually<br/>  }<br/>}</span></pre><p id="f455" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种解决方案与子链接有相同的优点和缺点，但是与子链接相比，对于项目新手来说，这种解决方案可能更难阅读，而且<code class="fe lv lw lx ly b">add(aSubscription)</code>的API不像子链接那样灵活。</p><h1 id="14f8" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">🎁总结</h1><p id="319d" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">到目前为止，您已经看到了处理Angular组件内部自动退订的5种不同技术。</p><p id="8a49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，上述解决方案中没有一个是“一刀切”的解决方案。选择哪种技术能够很好地满足您的项目需求将取决于您必须自己解决的几个问题:</p><ol class=""><li id="15cc" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">我们的组件中可以容忍多少样板代码？</li><li id="3d98" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">关于<em class="nu">隐含行为</em>，比如自动退订，我们的代码库应该有多明确？</li><li id="d17d" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">我们的项目会大量使用组件继承吗？</li><li id="6874" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">我们是否希望为此使用第三方解决方案？</li><li id="ce06" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">…以及更多。</li></ol></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><p id="a66c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说，我在我的项目中使用了<em class="nu">自动取消订阅基本组件</em>方法，因为我喜欢解决方案的明确性和我的组件中需要使用它的最少量的样板代码。当需要扩展任何基础组件时，我只是让基础组件继承我的<code class="fe lv lw lx ly b">AutoUnsubscribeComponent</code>。</p><p id="ad00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当我将我的代码库迁移到Angular 9+或在Angular 9+中开始另一个项目时，我会和我的队友一起认真考虑<em class="nu"> @UntilDestroy decorator </em>方法——与<em class="nu">自动取消订阅基础组件</em>方法相反，基于它的解决方案不会遭受继承能力耗尽。</p><h1 id="12f2" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">👓值得一看的文章</h1><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/where-shall-i-put-that-core-vs-shared-module-in-angular-5fdad16fcecc"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">“我该把它放在哪里？”-核心模块与角度共享模块</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">核心模块与共享模块的角度，专业的提示和技巧，加上一个经验法则，以确定哪个模块放置您的…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ks oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/handling-loading-indicators-in-angular-applications-the-right-way-11ff8b8896ba"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">正确处理角度应用中的负载指示器</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">一个优雅的，没有麻烦的方式来摆脱无意义的技术管道在您的业务角组件。</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="os l"><div class="oy l ou ov ow os ox ks oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/this-angular-technique-will-significantly-lower-code-duplication-in-big-projects-28fd62c3eadd"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">这种角度技术将显著降低大型项目中的代码重复</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">告别大型项目中ng模板的代码重复和性能问题</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="os l"><div class="oz l ou ov ow os ox ks oj"/></div></div></a></div></div></div>    
</body>
</html>