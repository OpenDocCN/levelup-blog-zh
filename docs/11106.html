<html>
<head>
<title>Dynamic Pull Request Previews with GitHub Actions and Azure App Service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GitHub操作和Azure应用服务的动态拉取请求预览</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dynamic-pull-request-previews-with-github-actions-and-azure-app-service-1f613986eab8?source=collection_archive---------8-----------------------#2022-02-16">https://levelup.gitconnected.com/dynamic-pull-request-previews-with-github-actions-and-azure-app-service-1f613986eab8?source=collection_archive---------8-----------------------#2022-02-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e17434b6e8e0da079f134d5a39be4bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ElNPZEOTQXsw5FxCjGdyTA.png"/></div></div></figure><div class=""/><div class=""><h2 id="1748" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">如果你正在从Vercel或Azure静态Web应用程序中寻找你所知道并喜欢的CI/CD功能，但使用Azure应用程序服务，这篇文章是为你准备的。</h2></div><p id="e39a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">设置场景:</strong>作为一名开发人员，您将业务挑战转化为代码，经常与希望(或需要)在QA环境中预览您的更改的设计人员和非技术利益相关者一起工作，确保在将它合并到生产中之前，一切看起来和工作起来都符合预期。</p><p id="f538" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">挑战:</strong>这通常需要大量的环境和开发运维流程——简而言之，大量的前期工具，这不是很敏捷！</p><blockquote class="lp"><p id="40ae" class="lq lr je bd ls lt lu lv lw lx ly lo dk translated">作为一名开发人员，我希望能够与设计师分享我对UI的最新更改的实时预览，以便在集成代码之前，我们可以在一个实时但隔离的环境中更好地协作。</p></blockquote><p id="4602" class="pw-post-body-paragraph kt ku je kv b kw lz kf ky kz ma ki lb lc mb le lf lg mc li lj lk md lm ln lo im bi translated">以下指南和代码要点记录了如何使用Azure App Service执行基于拉请求的部署预览。这个想法很大程度上是受Abel Wang的使用Azure DevOps的Azure App服务的静态Web App PR工作流<a class="ae me" href="https://devblogs.microsoft.com/devops/static-web-app-pr-workflow-for-azure-app-service-using-azure-devops/" rel="noopener ugc nofollow" target="_blank">的启发。</a></p><figure class="mg mh mi mj gt iv gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/7ffe609ab9d3f2535f29303c26803b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*HNlE3MYcuuNrNuQQgWN7Rw.png"/></div></figure><h1 id="1ee4" class="mk ml je bd mm mn mo mp mq mr ms mt mu kk mv kl mw kn mx ko my kq mz kr na nb bi translated">简单地</h1><p id="145c" class="pw-post-body-paragraph kt ku je kv b kw nc kf ky kz nd ki lb lc ne le lf lg nf li lj lk ng lm ln lo im bi translated">到本文结束时，您将已经构建了一个GitHub Actions工作流，它可以为Node.js(灵活的)项目自动执行以下过程。</p><ol class=""><li id="3aea" class="nh ni je kv b kw kx kz la lc nj lg nk lk nl lo nm nn no np bi translated">开发人员打开一个拉取请求。</li><li id="8b82" class="nh ni je kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">该操作构建拉请求，将其部署到一个唯一的URL，并在拉请求上留下一条注释，其中包含实时预览的链接。</li><li id="8e38" class="nh ni je kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">当开发人员将更多代码推送到拉请求的分支时，我们希望更新实时预览以反映他们的最新更改。</li><li id="beb4" class="nh ni je kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">一旦拉请求被关闭(通过合并显式地或隐式地)，实时预览应该被删除，因为它不再起作用。</li></ol><p id="2a00" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">✨ <strong class="kv jf">注意:</strong>最终的GitHub动作流程可以在本文底部找到。关于上下文，请继续阅读。</p><h1 id="ffc7" class="mk ml je bd mm mn mo mp mq mr ms mt mu kk mv kl mw kn mx ko my kq mz kr na nb bi translated">第1章:入门</h1><p id="7112" class="pw-post-body-paragraph kt ku je kv b kw nc kf ky kz nd ki lb lc ne le lf lg nf li lj lk ng lm ln lo im bi translated">本文假设您已经在Azure订阅中部署了Azure应用服务。如果您配置了从GitHub中的<em class="nv">主</em>分支到App服务的连续部署(这可以在创建App服务时配置，也可以稍后通过部署中心配置),您就可以开始了！</p><figure class="mg mh mi mj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nw"><img src="../Images/20419e7da2d8c16946cb699e4a4a0526.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yv65raq7VYsuTO1Yb24psA.png"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">将GitHub连接到用于CI/CD的Azure应用服务</figcaption></figure><h2 id="d763" class="ob ml je bd mm oc od dn mq oe of dp mu lc og oh mw lg oi oj my lk ok ol na om bi translated">创建服务主体</h2><p id="b709" class="pw-post-body-paragraph kt ku je kv b kw nc kf ky kz nd ki lb lc ne le lf lg nf li lj lk ng lm ln lo im bi translated">其次，我们需要<a class="ae me" href="https://docs.microsoft.com/en-us/cli/azure/create-an-azure-service-principal-azure-cli" rel="noopener ugc nofollow" target="_blank">创建一个服务主体</a>。请将此视为一组专用的凭证，GitHub操作流将使用这些凭证来创建、更新和删除App服务的部署槽。</p><p id="8bfe" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">不用硬编码您自己的用户名和密码，我们可以利用服务主体的RBAC配置来精确地限定其权限范围，这样它只能执行它需要执行的特定任务集，而不能执行其他任务。</p><h2 id="50c8" class="ob ml je bd mm oc od dn mq oe of dp mu lc og oh mw lg oi oj my lk ok ol na om bi translated"><strong class="ak">选项A:使用Azure门户创建服务主体</strong></h2><p id="f8e2" class="pw-post-body-paragraph kt ku je kv b kw nc kf ky kz nd ki lb lc ne le lf lg nf li lj lk ng lm ln lo im bi translated">遵循这个指南:<a class="ae me" href="https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-create-service-principal-portal" rel="noopener ugc nofollow" target="_blank">通过Azure门户创建服务主体</a></p><h2 id="e319" class="ob ml je bd mm oc od dn mq oe of dp mu lc og oh mw lg oi oj my lk ok ol na om bi translated"><strong class="ak">选项B:使用CLI创建服务主体</strong></h2><p id="9650" class="pw-post-body-paragraph kt ku je kv b kw nc kf ky kz nd ki lb lc ne le lf lg nf li lj lk ng lm ln lo im bi translated">假设您通过<code class="fe on oo op oq b">$ az login</code>进行了身份验证，在您的终端中执行下面的命令，但是一定要用您自己的值分别替换SUBSCRIPTION-ID和RESOURCE-GROUP占位符。</p><pre class="mg mh mi mj gt or oq os ot aw ou bi"><span id="86be" class="ob ml je oq b gy ov ow l ox oy">$ az ad sp create-for-rbac --name CICD-SP --role Contributor --scopes /subscriptions/[SUBSCRIPTION-ID]/resourceGroups/[RESOURCE-GROUP-NAME] --sdk-auth</span></pre><p id="552e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">上面的命令在你的Azure租户下创建一个名为<em class="nv"> CICD-SP </em>和角色<em class="nv">贡献者</em>的服务主体。输出如下所示。稍后我们需要复制整个JSON响应。</p><pre class="mg mh mi mj gt or oq os ot aw ou bi"><span id="f739" class="ob ml je oq b gy ov ow l ox oy">{<br/>  "clientId": "&lt;GUID&gt;",<br/>  "clientSecret": "&lt;GUID&gt;",<br/>  "subscriptionId": "&lt;GUID&gt;",<br/>  "tenantId": "&lt;GUID&gt;",<br/>  (...)<br/>}</span></pre><h1 id="5cfe" class="mk ml je bd mm mn mo mp mq mr ms mt mu kk mv kl mw kn mx ko my kq mz kr na nb bi translated">将服务主体添加为GitHub机密</h1><p id="b487" class="pw-post-body-paragraph kt ku je kv b kw nc kf ky kz nd ki lb lc ne le lf lg nf li lj lk ng lm ln lo im bi translated">第三步是告诉GitHub我们的服务原则，因为我们将在我们的动作工作流中使用它来认证和执行必要的部署任务。只需在您的存储库中创建一个新的GitHub Secret，然后粘贴上面的JSON响应。</p><p id="6a84" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我将命名我的秘密:<em class="nv"> AZURE_CREDENTIALS </em></p><figure class="mg mh mi mj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oz"><img src="../Images/6536b985525aec13c8424ccf0a9ad2e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B8dCLBt5kXRJqEH80F3HYA.png"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">创建一个新的GitHub秘密</figcaption></figure><h2 id="8490" class="ob ml je bd mm oc od dn mq oe of dp mu lc og oh mw lg oi oj my lk ok ol na om bi translated">回顾:刚刚发生了什么？</h2><p id="c941" class="pw-post-body-paragraph kt ku je kv b kw nc kf ky kz nd ki lb lc ne le lf lg nf li lj lk ng lm ln lo im bi translated">我们创建了一个具有所需权限的服务主体。这个服务主体随后作为一个秘密被添加到我们的GitHub存储库中。现在，我们可以从GitHub动作工作流内部认证Azure。</p><h1 id="3f69" class="mk ml je bd mm mn mo mp mq mr ms mt mu kk mv kl mw kn mx ko my kq mz kr na nb bi translated">第2章:构建GitHub动作工作流</h1><p id="f7c9" class="pw-post-body-paragraph kt ku je kv b kw nc kf ky kz nd ki lb lc ne le lf lg nf li lj lk ng lm ln lo im bi translated">正如我们已经发现的，Azure应用服务以部署插槽为特色。这些是可交换的环境，我们将利用它们为我们的拉请求动态地创建、发布和删除预览。</p><figure class="mg mh mi mj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pa"><img src="../Images/223d6e8dbfb101f4aeb75c485049b47a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q8v-AkXxwNwsIbQ3nfHWkg.png"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">它看起来会像这样！</figcaption></figure><h2 id="d5ef" class="ob ml je bd mm oc od dn mq oe of dp mu lc og oh mw lg oi oj my lk ok ol na om bi translated">让我们建造它！</h2><p id="5f19" class="pw-post-body-paragraph kt ku je kv b kw nc kf ky kz nd ki lb lc ne le lf lg nf li lj lk ng lm ln lo im bi translated">任何GitHub动作工作流的第一部分都是一个触发器，我们想要在一个<em class="nv"> pull_request </em>事件上触发，但是具体来说，每次一个pull请求都是<em class="nv">打开</em>、<em class="nv">同步</em>或者<em class="nv">关闭</em>。因此，我们的模板如下所示:</p><figure class="mg mh mi mj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pb"><img src="../Images/3ea73b238496647047c319c1f394ef3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xMpcYRJqfw7KeLrTEkw3JQ.png"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">GitHub动作工作流程剖析</figcaption></figure><p id="1e57" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如您所见，我们有三个具体的任务，分别对应于我们需要执行的操作类型(即创建、更新或删除预览)。我们在这里看到的是，每个作业都是根据事件动作的类型有条件地执行的。</p><h2 id="cd2f" class="ob ml je bd mm oc od dn mq oe of dp mu lc og oh mw lg oi oj my lk ok ol na om bi translated">通过自动注释通知开发人员</h2><p id="411e" class="pw-post-body-paragraph kt ku je kv b kw nc kf ky kz nd ki lb lc ne le lf lg nf li lj lk ng lm ln lo im bi translated">如果拉请求被打开(第一次)，我们触发<em class="nv">创建-部署-预览</em>。我们需要做的第一件事就是通知开发者一个拉请求预览正在构建中。让我们从使用<a class="ae me" href="https://github.com/marketplace/actions/create-or-update-comment" rel="noopener ugc nofollow" target="_blank">创建或更新评论</a>动作在这个拉请求上留下评论开始。</p><figure class="mg mh mi mj gt iv gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/e430cc86bf998fcd94919046ade91b25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*AZvmTPk9d_mjWuVcB6m8DQ.png"/></div></figure><p id="9e86" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">当在我们的工作流中实现时，它看起来像这样:</p><figure class="mg mh mi mj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pd"><img src="../Images/6384ba2b82b4a0a9dd0a086f0e4e0501.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eG5-oeWU4_5uD7t8kJLMRg.png"/></div></div></figure><figure class="mg mh mi mj gt iv gh gi paragraph-image"><div class="ab gu cl pe"><img src="../Images/5de973da7109ead1d5f9e77756ae2e01.png" data-original-src="https://miro.medium.com/v2/format:webp/1*spgtUKmEaBJ-v7KVCH6R4g.png"/></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">输出:对拉取请求的注释</figcaption></figure><h2 id="3e34" class="ob ml je bd mm oc od dn mq oe of dp mu lc og oh mw lg oi oj my lk ok ol na om bi translated">创建唯一的部署插槽</h2><p id="61c2" class="pw-post-body-paragraph kt ku je kv b kw nc kf ky kz nd ki lb lc ne le lf lg nf li lj lk ng lm ln lo im bi translated">这时我们的服务负责人终于出现了。我们需要连续做三步。登录Azure，在我们的应用服务中创建部署槽，并发布代码！</p><p id="e1f8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">得益于<a class="ae me" href="https://github.com/marketplace/actions/azure-login" rel="noopener ugc nofollow" target="_blank"> Azure登录</a>动作，通过GitHub动作登录Azure变得简单了。我们需要做的就是引用我们之前创建的GitHub秘密。</p><figure class="mg mh mi mj gt iv gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/d48cc9df860111bb7c195fa4352e8d84.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*lkCBFscI2InrnlkYVAiWAQ.png"/></div></figure><figure class="mg mh mi mj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pg"><img src="../Images/799e5df4855ec066e5c3216d82413074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kY116ZNtVkAQTx1fNUESNQ.png"/></div></div></figure><p id="85fd" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">一旦我们通过了身份验证，我们希望创建一个惟一的部署槽，将拉请求的实时预览推送到这个部署槽。在这一步，我们通过<a class="ae me" href="https://github.com/marketplace/actions/azure-cli-action" rel="noopener ugc nofollow" target="_blank"> Azure CLI动作</a>利用Azure CLI命令。</p><figure class="mg mh mi mj gt iv gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/45cc4dabeea6027ad7cc7aea80144cd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*3VtWSP-fPCLaLLJ-cjH3Sw.png"/></div></figure><figure class="mg mh mi mj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pi"><img src="../Images/69ac2972dbb5b3df33759ec9898304e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lPxpvgkB5N0mRsEMA4uK-g.png"/></div></div></figure><p id="ee5f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">当我们调用Azure CLI命令来创建新的部署插槽时，这里会发生一些事情(参见<a class="ae me" href="https://docs.microsoft.com/en-us/cli/azure/webapp/deployment/slot" rel="noopener ugc nofollow" target="_blank"> CLI文档</a>)。</p><p id="4549" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">首先，我们传递应用服务的名称和相应的资源组。最后，我们需要向命令传递一个插槽名称。这里，我们根据连续的拉请求编号动态地构建一个名称。例如:<em class="nv">预览-pr-1 </em></p><figure class="mg mh mi mj gt iv gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/20b8e181adbb31e640adb3eda94c3bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*hqsUe-lDg3XySbGKEU4xtA.png"/></div></figure><figure class="mg mh mi mj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pk"><img src="../Images/1370cdaed9eb734e95c11f56e9a67512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jaR-vjNFeTuljk7zFMFtCQ.png"/></div></div></figure><p id="4b0e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，我们将拉请求预览发布到先前创建的部署槽。这意味着我们将能够在完成后在浏览器中查看它。但是你会问，开发人员如何知道这个动态构造的预览URL呢？提示:我们更新评论！</p><h2 id="c021" class="ob ml je bd mm oc od dn mq oe of dp mu lc og oh mw lg oi oj my lk ok ol na om bi translated">更新部署预览注释</h2><p id="9d27" class="pw-post-body-paragraph kt ku je kv b kw nc kf ky kz nd ki lb lc ne le lf lg nf li lj lk ng lm ln lo im bi translated">为了不使pull请求复杂化，我们将最初的注释(通知开发人员他们的代码正在部署中)更新为更有用的消息，共享到实时预览的链接。使用注释id和<em class="nv">编辑模式:替换</em>我们可以简单地覆盖它。</p><p id="5cab" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">此外:+100加分，因为你可以在评论中添加反馈！</p><figure class="mg mh mi mj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pl"><img src="../Images/356d5560c8a3e3980671584de22f05f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YCsxrvuxPdxXwZKtDh6oMg.png"/></div></div></figure><figure class="mg mh mi mj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pa"><img src="../Images/223d6e8dbfb101f4aeb75c485049b47a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q8v-AkXxwNwsIbQ3nfHWkg.png"/></div></div></figure><p id="02ac" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">🎉恭喜你！这就是我从现在开始用Azure App Service做拉请求部署预览的方式。</p><figure class="mg mh mi mj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pm"><img src="../Images/657aa7fcfd21a58c5f396b4a701b2ab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nEDM81GpHDeRbOQUNmjg3Q.png"/></div></div></figure><p id="1632" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">完整的GitHub Actions工作流(包括如何处理对Pull请求的更新，以及在PR结束时删除部署槽)记录如下。我将感谢您的反馈👏🏼</p><p id="db60" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">✨领英:<a class="ae me" href="https://www.linkedin.com/in/olafwrieden/" rel="noopener ugc nofollow" target="_blank">奥拉夫·瑞伊登</a>T2】✨github:<a class="ae me" href="https://github.com/olafwrieden" rel="noopener ugc nofollow" target="_blank">关注我</a></p><figure class="mg mh mi mj gt iv gh gi paragraph-image"><a href="https://www.buymeacoffee.com/olafwrieden"><div class="gh gi pn"><img src="../Images/82a7c4ed4c162a5206eef14d35022d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*2YFz6pIz0GcYH0W76wZlyw.png"/></div></a></figure><h2 id="54f8" class="ob ml je bd mm oc od dn mq oe of dp mu lc og oh mw lg oi oj my lk ok ol na om bi translated">完成GitHub操作工作流程</h2><figure class="mg mh mi mj gt iv"><div class="bz fp l di"><div class="po pp l"/></div></figure></div></div>    
</body>
</html>