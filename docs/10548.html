<html>
<head>
<title>Playing with Lenia, a Continuous Version of Conway’s Game of Life</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与Lenia玩耍，康威生命游戏的连续版本</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/playing-with-lenia-a-continuous-version-of-conways-game-of-life-a26a5a7f1680?source=collection_archive---------15-----------------------#2021-12-19">https://levelup.gitconnected.com/playing-with-lenia-a-continuous-version-of-conways-game-of-life-a26a5a7f1680?source=collection_archive---------15-----------------------#2021-12-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/cc473b3ff91ee96aec06b7520d901aae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*CwTP7ARiYE_BvsWOQzCkLA.gif"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">一些列宁主义的例子</figcaption></figure><p id="b923" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你读了这篇文章，很可能你已经知道康威的生活游戏。它基本上是生活在二维网格世界中的细胞，其中的细胞可以是活的，也可以是死的。给定初始配置，它们遵循一组简单的规则进化。在这里，我们将看到由伯特·王Chan陈(2015)创作的《勒尼亚》，这是康威《生活的游戏》的广义或连续版本。</p><p id="aba3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">先看基础的。经典的生活游戏有这些简单的规则:</p><ol class=""><li id="03e6" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">任何具有少于两个活邻居(在<em class="lf"> t -1 </em>)的活单元(在时间<em class="lf"> t-1 </em>)在时间<em class="lf"> t </em>转变为死状态。</li><li id="49a9" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">任何具有两个或三个存活邻居(<em class="lf"> t -1 </em>)的存活单元(<em class="lf"> t -1 </em>)在时间<em class="lf"> t </em>保持存活。</li><li id="e19e" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">任何具有三个以上活邻居(<em class="lf"> t -1 </em>)的活单元(<em class="lf"> t -1 </em>)在时间<em class="lf"> t </em>转变为死状态。</li><li id="f92e" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">恰好具有三个活邻居(<em class="lf"> t -1 </em>)的死单元(<em class="lf"> t -1 </em>)在时间<em class="lf"> t </em>转变到活状态。</li></ol><p id="1ecf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想用这些规则为生命游戏写一个程序，你可以用一些简单的循环来计算相邻的单元格和一些if-else语句。为了计算相邻细胞的数量，你可以看到使用卷积和这个内核将有助于以后的推广。</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ll"><img src="../Images/6ddb8d28f2a327cfcc99d43b680b7b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3kyeR7lgHLpIQBxcvTz5Pg.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">核K矩阵及其可视化</figcaption></figure><p id="bc23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个内核将帮助计算有多少个邻居单元(不包括它自己在中心)。除了使用与这个核的卷积来计算相邻细胞，我们还需要做一些条件来根据上面的规则进化细胞。为了概括这一点，我们可以使用称为增长或映射函数的东西。对于生命的经典游戏，成长函数值会离散为<em class="lf"> 1 </em>(出生)<em class="lf"> 0 </em>(存活)，或者<em class="lf"> -1 </em>(死亡)。为了用这些计算和规则来形象化经典生活游戏，我们可以看到这个图表。世界<em class="lf"> A </em>，站点<em class="lf"> x </em>和邻居<em class="lf"> N </em>如下图所示。进化将通过将内核<em class="lf"> K </em>和函数<em class="lf"> G </em>应用于初始<em class="lf"> A </em>来更新/进化单元，并再次重复。</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lu"><img src="../Images/d1d374d306387ccb563bc33909e41b0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4StqjUYM65YRnSo3uOxRnQ.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">经典康威生活游戏规则</figcaption></figure><p id="ca26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个生活游戏的Python代码可以这样写(你可以用Jupyter笔记本在线运行这个<a class="ae lv" href="https://cocalc.com/projects?session=default" rel="noopener ugc nofollow" target="_blank">:</a></p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="51db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行代码后，结果将如下所示:</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ly"><img src="../Images/90ddd99e9b059a0191caaf393ef08d47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Y2h_pCaq-YXCKGXnqFejYQ.gif"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">康威的生活游戏:滑翔机</figcaption></figure><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lz"><img src="../Images/d4484e092477cff82404d546690989e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VZlwt5gs0N_L3S7zAT8gRw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">康威的生命游戏:内核和生长函数</figcaption></figure><p id="6afe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，Lenia有类似的规则，但推广到连续域，具有实值的无穷小站点<em class="lf"> x </em>，循环邻域<em class="lf"> N </em>，环状内核<em class="lf"> K </em>(模仿经典生命游戏的内核)，平滑增长函数<em class="lf"> G </em>(模仿经典生命游戏的步进/离散<em class="lf"> G </em>，增量时间更新<em class="lf"> dt </em>。<em class="lf"> A </em>的更新值也被夹在<em class="lf"> 0 </em>和<em class="lf"> 1 </em>之间(如果更新值低于<em class="lf"> 0 </em>，将被设置为<em class="lf">0</em>；如果该值高于<em class="lf"> 1 </em>，则设置为<em class="lf"> 1 </em>。</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ma"><img src="../Images/e15e19161dccd1fc7b3eecab76ffce6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FFoG-lRhgWkyTtnCDBBd9g.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">勒尼亚的统治</figcaption></figure><p id="6df0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本上，该规则可以用以下公式表示:</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/b673635d54c8a85c0895889bf5effad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/1*X_ow9o49uUN4mFeumbUS5g.gif"/></div></figure><p id="cb85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Python代码可以这样写(来自Lenia):</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="e6e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面代码的结果:</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ly"><img src="../Images/c33e51c963afa526bcf017bc81595b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jBS4gRzSpLwlCyhVeWob8w.gif"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">莱娜:奥比姆</figcaption></figure><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi mc"><img src="../Images/8343587eefe7858d84ae234e63d92663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zm-U0fjOMOuhZkTW_unqRQ.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">Lenia:核函数和生长函数</figcaption></figure><p id="9e9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这里阅读更多关于伯特·王Chan陈的文章。至于更有效的计算，可以用快速傅立叶变换(FFT)代替上面的简单卷积计算。</p><p id="0fac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想在不自己运行代码的情况下和Lenia一起玩，Lenia的作者在这里有一个web (Javascript)版本可以玩<a class="ae lv" href="https://chakazul.github.io/Lenia/JavaScript/Lenia.html" rel="noopener ugc nofollow" target="_blank">https://chakazul.github.io/Lenia/JavaScript/Lenia.html</a>:</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi md"><img src="../Images/46209aecc0b665a74f8d8046d14ca969.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XF_yLxHUJHoiqPYURypfIA.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated"><a class="ae lv" href="https://chakazul.github.io/Lenia/JavaScript/Lenia.html" rel="noopener ugc nofollow" target="_blank"> Lenia网页版</a>截图</figcaption></figure><p id="e8b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过Lenia，你可以探索生命游戏连续版本的不同规则，比如使用不同的内核和生长函数来观察这些生物如何进化和行为。看到这个数字世界的简单规则可以导致一些涌现现象，这有点酷。2020年，Lenia还进行了进一步的扩展，在3D/4D中产生了更多有趣的图案。如果你觉得这个有意思，就去看看，玩玩。</p></div></div>    
</body>
</html>