<html>
<head>
<title>Image Processing — Making Custom Image Filters in React.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图像处理-在React.js中制作自定义图像滤镜</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/image-processing-making-custom-image-filters-react-js-part-2-ee2787f56b0d?source=collection_archive---------4-----------------------#2019-08-06">https://levelup.gitconnected.com/image-processing-making-custom-image-filters-react-js-part-2-ee2787f56b0d?source=collection_archive---------4-----------------------#2019-08-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0bb6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢阅读我的<a class="ae ko" href="https://overflowjs.com/posts/Image-Processing-In-Reactjs-Part-1.html" rel="noopener ugc nofollow" target="_blank">第一部</a>。现在准备开始另一个实现。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/fa8287c9f7c337d0ce209cdcfe9aa78a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M7NM6E6R6KY8MBl9gTML3A.png"/></div></div></figure><blockquote class="lb lc ld"><p id="fd76" class="jq jr le js b jt ju jv jw jx jy jz ka lf kc kd ke lg kg kh ki lh kk kl km kn im bi translated"><em class="it">注意:第1部分讲述了图像处理的基本原理，然后使用Cloudniary API创建了一个小的过滤器应用程序。查看直播app点击这里—</em><a class="ae ko" href="https://cryptic-sierra-27182.herokuapp.com/" rel="noopener ugc nofollow" target="_blank"><em class="it"/></a><em class="it">，阅读博文</em> <a class="ae ko" href="https://overflowjs.com/posts/Image-Processing-In-Reactjs-Part-1.html" rel="noopener ugc nofollow" target="_blank"> <em class="it">点击这里</em> </a> <em class="it">了解更多。</em></p></blockquote><p id="b1bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编程中最有趣的事情之一就是用不同的方法解决同一个问题。但是一切都是有代价的。正如我们在本系列的第一部分中使用Cloudniary进行图像处理一样，这是一个付费的解决方案，尽管它是一个很好的库。</p><p id="c823" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">今天，我们将在处理图像时实现一些重要的概念:</p><ol class=""><li id="d914" class="li lj it js b jt ju jx jy kb lk kf ll kj lm kn ln lo lp lq bi translated">平滑滤波器(一些滤波器和算法)</li><li id="884d" class="li lj it js b jt lr jx ls kb lt kf lu kj lv kn ln lo lp lq bi translated">阈值过滤器</li><li id="c336" class="li lj it js b jt lr jx ls kb lt kf lu kj lv kn ln lo lp lq bi translated">在图像中寻找轮廓</li></ol><p id="b7ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们将使用直播摄像机从网络摄像头直播流中捕捉一些图像。</p><blockquote class="lb lc ld"><p id="d87f" class="jq jr le js b jt ju jv jw jx jy jz ka lf kc kd ke lg kg kh ki lh kk kl km kn im bi translated"><em class="it">注:这里是UI的直播app链接(第一次加载可能需要时间)——</em><a class="ae ko" href="https://peaceful-reef-69295.herokuapp.com/" rel="noopener ugc nofollow" target="_blank"><em class="it">https://peaceful-reef-69295.herokuapp.com/</em></a><em class="it">和Github代码链接——</em><a class="ae ko" href="https://github.com/overflowjs-com/image_app_image_processing_opencvviawebcam_part_2" rel="noopener ugc nofollow" target="_blank"><em class="it">https://Github . com/overflow js-com/image _ app _ image _ processing _ opencvviaweb cam _ part _ 2</em></a><em class="it">，欢迎随时查看。</em></p></blockquote></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="0d29" class="md me it bd mf mg mh dn mi mj mk dp ml kb mm mn mo kf mp mq mr kj ms mt mu mv bi translated">图书馆</h2><p id="5a85" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">OpenCV:<a class="ae ko" href="https://www.npmjs.com/package/opencv4nodejs" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/opencv4nodejs</a></p><ul class=""><li id="5a66" class="li lj it js b jt ju jx jy kb lk kf ll kj lm kn nb lo lp lq bi translated">如果你是初学者，这需要时间。建立第三方系统是需要学习的。</li></ul><p id="f29b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">节点js:<a class="ae ko" href="https://www.npmjs.com/package/opencv4nodejs" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/opencv4nodejs</a></p><p id="e6d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">网络摄像头连接器:<a class="ae ko" href="https://www.npmjs.com/package/react-webcam" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/react-webcam</a></p><ul class=""><li id="7a71" class="li lj it js b jt ju jx jy kb lk kf ll kj lm kn nb lo lp lq bi translated">使用网络摄像头包装器的直接实现</li></ul><p id="9ed9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">API调用库</p><ul class=""><li id="2dc8" class="li lj it js b jt ju jx jy kb lk kf ll kj lm kn nb lo lp lq bi translated">我们使用来自NPM的同构读取从React调用API</li></ul><p id="1913" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">前端:反应和材质UI。要获得更多帮助，请参阅上一篇文章</p><ul class=""><li id="4e5c" class="li lj it js b jt ju jx jy kb lk kf ll kj lm kn nb lo lp lq bi translated"><a class="ae ko" href="https://material-ui.com/" rel="noopener ugc nofollow" target="_blank">https://material-ui.com/</a></li></ul><p id="fd11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">API:用ES6编写的Nodejs Express.js代码，用于API和服务器端处理。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="bc86" class="md me it bd mf mg mh dn mi mj mk dp ml kb mm mn mo kf mp mq mr kj ms mt mu mv bi translated"><strong class="ak">让我们先从用户界面开始</strong></h2><p id="fabd" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">我们的目标是从网络摄像头捕捉图像，然后通过我们自己的API调用应用过滤器。</p><ol class=""><li id="bf2a" class="li lj it js b jt ju jx jy kb lk kf ll kj lm kn ln lo lp lq bi translated">创建新的react应用程序:</li></ol><pre class="kq kr ks kt gt nc nd ne nf aw ng bi"><span id="de43" class="md me it nd b gy nh ni l nj nk">create-react-app image_app_opencvwebcam</span></pre><p id="3bf9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.进入项目内部并安装依赖项:</p><pre class="kq kr ks kt gt nc nd ne nf aw ng bi"><span id="bbf1" class="md me it nd b gy nh ni l nj nk">cd image_app_opencvwebcam<br/>npm install @material-ui/core — save<br/>npm install react-webcam — save<br/>npm install — save isomorphic-fetch es6-promise</span></pre><p id="faa0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.让我们在<code class="fe nl nm nn nd b">src</code>文件夹中创建一个<code class="fe nl nm nn nd b">containers, components, utlis</code>文件夹。容器将包含作为我们主要入口点的<code class="fe nl nm nn nd b">ImageOps.jsx</code>，组件将包含作为我们可重用组件的<code class="fe nl nm nn nd b">Imagefilter.jsx</code>和<code class="fe nl nm nn nd b">WebCamCapture.jsx</code>。<code class="fe nl nm nn nd b">Utils</code>将使用我们的<code class="fe nl nm nn nd b">Api.js</code> API包装器来访问Node.js服务器。</p><p id="b2f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该目录将如下所示</p><pre class="kq kr ks kt gt nc nd ne nf aw ng bi"><span id="ef45" class="md me it nd b gy nh ni l nj nk">image_app_opencvwebcam<br/>├── README.md<br/>├── node_modules<br/>├── package.json<br/>├── .gitignore<br/>├── public<br/>│   ├── favicon.ico<br/>│   ├── index.html<br/>│   └── manifest.json<br/>└── src<br/>    ├── containers<br/>        ├── ImageOps.jsx<br/>    ├── components<br/>        ├── Imagefilter.jsx<br/>        ├── WebCamCapture.jsx<br/>    ├── utils<br/>        ├── Api.js<br/>    ├── App.css<br/>    ├── App.js<br/>    ├── App.test.js<br/>    ├── index.css<br/>    ├── index.js<br/>    ├── logo.svg<br/>    └── serviceWorker.js</span></pre><p id="49ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你读过我们的第一篇文章，你就会知道我们的App.js代码是什么:)</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="3bb8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们检查一下<code class="fe nl nm nn nd b">ImageOps.jsx</code>渲染代码:</p><pre class="kq kr ks kt gt nc nd ne nf aw ng bi"><span id="d6d3" class="md me it nd b gy nh ni l nj nk">import React from 'react';</span><span id="2c7e" class="md me it nd b gy no ni l nj nk">import Container from '@material-ui/core/Container';<br/>import Grid from '@material-ui/core/Grid';<br/>import Card from '@material-ui/core/Card';<br/>import CardHeader from '@material-ui/core/CardHeader';<br/>import CardContent from '@material-ui/core/CardContent';<br/>import Typography from '@material-ui/core/Typography';<br/>import WebCamCapture from './Components/WebCamCapture';</span><span id="39ae" class="md me it nd b gy no ni l nj nk">export default class ImageOpsContainer extends React.Component {<br/>    <br/> constructor(props) {<br/>   super(props);</span><span id="79a4" class="md me it nd b gy no ni l nj nk">   this.state ={<br/>     image_data: null<br/>   };<br/> }</span><span id="1f9e" class="md me it nd b gy no ni l nj nk">saveCapturedImage(data) {<br/>  this.setState({ image_data: data });<br/>}</span><span id="544b" class="md me it nd b gy no ni l nj nk">render() {<br/>  return (<br/>    &lt;Container maxWidth="md"&gt;<br/>      &lt;Grid container spacing={2}&gt;<br/>        &lt;Grid item xs={12}&gt;<br/>          &lt;Card&gt;<br/>            &lt;CardContent&gt;<br/>               &lt;Typography variant="body" color="textPrimary"   component="p"&gt;<br/>                  Image processing part-2<br/>               &lt;/Typography&gt;<br/>               &lt;Typography variant="h6" color="textPrimary" component="h6"&gt;<br/>                  CAMERA PREVIEW<br/>               &lt;/Typography&gt;<br/>               &lt;WebCamCapture saveCapturedImage={(data) =&gt;<br/>               this.saveCapturedImage(data)}/&gt;<br/>            &lt;/CardContent&gt;<br/>           &lt;/Card&gt;<br/>        &lt;/Grid&gt;<br/>      &lt;/Grid&gt;<br/>    &lt;/Container&gt;<br/>  );<br/>}</span></pre><p id="e0e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:我们已经从@material-ui模块导入了容器、网格、卡片、卡片内容、版式，并从我们自己的组件<code class="fe nl nm nn nd b">WebCamCapture.jsx</code>导入了WebCamCapture</p><p id="2002" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">顾名思义，WebCamCapture是用来从相机中捕获图像的，我们还通过<code class="fe nl nm nn nd b">saveCapturedImage</code>函数作为道具，当我们单击<code class="fe nl nm nn nd b">WebCamCapture</code>组件中的捕获按钮时，get会调用这个函数。<code class="fe nl nm nn nd b">saveCapturedImage</code>功能只是用图像数据设置容器状态。</p><pre class="kq kr ks kt gt nc nd ne nf aw ng bi"><span id="9df7" class="md me it nd b gy nh ni l nj nk">saveCapturedImage(data) {<br/>  this.setState({ image_data: data });<br/>}</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="10ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们看看WebCamCapture组件，以便更好地了解该组件的工作原理:</p><pre class="kq kr ks kt gt nc nd ne nf aw ng bi"><span id="038a" class="md me it nd b gy nh ni l nj nk">import React from 'react';<br/>import Webcam from 'react-webcam';<br/>import Grid from '<a class="ae ko" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/Grid';<br/>import Button from '<a class="ae ko" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/Button';</span><span id="3ba0" class="md me it nd b gy no ni l nj nk">export default class WebCamCaptureContainer extends React.Component {<br/>    constructor(props) {<br/>        super(props);<br/>        this.state = {<br/>            videoConstants: {<br/>                width: 1200,<br/>                height: 720,<br/>                facingMode: 'user'<br/>            }<br/>        }<br/>    }<br/>    captureImage() {<br/>          this.props.saveCapturedImage(this.refs.webcam.getScreenshot());<br/>    }<br/>    render() {<br/>   return (<br/>     &lt;div&gt;<br/>      &lt;Grid container spacing={1}&gt;<br/>        &lt;Grid item xs={12}&gt;<br/>          &lt;Webcam<br/>            ref="webcam"<br/>            audio={false}<br/>            // height={350}<br/>            screenshotFormat="image/jpeg"<br/>            // width={350}<br/>            videoConstraints={this.state.videoConstants}<br/>            /&gt;<br/>          <br/>        &lt;/Grid&gt;<br/>        &lt;Grid item xs={12}&gt;<br/>          &lt;Button variant="contained" align="center" color="primary" onClick={() =&gt;  this.captureImage()} &gt;<br/>            Capture<br/>          &lt;/Button&gt;<br/>        &lt;/Grid&gt;<br/>      &lt;/Grid&gt;<br/>     &lt;/div&gt;<br/>   );<br/>    }<br/>}</span></pre><p id="9f6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们添加了网络摄像头组件和按钮来捕捉当前图像。两者都在12个空格的网格中，这意味着一行中只有一个组件。</p><p id="8728" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">点击按钮时，我们从网络摄像头捕捉当前图像作为截图，并将其传递给从<code class="fe nl nm nn nd b">ImageOps.jsx</code>传递来的道具函数<code class="fe nl nm nn nd b">saveCapturedImage</code></p><blockquote class="lb lc ld"><p id="6cba" class="jq jr le js b jt ju jv jw jx jy jz ka lf kc kd ke lg kg kh ki lh kk kl km kn im bi translated">注意:如果您在理解该材料代码时有困难，请转到—<a class="ae ko" href="https://material-ui.com/components/" rel="noopener ugc nofollow" target="_blank">https://material-ui.com/components/</a></p></blockquote><p id="7e5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们运行这个项目，通过<code class="fe nl nm nn nd b">npm start</code>看看到目前为止我们已经构建了什么</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi np"><img src="../Images/a5234ecf4d5279ca9ef36b78bb652302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VFyamISMZB70AmK887hzSQ.png"/></div></div></figure><p id="04de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们继续过滤和编码他们的用户界面。</p><h1 id="39e9" class="nq me it bd mf nr ns nt mi nu nv nw ml nx ny nz mo oa ob oc mr od oe of mu og bi translated">平滑过滤器:</h1><p id="bfbe" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">平滑图像或者我们可以说模糊图像在许多图像操作中非常有用。最大的一个问题是减少图像中的噪声，如果我们创建一个遮罩或进行对象检测/面部检测或处理任何类型的图像，这将非常有用。</p><p id="21cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注:如需了解更多信息，请访问—<a class="ae ko" href="https://docs.opencv.org/2.4/doc/tutorials/imgproc/gausian_median_blur_bilateral_filter/gausian_median_blur_bilateral_filter.html" rel="noopener ugc nofollow" target="_blank">https://docs . opencv . org/2.4/doc/tutorials/imgproc/Gaussian _ median _ blur _ bias _ filter/Gaussian _ median _ blur _ bias _ filter . html</a></p><p id="dbe0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在在组件内部，我们将创建另一个组件<code class="fe nl nm nn nd b">Imagefilter.jsx</code></p><pre class="kq kr ks kt gt nc nd ne nf aw ng bi"><span id="7e9e" class="md me it nd b gy nh ni l nj nk">import React from 'react';</span><span id="00b6" class="md me it nd b gy no ni l nj nk">import Grid from '<a class="ae ko" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/Grid';<br/>import Button from '<a class="ae ko" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/Button';<br/>import Typography from '<a class="ae ko" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/Typography';</span><span id="bfaa" class="md me it nd b gy no ni l nj nk">import Card from '<a class="ae ko" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/Card';<br/>import CardContent from '<a class="ae ko" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/CardContent';<br/>import { Divider, CardHeader } from '<a class="ae ko" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core';<br/>import {api} from '../Utils/Api';</span><span id="585e" class="md me it nd b gy no ni l nj nk">export default class ImageFilters extends React.Component {</span><span id="2ba2" class="md me it nd b gy no ni l nj nk"> constructor(props) {<br/>        super(props);<br/>        <br/>        this.state = {<br/>            smoothing_effects: [<br/>                {label: "Blur", key: "blur"},<br/>                {label: "Gaussian Blur", key: "gaussian_blur"},<br/>                {label: "Median Blur", key: "median_blur"},<br/>                {label: "Bilateral Filter", key: "median_filter"},<br/>            ],<br/>            render: {}<br/>        }<br/>    }</span><span id="6e6d" class="md me it nd b gy no ni l nj nk">  applyEffect(effect) {<br/>    api("apply_filter", {<br/>      type: effect,<br/>      data: this.props.image_data<br/>    }).then((data) =&gt; {<br/>       const render = this.state.render;<br/>       render[effect] = data;<br/>       this.setState({render});<br/>     });<br/>   }</span><span id="bd73" class="md me it nd b gy no ni l nj nk">   getFilterData(effect) {<br/>     if(this.state.render[effect]) {<br/>       return this.state.render[effect];<br/>     }<br/>     return this.props.image_data;<br/>   }</span><span id="6b1a" class="md me it nd b gy no ni l nj nk">  render() {</span><span id="471d" class="md me it nd b gy no ni l nj nk">    if (!this.props.image_data) {<br/>      return (<br/>        &lt;div/&gt;;<br/>      )<br/>    }</span><span id="d2eb" class="md me it nd b gy no ni l nj nk">    return (<br/>            &lt;Grid container&gt;<br/>                {this.state[this.props.type].map((effect, i) =&gt; {<br/>                    return (<br/>                        &lt;Grid item md={4} key={i}&gt;<br/>                            &lt;Card&gt;<br/>                              &lt;CardHeader title={`${effect.label}   Image`}&gt;<br/>                                &lt;/CardHeader&gt;<br/>                                &lt;CardContent&gt;<br/>                                    &lt;img src={this.getFilterData(effect.key)} alt="" height="300px" /&gt;<br/>                                    &lt;Button variant="contained" align="center" color="secondary" onClick={() =&gt; this.applyEffect(effect.key)} &gt;<br/>                                        Generate<br/>                                    &lt;/Button&gt;<br/>                                &lt;/CardContent&gt;<br/>                            &lt;/Card&gt;<br/>                            &lt;Divider /&gt;<br/>                        &lt;/Grid&gt;<br/>                     )<br/>                })}<br/>            &lt;/Grid&gt;<br/>        )<br/>    }<br/>}</span></pre><p id="9288" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们了解一下代码是怎么回事。</p><p id="9acc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个组件非常简单。我们已经启动了一个网格容器，然后根据道具类型(smoothing _ effects/threshold _ effects/contour _ effects)迭代状态场效应，以生成每个效果卡。</p><p id="6b46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于中型设备来说，卡容器是一个4列的网格，而对于较小的设备来说，卡容器占据整个12列的空间。现在对于较大的器件，4列每行将产生3列。</p><p id="bfba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在渲染时，我们检查捕捉的图像是否可用，如果可用，那么显示要应用的过滤器。</p><pre class="kq kr ks kt gt nc nd ne nf aw ng bi"><span id="716e" class="md me it nd b gy nh ni l nj nk">&lt;Card&gt;<br/>    &lt;CardHeader title={`${effect.label} Image`}&gt;<br/>    &lt;/CardHeader&gt;<br/>    &lt;CardContent&gt;<br/>        &lt;img src={this.getFilterData(effect.key)} alt="" height="300px" /&gt;<br/>        &lt;Button variant="contained" align="center" color="secondary" onClick={() =&gt; this.applyEffect(effect.key)} &gt;<br/>            Generate<br/>        &lt;/Button&gt;<br/>    &lt;/CardContent&gt;<br/>&lt;/Card&gt;</span></pre><p id="7eb1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们有了一个图像作为内容和一个按钮来应用过滤器。图像内容来自下面的函数。</p><pre class="kq kr ks kt gt nc nd ne nf aw ng bi"><span id="a8d5" class="md me it nd b gy nh ni l nj nk">getFilterData(effect) {<br/>    if(this.state.render[effect]) {<br/>        return this.state.render[effect];<br/>    }<br/>  return this.props.data;<br/>}</span></pre><p id="9916" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如你所见，我们正在检查天气效果是否保存在状态对象中。如果是，那么渲染它，否则只返回原始图像。同样，在点击按钮时，我们从Api.js文件中调用一个API对象。在API对象中，我们传递端点名称和一些必需的参数。成功执行后，我们将设置状态渲染对象，并使用相应的过滤器显示图像:</p><pre class="kq kr ks kt gt nc nd ne nf aw ng bi"><span id="327e" class="md me it nd b gy nh ni l nj nk">applyEffect(effect) {<br/>    api("apply_filter", {<br/>        type: effect,<br/>        data: this.props.image_data<br/>    }).then((data) =&gt; {<br/>        const render = this.state.render;<br/>        render[effect] = data;<br/>        this.setState({render});<br/>    });<br/>}</span></pre><p id="bd88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看utils中的Api.js文件</p><pre class="kq kr ks kt gt nc nd ne nf aw ng bi"><span id="f5e1" class="md me it nd b gy nh ni l nj nk">import fetch from  'isomorphic-fetch';<br/>const BASE_API_URL = "<a class="ae ko" href="http://localhost:4000/" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/</a>"<br/>return fetch(BASE_API_URL+api_end_point,<br/>    {<br/>        method: 'POST',<br/>        headers: {<br/>            'Content-Type': 'application/json'<br/>        },<br/>        body:JSON.stringify(data)<br/>    }).then((response) =&gt; {<br/>        return response.json();<br/>    });<br/>}</span></pre><p id="2149" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我们使用来自同构获取模块的获取API来调用我们的自定义API。</p><p id="bc8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:要阅读更多关于这个模块的内容，请查看<a class="ae ko" href="https://github.com/matthew-andrews/isomorphic-fetch" rel="noopener ugc nofollow" target="_blank">https://github.com/matthew-andrews/isomorphic-fetch</a></p><p id="6ff8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe nl nm nn nd b">ImageOps.jsx</code>中，我们创建了两个网格</p><pre class="kq kr ks kt gt nc nd ne nf aw ng bi"><span id="d118" class="md me it nd b gy nh ni l nj nk">{this.state.image_data &amp;&amp; <br/> &lt;Grid item md={12}&gt;<br/>        &lt;CardHeader title={`Captured Image`}&gt;<br/>    &lt;/CardHeader&gt;<br/>    &lt;img src={this.state.image_data} alt="" height="300px"/&gt;<br/>&lt;/Grid&gt;}<br/>&lt;Grid item xs={12}&gt;<br/>    &lt;Card&gt;<br/>        &lt;CardContent&gt;<br/>            &lt;Typography variant="h6" color="textPrimary" component="h6"&gt;<br/>                IMAGE SMOOTH FILTERS<br/>            &lt;/Typography&gt;<br/>            &lt;ImageFilters image_data={this.state.image_data} type="smoothing_effects" /&gt;<br/>        &lt;/CardContent&gt;<br/>    &lt;/Card&gt;<br/>&lt;/Grid&gt;</span></pre><p id="4c93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个网格用于显示在我们的状态下对应于image_data的捕获图像。第二个网格是12列网格，包含ImageFilters组件，在ImageFilters中，我们传递两个属性数据image_data和效果类型。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi oh"><img src="../Images/b83041151355a59f82917f61fd5eb282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ArUbwj45nZB6G6RsDipcCg.png"/></div></div></figure><p id="364b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在完成了平滑过滤器，让我们为另外两个编写UI代码。</p><h1 id="7e82" class="nq me it bd mf nr ns nt mi nu nv nw ml nx ny nz mo oa ob oc mr od oe of mu og bi translated">阈值过滤器:</h1><p id="9151" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">阈值滤波用于图像分割，可用于信息提取。许多过程使用它来产生和分析二进制过滤器。它赋予每个像素白色或黑色。并且哪个像素将是白色或黑色的决定因素取决于算法。我们将在这里使用其中的一些。</p><p id="a722" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于像从图像中读取数字、识别物体或从图像中读取文本这样的信息提取，所有这些都使用阈值作为一个过程。</p><p id="62a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">UI代码大部分都是相同的，只是有一些状态更新。</p><p id="da25" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的<code class="fe nl nm nn nd b">Imagefilter.jsx</code>组件中，我们将为状态添加阈值效果。</p><pre class="kq kr ks kt gt nc nd ne nf aw ng bi"><span id="b62f" class="md me it nd b gy nh ni l nj nk">this.state = {<br/>    smoothing_effects: [<br/>        {label: "Blur", key: "blur"},<br/>        {label: "Gaussian Blur", key: "gaussian_blur"},<br/>        {label: "Median Blur", key: "median_blur"},<br/>        {label: "Bilateral Filter", key: "median_filter"},<br/>    ],<br/>    threshold_effects: [<br/>        {label: "Simple Threshold", key: "simple_threshold"},<br/>        {label: "Adaptive Threshold", key: "adaptive_threshold"},<br/>        {label: "Otsu's Threshold", key: "otasu_threshold"},<br/>    ],<br/>    render: {}<br/>}</span></pre><p id="f25c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe nl nm nn nd b">ImageOps.jsx</code>中，我们将为阈值过滤器添加一个新的网格。</p><pre class="kq kr ks kt gt nc nd ne nf aw ng bi"><span id="afef" class="md me it nd b gy nh ni l nj nk">&lt;Grid item xs={12}&gt;<br/>    &lt;Card&gt;<br/>        &lt;CardContent&gt;<br/>            &lt;Typography variant="h6" color="textPrimary" component="h6"&gt;<br/>                THRESHOLDING FILTERS<br/>            &lt;/Typography&gt;<br/>            &lt;ImageFilters image_data={this.state.image_data} type="threshold_effects" /&gt;<br/>        &lt;/CardContent&gt;<br/>    &lt;/Card&gt;<br/>&lt;/Grid&gt;</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi oi"><img src="../Images/ce1b1755bd4e86fb093f885133a50dca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YLs1e_JCj4ttu3Ujf3avvg.png"/></div></div></figure><h1 id="4d8c" class="nq me it bd mf nr ns nt mi nu nv nw ml nx ny nz mo oa ob oc mr od oe of mu og bi translated">查找轮廓:</h1><p id="e859" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">轮廓是在图像中遵循相同颜色或强度的形状上创建边界。我们将创建一个二进制阈值图像生成器，并尝试绘制轮廓(物体周围的边界)，然后在图像上绘制这些边界。它可用于各种过程计数。Ting object就是其中之一，还有更多。它有助于从一组多个对象中过滤出所需的对象。所以让我们检查一下它的能力。</p><p id="3a77" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在用户界面层面上，这与我们对阈值过滤器所做的相同，即首先在<code class="fe nl nm nn nd b">Imagefilter.jsx</code>中添加轮廓的状态</p><pre class="kq kr ks kt gt nc nd ne nf aw ng bi"><span id="bc52" class="md me it nd b gy nh ni l nj nk">this.state = {<br/>    smoothing_effects: [<br/>        {label: "Blur", key: "blur"},<br/>        {label: "Gaussian Blur", key: "gaussian_blur"},<br/>        {label: "Median Blur", key: "median_blur"},<br/>        {label: "Bilateral Filter", key: "median_filter"},<br/>    ],<br/>    threshold_effects: [<br/>        {label: "Simple Threshold", key: "simple_threshold"},<br/>        {label: "Adaptive Threshold", key: "adaptive_threshold"},<br/>        {label: "Otsu's Threshold", key: "otasu_threshold"},<br/>    ],<br/>    contour_effects: [<br/>        {label: "Find all contours", key: "find_all_contours"},<br/>        {label: "Find filtered contours", key: "find_filtered_contours"},<br/>    ],<br/>    render: {}<br/>}</span></pre><p id="86ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后在<code class="fe nl nm nn nd b">ImageOps.jsx</code>中添加网格</p><pre class="kq kr ks kt gt nc nd ne nf aw ng bi"><span id="f14e" class="md me it nd b gy nh ni l nj nk">&lt;Grid item xs={12}&gt;<br/>    &lt;Card&gt;<br/>        &lt;CardContent&gt;<br/>            &lt;Typography variant="h6" color="textPrimary" component="h6"&gt;<br/>                CONTOUR FILTERS<br/>            &lt;/Typography&gt;<br/>            &lt;ImageFilters image_data={this.state.image_data} type="contour_effects" /&gt;<br/>        &lt;/CardContent&gt;<br/>    &lt;/Card&gt;<br/>&lt;/Grid&gt;</span></pre><p id="c762" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是它看起来的样子</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi oj"><img src="../Images/5fd91ba166f4c5a4013298f143b529ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y1AnIXr7GNVd6Lu3K2eKDA.png"/></div></div></figure><p id="2486" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完整的用户界面，因为该项目将有如下初始外观</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ok"><img src="../Images/67769f3778df77d7725b33b1431e5133.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ljhZMY2MgDsQ9QxHVuKFnQ.png"/></div></div></figure><p id="54ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们已经为过滤器实现了整个UI。现在我们所需要的是应用过滤器的工作API端点，看看它的神奇之处。</p><p id="504c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于这篇文章太长，我们将在图像处理系列的第3部分中实现它。我们将在Node.js中加入OpenCV，最后看看一切是如何端到端工作的。所以，g <em class="le"> et yourself在https://overflowjs.com/<a class="ae ko" href="https://overflowjs.com/" rel="noopener ugc nofollow" target="_blank"/><em class="le">加入了我们2500多人的订阅家庭，请点击本文的分享按钮，与你的同事、朋友和其他人分享。</em></em></p><p id="5e17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您想加入我的电子邮件列表，请考虑在这里输入您的电子邮件地址 和<strong class="js iu">关注我的</strong><a class="ae ko" href="https://medium.com/@ideepak.jsd" rel="noopener"><strong class="js iu">medium</strong></a><strong class="js iu">阅读更多关于javascript和</strong><a class="ae ko" href="https://github.com/dg92" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">github</strong></a><strong class="js iu">的文章，查看我的疯狂代码</strong>。如果有什么不清楚或者你想指出什么，请在下面评论。</p><p id="5cc5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能也会喜欢我的其他文章</p><ol class=""><li id="1d26" class="li lj it js b jt ju jx jy kb lk kf ll kj lm kn ln lo lp lq bi translated"><a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/javascript-execution-context-and-hoisting-c2cc4993e37d"> Javascript执行上下文和提升</a></li><li id="ae72" class="li lj it js b jt lr jx ls kb lt kf lu kj lv kn ln lo lp lq bi translated"><a class="ae ko" href="https://medium.com/datadriveninvestor/javascript-generator-yield-next-async-await-8442d2c77185" rel="noopener"> Javascript —生成器-产出/下一个&amp;异步-等待🤔</a></li><li id="edcb" class="li lj it js b jt lr jx ls kb lt kf lu kj lv kn ln lo lp lq bi translated"><a class="ae ko" href="https://medium.com/datadriveninvestor/javascript-context-this-keyword-9a78a19d5786" rel="noopener">理解Javascript‘this’关键字(上下文)</a>。</li><li id="43be" class="li lj it js b jt lr jx ls kb lt kf lu kj lv kn ln lo lp lq bi translated"><a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/write-beautiful-javascript-with-λ-fp-es6-350cd64ab5bf">带有映射、归约、过滤的Javascript数据结构</a></li><li id="201e" class="li lj it js b jt lr jx ls kb lt kf lu kj lv kn ln lo lp lq bi translated"><a class="ae ko" href="https://medium.com/datadriveninvestor/javascript-currying-vs-partial-application-4db5b2442be8" rel="noopener"> Javascript- Currying VS部分应用</a></li><li id="7b8f" class="li lj it js b jt lr jx ls kb lt kf lu kj lv kn ln lo lp lq bi translated"><a class="ae ko" href="https://medium.com/datadriveninvestor/javascript-es6-iterables-and-iterators-de18b54f4d4" rel="noopener"> Javascript ES6 —可迭代程序和迭代器</a></li><li id="a8af" class="li lj it js b jt lr jx ls kb lt kf lu kj lv kn ln lo lp lq bi translated"><a class="ae ko" href="https://codeburst.io/write-beautiful-javascript-with-%CE%BB-fp-es6-350cd64ab5bf" rel="noopener" target="_blank"> Javascript性能测试—针对vs针对每个vs (map、reduce、filter、find)。</a></li><li id="18e5" class="li lj it js b jt lr jx ls kb lt kf lu kj lv kn ln lo lp lq bi translated"><a class="ae ko" href="https://medium.com/datadriveninvestor/why-to-use-javascript-proxy-5cdc69d943e3" rel="noopener"> Javascript —代理</a></li><li id="5443" class="li lj it js b jt lr jx ls kb lt kf lu kj lv kn ln lo lp lq bi translated"><a class="ae ko" href="https://medium.com/datadriveninvestor/still-confused-in-js-scopes-f7dae62c16ee" rel="noopener"> Javascript —作用域</a></li><li id="1c9f" class="li lj it js b jt lr jx ls kb lt kf lu kj lv kn ln lo lp lq bi translated"><a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/image-object-detection-with-tensorflow-js-b8861119ed46">用Tensorflow-js进行图像目标检测🤔</a></li><li id="8621" class="li lj it js b jt lr jx ls kb lt kf lu kj lv kn ln lo lp lq bi translated"><a class="ae ko" href="https://codeburst.io/fractal-a-nodejs-app-structure-for-infinite-scale-d74dda57ee11" rel="noopener" target="_blank"> Nodejs app结构——构建高可扩展性架构。</a></li><li id="60fb" class="li lj it js b jt lr jx ls kb lt kf lu kj lv kn ln lo lp lq bi translated"><a class="ae ko" href="https://codeburst.io/node-js-10-0-0-what-to-expect-as-a-backend-developer-security-enthusiast-f8680f132320" rel="noopener" target="_blank"> Node.js 10.0.0，作为后端开发者/安全爱好者有什么期待？</a></li><li id="05aa" class="li lj it js b jt lr jx ls kb lt kf lu kj lv kn ln lo lp lq bi translated"><a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/image-processing-making-custom-image-filters-react-js-part-2-ee2787f56b0d">图像处理——在React.js中制作自定义图像滤镜</a></li><li id="a05c" class="li lj it js b jt lr jx ls kb lt kf lu kj lv kn ln lo lp lq bi translated"><a class="ae ko" href="https://medium.com/@ideepak.jsd/google-india-phone-call-interview-question-software-developer-5a164e97ddeb" rel="noopener">谷歌印度面试问题</a></li></ol><p id="7131" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">查看<a class="ae ko" href="https://overflowjs.com/tags/angular/posts" rel="noopener ugc nofollow" target="_blank"> Angular </a>、<a class="ae ko" href="https://overflowjs.com/tags/nodejs/posts" rel="noopener ugc nofollow" target="_blank"> Node.js </a>、<a class="ae ko" href="https://overflowjs.com/tags/Vuejs/posts" rel="noopener ugc nofollow" target="_blank"> Vue.js </a>上的文章。</p><p id="1ba9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">谢谢大家！</p></div></div>    
</body>
</html>