<html>
<head>
<title>Background with rounded corners in UITextView</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">UITextView中带圆角的背景</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/background-with-rounded-corners-in-uitextview-1c095c708d14?source=collection_archive---------8-----------------------#2020-07-19">https://levelup.gitconnected.com/background-with-rounded-corners-in-uitextview-1c095c708d14?source=collection_archive---------8-----------------------#2020-07-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f96b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在制作<a class="ae kl" href="https://github.com/rajdeep/proton/" rel="noopener ugc nofollow" target="_blank">质子</a>的过程中，我有机会学到了很多东西。就像我喜欢分享我的代码一样，我也喜欢谈论挑战和胜利。这篇文章关注的是<a class="ae kl" href="https://github.com/rajdeep/proton/" rel="noopener ugc nofollow" target="_blank"> Proton </a>中的另一个特性，我相信这个特性在iOS中应该是现成的。如果你是新手，在深入细节之前，想了解更多关于<a class="ae kl" href="https://github.com/rajdeep/proton/" rel="noopener ugc nofollow" target="_blank"> Proton </a>，<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/building-a-native-editor-for-ios-968ff9bc6e0c">为iOS </a>构建一个原生编辑器是一个很好的起点。</p><h1 id="8ad5" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">带背景的文本</h1><p id="11a6" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们经常想在文本视图中给文本添加背景。最简单也可能是最好的方法是使用<a class="ae kl" href="https://developer.apple.com/documentation/foundation/nsattributedstring/key/1528791-backgroundcolor" rel="noopener ugc nofollow" target="_blank"> backgroundColor </a>属性。您可以为给定的范围提供任何<code class="fe lp lq lr ls b">UIColor</code>，iOS会负责在文本背景中呈现该颜色。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/e4d206d62c77d5e1a6d26faee415d829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*wOmbb7jAISGE0KQYl-Wxaw.png"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">用...发短信。背景颜色属性</figcaption></figure><p id="6c14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您需要的唯一代码是将属性<code class="fe lp lq lr ls b">backgroundColor: UIColor.cyan</code>添加到<code class="fe lp lq lr ls b">UITextView</code>的<code class="fe lp lq lr ls b">attributedText</code>属性中的<code class="fe lp lq lr ls b">NSAttributedString.Key</code>列表中。虽然这在大多数情况下是可行的，但可能感觉太普通了。你可能想要更花哨的格式，比如添加阴影或边框。至少，很可能你会想要圆角的背景。不幸的是，这些属性都不能通过使用属性来修改。</p><h1 id="10da" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">更好的背景</h1><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mf"><img src="../Images/b9be0a67245a5eae11eb64757de4fc29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*47_BkChF6mpSnqOSBGaRQQ.png"/></div></div></figure><p id="d932" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在使用<a class="ae kl" href="https://github.com/rajdeep/proton/" rel="noopener ugc nofollow" target="_blank"> Proton </a>时遵循的一个原则是提供我们作为开发人员可能想要定制的所有功能，同时保持这些定制的自然性。我的意思是，您可能想要做的所有定制，在理想情况下应该只不过是添加一个带有必需信息的属性。例如，如果您想在UITextView中添加列表，那么只需在文本范围中添加一个<code class="fe lp lq lr ls b">.listItem</code>属性即可。你可以在UITextView 的<a class="ae kl" href="https://medium.com/dev-genius/lists-in-uitextview-756fe2b1407a" rel="noopener">列表中阅读我的冒险经历。使用</a><a class="ae kl" href="https://github.com/rajdeep/proton/" rel="noopener ugc nofollow" target="_blank">质子</a>，您可以添加一个与<code class="fe lp lq lr ls b">backgroundColor</code>非常相似的属性，并实现以下功能:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/49a4e8581d0da484072199d1732c7bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*NCHl1YutjoDUXL9nDWchRA.png"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">圆角背景</figcaption></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/22c672f955917f75d6a24e177be4ce84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*FbJeyBPMuJstvHYPwX2kLA.png"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">带阴影的圆角</figcaption></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/308e5ae64a653ae5e5cf3c98a1c3d0ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*DnnsJY4s-TgOsL5NQYKDcA.png"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">仅带边框的背景</figcaption></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/af947897ac395d4d06522589370ead42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*J9C6d8UjvakfSkBhg2xJBQ.png"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">阴影、边框和圆角</figcaption></figure><p id="5d4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您需要添加的唯一代码是:</p><pre class="lu lv lw lx gt mk ls ml mm aw mn bi"><span id="eec9" class="mo kn iq ls b gy mp mq l mr ms">let style = BackgroundStyle(color: .green, cornerRadius: 5, <br/>border: BorderStyle(lineWidth: 1, color: UIColor.blue),  <br/>shadow: ShadowStyle(color: .gray, offset: CGSize(width: 2, height: 2), blur: 3))</span><span id="3bdc" class="mo kn iq ls b gy mt mq l mr ms">editor.addAttribute(.backgroundStyle, value: style, at: editor.selectedRange)</span></pre><p id="0b6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lp lq lr ls b">editor</code>是<code class="fe lp lq lr ls b">UITextView</code>的<a class="ae kl" href="https://github.com/rajdeep/proton/" rel="noopener ugc nofollow" target="_blank">质子</a>对应。除了其他特性，它还提供了简单的API来操作属性。</p><h1 id="04ab" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">在后台</h1><p id="195e" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">如果你想了解这是如何在质子中实现的，请继续阅读。</p><p id="02a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">文本的布局和绘制由<code class="fe lp lq lr ls b"><a class="ae kl" href="https://developer.apple.com/documentation/uikit/nslayoutmanager" rel="noopener ugc nofollow" target="_blank">NSLayoutManager</a></code>管理。它提供了两个可以被覆盖以实现所需行为的功能:</p><h2 id="ddf1" class="mo kn iq bd ko mu mv dn ks mw mx dp kw jy my mz la kc na nb le kg nc nd li ne bi translated">初始方法</h2><p id="23ca" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我尝试的第一种方法是使用<a class="ae kl" href="https://developer.apple.com/documentation/uikit/nslayoutmanager/1403161-fillbackgroundrectarray" rel="noopener ugc nofollow" target="_blank">fillbackgroundrectaray</a>。该函数为具有<code class="fe lp lq lr ls b">.backgroundColor</code>属性的范围绘制背景提供了更好的控制。这个函数被所有用背景色定义范围的矩形调用。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">带圆角的绘图背景</figcaption></figure><p id="80e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法是可行的，但是根据内容的添加方式，<a class="ae kl" href="https://developer.apple.com/documentation/uikit/nslayoutmanager/1403161-fillbackgroundrectarray" rel="noopener ugc nofollow" target="_blank">fillbackgroundrectaray</a>可能会被多次调用，甚至是针对同一行中的文本。这会导致基于单词而不是文本行渲染圆角:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/64f3bbaf673cc1e99e7daa8e3df17073.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*oHLmIPzjWJXm4fB_V-kg9g.png"/></div></figure><p id="c7d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果内容是粘贴的，而不是输入的，背景会像预期的那样绘制，每个单词没有可见的舍入，正如我们上面看到的。</p><h2 id="6a75" class="mo kn iq bd ko mu mv dn ks mw mx dp kw jy my mz la kc na nb le kg nc nd li ne bi translated">最后进场</h2><p id="2e01" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">花多一点时间在<code class="fe lp lq lr ls b">NSLayoutManager</code>上，我发现使用<code class="fe lp lq lr ls b"><a class="ae kl" href="https://developer.apple.com/documentation/uikit/nslayoutmanager/1402949-drawbackground" rel="noopener ugc nofollow" target="_blank">drawBackground</a></code>是一个更好的选择。使用与上面类似的代码，您可以获得更好的结果。</p><p id="5731" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kl" href="https://github.com/rajdeep/proton/" rel="noopener ugc nofollow" target="_blank">质子</a>中，我添加了额外的逻辑来根据每条重叠的线计算圆角，还使用了一个技巧来确保当有边界时，边界只画在有背景的矩形的外边缘。</p><p id="bd8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">包含所有选定范围的初始版本看起来如下，其中角在外边缘是圆形的，但第一个矩形的底线仍然导致它显示为两个独立的背景矩形。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/5049a6ffea82647db7ae2d75ed0aecfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*MdBaOVhMkT4iBVkGo8gwBg.png"/></div></figure><p id="b193" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用一些简单的逻辑，我能够计算出重叠线，如下图黄色所示:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/b41eddeb8a6c52570026d2b5b61e0c9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*3XLwGW6IqjxMdPtwWw5NAw.png"/></div></figure><p id="c625" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦识别出重叠的线条，剩下的唯一一件事就是为线条使用与背景相同的颜色，这样线条就消失了:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/b81c9bf5a57b90f609f2eda143847453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*qFu34eRcV_b70GzQStPa2g.png"/></div></figure><h2 id="0ee6" class="mo kn iq bd ko mu mv dn ks mw mx dp kw jy my mz la kc na nb le kg nc nd li ne bi translated">还有一点</h2><p id="6305" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">有了绘制圆角背景的所有计算，它还有助于动态绘制背景，根据应用了<code class="fe lp lq lr ls b">backgroundStyle</code>的文本范围合并和拆分背景:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/3a4b9e3bded15ec64b7b11f3b4498682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/1*pICxqEeQEYigWeojl8Ms7g.gif"/></div></figure><p id="6351" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望你喜欢阅读这篇文章，就像我喜欢在<a class="ae kl" href="https://github.com/rajdeep/proton/" rel="noopener ugc nofollow" target="_blank"> Proton </a>中开发这个特性一样。</p></div></div>    
</body>
</html>