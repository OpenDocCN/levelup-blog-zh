<html>
<head>
<title>Minikube Tips &amp; Tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Minikube提示和技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/minikube-tips-tricks-739f4b00ac17?source=collection_archive---------1-----------------------#2021-07-21">https://levelup.gitconnected.com/minikube-tips-tricks-739f4b00ac17?source=collection_archive---------1-----------------------#2021-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f097" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">minikube最佳实践和技巧的集合，用于改善运行本地Kubernetes集群的开发人员体验。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/999db54af9ad320a3836883a4da0ca8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fvd3rx71oIwBywHtQlEIBg.png"/></div></div></figure><p id="08fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Minikube是在macOS、Linux和Windows上运行本地Kubernetes集群的一个流行选项。虽然它拥有丰富的功能集和跨平台支持，但minikube的行为与全功能的Kubernetes集群略有不同，后者经常让开发人员和希望在本地测试其应用程序的Kubernetes新用户感到困惑。在本帖中，我们将介绍一些常见的陷阱和技巧，让你的开发团队更好地体验minikube。</p><p id="5a11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(<em class="la">注:有关Kubernetes的替代解决方案，请参见“</em><a class="ae lb" href="https://blog.devgenius.io/kubernetes-for-local-development-a6ac19f1d1b2" rel="noopener ugc nofollow" target="_blank"><em class="la">【Kubernetes for Local Development】</em></a><em class="la">”</em>)</p><h1 id="33d2" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">给Minikube更多的CPU和内存</h1><p id="0cbb" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">默认情况下，minikube启动时有2个CPU和2gb的内存，这对于测试一些微服务的较小团队来说可能足够了。然而，一旦minikube被用于运行与数据库(例如PostgreSQL、Redis)和消息队列(例如Kafka)的集成测试，minikube就会因为耗尽资源限制而崩溃。要避免这种情况，首先要为底层驱动程序(如VirtualBox、Docker等)提供更多资源:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mf"><img src="../Images/20765e2b8dd7711342dfaa2463016ecf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qNbljYWg34ef0envli-pog.png"/></div></div></figure><p id="9066" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后通过以下方式设置内存和cpu配置:</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="07c3" class="ml ld it mh b gy mm mn l mo mp">$ minikube config set memory 6144<br/>$ minikube config set cpus 4</span></pre><p id="17dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者在启动时通过命令行标志:</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="3d34" class="ml ld it mh b gy mm mn l mo mp">$ minikube start --memory 6144 --cpus 4</span></pre><p id="c91c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要最大限度地利用可用资源:</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="dc91" class="ml ld it mh b gy mm mn l mo mp">$ minikube start --memory=max --cpus=max</span></pre><h1 id="d786" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">设置Kubernetes版本</h1><p id="acb9" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">Minikube最多支持六个以前的Kubernetes次要版本。如果您的组织使用的是托管的Kubernetes服务(例如GKE、EKS、AKS)，那么在生产环境中运行的版本很可能不是Kubernetes minikube默认运行的最新版本。虽然这通常不是问题，但一些Kubernetes版本有突破性的变化(例如，<a class="ae lb" href="https://blog.devgenius.io/no-docker-isnt-dead-2b9ee45d5833" rel="noopener ugc nofollow" target="_blank"> 1.20用containerd </a>替换docker-shim)和弃用(例如，<a class="ae lb" href="https://blog.devgenius.io/upgrading-to-kubernetes-1-16-ad977933694d" rel="noopener ugc nofollow" target="_blank"> 1.16删除了</a> <code class="fe mq mr ms mh b"><a class="ae lb" href="https://blog.devgenius.io/upgrading-to-kubernetes-1-16-ad977933694d" rel="noopener ugc nofollow" target="_blank">extensions/v1beta1</a></code> <a class="ae lb" href="https://blog.devgenius.io/upgrading-to-kubernetes-1-16-ad977933694d" rel="noopener ugc nofollow" target="_blank">到稳定的API版本</a>)。您可以使用以下选项设置所需的Kubernetes版本:</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="8247" class="ml ld it mh b gy mm mn l mo mp">$ <!-- -->minikube start --kubernetes-version=v1.19.0</span></pre><p id="e5be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您需要测试运行不同版本的多个集群时，设置Kubernetes版本也很有用。结合使用<code class="fe mq mr ms mh b">--profile</code>标志来创建不同的集群:</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="8d9e" class="ml ld it mh b gy mm mn l mo mp">$ <!-- -->minikube start -p dev --kubernetes-version=v1.19.0<br/>$ <!-- -->minikube start -p stage --kubernetes-version=v1.18.0</span></pre><h1 id="2a5e" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">使用本地Docker图像</h1><p id="1fe7" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">除非您使用类似于<a class="ae lb" href="https://skaffold.dev/" rel="noopener ugc nofollow" target="_blank"> skaffold </a>的工作流自动化工具，否则您需要手动将容器图像推送到minikube以使用本地构建的工件。对于使用Docker容器运行时构建的集群(与cri-o或containerd相反)，让您的终端使用集群内Docker守护进程:</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="c607" class="ml ld it mh b gy mm mn l mo mp">$ eval $(minikube docker-env)</span></pre><p id="5740" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，所有Docker命令都将针对集群中的Docker守护进程运行:</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="b5f0" class="ml ld it mh b gy mm mn l mo mp">$ docker build -t my_awesome_image .</span></pre><p id="ccc9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦构建了映像，任何请求该映像的Kubernetes工作负载都可以使用它。但是，请确保将<code class="fe mq mr ms mh b">imagePullPolicy</code>设置为<code class="fe mq mr ms mh b">Never</code>，否则Kubernetes将试图从远程存储库中提取图像，从而导致失败。</p><p id="227d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要返回使用您的电脑自己的Docker守护程序，请打开一个新的终端窗口或运行:</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="2b3c" class="ml ld it mh b gy mm mn l mo mp">$ eval $(minikube docker-env -u)</span></pre><p id="ba19" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于其他运行时，请查看:</p><div class="mt mu gp gr mv mw"><a href="https://minikube.sigs.k8s.io/docs/handbook/pushing/" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">推送图像</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">比较将您的映像推入minikube集群的8种方式。术语表:拉意味着下载一个容器映像…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">minikube.sigs.k8s.io</p></div></div></div></a></div><h1 id="9c09" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">明智地使用Minikube插件</h1><p id="9b8d" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">Minikube维护了几个附加功能的扩展，默认情况下启用了<code class="fe mq mr ms mh b">default-storageclass</code>和<code class="fe mq mr ms mh b">storage-provisioner</code>:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nf"><img src="../Images/ed0dece0e06714a42fcde418e321f2b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ePvShvSe26oPY3JFy95zWQ.png"/></div></div></figure><p id="512a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要启用其他插件，请运行:</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="0b23" class="ml ld it mh b gy mm mn l mo mp">$ minikube addons enable &lt;name-of-addon&gt;</span></pre><p id="3f99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然这为开发人员提供了一种快速安装调试工具(如dashboard、efk、metrics-server)或网络工具(如ingress、istio)的简单方法，但我不建议启用这些工具，原因有二:</p><ol class=""><li id="dec1" class="ng nh it js b jt ju jx jy kb ni kf nj kj nk kn nl nm nn no bi translated">对于拥有资源受限机器的开发者来说，这些插件会蚕食可用资源。如果可能，使用替代解决方案为应用程序单元预留资源。例如，不是直接运行Kubernetes仪表板，而是与<a class="ae lb" href="https://k8slens.dev/" rel="noopener ugc nofollow" target="_blank"> Lens </a>或<a class="ae lb" href="https://k9scli.io/" rel="noopener ugc nofollow" target="_blank"> K9s </a>集成以满足仪表板需求。</li><li id="9a7f" class="ng nh it js b jt np jx nq kb nr kf ns kj nt kn nl nm nn no bi translated">为了保持在minikube和生产集群之间安装这些扩展服务的一致方式，请利用现有方法来安装它们(例如，用于nginx入口的Helm chart，而不是minikube的入口)。</li></ol><h1 id="356a" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">访问应用程序</h1><p id="0dad" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">虽然Kubernetes支持<code class="fe mq mr ms mh b">NodePort</code>和<code class="fe mq mr ms mh b">LoadBalancer</code>服务类型以将内部应用程序暴露给外部流量，但minikube如何实现这些取决于操作系统(例如macOS与Linux)和部署选项(例如Docker、VirtualBox、VMWare)。</p><p id="9262" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我看到的最常见的问题是macOS用户使用Docker驱动程序运行minikube。由于macOS 上没有<a class="ae lb" href="https://docs.docker.com/docker-for-mac/networking/#there-is-no-docker0-bridge-on-macos" rel="noopener ugc nofollow" target="_blank"> docker0桥，这使得主机无法访问容器IP。换句话说，当我通过NodePort公开一个Kubernetes服务时，我不能直接从我的终端点击<code class="fe mq mr ms mh b">$(minikube ip):&lt;port&gt;</code>。为了举例说明，让我们以来自</a><a class="ae lb" href="https://minikube.sigs.k8s.io/docs/start/" rel="noopener ugc nofollow" target="_blank"> minikube quickstart </a>的echoserver为例。在macOS上点击minikube端点会挂起，而在Linux上，它会返回预期的结果:</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="9b84" class="ml ld it mh b gy mm mn l mo mp"># Echo server example with nodeport 31652</span><span id="7cf6" class="ml ld it mh b gy nu mn l mo mp">$ kubectl create deployment hello-minikube --image=k8s.gcr.io/echoserver:1.4<br/>$ kubectl expose deployment hello-minikube --type=NodePort --port=8080</span><span id="c2ec" class="ml ld it mh b gy nu mn l mo mp"># on macOS this hangs<br/>$ curl $(minikube ip):31652</span><span id="e9af" class="ml ld it mh b gy nu mn l mo mp">curl: (7) Failed to connect to 192.168.49.2 port 31652: Network is unreachable</span><span id="3c7f" class="ml ld it mh b gy nu mn l mo mp"># on Linux, this returns<br/>$ curl $(minikube ip):31652</span><span id="acb7" class="ml ld it mh b gy nu mn l mo mp">CLIENT VALUES:<br/>client_address=172.17.0.1<br/>command=GET<br/>real path=/<br/>...</span></pre><p id="ff4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有三种方法可以访问服务的节点端口:</p><ol class=""><li id="8c19" class="ng nh it js b jt ju jx jy kb ni kf nj kj nk kn nl nm nn no bi translated">使用<code class="fe mq mr ms mh b">minikube service &lt;service-name&gt;</code>命令让minikube创建一个隧道并分配一个随机节点端口值:</li></ol><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nv"><img src="../Images/119bb043fdb122309b9bc888690f59ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fZQGwfhNOEspcAkWPGUGhA.png"/></div></div></figure><p id="8c90" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.使用<code class="fe mq mr ms mh b">port-forward</code>命令将服务映射到本地主机:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nw"><img src="../Images/8c797ee14dc93fb4bbf3056b18fd3d9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*29cpTRjB4kk1MWotPjZDGw.png"/></div></div></figure><p id="75f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.或者在启动minikube时预先暴露端口(或端口范围)</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="2f85" class="ml ld it mh b gy mm mn l mo mp">$ minikube start <!-- -->--extra-config=apiserver.service-node-port-range=32760-32767 --ports=127.0.0.1:32760-32767:32760-32767</span></pre><p id="9f06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于习惯于使用<code class="fe mq mr ms mh b">docker -p</code>命令或通过docker-compose文件设置端口的开发人员来说，最后一种方法可能感觉更自然。如果应用程序有几个预期的端口范围要导出(例如，PostgreSQL的端口范围是5432，Kafka的端口范围是9092)，那么只开放单个端口也可以满足需求。否则，使用port-forwarding命令不仅可以与minikube交互，还可以与远程集群交互。对于那些寻找一个完美的用户界面来管理这些的人来说，<a class="ae lb" href="https://kube-forwarder.pixelpoint.io/" rel="noopener ugc nofollow" target="_blank"> Kube Forwarder </a>是一个很好的解决方案。</p><p id="46b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于<code class="fe mq mr ms mh b">LoadBalancer</code>类型的服务，可以通过<code class="fe mq mr ms mh b">minikube tunnel</code>命令公开。它作为一个进程运行，并使用群集的IP地址作为网关在主机上创建一个网络路由。虽然这有助于公开单个服务，但最常见的用例是公开入口控制器(例如nginx、ambassador、traefik)并通过入口路由传入流量。修改<code class="fe mq mr ms mh b">/etc/hosts</code>文件以将<code class="fe mq mr ms mh b">minikube ip</code>映射到一个DNS名称也可以模拟命中外部DNS端点。</p><p id="4cfe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="la">(注意:还有一种方法可以通过设置</em> <code class="fe mq mr ms mh b"><em class="la">--listen-address=0.0.0.0</em></code> <em class="la">来配置minikube监听远程网络，即将minikube暴露给外界。虽然这对于测试来说很方便，但是考虑到安全隐患，请谨慎使用。)</em></p><h1 id="34f3" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">通过主机装载和文件同步进行热重装</h1><p id="8ff9" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">Minikube支持将主机目录挂载到VM中，类似于<code class="fe mq mr ms mh b">docker -v</code>命令。要装载目录，请运行:</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="b54b" class="ml ld it mh b gy mm mn l mo mp">$ minikube mount &lt;src dir on host&gt;:&lt;target dir on minikube&gt;</span></pre><p id="753e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可以被任何Kubernetes容器引用:</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="d4cf" class="ml ld it mh b gy mm mn l mo mp">volumeMount:<br/>- name: configs<br/>  mountPath: /usr/app/configs<br/>volumes:<br/>- name: configs<br/>  hostPath:<br/>    path: &lt;target-dir-from-minikube-mount&gt;</span></pre><p id="cbf9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这对于挂载各种配置或机密进行测试非常有用，而不必依赖重新加载机制来重新挂载pod上的值。</p><p id="7b85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要在启动时将文件同步到minikube，您也可以将文件放在<code class="fe mq mr ms mh b">$MINIKUBE_HOME/files</code>下。一个很好的用例是安装定制的DNS配置或SSL证书。</p><pre class="kp kq kr ks gt mg mh mi mj aw mk bi"><span id="4110" class="ml ld it mh b gy mm mn l mo mp">$ mkdir -p ~/.minikube/files/etc<br/>$ echo nameserver 8.8.8.8 &gt; ~/.minikube/files/etc/resolv.conf<br/>$ minikube start</span></pre></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h1 id="fe6c" class="lc ld it bd le lf oe lh li lj of ll lm ln og lp lq lr oh lt lu lv oi lx ly lz bi translated">最后的想法</h1><p id="894c" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">对于大多数从Docker到Kubernetes的开发人员来说，minikube为“简单地”测试他们的应用程序带来了一些复杂性和挑战。Minikube与迭代应用程序开发解决方案(如<a class="ae lb" href="https://draft.sh/" rel="noopener ugc nofollow" target="_blank"> Draft </a>、<a class="ae lb" href="https://github.com/okteto/okteto" rel="noopener ugc nofollow" target="_blank"> Okteto </a>和<a class="ae lb" href="https://github.com/GoogleContainerTools/skaffold" rel="noopener ugc nofollow" target="_blank"> Skaffold </a>)配合得最好，但即使没有这些工具，了解如何设置适当的资源、推送图像和从外部访问应用程序也有助于使本地Kubernetes体验更加无缝。</p></div></div>    
</body>
</html>