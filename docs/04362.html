<html>
<head>
<title>Tutorial: How to create a CLI tool in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">教程:如何在Golang中创建CLI工具</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/tutorial-how-to-create-a-cli-tool-in-golang-a0fd980264f?source=collection_archive---------3-----------------------#2020-06-23">https://levelup.gitconnected.com/tutorial-how-to-create-a-cli-tool-in-golang-a0fd980264f?source=collection_archive---------3-----------------------#2020-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/35790923dd15669f7ccdf5bb89394723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SSAlE3YgWEahm6hOX6KlQA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">壁纸洞穴<a class="ae kc" href="https://wallpapercave.com/w/wp4185680" rel="noopener ugc nofollow" target="_blank">链接</a></figcaption></figure><p id="cbe6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di">所以</span> 2020年，我决定是时候学习一门新的编程语言了。我喜欢Javascript——这一点可能永远不会改变。但与此同时，知道如何用更多的语言编写代码总是有好处的，原因有很多，比如成为一名更加全能的开发人员，能够使用更多样的工具。因为最终，这就是编程语言:我们用来构建软件的工具。</p><p id="30f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Golang是一种已经存在了一段时间(从2009年开始)的编程语言，但是直到最近几年我才开始听到很多关于它的东西。在过去的一年里，在我目前的工作中，我们已经开始使用它来构建一些微服务。作为一个好奇的人，我对这门语言的兴趣开始增长。所以我告诉自己，<em class="lk">“好吧！是时候学习一门新的语言了。我来了！”</em>(一语双关)。</p><p id="efac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我将描述我在学习过程中发现的一些事情。请记住，我不是这种语言的专家。但是，我仍然能够很快学会它的工作原理和使用方法。我也从Golang Reddit社区获得了一些好的建议，并且在web开发方面有超过9年的经验。所以不用担心，我又不是完全的初学者！</p><h1 id="e300" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">你将在本教程中学到什么</h1><p id="dd11" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">对于本教程，我们将构建一个<strong class="kf ir"> CSV到JSON </strong> CLI(命令行界面)工具。希望在阅读完这篇文章后，你会知道如何:</p><ul class=""><li id="c2d4" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">通过定义命令参数和标志来实现CLI</li><li id="e2d9" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">读取CSV文件</li><li id="bbf0" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">写文件</li><li id="2dfd" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">使用go程序和渠道</li><li id="5184" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">编写单元测试(因为测试很重要！)</li></ul><h1 id="06ba" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">你学不到的东西</h1><p id="ba86" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">要学习本教程，您不需要成为Golang专家，甚至不需要成为这种语言的中级开发人员。但是你需要知道基本的Golang语法是如何工作的。我们不会花时间学习如何声明变量、函数、结构、if语句、for语句等。<em class="lk"> </em>那是<em class="lk">太无聊了</em>，而且大概你已经知道做那些事了。如果你没有，我邀请你去参观:<a class="ae kc" href="https://gobyexample.com/" rel="noopener ugc nofollow" target="_blank">以身作则</a>。这个网站是我现在用来了解关于Golang的几乎所有信息的主要来源。那个网页上的例子非常容易理解，而且直截了当。</p><h1 id="076c" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="6fe4" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">因此，如果您是那种不喜欢为了学习某样东西而阅读冗长的文章的开发人员，并且您认为仅仅通过阅读一些源代码就能够理解任何东西，那么就去查看我的GitHub存储库中的全部教程代码吧:</p><div class="nc nd gp gr ne nf"><a href="https://github.com/Andrew4d3/go-csv2json" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">Andrew4d3/go-csv2json</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">这是一个将CSV文件转换成JSON文件的工具。它将把一个文件中的所有CSV行解析成一个JSON数组，然后…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">github.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt jw nf"/></div></div></a></div><p id="b3fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但至少在你走之前给我留下一个掌声；)</p><h1 id="4d80" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">定义我们的CSV到JSON应用程序</h1><p id="9a58" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">首先，让我们定义我们的CLI工具应该具有哪些功能和要求:</p><ul class=""><li id="0800" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">这个程序应该以CSV文件路径作为参数，并使用相同的数据生成一个JSON文件。</li><li id="f55b" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">JSON文件应该包含一个数组，其中每个数组元素代表输入CSV文件中的一行。</li><li id="4e1c" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">所有JSON数据都是字符串类型。</li><li id="5ca5" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">您将能够生成一个“格式良好”(缩进)的JSON文件。</li><li id="edaa" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">您将能够指出输入CSV文件是使用“逗号”还是“分号”作为列分隔符。</li><li id="02c0" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">这个程序必须有一个“帮助”选项，知道如何使用这个工具。</li></ul><p id="9d81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一般来说，此CLI工具应该具有以下签名:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="0aa1" class="od lm iq nz b gy oe of l og oh">Usage: ./csv2json [options] &lt;csvFile&gt;<br/>Options:<br/>  -pretty<br/>        Generate pretty JSON<br/>  -separator string<br/>        Column separator (default "comma")</span></pre><p id="7df3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们开始吧！</p><h1 id="ea00" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">获取输入的文件数据</h1><p id="90db" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">让我们创建我们的主go文件，名为:<code class="fe oi oj ok nz b">csv2json.go</code>。最初，它看起来像这样:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="7825" class="od lm iq nz b gy oe of l og oh">package main</span><span id="a1a6" class="od lm iq nz b gy ol of l og oh">func main() {<br/>}</span></pre><p id="1f8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这绝对是无所事事！因此，让我们通过添加一个<a class="ae kc" href="https://gobyexample.com/structs" rel="noopener ugc nofollow" target="_blank"> Go结构</a>来改变这种情况，该结构将存储我们需要的文件信息:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="e61c" class="od lm iq nz b gy oe of l og oh">type inputFile struct {<br/>   <strong class="nz ir">filepath</strong>  string<br/>   <strong class="nz ir">separator</strong> string<br/>   <strong class="nz ir">pretty</strong>    bool<br/>}</span></pre><p id="0d6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的文件结构称为<code class="fe oi oj ok nz b">inputFile</code>，我们将使用它来存储CSV文件路径、使用的分隔符(逗号或分号)以及生成的JSON文件是否格式良好(“pretty”值)。一般来说，这个结构负责存储用户输入的所有输入数据。</p><p id="db7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在是时候实现负责获取这些数据的函数了。我们将称它为<code class="fe oi oj ok nz b">getFileData</code>。事情是这样的:</p><figure class="nu nv nw nx gt jr"><div class="bz fp l di"><div class="om on l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我加入了一些解释我所做的事情的评论</figcaption></figure><p id="07ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的函数负责从终端获取所有输入数据，然后返回两个值:一个<code class="fe oi oj ok nz b">inputFile</code>实例和一个<code class="fe oi oj ok nz b">error</code>。我加入了一些详细解释一切的评论。简而言之，它是这样做的:</p><ul class=""><li id="7d79" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">验证参数的数量</li><li id="43a6" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">解析命令参数</li><li id="7c2e" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">验证我们是否收到了正确的“分隔符”参数。</li><li id="f0db" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">如果一切顺利，返回适当的<code class="fe oi oj ok nz b">inputFile</code>实例。</li></ul><p id="8651" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一件事要做。我们刚刚创建的函数有来自Go标准库的多个包。如果你在使用VSCode时安装了所有必要的Go插件，你会注意到所有这些包是如何自动导入的。但是如果没有，您将需要手动导入它们。像这样:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="a93f" class="od lm iq nz b gy oe of l og oh">import (<br/>   "errors"<br/>   "flag"<br/>   "os"<br/>)</span></pre><p id="bbec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了程序的第一个函数。但是我们怎么知道它是否有效呢？您可能认为我们可以通过从主函数调用它，然后在终端中输入:<code class="fe oi oj ok nz b">go run csv2json.go test.csv</code>来手动测试它。</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="7e0d" class="od lm iq nz b gy oe of l og oh">func main() {<br/>   fileData, err := getFileData()<br/>}</span></pre><p id="1c9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很方便，也很容易检查，但是本教程中我们想学的一件事就是编写<strong class="kf ir">单元测试</strong>。因此，让我们创建一个名为<code class="fe oi oj ok nz b">csv2json_test.go</code>的文件，我们将在其中编写以下代码:</p><figure class="nu nv nw nx gt jr"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="8a99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来我写了很多代码。但是我实际上使用了一个有用的VSCode特性，它允许我为特定的函数创建单元测试模板。为了使用它，首先，你需要安装所有必要的Golang插件。之后，你可以右击任何函数，然后点击“Go:Generate Unit Tests For Function”选项。您将看到如何为该函数创建一个好的样板测试代码。</p><figure class="nu nv nw nx gt jr gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/f0870c17cb7c7fa8b02c628f66eddd79.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*EFA_xmYgRxJKu8-H7bbQTw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">你必须点击第三个选项</figcaption></figure><p id="c720" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您在最后一段代码中看到的，我写了一些行内注释，详细解释了几乎所有内容。总而言之，这就是我们所做的:</p><ul class=""><li id="53f2" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">我们想要为这个功能定义不同的测试用例。这就是为什么我们要创建您在顶部看到的<code class="fe oi oj ok nz b">tests</code>切片。</li><li id="5af3" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">我们通过迭代这个<code class="fe oi oj ok nz b">tests</code>切片来运行每个测试用例</li><li id="d907" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">在每个测试中，我们的目的是模拟用户如何引入命令参数，这就是为什么我们需要使用<code class="fe oi oj ok nz b">os.Args</code>引用</li><li id="2e61" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">最后，我们执行所有必需的断言来验证我们是否得到了想要的结果</li></ul><p id="d353" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们如何运行这些测试呢？只需在终端中运行以下命令:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="defe" class="od lm iq nz b gy oe of l og oh">$ go test -v</span></pre><p id="c68c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你的测试被正确定义并且被测试的函数没有任何错误。您将看到如下输出:</p><figure class="nu nv nw nx gt jr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/9881d72a4f033dbc64a5a11b47e9903e.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*qI5lo07YKHps-ZK60nTeUA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">所有测试都通过了！</figcaption></figure><h1 id="eca1" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">验证CSV文件</h1><p id="364c" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">我们已经收集了文件数据，但是我们仍然不知道它是否是现有的CSV文件。为此，我们将创建一个名为<code class="fe oi oj ok nz b">checkIfValidFile</code>的新函数。这样的函数将接收输入的文件路径作为唯一的参数，并返回一个布尔值，表明该文件是否有效。</p><figure class="nu nv nw nx gt jr"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="cbb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见，这个函数比前一个函数更短，更容易理解。我们正在执行两项验证:</p><ul class=""><li id="fc2f" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">使用<code class="fe oi oj ok nz b">filepath.Ext</code>方法验证文件扩展名(CSV)</li><li id="b4f3" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">使用<code class="fe oi oj ok nz b">os.Stat</code>方法验证输入的文件路径是否属于现有文件</li></ul><p id="3192" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果一切都正确，我们返回<code class="fe oi oj ok nz b">true</code>，否则，我们返回带有相应错误的<code class="fe oi oj ok nz b">false</code>。请注意我们是如何使用标准库中名为<code class="fe oi oj ok nz b">filepath</code>的新包的。所以别忘了导入它:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="f883" class="od lm iq nz b gy oe of l og oh">import (<br/>   "errors"<br/>   "flag"<br/>   "os" <br/>   <strong class="nz ir">"path/filepath"</strong><br/>)</span></pre><p id="278a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们对刚刚编写的函数进行单元测试:</p><figure class="nu nv nw nx gt jr"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="228a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个测试函数和我们之前写的类似。我们正在定义一组测试用例，并对它们进行迭代。但是这次我们使用标准库中的<code class="fe oi oj ok nz b">ioutil</code>包创建一个临时文件。一旦所有测试完成，临时文件将被自动删除。</p><h1 id="5016" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">处理CSV文件</h1><p id="3784" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">现在是时候读取CSV文件了。为了做到这一点，我们将编写一个名为<code class="fe oi oj ok nz b">processCsvFile</code>的新函数。这个函数中的参数是:<code class="fe oi oj ok nz b">filedata</code>结构和一个“写者”通道。是的，没错…这次我们将使用Go频道。我们的函数是这样的:</p><figure class="nu nv nw nx gt jr"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="4793" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我知道在这个解决方案中没有必要使用<strong class="kf ir"> Go-channels </strong>和<strong class="kf ir"> Go-routines </strong>。然而，我想把它们包含在本教程中，因为它们是Go语言中强大的特性，我们应该学习如何使用。主要思想是我们将有两个独立的Go例程(线程):一个用于读取CSV文件，另一个用于编写JSON文件。</p><p id="1c8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">功能<code class="fe oi oj ok nz b">processCsvFile</code>是我们的第一个go-routine。它的职责是顺序读取CSV文件并逐一处理每一行。为此，我们使用了几个效用函数，我将在下面解释。</p><p id="2f53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个函数是<code class="fe oi oj ok nz b">exitGracefully</code>，用于在意外情况发生时终止程序:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="a701" class="od lm iq nz b gy oe of l og oh">func exitGracefully(err error) {<br/>   fmt.Fprintf(os.Stderr, "error: %v\n", err)<br/>   os.Exit(1)<br/>}</span></pre><p id="709c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个功能是<code class="fe oi oj ok nz b">check</code>，用来检查错误。如果发现错误，该功能还会重复使用<code class="fe oi oj ok nz b">exitGracefully</code>功能。</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="4d40" class="od lm iq nz b gy oe of l og oh">func check(e error) {<br/>   if e != nil {<br/>      <strong class="nz ir">exitGracefully</strong>(e)<br/>   }<br/>}</span></pre><p id="3527" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一个函数——可能也是最复杂的一个——是<code class="fe oi oj ok nz b">processLine</code>函数。它将获取<code class="fe oi oj ok nz b">headers</code>和<code class="fe oi oj ok nz b">line</code>切片，并从中创建一个字符串映射。</p><figure class="nu nv nw nx gt jr"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="5848" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们知道了我们的内部函数是如何工作的，让我们更详细地解释一下我们的主<code class="fe oi oj ok nz b">processCsvFile</code>函数是做什么的:</p><ul class=""><li id="de4b" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">首先，我们将使用相应的“分隔符”选项实例化一个CSV阅读器。</li><li id="71cb" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">然后，我们将读取第一行，将CSV文件头放入一个字符串片段。</li><li id="522a" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">现在，我们将遍历每一行来获取列值。</li><li id="3adc" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">由于标题和列值在不同的片段中，我们可以使用<code class="fe oi oj ok nz b">processLine</code>函数从它们中构建一个字符串映射</li><li id="8daa" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">一旦我们有了生成的字符串映射——或<code class="fe oi oj ok nz b">recordMap</code>——我们就可以把它推送到我们的<code class="fe oi oj ok nz b">writerChannel</code>。</li></ul><p id="7c7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您的编辑器还没有为您完成，不要忘记包含我们还没有导入的包:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="9043" class="od lm iq nz b gy oe of l og oh">import (<br/>   "errors"<br/>   "flag"<br/>   "os" <br/>   "path/filepath"<br/>   <strong class="nz ir">"fmt"<br/>   "encoding/csv"<br/>   "io"<br/></strong>)</span></pre><p id="bc7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个函数的单元测试如下所示:</p><figure class="nu nv nw nx gt jr"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="8e5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您所看到的，我们的每个测试用例都会生成一个带有一些可测试内容的临时CSV文件。我们使用关键字<code class="fe oi oj ok nz b">go</code>调用目标函数，以表明这个函数实际上是一个go-routine，它将在与主函数不同的线程中执行。最后，我们迭代包含期望值的切片。该循环中的每一步都将从写入通道中获取一条记录，并做出相应的测试断言。</p><h1 id="39c6" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">编写最终的JSON文件</h1><p id="b600" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">还有一个主要功能。我们准备把它叫做<code class="fe oi oj ok nz b">writeJSONFile</code>，正如它的名字所说，它的目的是编写最终的JSON文件。为此，我们将使用我们从过去的<code class="fe oi oj ok nz b">processCsvFile</code>函数推入编写器通道的数据。事情是这样的:</p><figure class="nu nv nw nx gt jr"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="2ea5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你所看到的，这个函数也使用了一些实用函数(<code class="fe oi oj ok nz b">createStringWriter</code>和<code class="fe oi oj ok nz b">getJSONFunc</code>)。让我们检查他们做什么。</p><p id="5d86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe oi oj ok nz b">createStringWriter</code>函数负责实例化一个JSON文件编写器。事情是这样的:</p><figure class="nu nv nw nx gt jr"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="fe57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，这个函数依赖于“函数闭包”，这是一个常见的语言特性，您可以在Javascript等其他语言中找到。总而言之，这就是我们正在做的事情:</p><ul class=""><li id="a3e6" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">定义JSON文件的位置和名称，这将是与输入的CSV文件相同的文件位置和名称，但是带有一个<code class="fe oi oj ok nz b">.json</code>扩展名，而不是<code class="fe oi oj ok nz b">.csv</code>扩展名。</li><li id="f9fe" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">使用我们已经构建的位置打开文件。</li><li id="f2f9" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">返回将作为JSON文件编写器的函数。该函数将接受任何数据字符串，并将其写入JSON文件。如果没有更多的数据需要写入，我们就关闭文件。</li></ul><p id="8831" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们来写<code class="fe oi oj ok nz b">getJSONFunc</code>。这个函数也返回另一个函数和一个字符串值。它的职责是确保我们以正确的格式生成JSON数据。所有这些都是通过返回适当的JSON解析器函数和“换行符”来完成的。</p><figure class="nu nv nw nx gt jr"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="a0fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您可能注意到的，我们依赖于标准库中的<code class="fe oi oj ok nz b">json</code>包。具体来说，我们使用了<code class="fe oi oj ok nz b">Marshal</code>和<code class="fe oi oj ok nz b">MarshalIndent</code>方法。第一个是<code class="fe oi oj ok nz b">pretty</code>选项激活时，第二个是未激活时。我们还定义了在编写新对象时是否应该换行。</p><p id="236b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们知道了这两个效用函数是如何工作的，是时候解释一下<code class="fe oi oj ok nz b">writeJSONFile</code>函数是做什么的了。简单总结一下:</p><ul class=""><li id="19d7" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">在初始化和实例化我们的实用函数之后，我们编写JSON文件的第一个字符。因为我们正在生成一个对象数组，所以我们需要先打开方括号。</li><li id="d986" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">现在是时候迭代由写入者通道接收的记录了。我们通过使用for-loop语句来实现这一点。在每次迭代中，我们总是检查通道上是否有更多的记录。如果有更多，我们使用两个闭包函数。一个用于构建JSON数据，另一个用于将数据写入JSON文件。</li><li id="0245" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">如果没有更多的记录要处理，我们关闭括号(和JSON文件)并向<code class="fe oi oj ok nz b">done</code>通道发送一个信号，指示所有工作都已完成。我们也打破了for循环。</li></ul><p id="1c8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像往常一样，不要忘记导入所使用的包:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="7c8c" class="od lm iq nz b gy oe of l og oh">import (<br/>   "errors"<br/>   "flag"<br/>   "os" <br/>   "path/filepath"<br/>   "fmt"<br/>   "encoding/csv"<br/>   "io"<br/>   <strong class="nz ir">"strings"<br/>   "encoding/json"</strong><br/>)</span></pre><p id="43e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了对这个函数进行单元测试，我们需要做一些额外的工作，创建两个JSON文件，我们将用它们来比较函数结果。因此，让我们创建一个包含以下文件的<code class="fe oi oj ok nz b">testJsonFiles</code>文件夹:</p><p id="9337" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">包含以下内容的<code class="fe oi oj ok nz b">compact.json</code>文件(只有一行):</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="1546" class="od lm iq nz b gy oe of l og oh">[{"COL1":"1","COL2":"2","COL3":"3"},{"COL1":"4","COL2":"5","COL3":"6"}]</span></pre><p id="3092" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和一个包含以下内容的<code class="fe oi oj ok nz b">pretty.json</code>文件:</p><figure class="nu nv nw nx gt jr"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="5098" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，这两个文件有相同的数据，但格式不同。现在让我们编写相应的单元测试。</p><figure class="nu nv nw nx gt jr"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="f32a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之，我们想要的是将我们测试的函数生成的JSON文件内容与我们手动创建的JSON文件进行比较。您可以看到每个测试用例是如何与<code class="fe oi oj ok nz b">testJsonFile</code>文件夹中的文件相匹配的。</p><h1 id="f4e6" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">把所有的放在一起</h1><p id="e802" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">至此，我们已经实现了执行预期任务所需的所有功能。然而，我们仍然需要定义这些功能如何协同工作。所以让我们完成<code class="fe oi oj ok nz b">main</code>函数的编写:</p><figure class="nu nv nw nx gt jr"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="1e06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能已经注意到了一件事，那就是我们是如何给<code class="fe oi oj ok nz b">flag.Usage</code>属性分配一个匿名函数的。这样做的目的是向我们的程序表明，当用户在终端中输入<code class="fe oi oj ok nz b">--help</code>选项时，我们想要执行什么功能。</p><p id="bf06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时，代码的其余部分对您来说应该很熟悉了。首先，我们获取并验证所有输入数据，最后，我们调用分别用于读取和写入CSV和JSON文件的函数(或go-routines)。注意这两个函数是如何使用<code class="fe oi oj ok nz b">go</code>关键字调用的，这意味着它们将使用不同的线程同时运行。</p><p id="7aa5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们的CLI工具完成了。如果你觉得你错过了什么，检查整个代码<a class="ae kc" href="https://github.com/Andrew4d3/go-csv2json/blob/master/csv2json.go" rel="noopener ugc nofollow" target="_blank">这里</a>。为了进行最终测试，我们需要一个真实的CSV文件。如果你手头没有，你可以在<a class="ae kc" href="https://support.spatialkey.com/spatialkey-sample-csv-data/" rel="noopener ugc nofollow" target="_blank">这个网站</a>上找到一些包含样本数据的CSV文件。一旦您选择了一个工具，就可以通过在终端中输入以下命令来测试我们最近创建的工具:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="173d" class="od lm iq nz b gy oe of l og oh">$ go run csv2json &lt;CSV File path&gt;</span></pre><p id="5646" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">按“Enter”键，您应该会在终端中看到类似这样的内容:</p><figure class="nu nv nw nx gt jr gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/457a662d9d8009bf202a59924f540358.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*imdd2OcJrAV7CoG9uPCviQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在我的例子中，CSV文件位于项目的根目录下</figcaption></figure><p id="5a79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着一切进展顺利。转到并导航到CSV文件所在的位置。现在您应该会看到一个同名的JSON文件。它应该是这样的:</p><figure class="nu nv nw nx gt jr gh gi paragraph-image"><div class="gh gi or"><img src="../Images/d8a2056d5f98ca22ec62698fb4a5356c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*4QYE96gYqUh7glCsfmhBVQ.png"/></div></figure><p id="e48f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们没有启用任何“漂亮”选项。所以所有生成的JSON都在一行中，这是默认行为。让我们运行相同的命令，但现在启用“漂亮”选项:</p><figure class="nu nv nw nx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi os"><img src="../Images/f8665ecaa21068697b016ba28fcc9983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Zrf3Yn4DTkSKzcwM2UQ9g.png"/></div></div></figure><p id="62f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们得到了一个缩进的JSON文件。</p><figure class="nu nv nw nx gt jr gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/a0e59a28ce41f38b509bdf1f442f07f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*9KzZ1Z9WiOFIBq0Pcs3H_g.png"/></div></figure><p id="1850" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您愿意，您可以找到一个使用分号而不是逗号的CSV并测试它。它应该没有任何问题。</p><p id="e009" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们以构建程序二进制文件来结束:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="3853" class="od lm iq nz b gy oe of l og oh">$ go build csv2json.go</span></pre><p id="ff0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在您有了一个可以发布和分发的可执行文件。让我们用这个文件测试一下<code class="fe oi oj ok nz b">help</code>选项。我们应该看到我们在<code class="fe oi oj ok nz b">flag.Usage</code>函数中打印的数据:</p><figure class="nu nv nw nx gt jr gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/ecb9bdecf90ea20dbe5dfcc333652353.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*ZNp25EjHbKpZQOXirSiwLQ.png"/></div></figure><p id="8926" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">恭喜你！您已经使用Go成功创建了一个CLI工具。非常感谢你阅读我的教程。我希望你已经学到了一两件关于这门语言的新东西。<em class="lk">下次见！</em></p><p id="fbae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lk">快乐编码！</em></p></div></div>    
</body>
</html>