<html>
<head>
<title>AWS Lambda asynchronous invocations with destinations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有目的地的AWS Lambda异步调用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/aws-lambda-asynchronous-invocations-with-destinations-5a2d47082fe9?source=collection_archive---------7-----------------------#2021-07-25">https://levelup.gitconnected.com/aws-lambda-asynchronous-invocations-with-destinations-5a2d47082fe9?source=collection_archive---------7-----------------------#2021-07-25</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="4540" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">一种在代码中分离业务逻辑的技术。</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/c7a7ce829fa70d1047f8f090adc04d07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0UydUYVypDZwMYbb"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">Ludemeula Fernandes 在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="965b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Lambda函数一次只能做一件事。从长远来看，混合业务逻辑从来都不是好事:测试和可维护性可能会成为一种痛苦。</p><p id="3684" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">将业务逻辑分成多个Lambda函数的一种方法是使用AWS提供的许多<a class="ae kz" href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventsourcemapping.html" rel="noopener ugc nofollow" target="_blank">事件源</a>来启动Lambda函数调用。</p><p id="74c9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">💁<em class="lw">我之前用AWS和Terraform写过一点</em> <a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/event-driven-architecture-for-dummies-222c7b930e5f"> <em class="lw">事件驱动架构简介</em> </a> <em class="lw">。</em></p><p id="d284" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当AWS Lambda被异步调用时，它有一个很好的特性:将目的地附加到Lambda调用中。Lambda函数完成执行后，会将响应发送到已配置的目的地。这些目的地可以是SNS、SQS、事件桥或另一个Lambda函数。该配置可以有失败和成功执行的目的地。</p><h1 id="8fef" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">我如何设置它？</h1><p id="67c6" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">如果您正在使用Terraform，则很容易添加:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="a25c" class="mz ly iu mv b gz na nb l nc nd">resource "aws_lambda_function" "test" {<br/>  filename         = "test.zip"<br/>  function_name    = "test"<br/>  role             = aws_iam_role.test.arn<br/>  handler          = "test.handler"<br/>  source_code_hash = filebase64sha256("test.zip")<br/>  runtime          = "nodejs14.x"<br/>}</span><span id="4aa2" class="mz ly iu mv b gz ne nb l nc nd">resource "aws_lambda_function_event_invoke_config" "test" {<br/>  function_name = <!-- -->aws_lambda_function<!-- -->.test.function_name<br/><br/>  destination_config {<br/>    on_failure {<br/>      destination = aws_sqs_queue.test.arn<br/>    }<br/><br/>    on_success {<br/>      destination = aws_sns_topic.test.arn<br/>    }<br/>  }<br/>}</span></pre><p id="af9a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在上面的代码中，我们告诉Lambda函数，如果执行失败，就将执行响应发送到SQS队列，如果成功，就发送到SNS主题。</p><p id="d446" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这对于记录失败的执行和调试我们的代码或者分离业务逻辑非常有用。</p><p id="2e42" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">需要记住的一点是<strong class="lc iv">添加权限给λ函数</strong> <a class="ae kz" href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-intro-execution-role.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv">执行角色</strong> </a>视目的地而定:</p><ul class=""><li id="7e67" class="nf ng iu lc b ld le lg lh lj nh ln ni lr nj lv nk nl nm nn bi translated"><strong class="lc iv">SQS—</strong><a class="ae kz" href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_SendMessage.html" rel="noopener ugc nofollow" target="_blank">SQS:SendMessage</a></li><li id="e728" class="nf ng iu lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><strong class="lc iv">SNS—</strong><a class="ae kz" href="https://docs.aws.amazon.com/sns/latest/api/API_Publish.html" rel="noopener ugc nofollow" target="_blank">SNS:Publis</a>h</li><li id="a6f4" class="nf ng iu lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><strong class="lc iv">λ</strong>—<a class="ae kz" href="https://docs.aws.amazon.com/lambda/latest/dg/API_Invoke.html" rel="noopener ugc nofollow" target="_blank">λ:invoke function</a></li><li id="e778" class="nf ng iu lc b ld no lg np lj nq ln nr lr ns lv nk nl nm nn bi translated"><strong class="lc iv">事件桥</strong> — <a class="ae kz" href="https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEvents.html" rel="noopener ugc nofollow" target="_blank">事件:PutEvents </a></li></ul><h1 id="aa71" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">有什么例子？</h1><p id="db9a" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">使用Javascript的Lambda函数，我们将编写如何向SNS主题(或SQS/Lambda/EventBridge)发送成功的响应。</p><p id="7880" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">💁<em class="lw">为什么不处决那些失败者？我们的Lambda函数已经通过在响应中发送完整的错误消息和执行细节为我们处理了这个问题。</em></p><p id="ea1c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">假设我们正在AWS上构建一个转录服务。我们使用AWS转录来为我们做转录。这个过程是异步的，所以我们需要听取来自AWS转录的更新。为此，我们需要使用<a class="ae kz" href="https://docs.aws.amazon.com/transcribe/latest/dg/cloud-watch-events.html" rel="noopener ugc nofollow" target="_blank"> CloudWatch事件</a>。</p><p id="6891" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">转录作业完成后，我们希望将作业的状态和输出保存到DB (1)。我们还想给自己发送一封电子邮件通知，告诉我们工作已经完成(2)。</p><h1 id="4264" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">我该如何编码？</h1><p id="8d22" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">Terraform中监听AWS转录更新的基本设置可能如下所示:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="b455" class="mz ly iu mv b gz na nb l nc nd">resource "aws_lambda_function" "job" {<br/>  filename         = "job.zip"<br/>  function_name    = "job"<br/>  role             = aws_iam_role.job.arn<br/>  handler          = "job.handler"<br/>  source_code_hash = filebase64sha256("job.zip")<br/>  runtime          = "nodejs14.x"<br/>}</span><span id="c5fb" class="mz ly iu mv b gz ne nb l nc nd">resource "aws_cloudwatch_event_rule" "job_status" {<br/>  name          = "job-status"<br/>  description   = "Transcription job status change"<br/>  event_pattern = &lt;&lt;EOF<br/>{<br/>  "source": [<br/>    "aws.transcribe"<br/>  ],<br/>  "detail-type": [<br/>    "Transcribe Job State Change"<br/>  ],<br/>  "detail": {<br/>    "TranscriptionJobStatus": [<br/>      "COMPLETED",<br/>      "FAILED"<br/>    ]<br/>  }<br/>}<br/>EOF<br/>}</span><span id="e18b" class="mz ly iu mv b gz ne nb l nc nd">resource "aws_lambda_permission" "allow_cloudwatch" {<br/>  statement_id  = "AllowExecutionFromCloudWatchEventRule"<br/>  action        = "lambda:InvokeFunction"<br/>  function_name = aws_lambda_function.<!-- -->job<!-- -->.function_name<br/>  principal     = "events.amazonaws.com"<br/>  source_arn    = aws_cloudwatch_event_rule.job_status.arn<br/>}</span><span id="5239" class="mz ly iu mv b gz ne nb l nc nd">resource "aws_cloudwatch_event_target" "target" {<br/>  target_id = "AllowExecutionFromCloudWatchEventRule"<br/>  rule      = aws_cloudwatch_event_rule.job_status.name<br/>  arn       = aws_lambda_function.job.arn<br/>}</span></pre><p id="35b6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们的Lambda函数监听来自AWS的更新，并相应地采取行动，例如，将输出保存到数据库中。Lambda函数的执行结束(1)，那么我们如何通知自己转录工作已经完成？</p><p id="1e6a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因为Lambda函数一次只能做一件事，所以添加发送电子邮件通知的功能是没有意义的(2)。因此，让我们像这样在Lambda函数中使用目的地的强大功能:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="d341" class="mz ly iu mv b gz na nb l nc nd">resource "aws_sns_topic" "job_email" {<br/>  name = "job_email"<br/>}</span><span id="4b2b" class="mz ly iu mv b gz ne nb l nc nd">resource "aws_lambda_function" "job_email" {<br/>  filename         = "job_email.zip"<br/>  function_name    = "job_email"<br/>  role             = aws_iam_role.job_email.arn<br/>  handler          = "job_email.handler"<br/>  source_code_hash = filebase64sha256("job_email.zip")<br/>  runtime          = "nodejs14.x"<br/>}</span><span id="50cc" class="mz ly iu mv b gz ne nb l nc nd">resource "aws_lambda_permission" "allow_sns" {<br/>  statement_id  = "AllowExecutionFromSns"<br/>  action        = "lambda:InvokeFunction"<br/>  function_name = aws_lambda_function.<!-- -->job_email<!-- -->.function_name<br/>  principal     = "sns.amazonaws.com"<br/>  source_arn    = aws_sns_topic.job_email.arn<br/>}</span><span id="855f" class="mz ly iu mv b gz ne nb l nc nd">resource "aws_sns_topic_subscription" "subscription" {<br/>  topic_arn = aws_sns_topic.job_email.arn<br/>  protocol = "lambda"<br/>  endpoint = aws_lambda_function.<!-- -->job_email<!-- -->.arn<br/>}</span><span id="a382" class="mz ly iu mv b gz ne nb l nc nd">resource "aws_lambda_function_event_invoke_config" "job" {<br/>  function_name = <!-- -->aws_lambda_function<!-- -->.job.function_name<br/><br/>  destination_config {<br/>    on_failure {<br/>      destination = aws_sqs_queue.job.arn<br/>    }<br/><br/>    on_success {<br/>      destination = aws_sns_topic.job_email.arn<br/>    }<br/>  }<br/>}</span></pre><p id="a7f5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们创建一个SNS主题和一个Lambda函数。Lambda函数订阅了SNS主题，因此当SNS主题被我们的成功目标配置调用时，它会自动执行我们的Lambda函数。</p><p id="3ad8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">剩下唯一要做的就是正确设置我们想要发送给SNS topic / Lambda函数的响应。</p><p id="6056" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们的第一个Lambda函数(1)从CloudWatch事件获取更新，因此代码可能如下所示:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="5f9c" class="mz ly iu mv b gz na nb l nc nd">export const handler = async (event, context) =&gt; {<br/>  try {<br/>    const status = event.detail.TranscriptionJobStatus<br/>    // Do business logic, get output from job and save to DB<br/>    return { text: `Job finish with status ${status}` }<br/>  } catch(err) {<br/>    throw err<br/>  }<br/>}</span></pre><p id="b530" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果执行成功，我们的Lambda函数会自动将我们在return语句中定义的响应发送到SNS主题。你可以定义任何你想要的东西。当SNS主题执行我们的第二个Lambda函数(2)时，有效负载将是前一个Lambda函数的响应:</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="9c67" class="mz ly iu mv b gz na nb l nc nd">export const handler = async (event, context) =&gt; {<br/>  try {<br/>    const { text } = JSON.parse(event.Records[0].Sns.Message)<br/>    // Send email with SES and use text as body<br/>    return { statusCode: 200 }<br/>  } catch(err) {<br/>    throw err<br/>  }<br/>}</span></pre><p id="0f3a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">代码实现可以是您想要的任何东西，在本例中是发送电子邮件通知。</p><p id="1f10" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们现在已经将业务逻辑分成两个Lambda函数，这使得我们的测试和可维护性更容易，因为每个Lambda函数只做一件事🎉</p><div class="nt nu gq gs nv nw"><a href="https://blog.jagonzalr.com/membership" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fp"><div class="ny ab nz cl cj oa"><h2 class="bd iv gz z fq ob fs ft oc fv fx it bi translated">加入我的介绍链接媒体-何塞安东尼奥冈萨雷斯罗德里格斯</h2><div class="od l"><h3 class="bd b gz z fq ob fs ft oc fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oe l"><p class="bd b dl z fq ob fs ft oc fv fx dk translated">blog.jagonzalr.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok kt nw"/></div></div></a></div></div></div>    
</body>
</html>