<html>
<head>
<title>Implement Event Sourcing With MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用MongoDB实现事件源</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implement-event-sourcing-with-mongodb-1fbf2cc0d155?source=collection_archive---------0-----------------------#2021-08-18">https://levelup.gitconnected.com/implement-event-sourcing-with-mongodb-1fbf2cc0d155?source=collection_archive---------0-----------------------#2021-08-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="31fa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在不影响应用程序代码库的情况下启用事件源模式</h2></div><p id="d6eb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">事件源方法是一种基于微服务构建新架构的新兴模式。这种方法的优点不胜枚举，但我将尝试分享其中最重要的:</p><ul class=""><li id="392f" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated">解耦系统</li><li id="d338" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">实时更改(这意味着我不必等待移动数据的计划作业)</li><li id="89d3" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">责任分离</li></ul><p id="08a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">自从我们转向微服务以来，这种方法得到了非常广泛的使用，我们需要一些方法来通知所有架构部分数据的变化。</p><p id="b687" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将深入了解什么是事件源，以及如何使用MESS实现它，MESS是一个直接连接到<a class="ls lt ep" href="https://medium.com/u/db5cd12199bd?source=post_page-----1fbf2cc0d155--------------------------------" rel="noopener" target="_blank"> MongoDB </a>并对数据更改做出反应的简单工具。这种方法与传统RDBMS上的触发器非常相似，但是是异步的，并且工作负载在系统之外，所以不会有任何数据库过载。</p><p id="4490" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，让我们跳转到文章！</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lu"><img src="../Images/2c6f188946fdcf194f6a283bf6a2669b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q3C_5QCRWEQg7oHI"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">照片由<a class="ae mk" href="https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"/>在<a class="ae mk" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="be15" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">什么是事件采购？</h1><p id="e7cd" class="pw-post-body-paragraph ki kj it kk b kl nk ju kn ko nl jx kq kr nm kt ku kv nn kx ky kz no lb lc ld im bi translated">事件源是一种让我们自动更新数据和发布事件的模式。保存数据或在系统间共享数据的传统方法是基于移动整个信息。想想ETL流或常规API。事件采购使用基于事件的不同方法。每次主数据更改信息时，都会向事件存储发送一个事件。通过访问事件存储，体系结构的每个组件都能够重建实际的信息。事件存储不仅是一个事件数据库，也是一个消息代理，因此每个组件(订阅者)都可以在新事件生成时得到通知。下图显示了该模式的工作原理。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi np"><img src="../Images/21d4f7e5077a424e4dc5bfd362c71161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tg38LM-50UVvl2aI0aKN7Q.png"/></div></div></figure><p id="ed3f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看如何轻松实现事件搜索！</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="c380" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">什么是MESS (MongoDB事件源)？</h1><p id="594f" class="pw-post-body-paragraph ki kj it kk b kl nk ju kn ko nl jx kq kr nm kt ku kv nn kx ky kz no lb lc ld im bi translated">MESS是一个开源工具，它从MongoDB实现事件源监听事件。对于那些习惯玩传统RDMS的人来说，它有点像触发器，但是在数据库之外触发事件。这个应用程序使用内置的MongoDB特性ChangeStream。</p><p id="245a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，通过在您的架构中添加MESS，您可以使用webhook将数据更改事件转发到应用程序，或者简单地将事件添加到像R <a class="ae mk" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> abbitMQ </a>或<a class="ae mk" href="https://www.confluent.io/what-is-apache-kafka/" rel="noopener ugc nofollow" target="_blank"> Kafka </a>这样的队列中。</p><p id="0215" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">换句话说，MESS是一个无需对应用程序代码库做任何更改就能实现事件源的工具。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="8343" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">动手代码！</h1><p id="2232" class="pw-post-body-paragraph ki kj it kk b kl nk ju kn ko nl jx kq kr nm kt ku kv nn kx ky kz no lb lc ld im bi translated">阅读官方文档，有许多启动它的选项。最舒服的是基于docker的。在本文中，我们将使用它，并将我们的设置基于docker-compose文件。通过用Kubernetes配置翻译docker-compose文件，这个例子可以很容易地移植到Kubernetes集群。</p><p id="cf1e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，创建你的<code class="fe nq nr ns nt b">docker-compose.yml</code>文件。您可以使用下面的代码，其中您必须用您实际的数据库配置替换<code class="fe nq nr ns nt b">&lt;connection string&gt;</code>。</p><pre class="lv lw lx ly gt nu nt nv nw aw nx bi"><span id="0c38" class="ny mt it nt b gy nz oa l ob oc">version: "2"<br/>services:<br/>  node:<br/><br/>    image: zeppaman/mongo-event-sourcing<br/>    #these settings overrides the .env file<br/>    environment:<br/>      - NODE_ENV=production<br/>      - PORT=5000<br/>      - MONGODB_URL=&lt;connection string&gt;<br/>   volumes:<br/>     - ./config/:/usr/src/app/config/<br/>    expose:<br/>      - "8081"</span></pre><p id="fbf9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一步是通过在路径<code class="fe nq nr ns nt b">.config/config.js</code>中创建一个文件来配置它。该文件配置列出哪些数据库和集合。在我们的例子中，我们将通过输入下面的配置列出一个名为<code class="fe nq nr ns nt b">test-db</code>的数据库以及其中的所有集合:</p><pre class="lv lw lx ly gt nu nt nv nw aw nx bi"><span id="1b36" class="ny mt it nt b gy nz oa l ob oc">{<br/>  databases:{<br/>    "test-db":{<br/>    }<br/>}}</span></pre><p id="129b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您只从一个集合中监听变更，您只需在那个<code class="fe nq nr ns nt b">test-db</code>节点中添加名字，正如官方文档中解释的那样。</p><p id="7fe7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了测试这个工具，我们可以使用<a class="ae mk" href="https://requestbin.com/" rel="noopener ugc nofollow" target="_blank"> RequestBin </a>这个工具可以公开端点并跟踪你发出的所有HTTP请求。为此，只需导航到网址“<a class="ae mk" href="https://requestbin.com/" rel="noopener ugc nofollow" target="_blank">https://requestbin.com/</a>”并点击“<strong class="kk iu">创建一个公共垃圾箱。</strong>”。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi od"><img src="../Images/aade29a883e9517682d924ab7f3719c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kfzVfw1qK1Gv90KVtGiE-A.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">创建新的媒体夹</figcaption></figure><p id="3816" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该选项将创建一个不需要身份验证的公共HTTP端点。进入下一个窗口，您将看到可以用作请求目的地的URL。您应该会看到类似下图的内容。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/40dfd76aefb161ceaa0fb3f8ac30bcfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*AecGYpoTC_HL2lQhkzQILg.png"/></div></figure><p id="1c43" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一步是定义监听管道。事实上，我们可以连接许多操作数据的动作，并将其发送到正确的目的地。作为目的地，我们可以使用HTTP调用(webhook)或队列。在这个例子中，我将使用webhook和log来跟踪数据。配置如下:</p><pre class="lv lw lx ly gt nu nt nv nw aw nx bi"><span id="1b9a" class="ny mt it nt b gy nz oa l ob oc">pipeline: [{<br/>            name:"log"<br/>        },<br/>        {<br/>            name:"http",<br/>            config: <br/>            {<br/>                "endpoint":"https://&lt;myid&gt;.x.pipedream.net"<br/>            }<br/>        }],</span></pre><p id="c9b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在配置已经完成，我们可以启动应用程序了。在您的终端中键入<code class="fe nq nr ns nt b">docker-compose up</code>,您会看到MESS正在监听端口3000。</p><p id="6729" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只需进入MongoDB并编辑一些数据。在下图中，您可以看到数据编辑器</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi of"><img src="../Images/055d5004e846229ee5249465319a951a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*DoV3-sPrllmOidZnFb-Csw.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">MongoDB上的数据条目</figcaption></figure><p id="a21b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">保存后，事件已经侦听，您可以通过日志看到处理过程，如下图所示。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi og"><img src="../Images/da157ae0bccbc56c630bf5c08a7a1153.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*j_5jhGoiYKAP8hMpYC2U_g.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">记录在控制台中的数据</figcaption></figure><p id="5081" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为最后一步，您可以根据请求检查操作的结果。你会发现类似下图的东西。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi oh"><img src="../Images/181398a3a343aa65023dbe90cba34dff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1tggBi28bEUyCyDd_iPnLg.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">请求框捕获的数据</figcaption></figure><p id="a828" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，您可以用任何其他web服务替换假的RequestBin URL，这样就设置好了。如果您想要将数据转发到许多系统，您只需在管道中输入更多条目。</p><h1 id="635c" class="ms mt it bd mu mv oi mx my mz oj nb nc jz ok ka ne kc ol kd ng kf om kg ni nj bi translated">外卖</h1><p id="b8a2" class="pw-post-body-paragraph ki kj it kk b kl nk ju kn ko nl jx kq kr nm kt ku kv nn kx ky kz no lb lc ld im bi translated">事件源对于微服务和复杂架构来说是一个非常有用的模式。可以有很多实现，但是可以考虑通过添加MESS来实现。如果您想在不修改架构中现有应用程序的情况下启用这种方法，这种解决方案是不错的。此外，可以对MESS进行配置，以定制数据交付的每个部分(也可以通过映射字段或创建定制适配器)，这样您就能够满足未来的任何请求。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="75c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">喜欢这篇文章吗？成为 <a class="ae mk" href="https://daniele-fontani.medium.com/membership" rel="noopener"> <em class="on">中等会员</em> </a> <em class="on">继续无限制学习。如果你使用下面的链接，我会收到你的一部分会员费，不需要你额外付费。</em></p><h2 id="c8de" class="ny mt it bd mu oo op dn my oq or dp nc kr os ot ne kv ou ov ng kz ow ox ni oy bi translated">参考</h2><ul class=""><li id="c7a5" class="le lf it kk b kl nk ko nl kr oz kv pa kz pb ld lj lk ll lm bi translated"><a class="ae mk" href="https://github.com/zeppaman/mongo-event-sourcing" rel="noopener ugc nofollow" target="_blank">GitHub项目</a></li><li id="f416" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae mk" href="https://www.npmjs.com/package/mongo-event-sourcing" rel="noopener ugc nofollow" target="_blank">NPM套餐</a></li><li id="5647" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae mk" href="https://hub.docker.com/r/zeppaman/mongo-event-sourcing" rel="noopener ugc nofollow" target="_blank">Docker图像</a></li></ul></div></div>    
</body>
</html>