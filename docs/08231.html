<html>
<head>
<title>Flattening in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿中的扁平化</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/flattening-in-typescript-515d7bc0fe15?source=collection_archive---------6-----------------------#2021-04-13">https://levelup.gitconnected.com/flattening-in-typescript-515d7bc0fe15?source=collection_archive---------6-----------------------#2021-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5cde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TypeScript的类型系统使得使用递归和嵌套类型成为可能。在某些情况下，软件开发人员可以用嵌套值来简化类型，以获得简单性；例如，将二维数组展平为一维数组时。本文概述了与扁平化相关的<em class="kl">范畴理论</em>的相关部分，并展示了示例性实现。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/4d33125637527a3d49816b5e00df7a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XK5x0UxqT2tCaQlj"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">由<a class="ae lc" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> CHUTTERSNAP </a>在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="dd9a" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">范畴理论</h1><p id="60eb" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">范畴理论提出了一个单子的构造，单子是一个值容器，充当操纵适用值的代理。在函数式编程中，单子充当用于在计算管道中保存值的基本结构。最流行的(根据我目前的经验)包括<code class="fe mg mh mi mj b">Option</code>、<code class="fe mg mh mi mj b">Either</code>、<code class="fe mg mh mi mj b">Task</code>、<code class="fe mg mh mi mj b">Array</code>、<code class="fe mg mh mi mj b">Set</code>和<code class="fe mg mh mi mj b">Map</code>单子。</p><p id="45fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">传统上，单子需要两个函数才能存在:</p><ul class=""><li id="fe4a" class="mk ml iq jp b jq jr ju jv jy mm kc mn kg mo kk mp mq mr ms bi translated">一个单子构造函数(称为<code class="fe mg mh mi mj b">of</code>或<code class="fe mg mh mi mj b">wrap</code>)，它接受单个参数并产生一个包含传递值的单子，</li><li id="eade" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated">一个一元组合子(称为<code class="fe mg mh mi mj b">bind</code>、<code class="fe mg mh mi mj b">chain</code>或<code class="fe mg mh mi mj b">flatMap</code>)，一个一元作为第一个参数，另一个一元构造函数(具有非平凡逻辑)作为第二个参数；组合子将一元值传递给前面提到的构造函数，并返回新创建的一元值。</li></ul><p id="5899" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在TypeScript中，人们可以将<code class="fe mg mh mi mj b">ReadonlyArray&lt;T&gt;</code>视为一个单子，因为它包含一个值集合并公开以下方法:</p><ul class=""><li id="16bf" class="mk ml iq jp b jq jr ju jv jy mm kc mn kg mo kk mp mq mr ms bi translated"><code class="fe mg mh mi mj b">Array.prototype.of</code>、<code class="fe mg mh mi mj b">Array.prototype.from</code>、<code class="fe mg mh mi mj b">Array.prototype.constructor</code>，在某些情况下，可以分别作为一元构造函数，</li><li id="778a" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated"><code class="fe mg mh mi mj b">Array.prototype.flatMap</code>，充当一元组合子。</li></ul><p id="a792" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一元组合子的存在间接暗示了一元的一元(<em class="kl">嵌套一元</em>)的行为就像<em class="kl">简单一元</em>。在一元世界中，开发人员应该将数组中的数组视为一维数组，除非另有说明。大多数专业人士都知道"<em class="kl">将嵌套结构简化为简化的对应结构</em>"称为<em class="kl">扁平化</em>，本文将深入解释如何高效地编写扁平化代码。</p><h1 id="21c5" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">打字稿中的单子</h1><p id="7655" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">TypeScript的类型系统允许开发人员轻松创建一元类型。这种类型必须包含一个(或多个)值，最好还包含一个区分类型的属性，以区别于其他单子。我在下面提供了一个<code class="fe mg mh mi mj b">Option&lt;T&gt;</code>单子的基本实现:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="ded3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我选择了<code class="fe mg mh mi mj b">type</code>作为<code class="fe mg mh mi mj b">Option</code>类型的鉴别器属性；它可以接受<code class="fe mg mh mi mj b">someOptionSymbol</code>或<code class="fe mg mh mi mj b">noneOptionSymbol</code>作为值。我更喜欢一个符号而不是一个属性值，而是一个属性本身(因为它在迭代对象属性时有优先处理权)，但是从TypeScript 4.2开始，有区别的联合仍然不能处理符号键属性。符号的使用减少了来自不受<code class="fe mg mh mi mj b">Option</code>机制管理的代码的可能的结构注入。</p><h1 id="2000" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">链接</h1><p id="11a7" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">软件开发人员可能会在管道中使用一元组合符(<em class="kl">链接</em>)来在嵌套一元出现问题之前绕过它们。如果应用的顺序正确，组合子应该将嵌套限制在第一级复杂度(简单单子)，而不是允许创建嵌套单子。在某种程度上，人们可以把这样一个函数看作是<em class="kl">映射和展平</em>的组合，因此有些人把它命名为<code class="fe mg mh mi mj b">flatMap</code>。</p><p id="4509" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">名为<code class="fe mg mh mi mj b">chainOption</code>的一元组合器使用<em class="kl">部分应用程序设计模式</em>。非平凡的单子构造函数<code class="fe mg mh mi mj b">ctor</code>作为第一个部分应用的参数，<code class="fe mg mh mi mj b">option</code>单子作为第二个。最终，功能的实现归结为3行有效代码，如下所示:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="8b65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我提供了一个如何在实践中使用<code class="fe mg mh mi mj b">chainOption</code>的例子。<code class="fe mg mh mi mj b">multiplyByTen</code>函数是一个部分应用的<code class="fe mg mh mi mj b">chainOption</code>实例，它提供了数字单子内的映射操作(我建议读者检查一下给出的签名)。下面的代码片段展示了如何应用<code class="fe mg mh mi mj b">multiplyByTen</code>两次来产生一个简单的数字单子:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="5ecc" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">嵌套展平</h1><p id="8620" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">人们可以通过提取一个单子的值，将一个单子(或者换句话说，二级嵌套单子)转换成一个简单单子。基本展平的实现在很大程度上取决于所讨论的单子类型。我为<code class="fe mg mh mi mj b">Option&lt;T&gt;</code>单子创建了一个例子，如下所示:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="58bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以根据需要在管道中多次应用基本展平，以实现所需的嵌套级别。下面的例子展示了如何将一个<code class="fe mg mh mi mj b">nestedOption</code>(第三层嵌套单子)展平为一个简单单子。这种解决方案适用于低级嵌套单子，因为增加几层扁平化不会让开发人员筋疲力尽。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="b3ce" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">显式展平</h1><p id="06ae" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">数组对象的原型包含一个有趣的方法，叫做<code class="fe mg mh mi mj b">flat</code>。它的用户可以定义应用于所讨论的数组的扁平化深度，从而减少单次调用的最终扁平化调用的数量。我非常仔细地阅读了该方法的类型定义，这启发我想出一种方法将它们移植到一元世界中。</p><p id="e100" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想从创建一个描述任何级别的嵌套单子的类型开始。下面可用的<code class="fe mg mh mi mj b">NestedOption&lt;T, L extends number&gt;</code> ( <em class="kl"> L </em> like level)的示例性实现利用了对于<code class="fe mg mh mi mj b">L &gt; 1</code> a <code class="fe mg mh mi mj b">NestedOption&lt;T, L&gt;</code>等于<code class="fe mg mh mi mj b">Option&lt;NestedOption&lt;T, L-1&gt;&gt;</code>的定律。我建议读者做一个思维实验，看看TypeScript编译器如何将<code class="fe mg mh mi mj b">NestedOption&lt;string, 5&gt;</code>解析成最终类型。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="cd2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">定义了<code class="fe mg mh mi mj b">NestedOption</code>类型后，我终于可以引入<code class="fe mg mh mi mj b">flattenNestedOption</code>，如下图所示。不幸的是，由于类型的复杂性和TypeScript的限制，我需要使用<code class="fe mg mh mi mj b">@ts-ignore</code>来隐藏类型差异。如果读者找到了解决这个问题的方法，请在评论区写下评论。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="16fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用<code class="fe mg mh mi mj b">flattenNestedOption</code>函数可以归结为计算嵌套的级别，并使用嵌套的单子调用函数，如下例所示。拥有一个在运行时计算嵌套级别的函数将是最大的改进。我将让读者来思考如何恰当地实现这样的挑战。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="aaa0" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">摘要</h1><p id="f570" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">范畴理论引入了单子的概念，允许开发者抽象出一些值的操作。在某些情况下，递归和嵌套类型可能遵循一元的定义，因此开发人员在处理这类类型时可以利用一元法则。由上述法则管理的扁平化是将数学概念应用到软件开发中的一个典型例子。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="9863" class="ld le iq bd lf lg nh li lj lk ni lm ln lo nj lq lr ls nk lu lv lw nl ly lz ma bi translated">分级编码</h1><p id="9227" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">感谢您成为我们社区的一员！<a class="ae lc" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank">订阅我们的YouTube频道</a>或者加入<a class="ae lc" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> Skilled.dev编码面试课程</strong> </a>。</p><div class="nm nn gp gr no np"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">编写面试问题+获得开发工作</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">掌握编码面试的过程</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">技术开发</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od kw np"/></div></div></a></div></div></div>    
</body>
</html>