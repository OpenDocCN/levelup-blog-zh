<html>
<head>
<title>How to Improve Java Backend Performance — Writing code that just runs is not enough!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何提高Java后端性能——仅仅编写运行的代码是不够的！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-improve-java-backend-performance-writing-code-that-just-runs-is-not-enough-d5c29392f62c?source=collection_archive---------2-----------------------#2021-07-22">https://levelup.gitconnected.com/how-to-improve-java-backend-performance-writing-code-that-just-runs-is-not-enough-d5c29392f62c?source=collection_archive---------2-----------------------#2021-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3d37" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">查找常见后端瓶颈和解决方案的演练。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b5d88819713824c87268b7a9b5bbd3ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XS9T7h4Y22IzeQYodwjbzA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://www.freepik.com/starline" rel="noopener ugc nofollow" target="_blank">女星</a>在<a class="ae ky" href="https://www.freepik.com/free-vector/rocket-launch-cloud-sky-background_13514235.htm#page=1&amp;query=rocket&amp;position=17" rel="noopener ugc nofollow" target="_blank"> Freepick </a>上拍照</figcaption></figure><p id="c219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个故事中，我将讨论Java应用程序的性能调优方法。在您构建应用程序之后，由于各种原因，性能可能与您预期的不同。有时你可能找不到它们，即使你在投入生产之前做了负载测试。</p><p id="c6ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我要讨论的主要话题是:</p><ul class=""><li id="60d9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">寻找瓶颈</li><li id="69cd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">要应用的常见调整</li><li id="efc7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">JDBC相关的代码更改和调整</li><li id="7a66" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">JVM调优</li></ul><p id="e63b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我必须说，这些是你可以做的一些常见的调整，这完全取决于你的业务逻辑。有些优化对您的用例来说可能是不必要的。好吧，我们开始吧。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0d21" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">寻找性能瓶颈</h1><p id="80d4" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">要微调后端，首先，您需要找到应用程序中的瓶颈。在这种情况下，您可以盲目地跟随直觉，或者使用分析器来更好地了解您的应用程序。</p><h2 id="58e6" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">使用Java分析器</h2><p id="ca0e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果你打算使用一个分析器，<a class="ae ky" href="https://www.ej-technologies.com/products/jprofiler/overview.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> JProfiler </strong> </a> <strong class="lb iu">或者</strong><a class="ae ky" href="https://github.com/javamelody/javamelody/wiki" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">Java melody</strong></a>是一些你可以使用的很棒的工具。在<a class="ae ky" href="https://dzone.com/articles/top-9-free-java-process-monitoring-tools-amp-how-t" rel="noopener ugc nofollow" target="_blank"> DZone </a>中找到更多关于免费java评测器的信息。特别是JProfiler将提供详细的意见时，分析数据库与JDBC连接，JPA，以及NoSQL。因为大多数时候瓶颈发生在数据库层。</p><h2 id="86c9" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">使用Java堆转储分析器</h2><p id="bd79" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这是第二个选项，可以通过分析JVM堆区域来发现后端中的瓶颈。该工具专门用于在生产中发现在测试阶段无法发现的内存问题。</p><p id="f5dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.eclipse.org/mat/" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">【Eclipse内存分析器(MAT) </strong> </a>是你可以使用的最简单的工具之一。<a class="ae ky" href="https://docs.oracle.com/javase/7/docs/technotes/tools/share/jhat.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> jhat </strong> </a>和<a class="ae ky" href="https://visualvm.github.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">jvvisualvm</strong></a><strong class="lb iu"/>是一些替代方案。使用MAT，更容易有效地分析包含数百万个对象的堆转储，并了解谁在阻止垃圾收集器收集对象。它还提供运行报告来自动提取泄漏嫌疑。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/0c4f803d2bf5d10e1879b69613230188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c-tR4UTnpmq_z49yIrUhgg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Eclipse内存分析器-图片来自<a class="ae ky" href="https://www.eclipse.org/mat/about/overview.png" rel="noopener ugc nofollow" target="_blank">eclipse.org</a></figcaption></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2a64" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">您可以进行的常见调整</h1><p id="3bea" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">可以在代码级、JVM级和数据库级进行调整。我必须再说一遍，这些完全取决于您的业务需求，解决最大的瓶颈会更容易更快地完成工作。</p><h1 id="35b7" class="mq mr it bd ms mt oa mv mw mx ob mz na jz oc ka nc kc od kd ne kf oe kg ng nh bi translated">代码级别的注意事项</h1><blockquote class="of og oh"><p id="7a30" class="kz la oi lb b lc ld ju le lf lg jx lh oj lj lk ll ok ln lo lp ol lr ls lt lu im bi translated">前面提到的DZone性能监控调查将代码级问题列为应用程序性能问题的首要原因。大多数代码级别的问题是由于代码构造中的错误造成的，比如长时间等待、糟糕的迭代、低效的代码算法、糟糕的数据结构选择等等。<br/>——<a class="ae ky" href="https://www.eginnovations.com/blog/top-10-java-performance-problems/#Java-Code" rel="noopener ugc nofollow" target="_blank">eginnovations.com</a></p></blockquote><h2 id="8507" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">使用字符串生成器而不是字符串串联</h2><p id="2a9a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这适用于需要重复修改字符串的情况。如果你只修改一次，几乎是一样的。如你所知，字符串对象是不可变的。所以如果你修改了一个字符串，它实际上不会被修改。实际情况是它将创建一个新的字符串，与创建新的字符串对象相关的开销可能会很大。如果这种情况重复发生，就需要一次又一次地分配新的内存，这不是一个好的做法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="b0c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有像<code class="fe oo op oq or b">String s = "a" + "b" + "c"</code>这样的单行语句，你可以使用串联，因为编译器会自动使用<code class="fe oo op oq or b">StringBuilder</code>。</p><h2 id="2573" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">尽可能使用原语和堆栈</h2><p id="434e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">java堆空间和Java堆栈内存是JVM中两种主要的内存类型。堆栈内存遵循“后进先出”(LIFO)的内存分配原则，是最快的内存分配和内存访问方式。与堆相比，栈的内存较少，您可以使用<code class="fe oo op oq or b">-Xss</code> JVM选项来增加栈的大小。堆栈内存存储对象的基本类型和地址。所以如果你使用原语，你会自动使用堆栈内存，它有更快的内存访问。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/8c486484786a3d03361a7c722d9e63c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PECJvd7oCb3wtyt1VwZg_Q.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">堆和栈的关系</figcaption></figure><h2 id="7d28" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">额外的精确性——真的需要吗？</h2><p id="d70d" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">不要使用<code class="fe oo op oq or b">BigInteger</code>或<code class="fe oo op oq or b">BigDecimal</code>，除非你的数字超出了<code class="fe oo op oq or b">long</code>或<code class="fe oo op oq or b">double</code>的范围。这些类型需要更多的内存空间，并且会显著降低计算速度。</p><h2 id="0b0c" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">“finalize”不应用于将字段设置为“null”</h2><p id="4b82" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">没有必要使用finalize将字段设置为null。垃圾收集器会在需要时自动移除它们。这样做实际上可能会给垃圾收集器带来额外的工作，而且对象的寿命可能会更长一些。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="7243" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">如果可能，使用流对象</h2><p id="ace2" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Java流对象比读/写对象性能更好，因为它们不必处理字符串到字节的转换。例如，<code class="fe oo op oq or b">PrintWriter</code>可以替换为<code class="fe oo op oq or b">OutputStream</code>。</p><h2 id="2a12" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">打破大的请求</h2><p id="59aa" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">当请求较大且需要大量时间处理时，这是后端常见的滥用。您可以通过减少冗余请求并将大量请求分解成较小的请求来消除它。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6877" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">进入JDBC和数据库层</h1><p id="40e1" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">通常，最大的瓶颈在JDBC和数据库层之间。连接池和语句池可用于重用现有的连接/准备好的语句，消除启动新连接和解析SQL的成本。</p><h2 id="399d" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">连接池</h2><p id="e5ab" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">创建JDBC连接需要大量资源，尤其是在中间层服务器环境中使用JDBC API时，比如在支持Java的web服务器上使用JDBC的DataDirect Connect或JDBC的DataDirect SequeLink。因此，实现连接池可以在需要时创建新连接之前节省时间。连接池模块将被创建为任何标准JDBC驱动程序产品之上的一个层。当连接被释放时，池中的其他客户机可以使用它。</p><p id="65b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Apache Commons DBCP、HikariCP是一些可以用于连接池的JDBC框架。</p><h2 id="ba25" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">语句池</h2><p id="fe66" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">与连接池一样，语句池也可以节省大量事务时间。<code class="fe oo op oq or b">OraclePreparedStatement</code>和<code class="fe oo op oq or b">OracleCallableStatement</code>可以缓存在语句池中，JDBC驱动程序会自动在缓存中搜索匹配的语句并重用它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/a2958e6ad6e515f249d2cb37cbabd43c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D_G6GYxStH2HcYG408sBog.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">JDBC统筹</figcaption></figure><h2 id="5c8f" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">使用Infinispan/Redis等数据存储</h2><p id="0a62" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">有很多内存中的开源缓存接口可以与Java一起工作。其主要目标是为频繁访问的数据提供快速的内存缓存。<strong class="lb iu"> Ehcache，Hazelcast，Memcached，AWS的ElastiCacheare还有其他一些你可以选择的缓存选项。根据需要，它们可以作为嵌入式或分布式使用。</strong></p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="455d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">JVM调优</h1><p id="b0cc" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在进入垃圾收集之前，我将简要介绍一下java内存模型。Java运行时内存分为五个部分。<strong class="lb iu">堆区、方法区、JVM栈、本地方法栈、PC寄存器</strong>就是它们。在这个故事中，我将主要讨论堆区域，因为它对应用程序的性能有直接影响。这一部分可能比其他部分长，因为我希望涵盖Java内存管理和垃圾收集的一些概念。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/8497ede70a2aa454aa0191c0dc99dc8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A1EixgbIiil1BI2zIiwcVQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">JVM堆内存</figcaption></figure><p id="4260" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java堆是Java程序的对象所在的地方。如果你得到一个类似<code class="fe oo op oq or b"><strong class="lb iu">java.lang.OutOfMemoryError</strong></code>的错误，那是因为堆内存已满。它是活对象、死对象和空闲内存的存储库。堆区分为<strong class="lb iu">年轻代和老代，</strong>这是垃圾收集器(GC)的工作区。</p><p id="a2d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">年轻一代是保存新创建对象的区域。它被进一步分成<strong class="lb iu"> EdenSpace和两个幸存者空间</strong>。这两个叫做<strong class="lb iu"> FromSpace(S0)和ToSpace(S1)。</strong>对象的生命周期从初始内存分配开始于Eden空间。一旦Eden空间被填满，就执行GC。该迭代将删除所有死对象并将活对象移动到S0。接下来，将在Eden中创建新对象，并再次执行GC，死对象将被删除，活对象将被移到S1。所以这是一个重复的任务，JVM会一直空出一个幸存者空间。这个过程被称为<strong class="lb iu">小GC。</strong>次要垃圾收集将持续一定次数，这些对象将被移至老代空间。这种情况称为<strong class="lb iu">促销</strong>。该阈值称为<strong class="lb iu">任期年龄</strong>，可以使用<strong class="lb iu"> </strong> <code class="fe oo op oq or b">MaxTenuringThreshold</code>参数进行更改。老一代的GC被称为<strong class="lb iu">主要GC </strong>，影响应用性能。(老一代中的对象是长寿的，与年轻一代中的GC相比，GC花费的时间更长。)</p><p id="a8d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个内存空间是永久生成(PermGen)。这包含JVM描述应用程序中使用的类和方法所需的元数据，如常量池(内存池)、字段和方法数据以及代码。从Java 8开始，PermGen被Metaspace取代，在Metaspace中，内存可以自动调整大小，默认情况下无限制。</p><p id="1c5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的垃圾收集都是“停止世界”事件。当GC发生时，应用程序中的所有线程都将停止。对于日志，可以通过指定<code class="fe oo op oq or b"><strong class="lb iu">-XX</strong>:+PrintGC <strong class="lb iu">-XX</strong>:+PrintGCDetails <strong class="lb iu">-XX</strong>:+PrintGCTimeStamps <strong class="lb iu">-Xloggc</strong>:&lt;<strong class="lb iu">filename</strong>&gt;</code>来启用GC日志。</p><h2 id="03d9" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">JVM性能目标</h2><p id="ed39" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在开始调优JVM性能之前，您可以考虑三个目标。这些目标必须根据您的业务需求来选择。</p><ul class=""><li id="d505" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">延迟</strong> — <strong class="lb iu">运行GC事件所需的</strong>时间量。</li><li id="1b7e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">吞吐量</strong> —虚拟机执行应用所花费的时间与执行垃圾收集所花费的时间的百分比。</li><li id="e4ab" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">内存量</strong> —垃圾收集器平稳运行所需的内存量。</li></ul><h2 id="ab3e" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated"><strong class="ak"> JVM调优原则</strong></h2><p id="72e9" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">JVM调优不是一件简单的事情，但是，您可以遵循一些原则来简化这项任务。</p><ul class=""><li id="0055" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">少量垃圾收集</strong> —垃圾收集应该在一次运行中收集尽可能多的死对象，以减少垃圾收集的频率。</li><li id="7fd2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu"> GC内存最大化</strong> —它表示GC在一个周期内可以访问的内存越多，清理效率越高，收集频率越低。</li><li id="b5f7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">三选二</strong> —您需要从三个绩效目标中选择两个与您的业务需求最相关的目标。例如，高吞吐量和低延迟会导致更高的内存使用率。</li></ul><p id="364c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过为堆区域和不同的垃圾收集器更改不同的内存大小来遵循试错法。我希望不久能在《垃圾收集者》中增加一个故事。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="89ed" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="05e4" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">感谢阅读。我相信这篇文章可以帮助您优化Java应用程序的性能。要了解更多详情，您也可以访问参考网站。编码快乐！</p><h2 id="9e97" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">参考</h2><ul class=""><li id="827d" class="lv lw it lb b lc ni lf nj li ov lm ow lq ox lu ma mb mc md bi translated"><a class="ae ky" href="https://blog.jooq.org/2015/02/05/top-10-easy-performance-optimisations-in-java/" rel="noopener ugc nofollow" target="_blank">Java中十大简单的性能优化</a></li><li id="8b9b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://www.eginnovations.com/blog/top-10-java-performance-problems/#Java-Code" rel="noopener ugc nofollow" target="_blank">十大Java性能问题及解决方法</a></li><li id="b486" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://www.progress.com/tutorials/jdbc/jdbc-jdbc-connection-pooling" rel="noopener ugc nofollow" target="_blank"> JDBC连接池</a></li><li id="2697" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://infinispan.org/docs/stable/titles/overview/overview.html" rel="noopener ugc nofollow" target="_blank"> Infinispan技术概述</a></li><li id="6ca5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://www.infoworld.com/article/2074843/j2ee-application-performance-optimization.html?page=2" rel="noopener ugc nofollow" target="_blank"> J2EE应用性能优化</a></li><li id="cf7e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://dzone.com/articles/how-to-properly-plan-jvm-performance-tuning" rel="noopener ugc nofollow" target="_blank">如何正确规划JVM性能调优</a></li><li id="004b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://docs.oracle.com/cd/E26576_01/doc.312/e24936/tuning-java.htm#GSPTG00006" rel="noopener ugc nofollow" target="_blank">调优Java运行时系统</a></li><li id="3042" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" rel="noopener ugc nofollow" target="_blank"> Java垃圾收集基础知识</a></li><li id="5b41" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://sematext.com/blog/jvm-performance-tuning/" rel="noopener ugc nofollow" target="_blank"> JVM调优:如何为性能调优准备您的环境</a></li></ul></div></div>    
</body>
</html>