<html>
<head>
<title>Build your first REST API in Go language using the Gin framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Gin框架用Go语言构建你的第一个REST API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-your-first-rest-api-in-go-language-using-gin-framework-827aadc14e07?source=collection_archive---------1-----------------------#2020-04-17">https://levelup.gitconnected.com/build-your-first-rest-api-in-go-language-using-gin-framework-827aadc14e07?source=collection_archive---------1-----------------------#2020-04-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/f2869fe772af8be4a522bafd3330ac3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ifpd_HtDiK9u6h68SZgNuA.png"/></div></div></figure><div class=""/><p id="ec61" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi kz translated"><span class="l la lb lc bm ld le lf lg lh di"> Go </span>是一种开源编程语言，可以轻松构建简单、可靠、高效的软件。</p><blockquote class="li lj lk"><p id="4364" class="kb kc ll kd b ke kf kg kh ki kj kk kl lm kn ko kp ln kr ks kt lo kv kw kx ky im bi translated">在本教程中，我们将创建一个允许用户从服务器上传和下载文件的API。最终的源代码可以在<a class="ae lp" href="https://github.com/mehrdadep/go-rest-example" rel="noopener ugc nofollow" target="_blank"> <strong class="kd jf"> GitHub </strong> </a>上找到。</p></blockquote></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="b1a3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将使用<a class="ae lp" href="https://github.com/gin-gonic/gin" rel="noopener ugc nofollow" target="_blank"> Gin </a> web框架来处理我们的REST APIs。Gin是一个用Go (Golang)编写的HTTP web框架。它有一个类似Martini的API，性能更好。</p><h2 id="d42b" class="lx ly je bd lz ma mb dn mc md me dp mf km mg mh mi kq mj mk ml ku mm mn mo mp bi translated">先决条件</h2><ul class=""><li id="a22e" class="mq mr je kd b ke ms ki mt km mu kq mv ku mw ky mx my mz na bi translated">我们假设您已经安装了GO。如果没有，请在此查看<a class="ae lp" href="https://golang.org/doc/install" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="acca" class="mq mr je kd b ke nb ki nc km nd kq ne ku nf ky mx my mz na bi translated">你需要知道一点关于<a class="ae lp" href="https://blog.golang.org/using-go-modules" rel="noopener ugc nofollow" target="_blank"> Go模块</a>的知识。我们将使用模块作为我们的依赖管理解决方案。</li></ul><h1 id="e8cc" class="ng ly je bd lz nh ni nj mc nk nl nm mf nn no np mi nq nr ns ml nt nu nv mo nw bi translated">第一步</h1><p id="5d96" class="pw-post-body-paragraph kb kc je kd b ke ms kg kh ki mt kk kl km nx ko kp kq ny ks kt ku nz kw kx ky im bi translated">首先，您需要用您的模块名创建一个目录。然后使用<code class="fe oa ob oc od b">go mod init</code>命令初始化go模块。现在您必须使用<code class="fe oa ob oc od b">go get github.com/gin-gonic/gin</code>将Gin作为您的依赖项之一</p><p id="abdd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在在你的模块的根目录下创建一个<code class="fe oa ob oc od b">main.go</code>文件。这个文件是一切开始的地方。您的主文件应该是这样的:</p><pre class="oe of og oh gt oi od oj ok aw ol bi"><span id="a649" class="lx ly je od b gy om on l oo op">package main<br/><br/><br/>func main(){<br/>   // function starts here<br/>}</span></pre><p id="cbea" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在创建一个名为api的目录，并在api目录下创建两个名为<strong class="kd jf"> <em class="ll">控制器</em>T22<strong class="kd jf">和<em class="ll">视图</em>T26】的新目录。我们将把控制器背后的逻辑从我们的视图中分离出来。所以现在你的项目应该有这样的结构:</strong></strong></p><pre class="oe of og oh gt oi od oj ok aw ol bi"><span id="7934" class="lx ly je od b gy om on l oo op">/go_rest_example/<br/>    /api/<br/>        /service/<br/>            main.go<br/>        /view/<br/>            main.go<br/>    main.go<br/>    go.mod<br/>    go.sum</span></pre><h1 id="d4a9" class="ng ly je bd lz nh ni nj mc nk nl nm mf nn no np mi nq nr ns ml nt nu nv mo nw bi translated">我们上传点东西吧</h1><p id="746c" class="pw-post-body-paragraph kb kc je kd b ke ms kg kh ki mt kk kl km nx ko kp kq ny ks kt ku nz kw kx ky im bi translated">在这一部分，我们将创建我们的上传API。在view的main.go文件中创建一个名为<code class="fe oa ob oc od b">StartServer</code>的函数。这个函数将使用Gin框架来处理API端点，并在本地机器的一个端口上启动一个web服务器。所以不要忘记在你的文件顶部导入<code class="fe oa ob oc od b">gin-gonic/gin</code>包。首先我们必须从Gin的<code class="fe oa ob oc od b">Default</code>函数中创建一个路由器。</p><p id="cde5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以在路由器上使用Gin的<code class="fe oa ob oc od b">Group</code>功能将一堆相同的端点分组。在这个项目中，我们将有两个端点，一个用于上传，另一个用于下载。</p><p id="7b51" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将我们的路由器分组在<code class="fe oa ob oc od b">/api</code> <strong class="kd jf"> <em class="ll"> </em> </strong>端点上，因为我们所有的端点都以它开始，然后将<code class="fe oa ob oc od b">/api</code>与<code class="fe oa ob oc od b"> /v1</code> <strong class="kd jf"> <em class="ll"> </em> </strong>分组，因为(当然)这是这个API的第一个版本，最后将<code class="fe oa ob oc od b"> /v1</code>分组在<code class="fe oa ob oc od b"> /files</code>上。现在我们有了最终的终点:</p><pre class="oe of og oh gt oi od oj ok aw ol bi"><span id="7965" class="lx ly je od b gy om on l oo op">POST /api/v1/files/ <br/>GET /api/v1/files/:name/</span></pre><p id="57ea" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要在您的最终端点上指定<code class="fe oa ob oc od b">http</code>方法，请使用大写字母的http方法名(例如<code class="fe oa ob oc od b">POST</code>、<code class="fe oa ob oc od b">GET</code>)。这些函数的第一个参数是端点地址，第二个参数是处理API调用的函数。</p><p id="5ce3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Gin将请求放在<strong class="kd jf"> <em class="ll"> </em> </strong> <code class="fe oa ob oc od b">*gin.Context</code>类型中，因此您可以从<code class="fe oa ob oc od b">*gin.Context</code>变量中访问请求头、文件等。您应该将该类型作为参数传递给<code class="fe oa ob oc od b">http</code>方法的第二个参数。</p><p id="bb45" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要在自定义端口上运行您的服务器，请使用带有<code class="fe oa ob oc od b">“:PORT_NUM”</code>的run方法。例如，要在端口8095上运行，请使用<code class="fe oa ob oc od b">router.Run(“:8095”)</code></p><p id="5827" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">视图目录中的main.go文件现在应该是这样的:</p><pre class="oe of og oh gt oi od oj ok aw ol bi"><span id="b00f" class="lx ly je od b gy om on l oo op">package view<br/><br/>import (<br/>   "github.com/gin-gonic/gin"<br/>)<br/><br/>func StartServer() {<br/>   router := gin.Default()<br/>   api := router.Group("/api")<br/>   v1 := api.Group("/v1")<br/>   files := v1.Group("/files")<br/>   files.POST("/", func(c *gin.Context) {</span><span id="3ab3" class="lx ly je od b gy oq on l oo op">     // Controller code's goes here<br/>})<br/>   router.Run(":8080")<br/>}</span></pre><p id="fa61" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们必须从请求中接收一个文件，并将其保存在某个地方。使用Gin的<code class="fe oa ob oc od b">FormFile</code>函数从请求中检索单个文件。如果出现任何错误，您可以使用Gin的<code class="fe oa ob oc od b">JSON</code>函数和Gin的<code class="fe oa ob oc od b">H</code> <strong class="kd jf"> <em class="ll"> </em> </strong>类型返回一个<code class="fe oa ob oc od b">JSON</code>响应。现在你的<code class="fe oa ob oc od b">POST</code>函数的主体应该是这样的:</p><pre class="oe of og oh gt oi od oj ok aw ol bi"><span id="a0a7" class="lx ly je od b gy om on l oo op">file, err := c.FormFile("file")<br/>if err != nil {<br/>   c.JSON(http.<em class="ll">StatusBadRequest</em>, gin.H{"error": err.Error()})<br/>}</span></pre><p id="ecea" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们必须在控制器中处理上传。在<code class="fe oa ob oc od b">./api/controller/main.go</code>中创建一个名为<code class="fe oa ob oc od b">Upload</code>的函数。这个函数将接收一个文件作为参数，并将它保存在一个目的地(或者您可以在视图的主文件中使用Gin的<code class="fe oa ob oc od b">SaveUploadedFile</code>函数)。现在控制器的main.go文件应该是这样的</p><pre class="oe of og oh gt oi od oj ok aw ol bi"><span id="60c2" class="lx ly je od b gy om on l oo op">package controller<br/><br/>import (<br/>   "fmt"<br/>   "io"<br/>   "mime/multipart"<br/>   "os"<br/>   "time"<br/>)<br/><br/>// This is the root directory of uploaded files<br/>var base = "/home/mehrdadep/example"<br/><br/>func Upload(file *multipart.FileHeader) (string, error) {<br/>   src, err := file.Open()<br/>   if err != nil {<br/>      return "", err<br/>   }<br/>   defer src.Close()<br/>   n := fmt.Sprintf("%d - %s", time.Now().UTC().Unix(), file.Filename)<br/>   dst := fmt.Sprintf("%s/%s", base, n)<br/>   out, err := os.Create(dst)<br/>   if err != nil {<br/>      return "", err<br/>   }<br/>   defer out.Close()<br/><br/>   _, err = io.Copy(out, src)<br/>   return n, err<br/>}</span></pre><p id="d847" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回到视图，我们可以通过调用控制器的上传函数来完成上传API的实现。现在你的<code class="fe oa ob oc od b">POST</code>函数的主体应该是这样的:</p><pre class="oe of og oh gt oi od oj ok aw ol bi"><span id="c2e3" class="lx ly je od b gy om on l oo op">file, err := c.FormFile("file")<br/>if err != nil {<br/>   c.JSON(http.<em class="ll">StatusBadRequest</em>, gin.H{"error": err.Error()})<br/>   return<br/>}<br/>n, err := controller.Upload(file)<br/>if err != nil {<br/>   c.JSON(http.<em class="ll">StatusInternalServerError</em>, gin.H{"error": err.Error()})<br/>   return<br/>}<br/>c.JSON(http.<em class="ll">StatusOK</em>, gin.H{<br/>   "success": "Uploaded successfully",<br/>   "name": fmt.Sprintf("%s", n),<br/>})</span></pre><h1 id="c413" class="ng ly je bd lz nh ni nj mc nk nl nm mf nn no np mi nq nr ns ml nt nu nv mo nw bi translated">我们也能下载吗？</h1><p id="8c52" class="pw-post-body-paragraph kb kc je kd b ke ms kg kh ki mt kk kl km nx ko kp kq ny ks kt ku nz kw kx ky im bi translated">当然了。Gin可以使用<code class="fe oa ob oc od b">ShouldBindUri</code>函数绑定<code class="fe oa ob oc od b">url</code>变量。现在让我们创建我们的下载端点。在你的视图的<code class="fe oa ob oc od b">main.go</code>文件的顶部创建一个新的自定义类型命名文件。我们将使用这个类型和Gin的<code class="fe oa ob oc od b">ShouldBindUri</code>从<code class="fe oa ob oc od b">uri</code>中读取一个变量。</p><pre class="oe of og oh gt oi od oj ok aw ol bi"><span id="36e7" class="lx ly je od b gy om on l oo op">type File struct {<br/>   Name string `uri:"name" binding:"required"`<br/>}</span></pre><p id="b16e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在添加端点，使用它的名称下载文件。</p><pre class="oe of og oh gt oi od oj ok aw ol bi"><span id="d177" class="lx ly je od b gy om on l oo op">files.GET("/:name/", func(c *gin.Context) {<br/>   var file File<br/>   if err := c.ShouldBindUri(&amp;file); err != nil {<br/>      c.JSON(http.<em class="ll">StatusBadRequest</em>, gin.H{"msg": err})<br/>      return<br/>   }<br/>})</span></pre><p id="930d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">之后，如果<code class="fe oa ob oc od b">uri</code>绑定到文件类型，我们必须将它传递给控制器的<code class="fe oa ob oc od b">Download</code>函数来处理文件的下载。最后，我们可以使用Gin的数据函数提供文件。现在视图中的<code class="fe oa ob oc od b">GET</code>方法应该是这样的:</p><pre class="oe of og oh gt oi od oj ok aw ol bi"><span id="9517" class="lx ly je od b gy om on l oo op">var f File<br/>if err := c.ShouldBindUri(&amp;f); err != nil {<br/>   c.JSON(http.<em class="ll">StatusBadRequest</em>, gin.H{"error": err})<br/>   return<br/>}<br/>m, cn, err := controller.Download(f.Name)<br/>if err != nil {<br/>   c.JSON(http.<em class="ll">StatusNotFound</em>, gin.H{"error": err})<br/>   return<br/>}<br/>c.Header("Content-Disposition", "attachment; filename="+n)<br/>c.Data(http.<em class="ll">StatusOK</em>, m, cn)</span></pre><p id="4417" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在控制器的主文件中创建一个名为<code class="fe oa ob oc od b">Download</code>的函数。这个函数获取一个文件名，并将它的mime类型和内容返回给视图。我们使用<code class="fe oa ob oc od b">http</code>包的<code class="fe oa ob oc od b">DetectContentType</code>函数来检测文件的内容类型。现在<code class="fe oa ob oc od b">Download</code>功能变为:</p><pre class="oe of og oh gt oi od oj ok aw ol bi"><span id="b553" class="lx ly je od b gy om on l oo op">func Download(n string) (string, []byte, error) {<br/>   dst := fmt.Sprintf("%s/%s", base, n)<br/>   b, err := ioutil.ReadFile(dst)<br/>   if err != nil {<br/>      return "", nil, err<br/>   }<br/>   m := http.DetectContentType(b[:512])<br/><br/>   return m, b, nil<br/>}</span></pre><h1 id="3738" class="ng ly je bd lz nh ni nj mc nk nl nm mf nn no np mi nq nr ns ml nt nu nv mo nw bi translated"><strong class="ak">给我造点我能用的东西</strong></h1><p id="3050" class="pw-post-body-paragraph kb kc je kd b ke ms kg kh ki mt kk kl km nx ko kp kq ny ks kt ku nz kw kx ky im bi translated">在你的模块的根文件夹中运行<code class="fe oa ob oc od b">go build -o ./rest-api main.go</code>命令，将你的模块构建到一个文件中。现在您可以使用<code class="fe oa ob oc od b">./rest-api</code>运行它。或者，您可以使用<code class="fe oa ob oc od b">go run main.go</code>运行您的项目，而不构建它。</p><p id="99d9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Gin的默认环境是调试模式。在使用<code class="fe oa ob oc od b">gin.SetMode(gin.ReleaseMode)</code>调用<code class="fe oa ob oc od b">view.StartServer()</code>功能之前，您可以将其更改为释放模式。如果你正在使用调试模式，你应该会看到类似这样的输出，这意味着你的服务器正在运行，等待你调用它的API。</p><pre class="oe of og oh gt oi od oj ok aw ol bi"><span id="6d28" class="lx ly je od b gy om on l oo op">[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.</span><span id="c886" class="lx ly je od b gy oq on l oo op">[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.<br/> - using env:   export GIN_MODE=release<br/> - using code:  gin.SetMode(gin.ReleaseMode)</span><span id="85b2" class="lx ly je od b gy oq on l oo op">[GIN-debug] POST   /api/v1/files/            --&gt; go-rest-example/api/view.StartServer.func1 (3 handlers)<br/>[GIN-debug] GET    /api/v1/files/:name/      --&gt; go-rest-example/api/view.StartServer.func2 (3 handlers)<br/>[GIN-debug] Listening and serving HTTP on :8080</span></pre><h1 id="b5e7" class="ng ly je bd lz nh ni nj mc nk nl nm mf nn no np mi nq nr ns ml nt nu nv mo nw bi translated"><strong class="ak">我没有涵盖的内容</strong></h1><ul class=""><li id="0fe7" class="mq mr je kd b ke ms ki mt km mu kq mv ku mw ky mx my mz na bi translated">杜松子酒的中间产品</li><li id="9995" class="mq mr je kd b ke nb ki nc km nd kq ne ku nf ky mx my mz na bi translated">使用数据库保存文件的元数据</li><li id="354f" class="mq mr je kd b ke nb ki nc km nd kq ne ku nf ky mx my mz na bi translated">上传前的MIME类型检查</li><li id="d601" class="mq mr je kd b ke nb ki nc km nd kq ne ku nf ky mx my mz na bi translated">功能的单元测试</li></ul></div></div>    
</body>
</html>