<html>
<head>
<title>Node.js Best Practices — Error Handling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js最佳实践—错误处理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/node-js-best-practices-error-handling-50719c42504f?source=collection_archive---------2-----------------------#2020-04-13">https://levelup.gitconnected.com/node-js-best-practices-error-handling-50719c42504f?source=collection_archive---------2-----------------------#2020-04-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/afa680d1984cbbf7110c0a2835351b4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZoKybkwoPd6Z_hFS"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">理查德·布拉金斯-泰勒在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2c2f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Node.js是编写应用程序的流行运行时。这些应用程序通常是许多人使用的生产质量应用程序。为了使维护它们变得更容易，我们必须制定一些准则供人们遵循。</p><p id="206c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究Node.js应用程序中错误处理的最佳实践。</p><h1 id="bc0c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">仅使用内置的错误对象</h1><p id="2821" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在JavaScript中，我们可以创建error对象的子类，因此不需要创建自定义类型或返回一些错误值来抛出错误。</p><p id="6d3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以实例化<code class="fe mh mi mj mk b">Error</code>类或<code class="fe mh mi mj mk b">Error</code>类的子类。这样，会增加一致性，减少混乱。对每个看代码的人来说就少了很多头痛。</p><p id="1b81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以通过编写以下代码抛出一个<code class="fe mh mi mj mk b">Error</code>实例:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4352" class="mt lf it mk b gy mu mv l mw mx">throw new Error('error');</span></pre><p id="aff6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过使用如下的<code class="fe mh mi mj mk b">catch</code>块来捕捉错误并优雅地处理它们:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5882" class="mt lf it mk b gy mu mv l mw mx">try {<br/>  foo();<br/>} catch (e) {<br/>  if (e instanceof RangeError) {<br/>    console.error(`${e.name} - ${e.message}`)<br/>  }<br/>}</span></pre><p id="1b99" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码只处理<code class="fe mh mi mj mk b">RangeError</code>实例。</p><p id="9cd3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以从<code class="fe mh mi mj mk b">Error</code>实例中获得错误名称和堆栈跟踪。此外，我们可以通过子类化<code class="fe mh mi mj mk b">Error</code>类来创建自己的错误类:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="cbd2" class="mt lf it mk b gy mu mv l mw mx">class CustomError extends Error {<br/>  constructor(foo = 'bar', ...params) {<br/>    super(...params)<br/>    if (Error.captureStackTrace) {<br/>      Error.captureStackTrace(this, CustomError)<br/>    }</span><span id="53fc" class="mt lf it mk b gy my mv l mw mx">    this.name = 'CustomError'    <br/>    this.foo = foo<br/>    this.date = new Date()<br/>  }<br/>}</span></pre><p id="0cdc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以抛出一个<code class="fe mh mi mj mk b">CustomError</code>实例，并通过编写以下代码来捕获它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d5ac" class="mt lf it mk b gy mu mv l mw mx">try {<br/>  throw new CustomError('baz');<br/>} catch (e) {  <br/>  if (e instanceof CustomError) {<br/>    console.error(`${e.name} - ${e.foo}`)<br/>  }<br/>}</span></pre><h1 id="b4fe" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">区分操作错误和程序员错误</h1><p id="f748" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">用户操作失误应由用户自行处理。例如，如果输入了无效的输入，我们应该通过向他们发送错误消息来处理它。</p><p id="5b81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，如果错误是程序员的错误，那么我们应该修复它们。保持程序员错误不被修复不是一个好主意，因为它会导致糟糕的用户体验和数据损坏。</p><p id="2a3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于用户错误，我们应该向客户端发送web应用程序的400系列响应代码。400表示输入错误，401表示未授权，403表示禁止。</p><h1 id="822c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">集中处理错误，而不是在Express中间件中</h1><p id="dd16" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在Express应用程序中，错误处理应该集中在自己的中间件中完成，而不是分散在多个中间件中。</p><p id="200d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们应该编写类似下面的代码来处理错误:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d087" class="mt lf it mk b gy mu mv l mw mx">const express = require('express');<br/>const bodyParser = require('body-parser');</span><span id="8297" class="mt lf it mk b gy my mv l mw mx">const app = express();</span><span id="87c2" class="mt lf it mk b gy my mv l mw mx">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="421e" class="mt lf it mk b gy my mv l mw mx">app.get('/', (req, res, next) =&gt; {<br/>  try {<br/>    throw new Error('error')<br/>    res.send('hello')<br/>  } catch (err) {<br/>    next(err)<br/>  }<br/>});</span><span id="6292" class="mt lf it mk b gy my mv l mw mx">app.use((err, req, res, next) =&gt; {<br/>  res.send('error occurred')<br/>})</span><span id="1b6b" class="mt lf it mk b gy my mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="e9e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们在应用程序的末尾添加了一个错误处理程序，以便它在所有路由调用<code class="fe mh mi mj mk b">next</code>时运行。</p><p id="6910" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们就不必编写多段代码来处理错误。在上面的代码中:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0f3a" class="mt lf it mk b gy mu mv l mw mx">app.use((err, req, res, next) =&gt; {<br/>  res.send('error occurred')<br/>})</span></pre><p id="b2ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是错误处理器中间件。GET route中的<code class="fe mh mi mj mk b">next</code>函数调用错误处理程序，因为它抛出了一个错误。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/0d1c608a4e59dd294b723ecfb679a5ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*52saWIQypqkM-AFm"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@cmart10?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迦勒·马丁</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="510f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用Swagger记录API错误</h1><p id="9e97" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">文档非常重要，因为它让人们知道如何使用API，并确保对API的更改不会意外地产生不良行为。</p><p id="c5a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，将Swagger添加到Express应用程序很容易，因为我们有Swagger UI Express包来为我们做这件事。我们可以通过编写以下代码来安装Swagger UI Express包:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8c51" class="mt lf it mk b gy mu mv l mw mx">npm install swagger-ui-express</span></pre><p id="93d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以如下创建一个<code class="fe mh mi mj mk b">swagger.json</code>文件:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="fc28" class="mt lf it mk b gy mu mv l mw mx">{<br/>  "openapi": "3.0.0",<br/>  "info": {<br/>    "title": "Sample API",<br/>    "description": "Optional multiline or single-line description in [CommonMark](http://commonmark.org/help/) or HTML.",<br/>    "version": "0.1.9"<br/>  },<br/>  "servers": [<br/>    {<br/>      "url": "https://UnwittingRudeObservation--five-nine.repl.co",<br/>      "description": "Optional server description, e.g. Main (production) server"<br/>    },<br/>    {<br/>      "url": "https://UnwittingRudeObservation--five-nine.repl.co",<br/>      "description": "Optional server description, e.g. Internal staging server for testing"<br/>    }<br/>  ],<br/>  "paths": {<br/>    "/": {<br/>      "get": {<br/>        "summary": "Returns a hello message.",<br/>        "description": "Optional extended description in CommonMark or HTML.",<br/>        "responses": {<br/>          "200": {<br/>            "description": "A JSON string message",<br/>            "content": {<br/>              "application/json": {<br/>                "schema": {<br/>                  "type": "string",<br/>                  "items": {<br/>                    "type": "string"<br/>                  }<br/>                }<br/>              }<br/>            }<br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="d2b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在我们的应用程序中，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8d59" class="mt lf it mk b gy mu mv l mw mx">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const swaggerUi = require('swagger-ui-express');<br/>const swaggerDocument = require('./swagger.json');<br/>const app = express();</span><span id="31de" class="mt lf it mk b gy my mv l mw mx">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="d27d" class="mt lf it mk b gy my mv l mw mx">app.get('/', (req, res, next) =&gt; {<br/>  res.send('hello')<br/>});</span><span id="2f32" class="mt lf it mk b gy my mv l mw mx">app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerDocument));<br/>app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="1c1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以去<a class="ae kf" href="https://editor.swagger.io/" rel="noopener ugc nofollow" target="_blank">https://editor.swagger.io/</a>编辑我们的Swagger API文档。</p><h1 id="6f3f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="cd59" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们想在节点应用程序中抛出错误，我们应该抛出一个<code class="fe mh mi mj mk b">Error</code>的实例或者<code class="fe mh mi mj mk b">Error</code>的子类。捕捉错误可以在节点应用程序的catch块中完成。对于Express应用程序，它也应该由中央错误处理程序来处理。</p><p id="e891" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了使使用和更改API变得容易，我们应该使用Swagger来记录我们的API拥有的路由。对于Express应用程序，我们可以使用Swagger UI Express以一种易于阅读的格式将我们的<code class="fe mh mi mj mk b">swagger.json</code>文件作为一个单独的页面。</p><p id="d7e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于用户错误，我们应该将错误发回给他们。程序员的错误应该由我们来解决。</p></div></div>    
</body>
</html>