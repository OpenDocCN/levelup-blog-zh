<html>
<head>
<title>Learning C++: Nonmutating Algorithms of the STL Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习c++:STL的不变算法第2部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-nonmutating-algorithms-of-the-stl-part-2-1d89277fb573?source=collection_archive---------16-----------------------#2020-04-22">https://levelup.gitconnected.com/learning-c-nonmutating-algorithms-of-the-stl-part-2-1d89277fb573?source=collection_archive---------16-----------------------#2020-04-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7a7930f096452e69633c6098c73ec544.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pBdTZzs8F7fFY6Q5"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">凯文·Ku在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="2324" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我将展示C++标准模板库中的另一组非可变算法。这组函数是可以用来在容器中查找数据或搜索数据的函数。在开始之前，我应该提到这些函数将用于未排序的数据。我将在另一篇文章中详细讨论对排序数据使用哪些函数。</p><h1 id="e47a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">查找功能</h1><p id="86c8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">find</code>函数用于确定容器中是否存在指定的值。如果值在容器中，函数返回一个迭代器，如果值不在容器中，函数返回end。</p><p id="3739" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是<code class="fe mh mi mj mk b">find</code>函数的语法模板:</p><p id="16ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> find(范围-开始，范围-结束，值)；</em></p><p id="9667" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个使用<code class="fe mh mi mj mk b">find</code>函数的示例程序:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="f1f2" class="mu lf it mk b gy mv mw l mx my">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;algorithm&gt;<br/>#include &lt;cstdlib&gt;<br/>#include &lt;ctime&gt;<br/>using namespace std;</span><span id="f780" class="mu lf it mk b gy mz mw l mx my">void buildVec(vector&lt;int&gt; &amp;vec, int n) {<br/>  srand(time(0));<br/>  for (int i = 1; i &lt;= n; i++) {<br/>    vec.push_back(rand() % 100 + 1);<br/>  }<br/>}</span><span id="768d" class="mu lf it mk b gy mz mw l mx my">void printVec(vector&lt;int&gt; vec) {<br/>  int i = 0;<br/>  for (const int n : vec) {<br/>    cout &lt;&lt; n &lt;&lt; " ";<br/>    if (++i % 10 == 0) {<br/>      cout &lt;&lt; endl;<br/>    }<br/>  }<br/>}</span><span id="e672" class="mu lf it mk b gy mz mw l mx my">int main () {<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 50);<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl;<br/>  int value;<br/>  for (int i = 1; i &lt;= 2; i++) {<br/>    cout &lt;&lt; "Value to find: ";<br/>    cin &gt;&gt; value;<br/>    auto position = find(numbers.begin(), numbers.end(), value);<br/>    if (position != numbers.end()) {<br/>      cout &lt;&lt; "Found " &lt;&lt; value &lt;&lt; "." &lt;&lt; endl;<br/>    }<br/>    else {<br/>      cout &lt;&lt; value &lt;&lt; " not in numbers." &lt;&lt; endl;<br/>    }<br/>  }<br/>  return 0;<br/>}</span></pre><p id="f736" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个程序运行一次的输出:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="2193" class="mu lf it mk b gy mv mw l mx my">57 4 86 1 39 47 67 37 12 30<br/>86 6 94 48 23 72 82 31 82 52<br/>65 29 60 68 48 18 29 2 97 74<br/>87 23 68 61 45 10 85 55 94 72<br/>34 61 44 45 43 5 12 15 24 54</span><span id="37a0" class="mu lf it mk b gy mz mw l mx my">Value to find: 3<br/>3 not in numbers.<br/>Value to find: 82<br/>Found 82.</span></pre><h1 id="98de" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">find_if函数</h1><p id="0cc0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">find_if</code>函数用于根据谓词函数查找值，谓词函数可以是lambda函数或函数适配器。以下是该函数的语法模板:</p><p id="557b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> find_if(范围开始，范围结束，函数)；</em></p><p id="0fb2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我的第一个例子将使用一个谓词函数来确定该函数找到的值。我创建了一个函数<code class="fe mh mi mj mk b">greaterThan98</code>，它返回其参数与值98的比较结果。程序如下:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="28e1" class="mu lf it mk b gy mv mw l mx my">bool greaterThan98(int n) {<br/>  return n &gt; 98;<br/>}</span><span id="d719" class="mu lf it mk b gy mz mw l mx my">int main () {<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 50);<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  auto found = find_if(numbers.begin(), numbers.end(),<br/>                       greaterThan98);<br/>  if (found != numbers.end()){<br/>    cout &lt;&lt; "found value greater than 98" &lt;&lt; endl;<br/>  }<br/>  else {<br/>    cout &lt;&lt; "did not find value greater than 98";<br/>  }<br/>  return 0;<br/>}</span></pre><p id="b3d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序两次运行的结果:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="8fec" class="mu lf it mk b gy mv mw l mx my">89 4 17 84 93 97 99 14 83 7<br/>7 76 89 61 85 64 41 18 13 67<br/>46 44 83 68 93 93 19 76 41 73<br/>96 86 60 12 36 56 100 54 28 98<br/>70 51 46 85 36 86 20 18 13 85</span><span id="5e9c" class="mu lf it mk b gy mz mw l mx my">found value greater than 98</span><span id="1af4" class="mu lf it mk b gy mz mw l mx my">64 73 77 52 53 7 49 23 34 74<br/>6 89 96 10 17 24 31 14 51 47<br/>58 58 76 64 82 1 95 69 4 78<br/>81 11 94 27 12 63 46 42 42 12<br/>63 87 6 51 72 71 64 6 72 8</span><span id="d4f1" class="mu lf it mk b gy mz mw l mx my">did not find value greater than 98</span></pre><p id="8ea6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用函数适配器和绑定器来代替。解释这方面的背景超出了本文的范围，所以请到<a class="ae kf" href="https://www.cplusplus.com/reference/functional/bind/" rel="noopener ugc nofollow" target="_blank">这里</a>进行解释。现在理解了(希望如此)绑定器是如何工作的，这里是前面的程序使用<code class="fe mh mi mj mk b">greater&lt;int&gt;()</code>函数对象和一个绑定器将值98绑定到函数:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="de6a" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  using namespace std::placeholders;<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 50);<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl;<br/>  auto found = find_if(numbers.begin(), numbers.end(),<br/>                       bind(greater&lt;int&gt;(),_1, 98));<br/>  if (found != numbers.end()){<br/>    cout &lt;&lt; "found value greater than 98" &lt;&lt; endl;<br/>  }<br/>  else {<br/>    cout &lt;&lt; "did not find value greater than 98";<br/>  }<br/>  return 0;<br/>}</span></pre><p id="d814" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出类似于上面的输出，当然，只是数字不同。</p><p id="c848" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另外，请注意，我在main中使用了一个<code class="fe mh mi mj mk b">using </code>语句。这样做简化了函数调用中的<code class="fe mh mi mj mk b">bind</code>调用。否则，我会写:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="bf42" class="mu lf it mk b gy mv mw l mx my">auto found = find_if(numbers.begin(), numbers.end(),<br/>               bind(greater&lt;int&gt;(),std::placeholders::_1, 98));</span></pre><h1 id="917d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">函数的作用是</h1><p id="887f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">find家族中最后一个函数是<code class="fe mh mi mj mk b">find_if_not</code>。此函数返回容器中不匹配指定标准的第一个元素。以下是该函数的语法模板:</p><p id="2e7a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> find_if_not(range-start，range-end，函数)；</em></p><p id="207f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于下面的例子，我传入一个lambda函数作为第三个参数。这个函数检查一个值是否大于或等于10。<code class="fe mh mi mj mk b">find_if_not</code>函数将返回不符合该标准的第一个值。程序如下:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="4bcc" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 50);<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl;<br/>  auto found = find_if_not(numbers.begin(), numbers.end(),<br/>                          [](int element) { return element &gt;= 10;});<br/>  if (found != numbers.end()){<br/>    cout &lt;&lt; "found value less than 10: " &lt;&lt; *found &lt;&lt; endl;<br/>  }<br/>  else {<br/>    cout &lt;&lt; "did not find value less than 10";<br/>  }<br/>  return 0;<br/>}</span></pre><p id="3093" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个程序运行一次的输出:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="cce4" class="mu lf it mk b gy mv mw l mx my">17 60 44 24 56 10 68 95 76 20<br/>55 21 34 87 46 32 62 9 5 3<br/>12 79 34 44 51 96 6 29 62 95<br/>40 86 95 8 89 67 72 10 8 34<br/>8 59 23 27 16 68 98 74 62 71</span><span id="f254" class="mu lf it mk b gy mz mw l mx my">found value less than 10: 9</span></pre><p id="e53c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，这些<code class="fe mh mi mj mk b">find</code>函数最适合顺序容器，比如数组和向量。关联容器和无序容器都有自己的find函数作为成员函数，效率比我在这里描述的函数要高得多。</p><h1 id="410f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用搜索功能</h1><p id="96ce" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">find</code>函数用于查找容器中的单个值。下一组函数是<code class="fe mh mi mj mk b">search</code>函数，用于查找容器中的值序列。</p><p id="3f3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这组中的第一个功能是<code class="fe mh mi mj mk b">search</code>。这个函数有四个参数:开始搜索范围、结束搜索范围、要搜索的开始范围和要搜索的结束范围。下面是<code class="fe mh mi mj mk b">search</code>函数的语法模板:</p><p id="9591" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">搜索(搜索-范围-开始，搜索-范围-结束，序列-范围-开始，序列-范围-结束)；</em></p><p id="19d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数返回一个迭代器到找到匹配的第一个元素，如果没有找到匹配，函数返回一个迭代器结束。</p><p id="633c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个使用<code class="fe mh mi mj mk b">search</code>函数在向量中寻找一系列值的例子。该程序在一组50个随机生成的数字中搜索序列<em class="ml"> 98，99 </em>。代码如下:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="7293" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 50);<br/>  sort(numbers.begin(), numbers.end());<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl;<br/>  vector&lt;int&gt; highVals = {98, 99};<br/>  auto found = search(numbers.begin(), numbers.end(),<br/>                      highVals.begin(), highVals.end());<br/>  if (found != numbers.end()) {<br/>    cout &lt;&lt; "Found sequence starting with: " &lt;&lt; *found &lt;&lt; endl;<br/>  }<br/>  else {<br/>    cout &lt;&lt; "Didn't find sequence." &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="0458" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是该程序的两次运行:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="9551" class="mu lf it mk b gy mv mw l mx my">1 1 1 3 7 8 9 11 13 15</span><span id="c448" class="mu lf it mk b gy mz mw l mx my">17 18 19 20 22 26 27 33 33 33</span><span id="3123" class="mu lf it mk b gy mz mw l mx my">43 45 46 47 48 50 51 61 63 63<br/>64 66 69 73 73 75 80 80 81 82|<br/>83 84 86 86 88 90 91 96 99 99</span><span id="a1c3" class="mu lf it mk b gy mz mw l mx my">Didn't find sequence.</span><span id="9cb0" class="mu lf it mk b gy mz mw l mx my">1 1 2 2 3 4 5 10 14 17<br/>19 28 31 33 34 39 41 44 47 50<br/>50 51 53 55 58 59 60 62 63 67<br/>68 68 70 72 75 77 80 80 80 82<br/>84 85 94 94 94 95 98 99 99 99</span><span id="664c" class="mu lf it mk b gy mz mw l mx my">Found sequence starting with: 98</span></pre><p id="9c3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个组的另一个功能是<code class="fe mh mi mj mk b">search_n</code>。此函数搜索指定数量的相同值，例如连续三个100或连续两个87。</p><p id="8638" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是<code class="fe mh mi mj mk b">search_n</code>函数的语法模板:</p><p id="b806" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> search_n(范围-开始，范围-结束，顺序-计数，值)；</em></p><p id="6641" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">search_n</code>的返回值是一个迭代器，指向序列中第一个找到的值，如果序列没有找到，函数返回一个迭代器结束。</p><p id="23ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个演示<code class="fe mh mi mj mk b">search_n</code>功能如何工作的程序:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="0866" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 50);<br/>  sort(numbers.begin(), numbers.end());<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl;<br/>  int seqCount, searchVal;<br/>  cout &lt;&lt; "What value? ";<br/>  cin &gt;&gt; searchVal;<br/>  cout &lt;&lt; "How many in a row? ";<br/>  cin &gt;&gt; seqCount;<br/>  auto found = search_n(numbers.begin(), numbers.end(),<br/>                        seqCount, searchVal);<br/>  if (found != numbers.end()) {<br/>    cout &lt;&lt; "Found at position: "<br/>         &lt;&lt; int(found - numbers.begin()) &lt;&lt; endl;<br/>  }<br/>  else {<br/>    cout &lt;&lt; "Did not find that sequence count in the container."<br/>         &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="cd32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的几次运行:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="8926" class="mu lf it mk b gy mv mw l mx my">1 3 5 6 10 11 12 12 12 13<br/>13 15 22 30 32 33 35 35 38 40<br/>42 45 49 50 53 53 54 59 59 60<br/>61 61 69 69 71 73 73 77 79 80<br/>80 82 84 85 87 91 91 92 94 99</span><span id="07bd" class="mu lf it mk b gy mz mw l mx my">What value? 91<br/>How many in a row? 2<br/>Found at position: 45</span><span id="d83b" class="mu lf it mk b gy mz mw l mx my">2 3 5 5 5 6 7 8 8 13<br/>14 16 16 18 25 28 32 32 33 36<br/>39 44 44 44 48 48 50 56 65 65<br/>66 72 73 74 76 77 77 79 82 86<br/>89 93 95 97 97 97 98 99 100 100</span><span id="fb87" class="mu lf it mk b gy mz mw l mx my">What value? 5<br/>How many in a row? 3<br/>Found at position: 2</span></pre><p id="f67a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以看到，我通过使用以下算法从找到第一个值的位置减去<code class="fe mh mi mj mk b">begin</code>位置来确定序列中找到第一个元素的位置:</p><p id="d175" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">int(found — numbers.begin())</code></p><p id="ff2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">调用<code class="fe mh mi mj mk b">search_n</code>函数的一个可选方法是提供一个谓词函数作为确定匹配的标准。此版本函数的语法模板是:</p><p id="57cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> search_n(range-start，range-end，sequence-count，value，谓词-函数)；</em></p><p id="17de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个搜索大于指定值的指定值序列的示例:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="20af" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 50);<br/>  sort(numbers.begin(), numbers.end());<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl;<br/>  int seqCount, searchVal;<br/>  cout &lt;&lt; "Greater than what value? ";<br/>  cin &gt;&gt; searchVal;<br/>  cout &lt;&lt; "How many in a row? ";<br/>  cin &gt;&gt; seqCount;<br/>  auto found = search_n(numbers.begin(), numbers.end(),<br/>                        seqCount, searchVal, greater&lt;int&gt;());<br/>  if (found != numbers.end()) {<br/>    cout &lt;&lt; "Found at position: "<br/>         &lt;&lt; int(found - numbers.begin()) &lt;&lt; endl;<br/>  }<br/>  else {<br/>    cout &lt;&lt; "Did not find that sequence count in the container."<br/>         &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="55b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个程序运行一次的输出:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="d6ce" class="mu lf it mk b gy mv mw l mx my">1 1 3 6 15 16 20 24 24 26<br/>27 34 35 39 41 44 44 46 48 48<br/>48 49 50 51 51 55 57 57 57 57<br/>63 65 67 67 67 68 69 72 72 73<br/>74 75 76 78 85 87 87 90 91 98</span><span id="0e51" class="mu lf it mk b gy mz mw l mx my">Greater than what value? 85<br/>How many in a row? 2<br/>Found at position: 45</span></pre><h1 id="086f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">还有更多的算法来寻找值</h1><p id="9190" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">STL中还有一套算法用于查找值和搜索序列。我将在下一篇文章中介绍这些函数，作为非可变算法系列的第3部分。</p><p id="ecdd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您阅读这篇文章，请给我发电子邮件，提出您的意见和建议。</p></div></div>    
</body>
</html>