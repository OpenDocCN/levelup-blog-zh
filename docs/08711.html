<html>
<head>
<title>5 Ways to Create an Object in C# and When to Choose Which One</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用C#创建对象的5种方法以及何时选择哪一种</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-ways-to-create-an-object-in-c-and-when-to-choose-which-one-4aabea5c3e40?source=collection_archive---------0-----------------------#2021-05-28">https://levelup.gitconnected.com/5-ways-to-create-an-object-in-c-and-when-to-choose-which-one-4aabea5c3e40?source=collection_archive---------0-----------------------#2021-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c8b6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当创建一个对象时，像建筑师一样思考。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fface17199faf6fd3c1b8d04ff43e6c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rf4eJbY5G_3SJpXZ"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d672" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在编程世界中，几乎总是有几种方法可以达到相同的结果。如果软件开发人员在开始编写任何代码之前，定期对解决设计或编码问题的可用方法进行权衡分析，他们可以在职业生涯中快速成长。</p><p id="1bbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有什么比创建一个对象更容易的呢？几乎没有。</p><p id="d95f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，即使是开发人员每天做的这种琐碎的任务也有5种不同的方法。了解创建对象的每种方法的优缺点将允许开发人员选择最适合他们特定情况的方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5309" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.使用new()关键字创建对象</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="54fc" class="mw md it bd me mx my dn mi mz na dp mm li nb nc mo lm nd ne mq lq nf ng ms nh bi translated">优点:</h2><ul class=""><li id="f97b" class="ni nj it lb b lc nk lf nl li nm lm nn lq no lu np nq nr ns bi translated">这是<strong class="lb iu">实例化一个对象最简单的方法</strong>。这就像创建一个变量或调用一个静态方法一样简单。</li><li id="8548" class="ni nj it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">使用新关键字创建对象的位置没有限制。可以从应用程序的任何部分实例化一个对象，例如实例方法、静态方法、构造函数、catch块等。</li><li id="97d3" class="ni nj it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">对于构造函数中没有大量逻辑的对象或者不是大型对象，使用new关键字在性能方面是一个<strong class="lb iu">廉价的过程</strong>(如果您对为什么实例化大型对象是一个耗时的过程感兴趣，可以查看<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/why-is-list-struct-is-15-times-faster-to-allocate-than-list-class-17f5f79889ae">这是我的帖子</a>)。</li></ul><h2 id="14e4" class="mw md it bd me mx my dn mi mz na dp mm li nb nc mo lm nd ne mq lq nf ng ms nh bi translated">缺点:</h2><ul class=""><li id="4ea4" class="ni nj it lb b lc nk lf nl li nm lm nn lq no lu np nq nr ns bi translated"><strong class="lb iu">新的是胶水</strong>。这种创建对象的方式在类之间创建了一种在运行时不会被破坏的紧密耦合。滥用new关键字会使代码可重用性、单元测试变得复杂。新关键字用得越多，代码库就变得越庞大。</li><li id="3198" class="ni nj it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">没有简单的方法<strong class="lb iu">来改变对象的寿命</strong>。由new关键字实例化的对象的生存期将由外部对象控制。<code class="fe ny nz oa ob b">EmailService</code>将在<code class="fe ny nz oa ob b">OrderService</code>创建后创建。<code class="fe ny nz oa ob b">OrderService</code>一变成垃圾<code class="fe ny nz oa ob b">EmailService</code>就变成垃圾。为了将一个<code class="fe ny nz oa ob b">EmailService</code>对象的生命周期切换到一个单一对象，你需要修改<code class="fe ny nz oa ob b">OrderService</code>类的代码。</li><li id="853e" class="ni nj it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">如果需要执行来自对象构造器的长时间运行的逻辑，分配对象<strong class="lb iu">会更慢</strong>。</li><li id="126f" class="ni nj it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">将一个对象分配到大对象堆<strong class="lb iu">中比分配一个小对象要慢</strong>，因为运行时需要在内存碎片区域中寻找合适的位置。</li><li id="b299" class="ni nj it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">因为可以在代码中的任何地方创建实例，所以很容易以<strong class="lb iu">隐式依赖</strong>结束。如果一个依赖项没有在构造函数中定义，而是在类的方法中创建的，那么这个依赖项被称为隐式的。要回答一个类使用什么依赖关系的问题，开发人员需要分析该类的整个实现。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2780" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.将对象创建委托给阿迪容器</h1><p id="1594" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">创建对象的责任可以委托给一个单独的组件，即依赖注入容器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="bb36" class="mw md it bd me mx my dn mi mz na dp mm li nb nc mo lm nd ne mq lq nf ng ms nh bi translated">优点:</h2><ul class=""><li id="4130" class="ni nj it lb b lc nk lf nl li nm lm nn lq no lu np nq nr ns bi translated">理解对象使用的依赖关系要容易得多，因为它们都是在构造函数中指定的。开发人员只需要查看构造函数，就可以清楚地知道对象使用的是什么依赖关系，而不必分析类实现的其余部分。DI容器鼓励使用<strong class="lb iu">显式依赖</strong>。</li><li id="d168" class="ni nj it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">使用阿迪容器允许开发人员轻松切换<strong class="lb iu">对象生命周期</strong>(单例、按请求等)。)，这可以在应用程序的合成根完成，而不必修改应用程序代码的其余部分。</li><li id="77a4" class="ni nj it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">DI容器允许开发人员在同一接口的不同实现之间快速切换应用程序代码。</li><li id="ef3f" class="ni nj it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">除了完成构建对象图的主要职责之外，DI容器还提供了<strong class="lb iu">额外的有用特性</strong>，比如拦截。</li></ul><h2 id="1bcc" class="mw md it bd me mx my dn mi mz na dp mm li nb nc mo lm nd ne mq lq nf ng ms nh bi translated">缺点:</h2><ul class=""><li id="2556" class="ni nj it lb b lc nk lf nl li nm lm nn lq no lu np nq nr ns bi translated">与直接使用new关键字相比，创建对象<strong class="lb iu">要慢一些</strong>，因为DI容器使用反射和其他技术。</li><li id="74ff" class="ni nj it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">如果应用组合根中的依赖项配置错误，将不会有<strong class="lb iu">编译错误</strong>，而只是运行时崩溃。</li><li id="66e5" class="ni nj it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">应用程序中的<strong class="lb iu">流程更难</strong>跟踪。仅通过查看类构造函数中的接口，如果不阅读组合根中的配置，很难猜出当前使用的是哪个实现。</li><li id="b1d2" class="ni nj it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">开发者需要通过阅读文档来学习如何使用DI容器。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6611" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.使用反射创建对象</h1><p id="4ea5" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">实例化对象的下一种方法是反射机制。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="d347" class="mw md it bd me mx my dn mi mz na dp mm li nb nc mo lm nd ne mq lq nf ng ms nh bi translated">优点:</h2><ul class=""><li id="789d" class="ni nj it lb b lc nk lf nl li nm lm nn lq no lu np nq nr ns bi translated">反射允许<strong class="lb iu">后期绑定。</strong>反射机制允许开发者创建编译时不存在的类的实例，例如从动态加载的程序集中创建。</li><li id="22fe" class="ni nj it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">反射允许开发者实现一些<strong class="lb iu">通用算法</strong>。例如，使用反射的开发人员可以实现一种方法，该方法可以创建任何复杂程度的对象的深层副本。</li></ul><h2 id="a79b" class="mw md it bd me mx my dn mi mz na dp mm li nb nc mo lm nd ne mq lq nf ng ms nh bi translated">缺点:</h2><ul class=""><li id="a8e9" class="ni nj it lb b lc nk lf nl li nm lm nn lq no lu np nq nr ns bi translated">反射允许开发人员<strong class="lb iu">绕过封装</strong>，所以很容易错误地破坏类不变量。</li><li id="525b" class="ni nj it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">错误实现的反射算法，类型名中的错别字在构建时不会被检测到<strong class="lb iu">，但在运行时会失败。</strong></li><li id="a4f1" class="ni nj it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">对象创建<strong class="lb iu">比使用new关键字要慢</strong>，因为必须扫描汇编元数据才能找到类型信息。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e44f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.从对象池中获取对象</h1><p id="1a66" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">可以从对象池中加载已经预先创建的对象，而不是创建对象。显然，对象必须预先用新的关键字或反射创建，但这只需要做一次。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="4691" class="mw md it bd me mx my dn mi mz na dp mm li nb nc mo lm nd ne mq lq nf ng ms nh bi translated">优点:</h2><ul class=""><li id="edc6" class="ni nj it lb b lc nk lf nl li nm lm nn lq no lu np nq nr ns bi translated">从池中加载一个对象<strong class="lb iu">比从头开始创建一个对象要快得多</strong>，因此应用程序的性能得到了提高。</li><li id="0f1b" class="ni nj it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">使用对象池<strong class="lb iu">减少了垃圾收集器</strong>的压力，因为对象在使用后被送回对象池，而不是变成垃圾。同样，这提高了应用程序的性能。</li></ul><h2 id="2b3f" class="mw md it bd me mx my dn mi mz na dp mm li nb nc mo lm nd ne mq lq nf ng ms nh bi translated">缺点:</h2><ul class=""><li id="bf9c" class="ni nj it lb b lc nk lf nl li nm lm nn lq no lu np nq nr ns bi translated">记住<strong class="lb iu">在不再需要对象时将它发送回</strong>对象池是很重要的。这是开发人员很容易忘记的一个额外的重要步骤。</li><li id="47fa" class="ni nj it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">当开发人员需要保存许多大型对象时，对象池不是最佳选择。<strong class="lb iu">可达到内存限制</strong>。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="39c4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.通过反序列化创建对象</h1><p id="f900" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">创建对象的最后一种方法是将它从二进制、JSON或其他格式反序列化。当然，对象必须预先序列化并存储在内存或外部文件存储中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="fa79" class="mw md it bd me mx my dn mi mz na dp mm li nb nc mo lm nd ne mq lq nf ng ms nh bi translated">优点:</h2><ul class=""><li id="28b5" class="ni nj it lb b lc nk lf nl li nm lm nn lq no lu np nq nr ns bi translated">被序列化并存储到外部存储器的对象将在应用重启后继续存在。有时候，很少改变的大对象构建一次要便宜得多，以二进制格式存储它们，并在需要时将它们反序列化回内存。</li><li id="07b2" class="ni nj it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">二进制序列化<strong class="lb iu">比JSON或XML序列化</strong>更快。</li><li id="544b" class="ni nj it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">二进制序列化可以序列化和反序列化具有<strong class="lb iu">循环依赖</strong>的对象图。</li></ul><h2 id="7fda" class="mw md it bd me mx my dn mi mz na dp mm li nb nc mo lm nd ne mq lq nf ng ms nh bi translated">缺点:</h2><ul class=""><li id="de68" class="ni nj it lb b lc nk lf nl li nm lm nn lq no lu np nq nr ns bi translated">二进制序列化要求对象标记有<strong class="lb iu">【可序列化】</strong>属性。</li><li id="0225" class="ni nj it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">与JSON或XML序列化相比，二进制序列化不以人类可读的格式存储数据。</li><li id="ca58" class="ni nj it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">这种方法需要为序列化文件提供和维护<strong class="lb iu">附加存储</strong>。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1115" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="4bf3" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">没有更好或更坏的方法。这完全取决于你的具体情况。找到以最有效的方式解决您的问题的解决方案的唯一方法是权衡您的需求和每种可用方法的利弊，直到找到最合适的方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="a162" class="mw md it bd me mx my dn mi mz na dp mm li nb nc mo lm nd ne mq lq nf ng ms nh bi translated">我的其他文章</h2><div class="of og gp gr oh oi"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-implement-the-singleton-design-anti-pattern-in-c-68bb664c31f2"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">在C#中实现单例设计反模式的5种方法</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">各有利弊</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ks oi"/></div></div></a></div><div class="of og gp gr oh oi"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-implement-repository-pattern-in-c-e12565e4d4a2"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">C#中五大存储库模式实现的比较</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">一个成熟的软件工程师通常知道解决同一个编程问题的几种方法，并做出选择…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow ks oi"/></div></div></a></div><div class="of og gp gr oh oi"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-clone-an-object-in-c-d1374ec28efa"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">在C#中克隆对象的5种方法</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">各有利弊</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="or l"><div class="oy l ot ou ov or ow ks oi"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="066c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">分级编码</h1><p id="e3e7" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">感谢您成为我们社区的一员！<a class="ae ky" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank">订阅我们的YouTube频道</a>或者加入<a class="ae ky" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Skilled.dev编码面试课程</strong> </a>。</p></div></div>    
</body>
</html>