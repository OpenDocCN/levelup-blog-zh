<html>
<head>
<title>Learning JavaScript: Computing with Object Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习JavaScript:用对象方法计算</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-javascript-computing-with-object-methods-6bd194afd568?source=collection_archive---------14-----------------------#2020-09-01">https://levelup.gitconnected.com/learning-javascript-computing-with-object-methods-6bd194afd568?source=collection_archive---------14-----------------------#2020-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e677d546fcb1c0470975848836a413ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V3hp5yu59sKZDGb3"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">乔安娜·科辛斯卡在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="06a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript有一组内置方法，可以用于用户定义的对象。在本文中，我将讨论其中的几种方法，以及如何在JavaScript程序中使用它们。</p><h1 id="c39e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对象.分配</h1><p id="1540" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">方法用于将一个对象复制到另一个对象中。此方法的语法模板是:</p><p id="97d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> Object.assign(目标，源)；</em></p><p id="384c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中<em class="ml">源</em>是要复制的对象，而<em class="ml">目标</em>是要复制的对象。如果您想要分配目标对象，此方法将返回它。</p><p id="7e08" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个演示如何使用<code class="fe mh mi mj mk b">Object.assign</code>的示例程序:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="27a3" class="mu lf it mk b gy mv mw l mx my">function Student(name, id, grades) {<br/>  this.name = name;<br/>  this.id = id;<br/>  this.grades = grades;<br/>}</span><span id="4d07" class="mu lf it mk b gy mz mw l mx my">let st1 = new Student("",0,[]);<br/>et st2 = new Student("Jane Doe", 123, [91, 92, 93]);<br/>Object.assign(st1, st2);<br/>print(`${st1.name}, ${st1.id}\n[${st1.grades}]`);</span></pre><p id="1168" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="c7dc" class="mu lf it mk b gy mv mw l mx my">Jane Doe, 123<br/>[91, 92, 93]</span></pre><p id="c29e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用这种方法的一个很好的理由是确保新对象拥有旧对象的所有属性和值。当你写自己的方法时，你可能会不小心漏掉一些东西，而<code class="fe mh mi mj mk b">Object.assign</code>会系统地确保所有的属性和值都被赋给新对象。</p><h1 id="c87a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对象.创建</h1><p id="01fe" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">Object.create</code>方法从现有的对象原型创建一个新对象。以下是该方法的语法模板:</p><p id="808f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">const | let | var object-name = object . create(existing-object)；</em></p><p id="2ac5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看几个例子，看看这种方法在实践中是如何工作的。第一个例子从一个函数创建一个新对象，然后使用<code class="fe mh mi mj mk b">Object.create</code>创建第二个对象:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="ddb7" class="mu lf it mk b gy mv mw l mx my">function Student(name, id, grades) {<br/>  this.name = name;<br/>  this.id = id;<br/>  this.grades = grades;<br/>}</span><span id="7d9a" class="mu lf it mk b gy mz mw l mx my">let st1 = new Student("Bob Green", 1234, [81, 77, 92]);<br/>print(`${st1.name}, ${st1.id}\n${st1.grades}`);<br/>let st2 = Object.create(st1);<br/>print(`${st2.name}, ${st2.id}\n${st2.grades}`);</span></pre><p id="aafa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="0a5d" class="mu lf it mk b gy mv mw l mx my">Bob Green, 1234<br/>81,77,92<br/>Bob Green, 1234<br/>81,77,92</span></pre><p id="1b06" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">必须编写代码来更改新创建的对象的属性。</p><p id="9ec3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您也可以使用现有对象中的<code class="fe mh mi mj mk b">Object.create</code>,如下例所示:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="12eb" class="mu lf it mk b gy mv mw l mx my">let Point = {x: null, y: null};<br/>print(`x: ${Point.x}, y: ${Point.y}`);<br/>let p1 = Object.create(Point);<br/>p1.x = 1;<br/>p1.y = 2;<br/>print(`x: ${p1.x}, y: ${p1.y}`);</span></pre><p id="80b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="f9f4" class="mu lf it mk b gy mv mw l mx my">x: null, y: null<br/>x: 1, y: 2</span></pre><p id="2da9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与<code class="fe mh mi mj mk b">Object.assign</code>一样，使用该方法创建新对象确保了在创建新对象时使用现有对象的所有部分。</p><h1 id="4fc4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对象.条目</h1><p id="5d1e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">Object.entries</code>方法以与for-in循环相同的方式返回对象的键/值对。以下是该方法的语法模板:</p><p id="0042" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> [key，value]= object . entries(object)；</em></p><p id="3278" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是枚举对象的键和值的实际方法:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="c6ee" class="mu lf it mk b gy mv mw l mx my">let stu1 = {<br/>  name: "Jane Smith",<br/>  id: 1234,<br/>  grades: [88, 91, 77]<br/>}</span><span id="c8c2" class="mu lf it mk b gy mz mw l mx my">for (let [key, value] of Object.entries(stu1)) {<br/>  print(`${key}: ${value}`)<br/>}</span></pre><p id="4082" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="a608" class="mu lf it mk b gy mv mw l mx my">name: Jane Smith<br/>id: 1234<br/>grades: 88,91,77</span></pre><p id="9725" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实现同样目的的另一种方法是使用数组解构和<code class="fe mh mi mj mk b">forEach</code>方法，就像这样:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="7632" class="mu lf it mk b gy mv mw l mx my">let stu1 = {<br/>  name: "Jane Smith",<br/>  id: 1234,<br/>  grades: [88, 91, 77]<br/>}<br/>Object.entries(stu1).forEach(([key, value]) =&gt;<br/>                             print(`${key}: ${value}`));</span></pre><p id="5b3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用这种方法可以确保对象的所有属性都被访问，尽管一个<code class="fe mh mi mj mk b">for-of</code>循环也可以做到这一点，因为底层代码使用迭代器来访问对象中的所有属性。</p><h1 id="6f00" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对象. is</h1><p id="9c66" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">Object.is </code>方法比较两个对象以确定它们是否包含相同的值。以下是该方法的语法模板:</p><p id="9871" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">布尔值Object.is(object1，object 2)；</em></p><p id="2c30" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个使用<code class="fe mh mi mj mk b">Object.is</code>方法的示例程序:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="c6b9" class="mu lf it mk b gy mv mw l mx my">let stu1 = {<br/>  name: "Jane Smith",<br/>  id: 1234,<br/>  grades: [88, 91, 77]<br/>}</span><span id="ca73" class="mu lf it mk b gy mz mw l mx my">let stu2 = stu1;<br/>if (Object.is(stu1, stu2)) {<br/>  print("Same object.");<br/>}<br/>else {<br/>  print("Different objects.");<br/>}<br/>stu2 = Object.assign(stu2, stu1);<br/>if (Object.is(stu1, stu2)) {<br/>  print("Same object.");<br/>}<br/>else {<br/>  print("Different objects.");<br/>}<br/>stu2 = {<br/>  name: "John Smith",<br/>  id: 2345,<br/>  grades: [91, 88, 77]<br/>}<br/>if (Object.is(stu1, stu2)) {<br/>  print("Same object.");<br/>}<br/>else {<br/>  print("Different objects.");<br/>}</span></pre><p id="1929" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="1e9e" class="mu lf it mk b gy mv mw l mx my">Same object.<br/>Same object.<br/>Different objects.</span></pre><p id="e84f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个比较是在通过从另一个对象赋值而创建的对象之间进行的，因此它们显然是同一个对象。第二个比较是在原始的学生对象和使用<code class="fe mh mi mj mk b">Object.assign</code>方法创建的对象之间进行的，所以这两个对象也是相同的。最后一个比较是在两个对象之间进行的，这两个对象的属性中存储了完全不同的值，因此比较返回的对象是不同的对象。</p><h1 id="57a2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对象.键</h1><p id="e2c7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">Object.keys</code>方法返回一个包含对象键的数组。以下是该方法的语法模板:</p><p id="8b00" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">关键字数组object . keys(object-name)；</em></p><p id="d76a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个示例从对象中提取键并显示结果数组:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="1aaa" class="mu lf it mk b gy mv mw l mx my">let stu1 = {<br/>  name: "Jane Smith",<br/>  id: 1234,<br/>  grades: [88, 91, 77]<br/>}<br/>let keys = Object.keys(stu1);<br/>print(keys); // displays name,id,grades</span></pre><p id="ffac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然这不是特别有效，但我们可以使用这种方法来显示对象中的值，如下所示:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="c7c7" class="mu lf it mk b gy mv mw l mx my">let stu1 = {<br/>  name: "Jane Smith",<br/>  id: 1234,<br/>  grades: [88, 91, 77]<br/>}<br/>let keys = Object.keys(stu1);<br/>for (key of keys) {<br/>  print(key + ": " + stu1[key]);<br/>}</span></pre><p id="058b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="7467" class="mu lf it mk b gy mv mw l mx my">name: Jane Smith<br/>id: 1234<br/>grades: 88, 91, 77</span></pre><p id="3226" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有其他技术可以用来从对象中提取键，但是这个方法是一个更有效、更可靠的方法。</p><h1 id="ed1a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对象.值</h1><p id="baa6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">Object.values</code>方法返回一个包含存储在对象中的值的数组。以下是该方法的语法模板:</p><p id="4bd6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">值数组object . values(object-name)；</em></p><p id="54a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个演示这种方法如何工作的程序:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="9d53" class="mu lf it mk b gy mv mw l mx my">let stu1 = {<br/>  name: "Jane Smith",<br/>  id: 1234,<br/>  grades: [88, 91, 77]<br/>}<br/>let values = Object.values(stu1);<br/>print(values); // displays Jane Smith,1234,88,81,77</span></pre><p id="90b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果在不知道对象属性的情况下，要搜索某个对象中是否存储了特定的值，可能需要使用此方法。</p><h1 id="8f63" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对象. fromEntries</h1><p id="d5f4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">Object.fromEntries</code>方法接受一个键/值对列表，并返回一个包含这些键/值对的对象。以下是该方法的语法模板:</p><p id="e8ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> object Object.fromEntries(键/值对列表)；</em></p><p id="c938" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个演示<code class="fe mh mi mj mk b">Object.fromEntries</code>如何工作的程序:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="faab" class="mu lf it mk b gy mv mw l mx my">let point = [['x', 1], ['y', 2]];<br/>let pntObj = Object.fromEntries(point);<br/>print("x: " + pntObj.x + ", y: " + pntObj.y);</span></pre><p id="8b5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="3f05" class="mu lf it mk b gy mv mw l mx my">x: 1, y: 2</span></pre><p id="27fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当程序最终需要从一开始只是存储在列表中的数据创建一个对象时，这个方法很有用。</p><h1 id="7c55" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对象.冻结</h1><p id="bfd7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">Object.freeze</code>方法使对象成为只读的，这意味着您可以检索对象的属性值，但不能更改它们。以下是该方法的语法模板:</p><p id="51b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> Object.freeze(对象)；</em></p><p id="8ac6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的shell交互演示了<code class="fe mh mi mj mk b">Object.freeze</code>的工作方式:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="bc07" class="mu lf it mk b gy mv mw l mx my">js&gt; let point = {x: 1, y: 2};<br/>js&gt; point<br/>({x:1, y:2})<br/>js&gt; point.x = 2;<br/>2<br/>js&gt; point.y = 3;<br/>3<br/>js&gt; point<br/>({x:2, y:3})<br/>js&gt; Object.freeze(point);<br/>({x:2, y:3})<br/>js&gt; point.x = 4;<br/>4<br/>js&gt; point<br/>({x:2, y:3})<br/>js&gt; point.y = 5;<br/>5<br/>js&gt; point<br/>({x:2, y:3})</span></pre><p id="362c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦<code class="fe mh mi mj mk b">Object.freeze</code>方法被应用到一个对象，你就可以访问这些值，但是不能改变它们。您可以从shell输出中看到，尝试更改冻结对象的值不会导致错误，但是值不会更改。</p><h1 id="8be2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对象.定义属性</h1><p id="68f5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">Object.defineProperty</code>方法允许你在一个现有的对象上定义一个新的属性。以下是该方法的语法模板:</p><p id="816a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">object . define property(object，property-name，{value，[descriptor]})；</em></p><p id="e1d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中可选描述符以几种方式定义属性。有关所有可能的描述符的列表，请参见关于JavaScript对象的MDN参考指南。本文末尾有一个链接。</p><p id="1226" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个演示<code class="fe mh mi mj mk b">Object.defineProperty </code>方法如何工作的程序:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="a0f7" class="mu lf it mk b gy mv mw l mx my">let student = {name: "Jane Smith", id: 1234};<br/>print(`${student.name}, ${student.id}`);<br/>Object.defineProperty(student, "grades", {<br/>  value: [88, 71, 92],<br/>  writable: true<br/>});<br/>print();<br/>print(`${student.name}, ${student.id}\n${student.grades}`);</span></pre><p id="9cd5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="7359" class="mu lf it mk b gy mv mw l mx my">Jane Smith, 1234</span><span id="d96b" class="mu lf it mk b gy mz mw l mx my">Jane Smith, 1234<br/>88,71,92</span></pre><p id="e1cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我演示了如何通过将属性的<code class="fe mh mi mj mk b">writable</code>描述符设置为<code class="fe mh mi mj mk b">true</code>来设置其中一个描述符。</p><h1 id="daa6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">更多对象方法</h1><p id="db40" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我在本文中介绍的方法只是JavaScript中最常见和最有用的一些对象方法。要查看它们并了解它们能做什么，请访问MDN对象方法参考页面<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="21f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请将您的意见和建议发邮件至mmmcmillan1@att.net<a class="ae kf" href="mailto:mmmcmillan1@att.net" rel="noopener ugc nofollow" target="_blank">给我。如果你对我的在线编程课程感兴趣，请访问</a><a class="ae kf" href="https://learningcpp.teachable.com" rel="noopener ugc nofollow" target="_blank">https://learningcpp.teachable.com</a>。</p></div></div>    
</body>
</html>