<html>
<head>
<title>Protobufs Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Protobufs解释道</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/protobufs-explained-17ed6ba52076?source=collection_archive---------13-----------------------#2022-11-14">https://levelup.gitconnected.com/protobufs-explained-17ed6ba52076?source=collection_archive---------13-----------------------#2022-11-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3061" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本质上，协议缓冲区(也称为protobufs)允许将结构化数据编码成一个紧凑的字节流(0和1的序列)。假设您有一个带有属性score和name的player JavaScript对象:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="2160" class="ku kv iq kq b gy kw kx l ky kz">{<br/>  score : 25,<br/>  name: "Tom"<br/>}</span></pre><p id="4847" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果通过protobufs序列化，它将变成如下所示的字节流(每个字节用两个十六进制数字表示):</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="4229" class="ku kv iq kq b gy kw kx l ky kz">08 <!-- -->C8<!-- --> 01 12 03 54 6F 6D</span></pre><p id="f7f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，它总共有8个字节。</p><p id="43fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相比之下，用JSON序列化的相同对象(去掉空白)将产生26字节的数据。所以在这个特殊的例子中，protobufs变体大约比x3小。这种差异会因下划线数据的不同而有所不同，但总体上protobuf序列化版本总是比基于文本的版本小，并且在大规模系统上会产生巨大的差异。</p><p id="ade1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即使您已经使用protobufs有一段时间了，您也可能会对它们有一些疑问:</p><ul class=""><li id="89f3" class="la lb iq jp b jq jr ju jv jy lc kc ld kg le kk lf lg lh li bi translated">为什么我们需要原型定义，我们不能将结构化消息直接转换成二进制吗？</li><li id="8f68" class="la lb iq jp b jq lj ju lk jy ll kc lm kg ln kk lf lg lh li bi translated">为什么我们在原型定义中需要字段编号？</li><li id="3b3d" class="la lb iq jp b jq lj ju lk jy ll kc lm kg ln kk lf lg lh li bi translated">除了语言原生类型之外，为什么我们还需要为字段定义类型？</li><li id="30ce" class="la lb iq jp b jq lj ju lk jy ll kc lm kg ln kk lf lg lh li bi translated">本机类型、原型类型和连线类型之间的区别。</li><li id="757a" class="la lb iq jp b jq lj ju lk jy ll kc lm kg ln kk lf lg lh li bi">…</li></ul><h1 id="e397" class="lo kv iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">编码</h1><p id="46bd" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">要将上述对象编码成字节流，protobuf编码器需要两个输入，要编码的实际对象和它的proto定义。</p><blockquote class="mq mr ms"><p id="ecaf" class="jn jo mt jp b jq jr js jt ju jv jw jx mu jz ka kb mv kd ke kf mw kh ki kj kk ij bi translated">原型定义是用原型语言编写的。语言有两个版本，proto2和proto3，我们将讨论后者(尽管我们在这里使用的例子在proto2中是相同的)</p></blockquote><p id="3fc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是上述对象的原型定义</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="7c3f" class="ku kv iq kq b gy kw kx l ky kz">message Player {<br/>  <em class="mt">int32</em> score = 1;<br/>  <em class="mt">string</em> name = 2;<br/>}</span></pre><p id="830f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个关于编码的高级视图</p><figure class="kl km kn ko gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mx"><img src="../Images/7428262c7ecb6d1a2942548e016e9650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_lbhRnfNiTexdC2nXw5FiA.png"/></div></div></figure><p id="46ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">先说一下proto语言及其类型，按照我们的例子，结构化数据被定义为一个<code class="fe nf ng nh kq b">message</code>，单个字段有类型和字段号，“name”是类型<code class="fe nf ng nh kq b">string</code>，它的字段号是1；“年龄”是字段号为2的类型<code class="fe nf ng nh kq b">int32</code>。这种类型是与语言无关的，也就是说，<code class="fe nf ng nh kq b">message</code>类型可以翻译成JavaScript和POJO中的对象或Java中的类，<code class="fe nf ng nh kq b">int32</code>可以翻译成JavaScript中的<code class="fe nf ng nh kq b">number</code>，而在Java中它可以有更具体的<code class="fe nf ng nh kq b">int</code>类型。</p><h1 id="2a23" class="lo kv iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">3种打字系统</h1><p id="baa5" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">我们需要记住，编码/解码涉及到多种类型系统。</p><ul class=""><li id="50bd" class="la lb iq jp b jq jr ju jv jy lc kc ld kg le kk lf lg lh li bi translated"><strong class="jp ir">线类型</strong>——如何在字节流中写入内容</li><li id="4cec" class="la lb iq jp b jq lj ju lk jy ll kc lm kg ln kk lf lg lh li bi translated"><strong class="jp ir">proto types</strong>—proto definition语言中性类型，这是对protobufs编码器/解码器关于如何将语言本机类型转换为有线类型以及如何将有线类型转换为有线类型的指示。</li><li id="b951" class="la lb iq jp b jq lj ju lk jy ll kc lm kg ln kk lf lg lh li bi translated"><strong class="jp ir">语言本地类型</strong> —例如JavaScript对象、字符串、数字、布尔或Java类、字符串、字符、整数、浮点、布尔</li></ul><p id="1b81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要考虑的一个有趣点是，<strong class="jp ir">线类型</strong>和<strong class="jp ir">语言本机类型</strong>具有内存表示(即它们如何存储在0和1中)，而<strong class="jp ir">原型类型</strong>从不存在于内存中，它们在编码过程中用于将语言本机类型转换为线类型，在解码过程中用于执行相反的操作。</p><p id="5a08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们回顾我们的例子时，我们将很快看到所有三种类型系统在编码/解码过程中所扮演的角色，但在此之前，我们需要了解一些基础知识。我们将从变异体开始。</p><h2 id="232d" class="ku kv iq bd lp ni nj dn lt nk nl dp lx jy nm nn mb kc no np mf kg nq nr mj ns bi translated">Varints</h2><p id="bf14" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">变量是一种使用一个或多个字节序列化整数的方法。变量的字节长度随着整数变大而增加。因此，varint可能由一个或多个字节组成，每个字节中的最高有效位(MSB)称为延续位，当它被设置时，意味着至少还有一个字节要读取，每个字节中的其余7位专用于存储该值。你可以在7位中存储的最高无符号值是2⁷=128，所以任何高于这个值的值都需要另一个字节来容纳。让我们看一下例子，看看这实际上是如何工作的。</p><p id="3327" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">varint中编码的整数<code class="fe nf ng nh kq b">1</code>是<code class="fe nf ng nh kq b">00000001</code>为了计算出它，我们查看最高有效位，看到它是零，这告诉我们这个varint没有更多的字节可供读取，接下来我们丢弃最高有效位(因为它仅用于正确读取varint ),剩下7位实际整数值<code class="fe nf ng nh kq b">0000001</code>,它是10进制的<code class="fe nf ng nh kq b">1</code>。</p><p id="ede7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看如何计算出varint <code class="fe nf ng nh kq b">1010 1100 0000 0010</code>实际上保存的是整数值<code class="fe nf ng nh kq b">300</code>。我们查看第一个字节中的第一位，看到它已设置，这意味着还有另一个字节要读取，然后我们读取下一个字节的第一位，看到它没有设置，告诉我们已经到达末尾。接下来，我们删除延续位，剩下的是保存整数值的位组，我们反转它们，因为变量首先存储较不重要的组，这是我们在base2中的最后一个整数，然后我们可以使用位置表示法来查看它在base10中的样子。下图说明了这一点。</p><figure class="kl km kn ko gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nt"><img src="../Images/df4e2128dd6e84784b728e3e4bebb59c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JUbitpFyhVnLbbHbkdjPeA.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">理解变量</figcaption></figure><p id="45f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要更多关于varints的信息？看看<a class="ae ny" href="https://carlmastrangelo.com/blog/lets-make-a-varint" rel="noopener ugc nofollow" target="_blank"> Carl Mastrangelo </a>写的，里面涵盖了很多有趣的方面。</p><h2 id="eb47" class="ku kv iq bd lp ni nj dn lt nk nl dp lx jy nm nn mb kc no np mf kg nq nr mj ns bi translated">编码消息基础</h2><p id="627e" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">当消息被编码时，每个字段都被写成一个键值对，一个接一个。字节流中的每个键都是一个值为<code class="fe nf ng nh kq b">(field_number &lt;&lt; 3) | wire_type</code>的变量，即最后3位总是存储值的类型。<strong class="jp ir">不保证键值对的顺序。</strong></p><h2 id="dc0a" class="ku kv iq bd lp ni nj dn lt nk nl dp lx jy nm nn mb kc no np mf kg nq nr mj ns bi translated">读取第一个键值对</h2><p id="6d59" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">我建议我们假装是一个protobufs解码器，像它一样读取我们的示例字节流。除此之外，让我们想象一下，我们现在无法访问消息的proto定义，我们唯一知道的是字节流的样子和protobufs协议是如何工作的。</p><p id="1a67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，第一个字节是<code class="fe nf ng nh kq b">08</code>，根据我们已经说过的，我们希望它是一个字段键和wire_type。</p><figure class="kl km kn ko gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nz"><img src="../Images/48070997b47db353af24aed794f0cf31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZeldkYdMe9t4Q0FsK9ZYKA.jpeg"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">字段键</figcaption></figure><p id="850e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，我们知道字段编号为1，wire-type为0，对应于varint ( <a class="ae ny" href="https://developers.google.com/protocol-buffers/docs/encoding#types" rel="noopener ugc nofollow" target="_blank">由protobufs协议</a>定义)，基于此，我们可以继续读取字节流<code class="fe nf ng nh kq b">C8</code>中的下一个Varint，它的延续位<code class="fe nf ng nh kq b">11001000</code>已设置—我们还需要读取下一个字节<code class="fe nf ng nh kq b">01</code>，它的延续位<code class="fe nf ng nh kq b">00000001</code>未设置—我们已完成读取Varint。接下来，我们需要删除延续位并颠倒位组的顺序以得到<code class="fe nf ng nh kq b">0000001 1001000</code>(为了理解为什么我还没有将它转换为base10，请继续阅读)</p><figure class="kl km kn ko gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oa"><img src="../Images/e3a1f5edbf3fb51d247eeff02c05d240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8bDII7UmLyTW_p5mmAUZPg.png"/></div></div></figure><p id="50f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样我们就完成了读取第一个编码的键-值对，但这只是读取，原始对象属性的重建还需要几个步骤。</p><h2 id="651f" class="ku kv iq bd lp ni nj dn lt nk nl dp lx jy nm nn mb kc no np mf kg nq nr mj ns bi translated">Protobuf消息不是完全自描述的</h2><p id="e414" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">解码器不查看其原型定义就不能完全重构原始消息。让我们看看到目前为止我们已经收集了哪些信息。我们已经从字节流中读取了与该字段相关的任何内容，但是这些信息足以重建原始的对象属性吗？</p><ul class=""><li id="cb7d" class="la lb iq jp b jq jr ju jv jy lc kc ld kg le kk lf lg lh li bi translated">字段编号:1</li><li id="058c" class="la lb iq jp b jq lj ju lk jy ll kc lm kg ln kk lf lg lh li bi translated">电线类型:Varint</li><li id="14bc" class="la lb iq jp b jq lj ju lk jy ll kc lm kg ln kk lf lg lh li bi translated">数值:<code class="fe nf ng nh kq b">0000001 1001000</code></li></ul><p id="aa35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对，我们仍然需要弄清楚字段名以及如何解释二进制值。</p><p id="870a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了弄清楚为什么我们不查看字段的原型类型定义就不能解释值，考虑一下，原型类型<code class="fe nf ng nh kq b">int32</code>和<code class="fe nf ng nh kq b">sint32</code>都用varint wire-type编码。现在，值<code class="fe nf ng nh kq b">0000001 1001000</code>对于int32可能意味着200，对于sint32可能意味着100。如果你的银行账户里少了100美元，仅仅是因为有人不知道原型定义，你不会高兴的。还记得我们说过原型类型是编码器/解码器的一种指令吗？</p><p id="6704" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一点上，打开了查看原型定义的大门，从中我们可以看出，编号为1的字段被命名为“score ”,其原型类型是int32。</p><figure class="kl km kn ko gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi ob"><img src="../Images/dac33bad3fe67e4e18aa11ffeb7f3c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3-A4s-kw4VIg8Di5m5-_Aw.png"/></div></div></figure><p id="c1fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们在JavaScript环境中解码，类型告诉我们应该将值解释为普通变量(如果是sint32，我们需要一个额外的步骤将其解码为ZigZag signed integer编码，这将导致值100 ),它还会指示我们使用JS <code class="fe nf ng nh kq b">number</code>类型作为结果类型。因此，我们最终将属性值为200的属性score赋给目标对象。</p><p id="e64f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于意识来说，这是这个特殊领域的类型</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="eba8" class="ku kv iq kq b gy kw kx l ky kz">+------------+------------+-----------+<br/>| JavaScript | proto type | wire-type |<br/>+------------+------------+-----------+<br/>| number     | int32      | Varint    |<br/>+------------+------------+-----------+</span></pre><p id="eed2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编码器使用原型定义来:</p><ul class=""><li id="b137" class="la lb iq jp b jq jr ju jv jy lc kc ld kg le kk lf lg lh li bi translated">验证输入，例如，<code class="fe nf ng nh kq b">number</code>类型的JavaScript值符合proto <code class="fe nf ng nh kq b">int32</code>，但<code class="fe nf ng nh kq b">string</code>不符合。</li><li id="5bb5" class="la lb iq jp b jq lj ju lk jy ll kc lm kg ln kk lf lg lh li bi translated">确定目标焊线类型，例如<code class="fe nf ng nh kq b">Varint</code>代表<code class="fe nf ng nh kq b">int32</code></li><li id="8321" class="la lb iq jp b jq lj ju lk jy ll kc lm kg ln kk lf lg lh li bi translated">包括字段号，以使解码器能够识别字段</li></ul><p id="7cd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解码器使用它们来:</p><ul class=""><li id="1e00" class="la lb iq jp b jq jr ju jv jy lc kc ld kg le kk lf lg lh li bi translated">根据字段编号获取字段名称</li><li id="96d8" class="la lb iq jp b jq lj ju lk jy ll kc lm kg ln kk lf lg lh li bi translated">了解如何解码线类型，并以适当的语言原生类型加载它们。</li></ul><figure class="kl km kn ko gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mx"><img src="../Images/87aba6498a4caa9ec0843b829888b450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W39UEX6suj2XffaR0AOMAQ.png"/></div></div></figure><p id="50f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于协议缓冲区还有很多要讨论的，但是现在让我们结束对字节流的研究，也了解长度分隔的字段是如何编码的。</p><p id="de16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在第四个字节<code class="fe nf ng nh kq b">12</code>，也就是<code class="fe nf ng nh kq b">00010010</code>，所以我们得到了线类型<code class="fe nf ng nh kq b">010</code> = 2长度分隔，字段编号<code class="fe nf ng nh kq b">0010</code> =2。这里的类型告诉我们，我们应该期待一个表示值的长度的变量，下一个字节<code class="fe nf ng nh kq b">03</code>是二进制的<code class="fe nf ng nh kq b">00000011</code>，它是一个等于3的变量int，我们可以继续读取值<code class="fe nf ng nh kq b">54 6F 6D</code>的下3个字节。从proto我们得到字段名“name”，字段类型是<code class="fe nf ng nh kq b">string</code>，字符串编码为UTF8，当用UTF8解码值时，我们得到“Tom”。</p><figure class="kl km kn ko gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oc"><img src="../Images/482216c44a6c66210db5d1cdb2f9b853.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m0b0svUsRWpAnHzL7cEX4A.png"/></div></div></figure><p id="ec7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于长度分隔的字段，需要注意的主要一点是，它的长度变量位于键和值之间。</p><p id="8ea0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">祝你玩得愉快！👽</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><h1 id="6a1a" class="lo kv iq bd lp lq ok ls lt lu ol lw lx ly om ma mb mc on me mf mg oo mi mj mk bi translated">分级编码</h1><p id="e8c3" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="3939" class="la lb iq jp b jq jr ju jv jy lc kc ld kg le kk lf lg lh li bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="0d69" class="la lb iq jp b jq lj ju lk jy ll kc lm kg ln kk lf lg lh li bi translated">📰查看<a class="ae ny" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>中的更多内容</li><li id="cdfe" class="la lb iq jp b jq lj ju lk jy ll kc lm kg ln kk lf lg lh li bi translated">🔔关注我们:<a class="ae ny" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae ny" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae ny" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="fb2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀👉<a class="ae ny" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>