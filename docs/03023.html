<html>
<head>
<title>SwiftUI — Instagram Story Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI — Instagram故事教程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/swiftui-instagram-story-tutorial-37f80711544?source=collection_archive---------10-----------------------#2020-04-15">https://levelup.gitconnected.com/swiftui-instagram-story-tutorial-37f80711544?source=collection_archive---------10-----------------------#2020-04-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9768" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让-马克·布里安内</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/e4ed5be03a277a8e79cff0c0bb83ede4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Dap2nPtGXjuN909R3ZWu0Q.gif"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">最终产品</figcaption></figure><p id="1f88" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里是最终产品的外观。很多用过Instagram的人都会很熟悉。最棒的是，这并不一定要严格适用于分享社交媒体照片。您可以使用这种类型的视图来展示任何东西。它可以是产品、新闻文章或其他照片。我们开始吧！</p><blockquote class="lq lr ls"><p id="ffd5" class="ku kv lt kw b kx ky ju kz la lb jx lc lu le lf lg lv li lj lk lw lm ln lo lp im bi translated">在开始之前，请考虑使用这个<a class="ae lx" href="https://trailingclosure.com/signup/" rel="noopener ugc nofollow" target="_blank">链接</a>订阅，如果你没有在<a class="ae lx" href="https://trailingclosure.com/" rel="noopener ugc nofollow" target="_blank">TrailingClosure.com</a>上阅读这篇文章，请随时来看看我们！</p></blockquote><h2 id="3cc3" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">入门指南</h2><p id="b88c" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">如果你在Xcode中跟随，那么你将需要这个项目的一些照片。我从Unsplash的自然版块收集了一些来用于本教程。你可以在这里下载它们<a class="ae lx" href="https://firebasestorage.googleapis.com/v0/b/trailingclosure-website.appspot.com/o/NaturePhotos.zip?alt=media&amp;token=b5f4c394-31c1-484e-bb32-cd08633ac3cb" rel="noopener ugc nofollow" target="_blank"/></p><p id="27de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦有了这些，启动Xcode，创建一个新项目，并将照片添加到<code class="fe mw mx my mz b">Assets.xcassets</code>文件夹中。</p><h2 id="fec5" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">创建<code class="fe mw mx my mz b">LoadingRectangle</code>视图</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/b041aecdf9615a13d75a1fdd1fddda17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*qy82eMAGueylNWa_.gif"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">每个单独的部分是一个装载矩形</figcaption></figure><p id="107b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mw mx my mz b">LoadingRectangle</code>将用于显示每张照片的时间进程。它由两个<code class="fe mw mx my mz b">Rectangle</code>视图组成，一个在另一个之上。顶部的<code class="fe mw mx my mz b">Rectangle</code>随着时间的推移增加它的宽度来覆盖另一个。</p><ol class=""><li id="ad6a" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated">首先创建一个新的SwiftUI视图，名为<code class="fe mw mx my mz b">LoadingRectangle</code>。</li><li id="3b09" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">移除为您生成的<code class="fe mw mx my mz b">Text</code>，并用<code class="fe mw mx my mz b">GeometryReader</code>替换它。这会给你一个参考，我们马上要用到的框架。</li><li id="47c4" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">接下来为了堆叠两个矩形，在<code class="fe mw mx my mz b">GeometryReader</code>中添加一个<code class="fe mw mx my mz b">ZStack</code>，并放置在两个<code class="fe mw mx my mz b">Rectangle</code>视图中。确保你给<code class="fe mw mx my mz b">ZStack</code>一个<code class="fe mw mx my mz b">.leading</code>对齐，这样我们的顶部<code class="fe mw mx my mz b">Rectangle</code>将从左手边开始生长。</li></ol><p id="8332" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是目前为止您应该有的内容:</p><pre class="kj kk kl km gt no mz np nq aw nr bi"><span id="5699" class="ly lz it mz b gy ns nt l nu nv">var body: some View {<br/>    GeometryReader { geometry in<br/>        ZStack(alignment: .leading) {<br/>            Rectangle()<br/>            Rectangle()<br/>        }<br/>    }<br/>}</span></pre><p id="2558" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们需要修改顶部的<code class="fe mw mx my mz b">Rectangle</code>,这样它会随着时间改变大小。为此，您需要声明<code class="fe mw mx my mz b">progress</code>变量。</p><pre class="kj kk kl km gt no mz np nq aw nr bi"><span id="5b94" class="ly lz it mz b gy ns nt l nu nv">var progress: CGFloat</span></pre><p id="4aab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后修改第二个<code class="fe mw mx my mz b">Rectangle</code>，使其宽度根据<code class="fe mw mx my mz b">progress</code>变量变化。</p><pre class="kj kk kl km gt no mz np nq aw nr bi"><span id="ea5f" class="ly lz it mz b gy ns nt l nu nv">var body: some View {<br/>    GeometryReader { geometry in<br/>        ZStack(alignment: .leading) {<br/>            Rectangle()<br/>            Rectangle()<br/>                .frame(width: geometry.size.width * self.progress, height: nil, alignment: .leading)<br/>        }<br/>    }<br/>}</span></pre><p id="89b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，你可以根据自己的喜好设计矩形的样式。我已经修改了他们的圆角半径和颜色。最终的<code class="fe mw mx my mz b">body</code>代码如下。</p><pre class="kj kk kl km gt no mz np nq aw nr bi"><span id="6f51" class="ly lz it mz b gy ns nt l nu nv">var body: some View {<br/>    GeometryReader { geometry in<br/>        ZStack(alignment: .leading) {<br/>            Rectangle()<br/>                .foregroundColor(Color.white.opacity(0.3))<br/>                .cornerRadius(5)<br/><br/>            Rectangle()<br/>                .frame(width: geometry.size.width * self.progress, height: nil, alignment: .leading)<br/>                .foregroundColor(Color.white.opacity(0.9))<br/>                .cornerRadius(5)<br/>        }<br/>    }<br/>}</span></pre><h2 id="13d6" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">组合图像和<code class="fe mw mx my mz b">LoadingRectangle</code></h2><p id="390b" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">让我们转到<code class="fe mw mx my mz b">ContentView.swift</code>。Xcode在您制作项目时生成了这个文件。</p><p id="12af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先在顶部声明一个图像名称数组。这些应该是我们之前添加的照片的名称，并且将是我们在“故事”中显示的图像。</p><pre class="kj kk kl km gt no mz np nq aw nr bi"><span id="c2eb" class="ly lz it mz b gy ns nt l nu nv">var imageNames:[String] = ["image01","image02","image03","image04","image05","image06","image07"]</span></pre><p id="53db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类似于我们在<code class="fe mw mx my mz b">LoadingRectangle</code>中所做的，用包裹在<code class="fe mw mx my mz b">GeometryReader</code>中的<code class="fe mw mx my mz b">ZStack</code>替换<code class="fe mw mx my mz b">Text</code>，并将<code class="fe mw mx my mz b">Image</code>和水平堆叠的<code class="fe mw mx my mz b">LoadingRectangle</code>放入其中。</p><pre class="kj kk kl km gt no mz np nq aw nr bi"><span id="87c4" class="ly lz it mz b gy ns nt l nu nv">var body: some View {<br/>    GeometryReader { geometry in<br/>        ZStack(alignment: .top) {<br/>            Image(self.imageNames[0])<br/>                .resizable()<br/>                .edgesIgnoringSafeArea(.all)<br/>                .scaledToFill()<br/>                .frame(width: geometry.size.width, height: nil, alignment: .center)<br/>                .animation(.none)<br/>            HStack(alignment: .center, spacing: 4) {<br/>                ForEach(self.imageNames.indices) { x in<br/>                    LoadingRectangle(progress: 1.0)<br/>                        .frame(width: nil, height: 2, alignment: .leading)<br/>                        .animation(.linear)<br/>                }<br/>            }.padding()<br/>        }<br/>    }<br/>}</span></pre><p id="ecf7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">出于时间的原因，我已经添加了一些东西，但是请随意回去试验一些设置来感受一下我所做的(特别是图像的修改器和<code class="fe mw mx my mz b">LoadingRectangle</code>的框架)</p><p id="26b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">目前，我们已经在上面的代码中添加了两个占位符。</p><ol class=""><li id="afe4" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated">对于当前显示的图像。<code class="fe mw mx my mz b">Image(self.imageNames[0])</code></li><li id="27a7" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">查看每个<code class="fe mw mx my mz b">LoadingRectangle</code>的进度。<code class="fe mw mx my mz b">LoadingRectangle(progress: 1.0)</code></li></ol><p id="6517" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了前进，我们需要创建我们的<code class="fe mw mx my mz b">StoryTimer</code>，它控制照片间的移动，并将其进度反馈给<code class="fe mw mx my mz b">LoadingRectangle</code>。</p><h2 id="c137" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">创建<code class="fe mw mx my mz b">StoryTimer</code></h2><p id="520a" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">我们需要创建的最后一个部分是一个计时器。这将是一个ObservableObject，它向我们的其余部分发布它的<code class="fe mw mx my mz b">progress</code>变量。</p><pre class="kj kk kl km gt no mz np nq aw nr bi"><span id="ccf5" class="ly lz it mz b gy ns nt l nu nv">class StoryTimer: ObservableObject {<br/>    <br/>    @Published var progress: Double<br/>    private var interval: TimeInterval<br/>    private var max: Int<br/>    private let publisher: Timer.TimerPublisher<br/>    private var cancellable: Cancellable?<br/>    <br/>    <br/>    init(items: Int, interval: TimeInterval) {<br/>        self.max = items<br/>        self.progress = 0<br/>        self.interval = interval<br/>        self.publisher = Timer.publish(every: 0.1, on: .main, in: .default)<br/>    }<br/>    <br/>    func start() {<br/>        self.cancellable = self.publisher.autoconnect().sink(receiveValue: {  _ in<br/>            var newProgress = self.progress + (0.1 / self.interval)<br/>            if Int(newProgress) &gt;= self.max { newProgress = 0 }<br/>            self.progress = newProgress<br/>        })<br/>    }<br/>}</span></pre><p id="7ad4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看看<code class="fe mw mx my mz b">StoryTimer</code>的初始化器。它接受我们的“故事”中的项目数量，以及我们应该显示每个项目多长时间的一个<code class="fe mw mx my mz b">TimeInterval</code>。</p><p id="e4c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们的<code class="fe mw mx my mz b">ContentView</code>出现时，我们将调用<code class="fe mw mx my mz b">start()</code>函数，开始从<code class="fe mw mx my mz b">TimerPublisher</code>接收值。每次收到一个新值，我们就更新由我们的<code class="fe mw mx my mz b">StoryTimer</code>类发布的<code class="fe mw mx my mz b">progress</code>变量。这反过来触发我们的<code class="fe mw mx my mz b">ContentView</code>用正确的进度更新我们的<code class="fe mw mx my mz b">LoadingRectangle</code>,并在屏幕上显示正确的图像。</p><h2 id="86e7" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">删除<code class="fe mw mx my mz b">ContentView</code>中的占位符</h2><p id="c229" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">首先在<code class="fe mw mx my mz b">ContentView</code>的顶部创建一个<code class="fe mw mx my mz b">StoryTimer</code>的实例。</p><pre class="kj kk kl km gt no mz np nq aw nr bi"><span id="1281" class="ly lz it mz b gy ns nt l nu nv">@ObservedObject var storyTimer: StoryTimer = StoryTimer(items: 7, interval: 3.0)</span></pre><p id="f5e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后用以下代码替换声明<code class="fe mw mx my mz b">Image</code>的那一行:</p><pre class="kj kk kl km gt no mz np nq aw nr bi"><span id="604a" class="ly lz it mz b gy ns nt l nu nv">Image(self.imageNames[Int(self.storyTimer.progress)])</span></pre><p id="dbd4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样做的目的是从<code class="fe mw mx my mz b">StoryTimer</code>获取进度，并通过其索引选择相应的图像。</p><p id="2b33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要更新的第二个占位符是关于我们的<code class="fe mw mx my mz b">LoadingRectangle</code>进度的占位符。将其实例化替换为以下内容:</p><pre class="kj kk kl km gt no mz np nq aw nr bi"><span id="9d1b" class="ly lz it mz b gy ns nt l nu nv">LoadingRectangle(progress: min( max( (CGFloat(self.storyTimer.progress) - CGFloat(x)), 0.0) , 1.0) )</span></pre><p id="3be2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这看起来像是发生了很多事情，但实际上只是一些简单的数学。<code class="fe mw mx my mz b">self.storyTimer.progress</code>数值范围从<code class="fe mw mx my mz b">0</code>到<code class="fe mw mx my mz b">N</code>(要显示的照片数量)。这里<code class="fe mw mx my mz b">Loadingrectangle</code>需要一个从<code class="fe mw mx my mz b">0.0</code>到<code class="fe mw mx my mz b">1.0</code>的进度值。我们正在根据每个<code class="fe mw mx my mz b">LoadingRectangle</code>(本例中为<code class="fe mw mx my mz b">x</code>)的索引进行转换</p><p id="5c18" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">启动定时器</strong> <br/>最后，在<code class="fe mw mx my mz b">ContentView.swift</code>中的<code class="fe mw mx my mz b">ZStack</code>底部，当视图出现时需要启动<code class="fe mw mx my mz b">StoryTimer</code>。</p><pre class="kj kk kl km gt no mz np nq aw nr bi"><span id="4710" class="ly lz it mz b gy ns nt l nu nv">var body: some View {<br/>    GeometryReader { geometry in<br/>        ZStack(alignment: .top) {<br/>            /* Image and LoadingRectangles Here */<br/>        }<br/>        .onAppear { self.storyTimer.start() }<br/>        .onDisappear {self.storyTimer.cancel() }<br/><br/>    }<br/>}</span></pre><p id="1719" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果一切顺利，你应该能够点击运行按钮，并得到你所看到的如下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/975e8dc57a2827b3cef98db55b6e107d.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/0*k_5GJ4Kweq0WnNEs.gif"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">成品</figcaption></figure><h2 id="6e06" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">额外学分</h2><p id="29d2" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">如果你想多走一步，你可以在屏幕的每一半实现<code class="fe mw mx my mz b">TapGesture</code> s，像在Instagram应用程序中一样循环浏览照片。</p><h2 id="ae5d" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">在<code class="fe mw mx my mz b">ContentView.swift</code>中增加<code class="fe mw mx my mz b">TapGesture</code></h2><p id="6f00" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">在主<code class="fe mw mx my mz b">ContentView</code>体内<code class="fe mw mx my mz b">ZStack</code>底部增加以下<code class="fe mw mx my mz b">HStack</code>。</p><pre class="kj kk kl km gt no mz np nq aw nr bi"><span id="beb9" class="ly lz it mz b gy ns nt l nu nv">HStack(alignment: .center, spacing: 0) {<br/>    Rectangle()<br/>        .foregroundColor(.clear)<br/>        .contentShape(Rectangle())<br/>        .onTapGesture {<br/>            self.storyTimer.advance(by: -1)<br/>    }<br/>    Rectangle()<br/>        .foregroundColor(.clear)<br/>        .contentShape(Rectangle())<br/>        .onTapGesture {<br/>            self.storyTimer.advance(by: 1)<br/>    }<br/>}</span></pre><h2 id="0259" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">修改<code class="fe mw mx my mz b">StoryTimer</code></h2><p id="a5c9" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">接下来我们需要给<code class="fe mw mx my mz b">StoryTimer</code>类添加一个函数，允许我们增加或减少它的进度。我们想看下一张照片，但不要跳过太远，切入它的放映时间。下面的函数计算当前项目索引，然后推进进度(或者，如果您提供负数，则减去进度)。</p><pre class="kj kk kl km gt no mz np nq aw nr bi"><span id="7a74" class="ly lz it mz b gy ns nt l nu nv">func advance(by number: Int) {<br/>    let newProgress = max((Int(self.progress) + number) % self.max , 0)<br/>    self.progress = Double(newProgress)<br/>}</span></pre><h2 id="69a6" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">全部完成</h2><p id="3600" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">再试一次！尝试从屏幕的左侧和右侧轻按，以查看照片的前后移动。最好的部分是，<code class="fe mw mx my mz b">LoadingRectangle</code>仍然无缝动画。</p><h2 id="3dbb" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">支持未来的帖子</h2><p id="adfb" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">如果你喜欢这篇文章，请考虑使用这个<a class="ae lx" href="https://trailingclosure.com/signup/" rel="noopener ugc nofollow" target="_blank">链接</a>订阅我的网站，如果你没有在【TrailingClosure.com】的上阅读这篇文章，请随时来看看我们！</p></div></div>    
</body>
</html>