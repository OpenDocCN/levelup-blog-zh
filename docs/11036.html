<html>
<head>
<title>Semantic Release Automation with Gradle using Nyx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用倪克斯的Gradle语义发布自动化</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/semantic-release-automation-with-gradle-using-nyx-ba345235a365?source=collection_archive---------2-----------------------#2022-02-09">https://levelup.gitconnected.com/semantic-release-automation-with-gradle-using-nyx-ba345235a365?source=collection_archive---------2-----------------------#2022-02-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="03d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你像我一样，你可能不想重复你自己，你喜欢自动化事情，这样你就可以专注于重要的事情。虽然有大量的工具和方法可以帮助你完成软件生命周期管理中如此多的常见任务，但是发布自动化是它们不足的一个领域。</p><p id="74d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设您正在维护一个Git存储库(可选地托管在<a class="ae kl" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>、<a class="ae kl" href="https://gitlab.com/" rel="noopener ugc nofollow" target="_blank"> GitLab </a>或其他服务上)，并且已经有了CI/CD(使用<a class="ae kl" href="https://docs.github.com/en/free-pro-team@latest/actions/guides/about-continuous-integration" rel="noopener ugc nofollow" target="_blank"> GitHub动作</a>、<a class="ae kl" href="https://docs.gitlab.com/ee/ci/" rel="noopener ugc nofollow" target="_blank"> GitLab CI </a>、<a class="ae kl" href="https://www.jenkins.io/" rel="noopener ugc nofollow" target="_blank"> Jenkins </a>、<a class="ae kl" href="https://www.jetbrains.com/teamcity/" rel="noopener ugc nofollow" target="_blank"> TeamCity </a>、<a class="ae kl" href="https://www.atlassian.com/software/bamboo" rel="noopener ugc nofollow" target="_blank"> Bamboo </a>、<a class="ae kl" href="https://circleci.com/" rel="noopener ugc nofollow" target="_blank"> CircleCI </a>等)。如果你是一个最佳实践忍者，你可能也已经定义了一个适合你的工作流的分支模型，建立了<a class="ae kl" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank"> SemVer </a>作为你的版本化方案，也采用了一个提交消息约定，比如<a class="ae kl" href="https://www.conventionalcommits.org/" rel="noopener ugc nofollow" target="_blank">常规提交</a>或者甚至定义了你自己的。</p><p id="9389" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您离发布管理天堂只有一步之遥了！总体策略已经很好地定义了，但是当涉及到管理分支、标签、拉/合并请求、变更日志和发布时，你要么手动地做，绞尽脑汁试图不留下任何东西，要么自动地用你缝合在一起的几个工具，用一些定制代码来填补空白。</p><p id="6f8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">倪克斯是一个非常灵活的工具，可以让你把所有的东西放在一起，这样你就可以在自动驾驶上设置发布管理。你可以在GitHub上的这里找到<a class="ae kl" href="https://github.com/mooltiverse/nyx" rel="noopener ugc nofollow" target="_blank">。在这篇文章中，我将向你展示如何在几分钟内开始，不管你的项目堆栈，规模和复杂性。</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/7d32affbce0c5afc9fc408047bea7d2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*plMYiXxLeJto-UpJ"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">多梅尼科·洛亚在<a class="ae kl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="9aa2" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">背景和免责声明</h1><p id="f013" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">几年前，我在GitLab  上给<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/semantic-versioning-and-release-automation-on-gitlab-9ba16af0c21">写过一篇关于<em class="mf">语义版本化和发布自动化的类似文章。这个解决方案是基于<a class="ae kl" href="https://github.com/semantic-release/semantic-release" rel="noopener ugc nofollow" target="_blank"> <em class="mf">语义发布</em> </a>的，因为当时它是我发现的最有效的工具。如果您正在进行节点项目，这可能仍然是您的最佳选择。然而，在寻找一个更加便携和简化的解决方案时，它有一些我无法用其他任何方法克服的缺点。</em></a></p><p id="b421" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我决定发布一个全新的工具，它可以大规模用于任何堆栈，易于上手，功能强大，足以应对最微妙的边缘情况。这就是了！所以，如果我是第一个倪克斯迷，不要感到惊讶！</p><p id="5ddf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还写了另一篇帖子，就像这篇关于倪克斯的帖子一样，但是使用了CLI和/或Docker镜像，所以如果你打算使用命令行或Docker化环境，你可能应该直接跳到那篇帖子。</p><p id="d1ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本指南假设:</p><ul class=""><li id="c135" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated"><a class="ae kl" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本化(SemVer) </a>用于版本化。在撰写本文时，这是倪克斯唯一支持的方案，但是将来的版本可能也会支持Maven和定制方案</li><li id="17a3" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">你已经对<strong class="jp ir">提交消息约定</strong>有了基本的了解，这是用于将结构化信息嵌入提交消息并自动读取它们的模式。如果您不这样做，那么<a class="ae kl" href="https://www.conventionalcommits.org/" rel="noopener ugc nofollow" target="_blank">常规提交</a>(也称为<em class="mf">角度约定</em>)是一个很好的起点，它是开箱即用的，尽管您甚至可以自由配置自定义约定</li><li id="ba88" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">你知道什么是分支模型。如果你没有，你可以从<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/best-practice/branching-models/" rel="noopener ugc nofollow" target="_blank">这里</a>开始，这里也涵盖了标准模型，如<a class="ae kl" href="https://nvie.com/posts/a-successful-git-branching-model/" rel="noopener ugc nofollow" target="_blank"> GitFlow </a>、<a class="ae kl" href="https://www.endoflineblog.com/oneflow-a-git-branching-model-and-workflow" rel="noopener ugc nofollow" target="_blank"> OneFlow </a>或<a class="ae kl" href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/github-flow" rel="noopener ugc nofollow" target="_blank"> GitHubFlow </a>和<a class="ae kl" href="https://docs.gitlab.com/ee/topics/gitlab_flow.html" rel="noopener ugc nofollow" target="_blank"> GitLabFlow </a></li><li id="e0f2" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">你对<a class="ae kl" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> Git </a>、<a class="ae kl" href="https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell" rel="noopener ugc nofollow" target="_blank">branch</a>和<a class="ae kl" href="https://git-scm.com/book/en/v2/Git-Basics-Tagging" rel="noopener ugc nofollow" target="_blank">tag</a>很有信心。您可以选择适当的CI/CD环境，虽然倪克斯并不受限于任何环境，但是提供了关于<a class="ae kl" href="https://docs.github.com/en/free-pro-team@latest/actions/guides/about-continuous-integration" rel="noopener ugc nofollow" target="_blank"> GitHub动作</a>和<a class="ae kl" href="https://docs.gitlab.com/ee/ci/" rel="noopener ugc nofollow" target="_blank"> GitLab CI </a>的示例</li><li id="a832" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">Gradle是这篇文章中唯一使用的构建工具，而倪克斯可以在任何平台和任何其他工具上使用</li></ul></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="f411" class="lc ld iq bd le lf nb lh li lj nc ll lm ln nd lp lq lr ne lt lu lv nf lx ly lz bi translated">倪克斯是如何运作的</h1><p id="639d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">倪克斯<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/how-nyx-works/" rel="noopener ugc nofollow" target="_blank">将整个发布过程分成步骤</a>，你可以一起运行，也可以通过插件提供的不同任务一个接一个地运行。其步骤是:<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/how-nyx-works/#infer" rel="noopener ugc nofollow" target="_blank"> <em class="mf">推断</em> </a>，<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/how-nyx-works/#make" rel="noopener ugc nofollow" target="_blank"> <em class="mf">制作</em> </a>，<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/how-nyx-works/#mark" rel="noopener ugc nofollow" target="_blank"> <em class="mf">标记</em> </a>，<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/how-nyx-works/#publish" rel="noopener ugc nofollow" target="_blank"> <em class="mf">发布</em> </a>，它们各自的任务名称分别是<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/usage/#nyxinfer" rel="noopener ugc nofollow" target="_blank"><em class="mf"/></a>，<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/usage/#nyxmake" rel="noopener ugc nofollow" target="_blank"> <em class="mf"> nyxMake </em> </a>，<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/usage/#nyxmark" rel="noopener ugc nofollow" target="_blank"> <em class="mf"> nyxMark </em> </a>和<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/usage/#nyxpublish" rel="noopener ugc nofollow" target="_blank"> <em class="mf">所有步骤都是可选的，但是它们有连锁依赖关系:<em class="mf">发布&gt;标记&gt;制作&gt;推断</em>，所以你可以单独运行<em class="mf">推断</em>但是<em class="mf">制作</em>依赖于<em class="mf">推断，标记</em>依赖于<em class="mf">制作</em>等等。</em></a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/ba2f43aef8c9c8f4043aaf800e948060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*Th86c2XBdlA-q1Jct3xeoA.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">倪克斯台阶</figcaption></figure><p id="7b67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mf">推断</em>是第一步，也是最重要的一步，它读取Git提交历史来设置项目<strong class="jp ir">版本</strong>，该版本可能是新版本(如果有<strong class="jp ir">重大</strong>变更要发布)或之前的版本(如果没有遇到重大变更)。换句话说:你总是有正确的<strong class="jp ir">版本</strong>设置，不管是以前的还是新的。先前的<strong class="jp ir">版本</strong>从Git标签中读取，如果必须生成新的版本，则通过<strong class="jp ir">在先前版本上碰撞</strong>正确的标识符来计算。结果是将<a class="ae kl" href="https://docs.gradle.org/current/userguide/writing_build_scripts.html#sec:standard_project_properties" rel="noopener ugc nofollow" target="_blank">项目<strong class="jp ir">版本</strong>属性</a>设置为正确的值。<em class="mf">推断</em>到此为止，不采取进一步的行动，但是你的Gradle脚本现在可以使用项目<strong class="jp ir">版本</strong>用于任何目的。</p><p id="b517" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值得注意的是，许多其他工具只在整个过程结束时才给你<strong class="jp ir">版本</strong>，从构建脚本的角度来看，它基本上是无用的(甚至在工件已经被推送到存储库之后)，所以你不能截取<strong class="jp ir">版本</strong>供你的定制任务使用(例如，将它嵌入到文档或其他文件中)。使用这些工具，你甚至不能在中间添加任何验证，因此一旦你运行发布任务，你就没有其他机会来控制将要发布的内容。有些工具甚至更糟，因为你甚至不知道他们是否会给你一个<strong class="jp ir">版本</strong>供你使用(比如当没有新的变化时)，所以你最终运行它们两次:第一次作为<em class="mf">抽测运行</em>，只是为了看看是否有新版本可用，第二次(你需要有条件地运行)是为了实际使用它。</p><p id="eac0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，有了倪克斯，你可以自由地运行<em class="mf">推断</em>，在任何你需要的地方使用<strong class="jp ir">版本</strong>号，甚至使用它的内部发现来定制整个过程。<strong class="jp ir">版本</strong>属性是Gradle脚本在全球范围内使用的<a class="ae kl" href="https://docs.gradle.org/current/userguide/writing_build_scripts.html#sec:standard_project_properties" rel="noopener ugc nofollow" target="_blank">标准</a>属性，因此，一旦它被设置，你可以确保整个项目始终使用相同的<strong class="jp ir">版本</strong>。你<strong class="jp ir">总是有一个版本</strong>，它可能是以前的版本，也可能是新的版本(你可以通过<code class="fe nh ni nj nk b"><a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/state-reference/global-attributes/#new-version" rel="noopener ugc nofollow" target="_blank">nyxState.newVersion</a></code>属性来判断，下面会详细介绍)。即使你不需要发布一个<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/state-reference/global-attributes/#new-release" rel="noopener ugc nofollow" target="_blank">新版本</a>，你也有一个可以在内部使用的版本(例如用于测试)。</p><p id="167a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mf"> Make </em>是使用来自release范围的信息，通过渲染一个可定制的<a class="ae kl" href="https://handlebarsjs.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">手柄</strong> </a> <strong class="jp ir"> </strong>模板，生成一个<strong class="jp ir"> changelog </strong>的步骤。</p><p id="d6a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mf">标记</em>可以有选择地<strong class="jp ir">提交</strong>未决的变更(即，如果你想在密封它之前将changelog文件添加到你的发布版本中)，<strong class="jp ir">用新的发布版本名称标记</strong>最新的提交，<strong class="jp ir">将</strong>变更推送到远程存储库。</p><p id="e774" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mf">发布</em>可以最终发布新版本给远程服务(即<a class="ae kl" href="https://docs.github.com/en/github/administering-a-repository/about-releases" rel="noopener ugc nofollow" target="_blank"> GitHub发布</a>，<a class="ae kl" href="https://docs.gitlab.com/ee/user/project/releases/" rel="noopener ugc nofollow" target="_blank"> GitLab发布</a>)使其对观众可用。<em class="mf"> Make </em>生成的changelog也可以作为发布<strong class="jp ir">描述</strong>。</p><p id="941e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这些精细的任务，您可以构建任何<strong class="jp ir">增量</strong>发布过程，而不会失去一致性，即使暂停过程并在以后的任何时间恢复它。在构建脚本的最开始运行<em class="mf">推断</em>之后，您可以将<strong class="jp ir">版本</strong>和其他发现用于任何其他任务，然后，如果您愿意，您可以使用<em class="mf">标记</em>和<em class="mf">发布</em>来完成发布。</p><p id="94c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这要归功于倪克斯揭露的另一个非常强大的特性:状态对象。<strong class="jp ir">状态</strong>(在Gradle scripts 中也作为<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/usage/#accessing-the-nyx-state-extra-project-property-from-build-scripts" rel="noopener ugc nofollow" target="_blank">额外的项目属性可用)是倪克斯存储其所有内部信息的地方，也可供您阅读其关于发布范围和解析配置值的详细信息。由上述所有任务创建和更新<strong class="jp ir">状态</strong>。</a></p><h1 id="182d" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">开始使用Gradle插件</h1><p id="edc3" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">虽然倪克斯是可移植的，可以在任何平台上使用，但Gradle从一开始就被认为是一等公民，它的<a class="ae kl" href="https://plugins.gradle.org/plugin/com.mooltiverse.oss.nyx" rel="noopener ugc nofollow" target="_blank">插件</a>已经首次发布。</p><p id="2590" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以将该插件作为<a class="ae kl" href="https://docs.gradle.org/current/userguide/plugins.html#sec:types_of_plugins" rel="noopener ugc nofollow" target="_blank"> <em class="mf">常规项目</em>之一或作为<em class="mf">设置</em>插件</a>来应用。在这个例子中，我们将它用作<em class="mf">设置</em>插件，这是<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/usage/#apply-the-plugin" rel="noopener ugc nofollow" target="_blank">强烈建议</a>使用它的方式。</p><p id="51c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在你的项目的根文件夹中创建一个新的<code class="fe nh ni nj nk b">settings.gradle</code>文件或者编辑现有的文件，然后用这个<a class="ae kl" href="https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block" rel="noopener ugc nofollow" target="_blank"> DSL </a>应用插件(用最新的<a class="ae kl" href="https://github.com/mooltiverse/nyx/releases" rel="noopener ugc nofollow" target="_blank">版本</a>替换<code class="fe nh ni nj nk b">"1.0.0"</code></p><pre class="kn ko kp kq gt nl nk nm nn aw no bi"><span id="6ef2" class="np ld iq nk b gy nq nr l ns nt">plugins {<br/>  id "com.mooltiverse.oss.nyx" version "1.0.0"<br/>}</span></pre><p id="2e13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在运行<code class="fe nh ni nj nk b">gradle tasks</code>(或者<code class="fe nh ni nj nk b">./gradlew tasks</code>，如果你正在使用<a class="ae kl" href="https://docs.gradle.org/current/userguide/gradle_wrapper.html" rel="noopener ugc nofollow" target="_blank">包装器</a>)来查看可用的新任务:</p><pre class="kn ko kp kq gt nl nk nm nn aw no bi"><span id="9d43" class="np ld iq nk b gy nq nr l ns nt">$ gradle tasks<br/>&gt; Task :tasks<br/><br/>[...]<br/><br/>Release tasks<br/>-------------<br/><strong class="nk ir">nyxClean</strong> - Deletes local release artifacts and reverts the release process to its initial state<br/><strong class="nk ir">nyxInfer</strong> - Collects informations from the local Git repository to generate the new version and plan the release actions<br/><strong class="nk ir">nyxMake</strong> - Builds the configured local release artifacts<br/><strong class="nk ir">nyxMark</strong> - Marks the release by tagging and committing the repository<br/><strong class="nk ir">nyxPublish</strong> - Publishes the new release to remote services and emits notifications<br/>release - Runs all the release tasks<br/><br/>[...]<br/><br/>BUILD SUCCESSFUL in 280ms<br/>1 actionable task: 1 executed</span></pre><h1 id="1f52" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">使用预设进行配置</h1><p id="a3d3" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">先说一个巨大的省时器:<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-presets/" rel="noopener ugc nofollow" target="_blank">配置<strong class="jp ir">预置</strong> </a>。不要将预设与默认混淆，因为它们是相当精简的工作配置，您可以开箱即用或作为基线使用，您可以覆盖任何选项以更好地满足您的需求。</p><p id="4285" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看它们有多强大和简单，然后回到我们的<code class="fe nh ni nj nk b">settings.gradle</code>文件添加<code class="fe nh ni nj nk b">nyx</code>扩展名:</p><pre class="kn ko kp kq gt nl nk nm nn aw no bi"><span id="05ad" class="np ld iq nk b gy nq nr l ns nt">plugins {<br/>  id "com.mooltiverse.oss.nyx" version "1.0.0"<br/>}</span><span id="d98d" class="np ld iq nk b gy nu nr l ns nt">nyx {<br/>  preset = 'extended'<br/>}</span></pre><p id="f4af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就这么简单！<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-presets/extended/" rel="noopener ugc nofollow" target="_blank"> <em class="mf">扩展</em> </a>预置不是唯一可用的预置，但它可以让您体验到只需一行配置就能得到的东西:</p><ul class=""><li id="67aa" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">配置了两个<strong class="jp ir">提交消息约定</strong>:<a class="ae kl" href="https://www.conventionalcommits.org/" rel="noopener ugc nofollow" target="_blank"><em class="mf">常规提交</em> </a>和<a class="ae kl" href="https://gitmoji.dev/" rel="noopener ugc nofollow" target="_blank"> <em class="mf"> gitmoji </em> </a>。<em class="mf">常规提交</em>具有优先级，因此只有当<em class="mf">常规提交</em>无法匹配提交时，倪克斯才会尝试将提交与<em class="mf"> gitmoji </em>进行匹配。当提交与约定相匹配时，它们的<strong class="jp ir">类型</strong>被推断出来以将它们分类到变更日志的不同部分，并且如果需要的话，还确定哪个版本标识符应该被<strong class="jp ir">碰撞</strong>以生成新的<strong class="jp ir">版本</strong>。只有那些被认为是<strong class="jp ir">碰撞</strong>版本标识符的提交被认为是<strong class="jp ir">重要的</strong></li><li id="b1ca" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">八个<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">发布类型</strong> </a>，涵盖了广泛的<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/best-practice/branching-models/" rel="noopener ugc nofollow" target="_blank">分支模型</a>，包括:<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/best-practice/branching-models/#mainline" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mf">主线</em></strong></a><em class="mf">正式</em>或<em class="mf">常规</em>发布从<em class="mf">主</em>或<em class="mf">主</em>分支仅使用<em class="mf">核心</em>版本标识符如<em class="mf">x . y . z</em>；<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/best-practice/branching-models/#integration-branches" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mf">集成</em> </strong> </a>和<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/best-practice/branching-models/#maturity-branches" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="mf"/></strong></a>(又名<em class="mf">预览版</em>发布，从<em class="mf">开发</em>，<em class="mf">开发</em>，<em class="mf">集成</em>，<em class="mf">最新，alpha </em>，<em class="mf"> beta </em>等分支使用<strong class="jp ir">预发布</strong> <em class="mf">特性/XXX </em>、<em class="mf">修复/XXX </em>、<em class="mf">热修复/XXX </em>分支)、<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/best-practice/branching-models/#maintenance-branches" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mf">维护</em> </strong> </a>(又名<em class="mf">后期发布</em>)和<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/best-practice/branching-models/#release-branches" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mf">发布</em> </strong> </a>(来自<em class="mf"> x.y.z </em></li><li id="6a6f" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">两个<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/services/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">服务</strong> </a> (GitHub和GitLab)，它们可以分别从<code class="fe nh ni nj nk b">GITHUB_TOKEN</code>和<code class="fe nh ni nj nk b">GITLAB_TOKEN</code>环境变量中读取认证令牌(如个人访问令牌),以备不时之需</li><li id="4b62" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe nh ni nj nk b">CHANGELOG.md</code>文件在项目根目录下生成，每个版本有四个部分:<em class="mf">添加</em>，<em class="mf">修复</em>，<em class="mf">删除</em>，<em class="mf">安全</em>，每个部分收集特定<strong class="jp ir">类型的提交</strong></li></ul><p id="b11d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于像这样的帖子来说，详细描述这一切太多了，但是你仍然可以跳到<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/" rel="noopener ugc nofollow" target="_blank">配置参考</a>或者看下面的更多内容。尽管如此，我们还是可以概述一些事情:</p><ul class=""><li id="80ef" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">如果产生了一个新的版本，与该版本匹配的<strong class="jp ir">发布类型</strong>是您可以配置是否必须执行Git操作的地方，比如提交新的变更、标记和推送到远程</li><li id="f84e" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">如果想知道是否支持版本<strong class="jp ir">前缀</strong>(即<strong class="jp ir"><em class="mf">v</em></strong><em class="mf">1 . 2 . 3</em>或<strong class="jp ir"><em class="mf">rel</em></strong><em class="mf">1 . 2 . 3</em>而不是简单的<em class="mf"> 1.2.3 </em>)答案是<strong class="jp ir">是</strong>，请参见<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/global-options/" rel="noopener ugc nofollow" target="_blank">参考文献</a></li><li id="bd39" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">一些发布类型被配置为版本号的线性增加(如<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/best-practice/branching-models/#mainline" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mf">【主线】</em> </strong> </a>，仅使用<em class="mf">核心</em>版本标识符，如<em class="mf"> x.y.z </em>)而其他的(如<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/best-practice/branching-models/#integration-branches" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mf">集成</em> </strong> </a>和<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/best-practice/branching-models/#maturity-branches" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mf">成熟度</em> </strong> </a>，使用额外的标识符，如<em class="mf"> x.y.z-prerelease.n </em></li><li id="4e8e" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><strong class="jp ir">内部</strong>发布类型并不意味着应用任何标签或被发布，但仍然会为您生成一个<strong class="jp ir">版本</strong>号(带有额外的标识符以使其明确，如<em class="mf">x . y . z-internal . n-timestamp . 20220101</em>)来完成构建。对于内部发布，您应该总是有一个后备发布类型(它实际上并不发布或推送任何东西，但是即使在这种情况下也能保持您的构建过程的一致性)</li><li id="19ae" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">倪克斯没有预定义的发布类型集(像<em class="mf">标准</em>、<em class="mf">预发布</em>、<em class="mf">维护</em>)，每一个都可以从头开始完全配置，给你完全的选择自由。这同样适用于您可以完全配置的分支名称</li><li id="84d9" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">当使用<strong class="jp ir">额外标识符</strong>(即预发行版)时，您可以定义任意多个，可选地为它们分配动态值(或使用自动增量)，并且不限于一个</li></ul><h2 id="fa92" class="np ld iq bd le nv nw dn li nx ny dp lm jy nz oa lq kc ob oc lu kg od oe ly of bi translated">覆盖预设值</h2><p id="9f47" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">如果一个预置<strong class="jp ir">几乎</strong>是你需要的，但不是完美的契合，那该怎么办？别担心，你不需要放弃预置，写一个全新的配置。您可以从预设开始，<strong class="jp ir">覆盖</strong>您需要的值。让我向您展示这个经过修改的版本的<code class="fe nh ni nj nk b">settings.gradle</code>文件，其中有一些改动:</p><pre class="kn ko kp kq gt nl nk nm nn aw no bi"><span id="a7ce" class="np ld iq nk b gy nq nr l ns nt">plugins {<br/>  id "com.mooltiverse.oss.nyx" version "1.0.0"<br/>}</span><span id="8d6d" class="np ld iq nk b gy nu nr l ns nt">nyx {<br/>  preset = 'extended'<br/>  changelog {<br/>    path = 'build/CHANGELOG.md'<br/>  }<br/>  releaseTypes {<br/>    publicationServices = [ 'github' ]<br/>    items {<br/>      mainline {<br/>        ...<br/>        description = '{{#<!-- -->fileContent<!-- -->}}build/CHANGELOG.md{{/<!-- -->fileContent<!-- -->}}'<br/>        gitCommit = 'true'<br/>      }<br/>    }<br/>  }<br/>  services {<br/>    github {<br/>      type = 'GITHUB'<br/>      options {<br/>        AUTHENTICATION_TOKEN = '{{#<!-- -->environmentVariable<!-- -->}}GH_TOKEN{{/<!-- -->environmentVariable<!-- -->}}'<br/>        REPOSITORY_NAME = 'myrepo'<br/>        REPOSITORY_OWNER = 'jdoe'<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="5e33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，我们仍在使用<em class="mf">扩展</em>预设，但这里的其他选项具有优先权，因此它们可以<strong class="jp ir">添加新选项</strong>或<strong class="jp ir">覆盖现有选项</strong>。</p><p id="6357" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个备注:当使用多种配置方法或定制预置时，复杂的配置选项(例如<code class="fe nh ni nj nk b">commitMessageConventions</code>、<code class="fe nh ni nj nk b">releaseTypes</code>、<code class="fe nh ni nj nk b">services</code>)必须整体继承或覆盖。这种类型的配置选项不支持覆盖单个值和继承其他值，因此当它们在一个配置级别重新声明时，所有从优先级较低的配置方法继承的值(包括预设)都将被抑制。</p><p id="92d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们改变了变更日志的目标文件，现在是<code class="fe nh ni nj nk b">build/CHANGELOG.md</code>而不是<code class="fe nh ni nj nk b">CHANGELOG.md</code>。</p><p id="97c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们覆盖<em class="mf">主线</em>发布类型，在新版本的情况下启用挂起变更的git提交(<code class="fe nh ni nj nk b">gitCommit = 'true'</code>)，并使用将发布到<a class="ae kl" href="https://docs.github.com/en/github/administering-a-repository/about-releases" rel="noopener ugc nofollow" target="_blank"> GitHub发布</a>的发布<strong class="jp ir">描述</strong>的变更日志文件的内容。如果我们想发布到<a class="ae kl" href="https://docs.gitlab.com/ee/user/project/releases/" rel="noopener ugc nofollow" target="_blank"> GitLab Releases </a>我们可以这样:</p><pre class="kn ko kp kq gt nl nk nm nn aw no bi"><span id="6191" class="np ld iq nk b gy nq nr l ns nt">plugins {<br/>  id "com.mooltiverse.oss.nyx" version "1.0.0"<br/>}</span><span id="a2a5" class="np ld iq nk b gy nu nr l ns nt">nyx {<br/>  preset = 'extended'<br/>  changelog {<br/>    path = 'build/CHANGELOG.md'<br/>  }<br/>  releaseTypes {<br/>    publicationServices = [ 'gitlab' ]<br/>    items {<br/>      mainline {<br/>        ...<br/>        description = '{{#<!-- -->fileContent<!-- -->}}build/CHANGELOG.md{{/<!-- -->fileContent<!-- -->}}'<br/>        gitCommit = 'true'<br/>      }<br/>    }<br/>  }<br/>  services {<br/>    gitlab {<br/>      type = 'GITLAB'<br/>      options {<br/>        AUTHENTICATION_TOKEN = '{{#<!-- -->environmentVariable<!-- -->}}GL_TOKEN{{/<!-- -->environmentVariable<!-- -->}}'<br/>        REPOSITORY_NAME = 'myrepo'<br/>        REPOSITORY_OWNER = 'jdoe'<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="0fdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还记得上面预置配置的两个服务(GitHub和GitLab)吗？在那个阶段，他们是助手，但是他们还不活跃(这是服务特有的)，所以为了实际发布版本，我们使用<code class="fe nh ni nj nk b">publicationServices = [ 'github' ]</code>或<code class="fe nh ni nj nk b">publicationServices = [ 'gitlab' ]</code>来启用服务。</p><p id="16b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，在<code class="fe nh ni nj nk b">services.github</code>或<code class="fe nh ni nj nk b">services.gitlab</code>部分中，我们设置存储库名称(<code class="fe nh ni nj nk b">myrepo</code>和所有者(<code class="fe nh ni nj nk b">jdoe</code>)并更改环境变量的名称以从(<code class="fe nh ni nj nk b">GH_TOKEN</code>或<code class="fe nh ni nj nk b">GL_TOKEN</code>)读取安全令牌。不管您为变量使用什么名称，需要注意的重要一点是，您可以<strong class="jp ir">避免将您的凭证</strong>硬编码到配置文件中，相反，您可以从环境中动态地读取它们，在那里您可以将它们存储为<strong class="jp ir">机密</strong>，您可以将它们配置为本地环境变量或CI/CD平台。</p><p id="df58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在GitHub上，你可以使用<a class="ae kl" href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token" rel="noopener ugc nofollow" target="_blank">这些指令</a>创建一个新的个人访问令牌，然后将它作为一个环境变量作为一个<a class="ae kl" href="https://docs.github.com/en/actions/security-guides/encrypted-secrets" rel="noopener ugc nofollow" target="_blank">加密的秘密</a>提供给你的CI/CD管道。更简单的是(但是只在CI/CD环境下工作)，您可以只使用自动生成的<code class="fe nh ni nj nk b"><a class="ae kl" href="https://docs.github.com/en/actions/learn-github-actions/contexts#secrets-context" rel="noopener ugc nofollow" target="_blank">secrets</a>.GITHUB_TOKEN</code>，仍然来自<code class="fe nh ni nj nk b"><a class="ae kl" href="https://docs.github.com/en/actions/learn-github-actions/contexts#secrets-context" rel="noopener ugc nofollow" target="_blank">secrets</a></code> <a class="ae kl" href="https://docs.github.com/en/actions/learn-github-actions/contexts#secrets-context" rel="noopener ugc nofollow" target="_blank">上下文</a>。</p><p id="5868" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在GitLab上，您可以使用这些指令创建一个新的个人访问令牌，然后将它作为一个<a class="ae kl" href="https://docs.gitlab.com/ee/ci/variables/index.html" rel="noopener ugc nofollow" target="_blank">环境变量</a>提供给CI/CD管道。</p><p id="1d39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不管平台如何，确保您使用的令牌有足够的权限来执行您需要的操作(比如发布版本)。</p><h2 id="440c" class="np ld iq bd le nv nw dn li nx ny dp lm jy nz oa lq kc ob oc lu kg od oe ly of bi translated">模板</h2><p id="475f" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">想知道发布版<code class="fe nh ni nj nk b">description</code>和<code class="fe nh ni nj nk b">AUTHENTICATION_TOKEN</code>的语法是什么吗？那些是<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/templates/" rel="noopener ugc nofollow" target="_blank">胡子模板</a>。您可以将其用于许多配置选项，以使您的配置<strong class="jp ir">动态</strong>和<strong class="jp ir">自适应</strong>。</p><p id="b49f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">倪克斯提供了一个<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/templates/#the-functions-library" rel="noopener ugc nofollow" target="_blank">函数库</a> (Mustache lambdas)供你在渲染内容(如变更日志)或读取值(如配置)时使用，这让你释放出很多额外的能力。</p><p id="6b64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只要允许使用模板，您仍然可以硬编码简单的值，但是使用这些函数通常会在安全性和灵活性方面给您带来额外的价值。</p><h2 id="e84d" class="np ld iq bd le nv nw dn li nx ny dp lm jy nz oa lq kc ob oc lu kg od oe ly of bi translated">Git远程凭据</h2><p id="3226" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">如果您的任何发布类型被配置为<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#git-push" rel="noopener ugc nofollow" target="_blank">将</a>本地更改推送到远程存储库(有些在<em class="mf">扩展的</em>预置do中),并且您的远程存储库是写保护的，那么您需要将您的凭证传递给倪克斯，如下所示:</p><pre class="kn ko kp kq gt nl nk nm nn aw no bi"><span id="6780" class="np ld iq nk b gy nq nr l ns nt">nyx {<br/>  <!-- -->git {<br/>    remotes {<br/>      origin {<br/>        user = 'jdoe'<br/>        password = '<!-- -->{{#<!-- -->environmentVariable<!-- -->}}PAT{{/<!-- -->environmentVariable<!-- -->}}<!-- -->'<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="7b26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本例中，我们为<code class="fe nh ni nj nk b">origin</code>远程存储库配置凭证，将<code class="fe nh ni nj nk b">jdoe</code>硬编码为用户名，并从<code class="fe nh ni nj nk b">PAT</code>环境变量中读取密码。</p><p id="ad92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于Git API的工作方式，即使使用OAuth或个人访问令牌，也总是需要同时传递<code class="fe nh ni nj nk b">user</code>和<code class="fe nh ni nj nk b">password</code>。但是，根据目标服务的不同，您可能需要以不同的方式传递它们:</p><ul class=""><li id="2ee0" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">当配置GitHub远程存储库时，将令牌作为名称<code class="fe nh ni nj nk b">user</code>传递，将空字符串作为名称<code class="fe nh ni nj nk b">password</code></li><li id="db53" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">当配置GitLab远程存储库时，传递固定字符串<code class="fe nh ni nj nk b">PRIVATE-TOKEN</code>作为<code class="fe nh ni nj nk b">user</code>名称，传递令牌作为<code class="fe nh ni nj nk b">password</code></li></ul><h1 id="ed4f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">该跑了</h1><p id="1c10" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">准备好了吗？让我们运行这个！你还不自信吗？您仍然可以使用<code class="fe nh ni nj nk b"><a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/global-options/#dry-run" rel="noopener ugc nofollow" target="_blank">dryRun</a></code>标志，这样倪克斯就不会改变您环境中的任何东西。</p><p id="d07e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除非你改变<code class="fe nh ni nj nk b"><a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/global-options/#verbosity" rel="noopener ugc nofollow" target="_blank">verbosity</a></code>(在这种情况下，继承自Gradle)或者遇到一些错误，否则倪克斯是非常安静的，只向你显示当前运行使用的<strong class="jp ir">版本</strong>号(新版本或者以前的版本)。例如:</p><pre class="kn ko kp kq gt nl nk nm nn aw no bi"><span id="4fef" class="np ld iq nk b gy nq nr l ns nt">$ gradle build<br/>Project version: 1.2.3<br/>...</span></pre><p id="f1d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里<code class="fe nh ni nj nk b">build</code>假设是你的任何任务。但是为什么倪克斯没有援引它就介入了呢？这是因为我们将其配置为一个<em class="mf">设置</em>插件，所以<em class="mf">推断</em>任务在Gradle构建过程的早期评估阶段运行。这样，您的脚本总是在常规构建期间设置了<strong class="jp ir">版本</strong>属性，即使是在运行第一批任务时。</p><p id="67f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你将倪克斯作为一个常规插件来应用，你需要手动或者通过任务依赖来运行<code class="fe nh ni nj nk b">nyxInfer</code>任务。</p><p id="5b2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有大量的<a class="ae kl" href="https://mooltiverse.github.io/nyx/example/user/git-history-examples/" rel="noopener ugc nofollow" target="_blank">例子</a>来展示倪克斯是如何基于分支和发布类型来工作的，但是让我们在这里做一个简单的介绍。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="8fd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设您正在<code class="fe nh ni nj nk b">main</code>或<code class="fe nh ni nj nk b">master</code>分支中运行构建脚本，其中您有一个标记为<code class="fe nh ni nj nk b">2.3.4</code>的先前提交和此后的其他提交，表明<code class="fe nh ni nj nk b">minor</code>和<code class="fe nh ni nj nk b">patch</code>标识符都必须被碰撞(根据<a class="ae kl" href="https://www.conventionalcommits.org/" rel="noopener ugc nofollow" target="_blank">常规提交</a>):</p><pre class="kn ko kp kq gt nl nk nm nn aw no bi"><span id="79c9" class="np ld iq nk b gy nq nr l ns nt">$ gradle build<br/>Project version: 2.4.0<br/>...</span></pre><p id="cf3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">生成版本<code class="fe nh ni nj nk b">2.4.0</code>是因为<code class="fe nh ni nj nk b">minor</code>标识符比<code class="fe nh ni nj nk b">patch</code>更重要。如果没有发现重要的提交，仍然使用先前标签的版本<code class="fe nh ni nj nk b">2.3.4</code>。</p><p id="2e46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们在刚刚从<code class="fe nh ni nj nk b">main</code>分支创建的<code class="fe nh ni nj nk b">alpha</code>分支中运行，其中<code class="fe nh ni nj nk b">2.3.4</code>是上一次提交的标签，然后我们添加了其他提交来碰撞<code class="fe nh ni nj nk b">minor</code>和<code class="fe nh ni nj nk b">patch</code>标识符，会怎么样？这是:</p><pre class="kn ko kp kq gt nl nk nm nn aw no bi"><span id="1463" class="np ld iq nk b gy nq nr l ns nt">$ gradle build<br/>Project version: 2.4.0-alpha.1<br/>...</span></pre><p id="9eba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在另一个<code class="fe nh ni nj nk b">minor</code>提交之后？</p><pre class="kn ko kp kq gt nl nk nm nn aw no bi"><span id="96f0" class="np ld iq nk b gy nq nr l ns nt">$ gradle build<br/>Project version: 2.4.0-alpha.2<br/>...</span></pre><p id="3b11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而当我们合并回<code class="fe nh ni nj nk b">main</code>？</p><pre class="kn ko kp kq gt nl nk nm nn aw no bi"><span id="dabc" class="np ld iq nk b gy nq nr l ns nt">$ gradle build<br/>Project version: 2.4.0<br/>...</span></pre><p id="3e8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#collapse-versions" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">折叠版本</strong> </a>的妙处，用于<em class="mf">预发布</em>，因为<code class="fe nh ni nj nk b">alpha</code>分支配置了这个方案。</p><p id="5b11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您还运行<code class="fe nh ni nj nk b">nyxPublish</code>任务(直接或者通过依赖项)，您将最终发布到已配置的服务，其描述取自changelog。</p><h1 id="83eb" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">在后台</h1><p id="6338" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们说<em class="mf">推断</em>是最重要的任务，但是它是如何确定<strong class="jp ir">版本</strong>号的呢？这很复杂，但我们会尽量保持简单。它考虑到了:</p><ul class=""><li id="4f03" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">Git提交历史</li><li id="ec50" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">已配置的发布类型</li><li id="31d5" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">已配置的提交消息约定</li></ul><p id="7e28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">发布类型</strong>在每次运行时根据<strong class="jp ir">当前分支</strong>的名称与一个正则表达式和其他可选约束匹配，如工作区状态(<em class="mf">干净</em>或<em class="mf">脏</em>)或一些环境变量的值。一旦从已配置的版本中选择了正确的版本类型，它将指示倪克斯:</p><ul class=""><li id="9eab" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">采取哪些Git操作(即<strong class="jp ir">提交</strong>、<strong class="jp ir">标记</strong>、<strong class="jp ir">推送</strong>)</li><li id="b3e9" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">使用哪个版本化方案(即<strong class="jp ir">线性</strong> x.y.x用于<em class="mf">正式</em>发布，<strong class="jp ir">折叠</strong> x.y.x-alpha.n用于预发布)以及可选的额外标识符添加到版本号(即<em class="mf">x . y . z-user . jdoe-timestamp . 2022 01 01</em>)</li><li id="0427" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">发布是否必须使用一些已知的服务<strong class="jp ir">发布</strong>(即<a class="ae kl" href="https://docs.github.com/en/github/administering-a-repository/about-releases" rel="noopener ugc nofollow" target="_blank"> GitHub发布</a>，<a class="ae kl" href="https://docs.gitlab.com/ee/user/project/releases/" rel="noopener ugc nofollow" target="_blank"> GitLab发布</a>)或者只是留在本地</li><li id="9c61" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#filter-tags" rel="noopener ugc nofollow" target="_blank">当读取提交历史时，哪些标签被认为是以前的版本，这样可以避免错误匹配</a></li><li id="6ec7" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#version-range" rel="noopener ugc nofollow" target="_blank">版本<strong class="jp ir">范围检查</strong> </a>(确保分支机构只发布特定范围内的版本)。你甚至可以让倪克斯<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#version-range-from-branch-name" rel="noopener ugc nofollow" target="_blank">从分支名称</a>推断版本范围，以防你遵循某种模式</li></ul><p id="af36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦知道了上述信息，<em class="mf">推断</em>检查提交历史并确定<strong class="jp ir">发布范围</strong>(将被包括在发布中的提交)，其可能包含也可能不包含关于新发布的<strong class="jp ir">重大变更</strong>。每个提交是否重要取决于所配置的用于检查每个提交消息的<strong class="jp ir">提交消息约定</strong>。</p><p id="e26b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果必须创建一个新版本，它用标识符确定在以前的版本上<strong class="jp ir">碰撞</strong>，并创建新的版本号，否则保持以前的版本不变。被碰撞的标识符也由使用中的<strong class="jp ir">约定</strong>决定。提交约定用于收集其消息符合已知模式的提交的意图，以便倪克斯知道变更是否应该发布新的<em class="mf">主要</em>或<em class="mf">次要</em>版本、一个<em class="mf">补丁</em>、一个<em class="mf">热修复</em>、一个<em class="mf">预发布</em>、一个<em class="mf">维护</em>或<em class="mf">内部</em>版本等等。</p><p id="e724" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，可选的<strong class="jp ir">额外标识符</strong>被应用于版本号，并且<strong class="jp ir">范围检查</strong>被执行以确保新版本在可选的范围约束内。</p><p id="2457" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于这个话题的更多信息可以在这里找到<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/how-nyx-works/#infer" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="f0e4" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">关于配置的更多信息</h1><p id="6b80" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">正如我们在上面看到的，预置功能强大且易于使用。上面的<em class="mf">扩展</em>预置带来了很多配置选项，这里<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-presets/extended/" rel="noopener ugc nofollow" target="_blank">列出了</a>，但是倪克斯配置可以更进一步。</p><p id="5357" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，我们介绍的是通过<code class="fe nh ni nj nk b"><a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/configuration-methods/#gradle" rel="noopener ugc nofollow" target="_blank">nyx</a></code> <a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/configuration-methods/#gradle" rel="noopener ugc nofollow" target="_blank"> Gradle扩展</a>的配置，因为使用Gradle插件可能更容易，但是倪克斯配置有<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/configuration-methods/" rel="noopener ugc nofollow" target="_blank">几个配置方法</a>。</p><p id="fc33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用YAML和JSON文件，甚至是它们的组合。如果在默认位置(<code class="fe nh ni nj nk b">.nyx.json</code>或<code class="fe nh ni nj nk b">.nyx.yaml</code>)找不到它们，你可以传递它们的路径(或者一个远程URL)。</p><p id="1991" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，通过混合几种配置方式，你可以继承一些集中管理的组织范围的设置，然后在项目的基础上定制它们，或者让不同的团队共享部分配置等等。</p><p id="19f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有配置选项也可以作为<strong class="jp ir">命令行</strong>参数或者甚至是<strong class="jp ir">环境变量</strong>来传递，以便满足甚至是最偏远的边缘情况(即，安全机密管理、在强化环境中的合规性、在CI/CD环境中的灵活性等等)。</p><p id="1ad1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/configuration-methods/" rel="noopener ugc nofollow" target="_blank">描述了全部配置方式及其评估顺序，而</a><a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/" rel="noopener ugc nofollow" target="_blank">配置参考</a>描述了每个选项的所有方式。</p><h2 id="63c2" class="np ld iq bd le nv nw dn li nx ny dp lm jy nz oa lq kc ob oc lu kg od oe ly of bi translated">关于提交消息约定和版本覆盖的更多信息</h2><p id="094b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在本指南中，我们使用<a class="ae kl" href="https://www.conventionalcommits.org/" rel="noopener ugc nofollow" target="_blank">约定提交</a>约定，因为它被广泛使用，但是没有什么可以阻止您使用任何其他约定，包括您自己定义的一些自定义约定。</p><p id="62bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在倪克斯，提交消息约定可以像其他一样配置<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/commit-message-conventions/" rel="noopener ugc nofollow" target="_blank"/>并且<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/commit-message-conventions/#enabled" rel="noopener ugc nofollow" target="_blank">可以使用多个</a>，所以你甚至可以组合它们。</p><p id="e147" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">约定是倪克斯能够从提交历史中推断信息以实现完全自动化的方式。同样，它们允许每个提交定义哪些版本标识符被<strong class="jp ir">碰撞</strong>(如果有的话)，以便从以前的版本号开始计算新的<strong class="jp ir">版本号</strong>。</p><p id="0479" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管如此，当您需要完全接管推理逻辑时，您总是可以覆盖<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/global-options/#version" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">版本</strong> </a>来使用，或者您可以通过将标识符传递给<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/global-options/#bump" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> bump </strong> </a>来完成，这样倪克斯仍然可以从提交历史中读取以前的版本并直接进行bumping，而无需检查提交。</p><h2 id="3273" class="np ld iq bd le nv nw dn li nx ny dp lm jy nz oa lq kc ob oc lu kg od oe ly of bi translated">有条件释放类型</h2><p id="486a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">让我们假设您希望您的正式发布只由<code class="fe nh ni nj nk b">main</code>或<code class="fe nh ni nj nk b">master</code>分支发布，但是，为了保证构建环境的一致性，要执行的整个范围的测试，等等，您需要它们只从集中的CI/CD环境发布，避免开发人员利用漏洞。</p><p id="dee6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">换句话说，您需要官方发布类型<strong class="jp ir">有条件地</strong>只在CI/CD环境中匹配。</p><p id="023d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，发布类型是按照它们在<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#enabled" rel="noopener ugc nofollow" target="_blank">列表</a>中的顺序进行评估的，因此只有在之前的项目没有成功匹配的情况下，才会对每个项目进行评估。同样，用于匹配一个发布类型的规则是基于<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#match-branches" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">当前分支</strong>名称</a>(匹配一个正则表达式)<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#match-workspace-status" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">工作区状态</strong> </a> ( <em class="mf">干净</em>或<em class="mf">脏</em>)或一些<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#match-environment-variables" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">环境变量</strong> </a>。</p><p id="180e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，我们可以使用一个环境变量(即<code class="fe nh ni nj nk b">CI</code>)来匹配官方发布类型。</p><p id="2050" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了完成这个例子，让我们添加一个模拟官方版本的后备版本类型，但是，它不发布官方版本，而只发布内部版本，正确地标识为内部版本。</p><p id="550f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">截取的配置示例可能是:</p><pre class="kn ko kp kq gt nl nk nm nn aw no bi"><span id="523c" class="np ld iq nk b gy nq nr l ns nt">nyx {<br/>  ...<br/>  releaseTypes {<br/>    <!-- -->enabled = [ 'mainline', 'internal' ]<br/>    <!-- -->items {<br/>      <!-- -->mainline {<br/>        filterTags = '^([0-9]\\d*)\\.([0-9]\\d*)\\.([0-9]\\d*)$'<br/>        gitCommit = 'false'<br/>        gitPush = 'true'<br/>        gitTag = 'true'<br/>        matchBranches = '^(master|main)$'<br/>        matchEnvironmentVariables {<br/>          CI = '^true$'<br/>        }<br/>        publish = 'true'<br/>      }<br/>      internal {<br/>        filterTags = '^([0-9]\\d*)\\.([0-9]\\d*)\\.([0-9]\\d*)$'<br/>        gitCommit = 'false'<br/>        gitPush = 'false'<br/>        gitTag = 'false'<br/>        identifiers {<br/>          '0' {<br/>                position = 'BUILD'<br/>                qualifier = 'internal'<br/>                value = '{{#sanitize}}{{branch}}{{/sanitize}}'<br/>              }<br/>        }<br/>        matchBranches = '^(master|main)$'<br/>        publish = 'false'<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="ed50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，只有当<code class="fe nh ni nj nk b">mainline</code>首先不匹配时(即因为没有找到值为<code class="fe nh ni nj nk b">true</code>的<code class="fe nh ni nj nk b">CI</code>环境变量)，并且当<code class="fe nh ni nj nk b">mainline</code>发布<em class="mf">正式</em>版本(如<em class="mf"> x.y.x </em>)时，<code class="fe nh ni nj nk b">internal</code>在版本号的构建部分添加<code class="fe nh ni nj nk b">internal</code>限定符，如:<em class="mf"> x.y.z+branch.main </em>。<code class="fe nh ni nj nk b">internal</code>发布类型不提交、标记或推送任何变更到存储库，也不发布任何内容，而<code class="fe nh ni nj nk b">mainline</code>会。</p><h2 id="16db" class="np ld iq bd le nv nw dn li nx ny dp lm jy nz oa lq kc ob oc lu kg od oe ly of bi translated">关于使用模板进行动态配置的更多信息</h2><p id="ded5" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">实现上一个示例相同结果的另一种方法是利用模板。这样，您甚至不需要添加额外的发布类型(但是请记住，在所有配置中建议使用最后一个后备发布类型)。看起来是这样的:</p><pre class="kn ko kp kq gt nl nk nm nn aw no bi"><span id="1647" class="np ld iq nk b gy nq nr l ns nt">nyx {<br/>  ...<br/>  releaseTypes {<br/>    <!-- -->enabled = [ 'mainline' ]<br/>    <!-- -->items {<br/>      <!-- -->mainline {<br/>        filterTags = '^([0-9]\\d*)\\.([0-9]\\d*)\\.([0-9]\\d*)$'<br/>        gitCommit = 'false'<br/>        gitPush = '<!-- -->{{#<!-- -->environmentVariable<!-- -->}}<!-- -->CI<!-- -->{{/<!-- -->environmentVariable<!-- -->}}<!-- -->'<br/>        gitTag = '<!-- -->{{#<!-- -->environmentVariable<!-- -->}}<!-- -->CI<!-- -->{{/<!-- -->environmentVariable<!-- -->}}<!-- -->'<br/>        matchBranches = '^(master|main)$'<br/>        publish = '<!-- -->{{#<!-- -->environmentVariable<!-- -->}}<!-- -->CI<!-- -->{{/<!-- -->environmentVariable<!-- -->}}<!-- -->'<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="b77d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，配置更加简洁，无论环境如何，都匹配相同的发布类型<code class="fe nh ni nj nk b">mainline</code>。然而，它的一些控制是否必须执行Git <a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#git-push" rel="noopener ugc nofollow" target="_blank"> push </a>和<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#git-tag" rel="noopener ugc nofollow" target="_blank"> tag </a>操作的标志(以及最终的<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/release-types/#publish" rel="noopener ugc nofollow" target="_blank">发布</a>)通过<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/templates/#environmentvariable" rel="noopener ugc nofollow" target="_blank">读取</a> <code class="fe nh ni nj nk b"><a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/templates/#environmentvariable" rel="noopener ugc nofollow" target="_blank">CI</a></code> <a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/configuration-reference/templates/#environmentvariable" rel="noopener ugc nofollow" target="_blank">环境变量的值来动态获取它们的值。</a></p><p id="27f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是可能的，因为<code class="fe nh ni nj nk b">CI</code>环境变量在定义时具有值<code class="fe nh ni nj nk b">true</code>，并且提到的标志被评估为布尔值。</p><h1 id="1f17" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">关于Gradle builds的更多信息</h1><h2 id="ef9c" class="np ld iq bd le nv nw dn li nx ny dp lm jy nz oa lq kc ob oc lu kg od oe ly of bi translated">多项目配置</h2><p id="53f3" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">如果你的Gradle项目被分割成子项目(<a class="ae kl" href="https://docs.gradle.org/current/userguide/multi_project_builds.html" rel="noopener ugc nofollow" target="_blank">多项目构建</a>)，你<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/introduction/usage/#multi-project-builds" rel="noopener ugc nofollow" target="_blank">应该</a>只对根项目应用插件，除非你知道你在做什么。如果你把它作为一个<em class="mf">设置</em>插件来应用，这甚至是一个梯度要求，否则倪克斯不会给你任何限制，但是你需要考虑每个子项目有不同版本的可能性。</p><p id="f648" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当应用到根项目时，您可能需要子项目使用与根项目相同的<strong class="jp ir">版本</strong>。一种方法是让子项目从根项目中读取，而不是从本地项目中读取，比如:</p><pre class="kn ko kp kq gt nl nk nm nn aw no bi"><span id="7081" class="np ld iq nk b gy nq nr l ns nt">tasks.register('myTask')  {<br/>    dependsOn ':nyxInfer' // not needed as settings.gradle plugin<br/>    doLast {<br/>        println <strong class="nk ir">rootProject</strong>.version<br/>    }<br/>}</span></pre><p id="7b3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，只是用<code class="fe nh ni nj nk b"><strong class="jp ir">rootProject</strong>.version</code>代替<code class="fe nh ni nj nk b"><strong class="jp ir">project</strong>.version</code>(或者只是<code class="fe nh ni nj nk b">version</code>)的问题。</p><p id="ca2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个选择是让根项目将版本传播到子项目，比如(在根<code class="fe nh ni nj nk b">build.gradle</code>文件中):</p><pre class="kn ko kp kq gt nl nk nm nn aw no bi"><span id="4b1b" class="np ld iq nk b gy nq nr l ns nt">subprojects {<br/>    version = rootProject.version<br/>}</span></pre><h2 id="bf8f" class="np ld iq bd le nv nw dn li nx ny dp lm jy nz oa lq kc ob oc lu kg od oe ly of bi translated">条件任务</h2><p id="5a14" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">其他发布管理工具的缺点之一是，它们不公开任何属性供您在构建脚本中使用。通过倪克斯，你可以使用<a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/state-reference/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">状态</strong> </a>对象获得完整的洞察力，这里我将向你展示一个例子。</p><p id="c245" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当使用Gradle插件时，你有更多的选择，因为你不需要将状态对象的内容序列化到本地文件中。相反，你可以把它作为一个名为<code class="fe nh ni nj nk b">nyxState</code>的全局构建脚本额外属性。</p><p id="0477" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从一个读取一些属性的例子开始:</p><pre class="kn ko kp kq gt nl nk nm nn aw no bi"><span id="ec46" class="np ld iq nk b gy nq nr l ns nt">task dumpSomeDiagnostics() {<br/>    dependsOn nyxInfer // not needed as settings.gradle plugin<br/>    doLast {<br/>        println rootProject.<strong class="nk ir">nyxState.</strong><a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/state-reference/global-attributes/#bump" rel="noopener ugc nofollow" target="_blank"><strong class="nk ir">bump</strong></a><br/>        println rootProject.<strong class="nk ir">nyxState.</strong><a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/state-reference/global-attributes/#directory" rel="noopener ugc nofollow" target="_blank"><strong class="nk ir">directory</strong></a>.getAbsolutePath()<br/>        println rootProject.<strong class="nk ir">nyxState.</strong><a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/state-reference/global-attributes/#scheme" rel="noopener ugc nofollow" target="_blank"><strong class="nk ir">scheme</strong></a>.toString()<br/>    }<br/>}</span></pre><p id="5341" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是你可以把它推得更远一点。假设您想仅在倪克斯决定发布新版本时运行某个任务。您可以使它依赖于<code class="fe nh ni nj nk b">nyxState.newRelease</code>属性，如下所示:</p><pre class="kn ko kp kq gt nl nk nm nn aw no bi"><span id="cc7a" class="np ld iq nk b gy nq nr l ns nt">tasks.myReleaseTask.onlyIf { rootProject.<strong class="nk ir">nyxState.</strong><a class="ae kl" href="https://mooltiverse.github.io/nyx/guide/user/state-reference/global-attributes/#new-release" rel="noopener ugc nofollow" target="_blank"><strong class="nk ir">newRelease</strong></a> }</span></pre><p id="e855" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，当<strong class="jp ir">版本</strong>没有改变或者改变了但不应该发布时，你可以跳过不必要的任务。</p><h1 id="bf1b" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">拉/合并提交</h1><p id="1f13" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">当创建<a class="ae kl" href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests" rel="noopener ugc nofollow" target="_blank">拉</a>或<a class="ae kl" href="https://docs.gitlab.com/ee/user/project/merge_requests/" rel="noopener ugc nofollow" target="_blank">合并请求</a>时，您通常会挤压属于合并的提交。这是避免混淆提交历史的好方法，但是从倪克斯的角度来看，这使得属于合并操作的单个提交的消息不可见，它们的消息也是不可见的。换句话说，如果您的意思是提交通过它们的提交消息来触发释放，您将看到倪克斯没有对来自合并请求的提交进行版本控制，因为它不再看到那些消息，并且提交消息约定无法检测它们的意图。这是真的，除非你将合并请求的标题设置为一个<strong class="jp ir">重要的</strong>消息，在这种情况下，倪克斯能够检测到该消息并触发版本。</p></div></div>    
</body>
</html>