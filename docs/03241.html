<html>
<head>
<title>HTML5 Canvas drawing application on Github pages (beginner-friendly tutorial)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Github页面上的HTML5画布绘制应用程序(初学者友好教程)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/html5-canvas-drawing-application-on-github-pages-beginner-friendly-tutorial-5d50b99adb6a?source=collection_archive---------9-----------------------#2020-04-27">https://levelup.gitconnected.com/html5-canvas-drawing-application-on-github-pages-beginner-friendly-tutorial-5d50b99adb6a?source=collection_archive---------9-----------------------#2020-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4dc5ce43ac40a3acc4934418d07ccee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OVwQgakC9OBw6BSxw2FX5Q.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">这是我们将要建造的</figcaption></figure><p id="177e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你好，朋友们，在这一部分，我通常会试着想一些讽刺的/有趣的话来说(作为一种轻松的方式来开始一个潜在的痛苦的教程)。但是在凌晨4点25分思考了五分钟后，我决定继续做下去。因为已经很晚了——也因为这个教程不会很痛苦(耶)。</p><p id="2011" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我一直试图找出如何在网上部署我的一些图像处理代码——在我的大学时代，我的大部分代码都是离线的(又名python脚本，嗯……我也学过其他语言，但我的重点领域是计算机视觉和一些ML/AI东西，所以这是我的借口)。无论如何，我只是想说这个教程是我正在努力的一个更大项目的一部分，但是我想既然这可以是一个独立的项目，为什么不呢？</p><p id="e667" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们开始吧！</p><p id="1621" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将在Github页面上托管这个简单的绘图应用程序。我真的不推荐它是一个静态网站托管服务。这意味着你不能发出AJAX请求之类的东西。但是对于一个基本的画布绘制应用程序来说，这是一种快速而肮脏的方式，直接从GitHub上的存储库中获取HTML、CSS和JavaScript文件，并在线托管它们。这是我第一次试用GitHub页面时提到的<a class="ae ld" href="https://www.thinkful.com/learn/a-guide-to-using-github-pages/" rel="noopener ugc nofollow" target="_blank">链接</a>。只要记得确保你的html文件没有嵌套在一个目录中，因为我听说如果你嵌套了它，GitHub页面可能找不到它。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/b1afb900039431654caf74bd8c9bb4ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LqHvu6j2ugAgli-ajSQiuw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">目录结构</figcaption></figure><p id="4966" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> <em class="lj">注意:我将这个目录命名为pyFlaskDraw，因为我最初打算在这个应用程序中使用python和Flask。但是我发现我不能用GitHub页面轻松地做到这一点，所以请原谅我糟糕的dir命名。可能会在Heroku什么的上继续这个项目。</em> </strong></p><p id="bfb2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在body标签中，我们只严格需要<canvas>标签。此外，我们希望包含javascript文件(第15行)和样式表(第9行)。</canvas></p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lk"><img src="../Images/4c6a51114ec5f6f332cb19375c5657c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kfaMx4U7JFz5UrztjNWHPg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">index.html</figcaption></figure><p id="2fab" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们从编写一个将图像绘制到画布上的函数开始。将您的图像存储在资产/图像目录中。我使用的是assets/images/reinePic.jpg。在这个函数中，我调整了我上传的图像的大小，然后使用这个方法代替默认的HTML canvas drawImage()方法。</p><pre class="lf lg lh li gt ll lm ln lo aw lp bi"><span id="3257" class="lq lr it lm b gy ls lt l lu lv">function drawImageToScale(img, ctx){<br/>    const img_width = 650;<br/>    const scaleFactor = img_width / img.width;<br/>    const img_height = img.height * scaleFactor;<br/>    ctx.drawImage(img, 0, 0,img_width,img_height);<br/>    return [img_width,img_height];<br/>}</span></pre><p id="ef4c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">好了，现在让我们在我们的</p><pre class="lf lg lh li gt ll lm ln lo aw lp bi"><span id="d966" class="lq lr it lm b gy ls lt l lu lv">window.addEventListener(“load”, () =&gt; {}</span></pre><p id="0aa9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">那么在上面的监听器中，我们的{}里面放了什么呢？我们必须首先正确地加载我们的图像和画布，然后在画布上绘制我们的Img。</p><pre class="lf lg lh li gt ll lm ln lo aw lp bi"><span id="a41f" class="lq lr it lm b gy ls lt l lu lv">window.addEventListener("load", () =&gt; {<br/>    const canvas = document.querySelector("#canvas");<br/>    const ctx = canvas.getContext('2d');</span><span id="a980" class="lq lr it lm b gy lw lt l lu lv">    const img = new Image();<br/>    img.src = "assets/images/reinePic.jpg";</span><span id="fe78" class="lq lr it lm b gy lw lt l lu lv">    img.onload = () =&gt; {<br/>        const [img_scaled_width, img_scaled_height] =   drawImageToScale(img, ctx);<br/>        canvas.width = img_scaled_width;<br/>        canvas.height = img_scaled_height;<br/>        window.addEventListener('resize', drawImageToScale(img,ctx));</span><span id="fe4a" class="lq lr it lm b gy lw lt l lu lv">}</span></pre><p id="23f3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在是绘画部分。我们应该考虑三种鼠标事件——鼠标按下、鼠标抬起和鼠标移动。我们使用addEventListeners来检测鼠标事件。所以让我们把这些加进去:</p><pre class="lf lg lh li gt ll lm ln lo aw lp bi"><span id="b98c" class="lq lr it lm b gy ls lt l lu lv">// eventListeners<br/> canvas.addEventListener("mousedown", startPosition);<br/> canvas.addEventListener("mouseup", finishedPosition);<br/> canvas.addEventListener("mousemove", draw)</span></pre><p id="5156" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们需要一个标志变量来告诉我们什么时候应该在图像上绘制像素，什么时候不应该。让我们称这个字母变量为painting，并将其初始化为false:</p><pre class="lf lg lh li gt ll lm ln lo aw lp bi"><span id="a4e2" class="lq lr it lm b gy ls lt l lu lv">let painting = false;</span></pre><p id="5a68" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">beginPath()方法开始一个路径，或者重置当前路径。我们需要两个函数…根据鼠标按下(startPosition)或鼠标抬起(finishedPosition)来做事情</p><pre class="lf lg lh li gt ll lm ln lo aw lp bi"><span id="419a" class="lq lr it lm b gy ls lt l lu lv">function startPosition(e){<br/>    painting = true;<br/>    draw(e);<br/> }</span><span id="b838" class="lq lr it lm b gy lw lt l lu lv">function finishedPosition(){<br/>    painting = false;<br/>    ctx.beginPath();<br/> }</span></pre><p id="de2d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在是绘制函数:</p><pre class="lf lg lh li gt ll lm ln lo aw lp bi"><span id="1e7f" class="lq lr it lm b gy ls lt l lu lv">function draw(e){<br/>    if (!painting)<br/>        return;<br/>    ctx.lineWidth = 3;<br/>    ctx.lineCap = 'round';<br/>    ctx.lineTo(e.clientX, e.clientY);<br/>    ctx.stroke();<br/>    ctx.beginPath();<br/>    ctx.moveTo(e.clientX, e.clientY);<br/> }</span></pre><p id="f61e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请注意，笔画的默认颜色是黑色。如果你想更详细地了解这个绘图工具是如何工作的，可以参考这个<a class="ae ld" href="https://www.youtube.com/watch?v=3GqUM4mEYKA" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="a2c4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">就是这样！</p><p id="de79" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">以下是sketch.js的完整代码:</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae ld" href="https://gist.github.com/Reine0017/52349a63eb3234e316a1ac4a5d1cead2" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/reine 0017/52349 a 63 EB 3234 e 316 a 1a C4 a5 D1 ce ad 2</a></figcaption></figure><p id="145a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">sketch.css只是:</p><pre class="lf lg lh li gt ll lm ln lo aw lp bi"><span id="4b6b" class="lq lr it lm b gy ls lt l lu lv">*{<br/> margin:0;<br/> padding:0;<br/> box-sizing: border-box;<br/>}</span><span id="65fb" class="lq lr it lm b gy lw lt l lu lv">#canvas {<br/> border: 1px solid black;<br/>}</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f68a" class="mg lr it bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">第二部分</h1><p id="b6ce" class="pw-post-body-paragraph kf kg it kh b ki nd kk kl km ne ko kp kq nf ks kt ku ng kw kx ky nh la lb lc im bi translated">好了，现在让我们添加控件！上面的应用程序只是简单的绘图，没有按钮来擦除或改变颜色。让我们添加三个按钮——透明画布，将绘图“笔”的颜色改为黑色或白色。</p><p id="216a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在我们的html中，我在一个绘图组件div中嵌套了<canvas>和一些控制按钮。</canvas></p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae ld" href="https://gist.github.com/Reine0017/c47203b991a163a02a46f4a4d8e76d13" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/reine 0017/c 47203 b 991 a 163 a 02 a 46 f 4 a 4d 8 e 76d 13</a></figcaption></figure><p id="4e59" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">就像我们在画布上所做的一样，我们使用document.querySelector来创建按钮常量，这样我们就可以在这些按钮被按下时注册onClick事件。</p><pre class="lf lg lh li gt ll lm ln lo aw lp bi"><span id="f842" class="lq lr it lm b gy ls lt l lu lv">const clearButton = document.querySelector('#clear');<br/>const blackButton = document.querySelector('#blackColour');<br/>const whiteButton = document.querySelector('#whiteColour');</span></pre><p id="30f5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于eventListeners:</p><pre class="lf lg lh li gt ll lm ln lo aw lp bi"><span id="df4e" class="lq lr it lm b gy ls lt l lu lv">clearButton.addEventListener('click', () =&gt; clearCanvas(img, ctx, canvas.width, canvas.height));<br/>blackButton.addEventListener('click', () =&gt; ctx.strokeStyle = "#000000");<br/>whiteButton.addEventListener('click', () =&gt; ctx.strokeStyle = "#ffffff");</span></pre><p id="ee14" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">clearCanvas函数还没写。但是我们可以在“加载”窗口eventListener之外编写一个函数:</p><pre class="lf lg lh li gt ll lm ln lo aw lp bi"><span id="4acc" class="lq lr it lm b gy ls lt l lu lv">function clearCanvas(img,ctx,img_scaled_width,img_scaled_height){<br/>    ctx.clearRect(0,0, img_scaled_width, img_scaled_height);<br/>    drawImageToScale(img, ctx);<br/>}</span></pre><p id="5af3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">完整的情况是这样的:</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae ld" href="https://gist.github.com/Reine0017/be7403b8df860aa469424443017c7f99" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/reine 0017/be 7403 b 8df 860 aa 469424443017 c7f 99</a></figcaption></figure><p id="4671" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后，对于css，它更多的是一个个人偏好的东西，所以我不会在这里详细阐述。如果您有任何其他问题，请联系我！</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae ld" href="https://gist.github.com/Reine0017/16e927e4fbea45dea388e0c34d8b7c17" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/reine 0017/16e 927 e 4 fbea 45 de a 388 E0 c 34d 8 b 7c 17</a></figcaption></figure><p id="c688" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">就是这样！感谢大家阅读我的教程:)</p><p id="aad6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果有些部分解释得不太清楚，我可以理解。但是在一篇文章中，我在媒体上解释事情的能力是有限的。我会尽快创建并上传一个YouTube视频，然后在这里更新:)</p><p id="f61f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">更新:这是YouTube的链接:<a class="ae ld" href="https://youtu.be/KZAb2Ikr_YQ" rel="noopener ugc nofollow" target="_blank">https://youtu.be/KZAb2Ikr_YQ</a></p><p id="9028" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">画图快乐！</p></div></div>    
</body>
</html>