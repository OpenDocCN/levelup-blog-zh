<html>
<head>
<title>Making Sense of React Inline Styles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解React内联样式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/making-sense-of-react-inline-styles-f521d9c511b3?source=collection_archive---------1-----------------------#2020-09-28">https://levelup.gitconnected.com/making-sense-of-react-inline-styles-f521d9c511b3?source=collection_archive---------1-----------------------#2020-09-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/c0a4bee7eb0060205eb22e30f5dc1dc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wxuVUeRWqmn94gjSIqYgEg.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">托马斯·布兰查德的《色彩》</figcaption></figure><div class=""/><div class=""><h2 id="f277" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">React内联样式通常不是在react项目中使用CSS的首选解决方案。有正当理由。但是在某些情况下，作为开发人员，我们只需要适应涉众的决定。</h2></div><p id="2064" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，明确声明:我是SCSS和CSS模块的忠实粉丝，这是比内嵌样式更快更强大的解决方案。在使用内联样式之前，您还应该尝试其他解决方案，比如StyledComponents、CSS-in-JS。我决定写这篇文章给所有需要使用内联样式并且不能/不想使用其他提到的解决方案的人。如果你想回顾值得一提的react组件样式选项，你可以查看Sitepoint 上的这篇文章和Freecodecamp 上的这篇文章。</p><p id="4112" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">已经有很多有效的观点表明react内联风格不是一个好主意。不支持CSS选择器，例如“:悬停”、“活动”、“焦点”、“之前”和“之后”、媒体查询，也不支持SCSS语法。</p><p id="6b6c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有什么优势吗？其中几个:</p><ul class=""><li id="3ec6" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">这是一个快速的解决方案，</li><li id="6141" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">我们的项目中不需要安装额外的包，</li><li id="9294" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">不需要CSS文件存储样式，</li><li id="bba8" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">我们可以自由地使用react state来从中派生样式，</li><li id="5159" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">不需要使用类。</li></ul><p id="ae88" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">React内联样式的一个简单示例:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="ed41" class="mr ms jj mn b gy mt mu l mv mw">function Button() {    <br/> return (<br/>  &lt;div<br/>    style={{<br/>      borderRadius: '6px',<br/>      border: '1px solid',<br/>      borderColor: 'red',<br/>      color: 'red,<br/>      padding: '8px 16px', <br/>    }}<br/>    onClick={(e) =&gt; handleClick(e)}&gt;<br/>    Click Me<br/>  &lt;/div&gt;<br/>)</span></pre><p id="127e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们立刻发现大部分代码都是css样式的。我们很想使用<code class="fe mx my mz mn b">className</code>并将代码转移到CSS/SCSS/Less文件中。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="5a41" class="mr ms jj mn b gy mt mu l mv mw">export function Button() {    <br/> return (<br/>  &lt;div<br/>    className="button"<br/>    onClick={handleClick}&gt;<br/>    Click Me<br/>  &lt;/div&gt;<br/>)</span></pre><p id="082b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这确实要清楚得多，但这是我们的要求所禁止的。让我们做点别的吧。将样式提取为单独的对象:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="a340" class="mr ms jj mn b gy mt mu l mv mw">const buttonStyle = {<br/>  borderRadius: '6px',<br/>  border: '1px solid',<br/>  borderColor: 'red',<br/>  color: 'red,<br/>  padding: '8px 16px', <br/>};</span><span id="8439" class="mr ms jj mn b gy na mu l mv mw">export function Button() {    <br/> return (<br/>  &lt;div<br/>    style={buttonStyle}<br/>    onClick={handleClick}&gt;<br/>    Click Me<br/>  &lt;/div&gt;<br/>)</span></pre><p id="a696" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好了，我们去掉了组件的冗长性。我们如何在这样的对象中使用组件状态？一点用都没有。</p><p id="2789" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以将<code class="fe mx my mz mn b">buttonStyle</code>提升到一个返回对象的函数，并将相关的组件状态作为参数传递给它:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="bc20" class="mr ms jj mn b gy mt mu l mv mw">const buttonStyle = <strong class="mn jk">({hover}) =&gt; (</strong>{<br/>  borderRadius: '6px',<br/>  border: '1px solid',<br/>  borderColor: <strong class="mn jk">hover</strong> ? 'black' : 'red',<br/>  color: <strong class="mn jk">hover</strong> ? 'black': 'red',<br/>  padding: '8px 16px', <br/>}<strong class="mn jk">)</strong></span><span id="473e" class="mr ms jj mn b gy na mu l mv mw">export function Button() {<br/> <strong class="mn jk">const [hover, setHover] = useState(false);</strong>    <br/> return (<br/>  &lt;div<br/>    style={buttonStyle<strong class="mn jk">({hover})</strong>}<br/><strong class="mn jk">    onPointerOver={()=&gt; setHover(true)}<br/>    onPointerOut={() =&gt; setHover(false)}</strong><br/>    onClick={handleClick}<br/>  &gt;<br/>    Click Me<br/>  &lt;/div&gt;<br/>)</span></pre><p id="ec7f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里发生了什么？我们引入了按钮组件的一些与样式相关的状态— <code class="fe mx my mz mn b">hover</code>，并在<code class="fe mx my mz mn b">onPointerOver</code>和<code class="fe mx my mz mn b">onPointerOut</code>事件中改变了这个状态。这模拟CSS <code class="fe mx my mz mn b">:hover</code>选择器。</p><p id="4e17" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以用同样的方法来模拟<code class="fe mx my mz mn b">:focus</code>和<code class="fe mx my mz mn b">:active</code>选择器:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="b831" class="mr ms jj mn b gy mt mu l mv mw">const buttonStyle = ({hover, <strong class="mn jk">focus, active</strong> }) =&gt; ({<br/>  borderRadius: '6px',<br/>  border: '1px solid',<br/>  borderColor: hover ? 'black' : 'red',<br/>  color: hover ? 'black': 'red',<br/>  padding: '8px 16px', <br/>}<strong class="mn jk">)</strong></span><span id="cc33" class="mr ms jj mn b gy na mu l mv mw">export function Button() {<br/> const [hover, setHover] = useState(false);<strong class="mn jk"><br/> const [focus, setFocus] = useState(false);<br/> const [active, setActive] = useState(false);</strong>  <br/>  <br/> return (<br/>  &lt;div<br/>    style={buttonStyle({hover, <strong class="mn jk">focus, active</strong>})}<br/>    tabIndex="0"<br/>    onPointerOver={()=&gt; setHover(true)}<br/>    onPointerOut={() =&gt; setHover(false)}<strong class="mn jk"><br/>    onFocus={()=&gt; setFocus(true)}<br/>    onBlur={() =&gt; setFocus(false)}<br/>    onPointerDown={()=&gt; setActive(true)}<br/>    onPointerUp={() =&gt; setActive(false)}<br/>    </strong>onClick={handleClick}<br/>  &gt;<br/>    Click Me<br/>  &lt;/div&gt;<br/>)</span></pre><p id="0929" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这需要大量的新代码，更重要的是，组件的每次重新渲染都会调用<code class="fe mx my mz mn b">buttonStyle</code>函数。因为我们很可能会将更多的状态和其他属性传递给按钮，这是一个很大的禁忌。另外一个问题是如何用新的选择器设置css属性，我们需要很多嵌套的“if”来在样式函数中正确处理这个问题。</p><p id="9a8c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦我们开始添加其他不影响风格的按钮状态，我们会很快被我们所做的一切弄得发疯。</p><p id="6317" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们如何解决这个问题？</p><p id="6243" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">理想情况下，我们希望为组件保留一个样式函数，然后将它包含在组件的状态中。我们可以用定制的钩子来做。姑且称之为<code class="fe mx my mz mn b">useInlineStyle</code>。我们的钩子将接受样式函数和其他一些我们想在样式函数中使用的道具。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="63ff" class="mr ms jj mn b gy mt mu l mv mw">const initialState = {<br/>  hover: false,<br/>  focus: false,<br/>  active: false<br/>}</span><span id="1787" class="mr ms jj mn b gy na mu l mv mw">function useInlineStyle(stylingFn, props) {<br/>  const [styleState, dispatch] = useReducer(reducer, initialState);</span><span id="9dc3" class="mr ms jj mn b gy na mu l mv mw">  const style = useMemo(() =&gt; { <br/>    return stylingFn(styleState, props)<br/>  }, [stylingFn, styleState, props);</span><span id="3bbd" class="mr ms jj mn b gy na mu l mv mw">  const setStyle = (type, value) =&gt; dispatch({type, value});<br/>  <br/>  return [style, setStyle];</span><span id="2613" class="mr ms jj mn b gy na mu l mv mw">}</span><span id="3416" class="mr ms jj mn b gy na mu l mv mw">function reducer(state, action) {<br/>  switch(action.type) {<br/>    case 'hover': return { ...state, hover: action.value }<br/>    case 'focus': return { ...state, focus: action.value }<br/>    case 'active': return { ...state, active: action.value }<br/>    default: return state;</span><span id="deed" class="mr ms jj mn b gy na mu l mv mw">  }</span><span id="006b" class="mr ms jj mn b gy na mu l mv mw">}</span></pre><p id="bab2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">并在我们的按钮中使用它:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="9f10" class="mr ms jj mn b gy mt mu l mv mw">const buttonStyle = (state, props) =&gt; ({<br/>  borderRadius: '6px',<br/>  border: '1px solid',<br/>  borderColor: state.hover ? 'black' : 'red',<br/>  color: state.hover ? 'black': 'red',<br/>  padding: '8px 16px', <br/>  width: props.isMobile ? '90%' : '200px'<br/>}<strong class="mn jk">)</strong></span><span id="2f47" class="mr ms jj mn b gy na mu l mv mw">export function Button({ busy, isMobile }) {<br/> const [style, setStyle] = useInlineStyle(<br/>   buttonStyle, { busy, isMobile }<br/> );  </span><span id="43ab" class="mr ms jj mn b gy na mu l mv mw"> return (<br/>  &lt;button<br/>    style={style}<br/>    onPointerOver={()=&gt; setStyle('hover', true)}<br/>    onPointerOut={() =&gt; setStyle('hover', false)}<strong class="mn jk"><br/></strong>    onFocus={()=&gt; setStyle('focus', true)}<br/>    onBlur={() =&gt; setStyle('focus', false)}<br/>    onPointerDown={()=&gt; setStyle('active', true)}<br/>    onPointerUp={() =&gt; setStyle('active', false)}<strong class="mn jk"><br/>    </strong>onClick={handleClick}<br/>  &gt;<br/>    Click Me<br/>  &lt;/button&gt;<br/>)</span></pre><p id="092c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">钩子负责生成样式，但是我们仍然需要手动将<code class="fe mx my mz mn b">setStyle</code>附加到指针事件上。我们可以把它移到钩子上，为按钮提供一个<code class="fe mx my mz mn b">ref</code>，并在<code class="fe mx my mz mn b">useEffect</code>中处理事件监听器，这样会更好。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="182a" class="mr ms jj mn b gy mt mu l mv mw">function useInlineStyle(styleFn, props) {<br/>  <strong class="mn jk">const ref = useRef(null); </strong><br/>  const [styleState, dispatch] = useReducer(<br/>    styleReducer, initialState);</span><span id="ca1e" class="mr ms jj mn b gy na mu l mv mw">  const setStyle = (type, value) =&gt; dispatch({ type, value })</span><span id="1e3a" class="mr ms jj mn b gy na mu l mv mw">  const style = useMemo(<br/>    () =&gt; styleFn(styleState, props), <br/>    [styleFn, styleState, props]<br/>  );</span><span id="8a5f" class="mr ms jj mn b gy na mu l mv mw">  <strong class="mn jk">useEffect(() =&gt; {<br/>    let el;</strong></span><span id="c16a" class="mr ms jj mn b gy na mu l mv mw"><strong class="mn jk">    const pointerOver = () =&gt; setStyle("hover", true);<br/>    const pointerOut = () =&gt; setStyle("hover", false);<br/>    const focus = () =&gt; setStyle("focus", true);<br/>    const blur = () =&gt; setStyle("focus", false);<br/>    const pointerDown = () =&gt; setStyle("active", true);<br/>    const pointerUp = () =&gt; setStyle("active", false);</strong></span><span id="1709" class="mr ms jj mn b gy na mu l mv mw"><strong class="mn jk">    if(ref.current) {<br/>      el = ref.current;<br/>      el.addEventListener('pointerover', pointerOver)<br/>      el.addEventListener('pointerout', pointerOut)<br/>      el.addEventListener('focus', focus)<br/>      el.addEventListener('blur', blur)<br/>      el.addEventListener('pointerdown', pointerDown)<br/>      el.addEventListener('pointerup', pointerUp)<br/>    }</strong></span><span id="ff90" class="mr ms jj mn b gy na mu l mv mw"><strong class="mn jk">    return () =&gt; {<br/>      el.removeEventListener('pointerover', pointerOver)<br/>      el.removeEventListener('pointerout', pointerOut)<br/>      el.removeEventListener('focus', focus) <br/>      el.removeEventListener('blur', blur) <br/>      el.removeEventListener('pointerdown', pointerDown)<br/>      el.removeEventListener('pointerup', pointerUp)<br/>    }<br/>  }, [ref, setStyle])</strong></span><span id="3089" class="mr ms jj mn b gy na mu l mv mw"><strong class="mn jk">  return [ref, style];</strong></span><span id="6f19" class="mr ms jj mn b gy na mu l mv mw">}</span></pre><p id="f455" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们只需要将<code class="fe mx my mz mn b">ref</code>从钩子传递给我们的组件。不需要手动使用<code class="fe mx my mz mn b">setStyle</code>。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="1ca8" class="mr ms jj mn b gy mt mu l mv mw">const buttonStyle = (state, props) =&gt; ({<br/>  borderRadius: '6px',<br/>  border: '1px solid',<br/>  borderColor: state.hover ? 'black' : 'red',<br/>  color: state.hover ? 'black': 'red',<br/>  padding: '8px 16px', <br/>  width: props.isMobile ? '90%' : '200px'<br/>}<strong class="mn jk">)</strong></span><span id="0044" class="mr ms jj mn b gy na mu l mv mw">export function Button({ isMobile }) {<br/> const <strong class="mn jk">[buttonRef, style]</strong> = useInlineStyle(<br/>   buttonStyle, { isMobile }<br/> ); <br/> <br/> return (<br/>   &lt;div<br/>    <strong class="mn jk">ref={buttonRef}</strong><br/>    style={style}<strong class="mn jk"><br/>    </strong>onClick={handleClick}<br/>   &gt;<br/>    Click Me<br/>   &lt;/div&gt;<br/>);</span></pre><p id="b236" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个按钮看起来干净多了，我们可以像<code class="fe mx my mz mn b">onPointerUp</code>一样将自定义代码附加到事件监听器上，而不用担心样式。</p><p id="959d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到目前为止，为了简洁起见，我们对按钮使用了最少的样式。在真实情况下，当用户按压、聚焦或特定道具改变时，我们的<code class="fe mx my mz mn b">buttonStyle</code>将显著增长以处理样式。如前所述，这将使我们的造型功能变得丑陋。</p><p id="03c2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了减轻这种情况，我们可以添加一个<code class="fe mx my mz mn b">buttonTheme</code>对象，在其中存储按钮样式的所有变量和规则。我们将在样式功能中使用该主题。以下是主题和挂钩的示例:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="fe29" class="mr ms jj mn b gy mt mu l mv mw">const theme = {<br/>  borderColor: {<br/>    default: 'black',<br/>    hover: 'red',<br/>    active: 'blue',<br/>    focus: 'blue',<br/>  },<br/>  color: {<br/>    default: 'black',<br/>    hover: 'white',<br/>    active: 'white',<br/>    focus: 'blue',<br/>  },<br/>  backgroundColor: {<br/>   default: 'white',<br/>   hover: 'red',<br/>   active: 'navy',<br/>   focus: 'white',<br/>  },<br/>  getColor(prop, { hover, focus, active }) {<br/>    const v = this[prop];<br/>    if (active) return v['active'];<br/>    if (focus &amp;&amp; !hover) return v['focus'];<br/>    if (hover) return v['hover'];<br/>    return v['default'];<br/>  }</span><span id="8aed" class="mr ms jj mn b gy na mu l mv mw">};</span><span id="608b" class="mr ms jj mn b gy na mu l mv mw">function getButtonStyle(state, props) {<br/>  return {<br/>    outline: "none",<br/>    userSelect: "none",<br/>    textAlign: "center",<br/>    borderRadius: "8px",<br/>    border: "1px solid",<br/>    padding: "8px 12px",<br/>    cursor: "pointer",<br/>    transition: "0.3s all",<br/>    borderColor: theme.getColor("borderColor", state),<br/>    color: theme.getColor("color", state),<br/>    backgroundColor: theme.getColor("backgroundColor", state),<br/>    width: props.isMobile ? "90%" : "200px",<br/>  };<br/>}</span><span id="9373" class="mr ms jj mn b gy na mu l mv mw"><br/>function Button({ children, isMobile, onClick }) {<br/>  const [buttonRef, buttonStyle] = useInlineStyle(<br/>    getButtonStyle, { isMobile }<br/>  );</span><span id="2ec9" class="mr ms jj mn b gy na mu l mv mw">  return (<br/>    &lt;div<br/>      tabIndex="0"<br/>      ref={buttonRef}<br/>      style={buttonStyle}<br/>      onPointerOver={() =&gt; console.log("over")}<br/>      onClick={onClick}&gt;{children}<br/>    &lt;/div&gt;<br/>  );</span><span id="033c" class="mr ms jj mn b gy na mu l mv mw">}</span></pre><p id="eb8e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" href="https://codesandbox.io/s/wispy-leaf-khttu?file=/src/Button.js" rel="noopener ugc nofollow" target="_blank">code sandbox上的完整代码和工作示例</a></p><figure class="mi mj mk ml gt iv"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="0441" class="nd ms jj bd ne nf ng nh ni nj nk nl nm kp nn kq no ks np kt nq kv nr kw ns nt bi translated">感谢阅读！</h1><p id="b5ae" class="pw-post-body-paragraph ky kz jj la b lb nu kk ld le nv kn lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">你认为解决方案怎么样？你在你的项目中使用内联样式吗？如果是，怎么做？如果不是，你喜欢的组件样式是什么？请在评论中告诉我！</p></div></div>    
</body>
</html>