<html>
<head>
<title>5 Benefits of String Immutability in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#中字符串不变性的5个好处</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-benefits-of-immutable-strings-in-c-a3d2c7c9eb6d?source=collection_archive---------0-----------------------#2021-01-27">https://levelup.gitconnected.com/5-benefits-of-immutable-strings-in-c-a3d2c7c9eb6d?source=collection_archive---------0-----------------------#2021-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/00e8d125e95591bf5e9635e48b03f08d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sX6dzkNAwLV2sdjE"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kf" href="https://unsplash.com/@perloov?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">记者</a>拍摄</figcaption></figure><p id="4128" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你试图在C#中修改一个字符串对象，将会创建一个新的对象。原始字符串将保持不变。这种技术被称为<strong class="ki iu">不变性</strong>。像任何其他技术一样，不变性有它的优点和缺点。C#开发人员都知道这个缺点，通过用StringBuilder类型替换字符串可以减轻这个缺点。字符串不变性的优点更值得讨论，这是我们接下来5分钟的计划。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="e301" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">没有副作用</h1><p id="ac9f" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">应用程序的不同部分可以依赖于单个对象。应用程序的一部分可以在某个条件语句中使用这个对象，根据对象的状态做出决定。应用程序的第二、第三和其他部分具有类似的逻辑。一切都会很顺利，直到有人决定改变物体的状态。很难预测这种变化将如何影响应用程序的不同部分。如果不进行深入研究，甚至很难确切知道哪些功能面临风险。</p><div class="mo mp gp gr mq mr"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-fix-bugs-and-not-introduce-new-ones-9f35e625673a"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd iu gy z fp mw fr fs mx fu fw is bi translated">如何在不破坏应用程序的情况下修复Bug</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">更改源代码时更自信的步骤。</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf jz mr"/></div></div></a></div><p id="7ec9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述情况称为副作用。最小化应用程序中副作用风险的一种方法是使用不可变的数据类型，string就是其中之一。代码的几个部分可以依赖于同一个string对象，但是它们不会受到修改字符串的影响，因为字符串是不可变的。任何试图改变字符串的人都会得到一个副本。</p><p id="b9b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不变性剩下的四个好处只是“无副作用”好处的特例。然而，仅仅笼统地谈论副作用就像描述单一责任原则，却只字不提解决SRP问题的模式，如装饰者、中介状态、责任链等。</p><p id="770b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，我们继续。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="1bd2" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">即时克隆</h1><p id="9bd5" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">当需要克隆某种引用数据类型的机制时，开发人员实现原型设计模式。根据克隆的类型(深层或浅层)、对象图的大小以及其他额外要求，克隆逻辑可以复杂、不复杂或相对简单。</p><p id="7f49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，对于不可变的数据类型，克隆逻辑非常简单:<strong class="ki iu">只需从克隆方法</strong>返回“this”指针。</p><p id="daf7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您使用dotPeek之类的工具检查string数据类型的实现，您会发现Clone方法的以下代码:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="fbda" class="np lm it nl b gy nq nr l ns nt">public sealed partial class String : IComparable, IEnumerable,...<br/>{ <br/>  <br/>    ...</span><span id="9ec9" class="np lm it nl b gy nu nr l ns nt">    public object Clone()<br/>    {<br/>        return this;<br/>    }</span><span id="0da2" class="np lm it nl b gy nu nr l ns nt">    ...</span><span id="998c" class="np lm it nl b gy nu nr l ns nt">}</span></pre><p id="b1a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是为字符串和其他不可变数据类型(包括自定义数据类型)实现克隆的意义。不需要分配内存，复制原始字符串，并返回对新副本的引用。</p><p id="82de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果某个消费者需要一个克隆的字符串，它会获得对原始字符串对象的引用。如果消费者需要在只读模式下使用字符串对象，他可以这样做，因为这是安全的。如果使用者需要修改字符串，将创建副本，因此原始对象不受影响。</p><p id="bccf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果某个消费者需要一个克隆的字符串，它会获得对原始字符串对象的引用。如果使用者需要在只读模式下使用字符串对象，它可以这样做，因为它是安全的。只要消费者需要更改字符串，就会进行复制，因此原始字符串不会受到影响。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="e086" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">字符串实习</h1><p id="1b98" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">字符串滞留机制通过在内存中为几个相同的字符串创建一个对象来帮助减少内存消耗。</p><p id="b161" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">内存中不会有三个string对象，执行下面这段代码时只有一个:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="cd2a" class="np lm it nl b gy nq nr l ns nt">string name1 = "Guy Ritchie";<br/>string name2 = "Guy Ritchie";<br/>string name3 = "Guy Ritchie";</span></pre><p id="e5e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编译器将检测相同的字符串文字，并生成在托管堆中分配单个盖·里奇字符串对象的指令，所有三个变量name1、name2、name3将指向同一个对象。</p><p id="77ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果代码试图用变量name3修改盖·里奇对象，将创建一个新对象，name3将引用新创建的对象，而变量name1和name2将继续引用旧对象。</p><p id="25a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是假设字符串是C#中普通的可变对象。编译器仍然为多个相同的字符串创建一个对象，不同的变量引用同一个字符串对象。你认为这是一种预期的行为吗？</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="97b4" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">线程安全</h1><p id="9710" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">当两个或多个线程同时修改同一个string对象时，不需要担心同步技术。不变性使得字符串线程安全，所以并发或死锁问题是不可能的。只要有几个线程处理同一个字符串对象，它就是完全安全的。</p><p id="866d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果多个线程修改同一个字符串对象，则不需要同步对该字符串的访问。每次尝试修改字符串对象都会导致创建一个新的对象，因此每个线程都将使用自己的字符串副本。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="4778" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">代码可读性</h1><p id="4f60" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">当代码处理不可变数据类型而不是可变数据类型时，它更容易阅读。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="ae3d" class="np lm it nl b gy nq nr l ns nt">public void DoSomething()<br/>{<br/>    var person = new Person();<br/>    person.Name = "Guy Ritchie";<br/>    DoSomethingMore(person);<br/>    Console.WriteLine(person.Name);<br/>}</span></pre><p id="559e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">开发人员只能尝试预测将显示哪个名称。这个名字可能仍然是盖·里奇。但也可能是布拉德·皮特或其他名字，或者根本不是一个名字。通过阅读代码找出真正价值的唯一方法是更深入地研究嵌套方法调用的实现细节。</p><p id="68da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是当开发人员阅读使用不可变数据类型编写的代码时，情况就不同了。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="b7b0" class="np lm it nl b gy nq nr l ns nt">public void DoSomething()<br/>{<br/>   string name = "Guy Ritchie";<br/>   DoSomethingMore(name);<br/>   Console.WriteLine(name);<br/>}</span></pre><p id="8eb7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">开发人员甚至不需要检查DoSomethingMore方法的实现细节就可以确定名称保持不变。这节省了大量学习现有代码行为的时间。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="a96c" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="ca31" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">记住，不变性不仅仅是关于字符串。不变性方法只在字符串和许多其他数据类型中实现。您还可以使您的自定义数据类型不可变，以获得我们讨论的所有好处。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="0159" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">关于可维护性的更多信息</h1><div class="mo mp gp gr mq mr"><a href="https://medium.com/codex/how-dependency-inversion-and-inversion-of-control-help-to-build-maintainable-software-systems-df9b61b07c75" rel="noopener follow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd iu gy z fp mw fr fs mx fu fw is bi translated">依赖反转和控制反转如何帮助构建可维护的软件系统</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">对象是面向对象编程的基本概念之一。对象封装了一组数据…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">medium.com</p></div></div><div class="na l"><div class="nv l nc nd ne na nf jz mr"/></div></div></a></div></div></div>    
</body>
</html>