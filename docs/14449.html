<html>
<head>
<title>Can you compare GraphQL and tRPC?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">能不能比较一下GraphQL和tRPC？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/can-you-compare-graphql-and-trpc-572e8b98bf48?source=collection_archive---------25-----------------------#2022-11-28">https://levelup.gitconnected.com/can-you-compare-graphql-and-trpc-572e8b98bf48?source=collection_archive---------25-----------------------#2022-11-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a44b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Twitter上有很多关于“GraphQL与tRPC”为应用程序构建一个现代后端的讨论。GraphQL作为REST的事实上的继任者在最近几年变得流行起来，而tRPC则解决了全栈应用中的端到端安全问题。这就像<a class="ae kl" href="https://twitter.com/alexdotjs/status/1597182082941595648?s=20&amp;t=hisusYuNOJ46q08HF8Is8w" rel="noopener ugc nofollow" target="_blank">把苹果比作橘子</a>。</p><p id="1125" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TLDR；GraphQL是一种查询语言，tRPC是一个库。</p><p id="17d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为一名在过去几年中使用GraphQL的开发人员，这引发了我对两者进行比较，看看他们都擅长什么(以及不擅长什么)。</p><p id="cc24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">点击下图观看这篇博文的<a class="ae kl" href="http://www.youtube.com/watch?v=_Tc7YVR-0LU" rel="noopener ugc nofollow" target="_blank"> YouTube视频版本</a>:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/e26d85ccd2efb38ff471a39887edd20c.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*9lZyetKfTF62JZj9.jpg"/></div></figure><h2 id="f712" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">但首先；您可能一直在错误地使用GraphQL</h2><p id="0acc" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">GraphQL是您的API的查询语言，它不是REST的一对一替代。这是一种比REST更灵活的查询API的方式，让您可以控制请求的响应。在许多Twitter对话中，我发现人们将GraphQL与REST进行比较，这与GraphQL是不同的。此外，GraphQL类型系统并不意味着用于端到端类型安全，至少不是以第一种方式。相反，这是一种记录API并确保API运行时类型正确的方法。</p><h2 id="d3df" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">我们可以对比GraphQL和tRPC吗？</h2><p id="81c5" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">GraphQL是API的查询语言，而tRPC是一组用于构建端到端类型安全API的库。如前所述，这就像把苹果比作橘子。但是让我们把他们两个都分解一下，了解一下他们的特点。</p><h2 id="52e6" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">GraphQL是一种查询语言</h2><p id="badc" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">GraphQL APIs通常使用HTTP作为传输层，GraphQL查询作为POST请求发送给API。然后，API处理查询，并将结果作为JSON响应返回。这与REST APIs的工作方式相同，但GraphQL是一种查询语言，而不是一种协议。这意味着您可以在任何传输层和任何协议上使用GraphQL。这也是为什么你可以在你的前端应用中使用GraphQL，因为它只是一种查询语言。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ls"><img src="../Images/f3bf6694292263a4f60a74781775fe8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AQLMpU6KSy6SFNMB.png"/></div></div></figure><p id="0b89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">GraphQL本身只不过是一种查询语言，根据它的规范，由GraphQL实现库和框架来实现这种查询语言。这意味着实现GraphQL有很多不同的方式，使用GraphQL也有很多不同的方式。这也是为什么在您的前端应用程序中有许多不同的使用GraphQL的方法。</p><h2 id="f2e0" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">tRPC是一个库</h2><p id="f7e9" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">tRPC是一组使用TypeScript来确保整个应用程序的类型安全的库。它的主要目的是使在单个代码库中构建端到端的类型安全应用程序变得容易。基础是一个tRPC服务器，您可以在其中定义端点(或路由)、这些端点的类型定义，并处理与数据源(如数据库)的任何连接。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi lx"><img src="../Images/1c6cd27c369558fa6f7668e4d96ad561.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*96_lta3aM8Ylnwax.png"/></div></div></figure><p id="9bc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用tRPC客户端库在前端应用程序中使用tRPC API。您不是直接发送HTTP请求来获取数据，而是让tRPC客户端为您处理，就像API的ORM一样。这个客户端可以在不依赖代码生成的情况下进行强类型API调用。您可以将TypeScript类型从服务器直接导入前端应用程序，而无需生成任何代码。</p><h2 id="4e08" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">GraphQL和tRPC有什么区别？</h2><p id="9461" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">这是一个非常主观的问题，但我认为知道GraphQL和tRPC的区别是很重要的。这样，您可以自己决定在应用程序中使用什么。</p><h2 id="b51e" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">GraphQL非常适合查询多个数据源</h2><p id="8685" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">GraphQL擅长将多个数据源组合成一个查询。GraphQL经常用于数据建模和架构，它非常适合这一点。例如，如果您想查询来自一个服务的数据(比如一个Headless CMS)和来自另一个服务的数据(比如一个数据库)，您可以使用GraphQL在一个查询中完成。您甚至可以在字段或类型级别组合这些数据。这是脸书和GitHub等公司使用GraphQL的主要原因之一。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ly"><img src="../Images/7aa36453dd51082b08c22bdf4b467d26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MkyOkPiCOde4keWC.png"/></div></div></figure><p id="7072" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lz">推文来自</em> <a class="ae kl" href="https://twitter.com/notrab" rel="noopener ugc nofollow" target="_blank"> <em class="lz">杰米·巴顿</em> </a> <em class="lz">和</em> <a class="ae kl" href="https://twitter.com/tazsingh" rel="noopener ugc nofollow" target="_blank"> <em class="lz">塔兹·辛格</em> </a> <em class="lz">。</em></p><p id="fd0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而tRPC并不真正意味着这一点。它旨在构建端到端的类型安全API，而不是真正用于组合多个数据源。你可以这么做，但这不是tRPC的目的。</p><h2 id="4598" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">tRPC非常适合端到端类型的安全</h2><p id="053d" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">tRPC对于端到端的类型安全非常有用，它允许您在前端应用程序中使用与后端应用程序中相同的类型。GraphQL没有在前端和后端之间共享类型定义的内置方法，但是您可以使用GraphQL模式来生成TypeScript类型定义。但这不同于端到端类型的安全。每次更新GraphQL模式时，都必须重新生成类型。</p><p id="3eb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当使用tRPC时，您正在使用TypeScript构建一切。这意味着您可以将类型从服务器直接导入到您的前端应用程序中。tRPC客户端可以直接从tRPC服务器访问TypeScript类型。在您的前端应用程序中查询tRPC时，您不需要外部库，因为它都内置在tRPC库中。</p><h2 id="3f40" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">GraphQL允许解耦服务；单一代码库的tRPC</h2><p id="8660" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">GraphQL非常适合去耦服务，因为它与编程语言和传输层无关。这意味着您可以使用任何编程语言和任何传输层。公开GraphQL API的服务可以用任何编程语言实现，例如TypeScript和Go，并且仍然能够相互通信。对于技术多样化的团队和公司来说，这是一个扩展和限制团队间依赖性的好方法。</p><p id="110e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">tRPC并不真的是为了这个。它意味着在一个单一的代码库中，在TypeScript中构建端到端的类型安全API！它将前端和后端紧密地结合在一起，例如在monorepo中。您可以在前端和后端应用程序中使用相同的类型，这允许您快速迭代您的应用程序。如果您正在构建一个全栈TypeScript项目，有什么不喜欢的呢？</p><h2 id="6777" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">tRPC比GraphQL更容易使用</h2><p id="7df4" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">“tRPC比GraphQL更容易使用”是人们在比较GraphQL和tRPC时经常使用的说法。但是由于tRPC是一个库，而GraphQL是一种查询语言，所以不可能进行比较。对于GraphQL，由开发人员使用许多可用的实现之一来构建GraphQL，而tRPC是一组可以开箱即用的库。这使得它不是一个公平的比较，但无论如何让我们打破它。</p><p id="31e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，您可以使用模式优先的GraphQL服务器库构建一个GraphQL API。您必须定义一个GraphQL模式，编写解析器从数据源收集数据，然后从该模式生成类型。作为一名开发人员，走这条路需要做大量的工作，并且需要做出许多选择。</p><p id="fd9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是您也可以使用代码优先的GraphQL服务器库来构建GraphQL API。这意味着您可以编写解析器，然后从解析器生成模式。就开发人员体验而言，代码优先库更接近tRPC，但仍然比使用像<a class="ae kl" href="https://stepzen.com/" rel="noopener ugc nofollow" target="_blank"> StepZen </a>这样的GraphQL即服务更具挑战性。</p><p id="6812" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，您还可以选择各种各样的GraphQL客户端库。您可以使用GraphQL客户端库，如<a class="ae kl" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank"> Apollo Client </a>或<a class="ae kl" href="https://formidable.com/open-source/urql/" rel="noopener ugc nofollow" target="_blank"> urql </a>来帮助您进行缓存和状态管理，或者使用只处理HTTP请求的库。有许多选择，当您刚接触GraphQL时可能不清楚。</p><h2 id="0540" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">结论</h2><p id="c261" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">在这篇博文中，我解释了GraphQL和tRPC的区别。我希望这篇博文能帮助你理解这两者之间的区别，并希望你现在能更好地决定在你的下一个项目中使用哪一个。在GraphQL和tRPC之间进行选择时，要问自己的主要问题是:</p><ul class=""><li id="f251" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">您是否希望在一个查询中查询多个数据源，并保持您的服务解耦？如果是这样，GraphQL是一个完美的选择。如果您想要端到端的类型安全，并且不关心前端和后端的解耦，tRPC是更好的选择。</li><li id="ad74" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">你打算使用多种编程语言吗？选择GraphQL，因为它是与编程语言无关的。如果您想在整个应用程序中使用TypeScript，tRPC可能是更好的选择。</li></ul><p id="1273" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在GraphQL和tRPC之间进行选择时，还有许多其他事情需要考虑，但在我看来这些是主要的。我很想听听你对此的想法，所以请通过Twitter告诉我，地址是<a class="ae kl" href="https://twitter.com/gethackteam" rel="noopener ugc nofollow" target="_blank"> @gethackteam </a>。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="0d5d" class="mv kv iq bd kw mw mx my kz mz na nb lc nc nd ne lf nf ng nh li ni nj nk ll nl bi translated">分级编码</h1><p id="90d7" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="c923" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="3304" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">📰查看<a class="ae kl" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="d508" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">🔔关注我们:<a class="ae kl" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae kl" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae kl" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="3349" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀👉<a class="ae kl" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>