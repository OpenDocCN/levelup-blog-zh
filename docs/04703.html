<html>
<head>
<title>Docker for Development: Service Containers vs Executable Containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker for Development:服务容器与可执行容器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/docker-for-development-service-containers-vs-executable-containers-9fb831775133?source=collection_archive---------7-----------------------#2020-07-10">https://levelup.gitconnected.com/docker-for-development-service-containers-vs-executable-containers-9fb831775133?source=collection_archive---------7-----------------------#2020-07-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/81fe3121f6f18f5fe0ea0050e1cbd6d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HOojeNIYrV6CQwm5fa-AnQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">作者通过<a class="ae kf" href="https://www.flickr.com/photos/cmmorrow/8129936745" rel="noopener ugc nofollow" target="_blank"> Flickr </a>拍摄的照片</figcaption></figure><p id="8930" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常，软件项目依赖于第三方服务和软件。示例包括关系数据库、消息代理或电子邮件服务。当开始一个新的软件项目或加入一个现有项目的开发团队时，安装所有必需的依赖项可能是一项艰巨而耗时的任务。您可以使用Docker来确保您使用的是所需软件的正确版本和配置，而不是大量的入门说明和一丝不苟地安装所有必需的软件依赖项。这就是使用Docker容器的美妙之处！</p><h2 id="a9d9" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">Docker是什么？</h2><p id="597c" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">Docker是一个用于启动和管理容器的软件平台。Docker容器是运行进程和命令的自包含环境。它与主机操作系统的其余部分以及其他Docker容器相隔离。每个容器都有自己的网络、文件系统，并且启动速度很快，因为它不具备完整操作系统中的所有功能(比如图形用户界面)。容器是从图像实例化的，其中图像是您希望Docker运行的所有“东西”。映像从一个基础映像开始，它可能是一个特定版本的<a class="ae kf" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> Postgresql </a>数据库、<a class="ae kf" href="https://ubuntu.com/" rel="noopener ugc nofollow" target="_blank"> Ubuntu </a> Linux发行版或者任何其他可以在Linux上运行的定制软件。您甚至可以通过在其他图像上分层定制配置来制作自己的Docker图像！</p><h2 id="df69" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">发展码头</h2><p id="3c4f" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">Docker是一个很棒的工具，通过使项目的软件依赖可靠、可重复、易于安装和运行，可以使开发更容易。然而，对于Docker的所有灵活性来说，一个陡峭的学习曲线和Docker最佳实践的智慧。在某些情况下，你可能认为直接在你的机器上安装软件更容易。在你的机器上本地安装软件和使用Docker容器有点像买书和从图书馆借书。随着你开始买越来越多的书，你必须在家里为所有这些书腾出空间。如果你经常从图书馆借书，你可以在看完之后把它们还回去，这样就不需要额外的书架空间了。</p><p id="a2d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不熟悉Docker的开发人员经常遇到的另一个问题是知道什么软件值得作为Docker容器运行。在一个Docker容器中运行多个应用程序和框架或者完全在一个Docker容器中开发可能很有吸引力。这是构建大型容器或使您的开发环境比需要的复杂得多的一种可靠方法。简单性是关键，坚持只运行Docker容器中的单个服务或可执行文件，可以节省时间，提高工作效率。</p><h2 id="d3aa" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">服务容器</h2><p id="0439" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">通常，服务很适合作为Docker容器运行。服务是作为单独、独立、长期运行的后台进程运行的任何第三方软件，您的项目将与之交互。示例包括数据库、web服务器和全栈应用程序，如JIRA或詹金斯。将服务作为Docker容器在本地运行很容易，因为您将安装项目所需的服务版本，而不必安装它的所有依赖项。(它们已经包含在容器中了！)</p><p id="5a7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一个例子，让我们看看如何将<a class="ae kf" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>消息代理作为Docker容器运行。首先，确保你已经安装了Docker。你可以按照这里的说明<a class="ae kf" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">为你的操作系统安装Docker。接下来，在终端中复制并执行下面的代码:</a></p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="eda5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个命令有什么作用？它将基于标记为<code class="fe mi mj mk ml b">management</code>的官方RabbitMQ Docker映像，以分离模式运行一个名为<code class="fe mi mj mk ml b">dev-rabbit</code>的新Docker容器。它还会将容器的主机名改为<code class="fe mi mj mk ml b">dev-rabbit</code>，并将容器的端口15672映射到我们主机的端口15672。这一切意味着什么？如果主机上不存在官方RabbitMQ Docker镜像，将从Docker Hub下载，特别是将下载并使用<code class="fe mi mj mk ml b">management</code>标记的版本。一分钟后会有更多的介绍。通过设置端口映射和主机名，容器中的RabbitMQ将像RabbitMQ在本地Linux主机上运行一样工作。<code class="fe mi mj mk ml b">management</code>标记的版本包括管理插件，所以我们可以使用user/pass <code class="fe mi mj mk ml b">guest/guest</code>进入<code class="fe mi mj mk ml b"><a class="ae kf" href="http://localhost:15672" rel="noopener ugc nofollow" target="_blank">http://localhost:15672</a></code>来访问RabbitMQ管理插件的基于浏览器的UI。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/0a229bbe0b770b767bcdf86fa55974bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TxpoaA-EKeG-iSLdnBc1Mg.png"/></div></div></figure><p id="65e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">容器将继续运行，直到主机关闭，或者我们手动告诉Docker停止运行容器。我们可以随时使用命令<code class="fe mi mj mk ml b">docker stop dev-rabbit</code>停止集装箱，并使用<code class="fe mi mj mk ml b">docker start dev-rabbit</code>再次手动启动集装箱。因为我们最初是以分离模式运行Docker容器的，<code class="fe mi mj mk ml b">dev-rabbit</code>容器将始终作为后台进程运行，并且可以用<code class="fe mi mj mk ml b">docker logs dev-rabbit</code>查看它到stdout的输出。</p><p id="5c98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看服务容器的另一个例子。让我们将<a class="ae kf" href="https://neo4j.com/" rel="noopener ugc nofollow" target="_blank"> Neo4j </a>图形数据库作为Docker容器运行。运行下面的终端命令来配置和启动容器:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="1a26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该命令基于标记为<code class="fe mi mj mk ml b">latest</code>的官方<code class="fe mi mj mk ml b">neo4j</code> Docker映像，在分离模式下运行一个名为<code class="fe mi mj mk ml b">dev-neo4j</code>的新Docker容器。该命令还将主机上的端口7474和7687映射到容器中的端口7474和7687。这个例子与RabbitMQ例子的主要区别是<code class="fe mi mj mk ml b">--volume</code>选项。该选项将主机上的<code class="fe mi mj mk ml b">$HOME/neo4j/data</code>目录(在类似Unix的操作系统上)映射到Docker容器中的<code class="fe mi mj mk ml b">/data</code>目录。<code class="fe mi mj mk ml b">/data</code>目录恰好是Neo4j存储数据库数据的地方。通过以这种方式使用<code class="fe mi mj mk ml b">--volume</code>选项，我们增加了数据持久性，这意味着即使容器被删除，数据仍将保留在主机的磁盘上。您可以通过向新的Neo4j数据库添加几个节点来测试这一点(访问<a class="ae kf" href="http://localhost:7474" rel="noopener ugc nofollow" target="_blank"> http://localhost:7474 </a>以使用Neo4j)，然后运行以下命令来删除容器:</p><pre class="mc md me mf gt mn ml mo mp aw mq bi"><span id="9afd" class="le lf it ml b gy mr ms l mt mu">docker rm dev-neo4j</span></pre><p id="8fdf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行下面的命令将显示数据仍然存在！</p><pre class="mc md me mf gt mn ml mo mp aw mq bi"><span id="cecc" class="le lf it ml b gy mr ms l mt mu">ls $HOME/neo4j/data</span></pre><p id="afa7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着相同的数据可以用于不同版本的Neo4j，甚至不同的Docker容器。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/5704587ddfde8dea397fc7cc739e6f9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F5z_wSFxNs_71nVQRLouyw.png"/></div></div></figure><p id="0835" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您所看到的，在您的机器上本地运行服务容器是简单明了且易于管理的。通过更改标记的版本，或者运行带有<code class="fe mi mj mk ml b">latest</code>标记的Docker容器，甚至可以很容易地升级到服务的新版本。由于有许多官方Docker映像的标记版本，找到与您的生产部署相匹配的服务版本应该不成问题。此外，如果您完成了项目工作，并且不再需要本地安装的服务，那么只需使用以下命令删除Docker容器，就可以从您的机器上删除该服务:</p><pre class="mc md me mf gt mn ml mo mp aw mq bi"><span id="f29c" class="le lf it ml b gy mr ms l mt mu">docker rm [container name]</span></pre><h2 id="6129" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">可执行容器</h2><p id="9ce5" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">服务是Docker容器最常见的用例。然而，可执行的命令行应用程序也可以作为Docker容器运行！可执行文件是一个命令行应用程序，它启动、执行一个操作，并在完成或遇到错误时退出。它们是短暂的，而且异常专注。可执行文件的一些例子是命令行工具，如<code class="fe mi mj mk ml b">grep</code>、<code class="fe mi mj mk ml b">ls</code>和<code class="fe mi mj mk ml b">cp</code>。其他例子是你可能已经安装的命令行应用程序，如<a class="ae kf" href="https://curl.haxx.se/" rel="noopener ugc nofollow" target="_blank"> curl </a>、<a class="ae kf" href="https://imagemagick.org/index.php" rel="noopener ugc nofollow" target="_blank"> ImageMagick </a>或<a class="ae kf" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> git </a>。事实证明，只要多做一点工作，您也可以将可执行文件作为Docker容器来运行！</p><p id="cbd9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，为什么要将命令行应用程序作为容器来运行呢？从软件包管理器或安装程序安装应用程序非常容易。事实证明，这并不总是那么简单。如果需要安装同一个应用程序的不同版本怎么办？如果您的操作系统没有可用的安装程序，或者软件包管理器中没有可用的应用程序，该怎么办？如果您唯一的选择是从源代码安装，该怎么办？为了减轻这些情况带来的痛苦，您可以创建一个临时的Docker容器来运行您的应用程序，并在完成后销毁该容器。</p><p id="10ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看一个例子。比方说，你正在做一个<a class="ae kf" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>项目，其中有一部分是用<a class="ae kf" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>编写的。你可以在你的机器上安装Go并在你完成项目后移除它，或者你可以安装<code class="fe mi mj mk ml b"><a class="ae kf" href="https://golang.org/cmd/go/" rel="noopener ugc nofollow" target="_blank">go</a></code> <a class="ae kf" href="https://golang.org/cmd/go/" rel="noopener ugc nofollow" target="_blank">命令</a>作为Docker容器。这将允许你为目标系统编译Go代码，不管你在什么操作系统上开发，都不需要安装Go！</p><p id="8a61" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，让我们使用下面的Hello World程序示例作为我们要编译的Go代码。将下面的代码复制到名为<code class="fe mi mj mk ml b">hello.go</code>的文件中:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="3255" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们需要创建Docker容器<code class="fe mi mj mk ml b">run</code>命令作为shell脚本，我们可以从命令行调用它。将以下代码复制到名为<code class="fe mi mj mk ml b">go</code>的文件中:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="198f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个shell脚本通过使用Docker Hub官方最新的<code class="fe mi mj mk ml b">golang</code>映像来运行一个新的Docker容器。重要的是，<code class="fe mi mj mk ml b">--rm</code>选项告诉Docker“remove”，也就是说，当它执行完后删除容器。我们还需要一种将Go代码放入容器的方法。使用<code class="fe mi mj mk ml b">--volume</code>选项，通过将环境变量<code class="fe mi mj mk ml b">$PWD</code>(运行shell脚本的目录)映射到容器中的<code class="fe mi mj mk ml b">/usr/src/app</code>来实现这一点。<code class="fe mi mj mk ml b">-w</code>选项将容器中的工作目录设置为<code class="fe mi mj mk ml b">/usr/src/app</code>——Go代码将被编译的目录。<code class="fe mi mj mk ml b">-e</code>选项设置容器中的环境变量，在本例中<code class="fe mi mj mk ml b">GOOS</code>和<code class="fe mi mj mk ml b">GOARCH</code>设置为shell中<code class="fe mi mj mk ml b">$GOOS</code>和<code class="fe mi mj mk ml b">$GOARCH</code>的值。Go语言具有真正有用的能力，可以为特定的操作系统和架构交叉编译Go代码，而不管你编译的是什么操作系统和架构。这两个环境变量都允许我们设置要为哪个操作系统和架构编译代码。我们的shell脚本的最后一行告诉Docker运行容器中的<code class="fe mi mj mk ml b">go</code>命令以及传递给shell脚本的任何参数。注意这次没有<code class="fe mi mj mk ml b">--name</code>选项。如果没有这个选项，Docker将为容器分配一个随机的匿名名称。</p><p id="4078" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，将<code class="fe mi mj mk ml b">go</code>文件保存到<code class="fe mi mj mk ml b">/usr/local/bin</code>或您的<code class="fe mi mj mk ml b">$PATH</code>中的等效目录。通过使用以下命令更改权限，确保文件是可执行的:</p><pre class="mc md me mf gt mn ml mo mp aw mq bi"><span id="22d6" class="le lf it ml b gy mr ms l mt mu">chmod 755 /usr/local/bin/go</span></pre><p id="6917" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请确保您的系统中尚未安装Go。如果您这样做了，请确保我们刚刚创建的shell脚本将被调用:</p><pre class="mc md me mf gt mn ml mo mp aw mq bi"><span id="d69f" class="le lf it ml b gy mr ms l mt mu">which go</span></pre><p id="7bf5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只要结果是<code class="fe mi mj mk ml b">/usr/local/bin/go</code>，您就一切就绪，否则，您需要将您的<code class="fe mi mj mk ml b">go</code> shell脚本移动到之前在<code class="fe mi mj mk ml b">$PATH</code>中调用的另一个目录，修改您的<code class="fe mi mj mk ml b">$PATH</code>顺序，或者重命名<code class="fe mi mj mk ml b">go</code> shell脚本。</p><p id="39e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">确保为您当前使用的机器设置您的<code class="fe mi mj mk ml b">$GOOS</code>和<code class="fe mi mj mk ml b">$GOARCH</code>环境变量。这一点很重要，因为它可能会阻止编译后的程序可执行。在我的例子中，我使用的是macOS，所以我将环境变量设置为:</p><pre class="mc md me mf gt mn ml mo mp aw mq bi"><span id="0816" class="le lf it ml b gy mr ms l mt mu">export GOOS=darwin<br/>export GOARCH=amd64</span></pre><p id="23fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">导航到保存<code class="fe mi mj mk ml b">hello.go</code>的目录。现在，在终端上运行下面的命令来编译<code class="fe mi mj mk ml b">hello.go</code>:</p><pre class="mc md me mf gt mn ml mo mp aw mq bi"><span id="7c58" class="le lf it ml b gy mr ms l mt mu">go build hello.go</span></pre><p id="f904" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一两秒钟后，编译将完成，您将在当前目录中拥有一个<code class="fe mi mj mk ml b">hello</code>可执行文件。用<code class="fe mi mj mk ml b">./hello</code>运行编译好的程序。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mw"><img src="../Images/eb15a370e4fc0146390f46fcd921f37d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wgMMwpWVB1C6nfSj4mrPcA.png"/></div></div></figure><p id="5ce6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">恭喜你，你没有安装Go就编译了Go代码！</p><p id="c644" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看最后一个例子。我们可以使用可执行的Docker容器运行开源的<a class="ae kf" href="https://tesseract-ocr.github.io/tessdoc/Home.html" rel="noopener ugc nofollow" target="_blank"> Tesseract </a> OCR(光学字符识别)命令行应用程序。在这种情况下，Docker Hub上没有正式的映像，但是我们可以通过创建Docker文件为Tesseract创建一个Docker映像。Docker文件包含构建Docker映像的所有说明。将下面的代码复制到名为Dockerfile的新文件中:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="6a98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第1行表明<code class="fe mi mj mk ml b">ubuntu</code> Docker图像将被用作我们新Docker图像的基础。第3行表示一旦Docker容器运行，就安装Tesseract包。第4行表示工作目录应该更改为<code class="fe mi mj mk ml b">/tesseract</code>。最后，执行<code class="fe mi mj mk ml b">tesseract</code>命令。当我们从这个映像创建一个新的Docker容器时，这些命令将按顺序运行，但是在运行我们的容器之前，我们首先需要构建Docker映像。</p><p id="ff0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用下面的命令在Docker文件所在的目录中构建Docker映像:</p><pre class="mc md me mf gt mn ml mo mp aw mq bi"><span id="a119" class="le lf it ml b gy mr ms l mt mu">docker build -t tesseract_ocr:latest .</span></pre><p id="8119" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mi mj mk ml b">-t</code>选项用标签<code class="fe mi mj mk ml b">latest</code>将图像的名称指定为<code class="fe mi mj mk ml b">tesseract_ocr</code>。</p><p id="c30c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们有了一个Tesseract图像，我们可以编写一个shell脚本来创建并执行一个基于<code class="fe mi mj mk ml b">tesseract_ocr</code>图像的Docker容器。将下面的代码复制到名为<code class="fe mi mj mk ml b">tesseract</code>的新文件中:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="03c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个shell脚本使用我们的<code class="fe mi mj mk ml b">tesseract_ocr</code>图像运行一个新的Docker容器。就像Go脚本一样，<code class="fe mi mj mk ml b">--rm</code>选项告诉Docker“删除”，也就是说，当它完成执行时删除容器。第一个卷绑定将执行Tesseract的目录映射到<code class="fe mi mj mk ml b">/tesseract</code>目录，您可能还记得，这是<code class="fe mi mj mk ml b">tesseract_ocr</code>映像的工作目录。第二个卷绑定将<code class="fe mi mj mk ml b">/var/folders</code>目录映射到主机上Tesseract用于临时文件存储的同一目录。最后，最后一行执行<code class="fe mi mj mk ml b">tesseract_ocr</code>图像，然后执行<code class="fe mi mj mk ml b">tesseract</code>命令以及我们提供的任何命令行参数。</p><p id="1f4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将<code class="fe mi mj mk ml b">tesseract</code>脚本复制到<code class="fe mi mj mk ml b">/usr/local/bin</code>或<code class="fe mi mj mk ml b">$PATH</code>中的另一个目录，并确保使用以下命令更改权限:</p><pre class="mc md me mf gt mn ml mo mp aw mq bi"><span id="1ae5" class="le lf it ml b gy mr ms l mt mu">chmod 755 /usr/local/bin/tesseract</span></pre><figure class="mc md me mf gt ju gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/9aa3da5b938bb47f7b4e988208f64b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/format:webp/1*A-WJry_pQ90EYzuKtB4k2w.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">hello.png</figcaption></figure><p id="f98c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用上面的图像<code class="fe mi mj mk ml b">hello.png</code>，我们可以将图像传递给Tesseract来读取文本<em class="my">“Hello World！”</em>来自图片。以下命令在<code class="fe mi mj mk ml b">hello.png</code>上运行Tesseract OCR，将文本保存到<code class="fe mi mj mk ml b">hello.txt</code>，并将结果显示到stdout:</p><pre class="mc md me mf gt mn ml mo mp aw mq bi"><span id="f12c" class="le lf it ml b gy mr ms l mt mu">tesseract hello.png hello &amp;&amp; cat hello.txt</span></pre><figure class="mc md me mf gt ju gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/0af3be5c524918c60ae4260f959ffe11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*5hDAnERt-1nVNWjIz1b9ow.png"/></div></figure><p id="6d49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很酷吧？</p><h2 id="90f4" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">结论</h2><p id="c4b3" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我们已经看到了服务容器和可执行容器的例子。服务容器相当简单，运行需要启动和停止的长时间运行的流程。可执行容器通常更复杂，难以配置和运行单一焦点、短命的应用程序。两者都有自己的用例，可以帮助你更有效地工作。通过一点创造性和试验，您将能够将任何服务或可执行文件转换成Docker容器。黑客快乐！</p></div></div>    
</body>
</html>