<html>
<head>
<title>Implementing The Fieldalignment Bundle in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中实现Fieldalignment包</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-the-fieldalignment-bundle-in-go-1f725302a6dc?source=collection_archive---------11-----------------------#2022-12-09">https://levelup.gitconnected.com/implementing-the-fieldalignment-bundle-in-go-1f725302a6dc?source=collection_archive---------11-----------------------#2022-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/0b2b915df3a150dde8d625b078efcb78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*11Eqz_7TQFZ0ntsq.jpg"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">作者照片</figcaption></figure><p id="937b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种简单的优化以最小的努力提高了Go程序的性能。直到现在也从未实施过。<strong class="kd iu"> fieldalignment bundle </strong>是一种技术，可以用来最小化应用程序在运行时使用的内存量。由于Go垃圾收集器的语义，这可以提高性能。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="0f5d" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">什么是结构填充？</h1><p id="7858" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">系统架构(32位、64位)定义了每个<em class="mj">字</em>的大小(以位为单位)以及系统内存的对齐方式。第一个因素是Go编程语言中原语类型<em class="mj">(即string、int、uint等)</em>大小的基础。例如，基本类型的尺寸可以在<code class="fe mk ml mm mn b"><a class="ae mo" href="https://cs.opensource.google/go/go/+/master:src/go/types/sizes.go;l=131?q=sizes.go" rel="noopener ugc nofollow" target="_blank">go/types/sizes.go:131</a></code>中找到。</p><p id="462b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个因素是<strong class="kd iu">结构填充</strong>的基础，它将结构的字段与内存中的地址对齐。这是通过向结构填充(添加额外的)字节来实现的，因此它的大小是有效字长的倍数<em class="mj">(即8字节* 64位系统上的倍数)</em>。结构填充的目的是提高内存使用的性能，并防止系统架构上的许多其他问题。</p><p id="d2c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mj">有关内存对齐的更多信息，请阅读</em> <a class="ae mo" href="https://go101.org/article/memory-layout.html" rel="noopener ugc nofollow" target="_blank"> <em class="mj">内存布局(Go) </em> </a> <em class="mj">和</em> <a class="ae mo" href="https://medium.com/@sebassegros/golang-dealing-with-maligned-structs-9b77bacf4b97" rel="noopener"> <em class="mj">处理恶意结构</em> </a> <em class="mj">。</em></p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e11a" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">什么是字段对齐？</h1><p id="a206" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated"><strong class="kd iu">字段对齐</strong>是对齐Go结构中字段的过程，目的是最小化结构的大小(在内存中)。例如，重新组织结构字段的顺序可以将其大小从24字节减少到16字节。在Go编程语言中，使用<code class="fe mk ml mm mn b">go install golang.org/x/tools/go/analysis/passes/fieldalignment/cmd/fieldalignment@latest</code>安装的<a class="ae mo" href="https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/fieldalignment" rel="noopener ugc nofollow" target="_blank">字段对齐工具</a>可以解决字段对齐问题。</p><p id="dad8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<code class="fe mk ml mm mn b">fieldalignment</code>命令将会告诉你程序中错位字段的位置。使用<code class="fe mk ml mm mn b">-fix</code>标志将为您修复这些问题，而使用<code class="fe mk ml mm mn b">-json</code>将以JSON格式打印出诊断结果。作为一个<strong class="kd iu">警告</strong>，运行<code class="fe mk ml mm mn b">fieldalignment -fix ./...</code>可能会从您的字段中删除注释，因为在Go抽象语法树中操作自由浮动注释存在潜在的困难。这个问题正在https://github.com/golang/go/issues/20744得到解决，但是围棋的创造者花了5年时间才取得进展。</p><pre class="mp mq mr ms gt mt mn mu bn mv mw bi"><span id="5d16" class="mx lh it mn b be my mz l na nb">file.go:17:14: struct with 64 pointer bytes could be 56</span></pre><h2 id="1b55" class="nc lh it bd li nd ne dn lm nf ng dp lq km nh ni lu kq nj nk ly ku nl nm mc nn bi translated">有什么好处？</h2><p id="0d89" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">现场校准的好处在批量生产中可以观察到。如果您的应用程序通过字段对齐为每个结构节省<em class="mj"> 8个字节，这将为一百万次请求内使用的每个结构节省<strong class="kd iu"> 8 MB </strong>内存。这让您可以节省内存资源，甚至可以减少<a class="ae mo" href="https://agrim123.github.io/posts/go-garbage-collector.html" rel="noopener ugc nofollow" target="_blank"> Go垃圾收集器</a> <em class="mj">(随着时间的推移提高性能)</em>中的峰值数量。具体来说，Go使用一个<em class="mj">停止全局垃圾收集器</em>，它在目标堆大小时触发。通过以一致的速度保持尽可能小的堆，可以减少垃圾收集器的延迟。</em></p><p id="949c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这也是使用零分配库的基本原理。</p><h2 id="c537" class="nc lh it bd li nd ne dn lm nf ng dp lq km nh ni lu kq nj nk ly ku nl nm mc nn bi translated">警告</h2><p id="cd28" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">艾伦·多诺万是谷歌的软件工程师，也是Go编程语言的合著者。他对场校准有什么看法？</p><blockquote class="no np nq"><p id="4162" class="kb kc mj kd b ke kf kg kh ki kj kk kl nr kn ko kp ns kr ks kt nt kv kw kx ky im bi translated"><em class="it">“应该审查fieldalignment应用的修复，因为在某些情况下，它们可能会</em> <a class="ae mo" href="https://cs.opensource.google/go/x/tools/+/refs/tags/v0.3.0:go/analysis/passes/fieldalignment/fieldalignment.go;l=45-48" rel="noopener ugc nofollow" target="_blank"> <em class="it">降低性能</em> </a> <em class="it">，并且它们肯定会导致依赖于字段顺序(通过反射)的测试失败。”</em></p><p id="9fa5" class="kb kc mj kd b ke kf kg kh ki kj kk kl nr kn ko kp ns kr ks kt nt kv kw kx ky im bi translated"><em class="it">艾伦·多诺万(</em> <a class="ae mo" href="https://github.com/golang/go/issues/57091#issuecomment-1338150430" rel="noopener ugc nofollow" target="_blank"> <em class="it">评论</em> </a> <em class="it"> ) </em></p></blockquote><p id="9f67" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">字段对齐会导致性能下降，因为紧凑的字段顺序会导致同时更新的两个变量(在不同的goroutines中)占用相同的CPU缓存行:这导致一种称为<a class="ae mo" href="https://en.wikipedia.org/wiki/False_sharing" rel="noopener ugc nofollow" target="_blank">假共享</a>的内存争用。当错误共享发生时，被更新的第一个变量被强制重新加载CPU缓存块，即使它不是必需的。因此，更新每个变量的两个goroutines都变慢了。</p><p id="2e0b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mj">由于这个警告，建议对你的字段对齐代码进行基准测试。</em></p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="3d0f" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">什么是捆绑？</h1><p id="6a49" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">在软件开发的上下文中，一个包代表了一个文件或源代码的集合。在本文的上下文中，一个包代表整个源包的单个文件版本。因此，通过将应用程序的所有源文件(<code class="fe mk ml mm mn b">.go</code>)组合成一个单独的<code class="fe mk ml mm mn b">.go</code>文件，就实现了一个包。这样做可能有很多原因；比如本文中的这个。通过使用<code class="fe mk ml mm mn b">go install golang.org/x/tools/cmd/bundle@latest</code>安装的工具，可以在Go中实现捆绑。</p><p id="0fcc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<code class="fe mk ml mm mn b">bundle</code>命令将应用程序捆绑到一个文件中。但是，这可能会生成一个在其导入中包含冲突的文件。通过<code class="fe mk ml mm mn b">-import new=old</code>标志可以修复文件输出中的导入，但是在其他情况下，您必须手动修复。一个问题(<a class="ae mo" href="https://github.com/golang/go/issues/57088" rel="noopener ugc nofollow" target="_blank">https://github.com/golang/go/issues/57088</a>)正在努力解决这些情况。</p><h2 id="8a09" class="nc lh it bd li nd ne dn lm nf ng dp lq km nh ni lu kq nj nk ly ku nl nm mc nn bi translated">警告</h2><p id="e152" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">由于“<a class="ae mo" href="https://cs.opensource.google/go/x/tools/+/refs/tags/v0.3.0:cmd/bundle/main.go;l=259" rel="noopener ugc nofollow" target="_blank">隐藏</a>”，捆绑代码有可能成功编译，但保持与原始包不同的行为。</p><p id="27e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mj">由于这个警告，你必须在CICD管道中测试你的捆绑代码。</em></p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="9982" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">实现Fieldalignment包</h1><p id="5e70" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated"><strong class="kd iu"> fieldalignment bundle </strong>技术包括捆绑源代码，然后对其进行fieldalignment。然而，这必须以一种仍然允许开发人员以简单的方式维护代码库的方式来完成。您必须创建代码库的副本并修改该副本，而不是直接将您的代码库转换为捆绑包或字段对齐。这允许您维护一个可供开发人员使用的可读版本。</p><p id="bb41" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">建议在自己的模块中定义<strong class="kd iu"> fieldalignment bundle </strong>，这样一个构建将<em class="mj">永远不会</em>包含两者。定义另一个模块的另一个好处是在测试时实现的:不是强迫开发人员通过<code class="fe mk ml mm mn b">find and replace</code>操作<em class="mj">(即模块/a到b) </em>在测试中切换模块，而是可以通过使用单行替换指令(<a class="ae mo" href="https://go.dev/ref/mod#go-mod-file-replace" rel="noopener ugc nofollow" target="_blank">模块</a> / <a class="ae mo" href="https://go.dev/ref/mod#go-work-file-replace" rel="noopener ugc nofollow" target="_blank">工作区</a>)在每个模块之间切换。</p><p id="6957" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mj">这种实现也使得在CICD管道中使用现场校准包变得容易，因为不需要额外的工作来测试代码。</em></p><h2 id="7e8e" class="nc lh it bd li nd ne dn lm nf ng dp lq km nh ni lu kq nj nk ly ku nl nm mc nn bi translated">一个实现</h2><p id="f2df" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">Disgo是第一个以文档化的方式实现<strong class="kd iu"> fieldalignment bundle </strong>的开源存储库。Disgo使用这种技术是因为它基于API类型库(<a class="ae mo" href="https://github.com/switchupcb/dasgo" rel="noopener ugc nofollow" target="_blank"> Dasgo </a>)，定义了类型的排序方式。Disgo的整个代码生成器过程在<code class="fe mk ml mm mn b"><a class="ae mo" href="https://github.com/switchupcb/disgo/blob/v10/_gen/README.md" rel="noopener ugc nofollow" target="_blank">_gen/README.md</a></code>中有描述。捆绑文件(<code class="fe mk ml mm mn b">disgo.go</code>)代码生成器位于<code class="fe mk ml mm mn b"><a class="ae mo" href="https://github.com/switchupcb/disgo/tree/v10/_gen/bundle" rel="noopener ugc nofollow" target="_blank">_gen/bundle</a></code>。</p><p id="e938" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于捆绑命令代码(来自<code class="fe mk ml mm mn b">x/tools/cmd</code>)中的错误，必须实施<code class="fe mk ml mm mn b">go generate</code>解决方案。因此，下面的步骤用于在Go中实现fieldalignment包。</p><ol class=""><li id="e1d7" class="nu nv it kd b ke kf ki kj km nw kq nx ku ny ky nz oa ob oc bi translated">清除包文件。</li><li id="adf4" class="nu nv it kd b ke od ki oe km of kq og ku oh ky nz oa ob oc bi translated">将go generate注释添加到文件中。</li><li id="5844" class="nu nv it kd b ke od ki oe km of kq og ku oh ky nz oa ob oc bi translated">调用go生成。</li><li id="b8a9" class="nu nv it kd b ke od ki oe km of kq og ku oh ky nz oa ob oc bi translated">解决包文件导入。</li><li id="29f8" class="nu nv it kd b ke od ki oe km of kq og ku oh ky nz oa ob oc bi translated">字段对齐代码。由于以下原因，您必须从代码中多次调用fieldalignment可执行文件。</li></ol><ul class=""><li id="5546" class="nu nv it kd b ke kf ki kj km nw kq nx ku ny ky oi oa ob oc bi translated">在某些情况下，fieldalignment必须运行多次才能完全应用。当未使用<code class="fe mk ml mm mn b">-json</code>标志时，这由退出代码3指示。</li><li id="26df" class="nu nv it kd b ke od ki oe km of kq og ku oh ky oi oa ob oc bi translated">以这种方式调用fieldalignment时使用<code class="fe mk ml mm mn b">-json</code>标志会导致退出代码1 <em class="mj">(分析错误)</em>，而没有建议的修复<em class="mj">(与</em><a class="ae mo" href="https://github.com/golang/go/issues/57091" rel="noopener ugc nofollow" target="_blank"><em class="mj">【https://github.com/golang/go/issues/57091</em></a><em class="mj">)</em>中的语句相反)。</li><li id="ff60" class="nu nv it kd b ke od ki oe km of kq og ku oh ky oi oa ob oc bi translated">没有一个<code class="fe mk ml mm mn b">golang.org/x/tools</code>使用导出的函数。</li></ul><h2 id="151b" class="nc lh it bd li nd ne dn lm nf ng dp lq km nh ni lu kq nj nk ly ku nl nm mc nn bi translated">修复删除的注释</h2><p id="93a6" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">当您使用Git等版本控制软件时，您可能会注意到在<em class="mj"> diff </em>中，某些字段的注释被删除了。在某些情况下，修复就像对字段重新排序一样简单<em class="mj">(这样它们就不会被字段对齐工具修改)</em>。在其他情况下，重新排序字段会破坏文档的质量。虽然有许多方法可以解决这个问题，但是最简单的方法是在包文件代码生成器中使用一个<code class="fe mk ml mm mn b">find and replace</code>函数。</p><p id="f280" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简单的<code class="fe mk ml mm mn b">strings.Replace</code>函数调用不起作用，因为一行中的空格<em class="mj">(填充)</em>数量可能不同。Disgo在一个<a class="ae mo" href="https://github.com/switchupcb/disgo/tree/v10/_gen#comments" rel="noopener ugc nofollow" target="_blank">多步骤过程</a>中解决了这个问题，该过程涉及在一个文本文件中将字段对齐结构<em class="mj">(不带注释)</em>定义为字段对齐结构<em class="mj">(带注释)</em>。在字符串比较之前，这些文本文件和捆绑文件被去除空间，以便可以比较跨多行的文本。一旦发生这种情况，就可以正确无误地使用替换操作。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="f3ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mj">原载于2022年12月9日https://switchupcb.com</em><em class="mj"><a class="ae mo" href="https://switchupcb.com/blog/implementing-the-fieldalignment-bundle-in-go/" rel="noopener ugc nofollow" target="_blank"><em class="mj">。</em></a></em></p></div></div>    
</body>
</html>