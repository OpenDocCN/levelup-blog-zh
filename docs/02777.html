<html>
<head>
<title>Build Flask APIs using SocketIO to Produce/Consume Kafka Messages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SocketIO构建Flask APIs来生成/消费Kafka消息</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-flask-apis-using-socketio-to-produce-consume-kafka-messages-95a15df2d1bc?source=collection_archive---------4-----------------------#2020-04-04">https://levelup.gitconnected.com/build-flask-apis-using-socketio-to-produce-consume-kafka-messages-95a15df2d1bc?source=collection_archive---------4-----------------------#2020-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="4ab2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设你有一个卡夫卡集群。您可以使用一些客户端代码轻松地从主题中生成和读取消息。如果您想通过端点公开您的Kafka集群来产生/消费消息，该怎么办？你会怎么做？</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><p id="ee24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要3个抽象组件来实现这一点，</p><ol class=""><li id="9fa7" class="kv kw it js b jt ju jx jy kb kx kf ky kj kz kn la lb lc ld bi translated">卡夫卡装置</li><li id="3b3a" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">连接到Kafka设置的应用程序</li><li id="ef49" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">一些网页来测试应用程序的端点</li></ol><p id="6160" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章给出了构建和测试以下架构的指导。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/a6bdaab14ce97aa3d3ae3f73c5394c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cq2Mu4HPR48VJpmtYeeaXA.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">目标结构</figcaption></figure><p id="212c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们将使用docker容器来设置Kafka，并使用Flask web-sockets来公开Kafka。让我们一次破解一个组件的架构！</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="8eaa" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">步骤1:使用Docker设置Kafka</h1><p id="acbe" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">kafka可用的两个docker图像是<a class="ae nc" href="https://hub.docker.com/r/spotify/kafka/" rel="noopener ugc nofollow" target="_blank"> spotify/kafka </a>和<a class="ae nc" href="https://hub.docker.com/r/wurstmeister/kafka/" rel="noopener ugc nofollow" target="_blank"> wurstmeister/kafka </a>。Wurstmeister是一个受欢迎的选择，我们将使用它进行设置。</p><p id="c667" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">参考<a class="ae nc" href="https://github.com/Stack-Box/stackbox-tutorials/tree/master/flask-kafka" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> Github文件夹</strong> </a>中用于构建这个例子的所有代码。</p><blockquote class="nd ne nf"><p id="9b26" class="jq jr ng js b jt ju jv jw jx jy jz ka nh kc kd ke ni kg kh ki nj kk kl km kn im bi translated"><strong class="js iu">注:</strong>代码根据读者的问题/PRs不断更新。因此，这里提到的片段和回购协议中的片段可能会有一些差异。参考这篇文章底部的更新。</p></blockquote><p id="262e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们使用一个<a class="ae nc" href="https://github.com/Stack-Box/stackbox-tutorials/blob/master/flask-kafka/docker-compose.yml" rel="noopener ugc nofollow" target="_blank"> docker-compose.yml </a>来打开Kafka和Zookeper容器。</p><pre class="lk ll lm ln gt nk nl nm nn aw no bi"><span id="7002" class="np ma it nl b gy nq nr l ns nt">version: '3' <br/>services:  <br/>   kafka:    <br/>      environment:      <br/>        KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181<br/>        KAFKA_ADVERTISED_HOST_NAME: &lt;your-ip&gt;  <br/>      image: wurstmeister/kafka    <br/>      ports:      <br/>        - "32770:9092"    <br/>      volumes:      <br/>        - /var/run/docker.sock:/var/run/docker.sock    <br/>      depends_on:      <br/>        - zookeeper   <br/>   zookeeper:    <br/>      image: wurstmeister/zookeeper    <br/>      ports:      <br/>        - "2182:2181"</span></pre><h2 id="701e" class="np ma it bd mb nu nv dn mf nw nx dp mj kb ny nz mn kf oa ob mr kj oc od mv oe bi translated">解码docker-compose.yml</h2><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="d928" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在compose文件中定义了两个服务，Kafka和Zookeeper。Kafka内部运行在docker网络的9092上，外部运行在32770(本地主机)和zookeeper上，内部运行在2181上，外部运行在2182上。</p><p id="1652" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ng">KAFKA _ ZOOKEEPER _ CONNECT</em>被设置为<em class="ng"> zookeeper:2181 </em>。这里zookeeper是docker网络中的服务名，端口也是内部端口。必须将KAFKA_ADVERTISED_HOST_NAME设置为您机器的en0 IP。例如，在mac上，您可以使用ipconfig getifaddr en0 找到它</p><p id="b4c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您想在提出代理本身的同时增加更多的代理或创建话题，请参考<a class="ae nc" href="https://github.com/wurstmeister/kafka-docker" rel="noopener ugc nofollow" target="_blank">wurstmeister/Kafka-docker</a>自述文件以获得更多有用的配置。</p><p id="b08f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到设置。现在运行下面的命令来启动您的容器。</p><pre class="lk ll lm ln gt nk nl nm nn aw no bi"><span id="ff36" class="np ma it nl b gy nq nr l ns nt">docker-compose up </span></pre><p id="4de2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">提示</strong>💡—如果您已经设置好IP，并且端口没有被占用，那么您的容器应该是打开的。有时，当Kafka brokers没有任何问题时，修剪docker映像、容器和卷，甚至重启docker都神奇地帮我解决了这个问题。</p><p id="0789" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我们完成了我们的Kafka设置！</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="oh og l"/></div></figure><p id="6f22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于那些想知道，我如何把这个设置。使用</p><pre class="lk ll lm ln gt nk nl nm nn aw no bi"><span id="c915" class="np ma it nl b gy nq nr l ns nt">docker-compose down</span></pre><p id="31ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">把集装箱拿下来。但是在你测试运行你的应用程序或者网页的时候，确保你有容器。您可以使用以下命令列出正在运行的容器。</p><pre class="lk ll lm ln gt nk nl nm nn aw no bi"><span id="6384" class="np ma it nl b gy nq nr l ns nt">docker ps</span></pre></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="54e2" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">步骤2:编写烧瓶插槽应用程序</h1><p id="f131" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">现在我们已经准备好了Kafka，让我们写一些读写消息的连接。</p><p id="a23f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">参考完整的工作<a class="ae nc" href="https://github.com/Stack-Box/stackbox-tutorials/blob/master/flask-kafka/app.py" rel="noopener ugc nofollow" target="_blank"> app.py </a>，我在下面解释一些重要的代码。</p><p id="538f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于我们不能完全使用REST APIs来读写我们的Kafka，我们将编写套接字来在我们的应用程序运行时保持与Kafka集群的连接，并且我们也可以将这些更改实时传输到我们的网页。Web-sockets是一个很酷的编程范例，用在简单的get/post/put不起作用的应用程序中，您需要一个连接来持续更长时间以实时获取/上传数据。阅读更多关于web-sockets、SocketIO的内容，理解和欣赏套接字的概念💡</p><p id="454d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用<a class="ae nc" href="https://github.com/miguelgrinberg/Flask-SocketIO" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">烧瓶套接字</strong> </a> <strong class="js iu"> </strong>在我们的应用程序中编写套接字。你所需要做的就是添加<strong class="js iu"> @socket </strong> decorator而不是通常的route decorator来作为一个套接字公开。</p><p id="b1c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在应用程序中有3个套接字端点。</p><ol class=""><li id="a0c1" class="kv kw it js b jt ju jx jy kb kx kf ky kj kz kn la lb lc ld bi translated"><strong class="js iu">连接</strong>:只是一个插座，检查通道上是否建立了连接</li><li id="ce68" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated"><strong class="js iu"> kafkaproducer </strong>:获取一条消息(从网页)并将其发布到一个已配置的kafka主题</li><li id="e0c5" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated"><strong class="js iu"> kafkaconsumer </strong>:读取主题中的所有消息，并将它们发送回同一个通道。这个发出的消息列表可以通过网页获取。</li></ol><p id="e287" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们将坚持一个名为<em class="ng">卡夫卡</em>的频道。</p><p id="a400" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Top从python连接到卡夫卡，我们就用<a class="ae nc" href="https://pypi.org/project/kafka-python/" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">Kafka-python</strong></a><strong class="js iu">。</strong>所有需求都可以在<a class="ae nc" href="https://github.com/Stack-Box/stackbox-tutorials/blob/master/flask-kafka/requirements.txt" rel="noopener ugc nofollow" target="_blank"> requirements.txt </a>中找到。我用python 3.6来实现。</p><h2 id="c759" class="np ma it bd mb nu nv dn mf nw nx dp mj kb ny nz mn kf oa ob mr kj oc od mv oe bi translated">生产者代码</h2><p id="2caa" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">生产者片段非常简单。</p><pre class="lk ll lm ln gt nk nl nm nn aw no bi"><span id="96ac" class="np ma it nl b gy nq nr l ns nt">@socketio.on('kafkaproducer', namespace="/kafka")<br/>def kafkaproducer(message):<br/>    producer = KafkaProducer(bootstrap_servers=BOOTSTRAP_SERVERS)<br/>    producer.send(TOPIC_NAME, value=bytes(str(message),<br/>        encoding='utf-8'), key=bytes(str(uuid.uuid4()),<br/>        encoding='utf-8'))<br/>    emit('logs', {'data': 'Added ' + message + ' to topic'})<br/>    emit('kafkaproducer', {'data': message})<br/>    producer.close()<br/>    kafkaconsumer(message)</span></pre><ol class=""><li id="5abb" class="kv kw it js b jt ju jx jy kb kx kf ky kj kz kn la lb lc ld bi translated">使用kafka-python中的KafkaProducer连接到Kafka</li><li id="53dd" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">然后将消息发布到Kafka(所有消息和密钥都需要是字节)</li><li id="7834" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">然后，我们发出一些日志，说明消息已经发布。</li><li id="3935" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">然后调用kafkaconsumer片段(这是为了在网页中显示通过消费者生成的消息)</li><li id="306e" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">整个方法都是用socketio、一个名称和一个命名空间来修饰的。名称是方法在网页中被调用的方式，名称空间相当于通道，在通道中所有的发出和发送将被协调。</li></ol><h2 id="8cd4" class="np ma it bd mb nu nv dn mf nw nx dp mj kb ny nz mn kf oa ob mr kj oc od mv oe bi translated">消费者代码</h2><p id="2a76" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">消费者需要一些额外的代码在消费完所有消息后停止。否则，它会一直监听新消息，不会退出。</p><pre class="lk ll lm ln gt nk nl nm nn aw no bi"><span id="49b8" class="np ma it nl b gy nq nr l ns nt"><a class="ae nc" href="http://twitter.com/socketio" rel="noopener ugc nofollow" target="_blank">@socketio</a>.on('kafkaconsumer', namespace="/kafka")<br/>def kafkaconsumer(message):<br/>    consumer = KafkaConsumer(group_id='consumer-1',<br/>                             bootstrap_servers=BOOTSTRAP_SERVERS)<br/>    tp = TopicPartition(TOPIC_NAME, 0)<br/>    consumer.assign([tp])<br/>    consumer.seek_to_end(tp)<br/>    lastOffset = consumer.position(tp)<br/>    consumer.seek_to_beginning(tp)<br/>    emit('kafkaconsumer1', {'data': ''})<br/>    for message in consumer:<br/>        emit('kafkaconsumer', <br/>             {'data': message.value.decode('utf8')})<br/>        if message.offset == lastOffset - 1:<br/>            break<br/>    consumer.close()</span></pre><ol class=""><li id="4429" class="kv kw it js b jt ju jx jy kb kx kf ky kj kz kn la lb lc ld bi translated">使用kafka-python中的KafkaConsumer连接到Kafka</li><li id="ea13" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">找出流中最后一条消息的位置</li><li id="d4eb" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">阅读所有消息，直到最后一条消息，并断开连接</li><li id="2c4e" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">还将这些消息发送给通道，使网页能够获取它们。</li><li id="e918" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">对“kafkaconsumer1”的初始发出是告诉web页面一组新的消息即将到来，并清除页面中现有的消息列表。</li></ol><p id="8686" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在当你跑的时候</p><pre class="lk ll lm ln gt nk nl nm nn aw no bi"><span id="c751" class="np ma it nl b gy nq nr l ns nt">python app.py</span></pre><p id="a7dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你将有你的网络插座启动和运行。Flask SocketIO不会显示任何启动日志，所以不要吃惊😛</p><h1 id="ac5f" class="lz ma it bd mb mc oi me mf mg oj mi mj mk ok mm mn mo ol mq mr ms om mu mv mw bi translated">第三步:写网页</h1><p id="048c" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">我写了一些<a class="ae nc" href="https://github.com/Stack-Box/stackbox-tutorials/blob/master/flask-kafka/index.html" rel="noopener ugc nofollow" target="_blank">超级基本的HTML </a>来连接应用程序并显示消息。它使用<a class="ae nc" href="https://socket.io/" rel="noopener ugc nofollow" target="_blank"> SocketIO </a>脚本从应用程序中传输数据。html有一个简单的表单，它接收一些消息并将其发送给生产者。有些部分可以读回来自消费者的所有消息，还可以显示日志。</p><p id="e007" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在运行你的kafka设置，运行你的应用并打开index.html<a class="ae nc" href="https://github.com/Stack-Box/stackbox-tutorials/blob/master/flask-kafka/index.html" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi on"><img src="../Images/9c7de3cd20ab2fc972f4365f48276a91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*iq7mLyfMPNSu-M7ZlHytUw.gif"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">工作</figcaption></figure><p id="63e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是时候庆祝了！(或者直接进入评论区提问，或者在<a class="ae nc" href="https://github.com/Stack-Box/stackbox-tutorials" rel="noopener ugc nofollow" target="_blank"> Github </a>上提出问题并解决问题，然后..CEL-EB-ratee！！)</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="oo og l"/></div></figure><p id="da57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结束了。在下面找到代码、包和其他有用资源的链接。拜拜👋</p><ul class=""><li id="7a05" class="kv kw it js b jt ju jx jy kb kx kf ky kj kz kn op lb lc ld bi translated"><a class="ae nc" href="https://github.com/Stack-Box/stackbox-tutorials" rel="noopener ugc nofollow" target="_blank">代码</a></li><li id="fc70" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn op lb lc ld bi translated"><a class="ae nc" href="https://github.com/wurstmeister/kafka-docker" rel="noopener ugc nofollow" target="_blank">卡夫卡码头工人</a></li><li id="d2ac" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn op lb lc ld bi translated"><a class="ae nc" href="https://github.com/miguelgrinberg/Flask-SocketIO" rel="noopener ugc nofollow" target="_blank">烧瓶插槽</a></li><li id="bcf5" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn op lb lc ld bi translated"><a class="ae nc" href="https://pypi.org/project/kafka-python/" rel="noopener ugc nofollow" target="_blank">卡夫卡-巨蟒</a></li><li id="0ef1" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn op lb lc ld bi translated"><a class="ae nc" href="https://socket.io/" rel="noopener ugc nofollow" target="_blank"> socket.io </a></li></ul><p id="ef85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ng"> —作者:</em> <a class="oq or ep" href="https://medium.com/u/a640a517f7d8?source=post_page-----95a15df2d1bc--------------------------------" rel="noopener" target="_blank"> <em class="ng">索米亚·纳加拉詹</em> </a></p><blockquote class="nd ne nf"><p id="81fd" class="jq jr ng js b jt ju jv jw jx jy jz ka nh kc kd ke ni kg kh ki nj kk kl km kn im bi translated"><strong class="js iu">2021年2月25日—更新</strong></p><p id="4a13" class="jq jr ng js b jt ju jv jw jx jy jz ka nh kc kd ke ni kg kh ki nj kk kl km kn im bi translated">向读者大声喊出来<a class="ae nc" href="https://github.com/halvnok" rel="noopener ugc nofollow" target="_blank"> halvnok </a>和<a class="ae nc" href="https://github.com/Exchizz" rel="noopener ugc nofollow" target="_blank"> Exchizz </a>寻求他们对代码的反馈和建议。</p><p id="4bfd" class="jq jr ng js b jt ju jv jw jx jy jz ka nh kc kd ke ni kg kh ki nj kk kl km kn im bi translated"><strong class="js iu">变更</strong></p><p id="3661" class="jq jr ng js b jt ju jv jw jx jy jz ka nh kc kd ke ni kg kh ki nj kk kl km kn im bi translated">1.烧瓶代码现在已经集装箱化了。请参考<a class="ae nc" href="https://github.com/Stack-Box/stackbox-tutorials/pull/2" rel="noopener ugc nofollow" target="_blank">堆栈箱-教程/pull/2 </a>。依赖版本的更新也很少。</p></blockquote></div></div>    
</body>
</html>