# 如何在 C 中使用链表

> 原文：<https://levelup.gitconnected.com/how-to-use-linked-lists-in-c-eda420d31568>

![](img/ba33a8b07bf8a183cb5b14005965a16e.png)

[安德鲁·尼尔](https://unsplash.com/@andrewtneel?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍照

```
-------------------------             ------------------------
|           |           |           \ |          |           |
|   DATA    |    NEXT   |-------------|   DATA   |    NEXT   |
|           |           |           / |          |           |
-------------------------             ------------------------
```

在 C 中拥有动态数据结构的方法之一是使用链表。在本文中，我将介绍添加、删除和搜索项目的基本方法。

对于这些例子，我们使用的数据结构如下:

```
typedef struct listas {
    int info;
    struct listas * next;
} list_t;
```

## 添加项目到**头:**

```
list_t * listaddhead (list_t * t, int val)
{
    list_t * new_item; if((new_item = malloc(sizeof(list_t)))){
        new_item->info = val;
        new_item->next = t;
        t = new_item;
    } else
        printf("out of memory");
    return t;
}
```

让我们详细看看，在头部添加的方法接收指向列表第一个元素的**指针和添加到列表**的**值。**

我们将使用 **MALLOC** 实例化内存。如果有足够的内存，我们将把从方法的输入中得到的值赋给新元素，在列表的开头，我们将把指针赋给下一个元素。列表的新头部将是指向新创建的元素的指针。

为了更清楚，我将画一些图，变量的名字和代码中的一样。

这是最初的情况:

```
-------------             ------------------------
|           |           \ |          |           |           \
|  T(HEAD)  |-------------|   INFO   |    NEXT   |-------------
|           |           / |          |           |           /
-------------             -------------------------------------             ------------
|           |           \ |          |
| new_item  |-------------|   NULL   |
|           |           / |          |
-------------             ------------
```

首先我们要实例化内存空间

```
(new_item = malloc(sizeof(list_t))-------------             ------------------------
|           |           \ |          |           |      \
|  T(HEAD)  |-------------|   INFO   |    NEXT   |-------
|           |           / |          |           |      /
-------------             -------------------------------------             ------------------------
|           |           \ |          |           |      \
| new_item  |-------------|   INFO   |    NEXT   |------- NULL
|           |           / |          |           |      /
-------------             ------------------------
```

现在我们将头部分配给下一个新元素

```
new_item->next = t;-------------             ------------------------
|           |           \ |          |           |      \
|  T(HEAD)  |-------------|   INFO   |    NEXT   |-------
|           |      |    / |          |           |      /
-------------      |      ------------------------
                   | 
                   ----------------------------------
                                                    |
-------------             ------------------------  |
|           |           \ |          |           |  |
| new_item  |-------------|   INFO   |    NEXT   |---
|           |           / |          |           |
-------------             ------------------------
```

我们让 head 指向新元素，它是方法返回的元素

```
t = new_item;-------------             ------------------------
|           |           \ |          |           |      \
|  T(HEAD)  |---   -------|   INFO   |    NEXT   |-------
|           |  |   |    / |          |           |      /
-------------  |   |      ------------------------
               |   | 
               |   ----------------------------------
               |                                    |
-------------  |          ------------------------  |
|           |  |        \ |          |           |  |
| new_item  |-------------|   INFO   |    NEXT   |---
|           |           / |          |           |
-------------             ------------------------
```

## 将项目添加到尾部:

```
list_t * listaddtail (list_t * t, int val) /* add in queue */
{
    list_t * new_item;
    list_t * tmp1;
    list_t * tmp2; int i;
    for(tmp2 = t, i = 0; tmp2; tmp1 = tmp2, tmp2 = tmp2->next)
        i++; if(i){
        if((new_item = malloc(sizeof(list_t)))){
            new_item->info = val;
            new_item->next = NULL; tmp1->next = new_item;
        } else
            printf("out of memory");
    } else
        t = listaddhead(t, val);
    return t;
}
```

如何在列表末尾添加一个元素？首先，我将列表向下滚动到最后一个元素，如果列表为空，我将调用开头的 add 方法，如果不为空，我将实例化新元素的内存，将从该方法接收到的输入值赋给新元素，并将指向下一个对象的指针设置为空。
除了列表中的最后一个元素，我们还将使它指向新创建的元素。

这是最初的情况:

```
 --------------------      --------------------      
   \ |        |         |    \ |        |         |    \ 
-----|  INFO  |   NEXT  |------|  INFO  |   NEXT  |------ NULL
   / |        |         |    / |        |         |    / 
     --------------------      --------------------
```

首先我们要实例化内存空间

```
(new_item = malloc(sizeof(list_t) TMP1                TMP2
     --------------------      --------------------      
   \ |        |         |    \ |        |         |    \ 
-----|  INFO  |   NEXT  |------|  INFO  |   NEXT  |------ NULL
   / |        |         |    / |        |         |    / 
     --------------------      --------------------------------       --------------------   
|          |     \ |        |         |     \ 
| new_item | ------|  INFO  |   NEXT  |------ NULL
|          |     / |        |         |     / 
------------       --------------------
```

现在让我们将列表的最后一个元素指向新元素

```
tmp1->next = new_item; TMP1
     --------------------      --------------------      
   \ |        |         |    \ |        |         |     
-----|  INFO  |   NEXT  |------|  INFO  |   NEXT  |----
   / |        |         |    / |        |         |   | 
     --------------------      --------------------   |  
              -----------------------------------------
------------  |    --------------------   
|          |  |  \ |        |         |     \ 
| new_item | ------|  INFO  |   NEXT  |------ NULL
|          |     / |        |         |     / 
------------       --------------------
```

## 删除元素

要删除一个项目，我滚动列表直到找到该项目，当滚动列表时，我保持指向当前项目的指针和指向前一个项目的指针。
一旦找到元素，我就用要删除的元素后面的元素的指针更新前一个元素的指针。然后我们释放想要删除的元素的内存。

首先，我们找到要删除的元素

```
for(tmp1 = NULL, tmp2 = t; tmp2->next && tmp2->info != val; tmp1 = tmp2, tmp2 = tmp2->next);
 TMP1         TMP2 (TO DELETE)
    ---------------    ---------------    ---------------    
  \ |      |      |  \ |      |      |  \ |      |      |  \ 
----| INFO | NEXT |----| INFO | NEXT |----| INFO | NEXT |----
  / |      |      |  / |      |      |  / |      |      |  / 
    ---------------    ---------------    ---------------
```

我们更新指针

```
tmp1->next = tmp2->next;
free (tmp2); TMP1         TMP2 (TO DELETE)
    ---------------    ---------------    ---------------    
  \ |      |      |    |      |      |  \ |      |      |  \ 
----| INFO | NEXT |--  | INFO | NEXT | ---| INFO | NEXT |----
  / |      |      | |  |      |      | |/ |      |      |  / 
    --------------- |  --------------- |  ---------------    
                    --------------------
```

释放内存

```
free (tmp2); TMP1
    ---------------                       ---------------    
  \ |      |      |                     \ |      |      |  \ 
----| INFO | NEXT |--                  ---| INFO | NEXT |----
  / |      |      | |                  |/ |      |      |  / 
    --------------- |                  |  ---------------    
                    --------------------
```

这些是在 c 中管理列表的基本方法。

我在这里放了完整的代码和一个试图执行代码的 main

```
Compile:
gcc -include list.c main.cRun:
./a.out
```

如果你有任何问题或者你已经用其他方式解决了它们，不要犹豫，在评论中写下它们！

为了获得无限的故事，你也可以考虑只花 5 美元注册成为媒体会员。如果你用我的 [*链接*](https://pietrocolombo.medium.com/membership) *注册，我会收到一点佣金。*