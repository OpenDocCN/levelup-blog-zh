<html>
<head>
<title>5 Steps to Serverless Security With the AWS Lambda Plugin from Kong</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kong的AWS Lambda插件实现无服务器安全的5个步骤</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-steps-to-serverless-security-with-the-aws-lambda-plugin-from-kong-c8616e47013e?source=collection_archive---------13-----------------------#2022-01-24">https://levelup.gitconnected.com/5-steps-to-serverless-security-with-the-aws-lambda-plugin-from-kong-c8616e47013e?source=collection_archive---------13-----------------------#2022-01-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/3a6def81f17f97caf1f0aa31cc2e8079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lyVjykDs81Nj60b8R3cIfA.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://unsplash.com/s/photos/server?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jg" href="https://unsplash.com/@freeche?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Kvistholt摄影</a>拍摄</figcaption></figure><div class=""/><div class=""><h2 id="56e1" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">如何使用Kong的AWS Lambda插件进行Lambda调用</h2></div><p id="070a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于不喜欢开发的开发者来说，lambdas是天堂。他们可以专注于编写自包含和模块化的代码片段，部署这些功能以按需执行，而无需关心资源管理或基础架构。然而，Lambda的执行可能很棘手。</p><p id="0948" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">AWS API Gateway的无服务器安全性令人望而生畏，尤其是当您只想调用一个简单的函数作为API端点时。对于这一点，有孔的轻松关口。</p><p id="9b43" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文和视频将介绍如何使用<a class="ae jg" href="https://docs.konghq.com/hub/kong-inc/aws-lambda" rel="noopener ugc nofollow" target="_blank"> AWS Lambda插件</a>设置Kong Gateway。我们的小型项目将经历以下步骤:</p><ol class=""><li id="3856" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">在Node.js中构建一个简单的无服务器函数，该函数处理请求的头部、查询参数和主体，然后用JSON进行响应。</li><li id="1e11" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">将我们的无服务器功能部署到AWS Lambda。</li><li id="c275" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">获取调用Lambda所需的凭证。</li><li id="b46c" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">配置Kong网关监听特定本地路径上的请求。</li><li id="2439" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">向Kong添加AWS Lambda插件，以便对该路径的请求调用我们的Lambda并返回调用结果。</li></ol><p id="bea2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要走在旁边，你需要以下物品:</p><ol class=""><li id="68d4" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">一个<a class="ae jg" href="https://aws.amazon.com/free/" rel="noopener ugc nofollow" target="_blank"> AWS账户</a>(我们的资源使用可能是自由层)。</li><li id="b39b" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">基本熟悉JavaScript和Node.js。</li><li id="0d77" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">安装在本地计算机上的AWS CLI。</li><li id="c938" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">孔网关安装在您的本地机器上。遵循<a class="ae jg" href="https://docs.konghq.com/" rel="noopener ugc nofollow" target="_blank"> Kong文档</a>中的入门说明。</li></ol><figure class="mi mj mk ml gt iv"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="5e6f" class="mo mp jj bd mq mr ms mt mu mv mw mx my kp mz kq na ks nb kt nc kv nd kw ne nf bi translated">核心概念</h1><h2 id="8eb7" class="ng mp jj bd mq nh ni dn mu nj nk dp my lh nl nm na ll nn no nc lp np nq ne nr bi translated">自动气象站λ</h2><p id="3d61" class="pw-post-body-paragraph ky kz jj la b lb ns kk ld le nt kn lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">几年前，AWS Lambda服务是无服务器的同义词。它代表了功能即服务(FaaS)的首批主流产品之一。有了AWS Lambda，开发人员只需上传一个函数的代码。</p><p id="ee1b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每当您需要执行函数时，AWS Lambda都会提供执行函数所需的资源，然后在无服务器函数执行完成时取消提供这些资源。开发人员不再需要关心资源管理，因为AWS Lambda在幕后处理它。AWS Lambda目前支持Node.js、Ruby、Python和其他几种语言。</p><h2 id="7433" class="ng mp jj bd mq nh ni dn mu nj nk dp my lh nl nm na ll nn no nc lp np nq ne nr bi translated">无服务器安全性</h2><p id="d809" class="pw-post-body-paragraph ky kz jj la b lb ns kk ld le nt kn lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">当涉及到部署无服务器代码时，安全性是一个关键问题，AWS提供了一些需要牢记的<a class="ae jg" href="https://docs.aws.amazon.com/whitepapers/latest/serverless-architectures-lambda/security-best-practices.html" rel="noopener ugc nofollow" target="_blank">安全最佳实践</a>。虽然不再有需要保持安全的服务器，但是关键的问题是正确地保护无服务器功能代码的调用和更新。</p><p id="232b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只有那些有适当授权的人，无论是服务还是人类用户，才应该被允许调用或更新无服务器代码。在AWS领域，这意味着建立适当的IAM策略，并将它们附加到与服务相关的角色或单个用户。对于AWS Lambda，安全锁定的相关<a class="ae jg" href="https://docs.aws.amazon.com/lambda/latest/dg/API_Operations.html" rel="noopener ugc nofollow" target="_blank">操作</a>包括<code class="fe nx ny nz oa b">InvokeFunction</code>和<code class="fe nx ny nz oa b">UpdateFunctionCode</code>。</p><h2 id="cce6" class="ng mp jj bd mq nh ni dn mu nj nk dp my lh nl nm na ll nn no nc lp np nq ne nr bi translated">孔门户</h2><p id="fb5d" class="pw-post-body-paragraph ky kz jj la b lb ns kk ld le nt kn lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">Kong Gateway是一个轻量级的开源API网关，位于您的上游服务之前。Kong Gateway易于配置和快速部署，充当中央网关守卫，将所有传入请求路由到其预期目的地，无论是上游API服务器、第三方服务、数据库，甚至是部署到AWS Lambda的功能。</p><p id="50ea" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为你的用户客户端和你的上游服务之间的一个薄薄的层，API gateway进一步扩展了无数的<a class="ae jg" href="https://docs.konghq.com/hub/" rel="noopener ugc nofollow" target="_blank"> Kong插件</a>来处理<a class="ae jg" href="https://konghq.com/learning-center/api-gateway/api-gateway-authentication/" rel="noopener ugc nofollow" target="_blank">认证</a>、授权、流量控制、安全等等。</p><h1 id="379c" class="mo mp jj bd mq mr ms mt mu mv mw mx my kp mz kq na ks nb kt nc kv nd kw ne nf bi translated">步骤1:编写我们的函数</h1><p id="576a" class="pw-post-body-paragraph ky kz jj la b lb ns kk ld le nt kn lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">对于我们的迷你项目，我们将使用为Node.js编写的基本Lambda函数。从关于示例函数代码的<a class="ae jg" href="https://docs.aws.amazon.com/lambda/latest/dg/with-android-create-package.html" rel="noopener ugc nofollow" target="_blank"> AWS文档中获得线索，我们编写了以下代码:</a></p><pre class="mi mj mk ml gt ob oa oc od aw oe bi"><span id="a4e7" class="ng mp jj oa b gy of og l oh oi">exports.handler = function(event, context, callback) {<br/>    var res ={<br/>        "statusCode": 200,<br/>        "headers": {<br/>            "Content-Type": "*/*"<br/>        }<br/>    };<br/>    var resultBody = {<br/>        message: "Lambda invoked successfully."<br/>    };<br/>    res.body = resultBody;<br/>    callback(null, res);<br/>};</span></pre><p id="e200" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简而言之，我们的函数用一个状态代码、一个简单的头和一个消息体来响应。我们将在后面的步骤中扩展这个函数，利用传入请求的头、查询字符串参数和主体。不过，就目前而言，这已经足够开始了。</p><h1 id="ef28" class="mo mp jj bd mq mr ms mt mu mv mw mx my kp mz kq na ks nb kt nc kv nd kw ne nf bi translated">步骤2:将功能部署到AWS Lambda</h1><p id="041d" class="pw-post-body-paragraph ky kz jj la b lb ns kk ld le nt kn lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">接下来，我们将功能代码部署到AWS Lambda。我们在AWS控制台中导航到Lambda services，确保我们已经选择了一个部署区域。对于本例的其余部分，我们将使用<code class="fe nx ny nz oa b">us-west-2 region</code>。点击创建功能。</p><p id="3ff8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将从头开始编写我们的函数，为我们的函数选择一个名称(my-lambda)并选择一个Node.js运行时(<code class="fe nx ny nz oa b">Node.js 14.x</code>)。</p><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/137206c06bab8d25c0361eae33d762a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*UABcKPeruSZGUKMJcE233w.png"/></div></figure><p id="850d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建了Lambda之后，我们导航到代码源并双击<code class="fe nx ny nz oa b">index.js</code>。然后，我们粘贴上面的函数代码。</p><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/d3f2d0d29d99eabaf599b1594759abcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_bDU08oTzhETwjEGJMQc-Q.png"/></div></div></figure><p id="0bf6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">点击部署。</p><p id="7493" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了确保我们的函数正常工作，我们可以直接在控制台中测试调用。点击测试，然后点击配置测试事件。使用默认的“hello world”模板。命名您的测试事件，保留提供的默认主体。点击创建。</p><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/dbf0e440f0b672e05ff7bcf2139c6872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zxl1ZzhYwyOyHDpIuAqo9A.png"/></div></div></figure><p id="e852" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi">Now, with your <code class="fe nx ny nz oa b">testevent</code> selected, click on Test. The execution results show the result of our function call一a status code, headers, and a body with a message.</p><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi om"><img src="../Images/2934813c67f0eaa77c429cb2c97117e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*Uu-TDQEwnYAHoSy_vwvuHg.png"/></div></figure><p id="54c8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">既然我们已经部署了简单的Lambda，我们希望远程调用我们的函数。让我们转到本地机器上的命令行。</p><h1 id="cf04" class="mo mp jj bd mq mr ms mt mu mv mw mx my kp mz kq na ks nb kt nc kv nd kw ne nf bi translated">步骤3:获取调用Lambda的凭证</h1><p id="7a93" class="pw-post-body-paragraph ky kz jj la b lb ns kk ld le nt kn lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">当然，不是任何人都可以调用你的Lambda。我们提到了无服务器安全需求，以确保我们正确地锁定了调用函数和更新函数代码的能力。对于我们当前的例子，我们将关注函数调用。</p><p id="f172" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要为有权调用这个Lambda的AWS IAM用户提供凭证。当我们使用AWS CLI尝试在没有任何凭证的情况下调用Lambda函数时，这一点很明显:</p><pre class="mi mj mk ml gt ob oa oc od aw oe bi"><span id="0842" class="ng mp jj oa b gy of og l oh oi">$ aws lambda invoke \<br/>--region=us-west-2 \<br/>--invocation-type=RequestResponse \<br/>--function-name=my-lambda \<br/>response.json<br/></span><span id="0347" class="ng mp jj oa b gy on og l oh oi">Unable to locate credentials. You can configure credentials by running "aws configure".</span></pre><p id="0a22" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的第一步是创建一个IAM用户。在AWS控制台中，导航到IAM服务，然后导航到用户。使用您选择的名称创建一个新的IAM用户，并授予该用户编程访问权限。我们称我们的用户为<code class="fe nx ny nz oa b">kong-lambda-invoker</code>。</p><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oo"><img src="../Images/a71c46d2d78f8a84c6465fb258bcdba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MnukY6gKb-xnm8eI1ax-tg.png"/></div></div></figure><p id="2a32" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">逐步浏览权限、标签和审查，使用默认设置。我们将创建一个没有权限的用户，然后从那里开始迭代。点击创建用户。现在，您有了新用户的“访问密钥ID”和“秘密访问密钥”。</p><p id="ce6b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回到命令行，让我们设置这些凭证。我们粘贴来自IAM用户创建结果的值，并指定我们的区域(<code class="fe nx ny nz oa b">us-west-2</code>)和默认输出格式(<code class="fe nx ny nz oa b">json</code>):</p><pre class="mi mj mk ml gt ob oa oc od aw oe bi"><span id="57b2" class="ng mp jj oa b gy of og l oh oi">$ aws configure<br/>AWS Access Key ID [None]: AKIA5***************<br/>AWS Secret Access Key [None]: hg8o***********************************<br/>Default region name [None]: us-west-2<br/>Default output format [json]: json</span></pre><p id="3a9a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们已经配置了AWS凭证，我们尝试再次从命令行调用我们的函数:</p><pre class="mi mj mk ml gt ob oa oc od aw oe bi"><span id="e1ab" class="ng mp jj oa b gy of og l oh oi">$ aws lambda invoke \<br/>--region=us-west-2 \<br/>--invocation-type=RequestResponse \<br/>--function-name=my-lambda \<br/>response.json<br/></span><span id="e708" class="ng mp jj oa b gy on og l oh oi">An error occurred (AccessDeniedException) when calling the Invoke operation: User: arn:aws:iam::95**********:user/kong-lambda-invoker is not authorized to perform: lambda:InvokeFunction on resource: arn:aws:lambda:us-west-2:95**********:function:my-lambda</span></pre><p id="ad8b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">进步！我们仍然无法调用我们的函数，但是这一次，原因不同了。我们的用户<code class="fe nx ny nz oa b">kong-lambda-invoker</code>没有权限调用我们的函数。让我们提供这些权限。回到AWS IAM，我们选择我们的用户并单击Add permissions。</p><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi op"><img src="../Images/5cf220bbe54fca2fc1b826dbbce216d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*3vjQCu5N-V6J6UAqZfwf9w.png"/></div></figure><p id="9a6d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，单击直接附加现有策略，然后创建策略。在策略编辑器中，单击JSON并粘贴以下代码。确保用部署lambda的区域替换REGION(<code class="fe nx ny nz oa b">us-west-2</code>)。此外，用您的AWS帐户ID替换<code class="fe nx ny nz oa b">AWS-ID</code>。</p><pre class="mi mj mk ml gt ob oa oc od aw oe bi"><span id="4a5b" class="ng mp jj oa b gy of og l oh oi">{<br/>    "Version": "2012-10-17",<br/>    "Statement": [<br/>        {<br/>            "Sid": "VisualEditor0",<br/>            "Effect": "Allow",<br/>            "Action": "lambda:InvokeFunction",<br/>            "Resource": "arn:aws:lambda:REGION:AWS-ID:function:my-lambda"<br/>        }<br/>    ]<br/>}</span></pre><p id="7167" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">单击其余的策略创建部分，接受所有默认设置。为策略命名(例如，<code class="fe nx ny nz oa b">Invoke-my-lambda</code>)。既然我们已经创建了lambda调用策略，我们将返回到IAM用户并为<code class="fe nx ny nz oa b">kong-lambda-invoker</code>用户添加权限。</p><p id="2232" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们直接附加现有的策略，然后找到我们刚刚创建的策略。选择策略后，我们单击剩余的步骤，并将权限附加给我们的用户。</p><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/8716a1826eb9b450ea67249ebbddfb16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FNckL6H-eqAFzqEET3031g.png"/></div></div></figure><p id="a53b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了用户和策略之后，我们可以返回到命令行并再次调用该函数。AWS可能需要一两分钟来对您的用户进行权限更改。然而，不久之后，我们的结果是:</p><pre class="mi mj mk ml gt ob oa oc od aw oe bi"><span id="5aa1" class="ng mp jj oa b gy of og l oh oi">$ aws lambda invoke \<br/>--region=us-west-2 \<br/>--invocation-type=RequestResponse \<br/>--function-name=my-lambda \<br/>response.json<br/>{<br/>    "StatusCode": 200,<br/>    "ExecutedVersion": "$LATEST"<br/>}</span><span id="fca1" class="ng mp jj oa b gy on og l oh oi">$ more response.json<br/>{"statusCode":200,"headers":{"Content-Type":"*/*"},"body":{"message":"Lambda invoked successfully."}}</span></pre><p id="4161" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有用！我们查看输出文件<code class="fe nx ny nz oa b">response.json</code>，看到我们的<code class="fe nx ny nz oa b">200 </code>状态和带有消息的初始主体。部署了Lambda函数并获得了凭证后，就该配置Kong了。</p><h1 id="67df" class="mo mp jj bd mq mr ms mt mu mv mw mx my kp mz kq na ks nb kt nc kv nd kw ne nf bi translated">步骤4:配置开源的Kong网关</h1><p id="fa90" class="pw-post-body-paragraph ky kz jj la b lb ns kk ld le nt kn lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">根据您的无服务器环境，在本地机器上安装Kong 的步骤会有所不同。一旦安装完成，我们有几个配置步骤要遵循。</p><h2 id="e901" class="ng mp jj bd mq nh ni dn mu nj nk dp my lh nl nm na ll nn no nc lp np nq ne nr bi translated">设置声明性配置</h2><p id="5477" class="pw-post-body-paragraph ky kz jj la b lb ns kk ld le nt kn lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">要使用AWS Lambda插件，我们可以在<a class="ae jg" href="https://docs.konghq.com/gateway-oss/2.3.x/db-less-and-declarative-config/" rel="noopener ugc nofollow" target="_blank">无db模式</a>下运行Kong，这意味着我们只需编写一个声明性配置文件，当我们启动Kong时，系统会读取该文件。首先，我们将创建一个项目文件夹并生成样板配置文件:</p><pre class="mi mj mk ml gt ob oa oc od aw oe bi"><span id="9ac0" class="ng mp jj oa b gy of og l oh oi">~$ mkdir project<br/>~$ cd project<br/>~/project$ kong config init<br/>~/project$ tree<br/>.<br/>└── kong.yml</span><span id="40d1" class="ng mp jj oa b gy on og l oh oi">0 directories, 1 file</span></pre><p id="fd9d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们将配置Kong的启动行为来使用那个<code class="fe nx ny nz oa b">kong.yml</code>进行配置。为此，我们需要复制<code class="fe nx ny nz oa b">Kong's kong.conf.default </code>模板文件，将副本命名为<code class="fe nx ny nz oa b">kong.conf</code>，然后编辑它:</p><pre class="mi mj mk ml gt ob oa oc od aw oe bi"><span id="ca99" class="ng mp jj oa b gy of og l oh oi">~/project$ cd /etc/kong<br/>/etc/kong$ sudo cp kong.conf.default kong.conf<br/>/etc/kong$ tree<br/>.<br/>├── kong.conf<br/>├── kong.conf.default<br/>└── kong.logrotate</span><span id="d85c" class="ng mp jj oa b gy on og l oh oi">0 directories, 3 files</span></pre><p id="0ce4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们编辑<code class="fe nx ny nz oa b">kong.conf </code>来做一些改变。</p><pre class="mi mj mk ml gt ob oa oc od aw oe bi"><span id="fa28" class="ng mp jj oa b gy of og l oh oi">#PATH: /etc/kong/kong.conf</span><span id="bba4" class="ng mp jj oa b gy on og l oh oi"># Around line 938, uncomment and set to off<br/>database = off</span><span id="d601" class="ng mp jj oa b gy on og l oh oi"># Around line 1122, uncomment and set to<br/># absolute path to project's kong.yml file<br/>declarative_config = /PATH/TO/MY/PROJECT/kong.yml</span></pre><p id="7e66" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了这两个更改，Kong知道在启动时以无db模式工作，查看我们指定的声明性配置文件。将我们的注意力转回到我们的声明性配置文件，让我们为Kong设置一个上游服务和一个路由。粘贴以下代码作为<code class="fe nx ny nz oa b">kong.yml</code>的全部内容:</p><pre class="mi mj mk ml gt ob oa oc od aw oe bi"><span id="8d66" class="ng mp jj oa b gy of og l oh oi">_format_version: "2.1"<br/>_transform: true<br/>services:<br/>  - name: my-service<br/>    url: https://httpstat.us/200<br/>routes:<br/>  - name: my-lambda-route<br/>    service: my-service<br/>    paths:<br/>      - /lambda</span></pre><p id="9559" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面，我们添加了一个上游服务(名为<code class="fe nx ny nz oa b">my-service</code>)。这个上游服务简单地指向<a class="ae jg" href="https://httpstat.us/" rel="noopener ugc nofollow" target="_blank">一个用于HTTP状态代码测试的站点</a>，它将返回一个<code class="fe nx ny nz oa b">200</code>。然后，我们创建一个路由(称为my-lambda-route ),监听<code class="fe nx ny nz oa b">/lambda</code>路径上的请求，将这些请求转发给我们的上游服务。</p><h2 id="fc6c" class="ng mp jj bd mq nh ni dn mu nj nk dp my lh nl nm na ll nn no nc lp np nq ne nr bi translated">启动孔</h2><p id="7f22" class="pw-post-body-paragraph ky kz jj la b lb ns kk ld le nt kn lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">准备好声明性配置文件后，我们启动Kong:</p><pre class="mi mj mk ml gt ob oa oc od aw oe bi"><span id="92f5" class="ng mp jj oa b gy of og l oh oi">~/project$ sudo kong start</span></pre><h2 id="282e" class="ng mp jj bd mq nh ni dn mu nj nk dp my lh nl nm na ll nn no nc lp np nq ne nr bi translated">使用Curl请求进行测试</h2><p id="d432" class="pw-post-body-paragraph ky kz jj la b lb ns kk ld le nt kn lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">我们可以使用<code class="fe nx ny nz oa b">curl</code>发送一个请求，看看Kong是否正确地监听了路径，并成功地将请求转发给上游服务:</p><pre class="mi mj mk ml gt ob oa oc od aw oe bi"><span id="8e4c" class="ng mp jj oa b gy of og l oh oi">~/project$ curl http://localhost:8000/lambda<br/>200 OK</span></pre><p id="5d4a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">非常好。孔已经起来了。接下来，我们将对我们的<code class="fe nx ny nz oa b">kong.yml</code>文件做一些修改，添加AWS Lambda插件。</p><h1 id="7e61" class="mo mp jj bd mq mr ms mt mu mv mw mx my kp mz kq na ks nb kt nc kv nd kw ne nf bi translated">步骤5:为Kong添加AWS Lambda插件</h1><p id="862d" class="pw-post-body-paragraph ky kz jj la b lb ns kk ld le nt kn lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">最简单的形式是，AWS Lambda插件可以在路由上启用，完全不需要将路由与上游服务相关联。Kong监听该路由路径上的请求，然后使用来自该请求的参数调用远程AWS Lambda函数。这就是我们将要采取的方法。</p><p id="59de" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用以下内容替换您的<code class="fe nx ny nz oa b">kong.yml</code>的内容。确保使用IAM用户的访问密钥ID和秘密访问密钥。</p><pre class="mi mj mk ml gt ob oa oc od aw oe bi"><span id="cec1" class="ng mp jj oa b gy of og l oh oi">_format_version: "2.1"<br/>_transform: true<br/>routes:<br/>  - name: my-lambda-route<br/>    paths:<br/>      - /lambda<br/>plugins:<br/>  - name: aws-lambda<br/>    route: my-lambda-route<br/>    config:<br/>      aws_key: REPLACE-WITH-ACCESS-KEY-ID<br/>      aws_secret: REPLACE-WITH-SECRET-ACCESS-KEY<br/>      aws_region: us-west-2<br/>      function_name: my-lambda<br/>      forward_request_body: true<br/>      forward_request_headers: true<br/>      forward_request_uri: true</span></pre><p id="9554" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你会注意到我们已经移除了上游服务。我们的路由不再与服务相关联，因为请求将转到Lambda调用。我们用我们的<code class="fe nx ny nz oa b">aws-lambda plugin</code>添加了一个插件部分。注意<code class="fe nx ny nz oa b">aws-lambda</code>不是一个任意的名字，而是特指捆绑在Kong中的AWS Lambda插件。</p><p id="1a91" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以将我们的插件与我们的route ( <code class="fe nx ny nz oa b">my-lambda-route</code>)和我们在AWS部署的Lambda函数相关联。我们包括IAM用户的凭证、部署区域和函数名。接下来，我们配置插件将请求的主体、头和URI转发给Lambda调用，这将在修改函数代码后不久在函数调用的<code class="fe nx ny nz oa b">event</code>对象中看到。不过，首先，我们将重新启动Kong并检查Lambda是否被正确调用。</p><pre class="mi mj mk ml gt ob oa oc od aw oe bi"><span id="d922" class="ng mp jj oa b gy of og l oh oi">~/project$ sudo kong restart</span><span id="b6eb" class="ng mp jj oa b gy on og l oh oi">~/project$ curl http://localhost:8000/lambda<br/>{"statusCode":200,"headers":{"Content-Type":"*/*"},"body":{"message":"Lambda invoked successfully."}}</span></pre><p id="c61f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">孔启动了，按预期调用我们的Lambda。现在，让我们更新Lambda函数代码来访问请求头、查询字符串参数和主体。回到<code class="fe nx ny nz oa b">my-lambda</code>的AWS控制台，用以下代码替换<code class="fe nx ny nz oa b">index.js</code>中的代码:</p><pre class="mi mj mk ml gt ob oa oc od aw oe bi"><span id="adb7" class="ng mp jj oa b gy of og l oh oi">exports.handler = function(event, context, callback) {<br/>    var res ={<br/>        "statusCode": 200,<br/>        "headers": {<br/>            "Content-Type": "*/*"<br/>        }<br/>    };<br/>    res.body = {<br/>      incoming_headers: event.request_headers,<br/>      incoming_query_parameters: event.request_uri_args,<br/>      incoming_body: event.request_body<br/>    };<br/>    callback(null, res);<br/>};</span></pre><p id="892f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">单击Deploy以部署更新的代码。我们将使用<a class="ae jg" href="https://insomnia.rest/products/insomnia" rel="noopener ugc nofollow" target="_blank">失眠症</a>来发送请求并检查结果。</p><p id="1c4b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们向Kong代理和路径发出一个基本请求，没有参数和主体。我们自己设置了一些额外的头(包括值为<code class="fe nx ny nz oa b">test-value1</code>的<code class="fe nx ny nz oa b">test-header1</code>)。我们向<code class="fe nx ny nz oa b">http://localhost:8000/lambda</code>发送请求，并收到以下响应:</p><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi or"><img src="../Images/d5d55d395c12f619187baf5e9975b4a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*naiYLizsYf1157z-ulDibA.png"/></div></div></figure><p id="14f3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">得到的响应体显示了<code class="fe nx ny nz oa b">incoming_headers</code>，这是失眠客户端发送给我们的Kong代理的原始头，现在被转发给Lambda调用。这些包括我们在《失眠》中明确设定的价值观。</p><p id="4190" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们发送另一个请求，这次将查询字符串参数添加到我们的请求URL中。</p><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi os"><img src="../Images/d462c1441c8eeb87d9967ae6354e22aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vpmq3JqrJi541EpESiRdJg.png"/></div></div></figure><p id="1a98" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果显示我们的查询字符串参数在响应体的<code class="fe nx ny nz oa b">incoming_query_parameters</code>键中回显给我们。</p><p id="3059" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们发送一个<code class="fe nx ny nz oa b">POST</code>请求并附加一个JSON主体，验证我们的Lambda函数接收了主体数据。</p><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/2d8aac8aa770e0f9c8a81ca9d1229a9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yoCvgZboNVpD8j3GzXYKbA.png"/></div></div></figure><p id="bfa3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个最后的请求中，我们看到<code class="fe nx ny nz oa b">incoming_headers</code>、<code class="fe nx ny nz oa b">incoming_query_parameters</code>和<code class="fe nx ny nz oa b">incoming_body</code>，它们都被正确填充。</p><p id="7c35" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的Lambda函数有效，调用Lambda函数的Kong插件也有效。这打开了无数可能性和使用模式的大门。</p><h1 id="52b1" class="mo mp jj bd mq mr ms mt mu mv mw mx my kp mz kq na ks nb kt nc kv nd kw ne nf bi translated">其他使用案例</h1><h2 id="68b2" class="ng mp jj bd mq nh ni dn mu nj nk dp my lh nl nm na ll nn no nc lp np nq ne nr bi translated">invocation_type=Event的异步调用</h2><p id="2f00" class="pw-post-body-paragraph ky kz jj la b lb ns kk ld le nt kn lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">插件默认将Lambda调用的<code class="fe nx ny nz oa b">invocation_type</code>设置为<code class="fe nx ny nz oa b">RequestResponse</code>。这是一个同步调用，等待函数执行完成并返回结果。AWS Lambda函数的另一个常见调用模式是<a class="ae jg" href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html" rel="noopener ugc nofollow" target="_blank">异步调用</a>，它启动或触发一个流程，而不等待响应。为此，您可以用<code class="fe nx ny nz oa b">invocation_type=Event</code>配置插件。</p><h1 id="0be7" class="mo mp jj bd mq mr ms mt mu mv mw mx my kp mz kq na ks nb kt nc kv nd kw ne nf bi translated">孔的AWS Lambda插件让无服务器安全变得简单</h1><p id="f47d" class="pw-post-body-paragraph ky kz jj la b lb ns kk ld le nt kn lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">完成这一步后，你就可以通过Kong的AWS Lambda插件调用你自己的Lambda函数了。您的用例可能要求将该插件与其他插件一起使用以实现强大的请求处理，或者您可以将该路由和插件与由Kong管理的其他路由和上游服务一起使用。</p><p id="0748" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Kong的内置插件去除了Lambda无服务器函数执行的复杂性。开发人员只需从部署一个功能开始。然后，为了确保遵循无服务器安全最佳实践，他们设置了一个IAM用户(或与服务关联的角色),该用户具有调用该功能和更新其代码的适当权限。</p><p id="94de" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了无服务器安全性，他们就可以写一些配置行来告诉Kong使用这个插件来调用这个函数。使用AWS Lambda的简单性——这使得开发人员可以轻松愉快地编写和部署模块化代码——得到了提升。</p><p id="8c30" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">【本文原载<a class="ae jg" href="https://konghq.com/blog/serverless-security/" rel="noopener ugc nofollow" target="_blank">此处</a>。]</p></div></div>    
</body>
</html>