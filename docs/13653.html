<html>
<head>
<title>Everything You Need To Know About The CompletableFuture API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于CompletableFuture API您需要知道的一切</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/everything-you-need-to-know-about-the-completablefuture-api-ec357e731a5c?source=collection_archive---------6-----------------------#2022-09-26">https://levelup.gitconnected.com/everything-you-need-to-know-about-the-completablefuture-api-ec357e731a5c?source=collection_archive---------6-----------------------#2022-09-26</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="5596" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">使Java中的异步编程令人兴奋的API！</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/174180f0755d22c25ca244282910036e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*28cvXxjD-1KPJsP9JAz2CA.jpeg"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@priscilladupreez?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">普里西拉·杜·普里兹</a>在<a class="ae kz" href="https://unsplash.com/s/photos/happy-with-laptop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="3732" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有几次，我被要求开发高性能的应用程序。事实上，最常见的问题之一是如何提高应用程序的性能。</p><p id="6063" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">提高应用程序性能的最佳方法之一是编写异步编程，这种编程可以导致多个计算并行进行。</p><p id="e05e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然早在2004年发布Java 5时，Java就已经引入了<code class="fe lw lx ly lz b"><strong class="lc iv">Future</strong></code>接口来支持异步编程，但是使用Future有一些缺点，这使得它在现实生活场景中的使用不太理想。</p><h1 id="afa7" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">未来界面的局限性</h1><ol class=""><li id="0996" class="ms mt iu lc b ld mu lg mv lj mw ln mx lr my lv mz na nb nc bi translated"><em class="nd">期货</em>不能手动完成。</li><li id="fa93" class="ms mt iu lc b ld ne lg nf lj ng ln nh lr ni lv mz na nb nc bi translated">无法并行执行多个<em class="nd">期货(</em>或结果<em class="nd"> ) </em>然后将结果组合在一起。</li><li id="3aba" class="ms mt iu lc b ld ne lg nf lj ng ln nh lr ni lv mz na nb nc bi translated">没有针对<em class="nd">未来</em>的异常处理构造。</li><li id="10d8" class="ms mt iu lc b ld ne lg nf lj ng ln nh lr ni lv mz na nb nc bi translated"><em class="nd">未来</em>没有机制来创建可以链接在一起的多个处理阶段。需要手动完成。</li><li id="064b" class="ms mt iu lc b ld ne lg nf lj ng ln nh lr ni lv mz na nb nc bi translated"><em class="nd"> Future </em>没有通知你一个API完成的机制。</li></ol><p id="c524" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">幸运的是，随着Java 8的发布，<code class="fe lw lx ly lz b"><strong class="lc iv">CompletableFuture</strong></code>解决了上述所有问题，并提供了一种更好的Java异步编程方法。</p><h1 id="5193" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">那么，CompletableFuture有什么特别之处呢？</h1><p id="68d3" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">异步编程就是通过在单独的线程而不是主应用程序线程上运行所有任务来编写非阻塞代码，并让主线程了解进度、完成状态或任务是否失败。</p><p id="78eb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Java中的<code class="fe lw lx ly lz b"><strong class="lc iv">CompletableFuture</strong></code> API支持异步编程。它实现了<a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html" rel="noopener ugc nofollow" target="_blank"><em class="nd"/></a>和<a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html" rel="noopener ugc nofollow" target="_blank"><em class="nd">completion stage</em></a>接口。</p><h1 id="f3a9" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">CompletableFuture API的优势</h1><ol class=""><li id="46f7" class="ms mt iu lc b ld mu lg mv lj mw ln mx lr my lv mz na nb nc bi translated">如果远程API服务在使用时被关闭，您可以手动完成将来的操作来检索数据。</li><li id="20d3" class="ms mt iu lc b ld ne lg nf lj ng ln nh lr ni lv mz na nb nc bi translated"><em class="nd"> CompletableFuture </em> API允许链接多个API，从而允许您创建异步工作流。</li><li id="e55c" class="ms mt iu lc b ld ne lg nf lj ng ln nh lr ni lv mz na nb nc bi translated">它提供了异常处理机制。</li><li id="3c1e" class="ms mt iu lc b ld ne lg nf lj ng ln nh lr ni lv mz na nb nc bi translated">它提供了将多个期货组合成单个<em class="nd"> CompletableFuture </em>的机制。</li><li id="7297" class="ms mt iu lc b ld ne lg nf lj ng ln nh lr ni lv mz na nb nc bi translated">它允许在响应可用时调用API的回调函数。</li></ol><h1 id="1d31" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">创造一个完美的未来</h1><p id="3aa5" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">CompletableFuture最简单的例子如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="67ea" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用无参数构造函数，可以创建尽可能简单的CompletableFuture。</p><pre class="kk kl km kn gu no lz np nq aw nr bi"><span id="5a83" class="ns mb iu lz b gz nt nu l nv nw"><strong class="lz iv">CompletableFuture&lt;String&gt; completableFuture = new <br/>CompletableFuture&lt;String&gt;();</strong></span></pre><p id="e02f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了得到CompletableFuture的结果，调用了<code class="fe lw lx ly lz b"><strong class="lc iv">CompletableFuture.get()</strong></code>。这个get()方法一直阻塞到未来完成。</p><p id="8662" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，为了解决这个问题，<code class="fe lw lx ly lz b"><strong class="lc iv">CompletableFuture.complete()</strong></code>可以用来手动完成未来。</p><pre class="kk kl km kn gu no lz np nq aw nr bi"><span id="36df" class="ns mb iu lz b gz nt nu l nv nw"><strong class="lz iv">CompletableFuture.complete("some dummy data from Future")</strong></span></pre><p id="8d6e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">等待这个Future的所有客户机将收到指定的结果，对上述方法的后续调用将被忽略。</p><p id="ea3e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">CompletableFuture有50多种不同的方法来组成、组合和执行异步计算步骤以及处理错误。T11】</p><p id="e6db" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里我们将介绍一些我在项目中广泛使用的最常见的方法。</p><h1 id="623e" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">运行异步任务的CompletableFuture</h1><p id="1418" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">运行异步任务主要有两种静态方法。</p><h2 id="0cd7" class="ns mb iu bd mc nx ny dn mg nz oa dp mk lj ob oc mm ln od oe mo lr of og mq oh bi translated">运行异步()</h2><p id="f6d0" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated"><strong class="lc iv"> <em class="nd">如果你想异步运行一些后台任务，又不想从任务中返回任何东西，那么使用</em> </strong> <code class="fe lw lx ly lz b"><strong class="lc iv">CompletableFuture.runAsync()</strong></code>。</p><p id="f5fd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">由于这个静态方法接受一个<a class="ae kz" href="https://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html" rel="noopener ugc nofollow" target="_blank"> <em class="nd"> Runnable </em> </a>对象并且不返回值，所以它返回<em class="nd">CompletableFuture&lt;Void&gt;</em>。重载版本也接受Executor作为第二个参数。</p><ol class=""><li id="4700" class="ms mt iu lc b ld le lg lh lj oi ln oj lr ok lv mz na nb nc bi translated"><em class="nd">completablefuture . run async(Runnable)</em></li><li id="6bc1" class="ms mt iu lc b ld ne lg nf lj ng ln nh lr ni lv mz na nb nc bi translated"><em class="nd">completablefuture . run async(Runnable，Executor) </em></li></ol><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="35bb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在获取线程名称的时候，你会注意到CompletableFuture在一个从全局<a class="ae kz" href="http://ForkJoinPool.commonPool()" rel="noopener ugc nofollow" target="_blank"><em class="nd">forkjoinpool . common pool()</em></a>获得的线程中执行了这个任务。</p><h2 id="a88e" class="ns mb iu bd mc nx ny dn mg nz oa dp mk lj ob oc mm ln od oe mo lr of og mq oh bi translated">供应同步()</h2><p id="8b4c" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated"><strong class="lc iv"> <em class="nd">如果你想</em> </strong> <strong class="lc iv"> <em class="nd">异步运行一些后台任务，想从那个任务返回什么，那么就用</em> </strong> <code class="fe lw lx ly lz b"><strong class="lc iv">CompletableFuture.supplyAsync()</strong></code> <strong class="lc iv">。</strong></p><p id="8ba9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它接受一个<a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html" rel="noopener ugc nofollow" target="_blank"> <em class="nd">供应商&lt; T &gt; </em> </a>并返回一个<em class="nd">CompletableFuture&lt;T&gt;</em>其中<em class="nd"> T </em>是通过调用给定供应商获得的值的类型。它还有把<em class="nd">执行器</em>作为第二个参数的版本。</p><ol class=""><li id="46a2" class="ms mt iu lc b ld le lg lh lj oi ln oj lr ok lv mz na nb nc bi translated"><em class="nd">completablefuture . supply sync(供应商&lt; T &gt; ) </em></li><li id="e3e5" class="ms mt iu lc b ld ne lg nf lj ng ln nh lr ni lv mz na nb nc bi translated"><em class="nd">completablefuture . supply sync(供应商&lt; T &gt;，执行者)</em></li></ol><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="2e34" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里你会注意到线程的名字是<em class="nd"> pool-1-thread-1 </em>而不是<a class="ae kz" href="http://ForkJoinPool.commonPool()" rel="noopener ugc nofollow" target="_blank"><em class="nd">forkjoinpool . common pool</em></a><em class="nd">。这是因为我们使用Executor创建了一个线程池，这样任务就可以从我们自己的线程池中执行。</em></p><p id="bc6a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">CompletableFuture API中的所有方法都有两个版本——一个有Executor作为第二个参数，另一个没有。 </p><h1 id="7f6c" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">对结果进行转换和处理</h1><p id="24f5" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">所以<code class="fe lw lx ly lz b"><strong class="lc iv">CompletableFuture.get()</strong></code>方法是阻塞的，它一直等到未来完成后才返回完成后的结果。</p><p id="54f3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来呢？您希望结果被转换或进一步处理，对吗？</p><p id="de0d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可以在回调函数中添加更多的逻辑。事实上，要构建异步应用程序，您需要添加一个回调，当异步计算完成时，该回调将被自动调用。</p><p id="f9fd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在CompletableFuture中添加回调函数的好处是，我们不必等待结果—只需在回调函数中添加逻辑，它就会自动执行。</p><p id="1dab" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">主要有三种方法来附加回调。</p><h2 id="c4a7" class="ns mb iu bd mc nx ny dn mg nz oa dp mk lj ob oc mm ln od oe mo lr of og mq oh bi translated">然后应用()</h2><p id="cd86" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated"><strong class="lc iv"> <em class="nd">如果要处理和转换CompletableFuture的结果，那么使用</em> </strong> <code class="fe lw lx ly lz b"><strong class="lc iv">thenApply()</strong></code> <strong class="lc iv"> <em class="nd">。</em> </strong></p><p id="7c52" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它以一个<a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html" rel="noopener ugc nofollow" target="_blank"> <em class="nd">函数&lt; T，R &gt; </em> </a>作为自变量。<em class="nd">函数&lt; T，R &gt; </em>是一个简单的函数接口，表示一个接受类型<em class="nd"> T </em>的参数并产生类型<em class="nd"> R </em>的结果的函数。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="0936" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b"><strong class="lc iv">thenApply()</strong></code>也可以用来将一系列的变换串联起来，一个接一个地执行。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nm nn l"/></div></figure><h2 id="2d56" class="ns mb iu bd mc nx ny dn mg nz oa dp mk lj ob oc mm ln od oe mo lr of og mq oh bi translated">然后接受()</h2><p id="ca6a" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated"><strong class="lc iv"> <em class="nd">如果你不想从回调函数中返回任何东西，只想在未来完成后执行一些代码，那么使用</em> </strong> <code class="fe lw lx ly lz b"><strong class="lc iv">thenAccept()</strong></code>。</p><p id="f6e6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b"><strong class="lc iv"><em class="nd">CompletableFuture.thenAccept()</em></strong></code>接受一个<a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html" rel="noopener ugc nofollow" target="_blank"> <em class="nd">消费者&lt; T &gt; </em> </a>并返回一个<em class="nd">CompletableFuture&lt;Void&gt;</em>。它能接触到它所依附的未来的结果。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nm nn l"/></div></figure><h2 id="51e1" class="ns mb iu bd mc nx ny dn mg nz oa dp mk lj ob oc mm ln od oe mo lr of og mq oh bi translated">然后运行()</h2><p id="d6fb" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated"><em class="nd">类似于</em> <code class="fe lw lx ly lz b"><strong class="lc iv">thenAccept()</strong></code> <strong class="lc iv"> <em class="nd">，如果你不想从回调函数中返回任何东西，只想执行一些未来完成后的代码，那么就使用</em> </strong> <code class="fe lw lx ly lz b"><strong class="lc iv">thenRun()</strong></code>。</p><p id="e143" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，<code class="fe lw lx ly lz b"><strong class="lc iv">thenAccept()</strong></code>可以访问它所附属的CompletableFuture的结果，而<code class="fe lw lx ly lz b"><strong class="lc iv">thenRun()</strong></code>却连未来的结果都不能访问。它将一个<em class="nd"> Runnable </em>作为参数，并返回一个<em class="nd">CompletableFuture&lt;Void&gt;</em>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="4f5f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="nd">由于</em> </strong> <code class="fe lw lx ly lz b"><strong class="lc iv">thenAccept()</strong></code> <strong class="lc iv"> <em class="nd">和</em> </strong> <code class="fe lw lx ly lz b"><strong class="lc iv">thenRun()</strong></code> <strong class="lc iv"> <em class="nd">都是消费者，它们往往被用作回调链中的最后一个回调。</em> </strong></p><p id="8267" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">CompletableFuture提供的所有回调方法都有两个异步变量，可以帮助并行执行计算。</p><pre class="kk kl km kn gu no lz np nq aw nr bi"><span id="70a0" class="ns mb iu lz b gz nt nu l nv nw"><strong class="lz iv">thenApply(Function&lt;? super T,? extends U&gt; fn)</strong></span><span id="9153" class="ns mb iu lz b gz ol nu l nv nw"><strong class="lz iv">thenApplyAsync(Function&lt;? super T,? extends U&gt; fn)</strong></span><span id="118d" class="ns mb iu lz b gz ol nu l nv nw"><strong class="lz iv">thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor)</strong></span></pre><h1 id="ac94" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">组合CompletableFutures的结果</h1><p id="1cc9" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">Java 8的发布带来的最好的事情之一是函数式编程的引入。它遵循<em class="nd">单子</em>设计模式。</p><blockquote class="om on oo"><p id="9ff9" class="la lb nd lc b ld le jv lf lg lh jy li op lk ll lm oq lo lp lq or ls lt lu lv in bi translated">“Monad是一种软件设计模式，其结构将程序片段(函数)组合在一起，并将它们的返回值包装在一个具有额外计算的类型中。”—维基百科</p></blockquote><p id="201c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">CompletableFuture API使您能够在一系列计算步骤中组合CompletableFuture实例。这种链接的结果是一个CompletableFuture，可以进一步链接和组合。</p><h2 id="05f0" class="ns mb iu bd mc nx ny dn mg nz oa dp mk lj ob oc mm ln od oe mo lr of og mq oh bi translated">然后撰写()</h2><p id="e8c7" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated"><strong class="lc iv"> <em class="nd">如果你想从一个远程API服务获取数据，并使用这些数据，你想从另一个API获取一些其他数据，你应该使用</em> </strong> <code class="fe lw lx ly lz b"><strong class="lc iv">thenCompose()</strong></code> <strong class="lc iv"> <em class="nd">。</em>T12】</strong></p><p id="e2aa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="nd"> thenCompose() </em>方法<em class="nd"> </em>接收一个函数，该函数返回同类型的另一个对象。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nm nn l"/></div></figure><h2 id="06b3" class="ns mb iu bd mc nx ny dn mg nz oa dp mk lj ob oc mm ln od oe mo lr of og mq oh bi translated"><strong class="ak">然后合并()</strong></h2><p id="9978" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated"><strong class="lc iv"> <em class="nd">如果你想将两个独立运行的期货组合起来，然后在两个期货都完成时对结果进行操作，其中一个期货的结果依赖于另一个，那么你应该使用</em> </strong> <code class="fe lw lx ly lz b"><strong class="lc iv">thenCombine()</strong></code> <strong class="lc iv">。</strong></p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nm nn l"/></div></figure><h1 id="d17c" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">异常处理</h1><p id="83ae" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">在一个完美的世界里，一切都会按照计划运行，不会有任何问题、错误或异常。嗯，那只是假设。</p><p id="cb08" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在软件开发中，异常可能并且将会发生。因此，处理它们是很重要的，否则它会破坏我们的系统。幸运的是，CompletableFuture API中有异常处理机制。</p><h2 id="021f" class="ns mb iu bd mc nx ny dn mg nz oa dp mk lj ob oc mm ln od oe mo lr of og mq oh bi translated">异常()</h2><p id="e9b1" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated"><strong class="lc iv"> <em class="nd">如果要记录并返回未来发生的异常的默认值，那么使用</em> </strong> <code class="fe lw lx ly lz b"><strong class="lc iv">exceptionally()</strong></code>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="3f61" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">还有其他方法，如<code class="fe lw lx ly lz b"><strong class="lc iv">handle()</strong></code>和<code class="fe lw lx ly lz b"><strong class="lc iv">completeExceptionally()</strong></code>，用于不同场景的异常处理。</p><h1 id="63e0" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">结论</h1><p id="a2d2" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">如前所述，CompletableFuture API中有50种方法可以满足不同的用例，探究每一种方法将会使本文变得冗长。</p><p id="29dc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最近几年我一直在研究异步系统。如果你是第一次学习，你肯定会觉得它令人望而生畏。然而，你会开始喜欢这种编程方法，因为随着时间的推移，它变得越来越令人兴奋。</p></div><div class="ab cl os ot hy ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="in io ip iq ir"><p id="74cd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你喜欢读这篇文章，你可能也会发现下面的文章值得你花时间去读。</p><div class="oz pa gq gs pb pc"><a href="https://medium.com/illumination/this-ai-generator-creates-viral-motivational-but-cringy-linkedin-posts-85ffd4902a45" rel="noopener follow" target="_blank"><div class="pd ab fp"><div class="pe ab pf cl cj pg"><h2 class="bd iv gz z fq ph fs ft pi fv fx it bi translated">这个人工智能生成器网站创建了病毒式的、激励性的、但令人生厌的LinkedIn帖子</h2><div class="pj l"><h3 class="bd b gz z fq ph fs ft pi fv fx dk translated">LinkedIn上无人问津的成功病毒工具。</h3></div><div class="pk l"><p class="bd b dl z fq ph fs ft pi fv fx dk translated">medium.com</p></div></div><div class="pl l"><div class="pm l pn po pp pl pq kt pc"/></div></div></a></div><div class="oz pa gq gs pb pc"><a rel="noopener  ugc nofollow" target="_blank" href="/9-incredible-websites-that-every-developer-should-bookmark-1534d52f3f7d"><div class="pd ab fp"><div class="pe ab pf cl cj pg"><h2 class="bd iv gz z fq ph fs ft pi fv fx it bi translated">每个开发者都应该收藏的9个不可思议的网站</h2><div class="pj l"><h3 class="bd b gz z fq ph fs ft pi fv fx dk translated">这些网站不仅会帮助你的软件开发之旅，还会帮助你的内容…</h3></div><div class="pk l"><p class="bd b dl z fq ph fs ft pi fv fx dk translated">levelup.gitconnected.com</p></div></div><div class="pl l"><div class="pr l pn po pp pl pq kt pc"/></div></div></a></div></div><div class="ab cl os ot hy ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="in io ip iq ir"><p id="cbc0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你喜欢阅读有助于你更好地学习、生活和工作的故事，可以考虑 <a class="ae kz" href="https://viveknaskar.medium.com/subscribe" rel="noopener"> <em class="nd">成为</em> </a> <em class="nd">的订阅者。成为会员后，你可以无限制地阅读10000篇故事、文章和作家。每月只要5美元。</em> <a class="ae kz" href="https://viveknaskar.medium.com/membership" rel="noopener"> <em class="nd">如果你使用我的链接</em> </a> <em class="nd">注册，我将获得一点佣金，帮助我写更多的文章。</em></p></div><div class="ab cl os ot hy ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="in io ip iq ir"><h1 id="e694" class="ma mb iu bd mc md ps mf mg mh pt mj mk ka pu kb mm kd pv ke mo kg pw kh mq mr bi translated">分级编码</h1><p id="a8bf" class="pw-post-body-paragraph la lb iu lc b ld mu jv lf lg mv jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="2816" class="ms mt iu lc b ld le lg lh lj oi ln oj lr ok lv px na nb nc bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="d391" class="ms mt iu lc b ld ne lg nf lj ng ln nh lr ni lv px na nb nc bi translated">📰查看<a class="ae kz" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="db7f" class="ms mt iu lc b ld ne lg nf lj ng ln nh lr ni lv px na nb nc bi translated">🔔关注我们:<a class="ae kz" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae kz" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae kz" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="9120" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">🚀👉<a class="ae kz" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv">将像你这样的开发人员安置在顶级创业公司和科技公司</strong> </a></p></div></div>    
</body>
</html>