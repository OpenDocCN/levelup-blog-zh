<html>
<head>
<title>Design Patterns: Chain of Responsibility Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式:JavaScript中的责任链模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/design-patterns-chain-of-responsibility-pattern-in-javascript-80b3c44d0f4e?source=collection_archive---------8-----------------------#2022-12-14">https://levelup.gitconnected.com/design-patterns-chain-of-responsibility-pattern-in-javascript-80b3c44d0f4e?source=collection_archive---------8-----------------------#2022-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e66b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使得对象不需要知道哪个对象处理它的请求和链的结构，并且发送方和接收方不需要有关于彼此的清楚信息。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1458c6a4ebf7765d67751b14428d76e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HLBYhBwEX6DRMC8b"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@fkaymak?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">法鲁克·凯马克</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a413" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设计模式对于web开发人员来说非常重要，掌握它们我们可以写出更好的代码。在本文中，我将使用<strong class="lb iu"> JavaScript </strong>来介绍<strong class="lb iu">责任模式链</strong>。</p><p id="270b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">公司里不同的职位有不同的职责和权限。以某公司的请假流程为例，团队成员请假1–2天，组长批准就够了，请假申请不需要流向部门经理和总监。上述公司对应的请假流程如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/d45c55a5f4981e5c463c961a099b0b5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*76hnYJTZd2IKYqGg90STSQ.png"/></div></div></figure><p id="89a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上图可以看出，如果流程中的审批人(请求处理对象)不能处理当前的休假审批请求，该请求将被转发给下一级审批人。对于web开发人员来说，在开发类似的审批流功能时，可以考虑使用<strong class="lb iu">责任链模式</strong>。</p><p id="967f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">责任链模式通过给多个对象一个处理请求的机会，避免了请求的发送方和接收方之间的耦合。<strong class="lb iu">在责任链模式中，许多对象将包含对下一个对象的引用，它们被连接起来形成一个链。</strong>请求在链上传递，直到链上的对象可以处理该请求。</p><p id="66a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在了解了责任链模式的作用之后，我将带您使用责任链模式来完成请假审批流程的上述功能。责任链模式主要由以下两个角色组成:</p><ul class=""><li id="bf35" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><code class="fe mf mg mh mi b">Handler</code>:抽象处理程序类，包含处理请求的抽象方法和指向后继处理程序的成员属性。</li><li id="4313" class="lw lx it lb b lc mj lf mk li ml lm mm lq mn lu mb mc md me bi translated"><code class="fe mf mg mh mi b">ConcreteHandler</code>:实现请求的具体处理逻辑，内部将决定请求是否可以处理，如果可以直接处理，则请求将被转发给后续的处理程序。</li></ul><p id="1f6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解下面的代码，我们来看看下面对应的UML类图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/1dbead85c913c9f4ce52c3332c74a3d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qsmoJxwOFHdQGZo5Ictv7Q.png"/></div></div></figure><p id="f2fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们定义一个用于处理休假请求的抽象处理程序类:</p><pre class="kj kk kl km gt mp mi mq bn mr ms bi"><span id="ec20" class="mt mu it mi b be mv mw l mx my">class DayOffHandler {<br/>  nextHandler;<br/><br/>  setNextHandler(hanlder) {<br/>    this.nextHandler = hanlder;<br/>  }<br/><br/>  getNextHandler() {<br/>    return this.nextHandler;<br/>  }<br/><br/>  handleRequest(name, daysOff) {<br/>    throw new Error("This method is implemented by subclasses!");<br/>  }<br/>}</span></pre><p id="6dc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mf mg mh mi b">DayOffHandler</code>抽象类中，私有成员属性<code class="fe mf mg mh mi b">nextHandler</code>用于保存后继处理程序的引用，<code class="fe mf mg mh mi b">setNextHandler</code>和<code class="fe mf mg mh mi b">getNextHandler</code>方法用于设置和获取<code class="fe mf mg mh mi b">nextHandler</code>属性的值。因为每个角色处理请求的逻辑是不同的，所以我们定义了一个<code class="fe mf mg mh mi b">handleRequest</code>抽象方法。</p><p id="c808" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后在<code class="fe mf mg mh mi b">DayOffHandler</code>抽象类的基础上，通过继承实现不同的子类。需要注意的是，当<strong class="lb iu">每个角色处理一个特定的请求时，会判断自己是否能处理该请求。如果它可以处理请求，它将直接处理它，否则，它将把请求转移到后续处理程序。</strong></p><p id="b9b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">teamleadhandler</strong></p><pre class="kj kk kl km gt mp mi mq bn mr ms bi"><span id="1487" class="mt mu it mi b be mv mw l mx my">class TeamleaderHandler extends DayOffHandler {<br/>  handleRequest(name, daysOff) {<br/>    const msg = `${name} asked for leave for ${daysOff} days, approved by the team leader`;<br/>    if (daysOff &lt;= 2) {<br/>      console.log(`${msg}, the process is over! \r\n`);<br/>    } else {<br/>      console.log(`${msg}, forwarded to the next level for approval.`);<br/>      this.getNextHandler() &amp;&amp;<br/>        this.getNextHandler().handleRequest(name, daysOff);<br/>    }<br/>  }<br/>}</span></pre><p id="9c20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">经理处理员</strong></p><pre class="kj kk kl km gt mp mi mq bn mr ms bi"><span id="9e87" class="mt mu it mi b be mv mw l mx my">class ManagerHandler extends DayOffHandler {<br/>  handleRequest(name, daysOff) {<br/>    const msg = `${name} asked for leave for ${daysOff} days, approved by department manager`;<br/>    if (3 &lt;= daysOff &amp;&amp; daysOff &lt;= 5) {<br/>      console.log(`${msg}, the process is over! \r\n`);<br/>    } else {<br/>      console.log(`${msg}, forwarded to the next level for approval.`);<br/>      this.getNextHandler() &amp;&amp;<br/>        this.getNextHandler().handleRequest(name, daysOff);<br/>    }<br/>  }<br/>}</span></pre><p id="355f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">董事经理</strong></p><pre class="kj kk kl km gt mp mi mq bn mr ms bi"><span id="2fa4" class="mt mu it mi b be mv mw l mx my">class DirectorHandler extends DayOffHandler {<br/>  handleRequest(name, daysOff) {<br/>    if (5 &lt; daysOff) {<br/>      console.log(<br/>        `${name} asked for leave for ${daysOff} days, Approved by the director, the process is over! \r\n`<br/>      );<br/>    }<br/>  }<br/>}</span></pre><blockquote class="mz na nb"><p id="4a1f" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">提示:在实际项目中，每个角色可以批准的休假天数应该支持动态配置。</p></blockquote><p id="a074" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在创建了对应于不同角色的处理程序类之后，我们仍然需要根据休假审批流程将处理程序对象串在一起，形成一个处理程序链。接下来我们要做的是封装上面的处理逻辑，所以我们引入了一个新的类。</p><pre class="kj kk kl km gt mp mi mq bn mr ms bi"><span id="ac14" class="mt mu it mi b be mv mw l mx my">class DayOffFlow {<br/>  dayOffHandler;<br/>  constructor() {<br/>    this.dayOffHandler = this.buildHandlerChain();<br/>  }<br/><br/>  buildHandlerChain() {<br/>    const teamleaderHandler = new TeamleaderHandler();<br/>    const managerHandler = new ManagerHandler();<br/>    const directorHandler = new DirectorHandler();<br/>    teamleaderHandler.setNextHandler(managerHandler);<br/>    managerHandler.setNextHandler(directorHandler);<br/>    return teamleaderHandler;<br/>  }<br/><br/>  handleRequest(name, daysOff) {<br/>    this.dayOffHandler.handleRequest(name, daysOff);<br/>  }<br/>}</span></pre><p id="b13c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们定义了一个<code class="fe mf mg mh mi b">DayOffFlow</code>类，它包含两个核心方法:</p><ul class=""><li id="f6d4" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><code class="fe mf mg mh mi b">buildHandlerChain</code>:该方法用于根据已知的休假审批流程构建休假处理链；</li><li id="02c8" class="lw lx it lb b lc mj lf mk li ml lm mm lq mn lu mb mc md me bi translated"><code class="fe mf mg mh mi b">handleRequest</code>:该方法接受两个参数，<code class="fe mf mg mh mi b">name</code>和<code class="fe mf mg mh mi b">daysOff</code>分别代表请假人员和请假天数，用于处理实际的请假请求。</li></ul><p id="bf09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了<code class="fe mf mg mh mi b">DayOffFlow</code>类，让我们验证它的功能:</p><pre class="kj kk kl km gt mp mi mq bn mr ms bi"><span id="c181" class="mt mu it mi b be mv mw l mx my">const dayOffFlow = new DayOffFlow();<br/>dayOffFlow.handleRequest("Bytefer", 1); // 1 days off<br/>dayOffFlow.handleRequest("Bytefish", 3); // 3 days off<br/>dayOffFlow.handleRequest("Chris1993", 6); // 6 days off</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/d45c55a5f4981e5c463c961a099b0b5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*76hnYJTZd2IKYqGg90STSQ.png"/></div></div></figure><p id="dc42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当上述代码成功运行时，控制台将输出以下结果:</p><pre class="kj kk kl km gt mp mi mq bn mr ms bi"><span id="492d" class="mt mu it mi b be mv mw l mx my">Bytefer asked for leave for 1 days, approved by the team leader, the process is over! <br/><br/>Bytefish asked for leave for 3 days, approved by the team leader, forwarded to the next level for approval.<br/>Bytefish asked for leave for 3 days, approved by department manager, the process is over! <br/><br/>Chris1993 asked for leave for 6 days, approved by the team leader, forwarded to the next level for approval.<br/>Chris1993 asked for leave for 6 days, approved by department manager, forwarded to the next level for approval.<br/>Chris1993 asked for leave for 6 days, Approved by the director, the process is over! </span></pre><p id="d1f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们总结一下责任链模式的使用场景:</p><ul class=""><li id="ac07" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">有多个对象可以处理同一个请求。哪个对象处理请求将在运行时确定。<strong class="lb iu">客户只需要向链提交请求，不需要关心请求由谁处理以及如何处理</strong>。</li><li id="5689" class="lw lx it lb b lc mj lf mk li ml lm mm lq mn lu mb mc md me bi translated">可以动态指定一组对象来处理请求，客户端可以动态创建一个责任链来处理请求，还可以更改链中处理器的顺序。</li></ul><p id="76a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">稍后我会继续介绍其他模式，如果你有兴趣，可以在<a class="ae ky" href="https://medium.com/@bytefer" rel="noopener"> Medium </a>或者<a class="ae ky" href="https://twitter.com/Tbytefer" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="bbec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想学习打字，不要错过<strong class="lb iu">掌握打字</strong>系列。</p><div class="nn no gp gr np nq"><a href="https://medium.com/frontend-canteen/with-these-articles-you-will-not-be-confused-when-learning-typescript-d96a5c99e229" rel="noopener follow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">有了40+篇文章，学习TypeScript就不会迷茫了</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">通过生动的动画，让你轻松了解TypeScript的难点和核心知识！不断地…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">medium.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe ks nq"/></div></div></a></div></div></div>    
</body>
</html>