<html>
<head>
<title>Learning JavaScript by Implementing Lodash Methods — Grouping Items</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过实现Lodash方法学习JavaScript对项目进行分组</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-javascript-by-implementing-lodash-methods-grouping-items-79a34b197435?source=collection_archive---------10-----------------------#2020-05-14">https://levelup.gitconnected.com/learning-javascript-by-implementing-lodash-methods-grouping-items-79a34b197435?source=collection_archive---------10-----------------------#2020-05-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/801c187adb01b527dadab8b780805cd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zPJcQt6pEfem_idN"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">布鲁克·卡吉尔在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="7108" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Lodash是一个非常有用的工具库，让我们可以轻松地处理对象和数组。</p><p id="7fcc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，现在JavaScript标准库正在赶上诸如Lodash之类的库，我们可以用简单的方法实现许多功能。</p><p id="e198" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究如何实现Lodash方法来对集合中的项目进行分组。</p><h1 id="daf5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><code class="fe mc md me mf b">keyBy</code></h1><p id="52b7" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">他们<code class="fe mc md me mf b">keyBy</code>方法将集合条目分组到由函数返回的键中，该函数将条目作为参数，并根据函数代码中的内容返回键。</p><p id="dec7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以创建自己的<code class="fe mc md me mf b">keyBy</code>函数如下:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="4ce3" class="mt lf it mf b gy mu mv l mw mx">const keyBy = (arr, fn) =&gt; {<br/>  let obj = {};<br/>  for (const a of arr) {<br/>    obj[fn(a)] = a;<br/>  }<br/>  return obj;<br/>}</span></pre><p id="5e54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们只是创建了一个空对象，然后用来自<code class="fe mc md me mf b">for...of</code>循环的数组条目调用<code class="fe mc md me mf b">fn</code>来填充它，并将它用作键。</p><p id="4b6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后将相应的数组条目设置为值，并返回对象。</p><p id="65da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们这样称呼它时:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="1247" class="mt lf it mf b gy mu mv l mw mx">const arr = [{<br/>    'dir': 'left',<br/>    'code': 99<br/>  },<br/>  {<br/>    'dir': 'right',<br/>    'code': 100<br/>  }<br/>];<br/>const result = keyBy(arr, o =&gt; String.fromCharCode(o.code))</span></pre><p id="b902" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么<code class="fe mc md me mf b">result</code>就是:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="e688" class="mt lf it mf b gy mu mv l mw mx">{<br/>  "c": {<br/>    "dir": "left",<br/>    "code": 99<br/>  },<br/>  "d": {<br/>    "dir": "right",<br/>    "code": 100<br/>  }<br/>}{<br/>  "c": {<br/>    "dir": "left",<br/>    "code": 99<br/>  },<br/>  "d": {<br/>    "dir": "right",<br/>    "code": 100<br/>  }<br/>}</span></pre><h1 id="6b47" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><code class="fe mc md me mf b">map</code></h1><p id="37d1" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe mc md me mf b">map</code>方法返回一个从原始数组映射而来的数组，方法是在每个条目上调用一个函数，并将它放入新数组中。</p><p id="4513" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于普通JavaScript有一个用于数组实例的<code class="fe mc md me mf b">map</code>方法，我们可以用它来实现Lodash <code class="fe mc md me mf b">map</code>方法。</p><p id="4df8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Lodash的<code class="fe mc md me mf b">map</code>方法也将一个对象作为参数，该对象获取键，然后用函数映射值，并将值放入返回的数组中。</p><p id="0665" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以这样实现:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="6bcf" class="mt lf it mf b gy mu mv l mw mx">const map = (collection, iteratee) =&gt; {<br/>  if (Array.isArray(collection)){<br/>    return collection.map(iteratee);<br/>  }<br/>  else {<br/>    return Object.values(collection).map(iteratee)<br/>  }<br/>}</span></pre><p id="8ede" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们使用<code class="fe mc md me mf b">Array.isArray</code>方法来检查<code class="fe mc md me mf b">collection</code>是否是一个数组。如果是，那么我们就使用数组的<code class="fe mc md me mf b">map</code>方法，并使用<code class="fe mc md me mf b">iteratee</code>作为回调。</p><p id="e30d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，我们使用<code class="fe mc md me mf b">Object.values</code>返回一个对象值的数组，并使用<code class="fe mc md me mf b">iteratee</code>作为回调函数调用<code class="fe mc md me mf b">map</code>。</p><p id="77af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们可以这样称呼它:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="ab48" class="mt lf it mf b gy mu mv l mw mx">const result = map([4, 8], x =&gt; x**2);</span></pre><p id="9042" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将<code class="fe mc md me mf b">result</code>设置为:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="1232" class="mt lf it mf b gy mu mv l mw mx">[<br/>  16,<br/>  64<br/>]</span></pre><p id="cf64" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，当我们跑步时:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="8d94" class="mt lf it mf b gy mu mv l mw mx">const result = map({ 'a': 4, 'b': 8 }, x =&gt; x**2);</span></pre><p id="5ff2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到同样的结果。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/b36b2709daef32ded988d939be6ffe74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kNcnRrOpMVkSL51H"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图为<a class="ae kf" href="https://unsplash.com/@miinyuii?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Duy Pham </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h1 id="57da" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><code class="fe mc md me mf b">partition</code></h1><p id="864f" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe mc md me mf b">partition</code>方法返回一个数组，该数组由传入的函数返回的键分组。</p><p id="55c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它根据函数返回的键对数组进行分组。</p><p id="88ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以如下实现它:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="9e95" class="mt lf it mf b gy mu mv l mw mx">const partition = (collection, predicate) =&gt; {<br/>  let obj = {};<br/>  for (const a of collection) {<br/>    if (!Array.isArray(obj[predicate(a)])) {<br/>      obj[predicate(a)] = [];<br/>    }<br/>    obj[predicate(a)].push(a);<br/>  }<br/>  return Object.keys(obj).map(k =&gt; obj[k])<br/>}</span></pre><p id="5fad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们创建了一个<code class="fe mc md me mf b">obj</code>对象，然后用一个<code class="fe mc md me mf b">for...of</code>循环遍历<code class="fe mc md me mf b">collection</code>。</p><p id="a54e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用键<code class="fe mc md me mf b">obj</code>创建一个数组，这个数组是通过调用条目上的<code class="fe mc md me mf b">predicate</code>创建的。</p><p id="b32d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果它不是一个数组，那么我们把它设置为一个空数组。然后我们根据按键推送项目。</p><p id="b87d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们通过将键映射到相应的值来返回数组中的值。</p><p id="9dad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么当我们这样称呼它的时候:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="7de3" class="mt lf it mf b gy mu mv l mw mx">const users = [{<br/>    'user': 'foo',<br/>    'active': false<br/>  },<br/>  {<br/>    'user': 'bar',<br/>    'active': true<br/>  },<br/>  {<br/>    'user': 'baz',<br/>    'active': false<br/>  }<br/>];</span><span id="a2dd" class="mt lf it mf b gy mz mv l mw mx">const result = partition(users, o =&gt; o.active);</span></pre><p id="d5c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到的<code class="fe mc md me mf b">result</code>是:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="faa2" class="mt lf it mf b gy mu mv l mw mx">[<br/>  [<br/>    {<br/>      "user": "foo",<br/>      "active": false<br/>    },<br/>    {<br/>      "user": "baz",<br/>      "active": false<br/>    }<br/>  ],<br/>  [<br/>    {<br/>      "user": "bar",<br/>      "active": true<br/>    }<br/>  ]<br/>]</span></pre><h1 id="de9c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="3d6a" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">通过使用<code class="fe mc md me mf b">for...of</code>循环将集合分组到一个对象中，并通过调用<code class="fe mc md me mf b">iteratee</code>函数填充键，可以实现<code class="fe mc md me mf b">keyBy</code>方法。然后，这些值由相应的键填充。</p><p id="b3ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mc md me mf b">map</code>方法可以由数组实例的<code class="fe mc md me mf b">map</code>方法实现。</p><p id="3eba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mc md me mf b">partition</code>也可以通过遍历所有对象，然后用数组条目调用<code class="fe mc md me mf b">predicate</code>来填充键，然后我们用相应的键将项目推入数组来实现。</p></div></div>    
</body>
</html>