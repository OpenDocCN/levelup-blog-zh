<html>
<head>
<title>Create Your Own Expression Parser</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建自己的表达式解析器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/create-your-own-expression-parser-d1f622077796?source=collection_archive---------0-----------------------#2020-02-01">https://levelup.gitconnected.com/create-your-own-expression-parser-d1f622077796?source=collection_archive---------0-----------------------#2020-02-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f8f7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">打造自己的编程语言的一步</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/88ebc4bc78d394c6c599c3ee0693d67d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bAgEUAvxvYWlByFD"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">维克多·加西亚在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="e720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有没有想过创造一种自己的编程语言？我做过几次。这是一项令人着迷的事业。我亲身体会到，当你坐下来开始追求这个想法时，你会感到不知所措。</p><p id="aaa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建编程语言的学科跨越了许多主题。以下是在给定编程语言的实现中可能会发现的一些组件:</p><ul class=""><li id="a07c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">解析器</strong>:将源代码转换成可操作的数据结构，称为<em class="me">解析树。</em></li><li id="0da3" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><strong class="lb iu">代码生成器</strong>:将解析树翻译成机器代码、字节码或其他可执行格式。</li><li id="51aa" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><strong class="lb iu">解释器</strong>:根据语言设计执行解析树或字节码图像。</li><li id="9109" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><strong class="lb iu">优化器</strong>:通过巧妙修改编译后的机器码，提高执行速度或减少代码大小。</li><li id="a1e3" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><strong class="lb iu">运行时</strong>:支持可执行文件的标准代码库，包括内置函数、内存分配器、垃圾收集器、线程管理器和其他关键子系统。</li></ul><p id="fa1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是一个简单的例子。还有许多其他可能的组件，多到无法在此解释。</p><p id="7de9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将重点讨论解析器。具体来说，我将描述一个解析器，它将一个数学表达式转换成一个叫做<em class="me">解析树</em>的数据结构。编程语言在更大的语义结构中使用表达式作为构建块。例如，在大多数语言中，每个条件“if”语句中都有一个表达式，如下所示:</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="0c95" class="mp mq it ml b gy mr ms l mt mu"><strong class="ml iu">if</strong> <strong class="ml iu">(</strong> <em class="me">expression</em> <strong class="ml iu">)</strong> <br/>    <em class="me">statement</em><br/><strong class="ml iu">else</strong><br/>    <em class="me">statement</em></span></pre><p id="b299" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我不会涉及解析编程语言的全部语法。我将只关注一种简单的方言表达。然而，一旦你理解了如何为表达式创建一个语法，以及如何从头开始为它编写一个解析器，处理一门编程语言的全部语法就只是一个努力和时间的问题了。理解一个表达式解析器会给你一个很好的基础，让你一路走到你自己的语言设计。</p><h2 id="5b3c" class="mp mq it bd mv mw mx dn my mz na dp nb li nc nd ne lm nf ng nh lq ni nj nk nl bi translated">目标</h2><p id="82fd" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">一旦你解析了一个表达式，你可以对它做很多不同的事情。您可以从中生成可执行代码。你可以画出它的图表。你可以做符号数学——例如，解方程或求导。</p><p id="9dbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我认为做一些不同的事情会很有趣。我将展示一个用JavaScript编写的基于浏览器的程序，它接受用户的输入，如下所示:</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="7057" class="mp mq it ml b gy mr ms l mt mu">cos(x^2+2*pi*theta)/sqrt(a^2+b^2)</span></pre><p id="0d94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后它会把这个文本转换成一个漂亮的公式，就像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/8148014f03d1a5eeda413f17c554e43f.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*MeMIG0DlQhQK_snPYWoDnQ.png"/></div></figure><h2 id="f994" class="mp mq it bd mv mw mx dn my mz na dp nb li nc nd ne lm nf ng nh lq ni nj nk nl bi translated">现场演示</h2><p id="3a78" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">您可以在另一个浏览器选项卡中打开解析器的<a class="ae ky" href="https://doncross.net/parser/" rel="noopener ugc nofollow" target="_blank">现场演示，并继续阅读本文的其余部分。</a></p><h2 id="e6c6" class="mp mq it bd mv mw mx dn my mz na dp nb li nc nd ne lm nf ng nh lq ni nj nk nl bi translated">步骤概述</h2><p id="dcfe" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">代码首先将用户的输入文本解析到一个解析树中。下面是上面显示的表达式的解析树的样子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/dc50f4f07b84305cad467118aa0d37bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0bPGm8C-W_HlRfyrKOo8Rg.png"/></div></div></figure><p id="2bf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后程序使用解析树创建一个<a class="ae ky" href="https://en.wikipedia.org/wiki/TeX" rel="noopener ugc nofollow" target="_blank"> TeX </a>格式的表达式:</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="0b05" class="mp mq it ml b gy mr ms l mt mu">\frac{ \cos \left( x^2 + 2\pi\theta \right) } {\sqrt{a^2 + b^2}}</span></pre><p id="fc44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，它使用<a class="ae ky" href="https://www.mathjax.org/" rel="noopener ugc nofollow" target="_blank"> MathJax </a> JavaScript库在浏览器中将TeX表达式呈现为优雅的排版数学。</p><h2 id="c35e" class="mp mq it bd mv mw mx dn my mz na dp nb li nc nd ne lm nf ng nh lq ni nj nk nl bi translated">限制</h2><p id="f4ee" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">为了保持代码有趣而简单，我将支持的数学语法限制为以下几项:</p><ul class=""><li id="ee9b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">拉丁字母变量:<code class="fe nt nu nv ml b">a</code>到<code class="fe nt nu nv ml b">z</code>和<code class="fe nt nu nv ml b">A</code>到<code class="fe nt nu nv ml b">Z</code>。</li><li id="34bd" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated">希腊字母变量，小写<code class="fe nt nu nv ml b">alpha</code>到<code class="fe nt nu nv ml b">omega</code>，大写<code class="fe nt nu nv ml b">Alpha</code>到<code class="fe nt nu nv ml b">Omega</code>。</li><li id="1a2b" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated">整数(<code class="fe nt nu nv ml b">724</code>)、浮点数(<code class="fe nt nu nv ml b">4.39254</code>)和科学记数法(<code class="fe nt nu nv ml b">6.27e+20</code>)形式的数值。</li><li id="cf8b" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated">二元运算符加法(<code class="fe nt nu nv ml b">+</code>)、减法(<code class="fe nt nu nv ml b">-</code>)、乘法(<code class="fe nt nu nv ml b">*</code>)、除法(<code class="fe nt nu nv ml b">/</code>)和求幂(<code class="fe nt nu nv ml b">^</code>)。</li><li id="1cc1" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated">一元前缀运算符<code class="fe nt nu nv ml b">+</code>(正)和<code class="fe nt nu nv ml b">-</code>(负)。请注意，根据上下文的不同，同一个符号可以表示不同的意思！</li><li id="303d" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated">余弦(<code class="fe nt nu nv ml b">cos</code>)、正弦(<code class="fe nt nu nv ml b">sin</code>)、绝对值(<code class="fe nt nu nv ml b">abs</code>)和平方根(<code class="fe nt nu nv ml b">sqrt</code>)函数。如果你愿意，以后添加更多的功能会很容易。</li><li id="cc5e" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated">使用括号<code class="fe nt nu nv ml b">()</code>来覆盖运算符优先级。</li></ul><h2 id="3e3d" class="mp mq it bd mv mw mx dn my mz na dp nb li nc nd ne lm nf ng nh lq ni nj nk nl bi translated">BNF语法</h2><p id="be39" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">不，“BNF语法”不是一个时髦的连锁餐厅的名字。<em class="me"> BNF </em>代表<a class="ae ky" href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form" rel="noopener ugc nofollow" target="_blank">Backus–Naur Form</a>，这种符号使你能够定义编程语言的语法。语言的语法是制作解析器的关键的第一步。这是你的路线图。它简明地定义了什么可以出现在一个有效的程序中。在为解析器编写代码时，您将不断地参考语法。</p><p id="a151" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们表达式解析器的BNF语法。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="9c42" class="mp mq it ml b gy mr ms l mt mu">expr ::= mulexpr { addop mulexpr }<br/>addop ::= "+" | "-"<br/>mulexpr ::= powexpr { mulop powexpr }<br/>mulop ::= "*" | "/"<br/>powexpr ::= "-" powexpr | "+" powexpr | atom [ "^" powexpr ]<br/>atom ::= ident [ "(" expr ")" ] | numeric | "(" expr ")"<br/>numeric ::= /[0-9]+(\.[0-9]*)?([eE][\+\-]?[0-9]+)?/<br/>ident ::= /[A-Za-z_][A-Za-z_0-9]*/</span></pre><p id="6f62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法是一系列的定义。每个定义都以类似于<code class="fe nt nu nv ml b">expr</code>的名称开头，后面跟有<code class="fe nt nu nv ml b">::=</code>符号，意思是“被定义为”每个<code class="fe nt nu nv ml b">::=</code>的右边是<code class="fe nt nu nv ml b">::=</code>左边命名的概念所允许的语法。</p><p id="2bc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从第一个定义开始，<code class="fe nt nu nv ml b">expr</code>，它代表任何要解析的数学表达式。当你看到</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="0730" class="mp mq it ml b gy mr ms l mt mu">mulexpr { addop mulexpr }</span></pre><p id="9db3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着一个表达式由一个<code class="fe nt nu nv ml b">mulexpr</code>和零个或多个<code class="fe nt nu nv ml b">addop mulexpr</code>对组成。换句话说，这些都是有效的<code class="fe nt nu nv ml b">expr</code>字符串:</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="bd4c" class="mp mq it ml b gy mr ms l mt mu">mulexpr<br/>mulexpr addop mulexpr<br/>mulexpr addop mulexpr addop mulexpr<br/>mulexpr addop mulexpr addop mulexpr addop mulexpr</span></pre><p id="8d20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，任何包含在<code class="fe nt nu nv ml b">{}</code>中的东西都意味着它可以出现任意次，包括零次。</p><p id="f0ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解<code class="fe nt nu nv ml b">mulexpr</code>和<code class="fe nt nu nv ml b">addop</code>的意思，继续阅读语法。你可以看到一个<code class="fe nt nu nv ml b">addop</code>既可以是字符串<code class="fe nt nu nv ml b">+</code>也可以是字符串<code class="fe nt nu nv ml b">-</code>。文字文本用双引号括起来，就像这样:<code class="fe nt nu nv ml b">"+"</code>。符号<code class="fe nt nu nv ml b">|</code>代表选择:解析器允许由竖线符号分隔的任何互斥选择。</p><p id="07c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法定义中的方括号<code class="fe nt nu nv ml b">[]</code>表示内容是可选的:它们要么不存在，要么出现一次。</p><p id="08eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，为了方便起见，我使用嵌入在<code class="fe nt nu nv ml b">//</code>中的JavaScript风格的正则表达式来定义符号<code class="fe nt nu nv ml b">numeric</code>和<code class="fe nt nu nv ml b">ident</code>。这是我自己的做事方式，尤其是当我用支持正则表达式的语言编写解析器时。</p><h2 id="2ff2" class="mp mq it bd mv mw mx dn my mz na dp nb li nc nd ne lm nf ng nh lq ni nj nk nl bi translated">标记器</h2><p id="37b4" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">一旦你理解了如何为你的语言编写BNF语法，下一步就是创建一个标记器，它可以识别你的语言中的<em class="me">标记</em>。记号是你的语言中文本的基本单位，就像不能分裂的原子。在我们的示例表达式语言中，标记是标点符号，如<code class="fe nt nu nv ml b">+</code>和<code class="fe nt nu nv ml b">-</code>，标识符，如<code class="fe nt nu nv ml b">theta</code>，以及数字文字，如<code class="fe nt nu nv ml b">47.259</code>。</p><p id="5c51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些人把记号赋予器叫做<em class="me">扫描器</em>、词汇分析器<em class="me">或<em class="me">词法分析器</em>。它们的意思都一样。关键是，您需要某种东西将输入中的字符序列预处理成代表您的语言的基本文本单元的块。构建解析树的代码部分将使用来自记号赋予器的一系列记号。记号赋予器和解析器之间的职责分离保持了代码的模块化和维护的灵活性。</em></p><p id="8402" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了组成令牌的字符块之外，还可以方便地将一些其他数据附加到每个令牌上:</p><ul class=""><li id="65b9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">令牌在输入</strong>中的位置。如果您正在从一个文件中解析源代码，记住每个标记的位置的一种自然方法是根据它在该文件中的行号和列号。如果解析器在某个特定的标记处检测到语法错误，那么它可以报告一条错误消息，其中包括行号和列号。这样做有助于用户找到问题所在。在本文的演示程序中，输入是单行文本。因此，每个标记都在输入字符串中存储自己的从零开始的索引。当出现错误时，演示程序会在文本输入框中突出显示有问题的令牌。</li><li id="afd9" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><strong class="lb iu">令牌的类型</strong>。在我的示例解析器中，所有标记都被分类为标识符、运算符或数字。确定标记的类型有助于解析器理解如何处理它看到的每个标记。</li></ul><p id="fd37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我如何实现代表输入中每个标记的<code class="fe nt nu nv ml b">Token</code>类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="95a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，<code class="fe nt nu nv ml b">Parser</code>类在其构造函数中完成了所有的标记化工作。要解析的文本被传递到构造函数中，结果产生的<code class="fe nt nu nv ml b">Token</code>对象列表存储在<code class="fe nt nu nv ml b">this.tokenList</code>中。记号赋予器逻辑使用检查数字文字或标识符的正则表达式(<code class="fe nt nu nv ml b">reToken</code>)来识别记号。如果两者都不匹配，它会将下一个非空白字符视为一个标记。因此，每个空白字符都被忽略，每个非空白字符都包含在某个标记中。</p><p id="3aea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">帮你自己一个忙。如果能像这样使用正则表达式，标记化就容易多了。否则，您必须进行一些繁琐的编码来从输入中提取标记。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">解析器构造函数对输入进行标记。</figcaption></figure><h2 id="9deb" class="mp mq it bd mv mw mx dn my mz na dp nb li nc nd ne lm nf ng nh lq ni nj nk nl bi translated">创建解析树</h2><p id="bd18" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在<code class="fe nt nu nv ml b">Parser</code>类中解析表达式的主要方法叫做<code class="fe nt nu nv ml b">Parse</code>。它调用一个助手方法<code class="fe nt nu nv ml b">ParseExpr</code>，该方法遵循BNF语法中的<code class="fe nt nu nv ml b">expr</code>规则。<code class="fe nt nu nv ml b">ParseExpr</code>实现了一个递归下降、贪婪的解析器，它试图在遵守语法的同时消耗尽可能多的标记。</p><p id="ff2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些情况下，无效的语法会导致<code class="fe nt nu nv ml b">ParseExpr</code>放弃并返回一个有效的解析树，用于它能够根据语法匹配的最左边部分的标记。这就是为什么<code class="fe nt nu nv ml b">Parse</code>需要确保所有的代币都被消费掉。如果<code class="fe nt nu nv ml b">ParseExpr</code>返回后还有剩余的令牌，说明有语法错误。在这种情况下，<code class="fe nt nu nv ml b">Parse</code>抛出一个异常。</p><p id="cb3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能会问，当有未解析的令牌时，为什么<code class="fe nt nu nv ml b">ParseExpr</code>本身不抛出异常。这是因为解析器是一个相互递归的函数系统。有些情况下<code class="fe nt nu nv ml b">ParseExpr</code>需要识别另一个表达式中的一个表达式。例如，考虑这个语法规则的粗体部分:</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="b2b7" class="mp mq it ml b gy mr ms l mt mu">atom ::= ident [ "(" expr ")" ] | numeric | <strong class="ml iu">"(" expr ")"</strong></span></pre><p id="aa21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个表达式可以出现在另一个表达式的括号内。一旦解析器看到一个<code class="fe nt nu nv ml b">(</code>，它就调用<code class="fe nt nu nv ml b">ParseExpr</code>来处理括号内的表达式。<code class="fe nt nu nv ml b">ParseExpr</code>一碰到<code class="fe nt nu nv ml b">)</code>就会停止，因为那个令牌不是<code class="fe nt nu nv ml b">addop</code>。右括号标记不是语法错误；这是必须的！所以这就是为什么你需要一个额外的函数<code class="fe nt nu nv ml b">Parse</code>在顶层被调用，以便在未处理的令牌剩余时失败。</p><h2 id="68fb" class="mp mq it bd mv mw mx dn my mz na dp nb li nc nd ne lm nf ng nh lq ni nj nk nl bi translated">例外是你的朋友</h2><p id="dae0" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">如果您用来编写解析器的编程语言中有异常，那么利用它们是个好主意。我用C写了一个解析器，少了很多乐趣。代码很快变得臃肿，检查其他函数的返回值，并在它们指出错误时退出。C中的一个替代方法是使用<code class="fe nt nu nv ml b">setjmp</code>和<code class="fe nt nu nv ml b">longjmp</code>，尽管由于各种原因这是<a class="ae ky" href="https://en.wikipedia.org/wiki/Setjmp.h#Caveats_and_limitations" rel="noopener ugc nofollow" target="_blank">危险的。抛出异常消除了大量庞大、重复的编码。在调用其他可能失败的函数后，解析器中的每个函数都可以轻松地继续运行。</a></p><p id="ec80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有人可能会反对异常是“昂贵的”。我的回答是，考虑只有当语法错误时才会发生异常。在这种情况下，一切都会停滞不前。用户必须找出如何解决问题，编辑代码，并再次启动解析器。因此，处理语法错误的额外毫秒开销可以忽略不计。一旦源代码有了正确的语法，就没有异常开销。可以说，在性能很重要的成功案例中，基于异常的代码更快，因为它不必一直检查返回值！</p><h2 id="1928" class="mp mq it bd mv mw mx dn my mz na dp nb li nc nd ne lm nf ng nh lq ni nj nk nl bi translated">根据语法编写您的解析器</h2><p id="63ab" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">让我们来看看<code class="fe nt nu nv ml b">ParseExpr</code>功能。我喜欢在每个规则解析函数中包含相关的语法规则作为注释。这样做可以在代码审查期间作为一个方便的参考。我邀请您花一点时间来验证语法注释与其下面的代码是否匹配。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="3675" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">助手函数<code class="fe nt nu nv ml b">NextTokenIs</code>验证至少还有一个令牌，并且下一个令牌在传递给它的字符串列表的选项中。如果是，它返回该令牌，并通过递增<code class="fe nt nu nv ml b">nextTokenIndex</code>前进到下一个令牌。否则，它什么也不做并返回<code class="fe nt nu nv ml b">null</code>。</p><p id="c55c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv ml b">ParseExpr</code>迭代查找由<code class="fe nt nu nv ml b">+</code>或<code class="fe nt nu nv ml b">-</code>操作符分隔的<code class="fe nt nu nv ml b">mulexpr</code>项，调用<code class="fe nt nu nv ml b">ParseMulExpr</code>处理语法中的<code class="fe nt nu nv ml b">mulexpr</code>规则。它发现的增加/减少的<code class="fe nt nu nv ml b">mulexpr</code>项越多，构建的树就越深。</p><p id="621c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其余的语法规则以类似的方式实现。</p><h2 id="1ae6" class="mp mq it bd mv mw mx dn my mz na dp nb li nc nd ne lm nf ng nh lq ni nj nk nl bi translated">表达式类</h2><p id="d494" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">解析函数都返回从基类<code class="fe nt nu nv ml b">Expression</code>派生的类的实例。<code class="fe nt nu nv ml b">Expression</code>类的一个实例充当解析树中的一个节点。每个节点在成员变量<code class="fe nt nu nv ml b">arglist</code>中包含零个或多个子表达式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="0b48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个表达式节点还持有在原始文本中表示它的标记。例如，在表达式<code class="fe nt nu nv ml b">a+b</code>中，解析树的根节点包含令牌<code class="fe nt nu nv ml b">+</code>，并且该根节点的子节点是作为叶节点的表达式<code class="fe nt nu nv ml b">a</code>和<code class="fe nt nu nv ml b">b</code>(没有子节点的节点)。</p><p id="68c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有从<code class="fe nt nu nv ml b">Expression</code>派生的类都有相同的内部数据结构。这个类集合的存在是为了覆盖成员函数，以便生成TeX输出，我们将在下面看到。</p><h2 id="c856" class="mp mq it bd mv mw mx dn my mz na dp nb li nc nd ne lm nf ng nh lq ni nj nk nl bi translated">使用解析树</h2><p id="fd28" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">从<code class="fe nt nu nv ml b">Expression</code>派生的每个类都包含一个名为<code class="fe nt nu nv ml b">PrettyMath</code>的成员函数。它的工作是生成一个包含TeX代码的字符串。例如，<code class="fe nt nu nv ml b">Expression_Function</code>类为函数<code class="fe nt nu nv ml b">abs</code>、<code class="fe nt nu nv ml b">sqrt</code>、<code class="fe nt nu nv ml b">sin</code>和<code class="fe nt nu nv ml b">cos</code>处理解析树中的节点。它知道TeX语法是不同的，取决于这些函数中的哪一个出现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="d2d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子表明，作为语言实现者，您可以自由地检查各种错误。我可以让扫描仪拒绝任何未知功能。相反，扫描器将任何字母数字序列识别为可能的变量或函数名。如果<code class="fe nt nu nv ml b">PrettyMath</code>函数不知道如何处理给定的符号，它的工作就是抱怨。在解析后检查未定义的符号更适合大多数语言，因为知道一个符号是否被定义通常是一个语义问题，而不是语法问题。</p><h2 id="8305" class="mp mq it bd mv mw mx dn my mz na dp nb li nc nd ne lm nf ng nh lq ni nj nk nl bi translated">运算符优先级</h2><p id="9939" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在表达式中，某些运算符必须在其他运算符之前计算。例如在<code class="fe nt nu nv ml b">a*b+c*d</code>中，常规是<code class="fe nt nu nv ml b">a</code>和<code class="fe nt nu nv ml b">b</code>相乘，然后是<code class="fe nt nu nv ml b">c</code>和<code class="fe nt nu nv ml b">d</code>，最后是乘积<code class="fe nt nu nv ml b">a*b</code>和<code class="fe nt nu nv ml b">c*d</code>相加。我们说乘法比加法有更高的优先权。</p><p id="31bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于规则的嵌套方式，优先级隐含在语法中。事实是</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="c262" class="mp mq it ml b gy mr ms l mt mu">expr ::= mulexpr { addop mulexpr }</span></pre><p id="368e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">被定义为</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="b45a" class="mp mq it ml b gy mr ms l mt mu">mulexpr ::= powexpr { mulop powexpr }</span></pre><p id="a9ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">告诉您这种语法将乘法置于比加法更高的优先级，因为语法分析器在更深层次的递归中处理乘法。</p><p id="84e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运算符优先级在生成TeX输出时也很重要，如下面的函数所示，该函数用于确定每个子表达式是否需要括号:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h2 id="f2ba" class="mp mq it bd mv mw mx dn my mz na dp nb li nc nd ne lm nf ng nh lq ni nj nk nl bi translated">结合性</h2><p id="3d78" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">除了运算符优先级，理解结合性也很重要。对于中缀二元操作符(出现在两个参数之间的操作符，如<code class="fe nt nu nv ml b">a+b</code>中的<code class="fe nt nu nv ml b">+</code>)，同一操作符的长链可以是左关联的，也可以是右关联的。</p><p id="4faf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">左关联运算符从左到右分组。这对于减法和除法来说是最重要的，因为它们的顺序很重要。例如:<code class="fe nt nu nv ml b">a-b-c-d</code>解释为<code class="fe nt nu nv ml b">((a-b)-c)-d</code>。这是通过使用大括号的“零个或多个”语法规则的简单迭代从语法中产生的，如</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="a968" class="mp mq it ml b gy mr ms l mt mu">expr ::= mulexpr { addop mulexpr }</span></pre><p id="f126" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为解析器从左到右处理迭代，所以构建了节点链，使得最左边的术语位于树的最深处。因此，它们在转换为TeX时首先被处理。</p><p id="417f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">右关联运算符从右向左分组。该语法中唯一的右关联二元运算符是取幂运算符<code class="fe nt nu nv ml b">^</code>。当解析器看到<code class="fe nt nu nv ml b">a^b^c^d</code>时，我们希望它将这个字符串解释为<code class="fe nt nu nv ml b">a^(b^(c^d))</code>。该语法使用递归而不是迭代来确保右边在结果解析树中更深。请参见以下规则的粗体部分。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="131f" class="mp mq it ml b gy mr ms l mt mu"><strong class="ml iu">powexpr</strong> ::= "-" powexpr | "+" powexpr | <strong class="ml iu">atom [ "^" powexpr ]</strong></span></pre><p id="dd9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，<code class="fe nt nu nv ml b">powexpr</code>定义中的一元前缀操作符<code class="fe nt nu nv ml b">+</code>和<code class="fe nt nu nv ml b">-</code>在其右侧使用递归来加强右结合性。</p><h2 id="fea8" class="mp mq it bd mv mw mx dn my mz na dp nb li nc nd ne lm nf ng nh lq ni nj nk nl bi translated">无法表达</h2><p id="3f21" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">正如我上面提到的，一旦您理解了如何为表达式创建解析器，您就可以扩充您的语法以包括函数定义、条件语句、循环语句和您自己的编程语言的其他部分。你可以研究像<a class="ae ky" href="https://www.lysator.liu.se/c/ANSI-C-grammar-y.html" rel="noopener ugc nofollow" target="_blank"> ANSI C </a>或<a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure" rel="noopener ugc nofollow" target="_blank"> C# </a>这样的现有编程语言的语法来寻找灵感。</p><p id="d12b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编程语言原型化的一个好方法是构建一个直接执行解析树的解释器。稍后，您可以尝试为给定的处理器发出字节代码甚至机器代码。<a class="ae ky" href="https://llvm.org/" rel="noopener ugc nofollow" target="_blank"> LLVM </a>编译器基础设施项目可能有助于以严肃的编程语言生成机器代码。</p><h2 id="f16c" class="mp mq it bd mv mw mx dn my mz na dp nb li nc nd ne lm nf ng nh lq ni nj nk nl bi translated">为什么要做这个疯狂的事情？</h2><p id="bdec" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">有些人会嘲笑并告诉你，世界最不需要的就是另一种编程语言。已经有数百种编程语言。任何新的尝试都应该有一个令人信服的理由来激励大量的人去尝试新的东西。如果你的目标是创造一种接管世界的超级流行的语言，那么这种可能性对你来说是不利的。</p><p id="eb97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，创造一种编程语言还有其他很好的理由。在现有的软件系统中，您可能特别需要一种简洁优雅的语言。许多文本编辑器、电子表格和计算机辅助设计系统都有内置的脚本语言，允许用户创建自己的宏或自定义应用程序。</p><p id="542d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在创建和使用我自己的编程语言后，我现在对编程有了更深层次的理解。编译器和解释器似乎不再神秘。我也对大量的工作和天赋留下了深刻的印象，这些工作和天赋进入了健壮且被广泛采用的语言，如C#、JavaScript和Python。</p><p id="b124" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论你的目标是什么，我相信你会发现创造一种你自己的编程语言是一种有益的、具有挑战性的、迷人的经历。</p><h2 id="ec3e" class="mp mq it bd mv mw mx dn my mz na dp nb li nc nd ne lm nf ng nh lq ni nj nk nl bi translated">读者练习</h2><p id="46df" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">GitHub上提供了演示解析器的完整源代码。如果您有兴趣自己学习更多，以下是一些您可以练习的想法，基于此源代码:</p><ul class=""><li id="8e05" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">将输入表达式转换为LISP语法。例如:以<code class="fe nt nu nv ml b">3*x+47/y</code>为输入，生成输出<code class="fe nt nu nv ml b">(+ (* 3 x) (/ 47 y))</code>。</li><li id="4df5" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated">修改语法、解析器和TeX生成器，以允许任何数量的逗号分隔参数的函数:<code class="fe nt nu nv ml b">max(a, b, c, ...)</code>。</li><li id="5f61" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated">给定一个解析树，编写创建另一个解析树的代码，该解析树是第一个解析树相对于变量<code class="fe nt nu nv ml b">x</code>的<a class="ae ky" href="https://en.wikipedia.org/wiki/Partial_derivative" rel="noopener ugc nofollow" target="_blank">偏导数</a>。将所有其他变量视为常数。例如:将<code class="fe nt nu nv ml b">(x^3+5)^2</code>转换为<code class="fe nt nu nv ml b">2*(x^3+5)*3*x^2</code>。</li><li id="9ca7" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated">添加表达式简化器，消除表达式中不必要的复杂性。例如，它可能会将<code class="fe nt nu nv ml b">1*x+0*y-7*x</code>转换为<code class="fe nt nu nv ml b">-6*x</code>。本练习将让您了解优化器在编译器中的作用。</li><li id="92c9" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated">制作一个2D函数绘图仪，绘制关于自变量<code class="fe nt nu nv ml b">x</code>的表达式。</li></ul><h2 id="f123" class="mp mq it bd mv mw mx dn my mz na dp nb li nc nd ne lm nf ng nh lq ni nj nk nl bi translated">参考</h2><ol class=""><li id="3371" class="lv lw it lb b lc nm lf nn li ny lm nz lq oa lu ob mb mc md bi translated">本文中使用的完整源代码可以从以下网址获得:<a class="ae ky" href="https://github.com/cosinekitty/parser" rel="noopener ugc nofollow" target="_blank">https://github.com/cosinekitty/parser</a></li><li id="b189" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ob mb mc md bi translated">这里有一个在你的浏览器中运行的解析器的现场演示:<a class="ae ky" href="https://doncross.net/parser/" rel="noopener ugc nofollow" target="_blank">https://doncross.net/parser/</a></li></ol></div></div>    
</body>
</html>