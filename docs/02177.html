<html>
<head>
<title>JavaScript Best Practice — New Constructs and Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—新的构造和函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practice-new-constructs-and-functions-f28585a11a58?source=collection_archive---------8-----------------------#2020-02-24">https://levelup.gitconnected.com/javascript-best-practice-new-constructs-and-functions-f28585a11a58?source=collection_archive---------8-----------------------#2020-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a1fc282dc7a8b21e5bc053f73e8b2e58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Oi8Zb6VTuzT7oaH3"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@pageeightstudio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">第八页工作室</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="11d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何其他编程语言一样，JavaScript有自己的最佳实践列表，使程序更容易阅读和维护。JavaScript也有很多棘手的地方。我们可以很容易地遵循一些最佳实践，使我们的JavaScript代码易于阅读。</p><p id="b075" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将着眼于用模块和块替换IIFE，用类方法和箭头函数替换传统函数，从<code class="fe le lf lg lh b">script</code>标签中移除语言属性，编写纯函数，以及避免一长串参数。</p><h1 id="4804" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">用模块和积木代替生活</h1><p id="7519" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">IIFE代表立即调用的函数表达式。这是一个构造，我们定义一个函数，然后立即调用它。</p><p id="3b33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是隔离数据以防止从外部访问它们的一种流行方法。此外，它将它们隐藏在全局范围之外。</p><p id="a051" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这在ES6之前很方便，因为没有模块标准，也没有更简单的方法来隐藏全局范围内的东西。</p><p id="b9a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，在ES6中，模块是作为一个新特性引入的。这意味着我们可以替换类似这样的东西:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6669" class="mt lj it lh b gy mu mv l mw mx">(function() {<br/>  let x = 1;<br/>})()</span></pre><p id="9f6c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">模块具有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f70c" class="mt lj it lh b gy mu mv l mw mx">let x = 1;</span></pre><p id="ac69" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们不希望它在模块外可用，我们就不要导出它。</p><p id="4924" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了模块，也不需要用IIFEs命名空间，因为我们可以把模块放在不同的文件夹中，把它们彼此分开。</p><p id="2aa7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有，ES6的另一个新特性是blocks。现在，我们可以使用花括号定义与外部范围隔离的代码块，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="a50d" class="mt lj it lh b gy mu mv l mw mx">{<br/>  let x = 1;<br/>  console.log(x);<br/>}</span></pre><p id="348a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了像<code class="fe le lf lg lh b">let</code>或<code class="fe le lf lg lh b">const</code>这样的块范围的关键字来声明变量或常量，我们就不必担心那些我们不希望在外面被访问的东西被访问了。</p><p id="fb8e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以定义任意的块，而不需要<code class="fe le lf lg lh b">if</code>语句、循环或生命。</p><h1 id="7908" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">用箭头函数和类方法代替传统函数</h1><p id="335e" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">同样，在ES6中，我们有构造函数的类语法。这样，我们就不需要<code class="fe le lf lg lh b">function</code>关键字来创建构造函数。</p><p id="c38b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这使得继承变得更加容易，并且没有关于<code class="fe le lf lg lh b">this</code>的混乱。</p><p id="c6f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们还有箭头函数，它不会改变函数内部的<code class="fe le lf lg lh b">this</code>的值。</p><p id="1a50" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe le lf lg lh b">function</code>关键字的唯一理由是生成器函数，它们是用<code class="fe le lf lg lh b">function*</code>关键字声明的。</p><p id="c35d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以通过编写以下代码来创建一个简单的生成器函数:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="54d0" class="mt lj it lh b gy mu mv l mw mx">const generator = function*() {<br/>  yield 1;<br/>  yield 2;<br/>}</span></pre><p id="aa9f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，生成器函数只能返回生成器，所以我们不能从它返回任何东西。</p><h1 id="3ac4" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">来自脚本标签的语言属性</h1><p id="e2a0" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">language</code>属性不再需要包含在<code class="fe le lf lg lh b">script</code>标签中。</p><p id="8417" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不要写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="5b2a" class="mt lj it lh b gy mu mv l mw mx">&lt;script src="<a class="ae kf" href="https://code.jquery.com/jquery-2.2.4.min.js" rel="noopener ugc nofollow" target="_blank">https://code.jquery.com/jquery-2.2.4.min.js</a>" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous" language='text/javascript'&gt;&lt;/script&gt;</span></pre><p id="e994" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9f04" class="mt lj it lh b gy mu mv l mw mx">&lt;script src="<a class="ae kf" href="https://code.jquery.com/jquery-2.2.4.min.js" rel="noopener ugc nofollow" target="_blank">https://code.jquery.com/jquery-2.2.4.min.js</a>" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"&gt;&lt;/script&gt;</span></pre><p id="cc8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为JavaScript是在浏览器中运行的语言。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/d81dea617d7fabbb2eb8448e47e54889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T2VyaShEfuWBQp3w"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">雄心勃勃的创意公司Rick Barrett在Unsplash上的照片</figcaption></figure><h1 id="cbf0" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">编写纯函数</h1><p id="7704" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们应该把函数写成纯函数。也就是说，如果我们传递相同的输入，函数总是给出相同的输出。</p><p id="6b8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很重要，因为它使测试变得容易。此外，我们知道它具体会做什么，减少出错的机会。</p><p id="1193" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">纯函数易于阅读和理解。流程确定且简单。因此，这是可以预见的。</p><p id="73e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">纯函数的示例如下:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c0b2" class="mt lj it lh b gy mu mv l mw mx">const add = (a, b) =&gt; a + b;</span></pre><p id="8f02" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们给它相同的输入，<code class="fe le lf lg lh b">add</code>函数总是给出相同的输出，因为它只是根据参数计算结果。不取决于别的。</p><p id="d564" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，它的逻辑流程是非常可预测的。</p><p id="de53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">非纯函数的一个例子是，即使给定相同的输入，也返回不同的输出。例如，如果我们有一个函数来获取今年之前<code class="fe le lf lg lh b">x</code>年的年份:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3663" class="mt lj it lh b gy mu mv l mw mx">const getYearBefore = (x) =&gt; new Date().getFullYear() - x;</span></pre><p id="7eb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这不是一个纯粹的函数，因为<code class="fe le lf lg lh b">new Date()</code>会根据当前日期而变化。因此，在给定相同输入的情况下，<code class="fe le lf lg lh b">getYearBefore</code>的结果取决于当前日期的年份。</p><p id="3d4a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了使它成为一个纯粹的函数，我们可以写成:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="0256" class="mt lj it lh b gy mu mv l mw mx">const getYearBefore = (date, x) =&gt; date.getFullYear() - x;</span></pre><p id="e131" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为日期现在被传递到函数中，所以假设我们有相同的输入，我们会得到相同的结果，因为函数中没有不确定的东西。它只是将参数组合在一起并返回结果。</p><p id="085f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们不必担心当前日期或日期实现如何变化。</p><p id="eda2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为<code class="fe le lf lg lh b">new Date()</code>结果的不可预测性，在我们把它变成一个纯函数之前，扩展函数是很困难的。</p><p id="46fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，更改<code class="fe le lf lg lh b">new Date()</code>可能会在更改前破坏程序的其他部分。现在我们不用担心这个了。</p><p id="3f55" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于不可预测性，跟踪和调试也更加困难。</p><h1 id="1915" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">避免长参数列表</h1><p id="acfe" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">使用ES6的析构语法，我们可以向函数传递大量的参数，而不必实际上分别传递它们。</p><p id="914c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不要写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="78d8" class="mt lj it lh b gy mu mv l mw mx">const add = (a, b, c, d, e) =&gt; a + b + c + d + e;</span></pre><p id="80bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它有5个参数。我们可以写道:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="8499" class="mt lj it lh b gy mu mv l mw mx">const add = ({<br/>  a,<br/>  b,<br/>  c,<br/>  d,<br/>  e<br/>}) =&gt; a + b + c + d + e;</span></pre><p id="6ab9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们只需要将一个对象传入函数，并在<code class="fe le lf lg lh b">add</code>函数中得到5个变量。</p><p id="fa78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以这样称呼<code class="fe le lf lg lh b">add</code>:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4c0d" class="mt lj it lh b gy mu mv l mw mx">const obj = {<br/>  a: 1,<br/>  b: 2,<br/>  c: 3,<br/>  d: 4,<br/>  e: 5<br/>}</span><span id="62b5" class="mt lj it lh b gy mz mv l mw mx">add(obj);</span></pre><p id="380e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也适用于嵌套对象。例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f6bc" class="mt lj it lh b gy mu mv l mw mx">const buildString = ({<br/>  foo: {<br/>    bar,<br/>    baz<br/>  }<br/>}) =&gt; `${bar} ${baz}`;</span></pre><p id="b3ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们可以这样称呼<code class="fe le lf lg lh b">buildString</code>:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="672c" class="mt lj it lh b gy mu mv l mw mx">const obj = {<br/>  foo: {<br/>    bar: 'bar',<br/>    baz: 'baz'<br/>  }<br/>};</span><span id="7360" class="mt lj it lh b gy mz mv l mw mx">buildString(obj);</span></pre><p id="8cad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了保持数据的私密性，我们可以用模块和块来代替IIFEs。现在我们不需要额外的代码来定义函数和调用它。</p><p id="c6ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，类语法是定义构造函数的更清晰的方法，尤其是当我们想要从其他构造函数继承时。<code class="fe le lf lg lh b">this</code>的价值也更加清晰。</p><p id="2f3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编写纯函数是一个很好的实践，因为它是可预测的，因为给定相同的输入，我们总是有相同的输出。因为它也更容易阅读和测试。</p><p id="a255" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了析构语法，我们可以减少对象中变量的大量参数。给定我们作为参数传入的属性的键名和位置，所有内容都被自动赋值。</p></div></div>    
</body>
</html>