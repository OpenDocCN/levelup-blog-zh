<html>
<head>
<title>Fully Automated NextJS Builds/Deployments (GitHub, AWS ECR, Fargate Service, ECS)- Part 3/4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">完全自动化的NextJS构建/部署(GitHub、AWS ECR、Fargate Service、ECS)——第3/4部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/fully-automated-nextjs-builds-deployments-github-aws-ecr-fargate-service-ecs-part-3-4-1b200b961502?source=collection_archive---------2-----------------------#2022-06-04">https://levelup.gitconnected.com/fully-automated-nextjs-builds-deployments-github-aws-ecr-fargate-service-ecs-part-3-4-1b200b961502?source=collection_archive---------2-----------------------#2022-06-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="00d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在最后一部分中，我们重点介绍了GitHub工作流以及GitHub和AWS之间使用OIDC的认证。我们现在已经准备好让我们的应用程序作为一个容器在AWS上运行。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/75c1b54c579616bfba1c70c794bc4c8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E-n05NuVjZyxClghkdbLOQ.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图片来源:stock.adobe.com</figcaption></figure><h1 id="d8fd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">教程的内容</h1><p id="2fca" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated"><a class="ae me" rel="noopener ugc nofollow" target="_blank" href="/fully-automated-nextjs-builds-deployments-github-aws-ecr-fargate-service-ecs-part-1-4-6216e58dcb89">第一部分— Docker图像/ ECR平台部署&amp;推送图像。</a></p><p id="573f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae me" rel="noopener ugc nofollow" target="_blank" href="/fully-automated-nextjs-builds-deployments-github-aws-ecr-fargate-service-ecs-part-2-4-36caa082676a">第二部分——完全的GitHub集成&amp; TF后端AWS/S3 </a></p><p id="6021" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第三部分—自动气象站上的Fargate平台部署</strong></p><p id="4541" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第四部分—优化和生产就绪</p><p id="b851" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如本教程的标题所揭示的，我们将使用Terraform进行自动化资源供应。</p><h1 id="a39e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将（行星）地球化（以适合人类居住）</h1><p id="afd5" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">因此，现在是时候仔细研究一下Terraform和基础设施即代码(IAC)的概念了。在第一部分，我已经写了:</p><blockquote class="mf mg mh"><p id="c42e" class="jn jo mi jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated">Terraform是一个“基础设施即代码”(简称IAC)工具。IAC允许您用代码定义、部署和更新基础设施。基本上，运行应用程序所需的一切都用代码表示。即服务器、数据库、网络、配置、日志、文档、测试、部署流程。IAC是在云环境中运行现代应用程序的基础。</p></blockquote><p id="d930" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">IAC工具有几种类别。最著名的是配置管理工具，如Chef、Puppet和Ansible。它们是为在现有服务器上安装和管理软件而设计的。另一种方法是服务器模板工具，如Docker、Packer和vagger。这个想法是创建一个包含所有相关内容的服务器映像，包括操作系统、软件、工具等的快照。服务器模板是不可变基础设施的关键组成部分:虽然配置管理和服务器模板工具定义了在每台服务器上运行的代码，但Terraform等服务器配置工具负责创建服务器本身。但不仅仅是服务器，还有数据库、缓存、负载平衡器、监控、配置、防火墙设置、路由、证书以及基础设施的几乎所有其他方面。</p><p id="7941" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本教程的第一部分，我们已经使用Terraform在AWS上创建了一个弹性容器注册中心(ECR)。</p><p id="abf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们已经创建了一个Docker文件，将我们的应用程序放在Docker映像上。然后，我们将此图像推送到ECR。</p><h1 id="e8af" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是法盖特？</h1><p id="039f" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">简言之，Fargate提供了在AWS上无服务器运行容器的能力。本质上，它将容器执行的任务从复杂基础设施的供应中分离出来。有了Fargate，我们有效地处于容器级别，不需要设置或配置基础设施堆栈中的任何东西，比如虚拟机实例。这部分由AWS有效管理。尽管如此，还是需要一些基本的基础设施。</p><p id="4bc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里找到更多信息:<a class="ae me" href="https://aws.amazon.com/fargate/" rel="noopener ugc nofollow" target="_blank">https://aws.amazon.com/fargate/</a></p><h1 id="8052" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我们开始吧</h1><p id="d1aa" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">首先，我们需要在Terraform文件夹下新建一个文件夹“deployment”。这个文件夹将包含所有必要的Terraform脚本，我们将需要推出我们的应用程序作为一个Fargate服务。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="2216" class="mr lc iq mn b gy ms mt l mu mv">$ cd terraform/<br/>$ mkdir deployment</span></pre><p id="00dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们还可以为后端配置创建另一个子文件夹。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="ef99" class="mr lc iq mn b gy ms mt l mu mv">$ cd deployment<br/>$ mkdir config</span></pre><p id="fadd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后是后端配置:</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="2570" class="mr lc iq mn b gy ms mt l mu mv">$ touch backend-config.tf</span></pre><p id="f50b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">配置如下所示。占位符必须替换为现有的S3时段名称。DynamoDB表也是如此。密钥可以自由分配，但必须是唯一的。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="b3fd" class="mr lc iq mn b gy ms mt l mu mv">bucket                      = "&lt;replace-with-your-s3-bucket"<br/>key                         = "&lt;replace-with-your-key.tfstate&gt;"<br/>region                      = "eu-central-1"<br/>encrypt                     = true<br/>dynamodb_table              = "&lt;replace-with-your-table&gt;"</span></pre><p id="3fc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这导致以下文件夹结构。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="8441" class="mr lc iq mn b gy ms mt l mu mv">.<br/>├── pages<br/>│   └── api<br/>├── public<br/>├── styles<br/>└── terraform<br/>    └── registry<br/>    └── deployment</span></pre><p id="5bbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，现在必须在/terraform/deployment下创建另一个名为provider.tf的文件，它定义了AWS Terraform提供程序。这个文件的内容现在看起来像这样。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="750e" class="mr lc iq mn b gy ms mt l mu mv">terraform {<br/>  required_version = "&gt;= 1.0.11"<br/>  backend "s3" { /* See the backend config in config/backend-config.tf */ }<br/><br/>  required_providers {<br/>		aws = {<br/>			source  = "hashicorp/aws"<br/>			version = "~&gt; 3.68.0"<br/>		}<br/>		random = {<br/>			source  = "hashicorp/random"<br/>			version = "~&gt; 3.1.0"<br/>		}<br/>  }<br/>}<br/><br/>provider "aws" {<br/>  region = var.aws_region<br/><br/>  default_tags {<br/>    tags = {<br/>      Application = var.service_name<br/>      Terraform  = true<br/>    }<br/>  }<br/>}</span></pre><h1 id="4e71" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">ECS集群</h1><p id="d539" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">在第一步中，我建议创建集群。如果它已经存在，那么这一步是不必要的。在本例中，我假设VPC和子网已经存在。对VPC和子网资源的数据的访问可以使用数据资源来完成。为此，我们创建一个名为data.tf的文件，其内容如下:</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="621b" class="mr lc iq mn b gy ms mt l mu mv">data "aws_caller_identity" "current" {<br/>}<br/><br/>data "aws_vpc" "main" {<br/>  tags = {<br/>	Name = &lt;name of your vpc&gt;<br/>  }<br/>}<br/><br/>data "aws_subnet_ids" "public" {<br/>  vpc_id = data.aws_vpc.main.id<br/>  tags = {<br/>	Type = "public"<br/>  }<br/>}<br/><br/>data "aws_subnet_ids" "private" {<br/>  vpc_id = data.aws_vpc.main.id<br/>  tags = {<br/>	Type = "private"<br/>  }<br/>}</span></pre><p id="90f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在可以在我们的资源中使用已经存在的VPC。让我们通过创建ECS的例子来更深入地了解一下这一点。</p><p id="b967" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们创建另一个名为ecs.tf的文件，其内容如下。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="be15" class="mr lc iq mn b gy ms mt l mu mv">resource "aws_ecs_cluster" "cluster" {<br/>  name = "${var.service_name}-ecs"<br/><br/>  setting {<br/>    name  = "containerInsights"<br/>    value = "enabled"<br/>  }<br/><br/>  configuration {<br/>    execute_command_configuration {<br/>      kms_key_id = aws_kms_key.current.arn<br/>      logging    = "OVERRIDE"<br/><br/>      log_configuration {<br/>        cloud_watch_encryption_enabled = true<br/>        cloud_watch_log_group_name = aws_cloudwatch_log_group.current.name<br/>      }<br/>    }<br/>  }<br/>}<br/><br/>resource "aws_kms_key" "current" {<br/>  description             = "${var.service_name}-ecs kms key"<br/>  deletion_window_in_days = 7<br/>}<br/><br/>resource "aws_cloudwatch_log_group" "current" {<br/>  name = "${var.service_name}-ecs"<br/>}</span></pre><p id="1ffd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们自动启用容器洞察，并为ECS集群创建一个CloudWatch日志组。</p><p id="12e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们创建以下两个文件来设置变量。</p><p id="dafe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi"> variables.tf </em></p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="0a84" class="mr lc iq mn b gy ms mt l mu mv">variable "service_name" {<br/>  type        = string<br/>  description = "the name of the service."<br/>}</span></pre><p id="051f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi"> vars.tfvars </em></p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="48e5" class="mr lc iq mn b gy ms mt l mu mv"># General<br/>service_name		= "cicd-tutorial"<br/>aws_region              = "eu-central-1"</span></pre><p id="8226" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们首先手动运行这一部分，看看是否创建了集群。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="a542" class="mr lc iq mn b gy ms mt l mu mv">$ terraform init -backend-config=config/backend-config.tf<br/>$ terraform plan -var-file=vars.tfvars</span></pre><p id="7b57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用命令“terraform plan ”,我们可以首先检查terraform想要做什么。</p><p id="5966" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出应该如下所示。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="59a9" class="mr lc iq mn b gy ms mt l mu mv">Terraform will perform the following actions:<br/><br/>  # aws_cloudwatch_log_group.current will be created<br/>  + resource "aws_cloudwatch_log_group" "current" {<br/>      + arn               = (known after apply)<br/>      + id                = (known after apply)<br/>      + name              = "cicd-tutorial-ecs"<br/>      + retention_in_days = 0<br/>      + tags_all          = {<br/>          + "Application" = "cicd-tutorial"<br/>          + "Terraform"   = "true"<br/>        }<br/>    }<br/><br/>  # aws_ecs_cluster.cluster will be created<br/>  + resource "aws_ecs_cluster" "cluster" {<br/>      + arn      = (known after apply)<br/>      + id       = (known after apply)<br/>      + name     = "cicd-tutorial-ecs"<br/>      + tags_all = {<br/>          + "Application" = "cicd-tutorial"<br/>          + "Terraform"   = "true"<br/>        }<br/><br/>      + configuration {<br/>          + execute_command_configuration {<br/>              + kms_key_id = (known after apply)<br/>              + logging    = "OVERRIDE"<br/><br/>              + log_configuration {<br/>                  + cloud_watch_encryption_enabled = true<br/>                  + cloud_watch_log_group_name     = "cicd-tutorial-ecs"<br/>                }<br/>            }<br/>        }<br/><br/>      + setting {<br/>          + name  = "containerInsights"<br/>          + value = "enabled"<br/>        }<br/>    }<br/><br/>  # aws_kms_key.current will be created<br/>  + resource "aws_kms_key" "current" {<br/>      + arn                                = (known after apply)<br/>      + bypass_policy_lockout_safety_check = false<br/>      + customer_master_key_spec           = "SYMMETRIC_DEFAULT"<br/>      + deletion_window_in_days            = 7<br/>      + description                        = "cicd-tutorial-ecs kms key"<br/>      + enable_key_rotation                = false<br/>      + id                                 = (known after apply)<br/>      + is_enabled                         = true<br/>      + key_id                             = (known after apply)<br/>      + key_usage                          = "ENCRYPT_DECRYPT"<br/>      + multi_region                       = (known after apply)<br/>      + policy                             = (known after apply)<br/>      + tags_all                           = {<br/>          + "Application" = "cicd-tutorial"<br/>          + "Terraform"   = "true"<br/>        }<br/>    }<br/><br/>Plan: 3 to add, 0 to change, 0 to destroy.</span></pre><p id="ab8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们可以调用命令‘terraform apply’在AWS上创建资源。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="d39c" class="mr lc iq mn b gy ms mt l mu mv">$ terraform apply -var-file=vars.tfvars<br/>...</span><span id="1dc0" class="mr lc iq mn b gy mw mt l mu mv">Releasing state lock. This may take a few moments...<br/><br/>Apply complete! Resources: 3 added, 0 changed, 0 destroyed.</span></pre><p id="5453" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">超级！奏效了。</p><p id="a569" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">新的ECS集群现在应该在AWS控制台中可见。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mx"><img src="../Images/fe5b7cf2fa141022d0c3badd882a4b1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eOiex0QNWBCcxo2aHOGKhQ.png"/></div></div></figure><p id="8410" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi">基本上</em>，现在唯一缺少的就是我们的服务。我们记得，在前面的部分中，我们已经创建了一个容器，并将其作为Docker映像存储在AWS ECR(容器注册表)中。我们已经在GitHub工作流程中完全自动化了这些步骤。</p><h1 id="3a22" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Fargate服务定义</h1><p id="7ae4" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我们的应用程序是一个需要通过互联网访问的web应用程序。因此，我们需要一个允许从外部访问的SecurityGroup。我们稍后将对此进行定义。首先，我们负责创建必要的Fargate资源。</p><p id="249e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们需要一个名为“service.tf”的文件，其内容如下:</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="dc9b" class="mr lc iq mn b gy ms mt l mu mv">resource "aws_ecs_task_definition" "service_task_fargate" {<br/>	network_mode = "awsvpc"<br/>	family = var.service_name<br/>	requires_compatibilities = ["FARGATE"]<br/>	cpu = 256<br/>	memory = 512<br/>	execution_role_arn =aws_iam_role.ecs_task_execution_role.arn<br/>  	task_role_arn = aws_iam_role.ecs_task_role.arn<br/>	container_definitions = jsonencode([{<br/>		name = var.service_name<br/>		image = "${var.account_id}.dkr.ecr.eu-central-1.amazonaws.com/${var.service_name}-ecr:${var.image_tag}"<br/>	  	logConfiguration = {<br/>		  logDriver = "awslogs",<br/>		  options   = {<br/>			awslogs-group = "/aws/ecs/${var.service_name}"<br/>			awslogs-region = "eu-central-1"<br/>			awslogs-create-group  = "true"<br/>			awslogs-stream-prefix = var.service_name<br/>		  }<br/>		}<br/>		portMappings = [{<br/>			protocol="tcp"<br/>			containerPort=3000<br/>			hostPort=3000<br/>		}]}<br/>	])<br/>}<br/><br/>resource "aws_ecs_service" "ecs_service" {<br/>  name = "${var.service_name}-service"<br/>  cluster = aws_ecs_cluster.cluster.id<br/>  task_definition = aws_ecs_task_definition.service_task_fargate.arn<br/>  desired_count = 1<br/>  launch_type = "FARGATE"<br/><br/>  network_configuration {<br/>	subnets = data.aws_subnet_ids.private.ids<br/>	assign_public_ip = false<br/>	security_groups = [aws_security_group.ecs_tasks.id]<br/>  }<br/>}<br/><br/>resource "aws_security_group" "ecs_tasks" {<br/>  name = "${var.service_name}-sg-ecs-tasks"<br/>  vpc_id = data.aws_vpc.main.id<br/>  ingress {<br/>	  protocol="tcp"<br/>	  from_port=3000<br/>	  to_port=3000<br/>	  cidr_blocks=["0.0.0.0/0"]<br/>  }<br/>  egress {<br/>	  protocol="-1"<br/>	  from_port=0<br/>	  to_port=0<br/>	  cidr_blocks=["0.0.0.0/0"]<br/>  }<br/>}</span></pre><p id="5885" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从Terraform脚本中可以看出，我们需要两个资源。一个是服务定义本身。这又引用了在同一个文件中定义的任务定义。其中，任务定义描述了使用哪个容器映像。</p><p id="4a15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还向任务添加了一个日志定义，它将日志写入CloudWatch。如果不想这样，可以省略这一节。</p><p id="ad86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于CloudWatch日志记录，我们还需要资源和权限。这些看起来像下面这样。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="ad79" class="mr lc iq mn b gy ms mt l mu mv">resource "aws_cloudwatch_log_group" "containers" {<br/>  name              = "/aws/ecs/${var.service_name}"<br/>  retention_in_days = 7<br/>  tags = {<br/>	Terraform = "true"<br/>	Name = "cloudwatch-group-${var.service_name}"<br/>  }<br/>}<br/><br/>data "aws_iam_policy_document" "cloudwatch_logs_policy" {<br/>  statement {<br/>	actions = [<br/>	  "logs:CreateLogStream",<br/>	  "logs:CreateLogGroup",<br/>	  "logs:DescribeLogStreams",<br/>	  "logs:PutLogEvents"<br/>	]<br/><br/>	resources = [<br/>	  "${aws_cloudwatch_log_group.containers.arn}:*"<br/>	]<br/>  }<br/>}<br/><br/>resource "aws_iam_policy" "cloudwatch_logs_policy" {<br/>  path   = "/ecs/task-role/"<br/>  policy = data.aws_iam_policy_document.cloudwatch_logs_policy.json<br/>}<br/><br/>resource "aws_iam_role_policy_attachment" "cloudwatch_logs_policy" {<br/>  role       = aws_iam_role.ecs_task_role.name<br/>  policy_arn = aws_iam_policy.cloudwatch_logs_policy.arn<br/>}</span></pre><p id="64f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在资源“aws_ecs_service”中也有网络配置。这里定义了Fargate容器放置在哪个子网中。</p><p id="0e19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在任务定义中，我们还可以看到两个属性execution_role_arn和task_role_arn，这意味着需要一个具有Fargate服务任务执行权限的IAM角色。</p><p id="69fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们创建一个名为“iam.tf”的文件，并定义这个角色。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="03e7" class="mr lc iq mn b gy ms mt l mu mv">resource "aws_iam_role" "ecs_task_execution_role" {<br/>  name = "${var.service_name}-ecs-task-execution-role"<br/>  assume_role_policy = jsonencode({<br/>	Version = "2012-10-17"<br/>	Statement = [<br/>	  {<br/>		Action = "sts:AssumeRole",<br/>		Effect = "Allow",<br/>		Sid = "",<br/>		Principal = {<br/>		  Service = "ecs-tasks.amazonaws.com"<br/>		}<br/>	  }]<br/>  })<br/>}<br/><br/>resource "aws_iam_role" "ecs_task_role" {<br/>  name = "${var.service_name}-ecsTaskRole"<br/><br/>  assume_role_policy = &lt;&lt;EOF<br/>{<br/> "Version": "2012-10-17",<br/> "Statement": [<br/>   {<br/>     "Action": "sts:AssumeRole",<br/>     "Principal": {<br/>       "Service": "ecs-tasks.amazonaws.com"<br/>     },<br/>     "Effect": "Allow",<br/>     "Sid": ""<br/>   }<br/> ]<br/>}<br/>EOF<br/>}<br/><br/>resource "aws_iam_role_policy_attachment" "ecs-task-execution-role-policy-attachment" {<br/>  role       = aws_iam_role.ecs_task_execution_role.name<br/>  policy_arn = "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy"<br/>}</span></pre><p id="d74d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们再看一下variables.tf文件。现在看起来应该如下所示:</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="5336" class="mr lc iq mn b gy ms mt l mu mv"># Common Variables<br/>variable "aws_region" {<br/>  type        = string<br/>}<br/><br/>variable "image_tag" {<br/>  type 			= string<br/>  description 	= "Given image tag for the current deployment."<br/>}<br/><br/>variable "vpc_name" {<br/>  type 	= string<br/>  description = "Name of the containing VPC. Required."<br/>}<br/><br/>variable "public_subnets" {<br/>  type    = list(string)<br/>  default = []<br/>}<br/><br/>variable "account_id" {<br/>  type = string<br/>  description = "ID of the AWS account"<br/>}<br/><br/>variable "service_name" {<br/>  type        = string<br/>  description = "the name of the service."<br/>}<br/><br/>variable "image_tag" {<br/>  type        = string<br/>}</span></pre><p id="b09b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">变量的值在vars.tfvars文件中定义如下:</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="79a4" class="mr lc iq mn b gy ms mt l mu mv"># General<br/>service_name		= "name-of-your-service"<br/>aws_region              = "eu-central-1"<br/>account_id 		= "id-of-your-account"<br/>image_tag               = var.image_tag<br/># VPC<br/>vpc_name                = "your-vpc-name"</span></pre><p id="eb68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，图像标签被设置为初始固定。在本教程的最后一集，我们生成了IMAGE_TAG，如下所示:</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="12b4" class="mr lc iq mn b gy ms mt l mu mv">export IMAGE_TAG=$(git rev-parse --short HEAD)</span></pre><p id="38e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">稍后，我们将确保从GitHub工作流中动态地提取这一点，以确保容器在每次部署时都被替换。目前，我们手动设置标签应该足够了。</p><p id="575e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是时候部署容器了。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="e2c4" class="mr lc iq mn b gy ms mt l mu mv">$ terraform apply -var-file=vars.tfvars<br/>Apply complete! Resources: 7 added, 0 changed, 0 destroyed.</span></pre><p id="7a6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！成功了。我们的Fargate服务在ECS上运行。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi my"><img src="../Images/aa3988d303baf9d4427d4d3f7bc9f46f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VSn99iy3cJ4FSCD1Zumm1Q.png"/></div></div></figure><p id="f450" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据我们的配置，我们将服务放在私有子网中。因此，它只能在这个网络上访问。例如，如果它是一个内部服务，只是为其他服务提供端点或者像SQS一样与内部资源通信，我们就完成了。但是这个教程是关于把一个带UI的NextJS应用放到互联网上。因此，我们仍然缺少一个指向互联网并提供公共访问的组件。为此，我们需要一个应用程序负载平衡器。我们现在将在TargetGroup的帮助下将它连接到Fargate，以便从外部访问。</p><p id="066c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们仍然需要以下地形资源。</p><p id="21c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们首先将以下部分添加到securitygroups.tf中。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="e4f1" class="mr lc iq mn b gy ms mt l mu mv">resource "aws_security_group" "alb" {<br/>  name = "${var.service_name}-sg-alb"<br/>  vpc_id = data.aws_vpc.main.id<br/>  ingress {<br/>	  protocol="tcp"<br/>	  from_port=80<br/>	  to_port=80<br/>	  cidr_blocks=["0.0.0.0/0"]<br/>  }<br/>  egress {<br/>	  protocol="-1"<br/>	  from_port=0<br/>	  to_port=0<br/>	  cidr_blocks=["0.0.0.0/0"]<br/>  }<br/>}</span></pre><p id="3c4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们允许通过HTTP访问负载平衡器。在教程的下一部分，我们将配置HTTPS。</p><p id="5e4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们需要一个名为lb.tf的文件，它包含所有需要的应用程序负载平衡器资源。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="0e03" class="mr lc iq mn b gy ms mt l mu mv">module "lb_security_group_public" {<br/>  source  = "terraform-aws-modules/security-group/aws"<br/>  version = "~&gt; 4.8.0"<br/><br/>  // the fargate ENI will use this security group<br/>  // it also needs access to the ALB to allow traffic<br/>  name            = "fargate-allow-alb-traffic"<br/>  use_name_prefix = false<br/>  description     = "Security group for example usage with ALB"<br/>  vpc_id          = data.aws_vpc.main.id<br/><br/>  ingress_cidr_blocks      = ["0.0.0.0/0"]<br/>  ingress_ipv6_cidr_blocks = ["::/0"]<br/>  ingress_rules            = ["http-80-tcp"]<br/>  egress_rules             = ["all-all"]<br/><br/>  tags                 = {<br/>    Terraform 	=  true<br/>  }<br/>}<br/><br/>resource "aws_lb" "current" {<br/>  name               = "${var.service_name}-lb"<br/>  load_balancer_type = "application"<br/>  security_groups    = [ aws_security_group.alb.id ]<br/>  subnets            = data.aws_subnet_ids.public.ids<br/>  enable_deletion_protection = false<br/>}<br/><br/>resource "aws_alb_listener" "http" {<br/>  load_balancer_arn = aws_lb.current.id<br/>  port              = 80<br/>  protocol          = "HTTP"<br/><br/>  default_action {<br/>    target_group_arn = aws_alb_target_group.target_group.id<br/>    type             = "forward"<br/>  }<br/>}<br/><br/>resource "aws_alb_target_group" "target_group" {<br/>  name = "${var.service_name}-tg"<br/>  port = 80<br/>  protocol = "HTTP"<br/>  vpc_id = data.aws_vpc.main.id<br/>  target_type = "ip"<br/>  health_check {<br/>    healthy_threshold   = "3"<br/>    interval            = "30"<br/>    protocol            = "HTTP"<br/>    matcher             = "200"<br/>    timeout             = "3"<br/>    path                = "/"<br/>    unhealthy_threshold = "2"<br/>  }<br/>}</span></pre><p id="2c50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，我们现在可以再次运行Terraform。因此，我们的应用运行在Fargate上，可以通过互联网上的负载平衡器访问。</p><p id="3b67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们可以在AWS控制台中将DNS名称复制并粘贴到浏览器中。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mz"><img src="../Images/ab4948a79d5c988bc768da515b2773ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ytmUkVlCSj0sPvHeTyfYWA.png"/></div></div></figure><p id="73df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，这离生产就绪还差得很远。在下一个也是最后一个部分，我们将处理这个问题，并添加一个SSL证书。</p><p id="a1f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完整的代码一如既往地可以在<a class="ae me" href="https://github.com/codewithrico/cicd-tutorial-part-3" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="c712" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi">编码快乐！</em></p></div></div>    
</body>
</html>