<html>
<head>
<title>Handling complex form state using React hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React钩子处理复杂的表单状态</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/handling-complex-form-state-using-react-hooks-76ee7bc937?source=collection_archive---------1-----------------------#2019-09-04">https://levelup.gitconnected.com/handling-complex-form-state-using-react-hooks-76ee7bc937?source=collection_archive---------1-----------------------#2019-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ca20" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用<strong class="ak"> this.setState() </strong>的替代方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/be373847515f7929d3fcc30a1b4ba142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kEPCQNY4dwVyaFuLEwJcNQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">每个人都上钩了吗？<a class="ae ky" href="https://cdn-media-1.freecodecamp.org/images/1*0MgGEfZfLO91g1Oa2h3ebQ@2x.png" rel="noopener ugc nofollow" target="_blank">图片积分—免费代码营</a></figcaption></figure><p id="5527" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> React hooks </strong>发布已经有一段时间了，大家都爱上了它们。我明白，因为我也是你们中的一员。钩子让我着迷！</p><p id="7757" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">钩子允许我们创建更小的、可组合的、可重用的、更易管理的React组件。</p><p id="c009" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能使用钩子的一个用例是使用<strong class="lb iu"> useState </strong>或<strong class="lb iu"> useReducer管理表单状态。</strong></p><p id="997a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们考虑一个场景，其中您必须管理具有多个表单输入的复杂表单状态，表单输入可以是几种不同的类型，如<em class="lv">文本、数字、日期</em>输入。表单状态甚至可以有嵌套信息，例如用户的地址信息，它有自己的子字段，如<code class="fe lw lx ly lz b">address.addressLine1</code>、<em class="lv">、<code class="fe lw lx ly lz b">address.addressLine2</code>等。</em></p><p id="6c13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也许您还必须根据当前状态更新表单状态，例如切换按钮。</p><p id="d3ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您对每个单独的表单字段使用<strong class="lb iu"> useState </strong>，那么您就有能力根据当前状态计算新的状态。</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="211f" class="me mf it lz b gy mg mh l mi mj">const [modalActive, updateModal] = useState(false)<br/>.<br/>.<br/>.<br/>// new state based on previous<br/>updateModal(prev =&gt; !prev)</span></pre><p id="cc56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果你有太多的单个表单字段，比如100+ ( <strong class="lb iu"> YESS！！我管理着100多个表单字段</strong>，这种方法并不友好。</p><p id="bd5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象...</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="cff7" class="me mf it lz b gy mg mh l mi mj">const [firstName, setFirstName] = useState('')<br/>const [middleName, setMiddleName] = useState('')<br/>const [lastName, setLastName] = useState('')<br/>.<br/>.<br/>.<br/>.</span></pre><p id="40d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编写单独的使用状态，然后为每个字段使用单独的更新函数是不实际的。我们的另一个选择是钩子。</p><p id="2c73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子。</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="e284" class="me mf it lz b gy mg mh l mi mj">const initialState = {<br/>  firstName: '',<br/>  lastName: ''<br/>};</span><span id="f7d1" class="me mf it lz b gy mk mh l mi mj">function reducer(state, action) {<br/>  switch (action.type) {<br/>    case 'firstName':<br/>      return { firstName: action.payload };<br/>    case 'lastName':<br/>      return { lastName: action.payload };<br/>    default:<br/>      throw new Error();<br/>  }<br/>}</span><span id="6e3f" class="me mf it lz b gy mk mh l mi mj">function Counter() {<br/>  const [state, dispatch] = useReducer(reducer, initialState);</span><span id="04b4" class="me mf it lz b gy mk mh l mi mj">return (<br/>    &lt;&gt;<br/>      &lt;input<br/>        type="text"<br/>        name="firstName"<br/>        placeholder="First Name"<br/>        onChange={(event) =&gt; {<br/>          dispatch({<br/>           type: 'firstName',<br/>           payload: event.target.value<br/>          })<br/>        }}<br/>        value={state.firstName} /&gt;<br/>      &lt;input<br/>        type="text"<br/>        name="lastName"<br/>        placeholder="Last Name"<br/>        onChange={(event) =&gt; {<br/>          dispatch({<br/>           type: 'lastName',<br/>           payload: event.target.value<br/>          })<br/>        }}<br/>        value={state.lastName} /&gt;<br/>   &lt;/&gt;<br/>  );<br/>}</span></pre><p id="456b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">呃，不太好。您不可能为reducer中的那些<strong class="lb iu"> n </strong>个表单字段编写每个用例。</p><p id="58f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是<strong class="lb iu"> useReducer </strong>中使用的reducer函数只是一个普通的函数，返回一个更新的状态对象。所以，我们可以做得更好。</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="91e0" class="me mf it lz b gy mg mh l mi mj">function reducer(state, action) {<br/>  // field name and value are retrieved from event.target<br/>  const { name, value } = action<br/>  <br/>  // merge the old and new state<br/>  return { ...state, [name]: value }<br/>}</span></pre><p id="86aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这看起来像一个更好和更清洁的减速器。</p><p id="1b7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这不允许我们在用回调函数调用更新函数时根据当前状态计算新的状态，就像我们可以用<code class="fe lw lx ly lz b">useState</code>做的那样:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="1e4e" class="me mf it lz b gy mg mh l mi mj">this.setState((prev) =&gt; ({ isActive: !prev }))</span><span id="c8f3" class="me mf it lz b gy mk mh l mi mj">// or</span><span id="373c" class="me mf it lz b gy mk mh l mi mj">const [modalActive, updateModal] = useState(false)<br/>.<br/>.<br/>.<br/>updateModal(prev =&gt; !prev)</span></pre><p id="861b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有，像<code class="fe lw lx ly lz b">address.addressLine1</code> <em class="lv">，</em> <code class="fe lw lx ly lz b">address.pinCode</code> <em class="lv">这样的嵌套状态更新呢？</em></p><p id="0baf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于使用不太理想的方法来管理复杂的表单状态，我们已经讨论了很多。让我向你展示解决方案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">哒哒！！</figcaption></figure><p id="2a32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是处理复杂表单场景的完整源代码。</p><p id="29d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我来稍微解释一下减速器(<code class="fe lw lx ly lz b"><strong class="lb iu">enhancedReducer</strong></code> <strong class="lb iu"> </strong> :P)的功能。</p><p id="da66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">reducer函数接收两个参数，第一个参数是更新前的当前状态。当您调用<code class="fe lw lx ly lz b">updateState</code><strong class="lb iu">/</strong>/<code class="fe lw lx ly lz b">dispatch</code><strong class="lb iu"/>函数更新减速器状态时，该参数自动提供。reducer函数的第二个参数是您调用<code class="fe lw lx ly lz b">updateState</code> <strong class="lb iu"> </strong>函数所用的值。它不必是典型的<em class="lv">重复动作对象</em>采取<code class="fe lw lx ly lz b">{ type: ‘something’, payload: ‘something’ }</code>的形式。它可以是任何东西，数字、字符串、对象甚至函数。</p><p id="7a75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们正在利用的。如果<code class="fe lw lx ly lz b">updateArg</code>是一个函数，我们用当前状态调用它来计算新的状态。我们从这个函数返回的任何对象都成为我们的新状态。</p><p id="4363" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe lw lx ly lz b">updateArg</code>是一个普通的旧Javascript对象，那么有两种情况。</p><p id="01ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1: <strong class="lb iu">对象没有</strong> <code class="fe lw lx ly lz b"><strong class="lb iu">_path</strong></code> <strong class="lb iu">和</strong> <code class="fe lw lx ly lz b"><strong class="lb iu">_value</strong></code> <strong class="lb iu">属性</strong>，因此是一个普通的更新对象，就像我们给<code class="fe lw lx ly lz b">this.setState</code>的一样。所以，你可以用一个新的对象调用<code class="fe lw lx ly lz b"><strong class="lb iu">updateState</strong></code> <strong class="lb iu"> </strong>，这个新的对象包含了你想要更新的状态片段，它会把它和旧的对象合并并返回新的状态。</p><p id="88c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2: <strong class="lb iu">对象有</strong> <code class="fe lw lx ly lz b"><strong class="lb iu">_path</strong></code> <strong class="lb iu">和</strong> <code class="fe lw lx ly lz b"><strong class="lb iu">_value</strong></code> <strong class="lb iu">属性——用有这两个属性的对象调用<code class="fe lw lx ly lz b">updateState</code>函数时有</strong>。我们将此视为特殊情况，其中<strong class="lb iu"> </strong> <code class="fe lw lx ly lz b"><strong class="lb iu">_path</strong></code>表示嵌套字段路径。以字符串形式，例如:<code class="fe lw lx ly lz b">'address.pinCode'</code>或代表路径的数组<code class="fe lw lx ly lz b">[‘address’, ‘pinCode’]</code>。</p><p id="577a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何利用这样的路径表示来更新对象中的嵌套字段呢？我们将使用<strong class="lb iu">洛达什</strong>的<code class="fe lw lx ly lz b"><strong class="lb iu">set</strong></code>方法。它接受两种路径形式作为update和object的有效输入。</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="f174" class="me mf it lz b gy mg mh l mi mj">set(objectToUpdate, path, newValue)</span><span id="51f7" class="me mf it lz b gy mk mh l mi mj">const state = {<br/>  name: {<br/>   first: '',<br/>   middle: '',<br/>   last: ''<br/>  }<br/>}</span><span id="dac3" class="me mf it lz b gy mk mh l mi mj">// and to update, for eg: first name.<br/>// both ways of path are correct.</span><span id="dd3e" class="me mf it lz b gy mk mh l mi mj">set(state, 'name.first', 'Aditya')<br/>set(state, ['name', 'first'], 'Aditya')</span></pre><p id="e6fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，<code class="fe lw lx ly lz b"><strong class="lb iu">set</strong></code>方法就地改变对象并且不返回新的副本，但是在React世界中，改变检测依赖于<strong class="lb iu">的不变性。</strong>需要在内存中具有新位置的数据的全新副本来触发渲染。</p><p id="dc54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了绕过这一点，我们使用<strong class="lb iu"> immer，</strong>以一种易于使用的形式帮助处理Javascript对象的不变性。</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="b6c9" class="me mf it lz b gy mg mh l mi mj">import produce from 'immer'</span><span id="47a7" class="me mf it lz b gy mk mh l mi mj">produce(state, draft =&gt; {<br/>  set(draft, _path, _value);<br/>});</span></pre><p id="0012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来自<strong class="lb iu"> </strong> immer <strong class="lb iu"> </strong>的<code class="fe lw lx ly lz b"><strong class="lb iu">produce</strong></code>函数把要处理的对象作为它的第一个参数，在我们的例子中它是当前状态，它的第二个参数是一个接收对象的<strong class="lb iu">草稿副本</strong>以进行变异的函数，无论你在草稿状态下在这个函数内部修改什么，都是在<strong class="lb iu">副本</strong>上完成的，而不是实际的输入对象<strong class="lb iu">状态</strong>就地完成的。然后，它自动返回带有<strong class="lb iu">更新的</strong>数据的<strong class="lb iu">新对象</strong>。</p><p id="4106" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们的增强型减速器:D</p><p id="3759" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅仅</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="276a" class="me mf it lz b gy mg mh l mi mj">yarn add lodash immer</span></pre><p id="4419" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽情享受吧。</p><p id="ad66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">gist中的示例可以进一步细化，在<strong class="lb iu"> </strong> <code class="fe lw lx ly lz b"><strong class="lb iu">enhancedReducer</strong></code>中处理更多的边缘情况，并且可以通过映射表单规范对象来缩短表单字段代码，以动态创建它，并减少代码重复和其他一些事情。</p><p id="696d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你们中的一些人可能会想，如果我们这么想复制<strong class="lb iu"> this.setState，</strong>那么为什么不让setState的第二个参数回调函数在状态更新后执行一些操作呢？嗯，这还不够明确！我们将一步一步地告诉代码，如何做某事。而不是简单的告诉它做什么。我会使用<code class="fe lw lx ly lz b"><strong class="lb iu">useEffect</strong></code>而不是回调函数，因为它是声明性的，而<em class="lv">会对变化做出反应。</em></p><p id="8dc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">声明式与命令式和函数式编程是另一个完整的话题，我将在以后分享。</p><p id="6b58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">资源:</p><div class="mn mo gp gr mp mq"><a href="https://lodash.com/docs/4.17.15#set" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">Lodash文档</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">编辑描述</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">lodash.com</p></div></div></div></a></div><div class="mn mo gp gr mp mq"><a href="https://github.com/immerjs/immer" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">immerjs/immer</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">通过简单地修改“年度突破”的当前树获胜者，创建下一个不可变的状态树…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">github.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ks mq"/></div></div></a></div></div></div>    
</body>
</html>