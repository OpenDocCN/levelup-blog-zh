<html>
<head>
<title>Writing a Network Scanner using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python编写网络扫描仪</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/writing-a-network-scanner-using-python-a41273baf1e2?source=collection_archive---------0-----------------------#2020-07-25">https://levelup.gitconnected.com/writing-a-network-scanner-using-python-a41273baf1e2?source=collection_archive---------0-----------------------#2020-07-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/49944d4abec1012628a9c4d3edcbb008.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aQFOoc5KSXa795XwvxT0DA.jpeg"/></div></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><blockquote class="ki kj kk"><p id="1555" class="kl km kn ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated"><strong class="ko iu">注意:</strong>下面的教程适用于任何Linux发行版，只要你有root权限，也就是说，你必须使用root用户执行这个脚本。</p></blockquote></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="0c38" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">什么是网络扫描仪？</h1><p id="60c9" class="pw-post-body-paragraph kl km it ko b kp mi kr ks kt mj kv kw mk ml kz la mm mn ld le mo mp lh li lj im bi translated">网络扫描仪是一种软件工具，用于扫描网络中连接的设备。它还用于诊断和调查目的，以查找和分类网络上运行的设备。该工具将一个IP地址或一系列IP地址作为输入，然后依次扫描每个IP地址，并确定该特定IP地址上是否存在设备。它扫描网络并返回IP地址及其相应的MAC地址(如果设备存在)。网络安全专业人士常用的一个流行工具是<a class="ae mq" href="https://nmap.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ko iu"> nmap </strong> </a>。</p><h1 id="bacf" class="lk ll it bd lm ln mr lp lq lr ms lt lu lv mt lx ly lz mu mb mc md mv mf mg mh bi translated">它是如何工作的？</h1><p id="a13a" class="pw-post-body-paragraph kl km it ko b kp mi kr ks kt mj kv kw mk ml kz la mm mn ld le mo mp lh li lj im bi translated">为了理解网络扫描器如何扫描整个网络，我们需要先了解什么是<strong class="ko iu"> ARP(地址解析协议)</strong>。</p><p id="997c" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">在网络中，大多数计算机使用<strong class="ko iu"> IP地址</strong>与其他设备通信，然而，实际上，通信是通过<strong class="ko iu"> MAC地址进行的。ARP用于找出IP地址已知的特定设备的MAC地址。</strong>例如，一台设备想要与网络上的另一台设备通信，然后发送设备使用ARP来查找它想要与之通信的设备的MAC地址。ARP包含两个步骤来查找MAC地址:</p><ol class=""><li id="3732" class="mw mx it ko b kp kq kt ku mk my mm mz mo na lj nb nc nd ne bi translated">发送设备发送一个<strong class="ko iu"> ARP请求</strong>，其中包含它想要与之通信的设备的IP地址。该请求被广播，这意味着网络中的每个设备都将接收到该请求，但是只有具有预期IP地址的设备才会响应。</li><li id="f15f" class="mw mx it ko b kp nf kt ng mk nh mm ni mo nj lj nb nc nd ne bi translated">接收到广播消息后，IP地址等于消息中IP地址的设备将向发送方发送一个包含其MAC地址的<strong class="ko iu"> ARP响应</strong>。</li></ol><p id="d49e" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">网络扫描器使用ARP请求和响应来扫描整个网络，以查找网络上的活动设备以及它们的MAC地址。</p><p id="28fb" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">如果仍然不清楚什么是ARP以及它是如何工作的，那么参考下面的图片。</p><figure class="nl nm nn no gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/9a75ad0254029632f09cd6ac509d326c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mda_kqjm4ONDM7jQnKZ7TQ.jpeg"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated"><strong class="bd lm">图一。ARP请求</strong></figcaption></figure><figure class="nl nm nn no gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/b2ee1275321d0ac95238d063ea86ebb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LTdIvgRjXx9XewTRZVeAyg.jpeg"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated"><strong class="bd lm">图二。ARP响应</strong></figcaption></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="8c90" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">现在我们知道了网络扫描器内部是如何工作的，让我们开始用Python编写它。</p><h1 id="86f2" class="lk ll it bd lm ln mr lp lq lr ms lt lu lv mt lx ly lz mu mb mc md mv mf mg mh bi translated">使用的模块:</h1><ol class=""><li id="145c" class="mw mx it ko b kp mi kt mj mk nu mm nv mo nw lj nb nc nd ne bi translated"><a class="ae mq" href="https://docs.python.org/3.4/library/subprocess.html" rel="noopener ugc nofollow" target="_blank"> argparse </a>:要了解这是什么，请阅读我的第一篇文章<a class="ae mq" href="https://medium.com/@dharmilch18/changing-mac-address-using-python-8a16fc4a3563#f878" rel="noopener">这里</a>。</li><li id="5ff9" class="mw mx it ko b kp nf kt ng mk nh mm ni mo nj lj nb nc nd ne bi translated"><a class="ae mq" href="https://scapy.readthedocs.io/en/latest/extending.html" rel="noopener ugc nofollow" target="_blank"> Scapy </a>:使用户能够发送、嗅探、解析和伪造网络数据包。这种能力允许开发能够探测、扫描或攻击网络的工具。它可以伪造或解码大量协议的数据包，通过网络发送它们，捕获它们，匹配请求和回复，等等。它可以轻松处理大多数任务，如扫描、跟踪路由、探测、单元测试、攻击或网络发现。</li></ol><blockquote class="ki kj kk"><p id="946a" class="kl km kn ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">好了，在开始用Python写代码之前，我要告诉你我的设置:我目前在Windows 10上，我有<a class="ae mq" href="https://www.virtualbox.org/" rel="noopener ugc nofollow" target="_blank"> Virtualbox </a>在两个虚拟机上运行(1。Kali Linux和2。Windows 10)。我将在我的Kali Linux机器上执行python脚本，并尝试扫描整个网络。注意:虚拟机在Virtualbox中被配置为使用<strong class="ko iu"> NatNetwork </strong>。要了解更多关于NatNetwork以及如何配置VM来使用它，请阅读<a class="ae mq" href="https://www.techrepublic.com/article/how-to-create-multiple-nat-networks-in-virtualbox/" rel="noopener ugc nofollow" target="_blank"> this </a>。</p></blockquote></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="40b2" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">编写网络扫描仪</h1><p id="1975" class="pw-post-body-paragraph kl km it ko b kp mi kr ks kt mj kv kw mk ml kz la mm mn ld le mo mp lh li lj im bi translated">因为我们知道需要什么模块，所以让我们开始编写脚本。</p><h2 id="68ec" class="nx ll it bd lm ny nz dn lq oa ob dp lu mk oc od ly mm oe of mc mo og oh mg oi bi translated"><strong class="ak">步骤1:导入上面讨论的模块。</strong></h2><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="oj ok l"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">导入模块</figcaption></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h2 id="7c76" class="nx ll it bd lm ny nz dn lq oa ob dp lu mk oc od ly mm oe of mc mo og oh mg oi bi translated"><strong class="ak">步骤2: </strong> <strong class="ak">实现允许用户传递命令行参数的功能。</strong></h2><p id="975c" class="pw-post-body-paragraph kl km it ko b kp mi kr ks kt mj kv kw mk ml kz la mm mn ld le mo mp lh li lj im bi translated">要将这个特性添加到我们的脚本中，我们需要利用我们在步骤1中导入的<strong class="ko iu"> argparse </strong>模块。</p><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="oj ok l"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">添加命令行参数功能</figcaption></figure><p id="db0e" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">要了解更多关于argparse如何工作，脚本的上述部分做什么以及它给脚本增加了什么功能，请阅读我以前的文章如何<a class="ae mq" href="https://medium.com/@dharmilch18/changing-mac-address-using-python-8a16fc4a3563#03c5" rel="noopener">更改设备的MAC地址</a>中的整个<strong class="ko iu">步骤2 </strong>。</p><p id="194a" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">以上代码允许用户为<strong class="ko iu">界面</strong>值提供如下输入:</p><pre class="nl nm nn no gt ol om on oo aw op bi"><span id="22a0" class="nx ll it om b gy oq or l os ot">root@kali:~# python3 network_scanner.py -t IP_Address/IP_Addresses</span></pre><p id="2ed6" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated"><strong class="ko iu">或</strong></p><pre class="nl nm nn no gt ol om on oo aw op bi"><span id="bcbc" class="nx ll it om b gy oq or l os ot">root@kali:~# python3 network_scanner.py --target IP_Address/IP_Addresses</span></pre><p id="4273" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated"><strong class="ko iu"> IP_Address </strong> =您要扫描的特定IP地址，以检查是否有设备正在使用该IP地址。</p><p id="dca1" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated"><strong class="ko iu"> IP地址</strong> =要扫描的IP地址范围。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h2 id="43df" class="nx ll it bd lm ny nz dn lq oa ob dp lu mk oc od ly mm oe of mc mo og oh mg oi bi translated"><strong class="ak">步骤3:编写扫描网络的函数</strong></h2><p id="4382" class="pw-post-body-paragraph kl km it ko b kp mi kr ks kt mj kv kw mk ml kz la mm mn ld le mo mp lh li lj im bi translated">在此功能中，我们必须执行以下操作才能扫描网络:</p><ul class=""><li id="29e2" class="mw mx it ko b kp kq kt ku mk my mm mz mo na lj ou nc nd ne bi translated">创建一个ARP请求。</li><li id="aa77" class="mw mx it ko b kp nf kt ng mk nh mm ni mo nj lj ou nc nd ne bi translated">创建一个以太网帧。</li><li id="319d" class="mw mx it ko b kp nf kt ng mk nh mm ni mo nj lj ou nc nd ne bi translated">将ARP请求放入以太网帧中。</li><li id="4302" class="mw mx it ko b kp nf kt ng mk nh mm ni mo nj lj ou nc nd ne bi translated">发送组合帧并接收响应。</li><li id="26c8" class="mw mx it ko b kp nf kt ng mk nh mm ni mo nj lj ou nc nd ne bi translated">解析响应并打印结果。</li></ul><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="oj ok l"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">扫描功能</figcaption></figure><p id="fe11" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">注意函数<strong class="ko iu"> scan </strong>将IP地址作为参数。现在，让我们逐行分解上面的代码。</p><pre class="nl nm nn no gt ol om on oo aw op bi"><span id="a6ab" class="nx ll it om b gy oq or l os ot">def scan(ip):<br/>    .....<br/>    .....</span><span id="2898" class="nx ll it om b gy ov or l os ot">scan('10.0.2.15')</span></pre><p id="090a" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">现在，我们要做的第一件事是创建一个ARP请求(见图1。)架用<strong class="ko iu">舟皿</strong>。</p><pre class="nl nm nn no gt ol om on oo aw op bi"><span id="d96d" class="nx ll it om b gy oq or l os ot">arp_req_frame = scapy.ARP(pdst = ip)</span></pre><p id="2e85" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">上面的代码行使用scapy的ARP类创建了一个ARP请求帧，目的IP地址<strong class="ko iu"> (pdst) </strong>作为函数的参数提供。目的IP地址被设置为传递给函数的IP地址，因为我们希望将ARP请求帧定向到我们想要的IP地址。例如，如果<strong class="ko iu"> ip = '10.0.2.15' </strong>,那么ARP请求只针对该ip地址。</p><p id="ce77" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">现在，问题是我怎么知道目的IP地址在ARP类中表示为<strong class="ko iu"> pdst </strong>？为此，scapy有一个内置函数，我们可以用它来查找一个类有哪些成员变量(变量)或字段。</p><pre class="nl nm nn no gt ol om on oo aw op bi"><span id="f5b1" class="nx ll it om b gy oq or l os ot">arp_req_frame = scapy.ARP(pdst = ip)<br/>print(scapy.ls(scapy.ARP()))</span><span id="c9d3" class="nx ll it om b gy ov or l os ot"><strong class="om iu">OUTPUT<br/></strong>root@kali:~/Desktop/Network Scanner# python3 network_scanner.py -t 10.0.2.1/24</span><span id="5661" class="nx ll it om b gy ov or l os ot">hwtype : XShortField        = 1               (1)<br/>ptype  : XShortEnumField    = 2048            (2048)<br/>hwlen  : FieldLenField      = None            (None)<br/>plen   : FieldLenField      = None            (None)<br/>op     : ShortEnumField     = 1               (1)<br/>hwsrc  : MultipleTypeField  = <strong class="om iu">'08:00:27:35:21:2e'</strong> (None)<br/>psrc   : MultipleTypeField  = <strong class="om iu">'10.0.2.9'</strong>      (None)<br/>hwdst  : MultipleTypeField  = '00:00:00:00:00:00' (None)<br/>pdst   : MultipleTypeField  = '0.0.0.0'       (None)</span></pre><blockquote class="ki kj kk"><p id="1da1" class="kl km kn ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated"><strong class="ko iu">注:10.0.2.1/24表示从10.0.2.1到10.0.2.254的IP地址</strong></p></blockquote><p id="291c" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated"><strong class="ko iu"> scapy.ls() </strong>函数返回特定类拥有的字段。它适用于scapy提供的每个类。我们只需将类名作为<strong class="ko iu"> scapy.class_name() </strong>传递给它。在上面的例子中，我们想知道ARP类拥有的字段或成员变量，所以我们使用了scapy.ls(scapy。ARP())。然后，这个函数给出了上面输出中所示的响应。该函数提供了字段的名称、该字段的简短描述以及每个字段的默认值。</p><p id="6c52" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">需要了解的主要领域有:</p><ul class=""><li id="d216" class="mw mx it ko b kp kq kt ku mk my mm mz mo na lj ou nc nd ne bi translated"><strong class="ko iu"> hwsrc </strong> =源MAC地址。</li><li id="c850" class="mw mx it ko b kp nf kt ng mk nh mm ni mo nj lj ou nc nd ne bi translated"><strong class="ko iu"> psrc </strong> =源IP地址。</li><li id="f1fa" class="mw mx it ko b kp nf kt ng mk nh mm ni mo nj lj ou nc nd ne bi translated">hwdst  =目的MAC地址。</li><li id="f18a" class="mw mx it ko b kp nf kt ng mk nh mm ni mo nj lj ou nc nd ne bi translated"><strong class="ko iu"> pdst </strong> =目的IP地址。</li></ul><p id="50e4" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">注:<strong class="ko iu"> hwsrc </strong>和<strong class="ko iu"> psrc </strong>将始终使用创建ARP请求包的机器的默认值。在我们的例子中，我的Kali机器的IP地址是<strong class="ko iu">‘10 . 0 . 2 . 9’</strong>，MAC地址是<strong class="ko iu">‘08:00:27:35:21:2e’</strong>，因此字段<strong class="ko iu"> psrc </strong>和<strong class="ko iu"> hwsrc </strong>中有这些值。另外，<strong class="ko iu"> hwdst </strong>和<strong class="ko iu"> pdst </strong>的默认值分别为<strong class="ko iu">' 00:00:00:00:00 '</strong>和<strong class="ko iu"> '0.0.0.0' </strong>。</p><p id="952a" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">因此，这就是我们在创建类的实例时，如何根据需要更改任何字段的值。此外，我们还可以通过scapy提供的另一个函数来查看ARP请求本身。</p><pre class="nl nm nn no gt ol om on oo aw op bi"><span id="e53c" class="nx ll it om b gy oq or l os ot">arp_req_frame = scapy.ARP(pdst = ip)<br/>print(arp_req_frame.summary())</span></pre><p id="2e02" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">执行上述代码后，我们得到以下输出。您可以看到它显示“<strong class="ko iu">谁拥有10.0.2.3表示10.0.2.9”，</strong>这意味着该数据包是一个请求数据包，它在询问每个人谁拥有IP地址为<strong class="ko iu"> 10.0.2.3 </strong>的数据包。第二部分，即<strong class="ko iu">说10.0.2.9 </strong>向所有接收设备提供关于ARP请求的源或发送者的信息，因此具有IP地址<strong class="ko iu"> 10.0.2.3 </strong>的接收设备将知道向谁发送ARP响应。您可以看到下面生成的输出与图1所示的相同。</p><pre class="nl nm nn no gt ol om on oo aw op bi"><span id="fb9f" class="nx ll it om b gy oq or l os ot">root@kali:~/Desktop/Network Scanner# python3 network_scanner.py -t 10.0.2.3</span><span id="b4f0" class="nx ll it om b gy ov or l os ot"><strong class="om iu">OUTPUT<br/></strong>root@kali:~/Desktop/Network Scanner# python3 network_scanner.py -t 10.0.2.3</span><span id="1ac2" class="nx ll it om b gy ov or l os ot"><strong class="om iu">ARP who has 10.0.2.3 says 10.0.2.9</strong></span></pre><p id="ba9a" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">scapy提供的另一个有用的功能是<strong class="ko iu"> show()。</strong></p><pre class="nl nm nn no gt ol om on oo aw op bi"><span id="e45a" class="nx ll it om b gy oq or l os ot">arp_req_frame = scapy.ARP(pdst = ip)<br/>print(arp_req_frame.show())</span></pre><p id="0e2c" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">执行之后，它生成以下输出。</p><pre class="nl nm nn no gt ol om on oo aw op bi"><span id="46f8" class="nx ll it om b gy oq or l os ot">root@kali:~/Desktop/Network Scanner# python3 network_scanner.py -t 10.0.2.3</span><span id="903f" class="nx ll it om b gy ov or l os ot"><strong class="om iu">OUTPUT</strong><br/>###[ ARP ]###<br/>hwtype    = 0x1<br/>ptype     = IPv4<br/>hwlen     = None<br/>plen      = None<br/>op        = who-has<br/>hwsrc     = 08:00:27:35:21:2e<br/>psrc      = 10.0.2.9<br/>hwdst     = 00:00:00:00:00:00<br/>pdst      = 10.0.2.3</span></pre><p id="23fb" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">上面的输出显示了ARP请求数据包的各个字段及其相应的值。请注意，<strong class="ko iu"> pdst(目的IP地址)</strong>的值为<strong class="ko iu"> 10.0.2.3 </strong>，因为在执行代码时，我们提供了一个命令行参数来确定要扫描哪个IP地址，然后将该IP地址设置为pdst。这是因为在创建ARP类的实例时，我们使用<strong class="ko iu"> scapy提供了目的设备的IP地址。ARP(pdst = ip) </strong>其中<strong class="ko iu"> ip </strong>是一个变量名，其值取自执行时传递的命令行参数。我们已经介绍了如何添加命令行参数功能，该功能在<strong class="ko iu">步骤2 </strong>中接受输入。</p><p id="ff11" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">在创建了ARP请求包之后，我们现在需要创建一个<a class="ae mq" href="https://en.wikipedia.org/wiki/Ethernet_frame" rel="noopener ugc nofollow" target="_blank">以太网</a>帧。以太网帧包含诸如源和目的地硬件(MAC)等字段。现在，由于网络内部的通信是使用MAC地址进行的，我们可以将目的硬件地址字段的值设置为我们想要通信的MAC地址。点击了解更多关于<a class="ae mq" href="https://www.geeksforgeeks.org/ethernet-frame-format/" rel="noopener ugc nofollow" target="_blank">以太网帧的信息。</a></p><p id="bb08" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">ARP请求应该被广播(发送到网络中的每个IP地址)。因此，为了广播ARP请求，我们将以太网字段的<strong class="ko iu">目的地址</strong>字段设置为<strong class="ko iu">‘ff:ff:ff:ff:ff:ff’</strong>，因为这是一个广播MAC地址。我们现在使用scapy来做这件事。</p><pre class="nl nm nn no gt ol om on oo aw op bi"><span id="905a" class="nx ll it om b gy oq or l os ot">broadcast_ether_frame = scapy.Ether(dst = "ff:ff:ff:ff:ff:ff")</span></pre><p id="df13" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">上面的代码行创建了一个以太网帧，其中<strong class="ko iu"> dst(目的地址)</strong>被设置为<strong class="ko iu">‘ff:ff:ff:ff:ff:ff:ff’。</strong>注意，我们可以在以太网类上使用scapy.ls()和show()函数。可以使用scapy.ls()函数查看以太网帧的字段，类似于我们在ARP类中的操作。show()函数也可以像我们在ARP类中一样使用。这两个函数的输出如下所示。</p><pre class="nl nm nn no gt ol om on oo aw op bi"><span id="9980" class="nx ll it om b gy oq or l os ot">print(scapy.ls(scapy.Ether()))</span><span id="0104" class="nx ll it om b gy ov or l os ot"><strong class="om iu">OUTPUT<br/></strong>dst  : DestMACField     = 'ff:ff:ff:ff:ff:ff' (None)<br/>src  : SourceMACField   = '08:00:27:35:21:2e' (None)<br/>type : XShortEnumField  = 36864           (36864)</span><span id="4877" class="nx ll it om b gy ov or l os ot">--------------------------------------------------------------------</span><span id="4552" class="nx ll it om b gy ov or l os ot">print(broadcast_ether_frame.show())</span><span id="aceb" class="nx ll it om b gy ov or l os ot"><strong class="om iu">OUTPUT<br/></strong>###[ Ethernet ]###<br/>dst       = ff:ff:ff:ff:ff:ff<br/>src       = 08:00:27:35:21:2e<br/>type      = 0x9000</span></pre><p id="a1dd" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">下一步是合并ARP请求和以太网帧。我们使用scapy来实现这一点，因为它提供了一种非常方便的方式来组合框架。我们通过下面的代码行来实现。</p><pre class="nl nm nn no gt ol om on oo aw op bi"><span id="4eab" class="nx ll it om b gy oq or l os ot">broadcast_ether_arp_req_frame = broadcast_ether_frame/arp_req_frame</span></pre><p id="4456" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">上面的代码通过使用<strong class="ko iu"> '/' </strong>符号组合ARP请求和以太网帧来创建一个新帧。这是因为scapy允许我们使用它来组合帧。</p><p id="b450" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">现在，如果我们调用<strong class="ko iu"> show() </strong>函数，我们可以看到最终的组合帧由以太网和ARP请求组成。</p><pre class="nl nm nn no gt ol om on oo aw op bi"><span id="7921" class="nx ll it om b gy oq or l os ot">root@kali:~/Desktop/Network Scanner# python3 network_scanner.py -t 10.0.2.3</span><span id="d43b" class="nx ll it om b gy ov or l os ot"><strong class="om iu">OUTPUT<br/></strong>###[ Ethernet ]###<br/>dst       = ff:ff:ff:ff:ff:ff<br/>src       = 08:00:27:35:21:2e<br/>type      = ARP</span><span id="b754" class="nx ll it om b gy ov or l os ot">###[ ARP ]###<br/>hwtype    = 0x1<br/>ptype     = IPv4<br/>hwlen     = None<br/>plen      = None<br/>op        = who-has<br/>hwsrc     = 08:00:27:35:21:2e<br/>psrc      = 10.0.2.9<br/>hwdst     = 00:00:00:00:00:00<br/>pdst      = 10.0.2.3</span></pre><p id="fcd6" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">我们可以看到，以太网帧的类型字段现在将ARP作为其类型。此外，帧的ARP部分通过<strong class="ko iu"> op </strong>字段的值被识别为<strong class="ko iu"> ARP请求</strong>。如果<strong class="ko iu"> op = who-has </strong>则意味着它是一个<strong class="ko iu"> ARP请求</strong>，如果<strong class="ko iu"> op = is-at </strong>则它是<strong class="ko iu"> ARP响应</strong>。</p><p id="7337" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">现在剩下的唯一事情就是发送组合帧并接收响应。为了发送请求和接收响应，我们将使用scapy提供的函数，该函数不仅发送请求，还返回响应。</p><p id="ceb7" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">该函数将捕获的响应作为python元组返回，其中元组的第一个元素包含设备响应的<strong class="ko iu">已回答的</strong>响应，第二个元素包含<strong class="ko iu">未回答的</strong>响应。未回答列表中的响应意味着没有使用这些IP地址的设备。</p><p id="a6b4" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">scapy提供的完成上述任务的函数称为<strong class="ko iu"> scapy.srp()。</strong>该函数将实际要传输的帧作为参数。你可以看到我们已经通过<strong class="ko iu">broadcast _ ether _ ARP _ req _ frame(我们最终的组合帧)</strong>传递到下面的函数。它还需要一个<strong class="ko iu">超时</strong>输入，告知scapy在进一步移动之前应该等待多长时间来接收响应。从下面的例子来看，这意味着<strong class="ko iu"> timeout = 1 </strong>意味着scapy将等待1秒钟的响应，如果没有收到响应，它将进一步将数据包发送到下一个IP地址。参数<strong class="ko iu"> verbose = False </strong>并不重要，它只是阻止scapy在屏幕上打印自己的消息。</p><pre class="nl nm nn no gt ol om on oo aw op bi"><span id="d4c6" class="nx ll it om b gy oq or l os ot">answered_list= scapy.srp(broadcast_ether_arp_req_frame, timeout = 1, verbose = False)<br/>    print('Total Number of Responses -&gt;', len(answered_list))<br/>    print('\n-----------Answered Responses---------')<br/>    print('Number of Answered Responsed -&gt;', len(answered_list[0]))<br/>    print('\n')<br/>    for i in range(0,len(answered_list[0])):<br/>        print(answered_list[0][i])<br/>        print('\n')<br/>    print('\n-----------UnAnswered Responses---------')<br/>    print('Number of UnAnswered Responsed -&gt;', len(answered_list[1]))<br/>    print('\n')<br/>    for i in range(0,len(answered_list[1])):<br/>        print(answered_list[1][i])<br/>        print('\n')</span></pre><p id="60bd" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">上面的代码显示了应答(响应)响应的总数和实际响应本身。它还显示未回答(未回应)的回应总数和实际回应数。</p><p id="5049" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">注意:这段代码不会在最终的脚本中使用，只是为了理解<strong class="ko iu"> scapy.srp() </strong>函数返回的输出。上述代码生成以下输出。</p><figure class="nl nm nn no gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ow"><img src="../Images/a2a733b26886bb00e7dc26e70761b15a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ok3M83G4Ujj79XkY87hoqQ.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">scapy.srp()函数输出</figcaption></figure><p id="0eff" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">从上图中，我们可以看到收到的回复总数是<strong class="ko iu">两个。</strong>这是因为元组由两个元素组成<strong class="ko iu">已回答</strong>和<strong class="ko iu">未回答</strong>。此外，我们可以看到，应答的总响应数为<strong class="ko iu">三个</strong>，这意味着只有<strong class="ko iu">三个</strong>设备响应了ARP响应。在这下面，我们还可以看到实际的反应本身。在此之后，我们看到未响应的响应总数为<strong class="ko iu"> 253 </strong>，这意味着<strong class="ko iu"> 253 </strong>设备没有响应。我们还可以看到scapy为未回答的响应记录的一些响应。</p><p id="9120" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">显示上述输出的主要目的是让您了解我们只需要已回答的响应，而不是未回答的。因此，我们可以使用下面的代码行只访问已回答的响应。</p><pre class="nl nm nn no gt ol om on oo aw op bi"><span id="6fc4" class="nx ll it om b gy oq or l os ot">answered_list = scapy.srp(broadcast_ether_arp_req_frame, timeout = 1, verbose = False)[0]</span></pre><p id="e1ab" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">由于<strong class="ko iu"> answered_list </strong>是一个元组，我们可以通过在方括号中提供索引来提取单个元素。上面的代码将只存储已回答的响应。</p><p id="47f4" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">现在，剩下的就是从每个应答的响应中提取IP地址和MAC地址。为此，我们将在列表中使用Python字典。</p><pre class="nl nm nn no gt ol om on oo aw op bi"><span id="1efd" class="nx ll it om b gy oq or l os ot">result = []<br/>    for i in range(0,len(answered_list)):<br/>        client_dict = {"ip" : answered_list[i][1].psrc, "mac" : answered_list[i][1].hwsrc}<br/>        result.append(client_dict)</span><span id="6edf" class="nx ll it om b gy ov or l os ot">print(result)</span></pre><p id="ad45" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">上面的代码创建一个名为<strong class="ko iu"> result </strong>的空列表，然后为每个响应创建一个名为<strong class="ko iu"> client_dict </strong>的字典，然后将其附加到<strong class="ko iu"> result </strong>列表中。<strong class="ko iu"> client_dict </strong>有两个键<strong class="ko iu">‘ip’</strong>和<strong class="ko iu">‘mac’</strong>，分别存储IP地址和MAC地址。对于我们的情况，上述代码的输出将是:</p><pre class="nl nm nn no gt ol om on oo aw op bi"><span id="24c0" class="nx ll it om b gy oq or l os ot">root@kali:~/Desktop/Network Scanner# python3 network_scanner.py -t 10.0.2.1/24</span><span id="0ca3" class="nx ll it om b gy ov or l os ot">[{'ip': '10.0.2.1', 'mac': '52:54:00:12:35:00'}, {'ip': '10.0.2.2', 'mac': '52:54:00:12:35:00'}, {'ip': '10.0.2.3', 'mac': '08:00:27:22:d8:10'}]</span></pre><p id="710a" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated"><strong class="ko iu"> scan() </strong>函数的下一步是返回<strong class="ko iu">结果</strong>列表。我们将在另一个函数中使用结果列表，以某种格式打印结果。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h2 id="5909" class="nx ll it bd lm ny nz dn lq oa ob dp lu mk oc od ly mm oe of mc mo og oh mg oi bi translated">第四步:编写函数以某种格式打印结果。</h2><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="oj ok l"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">以某种格式打印的显示功能</figcaption></figure><p id="9b1d" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">上面的display()函数将结果列表作为输入，并以某种格式显示结果。它产生如下所示的输出。</p><pre class="nl nm nn no gt ol om on oo aw op bi"><span id="5550" class="nx ll it om b gy oq or l os ot">root@kali:~/Desktop/Network Scanner# python3 network_scanner.py -t 10.0.2.1/24<br/>-----------------------------------<br/>IP Address     MAC Address<br/>-----------------------------------<br/>10.0.2.1       52:54:00:12:35:00<br/>10.0.2.2       52:54:00:12:35:00<br/>10.0.2.3       08:00:27:22:d8:10</span></pre><p id="20b2" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">这是脚本完成的地方，我们已经成功地使用Python创建了一个网络扫描器。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h2 id="e72d" class="nx ll it bd lm ny nz dn lq oa ob dp lu mk oc od ly mm oe of mc mo og oh mg oi bi translated">工作示例</h2><p id="4a53" class="pw-post-body-paragraph kl km it ko b kp mi kr ks kt mj kv kw mk ml kz la mm mn ld le mo mp lh li lj im bi translated">我使用的是带有两个虚拟机(Kali Linux和Windows 10)的Virtualbox设置。我将向你展示我们创造的扫描仪工作得非常好。我将在Kali Linux中执行脚本，还将启动Windows 10 VM。期望输出还应该包含Windows 10虚拟机的IP地址和MAC地址。</p><figure class="nl nm nn no gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ox"><img src="../Images/65a26d593cf983aab566d253cb024fa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s7JrqxS0JWCTefI0tyH__w.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">Windows 10虚拟机</figcaption></figure><p id="4fa6" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">从上图中，我们可以注意到Windows 10虚拟机的两点:</p><ol class=""><li id="a3b2" class="mw mx it ko b kp kq kt ku mk my mm mz mo na lj nb nc nd ne bi translated">IP地址= 10.0.2.15</li><li id="333b" class="mw mx it ko b kp nf kt ng mk nh mm ni mo nj lj nb nc nd ne bi translated">MAC地址= 08-00-27-e6-e5-59(在描述字段下方的图像中表示为物理地址)</li></ol><p id="f1dc" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">现在，Kali Linux机器上的脚本生成的输出。</p><figure class="nl nm nn no gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oy"><img src="../Images/797186eae18053c34e225869499f8715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JI3MNlVOdmBJd9ki-crvpw.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">Kali Linux虚拟机上的脚本输出</figcaption></figure><p id="cbbd" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">从上图中，我们可以看到我们创建的网络扫描器脚本扫描了整个网络，包括同一个网络中的Windows 10虚拟机。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="f244" class="pw-post-body-paragraph kl km it ko b kp kq kr ks kt ku kv kw mk ky kz la mm lc ld le mo lg lh li lj im bi translated">感谢您的阅读。完整的代码可以在我的<a class="ae mq" href="https://github.com/dharmil18/Network-Scanner" rel="noopener ugc nofollow" target="_blank"> Github库</a>中找到。</p></div></div>    
</body>
</html>