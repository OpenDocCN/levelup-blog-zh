<html>
<head>
<title>Deploying a Node app to AWS Elastic Beanstalk using GitHub Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GitHub操作将节点应用程序部署到AWS Elastic Beanstalk</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/deploying-a-node-app-to-aws-elastic-beanstalk-using-github-actions-d64c7e486701?source=collection_archive---------6-----------------------#2021-02-22">https://levelup.gitconnected.com/deploying-a-node-app-to-aws-elastic-beanstalk-using-github-actions-d64c7e486701?source=collection_archive---------6-----------------------#2021-02-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/aa84117e463ceec239f4cb938c113a85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NGRF-CcsFOic1ga1tWBglA.png"/></div></div></figure><div class=""/><p id="2967" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着时间的推移，新闻技术和工具的出现为我们的日常问题带来了更好更快的解决方案。在持续集成和持续部署(CI/CD)的世界中，大多数解决方案都试图尽可能地自动化一个或多个过程。这就是本文的重点<strong class="ka jc"> GitHub动作</strong>的情况。</p><blockquote class="kw kx ky"><p id="eaa3" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">GitHub Actions是GitHub提供的工具，用于自动化CI/CD软件工作流，支持在GitHub上构建、测试和部署您的托管代码。这些工作流由GitHub事件触发，如推送、问题创建或新发布，这允许基于项目特征的不同工作流的个性化。</p></blockquote><p id="7429" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然Actions自动化了整个部署管道，但它易于维护且灵活，因为它与我们在linux终端中看到的命令一起工作，非常像Gitlab。此外，它为任何操作系统上的许多语言提供了大量的模板选择，并与许多云服务集成，以帮助构建您的工作流，这意味着GitHub上托管的任何项目都可以有自己的工作流！</p><p id="339c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基于这种想法，本文将展示一个GitHub动作的示例，该示例针对一个要在AWS弹性Beanstalk环境上部署的带有Express应用程序的节点。</p><h1 id="30dd" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">弹性豆茎环境</h1><p id="4062" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">在理解和展示工作流本身之前，我们必须准备好一个操作环境，并创建一个bucket来接收来自GitHub Actions的节点应用程序。bucket创建步骤只是一个在将来帮助组织应用程序版本的过程。我们将使用Express在Node中运行一个简单的“Hello World ”,因为我们的重点是解释部署过程。</p><p id="9d5a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，要让一个应用在Elastic Beanstalk上运行，我们需要创建一个<strong class="ka jc">源码包</strong>，在我们的例子中，它是一个<strong class="ka jc"> zip </strong>文件，包含一个<strong class="ka jc"> Dockerfile </strong>和Dockerfile要运行的<strong class="ka jc">源码</strong>。在本地创建我们的应用程序后，这些文件将包含在源代码包中:</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/adfd6dadff8859081b957ab4b6b615b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*oAj37MYB2EouHDwh4cb7mQ.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">用于构建源代码包的文件</figcaption></figure><p id="b4cb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">文件的内容有:</p><p id="3d64" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">app.js</p><pre class="mh mi mj mk gt mp mq mr ms aw mt bi"><span id="92a1" class="mu le jb mq b gy mv mw l mx my">const express = require('express')<br/>const app = express()<br/>const APP_PORT = process.env.APP_PORT || 3000;app.get('/', (req, res) =&gt; {<br/>  res.send('Hello World!')<br/>})app.listen(APP_PORT, () =&gt; {<br/>  console.log(`Running app at port:${APP_PORT}`)<br/>})</span></pre><p id="d508" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Dockerfile文件</p><pre class="mh mi mj mk gt mp mq mr ms aw mt bi"><span id="9860" class="mu le jb mq b gy mv mw l mx my">FROM node:10<br/>WORKDIR /usr/src/app<br/>COPY package*.json ./<br/>RUN npm install<br/>COPY . .<br/>ENV APP_PORT 8080<br/>EXPOSE 8080<br/>CMD [ "node", "app.js" ]</span></pre><p id="02ee" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">dockerignore</p><pre class="mh mi mj mk gt mp mq mr ms aw mt bi"><span id="d821" class="mu le jb mq b gy mv mw l mx my">node_modules<br/>npm-debug.log</span></pre><p id="2b20" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">package.json</p><pre class="mh mi mj mk gt mp mq mr ms aw mt bi"><span id="3e37" class="mu le jb mq b gy mv mw l mx my">{<br/>  "name": "my-awesome-app",<br/>  "version": "1.0.0",<br/>  "description": "Hello World in Node with Express",<br/>  "main": "app.js",<br/>  "scripts": {<br/>    "start": "node app.js"<br/>  },<br/>  "author": "",<br/>  "license": "ISC",<br/>  "dependencies": {<br/>    "express": "^4.17.1"<br/>  }<br/>}</span></pre><p id="3705" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将这些文件放在一个zip文件下(出于演示目的，命名为"<strong class="ka jc"> my-awesome-app-v0.zip </strong>)，我们可以转到AWS Elastic Beanstalk控制台开始创建我们的环境。</p><p id="58ff" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们点击“<strong class="ka jc">创建新环境</strong>”按钮，选择“<strong class="ka jc"> Web服务器环境</strong>”，然后，设置“<strong class="ka jc">应用程序名称</strong>”。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/bf7d4578217c7ea09ec2cd8ab91a7d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nplSz2kmUfZwpdzgLW5Njw.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">在帐户的EB应用程序名称中，应用程序名称必须是唯一的</figcaption></figure><p id="072f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们为它定义了“<strong class="ka jc">环境名</strong>和“<strong class="ka jc">域</strong>”。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi na"><img src="../Images/fcba78685384200f2ffa8da55eb045a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-PCPaoeCeIM05bnVvT_z7w.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">设置环境名称和域。单击“检查可用性”以检查是否可以使用所需的域</figcaption></figure><p id="5b74" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，我们定义将使用什么平台。我们选择了“<strong class="ka jc">托管平台</strong>，因为我们想要将<strong class="ka jc"> Docker </strong>与<strong class="ka jc"> Amazon Linux 2 </strong>一起使用，试图使实例的基础设施尽可能地轻量级和最新。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nb"><img src="../Images/24ad0f3a2df51d1ce0a1f30ae24f7678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6W-1LSeLrHhwyG_-7fn6_Q.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">用Amazon Linux 2平台设置Docker</figcaption></figure><p id="4c1e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步是设置要部署到环境中的应用程序代码。给出了三个选项:“示例应用程序”、“版本标签”或“上传您的代码”。我们将选择“上传您的代码”，并选择我们的“<strong class="ka jc"> my-awesome-app-v0.zip </strong>”文件。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nc"><img src="../Images/3ae77f35a3ed7736a07ec965142a0b5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CTNJ4o3HvupD0pK_3uH6lQ.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">“我的-牛逼-app-v0.zip”上传</figcaption></figure><p id="5410" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑到我们将使用自定义VPC和子网配置，我们必须在完成创建过程之前，通过转至“<strong class="ka jc">配置更多选项</strong>”来定义要使用的配置。</p><p id="1d0e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，请转到“<strong class="ka jc">网络</strong>卡并进行编辑。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/1c8e27598a5a26e9b80d42a54de1c038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J5T7whehL2vc07uQ0BK7bQ.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">编辑网卡</figcaption></figure><p id="297d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">选择所需的<strong class="ka jc"> VPC </strong>和<strong class="ka jc">子网</strong>。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/be6172ae9ea6bdadc7abe6370e56b640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M6fugHZzPacsgfhxtvwkNQ.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">选择VPC</figcaption></figure><figure class="mh mi mj mk gt is gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/584452a2dc7fb0f076e0c2f3906b9d50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n7_AQFDL6-RjlIHoDwbwqg.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">选择子网</figcaption></figure><p id="5e15" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们需要为我们的<strong class="ka jc"> EC2 </strong>实例设置一个<strong class="ka jc">安全组</strong>。转到编辑“<strong class="ka jc">实例</strong>”卡并选择一个EC2安全组。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/c0a68246e8425e151b9d974a6ca43580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wTN_MbhlkIGf-2avsCI61g.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">选择安全组</figcaption></figure><p id="5ec9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">点击<strong class="ka jc">创建环境</strong>，环境创建开始。在等待AWS构建过程之后，您应该会看到这样的环境:</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/d55f783b8ab8fe8ebe2bb6fa44fcd93e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KrZtT91r1N2JU6umOpG_sA.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">环境预览</figcaption></figure><p id="5a34" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在去<strong class="ka jc"> S3 </strong>创建一个桶来存储我们未来的应用程序版本。其名称必须与我们的工作流文件中定义的名称相匹配。在这种情况下，我们命名为“<strong class="ka jc">我的-牛逼-app-bucket </strong>”。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/ec96284d1038360f8e76d8bda7a5948d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_hD8-8_Wo5itKV-_3b0xyA.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">设置存储桶的名称</figcaption></figure><figure class="mh mi mj mk gt is gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/d70938ab48bb934fdd1362f27916d9d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*BvP_xXd-z0GqokeHJQ5YHQ.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">定义存储桶的访问权限</figcaption></figure><p id="7010" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认情况下，可以保留剩余铲斗的配置。有了创建的弹性Beanstalk环境和bucket，下一步是使用GitHub Actions更新我们的应用程序。</p><h1 id="88ce" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">了解工作流程</h1><p id="27fb" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">在Actions中，工作流是在YAML文件中定义的，该文件描述了包含一组命令的步骤，这些命令创建了整个CI/CD管道流程。该文件必须放在<strong class="ka jc">下。github/workflows </strong>"文件夹放在你的资源库的根目录下，它的名字可以是任何东西(真的)。在这个例子中，我给的名字是“node-deploy-aws-eb.yml”。</p><p id="24a8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于比较的好奇，在Gitlab中，您也可以在YAML文件中描述一个管道，但是每个存储库中只能有一个必须命名为“<strong class="ka jc">的文件。gitlab-ci.yml </strong>"在存储库的根目录下，而在GitHub中你可以有多个文件，每个文件都是根据你选择的GitHub事件触发执行的(这将在接下来的段落中强调)。</p><p id="11a2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，由于我们将在AWS Elastic Beanstalk环境中部署一个节点应用程序，我们将按照以下顺序将我们的工作流分为两部分:</p><ol class=""><li id="cf0d" class="ng nh jb ka b kb kc kf kg kj ni kn nj kr nk kv nl nm nn no bi translated"><strong class="ka jc">创建Elastic Beanstalk版本</strong>:为我们的Elastic Beanstalk应用程序创建一个新版本，并将其存储在一个定制的S3桶中。</li><li id="718c" class="ng nh jb ka b kb np kf nq kj nr kn ns kr nt kv nl nm nn no bi translated"><strong class="ka jc">部署到弹性Beanstalk环境</strong>:将我们的新版本部署到我们创建的环境中。</li></ol><p id="6266" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了加快速度，工作流文件如下:</p><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="a6e4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解释文件的各个部分:</p><p id="a32f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“<strong class="ka jc">名称</strong>只是文件的描述。</p><p id="66ef" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">"<strong class="ka jc"> env </strong>"的工作方式类似于一个名称空间，您可以在其中定义要在"<strong class="ka jc">步骤</strong>中使用的自定义环境变量。</p><p id="d2ff" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“<strong class="ka jc"> on </strong>”作为一个命名空间，您可以在其中定义哪些GitHub事件将触发此工作流的执行。“<strong class="ka jc">推送</strong>”、“<strong class="ka jc">分支</strong>”、“<strong class="ka jc">【main】</strong>”定义了分支“main”上的每一次推送都会触发该工作流。</p><p id="c67d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">作业</strong>，顾名思义，定义了工作流程中要执行的“作业”。定义了两个作业:“<strong class="ka jc"> create_eb_version </strong>”和“<strong class="ka jc"> deploy_aws </strong>”。</p><p id="5215" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">运行-开启</strong>定义运行作业的图像(机器类型)。</p><p id="3b57" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">需要</strong>定义作业之间的依赖关系。在这种情况下，只有在“<strong class="ka jc"> create_eb_version </strong>”之前运行过的情况下，“<strong class="ka jc"> deploy_aws </strong>”才会运行。</p><p id="a3a5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">"<strong class="ka jc">uses:actions/check out @ v2</strong>"允许工作流通过签出来访问您的存储库。</p><p id="1eb5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">"<strong class="ka jc">使用:actions/setup-python@v1 </strong>"在机器中安装python，这样我们就可以安装" Elastic Beanstalk Cli "来部署我们的应用程序。</p><p id="d652" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">"<strong class="ka jc">用途:aws-actions/configure-AWS-credentials @ v1</strong>"处理AWS帐户验证。</p><p id="3077" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">"<strong class="ka jc"> secrets </strong>"包含包含敏感信息的加密环境变量。</p><p id="707c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要在“秘密”下定义我们的变量，我们需要转到“<strong class="ka jc">设置</strong>”选项卡，“<strong class="ka jc">秘密</strong>”菜单，并点击“<strong class="ka jc">新储存库秘密</strong>”。对于我们的工作流，我们定义了以下变量:</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nw"><img src="../Images/3a9c6630aa88bdd93e6afb85c56d2cd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X1mGO_t1z40E_4tIWPlc5A.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">“秘密”下定义的变量</figcaption></figure><p id="c41d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">定义好这些配置后，我们可以将文件推送到我们的存储库中，以查看GitHub操作的运行情况(抱歉)。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nx"><img src="../Images/117fef6c8df0d780bd2540ef494f8566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YzCdfyBYt0lw0euCxUW82A.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">推送的文件</figcaption></figure><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ny"><img src="../Images/a62e78aa707bf6130903191ed187c15f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rbrl_aOQCuqaznkfbXp5Jg.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">运行中的工作流</figcaption></figure><p id="ac01" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当两个作业都成功运行时，它们将在可视化整个管道时获得绿色复选标记。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nz"><img src="../Images/e7680c1426ffba7797104bbc7048859e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q6BwfO7-2RqyE6jFbhHx1A.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">成功执行</figcaption></figure><p id="d9df" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以通过检查我们的定制bucket并查看存储在那里的已创建的应用程序版本来验证一切工作正常。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/cac4949ec6983b0a5333b87afe9f81f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GD0cVp97e176vpRcjtqIiA.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">带应用程序版本的桶</figcaption></figure><p id="4f39" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和我们的具有相同应用程序版本的弹性Beanstalk环境。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/9040821cbfaa3a32bd3a9a6218666062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FirBfASSjOvXTMrN7RB6pA.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">应用程序版本的环境</figcaption></figure><p id="3f47" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">时候到了！要查看应用程序的运行情况，只需点击应用程序的URL，您应该会看到著名的“Hello World”消息。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/48808b1ec0d7f99178f561ed7100a888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*fUQxz4BrF2lmkcBlhK4bKg.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">你好世界信息</figcaption></figure><h1 id="8c98" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结论</h1><p id="314a" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">Actions是对GitHub的一个很好的补充，因为它提供了一个健壮且易于维护的CI/CD自动化工具。通过使用它，我们可以在GitHub本身内部查看从代码提交到app更新的整个部署过程，减少了使用多个工具时耦合产生的困难。</p><p id="b23a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管Actions是最近(2019年11月)推出的，但它背后有一个庞大的社区，帮助其发展，并支持现有用户和新用户。这意味着从现在开始只会越来越好。</p><h1 id="dc62" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">参考</h1><div class="ip iq gp gr ir oc"><a href="https://github.com/features/actions" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd jc gy z fp oh fr fs oi fu fw ja bi translated">功能* GitHub操作</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">github.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq ix oc"/></div></div></a></div><div class="ip iq gp gr ir oc"><a href="https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd jc gy z fp oh fr fs oi fu fw ja bi translated">GitHub操作的工作流语法</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">工作流文件使用YAML语法，并且必须具有. yml或。yaml文件扩展名。如果你刚到YAML，想…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">docs.github.com</p></div></div></div></a></div></div></div>    
</body>
</html>