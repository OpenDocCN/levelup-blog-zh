# 数据安全简介

> 原文：<https://levelup.gitconnected.com/introduction-to-the-data-security-7b69f6bf7588>

如今，数据就是一切，特别是在软件领域，数据驱动型应用程序的兴起得到了释放，保护数据的需求是必须的。每个安全团队面临的挑战是保证用户的安全，发送和存储的数据应该是只读的。

另一个责任是防止攻击和最小化损害。人们发现，旧的和新的实践也容易受到硬件进步的影响。

安全性发展迅速，开发人员和公司需要找到保护信息安全的方法。有无数的攻击媒介，但最关键的与数据存储和通信有关。

安全团队需要评估风险评估和管理。当然，对于物理安全有一种局部的方法，但是主要关注的是对我们信息的安全访问。加密是从第 0 天开始的，这避免了从另一方读取数据，但数据也可以被解密。在 20 世纪 70 年代，加密成了一件大事，当普通人能够使用加密时，它成了一笔可观的好资产。

这导致了改进，通过公开，许多针对加密的攻击被削弱了，因为其他人已经看到并修复了可能的漏洞。

加密很重要，对于减轻攻击和从攻击中恢复更是如此。

让我们来谈谈哈希，这是一个非常严密的概念，用于加密和一般的数据安全。

## 散列法

保持数据安全存储的一种方法是使其不可读和不可恢复，这完全取决于用户数据。

您可能希望以用户可以阅读的格式保存用户的数据，但是密码呢？

**哈希**是一个广泛的领域，但可以在校验和、压缩和消息认证中找到。哈希的职责是用一种称为哈希函数的东西对数据进行编码，哈希函数使用一种或多种算法将数据转换为哈希。

哈希是一条单行道。你可以这样看。

`Data ==> Hash = Hashed data`

在登录和注册过程中可以找到最好的散列方案。

当你**注册**到一个网站时，数据(密码)被散列，其值被存储在数据库中。到目前为止，一切都很酷，然后，**登录**过程非常简单，因为用户键入密码，使用与**注册**相同的散列过程对数据进行散列，并与数据库内的散列进行比较。

这种散列过程是一件好事，但它有一个可怕的问题，如果两个或更多的用户有相同的密码，它可以访问所有的帐户使用相同的密码。这个问题通过一个名为 **salt** 的特性得到了解决。

**Salt** 是一个唯一的数据，主要是一个 Unix 时间戳，当我们用 halt Salt 注册散列时使用，这使得散列函数产生一个唯一的输出

Salt 用于在每次执行时获取不同的数据，有很多 salt 技术，其中大部分是按照难度分类的。

结果是这样的:

`Data ==> [Hash + Salt] = Hashed Data`

## 存储数据

一旦数据被散列，我们需要找到一种适当的方法来存储数据，甚至是密码。

对所有用户来说，一个不好的做法是在许多网站上使用同一个密码，如果你在其中任何一个网站受到攻击，获得连锁攻击的概率非常高。

哈希是可以的，但是没有**盐**的哈希是不好的做法。

这里有一个 Python 2 脚本，展示了如何以一种简单的方式实现散列。

```
import hashlib
hashed = hashlib.md5(b'david').hexdigest() # Hexadecimal output
print(hashed)The output is: 172522ec1028ab781d9dfd17eaca4427
```

md5 加密模块是一个众所周知但很老的散列机制，使用了其他更现代和更强大的技术，其中之一是`shake_128`。您可以控制哈希创建的总体安全性和输出的哈希数据量。

在 **Python 3** 中有同样的例子，但是使用了不同的散列机制，`hexdigest()`需要一个数字来表示输出字符串中的字符数。

```
#!/usr/bin/python3import hashlib
hashed = hashlib.shake_128(b'david').hexdigest(20)
print(hashed)The output is: 6c0e6b1fdacdc29927704095e9cf61e9dc3d77fb
```

就像我之前说过的，对它们加盐是很重要的，附加一个随机的字符串会使输出变得独一无二。

这里有一个完整的例子。

```
#!/usr/bin/python3import hashlib
import uuidpassword = 'david'
salt = uuid.uuid4().hex
full = hashlib.shake_128(str.encode(salt + password)).hexdigest(20) + ":" + salt
print(full)The output is: 7e74d5f97a733840c38b34852a22462f44d21892:fef1bc6e47234471bd2a81733a2a9af7
```

您可以很容易地看到，有一个加密的盐和密码由加密的唯一盐值分裂。

事情是，使用哈希机制来保护信息税免受 GP 使用，可以从时间和内存上受益于对攻击者的攻击并避免冲突。

您应该跟踪用于散列的算法，并在必要时升级它们。就加密而言，有很多机制，但并不是所有的都是为密码设计的，一切都有加密。

## 加密

散列过程的自然发展是加密技术。

简而言之，与散列法几乎相同，但是存储的数据可以被转换和安全地反转。加密是双向的

加密以多种方式广泛应用于通信中。有很多机制可以做到这一点。

加密领域的关键术语有四个，其中:

1.  **纯文本**指你要加密或保密的数据
2.  **密文**是数据本身没有意义，是数据加密过程的结果
3.  **加密**是将明文转换成密文的过程
4.  **解密**是相反的过程，从密文开始

这整个加密的事情是一个完整的世界。但要做到公正，就需要涵盖两种可用的加密技术。

简而言之，**对称** **加密**当使用相同的密钥进行加密/解码时，每个人都需要拥有相同的密钥。

**非对称加密**更复杂，这种需要两个密钥，一个私钥和一个公钥。为了发送加密的消息，您需要使用发送方的公钥进行加密，接收方将使用私钥对发送的信息进行解密。每个参与者都有两个密钥。

有许多加密算法可用于此，但目前最常用的是 AES、Blowfish 或 IDEA。如果没有一个安全的地方来存储加密的数据，那么无论使用什么样的加密方法都是没有用的。

我们总结一下目前为止的情况。

对称密钥是用于使用相同密钥对数据进行编码和解码的私钥，而非对称密钥(注意两者)是在传输周期中分别用于编码和解码的公钥和私钥。

此外，还有用于未来输入数据加密的编码技术，以及用于以后对其解密的编码技术，这两种操作都是分别用所提到的公钥和私钥来完成的。

这些技术结合起来用于 **TLS/SSL 体验**。两人都负责 **HTTPS** 的通讯。

服务器和客户端之间的通信是一个**共享秘密**，它们将使用它来解码/编码它们之间的所有流量，并且只对它们进行解码/编码。服务器还提供公钥，用于向您的客户端验证其身份。

这个**共享秘密**在双方之间预先共享，这被称为 PSK(预共享密钥),或者仅在基于协定协议的通信开始时共享。

这看起来很复杂，但是读几遍之后就很容易理解了。

在文章的后面会有更详细的解释。

## 通信是如何进行的？

有很多种沟通方式。但是除了使用或实现 SSL/TLS 来确保客户端和服务器之间的安全连接之外，还需要端到端加密和前向保密。

当您在任何消息服务中创建帐户时，您都有一个可用的私钥和公钥。当你向朋友发送消息时，双方握手，这评估了与发送者的公众连接和检查签名的意愿。

然后，接收方将其自己的握手发送回给您，这也是经过验证的。当两次握手都有效时，系统将生成著名的**秘密共享密钥**(还记得吗？).因此，两个人都用这个密钥来加密他们发送给对方的消息。

在这一点上，我们可以有一个非常关键的错误，如果第三个人获得了一个参与者的钥匙，这个人可以在未来的握手中冒充他们。如果它已经被攻破并控制了私钥，用那个密钥发送的信息就可以被解密。

为了防止这种情况，并且为了提供所谓的前向保密，需要非常频繁地切换**秘密共享密钥**。

前向保密是当两个人用**共享密钥**发送消息时，如果第三个人来了，它可以使用该密钥并看到来自原始成员的所有以前的消息。

具有转发保密规范的系统由每次它们相互交谈时新的共享秘密密钥的协议组成。如果密钥被泄露，解密将仅应用于用该密钥签名的特定消息。

钥匙旋转将大幅缩小范围。

## 让我们简单谈谈访问控制

不管实施了什么散列、加密或任何安全机制，您都需要弄清楚谁可以访问数据。

这都是由认证机制处理的，有些人使用用户密码表单，其他 2FA 或 MFAs 解决方案。

事情是，不仅认证是值得的，而且授权呢，简而言之，你可以使用什么或与什么交互。

现代解决方案使用 ACL 或基于角色的访问控制，提供了一种方法来引导您确定允许执行的访问级别和功能。由开发人员或编程团队来决定哪种机制最适合您心目中的软件类型。

## 一切都与数据有关

数据驱动软件是当今的主流。但我们不能忘记，违规行为可能会发生，当然，它们是可以控制的。

您可以通过不收集不需要数据或设置密码存储机制来最小化风险，但这也可以通过使用社交认证服务来避免。

拥有 **OpenID 技术**并以适当的方式控制系统间的**秘密共享密钥**是健康和安全环境的良好标志。

这篇文章的整个想法是为了更好地理解引擎盖下发生的事情，并意识到什么是可以控制的，什么是不可以控制的。

安全快乐:)