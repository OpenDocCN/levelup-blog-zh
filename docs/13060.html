<html>
<head>
<title>Learn Programming with Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Typescript学习编程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learn-programming-with-typescript-69d6a60373ed?source=collection_archive---------15-----------------------#2022-08-03">https://levelup.gitconnected.com/learn-programming-with-typescript-69d6a60373ed?source=collection_archive---------15-----------------------#2022-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3923b1a23d898e380b669e7359ab59f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-TOTEUNUyF2EfV6E5MxFMw.png"/></div></div></figure><blockquote class="jy jz ka"><p id="8f5a" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以，你想成为一名程序员！嗯，也许不是成为一个T1，但只是T2做一些。从哪里开始？就是这个地方。在这里，我们将从一个完全初学者的角度来看编程——不要对任何你可能已经知道的东西做任何假设。在我们的练习中，我们将关注Typescript中的前端web开发，也称为<strong class="ke ir">制作网页</strong>。沿着这条路，我们将看看编程的一些历史渊源，以及它们如何在今天发挥它的限制和可能性。你准备好了吗？我们开始吧！</p></blockquote><h1 id="1e97" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">我的孩子在电脑上工作</h1><p id="bcb2" class="pw-post-body-paragraph kb kc iq ke b kf ly kh ki kj lz kl km ma mb kp kq mc md kt ku me mf kx ky kz ij bi translated">当一个人提到在休闲公司编程时，通常有人会说他们的孩子(或者他们的邻居，或者他们的配偶)也在电脑上工作。太多时候，这样的感叹是被误导的，因为在计算机上工作的许多方面与编程无关。</p><p id="2fa9" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">让我们把他们赶走:</p><ol class=""><li id="19e2" class="mg mh iq ke b kf kg kj kk ma mi mc mj me mk kz ml mm mn mo bi translated"><strong class="ke ir">设置和构建硬件。</strong></li><li id="2725" class="mg mh iq ke b kf mp kj mq ma mr mc ms me mt kz ml mm mn mo bi translated"><strong class="ke ir">设置软件</strong>。</li><li id="fe85" class="mg mh iq ke b kf mp kj mq ma mr mc ms me mt kz ml mm mn mo bi translated">设计网络。</li><li id="9443" class="mg mh iq ke b kf mp kj mq ma mr mc ms me mt kz ml mm mn mo bi translated"><strong class="ke ir">将软件设计成一套想法(架构)。</strong></li><li id="3e20" class="mg mh iq ke b kf mp kj mq ma mr mc ms me mt kz ml mm mn mo bi translated"><strong class="ke ir">使用任何种类的软件，包括连接各种。</strong></li><li id="c8ab" class="mg mh iq ke b kf mp kj mq ma mr mc ms me mt kz ml mm mn mo bi translated">解决电脑问题和技术支持。</li><li id="48af" class="mg mh iq ke b kf mp kj mq ma mr mc ms me mt kz ml mm mn mo bi translated"><strong class="ke ir">技术写作。</strong></li></ol><p id="8c34" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">如果这些都不是编程，那什么是？编程指的是编写代码的特定行为，这些代码最终将在特定的硬件上运行。我们将深入研究这些代码看起来是什么样的，以及它们是如何运行的，但是可以说，如果你不写代码，你就不是在编程。这就是为什么程序员互称<strong class="ke ir">编码员</strong>，我们的工作<strong class="ke ir">编码</strong>的原因。你会听到的另一个术语是<strong class="ke ir"> devs </strong>，是<em class="kd">软件开发者</em>的简称。</p><p id="c4e2" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">所以… <em class="kd">现在</em>你知道有多少人是程序员？大概很少。事实证明，编程是一种罕见的职业。美国人口中只有大约2%的人从事编程工作，只有不到1%的人能做得很好。编程也是一项吃力不讨好的工作，充满了失败、漏洞修复和伴随而来的客户抱怨——而表扬和认可却很少被听到。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/c6d5fd7821d76c1a34b14bde000cfd2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/0*TViaQQI9Mpib4M-L.jpg"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">大家都听说过微软Word，但是有没有人用它给它的发明者<a class="ae mu" href="https://en.wikipedia.org/wiki/Charles_Simonyi" rel="noopener ugc nofollow" target="_blank"><strong class="bd lc"/></a>写一封感谢信呢？大概不会。这位匈牙利裔美国软件开发商的公司被微软收购，他将继续监督MS Office的开发。他估计有50亿美元的净资产，这证明了成功的软件可以赚到钱。</figcaption></figure><h1 id="e94b" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">我在哪里报名？</h1><p id="85d7" class="pw-post-body-paragraph kb kc iq ke b kf ly kh ki kj lz kl km ma mb kp kq mc md kt ku me mf kx ky kz ij bi translated">如果这么可怕，这么难，为什么还有人去做？原因之一当然是钱。编程一直是收入最高的职业之一，与律师和医生争夺最高收入。但这并不是对大多数程序员的真正吸引力。编程的诱惑在于它提供了无限的可能性——<em class="kd">空中楼阁，</em>正如我在童年的顿悟中想到的那样。软件开发的真相是你可以用软件做任何事情。没有限制。你知道有几个工作能这么说？</p><p id="7466" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">只要环顾四周，我们就能发现这是真的。软件已经吞噬了世界。从农业和能源到交通和电子游戏，它无处不在。甚至新的生命形式都是用<a class="ae mu" href="https://en.wikipedia.org/wiki/CRISPR" rel="noopener ugc nofollow" target="_blank"> CRISPR </a>制造的，用软件组装<a class="ae mu" href="https://en.wikipedia.org/wiki/Messenger_RNA" rel="noopener ugc nofollow" target="_blank"> mRNA </a>疫苗。如果你成为一名程序员——在任何语言和任何平台上——这个无限的世界向你完全敞开。这是相当令人兴奋的东西！</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/88bcdd5a90f1926146992d8ef79dee27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6lnkOx60CSzX3Lbs"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">计算机先驱艾伦·图灵的概念性<a class="ae mu" href="https://en.wikipedia.org/wiki/Alan_Turing" rel="noopener ugc nofollow" target="_blank">图灵机</a>从来就不是用来制造的；这是一个纸上的理论数学练习——后来成为所有现代计算机的基础。尽管如此，在2010年，威斯康星州的一名工程师建造了这个<a class="ae mu" href="https://spectrum.ieee.org/032610-diy-turing-machine" rel="noopener ugc nofollow" target="_blank">工作物理模型</a>。根据定义，图灵机的两端都有纸带卷形式的无限存储空间。显然，这在这里是不可能的——对任何真正的计算机也是如此。</figcaption></figure><h1 id="7742" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">所有计算机都是等效的</h1><p id="8015" class="pw-post-body-paragraph kb kc iq ke b kf ly kh ki kj lz kl km ma mb kp kq mc md kt ku me mf kx ky kz ij bi translated">计算机的一个显著特点是，尽管自20世纪40年代发明以来已经有了很大的发展，但所有的计算机在本质上都是完全相同的。我的意思不是“相似”，我的意思是任何曾经存在的计算机都可以与未来可能存在的任何其他计算机交换，并且它可以做同样的工作。</p><p id="6498" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">你听说过你的手机比阿波罗任务有更强的计算能力，所以很明显你的手机可以做这些计算。但是你可能没有意识到阿波罗时代的电脑可以做你的手机能做的所有事情！我们知道这是真的，因为两个杰出的人，艾伦·图灵和T2·阿隆佐·邱奇，独立地用数学证明了任何具有一些简单特征的机器都可以实现任何可以计算的功能。</p><p id="91fd" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">当试图推广全新的计算理念时，图灵提出了一种只能执行少量物理操作的物理机器的理论:</p><ol class=""><li id="9668" class="mg mh iq ke b kf kg kj kk ma mi mc mj me mk kz ml mm mn mo bi translated">在一条没有尽头的纸带上打孔。</li><li id="6b83" class="mg mh iq ke b kf mp kj mq ma mr mc ms me mt kz ml mm mn mo bi translated"><strong class="ke ir">前进到磁带上的另一个位置。</strong></li><li id="0cd6" class="mg mh iq ke b kf mp kj mq ma mr mc ms me mt kz ml mm mn mo bi translated"><strong class="ke ir">读取该位置是否打孔。</strong></li></ol><p id="89fa" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">图灵机只是一个智力练习，不需要建造。当你得知图灵的打孔机也能发射航天飞机，还能玩<a class="ae mu" href="https://en.wikipedia.org/wiki/Forza" rel="noopener ugc nofollow" target="_blank"> Forza </a>的时候，你会惊讶吗？有可能。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/577e81ddc99a86497f43645f572e7678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iu7KwRnvIGwtHcrv"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">20世纪80年代的家庭立体声组件由微处理器(以及软件)驱动，但仍然使用定制的<a class="ae mu" href="https://en.wikipedia.org/wiki/Display_device#Segment_displays" rel="noopener ugc nofollow" target="_blank">分段LED显示屏</a>，而不是我们今天使用的基于像素的屏幕。虽然从技术上来说，计算能力没有什么不同，但显示技术的进步导致今天的软件看起来与早期计算机上的软件大不相同。</figcaption></figure><p id="0196" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">那么，为什么没有人尝试用20世纪60年代的电脑打视频电话或制造自动驾驶汽车呢？原因归结为任何两台图灵完全机器之间的两个差异:</p><ol class=""><li id="031e" class="mg mh iq ke b kf kg kj kk ma mi mc mj me mk kz ml mm mn mo bi translated">他们跑得多快，还有…</li><li id="48ef" class="mg mh iq ke b kf mp kj mq ma mr mc ms me mt kz ml mm mn mo bi translated"><strong class="ke ir">他们编程有多容易</strong>。</li></ol><p id="c1dd" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">最初的纸带机想法听起来很慢，而且编程也很糟糕。你必须用类似莫尔斯电码的东西在纸带上写出“数据”——用一系列的孔和无孔来代表每个字母或数字。你必须根据最基本的操作来编写机器的所有“指令”，任何计算的结果都必须写在磁带本身的末尾。但是……有可能。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/139bd6c060661db6c86c8e43b2c8c548.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8t0J9v_i5GDIOhRS0ljt7Q.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">1959年推出的IBM 1401计算机的顶部前面板包括处理器内部操作的实时图表。输入、处理、记忆、存储和输出都用连线来表示数据是如何流动的。在这个时代，像CRT或今天的平板显示器这样的基于屏幕的显示器根本不存在，导致了许多旧电视剧和电影中大型计算机上看到的“闪烁的灯”。</figcaption></figure><h1 id="4a0b" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">许多闪烁的灯</h1><p id="2dd2" class="pw-post-body-paragraph kb kc iq ke b kf ly kh ki kj lz kl km ma mb kp kq mc md kt ku me mf kx ky kz ij bi translated">谢天谢地，计算机行业在40年代就已经有了建造数字计算机的想法，而不是物理图灵机。这些机器将在电子电路中保存(或不保存)电压，而不是用纸带来保存数据和指令。你可以把这些电压想象成打孔机。如果胶带上有孔，则电路中有电压。如果不是，就不是。蚀刻在所有计算机芯片上的实际硅电路在引擎盖下正是这种设计。</p><p id="5db8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">尽管关于这种硬件是如何产生的还有很多可以说的，但我们并不需要这些信息来给计算机编程。事实上，所有的编程都生活在一个<a class="ae mu" href="https://en.wikipedia.org/wiki/Abstraction_(computer_science)" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"/></a>抽象的幻想世界中。我们不会试图给字面上的图灵机“编程”，而是用一种隐藏了许多底层细节的编程语言来编写代码。这很好——但是知道真正发生了什么也很重要，因为当你的程序在硬件上运行时，你的抽象中的误解会导致真实世界的错误。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/5d7baf331b1f88f543de8298251a08e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N0hjOkDhU_Wpvc_o"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">一些早期的街机视频游戏，如雅达利小行星，是用矢量图形制作的。在这种架构中，一系列坐标用于将<a class="ae mu" href="https://en.wikipedia.org/wiki/Cathode-ray_tube" rel="noopener ugc nofollow" target="_blank">阴极射线管</a>光束激发成特定的照明形状，这从岩石的锯齿状边缘和下面缺少任何圆形部分的文字中可以明显看出。很久以后，随着<a class="ae mu" href="https://en.wikipedia.org/wiki/Scalable_Vector_Graphics" rel="noopener ugc nofollow" target="_blank"> SVG </a>的引入，这些图形的更复杂形式将被添加到web浏览器中。</figcaption></figure><h1 id="db37" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">输入过程输出</h1><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/56d5887dae15182c8de1a1c80a943d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fh-elJq-cZyDGB24BuGG2g.png"/></div></div></figure><p id="fc10" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">所有的计算机操作都遵循相同的操作模式，称为<em class="kd">输入-处理-输出</em>。虽然从计算机中收集一个按键并将其发送到程序(或屏幕)需要成千上万行代码，但我们现在将这些抽象出来，一般来说:</p><ol class=""><li id="161c" class="mg mh iq ke b kf kg kj kk ma mi mc mj me mk kz ml mm mn mo bi translated">出现一些<strong class="ke ir">输入</strong>。可能来自打字，也可能来自一些存储的数据。</li><li id="d91a" class="mg mh iq ke b kf mp kj mq ma mr mc ms me mt kz ml mm mn mo bi translated">一些<strong class="ke ir">过程</strong>发生了，比如做数学或者另一个<a class="ae mu" href="https://en.wikipedia.org/wiki/Algorithm" rel="noopener ugc nofollow" target="_blank">算法</a>。</li><li id="14d5" class="mg mh iq ke b kf mp kj mq ma mr mc ms me mt kz ml mm mn mo bi translated"><strong class="ke ir">输出</strong>去往某个地方——比如显示器、你的扬声器或者另一个进程。</li></ol><p id="0582" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">现代操作系统让我们处理这些步骤，而不用担心输入如何出现或者输出去哪里。事实上，这就是操作系统的全部目的。例如，当程序员为Windows编写应用程序时，他或她允许Windows处理输入和输出部分——因此应用程序程序员不必这样做。</p><p id="b3ce" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">这也是不同操作系统互不兼容的原因。即使两台机器有相同的处理器，每个操作系统处理输入和输出的方式也会不同。这就是为什么为Windows编写的桌面程序不能在Mac上运行，除非对它们的代码进行重大修改——也是为什么苹果商店的应用程序不能在安卓手机上运行。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/0ea9a2101d0210abef0596b40e60bde0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gr4fGckjprZpJDVUvmfPaA.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">同一个硬件可以运行几个操作系统，比如这台iMac及其英特尔<strong class="bd lc">处理器</strong>在Mac OS、Windows和Linux桌面环境中显示。我们知道相同的<strong class="bd lc">指令集</strong>一定在幕后运行，因为硬件是相同的。然而，软件应用程序是不兼容的，因为它们依赖于操作系统来处理输入和输出。</figcaption></figure><h1 id="7d60" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">里程表和邮箱</h1><p id="7fce" class="pw-post-body-paragraph kb kc iq ke b kf ly kh ki kj lz kl km ma mb kp kq mc md kt ku me mf kx ky kz ij bi translated">在执行我们的处理步骤的芯片<strong class="ke ir">处理器</strong>内部，有两个关键部分，我喜欢称之为<strong class="ke ir">里程表</strong>和<strong class="ke ir">邮箱</strong>。</p><p id="3a16" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">每个人都知道汽车里程表是如何工作的。当汽车向前滚动时，它也向前滚动，与车轮机械相连。尽管你不应该把你的里程表倒推，但这在过去是可能的。因此，想象一下，在我们假设的计算机中有一个里程表组件，它可以向任何方向滚动。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/8f1756caa8c1177dfcb984725336eaf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fC0p_4-eM-iG5kRj"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">机械收银机，像这个来自国家收银机的精致的装饰艺术风格的T21模型，将通过一组类似里程表的显示轮输出他们的总数。当每一个低位数字从9滚回0时，锁存器会触发左边的下一个数字向上滚动一个位置。电子计算机与硅基存储器的工作方式相同。NCR将继续发展成为一家成熟的计算机公司，至今仍在生产基于计算机的POS系统。</figcaption></figure><p id="339a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">我们在老式的收银机上看到过这种展示。收银员不需要记录总数——它显示在显示屏上，每次输入商品的价格时都会“向前滚动”。按下$1的按钮，显示里程表向前滚动1。有优惠券吗？这可能会让时间倒退50年。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/706117f3a579ab88a4d4dc2c737de10e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*SWVRvhAv1QmCMvLe18hW0Q.png"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">IBM 3660超市系统是1974年推出的现在无处不在的T2 UPC T3条形码扫描仪的早期应用。IBM还发明了UPC标准，其工作原理是将每件商品的价格与条形码号码分开存储。计算机化的收银机将从中央存储设备中查找每一件商品，然后将其价格添加到<a class="ae mu" href="https://en.wikipedia.org/wiki/Accumulator_(computing)" rel="noopener ugc nofollow" target="_blank">累加器</a>和总显示中——这与它们今天的工作方式相同。</figcaption></figure><p id="97ca" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">要把收银机变成电脑，我们首先要在电路组合中加入一些别的东西:<strong class="ke ir">存储</strong>。我喜欢把存储想象成一系列的<strong class="ke ir">邮箱</strong>(或者我70岁时的小盒子)。我们能用这些邮箱做什么？我们可以保留里程表的值！</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/8c18444bd24af3bfeedecdbaccc368b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XzBQB6UfgaprYjiH9rmf_w.png"/></div></div></figure><p id="aeba" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">如果杂货店需要跟踪20个人的购买情况，它将需要20个邮箱，每个邮箱对应一个总数。从第一个顾客在第一个邮箱的总数开始，在顾客付款后，计算机可以移动到“下一个邮箱”。当所有的顾客都完成结帐后，他们个人的总数仍然会在邮箱里。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/327b1e1bee7196c2cc79a4dafe3d0521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cx4c4rlOC0WVZaLV"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">虽然没有这些漂亮，但我的幼儿园确实为每个孩子都准备了一个小房间，标有我们的名字。计算机内存的组织方式完全相同。行和列保存真实信息，而外部的标签或名称可以更改。</figcaption></figure><h1 id="a29b" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">总计</h1><p id="c049" class="pw-post-body-paragraph kb kc iq ke b kf ly kh ki kj lz kl km ma mb kp kq mc md kt ku me mf kx ky kz ij bi translated">如果邮箱和里程表可以双向移动数据<strong class="ke ir"/>，那么我们就可以从每个邮箱中读取数据，并将里程表向前滚动那个量——在里程表中留下一个总计。事实上，这正是这些部件的工作原理。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/036abbd176edcc12d1f445da4a01560a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fiAcxYHAgPz5uiriqSc2Hw.png"/></div></div></figure><p id="45b2" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">这不仅是商店购买的总额，也是计算的总额，因为这是我们让计算机工作所需要的。如果我们给自己多几个里程表和几个小房间来工作(并给这些部件起真实的名字),我们就有了每一台现代计算机的图表！</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/39d99451365ec9ddf7a65fb15c4e3586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k7-qtF-sLH-Fn6cqkZwmiA.png"/></div></div></figure><p id="158a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">来自模拟计算机的“里程表”真的叫做<a class="ae mu" href="https://en.wikipedia.org/wiki/Processor_register" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">寄存器</strong> </a>，邮箱叫做<a class="ae mu" href="https://en.wikipedia.org/wiki/Computer_data_storage" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">存储</strong> </a> <strong class="ke ir">位置</strong>。你可以看到，有了更多的寄存器和更多的存储位置，我们可以轻松地进行更复杂的计算。如果任何寄存器都可以寻址任何存储单元进行读写，我们就可以编写任何复杂程度的程序，只受存储量的限制。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/91a59ad63cc84eb940fa0349113b94fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YY7M-_c592hCsY0D"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">像今天的DRAM这样的现代存储器仍然是由物理电路和开关组成的。最初画在胶片上，今天这些电路设计在软件中以人类规模绘制，或者直接从代码制作<a class="ae mu" href="https://en.wikipedia.org/wiki/Field-programmable_gate_array" rel="noopener ugc nofollow" target="_blank">，然后使用</a><a class="ae mu" href="https://en.wikipedia.org/wiki/Photolithography" rel="noopener ugc nofollow" target="_blank">光刻</a>蚀刻到微观尺度的硅中。</figcaption></figure><p id="63b6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">实际上，术语<em class="kd">存储</em>代表两种不同的东西。它可以指<strong class="ke ir">内存</strong>，这是一种在硅片级别连接到处理器的存储设备，也可以指<strong class="ke ir">磁盘驱动器</strong>或其他形式的外部存储器，它们不直接连接到计算机主板上的处理器。</p><p id="0ecb" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">实际上，内存和驱动器存储是可以互换的。这允许我们将文件从文字处理器(在内存中)保存到磁盘或其他存储介质上，然后加载它以继续处理该文件。</p><p id="8843" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">为什么我们不能直接输入磁盘上的文件呢？<strong class="ke ir">处理器</strong>的一个基本限制是，它只能处理内存中的数据，而内存是在硅片层面上与处理器物理连接的。在处理开始之前，任何在其他类型的存储器中的数据必须被加载到那个存储器中。同样，为了保存，内存中的任何数据都必须<strong class="ke ir">写出</strong>到外部存储，如果它要在新数据加载到相同位置时或断电时不被覆盖的话。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/548e04d4616d303d5550299afb8b44f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6VNtW9qhHQcI3ItfKP1biA.png"/></div></div></figure><p id="035c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">请注意，寄存器、内存位置和磁盘驱动器都有自己的寻址方案。为了将数据从<code class="fe nr ns nt nu b">Drive 1</code>上的<code class="fe nr ns nt nu b">Location 2</code>移动到内存中的<code class="fe nr ns nt nu b">Location 1</code>，我们必须为源位置和目的位置写一个合适的地址。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/43eb8553be82fc424ef12038949a9997.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rjPWgOxSnIg3Vx-e"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">IBM的<a class="ae mu" href="https://en.wikipedia.org/wiki/IBM_305_RAMAC" rel="noopener ugc nofollow" target="_blank"> RAMAC </a>是第一个使用一堆旋转磁性盘片的大容量存储设备，工程师在这里表示。每个盘片被进一步分成比萨饼形状的扇区，在那里数据可以被一个读写头访问，读写头悬浮在移动臂上。我们今天仍然使用旋转驱动器技术，但是即使像USB闪存驱动器这样的固态存储设备也是以同样的方式组织的。在操作系统中，它的用法与旋转驱动器相同。</figcaption></figure><p id="12fb" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">在<a class="ae mu" href="https://en.wikipedia.org/wiki/Hard_disk_drive" rel="noopener ugc nofollow" target="_blank">硬盘</a>驱动器上查找东西不是你想自己处理的事情。您的数据实际上分散在各处，跨越物理驱动器的几个盘片和扇区。甚至单个文件也可以跨越多个位置。幸运的是，操作系统将它抽象化，允许我们通过<strong class="ke ir">文件</strong>和<strong class="ke ir">文件夹名称</strong>来引用磁盘数据。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/0b43b95987da7b2fc885854f5f8cd522.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*m2xq2jtfOGujMb1q.jpg"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">IBM的第一台个人电脑，型号为<a class="ae mu" href="https://en.wikipedia.org/wiki/IBM_Personal_Computer" rel="noopener ugc nofollow" target="_blank"> 5150 </a>，包括两个软盘驱动器形式的物理存储设备，左边系统单元中的黑色矩形。它们被标为“A”和“b”。可以添加一个可选的硬盘驱动器，称为“C”。这导致了我们今天的“C驱动器”,以及插入USB棒或外部驱动器后出现的D、E等。</figcaption></figure><p id="e422" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">寻址存储单元也有类似的问题。实际上，物理内存设置在称为<em class="kd">库</em>的<strong class="ke ir">行</strong>和称为<em class="kd">地址</em>或<em class="kd">偏移量</em>的<strong class="ke ir">列</strong>中。但是谁想试着去跟踪它呢？如果我们能够用一个名字而不是两个长数字来标记我们的记忆位置，那会好得多。然后我们可以在程序中说，“将值从<code class="fe nr ns nt nu b">Susan’s</code>“邮箱”(内存)移动到<code class="fe nr ns nt nu b">Steven’s</code>。或者，“从<code class="fe nr ns nt nu b">Marty’s</code>存储位置的值中扣除10%”。"</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/6ff126e83a28afe1020b1640c7bcb404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*x3S8GOMXbxW1x6pJ_JO7yw.png"/></div></figure><p id="74b1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">变量允许我们通过为存储位置指定名称来抽象数据在内存中存储的物理方式，就像文件和文件夹名称允许我们在不知道它们的确切物理位置的情况下读写磁盘上的特定位置一样。</p><p id="661e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">您可能还会注意到，上一张图中完全没有前面描述的寄存器。这是因为它们也被抽象成了高级编程语言。处理器在计算中间结果时使用寄存器，但是在Typescript中我们不需要担心它们。我们只需要关心我们创建的<strong class="ke ir">命名变量</strong>，而不是它们在内存中的实际存储位置。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/a49fad777e5c67f7fa00baf8ee3becaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TL4yDLyhj4raN3MF.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">IBM的<a class="ae mu" href="https://en.wikipedia.org/wiki/EBCDIC" rel="noopener ugc nofollow" target="_blank"> EBCDIC </a>(不幸读作EBB-suh-dick)是一种将穿孔卡片存储器上的数字转换成字母和单词的早期代码。打印在顶部的字母“A”由它下面一行中的一个穿孔和“1”行中的一个穿孔表示。字母“J”是文本下面两行的一个穿孔<strong class="bd lc">加上“1”行的一个穿孔。后来，机械刷可以通过这些孔进行电接触，并读取穿孔，将它们转换成字母和单词。</strong></figcaption></figure><h1 id="8423" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">不仅仅是语言</h1><p id="4cb9" class="pw-post-body-paragraph kb kc iq ke b kf ly kh ki kj lz kl km ma mb kp kq mc md kt ku me mf kx ky kz ij bi translated">直到员工信息的最后一个例子，我们只讨论了使用寄存器或存储器来跟踪<strong class="ke ir">号</strong>。但是如果我们想要处理另一种数据，比如组成雇员<code class="fe nr ns nt nu b">name</code>或<code class="fe nr ns nt nu b">email</code>的文本，该怎么办呢？如何在旋转的里程表上描绘字母和单词(或小行星)？答案是<strong class="ke ir">他们不能</strong>。</p><p id="f78c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">为了将原始数字转换成字母和单词，我们需要一种<strong class="ke ir">密码</strong>，一个转换表，其中每个数字代表一个字母。我们今天使用的这个叫做<a class="ae mu" href="https://en.wikipedia.org/wiki/Unicode" rel="noopener ugc nofollow" target="_blank"> Unicode </a>。由于悠久而丰富多彩的历史，我在这里就不详述了，大写字母<strong class="ke ir"> A </strong>的Unicode编码是<code class="fe nr ns nt nu b">65</code>。字母<code class="fe nr ns nt nu b">B</code>是<code class="fe nr ns nt nu b">66</code>，以此类推。因此，世界语言中使用的所有字形都用Unicode编码。</p><h1 id="cd2c" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">这正是我的看法</h1><p id="9f45" class="pw-post-body-paragraph kb kc iq ke b kf ly kh ki kj lz kl km ma mb kp kq mc md kt ku me mf kx ky kz ij bi translated">我们说过，在Unicode中，数字65代表字母“A”。但是很明显，它也代表了实际的数字65，就像我们在收银台把顾客的购买量加起来一样。我们不希望有人花65美元购买的东西在收据上显示为<code class="fe nr ns nt nu b">$A</code>。同样的道理，如果他们扔给我们两块钱的糖果，我们也不想在字母“a”上加2。</p><p id="6246" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">实际上，数字65可能会出现在各种不同的上下文中。它可能是圣克鲁斯周六早晨的温度，也可能是你显示器上<a class="ae mu" href="https://en.wikipedia.org/wiki/RGB_color_model" rel="noopener ugc nofollow" target="_blank"> RGB </a>显示屏中一个红色像素的亮度。重要的一点是，在裸机上，只有数字65是真实的——因为它在里程表的某个地方。每当我们处理计算机值时，得到正确的值是成功的一半，但是<strong class="ke ir">正确地解释</strong>它是另一半。底层硬件不知道您的意图；它只能给你一个<code class="fe nr ns nt nu b">65</code>。</p><h1 id="2052" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">运算符和操作数</h1><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/8b1434311b173ac38511e8c91f1a2af3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*uXvVORHWbqn2Orvp6AGCpg.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">这张来自IBM System/370操作原理的图表显示了只执行一项简单任务的低级机器指令<a class="ae mu" href="https://en.wikipedia.org/wiki/Machine_code" rel="noopener ugc nofollow" target="_blank">的格式——比如改变寄存器、存储器或两者中的值。黄色的<strong class="bd lc">操作符</strong>告诉我们要做什么，粉色的<strong class="bd lc">寄存器操作数</strong>和橙色的<strong class="bd lc">存储操作数</strong>是它们操作的位置。</a></figcaption></figure><p id="bd62" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">所有这些关于数据表示的讨论都很有趣，但是我们实际上并没有对这些数据做任何有用的事情。处理器的工作部分称为它的<a class="ae mu" href="https://en.wikipedia.org/wiki/Instruction_set_architecture" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">指令集</strong> </a>。虽然处理器提供的特定指令集各不相同，但如果给出正确的指令，每个处理器都可以用来产生相同的结果——因为它们都是图灵机。</p><p id="b6fe" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">每条指令被分成一个<strong class="ke ir">操作符</strong>和一个<strong class="ke ir">操作数</strong>(读作<em class="kd"> AH-purr-and </em>)。操作符告诉<em class="kd">做什么</em> <strong class="ke ir"> <em class="kd"> </em> </strong>操作数告诉<em class="kd">用</em>做什么。如果我们试图将存储器中的一个值添加到一个寄存器中(一个非常常见的操作)，操作符是<strong class="ke ir"> add </strong>，操作数是寄存器的<strong class="ke ir">名称和存储单元的<strong class="ke ir">地址</strong>。</strong></p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/002778a0770dd48cb7990cfc3835b59a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DZYV6i8um-3qf8VL.jpg"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">Milton Bradly<a class="ae mu" href="https://en.wikipedia.org/wiki/Big_Trak" rel="noopener ugc nofollow" target="_blank"><strong class="bd lc">Big Trak</strong></a>是一辆早期的可编程卡车，于1979年发布——那一年我11岁生日，我成功地说服父母给我买了一辆。没过多久，这个玩具仅有16个可编程步骤的小内存就变得有限了。其中一个步骤可能是一个原始类型的循环，尽管这台机器的编程语言并不是完全的。</figcaption></figure><h1 id="539c" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">向可编程性的飞跃</h1><p id="c018" class="pw-post-body-paragraph kb kc iq ke b kf ly kh ki kj lz kl km ma mb kp kq mc md kt ku me mf kx ky kz ij bi translated">我们说过，增加存储位置是将计算器/收银机推向计算领域的一个因素。但是最大的推动力来自可编程性——人们可以提供一个指令列表，在下面的计算器上运行。鉴于我们目前对计算机体系结构的了解，让我们回顾一下我们应该可以用来编程的能力:</p><ol class=""><li id="4059" class="mg mh iq ke b kf kg kj kk ma mi mc mj me mk kz ml mm mn mo bi translated"><strong class="ke ir">内存中保存数据的一组存储位置。</strong></li><li id="35d4" class="mg mh iq ke b kf mp kj mq ma mr mc ms me mt kz ml mm mn mo bi translated"><strong class="ke ir">处理器可以对内存值执行的操作列表。</strong></li><li id="cd96" class="mg mh iq ke b kf mp kj mq ma mr mc ms me mt kz ml mm mn mo bi translated"><strong class="ke ir">使数据出现在内存中的一组输入设备。</strong></li><li id="ab2e" class="mg mh iq ke b kf mp kj mq ma mr mc ms me mt kz ml mm mn mo bi translated"><strong class="ke ir">一组显示内存值的输出设备。</strong></li></ol><p id="ee1a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">今天，在我们的编程工作和实现这一点的物理设备之间有许多抽象层。不管怎样，到目前为止，只有我们描述的这些物理现象在你的程序运行时才真正发生——这个概念将成为我们用Typescript编写程序的基础。</p><p id="cddc" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">使用这种硬件的唯一方面，我们还没有描述的是如何编写使处理器做任何有用的事情的指令。因为每个处理器家族或芯片设计都有自己的固定指令集，<strong class="ke ir">编程语言</strong>是约翰·巴科斯在1948年引入FORTRAN语言后发明的。FORTRAN和随后的语言允许我们“编写一次，在任何地方运行”,并使程序可以在各种处理器硬件上运行。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/f4f1cdac61ba140fc4acf08bfd52a373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*506tKhXNG_4QJCcLSSvmQQ.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">Big Trak手册中的图表显示了如何通过键盘对序列进行编程。绿色按钮是操作，黄色按钮是提供给它们的值。圈数以分钟为单位，15分钟为1/4圈。红色的<code class="fe nr ns nt nu b">CM</code>按钮代表“清除记忆”</figcaption></figure><h1 id="c122" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">编译器和解释器</h1><p id="6f78" class="pw-post-body-paragraph kb kc iq ke b kf ly kh ki kj lz kl km ma mb kp kq mc md kt ku me mf kx ky kz ij bi translated">为了将我们用Typescript(或FORTRAN)编写的编程语言语句转换成芯片中的实际机器语言操作符，必须进行一些翻译。这个翻译步骤被称为<strong class="ke ir">编译</strong>，完成这项工作的软件被称为<a class="ae mu" href="https://en.wikipedia.org/wiki/Compiler" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">编译器</strong> </a>。不管我们写什么语言或者什么时候引入代码，这个编译步骤都必须发生。</p><p id="86f1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">一些语言提供了一种特殊类型的编译器，称为<a class="ae mu" href="https://en.wikipedia.org/wiki/Interpreter_(computing)" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">解释器</strong> </a>。解释器不是等到整个程序都写好了，而是在输入时编译每一行代码。解释器的优点是程序员不需要等到程序完成才能看到结果。缺点是，只有传统的编译器可以将程序作为一个整体来检查，以便通过选择最短或最快的机器指令来进一步优化程序，从而给出程序中指示的结果。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/138dea205e07ddfcd4b3841daaae6c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RhTaVh4-oFsCgywU.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">麻省理工学院的<a class="ae mu" href="https://scratch.mit.edu/" rel="noopener ugc nofollow" target="_blank"> <strong class="bd lc"> Scratch </strong> </a>环境旨在通过使用非常类似于大型Trak或其他物理设备的按钮按钮来教授编程。每个彩色的<strong class="bd lc">块</strong>代表一个操作，<strong class="bd lc">圆圈</strong>中的白色值是它必须处理的数据。Scratch主要用于游戏编程，它抽象出了设计用户界面的大部分工作——这限制了它可以创建的用户界面的类型。</figcaption></figure><p id="38b4" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">缺乏从上到下对整个程序的了解，解释者通常不能提供这种优化——因此我们熟悉的大多数程序，如Microsoft Word或Photoshop都是编译的。然而实际上，现代的解释器已经被证明几乎和编译器一样快。</p><p id="a9db" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">JavaScript及其未来的表亲Typescript是运行在浏览器中的解释型语言，如Chrome、Safari或Firefox。每次打开浏览器窗口时，都会有一个JavaScript解释器，它有自己的语言语句集，允许我们处理内存和存储中的数据。我们将利用这种环境来学习编程。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/bf29e952343324102ea34d6f4b0e0c97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n7-zdmRiOLRNiM0f_BzQSQ.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">优秀的微软<a class="ae mu" href="https://www.microsoft.com/en-us/makecode" rel="noopener ugc nofollow" target="_blank"> <strong class="bd lc"> MakeCode </strong> </a>平台也可以用blocks编程——或者用Typescript！这些程序可以针对许多有趣的<a class="ae mu" href="https://arcade.makecode.com/hardware" rel="noopener ugc nofollow" target="_blank">手持设备</a>以及小型电脑和网络浏览器——比如我的<a class="ae mu" href="https://arcade.makecode.com/59845-44370-91548-60605" rel="noopener ugc nofollow" target="_blank"> MathTown Alley </a>游戏。</figcaption></figure><h1 id="2a47" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">怎么了，医生？</h1><p id="2dee" class="pw-post-body-paragraph kb kc iq ke b kf ly kh ki kj lz kl km ma mb kp kq mc md kt ku me mf kx ky kz ij bi translated">在本系列的第一部分中，我们看了计算机如何存储数据和操作数据，注意到所有计算机都可以执行相同的基本操作。我们还看到了如何将计算机存储的一部分交给一个程序或一组指令来处理内存中的数据。这些想法共同构成了<a class="ae mu" href="https://en.wikipedia.org/wiki/Stored-program_computer" rel="noopener ugc nofollow" target="_blank">存储程序计算机</a>的基础。</p><p id="ad49" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">在第2部分中，我们将设置开发Typescript应用程序所需的工具，包括web服务器和IDE——并进行测试以确保我们可以在浏览器中看到我们的更改。我们还将看到如何使用控制台日志来帮助我们调试程序，而不仅仅是为了这个目的创建HTML输出。</p><p id="77a0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated">一如既往，感谢您的加入！</p><p id="f26c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km ma ko kp kq mc ks kt ku me kw kx ky kz ij bi translated"><em class="kd"> — D </em></p></div></div>    
</body>
</html>