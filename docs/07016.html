<html>
<head>
<title>How to Integrate Firebase Authentication with the Ktor Auth Feature</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将Firebase身份验证与Ktor身份验证功能集成在一起</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-integrate-firebase-authentication-with-ktors-auth-feature-dc2c3893a0cc?source=collection_archive---------7-----------------------#2021-01-19">https://levelup.gitconnected.com/how-to-integrate-firebase-authentication-with-ktors-auth-feature-dc2c3893a0cc?source=collection_archive---------7-----------------------#2021-01-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="086f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么不让专家来处理你的用户管理呢？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cb981b59f4bc7f10f65ec551763f5330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IkqZ2kEnDdW40WfN07K5tg.jpeg"/></div></div></figure><p id="ccb3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你像我一样，当开发一个应用程序时，你知道安全需要是优先考虑的；您还知道，开发一个足以抵御当今攻击的可靠身份验证系统需要深入的安全知识。这就是为什么通常最好让专家来开发这类系统——像谷歌的那些专家已经构建了<a class="ae ln" href="https://firebase.google.com/docs/auth" rel="noopener ugc nofollow" target="_blank"> Firebase的认证</a>系统，该系统对于大多数中小型应用程序来说都易于实现和维护……无论它们是web还是移动应用程序。</p><p id="a5e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我是Kotlin编程语言的超级粉丝，所以我最近开始使用开源的Jetbrains开发框架<a class="ae ln" href="https://ktor.io/" rel="noopener ugc nofollow" target="_blank"> Ktor </a>构建后端应用程序。在本文中，我将向您展示如何将Firebase身份验证与Ktor框架已经提供的Auth特性集成在一起。</p><p id="a779" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们都知道，重新创建轮子通常只是浪费开发人员的时间，所以我使用当前的<a class="ae ln" href="https://github.com/ktorio/ktor/tree/master/ktor-features/ktor-auth-jwt" rel="noopener ugc nofollow" target="_blank"> JWT功能</a>代码作为起点，并编辑它以使用Firebase而不是自定义的JWT实现，所以我必须感谢Jetbrains的出色开发人员，他们编写了原始代码……谢谢大家！:)</p><p id="fb10" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文假设您对Ktor框架有基本的了解——如果您想学习更多的基础知识，网上有很多关于这些主题的教程！最近刚入门的时候用了不少。</p><p id="2db2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们将使用IntelliJ IDEA Ktor插件创建一个新的Ktor项目。我们将选择我们想要使用的特性，并且我们将告诉插件我们想要使用Kotlin Gradle DSL。你可以选择如何处理内容协商，我用的是GSON。对于HTTPClient引擎，我使用的是Jetty，当然我们还需要勾选认证。我还勾选了通话记录，这样我就可以看到我呼叫了哪些端点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lo"><img src="../Images/607113ae66f15ddf5df50c7b73bfc979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XvBhWTD7dc2GEQpgWkfK8A.png"/></div></div></figure><p id="143a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦你完成选择功能，按照提示，直到你有一个初始化的项目。要完成Ktor安装，请用下面的文件替换当前的build.gradle.kts文件，并加载更改。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="c4a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们设置我们的Firebase项目，并为Firebase管理设置生成一个新的私钥。Firebase文档非常好，所以如果你不确定如何创建一个Firebase项目，点击<a class="ae ln" href="https://firebase.google.com/docs" rel="noopener ugc nofollow" target="_blank">这里</a>寻找答案。有了新项目后，导航到项目设置，然后导航到服务帐户。在那里，您可以单击“生成新的私钥”按钮。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lr"><img src="../Images/71535fb2b8b16ab1bd128a473eb78cb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*igOAQS6-y2_yh6XwhUcarw.png"/></div></div></figure><p id="a6d8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将下载一个json文件，然后将它放在项目的resources目录中，记住，如果您计划发布一个公共repo，请将它添加到您的。gitignore文件！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/6281886fadbbd07069dbf628de54fa24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iFivbhOB0ZeBc3lU6GPDvg.png"/></div></div></figure><p id="982d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">太好了，我们设置好了，可以开始看代码了:)</p><p id="10bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，让我们再添加几个Kotlin文件。从你的根目录，创建文件<code class="fe lt lu lv lw b">auth/firebase/FirebaseAuth.kt</code>，然后创建目标文件<code class="fe lt lu lv lw b">config/firebase/AuthConfig</code>和<code class="fe lt lu lv lw b">config/firebase/FirebaseAdmin</code>，最后创建数据类文件<code class="fe lt lu lv lw b">model/User</code>。完成后，你的文件夹结构应该如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lx"><img src="../Images/3b81c1ee745a14ba335c0a2ba38984d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w-9KrcXsISnSbxOrJbaAGw.png"/></div></div></figure><p id="774f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们从Firebase管理代码开始。在<code class="fe lt lu lv lw b">FirebaseAdmin</code>文件中粘贴下面的代码(记得把json文件的名字改成你下载的那个)，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="ba10" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后在您的<code class="fe lt lu lv lw b">Application.kt</code>文件中的特性安装代码上方添加一行<code class="fe lt lu lv lw b">FirebaseAdmin.init()</code>。这将使用您下载的凭证来初始化您的Firebase应用程序。</p><p id="4048" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来将下面的代码添加到您的<code class="fe lt lu lv lw b">FirebaseAuth.kt</code>文件中，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="a574" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的代码提供了一个<code class="fe lt lu lv lw b">AuthenticationProvider</code>，然后用嵌套的<code class="fe lt lu lv lw b">Configuration</code>类构建它。这个配置类提供对令牌和lambda函数(我们将在后面设置)的访问，以提供<code class="fe lt lu lv lw b">Principle</code>(即<code class="fe lt lu lv lw b">User</code>)。</p><p id="cabf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来我们有了<code class="fe lt lu lv lw b">Authentication.Configuration.firebase</code>扩展函数，它将为我们做所有的实际工作。这里我们构建了<code class="fe lt lu lv lw b">AuthenticationProvider</code>，然后我们用它来设置一个拦截器；在这个拦截器中，我们获取令牌并检查令牌是否有效。最后，我们调用lambda来获取我们的<code class="fe lt lu lv lw b">Principle</code>，当然，我们在try/catch中这样做，以便我们可以捕捉和处理任何可能发生的错误。</p><p id="224e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们转到<code class="fe lt lu lv lw b">AuthConfig</code>和<code class="fe lt lu lv lw b">User</code>文件。<code class="fe lt lu lv lw b">AuthConfig</code>将为我们的<code class="fe lt lu lv lw b">Configuration</code>提供lambda函数，这样我们就可以获取我们的<code class="fe lt lu lv lw b">Principle</code>并且<code class="fe lt lu lv lw b">User</code>文件将成为我们的数据模型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="cd1a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，我们上面的<code class="fe lt lu lv lw b">User</code>数据类实现了<code class="fe lt lu lv lw b">Principle</code>接口。这是因为我们的<code class="fe lt lu lv lw b">Configuration</code>期待那种类型。一旦添加了<code class="fe lt lu lv lw b">User</code>数据类代码，将下面的代码添加到您的<code class="fe lt lu lv lw b">AuthConfig</code>文件中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="72ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的代码为我们的<code class="fe lt lu lv lw b">Configuration</code>类提供了一个扩展函数，正如我前面提到的，它提供了lambda来获取我们的<code class="fe lt lu lv lw b">Principle</code>。最后，我们将编辑我们的<code class="fe lt lu lv lw b">Application.kt</code>文件，以使用我们添加的所有代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="e39a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码中，你可以看到当安装了<code class="fe lt lu lv lw b">Authentication</code>特性时，我们使用了我们的<code class="fe lt lu lv lw b">firebase</code>扩展函数，并把我们的<code class="fe lt lu lv lw b">configure</code>扩展函数交给了它。现在，当我们对经过身份验证的端点进行任何调用时，我们的应用程序将在请求头中查找令牌，如果找到，令牌将被验证，最后我们的<code class="fe lt lu lv lw b">User</code>数据将被添加到调用中，并可以通过调用<code class="fe lt lu lv lw b">call.principle&lt;User&gt;()</code>进行检索。</p><p id="c10a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了所有这些，我们现在可以在前端注册/登录Firebase，并在对后端进行安全调用时获得一个不记名令牌。我们可以让Firebase负责诸如刷新令牌、发送电子邮件地址验证电子邮件以及更新用户的电子邮件或密码之类的事情。</p><p id="c253" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这是有用的:)如果你想要完整的项目代码，可以在我的GitHub:<a class="ae ln" href="https://github.com/Yukigeshiki/ktor-firebase-auth" rel="noopener ugc nofollow" target="_blank">https://github.com/Yukigeshiki/ktor-firebase-auth</a>上找到，如果你发现任何可以改进的地方，请在评论中告诉我！</p></div></div>    
</body>
</html>