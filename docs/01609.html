<html>
<head>
<title>Demystifying Scala Eager Lazy Memoized — How Cats Eval Can Save Your Recursive Stack From Overflowing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开Scala Eager Lazy Memoized的神秘面纱Cats Eval如何避免递归堆栈溢出</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/demystified-scala-eager-lazy-memoized-how-cats-eval-can-safe-your-recursive-stack-for-overflowing-b919c2c16b4a?source=collection_archive---------16-----------------------#2020-01-15">https://levelup.gitconnected.com/demystified-scala-eager-lazy-memoized-how-cats-eval-can-safe-your-recursive-stack-for-overflowing-b919c2c16b4a?source=collection_archive---------16-----------------------#2020-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/93eac39b85ffe3184fe5621e9a260f25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8HHgL1DxK5aq6rPX.png"/></div></div></figure><p id="5c4d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在学习了越来越多的函数式编程之后，我们通常在Java、JavaScript和其他命令式语言中进行的许多操作都是递归实现的。</p><p id="ad7a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">围绕不变性编写代码有一些优点和缺点——你会更多地考虑<a class="ae kz" href="https://www.quora.com/How-can-I-learn-to-think-like-a-functional-programmer" rel="noopener ugc nofollow" target="_blank">功能性</a>。</p><p id="b84e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Scala中，递归通常是通过底层的堆栈来实现的。对于您所做的大多数操作，递归工作得很好。但是，如果您想要同步处理大量数据(这需要循环处理数据以转换到另一个数据),它可能会破坏您的堆栈并导致堆栈溢出。</p><p id="7be7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了对一个庞大的数据集进行函数式编程，您将如何推迟这种情况？</p><p id="ff89" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">答案是使用<a class="ae kz" href="https://typelevel.org/cats/datatypes/eval.html" rel="noopener ugc nofollow" target="_blank"> Eval </a>。它是一种用于控制同步数据评估的cats数据类型。</p><p id="fde3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们开始之前，让我告诉你一点关于Scala修饰符的三种机制，以及如何利用它们来优化应用程序的性能。</p><h1 id="d344" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是渴望？</h1><p id="c370" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">当你声明一个计算时，急切的计算发生了，它立刻唤起它。例如，Scala中的<code class="fe md me mf mg b">val</code>在你声明它的时候会正确地调用计算内部的值。</p><h1 id="de9b" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是懒？</h1><p id="e8b9" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">懒惰计算是渴望的反义词。当你唤起它们时，它会唤起计算。例如，如果在Scala中定义了<code class="fe md me mf mg b">def</code>,计算不会马上被调用。当你第二次调用这个函数时，它就会被调用。</p><h1 id="c104" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是记忆？</h1><p id="97c9" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">内存化的计算就像一个缓存，它存储了您对该计算的初始调用的结果，以便下次您调用该计算时，它可以从缓存中检索它。</p><p id="42dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，当你在Scala中声明一个<code class="fe md me mf mg b">val</code>时，当你再次检索计算时，它将会记忆它。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="aa39" class="mp lb it mg b gy mq mr l ms mt">val x = {<br/>  println(s"hi, I am eager and memoized!")<br/>  math.random<br/>}<br/>// hi, I am eage and memoized!<br/>// x: Double = 0.09227668662578081<br/><br/><br/>// first access <br/>x<br/>// res0: Double = 0.09227668662578081<br/><br/>// second access<br/>x<br/>// res1: Double = 0.09227668662578081</span></pre><h1 id="3d6f" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">作为单子求值</h1><p id="2eaf" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">猫<code class="fe md me mf mg b">Eval</code>有三种类型:<code class="fe md me mf mg b">now</code>、<code class="fe md me mf mg b">always</code>、<code class="fe md me mf mg b">later</code>，表现与评估的<code class="fe md me mf mg b">scala</code>型号相同。</p><p id="cab4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">像这样导入和定义构造函数参数的方式，创建了一个<code class="fe md me mf mg b">eval</code>类型的实例:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="47b3" class="mp lb it mg b gy mq mr l ms mt">import cats.Eval<br/>val now = Eval.now(math.random + 1000) // this will evaluate right away<br/>val always = Eval.always(math.random + 2000)<br/>val later = Eval.later(math.random + 3000)</span></pre><p id="b3df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以通过调用<code class="fe md me mf mg b">value</code>方法来提取您创建的<code class="fe md me mf mg b">Eval</code>实例的结果。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="0db3" class="mp lb it mg b gy mq mr l ms mt">now.value</span></pre><p id="a8ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe md me mf mg b">Eval.now</code>相当于<code class="fe md me mf mg b">val</code>——是渴望，是记忆。<code class="fe md me mf mg b">Eval.always</code>相当于<code class="fe md me mf mg b">def</code>——它懒惰，不被记忆。<code class="fe md me mf mg b">Eval.later</code>相当于<code class="fe md me mf mg b">lazy</code>——是懒，是记忆。</p><p id="e5d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">知道了这一点，就可以通过<code class="fe md me mf mg b">Eval</code>构造<code class="fe md me mf mg b">map</code>和<code class="fe md me mf mg b">flatMap</code>，因为它是一个<a class="ae kz" href="https://en.wikipedia.org/wiki/Monad_(functional_programming)" rel="noopener ugc nofollow" target="_blank">单子</a>。</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="cf0f" class="mp lb it mg b gy mq mr l ms mt">val greetings = for {<br/>  hi &lt;- Eval.now {<br/>      println("hi is evoke.")<br/>      s"hi with random math : $math.random"<br/>    }<br/>  world &lt;- Eval.always {<br/>      println("always is evoke.")<br/>      "world -- $math.random"<br/>  }<br/>} yield hi + world<br/><br/>// first access, which one gets evoke? What will the value?<br/>greetings.value<br/><br/>// second access, which one gets evoke what will the value?<br/>greetings.value</span></pre><p id="21b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的代码中，<code class="fe md me mf mg b">Eval.now</code>首先被打印和计算。然而，第一次访问和附加访问时，<code class="fe md me mf mg b">world</code>被评估，并转到<code class="fe md me mf mg b">yield</code>部分评估<code class="fe md me mf mg b">hi+world</code>。</p><p id="1222" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Eval有一个<code class="fe md me mf mg b">memoize</code>功能，能够记忆所有的计算结果。让我给你举个例子:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="2395" class="mp lb it mg b gy mq mr l ms mt">val x = Eval.always{println("First step")}<br/>          .map(_ =&gt; println("Second Step"))<br/>          .memoize<br/>          .map(_ =&gt;  println("Third Step"))<br/>          <br/>// first access<br/>x.value<br/>// First Step<br/>// Second Step<br/>// Third Step<br/><br/>// second access <br/>x.value<br/>// Third Step</span></pre><p id="2036" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">外卖</strong>注意:如果你有一个只有一步连续变化的计算序列，你可以在计算中记忆它以提高它的性能。</p><p id="e1b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通常我们在用数字计算递归调用时，会遇到<code class="fe md me mf mg b">stack-overflow</code>。<code class="fe md me mf mg b">Eval.defer</code>可以帮助你从栈中延迟计算，并把它们存储在堆中，这样你就可以递归地计算大量的计算。</p><p id="8659" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">阶乘的简单示例:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="0215" class="mp lb it mg b gy mq mr l ms mt">def factorial(x:BigInt) : BigInt = if(x == 0) {<br/>  1<br/>} else {<br/>  factorial(x-1) * x<br/>}<br/><br/>factorial(500000) // this will blow up your stack</span></pre><p id="4bae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">稍微改变一下<code class="fe md me mf mg b">Eval</code>，你就可以计算出你的<code class="fe md me mf mg b">BigInt</code>阶乘</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="fa25" class="mp lb it mg b gy mq mr l ms mt">def factorialEval(x: BigInt): Eval[BigInt] = if(x == 0) {<br/>  Eval.now(1)<br/>} else {<br/>  Eval.defer(factorialEval(x-1).map(_ * x))<br/>}<br/><br/>// incorporate in your original factorial method<br/>def factorial(x:BigInt):BigInt = factorialEval(x).value</span></pre><h1 id="4989" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">一个练习项目:</h1><p id="a827" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">能不能把foldRight转换成Eval？</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="3808" class="mp lb it mg b gy mq mr l ms mt">def foldRight[A,B](as:List[A], acc:B)(fn:(A,B) =&gt; B):B = as match {<br/>  case head::tail =&gt;<br/>    fn(head, foldRight(tail,acc)(fn))<br/>  case Nil =&gt;<br/>    acc<br/>}</span></pre><h1 id="33bc" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">主要外卖:</h1><ul class=""><li id="9d5b" class="mu mv it kd b ke ly ki lz km mw kq mx ku my ky mz na nb nc bi translated">计算有三个术语——渴望、懒惰、记忆</li><li id="8ed6" class="mu mv it kd b ke nd ki ne km nf kq ng ku nh ky mz na nb nc bi translated">Eval和Scala有相同的3个术语——eval . now，Eval.always，Eval.later</li><li id="ee67" class="mu mv it kd b ke nd ki ne km nf kq ng ku nh ky mz na nb nc bi translated">您可以记忆您的计算序列，还可以使用Eval创建(几乎完全)无堆栈计算，以优化您对大量数据和数据结构的计算。</li></ul><h1 id="08b0" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">喜欢这篇文章？</h1><p id="247b" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">注册我的<a class="ae kz" href="https://edward-huang.com/subscribe/" rel="noopener ugc nofollow" target="_blank">简讯</a>每周获取此内容！</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="9fde" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np">最初发表于</em><a class="ae kz" href="https://edward-huang.com/tech/scala/programming/functional-programming/2020/01/12/demystified-scala-eager-lazy-memoized-how-cats-eval-can-safe-your-recursive-stack-for-overflowing/" rel="noopener ugc nofollow" target="_blank"><em class="np">https://edward-huang.com</em></a><em class="np">。</em></p></div></div>    
</body>
</html>