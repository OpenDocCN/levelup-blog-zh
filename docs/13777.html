<html>
<head>
<title>Advanced Python: Decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级Python:decorator</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/advanced-python-decorators-d00359a869a2?source=collection_archive---------12-----------------------#2022-10-04">https://levelup.gitconnected.com/advanced-python-decorators-d00359a869a2?source=collection_archive---------12-----------------------#2022-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3271" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章将展示我们如何有效地使用python decorators。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/13f95d64bf7a176cc389993ad562b129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eoth4qMISIZ4crib8VX82A.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">由<a class="ae lb" href="https://unsplash.com/@artturijalli?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Artturi Jalli </a>在<a class="ae lb" href="https://unsplash.com/s/photos/python?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="3e7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Python中的Decorators是一种强大的设计模式，它允许我们在不修改Python对象的现有结构的情况下应用新的功能。正如我们在本系列的第一篇文章中看到的，我们可以将类作为参数传递，或者它可以从函数中返回，比如Python函数也是一等公民，我们也可以对函数执行所有这些操作。</p><h1 id="4f10" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">到目前为止，这个系列</h1><ul class=""><li id="b58d" class="ma mb iq jp b jq mc ju md jy me kc mf kg mg kk mh mi mj mk bi translated"><a class="ae lb" href="https://python.plainenglish.io/advanced-python-classes-objects-and-mro-423bb01521fb" rel="noopener ugc nofollow" target="_blank"> Python类、对象和MRO </a></li><li id="c6ff" class="ma mb iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/advanced-python-dataclasses-6a1e53bc4d8d">数据类</a></li><li id="5503" class="ma mb iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">装修工(此职位)</li></ul><h1 id="95a6" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">深入探讨Python函数</h1><p id="a881" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">在我们理解什么是装饰器之前，我们需要了解更多关于python函数及其工作原理的知识。</p><pre class="km kn ko kp gt mt mu mv mw aw mx bi"><span id="2bff" class="my ld iq mu b gy mz na l nb nc"><strong class="mu ir">&gt;&gt;&gt; def print_hello(name: str) -&gt; None:<br/>...     print("Hello " + name)<br/>...<br/>&gt;&gt;&gt; print_hello("Spiderman")<br/>Hello Spiderman<br/>&gt;&gt;&gt;</strong></span></pre><p id="7450" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，我们可以看到函数<code class="fe nd ne nf mu b"><strong class="jp ir">print_hello()</strong></code>打印了“Hello &lt; input &gt;”，其中<em class="ng"> input </em>是我们传递给函数的参数，最终它没有返回任何值(因为我们没有返回任何值)。</p><blockquote class="nh ni nj"><p id="c7da" class="jn jo ng jp b jq jr js jt ju jv jw jx nk jz ka kb nl kd ke kf nm kh ki kj kk ij bi translated">有一个叫做副作用的概念，它基本上意味着如果一个函数改变了它的函数定义之外的任何东西，比如改变已经传递的参数的值，改变一个全局变量的值，或者在stdout中打印一些东西。在这种情况下，我们的函数不返回任何东西，但是它在stdout中打印，所以它有副作用。</p></blockquote><h2 id="aff6" class="my ld iq bd le nn no dn li np nq dp lm jy nr ns lq kc nt nu lu kg nv nw ly nx bi translated">Python函数也是对象:一级对象</h2><p id="c893" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">正如我在上一篇文章中提到的，python函数也是对象，<a class="ae lb" href="https://stackoverflow.com/questions/245192/what-are-first-class-objects" rel="noopener ugc nofollow" target="_blank">一级对象</a>，这意味着在python中，我们可以像使用任何其他对象(int、float、string、list、tuple等)一样使用函数。)我们可以将它们作为参数传递给另一个函数，或者可以作为值返回。</p><pre class="km kn ko kp gt mt mu mv mw aw mx bi"><span id="b6dd" class="my ld iq mu b gy mz na l nb nc"><strong class="mu ir">def greet(func: callable):<br/>    print(func.__name__)<br/>greet(print_hello) </strong></span><span id="893d" class="my ld iq mu b gy ny na l nb nc">-------output------------<br/><strong class="mu ir">print_hello</strong></span></pre><p id="8ba9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的函数中，我们基本上是传递另一个函数作为它的参数，然后只打印它的名字。我们也可以这样做，</p><pre class="km kn ko kp gt mt mu mv mw aw mx bi"><span id="4762" class="my ld iq mu b gy mz na l nb nc"><strong class="mu ir">def print_hello(name:str) -&gt; None:<br/>    print('Hello ' + name)<br/><br/>def greet(func: callable) -&gt; None:<br/>    func("Thor")<br/><br/>greet(print_hello)</strong></span><span id="8df8" class="my ld iq mu b gy ny na l nb nc">------------output--------------<br/><strong class="mu ir">Hello Thor</strong></span></pre><p id="fccc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我们没有在<code class="fe nd ne nf mu b"><strong class="jp ir">print_hello</strong></code>后面使用<code class="fe nd ne nf mu b"><strong class="jp ir">()</strong></code>，因为我们不想执行它，我们想传递函数，在<code class="fe nd ne nf mu b"><strong class="jp ir">greet</strong></code>内部，我们实际上正在调用函数。所以基本上我们将<code class="fe nd ne nf mu b"><strong class="jp ir">print_hello</strong></code>作为参数传递给另一个函数，就像任何其他对象一样。</p><p id="ee9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们也可以从其他函数返回函数。</p><pre class="km kn ko kp gt mt mu mv mw aw mx bi"><span id="50aa" class="my ld iq mu b gy mz na l nb nc"><strong class="mu ir">def talk(name: str) -&gt; Callable[[], None]:<br/>    def greet() -&gt; None:<br/>        print("Hi " + name)<br/>    <br/>    #Notice no () here<br/>    return greet </strong></span><span id="f58d" class="my ld iq mu b gy ny na l nb nc"><strong class="mu ir">f = talk("Batman")<br/>print(f)<br/>f()</strong></span><span id="9d90" class="my ld iq mu b gy ny na l nb nc">----------output----------<br/><strong class="mu ir">&lt;function talk.&lt;locals&gt;.greet at 0x000001BBCB7CB5B0&gt;<br/>Hi Batman</strong></span></pre><p id="39ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们不是将一个函数传递给另一个函数，而是从<code class="fe nd ne nf mu b"><strong class="jp ir">talk()</strong></code>接收另一个函数，然后执行它，最后打印<code class="fe nd ne nf mu b"><strong class="jp ir">Hi Batman</strong></code>。</p><h2 id="1aa0" class="my ld iq bd le nn no dn li np nq dp lm jy nr ns lq kc nt nu lu kg nv nw ly nx bi translated">内部函数</h2><p id="bada" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">我们也可以在一个函数中定义另一个函数。</p><pre class="km kn ko kp gt mt mu mv mw aw mx bi"><span id="195d" class="my ld iq mu b gy mz na l nb nc"><strong class="mu ir">def outer_func() -&gt; ():<br/>    message = 'Hi'<br/><br/>    def inner_func():<br/>        print(message)<br/><br/>    return inner_func<br/><br/>outer_func()() # try with single () and see what happens!</strong></span><span id="de97" class="my ld iq mu b gy ny na l nb nc">-------output----------<br/><strong class="mu ir">Hi</strong></span></pre><p id="feca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们可以调用<code class="fe nd ne nf mu b"><strong class="jp ir">outer_func()</strong></code>,但是我们不能显式调用<code class="fe nd ne nf mu b"><strong class="jp ir">inner_func()</strong></code>,也不能访问该函数中声明的任何变量。</p><h1 id="8e5c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">装修工</h1><p id="3924" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">现在我们已经修改了关于python函数的重要概念，我们终于可以进入我们的主题了，Python装饰者。装饰器是返回可调用对象的可调用对象。基本上，装饰者接受一个函数，添加一些功能，然后返回它。</p><p id="5387" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们创建一个简单的装饰器。</p><p id="3a7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要创建一个在函数内部的包装器，它看起来类似于上面的函数，一个函数在另一个函数内部。</p><pre class="km kn ko kp gt mt mu mv mw aw mx bi"><span id="a209" class="my ld iq mu b gy mz na l nb nc"><strong class="mu ir">def my_decorator(func):<br/>    def wrapper():<br/>        print("Inside wrapper()")<br/>        func()<br/>    return wrapper</strong></span></pre><p id="0953" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们取一个函数作为<code class="fe nd ne nf mu b"><strong class="jp ir">my_decorator()</strong></code> <strong class="jp ir"> </strong>函数的自变量。在<code class="fe nd ne nf mu b"><strong class="jp ir">my_decorator()</strong></code> <strong class="jp ir"> </strong>中，我们定义了另一个函数，它将执行传递的函数。现在要使用这个装饰器，我们需要创建另一个函数，把它赋给一个变量，并把它赋给<code class="fe nd ne nf mu b"><strong class="jp ir">my_decorator().</strong></code></p><pre class="km kn ko kp gt mt mu mv mw aw mx bi"><span id="9e2c" class="my ld iq mu b gy mz na l nb nc"><strong class="mu ir">def say_something():<br/>    print("Hi!")<br/><br/>talk = my_decorator(say_something)<br/>talk()</strong></span><span id="90f9" class="my ld iq mu b gy ny na l nb nc">-------output----------<br/>Inside wrapper()<br/>Hi!</span></pre><p id="d5d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里到底发生了什么？</p><p id="391c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上，我们是用<strong class="jp ir"> </strong> <code class="fe nd ne nf mu b"><strong class="jp ir">my_decorator()</strong></code>来修饰<code class="fe nd ne nf mu b"><strong class="jp ir">say_something()</strong></code> <strong class="jp ir"> </strong>，然后将返回的函数保存为<strong class="jp ir"> </strong> <code class="fe nd ne nf mu b"><strong class="jp ir">talk,</strong></code>，但一般情况下，我们会将返回的函数名与原函数保持一致，即<code class="fe nd ne nf mu b"><strong class="jp ir">say_something()</strong></code></p><p id="106d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了便于使用，我们有一个选项来重写整个事情如下。</p><pre class="km kn ko kp gt mt mu mv mw aw mx bi"><span id="fc5f" class="my ld iq mu b gy mz na l nb nc">@<strong class="mu ir">my_decorator<br/>def say_something():<br/>    print("Hi!")</strong><br/><br/><strong class="mu ir">say_something()</strong></span><span id="212e" class="my ld iq mu b gy ny na l nb nc">-------output----------<br/>Inside wrapper()<br/>Hi!</span></pre><p id="ef9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出保持不变。</p><h2 id="a988" class="my ld iq bd le nn no dn li np nq dp lm jy nr ns lq kc nt nu lu kg nv nw ly nx bi translated">有争论的装饰者</h2><p id="5332" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">现在你可能会想，我们可以在任何函数中使用这个装饰器，但这不是真的，如果你的装饰器不能处理传递给被装饰函数的参数，那么它肯定会失败，正如你在下面看到的。</p><pre class="km kn ko kp gt mt mu mv mw aw mx bi"><span id="3e8b" class="my ld iq mu b gy mz na l nb nc">@<strong class="mu ir">my_decorator<br/>def say_something(name: str):<br/>    print(f"Hi {name}!")</strong><br/><br/><strong class="mu ir">say_something("Iron man")</strong></span><span id="bdff" class="my ld iq mu b gy ny na l nb nc">-------output----------<strong class="mu ir"><br/></strong>Traceback (most recent call last):<br/>  File "C:\Users\SANDIPAN DUTTA\PycharmProjects\decorators\Decorators.py", line 69, in &lt;module&gt;<br/>    say_something("Iron man")<br/>TypeError: my_decorator.&lt;locals&gt;.wrapper() takes 0 positional arguments but 1 was given</span></pre><p id="fa35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为内部函数<code class="fe nd ne nf mu b"><strong class="jp ir">wrapper()</strong></code> <strong class="jp ir"> </strong>不带任何参数。为了克服这一点，我们可以使用<code class="fe nd ne nf mu b"><strong class="jp ir">*args</strong></code>和<code class="fe nd ne nf mu b"><strong class="jp ir">**kwargs</strong></code> <strong class="jp ir"> </strong>，这样它可以接受任意数量的参数。</p><pre class="km kn ko kp gt mt mu mv mw aw mx bi"><span id="31a3" class="my ld iq mu b gy mz na l nb nc"><strong class="mu ir">def my_decorator(func):<br/>    def wrapper(</strong><strong class="mu ir">*args, **kwargs</strong><strong class="mu ir">):<br/>        print("Inside wrapper()")<br/>        func(</strong><strong class="mu ir">*args, **kwargs</strong><strong class="mu ir">)<br/>    return wrapper</strong></span><span id="9c6b" class="my ld iq mu b gy ny na l nb nc"><strong class="mu ir">@my_decorator<br/>def greet(name: str):<br/>    print(f"Hi {name}!")<br/><br/>greet("Iron man")</strong></span><span id="66a8" class="my ld iq mu b gy ny na l nb nc">-------output----------<br/>Inside wrapper()<br/>Hi Iron man!</span></pre><p id="1527" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有一个问题，在当前的方法中，修饰函数的返回值将被忽略。</p><pre class="km kn ko kp gt mt mu mv mw aw mx bi"><span id="cffe" class="my ld iq mu b gy mz na l nb nc"><strong class="mu ir">@my_decorator<br/>def greet(name: str):<br/>    return f"Hi {name}!"<br/><br/>var = greet("Iron man")<br/>print(var)</strong></span><span id="fa5f" class="my ld iq mu b gy ny na l nb nc">-------output----------<br/>Inside wrapper()<br/>None</span></pre><p id="9f94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为<code class="fe nd ne nf mu b"><strong class="jp ir">wrapper()</strong></code>实际上并没有返回任何东西，为了完成这项工作，我们需要返回修饰函数的值。</p><pre class="km kn ko kp gt mt mu mv mw aw mx bi"><span id="527e" class="my ld iq mu b gy mz na l nb nc"><strong class="mu ir">def my_decorator(func):<br/>    def wrapper(*args, **kwargs):<br/>        print("Inside wrapper()")<br/>        return func(*args, **kwargs)<br/>    return wrapper<br/><br/>@my_decorator<br/>def greet(name: str):<br/>    return f"Hi {name}!"<br/><br/>var = greet("Iron man")<br/>print(var)</strong></span><span id="d03f" class="my ld iq mu b gy ny na l nb nc">-------output----------<br/>Inside wrapper()<br/>Hi Iron man!</span></pre><h2 id="bb8b" class="my ld iq bd le nn no dn li np nq dp lm jy nr ns lq kc nt nu lu kg nv nw ly nx bi translated">真实世界的例子</h2><p id="0ea2" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">这是一个decorator的例子，它决定用户是登录还是使用会话登录flask应用程序。</p><pre class="km kn ko kp gt mt mu mv mw aw mx bi"><span id="34b9" class="my ld iq mu b gy mz na l nb nc"><strong class="mu ir">def login_required(f):<br/>    @wraps(f)<br/>    def wrap(*args, **kwargs):<br/>        if 'logged_in' in session:<br/>            return f(*args, **kwargs)<br/>        else:<br/>            flash("You need to login first")<br/>            return redirect(url_for('login_page'))<br/><br/>    return wrap<br/><br/><br/>@app.route("/logout/")<br/>@login_required<br/>def logout():<br/>    session.clear()<br/>    flash("You have been logged out!")<br/>    gc.collect()<br/>    return redirect(url_for('dashboard'))</strong></span></pre><h1 id="cebc" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="b203" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">在本教程中，我们学习了如何为我们自己的定制需求创建一个python装饰器。在下一篇文章中，我们将学习元类。下一集见。</p></div></div>    
</body>
</html>