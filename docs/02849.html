<html>
<head>
<title>A universal connection pool written in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个用C++写的通用连接池</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-universal-connection-pool-written-in-c-6f4f14a98a9e?source=collection_archive---------10-----------------------#2020-04-07">https://levelup.gitconnected.com/a-universal-connection-pool-written-in-c-6f4f14a98a9e?source=collection_archive---------10-----------------------#2020-04-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="032a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">能有多难？我只是想要一个到远程服务的简单连接。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/d9d5499bbb503761f1d78b08dfc377c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R606w52jzupI7mPHBY4k5Q.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">照片由<a class="ae lc" href="https://www.pexels.com/de-de/@christian-paul-del-rosario-230539?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">克里斯蒂安·保罗·德尔·罗萨里奥</a>通过<a class="ae lc" href="https://www.pexels.com/de-de/foto/badeort-batanen-baume-entspannung-732499/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a>拍摄</figcaption></figure><p id="5a10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi ld translated">几周前，这是我最初的想法。当时，我手头的问题需要一个到PostgreSQL数据库的可靠连接，以及到一个代理API和几个其他金融数据提供者的稳定连接。很快，我想出了一些相当明显的要求，这些要求更好地定义了“无脑”:</p><ul class=""><li id="9c97" class="lm ln iq jp b jq jr ju jv jy lo kc lp kg lq kk lr ls lt lu bi translated">该池必须保持一定数量的随时可用的连接</li><li id="0da7" class="lm ln iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">该池的用途应该是通用的</li><li id="5a14" class="lm ln iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">不知何故，我想利用RAII，因为编译器可以生成比我更好的代码</li></ul><h2 id="463e" class="ma mb iq bd mc md me dn mf mg mh dp mi jy mj mk ml kc mm mn mo kg mp mq mr ms bi translated">人脉就是一切</h2><p id="6eac" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">通常连接池有一个非常相似的使用流程。存在池的实例，例如作为类的成员。实际使用连接的代码从该池中获取一个连接，完成后，它会将该连接返回到该池。该池向使用代码保证，在连接安全返回之前，它不会向任何其他调用方提供相同的连接。这就叫<strong class="jp ir">移动语义</strong>。<br/>还有两个对池的调用，即获取和返回连接，允许池快速检查连接。如果连接以某种方式中断，这将使池能够重新连接。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi my"><img src="../Images/3980dff1bcec38feff437311b2677e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SxGcZgQ_-u1VNVCf4NUCoQ.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">连接池通常所在的上下文</figcaption></figure><p id="1323" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果连接在一定时间内没有被使用，许多远程API就会断开连接。这要求客户端向远程API发送心跳，例如虚拟请求，以维持正常的连接。最后，如果不再需要某个连接，就需要将其断开。这足以定义通用连接的接口。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">连接抽象基类</figcaption></figure><p id="c1fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我选择了继承而不是模板方法，因为对这些方法的调用可能会等待网络响应，因此无论如何比虚拟方法解析花费的时间要长得多。这样，我们可以明确地指定所有需要实现的方法。任何特定的连接，例如到PostgreSQL数据库的连接，都将从该类继承并实现所有纯虚函数。</p><h2 id="95f9" class="ma mb iq bd mc md me dn mf mg mh dp mi jy mj mk ml kc mm mn mo kg mp mq mr ms bi translated">它是你的还是我的</h2><p id="bac2" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">连接池在创建后拥有所有连接的唯一所有权。我们是否应该允许使用代码在使用连接时接管唯一或共享的所有权？来决定让我们收集几个选项。</p><ul class=""><li id="3406" class="lm ln iq jp b jq jr ju jv jy lo kc lp kg lq kk lr ls lt lu bi translated">将唯一所有权移动到使用代码(std::unique_ptr)</li><li id="44b1" class="lm ln iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">使用代码(std::weak_ptr或std::shared_ptr)共享所有权</li><li id="e0c5" class="lm ln iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">不要转移所有权(原始指针或引用)</li></ul><p id="7a0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RAII要求给出了一个提示，做什么。更重要的是，如果当池返回的连接访问对象超出范围时，连接自动返回，这不是很好吗？</p><blockquote class="nb nc nd"><p id="814f" class="jn jo kl jp b jq jr js jt ju jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj kk ij bi translated">R.1:使用资源句柄和RAII自动管理资源(资源获取是初始化)[ <a class="ae lc" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r1-manage-resources-automatically-using-resource-handles-and-raii-resource-acquisition-is-initialization" rel="noopener ugc nofollow" target="_blank"> C++核心指南</a> ]</p></blockquote><p id="cf6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们希望这样，我们必须删除原始指针或引用选项。std::*_ptr类提供了定义自定义删除器的方法，从理论上讲，它可以返回到池的连接。但为此，它至少需要一个对池的引用。这是可能做到的，但也许有另一个选择，有一个更简单的吸引力。更简单，因为它没有给众所周知的STL结构添加状态和副作用，这可能会使用户感到困惑。</p><p id="4833" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">认识一下ConnectionProxy。该池保持对其所有连接的唯一所有权，并向使用代码分发代理对象。那些代理对象应该是短暂的。因为它们不拥有任何连接，所以它们不能延长连接的生存期。这意味着池的寿命必须比任何连接代理都长。这反过来意味着，它们应该<strong class="jp ir">而不是</strong>存储在本地直接使用范围之外的任何地方。这实际上看起来更像是引用语义，我们之前已经排除了。</p><p id="043e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">连接在其用法上是排他的。这意味着我们需要在代理类中反映这一点。表达排他性的一个好工具是使用可移动的实例，在某种意义上，这就是std::unique_ptr所做的。在如下所示的代码中。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">ConnectionProxy</figcaption></figure><p id="fc39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，从代理对象移动后，它将保持默认状态，即成为一个空引用。</p><blockquote class="nb nc nd"><p id="b262" class="jn jo kl jp b jq jr js jt ju jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj kk ij bi translated">C.64:一个移动操作应该移动并让它的源处于有效状态[ <a class="ae lc" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c64-a-move-operation-should-move-and-leave-its-source-in-a-valid-state" rel="noopener ugc nofollow" target="_blank"> C++核心指南</a> ]</p></blockquote><h2 id="a370" class="ma mb iq bd mc md me dn mf mg mh dp mi jy mj mk ml kc mm mn mo kg mp mq mr ms bi translated">学习游泳</h2><p id="5423" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">大多数重要的决定都是由。现在我们可以开始设计实际的连接池了。连接池的哪种行为最小化了用户的认知负荷？为了理解这一点，让我们想出一些用户可能遇到的情况。</p><ul class=""><li id="9c24" class="lm ln iq jp b jq jr ju jv jy lo kc lp kg lq kk lr ls lt lu bi translated">当前连接开始使一些甚至所有查询失败</li><li id="50ad" class="lm ln iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">池已耗尽，无法向用户提供连接</li></ul><p id="a703" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果一个连接开始失败，我不想亲自尝试修复这个连接。池应该这样做，也就是说，使用代码应该将连接返回到池，并建立一个新的连接。使用代码有两种通信方式，即没有可用的连接。要么阻塞直到有空闲连接，要么立即返回，但不传递连接。我决定选择后者，因为我运行了一个主循环，可以在同时做一些其他工作后重试。您可以很容易地将重试循环移到池中，并使连接阻塞。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">连接池</figcaption></figure><p id="71b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于非阻塞行为，get_connection可能会返回无效的代理对象。使用代码必须检查代理是否有效。如果连接以任何特定于实现的方式抛出或失败，它需要被返回到池中。除此之外，记住不要存储连接代理，总是用一个新的来代替。<br/>作为回报，连接池自动执行(重新)连接、断开连接、健康检查和广播心跳。</p><p id="a0c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您在连接池声明中看到的，有一个方法调用所有连接的健康检查，另一个方法向所有空闲连接广播心跳。当前的实现不定期调用heart beat方法，相反，如果连接实现需要，用户可以从主循环或计时器中调用heart beat方法。</p><blockquote class="nb nc nd"><p id="0b7c" class="jn jo kl jp b jq jr js jt ju jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj kk ij bi translated">R.13:在单个表达式语句中最多执行一次显式资源分配[ <a class="ae lc" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r13-perform-at-most-one-explicit-resource-allocation-in-a-single-expression-statement" rel="noopener ugc nofollow" target="_blank"> C++核心指南</a> ]</p></blockquote><p id="8033" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为连接池不知道连接实现，所以它的构造函数接受一组连接实例。连接池的填充是由连接池工厂根据连接实现自动完成的。友好工厂类的模板专门化允许隐藏池的构造函数。</p><h2 id="1cf1" class="ma mb iq bd mc md me dn mf mg mh dp mi jy mj mk ml kc mm mn mo kg mp mq mr ms bi translated">学会飞翔</h2><p id="5123" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">这个连接池很简单，我目前使用它可靠地连接到PostgreSQL、几个有状态REST式API和一个相当老式的代理遗留API。有相当大的改进空间，例如，池可以具有不同于所有连接的最大数量的空闲连接的最大数量。另一个角度是均衡所有连接的负载，因为可能存在某种连接配额。</p><p id="0185" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您对完整的代码感兴趣，可以在GitHub上查看！</p><div class="nh ni gp gr nj nk"><a href="https://github.com/malikkirchner/connection-pool" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">malikkirchner/连接池</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">通用连接池。在GitHub上创建一个帐户，为malikkirchner/连接池的开发做出贡献。</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">github.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny kw nk"/></div></div></a></div></div></div>    
</body>
</html>