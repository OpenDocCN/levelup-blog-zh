<html>
<head>
<title>Open/Closed Principle and Backward Compatibility</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开放/封闭原则和向后兼容性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/open-closed-principle-and-backward-compatibility-cab2f462bc0f?source=collection_archive---------10-----------------------#2020-01-28">https://levelup.gitconnected.com/open-closed-principle-and-backward-compatibility-cab2f462bc0f?source=collection_archive---------10-----------------------#2020-01-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/433f55d6aec2e296ff3489b18a9ea369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VTTQMRvVRxdIYsRIEL5M8A.jpeg"/></div></div></figure><div class=""/><p id="a853" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">背景:</strong>网络、文章和书籍上已经有很多解释<a class="ae kw" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank"> S.O.L.I.D原则</a>和<a class="ae kw" href="https://www.oreilly.com/library/view/97-things-every/9780596809515/" rel="noopener ugc nofollow" target="_blank">编码最佳实践</a>的资源，但是我还是忍不住要分享一个我非常热爱的概念的简短例子，S.O.L.I.D原则和<a class="ae kw" href="https://en.wikipedia.org/wiki/Design_Patterns" rel="noopener ugc nofollow" target="_blank">设计模式</a>。因此，这是另一个开放/封闭原则的例子，它确实是我从一家银行接受的编码挑战面试的一部分，因此它显示了它的重要性——让我们一劳永逸地解决它。</p><p id="834c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">简介:</strong>原则声明一个类应该对扩展开放，但对修改关闭。当需求或规则经常改变或者至少可能改变时，这特别有帮助。遵循OCP将保护您的代码不受向后兼容性问题的影响。换句话说，如果新的需求必须由一个类来处理，那么就没有必要修改它，我们只需要为它引入一个子类，然后这个子类将独立地引入新的逻辑。很简单，现在我们想通过一个例子来更深入地了解这一点。</p><p id="d705" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">案例研究</strong>展示了如何处理一个支付请求，并注意财产<em class="kx">金额</em>的价值。这是关于有四个不同的网关<em class="kx">默认、常规、优先级和高级</em>——每个网关根据来自有效负载请求的金额值以不同的方式处理支付。下面是这些应该如何处理付款:</p><ul class=""><li id="cd62" class="ky kz jb ka b kb kc kf kg kj la kn lb kr lc kv ld le lf lg bi translated">默认值—1到50之间的值，服务成本为15%</li><li id="b4b5" class="ky kz jb ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">常规-值从50到100，服务成本为10%</li><li id="23ad" class="ky kz jb ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">优先级—值从100到300，服务成本为5%</li><li id="024f" class="ky kz jb ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">高级—价值超过300英镑，不考虑服务成本</li></ul><p id="f005" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简单但足够有趣，可以开始实现。首先，我们将看到如何简单地实现这个逻辑，然后我们如何使用OCP来保护我们的代码不受向后兼容性问题的影响。</p><p id="9780" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">天真的方法</strong></p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lm"><img src="../Images/e63c3993155c8fbb84178c217222a78a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EyzXK25R-OUjpa8uob0M_Q.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">图1 —对于大于300的值，有三个显式If和一个隐式If的简单方法</figcaption></figure><p id="0a5a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关注OCP的更好方法</p><p id="6b5b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在需要抽象出这些if语句，这样我们就可以停止用任何引入的新变化来修改代码，除此之外，我们还需要单独测试每个条件。请记住，在现实世界的例子中，这些条件可能比图1所示的更复杂、更长，这意味着我们需要有一个更好的策略来处理向后兼容性以及模块化编码实践。我们将通过以下步骤共同完成。</p><p id="0cb1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一步——我们创建一个接口，它将是我们上述功能的任何消费者的唯一接触点。这将为我们抽象出逻辑并将它们分开提供一个起点。</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lv"><img src="../Images/e4a5d9e60bee64079f37e6535b9567f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*te5ukkbWkEYibAlOd3M2nw.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">图2 —负责与客户端通信的接口</figcaption></figure><p id="8ccc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">步骤2——现在我们定义网关接口，它包含两个操作，一个是查看传入的请求是否符合标准，第二个操作是实际的支付处理器。</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lw"><img src="../Images/3095654543c84d87667f986099cacebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ErTtUMBge3uWAfeUxaHsg.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">图3-支付网关接口，通过Is匹配方法解析正确的支付处理器</figcaption></figure><p id="de7e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第3步——现在是时候实现前面提到的四个不同的网关了，每个网关都带有不同的金额值逻辑。</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lx"><img src="../Images/6bc68593e5c6c8852902336109618cba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E7oGc1I9OIn4MX9jx4-F7A.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">图4 —独立托管实际逻辑的支付网关(为<em class="ly">单元测试做好准备)</em></figcaption></figure><p id="e2e3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">步骤4——最后，支付处理器类负责处理来自请求的支付。该类将托管所有网关规则，并应用准确满足所需条件的规则。</p><p id="c53d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">注意:添加网关本身也可以使用</em> <a class="ae kw" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/reflection" rel="noopener ugc nofollow" target="_blank"> <em class="kx">反射</em> </a> <em class="kx">进行重构，这样每当一个新规则被添加到系统中时，开发者就不需要在支付处理器或任何其他依赖于它们的模块中手动添加。但是为了简单和集中于主题，它被忽略了。</em></p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lz"><img src="../Images/d99da05bd4d003744d5525d3cf0e6ac5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*69KG-9gRzMmLnFL3wCUdQw.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">图5 —支付处理器类(不再使用if语句—对扩展开放，对修改关闭)</figcaption></figure><p id="2423" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太棒了，不是吗？我喜欢这段代码，它将所有if语句抽象成独立的类，为单元测试做好了准备。如图所示，我们的支付处理器类现在可以扩展，因为我们可以添加无限的支付网关，但不能修改，因为我们不需要对这个类进行任何更改，不管可能添加多少个网关。</p><p id="1e9a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个虚拟类，展示了调用者如何调用上面的代码:</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ma"><img src="../Images/dc911dc58c34a11374e9b85b364d3903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TW7lVy0xQsrG2-vyt6BRgw.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">图6 —调用计算的消费者类</figcaption></figure><p id="a858" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望，现在这证明了实现OCP是多么容易，并且通过一点实践和挑战，将它应用到现实世界的场景中。</p><p id="f083" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编码快乐！</p></div></div>    
</body>
</html>