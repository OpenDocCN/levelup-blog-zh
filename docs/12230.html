<html>
<head>
<title>Code sharing monorepos in Flutter for simple Server-Client data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单服务器-客户端数据在Flutter中的代码共享monorepos</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/code-sharing-monorepos-in-flutter-for-simple-server-client-data-a2d79563b5e7?source=collection_archive---------13-----------------------#2022-05-24">https://levelup.gitconnected.com/code-sharing-monorepos-in-flutter-for-simple-server-client-data-a2d79563b5e7?source=collection_archive---------13-----------------------#2022-05-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7929" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你在网络上工作，毫无疑问你需要发送数据到服务器，并得到一些结果。当你这样做时，你的数据被强制转换成一个字符串(或原始字节)，不管你是使用了<a class="ae kl" href="https://www.json.org/json-en.html" rel="noopener ugc nofollow" target="_blank"> JSON </a>、<a class="ae kl" href="https://msgpack.org/index.html" rel="noopener ugc nofollow" target="_blank"> Messagepack </a>，还是一个定制的编码。</p><p id="853f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">样板文件中最麻烦的部分之一是将数据转换成这个字符串的序列化代码:服务器和客户机使用不同的语言；你的后端人员选择的JSON库与Javascript的<code class="fe km kn ko kp b">JSON.stringify</code>有不同的特点；一个团队在编写他们的序列化程序时使用了PascalCase，现在我们都被困在了这个端点上，因为更改它会破坏其他东西——您知道该如何操作。</p><p id="371a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Flutter在几年前首次进入开发领域，拥有令人印象深刻的开发人员体验，可以创建在Android和iOS上运行良好的应用程序。我们现在处于Flutter v3.0版本，除了移动平台，还支持原生Windows、MacOS、Linux和Web输出，这使得它成为任何跨平台工作的人的强大选择。或者，就此而言，如果你只做一个。我已经使用Flutter构建了几个Web应用程序的前端，这些应用程序从未被设计成跨平台的——使用我所知道的东西比回到HTML/CSS/JS/ <code class="fe km kn ko kp b">$FRAMEWORK_OF_THE_WEEK</code>的世界要简单得多。</p><p id="7a08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然Dart越来越流行，但我很少看到它在服务器端的使用。Dart可以像Python或Java(或您选择的服务器语言)一样用于运行您的服务器堆栈。在我最近的个人项目中，我选择了这样做。每当我在代码的不同区域工作时，我都期待着不需要转换语言的好处。</p><p id="c102" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我的前端和后端现在共享一种语言，我开始考虑共享代码。共享代码最明显的地方是服务器-客户端通信的编码。我可以用适当的JSON转换将消息编写为Dart类，客户机和服务器都使用这些方法进行通信。下一个挑战是如何共享代码——它应该是自己的包吗？应该是git子模块吧？因为只有我一个人在做这个，而不是一个大的团队，我希望它简单，并决定我将有一个单一的前端和后端代码库。</p><p id="a148" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这证明工作得很好。Flutter在构建时会优化掉你不使用的代码，所以你可以自由地为服务器端安装和编写你想要的代码，它不会让你的前端应用程序膨胀。共享的代码可以有效地共享。我也不会经常切换编辑器窗口来处理同一个应用程序的不同部分。</p><p id="b5df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么这看起来像什么？我首先创建了一个默认的Flutter应用程序，然后添加了服务器端。首先，pubspec.yaml看起来会像这样:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="27b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我留了一个空行来分隔服务器和应用程序的依赖关系。shelf是一个使服务器端代码更容易使用的包。http将在前端用于进行调用。</p><p id="fa12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Flutter/Dart对你的文件夹结构的布局有很好的约定。可执行文件保存在<code class="fe km kn ko kp b">bin</code>中，而库代码保存在<code class="fe km kn ko kp b">lib</code>中。Flutter略有不同，因为主flutter文件也放在<code class="fe km kn ko kp b">lib</code>中，因为该文件被编译成本地平台可执行文件。bin中的可执行文件可以导入lib中的文件，但反之则不行。因此，为共享代码创建一个服务器可执行文件和一个文件给出了这个文件结构</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/172a4961e8dc64f5f242ed02893f5430.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*0emGJbLPmnD5vam0xhj70A.png"/></div></figure><p id="8b29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe km kn ko kp b">shared.dart</code>中，我们将放入服务器和客户端都需要的代码。目前，它只是一条简单的消息，包含一些文本和一个数字。记住包括序列化和反序列化对象的方法:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="ec92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从flutter发送这个很容易。我已经删除了大多数默认的脚手架，所以每次按下按钮时，都会有一条消息发送到服务器:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="6636" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">jsonEncode</code>使用在类上定义的<code class="fe km kn ko kp b">toJson</code>方法。在服务器端，fromJson用于解码它:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="03b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行服务器和应用程序，我们看到每次按下按钮时，消息都在服务器端被接收和解码。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi la"><img src="../Images/f3512afc51b659d3380d548e72fc87f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mz9M1PD6sTq09vH0FW-L0w.png"/></div></div></figure><p id="6319" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这消除了用两种语言编写样板编码/解码的需要。它消除了使用像<a class="ae kl" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank"> Protobuf </a>这样的系统从消息文件中生成代码的需要。总的来说，这似乎是一种更快捷的工作方式。</p><p id="b508" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有一个好处是，共享类型不必是简单的数据对象。它们可以附加方法，服务器和客户端都可以调用这些方法——允许系统更好地重用代码，比如需要在服务器和客户端上运行的验证。</p></div></div>    
</body>
</html>