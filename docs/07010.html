<html>
<head>
<title>4 ways to generate code in C# — Including Source Generators in .NET 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用C#生成代码的4种方法——包括。网络5</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/four-ways-to-generate-code-in-c-including-source-generators-in-net-5-9e6817db425?source=collection_archive---------1-----------------------#2021-01-19">https://levelup.gitconnected.com/four-ways-to-generate-code-in-c-including-source-generators-in-net-5-9e6817db425?source=collection_archive---------1-----------------------#2021-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="bf1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">微软在最新的C#版本中引入了源代码生成器。这是一个新特性，允许我们在代码编译时生成源代码。在本文中，我将向您介绍四种可以生成源代码来简化我们日常工作的方法。然后就可以针对各种场景选择合适的方式了。</p><p id="6872" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好的开发人员是懒惰的开发人员，因为他们不想一遍又一遍地重复代码。在。NET世界中，我们有这样的方法来帮助我们生成代码:</p><ul class=""><li id="c944" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">代码片段。</li><li id="92d6" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">反思。</li><li id="4c9d" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">T4模板。</li><li id="ab5a" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">中的[新]源发生器。净5。</li></ul><p id="4e0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也许你有更多的想法，但这篇文章将主要涵盖这四种方式。你可以查看我这篇文章的repo:<a class="ae lc" href="https://github.com/yanxiaodi/MyCodeSamples/tree/main/CodeGeneratorDemo" rel="noopener ugc nofollow" target="_blank">https://github . com/yanxiaodi/MyCodeSamples/tree/main/CodeGeneratorDemo</a>。我们开始吧！</p><h1 id="2042" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">代码片段</h1><p id="420d" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">代码片段是可重用代码的小块，可以通过使用热键组合插入到我们的代码文件中。例如，如果你在Visual Studio中输入<code class="fe mg mh mi mj b">prop</code>然后按下<code class="fe mg mh mi mj b">Tab</code>，VS会自动在你的类中生成一个属性，那么你就可以很容易地替换属性名。VS已经为我们提供了很多内置的代码片段，比如<code class="fe mg mh mi mj b">prop</code>、<code class="fe mg mh mi mj b">if</code>、<code class="fe mg mh mi mj b">while</code>、<code class="fe mg mh mi mj b">for</code>、<code class="fe mg mh mi mj b">try</code>等。你可以在这里找到所有默认代码片段的列表:<a class="ae lc" href="https://docs.microsoft.com/en-us/visualstudio/ide/visual-csharp-code-snippets?view=vs-2019&amp;WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank"> C#代码片段</a>。</p><p id="702f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码片段的好处是您可以替换参数。例如，当我们为UWP/厦门/WPF应用程序使用MVVM模式时，我们经常需要在实现<a class="ae lc" href="https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.inotifypropertychanged?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank"> INotifyPropertyChanged </a>接口的类中创建属性。如果你使用<strong class="js iu"> MvvmCross </strong>框架，它可能看起来像这样:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="bbd5" class="ms le it mj b gy mt mu l mv mw">private ObservableCollection&lt;Comment&gt; _commentList;<br/>public ObservableCollection&lt;Comment&gt; CommentList<br/>{<br/>     get =&gt; _commentList;<br/>     set =&gt; SetProperty(ref _commentList, value);<br/>}</span></pre><p id="43ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们不想复制/粘贴然后改变变量名，所以我创建了一个代码片段来简化工作。创建一个名为<code class="fe mg mh mi mj b">myMvvm.snippet</code>的新文件，并复制&amp;粘贴以下代码:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="8484" class="ms le it mj b gy mt mu l mv mw">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;CodeSnippets ae lc" href="http://schemas.microsoft.com/VisualStudio/2005/CodeSnippet" rel="noopener ugc nofollow" target="_blank"&gt;http://schemas.microsoft.com/VisualStudio/2005/CodeSnippet"&gt;<br/>  &lt;CodeSnippet Format="1.0.0"&gt;<br/>    &lt;Header&gt;<br/>      &lt;SnippetTypes&gt;<br/>        &lt;SnippetType&gt;Expansion&lt;/SnippetType&gt;<br/>      &lt;/SnippetTypes&gt;<br/>      &lt;Title&gt;MvvmCross property&lt;/Title&gt;<br/>      &lt;Author&gt;Xiaodi Yan&lt;/Author&gt;<br/>      &lt;Shortcut&gt;mvxprop&lt;/Shortcut&gt;<br/>      &lt;Description&gt;<br/>        A property in a ViewModel in the Xamarin project with MvvmCross.<br/>      &lt;/Description&gt;<br/>    &lt;/Header&gt;<br/>    &lt;Snippet&gt;<br/>      &lt;Declarations&gt;<br/>        &lt;Literal&gt;<br/>          &lt;ID&gt;Property&lt;/ID&gt;<br/>          &lt;ToolTip&gt;Property name&lt;/ToolTip&gt;<br/>          &lt;Default&gt;Property&lt;/Default&gt;<br/>        &lt;/Literal&gt;<br/>        &lt;Object&gt;<br/>          &lt;ID&gt;type&lt;/ID&gt;<br/>          &lt;ToolTip&gt;Property type&lt;/ToolTip&gt;<br/>          &lt;Default&gt;string&lt;/Default&gt;<br/>        &lt;/Object&gt;<br/>        &lt;Literal&gt;<br/>          &lt;ID&gt;pProperty&lt;/ID&gt;<br/>          &lt;ToolTip&gt;Private property name&lt;/ToolTip&gt;<br/>          &lt;Default&gt;property&lt;/Default&gt;<br/>        &lt;/Literal&gt;<br/>      &lt;/Declarations&gt;<br/>      &lt;Code Language="csharp"&gt;<br/>        &lt;![CDATA[#region $Property$;<br/>  private $type$ _$pProperty$;<br/>        public $type$ $Property$<br/>        {<br/>            get =&gt; _$pProperty$;<br/>            set =&gt; SetProperty(ref _$pProperty$, value);<br/>        }<br/>  #endregion]]&gt;<br/>      &lt;/Code&gt;<br/>    &lt;/Snippet&gt;<br/>  &lt;/CodeSnippet&gt;<br/>&lt;/CodeSnippets&gt;</span></pre><p id="9911" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这段代码中，我们使用<code class="fe mg mh mi mj b">&lt;Shortcut&gt;</code>部分来指定快捷键<code class="fe mg mh mi mj b">mvxprop</code>，并使用<code class="fe mg mh mi mj b">&lt;Declarations&gt;</code>部分来声明一些参数。例如，我们声明了一个名为<code class="fe mg mh mi mj b">Property</code>的参数，然后使用<code class="fe mg mh mi mj b">$Property</code>将其插入到代码片段中。你可以通过<strong class="js iu">代码片段管理器</strong>从VS <strong class="js iu">工具</strong>菜单导入这个代码片段(或者按<strong class="js iu"> Ctrl+K，Ctrl+B </strong>)。</p><p id="320a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在您可以键入<code class="fe mg mh mi mj b">mvxprop</code>并按下<strong class="js iu"> Tab键</strong>，VS可以为您创建属性——您只需手动替换属性名称。</p><p id="ae03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有关更多信息:</p><ul class=""><li id="9505" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/visualstudio/ide/walkthrough-creating-a-code-snippet?view=vs-2019&amp;WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">演练:创建代码片段</a></li><li id="9ab7" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/visualstudio/ide/code-snippet-functions?view=vs-2019&amp;WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">代码片段函数</a></li><li id="db53" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/visualstudio/ide/how-to-distribute-code-snippets?view=vs-2019&amp;WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">如何:分发代码片段</a></li></ul><p id="1525" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码片段适合重用来插入整个类、方法或属性。您还可以将代码片段分发给其他用户。当我们创建新的文件/类/方法时，这很有用。但是如果您想在完成后更新生成的代码，您必须删除现有的代码，然后重新创建它。基本上，它节省了枯燥的复制/粘贴的时间，但它是一次性使用。</p><h1 id="a3b3" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">反射</h1><p id="48d0" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">反射被广泛应用于许多领域。NET框架和库，如<a class="ae lc" href="https://docs.microsoft.com/en-us/aspnet/core/?view=aspnetcore-5.0&amp;WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">ASP.NET核心</a>、<a class="ae lc" href="https://docs.microsoft.com/en-us/ef/core/?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">实体框架核心</a>等。它可以提供描述程序集、模块和类型的类型<a class="ae lc" href="https://docs.microsoft.com/en-us/dotnet/api/system.type?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">类型</a>的对象，这样你就可以动态地创建一个类型的实例，从一个现有的对象中获取类型，然后调用它的方法或者访问它的字段和属性。</p><p id="fcf6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们建造。NET应用程序，它生成程序集，如*。dll文件。这些程序集包含我们的模块，这些模块包含一些类型。类型包含成员。反思让我们能够读懂这些信息。因此我们可以动态加载新的*。dll文件并调用它们的方法或事件，而无需编辑代码。<strong class="js iu">动态</strong>意味着它在运行时工作。换句话说，当我们编译应用程序时。NET应用程序直到运行时才知道我们需要使用什么类型。通过这种方式，我们可以创建一个客户端，它可以基于我们的规则动态地执行其他程序集中的方法。如果我们按照规则更新其他程序集中的类，我们不需要更新客户端代码。</p><p id="e72a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看下面的样品。您可以在我的示例项目中找到它。我们在<strong class="js iu"> CodeGeneratorDemo中有一个名为<code class="fe mg mh mi mj b">ISpeaker</code>的接口。ReflectionDemo.Core </strong>项目如下图所示:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="be46" class="ms le it mj b gy mt mu l mv mw">namespace CodeGeneratorDemo.ReflectionDemo.Core<br/>{<br/>    public interface ISpeaker<br/>    {<br/>        string SayHello();<br/>    }<br/>}</span></pre><p id="f054" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建两个实现类:</p><p id="064b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mg mh mi mj b">ChineseSpeaker</code>:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="c670" class="ms le it mj b gy mt mu l mv mw">namespace CodeGeneratorDemo.ReflectionDemo.Core<br/>{<br/>    public class ChineseSpeaker : ISpeaker<br/>    {<br/>        public string Name =&gt; this.GetType().ToString();</span><span id="dcf6" class="ms le it mj b gy mx mu l mv mw">public string SayHello()<br/>        {<br/>            return "Nihao";<br/>        }<br/>    }<br/>}</span></pre><p id="6a1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还有<code class="fe mg mh mi mj b">EnglishSpeaker</code>:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="7233" class="ms le it mj b gy mt mu l mv mw">namespace CodeGeneratorDemo.ReflectionDemo.Core<br/>{<br/>    public class EnglishSpeaker : ISpeaker<br/>    {<br/>        public string Name =&gt; this.GetType().ToString();<br/>        <br/>        public string SayHello()<br/>        {<br/>            return "Hello!";<br/>        }<br/>    }<br/>}</span></pre><p id="bc95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以使用反射找到<code class="fe mg mh mi mj b">ISpeaker</code>接口的所有实现，并调用它们的方法或属性。</p><p id="34c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu"> CodeGeneratorDemo中创建一个名为<strong class="js iu"> ReflectionHelper </strong>的新文件。反射演示</strong>项目:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="13e9" class="ms le it mj b gy mt mu l mv mw">using CodeGeneratorDemo.ReflectionDemo.Core;<br/>using System;<br/>using System.Collections.Generic;<br/>using System.IO;<br/>using System.Linq;<br/>using System.Reflection;</span><span id="334d" class="ms le it mj b gy mx mu l mv mw">namespace CodeGeneratorDemo.ReflectionDemo<br/>{<br/>    public class ReflectionHelper<br/>    {<br/>        public static List&lt;Type&gt; GetAvailableSpeakers()<br/>        {<br/>            // You can also use AppDomain.CurrentDomain.GetAssemblies() to load all assemblies in the current domain.<br/>            // Get the specified assembly.<br/>            var assembly =<br/>                Assembly.LoadFrom(Path.Combine(Directory.GetCurrentDirectory(), "CodeGeneratorDemo.ReflectionDemo.Core.dll"));<br/>            // Find all the types in the assembly.<br/>            var types = assembly.GetTypes();<br/>            // Apply the filter to find the implementations of ISayHello interface.<br/>            var result = types.Where(x =&gt; x.IsClass &amp;&amp; typeof(ISpeaker).IsAssignableFrom(x)).ToList();<br/>            // Or you can use types.Where(x =&gt; x.IsClass &amp;&amp; x.GetInterfaces().Contains(typeof(ISpeaker))).ToList();<br/>            return result;<br/>        }<br/>    }<br/>}</span></pre><p id="7e7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个类中，我们加载包含我们需要的类型的指定dll文件。然后我们可以应用LINQ查询来找到所有使用反射的<code class="fe mg mh mi mj b">ISpeaker</code>接口的实现。</p><p id="25a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu"> CodeGeneratorDemo中。客户端</strong>项目，我们可以输出每个扬声器的名称和调用<code class="fe mg mh mi mj b">SayHello</code>方法:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="9b91" class="ms le it mj b gy mt mu l mv mw">private static void ReflectionSample()<br/>{<br/>    Console.WriteLine("Here is the Reflection sample:");<br/>    // Find all the speakers in the current domain<br/>    var availableSpeakers = ReflectionHelper.GetAvailableSpeakers();<br/>    foreach (var availableSpeaker in availableSpeakers)<br/>    {<br/>        // Create the instance of the type<br/>        var speaker = Activator.CreateInstance(availableSpeaker);<br/>        // Get the property info of the given property name<br/>        PropertyInfo namePropertyInfo = availableSpeaker.GetProperty("Name");<br/>        // Then you can get the value of the property<br/>        var name = namePropertyInfo?.GetValue(speaker)?.ToString();<br/>        Console.WriteLine($"I am {name}");<br/>        // Invoke the method of the instance<br/>        Console.WriteLine(availableSpeaker.InvokeMember("SayHello", BindingFlags.InvokeMethod, null, speaker, null));<br/>    }</span><span id="37d8" class="ms le it mj b gy mx mu l mv mw">Console.WriteLine();<br/>}</span></pre><p id="cfa6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行程序，你会看到下面的输出:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="36d2" class="ms le it mj b gy mt mu l mv mw">Here is the Reflection sample:<br/>I am CodeGeneratorDemo.ReflectionDemo.Core.ChineseSpeaker<br/>Nihao<br/>I am CodeGeneratorDemo.ReflectionDemo.Core.EnglishSpeaker<br/>Hello!</span></pre><p id="7cff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们需要添加其他语言的其他演讲者，只需在同一个项目中添加实现类。。NET反射可以自动找出所有需要的类并正确调用方法。</p><p id="0c80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们创建插件类型的应用程序时，这是非常有用的。首先，我们创建接口，并通过反射从客户端调用方法。然后，我们可以根据客户端的接口创建插件，这些插件可以作为*。dll文件并动态执行。</p><p id="47a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个场景是框架开发。作为一名框架开发人员，您将无法知道用户将创建什么样的实现，因此您只能使用反射来创建这些实例。一个例子是在一些MVVM框架中，如果你按照约定创建类，比如xxxViewModel，框架可以找到所有的视图模型并使用反射自动加载它们。</p><p id="4a97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一般人说反思，主要关注的是表现。因为它是在运行时运行的，所以理论上，它比普通的应用程序要慢一点。但是它对于许多场景都是灵活的，尤其是当你开发框架的时候。如果花几秒钟(或者几百毫秒)来加载程序集是可以接受的，那么请随意使用它。</p><p id="c875" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要用于反射的主要名称空间是<a class="ae lc" href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank"> System。反射</a>和<a class="ae lc" href="https://docs.microsoft.com/en-us/dotnet/api/system.type?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">系统。类型</a>。您可能还需要了解以下术语:</p><ul class=""><li id="613a" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">组装</a></li><li id="52f9" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.module?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">模块</a></li><li id="8fe8" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.constructorinfo?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank"> ConstructorInfo </a></li><li id="b1e2" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodinfo?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank"> MethodInfo </a></li><li id="7d5c" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.fieldinfo?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">字段信息</a></li><li id="4e1f" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.eventinfo?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">事件信息</a></li><li id="4074" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.propertyinfo?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank"> PropertyInfo </a></li><li id="0f14" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.parameterinfo?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">参数信息</a></li><li id="8359" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.customattributedata?WT.mc_id=DT-MVP-5001643%20" rel="noopener ugc nofollow" target="_blank">自定义属性数据</a></li></ul><p id="707b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有关更多信息，请查看这些文档:</p><ul class=""><li id="2449" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/reflection?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">倒影在。网</a></li><li id="4e3c" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/viewing-type-information?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">查看类型信息</a></li><li id="66e9" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/dynamically-loading-and-using-types?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">动态加载和使用类型</a></li></ul><h1 id="3462" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">T4模板</h1><p id="7e1e" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated"><strong class="js iu"> T4文本模板</strong>是文本块和控制逻辑的混合物，可以生成一个文本文件。<strong class="js iu"> T4 </strong>意为<em class="my">文本模板转换</em>。您可以使用它在Visual Studio for C#和Visual Basic中生成文件。但是文件本身可以是任何类型的文本，比如*。txt文件，或HTML文件，或任何语言的程序源代码。你用C#代码(或者VB)来控制模板中的逻辑。几年前，我曾经使用一个NuGet包(EntityFramework反向POCO生成器)来为EntityFramework生成POCO模型。它是通过T4模板实现的。我只需要更新T4模板中的数据库连接字符串并保存它，然后T4模板就可以读取数据库信息并自动创建所有的模型和方法。</p><p id="a40d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看奇迹是如何发生的。有两种T4模板:<strong class="js iu">运行期</strong>和<strong class="js iu">设计期</strong>。不同之处在于，运行时T4模板是在应用程序中执行的，以生成文本字符串。它将创建一个*。包含一个<code class="fe mg mh mi mj b">TransformText()</code>方法的cs类。然后，即使目标计算机没有安装Visual Studio，也可以调用此方法来生成字符串。相反，当您在Visual Studio中保存模板时，设计时T4模板会生成原始源代码或文本文件。如果要使用运行时T4模板，需要将文件的<strong class="js iu">自定义工具</strong>属性设置为<strong class="js iu">texttemplatingfile preprocessor</strong>。对于设计时T4模板，<strong class="js iu">自定义工具</strong>属性应设置为<strong class="js iu">TextTemplatingFileGenerator</strong>。</p><figure class="mk ml mm mn gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mz"><img src="../Images/b5c654074ed25812ed711740b0f35a5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L55UYYrjL_Uoxs1V4OrXVg.png"/></div></div></figure><p id="03fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以在<strong class="js iu"> CodeGeneratorDemo中找到样本。T4TemplateDemo </strong>项目。有两个T4模板:<strong class="js iu">runtimetexttemplatedemo . TT</strong>和<strong class="js iu">designtimetexttemplatedemo . TT</strong>。</p><h1 id="6bb5" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">运行时T4模板</h1><p id="5325" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">为了正确构建项目，您需要安装<strong class="js iu">系统。CodeDom </strong> NuGet包。打开<strong class="js iu">runtimetexttemplatedemo . TT</strong>文件，对HTML代码做一些修改，然后保存。您将看到T4模板自动更新生成的文件<strong class="js iu">runtimetexttemplatedemo . cs</strong>。您可以在客户端代码中使用一个名为<code class="fe mg mh mi mj b">TransformText()</code>的方法。</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="ebff" class="ms le it mj b gy mt mu l mv mw">&lt;#@ template language="C#" #&gt;<br/>&lt;#@ assembly name="System.Core" #&gt;<br/>&lt;#@ import namespace="System.Linq" #&gt;<br/>&lt;#@ import namespace="System.Text" #&gt;<br/>&lt;#@ import namespace="System.Collections.Generic" #&gt;<br/>&lt;html&gt;&lt;body&gt;<br/>&lt;h1&gt;Sales for Previous Month&lt;/h2&gt;<br/>&lt;table&gt;<br/>    &lt;# for (int i = 1; i &lt;= 10; i++)<br/>       { #&gt;<br/>         &lt;tr&gt;&lt;td&gt;Test name &lt;#= i #&gt; &lt;/td&gt;<br/>             &lt;td&gt;Test value &lt;#= i * i #&gt; &lt;/td&gt; &lt;/tr&gt;<br/>    &lt;# } #&gt;<br/> &lt;/table&gt;<br/>This report is Company Confidential.<br/>&lt;/body&gt;&lt;/html&gt;</span></pre><p id="7c47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每次保存模板，都会更新生成的文件。在客户端代码中，我们可以调用下面的代码:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="6324" class="ms le it mj b gy mt mu l mv mw">var page = new RunTimeTextTemplateDemo();<br/>Console.WriteLine(page.TransformText());</span></pre><p id="8718" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您将在控制台中看到HTML代码。</p><h1 id="794a" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">设计时T4模板</h1><p id="dbde" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">设计时模板只能在开发程序时在Visual Studio中使用。它生成原始文本文件，无论格式是什么—可以是*cs，*。通常，您需要定义一个<strong class="js iu">模型</strong>，它可以是一个文本文件(XML或JSON或csv或其他文件)，或者一个数据库，然后模板从模型中读取数据并生成一些源代码。</p><p id="0b79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有一个例子:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="af80" class="ms le it mj b gy mt mu l mv mw">&lt;#@ template debug="false" hostspecific="true" language="C#" #&gt;<br/>&lt;#@ assembly name="System.Core" #&gt;<br/>&lt;#@ import namespace="System.Linq" #&gt;<br/>&lt;#@ import namespace="System.Text" #&gt;<br/>&lt;#@ import namespace="System.Collections.Generic" #&gt;<br/>&lt;#@ import namespace="System.IO" #&gt;<br/>&lt;#@ output extension=".cs" #&gt;</span><span id="c35c" class="ms le it mj b gy mx mu l mv mw">using System;<br/>using System.Threading.Tasks;</span><span id="768b" class="ms le it mj b gy mx mu l mv mw">namespace CodeGeneratorDemo.T4TemplateDemo.DesignTimeTextTemplateDemo<br/>{<br/>&lt;# <br/>    var models = new List&lt;string&gt;();<br/>    // You can read the data from any source you have.<br/>    string path = Path.Combine(Path.GetDirectoryName(this.Host.TemplateFile), "dataSource.txt");<br/>    if(File.Exists(path))<br/>    {<br/>        models = File.ReadAllText(path).Split(',').ToList();<br/>    }<br/>    foreach (var model in models)<br/>    {<br/>        #&gt;<br/>    public partial class &lt;#=model#&gt;<br/>    {<br/>        public Guid Id { get; set; }<br/>        public &lt;#=model#&gt;(Guid id)<br/>        {<br/>            Id = id;<br/>        }<br/>    }</span><span id="fb29" class="ms le it mj b gy mx mu l mv mw">public partial class &lt;#=model#&gt;Service<br/>    {<br/>        public Task&lt;&lt;#=model#&gt;&gt; Get&lt;#=model#&gt;(Guid id)<br/>        {<br/>            return Task.FromResult(new &lt;#=model#&gt;(id));<br/>        }<br/>    }<br/>&lt;#<br/>    }<br/>#&gt;<br/>}</span></pre><p id="d94e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您保存模板时，T4模板可以为每个类生成模型和服务。</p><h1 id="662a" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">如何创建T4模板</h1><p id="6131" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">正如您在上述示例中看到的，T4模板由以下部分组成:</p><ul class=""><li id="75b4" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated"><strong class="js iu">指令</strong> —控制模板处理方式的元素。</li><li id="b2a4" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><strong class="js iu">文本块</strong> —直接复制到输出的原始文本。</li><li id="008d" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><strong class="js iu">控制块</strong> —将变量值插入文本的程序代码，并控制文本的条件或重复部分。</li></ul><p id="7908" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，您可以使用以下指令来指定输出文件格式:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="dd90" class="ms le it mj b gy mt mu l mv mw">&lt;#@ output extension=".txt" #&gt;</span></pre><p id="8a0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您也可以使用C#代码来控制逻辑。例如，检查以下代码:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="a8f6" class="ms le it mj b gy mt mu l mv mw">&lt;#<br/>    for(int i = 0; i &lt; 4; i++)<br/>    {<br/>#&gt;<br/>Hello!<br/>&lt;#<br/>    }<br/>#&gt;</span></pre><p id="cd78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它将输出<code class="fe mg mh mi mj b">Hello</code>四次。在这个例子中，<code class="fe mg mh mi mj b">Hello</code>是一个文本块，<code class="fe mg mh mi mj b">for</code>语句只是C#代码。</p><p id="2c73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要使用变量，可以使用表达式控制块。使用<code class="fe mg mh mi mj b">&lt;#= ... #&gt;</code>输出变量即可，如下图所示:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="0032" class="ms le it mj b gy mt mu l mv mw">&lt;#<br/>    string message = "Hello";<br/>    for(int i = 0; i &lt; 4; i++)<br/>    {<br/>#&gt;<br/>  &lt;#=message#&gt;<br/>&lt;#<br/>    }<br/>#&gt;</span></pre><p id="da4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它将输出四倍的<code class="fe mg mh mi mj b">Hello</code>。</p><p id="dc18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">T4模板的强大功能是您可以导入程序集并使用大多数。您需要的. NET库，例如:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="1832" class="ms le it mj b gy mt mu l mv mw">&lt;#@ assembly name="System.Core" #&gt;<br/>&lt;#@ import namespace="System.Linq" #&gt;<br/>&lt;#@ import namespace="System.Text" #&gt;<br/>&lt;#@ import namespace="System.Collections.Generic" #&gt;<br/>&lt;#@ import namespace="System.IO" #&gt;</span></pre><p id="384c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，您需要将它们放在原始文本和控制块之前。你甚至可以在控制块中使用反射。有了这些特性，我们可以为某些场景编写非常有用的模板。</p><h1 id="5996" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">调试T4模板</h1><p id="b3c2" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">像普通的C#程序一样，我们可以通过设置断点来调试T4模板。要调试设计时T4模板，右击该模板并从解决方案资源管理器的文件菜单中选择<strong class="js iu">调试T4模板</strong>。要调试运行时T4模板，只需调试项目，因为它在程序编译时运行。</p><figure class="mk ml mm mn gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nh"><img src="../Images/5312e1ebde8e32802c0d4daa248161c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YSRO6tvzGHlauFbiL4fB5w.png"/></div></div></figure><h1 id="4f1f" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">T4模板编辑器</h1><p id="a92c" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">默认情况下，Visual Studio不支持语法着色和智能感知等。幸运的是，我们有一些VS扩展来提高生产率，比如<a class="ae lc" href="https://www.devart.com/t4-editor/" rel="noopener ugc nofollow" target="_blank">德瓦特T4编辑器</a>。你可以在VS扩展市场搜索<em class="my"> T4模板</em>你会找到更多。</p><p id="3211" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们不会涉及T4模板的所有细节。有关更多信息，请阅读这些文档:</p><ul class=""><li id="3405" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/visualstudio/modeling/code-generation-and-t4-text-templates?view=vs-2019&amp;WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">代码生成和T4文本模板</a></li><li id="8216" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/visualstudio/modeling/walkthrough-generating-code-by-using-text-templates?view=vs-2019&amp;WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">演练:使用文本模板生成代码</a></li><li id="31eb" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/visualstudio/modeling/run-time-text-generation-with-t4-text-templates?view=vs-2019&amp;WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">使用T4文本模板进行运行时文本生成</a></li><li id="0df4" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/visualstudio/modeling/t4-text-template-directives?view=vs-2019&amp;WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank"> T4文本模板指令</a></li><li id="e1bd" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/visualstudio/modeling/text-template-control-blocks?view=vs-2019&amp;WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">文本模板控制块</a></li><li id="337e" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/visualstudio/modeling/guidelines-for-writing-t4-text-templates?view=vs-2019&amp;WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">T4文本模板编写指南</a></li></ul><h1 id="2d33" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">源发生器在。网络5</h1><p id="81e8" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">要开始使用源代码生成器，您需要安装最新的<a class="ae lc" href="https://dotnet.microsoft.com/download/dotnet/5.0" rel="noopener ugc nofollow" target="_blank">。NET 5 SDK </a>。</p><h1 id="36b8" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">什么是源发生器，它是如何工作的？</h1><p id="0822" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">根据微软的定义:</p><blockquote class="ni nj nk"><p id="a93a" class="jq jr my js b jt ju jv jw jx jy jz ka nl kc kd ke nm kg kh ki nn kk kl km kn im bi translated"><em class="it">源代码生成器是在编译期间运行的一段代码，它可以检查您的程序以生成与您的代码的其余部分一起编译的附加文件。</em></p></blockquote><p id="560c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们回顾一下反射是如何工作的。正如我之前提到的，当我们构建应用程序时，反射代码不知道它将使用什么类型，直到应用程序运行。这就是为什么人们抱怨反思的表现。如果我们在应用程序启动时加载了大量的程序集，这可能会对性能造成轻微的影响。这个问题很难解决，因为这是反射的缺点——你得到了开发的好处，但是你必须接受它的缺点。</p><p id="47d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">源生成器用于解决性能问题——至少，提高性能是一个重要的目标。源代码生成器可以分析当前的源代码，并注入到代码编译过程中，然后生成一些代码，这些代码将根据当前的源代码进行编译——换句话说，当应用程序完成编译时，它已经确切地知道它将使用什么类型。这是改进的关键。</p><p id="6a9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是来自微软的源生成器图表:</p><figure class="mk ml mm mn gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi no"><img src="../Images/d8c3d33b2ee151df9641b25c7a5eb856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u95iQhjo0xWmKnQnSqLX5A.png"/></div></div></figure><p id="37a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要知道的一件事是<strong class="js iu">源代码生成器只能给代码添加一些东西，而不能改变任何现有的代码</strong>。让我们看一个例子。</p><h1 id="84be" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">我的第一个源发生器示例</h1><p id="315c" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">生成源是<code class="fe mg mh mi mj b">Microsoft.CodeAnalysis.ISourceGenerator</code>的实现:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="2da6" class="ms le it mj b gy mt mu l mv mw">namespace Microsoft.CodeAnalysis<br/>{<br/>    public interface ISourceGenerator<br/>    {<br/>        void Initialize(GeneratorInitializationContext context);<br/>        void Execute(GeneratorExecutionContext context);<br/>    }<br/>}</span></pre><p id="b064" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建新的。名为<strong class="js iu"> CodeGeneratorDemo的. NET Standard 2.0类项目。SourceGeneratorDemo </strong>。安装这两个NuGet包:</p><ul class=""><li id="0a90" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">微软。CodeAnalysis.CSharp v3.8+版</li><li id="038f" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">微软。code analysis . analyzer v 3.3+版</li></ul><p id="b6d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还需要将语言版本指定为<code class="fe mg mh mi mj b">preview</code>:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="4b8a" class="ms le it mj b gy mt mu l mv mw">&lt;PropertyGroup&gt;<br/>  &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;<br/>  &lt;LangVersion&gt;preview&lt;/LangVersion&gt;<br/>&lt;/PropertyGroup&gt;</span></pre><p id="685b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从技术上来说，源代码生成器不是C#语言的特性。它们仍在预览中。所以我们现在需要明确地指定它。</p><p id="b19f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后在项目中创建一个<code class="fe mg mh mi mj b">SpeakersSourceGenerator.cs</code>文件。如下所示更新内容:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="2006" class="ms le it mj b gy mt mu l mv mw">using Microsoft.CodeAnalysis;<br/>using Microsoft.CodeAnalysis.CSharp.Syntax;<br/>using Microsoft.CodeAnalysis.Text;<br/>using System.Collections.Generic;<br/>using System.Text;</span><span id="f61c" class="ms le it mj b gy mx mu l mv mw">namespace CodeGeneratorDemo.SourceGeneratorDemo<br/>{<br/>    [Generator]<br/>    public class SpeakersSourceGenerator : ISourceGenerator<br/>    {<br/>        public void Initialize(GeneratorInitializationContext context)<br/>        {<br/>            // Not needed for this sample<br/>        }</span><span id="348a" class="ms le it mj b gy mx mu l mv mw">public void Execute(GeneratorExecutionContext context)<br/>        {<br/>            // begin creating the source we'll inject into the users compilation<br/>            var sourceBuilder = new StringBuilder(@"<br/>using System;<br/>namespace CodeGeneratorDemo.SourceGeneratorDemo<br/>{<br/>    public static class SpeakerHelper<br/>    {<br/>        public static void SayHello() <br/>        {<br/>            Console.WriteLine(""Hello from generated code!"");<br/>");<br/>            sourceBuilder.Append(@"<br/>        }<br/>    }<br/>}");<br/>            // inject the created source into the users compilation<br/>            context.AddSource("speakersSourceGenerator", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));<br/>        }<br/>    }<br/>}</span></pre><p id="c6b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mg mh mi mj b">SpeakersSourceGenerator</code>类实现了<code class="fe mg mh mi mj b">ISourceGenerator</code>接口，并具有<code class="fe mg mh mi mj b">Generator</code>属性。当程序编译时，它会找到源代码生成器并生成我们需要的代码。在这个例子中，我只创建了一个名为<code class="fe mg mh mi mj b">SpeakerHelper</code>的新类，它包含一个<code class="fe mg mh mi mj b">SayHello()</code>方法。如果我们正确地生成了代码，它应该会在控制台中输出消息。</p><p id="24c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，添加对<strong class="js iu"> CodeGeneratorDemo的引用。客户</strong>项目。请注意，您需要像这样更新项目文件:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="e123" class="ms le it mj b gy mt mu l mv mw">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;<br/>  &lt;PropertyGroup&gt;<br/>    &lt;OutputType&gt;Exe&lt;/OutputType&gt;<br/>    &lt;TargetFramework&gt;net5.0&lt;/TargetFramework&gt;<br/>    &lt;LangVersion&gt;preview&lt;/LangVersion&gt;<br/>  &lt;/PropertyGroup&gt;</span><span id="ca38" class="ms le it mj b gy mx mu l mv mw">&lt;ItemGroup&gt;<br/>    &lt;ProjectReference Include="..\CodeGeneratorDemo.SourceGeneratorDemo\CodeGeneratorDemo.SourceGeneratorDemo.csproj" <br/>                      OutputItemType="Analyzer"<br/>                      ReferenceOutputAssembly="false"/&gt;<br/>  &lt;/ItemGroup&gt;<br/>&lt;/Project&gt;</span></pre><p id="2b96" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您还需要指定语言版本。此外，因为我们没有将项目作为普通的dll文件引用，所以我们需要如上所示更新<code class="fe mg mh mi mj b">OutputItemType</code>和<code class="fe mg mh mi mj b">ReferenceOutputAssembly</code>的值。</p><p id="4d0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在客户端代码中添加代码:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="ed56" class="ms le it mj b gy mt mu l mv mw">private static void SourceGeneratorSample()<br/>{<br/>    CodeGeneratorDemo.SourceGeneratorDemo.SpeakerHelper.SayHello();<br/>}</span></pre><p id="c85f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能会看到VS抱怨<code class="fe mg mh mi mj b">CodeGeneratorDemo.SourceGeneratorDemo.SpeakerHelper</code>找不到，因为在我们的代码中没有这样的类。源生成器的工具仍在预览中，所以我们需要构建<strong class="js iu"> CodeGeneratorDemo。SourceGeneratorDemo </strong>项目并关闭VS然后重启它。然后你会发现VS也可以支持智能。当我们构建它时，源生成器实际上生成了<code class="fe mg mh mi mj b">SpeakerHelper</code>类。现在运行客户端应用程序，我们可以看到来自生成代码的输出:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="4dac" class="ms le it mj b gy mt mu l mv mw">Hello from generated code!</span></pre><p id="ed12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以过程是，当我们构建项目时，源生成器将被调用来产生一些代码，这些代码可以与原始源代码一起编译。这样，就不会有性能问题，因为它发生在编译过程中。当应用程序启动时，生成的代码已经与其他源代码一起编译了。</p><p id="38aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从我的经验来看，有时VS不能识别生成的方法或类，但是如果构建运行正确，这应该没问题。</p><figure class="mk ml mm mn gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi np"><img src="../Images/297505a91acc89a89f551e24994a1a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*edmNkq0abgOeUXekuHUewQ.png"/></div></div></figure><p id="f3c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您按下<code class="fe mg mh mi mj b">F12</code>来检查客户端代码中的<code class="fe mg mh mi mj b">SayHello()</code>方法，您将看到生成的文件显示该文件不可编辑:</p><figure class="mk ml mm mn gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nq"><img src="../Images/7fe27b7db05584be46354b167ee83804.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3uvrb59I5XsI4utRwrYSIQ.png"/></div></div></figure><p id="4df9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能会好奇文件在哪里。如果你想看到实际生成的文件，你可以将这些部分添加到<strong class="js iu"> CodeGeneratorDemo中。SourceGeneratorDemo </strong>项目和<strong class="js iu"> CodeGeneratorDemo。客户</strong>项目:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="79a3" class="ms le it mj b gy mt mu l mv mw">&lt;EmitCompilerGeneratedFiles&gt;true&lt;/EmitCompilerGeneratedFiles&gt;<br/>&lt;CompilerGeneratedFilesOutputPath&gt;$(BaseIntermediateOutputPath)\GeneratedFiles&lt;/CompilerGeneratedFilesOutputPath&gt;</span></pre><p id="5d5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后你可以在<strong class="js iu"> obj/GeneratedFiles </strong>文件夹中找到这个文件。如果不指定<strong class="js iu">CompilerGeneratedFilesOutputPath</strong>属性，它应该在<strong class="js iu">obj/SourceGeneratorFiles</strong>文件夹中。</p><p id="57c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这只是一个非常简单的例子，展示了如何在运行时之前生成代码。接下来，让我们看另一个稍微复杂一点的例子。</p><h1 id="704d" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">在编译中生成属性</h1><p id="fac2" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">当我们使用依赖注入时，通常我们需要手动注册实例。对于这个演示，我将创建一个<a class="ae lc" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">属性</a>来修饰需要注册的类。我们可以使用反射来检索这些属性，以找到特定的类，但操作可能会很昂贵。有了源代码生成器，我们可以在运行时之前生成代码来注册它们。</p><p id="0792" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建一个名为<code class="fe mg mh mi mj b">AutoRegisterSourceGenerator</code>的新类，如下所示:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="bd65" class="ms le it mj b gy mt mu l mv mw">[Generator]<br/>public class AutoRegisterSourceGenerator : ISourceGenerator<br/>{<br/>    public void Initialize(GeneratorInitializationContext context)<br/>    {<br/>        // TODO<br/>    }</span><span id="2d5a" class="ms le it mj b gy mx mu l mv mw">public void Execute(GeneratorExecutionContext context)<br/>    {<br/>         // TODO<br/>    }<br/>}</span></pre><p id="1a6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们创建属性。我们可以创建实际的类作为普通代码，但是为了演示，我将使用Source Generator来生成它。将以下代码添加到<code class="fe mg mh mi mj b">AutoRegisterSourceGenerator</code>:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="5db3" class="ms le it mj b gy mt mu l mv mw">private const string AttributeText = @"<br/>using System;<br/>namespace CodeGeneratorDemo.SourceGeneratorDemo<br/>{<br/>    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]<br/>    sealed class AutoRegisterAttribute : Attribute<br/>    {<br/>        public AutoRegisterAttribute()<br/>        {<br/>        }<br/>    }<br/>}";</span></pre><p id="e514" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这只是一个字符串。接下来，更新<code class="fe mg mh mi mj b">Execute</code>方法，将字符串添加到源代码中:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="55e9" class="ms le it mj b gy mt mu l mv mw">public void Execute(GeneratorExecutionContext context)<br/>{<br/>    context.AddSource("AutoRegisterAttribute", SourceText.From(AttributeText, Encoding.UTF8));<br/>}</span></pre><p id="406b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们构建项目时，它将生成<code class="fe mg mh mi mj b">AutoRegisterAttribute</code>。</p><p id="aac0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一步是创建一些接口:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="1678" class="ms le it mj b gy mt mu l mv mw">namespace CodeGeneratorDemo.Client.Core<br/>{<br/>    public interface IOrderService<br/>    {<br/>    }<br/>    public interface IProductService<br/>    {<br/>    }<br/>}</span></pre><p id="580a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还有一些实现，比如<code class="fe mg mh mi mj b">OrderService</code>和<code class="fe mg mh mi mj b">ProductService</code>，是用<code class="fe mg mh mi mj b">AutoRegister</code>属性修饰的:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="3d4b" class="ms le it mj b gy mt mu l mv mw">using System;<br/>using CodeGeneratorDemo.SourceGeneratorDemo;</span><span id="a165" class="ms le it mj b gy mx mu l mv mw">namespace CodeGeneratorDemo.Client.Core<br/>{<br/>    [AutoRegister]<br/>    public class OrderService : IOrderService<br/>    {<br/>        public OrderService()<br/>        {<br/>            Console.WriteLine($"{this.GetType()} constructed.");<br/>        }<br/>    }<br/>    <br/>    [AutoRegister]<br/>    public class ProductService : IProductService<br/>    {<br/>        public ProductService()<br/>        {<br/>            Console.WriteLine($"{this.GetType()} constructed.");<br/>        }<br/>    }<br/>}</span></pre><p id="8b8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">目前我们的代码中没有<code class="fe mg mh mi mj b">AutoRegister</code>。所以你会看到VS抱怨。这没有关系，因为属性将由源生成器稍后生成。</p><p id="10e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将有另一个名为<code class="fe mg mh mi mj b">DiContainerMocker</code>的类来模拟DI容器:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="741e" class="ms le it mj b gy mt mu l mv mw">using System;<br/>namespace CodeGeneratorDemo.Client.Core<br/>{<br/>    public static class DiContainerMocker<br/>    {<br/>        public static void RegisterService&lt;TInterface, TImplementation&gt;(TImplementation service)<br/>        {<br/>            Console.WriteLine($"{service.GetType()} has been registered for {typeof(TInterface)}.");<br/>        }<br/>    }<br/>}</span></pre><p id="6aa3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">源发电机依靠<a class="ae lc" href="https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">罗斯林</a>。它可以检查来自编译的数据。我们可以通过使用名为<code class="fe mg mh mi mj b">SyntaxReceivers</code>的对象来访问<code class="fe mg mh mi mj b">SyntaxTrees</code>，迭代<code class="fe mg mh mi mj b">SyntaxNodes</code>，然后基于这些信息生成代码。</p><p id="646d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建一个名为<code class="fe mg mh mi mj b">MySyntaxReceiver</code>的新类，它实现了<code class="fe mg mh mi mj b">ISyntaxReceiver</code>接口:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="3528" class="ms le it mj b gy mt mu l mv mw">public class MySyntaxReceiver : ISyntaxReceiver<br/>{<br/>    public List&lt;ClassDeclarationSyntax&gt; CandidateClasses { get; } = new List&lt;ClassDeclarationSyntax&gt;();</span><span id="c8a6" class="ms le it mj b gy mx mu l mv mw">/// &lt;summary&gt;<br/>    /// Called for every syntax node in the compilation, we can inspect the nodes and save any information useful for generation<br/>    /// &lt;/summary&gt;<br/>    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)<br/>    {<br/>        // any method with at least one attribute is a candidate for property generation<br/>        if (syntaxNode is ClassDeclarationSyntax classDeclarationSyntax<br/>            &amp;&amp; classDeclarationSyntax.AttributeLists.Count &gt;= 0)<br/>        {<br/>            CandidateClasses.Add(classDeclarationSyntax);<br/>        }<br/>    }<br/>}</span></pre><p id="cee7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这节课上，我们将检查每个<code class="fe mg mh mi mj b">SyntaxNode</code>。如果它是一个类并且有属性，那么我们将把它添加到一个列表中。</p><p id="01ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们需要在源生成器的<code class="fe mg mh mi mj b">Initialize</code>方法中注册<code class="fe mg mh mi mj b">MySyntaxReceiver</code>:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="43fc" class="ms le it mj b gy mt mu l mv mw">public void Initialize(GeneratorInitializationContext context)<br/>{<br/>    context.RegisterForSyntaxNotifications(() =&gt; new MySyntaxReceiver());<br/>}</span></pre><p id="498d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在是时候完成我们的源生成器了。这个想法是，我们将挂钩编译并检查<code class="fe mg mh mi mj b">SyntaxNode</code>是否是一个类并具有<code class="fe mg mh mi mj b">AutoRegister</code>属性。用以下代码更新<code class="fe mg mh mi mj b">Execute</code>方法:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="8555" class="ms le it mj b gy mt mu l mv mw">public void Execute(GeneratorExecutionContext context)<br/>        {<br/>            context.AddSource("AutoRegisterAttribute", SourceText.From(AttributeText, Encoding.UTF8));<br/>            if (!(context.SyntaxReceiver is MySyntaxReceiver receiver))<br/>            {<br/>                return;<br/>            }<br/>            CSharpParseOptions options = (context.Compilation as CSharpCompilation).SyntaxTrees[0].Options as CSharpParseOptions;<br/>            SyntaxTree attributeSyntaxTree =<br/>                CSharpSyntaxTree.ParseText(SourceText.From(AttributeText, Encoding.UTF8), options);<br/>            Compilation compilation = context.Compilation.AddSyntaxTrees(attributeSyntaxTree);<br/>            StringBuilder stringBuilder = new StringBuilder();<br/>            stringBuilder.Append(@"<br/>using System;<br/>using CodeGeneratorDemo.Client.Core;<br/>namespace CodeGeneratorDemo.SourceGeneratorDemo<br/>{<br/>    public class RegisterHelper<br/>    {<br/>        public static void RegisterServices()<br/>        {<br/>");<br/>            // Get all the classes with the AutoRegisterAttribute<br/>            INamedTypeSymbol attributeSymbol =<br/> compilation.GetTypeByMetadataName("CodeGeneratorDemo.SourceGeneratorDemo.AutoRegisterAttribute");<br/>            foreach (var candidateClass in receiver.CandidateClasses)<br/>            {<br/>                SemanticModel model = compilation.GetSemanticModel(candidateClass.SyntaxTree);<br/>                if (model.GetDeclaredSymbol(candidateClass) is ITypeSymbol typeSymbol &amp;&amp;<br/>                    typeSymbol.GetAttributes().Any(x =&gt;<br/>                        x.AttributeClass.Equals(attributeSymbol, SymbolEqualityComparer.Default)))<br/>                {<br/>                    stringBuilder.Append($@"<br/>            DiContainerMocker.RegisterService&lt;I{candidateClass.Identifier.Text}, {candidateClass.Identifier.Text}&gt;(new {candidateClass.Identifier.Text}());");<br/>                }<br/>            }<br/>            stringBuilder.Append(@"<br/>        }<br/>    }<br/>}");<br/>            context.AddSource("RegisterServiceHelper", SourceText.From(stringBuilder.ToString(), Encoding.UTF8));<br/>        }<br/>    }</span></pre><p id="fc4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你不熟悉罗斯林，这个方法可能看起来很复杂。它使用Roslyn API来获取类的元数据——有点类似于反射。您可以查看文档以了解更多信息:</p><ul class=""><li id="9809" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/work-with-syntax?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">使用语法</a></li><li id="ec32" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/work-with-semantics?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">使用语义</a></li><li id="5cf4" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><a class="ae lc" href="https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/syntax-visualizer?tabs=csharp&amp;WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">使用Visual Studio中的Roslyn语法可视化工具浏览代码</a></li></ul><p id="7629" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了更好地检查我们项目中的语法树，您可以安装<strong class="js iu">。NET编译器平台SDK </strong>来自<strong class="js iu"> Visual Studio Installer </strong>，为VS2019提供SyntaxVisualizer窗口。</p><figure class="mk ml mm mn gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nr"><img src="../Images/9d51071b49a99db67865798083485ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cx_ITf22eANB8Mu3JxLR_A.png"/></div></div></figure><p id="8fed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦我们找到了由<code class="fe mg mh mi mj b">AutoRegister</code>属性修饰的类，我们就可以添加注册实例的源代码。生成的代码会和原代码一起编译。通过这种方式，我们避免了昂贵的反射成本并提高了性能。</p><p id="1f72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们可以在客户端调用生成的代码:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="fd9c" class="ms le it mj b gy mt mu l mv mw">private static void SourceGeneratorSample()<br/>{<br/>    Console.WriteLine("Here is the simple Source Generator sample:");<br/>    CodeGeneratorDemo.SourceGeneratorDemo.SpeakerHelper.SayHello();<br/>    Console.WriteLine();<br/>    Console.WriteLine("Here is the AutoRegisterAttribute Source Generator sample:");<br/>    CodeGeneratorDemo.SourceGeneratorDemo.RegisterHelper.RegisterServices();<br/>}</span></pre><p id="bdce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您需要构建<strong class="js iu"> CodeGeneratorDemo。SourceGeneratorDemo </strong>项目然后重新打开VS2019。然后您可以看到这样的输出:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="d10b" class="ms le it mj b gy mt mu l mv mw">Here is the AutoRegisterAttribute Source Generator sample:<br/>CodeGeneratorDemo.Client.Core.OrderService constructed.<br/>CodeGeneratorDemo.Client.Core.OrderService has been registered for CodeGeneratorDemo.Client.Core.IOrderService.<br/>CodeGeneratorDemo.Client.Core.ProductService constructed.<br/>CodeGeneratorDemo.Client.Core.ProductService has been registered for CodeGeneratorDemo.Client.Core.IProductService.</span></pre><p id="48af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你按下<code class="fe mg mh mi mj b">RegisterServices()</code>上的<code class="fe mg mh mi mj b">F12</code>来检查它的定义，你会看到生成的代码如下:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="060b" class="ms le it mj b gy mt mu l mv mw">using System;<br/>using CodeGeneratorDemo.SourceGeneratorDemo.Core;<br/>namespace CodeGeneratorDemo.SourceGeneratorDemo<br/>{<br/>    public class RegisterHelper<br/>    {<br/>        public static void RegisterServices()<br/>        {<br/>            DiContainerMocker.RegisterService&lt;IProductService, ProductService&gt;(new ProductService());<br/>            DiContainerMocker.RegisterService&lt;IOrderService, OrderService&gt;(new OrderService());<br/>        }<br/>    }<br/>}</span></pre><p id="6a57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这正是我们想要的。</p><p id="12e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">酷的事情是，如果您删除或添加服务的<code class="fe mg mh mi mj b">AutoRegister</code>，您会看到生成的代码将立即更新-不需要重建项目！</p><h1 id="35cf" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">如何调试源代码生成器</h1><p id="146b" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">有时我们需要调试源代码生成器，以防出现任何问题。如果在源代码生成器中设置断点，您会发现它不起作用。解决方案是在<code class="fe mg mh mi mj b">Initialize</code>方法中附加调试器:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="76ee" class="ms le it mj b gy mt mu l mv mw">        public void Initialize(GeneratorInitializationContext context)<br/>        {<br/>#if DEBUG<br/>            if (!Debugger.IsAttached)<br/>            {<br/>                Debugger.Launch();<br/>            }<br/>#endif<br/>            context.RegisterForSyntaxNotifications(() =&gt; new MySyntaxReceiver());<br/>        }</span></pre><p id="ad92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，您可以通过设置断点来调试源代码生成器。</p><h1 id="4a09" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">如何处理复杂的模板代码？</h1><p id="3caa" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">在这两个例子中，我演示了如何使用源代码生成器生成代码。我们在<code class="fe mg mh mi mj b">Execute</code>方法中使用了原始字符串——这看起来很难看。更好的方法是使用模板引擎。一个可能的选择是<a class="ae lc" href="https://github.com/scriban/scriban" rel="noopener ugc nofollow" target="_blank">Scriban</a>——一种快速、强大、安全和轻量级的. NET脚本语言和引擎。因此我们可以将模板存储在单独的文件中，并使解决方案整洁。我不会深入研究模板语法，因为这超出了本文的范围。你可以在它的GitHub repo上找到更多。</p><h1 id="da34" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">使用场景</h1><p id="2c38" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">微软提供了一个源代码生成器指南。可以在GitHub上找到:<a class="ae lc" href="https://github.com/dotnet/roslyn/blob/master/docs/features/source-generators.cookbook.md" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/dot net/roslyn/blob/master/docs/features/source-generators . cookbook . MD</a>。您将看到源代码生成器可以应用于许多场景，尤其是替换反射，或者当您开发样板代码时。例如，一些JSON序列化经常使用动态分析，比如在运行时反射来检查类型。源代码生成器可以在编译时生成静态序列化代码，以节省成本。您还可以访问其他文件，如XML或JSON文件来生成您的代码。</p><p id="57a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在GitHub上查找更多示例:<a class="ae lc" href="https://github.com/dotnet/roslyn-sdk/tree/master/samples/CSharp/SourceGenerators" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/dot net/roslyn-SDK/tree/master/samples/cs harp/source generators</a>。</p><h1 id="2391" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">摘要</h1><p id="18e5" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">在本文中，我将向您介绍在C#程序中生成代码的四种方法。它们可能适合不同的场景，所以我们需要比较每种方法并选择合适的方法。</p><ul class=""><li id="ec53" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated"><strong class="js iu">代码片段</strong>:创建特定格式的代码块，如属性、方法、类等。<strong class="js iu">优点</strong>:节省键入重复代码块的时间。<strong class="js iu">缺点</strong>:只能适用于特定格式。无法自动更新。</li><li id="8b82" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">反射:在运行时获取元数据，然后与类、属性、方法等交互。<strong class="js iu">优点</strong>:强大灵活，适合多种场景。可以减少耦合。<strong class="js iu">缺点</strong>:成本贵。潜在的性能问题。维护起来更复杂。</li><li id="1bf4" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><strong class="js iu"> T4模板</strong>:生成一些样板代码。但有时它可以被设计模式重构。<strong class="js iu">优点</strong>:可以从其他文件中读取数据。许多可用的控制块。可以生成静态代码而没有性能问题。<strong class="js iu">缺点:</strong>可怕的编辑支持。模板容易出错。</li><li id="d1d8" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated"><strong class="js iu">源生成器</strong>:替换一些反射代码。基于Roslyn在编译中生成静态代码。优点:没有性能问题。更快的构建。智能感知支持。当无法生成源代码时，可以生成诊断。分部类/方法支持。缺点:工具需要改进。开始有点困难。</li></ul><p id="f561" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重点是我们如何使用源代码生成器——中提供的新特性。净5。它仍在预览中，所以我们可能很快就会看到微软的更多改进。我的期望是与VS2019更好的集成。现在体验不够好是因为必须反复重开VS。希望这篇文章能帮助你节省C#开发的时间。如果您有任何想法，请随时留下您的评论。谢了。</p></div></div>    
</body>
</html>