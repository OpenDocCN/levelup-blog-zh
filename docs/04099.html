<html>
<head>
<title>How to Write Thread-Safe Code With Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Kotlin编写线程安全的代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-write-thread-safe-code-with-kotlin-8a56ca6ff7a?source=collection_archive---------1-----------------------#2020-06-09">https://levelup.gitconnected.com/how-to-write-thread-safe-code-with-kotlin-8a56ca6ff7a?source=collection_archive---------1-----------------------#2020-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/773165e2fea884aebaf00c984a6c274c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*adSBeJp008q5hCblt4M3xw.png"/></div></div></figure><p id="2147" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Kotlin 使得编写<strong class="kd iu">线程安全</strong>代码变得容易(特别是如果我们把它与Java相比的话)，然而如果开发者想要他/她的代码真正是线程安全的，他/她仍然必须遵循一些基本规则。这个故事将介绍要遵循的主要规则，以及Kotlin提供的工具，但首先让我们讨论一下什么是<em class="kz">线程安全</em>代码。</p><h2 id="5bb8" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">线程安全代码</h2><p id="d5dd" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">当代码需要使用多个线程运行时，可能会出现各种各样的问题，主要分为以下几类:</p><ul class=""><li id="e48f" class="ly lz it kd b ke kf ki kj km ma kq mb ku mc ky md me mf mg bi translated"><strong class="kd iu">并发修改</strong>(或竞争条件):两个线程同时试图修改一个对象，如果对象是一个集合，通常会导致应用崩溃；这个问题通常可以通过使用同步节来解决。</li><li id="7e92" class="ly lz it kd b ke mh ki mi km mj kq mk ku ml ky md me mf mg bi translated"><strong class="kd iu">死锁(或活锁)</strong>:当尝试使用同步段时，我们可能会创建两个线程互相等待的情况；这导致应用程序冻结。</li></ul><p id="36fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">防止这些问题的黄金法则是只使用<strong class="kd iu">不可变对象</strong>。不可变对象是其状态在创建后不能改变的对象。因此，不存在并发修改的风险，并且由于不需要同步，我们还防止了死锁的风险。这也是为什么在本文<strong class="kd iu">中，我们将关注无需同步就能实现线程安全的技术</strong>。</p><p id="9d37" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是说起来容易，实现起来通常更难，尤其是当来自传统上对象是有状态的Java背景时(POJO、beans等)。).幸运的是，Kotlin提供了大量的语法糖，这将帮助我们在不损失太多性能的情况下，创建不可变的对象，以及更一般的线程安全代码。</p><h2 id="8d6e" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">尽可能使用val</h2><p id="f3b8" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">在Kotlin中声明变量或类成员时，我们可以在两个关键字之间进行选择:<strong class="kd iu"> val </strong>和<strong class="kd iu"> var </strong>。</p><p id="6526" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz"> var </em>基本上是指引用或变量的值是可以改变的，而<em class="kz"> val </em>是指它将是常量(只初始化一次)。</p><p id="b8ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们想要创建一个不可变的对象，那么它的所有成员都应该用关键字<em class="kz"> val </em>声明。<em class="kz"> var </em>关键字应该只用于局部变量(即函数或方法内部的变量)。</p><h2 id="d935" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">使用科特林的不可变集合</h2><p id="60cc" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">使用<em class="kz"> val </em>关键字只能确保变量总是引用同一个对象。如果我写:</p><blockquote class="mm mn mo"><p id="83c0" class="kb kc kz kd b ke kf kg kh ki kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ky im bi translated"><strong class="kd iu">val</strong>list = ArrayList&lt;String&gt;()</p></blockquote><p id="04f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么“列表”将总是引用同一个列表，但这并不意味着列表将是恒定的:我们仍然可以从列表中添加或删除元素。这意味着<strong class="kd iu">如果这个列表是类的成员，代码有可能不是线程安全的</strong>:如果两个线程试图调用一个改变列表内容的方法，将会有一个并发修改异常。</p><p id="9903" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了避免这种情况，最好使用Kotlin的不可变集合。而不是写:</p><blockquote class="mm mn mo"><p id="7879" class="kb kc kz kd b ke kf kg kh ki kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ky im bi translated"><strong class="kd iu">val</strong>list = arrayListOf&lt;String&gt;()</p></blockquote><p id="500c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">偏好写作:</p><blockquote class="mm mn mo"><p id="6caa" class="kb kc kz kd b ke kf kg kh ki kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ky im bi translated"><strong class="kd iu">val</strong>list = list of&lt;String&gt;()</p></blockquote><p id="ad1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当第一个创建一个可变列表时，第二个将创建一个没有任何方法来从列表中添加或删除元素的列表。当然，这意味着在创建列表时，我们必须知道我们希望列表中包含哪些元素。</p><p id="bf76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，列表可能会像这样初始化:</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6e5a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第一个例子中，我们给出了列表中的所有值。对于第二个，使用lambda表达式初始化值，该表达式的参数是列表中元素的索引(列表构造函数的第一个参数是列表的期望大小)。注意:在Kotlin中，<em class="kz"> List </em>是一种不可变列表，而<em class="kz"> ArrayList </em>是一种可变列表。</p><p id="fe24" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于不可变列表的初始化，也可以将可变列表声明为局部变量，然后将对该列表的引用存储为不可变列表:</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e2a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，我们必须确保我们不会保留对可变列表的任何引用，因为它应该只是一个帮助我们编写不可变列表初始化的工具，而不是我们以后要使用的东西。</p><h2 id="2abf" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">使用数据类</h2><p id="8231" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">数据类是一种特殊的类，其主要目的是保存数据。像任何其他类一样，这些数据类可以有成员和方法，但是它们在编写线程安全代码时也提供了一个非常有用的方法:<em class="kz"> copy() </em>方法。</p><p id="5224" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设我们声明一个数据类来保存一些数据。我们希望这个类中的对象是不可变的，因为我们正在编写线程安全的代码，所以所有的属性都必须用关键字<em class="kz"> val </em>声明。现在，我们正在操作这个类中的一个对象，我们想“改变”它的一个成员的值:我们没有其他选择，只能用这个成员的新值创建一个相同类的新对象。</p><p id="7aeb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于标准类，编写起来相当烦人。但是数据类提供了语法上的好处来使它变得容易。它是这样工作的:</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2ab4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，也可以封装此行为，使其看起来像是我们真的在修改对象，而实际上我们是在创建一个新对象:</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7172" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，我们提出一个线程安全的<em class="kz"> changePassword </em>方法，它并不真正改变用户的密码，而是通过创建一个新用户来看起来像是这样，这个新用户是原始用户的精确副本，但是具有新的密码。</p><p id="c894" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意:<em class="kz"> copy() </em>没有对对象进行深度复制，因此如果数据对象存储了对可变对象的引用，那么对该对象内容的任何更改都将出现在原始数据对象及其副本中。</p><h2 id="0930" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">使用同步块</h2><p id="55ce" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">只使用不可变对象并不总是可能的。有时，如果我们必须频繁地编辑对象的内容，那么为了改变属性值而创建不可变对象的新副本的成本会非常高。</p><p id="a0ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果是这种情况，我们将不得不切换回更经典的方法，使用同步块。</p><p id="d13c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与Java不同，Kotlin不提供一个<em class="kz">同步</em>关键字来允许我们编写互斥部分。但是，这并不重要，因为Kotlin提供了一个<em class="kz">同步</em>函数来实现相同的目的:</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="dd97" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是正如我上面所说的，<strong class="kd iu">如果可能的话，我们应该避免使用同步块</strong>，因为这会导致死锁问题。这种解决方案只有在使用不可变对象严重影响性能时才有好处。</p><h2 id="900e" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">使用已经定义的线程安全结构</h2><p id="c35a" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">如果不能套用之前给的建议，还是有办法的。JVM定义了几个基本上线程安全的类和集合。</p><p id="dcd3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有<em class="kz">原子</em>原语，比如<em class="kz">原子集成器</em>。即使几个线程试图同时修改一个<em class="kz"> AtomicInteger </em>的值，我们也永远不会有一个由竞争条件引起的这种对象的未定义状态。</p><p id="dfbb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有线程安全的集合，比如<em class="kz">collections . synchronized list</em>。</p><p id="0ff2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我个人不建议使用这些解决方案，原因有二:</p><ul class=""><li id="168d" class="ly lz it kd b ke kf ki kj km ma kq mb ku mc ky md me mf mg bi translated">它们不是多平台的:它们依赖于JVM，所以不能与Kotlin/Native(当然还有Kotlin/JS)一起使用</li><li id="af51" class="ly lz it kd b ke mh ki mi km mj kq mk ku ml ky md me mf mg bi translated">同步的集合并不完全是线程安全的，仍然有可能触发ConcurrentModificationException，所以开发人员通常必须添加额外的同步层</li></ul></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="550a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总之，我们已经看到了Kotlin提供的确保线程安全的主要工具:</p><ul class=""><li id="4e7f" class="ly lz it kd b ke kf ki kj km ma kq mb ku mc ky md me mf mg bi translated">val关键字帮助我们定义不可变的对象</li><li id="11a9" class="ly lz it kd b ke mh ki mi km mj kq mk ku ml ky md me mf mg bi translated">提供<strong class="kd iu">不可变集合</strong>的标准库</li><li id="ced6" class="ly lz it kd b ke mh ki mi km mj kq mk ku ml ky md me mf mg bi translated">由<strong class="kd iu">数据类</strong>提供的一些语法糖，帮助我们操作不可变的对象</li></ul><p id="2cbf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们没有选择，我们仍然可以依靠:</p><ul class=""><li id="77c8" class="ly lz it kd b ke kf ki kj km ma kq mb ku mc ky md me mf mg bi translated">语言的<strong class="kd iu">同步机制</strong>，这里快速介绍</li><li id="b422" class="ly lz it kd b ke mh ki mi km mj kq mk ku ml ky md me mf mg bi translated">Java标准库的同步类(如果我们计划在JVM上运行)</li></ul><p id="dab2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，多线程的主题非常广泛，Kotlin为此提供了许多便利的特性，我们在那里没有研究过。但是如果您想丰富您的文化，您可以看看Kotlin提供的高级同步机制和协程的用法。</p><p id="6aaa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，这些解决方案并不神奇，如果您不小心，它们不会让您编写线程安全的代码，这就是为什么线程安全数据结构的定义(主要使用不可变对象)应该始终作为编写多线程代码的基础。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><div class="ms mt mu mv gt nf"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">编写面试问题</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">技术开发</p></div></div><div class="no l"><div class="np l nq nr ns no nt jz nf"/></div></div></a></div></div></div>    
</body>
</html>