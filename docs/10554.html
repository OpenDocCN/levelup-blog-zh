<html>
<head>
<title>Public Errors from a REST API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">来自REST API的公共错误</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/public-errors-from-a-rest-api-87c61796d02c?source=collection_archive---------21-----------------------#2021-12-19">https://levelup.gitconnected.com/public-errors-from-a-rest-api-87c61796d02c?source=collection_archive---------21-----------------------#2021-12-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="939b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在GO中实现公共错误契约</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d9be880ae83e1008b063183f85e24d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rlbJwfRc9B-iAnYhfA7dsQ.png"/></div></div></figure><h1 id="bb53" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="a52a" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">今天我想分享一个关于如何实现应该公开的错误的想法。你知道，基于这些，各种客户端可以向用户显示特定的消息，从后备服务请求附加信息，等等。</p><p id="7e0b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在与第三方集成打交道的这些年里，我注意到的是，API调用中返回的错误并不清晰，并且不能确保在相同的API版本中存在错误契约。<br/>我最近遇到的一个例子是，当我在构建支付解决方案时，我想知道客户余额何时为空，以便显示正确的消息并向用户提供充值服务。我从第三方提供商那里得到的答案是……嗯，大概是这样</p><blockquote class="mn mo mp"><p id="7334" class="lm ln mq lo b lp mi ju lr ls mj jx lu mr mk lx ly ms ml mb mc mt mm mf mg mh im bi translated"><em class="it">我们将返回空余额的内部错误，但请放心，您可以调用另外3或4个端点并自己计算余额。</em></p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/219a074a4034b85de487e6f3688c9885.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*hGEas-LAxSI1-hLl.jpg"/></div></figure><p id="cb68" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">当我问他们，当帐户被封锁时，他们会返回什么错误，他们似乎很困惑，几天后才回答这个问题。</p><p id="22e3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">summa summaryum——他们的实现不允许知道各种场景中存在什么样的错误，他们需要分析流程以了解错误可能发生在哪里以及将返回什么样的错误代码。最糟糕的是，缺乏抽象，这意味着错误代码<em class="mq">帐户被阻止</em>可能会变成<em class="mq">帐户被阻止</em>，而之前没有任何更新。</p><p id="9318" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这也是故事之一，但我也面临过很多类似的问题，所以处理必须公开的错误并保持契约稳定似乎是一个严重的问题。或者也许我周围有某种坏运气的光环👺。无论如何，这是如何在围棋中解决这个问题的想法，它是基于大卫·切尼关于处理错误的<a class="ae mv" href="https://dave.cheney.net/2014/12/24/inspecting-errors" rel="noopener ugc nofollow" target="_blank">旧帖子。</a></p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="0cc6" class="ku kv it bd kw kx nd kz la lb ne ld le jz nf ka lg kc ng kd li kf nh kg lk ll bi translated">处理错误</h1><p id="9795" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">错误应该在返回给公共客户端之前在顶层处理。之所以要在这里完成，唯一的原因是业务层可以用在不同的地方。例如，相同的业务方法<code class="fe ni nj nk nl b">users.Find()</code>可以从UI网站等外部来源调用，也可以从管理员命令行工具等内部来源调用。这两种方式下，它们的行为应该是相同的，并且在这两种方式下，它们都应该显示一些错误。然而，用户界面和管理员界面上显示的内容可能不同。</p><p id="de10" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">UI只能返回错误代码，但是管理员也可以看到关于错误的更多细节以及如何解决它们的一些见解。</p><p id="1d9e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然而，当业务逻辑改变时，它不能影响UI或管理员面板。除非这是一个突破性的改变，但这是完全不同的话题...</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="d6fb" class="ku kv it bd kw kx nd kz la lb ne ld le jz nf ka lg kc ng kd li kf nh kg lk ll bi translated">代码示例</h1><p id="b618" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">为了让事情更清楚，让我们使用一些代码示例。<a class="ae mv" href="https://github.com/b-pagis/go-public-errors-example" rel="noopener ugc nofollow" target="_blank">这里有一个</a>的例子，由以下内容组成:</p><ul class=""><li id="51ef" class="nm nn it lo b lp mi ls mj lv no lz np md nq mh nr ns nt nu bi translated">业务逻辑(<code class="fe ni nj nk nl b">users</code>目录)</li><li id="1cbb" class="nm nn it lo b lp nv ls nw lv nx lz ny md nz mh nr ns nt nu bi translated">假冒存储服务与信息(<code class="fe ni nj nk nl b">repository</code>目录)</li><li id="e918" class="nm nn it lo b lp nv ls nw lv nx lz ny md nz mh nr ns nt nu bi translated">带有REST API的HTTP服务器-由公共客户端使用(<code class="fe ni nj nk nl b">http</code>目录和<code class="fe ni nj nk nl b">cmd/http-example</code>目录)</li><li id="8ef2" class="nm nn it lo b lp nv ls nw lv nx lz ny md nz mh nr ns nt nu bi translated">最后是代表管理员实用工具(<code class="fe ni nj nk nl b">cmd/cli-example</code>目录)的CLI</li></ul><pre class="kj kk kl km gt oa nl ob oc aw od bi"><span id="990b" class="oe kv it nl b gy of og l oh oi">.<br/>├── cmd<br/>│   ├── cli-example<br/>│   │   ├── main.go<br/>│   └── http-example<br/>│       └── main.go<br/>├── curler.sh<br/>├── go.mod<br/>├── http<br/>│   ├── error.go<br/>│   ├── handlers.go<br/>│   └── middleware.go<br/>├── repository<br/>│   ├── current<br/>│   │   ├── error.go<br/>│   │   └── current.go<br/>│   └── legacy<br/>│       ├── error.go<br/>│       └── legacy.go<br/>└── users<br/>    ├── errors.go<br/>    └── users.go</span></pre></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="3bf5" class="ku kv it bd kw kx nd kz la lb ne ld le jz nf ka lg kc ng kd li kf nh kg lk ll bi translated">实现包级错误</h1><p id="1be4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果您研究了项目结构，很可能您已经注意到每一层都有自己的错误实现和自己的错误代码。这种模式提供了更多的灵活性，并且没有引入集中的错误管理机制，所有的错误都在一个地方处理。</p><p id="657c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我认为，从长远来看，全局错误管理器是邪恶的，因为随着时间的推移，当有人想要替换代码的某些部分时，它只会变得越来越大，那么每次都肯定会触及全局错误处理程序。这增加了全球性破坏的风险。</p><p id="0a1c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">此外，使用全局错误管理器，业务逻辑在某个时候可能会被放入其中，因为这样做更方便、更简单、更快或有任何其他原因。</p><p id="536f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">当它被分离时，它保持简单、小，并且只与特定的层相关，因此更容易应用改变或者完全替换整个实现。</p><p id="4d0d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这里是<code class="fe ni nj nk nl b">user</code>错误实现。</p><pre class="kj kk kl km gt oa nl ob oc aw od bi"><span id="26f1" class="oe kv it nl b gy of og l oh oi">package users<br/><br/>// Error custom error type for the users domains<br/>type Error struct {<br/>	errCode    string<br/>	errMessage string<br/>}<br/><br/>func newError(code string, message string) error {<br/>	return Error{errCode: code, errMessage: message}<br/>}<br/><br/>func (e Error) Error() string {<br/>	return e.errMessage<br/>}<br/><br/>func (e Error) Code() string {<br/>	return e.errCode<br/>}</span></pre><blockquote class="mn mo mp"><p id="388c" class="lm ln mq lo b lp mi ju lr ls mj jx lu mr mk lx ly ms ml mb mc mt mm mf mg mh im bi translated">当然，这种方法也有一些缺点——代码重复，这会让一些狂热的DRY开发者抓狂。此外，在非常大的项目中处理它可能会非常烦人。然而，依我看，前者比后者更有可能发生😄</p></blockquote></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="2bd9" class="ku kv it bd kw kx nd kz la lb ne ld le jz nf ka lg kc ng kd li kf nh kg lk ll bi translated">返回错误</h1><p id="2a2e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">因为自定义错误实现符合标准错误的签名。我们只是简单地为我们关心的情况创建新的错误并传递它。</p><p id="6008" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">未找到案例的存储库错误示例:</p><pre class="kj kk kl km gt oa nl ob oc aw od bi"><span id="388e" class="oe kv it nl b gy of og l oh oi">return users.User{}, internalError{code: "notFound", msg: "user not found"}<br/>}</span></pre><blockquote class="mn mo mp"><p id="ddf5" class="lm ln mq lo b lp mi ju lr ls mj jx lu mr mk lx ly ms ml mb mc mt mm mf mg mh im bi translated"><em class="it">注意:如果需要，也可以包装原始错误。</em></p></blockquote></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="c36e" class="ku kv it bd kw kx nd kz la lb ne ld le jz nf ka lg kc ng kd li kf nh kg lk ll bi translated">根据行为采取行动</h1><p id="2f9e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在业务领域中，我们检查错误行为，而不是实际检查错误类型。因此，如果第一次搜索返回一个错误，我们检查这个错误是否实现了方法<code class="fe ni nj nk nl b">NotFound()</code>,如果是，并且如果确实没有找到错误，那么我们检查用户是否是遗留存储库。</p><pre class="kj kk kl km gt oa nl ob oc aw od bi"><span id="aef3" class="oe kv it nl b gy of og l oh oi">type notFounder interface {<br/>  NotFound() bool<br/>}<br/><br/>if e, ok := err.(notFounder); !ok {<br/>  return User{}, err<br/>} else {<br/>  if !e.NotFound() {<br/>    return User{}, err<br/>  }<br/>}<br/><br/>user, err = u.LegacyDB.Find(searchableUserName)<br/><br/>if err != nil {<br/>  return User{}, err<br/>}</span></pre><p id="a121" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果我们也不能在遗留存储库中找到用户，我们简单地将错误传递给上层。这样，没有实现这种方法的数据库层错误将被传递给调用者。那些实现这种方法的将被用作业务流程的一部分。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="74ae" class="ku kv it bd kw kx nd kz la lb ne ld le jz nf ka lg kc ng kd li kf nh kg lk ll bi translated">REST API契约</h1><p id="dc4d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">REST API是最后一层，信息从这里传递回调用者，所以这可能是我们可以定义和处理公共错误的最好地方。</p><p id="a511" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">有几种方法可以实现这一点。例如，我们可以在处理程序中通过定义带有相应HTTP状态代码的公共错误列表来实现:</p><pre class="kj kk kl km gt oa nl ob oc aw od bi"><span id="a31f" class="oe kv it nl b gy of og l oh oi">type publicErrors map[string]int<br/><br/>publicErrs := publicErrors{<br/>	"notFound":        http.StatusNotFound,<br/>	"sessionNotFound": http.StatusForbidden,<br/>}</span></pre><p id="cb54" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后像我们之前在业务级别所做的那样检查行为:</p><pre class="kj kk kl km gt oa nl ob oc aw od bi"><span id="fcbf" class="oe kv it nl b gy of og l oh oi">if err != nil {<br/>		log.Println(err)<br/>		if publicErrs.isPublic(err) {<br/>			w.Header().Add("Content-Type", "application/problem+json")<br/>			w.WriteHeader(publicErrs.HTTPStatusCode(err))<br/>			w.Write([]byte(`{"code":"` + publicErrs.Code(err) + `", "message":"` + err.Error() + `"}`))<br/><br/>			return<br/>		} else {<br/>			w.Header().Add("Content-Type", "application/problem+json")<br/>			w.WriteHeader(http.StatusInternalServerError)<br/>			w.Write([]byte(`{"code":"internalError"}`))<br/><br/>			return<br/>		}<br/>	}</span></pre><h2 id="9ade" class="oe kv it bd kw oj ok dn la ol om dp le lv on oo lg lz op oq li md or os lk ot bi translated">使用中间件</h2><p id="5ea0" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">对于那些不喜欢冗长工作方式的人来说，还有一种使用中间件的方法，它会以某种常见的方式处理公共错误响应。同样，我们需要用相应的HTTP状态定义公共错误列表，并返回包含该列表的新错误。</p><pre class="kj kk kl km gt oa nl ob oc aw od bi"><span id="db5e" class="oe kv it nl b gy of og l oh oi">publicErrs := publicErrors{<br/>		"notFound":            http.StatusNotFound,<br/>		"sessionNotFound":     http.StatusForbidden,<br/>		"adminAccessRequired": http.StatusForbidden,<br/>	}<br/><br/>	currentUser, err := getUserSession(currentUserID)<br/><br/>	if err != nil {<br/>		return nil, handlerError{allowedList: publicErrs, originalErr: err}<br/>	}</span></pre><p id="ebd8" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后我们创建一个中间件，在那里我们检查error是否实现了特定的功能，帮助我们确定我们的错误是否是公开的。</p><pre class="kj kk kl km gt oa nl ob oc aw od bi"><span id="adcb" class="oe kv it nl b gy of og l oh oi">type handlerErr interface {<br/>	Public() bool<br/>	HTTPStatusCode() int<br/>	Code() string<br/>	Error() string<br/>}<br/><br/>if e, ok := err.(handlerErr); ok &amp;&amp; e.Public() {<br/>	w.WriteHeader(e.HTTPStatusCode())<br/>	w.Write([]byte(`{"code":"` + e.Code() + `", "message":"` + err.Error() + `"}`))<br/>	return<br/>}<br/><br/>w.WriteHeader(http.StatusInternalServerError)<br/>w.Write([]byte(`{"code":"internalError"}`))<br/><br/>return</span></pre><p id="1175" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这样做可以让我们去掉多个HTTP writer函数调用，让处理程序更简洁。然而，如果我们需要在处理程序中使用cookies、查询参数、头或其他信息，这种方法可能会有点麻烦。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="0526" class="ku kv it bd kw kx nd kz la lb ne ld le jz nf ka lg kc ng kd li kf nh kg lk ll bi translated">响应和输出</h1><p id="dfc4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在本文的开头，我说过无论在哪里使用，业务实现都应该是相同的，所以如果您看过代码，就会发现我们对HTTP和CLI的错误处理是不同的。</p><p id="7c8b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">CLI返回有关它的更多信息，因为它仅供管理员内部使用。另一方面，HTTP返回的信息较少。</p><p id="31c0" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">以下是他们三人的回答，以供比较</p><h2 id="0277" class="oe kv it bd kw oj ok dn la ol om dp le lv on oo lg lz op oq li md or os lk ot bi translated">CLI </h2><pre class="kj kk kl km gt oa nl ob oc aw od bi"><span id="daef" class="oe kv it nl b gy of og l oh oi">***************<br/>* Scenario #1 *<br/>***************<br/>action: 	 searching for: Maria<br/>outcome:	 failed to get user Maria. Error: need higher access level<br/><br/>***************<br/>* Scenario #2 *<br/>***************<br/>action: 	 searching for: Maria<br/>outcome:	 found user: {ID:1 Name:Maria AccessLevel:1}<br/><br/>action: 	 searching for: Nushi<br/>outcome:	 failed to get user: Nushi. Error: need admin access level<br/><br/>action: 	 searching for: Mohammed<br/>outcome:	 found user: {ID:3 Name:Mohammed AccessLevel:3}<br/><br/>action: 	 searching for: Jose<br/>outcome:	 issue with third party, please contact support@thirdparty<br/><br/>action: 	 searching for: Wei<br/>outcome:	 failed to get user: Wei. Error: user not found</span></pre><h2 id="993b" class="oe kv it bd kw oj ok dn la ol om dp le lv on oo lg lz op oq li md or os lk ot bi translated"><strong class="ak"> HTTP </strong></h2><p id="24aa" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo iu">带有公共错误和中间件</strong></p><pre class="kj kk kl km gt oa nl ob oc aw od bi"><span id="dfc8" class="oe kv it nl b gy of og l oh oi">HTTP Status Code|	Respoonse<br/>403		|  {"code":"sessionNotFound", "message":"session not found or expired"}<br/>500		|  {"code":"internalError"}<br/>404		|  {"code":"notFound", "message":"user not found"}<br/>200		|  {"id":"1","name":"Maria","accessLevel":1}<br/>403		|  {"code":"adminAccessRequired", "message":"need admin access level"}<br/>200		|  {"id":"3","name":"Mohammed","accessLevel":3}<br/>500		|  {"code":"internalError"}<br/>404		|  {"code":"notFound", "message":"user not found"}</span></pre><blockquote class="mn mo mp"><p id="801e" class="lm ln mq lo b lp mi ju lr ls mj jx lu mr mk lx ly ms ml mb mc mt mm mf mg mh im bi translated"><em class="it">注意:<br/> HTTP服务包含三个处理程序:</em></p><p id="5975" class="lm ln mq lo b lp mi ju lr ls mj jx lu mr mk lx ly ms ml mb mc mt mm mf mg mh im bi translated">-不使用公共错误的那个<br/> -使用公共错误且错误在处理程序<br/>中处理的那个-有公共错误但错误在中间件中处理的那个</p><p id="1335" class="lm ln mq lo b lp mi ju lr ls mj jx lu mr mk lx ly ms ml mb mc mt mm mf mg mh im bi translated"><em class="it">此外，与中间件一起使用的处理程序有一个额外的公共错误</em> <code class="fe ni nj nk nl b"><em class="it">adminAccessRequired</em></code> <em class="it">，因此响应与没有中间件的略有不同。</em></p></blockquote><h2 id="e5b4" class="oe kv it bd kw oj ok dn la ol om dp le lv on oo lg lz op oq li md or os lk ot bi translated">实施确实很重要</h2><p id="9ba4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">让我们先把CLI被管理员使用的事实放在一边，这样会暴露更多的信息。<a class="ae mv" href="https://github.com/b-pagis/go-public-errors-example/blob/main/cmd/cli-example/main.go" rel="noopener ugc nofollow" target="_blank"> CLI实现</a>没有遵循我们在<a class="ae mv" href="https://github.com/b-pagis/go-public-errors-example/blob/main/http/handlers.go" rel="noopener ugc nofollow" target="_blank"> HTTP处理程序</a>中看到的相同模式。现在让我们问自己几个问题:</p><ul class=""><li id="21b4" class="nm nn it lo b lp mi ls mj lv no lz np md nq mh nr ns nt nu bi translated">我们能知道CLI将返回哪些错误吗？</li><li id="474b" class="nm nn it lo b lp nv ls nw lv nx lz ny md nz mh nr ns nt nu bi translated">我们需要分析所有代码来了解所有可能的变化吗？</li><li id="5c96" class="nm nn it lo b lp nv ls nw lv nx lz ny md nz mh nr ns nt nu bi translated">我们能否确保错误不会改变，管理员不会感到困惑？</li></ul><p id="361e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在让我们问自己，哪种方法更经得起未来的考验，更清晰，并且可以在回答问题/分析上花费更少的时间？</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="7a0d" class="ku kv it bd kw kx nd kz la lb ne ld le jz nf ka lg kc ng kd li kf nh kg lk ll bi translated">结论</h1><p id="479c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这是一篇非常简短的帖子，使用了非常基本的代码示例，没有任何优化。然而，它展示了一个核心思想，即公共错误确实很重要，我们应该在实现任何解决方案之前考虑它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/aa10b9aa7f9a3a820be85bc2bbd14d18.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/1*ZgT2bTEx2A9pITM73ObNOQ.gif"/></div></div></figure></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="c8ac" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果你喜欢我写的东西，想听更多，你可以<a class="ae mv" href="https://medium.com/subscribe/@p.a.g.i.s" rel="noopener">订阅这里</a>。如果你不是灵媒的一员，并且想成为一名灵媒，你可以在这里<a class="ae mv" href="https://medium.com/@p.a.g.i.s/membership" rel="noopener">做！</a></p><p id="5ee5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">当然，你可以用一杯热的虚拟咖啡招待我，☕ <strong class="lo iu">😋</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://ko-fi.com/W7W04WZNY"><div class="gh gi ov"><img src="../Images/f70fb2bbb97e021536fd6f765c321c37.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*JTEj4geAZKmQXuEoWoZj7w.png"/></div></a></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://www.buymeacoffee.com/b.pagis"><div class="gh gi ow"><img src="../Images/fdca75bbe0eee382398964b8e17af001.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*2EZTVBB8eamy2BEJJYAnBg.png"/></div></a></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://github.com/sponsors/b-pagis?frequency=one-time"><div class="gh gi ox"><img src="../Images/96f2533283f86e5b77e1cb7b51b8478e.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/1*h8F2xLkLEM9_oBwh8_iJlA.png"/></div></a></figure><h1 id="6b36" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">链接</h1><div class="oy oz gp gr pa pb"><a href="https://github.com/b-pagis/go-public-errors-example" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">GitHub-b-pagis/go-public-errors-example</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">关于如何处理公共错误的想法。这种或类似实现的主要优点:确保稳定…</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">github.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp ks pb"/></div></div></a></div><div class="oy oz gp gr pa pb"><a href="https://dave.cheney.net/2014/12/24/inspecting-errors" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">检查错误</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">返回接口类型错误值的函数的常见约定是，调用者不应该假定…</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">dave.cheney.net</p></div></div></div></a></div></div></div>    
</body>
</html>