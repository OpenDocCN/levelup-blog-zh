<html>
<head>
<title>What’s the point of Functional Programming?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式编程有什么意义？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/whats-the-point-of-functional-programming-83920cf24a89?source=collection_archive---------4-----------------------#2020-05-06">https://levelup.gitconnected.com/whats-the-point-of-functional-programming-83920cf24a89?source=collection_archive---------4-----------------------#2020-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0f66d499d8e2f7aee608e7e04e2ae7ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lTzHxJUnfl82RIJMd_vbhA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">爵士树，漂亮但不相干的照片。图片来源:<a class="ae kf" href="https://unsplash.com/photos/GfAqbDrCoio" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/GfAqbDrCoio</a></figcaption></figure><p id="8ded" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最近我读了尼尔·福特的书《T2功能思维》。我觉得很有意思，决定在这个帖子里整理一下自己的想法。这篇文章绝不是书评，也不是TLDR。大部分内容都是基于我自己的经历和理解。</p><h1 id="a9b8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">关于我</h1><p id="baa2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我受过命令式编程和面向对象风格的“训练”。但是作为一个熟悉Ruby和JavaScript的程序员，我对函数式编程的“元素”有点熟悉。我知道“作为一等公民的功能”，库里，compose，声明式编程，以及它们在React和Redux等真实世界战场上的工作方式。我有一些使用Elixir的经验，知道如何用递归函数替换循环。但是，我仍然觉得缺少了一些东西:一个连接所有点的范式的全貌。我开始读这本书。</p><p id="5783" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在开始阅读之前，我心中有几个问题:</p><ol class=""><li id="940e" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">有什么意义？所有这些扭曲思维的优点是什么？</li><li id="906f" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">“元素”与函数式编程有什么关系？</li></ol><p id="1237" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">读完这本书后，我想我能以某种方式回答这些问题。</p><h1 id="bf28" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">超级简短的函数式编程概述</h1><p id="90e9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">让我们首先对函数式编程做一个非常简短和非正式的概述。函数式编程是一种范式，其中函数是一等公民，这意味着，用简单的话来说，它们可以出现在你能想到的任何地方。循环被诸如“map”、“reduce”和“filter”之类的抽象所取代。人们可以通过currying、composing或者利用闭包来创建函数。大多数时候，变量是不可变的，这意味着它们一旦创建就不能被修改。异常或堆栈跳转是不常见的，其含义不同于它们的命令式并行。</p><h1 id="6465" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">有什么意义？</h1><blockquote class="mv mw mx"><p id="c3fb" class="kg kh my ki b kj kk kl km kn ko kp kq mz ks kt ku na kw kx ky nb la lb lc ld im bi translated"><strong class="ki iu">这都是关于抽象的。</strong></p></blockquote><p id="d273" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数式编程抽象事物的方式不同于命令式编程。它从命令式操作中抽象出一些“操作”，比如循环、映射和归约。随着通常单调乏味的操作被抽象出来，开发人员可以专注于更高层次的逻辑，并使代码更具表现力。</p><p id="2d14" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了说明这一点，我将使用下面的JavaScript代码片段。虽然对许多人来说，它不是一种“合格的”函数式语言，但在这里足以证明这个想法。假设我们有一个数字列表，我们想找到偶数并加倍。(不要问我为什么这个世界会有人想那么做。)</p><p id="41d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于命令式方法:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="067e" class="nl lf it nh b gy nm nn l no np">const myNumberArray = findSomeNumberArray()<br/>const evenNums = []<br/>const doubled = []<br/>for (let i = 0; i &lt; myNumberArray.length; i += 1) {<br/>  if (isEven(num)) {<br/>    evenNums.push(myNumberArray[i])<br/>  }<br/>}<br/>for (let i = 0; i &lt; evenNums.length; i += 1) {<br/>  doubled.push(double(evenNums[i]))<br/>}</span></pre><p id="f976" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于功能方法:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="4712" class="nl lf it nh b gy nm nn l no np">const myNumberArray = findSomeNumberArray()</span><span id="ffab" class="nl lf it nh b gy nq nn l no np">function isEven (num) {<br/>  return num % 2 === 0<br/>}<br/>function double (num) {<br/>  return num * 2<br/>}</span><span id="8454" class="nl lf it nh b gy nq nn l no np">myNumberArray.filter(isEven)<br/>             .map(double)</span></pre><p id="5487" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，后一种方法<strong class="ki iu">更具表现力</strong>。一看就能知道代码想做什么(虽然背后的目的还很神秘，因为没有人。)此外，通过转移我们抽象的地方，<strong class="ki iu">我们不仅改变了代码重用的粒度，还改变了我们思考问题的抽象层。</strong>现在,“我是”和“双重”可以在其他地方分享，我们可以专注于我们想做的“什么”,而不是“如何”去做。</p><p id="5ce5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="my">抽象带来的另一个好处是它为运行时打开了“接缝”。</em> </strong>当垃圾收集器第一次被发明出来的时候，开发者的生活就在那一点上改变了。不再需要管理内存，开发人员可以更多地关注业务逻辑，而不是系统级的通信。与此同时，通过抽象上述“操作”,函数式语言为运行时打开了“接缝”,以接管一些潜在的繁琐工作，如<a class="ae kf" href="https://www.scala-lang.org/api/2.12.2/scala/collection/parallel/immutable/ParMap.html" rel="noopener ugc nofollow" target="_blank">并发处理</a>和状态管理(移动部分)。)</p><blockquote class="mv mw mx"><p id="1fba" class="kg kh my ki b kj kk kl km kn ko kp kq mz ks kt ku na kw kx ky nb la lb lc ld im bi translated">OO通过封装移动部分使代码变得可以理解。FP通过最大限度地减少活动部分来使代码易于理解。—迈克尔·费哲(引自该书)</p></blockquote><p id="0a7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最小化活动部分的函数式语言的一些例子是</p><ul class=""><li id="a323" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld nr mn mo mp bi translated">将并发控制与数据结构相结合</li><li id="1425" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld nr mn mo mp bi translated">通过不变性和纯函数最小化状态</li></ul><p id="7967" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，摆脱了“活动部件”(线程、状态管理)，开发人员可以更加关注业务逻辑和表达能力。</p><p id="010f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，没有什么是没有代价的。为了让语言运行库很好地处理这些任务，开发人员必须编写代码，甚至以特定的方式考虑问题。就像由于GC的存在，你在C++中组织代码的方式不同于在Java中一样，通常，我们需要在函数式语言中构造不同于命令式语言的逻辑。</p><p id="507d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我看来，这些责任转移与其说是对还是错，不如说是交易。我们开发人员的工作是为正确的任务找到正确的工具。</p><h1 id="09c7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">“元素”与函数式编程有什么关系？</h1><p id="2c51" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我经常听说函数式编程的“元素”，比如不可变的、处理异常的不同方式、递归。我分别理解他们每一个人。但我的问题是:<strong class="ki iu">它们和函数式编程有什么关系？</strong></p><p id="d5bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">不可变</strong></p><p id="dcbd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不可变数据一旦启动就不能被修改。这意味着，如果你持有相同的引用，你可以确定“值”是相同的。<strong class="ki iu">为了使大多数功能机制生效，需要<em class="my">传递的函数是纯的</em> </strong>:一个没有副作用的函数，其返回值完全由其输入参数决定。这就是为什么这么多函数式语言都有不可变的数据:只有当数据不可变时，函数才是纯粹的。</p><p id="6794" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">错误处理</strong></p><p id="7ec4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">处理错误最常见的方式是异常:您抛出一个异常，执行流程跳转到捕获它的代码行。</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="4cc7" class="nl lf it nh b gy nm nn l no np">function sthMightGoWrong (a, b) {<br/>  if (everythingGoesWell()) {<br/>    return 'the-result'<br/>  } else {<br/>    throw new Error('ops!')<br/>  }<br/>}</span><span id="a0f5" class="nl lf it nh b gy nq nn l no np">try {<br/>  const result = sthMightGoWrong('hello', 'world')<br/>} catch (e) {<br/>  // execution jumps to here<br/>}</span></pre><p id="56f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一种处理错误的方法是返回值。一些命令式语言(如Go)和大多数函数式语言(如Elixir)都使用这种机制。</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="7dbc" class="nl lf it nh b gy nm nn l no np">function sthMightGoWrong (a, b) {<br/>  if (everythingGoesWell()) {<br/>    return { ok: true, result: 'the-result' }<br/>  } else {<br/>    return { ok: false, return: null }<br/>  }<br/>}<br/>const { ok, result } = sthMightGoWrong('hello', 'world')<br/>if (!ok) {<br/>  // error handling without stack jumping here<br/>}</span></pre><p id="9ae4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">后者与函数式编程有关，因为<strong class="ki iu">堆栈跳转是一个副作用。</strong>一个函数如果可能抛出就不再是纯的:给定同一套输入参数，结果不止一个:返回一些值或者跳转到别的地方。这就是为什么传统的抛出/捕捉错误处理在函数式语言中并不常见。</p><p id="1f29" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">递归</strong></p><p id="f1f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">递归是一种我们通过调用函数本身来分而治之解决问题的技术(这是一个非常草率的定义。这里看官方的<a class="ae kf" href="https://en.wikipedia.org/wiki/Recursion_(computer_science)" rel="noopener ugc nofollow" target="_blank"/>。)这是一种可以解决棘手问题的方法，否则这些问题通常不是微不足道的。在函数式编程中，它经常被用来代替命令式语言中的循环控制流，如“for”和“while”。但是这里又来了，为什么呢？</p><p id="1543" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过循环多次说“嗨”,例如:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="4870" class="nl lf it nh b gy nm nn l no np">// say hi by loops<br/>function sayHi () { console.log('hi') }<br/>function sayHiForTimes (times) {<br/>  for (var i = 0; i &lt; times; i += 1) {<br/>    sayHi()<br/>  }<br/>}</span></pre><p id="528c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">递归地做这件事:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="9ece" class="nl lf it nh b gy nm nn l no np">function sayHi () { console.log('hi') }<br/>function sayHiForTimes (times) {<br/>  if (times === 0) {<br/>    return<br/>  }<br/>  sayHi()<br/>  sayHiForTimes(times - 1)<br/>}</span></pre><p id="f267" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">答案和上面类似:<strong class="ki iu">对于抽象工作带来的好处，一定不能有共享状态。</strong>例如，如果我们共享任何状态，运行时为我们处理并发就变得很困难，如果不是不可能的话。</p><p id="d1fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些循环使用共享状态来控制自然流。这就是我们使用递归的原因，递归将“状态”转移到后续的函数调用中。</p><h1 id="b473" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">事后思考</h1><p id="5e0c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">对我来说，最让我惊叹的是抽象方式的不同所带来的寓意和可能性。有时候，只有在最底层的东西被抽象掉之后，我们才能开始看到上层更大的画面。它类似于复利，因为当前回合获得的利益可以加快下一回合。</p><p id="c6af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，范式转换让我们以不同的方式解构一个问题，这总是一件令人愉快的事情。💖</p><p id="9c05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谢谢你的阅读。如果你有什么想讨论的，请在下面留下你的评论。</p></div></div>    
</body>
</html>