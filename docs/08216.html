<html>
<head>
<title>React Hooks, Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React挂钩，第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-hooks-part-1-304643294f5?source=collection_archive---------11-----------------------#2021-04-11">https://levelup.gitconnected.com/react-hooks-part-1-304643294f5?source=collection_archive---------11-----------------------#2021-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1180" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">功能之旅</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c67f52830d267700337bfad7e45abfac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GrlhfKLtfouO8nuAkQBrbA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">现在我已经引起你的注意了，让我们来学习钩子吧！<a class="ae kv" href="https://unsplash.com/@chen93?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">陈</a>在<a class="ae kv" href="https://unsplash.com/s/photos/hook?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="bfb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不知道你怎么想，但是我已经阅读了许多文章，试图理解React类组件中的绑定/调用/应用，但是这些信息还没有被理解。考虑到这一点，我真的很高兴知道React已经相当迅速地脱离了类组件，并且功能组件确实可以处理状态/有状态逻辑。输入钩子！根据<a class="ae kv" href="https://reactjs.org/docs/hooks-overview.html" rel="noopener ugc nofollow" target="_blank"> React.js文档</a> : <em class="ls">“钩子是让你从函数组件中“挂钩”React状态和生命周期特性的函数。”</em></p><p id="3f77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React Hooks的核心概念是由<a class="ae kv" href="https://twitter.com/sophiebits" rel="noopener ugc nofollow" target="_blank"> Sophie Alpert </a>和<a class="ae kv" href="https://overreacted.io/" rel="noopener ugc nofollow" target="_blank"> Dan Abramov </a>在2018年React Conf上介绍的。Sophie Alpert(她当时是脸书React核心团队的经理)，<em class="ls">“…许多有经验的开发人员告诉我们，类中绑定和“this”工作的方式非常令人困惑…类对人类来说很难…类对机器来说也很难…很难在编译时准确地说出所有方法是如何组合在一起的…类使得编译器更难优化。所以不是只有我一个人过得不好！😅</em></p><p id="5d7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类组件目前还没有被正式否决，所以任何新的React开发人员都应该确保他们了解类组件概念的基础和附带的样板代码。根据Dan Abramov的说法，<em class="ls">“在脸书，我们有数以万计的班级组成部分，像你一样，我们不打算重写它们。”</em>话虽这么说，钩子也越来越普遍了，再加上真的很厉害，很好学。所以让我们开始吧！</p><h2 id="c726" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">使用状态</h2><p id="c4f3" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">简而言之，<code class="fe mr ms mt mu b">useState</code>旨在代替我们的初始状态声明/赋值，下面的<code class="fe mr ms mt mu b">this.setState</code>是初始状态变量声明的典型示例，它在功能上相当于<code class="fe mr ms mt mu b">state = {faved: [], searchTerm: “”}</code>。</p><p id="12a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用array<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">destructing</a>首先声明我们的状态变量的名称，之后“set &lt; variable &gt;”声明将更新该状态变量的setter函数。(这是惯例。)useState后面的括号<code class="fe mr ms mt mu b">()</code>用于使用变量的初始值/默认值调用React的useState函数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/348dadab691e9655f82d44759050245b.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*7ffo_71TCGTeHRQw8jdsvw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">实际使用状态</figcaption></figure><p id="8006" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您在这里看到的，我们的状态被分解为单个的状态元素。这可以防止我们意外地覆盖整个状态对象。不错吧。您可以在一个组件中使用<code class="fe mr ms mt mu b">useState</code>任意多次。您可以将该变量元素作为道具传递给子组件，就像在类组件中一样。与类组件不同，每个状态元素不必声明为对象文字，尽管它当然可以。</p><p id="bec8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们使用功能等同于<code class="fe mr ms mt mu b">this.setState</code>。<code class="fe mr ms mt mu b">faved</code>以一个空数组开始(如上图),经过下面的一点逻辑，我们<code class="fe mr ms mt mu b">setFaved</code>到一个新的数组值。就是这样！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/44560b652e8ff348184c6818359d65f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*5NNVeZBzpS6nBgXmqvxl7Q.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">setFaved，相当于this.setState</figcaption></figure><h2 id="3bb3" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">使用效果</h2><p id="b335" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated"><code class="fe mr ms mt mu b">useEffect</code>是一个特别有效的(lol看我在那里做了什么？)钩。根据需要，它允许componentDidMount、componentDidUpdate和componentWillUnmount的组合功能。就像这三种生命周期方法一样，它在组件的初始渲染之后才会发挥作用。</p><p id="700b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，根据<a class="ae kv" href="https://reactjs.org/docs/hooks-overview.html" rel="noopener ugc nofollow" target="_blank"> React.js文档</a> : <em class="ls">“效果挂钩，</em> <code class="fe mr ms mt mu b"><em class="ls">useEffect</em></code> <em class="ls">”，增加了从一个函数组件执行副作用的能力……我们称这些操作为“副作用”(或简称为“效果”)，因为它们会影响其他组件，并且在渲染期间无法完成……通过使用该挂钩，您可以告诉React，您的组件需要在渲染后做一些事情。”</em></p><p id="2b65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">componentDidMount的等价物很容易与<code class="fe mr ms mt mu b">useEffect</code>一起使用。只需用一个箭头函数(考虑到动作的异步性质)传递它，并调用必要的函数。下面，<code class="fe mr ms mt mu b">getFlowers</code>是一个简单的GET fetch函数，它是我从redux“MDP”(mapDispatchToProps)中作为props传递的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/0ff3fd8e8f8e9f49c4dd9fe17b153147.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*_K8Zkxd8uOgoFY6vU_qwow.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">功能等同于componentDidMount</figcaption></figure><p id="f017" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于componentDidUpdate功能:您可以传递一个空数组作为第二个参数，这将告诉React在重新呈现之前不要检查状态元素中的任何更改(或差异)。例如，如果我们有一个likes状态变量，并且你在上面传递的第二个参数中添加了<code class="fe mr ms mt mu b">[likes]</code>，那么如果<code class="fe mr ms mt mu b">likes</code>值没有改变，<code class="fe mr ms mt mu b">useEffect</code>就会知道跳过重新渲染。</p><p id="098c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">useEffect</code>还允许我们选择通过传递第二个函数来告诉组件如何“清理”。(注意，传递的函数可以是命名函数，也可以是匿名箭头函数。两者都将在<code class="fe mr ms mt mu b">useEffect</code>内部工作。)下面是React.js文档中一个有用的例子。</p><pre class="kg kh ki kj gt my mu mz na aw nb bi"><span id="9a5f" class="lt lu iq mu b gy nc nd l ne nf">useEffect(() =&gt; {    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);<br/>    <br/>return () =&gt; {      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);    <br/>};  <br/>});</span></pre><p id="f9d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，API在下一次重新渲染之前取消了好友状态，这很重要，因为每次重新渲染，我们都会体验到一个新的/不同的<code class="fe mr ms mt mu b">useEffect</code>实例。如果在组件的下一次呈现中friend.id不同，我们会看到一个错误。</p><h2 id="d182" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">定制挂钩！</h2><p id="c7c6" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">有大量的<a class="ae kv" href="https://reactjs.org/docs/hooks-rules.html#gatsby-focus-wrapper" rel="noopener ugc nofollow" target="_blank">规则</a>与学习挂钩。其中之一就是不要使用嵌套在函数中的钩子。然而，有一个很大的漏洞:自定义挂钩！你可以通过命名它为<code class="fe mr ms mt mu b">use&lt;SomeFunction&gt;</code>来编写你自己的定制钩子。(React linter将知道您正在编写自己的定制钩子，并且不会向您显示错误消息。)在这种情况下，您可以添加useState、useEffect或其他挂钩(我打算等我自己学会了它们就马上写出来！)并将它们组合在一个函数中。对于一个自定义钩子的有效例子(我还在学习，所以还没有在我自己的应用程序中实现)，去<a class="ae kv" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="770c" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">重构</h2><p id="b6ac" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">如果你决定尝试用钩子将一个类组件重构为一个功能组件，要知道你不必重构整个应用程序。使用钩子，React应用程序可以很好地处理一些类组件和其他功能组件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/ba36a551ea53ff4a0a101346b8180936.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*00mv4DHHoehQgywHC4ODaw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">重要提示:你必须导入任何被利用的钩子，否则你的代码将会崩溃</figcaption></figure><p id="08c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:请记住，当将一个类组件重构为函数组件时，我们必须将let、const(或var)写回到我们声明的函数中。删除所有对此的引用并声明。如果我们要传递道具，请在功能组件中传递道具。(如果你愿意，可以随意破坏这些道具。)别忘了拆下<code class="fe mr ms mt mu b">render() {}</code>！让任何linter/浏览器错误信息引导您前进。</p><p id="d527" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">祝重构好运。让我知道进展如何！！</p><div class="nh ni gp gr nj nk"><a href="https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889" rel="noopener follow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">理解React挂钩</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">本周，Sophie Alpert和我在React Conf上提出了“Hooks”提案，随后是Ryan的深入探讨…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">medium.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny kp nk"/></div></div></a></div><div class="nh ni gp gr nj nk"><a href="https://reactjs.org/docs/hooks-faq.html" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">挂钩常见问题解答-反应</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">钩子是React 16.8中的新增功能。它们允许您使用状态和其他React特性，而无需编写类。这个…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">reactjs.org</p></div></div><div class="nt l"><div class="nz l nv nw nx nt ny kp nk"/></div></div></a></div></div></div>    
</body>
</html>