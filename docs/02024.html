<html>
<head>
<title>Find All Permutations of a String in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Javascript中查找字符串的所有排列</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/find-all-permutations-of-a-string-in-javascript-af41bfe072d2?source=collection_archive---------0-----------------------#2020-02-13">https://levelup.gitconnected.com/find-all-permutations-of-a-string-in-javascript-af41bfe072d2?source=collection_archive---------0-----------------------#2020-02-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e4563d189ae190c088981b964c35618a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8hi02sPoR-kuQ3O7AlBqCg.png"/></div></div></figure></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><h2 id="9f56" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><a class="ae lb" href="https://github.com/noamsauerutley/string-permutations" rel="noopener ugc nofollow" target="_blank"> GitHub repo，包含完整的解决方案代码和测试套件。</a></h2></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><blockquote class="lc"><p id="e8e4" class="ld le iq bd lf lg lh li lj lk ll lm dk translated">给定一个字符串，返回该字符串的所有排列。</p></blockquote><p id="3e03" class="pw-post-body-paragraph ln lo iq lp b lq lr ls lt lu lv lw lx ko ly lz ma ks mb mc md kw me mf mg lm ij bi mh translated">当我坐下来解决这个问题时，我发现这是一个巨大的算法挑战。为什么？虽然操作字符串的任务表面上看起来似乎很熟悉，但实际上找到一个完整的解决方案需要我们处理一些意想不到的复杂性，这提供了利用<a class="ae lb" href="https://en.wikipedia.org/wiki/Recursive_tree" rel="noopener ugc nofollow" target="_blank">递归树</a>并熟悉<a class="ae lb" href="https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)" rel="noopener ugc nofollow" target="_blank">主定理</a>的机会。</p><p id="68f4" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated"><strong class="lp ir"> <em class="mv">注意</em> </strong> <em class="mv">:解决这个问题的方法不止一种。我在这里探索的解决方案模型利用了我发现对解决</em> <a class="ae lb" href="https://www.encyclopediaofmath.org/index.php/Algorithmic_problem" rel="noopener ugc nofollow" target="_blank"> <em class="mv">算法挑战</em> </a> <em class="mv">有广泛价值的工具和概念，以及我发现对Javascript中的字符串操作很直观的方法。</em></p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="1536" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">先说正事:什么是<strong class="lp ir"> </strong> <a class="ae lb" href="https://en.wikipedia.org/wiki/Permutation" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir">排列</strong> </a>？</p><h2 id="3cec" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">每亩地</h2><blockquote class="mw mx my"><p id="592e" class="ln lo mv lp b lq mq ls lt lu mr lw lx mz ms lz ma na mt mc md nb mu mf mg lm ij bi translated"><em class="iq"> /ˌpərmyo͝oˈtāSH(ə)n/ </em></p><p id="8a1f" class="ln lo mv lp b lq mq ls lt lu mr lw lx mz ms lz ma na mt mc md nb mu mf mg lm ij bi translated"><a class="ae lb" href="https://www.google.com/search?rlz=1C5CHFA_enUS709US712&amp;sxsrf=ACYBGNTPndNyReUeZnT9AMXjhP4lKoxabw:1581528989144&amp;q=how+to+pronounce+permutation&amp;stick=H4sIAAAAAAAAAOMIfcRoyy3w8sc9YSmTSWtOXmPU4-INKMrPK81LzkwsyczPExLnYglJLcoV4pfi5eIuALJKS8ASVixKTKl5PItYZTLyyxVK8hUKgNrygfpSFZBUAQAUxHbOYQAAAA&amp;pron_lang=en&amp;pron_country=us&amp;sa=X&amp;ved=2ahUKEwj73uXMxsznAhVBmlkKHbHDBSkQ3eEDMAB6BAgFEAg" rel="noopener ugc nofollow" target="_blank">学会发音</a></p><p id="c26b" class="ln lo mv lp b lq mq ls lt lu mr lw lx mz ms lz ma na mt mc md nb mu mf mg lm ij bi translated"><strong class="lp ir">名词</strong></p><p id="6fb1" class="ln lo mv lp b lq mq ls lt lu mr lw lx mz ms lz ma na mt mc md nb mu mf mg lm ij bi translated">一种方式，尤指几种可能的变化中的一种，在这种方式中一组或若干事物可以被排序或安排。</p></blockquote><p id="dd2e" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">所以每一个字符串都有许多排列，其中的字符可以重新排列。字符串排列类似于<a class="ae lb" href="https://en.wikipedia.org/wiki/Anagram" rel="noopener ugc nofollow" target="_blank">变位词</a>。然而，它不必是现有的单词，而可以简单地是字符的重新排列。</p><p id="a854" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">除了字符串之外的其他内容的排列示例如下:</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/e2358fe3ab61f5fd576c663d756d8844.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*jpYcn_e_FDdczT4ZkeU5Xg.png"/></div></figure><p id="7a91" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">对于仅仅三种颜色，我们可以有六种不同的排列，或者这些颜色的有序组合。</p><p id="79f6" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">排列的另一个例子是密码锁:</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/c7bebdef35b173cb045639d392b1c84f.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*dKlBQn44g7ZsW0eTu8nl-w.jpeg"/></div></figure><p id="501c" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">啊哦。密码锁的全部意义在于，相对少量的数字就可以创造出足够多的有序组合，以防止随意打开。</p><p id="0b1f" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">突然之间，整个字符串操作问题似乎变得更加令人生畏。</p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="ee17" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">所以我们已经弄清楚了什么是排列，并且确定(取决于字符串的长度)我们可能在寻找很多排列。从哪里开始？</p><p id="b525" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">当我看到这样的挑战时，我的第一反应是做两件事:</p><p id="37fc" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">1:制作一个空的<a class="ae lb" href="https://en.wikipedia.org/wiki/Array_data_structure" rel="noopener ugc nofollow" target="_blank">数组</a>。如果我的最终解决方案可能返回不止一个“正确”的元素(在本例中，是排列)，在我返回完整的解决方案之前，我需要一个地方来存储它们。</p><p id="5879" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">2: <a class="ae lb" href="https://en.wikipedia.org/wiki/Iteration" rel="noopener ugc nofollow" target="_blank">迭代</a>！如果我需要找到一个字符串中所有字符的有序组合，创建一个循环来遍历一个字符串中的所有字符似乎是一个不错的起点。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="06a6" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">在我们直接进入迭代之前，让我们先做一些事情。</p><p id="043e" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">如果用户输入一个空字符串，或者一个整数，或者试图在不输入任何内容的情况下运行该函数，该怎么办？如果没有字符串，我们就不能得到字符串的所有排列。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="59bb" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">如果输入到函数中的参数是<a class="ae lb" href="https://j11y.io/javascript/truthy-falsey/" rel="noopener ugc nofollow" target="_blank">false</a>，或者不是字符串，新代码行将返回一条错误消息。</p><p id="10db" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">好的，太好了！</p><p id="4111" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">但是如果字符串真的很短呢？比如只有一个字符的短？这也是一个场景，我们真的不需要弄乱整个迭代，并把东西推到一个数组位。例如，如果我们的字符串只是“a”，那么它只有一个排列——“a”。我们可以只返回a。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="65a1" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">好了，现在已经解决了这个问题，我们可以回到我们的迭代循环了。</p><p id="01f0" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">我们的函数在当前状态下的结构，现在看起来有点类似于所谓的主定理。</p><h2 id="55cd" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">主定理</h2><p id="02e5" class="pw-post-body-paragraph ln lo iq lp b lq nk ls lt lu nl lw lx ko nm lz ma ks nn mc md kw no mf mg lm ij bi translated">什么是<a class="ae lb" href="https://medium.com/@malaynandasana/master-theorem-b544fa8829f7" rel="noopener">主定理</a>？</p><p id="24bf" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">它是将潜在的复杂挑战分解成一系列较小问题的一系列步骤。许多问题或技术挑战都属于<a class="ae lb" href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm" rel="noopener ugc nofollow" target="_blank">分治算法</a>的范畴，它要求未来的求解者将一段数据分成更小的片段，直到这些片段足够简单，可以直接求解。</p><p id="c1df" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">用伪代码写出来，看起来是这样的:</p><pre class="nd ne nf ng gt np nq nr ns aw nt bi"><span id="5f5d" class="kf kg iq nq b gy nu nv l nw nx"><strong class="nq ir">procedure</strong> p( input <em class="mv">x</em> of size <em class="mv">n</em> ):<br/>   <strong class="nq ir">if</strong> <em class="mv">n</em> &lt; some constant <em class="mv">k</em>:<br/>     Solve <em class="mv">x</em> directly without recursion<br/>   <strong class="nq ir">else</strong>:<br/>     Create <em class="mv">a</em> subproblems of <em class="mv">x</em>, each having size <em class="mv">n</em>/<em class="mv">b</em><br/>     Call procedure p recursively on each subproblem<br/>     Combine the results from the subproblems</span></pre><p id="d61f" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">这里发生了一些重要的事情:</p><p id="0720" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">1:条件检查输入的大小是否小于常数。</p><p id="79cb" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">2:如果输入大于所述常数，输入被分解成更小的部分，直到它们都小到足以直接运行<strong class="lp ir">程序</strong></p><p id="ec3c" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">3:当这一步完成后，后处理过程的所有部分的结果可以合并，并作为一个大的数据位返回。</p><p id="c7d2" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">这种分解问题的方法通常被视为一棵树(特别是因为这通常有助于确定问题的<a class="ae lb" href="https://www.geeksforgeeks.org/understanding-time-complexity-simple-examples/" rel="noopener ugc nofollow" target="_blank">时间复杂度</a>)。你可以在这里阅读更多关于时间复杂性和大师方法<a class="ae lb" href="https://medium.com/@aman.jain/demystifying-master-theorem-e0436b2aff1f" rel="noopener">。</a></p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/c4dfda6bda306ceb8eead61ea3d10ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*3K1-xsPyGVwhSXstZoxtug.png"/></div></figure><p id="ce76" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">想了解更多关于递归树和主定理的知识吗？我喜欢康奈尔大学的这个大纲。</p><p id="4612" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">请注意，这种结构与下图中我们寻找字符串所有排列的特定挑战是多么相似:</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/46e7e9a6fc815cd9e09bfef45cb73bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*QBEePGu2SigGcbMeMqwTbA.png"/></div></figure><p id="efe9" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">虽然我们当前的函数与我们主定理的抽象伪代码并不完全相同，但是我们已经建立了一个逻辑路径，如果我们的输入小于一个常数(在我们的例子中，如果<strong class="lp ir"> string.length </strong>小于<strong class="lp ir"> 2 </strong>)，则返回一个解，如果不是，则创建一个要解决的子问题列表。</p><p id="d5a8" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">如果您以前展平过嵌套数组，这种方法可能会很熟悉。对于各种各样的挑战，这可能是一个很好的起点——它不会是解决所有问题的相关方法，但提供了一个很好的起点。</p><p id="7350" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated"><em class="mv">注意:这种方法确实利用了</em> <a class="ae lb" href="https://en.wikipedia.org/wiki/Recursion" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir"> <em class="mv">递归</em> </strong> </a> <em class="mv">。</em></p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/314261a2dc4a96558e0b2d0d328d502d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*X_6FLmHpf2wr897tIqcj5Q.jpeg"/></div></figure><p id="b5f4" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">你可以在这里阅读更多关于<strong class="lp ir">递归</strong><a class="ae lb" href="https://www.freecodecamp.org/news/recursion-demystified-99a2105cb871/" rel="noopener ugc nofollow" target="_blank"/><a class="ae lb" href="https://medium.com/code-zen/recursion-demystified-24867f045c62" rel="noopener">这里</a>(代码示例在<a class="ae lb" href="https://en.wikipedia.org/wiki/JavaScript" rel="noopener ugc nofollow" target="_blank">JavaScript</a>)<a class="ae lb" href="https://medium.com/@daniel.oliver.king/getting-started-with-recursion-f89f57c5b60e" rel="noopener">这里</a>(代码示例在<a class="ae lb" href="https://en.wikipedia.org/wiki/JavaScript" rel="noopener ugc nofollow" target="_blank">JavaScript</a>)<a class="ae lb" href="https://medium.com/better-programming/understanding-recursion-recursively-181f5f4dc528" rel="noopener">这里</a>(代码示例在<a class="ae lb" href="https://en.wikipedia.org/wiki/Ruby_(programming_language)" rel="noopener ugc nofollow" target="_blank">ruby</a>)<a class="ae lb" href="https://medium.com/@isaac_70614/recursion-a-step-by-step-introduction-ed25c957559c" rel="noopener">这里</a>(代码示例在<a class="ae lb" href="https://en.wikipedia.org/wiki/Python_(programming_language)" rel="noopener ugc nofollow" target="_blank"> python </a>)。</p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="7dbe" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">好吧，回到我们的代码。</p><p id="2339" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">现在，如果我们想利用主定理方法，我们可以更新我们的计划，使之比<code class="fe ob oc od nq b">// do something</code>更清晰一些。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="c998" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">为了简单起见，我想把我们正在迭代的当前元素赋给变量<strong class="lp ir"> char </strong>。</p><p id="835a" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">所以我们应该做的第一件事是把我们的<strong class="lp ir">字符串</strong>分解成子问题。</p><p id="d119" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">首先，我们有我们当前的角色，又名<strong class="lp ir">string【I】</strong>，又名<strong class="lp ir"> char </strong>。为了开始分解剩余的<strong class="lp ir">字符串</strong>，我们需要收集剩余的字符。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="068c" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">正如我们将当前字符分配给变量<strong class="lp ir"> char </strong>一样，让我们将剩余字符分配给变量<strong class="lp ir"> remainingChars </strong>。</p><p id="16be" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated"><strong class="lp ir"> <em class="mv">注</em> </strong> <em class="mv">:收集</em> <strong class="lp ir">剩余查尔</strong> <em class="mv">的方法有很多种。这只是一种方法。</em></p><p id="5624" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">为了收集这些字符，我们可以使用字符串方法<a class="ae lb" href="https://www.w3schools.com/jsref/jsref_slice_string.asp" rel="noopener ugc nofollow" target="_blank"> slice </a>。<a class="ae lb" href="https://www.w3schools.com/jsref/jsref_substring.asp" rel="noopener ugc nofollow" target="_blank"> Substring </a>是一个类似的方法，所以如果你更熟悉它，你可以用它来代替。Slice是<a class="ae lb" href="https://medium.com/@coadams9/javascript-a-few-methods-and-destructive-vs-non-destructive-c20197534ad1" rel="noopener">非破坏性的</a>，所以我们不需要担心改变我们的原始字符串——我们通过对我们的字符串进行切片得到的结果将是它自己的新字符串。</p><p id="a143" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">所以我们将从索引<strong class="lp ir"> 0 </strong>(字符串中的第一个字符)到索引<strong class="lp ir"> i </strong>(我们当前的字符，<strong class="lp ir"> char </strong>)分割字符。然后，我们将从索引<strong class="lp ir"> i + 1 </strong>(在<strong class="lp ir"> char </strong>之后的下一个字符)到索引<strong class="lp ir"> string.length </strong>(在<strong class="lp ir">字符串</strong>中的最后一个字符)的字符连接起来。</p><p id="d75c" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">所以现在我们有两个更小的字符串——char和remainingChars 。</p><p id="ce99" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">现在怎么办？</p><p id="5e66" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">好吧，让我们参考主定理:</p><pre class="nd ne nf ng gt np nq nr ns aw nt bi"><span id="740f" class="kf kg iq nq b gy nu nv l nw nx">Call procedure p recursively on each subproblem</span></pre><p id="fd37" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">所以我们将在剩余的字符串上调用我们的函数。</p><p id="c9ab" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">然后呢？</p><pre class="nd ne nf ng gt np nq nr ns aw nt bi"><span id="feee" class="kf kg iq nq b gy nu nv l nw nx">Combine the results from the subproblems</span></pre><p id="12f4" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">我知道我们需要那个空数组。</p><p id="076d" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">好的，那么这在JavaScript中是什么样子的呢？</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="bdb7" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">所以我们在这里做了一些事情。</p><p id="8daf" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">我们递归地调用了<strong class="lp ir">上的<strong class="lp ir">find permutations</strong>remaining chars</strong>。对于该函数的每个结果，我将其分配给一个名为<strong class="lp ir"> permutation </strong>的变量，我们可以将一个由<strong class="lp ir"> char </strong>和<strong class="lp ir"> permutation </strong>组合而成的字符串推入到我们的<strong class="lp ir">permutation array</strong>中。</p><p id="2741" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">所以让我们看看当我们返回<strong class="lp ir"> permutationsArray </strong>时会得到什么。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="19c3" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">好的，太好了！当给定输入<strong class="lp ir">“ABC”</strong>时，我们的<strong class="lp ir"> findPermutations </strong>函数返回所有六个排列！</p><p id="d41c" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">让我再尝试一件事。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="518b" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">这可不好。如果字符串中的一个字符重复出现，我们将得到两次排列。许多字符串都有重复的字符。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="00db" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">有很多不同的方法来删除多余的元素，但我选择使用Javascript的<a class="ae lb" href="https://www.w3schools.com/jsref/jsref_indexof.asp" rel="noopener ugc nofollow" target="_blank"> indexOf </a>方法来识别当前字符是否已经通过我们的<strong class="lp ir"> findPermutations </strong>方法运行过。indexOf返回一个字符的<strong class="lp ir">第一个</strong>索引，所以如果我们已经为一个“a”运行了<strong class="lp ir"> findPermutations </strong>，index of(“a”)将不同于<strong class="lp ir"> char </strong>(当前的，后来的“a”)的索引。</p><p id="f8a1" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">如果这是真的，我们可以<a class="ae lb" href="https://www.w3schools.com/js/js_break.asp" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir">继续</strong> </a>，这实质上将跳过当前的迭代循环，并继续下一个。</p><p id="cd81" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">让我们用这个加法来运行<strong class="lp ir"> findPermutation </strong>。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="cf46" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">完美！🌟基于主定理的方法使我们能够快速地将这个问题分解成小块，并开始返回正确的结果，只需要在这里和那里做一些调整，就可以按照预期的格式交付我们的解决方案。</p><h2 id="ffec" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">回顾:</h2><p id="c7b1" class="pw-post-body-paragraph ln lo iq lp b lq nk ls lt lu nl lw lx ko nm lz ma ks nn mc md kw no mf mg lm ij bi translated">那么我们基于主定理的方法是什么来着？</p><p id="b35a" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">1:建立一个基础案例——如果我们的输入大小小于某个常数，直接解决它，不要递归。</p><p id="1d7b" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">2:如果输入大于所述常数，将其分解成更小的块。</p><p id="d538" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">3:在碎片上递归调用函数，直到它们小到可以直接求解。</p><p id="33cf" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">4:组合各个部分的结果，并返回完整的解决方案。</p><p id="82b9" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">我发现这个模型是一个非常方便的工具，它为我解决算法挑战提供了一个可靠的起点。虽然不是特别适用于每一个算法问题，也不总是性能最好或最优雅的解决方案，但它是一个可靠的工作模型，可以很好地为您服务！</p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="d8ad" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">包含解决方案代码的<a class="ae lb" href="https://github.com/noamsauerutley/string-permutations" rel="noopener ugc nofollow" target="_blank"> GitHub repo还附带了一个测试套件，因此如果您愿意，您可以练习或尝试寻找这个问题的替代解决方案。</a></p><p id="cb4d" class="pw-post-body-paragraph ln lo iq lp b lq mq ls lt lu mr lw lx ko ms lz ma ks mt mc md kw mu mf mg lm ij bi translated">如果您想进一步探索，您可以尝试使用上面利用的解决方案模型来查找密码锁的所有组合。有用吗？你需要做任何改变吗？</p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><h2 id="4431" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/solving-the-two-sum-problem-in-javascript-three-ways-4d43067fcfc7">有兴趣解决Javascript中另一个流行的算法？点击这里。</a></h2></div></div>    
</body>
</html>