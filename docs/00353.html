<html>
<head>
<title>Face Detection with Python using OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OpenCV的Python人脸检测</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/face-detection-with-python-using-opencv-5c27e521c19a?source=collection_archive---------0-----------------------#2019-01-22">https://levelup.gitconnected.com/face-detection-with-python-using-opencv-5c27e521c19a?source=collection_archive---------0-----------------------#2019-01-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3f32663431e3732a268891a03e51a7d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sqd_67WOa03jvt2V"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">塔妮娅·里维拉在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="4b62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="le">原载于</em></strong><a class="ae kf" href="https://www.datacamp.com/community/tutorials/face-detection-python-opencv" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu"><em class="le">【www.datacamp.com】</em></strong></a><strong class="ki iu"><em class="le">。</em> </strong></p><p id="52f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">人脸检测是一种计算机视觉技术，有助于在数字图像中定位/可视化人脸。该技术是<a class="ae kf" href="https://en.wikipedia.org/wiki/Object_detection" rel="noopener ugc nofollow" target="_blank">对象检测技术</a>的一个具体用例，用于检测数字图像和视频中某一类语义对象(如人、建筑物或汽车)的实例。随着技术的发展，人脸检测变得越来越重要，尤其是在摄影、安全和营销等领域。</p><h1 id="1744" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">目标</h1><p id="0f8d" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">本教程将向您介绍使用OpenCV库在Python中进行对象检测的概念，以及如何利用它来执行面部检测等任务。</p><h1 id="b964" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">先决条件</h1><p id="5133" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">在研究OpenCV的概念之前，Numpy和Matplotlib的实践知识是必不可少的。在安装OpenCV之前，请确保您已经安装并运行了以下软件包。</p><ul class=""><li id="9dcf" class="mi mj it ki b kj kk kn ko kr mk kv ml kz mm ld mn mo mp mq bi translated">计算机编程语言</li><li id="bdfd" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated">Numpy</li><li id="93be" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated">Matplotlib</li></ul><h1 id="e3a2" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">目录</h1><ol class=""><li id="9dbf" class="mi mj it ki b kj md kn me kr mw kv mx kz my ld mz mo mp mq bi translated"><a class="ae kf" href="https://medium.com/p/5c27e521c19a/#02e9" rel="noopener"> OpenCV-Python </a></li></ol><p id="57df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.<a class="ae kf" href="https://medium.com/p/5c27e521c19a/#62ed" rel="noopener">图像作为数组</a></p><p id="00c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">3.<a class="ae kf" href="https://medium.com/p/5c27e521c19a/#6c31" rel="noopener">图片和OpenCV </a></p><p id="7347" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">4.<a class="ae kf" href="https://medium.com/p/5c27e521c19a/#a854" rel="noopener">人脸检测</a></p><p id="8bfc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">5.<a class="ae kf" href="https://medium.com/p/5c27e521c19a/#1425" rel="noopener">结论</a></p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="02e9" class="lf lg it bd lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly nl ma mb mc bi translated">OpenCV-Python</h1><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/3d9e5e5087e9d48fc2db0e61f9508c84.png" data-original-src="https://miro.medium.com/v2/resize:fit:208/format:webp/0*AKFQz7rh4DP03VNq.png"/></div></figure><p id="0dce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank"> OpenCV </a>由<strong class="ki iu"> Gary Bradsky </strong>于1999年在英特尔创立。第一次发布是在2000年稍晚的时候。OpenCV本质上代表<strong class="ki iu">开源计算机视觉库</strong>。虽然它是用优化的C/C++编写的，但是它有Python和Java以及C++的接口。OpenCV在全世界拥有活跃的用户群，由于计算机视觉应用的激增，其使用日益增加。</p><p id="35f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">OpenCV-Python是OpenCV的python API。你可以把它看作是OpenCV的C++实现的python包装器。OpenCV-Python不仅速度快(因为后台由C/C++编写的代码组成)，而且易于编码和部署(因为前台有Python包装器)。这使得它成为执行计算密集型程序的最佳选择。</p><h2 id="b776" class="nr lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lt kv ny nz lx kz oa ob mb oc bi translated">装置</h2><p id="5d6e" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">OpenCV-Python支持所有主流平台，如Mac OS、Linux和Windows。它可以通过以下任一方式安装:</p><p id="4a51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> 1。从预构建的二进制文件和源代码</strong>:</p><p id="3d9a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请参考详细文档<a class="ae kf" href="https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_setup/py_setup_in_windows/py_setup_in_windows.html" rel="noopener ugc nofollow" target="_blank">此处</a>为Windows，此处<a class="ae kf" href="https://www.pyimagesearch.com/2016/12/19/install-opencv-3-on-macos-with-homebrew-the-easy-way/" rel="noopener ugc nofollow" target="_blank">为Mac。</a></p><p id="583a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://pypi.org/project/opencv-python/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> 2。非官方</strong>为Python预建的OpenCV包</a>。</p><p id="9dd9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">标准桌面环境的软件包(Windows，macOS，几乎所有的GNU/Linux发行版)</p><ul class=""><li id="a33d" class="mi mj it ki b kj kk kn ko kr mk kv ml kz mm ld mn mo mp mq bi translated">如果只需要主模块，运行<code class="fe od oe of og b">pip install opencv-python</code></li><li id="0248" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated">如果需要main和contrib模块，运行<code class="fe od oe of og b">pip install opencv-contrib-python</code>(查看OpenCV文档<a class="ae kf" href="https://docs.opencv.org/master/" rel="noopener ugc nofollow" target="_blank">中的额外模块列表</a></li></ul><p id="486f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用Jupyter笔记本或您选择的任何Python IDE来编写脚本。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="62ed" class="lf lg it bd lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly nl ma mb mc bi translated">图像作为数组</h1><p id="4288" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">图像只不过是包含数据点像素的标准Numpy数组。图像的像素越多，分辨率就越高。你可以认为像素是以二维网格形式排列的微小信息块，像素的深度是指其中存在的颜色信息。为了被计算机处理，图像需要被转换成二进制形式。图像的颜色可以计算如下:</p><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="5744" class="nr lg it og b gy ol om l on oo">Number of colors/ shades = 2^bpp where bpp represents bits per pixel.</span></pre><p id="9c59" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">自然，比特/像素的数量越多，图像中可能的颜色就越多。下表更清楚地显示了这种关系。</p><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi op"><img src="../Images/797cf1581b3bc4fc2a2fe819b81c20bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/0*Zrz3SlqJQAG1iQGW.png"/></div></figure><h2 id="7b18" class="nr lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lt kv ny nz lx kz oa ob mb oc bi translated">现在让我们看看不同种类的图像的表示:</h2><h2 id="6459" class="nr lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lt kv ny nz lx kz oa ob mb oc bi translated">1.二进制映象</h2><p id="03a2" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">二进制图像由1比特/像素组成，因此只能有两种可能的颜色，即黑色或白色。黑色由值0表示，而1表示白色。</p><h2 id="74bf" class="nr lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lt kv ny nz lx kz oa ob mb oc bi translated">2.灰度图像</h2><p id="1a6a" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">灰度图像由每像素8位组成。这意味着它可以有256种不同的色调，其中0像素代表黑色，而255像素代表白色。例如，下图显示了以数组形式表示的灰度图像。灰度图像只有一个通道，其中通道代表维度。</p><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/5829cf10ac48faec69d8b9efaef37618.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/0*q80RGJhbjd3NkD02.png"/></div></figure><h2 id="396c" class="nr lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lt kv ny nz lx kz oa ob mb oc bi translated">3.彩色图像</h2><p id="e83d" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">彩色图像由红、蓝、绿三种颜色组合而成，而所有其他颜色都可以通过将这些原色以正确的比例混合来实现。</p><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi or"><img src="../Images/3e7dbc6377a5f114419c54f750682b1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/0*Mz_SmH0JD0TMeCn3.jpg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://ldcompanion.files.wordpress.com/2013/12/colour_ryb.jpg" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="6f18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">彩色图像也是每像素8位。因此，256种不同色调的颜色可以用0代表黑色，255代表白色。让我们看看著名的山魈彩色图像，它在许多图像处理例子中被引用。</p><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi os"><img src="../Images/23382bdd7636740af6c8aa574d0c13fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/0*ZarP_aK1-s--1-AP.png"/></div></figure><p id="873f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们检查上图的形状，我们会得到:</p><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="1e1a" class="nr lg it og b gy ol om l on oo">Shape <br/>(288, 288, 3) <br/>288: Pixel width <br/>288: Pixel height <br/>3: color channel</span></pre><p id="4e26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们可以用三维数组的形式来表示上面的图像。</p><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/1d4d992d7214aa52f42a6cc37e032c46.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/0*dwZGIOsU84yhHEot.png"/></div></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="6c31" class="lf lg it bd lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly nl ma mb mc bi translated">图像和OpenCV</h1><p id="c55c" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">在我们进入人脸检测过程之前，让我们学习一些关于使用OpenCV的基础知识。在本节中，我们将使用OpenCV对图像执行简单的操作，如打开图像、在图像上绘制简单的形状以及通过回调与图像进行交互。这是必要的，以创建一个基础，然后我们再走向高级的东西。</p><h2 id="cb1e" class="nr lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lt kv ny nz lx kz oa ob mb oc bi translated">在OpenCV中导入图像</h2><h2 id="78b7" class="nr lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lt kv ny nz lx kz oa ob mb oc bi translated">使用Jupyter笔记本</h2><p id="2278" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated"><strong class="ki iu">步骤:</strong></p><ul class=""><li id="f88c" class="mi mj it ki b kj kk kn ko kr mk kv ml kz mm ld mn mo mp mq bi translated"><strong class="ki iu">导入必要的库</strong></li></ul><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="17ca" class="nr lg it og b gy ol om l on oo">import numpy as np<br/>import cv2 <br/>import matplotlib.pyplot as plt <br/>%matplotlib inline</span></pre><ul class=""><li id="4dfa" class="mi mj it ki b kj kk kn ko kr mk kv ml kz mm ld mn mo mp mq bi translated">使用<strong class="ki iu"> imread </strong>功能读入图像。我们将使用彩色的“山魈”图像进行演示。可以从<a class="ae kf" href="https://github.com/parulnith/Face-Detection-in-Python-using-OpenCV/blob/master/opening%20images%20with%20opencv/mandrill_colour.png" rel="noopener ugc nofollow" target="_blank">这里</a>下载</li></ul><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="2afc" class="nr lg it og b gy ol om l on oo">img_raw = cv2.imread('image.jpg')</span></pre><ul class=""><li id="03ac" class="mi mj it ki b kj kk kn ko kr mk kv ml kz mm ld mn mo mp mq bi translated"><strong class="ki iu">阵列的类型和形状。</strong></li></ul><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="e397" class="nr lg it og b gy ol om l on oo">type(img_raw) <br/>numpy.ndarray</span><span id="c08c" class="nr lg it og b gy ou om l on oo">img_raw.shape <br/>(1300, 1950, 3)</span></pre><p id="9cc8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，<code class="fe od oe of og b">.png</code>图像被转换成一个形状为1300x1950的numpy数组，有3个通道。</p><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="a38e" class="nr lg it og b gy ol om l on oo">plt.imshow(img_raw)</span></pre><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/00556215a545c314e037dcd5668b2484.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/0*39A1lIl5-5YsvsZg.png"/></div></figure><p id="a7b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于颜色，我们得到的输出有点不同。我们期待一个明亮的彩色图像，但我们得到的是一个带有一些蓝色色调的图像。这是因为OpenCV和matplotlib的原色顺序不同。OpenCV读取BGR格式的图像，而matplotlib遵循RGB的顺序。因此，当我们通过OpenCV读取一个文件时，我们就好像它包含蓝色、绿色和红色顺序的通道一样。然而，当我们使用matplotlib显示图像时，红色和蓝色通道被交换，从而得到蓝色色调。为了避免这个问题，我们将把通道转换成matplotlib期望它使用函数<code class="fe od oe of og b">cvtColor</code>的方式。</p><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="3977" class="nr lg it og b gy ol om l on oo">img = cv2.cvtColor(img_raw, cv2.COLOR_BGR2RGB) <br/>plt.imshow(img)</span></pre><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi os"><img src="../Images/294fc27bc074d5b834ebd4e9638e25d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/0*267ylZZOP4k0NvLN.png"/></div></figure><h2 id="d1b5" class="nr lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lt kv ny nz lx kz oa ob mb oc bi translated">使用Python脚本</h2><p id="7a95" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">Jupyter笔记本非常适合学习，但在处理复杂的图像和视频时，我们需要在自己单独的窗口中显示它们。在本节中，我们将把代码作为一个. py文件来执行。您可以使用Pycharm、Sublime或您选择的任何IDE来运行下面的脚本。</p><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="6316" class="nr lg it og b gy ol om l on oo">import cv2<br/>img = cv2.imread('image.jpg')<br/>while True:<br/>    cv2.imshow('mandrill',img)</span><span id="44b9" class="nr lg it og b gy ou om l on oo">    if cv2.waitKey(1) &amp; 0xFF == 27:<br/>        break<br/></span><span id="9693" class="nr lg it og b gy ou om l on oo">cv2.destroyAllWindows()</span></pre><p id="da60" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这段代码中，我们有一个条件，只有当条件为真时，才会显示图像。此外，要打破这个循环，我们需要满足两个条件:</p><ul class=""><li id="d206" class="mi mj it ki b kj kk kn ko kr mk kv ml kz mm ld mn mo mp mq bi translated"><a class="ae kf" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_image_display/py_image_display.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> cv2.waitKey() </strong> </a>是一个键盘绑定函数。它的参数是以毫秒为单位的时间。该函数为任何键盘事件等待指定的毫秒数。如果您在这段时间内按下任何键，程序将继续运行。</li><li id="de24" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated">第二个条件与按下键盘上的Escape键有关。因此，如果已经过了1毫秒并按下了escape键，循环将会中断，程序将会停止。</li><li id="4c05" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated"><a class="ae kf" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_image_display/py_image_display.html" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu">cv2 . destroyallwindows()</strong></a>简单的销毁我们创建的所有窗口。如果您想要销毁任何特定的窗口，请使用函数<strong class="ki iu"> cv2.destroyWindow() </strong>，其中您将确切的窗口名称作为参数进行传递。</li></ul><h2 id="712d" class="nr lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lt kv ny nz lx kz oa ob mb oc bi translated">储蓄图像</h2><p id="bc72" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">图像可以保存在工作目录中，如下所示:</p><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="2675" class="nr lg it og b gy ol om l on oo">cv2.imwrite('final_image.png',img)</span></pre><p id="8474" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中，最终图像是要保存的图像的名称。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="837f" class="lf lg it bd lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly nl ma mb mc bi translated">对图像的基本操作</h1><p id="b02a" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">在这一节中，我们将学习如何在现有图像上绘制各种形状，以体验使用OpenCV的感觉。</p><h2 id="7168" class="nr lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lt kv ny nz lx kz oa ob mb oc bi translated">在图像上绘图</h2><ul class=""><li id="99cf" class="mi mj it ki b kj md kn me kr mw kv mx kz my ld mn mo mp mq bi translated">首先导入必要的库。</li></ul><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="5444" class="nr lg it og b gy ol om l on oo">import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline<br/>import cv2</span></pre><ul class=""><li id="d096" class="mi mj it ki b kj kk kn ko kr mk kv ml kz mm ld mn mo mp mq bi translated">创建一个黑色图像作为模板。</li></ul><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="e854" class="nr lg it og b gy ol om l on oo">image_blank = np.zeros(shape=(512,512,3),dtype=np.int16)</span></pre><ul class=""><li id="79e6" class="mi mj it ki b kj kk kn ko kr mk kv ml kz mm ld mn mo mp mq bi translated">显示黑色图像。</li></ul><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="6f3a" class="nr lg it og b gy ol om l on oo">plt.imshow(image_blank)</span></pre><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/a5a0cd8288c77cd493252f007d5bbabf.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/0*tXuyEcJyT6EDCMbt.png"/></div></figure><h2 id="65d5" class="nr lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lt kv ny nz lx kz oa ob mb oc bi translated">功能和属性</h2><p id="53e3" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">在图像上绘制形状的通用函数是:</p><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="c650" class="nr lg it og b gy ol om l on oo">cv2.shape(line, rectangle etc)(image,Pt1,Pt2,color,thickness)</span></pre><p id="6d50" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在函数中传递一些常见的参数，以便在图像上绘制形状:</p><ul class=""><li id="609e" class="mi mj it ki b kj kk kn ko kr mk kv ml kz mm ld mn mo mp mq bi translated">要在其上绘制形状的图像</li><li id="1808" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated">要从Pt1(左上)到Pt2(右下)绘制的形状的坐标</li><li id="e302" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated"><strong class="ki iu">颜色</strong>:要绘制的形状的颜色。它作为一个元组传递，例如:<code class="fe od oe of og b">(255,0,0)</code>。对于灰度，它将是亮度的标度。</li><li id="ffa4" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated">几何图形的厚度。</li></ul><p id="e067" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> 1。直线</strong></p><p id="ba69" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在图像上画一条直线需要指定直线要经过的点。</p><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="b8ef" class="nr lg it og b gy ol om l on oo"># Draw a diagonal red line with thickness of 5 px</span><span id="0c7a" class="nr lg it og b gy ou om l on oo">line_red = cv2.line(img,(0,0),(511,511),(255,0,0),5)<br/>plt.imshow(line_red)</span></pre><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/7a0e9baf948efccba8afc90c1dd0e511.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/0*gCpCVa8DiY0L5JcN.png"/></div></figure><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="c484" class="nr lg it og b gy ol om l on oo"># Draw a diagonal green line with thickness of 5 px</span><span id="26bb" class="nr lg it og b gy ou om l on oo">line_green = cv2.line(img,(0,0),(511,511),(0,255,0),5)<br/>plt.imshow(line_green)</span></pre><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/3c2021113a9fd9a7a2275bcc102d7f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/0*E93tZfH-Z3qVRf_d.png"/></div></figure><p id="2f9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> 2。矩形</strong></p><p id="bb9f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于矩形，我们需要指定左上角和右下角的坐标。</p><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="b9f4" class="nr lg it og b gy ol om l on oo">#Draw a blue rectangle with a thickness of 5 px</span><span id="e92a" class="nr lg it og b gy ou om l on oo">rectangle= cv2.rectangle(img,(384,0),(510,128),(0,0,255),5)<br/>plt.imshow(rectangle)</span></pre><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/4ee1d704c4aa661af887f82b7909b608.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/0*hMl1UIA02FgnqSBa.png"/></div></figure><p id="5406" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> 3。圆圈</strong></p><p id="73de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于一个圆，我们需要传递它的中心坐标和半径值。让我们在上面画的矩形里面画一个圆</p><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="0c82" class="nr lg it og b gy ol om l on oo">img = cv2.circle(img,(447,63), 63, (0,0,255), -1) # -1 corresponds to a filled circle<br/> <br/>plt.imshow(circle)</span></pre><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/7ebc3bfd31992dbce6f8977038d8cd8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/0*-u9T_B0NE5rPQb4z.png"/></div></figure><h2 id="af53" class="nr lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lt kv ny nz lx kz oa ob mb oc bi translated">在图像上书写</h2><p id="bc42" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">向图像添加文本也类似于在图像上绘制形状。但是在这样做之前，您需要指定某些参数:</p><ul class=""><li id="f27b" class="mi mj it ki b kj kk kn ko kr mk kv ml kz mm ld mn mo mp mq bi translated">要编写的文本</li><li id="8ada" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated">文本的坐标。图像上的文本从左下方开始。</li><li id="03da" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated">字体类型和比例。</li><li id="c923" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated">其他属性，如颜色、粗细和线型。通常使用的线型是<code class="fe od oe of og b">lineType = cv2.LINE_AA</code>。</li></ul><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="5b0d" class="nr lg it og b gy ol om l on oo">font = cv2.FONT_HERSHEY_SIMPLEX<br/>text = cv2.putText(img,'OpenCV',(10,500), font, 4,(255,255,255),2,cv2.LINE_AA)</span><span id="c3eb" class="nr lg it og b gy ou om l on oo">plt.imshow(text)</span></pre><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/767d1961205d9c2f1b4c80640eb2318d.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/0*mI-TFGpRjPy0_8G7.png"/></div></figure><p id="3ac1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些是可以使用OpenCV在图像上完成的小操作。随意试验形状和文本。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="a854" class="lf lg it bd lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly nl ma mb mc bi translated">4.人脸检测</h1><p id="13ec" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">人脸检测是一种在数字图像中识别或定位人脸的技术。面部检测的一个典型例子发生在我们通过智能手机拍照时，它会立即检测到照片中的面部。人脸检测不同于人脸识别。面部检测仅仅检测图像中面部的存在，而面部识别包括识别这是谁的面部。在本文中，我们将只讨论前者。</p><p id="684c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过使用分类器来执行面部检测。分类器本质上是一种算法，它决定给定的图像是正面的(人脸)还是负面的(不是人脸)。一个分类器需要在数以千计的有和没有人脸的图像上进行训练。幸运的是，OpenCV已经有两个预训练的人脸检测分类器，可以很容易地在程序中使用。这两个分类器是:</p><ul class=""><li id="3487" class="mi mj it ki b kj kk kn ko kr mk kv ml kz mm ld mn mo mp mq bi translated">哈尔分类器和</li><li id="cee7" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated">局部二元模式(<a class="ae kf" href="https://en.wikipedia.org/wiki/Local_binary_patterns" rel="noopener ugc nofollow" target="_blank"> LBP </a>)分类器。</li></ul><p id="12e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，在本文中，我们将只讨论Haar分类器。</p><h1 id="4855" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">基于Haar特征的级联分类器</h1><p id="6ee8" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated"><a class="ae kf" href="https://en.wikipedia.org/wiki/Haar-like_feature" rel="noopener ugc nofollow" target="_blank">类哈尔特征</a>是用于物体识别的数字图像特征。它们的名字源于它们与Haar小波的直觉相似性，并被用于第一个实时人脸检测器。<strong class="ki iu"> Paul Viola </strong>和<strong class="ki iu"> Michael Jones </strong>在他们题为<a class="ae kf" href="http://wearables.cc.gatech.edu/paper_of_week/viola01rapid.pdf" rel="noopener ugc nofollow" target="_blank">“使用简单特征增强级联的快速对象检测”</a>的论文中使用了基于Haar小波的Haar特征分类器的思想。该分类器广泛用于计算机视觉行业中的人脸检测等任务。</p><p id="2fab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Haar级联分类器采用机器学习方法进行视觉对象检测，能够非常快速地处理图像并实现高检测率。这可以归结为三个主要的<a class="ae kf" href="http://wearables.cc.gatech.edu/paper_of_week/viola01rapid.pdf" rel="noopener ugc nofollow" target="_blank">原因</a>:</p><ul class=""><li id="121d" class="mi mj it ki b kj kk kn ko kr mk kv ml kz mm ld mn mo mp mq bi translated">Haar分类器采用了<strong class="ki iu"> <em class="le">【积分图像】</em> </strong>的概念，可以非常快速地计算出检测器使用的特征。</li><li id="7063" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated">学习算法基于<a class="ae kf" href="https://en.wikipedia.org/wiki/AdaBoost" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> <em class="le"> AdaBoost </em> </strong> </a>。它从大量的特征集中选择少量的重要特征，并给出高效的分类器。</li><li id="bd9f" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated">更复杂的分类器被组合以形成“<strong class="ki iu"> <em class="le">级联</em> </strong>”，其丢弃图像中的任何非人脸区域，从而在有希望的物体状区域上花费更多的计算。</li></ul><p id="e872" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">现在让我们试着逐步理解该算法如何对图像起作用:</strong></p><h2 id="357a" class="nr lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lt kv ny nz lx kz oa ob mb oc bi translated">1.哈尔特征提取</h2><p id="3730" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">在将大量的训练数据(以图像的形式)输入系统后，分类器开始从每幅图像中提取Haar特征。Haar特征是一种卷积核，主要检测图像上是否存在合适的特征。以下是Haar特性的一些示例:</p><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/37cd549af04293b77d3791fe63a8a43b.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/0*70s9fLikYYh7drwb.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://www.cs.cmu.edu/~efros/courses/LBMV07/Papers/viola-cvpr-01.pdf" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="84a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些Haar特征就像窗口，被放置在图像上以计算单个特征。该特征本质上是通过减去白色区域下的像素和黑色区域下的像素的总和而获得的单个值。在下面的例子中可以很容易地看到这个过程。</p><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/a9cbf19fdbed4acace48470d17ab591a.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/0*ZphcGcH0U58FTLrR.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://www.cs.cmu.edu/~efros/courses/LBMV07/Papers/viola-cvpr-01.pdf" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="6b13" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">出于演示目的，假设我们只提取两个特征，因此这里只有两个窗口。第一个特征依赖于眼睛区域比相邻的脸颊和鼻子区域暗这一点。第二个特点是眼睛比鼻梁更黑。因此，当特征窗口在眼睛上移动时，它将计算单个值。然后，将该值与某个阈值进行比较，如果该值超过阈值，则推断这里存在边缘或某些积极特征。</p><h2 id="7ca1" class="nr lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lt kv ny nz lx kz oa ob mb oc bi translated">2.整体图像概念</h2><p id="2b0c" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">Viola Jones提出的算法使用24X24的基本窗口大小，这将导致在该窗口中计算超过180，000个特征。想象一下计算所有特征的像素差异？为这一计算密集型过程设计的解决方案是采用<strong class="ki iu">积分图像</strong>概念。积分图像意味着要找到任何矩形下所有像素的总和，我们只需要四个角的值。</p><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/14ca581d1a1df92c39a965edc1ae3fea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/0*Z4DJi4VWV-yo7kRz.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://www.cs.cmu.edu/~efros/courses/LBMV07/Papers/viola-cvpr-01.pdf" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="d191" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着，要计算任何特征窗口中像素的总和，我们不需要单独对它们求和。我们所需要的是使用4个角值来计算积分图像。下面的例子将使这个过程变得透明。</p><figure class="nn no np nq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pd"><img src="../Images/f34b5c9d70b05983c5fc144c47496629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Prc6H2ALxqqFbdr8.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://en.wikipedia.org/wiki/Summed-area_table" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><h2 id="4d67" class="nr lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lt kv ny nz lx kz oa ob mb oc bi translated">3.“Adaboost”:提高分类器精度</h2><p id="8ccc" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">如上所述，在24X24窗口内会产生超过180，000个特征值。然而，并不是所有的特征都对识别人脸有用。为了只从整个块中选择最好的特征，使用了一种叫做<strong class="ki iu"> AdaBoost </strong>的机器学习算法。它本质上做的是只选择那些有助于提高分类器精度的特征。它通过构建一个强分类器来实现，该强分类器是多个弱分类器的线性组合。这将功能的数量从大约180，000个急剧减少到大约6000个。</p><h2 id="9391" class="nr lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lt kv ny nz lx kz oa ob mb oc bi translated">4.使用“分类器级联”</h2><p id="a95a" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">Viola Jones确保算法快速执行的另一种方式是采用分类器的<strong class="ki iu">级联。级联分类器基本上由多个级组成，其中每个级由一个强分类器组成。这是有益的，因为它消除了在一个窗口上一次应用所有特征的需要。相反，它将特征分组到单独的子窗口中，并且每个阶段的分类器确定子窗口是否是人脸。如果不是，则该子窗口与该窗口中的特征一起被丢弃。如果子窗口移过分类器，则它继续到下一阶段，在该阶段应用第二阶段的特征。借助下图可以理解这一过程。</strong></p><figure class="nn no np nq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pe"><img src="../Images/4c220e6f5eef6c5692854f8c6a227c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eKLkwTE1eniKxqsY.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://www.researchgate.net/figure/Cascade-structure-for-Haar-classifiers_fig9_277929875" rel="noopener ugc nofollow" target="_blank">哈尔分类器的级联结构。</a></figcaption></figure><h1 id="0b8d" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">保罗-维奥拉算法可以被形象化如下:</h1><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/afddba2d4f0b0853157d7a00d2d97a76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/0*tTsnVeelkOL-y2IZ.gif"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://vimeo.com/12774628" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="a843" class="lf lg it bd lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly nl ma mb mc bi translated">基于OpenCV-Python的人脸检测</h1><p id="9cb9" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">现在我们对人脸识别背后的直觉和过程有了一个公平的想法。现在让我们使用OpenCV库来检测图像中的人脸。</p><h2 id="929c" class="nr lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lt kv ny nz lx kz oa ob mb oc bi translated">加载必要的库</h2><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="940d" class="nr lg it og b gy ol om l on oo">import numpy as np <br/>import cv2 <br/>import matplotlib.pyplot as plt <br/>%matplotlib inline</span></pre><h2 id="ab51" class="nr lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lt kv ny nz lx kz oa ob mb oc bi translated">加载待测图像的灰度</h2><p id="28bb" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">我们将使用下图:</p><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/5c41a691a7e29dfeeb10d98fbda3f033.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/0*a79ynCLQ_z2Kdiv9.png"/></div></figure><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="7acb" class="nr lg it og b gy ol om l on oo">#Loading the image to be tested <br/>test_image = cv2.imread('data/baby1.jpg')</span><span id="25fd" class="nr lg it og b gy ou om l on oo">#Converting to grayscale <br/>test_image_gray = cv2.cvtColor(test_image, cv2.COLOR_BGR2GRAY)</span><span id="1131" class="nr lg it og b gy ou om l on oo"># Displaying the grayscale image <br/>plt.imshow(test_image_gray, cmap='gray')</span></pre><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/d23bd91b61e472b40392ed99a0299955.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/0*ZSKNJFqdkOGI3xcw.png"/></div></figure><p id="17ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们知道OpenCV以BGR格式加载图像，所以我们需要将它转换成RBG格式，以便能够显示它的真实颜色。让我们为此编写一个小函数。</p><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="2fe3" class="nr lg it og b gy ol om l on oo">def convertToRGB(image): <br/>    return cv2.cvtColor(image, cv2.COLOR_BGR2RGB)</span></pre><h2 id="5ded" class="nr lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lt kv ny nz lx kz oa ob mb oc bi translated">哈尔级联文件</h2><p id="86f7" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">OpenCV附带了很多预先训练好的分类器。例如，有微笑、眼睛、脸等分类器。这些以XML文件的形式出现，位于文件夹<code class="fe od oe of og b">opencv/data/haarcascades/</code>中。然而，为了简单起见，您也可以从<a class="ae kf" href="https://github.com/parulnith/Face-Detection-in-Python-using-OpenCV/tree/master/data/haarcascades" rel="noopener ugc nofollow" target="_blank">这里的</a>访问它们。下载XML文件，并将它们放在与jupyter笔记本相同的工作目录下的data文件夹中。</p><h2 id="31f4" class="nr lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lt kv ny nz lx kz oa ob mb oc bi translated">加载正面人脸的分类器</h2><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="261b" class="nr lg it og b gy ol om l on oo">haar_cascade_face = cv2.CascadeClassifier('data/haarcascade/haarcascade_frontalface_default.xml')</span></pre><h2 id="8653" class="nr lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lt kv ny nz lx kz oa ob mb oc bi translated">人脸检测</h2><p id="2671" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">我们将使用分类器的<strong class="ki iu">检测多尺度</strong>模块。该函数将返回一个矩形，坐标为(x，y，w，h ),围绕检测到的人脸。该函数有两个重要参数，必须根据数据进行调整。</p><ul class=""><li id="849a" class="mi mj it ki b kj kk kn ko kr mk kv ml kz mm ld mn mo mp mq bi translated"><strong class="ki iu">比例因子</strong>在一张集体照中，可能会有一些人比其他人更靠近镜头。自然，这样的脸会比后面的脸显得更突出。这个因素弥补了这一点。</li><li id="930a" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated"><strong class="ki iu">邻居</strong>该参数指定一个矩形被称为一个面的邻居的数量。你可以在这里了解更多信息。</li></ul><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="94bf" class="nr lg it og b gy ol om l on oo">faces_rects = haar_cascade_face.detectMultiScale(test_image_gray, scaleFactor = 1.2, minNeighbors = 5);</span><span id="86ef" class="nr lg it og b gy ou om l on oo"># Let us print the no. of faces found<br/>print('Faces found: ', len(faces_rects))</span><span id="5d5d" class="nr lg it og b gy ou om l on oo">Faces found:  1</span></pre><p id="8b41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的下一步是循环遍历它返回的所有坐标，并使用Open CV在它们周围绘制矩形。我们将绘制一个厚度为2的绿色矩形</p><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="9efc" class="nr lg it og b gy ol om l on oo">for (x,y,w,h) in faces_rects:<br/>     cv2.rectangle(test_image, (x, y), (x+w, y+h), (0, 255, 0), 2)</span></pre><p id="93ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们将显示彩色的原始图像，以查看人脸是否被正确检测到。</p><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="3099" class="nr lg it og b gy ol om l on oo">#convert image to RGB and show image</span><span id="35fe" class="nr lg it og b gy ou om l on oo">plt.imshow(convertToRGB(test_image))</span></pre><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/0842e5153188491a9c5009f5f0a0ebe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/0*dKo_D4CIfSWTI4K6.png"/></div></figure><p id="45b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里。我们已经成功检测出照片中婴儿的脸部。现在让我们为整个人脸检测过程创建一个广义函数。</p><h1 id="0f32" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">基于广义函数的人脸检测</h1><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="6fe1" class="nr lg it og b gy ol om l on oo">def detect_faces(cascade, test_image, scaleFactor = 1.1):</span><span id="9a27" class="nr lg it og b gy ou om l on oo"># create a copy of the image to prevent any changes to the original one.<br/>    image_copy = test_image.copy()</span><span id="5fed" class="nr lg it og b gy ou om l on oo">    #convert the test image to gray scale as opencv face detector expects gray images<br/>    gray_image = cv2.cvtColor(image_copy, cv2.COLOR_BGR2GRAY)</span><span id="403c" class="nr lg it og b gy ou om l on oo">    # Applying the haar classifier to detect faces<br/>    faces_rect = cascade.detectMultiScale(gray_image, scaleFactor=scaleFactor, minNeighbors=5)</span><span id="9556" class="nr lg it og b gy ou om l on oo">    for (x, y, w, h) in faces_rect:<br/>        cv2.rectangle(image_copy, (x, y), (x+w, y+h), (0, 255, 0), 15)</span><span id="dacc" class="nr lg it og b gy ou om l on oo">    return image_copy</span></pre><h2 id="e46b" class="nr lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lt kv ny nz lx kz oa ob mb oc bi translated">在新图像上测试功能</h2><p id="f814" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">这个时间测试图像如下:</p><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/79ed3e91e6f7d29d523e33779a81fe4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/0*sfAw9gp5IxeDQhsS.png"/></div></figure><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="a982" class="nr lg it og b gy ol om l on oo">#loading image<br/>  test_image2 = cv2.imread('baby2.jpg')</span><span id="df72" class="nr lg it og b gy ou om l on oo">  # Converting to grayscale<br/>  test_image_gray = cv2.cvtColor(test_image, cv2.COLOR_BGR2GRAY)</span><span id="10a9" class="nr lg it og b gy ou om l on oo">  # Displaying grayscale image<br/>  plt.imshow(test_image_gray, cmap='gray')</span></pre><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/e2471f5a1e2f0c302981b76e8b5fdd71.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/0*2-t0SAXHXedXSPr4.png"/></div></figure><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="2152" class="nr lg it og b gy ol om l on oo">#call the function to detect faces<br/> faces = detect_faces(haar_face_cascade, test_image2)</span><span id="95e5" class="nr lg it og b gy ou om l on oo"> #convert to RGB and display image<br/> plt.imshow(convertToRGB(faces))</span></pre><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/4b6f2b2f2ede29ef8b1ae64b44762bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/0*ijT3oLy6WwsKUSeh.png"/></div></figure><h2 id="5cce" class="nr lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lt kv ny nz lx kz oa ob mb oc bi translated">在组图像上测试功能</h2><p id="aa44" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">现在让我们看看这个函数在团体照片上是否工作良好。我们将使用下面的图片来达到我们的目的。</p><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/97cb21036035a225eaa37d571472e832.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/0*qWLnoQGGa1xnmUIE.png"/></div></figure><p id="d61e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="le"> PC:印度女子板球队。</em> </strong></p><pre class="nn no np nq gt oh og oi oj aw ok bi"><span id="d9cc" class="nr lg it og b gy ol om l on oo">#loading image<br/>test_image2 = cv2.imread('group.jpg')</span><span id="1322" class="nr lg it og b gy ou om l on oo">#call the function to detect faces<br/>faces = detect_faces(haar_cascade_face, test_image2)</span><span id="7693" class="nr lg it og b gy ou om l on oo">#convert to RGB and display image<br/>plt.imshow(convertToRGB(faces))</span></pre><figure class="nn no np nq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pm"><img src="../Images/d04de58f068329e60e20dc818e95f03d.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/0*elYMU1k2tUxnJqTM.png"/></div></div></figure><p id="948c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">你可以在这里从</strong> <a class="ae kf" href="https://github.com/parulnith/Face-Detection-in-Python-using-OpenCV/blob/master/Face%20Detection%20with%20OpenCV-Python.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">访问完整的源代码。</strong> </a></p><h1 id="1425" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="6311" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">在本教程中，我们学习了使用Haar cascade在Python中使用Open CV进行人脸检测的概念。除了人脸还有很多检测器，可以在库中找到。随意试验它们，为眼睛、车牌等创建探测器。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><figure class="nn no np nq gt ju gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi pn"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure><div class="po pp gp gr pq pr"><a href="https://gitconnected.com/learn/python" rel="noopener  ugc nofollow" target="_blank"><div class="ps ab fo"><div class="pt ab pu cl cj pv"><h2 class="bd iu gy z fp pw fr fs px fu fw is bi translated">学习Python -最佳Python教程(2019) | gitconnected</h2><div class="py l"><h3 class="bd b gy z fp pw fr fs px fu fw dk translated">77大Python教程-免费学习Python。课程由开发人员提交并投票，使您能够…</h3></div><div class="pz l"><p class="bd b dl z fp pw fr fs px fu fw dk translated">gitconnected.com</p></div></div><div class="qa l"><div class="qb l qc qd qe qa qf jz pr"/></div></div></a></div></div></div>    
</body>
</html>