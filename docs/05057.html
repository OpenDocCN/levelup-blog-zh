<html>
<head>
<title>Graphs Data Structure: Depth First Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图形数据结构:深度优先搜索</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/graphs-data-structure-depth-first-search-4e71adef87b9?source=collection_archive---------21-----------------------#2020-07-31">https://levelup.gitconnected.com/graphs-data-structure-depth-first-search-4e71adef87b9?source=collection_archive---------21-----------------------#2020-07-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f633" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在之前的<a class="ae ko" href="https://medium.com/@Pavel_ilin/graphs-data-structure-breadth-first-search-ec662dc73079" rel="noopener">博客文章</a>中，我们讨论了如何将广度优先搜索算法应用于图形数据结构。今天，让我们弄清楚深度优先搜索(DFS)是如何工作的。</p><p id="611c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">DFS是用于在图中搜索节点和边的基本算法之一。这是一种遍历算法。</p><p id="eeda" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">提醒一下，这是我们的图表:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/8d3262cba49e4a6793ea4299932d442b.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*Fd6li4Ow_uVN9N7HHOw3lA.png"/></div></div></figure><p id="5e59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我们的邻接矩阵(在这里阅读邻接矩阵表示):</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/4bb754f6c579038250dc98e8187f7867.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*G3wD8Cn_wRkKJUIzZqApgg.png"/></div></figure><p id="7116" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据这个名字，我们可以假设BFS关注的是图形的深度。搜索从某个根节点开始，在回溯之前尽可能地搜索每个分支。</p><p id="f51e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的任务是编写一个算法，在回去探索其他路线之前，尽可能深入地探索路线。让我们看看我们如何能做它。</p><p id="a465" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">实施</strong></p><p id="70a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">深度优先搜索将基于堆栈中的内容。首先，我们将在堆栈中添加一个根节点，然后根据程序现在访问的节点更新这个值。我们将继续循环，直到所有的节点都被访问，堆栈变空。</p><p id="e6c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，我们将通过将被访问的节点存储在数组中来跟踪它们。最后，我们将返回这个数组来跟踪我们算法的路线。</p><p id="1905" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是最终代码的样子:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="2ef6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我们的溃败:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi le"><img src="../Images/2e4d790caabc4a3b3a93d32191538469.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*XRIAj4942eU4IxclpebjSA.png"/></div></figure><p id="84cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">结论</strong></p><p id="e0fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">邻接矩阵深度优先搜索的时间复杂度为O(V*E)。</p><p id="1678" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们讨论了如何用邻接矩阵表示来实现图形数据结构的BFS和DFS。我认为下一步应该是尝试邻接表，看看实现会有什么不同。</p><p id="5e1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不断学习，不断成长！</p><p id="8038" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以在<a class="ae ko" href="https://repl.it/@PavelIlin/Graphs-Depth-First-Search" rel="noopener ugc nofollow" target="_blank"> repl </a>里玩代码。</p><p id="ac1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在LinkedIn上连线吧！</p></div></div>    
</body>
</html>