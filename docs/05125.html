<html>
<head>
<title>WTF is Corecursion?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WTF是共同毁灭？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/wtf-is-corecursion-7d3ba8818b48?source=collection_archive---------13-----------------------#2020-08-05">https://levelup.gitconnected.com/wtf-is-corecursion-7d3ba8818b48?source=collection_archive---------13-----------------------#2020-08-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0af97720c51e0e66406d1637f9d308e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*o4V8F6VAPkNnaRhZ.png"/></div></div></figure><p id="415f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">递归是编程中经常用到的一个概念。通常，当人们说问题可以递归解决时，他们的意思是问题可以分解成一个更小的问题。</p><p id="191e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">许多算法和数据结构通常是以迭代和递归的方式解决的。</p><p id="7b77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">项目管理的生命周期通常以迭代的方式进行。一个庞大的系统可以分解成多个微服务。最流行的数据结构，数组，本质上是一种<em class="kw">递归</em>数据结构。</p><p id="13e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，假设你正在为一家X公司进行编码面试，他们会问你一些经典的斐波纳契问题。</p><p id="d95c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">"给定一个数n，打印第n个斐波那契数."</p><p id="595f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解决这个问题的第一个方法是递归或迭代(动态编程)。然而，也有另一种方式来回答这些问题，使用共奏。</p><p id="5190" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你一定在想:</p><p id="356b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“那么，什么是Corecurion？”</p><p id="e487" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将分享什么是共逆，并给你两个用共逆解决问题的例子。</p><h1 id="0077" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是共同毁灭？</h1><p id="c4c7" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">共递归是递归的反义词。递归<em class="kw">消耗</em>数据，而共递归<em class="kw">产生</em>数据。</p><p id="18e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">递归通常解析地工作。从远离基本案例的数据或问题开始，通过使用归纳法将问题分解成更小的数据，直到它达到基本案例。</p><p id="1aad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">协同进化综合作用。从基本案例开始并逐步建立—迭代地产生远离基本案例的数据，并具有某种递归关系。</p><p id="e542" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">共同毁灭的一个经典功能是<code class="fe ma mb mc md b">unfold</code>:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="7eec" class="mm ky iq md b gy mn mo l mp mq">def unfold[A,S](s: S)(f: S =&gt; Option[(A,S)]): List[A]</span></pre><p id="bfd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ma mb mc md b">A</code>是应用<code class="fe ma mb mc md b">f</code>后的状态结果，<code class="fe ma mb mc md b">S</code>是使用<code class="fe ma mb mc md b">f</code>后的当前状态或下一个状态。</p><p id="5a19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它需要一个初始状态，以及一个函数，用于在生成的迭代器中产生下一个状态和未来值，无论是列表还是流。</p><p id="9dcd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑递归与共递归的一种方法是，用自顶向下和自底向上的方法来解决问题。</p><p id="8b93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来实现<code class="fe ma mb mc md b">unfold</code>:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="19cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于经典的斐波那契数，我们可以通过从0和1开始展开来生成n个斐波那契数，并将这两个数相加来产生下一个状态:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="e7cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的函数中，我们通过跟踪<code class="fe ma mb mc md b">n</code>数和前一个状态中的两个来产生下一个斐波那契状态，从而产生一个斐波那契数列。当<code class="fe ma mb mc md b">num</code>达到0时，函数将终止，这意味着我们提供n个斐波那契数列。</p><p id="9432" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">核心体通常广泛用于函数式编程，主要是在处理无限数据结构时，比如流构建函数。通常，共简给出了产生潜在无限结构的有限子集的解决方案，例如创建生成器。</p><p id="e4c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将给出另外两个例子，我们可以用共递归来解决这个问题。</p><h1 id="f13f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">阶乘</h1><p id="79c4" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">阶乘的递归计算将定义一个基本情况<code class="fe ma mb mc md b">factorial(0)</code>等于<code class="fe ma mb mc md b">1</code>，递归关系将是<code class="fe ma mb mc md b">n * factorial(n-1)*</code>。</p><p id="5420" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于共简，我们从基础案例<code class="fe ma mb mc md b">factorial(0)</code>开始，也就是<code class="fe ma mb mc md b">1</code>。为了得到下一个结果，<code class="fe ma mb mc md b">n = 1</code>。</p><p id="6b64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就像常规的迭代解法一样，<code class="fe ma mb mc md b">factorial(2)</code>可以由<code class="fe ma mb mc md b">factorial(1) * (1+1)</code>导出。<code class="fe ma mb mc md b">factorial(1)</code>可以由<code class="fe ma mb mc md b">factorial(0) * (0+1)</code>派生而来，是基础案例。</p><p id="2e30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，我们可以倒着读——“用<code class="fe ma mb mc md b">n+1</code>乘<code class="fe ma mb mc md b">factorial(n)</code>可以产生<code class="fe ma mb mc md b">factorial(n+1)</code>”。</p><p id="84e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">知道了下一个值和下一个状态，让我们用<code class="fe ma mb mc md b">unfold</code>写出这个问题的解决方案:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="e641" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ma mb mc md b">unfold</code>函数将接受一个由<code class="fe ma mb mc md b">n</code>值和当前阶乘组成的元组。因此，我们在计算下一个阶乘数时增加了<code class="fe ma mb mc md b">n</code>的值。回调在<code class="fe ma mb mc md b">unfold</code>内起作用，采用未来值和下一个状态。下一个值将是<code class="fe ma mb mc md b">currentFactorial x num</code>，下一个状态将是一个包含以下数字和下一个计算阶乘的元组。</p><h1 id="5a31" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">树遍历</h1><p id="1e3b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">深度优先搜索方法中的树遍历是递归的经典例子。然而，广度优先搜索方法中的树遍历可以使用共递归来实现。</p><p id="8110" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实现深度优先和广度优先的根本区别在于存储节点的数据结构。当我们用深度优先搜索遍历树时，我们用栈(LIFO)存储每个节点。使用广度优先搜索，我们在遍历树时用队列(FIFO)存储节点。</p><p id="68c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它以后序遍历的方式递归地使用深度优先搜索。它从根开始，依次递归遍历每个子树。</p><p id="9994" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用corecursion实现广度优先搜索，可以从根开始，生成它的所有子树，并把它的所有子树作为一个整体列表放在下一个状态。下面的状态充当要遍历的队列。</p><p id="81f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们用节点中的<code class="fe ma mb mc md b">unfold</code>来实现BFS:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="61f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe ma mb mc md b">unfold</code>函数的每一步，我们将返回头部作为新结果，返回<code class="fe ma mb mc md b">newQueue</code>作为下一个状态。我们将把根节点的子节点添加到现有的“队列”列表中。</p><p id="e649" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">递归遍历将叶节点作为基本情况处理，并将树分析成子树。相比之下，corecursion遍历将根节点作为基本情况处理，并将树视为合成的根节点及其子节点。它在每一步产生一个辅助输出子树列表，为下一步提供输入。根的子节点将成为下一步的根节点。</p><h1 id="08f6" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">外卖食品</h1><p id="9fa6" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如果我们正在处理无限结构的树或生成无限结构的斐波那契或阶乘，共递归比递归更有用。通过递归，它将永远不会到达基本情况，因为它是无限的。然而，共简化将从基本情况开始，并无限地产生其输出。</p><p id="da6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">共简化的通用功能是<code class="fe ma mb mc md b">unfold</code>的精髓。展开是列举元素，使得给定的项目与其先例以及与之前一部分的先例具有相同的关系。</p><p id="058e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一种推导共递归的方法是使用迭代，或自底向上的方法。在函数式编程中，通过流构建函数已经慢慢地定义了共递归。</p><p id="f75c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有代码的来源是<a class="ae mt" href="https://github.com/edwardGunawan/Blog-Tutorial/blob/master/ScalaTutorial/corecursion/src/main/scala/main.scala" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="295e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">感谢阅读！如果你喜欢这篇文章，请随意订阅我的时事通讯中的</strong><a class="ae mt" href="https://edward-huang.com/subscribe/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"/></a><strong class="ka ir">来获得关于科技职业的文章、有趣的链接和内容的通知！</strong></p><p id="ee3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以关注我，也可以在<a class="ae mt" href="https://medium.com/@edwardgunawan880" rel="noopener">媒体</a>上关注我，以获得更多类似的帖子。</p><p id="b96f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">原载于</em><a class="ae mt" href="https://edward-huang.com/functional-programming/algorithm/programming/scala/2020/08/02/wtf-is-corecursion/" rel="noopener ugc nofollow" target="_blank"><em class="kw"/></a><em class="kw">。</em></p></div></div>    
</body>
</html>