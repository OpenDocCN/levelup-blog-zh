<html>
<head>
<title>A Brief Introduction to Blockchain Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">区块链发展简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-brief-introduction-to-blockchain-development-c5fdc038b95f?source=collection_archive---------7-----------------------#2021-04-25">https://levelup.gitconnected.com/a-brief-introduction-to-blockchain-development-c5fdc038b95f?source=collection_archive---------7-----------------------#2021-04-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="43d0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建Dapp所需的一切</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1d866229e8e66963a6be21e27487726d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pWSdnAyqwzpepg6ENrdveA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">谢谢<a class="ae ky" href="https://www.pexels.com/photo/code-coding-computer-cyberspace-270373/" rel="noopener ugc nofollow" target="_blank"> Pexels </a>！</figcaption></figure><p id="855b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章会给你一个简要的概述，当你开始着手<strong class="lb iu">区块链发展</strong>时，你<em class="lv">应该</em>知道的一切。</p><p id="dbdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们先弄清楚一些事情。我们不是在这里建造一个区块链。这就是区块链<em class="lv">核心</em>开发者所做的。我们在这里学习区块链<em class="lv">应用</em>开发的基础知识。这些是由区块链支持的分散式应用程序。</p><p id="c8f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多不同的区块链为我们的Dapp提供动力。但是最大的是<a class="ae ky" href="https://ethereum.org/en/" rel="noopener ugc nofollow" target="_blank">以太坊</a>。</p><p id="6d8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了与以太坊生态系统互动，你需要一个以太坊钱包和一些以太坊。最受欢迎的以太坊钱包之一是<a class="ae ky" href="https://metamask.io/" rel="noopener ugc nofollow" target="_blank"> Metamask </a>。</p><p id="1f1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以太坊钱包有三个部分</p><ol class=""><li id="b9f5" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">以太坊账户——可以发送和接收以太坊的实体</li><li id="6b6b" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">公钥——用户可以向其发送以太坊的地址</li><li id="b26d" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">私钥—访问您的以太坊</li></ol><p id="ce1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将使用您的以太坊钱包与以太坊网络中的Dapps进行交互。假设你想把你的以太币换成另一种加密货币。你可以通过分散交易平台Uniswap进行交易。</p><p id="5d0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://uniswap.org/" rel="noopener ugc nofollow" target="_blank"> Uniswap </a>由以太坊区块链公司提供动力。它依靠一种叫做智能合约的东西运行。但是那些是什么？</p><p id="c8c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">智能合约</strong> —区块链上的程序</p><p id="5353" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">智能合同有3个主要部分。</p><ul class=""><li id="e29a" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mk mc md me bi translated">用户—使用智能合同的人。</li><li id="eab9" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated">代码—使用智能合约时会发生什么。</li><li id="1c5f" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated">存储—智能合约将更改的对象。</li></ul><p id="12d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要说明的是，Dapps写在许多智能合约中。不止一个。例如，<a class="ae ky" href="https://github.com/Uniswap" rel="noopener ugc nofollow" target="_blank"> Uniswap </a>是一个由许多智能合约支持的Dapp。</p><p id="b999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Dapps与web开发中的后端或服务器端相当。客户端将连接到以太坊虚拟机上的智能合约，而不是连接到中央服务器。这就是我们的智能合约所在。</p><p id="5e8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们如何为我们的Dapp创建智能合约呢？</p><h1 id="ac11" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated"><strong class="ak">介绍坚固性</strong></h1><p id="fe23" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">Solidity是一种设计用于EVM的高级编程语言。你可以用Solidity来写你的智能合约。但是还有其他选择。</p><p id="5fb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将探索智能合约的一些基本语法和一般结构。然后，我们将为我们自己的令牌写一个简单的契约。</p><p id="89a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">坚固性使用原始类型。如果你熟悉另一种编程语言，你会认识一些。</p><ul class=""><li id="6d6c" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mk mc md me bi translated"><strong class="lb iu">布尔型</strong> —真或假</li><li id="2257" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated"><strong class="lb iu"> Uint </strong> —整数(数字决定大小的X次方)</li><li id="4492" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated"><strong class="lb iu">地址</strong> —以太坊地址</li><li id="400f" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated"><strong class="lb iu">字符串</strong> —文本</li></ul><p id="41dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很简单。以下是您将在Solidity中使用的基本数据结构。</p><ul class=""><li id="8957" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mk mc md me bi translated"><strong class="lb iu">数组</strong> —从零开始的项目列表(可以是固定数量或动态的)</li><li id="be1c" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated"><strong class="lb iu">映射</strong> —用键值对存储数据</li><li id="98e9" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated"><strong class="lb iu">结构</strong> —用于定义存储变量的新方式</li><li id="2f77" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated"><strong class="lb iu">枚举</strong> —创建自己的数据结构</li></ul><p id="e46b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设置可见性是智能合约开发的重要部分。你不希望你的私人地址公开！</p><p id="6097" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些关键字可以应用于变量和函数。</p><ul class=""><li id="bb54" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mk mc md me bi translated"><strong class="lb iu"> Public </strong> —任何人都可以调用这个函数</li><li id="c856" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated"><strong class="lb iu">私有</strong> —只有契约可以调用该函数</li><li id="74c7" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated"><strong class="lb iu">视图</strong> —该函数返回数据，不修改数据</li><li id="cd6e" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated"><strong class="lb iu">纯</strong> —函数不会修改甚至读取合同数据</li><li id="94be" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated"><strong class="lb iu">应付</strong> —功能可以接收以太坊</li></ul><p id="9a01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你将会经常使用公共和私有。但是记住其他人很重要。</p><p id="3431" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样一来，我们就可以开始写代码了！</p><h1 id="a05b" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">制作媒体令牌</h1><p id="c9f2" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">首先，我们使用<em class="lv"> Pragma </em>关键字<em class="lv">，</em>声明solidity的版本，然后指定Solidity为编译器以及什么版本。让我们看一个例子。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="915c" class="nn mm it nj b gy no np l nq nr"><strong class="nj iu">pragma solidity</strong> &gt;=0.4.22 &lt;0.6.0;</span></pre><p id="4544" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似这样的东西会出现在你写的每一份聪明的合同的顶部。</p><p id="aa7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是开发过程中的重要一步。编写了一个惊人的智能契约，却发现编译器无法与您使用的Solidity版本兼容，这不是很糟糕吗？</p><p id="2ad5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将为Medium创建一个令牌。姑且称之为<em class="lv"> MediumToken </em>。</p><p id="19fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要实际声明合同。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="97c8" class="nn mm it nj b gy no np l nq nr"><strong class="nj iu">pragma solidity</strong> &gt;=0.4.22 &lt;0.6.0;</span><span id="7940" class="nn mm it nj b gy ns np l nq nr">contract MediumToken {</span><span id="cacc" class="nn mm it nj b gy ns np l nq nr">}</span></pre><p id="9140" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里没什么特别的。只是为我们的令牌添加基本结构。</p><p id="2684" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">智能合约需要有一个构造函数。当我们的代码被部署到区块链时，这个函数将运行一次。</p><p id="ec64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来补充一下。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="2824" class="nn mm it nj b gy no np l nq nr"><strong class="nj iu">pragma solidity</strong> &gt;=0.4.22 &lt;0.6.0;</span><span id="66b9" class="nn mm it nj b gy ns np l nq nr">contract MediumToken {</span><span id="6c16" class="nn mm it nj b gy ns np l nq nr">constructor() public {<br/>address owner = msg.sender;<br/>    }</span><span id="e0b1" class="nn mm it nj b gy ns np l nq nr">}</span></pre><p id="4c78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们声明了一个<em class="lv">地址</em>变量，它等于msg.sender。这是调用这个函数的人的地址。也就是你。</p><p id="d92f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要在构造函数中做的另一件事是创建中间令牌。基本上，设置供给。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="b8eb" class="nn mm it nj b gy no np l nq nr"><strong class="nj iu">pragma solidity</strong> &gt;=0.4.22 &lt;0.6.0;</span><span id="69bf" class="nn mm it nj b gy ns np l nq nr">contract MediumToken {</span><span id="30ec" class="nn mm it nj b gy ns np l nq nr">constructor() public {<br/>address owner = msg.sender;<br/>balance[owner] = 420;   }</span><span id="bfa4" class="nn mm it nj b gy ns np l nq nr">}</span></pre><p id="778b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恭喜你。你刚刚铸造了420个中型代币。这个数字可以是你想要的任何数字。可能是5万亿或1万亿。以及两者之间的任何地方。</p><p id="d65a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还把所有的代币都给了所有者(你)。</p><p id="2329" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的构造函数运行之后，我们需要创建所有余额的映射。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="695b" class="nn mm it nj b gy no np l nq nr"><strong class="nj iu">pragma solidity</strong> &gt;=0.4.22 &lt;0.6.0;</span><span id="08b9" class="nn mm it nj b gy ns np l nq nr">contract MediumToken {</span><span id="940a" class="nn mm it nj b gy ns np l nq nr">constructor() public {<br/>address owner = msg.sender;<br/>balance[owner] = 420;   }</span><span id="a278" class="nn mm it nj b gy ns np l nq nr">mapping (address =&gt; uint256) public balances;</span><span id="b3cd" class="nn mm it nj b gy ns np l nq nr">}</span></pre><p id="c219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个<em class="lv">公共</em>映射，意味着任何人都可以看到它并与之交互。</p><p id="4c81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要编写一个允许用户发送他们的媒体令牌的函数。这看起来会像这样。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="9499" class="nn mm it nj b gy no np l nq nr"><strong class="nj iu">pragma solidity</strong> &gt;=0.4.22 &lt;0.6.0;</span><span id="bf82" class="nn mm it nj b gy ns np l nq nr">contract MediumToken {</span><span id="53d5" class="nn mm it nj b gy ns np l nq nr">constructor() public {<br/>address owner = msg.sender;<br/>balance[owner] = 420;   }</span><span id="962a" class="nn mm it nj b gy ns np l nq nr">mapping (address =&gt; uint256) public balances;</span><span id="d21b" class="nn mm it nj b gy ns np l nq nr">function send(uint amount, address recipient) public {</span><span id="ecde" class="nn mm it nj b gy ns np l nq nr">require(balances[msg.sender] &gt;= amount);<br/>require(balances[msg.sender] -amount &lt;= balances[msg.sender]);  require(balances[recipient] + amount &gt;= balances[recipient]);</span><span id="998b" class="nn mm it nj b gy ns np l nq nr">balances[msg.sender] -= amount; // Always subtract first  balances[recipient] += amount; // Add amount to recipient<br/>    }</span><span id="0e29" class="nn mm it nj b gy ns np l nq nr">}</span></pre><p id="2ce4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来分析一下这是怎么回事。</p><p id="0963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<em class="lv"> send </em>函数将以uint的形式接受金额。它还将接受收件人的地址。而且这个功能是公开的，任何人都可以看到。</p><p id="0ba4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们做的第一件事是创建一些require语句。这样我们就可以检查发送者的钱包中是否真的有足够的代币。</p><p id="4706" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外两个需求陈述是安全措施。智能合约开发越多越好。</p><p id="d3b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个是确保发送方的余额在发送令牌后小于或等于。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="8abc" class="nn mm it nj b gy no np l nq nr">require(balances[msg.sender] -amount &lt;= balances[msg.sender]);</span></pre><p id="e712" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个是确保收件人的地址大于或等于交易前的地址。</p><p id="77f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！我们创造了420个MediumTokens，把它们给了主人，创造了把它送给人的能力！</p><p id="fc92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想再看一遍，这里有完整的代码。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="b71a" class="nn mm it nj b gy no np l nq nr"><strong class="nj iu">pragma solidity</strong> &gt;=0.4.22 &lt;0.6.0;</span><span id="1ec9" class="nn mm it nj b gy ns np l nq nr">contract MediumToken {</span><span id="9ed4" class="nn mm it nj b gy ns np l nq nr">constructor() public {<br/>address owner = msg.sender;<br/>balance[owner] = 420;   }</span><span id="9472" class="nn mm it nj b gy ns np l nq nr">mapping (address =&gt; uint256) public balances;</span><span id="8096" class="nn mm it nj b gy ns np l nq nr">function send(uint amount, address recipient) public {</span><span id="204d" class="nn mm it nj b gy ns np l nq nr">require(balances[msg.sender] &gt;= amount);<br/>require(balances[msg.sender] -amount &lt;= balances[msg.sender]);  require(balances[recipient] + amount &gt;= balances[recipient]);</span><span id="9f9e" class="nn mm it nj b gy ns np l nq nr">balances[msg.sender] -= amount; // Always subtract first  balances[recipient] += amount; // Add amount to recipient<br/>    }</span><span id="930c" class="nn mm it nj b gy ns np l nq nr">}</span></pre><p id="6844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你写好了你的最终合同，你就可以把它部署到区块链。<em class="lv">但是首先把它部署到测试网上总是一个好主意。</em></p><p id="56ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有兴趣的话，你可以看看这个教程。</p></div></div>    
</body>
</html>