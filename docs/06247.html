<html>
<head>
<title>Testing React Hook Form With React Testing Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React测试库测试React钩子形式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/testing-react-hook-form-with-react-testing-library-16141ea17c8f?source=collection_archive---------1-----------------------#2020-11-08">https://levelup.gitconnected.com/testing-react-hook-form-with-react-testing-library-16141ea17c8f?source=collection_archive---------1-----------------------#2020-11-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/eb5ac59f3f4593ba47317bc1f54434d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Oj4wlp2Hp2FIr67-.jpg"/></div></div></figure><p id="0ea0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/managing-forms-with-react-hook-form-ae771dcf343d">之前的帖子</a>中，我们使用<a class="ae kz" href="https://react-hook-form.com/" rel="noopener ugc nofollow" target="_blank"> React Hook表单</a>添加了一个基本的食谱表单。为它添加一些单元测试将是一个好主意，以确保表单正常工作并捕捉任何未来的回归。我们将使用<a class="ae kz" href="https://testing-library.com/docs/react-testing-library" rel="noopener ugc nofollow" target="_blank"> React测试库</a> (RTL)作为测试框架的选择，因为它与钩子形式配合得非常好，并且是测试它的推荐库。</p><p id="b8ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">像往常一样，让我们从安装所需的包开始。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="325a" class="lj lk it lf b gy ll lm l ln lo">npm install --save-dev @testing-library/react @testing-library/jest-dom</span></pre><p id="abdd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了测试库，我们还添加了<a class="ae kz" href="https://github.com/testing-library/jest-dom" rel="noopener ugc nofollow" target="_blank"> jest-dom </a>来使用定制的jest匹配器。现在我们可以开始为Recipe组件编写测试了。让我们创建<strong class="kd iu"> Recipe.test.js </strong>文件，并添加第一个测试，检查基本字段是否正确呈现。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="7818" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">熟悉RTL的人可能会注意到，我们在这里没有使用<code class="fe lr ls lt lf b">getByText</code>查询，而是默认使用<code class="fe lr ls lt lf b">getByRole</code>。后者更受欢迎，因为它更接近用户与页面的交互方式——既使用鼠标/视觉显示，也使用辅助技术。</p><p id="cc10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是使用RTL的一个特别有说服力的理由——如果编写代码时考虑到可访问性，那么在大多数情况下,<code class="fe lr ls lt lf b">getByRole</code>查询就足够了。为了能够有效地使用<code class="fe lr ls lt lf b">*ByRole</code>查询，有必要了解每个HTML元素有什么作用。在我们的表单中我们使用<code class="fe lr ls lt lf b">h1</code>，它有<strong class="kd iu">标题</strong>角色，文本<code class="fe lr ls lt lf b">input</code>和<code class="fe lr ls lt lf b">textarea</code>有<strong class="kd iu">文本框</strong>角色，数字<code class="fe lr ls lt lf b">input</code>有<strong class="kd iu">微调按钮</strong>角色，<code class="fe lr ls lt lf b">button</code>有<strong class="kd iu">按钮</strong>角色。由于我们有多个具有相同角色的元素，我们可以使用<code class="fe lr ls lt lf b">name</code>选项来缩小搜索范围并匹配特定的元素。需要注意的是，这不是我们赋予输入元素的<strong class="kd iu">名称</strong>属性，而是它们的<a class="ae kz" href="https://www.w3.org/TR/accname-1.1/" rel="noopener ugc nofollow" target="_blank">可访问名称</a>，辅助技术使用它来识别HTML元素。浏览器使用几个规则来计算可访问名称。</p><p id="94a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">出于我们的目的，输入的可访问名称是从它的相关元素中计算出来的，在本例中，它是输入的标签。然而，要做到这一点，标签必须与输入正确关联，例如，输入被包装在标签中，或者标签具有与输入的<code class="fe lr ls lt lf b">id</code>相对应的<code class="fe lr ls lt lf b">for</code>属性。现在我们看到了具有可访问的表单是如何使测试变得更容易的。对于button，如果没有<code class="fe lr ls lt lf b">aria-label</code>或关联的<code class="fe lr ls lt lf b">aria-labelledby</code>属性(优先于其他提供的和本机的可访问名称)，则可访问名称是使用其内容计算的。在这种情况下，需要<strong class="kd iu">添加配料</strong>和<strong class="kd iu">保存</strong>文本。此外，我们可以使用regex语法来匹配名称，这很方便，例如，对于不区分大小写的匹配。</p><p id="34d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经完成了基础测试，让我们继续测试领域验证。在此之前，我们将通过添加<code class="fe lr ls lt lf b">saveData</code> prop来稍微修改表单组件，它将在表单提交时被调用。这样我们可以测试它是否被调用，并检查参数。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="68cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通常<code class="fe lr ls lt lf b">saveData</code>会调用API将表单数据发送到服务器或进行一些数据处理。出于字段验证的目的，我们只对该函数是否被调用感兴趣，因为如果任何字段无效，表单的<code class="fe lr ls lt lf b">onSubmit</code>回调就不会被调用。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="6a4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们通过提供无效数据一次性测试所有字段——没有名称、太长的描述和超过10的服务数量。然后我们提交表单，并检查错误消息的数量(呈现为<code class="fe lr ls lt lf b">span</code>和<code class="fe lr ls lt lf b">alert</code>角色)是否与出错字段的数量相同。我们甚至可以更进一步，检查特定的错误消息是否显示在屏幕上，但这似乎有点过分。由于提交表单会导致状态改变和重新呈现，我们需要使用<code class="fe lr ls lt lf b">findAllByRole</code>查询和<code class="fe lr ls lt lf b">await</code>来获取表单重新呈现后的错误消息。最后，我们确认没有调用模拟保存回调。</p><p id="d925" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们开始测试整个提交表单流之前，最好验证一下是否正确地添加和删除了成分字段。同时，让我们花点时间来改进“删除配料”按钮的可访问性，该按钮目前看起来像这样:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="0533" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">HTML字符<code class="fe lr ls lt lf b">&amp;#8722;</code>被用作减号<code class="fe lr ls lt lf b">-</code>，从可访问性的角度来看，这远非最佳选择。如果我们能提供一个实际的文本来描述这个按钮的功能，那就更好了。为了解决这个问题，我们将使用<code class="fe lr ls lt lf b">aria-label</code>属性。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="7f60" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是更好的方式，加上现在我们可以很容易地在测试中查询特定的删除按钮。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="52e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们继续使用类似的文本结构，并验证是否正确添加和删除了成分字段。值得注意的是，我们仍然可以使用<code class="fe lr ls lt lf b">*ByRole</code>查询，只是在移除按钮的情况下<code class="fe lr ls lt lf b">aria-label</code>现在是它的可访问名称。</p><p id="93ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后是测试表单提交流程的时候了。为了测试它，我们填写所有的字段，提交表单，然后验证我们的<code class="fe lr ls lt lf b">mockSave</code>函数已经被调用，并带有预期的值。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="0cf5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里需要注意的是，我们使用<code class="fe lr ls lt lf b">waitFor</code>实用程序来测试异步操作(提交表单)的结果。它将在异步操作完成后触发提供的回调。</p><p id="c2ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们有了一个相当全面的单元测试套件来验证表单的行为。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="31e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mb">最初发表于</em><a class="ae kz" href="https://claritydev.net/blog/testing-react-hook-form-with-react-testing-library/" rel="noopener ugc nofollow" target="_blank"><em class="mb">【https://claritydev.net】</em></a><em class="mb">。</em></p></div></div>    
</body>
</html>