<html>
<head>
<title>Let’s Create a Simple Load Balancer with Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们用Go创建一个简单的负载平衡器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/create-a-simple-load-balancer-with-go-4b474460bab2?source=collection_archive---------1-----------------------#2019-11-08">https://levelup.gitconnected.com/create-a-simple-load-balancer-with-go-4b474460bab2?source=collection_archive---------1-----------------------#2019-11-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/601ac645ba5a0caeb15b4524ab63b1ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*_9o3Zvr7BqDHANOpAJP43A.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">让我们用Go创建一个简单的负载平衡器</figcaption></figure><blockquote class="jy jz ka"><p id="b958" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注:你也可以在这里阅读来自<a class="ae la" href="https://kasvith.github.io/posts/lets-create-a-simple-lb-go" rel="noopener ugc nofollow" target="_blank">的文章。</a></p></blockquote><p id="df55" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">负载平衡器通过将负载分配给一组后端服务器，在web体系结构中起着关键作用。这使得服务更具可扩展性和可靠性。此外，由于配置了多个后端，该服务变得高度可用，因为负载平衡器可以在出现故障时修复正在工作的服务器。</p><p id="92fa" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在玩了像<a class="ae la" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> NGINX </a>这样的专业负载平衡器之后，我试着用<a class="ae la" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Golang </a>创建了一个简单的负载平衡器。</p><p id="03e6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">Go是一种现代语言，作为一等公民支持并发。Go有一个丰富的标准库，允许用更少的代码行编写高性能的应用程序。它还生成一个静态链接的单个二进制文件，以便于分发。</p><h1 id="2f3d" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">我们的简单负载平衡器是如何工作的</h1><p id="d09d" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">负载平衡器有不同的策略在一组后端之间分配负载。</p><p id="acac" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">举个例子，</p><ul class=""><li id="61e0" class="mh mi iq ke b kf kg kj kk lb mj lc mk ld ml kz mm mn mo mp bi translated"><strong class="ke ir">循环调度</strong> —平均分配负载，假设所有后端具有相同的处理能力</li><li id="850c" class="mh mi iq ke b kf mq kj mr lb ms lc mt ld mu kz mm mn mo mp bi translated"><strong class="ke ir">加权循环法</strong> —考虑到后端的处理能力，可以给出额外的权重</li><li id="5b92" class="mh mi iq ke b kf mq kj mr lb ms lc mt ld mu kz mm mn mo mp bi translated"><strong class="ke ir">最少连接</strong> —负载被分配给具有最少活动连接的服务器</li></ul><p id="2313" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">对于我们简单的负载均衡器，我们将使用这些方法中最简单的一个来实现，<strong class="ke ir">循环调度</strong>。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/4edba69a3249a1e6df0c3eaa9bbcd274.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/0*KtBXf8ouBRKUUqZV.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">循环负载平衡器</figcaption></figure><h1 id="dae4" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">循环选择</h1><p id="29f1" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">循环赛很简单。它为工人轮流执行任务提供了平等的机会。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/3b6e295d444a03d62d4961b28ebcec67.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/0*IjBcoNy7W3TPDxrs.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">传入请求的循环选择</figcaption></figure><p id="d53c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">如图所示，这种情况循环发生。但是我们不能直接使用它，不是吗？</p><p id="0bbc" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated"><strong class="ke ir">如果后端宕机了怎么办？我们可能不想在那里安排交通。所以这个不能直接用，除非我们给它加上一些条件。我们需要<strong class="ke ir">只将流量路由到已经启动并运行的后端</strong>。</strong></p><h1 id="2a72" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">让我们定义一些结构</h1><p id="6be1" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">修改计划后，我们知道现在我们需要一种方法来跟踪后端的所有细节。我们需要跟踪它是活的还是死的，还要跟踪URL。</p><p id="7c22" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">我们可以简单地定义一个这样的结构来保存我们的后端。</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="8866" class="ng lf iq nc b gy nh ni l nj nk">type Backend struct {<br/>   URL          *url.URL<br/>   Alive        bool<br/>   mux          sync.RWMutex<br/>   ReverseProxy *httputil.ReverseProxy<br/>}</span></pre><p id="fe52" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">别担心，我会对<code class="fe nl nm nn nc b">Backend</code>中的字段进行推理。</p><p id="9a46" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">现在我们需要一种方法来跟踪负载平衡器中的所有后端，因为我们可以简单地使用一个片和一个计数器变量。我们可以定义为<code class="fe nl nm nn nc b"><strong class="ke ir">ServerPool</strong></code> <strong class="ke ir"> : </strong></p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="5d21" class="ng lf iq nc b gy nh ni l nj nk">// ServerPool holds information about reachable backends<br/>type ServerPool struct {<br/>   backends []*Backend<br/>   current  uint64<br/>}</span></pre><h1 id="6b64" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">反向Proxy的使用</h1><p id="1c2c" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">正如我们已经指出的，负载平衡器的唯一目的是将流量路由到不同的后端，并将结果返回给原始客户端。</p><p id="4bc8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">根据Go的文档:</p><blockquote class="jy jz ka"><p id="2218" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq"> ReverseProxy是一个HTTP处理程序，它接收一个传入的请求并将其发送到另一个服务器，将响应代理回客户端。</em></p></blockquote><p id="fe81" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这正是我们想要的。没有必要重新发明轮子。我们可以简单地通过<code class="fe nl nm nn nc b">ReverseProxy</code>传递我们最初的请求。</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="8332" class="ng lf iq nc b gy nh ni l nj nk">u, _ := url.Parse("http://localhost:8080")<br/>rp := httputil.NewSingleHostReverseProxy(u)<br/><em class="kd">// initialize your server and add this as handler<br/></em>http.HandlerFunc(rp.ServeHTTP)</span></pre><p id="b0c6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">使用<code class="fe nl nm nn nc b">httputil.NewSingleHostReverseProxy(url)</code>,我们可以初始化一个反向代理，它将请求转发给被传递的<code class="fe nl nm nn nc b">url</code>。在上面的例子中，所有的请求现在都被传递到localhost:8080，结果被发送回原来的客户机。</p><p id="10cc" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">如果我们看一下<code class="fe nl nm nn nc b">ServeHTTP</code>方法签名，它具有与HTTP处理程序相同的签名，这就是为什么我们可以将它传递给<code class="fe nl nm nn nc b">http</code>中的<code class="fe nl nm nn nc b">HandlerFunc</code>。</p><p id="738f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">您可以在<a class="ae la" href="https://golang.org/pkg/net/http/httputil/#ReverseProxy" rel="noopener ugc nofollow" target="_blank">文档</a>中找到更多示例。</p><p id="0b64" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">对于我们简单的负载平衡器，我们可以用<code class="fe nl nm nn nc b">Backend</code>中相关联的<code class="fe nl nm nn nc b">URL</code>来启动<code class="fe nl nm nn nc b">ReverseProxy</code>，这样<code class="fe nl nm nn nc b">ReverseProxy</code>就会将我们的请求路由到<code class="fe nl nm nn nc b">URL</code>。</p><h1 id="7b9b" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">选拔过程</h1><p id="a931" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">我们需要在下一次挑选时跳过死胡同。但是做任何事情我们都需要一种计数的方法。</p><p id="27fa" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">多个客户端将连接到负载均衡器，当每个客户端请求下一个对等端传递流量时，可能会出现竞争情况。为了防止这种情况，我们可以用<code class="fe nl nm nn nc b">mutex</code>锁定<code class="fe nl nm nn nc b">ServerPool</code>。但是这可能有点过了，而且我们根本不想锁定服务器池。我们只想把计数器加1</p><p id="59c1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">为了满足这一要求，理想的解决方案是以原子方式进行这一增量。Go通过<code class="fe nl nm nn nc b">atomic</code>包支持该井。</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="b454" class="ng lf iq nc b gy nh ni l nj nk">// NextIndex atomically increase the counter and return an index<br/>func (s *ServerPool) NextIndex() int {<br/>   return int(atomic.AddUint64(&amp;s.current, uint64(1)) % uint64(len(s.backends)))<br/>}</span></pre><p id="f087" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在这里，我们将当前值自动增加1，并通过修改切片的长度来返回索引。这意味着该值将始终介于0和切片长度之间。最后，我们感兴趣的是特定的索引，而不是总计数。</p><h1 id="9f32" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">挑选一个活的后端</h1><p id="46e3" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">我们已经知道，我们的请求在每个后端的循环中被路由。我们只需要跳过死的，就这样。</p><p id="7c9b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated"><code class="fe nl nm nn nc b">GetNext()</code>总是返回一个限制在0和切片长度之间的值。在任何时候，我们都会得到下一个对等体，如果它不存在，我们将不得不在一个循环中搜索整个切片。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi no"><img src="../Images/e50dcc4d0bd289401c6c38aec1bf5181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/0*6z_8MBk1MKBraMBi.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">循环遍历切片</figcaption></figure><p id="14ae" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">如上图所示，我们想从下到上遍历整个列表，只需遍历<code class="fe nl nm nn nc b">next + length</code>即可。要选择一个索引，我们希望它位于切片长度之间。这很容易通过修改操作来完成。</p><p id="28b2" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在我们通过搜索找到一个工作的后端之后，我们将它标记为当前的后端。</p><p id="e2e1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">下面你可以看到上面操作的代码:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">获取下一个对等点</figcaption></figure><h1 id="fbe2" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">避免后端结构中的竞争情况</h1><p id="ddad" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">我们需要考虑一个严肃的问题。我们的<code class="fe nl nm nn nc b">Backend</code>结构有一个可以被不同的goroutines同时修改或访问的变量。</p><p id="d4c5" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">我们知道会有更多的goroutines从这里读取而不是写入。所以我们选择了<code class="fe nl nm nn nc b">RWMutex</code>来序列化对<code class="fe nl nm nn nc b">Alive</code>的访问。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">用互斥体保护数据</figcaption></figure><h1 id="56f0" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">让负载平衡请求</h1><p id="181c" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">有了我们创建的所有背景，我们可以制定以下简单的方法来负载平衡我们的请求。只有当我们的所有后端都离线时，它才会失败。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">简单地分配负载</figcaption></figure><p id="e904" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这个方法可以简单地作为一个<code class="fe nl nm nn nc b">HandlerFunc</code>传递给HTTP服务器。</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="16ff" class="ng lf iq nc b gy nh ni l nj nk">server := http.Server{<br/>  Addr:    fmt.Sprintf(":%d", port),<br/>  Handler: http.HandlerFunc(lb),<br/>}</span></pre><h1 id="08b0" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">仅将流量路由到健康的后端</h1><p id="1f8e" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">我们当前的<code class="fe nl nm nn nc b">lb</code>有一个严重的问题。我们不知道后端是否健康。为了知道这一点，我们必须尝试一个后端，并检查它是否是活的。</p><p id="72f1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">我们可以用两种方式做到这一点，</p><ul class=""><li id="89aa" class="mh mi iq ke b kf kg kj kk lb mj lc mk ld ml kz mm mn mo mp bi translated"><strong class="ke ir"> Active </strong>:在执行当前请求时，我们发现所选后端没有响应，将其标记为down。</li><li id="4100" class="mh mi iq ke b kf mq kj mr lb ms lc mt ld mu kz mm mn mo mp bi translated"><strong class="ke ir">被动</strong>:我们可以以固定的时间间隔ping后端并检查状态</li></ul><h1 id="b21b" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">主动检查健康的后端</h1><p id="96b7" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated"><code class="fe nl nm nn nc b">ReverseProxy</code>触发回调函数，<code class="fe nl nm nn nc b">ErrorHandler</code>出现任何错误。我们可以用它来检测任何故障。下面是实现。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">错误处理程序的实现</figcaption></figure><p id="ff5e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在这里，我们利用闭包的<strong class="ke ir">功能来设计这个错误处理程序。它允许我们在方法中捕获外部变量，比如服务器URL。它将检查现有的重试计数，如果它小于3，我们再次发送相同的请求到相同的后端。</strong></p><p id="bbc7" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这背后的原因是由于临时错误，服务器可能会拒绝您的请求，它可能会在短暂的延迟后可用(可能是服务器耗尽了套接字以接受更多的客户端)。因此，我们设置了一个计时器来延迟重试大约10毫秒。<em class="kd">我们会根据每个请求增加重试次数</em>。</p><p id="7d26" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在<strong class="ke ir">每次重试失败</strong>后，我们<strong class="ke ir">将该后端标记为关闭</strong>。</p><p id="3ffa" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">下一件我们想做的事情是尝试使用一个新的具有相同请求的后端。我们通过使用上下文包对尝试进行计数来做到这一点。在增加了尝试计数之后，我们将它传递回<code class="fe nl nm nn nc b">lb</code>以选择一个新的对等点来处理请求。</p><p id="ec0c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">现在我们不能无限期地这样做，因此我们需要从<code class="fe nl nm nn nc b">lb</code>开始检查在进一步处理请求之前是否已经达到了最大尝试次数。</p><p id="52fc" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">我们可以简单地从请求中获取尝试计数，如果它超过了最大计数，就删除请求。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">最终负载平衡法</figcaption></figure><p id="ee6f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这种实现是递归的。</p><h1 id="e1cf" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">上下文的使用</h1><p id="be11" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated"><code class="fe nl nm nn nc b">context</code>包允许你在一个HTTP请求中存储有用的数据。我们充分利用这一点来跟踪特定于请求的数据，如尝试次数和重试次数。</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="63cd" class="ng lf iq nc b gy nh ni l nj nk">const (<br/>  Attempts int = iota<br/>  Retry<br/>)</span></pre><p id="a05b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">首先，我们需要为上下文指定键。建议使用不冲突的整数键，而不是字符串。Go提供了<code class="fe nl nm nn nc b">iota</code>关键字来增量实现常数，每个常数包含一个惟一的值。这是定义整数键的完美解决方案。</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="e5bc" class="ng lf iq nc b gy nh ni l nj nk">// GetAttemptsFromContext returns the attempts for request<br/>func GetRetryFromContext(r *http.Request) int {<br/>  if retry, ok := r.Context().Value(Retry).(int); ok {<br/>    return retry<br/>  }<br/>  return 0<br/>}</span></pre><p id="2541" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">然后我们就可以像通常使用散列表一样获取值，如下所示。默认返回值可能取决于用例。</p><h1 id="44d1" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">被动健康检查</h1><p id="4c2d" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">被动健康检查允许恢复死的后端或识别它们。我们以固定的时间间隔ping后端以检查它们的状态。</p><p id="a939" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">要ping，我们尝试建立一个TCP连接。如果后端有响应，我们将它标记为活动的。如果你愿意，这个方法可以被修改来调用一个特定的端点，比如<code class="fe nl nm nn nc b">/status</code>。确保连接建立后立即关闭，以减少服务器的额外负载。否则，它将试图保持连接，最终会耗尽资源。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">检查后端是否活动</figcaption></figure><p id="2adb" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">现在我们可以迭代服务器并标记它们的状态，如下所示，</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">执行健康检查</figcaption></figure><p id="ecaa" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">为了定期运行，我们可以在Go中启动一个计时器。一旦创建了计时器，它就允许您使用通道监听事件。</p><p id="0a51" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在上面的代码片段中，<code class="fe nl nm nn nc b">&lt;-t.C</code> channel将每20秒返回一个值。<code class="fe nl nm nn nc b">select</code>允许检测该事件。<code class="fe nl nm nn nc b">select</code>如果没有<code class="fe nl nm nn nc b">default</code> case，等待至少一个case语句被执行。</p><p id="9565" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">最后，在单独的goroutine中运行这个程序。</p><h1 id="a248" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="a796" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">我们在这篇文章中讨论了很多东西。</p><ul class=""><li id="d1c0" class="mh mi iq ke b kf kg kj kk lb mj lc mk ld ml kz mm mn mo mp bi translated">循环选择</li><li id="9047" class="mh mi iq ke b kf mq kj mr lb ms lc mt ld mu kz mm mn mo mp bi translated">从标准库中反转Proxy</li><li id="5538" class="mh mi iq ke b kf mq kj mr lb ms lc mt ld mu kz mm mn mo mp bi translated">互斥体</li><li id="c179" class="mh mi iq ke b kf mq kj mr lb ms lc mt ld mu kz mm mn mo mp bi translated">原子操作</li><li id="38f5" class="mh mi iq ke b kf mq kj mr lb ms lc mt ld mu kz mm mn mo mp bi translated">关闭</li><li id="005b" class="mh mi iq ke b kf mq kj mr lb ms lc mt ld mu kz mm mn mo mp bi translated">复试</li><li id="aa11" class="mh mi iq ke b kf mq kj mr lb ms lc mt ld mu kz mm mn mo mp bi translated">选择操作</li></ul><p id="7a4e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">我们可以做很多事情来改进我们的小型负载平衡器。</p><p id="b16a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">举个例子，</p><ul class=""><li id="887c" class="mh mi iq ke b kf kg kj kk lb mj lc mk ld ml kz mm mn mo mp bi translated">使用堆来挑选活动后端以减少搜索面</li><li id="f074" class="mh mi iq ke b kf mq kj mr lb ms lc mt ld mu kz mm mn mo mp bi translated">统计数据</li><li id="183a" class="mh mi iq ke b kf mq kj mr lb ms lc mt ld mu kz mm mn mo mp bi translated">实施加权循环/最少连接</li><li id="d57f" class="mh mi iq ke b kf mq kj mr lb ms lc mt ld mu kz mm mn mo mp bi translated">添加对配置文件的支持</li></ul><p id="4748" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">等等。</p><p id="6897" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">你可以在这里找到库<a class="ae la" href="https://github.com/kasvith/simplelb/" rel="noopener ugc nofollow" target="_blank">的源代码。</a></p><p id="3d2f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">感谢您阅读这篇文章😄</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="dea5" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated"><em class="kd">原载于2019年11月8日</em><a class="ae la" href="https://kasvith.github.io/posts/lets-create-a-simple-lb-go/" rel="noopener ugc nofollow" target="_blank"><em class="kd">https://kas vith . github . io</em></a><em class="kd">。</em></p></div></div>    
</body>
</html>