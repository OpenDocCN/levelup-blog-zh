<html>
<head>
<title>Parsing JSON in Dart</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Dart中解析JSON</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/parsing-json-in-dart-47833e698879?source=collection_archive---------4-----------------------#2020-03-26">https://levelup.gitconnected.com/parsing-json-in-dart-47833e698879?source=collection_archive---------4-----------------------#2020-03-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d41a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将介绍在Dart中解析JSON的基础知识。最后，您将拥有一个带有列表视图的应用程序，其字段将由从API获取的数据填充。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/0838680d6dc2f503d85d1d3437069da4.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*EHOqXSGO6yiY7lAqX-qkKg.png"/></div></figure><p id="83b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kt translated">第一步:</p><p id="cae6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要获得JSON数据，您需要执行http方法，而要在Flutter中使用http方法，您需要导入一个库，该库支持常见的http方法，如GET、POST、PUT、DELETE等。</p><p id="3d16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">转到您的<em class="lc"> pubspec.yaml </em>文件，在依赖项部分，编写:</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="a2ce" class="li lj iq le b gy lk ll l lm ln">http: ^0.12.0+1</span></pre><p id="6929" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">保存文件，旋舞会自动运行<em class="lc">【旋舞包获取】</em>命令。(至少在Visual Code Studio中是这样)。</p><p id="6794" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kt translated">第二步:</p><p id="09dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导航到您的<em class="lc"> main.dart </em>文件。清除文件中的所有内容。</p><p id="e3ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从导入我们稍后将需要的库开始:</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="da3c" class="li lj iq le b gy lk ll l lm ln">import 'package:flutter/material.dart';</span><span id="4262" class="li lj iq le b gy lo ll l lm ln">import 'package:http/http.dart' as http;</span></pre><p id="2c2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个包对于材料组件是必不可少的。第二个包是我们包含在项目依赖项中的包。</p><p id="7424" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，将应用程序中的入口点定义为:</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="52e5" class="li lj iq le b gy lk ll l lm ln">void main(){runApp(MyApp())};</span></pre><p id="937b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者简而言之，</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="aa18" class="li lj iq le b gy lk ll l lm ln">void main() =&gt; runApp(MyApp());</span></pre><p id="78b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们定义一下<em class="lc"> MyApp </em>类。</p><p id="81b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kt translated">第三步:</p><p id="063e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将在一个类中编写我所有的代码，这个类将有多个状态，所以这个类将是有状态的。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="46d6" class="li lj iq le b gy lk ll l lm ln">class MyApp extends StatefulWidget {<br/>    @override _MyAppState createState() =&gt; _MyAppState();<br/>}</span><span id="631a" class="li lj iq le b gy lo ll l lm ln">class _MyAppState extends State&lt;MyApp&gt; {<br/>    @override Widget build(BuildContext context) {<br/>        return MaterialApp(<br/>            debugShowCheckedModeBanner: false,<br/>            home: Scaffold(<br/>                body: Center(),<br/>            ),<br/>        );<br/>     }<br/>}</span></pre><p id="cdf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kt translated">第四步:</p><p id="e865" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了一个基本的结构，让我们开始使用API来获得结果。为此我将使用<a class="ae lp" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank"> JSONPlaceholder REST API </a>。更确切地说，<a class="ae lp" href="https://jsonplaceholder.typicode.com/photos" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/photos</a>。</p><p id="3224" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">获得的JSON有一个对象列表，每个对象有五个属性:<em class="lc"> albumId </em>、<em class="lc"> id </em>、<em class="lc"> title </em>、<em class="lc"> url </em>和<em class="lc"> thumbnailUrl。现在让我们只关注三个属性:id、title和thumbnailUrl，忽略其余的。</em></p><p id="612e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来让我们用这三个属性和一个构造函数创建一个类。我们还将在<em class="lc">图片</em>类中包含一个<em class="lc"> fromJson() </em>工厂方法，以便于从Json对象创建<em class="lc">图片对象</em>。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="613e" class="li lj iq le b gy lk ll l lm ln">class Picture{<br/>    int id;<br/>    String title, thumbnailUrl;<br/>    Picture({this.id,this.title,this.thumbnailUrl});<br/>    factory Picture.fromJson(Map&lt;String, dynamic&gt; json) {<br/>        return Picture(<br/>            id: json['id'] as int,<br/>            title: json['title'] as String,<br/>            thumbnailUrl: json['thumbnailUrl'] as String,<br/>         );<br/>     }<br/>}</span></pre><p id="2540" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kt translated">第五步:</p><p id="cf56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们来做一个网络请求。</p><p id="7050" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们创建一个函数来获取JSON响应，并适当地将其转换成图片类型的列表。</p><p id="d09b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Flutter有一个非常棒的特性，叫做未来。未来用于表示在未来某个时间可用的潜在值或误差。Future总是伴随着一个数据类型(如Future <int>或Future <string>等。).</string></int></p><p id="ca85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们无法预测我们的请求何时会有结果，我们可能在1秒、10秒或10分钟后得到结果；或者，由于某些错误，我们可能永远得不到结果，相反，我们可能带着错误着陆。这就是为什么我们的函数不会返回一个列表<picture>，而是一个未来的<list>&gt;。</list></picture></p><p id="286c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二件重要的事情是函数将被标记为async，也就是说，它异步地执行它的操作。</p><p id="132f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以基本上，</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="caae" class="li lj iq le b gy lk ll l lm ln">Future&lt;List&lt;Picture&gt;&gt; obtainJson() async{<br/>    final response = await http.get('https://jsonplaceholder.typicode.com/photos'); <strong class="le ir">//1</strong><br/>    String responseBody = response.body; <strong class="le ir">//2</strong><br/>    dynamic jsonObject = json.decode(responseBody); <strong class="le ir">//3</strong><br/>    final convertedJsonObject = jsonObject.cast&lt;Map&lt;String, dynamic&gt;&gt;(); <strong class="le ir">//4</strong><br/>    List&lt;Picture&gt; list = convertedJsonObject.map&lt;Picture&gt;((json) =&gt; Picture.fromJson(json)).toList(); <strong class="le ir">//5</strong><br/>    return list; <strong class="le ir">//6</strong><br/>}</span></pre><ol class=""><li id="3bed" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">在第一行，我们执行了一个http <code class="fe lz ma mb le b">get</code>请求，并将其标记为<code class="fe lz ma mb le b">await</code>，这样在<code class="fe lz ma mb le b">get</code>操作返回之前，函数体中的进一步操作不会被执行。一个http <code class="fe lz ma mb le b">get</code>操作返回一个未来&lt;响应&gt;值。我们已经将该值存储到"<em class="lc"> response" </em>变量中。</li><li id="f5d5" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lv lw lx ly bi translated">接下来，我们将获得这个响应的主体。这个主体是String类型的，所以我们将它存储到String类型的变量"<em class="lc"> responseBody" </em>"中。</li><li id="c9b3" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lv lw lx ly bi translated">接下来，我们将把这个字符串转换成一个JSON对象。json.decode()函数接受string类型的参数，并返回结果json主体。</li><li id="db09" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lv lw lx ly bi translated">现在我们有了一个JSON对象，我们将把它转换成一个String类型的Map，dynamic，也就是Map <string dynamic="">。为此，我们将执行cast方法。结果值存储在变量“<em class="lc"> convertedJsonObject </em>中。</string></li><li id="4ad7" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lv lw lx ly bi translated">现在我们有了一个地图，我们将把它作为参数传递给<em class="lc"> Picture.fromJson </em>，它返回一个Picture对象。所有的值都需要这样做。此外，我们想要一个图片列表，而不仅仅是一张图片。为此我们使用<em class="lc">。toList() </em>。</li><li id="1ef1" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lv lw lx ly bi translated">最后我们会返回这个列表。</li></ol><p id="c222" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kt translated">第六步:</p><p id="4476" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要一个列表来显示结果。因此，我们肯定需要一个ListView小部件，但是在http请求返回任何数据时或之前，我们的ListView可能没有值。或者我们可能会遇到错误，没有列表显示，在这种情况下，我们需要某种视觉输出来表明这一点。</p><p id="9e97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们将使用FutureBuilder。FutureBuilder有两个非常重要的属性，<em class="lc"> future </em>和<em class="lc"> builder </em>(不是很有思想的名字吧？).</p><p id="0d6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">属性future指定了成功或失败的值，而builder提供了切换用例来处理每种可能的结果。</p><p id="6031" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确保在您的<em class="lc"> _MyAppState </em>的<em class="lc"> build(_) </em>函数中定义了这个变量。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="0859" class="li lj iq le b gy lk ll l lm ln">var futureBuilder = new FutureBuilder(<br/>  future: obtainJson(),<br/>  builder: (BuildContext context, AsyncSnapshot snapshot) {<br/>    switch (snapshot.connectionState) {<br/>        case ConnectionState.none:<br/>            return Text('Press button to start.');<br/>        case ConnectionState.active:<br/>            return Text('Awaiting result...');<br/>        case ConnectionState.waiting:<br/>            return Text('Awaiting result...');<br/>        case ConnectionState.done:<br/>            if (snapshot.hasError) <br/>                return Text('Error:${snapshot.error}');<br/>            return listViewBuilder(context, snapshot.data);<br/>        default:<br/>            return Text('Some error occurred');<br/>    }<br/>  }<br/>);</span></pre><p id="ff6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还没有定义<em class="lc"> listViewBuilder(_，_) </em>函数。让我们在下一步做那件事。注意，这个函数将返回一个列表视图。</p><p id="1c71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以不管连接状态如何，变量<em class="lc"> futureBuilder </em>总是有一个小部件值。</p><p id="d733" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kt translated">第七步:</p><p id="d6c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们定义<em class="lc"> listViewBuilder(_，_) </em>函数。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="10ef" class="li lj iq le b gy lk ll l lm ln">Widget listViewBuilder(BuildContext context,List&lt;dynamic&gt; values)<br/>{<br/>  return ListView.builder(<br/>    itemBuilder: (BuildContext context, int index) {<br/>      return ListTile(<br/>        leading: Text((values[index].id).toString()),<br/>        title: Text((values[index].title).toString()),<br/>        subtitle: Text((values[index].thumbnailUrl).toString()),<br/>       );<br/>     }<br/>   );<br/>}</span></pre><p id="1c15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">传递的值只是图片对象。因此，我们可以很容易地访问图片类的值。id，。标题，。thumbnailUrl)。的。toString()将这些属性值转换为字符串。</p><p id="798c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kt translated">第八步:</p><p id="e697" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一步，也许是非常重要的一步，是利用<em class="lc"> futureBuilder </em>变量中的小部件。为此，把你的脚手架变成:</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="8ffb" class="li lj iq le b gy lk ll l lm ln">Scaffold(<br/>  body: Center(<br/>    child: futureBuilder,<br/>  ),<br/>),</span></pre><p id="e423" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，当您运行应用程序时，您应该会在屏幕上看到以下内容:</p><div class="km kn ko kp gt ab cb"><figure class="mh kq mi mj mk ml mm paragraph-image"><img src="../Images/c0319ca510d01629be558a74e948d2c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*-Dsqr6SqlWTsKmgZKYrpOw.png"/></figure><figure class="mh kq mi mj mk ml mm paragraph-image"><img src="../Images/d73cc1d646eddc134ecd83fa54be4921.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*mEnypx6atflQ4UIyCeTBAg.png"/></figure></div><p id="9481" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你可能错过了什么，检查完整的<em class="lc"> main.dart </em>文件:</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="48f2" class="li lj iq le b gy lk ll l lm ln">import 'dart:convert';<br/>import 'package:flutter/material.dart';<br/>import 'package:http/http.dart' as http;</span><span id="9e0f" class="li lj iq le b gy lo ll l lm ln">void main() =&gt; runApp(MyApp());</span><span id="ea43" class="li lj iq le b gy lo ll l lm ln">class MyApp extends StatefulWidget {<br/>  @override _MyAppState createState() =&gt; _MyAppState();<br/>}</span><span id="d4f6" class="li lj iq le b gy lo ll l lm ln">class _MyAppState extends State&lt;MyApp&gt; {<br/>  <br/>  Future&lt;List&lt;Picture&gt;&gt; obtainJson() async {<br/>    final response = await http.get('https://jsonplaceholder.typicode.com/photos');<br/>    String responseBody = response.body;<br/>    dynamic jsonObject = json.decode(responseBody);<br/>    final convertedJsonObject = jsonObject.cast&lt;Map&lt;String, dynamic&gt;&gt;();<br/>    List&lt;Picture&gt; list = convertedJsonObject.map&lt;Picture&gt;((json) =&gt; Picture.fromJson(json)).toList();<br/>    return list;<br/>  }</span><span id="ff27" class="li lj iq le b gy lo ll l lm ln">  Widget listViewBuilder(BuildContext context, List&lt;dynamic&gt; values<br/>  {<br/>    return ListView.builder(<br/>      itemBuilder: (BuildContext context, int index) {<br/>        return ListTile(<br/>          leading: Text((values[index].id).toString()),<br/>          title: Text((values[index].title).toString()),<br/>          subtitle: Text((values[index].thumbnailUrl).toString()),<br/>        );<br/>      }<br/>    );<br/>  }</span><span id="931c" class="li lj iq le b gy lo ll l lm ln">  @override Widget build(BuildContext context) {<br/>    var futureBuilder = new FutureBuilder(<br/>      future: obtainJson(),<br/>      builder: (BuildContext context, AsyncSnapshot snapshot) {<br/>        switch (snapshot.connectionState) {<br/>          case ConnectionState.none:<br/>            return Text('Press button to start.');<br/>          case ConnectionState.active:<br/>            return Text('Awaiting result...');<br/>          case ConnectionState.waiting:<br/>            return Text('Awaiting result...');<br/>          case ConnectionState.done:<br/>            if (snapshot.hasError) <br/>              return Text('Error: ${snapshot.error}');<br/>            return listViewBuilder(context, snapshot.data);<br/>          default:<br/>            return Text('Some error occurred');<br/>           }<br/>         }<br/>       );</span><span id="9b6e" class="li lj iq le b gy lo ll l lm ln">  return MaterialApp(<br/>    debugShowCheckedModeBanner: false,<br/>    home: Scaffold(<br/>      body: Center(<br/>        child: futureBuilder,<br/>      ),<br/>    ),<br/>  );<br/> }<br/>}</span><span id="681c" class="li lj iq le b gy lo ll l lm ln">class Picture {<br/>  int id;<br/>  String title, thumbnailUrl;<br/>  Picture({this.id, this.title, this.thumbnailUrl});<br/>  factory Picture.fromJson(Map&lt;String, dynamic&gt; json) {<br/>    return Picture(<br/>      id: json['id'] as int,<br/>      title: json['title'] as String,<br/>      thumbnailUrl: json['thumbnailUrl'] as String,<br/>    );<br/>  }<br/>}</span></pre></div></div>    
</body>
</html>