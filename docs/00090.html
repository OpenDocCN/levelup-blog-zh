<html>
<head>
<title>Real World Examples of Higher Order Components (HOC) for React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React高阶元件(HOC)的真实示例</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/real-world-examples-of-higher-order-components-hoc-for-react-871f0d8b39d8?source=collection_archive---------0-----------------------#2018-02-25">https://levelup.gitconnected.com/real-world-examples-of-higher-order-components-hoc-for-react-871f0d8b39d8?source=collection_archive---------0-----------------------#2018-02-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5d93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React中最强大的模式之一是高阶组件(HOC)。特设的目的是用额外的功能来增强组件(通常是哑组件)。由于在现实生活的应用中，需要在各种<em class="kl">相似类型的组件中重用相同的功能，所以特设考虑到了可重用性。</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/19405fe5f7be8d83dbc716d366e03e86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AWD4l3oFGPy131GRU6QtVA.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">hoc非常强大，应该在每个项目中使用</figcaption></figure><p id="8b60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个非常常见的功能是切换。这可以用在不同的场景中，例如折叠/展开列表、显示/隐藏组件、突出显示/取消突出显示消息以引起用户的注意等。在本文中，我们将重点讨论两个例子，以更好地理解HOC是如何工作的，以及如何利用它们。</p><p id="c92b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用的两个示例是:</p><ol class=""><li id="d704" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">在段落和输入之间切换。这将允许用户在编辑和查看文章标题之间切换。</li><li id="a5cf" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">在折叠/展开列表之间切换。</li></ol><p id="be06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两种情况都需要相同的切换功能。使用一个特设，我们可以编写一次切换的逻辑，并为相同的组件重用它。</p><p id="bae6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现这个功能，我们只需要保持一个<code class="fe lq lr ls lt b">toggleStatus</code>键的状态，并有一个切换该状态的功能。因此，特设将如下所示:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="7536" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(a)它接受组件作为输入，该组件将是需要增强切换功能的组件。</p><p id="b015" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(b)它初始化一个状态，toggleStatus等于false，并且</p><p id="0e37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(c)声明一个切换函数，该函数将把<code class="fe lq lr ls lt b">toggleStatus</code>从假切换到真，反之亦然。</p><p id="9f98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(HOC将呈现传递的组件，但是它将向其添加两个道具。第一个是<code class="fe lq lr ls lt b">toggle</code>功能，第二个是来自状态的<code class="fe lq lr ls lt b">toggleStatus</code>。注意渲染方法中的<code class="fe lq lr ls lt b">this.props</code>是我们打算以正常方式传递给<code class="fe lq lr ls lt b">PassedComponent</code>的所有道具。</p><p id="8892" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总的来说，特设委员会的工作非常简单。它以正常方式呈现组件，但用<code class="fe lq lr ls lt b">toggleStatus</code>键和一个在真/假值之间切换该键的值的函数来赋予它状态。</p><p id="20ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们看看如何在上面提到的两种情况下使用这个HOC。</p><ol class=""><li id="8c11" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">ViewEditToggleExample:</li></ol><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="c291" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们可以通过以下方式调用这个组件:</p><pre class="kn ko kp kq gt lw lt lx ly aw lz bi"><span id="6add" class="ma mb iq lt b gy mc md l me mf">&lt;ViewEditToggleExample title='My first post' /&gt;</span></pre><p id="87d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先要注意的是，我们导出了带有<code class="fe lq lr ls lt b">ViewEditToggleExample</code>组件作为参数的<code class="fe lq lr ls lt b">withToggle</code>函数。这意味着当我们调用<code class="fe lq lr ls lt b">ViewEditToggleExample</code>时，它将从特设中获得额外的道具。</p><p id="466d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们可以使用这些道具来实现切换功能。正如我们看到的，当<code class="fe lq lr ls lt b">toggleStatus</code>为真时，我们显示一个输入，如果为假，我们显示一个带有标题的<code class="fe lq lr ls lt b">&lt;p&gt;</code>标签。</p><p id="1b97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过将<code class="fe lq lr ls lt b">toggle</code>函数作为按钮的<code class="fe lq lr ls lt b">onClick</code>道具，我们可以在单击按钮时在两种状态之间切换。例如，当更新文章标题的值时，可以使用上面的例子。用户将点击切换按钮并插入文章标题的新值。(注意，出于更新的目的，上面的例子是不完整的。我们需要处理输入的变化，还需要处理新值的提交。这可以通过另一个HOC来实现，因为处理表单提交在整个应用程序中是可重用的。)</p><p id="e37b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.CollapseExpandExample示例</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="c732" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们可以通过以下方式调用这个组件:</p><pre class="kn ko kp kq gt lw lt lx ly aw lz bi"><span id="4b9a" class="ma mb iq lt b gy mc md l me mf">const list = [<br/>  { id: 1, name: 'Eggs' },<br/>  { id: 2, name: 'Bread' },<br/>]</span><span id="c105" class="ma mb iq lt b gy mg md l me mf">&lt;CollapseExpandExample list={list} /&gt;</span></pre><p id="affb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和第一个例子一样，组件通过<code class="fe lq lr ls lt b">toggle</code>函数和<code class="fe lq lr ls lt b">toggleStatus</code>变量得到了增强，我们用它们来实现切换功能，在这个例子中是折叠和展开一个购物清单。</p><p id="0874" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过这两个例子，我们展示了高阶元件的强大功能。我们可以更进一步，向HOC添加更多的逻辑，以初始化<code class="fe lq lr ls lt b">toggleStatus</code>值。如果我们想要初始化扩展的购物清单，这可能会很方便。为了实现这一点，我们需要考虑到特设的第二个参数，如下所示:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="5901" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果我们向<code class="fe lq lr ls lt b">withToggle</code>函数传递第二个参数，我们可以像这样初始化<code class="fe lq lr ls lt b">toggleStatus</code>状态:</p><pre class="kn ko kp kq gt lw lt lx ly aw lz bi"><span id="f6bd" class="ma mb iq lt b gy mc md l me mf">const list = [<br/>  { id: 1, name: 'Eggs' },<br/>  { id: 2, name: 'Bread' },<br/>]</span><span id="4ee5" class="ma mb iq lt b gy mg md l me mf">&lt;CollapseExpandExample list={list} initialToggleStatus={true} /&gt;</span></pre><p id="fd41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一种替代方式来编写HOC，您可能会喜欢:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="a12c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了获得相同的结果，我们需要替换组件的默认导出:</p><pre class="kn ko kp kq gt lw lt lx ly aw lz bi"><span id="96f9" class="ma mb iq lt b gy mc md l me mf">// CollapseExpandExample.js<br/>export default withToggle(CollapseExpandExample)</span></pre><p id="0b8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">收件人:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="3a7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，主要的区别是道具的过滤(如之前评论中提到的)现在是在这个导出函数上完成的。</p></div></div>    
</body>
</html>