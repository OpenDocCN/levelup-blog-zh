<html>
<head>
<title>5 Ways You Can Improve Your React Code and Avoid Common Mistakes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改进React代码和避免常见错误的5种方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-ways-you-can-improve-your-react-code-and-avoid-common-mistakes-9f3d4ee2f525?source=collection_archive---------8-----------------------#2022-06-12">https://levelup.gitconnected.com/5-ways-you-can-improve-your-react-code-and-avoid-common-mistakes-9f3d4ee2f525?source=collection_archive---------8-----------------------#2022-06-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3267" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何解耦组件并更好地利用钩子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5bb74f4874368613e88ea5431d3f0535.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n2QyVDVEE7rDEMb9hWjLvg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@pakata" rel="noopener ugc nofollow" target="_blank"> Pakata Goh </a>在<a class="ae ky" href="https://unsplash.com/photos/EJMTKCZ00I0" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="2f0f" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要写大量的组件</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/86a529137c37c529b4b7d09a7741f80c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uMkTx6pQGRSSK5qFblJwDQ.png"/></div></div></figure><p id="38f9" class="pw-post-body-paragraph md me it mf b mg mh ju mi mj mk jx ml lp mm mn mo lt mp mq mr lx ms mt mu mv im bi translated">想象我们有一个这样的屏幕。我放的5个箭头是不同的数据块，不应该都在一个大文件中。</p><p id="6182" class="pw-post-body-paragraph md me it mf b mg mh ju mi mj mk jx ml lp mm mn mo lt mp mq mr lx ms mt mu mv im bi translated">相反，每个数据块都应该是一个单独的组件，我们应该有一个父组件，它将适当的属性传递给子组件，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e480" class="pw-post-body-paragraph md me it mf b mg mh ju mi mj mk jx ml lp mm mn mo lt mp mq mr lx ms mt mu mv im bi translated">(这只是为了演示，不会渲染任何东西)。</p><p id="6196" class="pw-post-body-paragraph md me it mf b mg mh ju mi mj mk jx ml lp mm mn mo lt mp mq mr lx ms mt mu mv im bi translated">但这个想法是，屏幕上的每一个可以真正成为独立软件并具有不同行为的部分都应该是一个独立的组件，这将防止你拥有一个难以通读的庞大组件。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="4fa3" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">避免嵌套组件</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6440" class="pw-post-body-paragraph md me it mf b mg mh ju mi mj mk jx ml lp mm mn mo lt mp mq mr lx ms mt mu mv im bi translated">上面的代码是合法的，并且可以工作，但是我们已经把子组件放到了父组件中，我们不需要使用props来调用onClick函数。</p><p id="1de8" class="pw-post-body-paragraph md me it mf b mg mh ju mi mj mk jx ml lp mm mn mo lt mp mq mr lx ms mt mu mv im bi translated">这样做的问题是，每次重新呈现父组件时，它也会重新定义子组件，这可能会导致一些不必要的行为和奇怪的性能。</p><p id="a22c" class="pw-post-body-paragraph md me it mf b mg mh ju mi mj mk jx ml lp mm mn mo lt mp mq mr lx ms mt mu mv im bi translated">解决这个问题的方法可以是完全删除子组件，或者从父组件中提取子组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="6228" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">要避免的常见状态错误</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="11c3" class="pw-post-body-paragraph md me it mf b mg mh ju mi mj mk jx ml lp mm mn mo lt mp mq mr lx ms mt mu mv im bi translated">为了保持连续性，让我们继续同一个例子。看着这段代码，你可能会认为当我们单击按钮时，计数会增加2，但实际上它只会增加1。</p><p id="4a96" class="pw-post-body-paragraph md me it mf b mg mh ju mi mj mk jx ml lp mm mn mo lt mp mq mr lx ms mt mu mv im bi translated">这是因为setState是异步的，当我们向两个setCounts传递相同的值时，反过来我们的计数只增加1。</p><p id="d8eb" class="pw-post-body-paragraph md me it mf b mg mh ju mi mj mk jx ml lp mm mn mo lt mp mq mr lx ms mt mu mv im bi translated">解决这个问题非常简单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6295" class="pw-post-body-paragraph md me it mf b mg mh ju mi mj mk jx ml lp mm mn mo lt mp mq mr lx ms mt mu mv im bi translated">我们可以将一个函数传递给setCount，它将始终获取当前值，因此即使两个调用是异步的，先启动的调用将增加该值，第二个调用可以使用更新后的值进一步增加我们的计数。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="11da" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">开始使用useMemo</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3623" class="pw-post-body-paragraph md me it mf b mg mh ju mi mj mk jx ml lp mm mn mo lt mp mq mr lx ms mt mu mv im bi translated">这样做的问题是，在计算函数运行后，我们更新setUser状态，例如，这将重新呈现整个组件，迫使invoiceCalculations函数再次运行，如果它是一个具有大量逻辑的大型函数，可能会占用很少的资源。更不用说我们希望它只在发票状态发生变化时被调用，而不是其他情况。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8806" class="pw-post-body-paragraph md me it mf b mg mh ju mi mj mk jx ml lp mm mn mo lt mp mq mr lx ms mt mu mv im bi translated">然而，如果我们使用useMemo钩子，它将记住invoiceInfo的最后一个值，并且只有在依赖关系(invoice)被更新时，它才会再次运行计算。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="96e8" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要给你的孩子传递一打道具</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a42d" class="pw-post-body-paragraph md me it mf b mg mh ju mi mj mk jx ml lp mm mn mo lt mp mq mr lx ms mt mu mv im bi translated">如果你的用户对象有很多属性，你真的不想把它们一个一个传递给你的子组件。而是将用户作为一个整体传递。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><div class="kj kk kl km gt my"><a href="https://medium.com/@ivan.zstoev/membership" rel="noopener follow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">通过我的推荐链接加入Medium-Ivan Stoev</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">medium.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm ks my"/></div></div></a></div></div></div>    
</body>
</html>