<html>
<head>
<title>What is a Monotonic Stack?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是单调堆栈？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-is-a-monotonic-stack-f10d79609c45?source=collection_archive---------4-----------------------#2022-08-23">https://levelup.gitconnected.com/what-is-a-monotonic-stack-f10d79609c45?source=collection_archive---------4-----------------------#2022-08-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/32396933c5c360f78a9fe36e46e51591.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NMqM7i_kHCvwL2Z7"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@maltehelmhold?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马尔特·赫尔姆霍尔德</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="659d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">单调堆栈是堆栈数据结构的一种变体，其中的元素总是以特定的顺序排序。在单调堆栈中，元素必须都是单调递增或单调递减的。单调堆栈经常出现在编码访谈中，使它们成为受访者理解的一个重要概念。在本文中，我们将讨论什么是单调堆栈，它们是如何工作的，以及它们的一些应用。</p><h2 id="eb96" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">用例</h2><p id="600c" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">单调堆栈通常用于跟踪数据集中的最大或最小元素。例如，假设你有一个整数数组，你想跟踪数组中每个索引处的最大整数。您可以为此使用单调堆栈。堆栈总是按降序排序，堆栈的顶部元素将是数组中直到该索引的最大整数。</p><p id="52f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您想要根据某种顺序操作数据时，单调堆栈也很有用。例如，如果您想确保数组总是按升序排序，您可以使用单调堆栈来实现这一点。</p><h2 id="1188" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">一个著名的例子</h2><p id="f9df" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">一个著名的单调堆栈面试问题是日落景观问题。在这个问题中，给你一个建筑物阵列，每个建筑物用它的高度来表示。这些建筑相互成一条直线，这意味着如果一座建筑比另一座建筑高，它们将被阻挡，看不到日落。太阳向右侧落下。你的目标是找到所有能看到日落的建筑。</p><p id="a026" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一组建筑物及其高度的示例:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="f476" class="le lf it mh b gy ml mm l mn mo">let buildings = [18, 14, 13, 16, 12];</span></pre><p id="48c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于太阳向右侧落下，我们需要确定哪些建筑物能够观看日落。从视觉上，我们可以看到18能够看到所有其他建筑。当我们检查14时，我们看到它被高度为16的4号建筑挡住了。继续检查我们的建筑物将导致确定只有在指数0，3和4的建筑物能看见日落。</p><p id="d00d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然从概念上和视觉上确定答案应该是什么很容易，但可能很难找出如何编码一个算法来有效地解决这个问题。这就是单调堆栈的用武之地。我们可以利用一个递减的单调堆栈，它允许我们弹出任何看不到日落的建筑。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mp"><img src="../Images/f489df7e325864080d04fe54aa5f732e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RhaKBFFqWmcZGIDO"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@ameliabartlett?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿米莉娅·巴特利特</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h2 id="63bd" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">利用单调堆栈</h2><p id="c5a7" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">下面的代码片段演示了我们如何使用单调堆栈来解决日落问题。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="c14d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们遍历建筑数组时，我们首先检查当前建筑是否比堆栈顶部的建筑高。如果是，我们知道当前建筑挡住了栈顶的建筑。因此，我们可以移除堆栈顶部的建筑。我们继续这样做，直到我们找到一个比当前建筑更高的建筑。此时，我们知道堆栈是单调递减的，这意味着它们都可以看到日落。</p><p id="8089" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在遍历整个数组后，我们的堆栈将包含所有可以看到日落的建筑。在本例中，我们的最终堆栈将是[0，3，4]，这是可以看到日落的建筑物的索引。</p><h2 id="6a1c" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">时间复杂度</h2><p id="c056" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">当涉及到我们算法的时间复杂度时，单调堆栈提供了很大的好处。在上面的例子中，我们的时间复杂度是O(n ),因为我们只遍历了一次建筑数组。单调堆栈允许我们实现这种时间复杂度，因为我们能够有效地移除任何无法在一次通过中看到日落的建筑物。</p><h2 id="7c72" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">结论</h2><p id="11c4" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">当我们需要维护数据的某种顺序时，单调堆栈是一个很好的工具。它们允许我们有效地删除任何不符合我们标准的元素，并可用于解决时间复杂的问题，否则很难实现。</p><p id="3c59" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望这篇文章能教会你一些东西。祝你的编码面试好运！</p></div></div>    
</body>
</html>