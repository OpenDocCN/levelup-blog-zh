<html>
<head>
<title>Introduction to Physics in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Unity中的物理学导论</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-physics-in-unity-1113ff12397b?source=collection_archive---------7-----------------------#2021-04-04">https://levelup.gitconnected.com/introduction-to-physics-in-unity-1113ff12397b?source=collection_archive---------7-----------------------#2021-04-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f00c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Unity中的物理由内置的<strong class="jp ir"> </strong>物理引擎处理。Unity中内置的物理引擎处理游戏对象交互的物理过程以及各种效果，如重力、加速度、碰撞等。</p><h1 id="8fe3" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">碰撞机</h1><p id="4b28" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">如果你想让游戏对象检测到与场景中其他游戏对象的碰撞，就需要一个碰撞器。但是如果你想让带有碰撞器的游戏对象受到物理影响，或者想知道碰撞如何影响其他游戏对象，你需要一个刚体。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/b6e2a730bec1f8a038d78dffce375c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*ehCsVHfK9ApRyXtx3C8dmA.png"/></div></figure><h2 id="7336" class="lw km iq bd kn lx ly dn kr lz ma dp kv jy mb mc kz kc md me ld kg mf mg lh mh bi translated">是触发器</h2><p id="3ec6" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">当启用Is Trigger时，它会将碰撞器变成一个触发体，允许其他游戏对象通过它，并且当刚体进入、停留或退出触发体时，它会发送一个OnTriggerEnter、OnTriggerStay或OnTriggerExit消息，而不是记录碰撞。</p><h2 id="65b8" class="lw km iq bd kn lx ly dn kr lz ma dp kv jy mb mc kz kc md me ld kg mf mg lh mh bi translated">材料</h2><p id="f2c2" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">如果你想让对撞机有任何独特的物理材料。一种物理材质允许你调整碰撞器的摩擦力和弹力。</p><h1 id="ea70" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">刚体</h1><p id="6eac" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">Unity中的物理引擎只知道，如果刚体组件被添加到游戏对象中，对象就意味着被物理作用，如果没有刚体组件，引擎就认为游戏对象是静态和不动的。当静态游戏对象(没有刚体)移动时，它会导致物理引擎重新运行计算，以优化场景中的静态对象。因此，确保在任何将要移动的游戏对象上有一个刚体，以使Unity尽可能最佳地运行。在OnCollision或OnTrigger事件期间，至少在两个相互作用的对象之一上也需要刚体。刚体组件有许多属性可以调整，以使游戏对象对力和碰撞做出不同的反应。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/39ca8726677302e10062ea94e46ba3a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*l2QfDvGl7Br2hqpiebgP3Q.png"/></div></figure><h2 id="dc35" class="lw km iq bd kn lx ly dn kr lz ma dp kv jy mb mc kz kc md me ld kg mf mg lh mh bi translated">团</h2><p id="80fa" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">物理引擎测量的游戏物体上刚体的质量，以千克为单位。就像在现实生活中，质量较大的游戏对象对质量较小的游戏对象有更大的反应。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mj"><img src="../Images/e1af053c105b2efd3eed966dda645d30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*DSwOPTrpFZKjk3d6B9XPrA.gif"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">蓝色球体的质量更大</figcaption></figure><h2 id="96f8" class="lw km iq bd kn lx ly dn kr lz ma dp kv jy mb mc kz kc md me ld kg mf mg lh mh bi translated">拖</h2><p id="4e3b" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">拖动属性是游戏对象在场景中移动时受到的阻力大小。如果阻力大于0，它将最终导致游戏对象停止，除非施加恒定的力，在这种情况下，阻力将阻碍其运动并使其减速(即下落更慢)。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ms"><img src="../Images/2c29389a79afa2967402a2092b51b154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*LCoafillFnkFYydrwKf_qA.gif"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">红色球体的阻力大于0</figcaption></figure><h2 id="19f5" class="lw km iq bd kn lx ly dn kr lz ma dp kv jy mb mc kz kc md me ld kg mf mg lh mh bi translated">角阻力</h2><p id="ce0b" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">角阻力的工作方式非常类似于阻力，但只对游戏对象的旋转速度施加阻力，这在大多数情况下类似于阻力。当游戏物体移动而不旋转时，就像垂直下落一样。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ms"><img src="../Images/5db28b97296e68990f880ee4fd131993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*NzqoR8VG2-YnW5aVlkT-7Q.gif"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">黄色表示阻力= 1，红色表示角阻力= 1</figcaption></figure><h2 id="dd12" class="lw km iq bd kn lx ly dn kr lz ma dp kv jy mb mc kz kc md me ld kg mf mg lh mh bi translated">利用重力</h2><p id="384d" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">当打开时，游戏对象将被Unity设置中定义的重力所吸引。默认设置是y轴上的-9.81，可以在“物理”下的项目设置中更改。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mt"><img src="../Images/8b9664fc5f621a8681d97493e4c56c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NXyXryzCuvCdRcuEmw5gvA.png"/></div></div></figure><h2 id="da58" class="lw km iq bd kn lx ly dn kr lz ma dp kv jy mb mc kz kc md me ld kg mf mg lh mh bi translated">是运动学的</h2><p id="9e7a" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">运动学控制物理是否影响游戏对象。关闭时，游戏对象受物理影响，打开时，游戏对象只能通过代码或动画改变变换来移动。如果游戏对象大部分时间是静态的，但在动画或脚本中会移动，那么请确保添加一个刚体并启用“运动学”,以便引擎知道对象可能会移动，并且在移动时不会浪费资源。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ms"><img src="../Images/385a6286d5db3f04f0f5b62ce98cb86c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*M2tLnbbgb8J0zqX3dvhPoA.gif"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">蓝色球体已经开启</figcaption></figure><h2 id="f045" class="lw km iq bd kn lx ly dn kr lz ma dp kv jy mb mc kz kc md me ld kg mf mg lh mh bi translated">插入</h2><p id="dfca" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">由于Unity中的物理是在FixedUpdate中处理的，它每0.02秒或每秒50次运行一次，因此Interpolate可以帮助修复固定帧速率可能导致的任何抖动运动。插值会占用大量资源，所以除非你发现问题，否则应该保留默认值。插值的三个设置是无、插值和外推。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mu"><img src="../Images/e1a24a51206dfe0be981ad635acc51dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*r2Pt0uRtWkdSsWZMd35Kew.png"/></div></div></figure><p id="379e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">无:</strong>关闭，默认情况下，不使用额外的资源。</p><p id="01dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">插值:</strong>使用之前的帧来平滑移动，并且是启用的资源最少的。</p><p id="3d28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">外推:</strong>使用下一帧来平滑运动，非常耗费资源。</p><h2 id="09cb" class="lw km iq bd kn lx ly dn kr lz ma dp kv jy mb mc kz kc md me ld kg mf mg lh mh bi translated">冲突检出</h2><p id="f993" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">是刚体的碰撞检测模式，它有4个设置，离散，连续，连续动态和连续推测。</p><p id="e9bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mv">注意:</em> </strong> <em class="mv">连续碰撞检测仅支持带有球体、胶囊或盒子碰撞器的刚体</em></p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/45606dc67d9e9d3cb961f2bb0f373394.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*am-SDbwYaKm48900z7VSgA.png"/></div></figure><p id="c5ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">离散:</strong>这是碰撞检测的默认模式。这是资源最少的冲突检测方法，并且在大多数情况下足以处理检测需求。你唯一需要改变的是当你遇到快速移动的游戏物体的碰撞问题时。</p><p id="5039" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">连续:</strong>当处理与静态(无刚体)游戏对象的高速碰撞时，使用该模式。这对资源是非常沉重的。</p><p id="ab76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">连续动态:</strong>此模式几乎与连续相同。不同之处在于，这适用于静态和动态(带有刚体)游戏对象。这也是非常耗费资源的。</p><p id="9885" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">连续推测:</strong>这种模式做连续动态所做的事情，但通常以准确性为代价，在资源使用上更便宜。也可以用于运动游戏对象。</p><h2 id="60d3" class="lw km iq bd kn lx ly dn kr lz ma dp kv jy mb mc kz kc md me ld kg mf mg lh mh bi translated">限制</h2><p id="55db" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">约束阻止游戏对象在选定的x、y或z轴或物理轴上移动或旋转，但仍然可以通过脚本或动画移动或旋转。</p></div></div>    
</body>
</html>