<html>
<head>
<title>How to Divide Our Apps into Manageable Chunks — MVC Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MVC解释了如何将我们的应用分成易于管理的块</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-divide-our-apps-into-manageable-chunks-af37e3eeb294?source=collection_archive---------11-----------------------#2020-06-17">https://levelup.gitconnected.com/how-to-divide-our-apps-into-manageable-chunks-af37e3eeb294?source=collection_archive---------11-----------------------#2020-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7f6eede4e530258cdeb8b15311d5a399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8FZDNR9k3etSR_jS"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">马库斯·斯皮斯克在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="eac9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编写用户使用的应用很难。因此，我们必须将它们分成小块，以便每个部分都易于管理。</p><p id="5e3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们将看看我们可以做到这一点的方法。</p><h1 id="271a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将系统分成模块</h1><p id="793d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们需要将我们的软件系统划分成模块，这样它们只能做一件事情，并且模块之间的耦合很小。</p><p id="28b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，维护将变得容易，我们不必担心我们的更改会破坏应用程序的另一部分。</p><h1 id="8e5d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">发布/订阅</h1><p id="78ff" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不应该通过一个单一的程序来推动所有的事件。这违反了对象封装。一个例程非常了解许多对象之间的交互。</p><p id="f981" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">耦合也因此而增加。发出事件的对象必须知道这些事件。</p><p id="b54a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可能不得不违反“不要重复自己”的原则来绕过紧耦合。此外，没有正交性，因为紧耦合意味着系统一部分的一个变化会影响另一部分。</p><p id="4b37" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用发布和订阅模式将模型从模型的视图中分离出来。这样，我们只需发布一个事件，任何想要收听该事件的实体都可以收听它。</p><p id="c137" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这比让每个实体彼此紧密耦合要好得多。</p><p id="67c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过实现事件总线来实现这一点，事件总线在一个位置传递事件，任何发送和监听事件的东西都可以监听同一个位置。</p><h1 id="e9e0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">模型-视图-控制器</h1><p id="342f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">模型-视图-控制器(MVC)模式是一种简单的设计模式，它将数据层和表示层分开。</p><p id="3dd0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">模型层有业务逻辑和数据操作逻辑。视图显示需要显示的任何数据，但不进行任何数据操作。</p><p id="71f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">控制器充当模型和视图之间的桥梁。</p><p id="9ef6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个很好的设计，因为视图与任何业务逻辑都是分离的，这正是我们想要的，因为我们不希望在不同的位置出现重复的数据。还有，我们不希望不同的地方有做相似或相同事情的逻辑。</p><h1 id="4be8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从模型中分离视图</h1><p id="688f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">将视图从模型中分离出来减少了表示逻辑和业务逻辑之间的耦合。这比在不同的地方放不同的东西灵活多了。</p><p id="588c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们必须从数据库中获取数据，然后在程序中以图表的形式显示出来，那么我们就编写一个程序来获取数据并显示出来。数据位于从数据库获取数据的包装类中，视图只显示从数据库中检索的数据。</p><h1 id="f2de" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">超越图形用户界面</h1><p id="3d3f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">MVC可以在GUI之外使用。这是一种通用的编程技术。视图是对模型的解释，它不一定是图形化的。</p><p id="051a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">控制器只是一个协调机制，它不必来自任何输入设备。</p><p id="c5ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们把MVC的概念推广到任何程序，那么这个模式仍然做着和图形程序一样的事情。</p><p id="1a8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">视图订阅来自模型的变更和来自控制器的逻辑事件。</p><p id="3631" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">控制器是控制视图的方式。它从模型和视图中发布事件。</p><p id="e17c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，对于REST API，视图是JSON响应。控制器是获取这些查询参数、请求体和头并将它们传递给模型的代码。它还将JSON响应传递给视图。</p><p id="d9a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无论视图中呈现何种类型的响应，模型都以相同的方式进行数据操作。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/4375649cd9b0056df6e3aee6bd2efff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f54n7yni9Mzeah8-"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@simplicity?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Marija Zaric </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="73e3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">黑板</h1><p id="3439" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">除了MVC模式之外，还有黑板模式，在这种模式下，任何实体都不互相认识。</p><p id="b1a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有发出事件的模块和订阅发出事件的模块，但是它们都不知道彼此的存在。黑板是所有模块读取的状态的全局位置。</p><p id="7e4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">知识源是将状态从黑板转换成所需表示的模块。控制组件选择、配置和运行模块。</p><p id="3d02" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种模式使得动态组合异构模块变得容易。由于没有太多的耦合，这些模块是可重用的，并且易于更改。</p><p id="6ddb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这使得系统更加健壮。</p><h1 id="672b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="fbd3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">MVC和blackboard模式是减少我们代码中的耦合的模式，它们都涉及到在不同的模块之间传递数据，而每个模块不需要太多关于另一个模块的知识。</p></div></div>    
</body>
</html>