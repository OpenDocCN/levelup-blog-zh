<html>
<head>
<title>Learning JavaScript: The Stack Data Structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习JavaScript:堆栈数据结构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-javascript-the-stack-data-structure-9f8a10346f6a?source=collection_archive---------23-----------------------#2021-01-25">https://levelup.gitconnected.com/learning-javascript-the-stack-data-structure-9f8a10346f6a?source=collection_archive---------23-----------------------#2021-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8edca36ac7b93a4d3aa30e35659eaf0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nHyxsSg4-g4lsQ3D"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">伊瓦·拉乔维奇在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="90fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">堆栈数据结构在计算机科学中有多种用途。在编程语言中，函数调用是通过使用堆栈来控制何时调用函数来实现的。在应用程序中，堆栈用于计算数字表达式，并可用于在不同基数之间转换数字，例如从十进制到二进制或从二进制到十六进制。</p><p id="68f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">堆栈也不太难实现，因为堆栈可以执行的操作数量有限。三个主要的操作符是:1)把一个新的项目推到堆栈上；2)从堆栈中弹出顶部项目；以及3)检查堆栈顶部的项目。您还可以实现一些其他的实用函数，但是要正确使用堆栈，您所需要的就是这三个操作。</p><p id="24e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我将向您展示如何用JavaScript构建一个stack类，并使用它来解决几个有趣的编程问题。</p><p id="2431" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我在本文中使用的是SpiderMonkey JavaScript shell，但是您应该能够使用其他JavaScript实现，而无需对我的代码进行太多更改。</p><h1 id="601d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">描述堆栈</h1><p id="6b7a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">堆栈是一种数据结构，其中数据被添加到堆栈的顶部，一次一个数据项，并且数据仅从顶部从堆栈中移除。现实生活中有很多栈的例子。</p><p id="2f20" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个例子是装入打印机的纸叠。当打印机想要打印一页时，它从纸堆的顶部取出一张纸，然后在上面打印。如果您想在有信头的纸上打印，或者打印一些尚未装入打印机的纸，您必须将那张纸放在纸叠的顶部。</p><p id="9163" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想从纸堆中取出纸张，您必须从顶部取出，因为您无法接触到顶部纸张下面的纸张。最后，你能在纸堆中看到的唯一一张纸是最上面的那张，因为它覆盖了所有其他的纸。</p><p id="ef44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个真实的堆栈示例是自助餐厅的托盘。当顾客想要一个托盘时，他们必须从堆叠的顶部拿取。如果洗碗工想增加一些托盘，他或她必须将干净的托盘放在托盘堆的顶部。如果您想查看堆叠中的托盘，您只能查看顶部的托盘，因为它覆盖了所有其他托盘。</p><p id="76d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">事实证明，这种设计对于许多基于计算机的应用程序也是有用的，其中一些我在上面提到过。</p><h1 id="8e1e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">堆栈类设计</h1><p id="98d7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我的堆栈实现使用JavaScript类，而不仅仅是一个对象。我喜欢JavaScript类的抽象，如果您选择将实现转移到另一种语言，如C++或Java，JavaScript设计将比使用JavaScript原型实现堆栈更有用。如果您不熟悉JavaScript类，这里的<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/learning-javascript-an-introduction-to-classes-part-1-d4c07b59ee3c">是我写的一篇文章，详细讨论了如何创建和使用JavaScript类。</a></p><p id="cb42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">设计高效堆栈类的关键是使用正确的底层数据结构来存储堆栈项目。我将使用一个数组作为我的stack类的数据存储。JavaScript数组有几个很好的内置方法，使得使用它们很容易。</p><p id="5a47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">堆栈操作实现为可从<code class="fe mh mi mj mk b">Stack</code>实例调用的类方法(函数)。除了<code class="fe mh mi mj mk b">push</code>、<code class="fe mh mi mj mk b">pop</code>和<code class="fe mh mi mj mk b">top</code>之外，我还将实现一个<code class="fe mh mi mj mk b">size</code>方法来确定堆栈中元素的数量，一个<code class="fe mh mi mj mk b">empty</code>方法来测试堆栈实例中是否有数据，一个<code class="fe mh mi mj mk b">clear </code>方法来删除堆栈中的所有内容。</p><p id="498b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于堆栈的操作数量如此之少，我们已经准备好进入堆栈类实现了。</p><h1 id="f859" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">堆栈类实现</h1><p id="2dcf" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">正如堆栈操作列表很短一样，实现一个<code class="fe mh mi mj mk b">Stack</code>类所需的代码也很短。具有讽刺意味的是，要实现的前两个方法<code class="fe mh mi mj mk b">push</code>和<code class="fe mh mi mj mk b">pop</code>具有相同名称的函数，用于JavaScript数组的相同目的。下面是<code class="fe mh mi mj mk b">Stack</code>类的定义:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ccb0" class="mt lf it mk b gy mu mv l mw mx">class Stack {<br/>  constructor() { <br/>    this.dataStore = []<br/>  }</span><span id="9266" class="mt lf it mk b gy my mv l mw mx">  push(element) {<br/>    this.dataStore.push(element)<br/>  }</span><span id="d18f" class="mt lf it mk b gy my mv l mw mx">  pop() {<br/>    this.dataStore.pop()<br/>  }</span><span id="7a9f" class="mt lf it mk b gy my mv l mw mx">  top() {<br/>    return this.dataStore[this.dataStore.length-1]<br/>  }</span><span id="8a5a" class="mt lf it mk b gy my mv l mw mx">  size() {<br/>    return this.dataStore.length;<br/>  }</span><span id="a190" class="mt lf it mk b gy my mv l mw mx">  empty() {<br/>    if (this.dataStore.length == 0) {<br/>      return true;<br/>    }<br/>    return false;<br/>  }</span><span id="8768" class="mt lf it mk b gy my mv l mw mx">  clear() {<br/>    if (this.dataStore.length == 0) {<br/>      return;<br/>    }    <br/>    while (this.dataStore.length &gt; 0) {<br/>      this.dataStore.pop();<br/>    }<br/>  }<br/>}</span></pre><p id="bed1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">构造函数方法初始化底层数据存储结构，即<code class="fe mh mi mj mk b">dataStore</code>数组。</p><p id="1e67" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">堆栈的顶部总是底层数组的最后一个元素，所以我们使用公式从长度中减去1来返回顶部的元素。</p><p id="6cd5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数组中元素的数量是堆栈的大小，所以我们返回数组的长度作为存储的堆栈元素的数量。</p><p id="b011" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果堆栈中有0个元素(长度等于0)，那么它是空的。</p><p id="ae70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过弹出数组中的所有元素来清除堆栈。</p><h1 id="9819" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">堆栈测试程序</h1><p id="c692" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在我演示使用堆栈来解决一些有用的问题之前，我将编写一个快速程序来测试所有的类方法。下面是测试程序:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0760" class="mt lf it mk b gy mu mv l mw mx">let myStack = new Stack();<br/>myStack.push("Mike");<br/>myStack.push("Terri");<br/>myStack.push("Meredith");<br/>putstr("Top of stack: ");<br/>print(myStack.top());<br/>putstr("Number of elements on the stack: ");<br/>print(myStack.size());<br/>if (!myStack.empty()) {<br/>  myStack.clear();<br/>}<br/>putstr("Top of supposedly empty stack: ");<br/>print(myStack.top());<br/>myStack.clear();<br/>putstr("Number of elements on the stack: ");<br/>print(myStack.size());</span></pre><p id="5850" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是程序的输出:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c4b2" class="mt lf it mk b gy mu mv l mw mx">Top of stack: Meredith<br/>Number of elements on the stack: 3<br/>Top of supposedly empty stack: undefined<br/>Number of elements on the stack: 0</span></pre><p id="2024" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我已经完成了Stack类的演示，让我们继续使用这个类来解决一些问题。</p><h1 id="d50e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将十进制数转换为二进制数</h1><p id="1885" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">堆栈可用于将数字从一种基数转换到另一种基数。我将通过编写一个将十进制数(基数为10)转换为二进制数(基数为2)的程序来演示这一点。该算法的工作原理是，首先获取基数进行转换，然后将该值推送到堆栈上。然后你用这个数除以基数，这个商就是新的基数。</p><p id="2583" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要获取转换后的数字，可以通过弹出堆栈来构建一个字符串，直到堆栈中不再有数字。</p><p id="1f1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是使用<code class="fe mh mi mj mk b">Stack</code>类将十进制数转换成二进制数的程序:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a2e0" class="mt lf it mk b gy mu mv l mw mx">let digits = new Stack();<br/>const base = 2;<br/>putstr("Enter the base number: ");<br/>let decimal = readline();<br/>putstr("Decimal number: ");<br/>print(decimal);<br/>while (decimal != 0) {<br/>  let digit = decimal % base;<br/>  digits.push(digit);<br/>  decimal = parseInt(decimal / base);<br/>}<br/>let converted = "";<br/>while (!digits.empty()) {<br/>  converted += digits.top();<br/>  digits.pop();<br/>}<br/>putstr("Binary number: ");<br/>print(converted);</span></pre><p id="d458" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是该程序几次运行的输出:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a235" class="mt lf it mk b gy mu mv l mw mx">C:\js&gt;js stack.js<br/>Enter the base number: 123<br/>Decimal number: 123<br/>Binary number: 1111011</span><span id="4909" class="mt lf it mk b gy my mv l mw mx">C:\js&gt;js stack.js<br/>Enter the base number: 1024<br/>Decimal number: 1024<br/>Binary number: 10000000000</span></pre><h1 id="8f7f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">寻找回文</h1><p id="7332" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">对于我使用堆栈的第二个例子，我将演示如何使用堆栈来确定一个单词是否是回文。回文是一个向前和向后拼写相同的单词。比如racecar是回文；鲍勃是一个回文；你好不是回文。</p><p id="b01f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我最喜欢的回文实际上是这样一句话，当你去掉空格后，它就变成了回文:一个人计划修建巴拿马运河。</p><p id="f4ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能很快就能看到如何使用堆栈来确定一个单词是否是回文。一个程序遍历一个字符串，提取每个字母并把它推到一个堆栈上。当你用完了所有的字母时，遍历堆栈，将每个字母弹出到一个新的字符串中。如果原始字符串和从堆栈中构建的字符串相同，则该单词是一个回文。</p><p id="8064" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个程序，它使用堆栈来确定一个单词是否是回文:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8c1c" class="mt lf it mk b gy mu mv l mw mx">let letters = new Stack();<br/>putstr("Enter a word: ");<br/>let originWord = readline();<br/>putstr("Word: ");<br/>print(originWord);<br/>let stop = originWord.length;<br/>for (let i = 0; i &lt; stop; i++) {<br/>  letters.push(originWord[i]);<br/>}<br/>let reversed = "";<br/>while (!letters.empty()) {<br/>  reversed += letters.top();<br/>  letters.pop();<br/>}<br/>putstr("Reversed word: ");<br/>print(reversed);<br/>if (reversed == originWord) {<br/>  print(originWord + " is a palindrome.");<br/>}<br/>else {<br/>  print(originWord + " is not a palindrome.");<br/>}</span></pre><p id="45c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是该程序几次运行的输出:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e8f7" class="mt lf it mk b gy mu mv l mw mx">C:\js&gt;js stack.js<br/>Enter a word: racecar<br/>Word: racecar<br/>Reversed word: racecar<br/>racecar is a palindrome.</span><span id="e342" class="mt lf it mk b gy my mv l mw mx">C:\js&gt;js stack.js<br/>Enter a word: hello<br/>Word: hello<br/>Reversed word: olleh<br/>hello is not a palindrome.</span><span id="24c6" class="mt lf it mk b gy my mv l mw mx">C:\js&gt;js stack.js<br/>Enter a word: amanaplanacanalpanama<br/>Word: amanaplanacanalpanama<br/>Reversed word: amanaplanacanalpanama<br/>amanaplanacanalpanama is a palindrome.</span></pre><p id="94be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我已经为您提供了两个如何使用堆栈解决问题的示例。如果你对更多涉及堆栈的问题感兴趣，可以在网上做一些搜索，探索如何使用堆栈将中缀算术方程转换为后缀方程，或者如何使用堆栈平衡语句中的符号，比如算术中使用的括号。</p><p id="893e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请回复这篇文章或给我发邮件，告诉我您的意见和建议。</p></div></div>    
</body>
</html>