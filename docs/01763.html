<html>
<head>
<title>Why You Should Be Using TypeScript + GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么应该使用TypeScript + GraphQL</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-you-should-be-using-typescript-graphql-5d87633f5363?source=collection_archive---------3-----------------------#2020-01-28">https://levelup.gitconnected.com/why-you-should-be-using-typescript-graphql-5d87633f5363?source=collection_archive---------3-----------------------#2020-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e4b9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用这种强大组合的学习成果。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/73f8e3d8d28fdc5d34fa28e58e5aeef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_pXr0HC0Vt5OhByD_VRxtg.jpeg"/></div></div></figure><h1 id="4cd1" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated"><strong class="ak">简介</strong></h1><p id="ee41" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">今天我要写的是关于<a class="ae mi" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">打字稿</a>和<a class="ae mi" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank">图表。我将简要介绍这些技术，然后直接进入学习成果。</a></p><p id="7fd9" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我已经使用这个堆栈将近两年了。我首先从GraphQL开始，这启发了我钻研TypeScript。还有很多东西需要学习，技术在不断发展，人们的兴趣在迅速增长，尤其是在企业领域，每天都有新的应用程序发布。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/241ea80db253718513ea7aab1ca64279.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*FXsUE6uld6Z0P9BgF8wj4w.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">GraphQL + TypeScript</figcaption></figure><h1 id="3a71" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated"><strong class="ak">什么是GraphQL？</strong></h1><p id="307c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">有许多介绍GraphQL的文章。如果你问10个不同的人GraphQL是什么，你会得到10个不同的答案。在这篇文章里我不会花太多时间解释。我建议阅读一些不同的观点，然后尝试一些GraphQL代码。</p><p id="64fd" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">Graph QL(Graph<strong class="lo iu">Q</strong>uery<strong class="lo iu">L</strong>language)是一种描述你拥有什么，你想要什么，并提供算法来解决这些请求的语言。</p><p id="2bbe" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">服务器提供整个可用数据的定义以及该数据的相关类型。数据以对象的形式呈现，我们知道所有键的名称和相关值的类型。这意味着您的后端是完整记录的，我们可以使用工具轻松地检查它。</p><p id="d180" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">只有一个端点可以向GraphQL服务器发出请求。客户机发送它需要的数据的键，服务器以JSON对象的形式响应产生的键-值对。简单地说，客户要求它想要的东西。</p><p id="0844" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">它被称为REST(表述性状态转移)的替代品，但它在概念上超出了该规范。</p><p id="3934" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">在服务器端有很多好处。您可以使用<a class="ae mi" href="https://graphql.org/learn/schema/" rel="noopener ugc nofollow" target="_blank"> SDL </a>(模式定义语言)来定义您的API模式，然后您可以获得自动自省和自我文档。有些解析器是将数据映射到请求的函数，而字段解析器是递归的。如果字段产生一个标量值，如字符串或数字，解析器执行完成。但是，如果一个字段产生一个对象值，那么查询将包含应用于该对象的另一个字段选择。</p><h1 id="db78" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">什么是TypeScript？</h1><p id="c86f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><a class="ae mi" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>是一种编程语言，是一套应用开发的工具。它是由<a class="ae mi" href="https://www.microsoft.com" rel="noopener ugc nofollow" target="_blank">微软</a>创造的，7年前发布，从那以后人们的兴趣一直在增长。</p><p id="e5b6" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">JavaScript一直因缺乏变量的类型安全性而受到批评，但随着TypeScript的出现，这种情况有所改变，它提供了一组(严格的)ECMAScript特性。它将文件转换为JavaScript，所以它包含了所有的标准特性，并添加了新的东西，如类型注释和面向对象的概念，如类和接口。它还支持未来新的JavaScript特性，比如异步函数和装饰器。</p><p id="6632" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">TypeScript提供编译时检查和强静态类型。这使得像<a class="ae mi" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VS Code </a>这样的IDE工具变得“更加智能”，提供了内嵌代码完成和错误检查。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><blockquote class="na"><p id="5ba7" class="nb nc it bd nd ne nf ng nh ni nj mh dk translated">我以为我懂API开发，但是GraphQL和TypeScript让我成为了更好的API开发者。</p></blockquote><h1 id="ffa6" class="ku kv it bd kw kx ky kz la lb lc ld le jz nk ka lg kc nl kd li kf nm kg lk ll bi translated">学习成果</h1><p id="77a8" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">下面是学习TypeScript和GraphQL的一些结果。我试图强调我认为超越REST和传统JavaScript的概念。</p><h2 id="d686" class="nn kv it bd kw no np dn la nq nr dp le lv ns nt lg lz nu nv li md nw nx lk ny bi translated"><strong class="ak">加深对API的理解</strong></h2><p id="9892" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">从REST之前就开始开发API(应用编程接口)。我见过一些不同的方法来来去去，还有其他规范，如SOAP (XML)、CORBA和Hateoas。我研究过数百个REST端点。我以为我懂API开发，但是GraphQL和TypeScript让我成为了更好的API开发者。</p><p id="e4dd" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">GraphQL API本质上是自省的。您可以获得所有可用数据的全类型模式，使其自文档化。这允许您发展对API的强烈直觉，并增强您对数据类型、实体和抽象的意识。</p><p id="fa95" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">你没有重载端点，也没有过度提取或提取不足。你不用在不同的技术栈之间跳来跳去，订阅和查询的形状是一样的(基于JSON)，变异也是一样的形状，除非你把它表示为“变异”,你明确地声明查询可能有副作用。它更容易被人类和机器阅读。</p><p id="d249" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">REST缺乏适当的标准，所以没有行业标准受到青睐，有太多的味道，太多的签名和文档很快就过时了。使用GraphQL，您可以从致力于采用标准方法并在整个行业推广的行业老手那里学习最佳实践，标准允许通用工具，因为系统共享一个通用接口。</p><p id="3c89" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">像REST的<a class="ae mi" href="https://swagger.io/" rel="noopener ugc nofollow" target="_blank"> Swagger </a>这样的工具也提供了类似的API内省，但是使用GraphQL，这个过程是自动的。工具<a class="ae mi" href="https://github.com/yarax/swagger-to-graphql" rel="noopener ugc nofollow" target="_blank"> Swagger-to-GraphQL </a>将您现有的Swagger模式转换为可执行的GraphQL模式。</p><p id="bae8" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">这些工具的结合使您能够构建强大而实用的编程接口，供所有GraphQL消费者使用。</p><p id="a698" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">TypeScript扩展了这一概念，从GraphQL API边界开始进行类型检查。当一个端点是完全类型化的时，误用它要困难得多。它鼓励您对数据进行更好的抽象，并适当地设计您的UI来容纳这些数据。</p><h2 id="3693" class="nn kv it bd kw no np dn la nq nr dp le lv ns nt lg lz nu nv li md nw nx lk ny bi translated"><strong class="ak">培养对类型安全的理解，以及这如何传达程序员的真实意图</strong></h2><p id="4461" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">类型注释给你一种程序员意图的更强烈的感觉。对于任何考虑使用TypeScript+GraphQL的人来说，拥有端到端打字的机会应该是一个巨大的激励因素。</p><p id="0f32" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">在现代的web开发栈中，可以在多个层次上体验到打字的力量。类型使您的IDE更加智能，在开发过程中建议正确的类型。它可以极大地增强您的开发人员体验。</p><p id="de39" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">如果你使用的是像<a class="ae mi" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VS Code </a>这样的现代IDE，TypeScript在你开发的时候有很强的指导方针和类型化的保护。类型错误是JavaScript中错误的一个巨大来源，正确地输入有助于提高代码质量。</p><p id="1a2a" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">在开发过程中识别bug比让客户在生产中发现它要好得多。</p><p id="162f" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">语言级别的TypeScript与API边界的GraphQL相结合，提供了高级别的代码自省和安全性。类型定义使你成为更好的开发者。</p><p id="cce1" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">代码生成提供了蛋糕上的樱桃。有不同的包可用，但大多数都为您的客户端提供类型生成，这意味着您可以从您的GraphQL API为您的客户端代码生成类型定义。</p><p id="b9ef" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><strong class="lo iu">由于您正在创建类型化数据图，因此可以免费生成TypeScript类型。</strong></p><p id="e5c2" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">你甚至可以生成像React组件和<a class="ae mi" href="https://medium.com/the-guild/graphql-code-generator-introducing-hooks-support-for-react-apollo-2cdc8a7b526d" rel="noopener"> GraphQL客户端钩子</a>这样的东西！</p><blockquote class="na"><p id="17ac" class="nb nc it bd nd ne nf ng nh ni nj mh dk translated">打字稿提高生产力，减少疯狂，它的价值随着时间的推移而增加。</p></blockquote><h2 id="1705" class="nn kv it bd kw no nz dn la nq oa dp le lv ob nt lg lz oc nv li md od nx lk ny bi translated"><strong class="ak">使用集成开发环境(代码完成、智能感知)分析您的代码库</strong></h2><p id="9432" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">内在API自省非常重要，因为您可以有效地免费获得[一些]文档和运行时类型检查。犯错误要难得多。通常只需一个<code class="fe oe of og oh b">ctrl-space</code>键序列就可以自动完成，像字段弃用这样的事情会实时呈现。大多数服务器都提供集成的API探索者，如<a class="ae mi" href="https://github.com/prisma-labs/graphql-playground" rel="noopener ugc nofollow" target="_blank"> GraphQL Playground </a>或<a class="ae mi" href="https://github.com/graphql/graphiql/blob/master/packages/graphiql/README.md" rel="noopener ugc nofollow" target="_blank">graph QL</a>。</p><p id="10fc" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">VS代码的特点是智能感知，它是一个代码完成辅助工具。它帮助您了解更多关于您正在使用的代码的信息。它会在您键入时跟踪参数，并且只需几次击键就可以添加对属性和方法的调用。IntelliSense随着更新变得更加智能，当您提供良好的类型定义时，它会更加智能。GraphQL有工具可以自动生成类型定义。</p><h2 id="0883" class="nn kv it bd kw no np dn la nq nr dp le lv ns nt lg lz nu nv li md nw nx lk ny bi translated">自动生成代码</h2><p id="5a90" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">您应该使用代码生成器从GraphQL API自动生成您的类型，但是您也可以生成其他东西，比如React和Apollo的<a class="ae mi" href="https://medium.com/the-guild/graphql-code-generator-introducing-hooks-support-for-react-apollo-2cdc8a7b526d" rel="noopener">钩子</a>。您甚至可以编写自己的插件来生成自己的代码，不要忘记您可以访问静态类型定义和模式自省。</p><p id="c83e" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">有不同的生成器可以尝试:我推荐<a class="ae mi" href="https://graphql-code-generator.com/" rel="noopener ugc nofollow" target="_blank"> GraphQL代码生成器</a>，但也有<a class="ae mi" href="https://typegraphql.ml/" rel="noopener ugc nofollow" target="_blank"> TypeGraphQL </a>，Apollo tools提供<a class="ae mi" href="https://github.com/apollographql/apollo-tooling" rel="noopener ugc nofollow" target="_blank"> Apollo code-gen </a>。</p><p id="87f3" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">想象一下代码生成的未来。不难想象作为模板生成的集成组件，但是整个客户端应用程序呢？有了机器学习，这似乎很有可能。</p><h2 id="1453" class="nn kv it bd kw no np dn la nq nr dp le lv ns nt lg lz nu nv li md nw nx lk ny bi translated"><strong class="ak">利用编译时安全和静态类型尽早识别bug</strong></h2><p id="e221" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果你改变了一些东西，你会立即看到错误和警告，任何有问题的地方都会被突出显示。你得到了跨特性的契约验证，这产生了非常干净的代码，因为基本的错误很难犯，并且破坏性的改变会立即显现。</p><h2 id="5cab" class="nn kv it bd kw no np dn la nq nr dp le lv ns nt lg lz nu nv li md nw nx lk ny bi translated">验证并遵守跨功能/团队的合同</h2><p id="0dcf" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">考虑代码生成如何从GraphQL API创建类型定义，以及GraphQL如何将不同的数据源整合到一个数据图中。微服务更容易管理。</p><p id="b3b6" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">一些框架有“模式拼接”的工作实现，也称为“联邦”(Apollo)或“远程模式”(Hasura)。在扩展和订阅等方面还有一些工作要做，但是这些工具有效地将来自不同筒仓的多个图合并成一个简洁的数据图。</p><p id="2f84" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">有了TypeScript类型定义和GraphQL APIs，就有可能实现跨特性的端到端契约验证。这是非常强大的，如果一个团队破坏了一个集成，这个错误将在编译时被检测到，并且您的持续集成环境(CI)可以被配置为跨远程模式进行编译时检查。</p><p id="5760" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">这是一个令人兴奋的概念，因为你可以想象这将如何在整个网络中发展。考虑由不同小组开发的ES模块。</p><h2 id="6e3b" class="nn kv it bd kw no np dn la nq nr dp le lv ns nt lg lz nu nv li md nw nx lk ny bi translated"><strong class="ak">在新特性对JavaScript可用之前访问它们</strong></h2><p id="09df" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">TypeScript支持ECMAScript 2015中的所有功能，并添加了一组附加功能:</p><ul class=""><li id="e5ab" class="oi oj it lo b lp mj ls mk lv ok lz ol md om mh on oo op oq bi translated"><a class="ae mi" href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html#type-annotations" rel="noopener ugc nofollow" target="_blank">类型注释和编译时类型检查。</a></li><li id="c5f8" class="oi oj it lo b lp or ls os lv ot lz ou md ov mh on oo op oq bi translated"><a class="ae mi" href="https://www.typescriptlang.org/docs/handbook/type-inference.html" rel="noopener ugc nofollow" target="_blank">式推论。</a></li><li id="97d2" class="oi oj it lo b lp or ls os lv ot lz ou md ov mh on oo op oq bi translated"><a class="ae mi" href="https://github.com/microsoft/TypeScript/wiki/FAQ#what-is-type-erasure" rel="noopener ugc nofollow" target="_blank">类型擦除。</a></li><li id="eef6" class="oi oj it lo b lp or ls os lv ot lz ou md ov mh on oo op oq bi translated"><a class="ae mi" href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html#interfaces" rel="noopener ugc nofollow" target="_blank">接口。</a></li><li id="d65c" class="oi oj it lo b lp or ls os lv ot lz ou md ov mh on oo op oq bi translated"><a class="ae mi" href="https://www.typescriptlang.org/docs/handbook/enums.html" rel="noopener ugc nofollow" target="_blank">枚举类型。</a></li><li id="e92d" class="oi oj it lo b lp or ls os lv ot lz ou md ov mh on oo op oq bi translated"><a class="ae mi" href="https://www.typescriptlang.org/docs/handbook/generics.html" rel="noopener ugc nofollow" target="_blank">仿制药。</a></li><li id="83f9" class="oi oj it lo b lp or ls os lv ot lz ou md ov mh on oo op oq bi translated"><a class="ae mi" href="https://www.typescriptlang.org/docs/handbook/namespaces.html" rel="noopener ugc nofollow" target="_blank">名称空间。</a></li><li id="fcb5" class="oi oj it lo b lp or ls os lv ot lz ou md ov mh on oo op oq bi translated"><a class="ae mi" href="https://www.typescriptlang.org/docs/handbook/basic-types.html#tuple" rel="noopener ugc nofollow" target="_blank">元组。</a></li></ul><p id="b37e" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">除了这些特殊的TypeScript特性之外，还有一些未来的ECMAScript特性，这些特性通常只有在您使用类似于<a class="ae mi" href="https://babeljs.io/docs/en/plugins/" rel="noopener ugc nofollow" target="_blank"> Babel plugins </a>的东西时才可用。TypeScript包括流行的ES next特性，如:</p><ul class=""><li id="523a" class="oi oj it lo b lp mj ls mk lv ok lz ol md om mh on oo op oq bi translated"><a class="ae mi" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#optional-chaining" rel="noopener ugc nofollow" target="_blank">可选链接</a></li><li id="037a" class="oi oj it lo b lp or ls os lv ot lz ou md ov mh on oo op oq bi translated"><a class="ae mi" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#nullish-coalescing" rel="noopener ugc nofollow" target="_blank">无效合并</a></li><li id="9369" class="oi oj it lo b lp or ls os lv ot lz ou md ov mh on oo op oq bi translated"><a class="ae mi" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions" rel="noopener ugc nofollow" target="_blank">断言功能</a></li></ul><p id="a94b" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">不要忘记TypeScript可以编译成常规的ECMAScript，所以这些特性应该可以与当今的JavaScript容器(browser、Node.js等)一起工作。</p><h2 id="deb7" class="nn kv it bd kw no np dn la nq nr dp le lv ns nt lg lz nu nv li md nw nx lk ny bi translated"><strong class="ak">了解代码变更的影响</strong></h2><p id="3c82" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">模式更改验证可以作为构建过程的一部分来实现。<a class="ae mi" href="https://www.apollographql.com/docs/graph-manager/integrations/" rel="noopener ugc nofollow" target="_blank"> Apollo Graph Manager </a>甚至可以针对客户端验证服务器模式的变化。有一个GitHub集成，您可以在其中监控客户端请求，如果有客户端请求数据图上的不推荐使用的字段，您可以跟踪它们，或者在它们不再使用时删除它们。</p><p id="3e74" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">TypeScript几乎可以立即测量影响，如果有错误，它甚至不会传输。如果您的常规CI工作流只是运行测试或构建，TypeScript将进行编译时检查。如果你对你的API运行code-gen，这将标记一个问题，即使它在组织的另一边。</p><h2 id="1e3d" class="nn kv it bd kw no np dn la nq nr dp le lv ns nt lg lz nu nv li md nw nx lk ny bi translated"><strong class="ak">将原则性决策应用于标准化应用开发</strong></h2><p id="9811" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这是主观的，但有一个观点通常是一件好事。用<a class="ae mi" href="https://fs.blog/2018/04/first-principles/" rel="noopener ugc nofollow" target="_blank">第一原理</a>来接近GraphQL是一个<strong class="lo iu">错误</strong>。您应该尽可能遵循最佳实践，并积极寻求意见和固执己见的软件。如果需要扩展，可以跳到现有的开源实现上。</p><p id="6b2a" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><a class="ae mi" href="https://principledgraphql.com/" rel="noopener ugc nofollow" target="_blank"> Principled GraphQL </a>，由阿波罗团队的<a class="ae mi" href="https://twitter.com/GeoffQL" rel="noopener ugc nofollow" target="_blank"> Geoff Schmidt </a>和<a class="ae mi" href="https://twitter.com/debergalis" rel="noopener ugc nofollow" target="_blank"> Matt DeBergalis </a>撰写，是一个受<a class="ae mi" href="https://12factor.net/config" rel="noopener ugc nofollow" target="_blank">十二因素应用</a>启发的指南(另一个你应该阅读的伟大的最佳实践指南)。这是一个很好的起点，有助于理解如何利用现场经验开发GraphQL应用程序。</p><p id="de3d" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">固执己见的软件最酷的一点是，你不必浪费时间来阐述你自己的观点并与你的同事争论，通常你的问题的解决方案已经被考虑了。</p><p id="a1b5" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">T21是我最喜欢的开源项目之一，它是固执己见的软件的一个极好的例子，它旨在通过接受一个共同的风格指南来停止所有正在进行的关于代码格式的争论。</p><h2 id="49b5" class="nn kv it bd kw no np dn la nq nr dp le lv ns nt lg lz nu nv li md nw nx lk ny bi translated"><strong class="ak">用通用工具开发应用</strong></h2><p id="07c1" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">GraphQL + TypeScript提供了对整个代码库的自省，GraphQL自省模式可用于驱动许多应用程序。</p><p id="1f96" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">有一些完整的框架是围绕GraphQL内省构建的。考虑像<a class="ae mi" href="https://github.com/apollographql/apollo-client" rel="noopener ugc nofollow" target="_blank"> Apollo Client </a>这样的工具，它在浏览器中构建了一个全面的规范化数据缓存，可以直接查询或者合并到一个<a class="ae mi" href="https://www.apollographql.com/docs/react/data/local-state/" rel="noopener ugc nofollow" target="_blank">本地链接状态</a>中进行本地状态管理。</p><p id="10c4" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">还有像<a class="ae mi" href="https://github.com/prisma-labs/graphql-playground" rel="noopener ugc nofollow" target="_blank"> GraphQL Playground </a>或者<a class="ae mi" href="https://github.com/graphql/graphiql/blob/master/packages/graphiql/README.md" rel="noopener ugc nofollow" target="_blank">graph QL</a>这样的GraphQL API探索者。有像<a class="ae mi" href="https://github.com/APIs-guru/graphql-voyager" rel="noopener ugc nofollow" target="_blank"> GraphQL Voyager </a>这样的图形可视化工具，像<a class="ae mi" href="https://graphqleditor.com/" rel="noopener ugc nofollow" target="_blank"> GraphQL Editor </a>这样的设计工具，像<a class="ae mi" href="https://graphcms.com/" rel="noopener ugc nofollow" target="_blank"> GraphCMS </a>这样的无头内容管理工具。每天都有新工具发布<a class="ae mi" href="https://github.com/search?q=graphql" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><blockquote class="na"><p id="d33f" class="nb nc it bd nd ne nf ng nh ni nj mh dk translated">在开发过程中识别bug比让客户在生产中发现它要好得多。</p></blockquote></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="75d6" class="nn kv it bd kw no np dn la nq nr dp le lv ns nt lg lz nu nv li md nw nx lk ny bi translated">获得在没有版本控制的情况下发展API的能力</h2><p id="386d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">过量提取是指提取的数据多于所需的数据。REST端点通常会提供所有内容，并允许客户端进行精选。而提取不足则相反，当在提取时没有传递足够的数据时，客户端必须从其他地方提取更多的数据。</p><p id="6a0b" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">假设您必须添加一个新字段或重命名一个旧字段，如果您想要创建更多优化的端点或更改一个端点，REST通常会采用版本化端点<code class="fe oe of og oh b">/v1/</code> <code class="fe oe of og oh b">/v2/</code>等。您可能有尚未更新的移动应用程序或其他客户端，并且您无法更新它们的代码。</p><p id="be3d" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">GraphQL使API的发展变得容易，而不必求助于端点版本控制，您可以标记字段以避免使用。</p><p id="d5b7" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">TypeScript使API更新更干净，您可以在编译时看到错误，并且接口定义了您正在处理的对象的预期形状。</p><h2 id="7cd8" class="nn kv it bd kw no np dn la nq nr dp le lv ns nt lg lz nu nv li md nw nx lk ny bi translated">获取关于您的信息体系结构和业务决策的知识</h2><p id="b68a" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">“真理的单一来源”是信息系统理论中的一个术语，在讨论GraphQL时你会经常听到。这是一个组织可以作为其信息架构的一部分来应用的概念，以确保组织中的每个人在做出业务决策时都使用相同的数据。</p><p id="ce92" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">GraphQL提供的数据图是现代应用程序开发堆栈中的一个新层。它对您的整个组织都很有用，经理和开发人员都可以使用它，它对领域建模很有用，并且为跨团队功能提供了准确的自我记录的数据表示。</p><p id="22fb" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">GraphQL减少了摩擦，改善了沟通。它促进了单个数据图，而不是在整个公司中有不同的数据仓库。如果您在许多地方有数据，您必须同步和聚合，这会导致复杂性，从而导致代价高昂的错误。这也使得决定什么/谁是数据的权威来源变得具有挑战性。</p><h2 id="ec78" class="nn kv it bd kw no np dn la nq nr dp le lv ns nt lg lz nu nv li md nw nx lk ny bi translated">了解API开发的不同方法</h2><p id="0ede" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">来自Apollo GraphQL文档:</p><blockquote class="ow ox oy"><p id="4c74" class="lm ln oz lo b lp mj ju lr ls mk jx lu pa ml lx ly pb mm mb mc pc mn mf mg mh im bi translated">因为模式直接位于应用程序客户机和底层数据服务之间，前端和后端团队应该在它的结构上协作。当你开发你自己的数据图时，练习 <strong class="lo iu"> <em class="it">模式优先开发</em> </strong> <em class="it">并在你开始实现你的API之前就一个模式达成一致。</em></p></blockquote><p id="830e" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><strong class="lo iu">模式优先</strong>是一种给予模式设计最高优先权的方法。它很有用，因为它解除了前端和后端团队的阻塞。在前端团队开始开发客户端之前，API不一定要工作，反之亦然。如果存在模式，API数据可能会被模仿。</p><p id="269b" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><strong class="lo iu">代码优先</strong>(又名<em class="oz">解析器优先</em>)是另一种流行的方法。这是以编程方式生成模式的地方<em class="oz"/>。关于正确的方法存在一些争论，双方都有不同的倡导者。这可能非常令人困惑，这是你欢迎强烈意见的事情之一。</p><p id="9bfe" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">如果您使用TypeScript，那么选择模式优先的<strong class="lo iu">会有一些特殊的挑战。</strong></p><p id="4e20" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">用TypeScript在Node.js中构建GraphQL API可能很困难，因为您必须用<a class="ae mi" href="https://graphql.org/learn/schema/" rel="noopener ugc nofollow" target="_blank"> SDL </a>(模式定义语言)创建您的模式类型以及ORM的数据模型(即TypeORM中的类)，然后为您的查询/变异/订阅编写解析器。这里的问题是，在您可以实现解析器之前，您被迫创建您的TypeScript接口，因为否则，您会得到类型错误，这不仅仅是存根您的方法。</p><p id="7c1c" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">还有一个相当严重的冗余和管理问题。仅仅添加一个新的字段，您就会发现自己正在更新许多文件，您必须修改模型、模式、解析器、类型定义和单元测试接口，然后才能更新您的客户端接口。它很难管理并且容易出错。如果你能建立一个单一的<strong class="lo iu">代码优先</strong>的事实来源，你就有可能消除这个问题。</p><h1 id="6d1e" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结论</h1><p id="9eb6" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我从使用TypeScript和GraphQL中学到了很多。我的经历中最值得注意的一件事是，我学到了可以应用于任何应用程序开发堆栈的概念。我学到的很多东西可以很容易地应用于REST和常规的JavaScript应用程序。</p><p id="7c3f" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">它让我懂得了数据类型的价值，并教会了我要小心过度获取和不足获取。它给了我关于如何进行API设计的好建议。我已经了解了依赖注入以及它是如何影响自动化测试的。我学到了自省和自我记录代码的重要性。</p><p id="76f2" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我坚信这种堆栈会越来越受欢迎，尤其是在企业领域。缺点是(像往常一样)，不得不学习新的东西。TypeScript增加了一点代码，我记得JavaScript开发人员会嘲笑Java和C++开发人员巨大的函数签名、访问修饰符等等。随着对可伸缩和可维护的web软件需求的增长，TypeScript开始变得相似，这是可以理解的。打字稿提高生产力，减少疯狂，它的价值随着时间的推移而增加。</p><p id="7073" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">未来是令人兴奋的，在许多方面，这只是第一步。</p><p id="0c95" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我强烈建议您学习TypeScript和GraphQL，尤其是如果您正在开发生产API的话。祝你努力成功！</p><h1 id="0e78" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">资源</h1><p id="7bed" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><a class="ae mi" href="https://github.com/apollographql/apollo-client" rel="noopener ugc nofollow" target="_blank">阿波罗客户端</a> / <a class="ae mi" href="https://www.apollographql.com/docs/graph-manager/integrations/" rel="noopener ugc nofollow" target="_blank">阿波罗图形管理器</a> /</p><p id="0677" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><a class="ae mi" href="https://principledgraphql.com/" rel="noopener ugc nofollow" target="_blank">原理图QL </a> / <a class="ae mi" href="https://12factor.net/config" rel="noopener ugc nofollow" target="_blank">十二要素App </a></p><p id="806f" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><a class="ae mi" href="https://github.com/prisma-labs/graphql-playground" rel="noopener ugc nofollow" target="_blank"> GraphQL游乐场</a>/<a class="ae mi" href="https://github.com/graphql/graphiql/blob/master/packages/graphiql/README.md" rel="noopener ugc nofollow" target="_blank">graph QL</a>/<a class="ae mi" href="https://github.com/APIs-guru/graphql-voyager" rel="noopener ugc nofollow" target="_blank">graph QL航海家</a></p><p id="c19f" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><a class="ae mi" href="https://graphqleditor.com/" rel="noopener ugc nofollow" target="_blank"> GraphQL编辑器</a> / <a class="ae mi" href="https://graphcms.com/" rel="noopener ugc nofollow" target="_blank"> GraphCMS </a></p><p id="c6fc" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><a class="ae mi" href="https://graphql-code-generator.com/" rel="noopener ugc nofollow" target="_blank"> GraphQL代码生成器</a>/<a class="ae mi" href="https://typegraphql.ml/" rel="noopener ugc nofollow" target="_blank">type graph QL</a>/<a class="ae mi" href="https://github.com/apollographql/apollo-tooling" rel="noopener ugc nofollow" target="_blank">Apollo Code-gen</a>。</p><p id="8d7f" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><a class="ae mi" href="https://swagger.io/" rel="noopener ugc nofollow" target="_blank">Swagger</a>/<a class="ae mi" href="https://github.com/yarax/swagger-to-graphql" rel="noopener ugc nofollow" target="_blank">Swagger-to-graph QL</a></p></div></div>    
</body>
</html>