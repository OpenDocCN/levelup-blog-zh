<html>
<head>
<title>Node.js Tips — Promises, CSV to JSON, and Watching Files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示—承诺、CSV转JSON和监视文件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/node-js-tips-promises-csv-to-json-watching-files-525f679b73d6?source=collection_archive---------13-----------------------#2020-07-12">https://levelup.gitconnected.com/node-js-tips-promises-csv-to-json-watching-files-525f679b73d6?source=collection_archive---------13-----------------------#2020-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7ad28ca8f72abf81cd7f32cb5e40b333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7X7lxUVb8qdZ1zuM"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@vincentvanzalinge?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">文森特·范·扎林格</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1289" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="14f0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">处理Node.js中require()引发的错误</h1><p id="b133" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用try-catch来捕捉由<code class="fe mh mi mj mk b">require</code>抛出的错误。</p><p id="d0ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c979" class="mt lf it mk b gy mu mv l mw mx">try {<br/>  require('./app.js');<br/>}<br/>catch (e) { <br/>  console.log(e);<br/>}</span></pre><p id="aa30" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只需调用<code class="fe mh mi mj mk b">try</code>中的<code class="fe mh mi mj mk b">require</code>，就可以捕捉到<code class="fe mh mi mj mk b">catch</code>中的错误。</p><h1 id="8ad5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">如何对流使用async/await</h1><p id="7854" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过用<code class="fe mh mi mj mk b">Promise</code>构造函数创建流的承诺，将<code class="fe mh mi mj mk b">async</code>和<code class="fe mh mi mj mk b">await</code>用于流。</p><p id="11b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="be65" class="mt lf it mk b gy mu mv l mw mx">const fd = fs.createReadStream('/foo.txt');<br/>const hash = crypto.createHash('sha1');<br/>hash.setEncoding('hex');<br/>fd.pipe(hash);</span><span id="2648" class="mt lf it mk b gy my mv l mw mx">const readHash = new Promise((resolve, reject) =&gt; {<br/>  hash.on('end', () =&gt; resolve(hash.read()));<br/>  fd.on('error', reject);<br/>});</span></pre><p id="1a80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以通过编写以下代码在异步函数中使用<code class="fe mh mi mj mk b">readHash</code>:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="53a3" class="mt lf it mk b gy mu mv l mw mx">(async function() {<br/>  const sha1 = await <!-- -->readHash<!-- -->;<br/>  console.log(sha1);<br/>}());</span></pre><h1 id="f620" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">承诺重试设计模式</h1><p id="3fb0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过推迟承诺来重试承诺。</p><p id="b104" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ec3a" class="mt lf it mk b gy mu mv l mw mx">const retry = (fn, retries=3, err=null) =&gt; {<br/>  if (!retries) {<br/>    return Promise.reject(err);<br/>  }<br/>  return fn().catch(err =&gt; {<br/>    return retry(fn, (retries - 1), err);<br/>  });<br/>}</span></pre><p id="a920" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">fn</code>是一个返回承诺的函数。</p><p id="e9a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只要我们还没有用尽重试，我们就会重试。</p><p id="f09b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果被<code class="fe mh mi mj mk b">fn</code>拒绝的承诺被拒绝，那么我们通过传入一个回调来调用<code class="fe mh mi mj mk b">retry</code>并把<code class="fe mh mi mj mk b">retries</code>减1来调用<code class="fe mh mi mj mk b">catch</code>。</p><p id="22a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们这样做，直到<code class="fe mh mi mj mk b">retries</code>达到0，然后重试次数用尽。</p><h1 id="86b3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在编写Promise代码时，我们不需要`. catch(err =&gt; console.error(err))'</h1><p id="32d1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不需要编写<code class="fe mh mi mj mk b">.catch(err =&gt; console.error(err))</code>，因为Node.js已经记录了承诺拒绝。</p><p id="6d98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即使没有这行代码，我们也会知道发生了错误。</p><h1 id="473a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">如何在Node.js中将CSV转换成JSON</h1><p id="40c1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">csvtojson</code>库将CSV转换成JSON。</p><p id="1e9f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要安装它，我们运行:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9042" class="mt lf it mk b gy mu mv l mw mx">npm install --save csvtojson</span></pre><p id="744d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以通过写来使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b605" class="mt lf it mk b gy mu mv l mw mx">const csv = require("csvtojson");</span><span id="00a5" class="mt lf it mk b gy my mv l mw mx">const readCsv = (csvFilePath) =&gt; {<br/>  csv()<br/>    .fromFile(csvFilePath)<br/>    .then((jsonArrayObj) =&gt; { <br/>       console.log(jsonArrayObj); <br/>     })<br/>}</span></pre><p id="a187" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过将<code class="fe mh mi mj mk b">csvFilePath</code>传递给<code class="fe mh mi mj mk b">fromFile</code>方法来读取小文件。</p><p id="e365" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它回报一个承诺。</p><p id="d18d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在<code class="fe mh mi mj mk b">jsonArrayObj</code>参数中得到转换后的结果。</p><p id="bd26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以从流中读取内容，然后获取JSON。</p><p id="bd54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3ee6" class="mt lf it mk b gy mu mv l mw mx">const readFromStream = (readableStream) =&gt; {<br/>  csv()<br/>    .fromStream(readableStream)<br/>    .subscribe((jsonObj) =&gt; { <br/>       console.log(jsonObj)<br/>    })<br/>}</span></pre><p id="1cf5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们调用<code class="fe mh mi mj mk b">fromStream</code>方法从流中获取数据。</p><p id="097d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用回调函数调用<code class="fe mh mi mj mk b">subscribe</code>来读取对象。</p><p id="6265" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以将<code class="fe mh mi mj mk b">fromFile</code>与<code class="fe mh mi mj mk b">async</code>和<code class="fe mh mi mj mk b">await</code>一起使用，因为它返回一个承诺:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3d56" class="mt lf it mk b gy mu mv l mw mx">const csvToJson = async (filePath) =&gt; {<br/>  const jsonArray = await csv().fromFile(filePath);<br/>}</span></pre><p id="a2f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它也可以在命令行上使用。</p><p id="c111" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以通过运行以下命令直接运行它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3430" class="mt lf it mk b gy mu mv l mw mx">npm install -g csvtojson<br/>csvtojson ./csvFile.csv</span></pre><h1 id="6912" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">无需重新启动Node.js即可在服务器上编辑节点应用程序文件，并查看最新的更改</h1><p id="c451" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用像Node-Supervisor这样的包来监视文件的变化，并自动重启Node应用程序。</p><p id="a2fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要安装它，我们运行:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f9c4" class="mt lf it mk b gy mu mv l mw mx">npm install supervisor -g</span></pre><p id="fe27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以通过运行以下命令使用节点管理器运行我们的程序:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7204" class="mt lf it mk b gy mu mv l mw mx">supervisor app.js</span></pre><p id="fa55" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以使用Nodemon来做同样的事情。</p><p id="b588" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过运行以下命令来安装它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c05c" class="mt lf it mk b gy mu mv l mw mx">npm install -g nodemon</span></pre><p id="8f47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">全球安装。</p><p id="6f53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者，我们可以通过运行以下命令来安装它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="bf91" class="mt lf it mk b gy mu mv l mw mx">npm install --save-dev nodemon</span></pre><p id="56eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将其作为项目的开发依赖项进行安装。</p><p id="4974" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以运行:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="62db" class="mt lf it mk b gy mu mv l mw mx">nodemon app.js</span></pre><p id="9855" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行我们的应用程序。</p><h1 id="ecaf" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用承诺来链接和分享先前的结果</h1><p id="b9e3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了用承诺共享先前的结果，我们可以用<code class="fe mh mi mj mk b">then</code>将它们链接起来。</p><p id="dacf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="930d" class="mt lf it mk b gy mu mv l mw mx">makeRequest(url1, data1)<br/>  .then((result1) =&gt; {  <br/>    return makeRequest(url2, data2);<br/>  })<br/>  .then((result2) =&gt; {  <br/>    return makeRequest(url3, data3);<br/>  })<br/>  .then((result3) =&gt; {<br/>     // ...<br/>  });</span></pre><p id="994b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从<code class="fe mh mi mj mk b">then</code>回调中的先前承诺中得到解决的结果。</p><p id="962c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了缩短这个过程，我们可以使用<code class="fe mh mi mj mk b">async</code>和<code class="fe mh mi mj mk b">await</code>来做同样的事情:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5260" class="mt lf it mk b gy mu mv l mw mx">const makeRequests = async () =&gt; {<br/>  //...<br/>  const r1 = await makeRequest(url1, data1);<br/>  const r2 = await makeRequest(url2, data2);<br/>  const r3 = await makeRequest(url3, data3);<br/>  return someResult;<br/>}</span></pre><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/539af44f4d60ff38c952c3221dd32af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7mumVh5gzimubCXe"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@purplelydia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Lydia Tan </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="f8d9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="75c2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以在承诺中加入溪流。</p><p id="463a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以观察代码文件的变化，并用各种程序重启我们的节点应用程序。</p><p id="2bf7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">csvtojson</code>库让我们将CSV转换成JSON。</p><p id="2b8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">承诺可以通过再次调用来重试。</p></div></div>    
</body>
</html>