<html>
<head>
<title>Guide to the Express Response Object</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速响应对象指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/guide-to-the-express-response-object-2eb1bd2cb1bd?source=collection_archive---------9-----------------------#2020-02-24">https://levelup.gitconnected.com/guide-to-the-express-response-object-2eb1bd2cb1bd?source=collection_archive---------9-----------------------#2020-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/df7c32b96aeb2a33500731e4050c16cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Evj8IuAOHs_dr4od"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@priscilladupreez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">普里西拉·杜·普里兹</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="223e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Express response对象允许我们向客户端发送响应。</p><p id="1a9a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以发送各种响应，比如字符串、JSON和文件。此外，除了主体之外，我们还可以向客户端发送各种标头和状态代码。</p><p id="0ff8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究响应对象的各种属性。</p><h1 id="1511" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">响应对象</h1><p id="1e9d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">response对象有一些有用的方法让我们返回各种类型的响应。</p><h1 id="af29" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">性能</h1><h2 id="1563" class="mh lf it bd lg mi mj dn lk mk ml dp lo kr mm mn ls kv mo mp lw kz mq mr ma ms bi translated">res.app</h2><p id="75db" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mt mu mv mw b">app</code>属性有应用程序的实例。它与<code class="fe mt mu mv mw b">req.app</code>属性相同。</p><h2 id="b765" class="mh lf it bd lg mi mj dn lk mk ml dp lo kr mm mn ls kv mo mp lw kz mq mr ma ms bi translated">资源标题发送</h2><p id="0f01" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mt mu mv mw b">headersSent</code>属性表明应用程序是否发送了响应的HTTP报头。</p><p id="5935" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="6796" class="mh lf it mw b gy nf ng l nh ni">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();</span><span id="4cdc" class="mh lf it mw b gy nj ng l nh ni">app.get('/', (req, res) =&gt; {<br/>  console.dir(res.headersSent)<br/>  res.send('foo');<br/>  console.dir(res.headersSent);<br/>})</span><span id="050f" class="mh lf it mw b gy nj ng l nh ni">app.listen(3000);</span></pre><p id="fee6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在响应发出之前，<code class="fe mt mu mv mw b">res.headersSent</code>是<code class="fe mt mu mv mw b">false</code>。一旦响应被发送，<code class="fe mt mu mv mw b">res.headersSent</code>变为<code class="fe mt mu mv mw b">true</code>。</p><h2 id="78ed" class="mh lf it bd lg mi mj dn lk mk ml dp lo kr mm mn ls kv mo mp lw kz mq mr ma ms bi translated">res.locals</h2><p id="8e43" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mt mu mv mw b">res.locals</code>属性是一个对象，它对只限于请求的局部变量做出响应。</p><p id="30f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它对于保存路线数据很有用。</p><p id="ee2f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="a552" class="mh lf it mw b gy nf ng l nh ni">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();</span><span id="6d25" class="mh lf it mw b gy nj ng l nh ni">app.use((req, res, next) =&gt; {<br/>  res.locals.foo = 'foo';<br/>  next()<br/>})</span><span id="7916" class="mh lf it mw b gy nj ng l nh ni">app.get('/', (req, res) =&gt; {<br/>  res.send(res.locals.foo);<br/>})</span><span id="1f1c" class="mh lf it mw b gy nj ng l nh ni">app.listen(3000);</span></pre><p id="6c6f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们显示<code class="fe mt mu mv mw b">foo</code>，因为我们将<code class="fe mt mu mv mw b">res.locals.foo</code>设置为<code class="fe mt mu mv mw b">'foo'</code>，然后调用路由处理器。</p><h1 id="eeed" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">方法</h1><p id="60ed" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">响应对象有各种方法。</p><h2 id="520e" class="mh lf it bd lg mi mj dn lk mk ml dp lo kr mm mn ls kv mo mp lw kz mq mr ma ms bi translated">res.append(字段[，值])</h2><p id="eb6e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mt mu mv mw b">append</code>方法让我们将响应头附加到我们的响应上。</p><p id="abc1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有以下代码:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="122f" class="mh lf it mw b gy nf ng l nh ni">const express = require('express')<br/>const app = express()</span><span id="0d82" class="mh lf it mw b gy nj ng l nh ni">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="5ed2" class="mh lf it mw b gy nj ng l nh ni">app.get('/', (req, res) =&gt; {<br/>  res.append('Link', ['&lt;<a class="ae kf" href="http://localhost/" rel="noopener ugc nofollow" target="_blank">http://localhost/</a>&gt;', '&lt;<a class="ae kf" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/</a>&gt;'])<br/>  res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly')<br/>  res.append('Warning', 'Alert')<br/>  res.send();<br/>})</span><span id="3864" class="mh lf it mw b gy nj ng l nh ni">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="6d5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们转到Postman时，当我们查看数据时，应该会在响应的Headers选项卡中看到相同的数据。</p><p id="4d45" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，我们必须运行<code class="fe mt mu mv mw b">res.send()</code>来实际发送响应。</p><h2 id="d866" class="mh lf it bd lg mi mj dn lk mk ml dp lo kr mm mn ls kv mo mp lw kz mq mr ma ms bi translated">RES . attachment([文件名])</h2><p id="d0b3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mt mu mv mw b">res.attachment</code>让我们为响应添加一个文件。它不发送响应。</p><p id="7166" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="a10e" class="mh lf it mw b gy nf ng l nh ni">const express = require('express')<br/>const app = express()</span><span id="2130" class="mh lf it mw b gy nj ng l nh ni">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="f49d" class="mh lf it mw b gy nj ng l nh ni">app.get('/', (req, res) =&gt; {<br/>  res.attachment('../public/foo.txt');<br/>  res.send();<br/>})</span><span id="bff9" class="mh lf it mw b gy nj ng l nh ni">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="3494" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，如果我们在<code class="fe mt mu mv mw b">public</code>文件夹中有一个<code class="fe mt mu mv mw b">foo.txt</code>，那么如果我们请求路由，该文件将被下载。</p><p id="2dfb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，我们再次使用<code class="fe mt mu mv mw b">res.send()</code>来实际发送响应。</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/4d0dbb6fa7c8207c1768a8b53557980b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wosRU2sRkE0-iVRs"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@picoftasty?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">梅姆</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="2a41" class="mh lf it bd lg mi mj dn lk mk ml dp lo kr mm mn ls kv mo mp lw kz mq mr ma ms bi translated">res.cookie(名称，值[，选项])</h2><p id="aa2d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">让我们给响应添加一个cookie。</p><p id="ff4f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在发送cookies之前，我们可以在<code class="fe mt mu mv mw b">options</code>对象中设置各种选项。它们如下:</p><ul class=""><li id="3b18" class="nl nm it ki b kj kk kn ko kr nn kv no kz np ld nq nr ns nt bi translated"><code class="fe mt mu mv mw b">domain</code>—cookie的域名字符串。默认为app的域名。</li><li id="3a4a" class="nl nm it ki b kj nu kn nv kr nw kv nx kz ny ld nq nr ns nt bi translated"><code class="fe mt mu mv mw b">encode</code> —用于cookie值编码的函数。默认为<code class="fe mt mu mv mw b">encodeURIComponent</code></li><li id="6511" class="nl nm it ki b kj nu kn nv kr nw kv nx kz ny ld nq nr ns nt bi translated"><code class="fe mt mu mv mw b">expires</code> —饼干在GMT的到期日。如果没有或者设置为0，则创建一个会话cookie</li><li id="e4d5" class="nl nm it ki b kj nu kn nv kr nw kv nx kz ny ld nq nr ns nt bi translated"><code class="fe mt mu mv mw b">httpOnly</code> —一个布尔标志，指示cookie是否只能由web服务器访问</li><li id="e47d" class="nl nm it ki b kj nu kn nv kr nw kv nx kz ny ld nq nr ns nt bi translated"><code class="fe mt mu mv mw b">maxAge</code> —用于设置相对于当前时间的到期时间的数字，单位为毫秒</li><li id="dce7" class="nl nm it ki b kj nu kn nv kr nw kv nx kz ny ld nq nr ns nt bi translated"><code class="fe mt mu mv mw b">path</code>—cookie路径的字符串。默认为<code class="fe mt mu mv mw b">/</code></li><li id="0823" class="nl nm it ki b kj nu kn nv kr nw kv nx kz ny ld nq nr ns nt bi translated"><code class="fe mt mu mv mw b">secure</code> — boolean标记仅用于HTTPS的cookie</li><li id="37e0" class="nl nm it ki b kj nu kn nv kr nw kv nx kz ny ld nq nr ns nt bi translated"><code class="fe mt mu mv mw b">signed</code> —布尔值，表示是否应对cookie进行签名</li><li id="7b47" class="nl nm it ki b kj nu kn nv kr nw kv nx kz ny ld nq nr ns nt bi translated"><code class="fe mt mu mv mw b">sameSite</code>—<code class="fe mt mu mv mw b">SameSite</code>Set-Cooke属性的布尔值或字符串值</li></ul><p id="7aa3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="c862" class="mh lf it mw b gy nf ng l nh ni">const express = require('express')<br/>const app = express()</span><span id="5e5b" class="mh lf it mw b gy nj ng l nh ni">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="0761" class="mh lf it mw b gy nj ng l nh ni">app.get('/', (req, res) =&gt; {<br/>  res.cookie('name', 'foo', { domain: 'repl.it', path: '/', secure: true })<br/>  res.send();<br/>})</span><span id="072a" class="mh lf it mw b gy nj ng l nh ni">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="7505" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们向客户端发送一个名为<code class="fe mt mu mv mw b">foo</code>的cookie。我们可以在右上角的Cookies链接下签到Postman。</p><p id="4a35" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在一个响应中发送多个cookies，如下所示:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="c971" class="mh lf it mw b gy nf ng l nh ni">const express = require('express')<br/>const app = express()<br/>app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="b653" class="mh lf it mw b gy nj ng l nh ni">app.get('/', (req, res) =&gt; {<br/>  res<br/>    .cookie('name', 'foo', { domain: 'repl.it', path: '/', secure: true })<br/>    .cookie('age', 10)<br/>    .send();<br/>})<br/>app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="aa89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以设置<code class="fe mt mu mv mw b">encode</code>选项来选择编码cookie的函数。例如，我们可以如下使用它:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="0cd6" class="mh lf it mw b gy nf ng l nh ni">const express = require('express')<br/>const app = express()<br/>app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="c11c" class="mh lf it mw b gy nj ng l nh ni">app.get('/', (req, res) =&gt; {<br/>  res<br/>    .cookie('name', 'foo', { encode: String })<br/>    .cookie('age', 10, { encode: Number })<br/>    .send();<br/>})<br/>app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="1c89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以如下设置<code class="fe mt mu mv mw b">httpOnly</code>标志:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="4fce" class="mh lf it mw b gy nf ng l nh ni">const express = require('express')<br/>const app = express()<br/>app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="6de8" class="mh lf it mw b gy nj ng l nh ni">app.get('/', (req, res) =&gt; {<br/>  res<br/>    .cookie('httpOnly', true, { httpOnly: true })<br/>    .send();<br/>})<br/>app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="1fa3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在像Postman这样的HTTP客户端中看到结果，响应中的cookie列在cookie部分。</p><h2 id="105c" class="mh lf it bd lg mi mj dn lk mk ml dp lo kr mm mn ls kv mo mp lw kz mq mr ma ms bi translated">res.clearCookie(名称[，选项])</h2><p id="9a4f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mt mu mv mw b">clearCookie</code>用给定的<code class="fe mt mu mv mw b">name</code>清除cookie。</p><p id="ac53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="448d" class="mh lf it mw b gy nf ng l nh ni">const express = require('express')<br/>const app = express()<br/>app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="5d90" class="mh lf it mw b gy nj ng l nh ni">app.get('/', (req, res) =&gt; {<br/>  res<br/>    .clearCookie('httpOnly', { path: '/' })<br/>    .send();<br/>})<br/>app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="c452" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，如果设置了<code class="fe mt mu mv mw b">httpOnly</code> cookie，它将在向<code class="fe mt mu mv mw b">/</code>发出请求后被清除。我们可以在cookies选项卡中通过Postman检查这一点。</p><h1 id="0abc" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="175c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用响应对象的属性和方法向客户端发送各种信息。</p><p id="ab96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用它用<code class="fe mt mu mv mw b">cookies</code>方法设置cookies，用<code class="fe mt mu mv mw b">clearCookies</code>方法清除它们。</p><p id="52d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mt mu mv mw b">cookies</code>方法采用了通常可用于cookies的各种选项。</p><p id="29e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe mt mu mv mw b">append</code>向响应添加各种响应头。</p><p id="36eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mt mu mv mw b">attachment</code>方法可以用来发送文件响应。</p></div></div>    
</body>
</html>