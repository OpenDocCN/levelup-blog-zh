<html>
<head>
<title>Scaling Microservices with gRPC and Envoy Proxy — Part I— with gRPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用gRPC和Envoy代理扩展微服务—第一部分—使用gRPC</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scaling-microservices-with-grpc-and-envoy-72a64fc5bbb6?source=collection_archive---------2-----------------------#2020-05-01">https://levelup.gitconnected.com/scaling-microservices-with-grpc-and-envoy-72a64fc5bbb6?source=collection_archive---------2-----------------------#2020-05-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2fb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你做过最终变得太大而无法处理的整体系统吗？您的组织是否倾向于将这样的大型整体系统分解为微服务架构风格？如果你还没有，那么也许你应该。虽然旅程并不容易，但绝对值得。原因如下。</p><h1 id="6ae9" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">微服务</h1><p id="db0a" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">微服务是一种软件开发技术——面向服务的架构(SOA)结构风格的变体——它将应用程序安排为松散耦合的、可单独部署的服务的集合。</p><p id="86f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它们提供了以下好处:<br/> <strong class="jp ir">模块化<br/> </strong>使得应用程序更容易理解、开发、测试，并且对架构侵蚀更有弹性。<br/> <strong class="jp ir">可扩展性<br/> </strong>由于微服务是彼此独立实现和部署的，因此可以独立地对它们进行监控和扩展。<br/> <strong class="jp ir">分布式开发<br/> </strong>它通过支持小型自治团队独立开发、部署和扩展他们各自的服务来实现开发的并行化。</p><p id="2ecf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在想象一下，你正在任何叫车应用程序上预订一辆车。如果应用程序提供不同类型的车辆，您将选择一个更好的车辆，然后分别输入您的接送位置，选择您的付款方式，确认您的预订，并等待分配的司机来接您。</p><p id="63bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们将处理上述请求的后端服务称为预订订单管理系统。如果这个后端是使用微服务架构风格构建的，它可能会有以下微服务，每一个服务于不同的目的。</p><ol class=""><li id="ba9f" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">一个根据用户的当前位置向用户显示可用的交通方式。</li><li id="a949" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">一个显示可供用户选择的支付方式。</li><li id="d3bf" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">一个用于在用户下订单后验证用户的真实性。</li><li id="1a9f" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">一个用于处理预订请求，并将司机与用户匹配。</li></ol><p id="c4e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它可以包含更多具有规模的微服务，但上面的示例应该让您对微服务架构风格有所了解。</p><h1 id="0d30" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">网络延迟</h1><p id="b2f9" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">网络延迟是一个术语，用来表示网络数据通信中发生的任何类型的延迟。在monolith系统的情况下，网络延迟是客户端请求到达服务器和服务器的响应到达客户端的时间延迟。然而，在微服务架构中，不同的微服务可以提供不同的功能，每个微服务部署在不同的节点上。因此，单个流(比如预订创建)可能有多个服务依赖项，每个依赖项都会产生自己的网络延迟成本。</p><p id="992a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请求和响应的字节越大，通过网络传输数据的网络延迟就越大。gRPC有助于减少网络延迟，但是在我分享如何减少延迟之前，让我先分享一些关于HTTP 1.1和HTTP 2的背景知识。</p><h2 id="4797" class="mc km iq bd kn md me dn kr mf mg dp kv jy mh mi kz kc mj mk ld kg ml mm lh mn bi translated">HTTP 2相对于HTTP 1.1的优势</h2><p id="c3c8" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">HTTP 2是运行在TCP(第4层—传输层)协议之上的第7层(应用层)协议，TCP(第4层—传输层)协议运行在IP(第3层—网络层)协议之上。下面是HTTP 2相对于HTTP 1.1的一些优势。</p><ol class=""><li id="f899" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated"><strong class="jp ir">使用HTTP 2复用请求</strong></li></ol><p id="7c07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">HTTP 1.1的缺点之一是<strong class="jp ir">行头阻塞</strong>。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mo"><img src="../Images/071d0881d100313191f71cabde2c6434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nhI-5imZWT2G7Flz"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">HTTP 1.1行首阻塞和HTTP 2多路复用对响应时间的影响</figcaption></figure><p id="665f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑从客户端到服务器的单一网络连接，如上图所示。使用HTTP 1.1，客户端会被阻塞，直到它收到对其请求#1的响应，然后才能发送请求#2。您可以通过打开多个HTTP连接并发出并发请求来避免这种等待时间。但是，您可能会受到HTTP池大小或浏览器对并发连接数目的限制。</p><p id="5137" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一端的HTTP 2向服务器提供<strong class="jp ir">多路复用</strong>请求。<br/>如上图所示，客户端可以发送请求#2，而不必等待响应#1，因此，上述必须创建多个HTTP连接来进行并发调用的方法消失了。</p><p id="e554" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<strong class="jp ir">从客户端到服务器的数据包传输</strong></p><p id="45cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个请求/响应的网络延迟取决于传输的数据量。数据包越小，延迟越短。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ne"><img src="../Images/e3ed18557b0396bfafeb67e105ad4be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IXSl0fKCL094y7PH"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">使用HTTP 1.1和HTTP 2的数据包大小</figcaption></figure><p id="6e89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们考虑一个在客户机和服务器之间传输的XML文档。如上图所示，您可以看到HTTP纯文本格式的XML包含的字节数(69字节)比二进制格式的字节数(57字节)多。这意味着二进制格式产生的网络延迟较少。</p><p id="e77b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是57字节仍然很高。也许我们可以进一步减少它？如果你想知道如何在<strong class="jp ir"> Protobuf </strong>中找到答案。使用Protobuf，您可以实现更小的数据大小，只有28个字节。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ne"><img src="../Images/92863d7bdc01aa7661e1f73a63e36e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Dtt2BsOTHpNLdLZg"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">使用协议缓冲区的数据包大小</figcaption></figure><h2 id="597c" class="mc km iq bd kn md me dn kr mf mg dp kv jy mh mi kz kc mj mk ld kg ml mm lh mn bi translated">协议缓冲区</h2><p id="b452" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">协议缓冲区(ProtoBuf)是一种灵活、高效、自动化的结构化数据序列化机制——想想XML，但是更小、更快、更简单。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/41680c8d5bff87b4220ce3ae5faabb94.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/0*3MZFDz5tsFF3SiYU"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">人.原型</figcaption></figure><p id="170b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以通过在中定义Protobuf消息类型来指定您希望序列化的信息的结构。原型文件。每个Protobuf消息都是一个小的信息逻辑记录，包含一系列名称-值对。下面是一个. proto文件的例子，它定义了一条包含个人信息的消息。</p><p id="3ad0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦定义了消息，您就可以在上运行适用于您的应用程序语言的Protobuf编译器。生成数据访问类的原型文件。这些为每个字段提供了简单的访问器(如<em class="ng"> name() </em>和<em class="ng"> set_name() </em>)，以及将整个结构序列化/解析为原始字节/从原始字节解析整个结构的方法。例如，如果您选择的语言是C++，运行上面例子中的编译器将生成一个名为<strong class="jp ir"> Person </strong>的类，通过编写如下代码，您可以使用该类在您的应用程序中填充、序列化和检索Person协议缓冲区消息:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nh"><img src="../Images/6f67141d3df8a9a46a12860e44b52512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bKD-Gv5x4eDQQqvh"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">使用从Person.proto生成的Person类的示例应用程序</figcaption></figure><h2 id="0da3" class="mc km iq bd kn md me dn kr mf mg dp kv jy mh mi kz kc mj mk ld kg ml mm lh mn bi translated">gRPC</h2><p id="15a9" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated"><strong class="jp ir">通用远程过程调用</strong>或简称为<strong class="jp ir"> gRPC </strong>是在HTTP2之上实现的现代RPC协议。与传统的HTTP/REST/JSON机制相比，gRPC有很多优势，比如</p><ol class=""><li id="685c" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">二元协议(HTTP/2)</li><li id="d364" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">在一个连接上多路复用多个请求(HTTP/2)</li><li id="bd3b" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">标题压缩(HTTP/2)</li><li id="49b7" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">强类型服务和消息定义(Protobuf)</li><li id="0e1c" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">许多语言中惯用的客户机/服务器库实现</li></ol><ul class=""><li id="e27e" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk ni lu lv lw bi translated">在gRPC中，客户端应用程序可以直接调用不同机器上的服务器应用程序上的方法，就像它是本地对象一样，这使得您可以更容易地创建分布式应用程序和服务。</li><li id="880c" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk ni lu lv lw bi translated">gRPC基于定义服务的思想，指定可以用参数和返回类型远程调用的方法。在服务器端，服务器实现这个接口，并运行一个gRPC服务器来处理客户端调用。在客户端，客户机有一个存根(客户机),它提供与服务器相同的方法。</li><li id="273c" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk ni lu lv lw bi translated">使用Protobuf编译器，您可以从服务定义自动生成存根。原型文件)的任何gRPC支持的语言。</li></ul><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nj"><img src="../Images/8ad53c6f44e5e42f36da6cb4b8ac7b2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2bfDO7j1jyIHHqSe"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated"><a class="ae nk" href="https://grpc.io/docs/what-is-grpc/introduction/" rel="noopener ugc nofollow" target="_blank"> gRPC架构</a></figcaption></figure><p id="c89c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">借助gRPC，您可以降低网络延迟，从而在更短的时间内满足更多的请求。但这带来了另一个问题。现在，服务器每分钟需要处理比以前更多的请求。为了避免现有服务器过载，我们可以引入更多的服务器来分担负载。但是不均衡的负载分布仍然会导致少数服务器被过度利用，少数服务器被利用不足。这时，您可能会引入负载平衡器。</p><p id="4efc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇博文的第2部分<a class="ae nk" href="https://medium.com/@nagaraj.kamalashree/scaling-microservices-with-grpc-and-envoy-proxy-part-2-148f589b2a83" rel="noopener">中，我将讨论负载平衡和特使代理。</a></p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="d076" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[1]协议缓冲器—<a class="ae nk" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank">https://developers.google.com/protocol-buffers</a></p><p id="adcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[2] gRPC负载均衡—<a class="ae nk" href="https://grpc.io/blog/grpc-load-balancing/#why-grpc" rel="noopener ugc nofollow" target="_blank">https://grpc.io/blog/grpc-load-balancing/#why-grpc</a></p><h1 id="f237" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">参考</h1><div class="ns nt gp gr nu nv"><a href="https://grpc.io/blog/grpc-load-balancing/" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">gRPC负载平衡</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">这篇文章描述了部署gRPC时看到的各种负载平衡场景。如果您使用gRPC和多个后端…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">grpc.io</p></div></div><div class="oe l"><div class="of l og oh oi oe oj my nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a href="https://grpc.io/docs/guides/" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">指导</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">本文向您介绍gRPC和协议缓冲区。gRPC可以使用协议缓冲区作为其接口…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">grpc.io</p></div></div><div class="oe l"><div class="ok l og oh oi oe oj my nv"/></div></div></a></div></div></div>    
</body>
</html>