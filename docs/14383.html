<html>
<head>
<title>All about git stash</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于git stash的一切</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/all-about-git-stash-8a9460fdc01e?source=collection_archive---------7-----------------------#2022-11-21">https://levelup.gitconnected.com/all-about-git-stash-8a9460fdc01e?source=collection_archive---------7-----------------------#2022-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="43d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个简单易懂的分步指南来理解git stash</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/19f1a4474fc4c8b79d07fa2c350f6c17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LOzYDcYiqSI4zG13"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/ja/@yancymin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">扬西·敏</a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1de2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> Git </a>是一个人必备的技能之一。很好地掌握Git的概念不仅可以帮助您有效地管理您的变更，还可以提高整体的生产力和工作流。本文旨在介绍许多有用的git命令之一，即<a class="ae lb" href="https://git-scm.com/docs/git-stash" rel="noopener ugc nofollow" target="_blank"> git stash </a>。</p><p id="3dc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我个人在从事各种项目时发现它非常有用。</p><p id="5f4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">话虽如此，让我们开始吧！</p><h1 id="1823" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">方案</h1><p id="c4b4" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">你有没有发现自己处于这样一个位置</p><ul class=""><li id="d85c" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">在错误的分支中进行了更改，但尚未提交它们？现在您希望以某种方式将这些变化转移到您选择的分支？</li><li id="f7b8" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">正在实施尚未完成的新变革，但由于新任务的优先级较高，您不得不紧急接受它？</li><li id="062b" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">因为这样或那样的原因，想要一个干净的工作树，但又不想放弃你的改变？</li><li id="014d" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">只是希望保存您未提交的更改以便将来查看？</li></ul><p id="dcc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么不要担心，因为<a class="ae lb" href="https://git-scm.com/docs/git-stash" rel="noopener ugc nofollow" target="_blank"> git stash </a>就是你所需要的！</p><h1 id="7902" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">什么是git stash？</h1><p id="d47c" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">它是一个命令，允许您将未提交的更改保存在类似数据结构的堆栈中。然后，您可以在需要时将这些更改应用回您的工作树。</p><p id="846a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这允许一个灵活的工作流程，同时同时处理几个任务。</p><h1 id="34e7" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">要记住的命令</h1><p id="f78b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">下一节包含与隐藏相关的各种命令以及与它们相关的细节</p><h2 id="31a1" class="mt ld iq bd le mu mv dn li mw mx dp lm jy my mz lq kc na nb lu kg nc nd ly ne bi translated">1.列出所有的藏匿点</h2><pre class="km kn ko kp gt nf ng nh bn ni nj bi"><span id="46bd" class="nk ld iq ng b be nl nm l nn no">git stash list</span></pre><p id="e6fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据你是否有什么东西，它会给出以下两个输出中的一个</p><ul class=""><li id="8cc6" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">空行:无库存</li><li id="cebc" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">索引中的存储列表:一个或多个存储</li></ul><p id="c5a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更多关于如何阅读这个列表的信息，请见下一节。</p><h2 id="095c" class="mt ld iq bd le mu mv dn li mw mx dp lm jy my mz lq kc na nb lu kg nc nd ly ne bi translated">2.将更改保存到存储</h2><p id="fc7f" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">考虑以下场景，其中您可能有两种更改，即</p><ul class=""><li id="ea66" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">跟踪文件中的更改</li><li id="2c56" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">未跟踪文件中的更改</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi np"><img src="../Images/01ac8bc694a842dbd2e1e24827acd13a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h75O89cQe7VvKvxzVISwvQ.png"/></div></div></figure><p id="cf64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要保存更改，只需输入</p><pre class="km kn ko kp gt nf ng nh bn ni nj bi"><span id="1abb" class="nk ld iq ng b be nl nm l nn no">git stash</span></pre><p id="33d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这创建了下面的stash并回滚到HEAD工作树。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/8c6caf9a1775d87ae30ab9bc3ad8d538.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*plhivrUx08OT_4vPSO1W6Q.png"/></div></figure><p id="c632" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，花括号中的数字表示该特定存储的索引。在这种情况下，由于stash堆栈为空，因此它出现在堆栈的顶部<strong class="jp ir">，即索引0 </strong>。当新的变更被保存到stash中时，先前变更的索引会不断增加。就像堆栈(FIFO)一样，堆栈的顶部是索引0。</p><p id="1d87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“<strong class="jp ir">在干管上的WIP</strong>”表示在干管分支上正在进行的工作</p><p id="8380" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并且<strong class="jp ir"> eeefba5 </strong>和<strong class="jp ir">提交2，</strong>分别是前一次提交的ID和消息。</p><p id="0fff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，总而言之，通用格式应该是这样的</p><pre class="km kn ko kp gt nf ng nh bn ni nj bi"><span id="41c7" class="nk ld iq ng b be nl nm l nn no">stash@{&lt;index of stash&gt;}: WIP on &lt;branch name&gt;: &lt;SHA-1 hash of the commit&gt; &lt;commit message of the last commit&gt;</span></pre><p id="01f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题1 </strong></p><p id="b0f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，未跟踪文件中引入的更改不会被隐藏。因此，要将这些包含在stash中，必须使用<code class="fe nr ns nt ng b">--include-untracked</code>标志。这将把未跟踪的变更和跟踪的变更一起保存在存储中。</p><pre class="km kn ko kp gt nf ng nh bn ni nj bi"><span id="44c4" class="nk ld iq ng b be nl nm l nn no">git stash --include-untracked</span></pre><p id="5c95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题二</strong></p><p id="250a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑我们在工作树中做了另一个改变，并把它藏起来。这将导致<code class="fe nr ns nt ng b">stash</code>看起来像这样</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nu"><img src="../Images/cd6519810d9f12529acd5a75175d83cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DtFGjDYgrWBD1xEHIA2Xdw.png"/></div></div></figure><p id="94af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所看到的，它们在表面上看起来是一样的。这使得某人很难识别哪些变更与哪个隐藏的项目相关联。人们必须研究实际的变化，以确定应用哪个存储。</p><p id="4458" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，向隐藏的项目添加有意义的消息，而不是保留默认消息，证明是有帮助的。要提供自定义消息，请使用以下命令</p><pre class="km kn ko kp gt nf ng nh bn ni nj bi"><span id="6b7b" class="nk ld iq ng b be nl nm l nn no">git stash push -m "test message" --include-untracked</span></pre><p id="302d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将导致我们的存储看起来像这样，而不是我们之前没有任何自定义消息</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nv"><img src="../Images/f6434404ec8754690b6e4209929b9a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FUcHLUQILT0VI2jctsCYwA.png"/></div></div></figure><p id="51cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">重要注意事项</strong></p><ul class=""><li id="9525" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">命令<code class="fe nr ns nt ng b">git stash save</code>在Git的<a class="ae lb" href="https://github.com/git/git/blob/master/Documentation/RelNotes/2.16.0.txt#L34" rel="noopener ugc nofollow" target="_blank"> 2.16.0版本</a>中被正式否决。因此，我不会在这篇文章中讨论这个问题。一个很好的参考是stackoverflow上的<a class="ae lb" href="https://stackoverflow.com/a/71040797/11597114" rel="noopener ugc nofollow" target="_blank"> this </a>和<a class="ae lb" href="https://stackoverflow.com/a/44681952/11597114" rel="noopener ugc nofollow" target="_blank"> this </a>答案。</li></ul><p id="f8d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">命令<code class="fe nr ns nt ng b">git stash create</code>和<code class="fe nr ns nt ng b">git stash store</code>已经被</p><h2 id="7a97" class="mt ld iq bd le mu mv dn li mw mx dp lm jy my mz lq kc na nb lu kg nc nd ly ne bi translated">3.将更改应用到工作树</h2><p id="7925" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">既然我们已经将更改保存在我们的存储中，我们可能希望将它们应用到正确的位置。为此，只需键入</p><pre class="km kn ko kp gt nf ng nh bn ni nj bi"><span id="1f6a" class="nk ld iq ng b be nl nm l nn no">git stash pop</span></pre><p id="75a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于这个命令的行为，需要注意一些事情</p><ul class=""><li id="e3b8" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">这将应用堆栈顶部的已保存更改，即堆栈的索引0</li><li id="13bb" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">这将从存储中删除那些更改。因此将所有其他保存的改变的索引分别减1。</li></ul><p id="5e5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想应用一个存在于第n个索引的改变，那么使用下面的命令</p><pre class="km kn ko kp gt nf ng nh bn ni nj bi"><span id="d7b7" class="nk ld iq ng b be nl nm l nn no">git stash apply stash@{N}</span></pre><p id="7af3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中<strong class="jp ir"> N </strong>是您希望应用的已保存更改的索引。关于这个命令需要注意的一点是，它不会删除保存的存储。</p><p id="508f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">补充说明</p><pre class="km kn ko kp gt nf ng nh bn ni nj bi"><span id="5291" class="nk ld iq ng b be nl nm l nn no">git stash branch &lt;branchname&gt; stash@{N}</span></pre><p id="3544" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从最初创建<code class="fe nr ns nt ng b">&lt;stash&gt;</code>的提交开始，创建并检查一个名为<code class="fe nr ns nt ng b">&lt;branchname&gt;</code>的新分支，将<code class="fe nr ns nt ng b">&lt;stash&gt;</code>中记录的更改应用到新的工作树和索引。如果成功，并且<code class="fe nr ns nt ng b">&lt;stash&gt;</code>是表单<code class="fe nr ns nt ng b">stash@{&lt;revision&gt;}</code>的引用，那么它就丢弃<code class="fe nr ns nt ng b">&lt;stash&gt;</code>。更多信息请点击<a class="ae lb" href="https://git-scm.com/docs/git-stash#Documentation/git-stash.txt-branchltbranchnamegtltstashgt" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="7512" class="mt ld iq bd le mu mv dn li mw mx dp lm jy my mz lq kc na nb lu kg nc nd ly ne bi translated">4.从存储中删除保存的更改</h2><p id="5abc" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">如果您觉得存储中某个保存的更改没有用，并且希望删除它，您可以使用以下命令</p><pre class="km kn ko kp gt nf ng nh bn ni nj bi"><span id="1c6e" class="nk ld iq ng b be nl nm l nn no">git stash drop stash@{N}</span></pre><p id="b5fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中<strong class="jp ir"> N </strong>是您希望从存储中删除的已保存更改的索引。</p><p id="2d05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您希望删除所有保存的更改并清空存储，请使用以下命令</p><pre class="km kn ko kp gt nf ng nh bn ni nj bi"><span id="6a71" class="nk ld iq ng b be nl nm l nn no">git stash clear</span></pre><h1 id="48b1" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">额外参考和阅读</h1><ol class=""><li id="a179" class="mf mg iq jp b jq ma ju mb jy nw kc nx kg ny kk nz ml mm mn bi translated"><a class="ae lb" href="https://stackoverflow.com/a/57008221/11597114" rel="noopener ugc nofollow" target="_blank">git stash save<em class="oa">和<em class="oa"> git stash store </em> </em></a>的区别</li><li id="271d" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk nz ml mm mn bi translated"><a class="ae lb" href="https://stackoverflow.com/questions/28635989/what-is-the-purpose-of-git-stash-create-and-git-stash-store" rel="noopener ugc nofollow" target="_blank">目的<em class="oa"> git stash创建</em>和<em class="oa"> git stash store </em> </a></li><li id="5507" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk nz ml mm mn bi translated"><a class="ae lb" href="https://stackoverflow.com/questions/44680028/whats-the-difference-between-git-stash-save-and-git-stash-push" rel="noopener ugc nofollow" target="_blank">区别<em class="oa"> git stash save </em>和<em class="oa"> git stash push </em> </a></li></ol></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><p id="435d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望我能够通过这篇文章提供至少一条有用的信息。如果你想让我介绍任何其他有用的<a class="ae lb" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> Git </a>命令，这超出了基础知识的范畴，请随意在评论中留下名字。</p></div></div>    
</body>
</html>