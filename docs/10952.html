<html>
<head>
<title>Passing Parameters to a .NET C# Method</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将参数传递给. NET C#方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/passing-parameters-to-a-net-c-method-388badb7c095?source=collection_archive---------3-----------------------#2022-01-31">https://levelup.gitconnected.com/passing-parameters-to-a-net-c-method-388badb7c095?source=collection_archive---------3-----------------------#2022-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="054e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">回归基础</h2><div class=""/><div class=""><h2 id="bd42" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">向. NET C#方法传递参数的不同方式。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/9bb22d816498e147533c4b6407855a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0cTQd03_0KqZTTXs4CdsbQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@benwhitephotography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">本·怀特</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>调整</figcaption></figure><p id="1740" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这篇文章主要是关于定义传递一个参数给一个<strong class="lk jd">的方法。NET C# </strong>方法，同时调用它。简单来说，就是关于著名的<code class="fe me mf mg mh b">Ref</code>和<code class="fe me mf mg mh b">Val</code>的事情。</p><p id="aab7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我知道，我知道。你可能会说:</p><blockquote class="mi mj mk"><p id="afee" class="li lj ml lk b ll lm kd ln lo lp kg lq mm ls lt lu mn lw lx ly mo ma mb mc md im bi translated">这是每个<strong class="lk jd">都有的一个太基础的东西。NET C# </strong>开发者都知道。真的需要解释成一整篇文章吗？！！！</p></blockquote><p id="45aa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你这个问题的简短回答是:<strong class="lk jd">是的</strong>。我知道这看起来像你说的那样太简单了，但是我有我的理由。</p><p id="8be5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在软件中，有很多基础知识需要学习，不幸的是，在花哨的框架和库的时代，年轻的开发人员往往会跳过这些基础知识，直接学习这些花哨的框架。</p><p id="1e97" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">他们中的一些人可能知道基本规则，但他们不知道背后的故事或科学。这真的重要吗？是的，大多数时候这很重要。</p><p id="622a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，有一种事情你需要彻底地观察至少一次，然后你就可以知道你做了它来过你的生活。这个题目就是其中之一。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mp"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><div class="mq mr gp gr ms mt"><a href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener follow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd jd gy z fp my fr fs mz fu fw jc bi translated">🔥订阅艾哈迈德的时事通讯🔥</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">订阅艾哈迈德的时事通讯📰直接获得最佳实践、教程、提示、技巧和许多其他很酷的东西…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">medium.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh lb mt"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ni"><img src="../Images/8af90ebf768a79a260acc698c8ead2c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xtbLIfJ6KELkGYeVCnzSFg.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@mattartz?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马特·阿特兹</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔雷克</a>调整</figcaption></figure><h1 id="33af" class="nj nk it bd nl nm nn no np nq nr ns nt ki nu kj nv kl nw km nx ko ny kp nz oa bi translated">关键因素</h1><p id="691c" class="pw-post-body-paragraph li lj it lk b ll ob kd ln lo oc kg lq lr od lt lu lv oe lx ly lz of mb mc md im bi translated">当我们试图理解一个参数如何被发送到一个<strong class="lk jd">时，有两个因素需要记住。NET C# </strong>方法。</p><p id="2194" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些因素是:</p><ol class=""><li id="e331" class="og oh it lk b ll lm lo lp lr oi lv oj lz ok md ol om on oo bi translated">参数类型<br/>值<br/>参考</li><li id="e134" class="og oh it lk b ll op lo oq lr or lv os lz ot md ol om on oo bi translated">参数<br/>传值方式<br/>引用方式</li></ol><p id="4b6d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，现在很明显，我们将有4种组合:</p><ol class=""><li id="9d5e" class="og oh it lk b ll lm lo lp lr oi lv oj lz ok md ol om on oo bi translated">逐值</li><li id="f7e9" class="og oh it lk b ll op lo oq lr or lv os lz ot md ol om on oo bi translated">参考值</li><li id="9570" class="og oh it lk b ll op lo oq lr or lv os lz ot md ol om on oo bi translated">按值引用</li><li id="3a6d" class="og oh it lk b ll op lo oq lr or lv os lz ot md ol om on oo bi translated">引用引用</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ou"><img src="../Images/1d8fa42c23728891d6978ac5b086caed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ty1-fSi-YDO1Gnu-Sc0IYg.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@jeremybezanger?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杰瑞米·贝赞格</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔雷克</a>调整</figcaption></figure><h1 id="91dd" class="nj nk it bd nl nm nn no np nq nr ns nt ki nu kj nv kl nw km nx ko ny kp nz oa bi translated">不同的类型如何储存在记忆中？</h1><p id="1257" class="pw-post-body-paragraph li lj it lk b ll ob kd ln lo oc kg lq lr od lt lu lv oe lx ly lz of mb mc md im bi translated">正如我们所说，我们有两种类型的参数；<strong class="lk jd">值</strong>和<strong class="lk jd">参考值</strong>。你需要知道的是，这两种类型在内存中的保存方式是不一样的。</p><p id="6de7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简而言之，我们有两种类型的内存:堆栈</p></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><p id="5a4c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi pc translated"><span class="l pd pe pf bm pg ph pi pj pk di"> N </span>注:解释<strong class="lk jd">栈</strong>和<strong class="lk jd">堆</strong>的每一个微小细节都超出了本文的范围。这就是为什么我们只总结和关注本文主要范围所需的一小部分。</p></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><h2 id="96c4" class="pl nk it bd nl pm pn dn np po pp dp nt lr pq pr nv lv ps pt nx lz pu pv nz iz bi translated">堆栈</h2><p id="14d9" class="pw-post-body-paragraph li lj it lk b ll ob kd ln lo oc kg lq lr od lt lu lv oe lx ly lz of mb mc md im bi translated">堆栈<strong class="lk jd">是存储<strong class="lk jd">值</strong>类型的地方。另外，<strong class="lk jd">引用</strong>类型(存储在堆中)的<strong class="lk jd">地址(堆内存位置)</strong>存储在<strong class="lk jd">栈</strong>中。</strong></p><p id="b8ee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，如果我们有:</p><pre class="ks kt ku kv gt pw mh px py aw pz bi"><span id="3254" class="pl nk it mh b gy qa qb l qc qd">int x = 1;</span></pre><p id="bce4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将存储在堆栈中，如下所示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/648b804c26e591b9e3676f0f7394fef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*LYRR7ahQr9s_cqe4-hZ1HQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nl">堆栈中存储的整数x</strong>。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><h2 id="0259" class="pl nk it bd nl pm pn dn np po pp dp nt lr pq pr nv lv ps pt nx lz pu pv nz iz bi translated">垃圾堆</h2><p id="6d17" class="pw-post-body-paragraph li lj it lk b ll ob kd ln lo oc kg lq lr od lt lu lv oe lx ly lz of mb mc md im bi translated"><strong class="lk jd">堆</strong>是存储<strong class="lk jd">引用</strong>类型的地方。</p><p id="091f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以如果我们有:</p><pre class="ks kt ku kv gt pw mh px py aw pz bi"><span id="57ec" class="pl nk it mh b gy qa qb l qc qd">Employee x = new Employee();</span></pre><p id="e87d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将存储在堆栈中，如下所示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qf"><img src="../Images/45b84ff70a5120a592213a1c583dcd33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OEIuOrj-o6oDHS5X5llCZA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nl">存储在堆栈中的雇员x(堆位置的地址)和堆(对象)</strong>。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qg"><img src="../Images/caeb9821fb2ed2d3526b7819c3546377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dnDtkZJLXL5yp8iuuwd1_g.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae lh" href="https://unsplash.com/@bel2000a?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Belinda Fewings </a>拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="8f8b" class="nj nk it bd nl nm nn no np nq nr ns nt ki nu kj nv kl nw km nx ko ny kp nz oa bi translated">通过值或引用传递参数是什么意思？</h1><p id="d10a" class="pw-post-body-paragraph li lj it lk b ll ob kd ln lo oc kg lq lr od lt lu lv oe lx ly lz of mb mc md im bi translated">这里有一条黄金法则要记住。简单有效。</p><h2 id="afc4" class="pl nk it bd nl pm pn dn np po pp dp nt lr pq pr nv lv ps pt nx lz pu pv nz iz bi translated">传值</h2><p id="dfc2" class="pw-post-body-paragraph li lj it lk b ll ob kd ln lo oc kg lq lr od lt lu lv oe lx ly lz of mb mc md im bi translated">意味着在运行时，原始参数的一个<strong class="lk jd">副本</strong>将被传递给该方法。</p><h2 id="0a26" class="pl nk it bd nl pm pn dn np po pp dp nt lr pq pr nv lv ps pt nx lz pu pv nz iz bi translated">传地址</h2><p id="6914" class="pw-post-body-paragraph li lj it lk b ll ob kd ln lo oc kg lq lr od lt lu lv oe lx ly lz of mb mc md im bi translated">意味着在运行时，传递给方法的原始参数将被传递给方法。</p><p id="95d5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有什么区别吗？当然，这也是我们将在本文的下一部分讨论的内容。</p><p id="3062" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">话虽如此，现在让我们来分析向<strong class="lk jd">传递参数的不同方式。NET C# </strong>方法。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/485195948b3fc8aa0ea9078cdb7de7e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e68MK9cBnwgpHULdstICjQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nl">逐个值</strong>，图像由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a></figcaption></figure><h1 id="7dc4" class="nj nk it bd nl nm nn no np nq nr ns nt ki nu kj nv kl nw km nx ko ny kp nz oa bi translated">逐值</h1><p id="cb31" class="pw-post-body-paragraph li lj it lk b ll ob kd ln lo oc kg lq lr od lt lu lv oe lx ly lz of mb mc md im bi translated">假设我们有:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qh qi l"/></div></figure><p id="a19c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如您所看到的，<code class="fe me mf mg mh b">ValByVal</code>方法:<br/>期望一个<code class="fe me mf mg mh b">int</code>作为输入参数，该参数是一个<strong class="lk jd">值</strong>类型<br/></p><p id="08cc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，可以保证<code class="fe me mf mg mh b">ValByVal</code>方法是<strong class="lk jd">逐值</strong>方法的候选方法。</p><p id="67a5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，回到代码，在执行完第5行之后，我们会在内存中有这个。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/648b804c26e591b9e3676f0f7394fef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*LYRR7ahQr9s_cqe4-hZ1HQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nl">堆栈中存储的整数x</strong>。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="1194" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<strong class="lk jd">第7行</strong>上，当调用<code class="fe me mf mg mh b">ValByVal</code>方法时，变量<strong class="lk jd"> x </strong>的副本将被隐式创建并传递给该方法。姑且称这个文案<strong class="lk jd">x’</strong>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/32689619467cd0a16e630de9dc8e81e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*7WP4t3J2JSPTvORy2m8onA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nl">堆栈</strong>中存储的整数x的副本。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="c4cc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，在第<strong class="lk jd">行第15 </strong>处，我们正在递增传入的参数，我们实际上是在递增<strong class="lk jd"> x' </strong>，而不是<strong class="lk jd"> x </strong>。</p><p id="ba2a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将留给我们这个:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qj"><img src="../Images/4f43eaee4ea3aa8abf9438837e88b45e.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*dslRKSrQg5qG-2kru7lMnQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nl">x’增加1并存储在堆栈</strong>中。图片来自<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a></figcaption></figure><p id="b9e4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这意味着当我们回到第8 行的<code class="fe me mf mg mh b">Main</code>方法时，<strong class="lk jd"> x </strong>的值仍然是<strong class="lk jd"> 1 </strong>。</p><p id="f9fd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">控制台上的结果如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qk"><img src="../Images/297e0c542b21ee499e37f5132b0d490a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lVfpTB6C_LFhDnj-0_o5jw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ql"><img src="../Images/2d77fc3d8eddb7a40b2971f4d502b9c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*znfcRE2UvTyq3c6Q1UEPMA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nl">参考值</strong>，图像由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>生成</figcaption></figure><h1 id="7b12" class="nj nk it bd nl nm nn no np nq nr ns nt ki nu kj nv kl nw km nx ko ny kp nz oa bi translated">参考值</h1><p id="a72b" class="pw-post-body-paragraph li lj it lk b ll ob kd ln lo oc kg lq lr od lt lu lv oe lx ly lz of mb mc md im bi translated">假设我们有:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qh qi l"/></div></figure><p id="c5d8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如您所见，<code class="fe me mf mg mh b">ValByRef</code>方法:<br/>\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" T7 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\</p><p id="416c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，通过引用方式保证<code class="fe me mf mg mh b">ValByRef</code>方法是<strong class="lk jd">值的候选。</strong></p><p id="8ab3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，回到代码，在执行完第5行之后，我们会在内存中有这个。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/648b804c26e591b9e3676f0f7394fef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*LYRR7ahQr9s_cqe4-hZ1HQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nl">堆栈中存储的整数x</strong>。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="637c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<strong class="lk jd">第7行</strong>上，当调用<code class="fe me mf mg mh b">ValByRef</code>方法时，原始变量<strong class="lk jd"> x </strong>将被传递给该方法。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/b62eab68f0674ba3dedcc69a7f18331b.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*zar0knjvymjOBlwEpQIHvw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">x '与x 相同。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="6ae6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，在第<strong class="lk jd">行第15 </strong>处，我们正在递增传入的参数，实际上我们正在递增<strong class="lk jd"> x </strong>。</p><p id="b37d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将留给我们这个:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qj"><img src="../Images/cd48af588c6121c8339de260876f8db5.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*c9ukOUvPzLQ34llB9NNUuw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nl"> x加1，存入堆栈</strong>。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="b536" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这意味着当我们回到第8 行的<strong class="lk jd">方法时，<strong class="lk jd"> x </strong>的值将会是<strong class="lk jd"> 2 </strong>。</strong></p><p id="0ff2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">控制台上的结果如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qm"><img src="../Images/17a140d69d9ef840ca3bfd001bdcc288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KNF1IG8LF1O1-1M4Qnt3EA.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/76bf4a1a74f589ee4c61b82695324243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PJxF9oYsZ3EOeWd4mlTxnA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nl">按值引用</strong>，图像由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a></figcaption></figure><h1 id="201f" class="nj nk it bd nl nm nn no np nq nr ns nt ki nu kj nv kl nw km nx ko ny kp nz oa bi translated">按值引用</h1><p id="e02a" class="pw-post-body-paragraph li lj it lk b ll ob kd ln lo oc kg lq lr od lt lu lv oe lx ly lz of mb mc md im bi translated">假设我们有:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qh qi l"/></div></figure><p id="c71d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如您所见，<code class="fe me mf mg mh b">RefByVal</code>方法:<br/>期望一个<code class="fe me mf mg mh b">Employee</code> <strong class="lk jd"> </strong>作为输入参数，它是一个<strong class="lk jd">引用</strong>类型<br/>发送的参数(参数类型前没有<code class="fe me mf mg mh b">ref</code></p><p id="6877" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，可以保证<code class="fe me mf mg mh b">RefByVal</code>方法是通过值方式引用<strong class="lk jd">的候选方法。</strong></p><p id="f153" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，回到代码，在执行完<strong class="lk jd">第10行</strong>之后，我们会在内存中有这个。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qf"><img src="../Images/cf03ae42eaa6f815c0d2d18a34a3ff4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*66pt_pDruUu79-FfM7ndqw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nl"> x正确存放在栈和堆中</strong>。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="48a1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<strong class="lk jd">第15 </strong>行，当调用<code class="fe me mf mg mh b">RefByVal</code>方法时，变量<strong class="lk jd"> x </strong>的副本将被隐式创建并传递给该方法。姑且称这个文案<strong class="lk jd">x’</strong>。</p><p id="514d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，这里值得一提的是，实际拷贝的，是<strong class="lk jd">栈</strong>中存储的<strong class="lk jd"> x </strong>的值。该值是<strong class="lk jd">堆</strong>中存储实际<strong class="lk jd">雇员</strong> <strong class="lk jd">对象</strong>的内存位置的地址。</p><p id="aa9c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们最终会得到这样的结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qf"><img src="../Images/e11e4bdf800e3d77d934444458279217.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s9wlDCEVAB_uvpHCq4An0g.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nl">x’从x复制并存储在堆栈</strong>中。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>提供</figcaption></figure><p id="ea37" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如您所见，<strong class="lk jd"> x' </strong>将保存与<strong class="lk jd">堆</strong>中存储实际<strong class="lk jd">员工X </strong>的内存位置相同的地址。这意味着<strong class="lk jd">x’</strong>也指的是同一个对象。</p><p id="5191" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，在第<strong class="lk jd">行第25 </strong>行，我们将雇员的名字更新为“Tarek ”,我们实际上是在更新最初传递给<code class="fe me mf mg mh b">RefByVal</code>方法的同一个对象<code class="fe me mf mg mh b">Employee ahmed</code>。</p><p id="b619" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，这导致了这样的结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qf"><img src="../Images/cc838caa3de2fd68aaf26582d0233b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n7jP0lZ5lSZzhSXp57DNsg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nl">员工ahmed更新为“Tarek”</strong>。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="42e0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，在<strong class="lk jd">第26 </strong>行，我们将<strong class="lk jd">x’</strong>自身设置为另一个新的<code class="fe me mf mg mh b">Employee</code>。这意味着一个新的<strong class="lk jd">雇员</strong>对象将被创建，存储在<strong class="lk jd">堆</strong>中，并且那个<strong class="lk jd">堆</strong>内存位置的地址将被存储在<strong class="lk jd">堆栈</strong>中的<strong class="lk jd">x’</strong>中。</p><p id="2cf9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，留给我们的是:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qf"><img src="../Images/e058fcaf37420bb84facfbb7f4bf0f25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zbLEGzmTw2Cqjc52f9368Q.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nl"> x = Tarek，x' = Hasan </strong>。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="712f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这意味着当我们回到第17 行的<code class="fe me mf mg mh b">Main</code>方法时，<code class="fe me mf mg mh b">Employee ahmed</code>的名字的值将是<strong class="lk jd"> Tarek </strong>。</p><p id="718a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">控制台上的结果如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qm"><img src="../Images/72ba8404f1c35c67f519af1cb0314b21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nRuRdnSuwwiNb1nonHqdnw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/93548338b24fcc57d01dc9d895a8ecf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wYrtKtA-9rlS0pWlAjX_TQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nl">引用引用</strong>，图像由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><h1 id="5e80" class="nj nk it bd nl nm nn no np nq nr ns nt ki nu kj nv kl nw km nx ko ny kp nz oa bi translated">引用引用</h1><p id="dd2d" class="pw-post-body-paragraph li lj it lk b ll ob kd ln lo oc kg lq lr od lt lu lv oe lx ly lz of mb mc md im bi translated">假设我们有:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qh qi l"/></div></figure><p id="e8a9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如您所看到的，<code class="fe me mf mg mh b">RefByRef</code>方法:<br/>期望一个<code class="fe me mf mg mh b">Employee</code>作为输入参数，它是一个<strong class="lk jd">引用</strong>类型<br/>。该参数期望由<strong class="lk jd">引用</strong>发送(在参数类型之前有一个<code class="fe me mf mg mh b">ref</code></p><p id="98da" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，可以保证<code class="fe me mf mg mh b">RefByRef</code>方法是<strong class="lk jd">通过引用</strong>方式引用的候选方法。</p><p id="ba43" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，回到代码，在执行完<strong class="lk jd">第10行</strong>之后，我们会在内存中有这个。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qf"><img src="../Images/cf03ae42eaa6f815c0d2d18a34a3ff4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*66pt_pDruUu79-FfM7ndqw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nl"> x正确存储在堆栈和堆中</strong>。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="3767" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<strong class="lk jd">第15行</strong>上，当调用<code class="fe me mf mg mh b">RefByRef</code>方法时，原始变量<strong class="lk jd"> x </strong>将被传递给该方法。</p><p id="8412" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们最终会得到这样的结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qf"><img src="../Images/8571629b3d07870147a3d703954fc7ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K1vWlw1vUkfG7x6vs0rzGA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nl">x’与x </strong>相同。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a></figcaption></figure><p id="1374" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，在第<strong class="lk jd">行第25 </strong>行，我们将雇员的名字更新为“Tarek ”,我们实际上是在更新原来传递给<code class="fe me mf mg mh b">RefByRef</code>方法的同一个对象<code class="fe me mf mg mh b">Employee ahmed</code>。</p><p id="e939" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，这导致了这样的结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qf"><img src="../Images/b42d04e23d7f9b5e4249dd0f98c415ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-tc6Zj4gRWNTLnG94Z7ltQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nl">员工ahmed更新为“Tarek”</strong>。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="737d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，在<strong class="lk jd">行26 </strong>上，我们将<strong class="lk jd">x’</strong>自身设置为另一个新的<code class="fe me mf mg mh b">Employee</code>。这意味着将创建一个新的<strong class="lk jd">雇员</strong>对象，存储在<strong class="lk jd">堆</strong>中，并且该<strong class="lk jd">堆</strong>内存位置的地址将存储在<strong class="lk jd">堆栈</strong>中的<strong class="lk jd">x’</strong>中。</p><p id="af05" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，<strong class="lk jd"> x' </strong>其实是<strong class="lk jd"> x </strong>。这意味着<strong class="lk jd"> x </strong>的地址也将被更新为新地址。</p><p id="bcdf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，留给我们的是:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qf"><img src="../Images/eb62862c06419a0c7b586cdd0ca94997.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yuzoAsDtN6MlMA6WhE8pKA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nl">x = x’=哈桑</strong>。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="3e0a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这意味着当我们回到第17行的<code class="fe me mf mg mh b">Main</code>方法时，<code class="fe me mf mg mh b">Employee ahmed</code>的名字的值将是<strong class="lk jd"> Hasan </strong>。</p><p id="bd1e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">控制台上的结果如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qm"><img src="../Images/16cdd087d54e46b09769679d3818491e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_bDSt6AlDL__GSegvpmkJQ.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qn"><img src="../Images/20ca78dc3120c31c859165c18c887c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MMfdvz7X9A0g7aRWwIvsNA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@peterampazzo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Pietro Rampazzo </a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="5192" class="nj nk it bd nl nm nn no np nq nr ns nt ki nu kj nv kl nw km nx ko ny kp nz oa bi translated">最后的想法</h1><p id="ca30" class="pw-post-body-paragraph li lj it lk b ll ob kd ln lo oc kg lq lr od lt lu lv oe lx ly lz of mb mc md im bi translated">我希望到现在为止，在调用<strong class="lk jd">时正在发生的事情背后的故事。NET C# </strong>方法时传入的参数是清晰的。</p><p id="b612" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你知道某人正开始他的<strong class="lk jd">之旅。NET C# </strong>开发者，也许你可以和他分享这篇文章。这将有助于他想象实际发生的事情。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mp"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="9c26" class="nj nk it bd nl nm nn no np nq nr ns nt ki nu kj nv kl nw km nx ko ny kp nz oa bi translated">希望这些内容对你有用。如果您想支持:</h1><p id="a7c8" class="pw-post-body-paragraph li lj it lk b ll ob kd ln lo oc kg lq lr od lt lu lv oe lx ly lz of mb mc md im bi translated">如果您还不是<strong class="lk jd">媒介</strong>的会员，您可以使用<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek/membership" rel="noopener"> <strong class="lk jd">我的推荐链接</strong> </a>，这样我可以从<strong class="lk jd">媒介</strong>中获得您的一部分费用，您无需支付任何额外费用。<br/>▎订阅<a class="ae lh" href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener"> <strong class="lk jd">我的简讯</strong> </a>将最佳实践、教程、提示、技巧和许多其他很酷的东西直接发送到您的收件箱。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mp"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="cd8c" class="nj nk it bd nl nm nn no np nq nr ns nt ki nu kj nv kl nw km nx ko ny kp nz oa bi translated">其他资源</h1><p id="6eb3" class="pw-post-body-paragraph li lj it lk b ll ob kd ln lo oc kg lq lr od lt lu lv oe lx ly lz of mb mc md im bi translated">这些是你可能会发现有用的其他资源。</p><div class="mq mr gp gr ms mt"><a rel="noopener  ugc nofollow" target="_blank" href="/protecting-public-methods-from-illogical-calls-in-net-c-91fcbb8bee33"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd jd gy z fp my fr fs mz fu fw jc bi translated">保护公共方法免受不合逻辑的调用。NET C#</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">包含代码示例和解释的完整指南。</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nc l"><div class="qo l ne nf ng nc nh lb mt"/></div></div></a></div><div class="mq mr gp gr ms mt"><a rel="noopener  ugc nofollow" target="_blank" href="/flagged-enumerations-how-to-represent-features-combinations-into-one-field-f32e46a0885"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd jd gy z fp my fr fs mz fu fw jc bi translated">标记枚举:如何在一个字段中表示特征组合</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">将[读、写、修改……]等功能及其组合表示到单个字段中。</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nc l"><div class="qp l ne nf ng nc nh lb mt"/></div></div></a></div><div class="mq mr gp gr ms mt"><a rel="noopener  ugc nofollow" target="_blank" href="/what-is-caching-in-software-systems-cfa71c385bfc"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd jd gy z fp my fr fs mz fu fw jc bi translated">什么是软件系统中的缓存</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">软件系统中缓存的定义和最佳实践。</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nc l"><div class="qq l ne nf ng nc nh lb mt"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mp"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure></div></div>    
</body>
</html>