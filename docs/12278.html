<html>
<head>
<title>Merge Sort — Top Down and Bottom Up for Arrays and Linked Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">合并排序—数组和链表的自上而下和自下而上排序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/sorting-algorithms-merge-sort-top-down-bottom-up-for-arrays-linked-lists-2426dcc39611?source=collection_archive---------2-----------------------#2022-05-29">https://levelup.gitconnected.com/sorting-algorithms-merge-sort-top-down-bottom-up-for-arrays-linked-lists-2426dcc39611?source=collection_archive---------2-----------------------#2022-05-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="6e09" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">合并排序是最有效和最流行的排序算法之一。它基于分而治之的方法，常用于计算机科学，实用，易于理解。我们将讨论实现细节，以及在使用合并排序时需要考虑和记住的最重要的事情。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/42270436ef08f362421533e3cdbf6733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WhQZF_SRJ41-ArehxsrZIA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">合并排序简介</figcaption></figure><h1 id="4319" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">内容</h1><ul class=""><li id="b6e7" class="mc md it js b jt me jx mf kb mg kf mh kj mi kn mj mk ml mm bi translated">什么是合并排序算法？</li><li id="6b59" class="mc md it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">合并两个排序后的数组。</li><li id="1192" class="mc md it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">合并排序是如何工作的？</li><li id="f225" class="mc md it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">让我们写一个算法并分析它(自上而下&amp;自下而上)</li><li id="838e" class="mc md it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">让我们看看它是如何处理链表的，而不仅仅是数组</li><li id="6680" class="mc md it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">常见问题解答</li><li id="2c1a" class="mc md it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">优势</li><li id="8b71" class="mc md it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">不足之处</li></ul></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="9399" class="le lf it bd lg lh mz lj lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb bi translated">什么是归并排序算法？</h1><p id="8a6c" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb ne kd ke kf nf kh ki kj ng kl km kn im bi translated">和<a class="ae nh" rel="noopener ugc nofollow" target="_blank" href="/sorting-algorithms-quick-sort-ed0fbbdd0d40">快速排序</a>一样，归并排序是一种分治算法。它将输入数组分成两半，这个拆分数组的过程一直持续到我们得到一个项目的更小的数组，然后合并过程从比较更小的拆分数组开始，并按照排序顺序将它们合并在一起，最后我们将得到一个排序后的数组。</p><h1 id="d1fa" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">合并两个排序的数组</h1><p id="242d" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb ne kd ke kf nf kh ki kj ng kl km kn im bi translated">在了解如何使用merge sort对数组进行排序之前，我们先了解一下如何将两个数组合并在一起的基本思路？</p><p id="4c1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们有两个排序数组arr 1:<em class="ni">【2，11，18，20，22】</em>&amp;【arr 2:<em class="ni">【4，9，19，25】</em>，为了合并它们，我们需要一个额外的数组来存放合并结果。</p><p id="2b27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们合并这两个排序后的数组的方法非常简单，只需比较最少的两个元素，并将最小的元素复制到第三个数组中。</p><p id="d033" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了把这分成几个步骤:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nj"><img src="../Images/7bd69ee40340724b10f41c7084b6a3c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uT7I4U6f56EobbTlPdBhRw.gif"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">合并两个排序的数组</figcaption></figure><ol class=""><li id="95b3" class="mc md it js b jt ju jx jy kb nk kf nl kj nm kn nn mk ml mm bi translated">从第一个数组中的<em class="ni"> i </em> index开始，第二个数组中的<em class="ni"> j </em> index和第三个数组中的<em class="ni"> k </em> index开始。</li><li id="13f4" class="mc md it js b jt mn jx mo kb mp kf mq kj mr kn nn mk ml mm bi translated">比较<em class="ni">I</em>T19】T14】j处的值</li><li id="9575" class="mc md it js b jt mn jx mo kb mp kf mq kj mr kn nn mk ml mm bi translated">将最小值放入<em class="ni"> k中</em>将最小值索引移动到下一个。</li><li id="b79b" class="mc md it js b jt mn jx mo kb mp kf mq kj mr kn nn mk ml mm bi translated">继续这样做，直到到达其中一个数组的末尾。</li><li id="4cea" class="mc md it js b jt mn jx mo kb mp kf mq kj mr kn nn mk ml mm bi translated">如果其中一个数组中还有剩余的元素，就把它们原样移动到第三个数组中。</li></ol><p id="3197" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的合并复杂度是O(n+m ),其中n是第一个数组的长度，m是第二个数组的长度。我们可以说差不多是O(n)了。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e439" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">合并两个以上排序的数组可以用同样的方法，你可以选择两个数组，合并它们，等等，直到得到一个排序的数组。</p><h2 id="c2e7" class="nq lf it bd lg nr ns dn lk nt nu dp lo kb nv nw ls kf nx ny lw kj nz oa ma ob bi translated">如果我们刚刚合并的两个数组是一个数组的一部分呢？如何对它们进行排序？</h2><p id="bc5a" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb ne kd ke kf nf kh ki kj ng kl km kn im bi translated">该过程将与我们上面描述的非常相似。让我们以下面的数组为例。现在我们需要在逻辑上将它分成两个有序的数组，这样我们就可以合并它们了。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/fb3e6e37054db9c1e5ae15901979d93a.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*ivEX16Puu0G6o4qV5b2CeA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">将合并排序数组概念应用于一个数组</figcaption></figure><p id="bc87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，我们可以定义low (l)、high (h)和mid (m)，用来定义第一个和第二个子阵列的边界。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi od"><img src="../Images/8c7c38c9c50974cdd938ed41497e4656.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*xRDD90TianQIusDT1r-pyA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">定义两个子阵列的边界</figcaption></figure><p id="21ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，要进行合并，我们需要另一个相同大小的数组来添加合并结果，最后，我们可以将结果从这个辅助数组复制回原始数组。</p><p id="e6ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，非常类似于第一个合并两个排序数组的例子，我们将需要I，j &amp; k，如下所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/cbce7886ff747d85d09705e082813cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*lov1f_5CBwM3v7IAy9XzMg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">初始化指针</figcaption></figure><p id="3ac8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后做和第一个例子完全一样的过程，但是不是I，j，&amp;k从0开始，只是确保I从L开始，j stats在m+1 &amp; k也从L开始。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">将一个数组与两个排序后的数组合并</figcaption></figure><p id="a67f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们比较一下，合并两个排序数组的代码，以及将两个排序数组合并成一个数组的代码，我们会发现它们非常相似，如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi of"><img src="../Images/909edf0459e5d188fcb41594333aa839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e5Lq_fgyRvlG3M2b3pTYmg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">比较，合并两个排序数组的代码，以及将两个排序数组合并成一个数组的代码</figcaption></figure><p id="7a65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是合并排序的基础。合并排序是简单地将一个数组分成更小的两半，直到每个数组只有一个项目(这是自然排序)，然后开始再次对这些子数组应用合并，直到我们到达一个排序后的数组。</p><h1 id="46ec" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">它是如何工作的？</h1><p id="43b1" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb ne kd ke kf nf kh ki kj ng kl km kn im bi translated">合并排序是一种递归算法，按照以下步骤工作:</p><ol class=""><li id="98a7" class="mc md it js b jt ju jx jy kb nk kf nl kj nm kn nn mk ml mm bi translated">将输入分成两半。</li><li id="8647" class="mc md it js b jt mn jx mo kb mp kf mq kj mr kn nn mk ml mm bi translated">通过递归使用相同的过程对每一半进行排序。</li><li id="43e5" class="mc md it js b jt mn jx mo kb mp kf mq kj mr kn nn mk ml mm bi translated">将排序后的两半合并在一起。</li></ol><h2 id="9418" class="nq lf it bd lg nr ns dn lk nt nu dp lo kb nv nw ls kf nx ny lw kj nz oa ma ob bi translated">如何拆分数组使其排序？</h2><p id="77c4" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb ne kd ke kf nf kh ki kj ng kl km kn im bi translated">只有一个元素的数组是按设计排序的，所以将数组分成两半，直到每个数组只有一个元素的基本情况将使数组排序。</p><h1 id="5b3d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">让我们为合并排序编写算法</h1><p id="3beb" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb ne kd ke kf nf kh ki kj ng kl km kn im bi translated">然而，合并排序被认为是递归的，但我们将通过如何写递归&amp;迭代版本的它和什么是不同的。</p><p id="d98f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在所有情况下，合并部分都是相同的&amp;这与我们上面讨论的将一个数组与排序后的两半合并完全相似:</p><p id="6190" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">合并部分将如前所述:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="5e09" class="nq lf it bd lg nr ns dn lk nt nu dp lo kb nv nw ls kf nx ny lw kj nz oa ma ob bi translated">递归方法(自顶向下)</h2><p id="166c" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb ne kd ke kf nf kh ki kj ng kl km kn im bi translated">递归方法的代码非常简单，我们只需要应用上面提到的三个步骤就可以了。</p><p id="fc06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">分割部分都是逻辑同步的，但要完成合并部分，您将需要我们前面讨论过的辅助数组。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/b39f7bd2a17c99cd708408ee413019de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KxfTyKXerY1rXKLuqbaaZA.gif"/></div></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d1f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">时间复杂度:</strong></p><p id="e0a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在所有3种情况下(最差、平均和最好),合并排序的时间复杂度为O(n Log n ),因为合并排序总是将数组分成两半，并花费线性时间来合并两半。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/42270436ef08f362421533e3cdbf6733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WhQZF_SRJ41-ArehxsrZIA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">对数时间复杂度</figcaption></figure><p id="1ddc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">空间复杂度:</strong></p><p id="6987" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当将两个排序后的数组合并成一个更大的数组时，我们需要空间来保存合并后的结果。</p><p id="ff44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们要组合的数组有O(n)个元素，所以我们总共需要O(n)个空间，但是因为我们在做递归调用，所以这个额外的数组将被复制log (n)次，所以这里的空间复杂度是O(n log n)。</p><p id="636a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">关于空间复杂性的注释:</strong></p><ul class=""><li id="a468" class="mc md it js b jt ju jx jy kb nk kf nl kj nm kn mj mk ml mm bi translated">如果我们仔细观察，我们会发现有些合并需要的空间不到O(n ),因为当我们合并两个各有一个元素的数组时，需要O(1)的空间，但是，当我们进行最后的合并时，我们将有两个各有n/2项的一半，所以我们需要O(n)的空间来合并结果。</li><li id="6f39" class="mc md it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">如果你仔细观察，当前的实现比O(n)使用更多的空间，O(n log(n))对于每个递归调用，我们传递的是输入的副本。而且，由于我们在遇到基本情况之前可能有O(log(n))个递归调用，这是输入的O(log(n))个副本，但是空间可以很容易地通过小的更改达到O(n)。</li></ul><h2 id="b728" class="nq lf it bd lg nr ns dn lk nt nu dp lo kb nv nw ls kf nx ny lw kj nz oa ma ob bi translated">迭代方法(自下而上)</h2><p id="ae50" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb ne kd ke kf nf kh ki kj ng kl km kn im bi translated">迭代部分基于这样的想法，即一个单品数组已经排序，所以如果我们有一个特定的数组，我们可以将其中的每个元素视为一个排序的数组，然后像往常一样应用合并。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/85ef764c5b3428f32c16bbff2192b34d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*vK2nYYw7hEXe8CmdpdOGtg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">迭代合并排序</figcaption></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="4556" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">时间复杂度是O(n log n ),因为我们对log n遍不进行n次合并&amp;空间复杂度是O(n ),因为我们在合并例程中使用辅助数组。这个版本比递归版本更好，因为我们提高了空间复杂度。</p><h1 id="cde3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">合并排序更适合于排序链表，而不仅仅是数组</h1><p id="934d" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb ne kd ke kf nf kh ki kj ng kl km kn im bi translated">除了插入排序之外，合并排序被推荐用于排序链表。链表缓慢的随机访问性能使得一些其他算法(比如快速排序)表现不佳，而另一些算法(比如堆排序)则无法实现。</p><p id="06e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将看到合并排序在链表中如何以O(nlogn)时间复杂度执行，这与它在排序数组时的性能非常相似。</p><p id="8a68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">合并排序链表的思想与合并排序数组是一样的&amp;它可以递归或迭代完成，就像我们处理数组一样。</p><h2 id="dfd4" class="nq lf it bd lg nr ns dn lk nt nu dp lo kb nv nw ls kf nx ny lw kj nz oa ma ob bi translated">递归方法</h2><p id="f564" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb ne kd ke kf nf kh ki kj ng kl km kn im bi translated">虽然链表的合并排序可以使用递归或迭代来完成，但这里我们将只讨论递归方法，以简化事情&amp;不要让人们对许多实现感到困惑。</p><p id="9172" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种方法中，我们将通过使链表中间节点的下一个值等于null来将输入链表分成两半，然后我们将在每一半上分别调用我们的递归排序函数，在每次调用结束时，我们将合并这两半排序后的链表来排序。</p><p id="0489" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这与我们处理数组的方法完全相似。</p><p id="4c5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">实施</strong></p><p id="b05f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要得到链表的中间部分，然后取消它的下一个部分，所以我们有两半，左半部分和右半部分，一旦我们把所有的链表分解成一个条目列表，我们将需要应用合并例程。所以这里有3个例程:</p><ol class=""><li id="b0a7" class="mc md it js b jt ju jx jy kb nk kf nl kj nm kn nn mk ml mm bi translated">获取链表的mid。</li><li id="bbd8" class="mc md it js b jt mn jx mo kb mp kf mq kj mr kn nn mk ml mm bi translated">编写合并方法。</li><li id="4ac7" class="mc md it js b jt mn jx mo kb mp kf mq kj mr kn nn mk ml mm bi translated">通过将链接列表分成两半来应用合并排序，然后合并这两半来获得排序的链接列表。</li></ol><p id="2439" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是单链表节点类:</p><pre class="kp kq kr ks gt oi oj ok ol aw om bi"><span id="88ea" class="nq lf it oj b gy on oo l op oq">public class SNode<br/>{<br/>public int Val;<br/>public SNode? Next;<br/> public SNode(int val = 0, SNode? next = null)<br/>  {<br/>    this.Val = val;<br/>    this.Next = next;<br/>  }</span><span id="bbd6" class="nq lf it oj b gy or oo l op oq">}</span></pre><p id="3006" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">链表的合并排序将如下所示(我添加了一些注释来描述和阐明代码本身的更多内容，但总的来说，它是直截了当的，由我上面提到的三个步骤组成)</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">合并排序链表</figcaption></figure><p id="4f76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">时间复杂度</strong></p><p id="c8ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">时间复杂度类似于我们在数组合并排序中讨论的。是O(n log n)。</p><p id="34fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，GetMid(..)方法的复杂度为O(n ),因为我们最多对列表的每个节点迭代一次。</p><p id="e38f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二，Merge方法的复杂度为O(n + m ),因为我们最多迭代每个列表的节点一次。</p><p id="8609" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，主MergeSort方法的复杂度为O(n log n ),因为在每次调用中，我们合并两个复杂度为O(n)的列表，并且递归树的深度将为log(n ),因为在每次调用中，我们将列表分成两半。</p><p id="8ae3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">空间复杂度</strong></p><p id="8b61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">空间复杂度也非常类似于数组方法，它是O(n log n ),因为我们每次调用合并排序都创建一个新的链表，因为我们调用合并排序log (n)次，所以空间复杂度是O(n log n)。如果我们使用迭代方法达到O(n ),空间复杂度可以得到改善，因为在合并期间不需要额外的列表副本。</p><h1 id="c9fd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">FQA</h1><h2 id="7722" class="nq lf it bd lg nr ns dn lk nt nu dp lo kb nv nw ls kf nx ny lw kj nz oa ma ob bi translated">链表最好的排序算法有哪些？</h2><p id="cda1" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb ne kd ke kf nf kh ki kj ng kl km kn im bi translated">有时候，人们更喜欢将链表的值复制到数组中，然后使用快速排序之类的方法对其进行排序，然后将其移回链表中，因为数组比链表具有更好的缓存性能。如果你要对一个链表进行排序，那么合并排序是很好的，插入排序也用于对链表进行排序，但是它的复杂度是O(n)。</p><h2 id="9330" class="nq lf it bd lg nr ns dn lk nt nu dp lo kb nv nw ls kf nx ny lw kj nz oa ma ob bi translated">这个算法稳定吗？</h2><p id="4f58" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb ne kd ke kf nf kh ki kj ng kl km kn im bi translated">如果两个具有相同键的对象在排序后的输出中出现的顺序与它们在要排序的输入数组中出现的顺序相同，则称排序算法是<strong class="js iu">稳定的</strong>。<strong class="js iu">合并排序</strong>是一种稳定排序，这意味着数组中的相同元素保持它们相对于彼此的原始位置。</p><h2 id="1520" class="nq lf it bd lg nr ns dn lk nt nu dp lo kb nv nw ls kf nx ny lw kj nz oa ma ob bi translated">这个算法适应性强吗？</h2><p id="c8f3" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb ne kd ke kf nf kh ki kj ng kl km kn im bi translated">简单地说，如果算法利用其元素的位置来最小化执行排序所需的操作数量，我们称之为自适应算法。自顶向下和自底向上合并排序都不是自适应的，因为它们总是进行O(n log n)运算。即使对数组进行了排序，数组也会被细分，然后进行比较。有一种类型的合并排序称为自然合并排序，它具有自适应性，但这超出了本主题的范围。</p><h2 id="2b08" class="nq lf it bd lg nr ns dn lk nt nu dp lo kb nv nw ls kf nx ny lw kj nz oa ma ob bi translated">这个算法到位了吗？</h2><p id="d310" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb ne kd ke kf nf kh ki kj ng kl km kn im bi translated">正如你在上面的例子中所看到的，合并排序并不在宫内，因为在所有情况下我们都需要辅助数组来执行合并部分。当我们通过递归来实现时，空间复杂度有时会达到O(n log n ),因为调用激活记录中的额外数组会导致log n的额外复杂度，正如我们上面提到的，为了改善这一点，我们可以使用自底向上技术来确保空间复杂度为O(n)。</p><h2 id="c08a" class="nq lf it bd lg nr ns dn lk nt nu dp lo kb nv nw ls kf nx ny lw kj nz oa ma ob bi translated">这个算法适用于链表吗？</h2><p id="6c4f" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb ne kd ke kf nf kh ki kj ng kl km kn im bi translated">该算法适用于链表，因为它的时间复杂度为O(n log n ),并且可以用与数组相似的过程来实现。</p><h2 id="aac9" class="nq lf it bd lg nr ns dn lk nt nu dp lo kb nv nw ls kf nx ny lw kj nz oa ma ob bi translated">什么时候用或者不用？</h2><p id="edef" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb ne kd ke kf nf kh ki kj ng kl km kn im bi translated">如果获取额外空间的成本很高，就不要使用它，如果排序的稳定性很重要，就使用它。</p><h2 id="690f" class="nq lf it bd lg nr ns dn lk nt nu dp lo kb nv nw ls kf nx ny lw kj nz oa ma ob bi translated">优势</h2><ul class=""><li id="bee2" class="mc md it js b jt me jx mf kb mg kf mh kj mi kn mj mk ml mm bi translated">对于较大的列表，它的速度更快，因为它的时间复杂度为O (n log n)</li><li id="9037" class="mc md it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">它具有一致的运行时间，在一个阶段中以相似的时间执行不同的位。</li><li id="5154" class="mc md it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">这是稳定的算法。</li></ul><h2 id="08bd" class="nq lf it bd lg nr ns dn lk nt nu dp lo kb nv nw ls kf nx ny lw kj nz oa ma ob bi translated">不足之处</h2><ul class=""><li id="5614" class="mc md it js b jt me jx mf kb mg kf mh kj mi kn mj mk ml mm bi translated">对于较小的任务，与其他排序算法相比速度较慢。</li><li id="c20c" class="mc md it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">它不是自适应的，所以即使列表被排序，它也会经历整个过程</li><li id="ba70" class="mc md it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">它使用更多的内存空间来存储初始拆分列表的子元素。</li></ul><h1 id="cfde" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">最后</h1><p id="262e" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb ne kd ke kf nf kh ki kj ng kl km kn im bi translated">我希望你觉得这个例子有用。我试图包含尽可能多的清晰的例子和想法，同时保持简单，关注重要的东西。请随时留下您的意见、建议或任何反馈。</p></div></div>    
</body>
</html>