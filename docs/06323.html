<html>
<head>
<title>Debugging Go Inside Docker, Using Visual Studio Code and Remote Containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">调试在Docker内部进行，使用Visual Studio代码和远程容器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/debugging-go-inside-docker-using-visual-studio-code-and-remote-containers-5c3724fe87b9?source=collection_archive---------0-----------------------#2020-11-16">https://levelup.gitconnected.com/debugging-go-inside-docker-using-visual-studio-code-and-remote-containers-5c3724fe87b9?source=collection_archive---------0-----------------------#2020-11-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/03baaaa84cb0aad1b624db94a47474a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFxdXb1V-7mfdi1cFHFCoQ.png"/></div></div></figure><p id="1d35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我的职业生涯中或从事个人项目时，我曾多次需要一些开源可执行文件来帮助我完成任务。我用过像<a class="ae kz" href="https://weasyprint.org/start/" rel="noopener ugc nofollow" target="_blank"> Weasyprint </a>、<a class="ae kz" href="https://wkhtmltopdf.org/" rel="noopener ugc nofollow" target="_blank"> WKHTMLTOPDF </a>、<a class="ae kz" href="https://exiftool.org/" rel="noopener ugc nofollow" target="_blank"> Exiftool </a>、<a class="ae kz" href="https://www.ghostscript.com/" rel="noopener ugc nofollow" target="_blank"> Ghostscript </a>这样的东西，不胜枚举(这些只是最近的一些)。这些都是很棒的工具，我相信还有成百上千种。它们提供了惊人的功能，节省了我无数的工作时间，我要么不用写，要么就是不知道如果必须写的话该从哪里开始写！我感谢这些工具以及更多免费和开源的工具。</p><p id="830f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，我不想将它们安装在我的本地计算机上。我100%反对在我的个人电脑上安装项目所需的额外软件，而不是为了在日常生活中帮助我。如果你碰巧为一家锁定他们机器的公司工作，在本地安装这个软件可能是不可能的。谢天谢地，我们有Docker和它所有的荣耀来帮助我们。利用Docker，我可以很容易地安装所有这些软件，并使用它没有放弃。即使我的机器被锁定了，Docker也可以来帮忙。</p><p id="cf2d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我在这些场景中多次使用Docker，感觉非常棒。但是这种情况下的调试体验并不大。由于我没有在本地安装这个软件，为了真正了解我的代码是否正常工作，我需要在Docker容器中运行它。这并不可怕，但它往往会导致大量日志语句和不必要的额外时间消耗。幸运的是，微软对Visual Studio代码有一个惊人的扩展，叫做<a class="ae kz" href="https://code.visualstudio.com/docs/remote/containers" rel="noopener ugc nofollow" target="_blank">远程容器</a>。从他们的页面:</p><blockquote class="la lb lc"><p id="76ba" class="kb kc ld kd b ke kf kg kh ki kj kk kl le kn ko kp lf kr ks kt lg kv kw kx ky im bi translated">Visual Studio Code Remote-Containers扩展允许您使用一个<a class="ae kz" href="https://docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker容器</a>作为全功能开发环境。它允许您打开容器内(或装入容器中)的任何文件夹，并利用Visual Studio代码的完整功能集。项目中的<a class="ae kz" href="https://code.visualstudio.com/docs/remote/containers#_create-a-devcontainerjson-file" rel="noopener ugc nofollow" target="_blank"> devcontainer.json文件</a>告诉VS代码如何使用定义良好的工具和运行时堆栈来访问(或创建)开发容器。该容器可用于运行应用程序或沙盒工具、库或运行时，这些都是使用代码库所需的。</p></blockquote><p id="5ef3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我们将编写一个非常简单的Go应用程序，它将利用Exiftool从PDF中提取并显示元数据。使用远程容器扩展，我们将只在Docker容器中安装Exiftool，并在容器中调试应用程序。我们走吧！</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="3693" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">设置</h1><p id="9b20" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">这个应用程序非常简单，它所做的就是对存储在容器中的PDF运行Exiftool。这篇文章的目标是探索使用远程容器扩展，所以不需要太复杂的东西。这是我们的代码:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="14f1" class="na lp it mw b gy nb nc l nd ne">package main</span><span id="3657" class="na lp it mw b gy nf nc l nd ne">import (</span><span id="ec88" class="na lp it mw b gy nf nc l nd ne">    "bytes"</span><span id="f9ae" class="na lp it mw b gy nf nc l nd ne">    "fmt"</span><span id="8f98" class="na lp it mw b gy nf nc l nd ne">    "os/exec"</span><span id="f493" class="na lp it mw b gy nf nc l nd ne">)<br/></span><span id="c825" class="na lp it mw b gy nf nc l nd ne">func main() {</span><span id="c52c" class="na lp it mw b gy nf nc l nd ne">    args := []string{"gobook.pdf"}</span><span id="02d8" class="na lp it mw b gy nf nc l nd ne">    cmd := exec.Command("exiftool", args...)</span><span id="85c2" class="na lp it mw b gy nf nc l nd ne">    var outb, errb bytes.Buffer</span><span id="e04b" class="na lp it mw b gy nf nc l nd ne">    cmd.Stdout = &amp;outb</span><span id="c09f" class="na lp it mw b gy nf nc l nd ne">    cmd.Stderr = &amp;errb</span><span id="07cc" class="na lp it mw b gy nf nc l nd ne">    err := cmd.Run()</span><span id="25a6" class="na lp it mw b gy nf nc l nd ne">    if err != nil {</span><span id="51bd" class="na lp it mw b gy nf nc l nd ne">        fmt.Println(&amp;errb)</span><span id="e013" class="na lp it mw b gy nf nc l nd ne">    }</span><span id="6099" class="na lp it mw b gy nf nc l nd ne">    fmt.Println(&amp;outb)</span><span id="258f" class="na lp it mw b gy nf nc l nd ne">}</span></pre><p id="bb42" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们快速分解一下。如前所述，这段代码没有做太多事情。首先，我们创建一个参数的字符串数组，它保存我们想要处理的PDF文件的名称。接下来，我们创建一个命令，告诉它使用前面的参数运行Exiftool。我们创建一些变量来保存命令函数的输出，运行命令，并打印出结果。这样做的结果只是将文件的元数据打印到屏幕上。</p><p id="b977" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们现在运行这段代码，这个命令肯定会失败，因为Exiftool没有安装在本地。因为这篇文章是关于不在本地安装的，所以让我们来看看支持这个应用程序的docker文件。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="622c" class="na lp it mw b gy nb nc l nd ne">FROM golang:1.14.12-stretch</span><span id="9ade" class="na lp it mw b gy nf nc l nd ne">RUN apt-get update &amp;&amp; \</span><span id="a713" class="na lp it mw b gy nf nc l nd ne">    apt-get install -y exiftool</span><span id="2d9c" class="na lp it mw b gy nf nc l nd ne">COPY main.go gobook.pdf ./</span><span id="f060" class="na lp it mw b gy nf nc l nd ne">ENTRYPOINT ["go", "run", "main.go"]</span></pre><p id="d139" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与应用程序非常相似，这个docker文件非常简单明了。首先，我们基于官方Golang Stretch映像创建映像，然后更新“apt-get”并安装Exiftool。接下来，我们复制“main.go”文件和我们想要处理的PDF。最后，我们设置入口点运行“main.go”文件，简单！</p><blockquote class="la lb lc"><p id="3175" class="kb kc ld kd b ke kf kg kh ki kj kk kl le kn ko kp lf kr ks kt lg kv kw kx ky im bi translated"><strong class="kd iu">注意</strong>:我正在使用的PDF是Caleb Doxsey的《Go编程入门》。你可以在这里阅读和下载PDF:<a class="ae kz" href="http://www.golang-book.com/books/intro" rel="noopener ugc nofollow" target="_blank">http://www.golang-book.com/books/intro</a></p></blockquote></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="889e" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">安装远程容器扩展</h1><p id="4bc1" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">就像Visual Studio代码中的任何其他扩展一样，只需在IDE中单击扩展图标，然后搜索“remote”。它应该在列表的顶部。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ng"><img src="../Images/582f8c8dab2f5b56100b802d6c4b0026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ACz8opteoGJQ73v-RWWPMw.png"/></div></div></figure><p id="27ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个图像中，我已经安装了扩展，如果您没有，请单击“安装”按钮进行安装。一旦安装了扩展，我们会在IDE的左下角看到一个新按钮。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/dc688bcdf0b7058387130752eb42a6ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*aYKZAnA2dmnPQUODAZYWNw.png"/></div></figure><p id="0bd7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这张截图中，我的鼠标图标消失了，但我将鼠标悬停在现在出现的绿色按钮上，它显示“打开一个远程窗口”。这实际上只是命令面板的一个方便快捷的方式。单击按钮，您将看到面板打开，已经为远程容器进行了过滤。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/75e0c98cb2779619c50739e49f0b585a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3--jEo959d6IBxsWv2TjtQ.png"/></div></div></figure><p id="7220" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有很多选项，我们不会一一介绍。你可以在这里了解更多关于这些选项的信息:<a class="ae kz" href="https://code.visualstudio.com/docs/remote/containers" rel="noopener ugc nofollow" target="_blank">https://code.visualstudio.com/docs/remote/containers</a></p><p id="90c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将关注第一个选项“在容器中重新打开”。这个命令基本上是说，重新打开我当前在一个容器中打开的这个项目。我可以用“打开容器中的文件夹”做同样的事情，这将要求我打开一个特定的文件夹，但我已经在这里了，所以让我们跳过一步。点击“在容器中重新打开”会给我们带来一些问题。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/d677b780781a9882c8fc819a970aa13d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GAwDIlkrjA2dVuBg20UYwA.png"/></div></div></figure><p id="c0c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，我们不会涵盖这两个选项。在这篇文章中，我们将关注“来自‘Dockerfile’”选项，因为我们已经为这个项目构建了一个docker file。你可以在这里了解更多这些选项:【https://code.visualstudio.com/docs/remote/containersT2】</p><p id="82d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">单击此选项将重新启动Visual Studio代码，您将看到创建了一个新的JSON文件。这基本上是在容器中运行和调试代码的启动配置。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/54fea156f71dd571afbafe70919528f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rtyaYZFT_YPvzKfIJLC1IA.png"/></div></div></figure><p id="49e3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">查看“devcontainer.json”文件，有相当多的选项可供您选择。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/5a72b8725067ee02ce9c4aa16f9852d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3tnWQrm9eK_YRW2T-ZMy-w.png"/></div></div></figure><p id="20d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有很多非常酷的功能，比如能够定义只适用于容器的Visual Studio代码扩展，以及能够在容器创建后运行命令。如果运行API，还可以定义端口转发。这些都是非常酷的东西，远远超过了我们在一篇文章中所能涉及的范围。</p><p id="b1d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您还应该注意到，当Visual Studio代码重新启动时，我们不仅获得了一个新的JSON文件，而且我们的Dev容器也启动了，并且在该运行容器中打开了一个终端会话！</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/67b2bfb965669f86558a4890227572bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-_xMIkOVDHQDuxsXEYWy1A.png"/></div></div></figure><p id="722f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以通过简单地运行“ls”命令来验证我们是否在容器中！</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/726c391da12744b65eb34aa0e37d4b48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dpjplv3G-0h10jQ83Ox1Sg.png"/></div></div></figure><p id="5790" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这看起来很棒，但是你应该注意到一些奇怪的事情。我让Visual Studio代码使用我现有的Dockerfile，它不会将文件夹中的所有内容都复制到容器中。我们可以通过从Dockerfile文件构建映像、运行容器并检查其内容来验证这一点。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/ebed33720880d502e4ae439dcfc1300b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C3aUorr5my_x_dS785rqjA.png"/></div></div></figure><p id="d6da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是我所期望的，仅仅是我复制的两个文件，加上任何来自Golang的图片。显然，远程容器做的有点不同，这是为了支持调试。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="d61f" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">调试您的代码</h1><p id="3c05" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">现在我们已经安装了扩展，有了新的JSON配置文件，并且有了一个正在运行的Dev容器。让我们调试代码吧！首先，我们需要设置一个断点，这很简单。对于这个例子，我们将在设置完参数后立即中断，并确保它们设置正确。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi np"><img src="../Images/13c65605cfb1dc25cc52bf01a22aefe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iVmvMbZCopYKMHgA-16oPA.png"/></div></div></figure><p id="22ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们打开“运行”面板，单击“运行和调试”按钮。您可能会被提示选择一个“环境”，在我们的例子中是“Go”。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/fbcb3e4fe183a172f23fba0facbfd4a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xFkcS5QDmuqdoOHIs_k_8g.png"/></div></div></figure><p id="bdbb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们应该像预期的那样命中断点，并且可以检查我们的代码。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/dc09297bebe6c22b98857d1f3df66710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ht2DsMYMgH2HR3sD1GMYuw.png"/></div></div></figure><p id="045b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从这里，我们可以像往常一样单步调试代码。这一切都发生在运行的Dev容器中！我们可以通过单击“Debug Console”选项卡查看代码输出来验证这一点。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/11a569d543de667ed1f80383bc8c8180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AVBg2jOqIlH_4N-VqGn50Q.png"/></div></div></figure><p id="0ab6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这显然是可行的，因为我没有在本地安装Exiftool！多牛逼啊！</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="038a" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">包扎</h1><p id="8f8f" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">在这篇文章中，我们仅仅触及了Docker容器中调试代码的皮毛。但是即使这个非常简单的例子也展示了远程容器扩展的强大功能。这为我在当地的发展提供了很多选择。这个用例特别强大，但它也让我们更接近于在一个代码最终会运行的环境中进行开发。在最终进入生产环境的容器中进行调试，可以让您在管道运行之前就发现问题。这是一件令人惊奇的事情！</p><p id="25c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更多关于远程容器的阅读和深入研究，请查看以下链接:<br/> -在容器内开发:<a class="ae kz" href="https://code.visualstudio.com/docs/remote/containers" rel="noopener ugc nofollow" target="_blank">【https://code.visualstudio.com/docs/remote/containers】</a><br/>-远程-容器Visual Studio市场:【https://marketplace.visualstudio.com/items?】T4itemName = ms-vs Code-remote . remote-containers<br/>-高级容器配置:<a class="ae kz" href="https://code.visualstudio.com/docs/remote/containers-advanced" rel="noopener ugc nofollow" target="_blank">https://Code . visual studio . com/docs/remote/containers-Advanced</a><br/>-GitHub代码:<a class="ae kz" href="https://github.com/atkinsonbg/debugging-golang-remote-containers" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/atkinsonbg/debugging-golang-remote-containers</a></p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><figure class="mr ms mt mu gt ju gh gi paragraph-image"><a href="https://ko-fi.com/O5O63ENS7"><div class="gh gi nt"><img src="../Images/3515ab52cb6fb5e74c27c7a2e06d3811.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*5imNjCtY48Wh3owQyPv6Cw.png"/></div></a></figure></div></div>    
</body>
</html>