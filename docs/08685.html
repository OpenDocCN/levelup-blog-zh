<html>
<head>
<title>Structuring GitHub Actions Safely</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">安全地构造GitHub动作</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/structuring-github-actions-safely-5309e5ee54de?source=collection_archive---------4-----------------------#2021-05-25">https://levelup.gitconnected.com/structuring-github-actions-safely-5309e5ee54de?source=collection_archive---------4-----------------------#2021-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4b7b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何设计有开始、中间和结束的GitHub Actions工作流，以便您可以安全地拆除您的环境并准确地通知您的团队。</h2></div><p id="4a34" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">GitHub Actions允许你通过在你的git存储库中包含一个简单的YAML文件来说明你想执行什么和什么时候执行，从而自动化任何软件工作流。如果你是新手，看看这里的<a class="ae le" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="39b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最近，我的团队构建了一个GitHub工作流来测试我们的软件在云上的部署——在Amazon Web Services上建立一个环境，运行一些测试，然后再次将其拆除。一开始，这是一项包含一系列步骤的工作。最后，我们使用了一个<code class="fe lf lg lh li b">if: failure()</code> <a class="ae le" href="https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#job-status-check-functions" rel="noopener ugc nofollow" target="_blank">状态检查函数</a>来确保最后一个步骤总是在任何先前的步骤失败后运行——并且最后一个步骤发送了一个Slack通知，让我们知道出现了错误。</p><p id="2c8a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这似乎行得通，但是假设在某个测试步骤中发生了故障。在这种情况下，我们直接跳到发送(正确的)故障通知，但是跳过了所有的拆卸步骤。所以资源仍然在云上，直到有人收到通知并手动停止AWS上的一切。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/ad618fe5b2b447c0b4d3de901a46a5a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UPediNWyNgOjjJiK"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@kar111?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">郭佳欣·阿维蒂斯扬</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="7e72" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们通过将一长串步骤分成三个独立的“工作”来重构工作流。这给出了一个逻辑上的划分，但是在发送成功/失败通知时，却出现了一些意想不到的问题。</p><p id="f6b0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">提醒一下，作业是GitHub操作工作流中步骤的高级集合。默认情况下，作业可以并行运行，并且各个作业不共享同一个工作区或虚拟机，因此您无法在作业之间自动共享状态(相比之下，所有“步骤”都在与其同级相同的环境中运行)。</p><p id="c391" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将工作流分成多个作业是否有意义取决于您正在做什么，但是对于我们的示例来说，重要的是要知道在作业之间建立依赖树是可能的。因此，我们可以运行作业1(设置环境)，然后运行作业2(运行测试)，最后运行作业3(拆除环境并发送通知)。</p><h1 id="0fde" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">通知</h1><p id="6c39" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">在我的例子中，我使用<a class="ae le" href="https://github.com/marketplace/actions/slack-templates" rel="noopener ugc nofollow" target="_blank">market place action Slack Templates</a>向Slack发送通知，但是你可以使用任意数量的免费GitHub Actions直接向你选择的Slack频道、微软团队或任何你想使用的东西发送通知。</p><p id="9095" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无论哪种方式，您都需要某种形式的身份验证令牌来触发您的通知，并且您应该将其保存为组织或存储库机密:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mw"><img src="../Images/76153f0fbeab7820046bd8d48e1f0f09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ihexy3ICgwnmAqtJdq6ifw.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">在GitHub repo中将token设置为秘密(图片由作者提供)</figcaption></figure><h1 id="43fa" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">序列中的作业</h1><p id="e2e1" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">这是我第一次尝试将工作流分成三个不同的任务。事实上，在我真正的工作流程中，中间的任务使用了不同于其他两个任务的运行器(不是<em class="mx"> ubuntu-latest </em>),所以这个<em class="mx">有</em>在一个单独的任务中。在这个例子中，我用<code class="fe lf lg lh li b">exit 0</code>模拟主要步骤——如果我想假装该步骤失败，例如由于测试失败，可以很容易地将它改为<code class="fe lf lg lh li b">exit 1</code>。默认情况下，任何非零退出代码都将停止工作流。</p><pre class="lk ll lm ln gt my li mz na aw nb bi"><span id="125b" class="nc ma it li b gy nd ne l nf ng">name: "Test Multiple Jobs"</span><span id="65a9" class="nc ma it li b gy nh ne l nf ng">on:<br/>  workflow_dispatch:<br/>  <br/>jobs:<br/>  startupjob:<br/>    name: Start Up<br/>    steps:<br/>      - name: Set Everything Up<br/>        run: exit 0</span><span id="6c3f" class="nc ma it li b gy nh ne l nf ng">  testsjob:<br/>    name: Run Tests<br/>    needs: startupjob<br/>    steps:<br/>      - name: Run the test suite<br/>        run: exit 0</span><span id="e22d" class="nc ma it li b gy nh ne l nf ng">  teardownjob:<br/>    name: Tear Down<br/>    needs: testsjob<br/>    if: always()<br/>    steps:<br/>      - name: Tear Down<br/>        run: exit 0<br/>        <br/>      - name: Notify via Slack Templates<br/>        uses: ScribeMD/slack-templates@0.6.7<br/>        if: always()<br/>        with:<br/>          bot-token: ${{ secrets.SLACK_TOKEN }}<br/>          channel-id: ${{ secrets.SLACK_CHANNEL_ID }}<br/>          template: result</span></pre><p id="f03f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，我使用了<code class="fe lf lg lh li b">on: workflow_dispatch</code>，这意味着它是通过GitHub的网站或API手动触发的，但也许你的工作流将是一个<code class="fe lf lg lh li b">on: push</code>事件或其他什么。</p><p id="ec42" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">默认情况下，GitHub可能会选择并行运行多个作业，所以我们使用<code class="fe lf lg lh li b">needs</code>关键字来建立依赖树。</p><p id="c24b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个作业(startupjob)没有依赖项，但是第二个作业(testsjob)有一个<code class="fe lf lg lh li b">needs: startupjob</code>条目，这意味着它需要startupjob完成才能运行。</p><p id="259b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，teardownjob有<code class="fe lf lg lh li b">needs: testsjob</code>来确保它只在测试完成后运行。所以我们有一个这样的线性依赖图:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi ni"><img src="../Images/46257f0a33c4847658fe8ce067dec6f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8RAy0QUJxiLx-RHfQcQjdg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">串行任务依赖关系图(图片由作者提供)</figcaption></figure><h1 id="7dd6" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">总是</h1><p id="69e7" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">你会注意到在第三个“拆卸”作业中有两行<code class="fe lf lg lh li b">if: always()</code>。他们在不同的层次工作。</p><p id="181e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个意味着整个拆卸作业应该始终运行。特别是如果第二个作业(测试)失败了——如果我们测试任何有价值的东西，这种情况很可能偶尔发生——我们仍然希望拆除环境以节省资源，并确保在下次需要时重置状态。</p><p id="ea13" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个<code class="fe lf lg lh li b">if: always()</code>适用于作业内的步骤范围。这意味着，在拆卸作业中，即使拆卸本身失败，我们仍然希望发送通知。</p><p id="8100" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">明确地说，仅仅第二个<code class="fe lf lg lh li b">if: always()</code>不足以确保通知步骤总是运行。它仅适用于拆卸作业。如果没有作业级别<code class="fe lf lg lh li b">if: always()</code>，我们会发现早期作业中的失败会提前完成整个工作流，并且teardownjob会被跳过，尽管其中一个步骤旨在运行'<em class="mx"> always' </em>。</p><p id="eaa7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，在正确的设置中(有两个<em class="mx"> always </em>条目，一个用于拆卸作业，一个用于通知步骤),我们可以模拟startupjob中的失败(例如，更改为<code class="fe lf lg lh li b">exit 1</code>)并看到以下状态:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nj"><img src="../Images/e2bfc510924f88b29c699291cde33d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wJwDh5h1aISlPuwup3QKPg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">不同作业的失败、跳过和成功结果(图片由作者提供)</figcaption></figure><p id="a2b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很好——拆除仍然运行以重置我们的环境(并且它应该以这样一种方式编码，即它可以处理启动作业没有完全运行的情况)。</p><p id="08a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是在我们如何解释通知的状态方面有一个复杂的问题。</p><h1 id="fbd5" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">工作状态忘记过去</h1><p id="8add" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">通过<code class="fe lf lg lh li b">status: ${{ job.status }}</code>传递给Slack通知动作感觉是正确的，在一切都按计划进行或者在拆卸工作的前一步发生故障的情况下，它将是正确的。</p><p id="3042" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但如果你看一下上面的工作依赖图，你会看到“启动”旁边有一个大的红叉，“拆除”旁边有一个大的绿勾。</p><p id="8dad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请记住，<code class="fe lf lg lh li b">job</code>只是当前拆卸作业的上下文，而不是整个工作流的上下文，因此在整个拆卸作业中,<code class="fe lf lg lh li b">job.status</code>实际上等于<code class="fe lf lg lh li b">success</code>。然后传递给Slack通知的状态是<code class="fe lf lg lh li b">success</code>,即使我们的启动或测试作业失败了——在这两种情况下，我们都希望记录失败，以确保有人看到。</p><p id="ee60" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们仔细看看所需的逻辑。如果<code class="fe lf lg lh li b">job.status</code>不等于<code class="fe lf lg lh li b">success</code>(意味着当前拆除作业本身的早期失败)或早期步骤失败，我们希望通知失败。</p><p id="278b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您实际上不能直接访问其他作业的状态<em class="mx">，除非</em>当前作业直接依赖于那些作业。在这种情况下，您可以使用<code class="fe lf lg lh li b"><a class="ae le" href="https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#needs-context" rel="noopener ugc nofollow" target="_blank">needs</a></code> <a class="ae le" href="https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#needs-context" rel="noopener ugc nofollow" target="_blank">上下文</a>来访问相关作业(记得我们在teardownjob中将<code class="fe lf lg lh li b">needs: testsjob</code>指定为一个字段)。</p><p id="2293" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此<code class="fe lf lg lh li b">needs.testsjob</code>提供了对前一个作业的访问，特别是<code class="fe lf lg lh li b">needs.testsjob.result</code>将包含字符串<code class="fe lf lg lh li b">success</code>、<code class="fe lf lg lh li b">failure</code>、<code class="fe lf lg lh li b">cancelled</code>或<code class="fe lf lg lh li b">skipped</code>。</p><p id="d3df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我的结论是使用这个表达式来确定要在我们的时差通知中显示的总体工作流结果:</p><pre class="lk ll lm ln gt my li mz na aw nb bi"><span id="9373" class="nc ma it li b gy nd ne l nf ng">${{ job.status == 'success' &amp;&amp; needs.testsjob.result == 'success' }}</span></pre><h2 id="a9e2" class="nc ma it bd mb nk nl dn mf nm nn dp mj kr no np ml kv nq nr mn kz ns nt mp nu bi translated">回到起点</h2><p id="4a89" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">够了吗？我们不也需要访问第一个作业“startupjob”的结果吗？</p><p id="2fd8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">事实证明，只要我们维护线性依赖树，我们就不需要。这是因为，如果startupjob失败，它会导致整个testsjob被跳过，并且<code class="fe lf lg lh li b">needs.testsjob.result</code>等于<code class="fe lf lg lh li b">skipped</code>(所以不等于<code class="fe lf lg lh li b">success</code>)。</p><p id="26bb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是最终的工作流文件，包括发送时差通知的正确状态检查:</p><pre class="lk ll lm ln gt my li mz na aw nb bi"><span id="c312" class="nc ma it li b gy nd ne l nf ng">name: "Test Multiple Jobs"</span><span id="2ecf" class="nc ma it li b gy nh ne l nf ng">on:<br/>  workflow_dispatch:<br/>  <br/>jobs:<br/>  startupjob:<br/>    name: Start Up<br/>    steps:<br/>      - name: Set Everything Up<br/>        run: exit 0</span><span id="5ee6" class="nc ma it li b gy nh ne l nf ng">  testsjob:<br/>    name: Run Tests<br/>    needs: startupjob<br/>    steps:<br/>      - name: Run the test suite<br/>        run: exit 0</span><span id="7e74" class="nc ma it li b gy nh ne l nf ng">  teardownjob:<br/>    name: Tear Down<br/>    needs: testsjob<br/>    if: always()<br/>    steps:<br/>      - name: Tear Down<br/>        run: exit 0<br/>        <br/>      - name: Notify via Slack<br/>        uses: ScribeMD/slack-templates@0.6.7<br/>        if: always()<br/>        with:<br/>          bot-token: ${{ secrets.SLACK_TOKEN }}<br/>          channel-id: ${{ secrets.SLACK_CHANNEL_ID }}<br/>          template: result<br/>          results: "${{ job.status }} ${{ join(needs.*.result, ' ') }}"</span></pre><p id="1164" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(注意最后的<code class="fe lf lg lh li b">results</code>条目应该都在一行上——它在上面换行)</p><p id="d6b8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在可以在时差通知中看到正确的通知。</p><h1 id="f834" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">摘要</h1><p id="93ab" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">本文展示了如何在独立作业的线性依赖图中设计GitHub动作工作流。</p><p id="0e48" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在最后一个作业中使用了<code class="fe lf lg lh li b">if: always()</code>,以确保它即使在早期的设置和核心测试作业失败时也能运行，这意味着我们的云环境在任何情况下都可以正确地拆除。</p><p id="6eea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，这使得用于确定是否通过我们的松散集成来通知“成功”或“失败”的表达式变得复杂，并且我们必须理解我们的精确依赖树，以便创建准确的表达式。</p><p id="7357" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用公共动作<a class="ae le" href="https://github.com/marketplace/actions/slack-templates" rel="noopener ugc nofollow" target="_blank"> Slack模板</a>将通知处理成Slack。</p><p id="f869" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您确实需要在GitHub Actions工作流作业之间共享状态，<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/github-actions-how-to-share-data-between-jobs-fc1547defc3e">这里有一个极好的可用选项摘要</a>。</p><p id="a724" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果不同的工作流结构或状态表达式对您的特定工作流有意义，请告诉我们！</p><h1 id="3bd8" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">Endid</h1><p id="d083" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">为了让Slack通知变得更容易，看一下<a class="ae le" href="https://endid.app/" rel="noopener ugc nofollow" target="_blank"> Endid，这是我用来监控Github动作的Slack应用</a>。这提供了一个即时安装来监控所有来自repos的GitHub操作，所以你根本不需要担心添加繁琐的通知代码到你的工作流程中！</p><p id="8c73" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，它还提供智能监控，只在工作流突然失败时发送通知，或者在修复后报告成功。</p></div></div>    
</body>
</html>