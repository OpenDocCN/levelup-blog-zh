<html>
<head>
<title>Semantic Versioning and Release Automation on GitLab</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GitLab上的语义版本和发布自动化</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/semantic-versioning-and-release-automation-on-gitlab-9ba16af0c21?source=collection_archive---------0-----------------------#2020-01-25">https://levelup.gitconnected.com/semantic-versioning-and-release-automation-on-gitlab-9ba16af0c21?source=collection_archive---------0-----------------------#2020-01-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f8078552594ebbeafd4cb759547856ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jow8lIIHaN8CA69s"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">潘卡杰·帕特尔在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1cd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您将项目托管在<a class="ae kc" href="https://gitlab.com/" rel="noopener ugc nofollow" target="_blank"> GitLab </a>上，并使用CI/CD，但是您仍然手动管理分支和发布。一旦你的活动增加，你就会忘记跟踪版本、发布、标签、分支等等。是时候改进你的工作流程，让一些事情自动化了。你的项目或团队有多大并不重要。就像Git一样，你不需要一个复杂的组织来使事情变得整洁，即使你独自工作。在这篇文章中，我将向你展示我建议的配置，以坚持<a class="ae kc" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本</a>规范，以及如何让它快速工作。</p><h2 id="7f71" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">截至2022年2月的更新</h2><p id="fa58" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">写完这篇文章后，我开始开发一个名为<a class="ae kc" href="https://github.com/mooltiverse/nyx" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">倪克斯</strong> </a>的新工具，来克服这里描述的解决方案的缺点，得到一个更干净、更精简的解决方案。</p><p id="3878" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我也写过一篇类似的介绍性文章:<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/semantic-release-automation-with-gradle-using-nyx-ba345235a365">Gradle使用倪克斯实现语义发布自动化</a>。</p><h2 id="b64f" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">截至2022年12月的更新</h2><p id="6c65" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><a class="ae kc" href="https://github.com/mooltiverse/nyx" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">倪克斯</strong> </a>现在也可以作为命令行工具和Docker图像使用。另一篇介绍文章是:<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/nyx-the-semantic-release-automation-tool-4e2dfa949f38">倪克斯，语义发布自动化工具</a>。</p><h1 id="ee93" class="lz lc iq bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">分支模型和工作流</h1><p id="b816" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">本文不是关于为你的项目选择正确的分支模型，因为它很容易配置，所以可以用于任何分支模型。</p><p id="dc91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你在GitLab上托管你的项目，给GitLabFlow一个机会。它是根据GitLab特有的特性绘制的，所以很容易利用(长时间运行)<a class="ae kc" href="https://docs.gitlab.com/ee/user/project/merge_requests/" rel="noopener ugc nofollow" target="_blank">合并请求</a>和<a class="ae kc" href="https://docs.gitlab.com/ee/ci/environments.html" rel="noopener ugc nofollow" target="_blank">环境</a>，举几个例子，它对分支不是强制性的，因为它更关注自动化。</p><p id="fb9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，没有什么可以阻止你使用其他模型，比如最受欢迎的<a class="ae kc" href="https://nvie.com/posts/a-successful-git-branching-model/" rel="noopener ugc nofollow" target="_blank"> GitFlow </a>、<a class="ae kc" href="https://www.endoflineblog.com/oneflow-a-git-branching-model-and-workflow" rel="noopener ugc nofollow" target="_blank"> OneFlow </a>或<a class="ae kc" href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/github-flow" rel="noopener ugc nofollow" target="_blank"> GitHubFlow </a>。为了快速比较，你可以开始看看这篇文章。我在这里的一点建议是，你需要开始弄清楚什么是你的项目和你的团队的最佳工作流，然后开始查看那些分支模型，如果需要的话，创建你自己的变体。只要你遵循一个<a class="ae kc" href="https://en.wikipedia.org/wiki/Feature-driven_development" rel="noopener ugc nofollow" target="_blank">特性驱动的开发</a>过程，你就可以很容易地找到一个简单有效的模型。此外，这不是一个永久的决定，您可以随时更改模型，所以不要陷入过度设计工作流中。简单起步，按需扩展。</p><p id="3a7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章的其余部分，我只是假设你使用:</p><ul class=""><li id="a6a1" class="mq mr iq kf b kg kh kk kl ko ms ks mt kw mu la mv mw mx my bi translated">无处不在的永久分支，发布发生的地方</li><li id="3884" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la mv mw mx my bi translated">维护分支(即<code class="fe mz na nb nc b">1.0.x</code>维护发布<code class="fe mz na nb nc b">1.0</code></li><li id="1c58" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la mv mw mx my bi translated">预览类似<code class="fe mz na nb nc b">alpha</code>的分支</li><li id="13e9" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la mv mw mx my bi translated">特性分支(像<code class="fe mz na nb nc b">feature/NAME,</code> <code class="fe mz na nb nc b">fix/NAME</code>)或者任何其他种类的分支来提交不产生发布的小工作单元(直到合并到上面的分支之一)。这些分支从现在开始被忽略，因为它们不需要触发释放</li></ul><p id="2334" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如何以及何时创建这些分支并合并它们取决于您的工作流。</p><h1 id="4dd7" class="lz lc iq bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">引入语义发布</h1><p id="5332" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我使用<a class="ae kc" href="https://github.com/semantic-release/semantic-release" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"/></a>(<a class="ae kc" href="https://github.com/semantic-release/semantic-release/releases/tag/v16.0.3" rel="noopener ugc nofollow" target="_blank">v 16 . 0 . 3</a>)是因为它易于插入、非侵入性，并且除了版本号的自动管理之外，还具有您可能需要的所有额外功能，如发布、<a class="ae kc" href="https://github.com/conventional-changelog/conventional-changelog" rel="noopener ugc nofollow" target="_blank">变更日志生成</a>等等。这些人的工作值得称赞！顺便说一下，如果你要使用它，请考虑在你的项目上展示他们的<a class="ae kc" href="https://github.com/semantic-release/semantic-release#badge" rel="noopener ugc nofollow" target="_blank">徽章</a>。完整文档可在<a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="fe76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有其他几个工具可以自动生成版本号，但并不是所有工具都能生成变更日志和发布版本，或者只是做出不同的假设。我找到的几个是<a class="ae kc" href="https://juhani.gitlab.io/go-semrel-gitlab/" rel="noopener ugc nofollow" target="_blank"> go-semrel-gitlab </a>，<a class="ae kc" href="https://github.com/python-semver/python-semver" rel="noopener ugc nofollow" target="_blank"> python-semver </a>，<a class="ae kc" href="https://github.com/fsaintjacques/semver-tool" rel="noopener ugc nofollow" target="_blank"> semver-tool </a>和<a class="ae kc" href="https://godoc.org/golang.org/x/tools/internal/semver" rel="noopener ugc nofollow" target="_blank"> semver </a>。</p><p id="50f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然<strong class="kf ir">语义发布</strong>是一个<a class="ae kc" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>包<a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/support/faq#can-i-use-semantic-release-to-publish-non-javascript-packages" rel="noopener ugc nofollow" target="_blank">，但它并不是专门针对节点项目</a>的，也不需要安装节点。您可以将它用于任何类型的项目，不管是哪种语言。我们将在一个<a class="ae kc" href="https://hub.docker.com/_/node" rel="noopener ugc nofollow" target="_blank">节点Docker容器</a>中使用它。</p><p id="24de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">话说够了。让我们开始吧。</p><h2 id="77f6" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">语义发布的利与弊</h2><p id="b1bc" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我想节省你的时间，以防我发现的一个不利因素使语义释放在你的情况下不可行。</p><p id="3f73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个缺点是，除非你使用本文末尾显示的调整之一(见<em class="ni">在发布步骤</em>之前知道版本号)，否则你不会提前知道版本号，所以如果你需要使用版本号来构建你的工件，即使实际上没有发布，事情也会变得有点混乱。即使做了这样的调整，在构建被<strong class="kf ir">语义发布</strong>跳过的分支或提交时，您也必须处理生成版本号的问题。</p><p id="6da4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，<strong class="kf ir"> semantic-release </strong>让您可以将您的发布管理置于自动驾驶状态，所以当上述限制都不适用于您的项目时，请考虑使用它。</p><h1 id="b121" class="lz lc iq bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">准备环境</h1><p id="9425" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">您需要生成一个新的<a class="ae kc" href="https://docs.gitlab.com/ce/user/profile/personal_access_tokens.html" rel="noopener ugc nofollow" target="_blank">个人访问令牌</a>来推送访问您的存储库。更具体地说，您需要将<code class="fe mz na nb nc b">api</code>和<code class="fe mz na nb nc b">write_repository</code> <a class="ae kc" href="https://docs.gitlab.com/ce/user/profile/personal_access_tokens.html#limiting-scopes-of-a-personal-access-token" rel="noopener ugc nofollow" target="_blank">范围</a>授予令牌。</p><p id="6754" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在复制生成的令牌，并将其用于名为<code class="fe mz na nb nc b">GITLAB_TOKEN</code>(或<code class="fe mz na nb nc b">GL_TOKEN</code>)的新<a class="ae kc" href="https://docs.gitlab.com/ee/ci/variables/" rel="noopener ugc nofollow" target="_blank"> CI/CD环境变量</a>。该变量可以是特定于项目的变量，也可以是<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/`">组变量</a>，但重要的是要使其受到<a class="ae kc" href="https://docs.gitlab.com/ee/ci/variables/#protected-environment-variables" rel="noopener ugc nofollow" target="_blank">保护</a>，比如:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/1f91581b40dcddfd6f95da437fb95c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8A4WaM1pAf2vgoOH-JEBDA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">为GITLAB项目或组配置的GITLAB_TOKEN变量示例</figcaption></figure><p id="15c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从现在开始，项目管道中运行的所有作业都将能够使用<code class="fe mz na nb nc b">GITLAB_TOKEN</code>变量。如果该变量受保护，则只有运行受保护分支的管道的作业才能访问该变量。</p><p id="cf2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">语义发布</strong>将使用令牌来标记发布并提交到存储库。</p><p id="7499" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请考虑由<strong class="kf ir">语义发布</strong>采取的所有动作(如标记和发布发布)将显示为由发布令牌的用户执行。如果你有大型团队，你可能会选择一个<em class="ni">服务用户</em>账户(或者Bot账户)。</p><h1 id="adfb" class="lz lc iq bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">配置语义发布</h1><p id="dc55" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">现在，为了配置<strong class="kf ir">语义发布</strong>，在您的Git repo的根目录下创建一个<code class="fe mz na nb nc b">.releaserc.yml</code>文件(<code class="fe mz na nb nc b">.gitlab-ci.yml</code>所在的位置)。编辑该文件，使其类似于:</p><pre class="nk nl nm nn gt no nc np nq aw nr bi"><span id="c2be" class="lb lc iq nc b gy ns nt l nu nv">plugins:<br/>  - "<a class="ae kc" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank">@semantic</a>-release/commit-analyzer"<br/>  - "<a class="ae kc" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank">@semantic</a>-release/release-notes-generator"<br/>  - "<a class="ae kc" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank">@semantic</a>-release/gitlab"<br/>branches:<br/>  - "master"<br/>  - "+([0-9])?(.{+([0-9]),x}).x"<br/>  - name: "alpha"<br/>    prerelease: "alpha"</span></pre><p id="fb52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面指示<strong class="kf ir">语义发布</strong>将<code class="fe mz na nb nc b">master</code>分支视为发布分支，而我们可能有任意数量的<code class="fe mz na nb nc b">N.M.x</code>维护分支加上一个我们想要触发发布的预发布分支(<code class="fe mz na nb nc b">alpha</code>)，与常规分支分开。</p><p id="289e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想深入了解配置，还有其他选项<a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/usage/configuration" rel="noopener ugc nofollow" target="_blank">和</a>。您甚至可以跳过配置文件，并通过命令行传递所有选项。</p><p id="38ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我使用YAML文件进行配置，但是您也可以轻松地使用JSON。</p><h2 id="ddb0" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">插件部分</h2><p id="1a48" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">插件做的正是你所期望的:它们扩展或定制了<strong class="kf ir">语义发布</strong>的行为。</p><p id="213c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">语义发布</strong>有一个<a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/usage/plugins" rel="noopener ugc nofollow" target="_blank">步骤</a>的内部序列，代表一个内部工作流程。在每一步，所有的插件都被调用。当插件列表结束时，下一步开始。插件在每一步都按照它们被定义的顺序被调用，直到最后一步所有的插件都被触发。</p><p id="948a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mz na nb nc b">plugins</code>部分是我们加载插件的地方。它与<a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/usage/plugins#default-plugins" rel="noopener ugc nofollow" target="_blank">默认插件</a>的不同之处在于:</p><ul class=""><li id="bc83" class="mq mr iq kf b kg kh kk kl ko ms ks mt kw mu la mv mw mx my bi translated"><code class="fe mz na nb nc b">@semantic-release/npm</code>插件被移除，因为我们不需要它(除非在一个节点项目上工作)</li><li id="d821" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la mv mw mx my bi translated"><code class="fe mz na nb nc b">@semantic-release/github</code>插件被替换为<code class="fe mz na nb nc b">@semantic-release/gitlab</code></li></ul><p id="c09c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只是为了记录起见，<code class="fe mz na nb nc b">plugins</code>部分可能已经被<code class="fe mz na nb nc b"><a class="ae kc" href="https://github.com/semantic-release/gitlab-config" rel="noopener ugc nofollow" target="_blank">gitlab-config</a></code> <a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/usage/shareable-configurations" rel="noopener ugc nofollow" target="_blank">可共享配置</a>所取代，但那无论如何都会带来<code class="fe mz na nb nc b">npm</code>插件。</p><p id="3650" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，插件将按照它们在文件中声明的顺序运行。</p><p id="b1c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有很多其他插件可以玩。完整列表可在<a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/extending/plugins-list" rel="noopener ugc nofollow" target="_blank">这里</a>获得。如果你想添加其他插件，只需在这一部分添加它们，并确保将它们作为管道的一部分下载进来(见下文)。只是要注意插件的顺序，因为它反映了插件执行的顺序。</p><h2 id="4952" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">分支部门</h2><p id="e76d" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">这个部分是从<strong class="kf ir">语义发布</strong>的角度配置工作流的地方。在我们深入了解配置细节之前，了解几个要点是很有用的:</p><ul class=""><li id="4942" class="mq mr iq kf b kg kh kk kl ko ms ks mt kw mu la mv mw mx my bi translated">从<strong class="kf ir">语义发布</strong>的角度来看，每个配置的分支定义了一种发布类型</li><li id="a96f" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la mv mw mx my bi translated">从概念上讲，<strong class="kf ir">语义发布</strong>处理的发布有三种类型:<strong class="kf ir">常规发布</strong>，<strong class="kf ir">预发布</strong>(比如，<code class="fe mz na nb nc b">alpha</code>，<code class="fe mz na nb nc b">beta</code>，<code class="fe mz na nb nc b">release candidate</code>或者<code class="fe mz na nb nc b">rc</code>，<code class="fe mz na nb nc b">preview</code>等等，你有想法)和<strong class="kf ir">后发布</strong>(又名<strong class="kf ir">维护发布</strong>)。每个分支都属于这些家族中的一个。<strong class="kf ir">语义发布</strong>使用的大部分逻辑是为了保证这些发布类型之间的一致性，因此维护发布只能发布它们所绑定的常规发布范围内的版本号，预发布由代表早期阶段的版本号来标识(如<code class="fe mz na nb nc b">alpha</code>、<code class="fe mz na nb nc b">rc</code>等)</li><li id="c757" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la mv mw mx my bi translated">不是你在项目中使用的所有分支都需要被定义为语义发布:只需要那些定义发布的分支。例如，不配置特性分支仅仅是因为在这些分支中提交不会触发发布。只有当这些分支被合并到一些发布分支时，语义发布才会采取行动(提交历史在这里被清理，以收集数据并提供给变更日志)</li><li id="6f17" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la mv mw mx my bi translated">相反，并不是所有配置到<strong class="kf ir">语义发布</strong>中的分支都必须是Git存储库中的实际分支。那些不存在的将被忽略，因为没有要分析的提交。这允许您拥有一个通用的配置(例如，您可以在多个项目中反映),并且您不需要担心匹配分支</li></ul><p id="09bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回到配置。</p><p id="e33b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mz na nb nc b">branches:</code>部分是由<strong class="kf ir">语义发布</strong>采取行动的分支列表，这取决于你的分支模型。记住，这些分支应该被配置为<a class="ae kc" href="https://docs.gitlab.com/ee/user/project/protected_branches.html" rel="noopener ugc nofollow" target="_blank">受保护分支</a>。</p><p id="d9c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个项目都具有以下属性:</p><ul class=""><li id="cb97" class="mq mr iq kf b kg kh kk kl ko ms ks mt kw mu la mv mw mx my bi translated"><code class="fe mz na nb nc b">name</code>:它可以是一个简单的分支名称，也可以是一个<a class="ae kc" href="https://github.com/micromatch/micromatch#matching-features" rel="noopener ugc nofollow" target="_blank"> glob </a>，它将被评估为与当前分支相匹配。例如，<code class="fe mz na nb nc b">master, develop</code>、<code class="fe mz na nb nc b">pre</code>、<code class="fe mz na nb nc b">next</code>是简单的分支名称，而<code class="fe mz na nb nc b">+([0-9])?(.{+([0-9]),x}).x</code>是一个与<code class="fe mz na nb nc b">1.x</code>、<code class="fe mz na nb nc b">2.2.x</code>等分支相匹配的词。使用globs时，考虑使用该测试仪。如果您的存储库中没有实际的分支匹配分支配置中的某个项目，那么配置中的那个项目将被忽略(并且当某个实际的分支匹配时会被考虑)。</li><li id="cdce" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la mv mw mx my bi translated"><code class="fe mz na nb nc b">channel</code>:忽略它，除非你知道你需要一个发布渠道，这取决于你发布的工件。知道使用时默认为<code class="fe mz na nb nc b">name</code>。更多信息见<a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/usage/workflow-configuration#channel" rel="noopener ugc nofollow" target="_blank">此处</a></li><li id="318d" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la mv mw mx my bi translated"><code class="fe mz na nb nc b">range</code>:使一个分支成为<a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/usage/workflow-configuration#maintenance-branches" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">维护</strong> </a>分支。<code class="fe mz na nb nc b">range</code>的值必须是整个项目中唯一的<strong class="kf ir"/>，并且必须是<code class="fe mz na nb nc b">N.M.x</code>或<code class="fe mz na nb nc b">N.x</code>的形式，其中<code class="fe mz na nb nc b">N</code>和<code class="fe mz na nb nc b">M</code>是数字(而<code class="fe mz na nb nc b">x</code>是固定的)。当分支<code class="fe mz na nb nc b">name</code>被定义为一个glob时，<code class="fe mz na nb nc b">range</code>由此被推断出来，因此所有匹配该glob的实际分支将有一个关联的<code class="fe mz na nb nc b">range</code>，这使得它们成为<strong class="kf ir">维护</strong>分支。换句话说，你不需要自己设置<code class="fe mz na nb nc b">range</code>属性</li><li id="76bb" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la mv mw mx my bi translated"><code class="fe mz na nb nc b">prerelease</code>:这是一个字符串，被<strong class="kf ir">语义发布</strong>用来在发布名称的末尾附加一个限定符。该属性使分支成为<a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/usage/workflow-configuration#pre-release-branches" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">预发布</strong> </a>分支。例如，如果<code class="fe mz na nb nc b">prerelease</code>是<code class="fe mz na nb nc b">alpha</code>，<strong class="kf ir">语义释放</strong>将产生类似<code class="fe mz na nb nc b">1.0.0-alpha.1</code>(更一般的是<code class="fe mz na nb nc b">x.y.z-alpha.j</code>)的释放。该属性也可以设置为<code class="fe mz na nb nc b">true</code>，在这种情况下，用于标识符的字符串是<code class="fe mz na nb nc b">name</code></li></ul><p id="6a35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mz na nb nc b">name</code>是分支或glob中唯一必须定义的属性，如果没有使用其他属性，分支可以只由<code class="fe mz na nb nc b">name</code>定义，就像上面配置示例中的<code class="fe mz na nb nc b">master</code>分支一样。当仅定义了<code class="fe mz na nb nc b">name</code>时，其他属性被默认。</p><p id="7a3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然没有明确设置，但每一项都有一个<a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/usage/workflow-configuration#branch-types" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"/></a>(记住<em class="ni">常规</em>、<em class="ni">前置</em>、<em class="ni">后置</em>科)在其中:</p><ul class=""><li id="505a" class="mq mr iq kf b kg kh kk kl ko ms ks mt kw mu la mv mw mx my bi translated"><strong class="kf ir">(常规)</strong> <a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/usage/workflow-configuration#release-branches" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">发布</strong> </a>:这些是发布版本实际被评估和发布的分支。默认情况下，对于不属于其他类型的所有分支，都会推断出这种类型的分支。<strong class="kf ir">语义发布</strong>需要至少一个发布分支，最多允许四个。除非你有不同的风格，平台等，你只需要一个发布分支。更多信息参见下面的<em class="ni">版本范围</em>部分</li><li id="72e2" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la mv mw mx my bi translated"><a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/usage/workflow-configuration#maintenance-branches" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">维护</strong> </a> <strong class="kf ir">(后发布)</strong>:这些分支是用来发布旧版本之上的版本(比如补丁和补丁)。例如，维护分支<code class="fe mz na nb nc b">1.0.x</code>是发布<code class="fe mz na nb nc b">v1.0.0</code>到<code class="fe mz na nb nc b">v1.0.N</code>的维护分支。维护发布的存在是为了避免在<em class="ni">版本范围</em>约束中发生，它们只是通过<code class="fe mz na nb nc b">range</code>属性的存在来推断，所以当一个分支定义了<code class="fe mz na nb nc b">range</code>时，它会自动被认为是一个维护分支</li><li id="881e" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la mv mw mx my bi translated"><a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/usage/workflow-configuration#pre-release-branches" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">预发布</strong> </a>:这些分支机构是为了在发布分支机构发布的常规发布之前发布发布。这些发布由一个结尾限定符(分支中定义的<code class="fe mz na nb nc b">prerelease</code>)限定，应该用于测试和预览目的</li></ul><p id="5818" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记住:<strong class="kf ir">你不能在配置中定义分支的类型，因为它总是由其他属性</strong>推断出来的。</p><p id="49f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你有多个发布分支时(比如说<code class="fe mz na nb nc b">master</code>和<code class="fe mz na nb nc b">preview</code>，其中<code class="fe mz na nb nc b">preview</code>是在<code class="fe mz na nb nc b">master</code>之前发布的版本)<strong class="kf ir">它们被定义的顺序关系到</strong>和<em class="ni">，因为在给定分支上发布的版本必须总是高于在前一个分支</em>上发布的版本。因此，在本例中，<code class="fe mz na nb nc b">master</code>必须在<code class="fe mz na nb nc b">preview</code>之前定义，因为它将在为<code class="fe mz na nb nc b">preview</code>标记后标记某个版本。更多信息请参见<a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/usage/workflow-configuration#pushing-to-a-release-branch" rel="noopener ugc nofollow" target="_blank">官方文件</a>。</p><h1 id="2e16" class="lz lc iq bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">配置GitLab CI管道</h1><p id="a75c" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">现在剩下要做的就是在<a class="ae kc" href="https://docs.gitlab.com/ee/ci/" rel="noopener ugc nofollow" target="_blank">管道配置</a>中添加一个作业来运行<strong class="kf ir">语义释放</strong>。</p><p id="89cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在repo的根目录中打开<code class="fe mz na nb nc b"><a class="ae kc" href="https://docs.gitlab.com/ee/ci/yaml/" rel="noopener ugc nofollow" target="_blank">.gitlab-ci.yml</a></code>文件(或者其他文件，如果您没有使用默认名称),然后添加一个作业，如下所示:</p><pre class="nk nl nm nn gt no nc np nq aw nr bi"><span id="2f03" class="lb lc iq nc b gy ns nt l nu nv">stages:<br/>  # your existing stages here<br/>  [...]<br/>  - release</span><span id="feb4" class="lb lc iq nc b gy nw nt l nu nv"># your existing jobs here<br/>[...]</span><span id="3946" class="lb lc iq nc b gy nw nt l nu nv">release:<br/>  image: node:13<br/>  stage: release<br/>  only:<br/>    refs:<br/>    - master<br/>    - alpha<br/>    # This matches maintenance branches<br/>    - /^(([0-9]+)\.)?([0-9]+)\.x/<br/>    # This matches pre-releases<br/>    - /^([0-9]+)\.([0-9]+)\.([0-9]+)(?:-([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?(?:\+[0-9A-Za-z-]+)?$/ <br/>  script:<br/>    - npm install <a class="ae kc" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank">@semantic</a>-release/gitlab<br/>    - npx semantic-release</span></pre><p id="0eeb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在这里做的是:</p><ul class=""><li id="1dfa" class="mq mr iq kf b kg kh kk kl ko ms ks mt kw mu la mv mw mx my bi translated">在管道末端增加<code class="fe mz na nb nc b">release</code> <a class="ae kc" href="https://docs.gitlab.com/ee/ci/yaml/#stages" rel="noopener ugc nofollow" target="_blank">阶段</a>(在<code class="fe mz na nb nc b">stages:</code>部分)(必须在末端，在建造、测试等之后)</li><li id="a6d2" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la mv mw mx my bi translated">添加<code class="fe mz na nb nc b">release</code>作业(在<code class="fe mz na nb nc b">release:</code>部分)来运行<strong class="kf ir">语义发布</strong>。作业在<a class="ae kc" href="https://hub.docker.com/_/node" rel="noopener ugc nofollow" target="_blank">节点</a>容器(<code class="fe mz na nb nc b">image: node:13</code>)中运行。考虑到<strong class="kf ir">语义发布</strong> <a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/#requirements" rel="noopener ugc nofollow" target="_blank">需要node . js 10.13或更高版本</a>。当流水线运行到我们希望触发<strong class="kf ir">语义释放</strong>的特定分支时，作业在<code class="fe mz na nb nc b">release</code>阶段(<code class="fe mz na nb nc b">stage: release</code>和<code class="fe mz na nb nc b">only</code>执行。然后，实际的<code class="fe mz na nb nc b">script:</code>运行所需的任务来安装所需的插件，并安装/运行<strong class="kf ir">语义发布</strong></li></ul><p id="dda9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里需要强调几点:</p><ul class=""><li id="585c" class="mq mr iq kf b kg kh kk kl ko ms ks mt kw mu la mv mw mx my bi translated"><code class="fe mz na nb nc b"><a class="ae kc" href="https://docs.gitlab.com/ee/ci/yaml/#onlyrefsexceptrefs" rel="noopener ugc nofollow" target="_blank">only:</a></code>部分是可选的，但是对于所有那些不需要运行<strong class="kf ir">语义释放</strong>的分支来说，它使管道更快。如果你省略这个部分，那么<code class="fe mz na nb nc b">release:</code>任务总是被执行，即使当<strong class="kf ir">语义释放</strong>仅仅因为无事可做而决定跳过动作。然而，这仍然意味着下载Docker映像并执行命令，增加了无用的工作和时间。如果您使用<code class="fe mz na nb nc b">only:</code>部分，请确保您在这里指定的分支和标签与上面的<strong class="kf ir">语义发布</strong>配置文件<code class="fe mz na nb nc b">.releaserc.yml</code>的<code class="fe mz na nb nc b">branches:</code>部分中配置的相匹配(这次使用<a class="ae kc" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank"> regexp </a></li><li id="d6a9" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la mv mw mx my bi translated">如果你有更多的<a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/extending/plugins-list" rel="noopener ugc nofollow" target="_blank">插件</a>(配置在<strong class="kf ir">语义发布</strong>配置文件的<code class="fe mz na nb nc b">plugins:</code>部分)或者<a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/extending/shareable-configurations-list" rel="noopener ugc nofollow" target="_blank">可共享配置</a>，你需要通过修改<code class="fe mz na nb nc b">npm install</code>命令来安装它们。您可以在同一个命令行上添加任意多的插件，例如:<code class="fe mz na nb nc b">@npm install @semantic-release/gitlab @semantic-release/exec</code>添加了<code class="fe mz na nb nc b">@semantic-release/exec</code>插件</li><li id="01f9" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la mv mw mx my bi translated"><code class="fe mz na nb nc b">npx semantic-release</code>命令既下载又运行<strong class="kf ir">语义发布</strong>，所以它是动作发生的地方</li></ul><h1 id="b4bd" class="lz lc iq bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">准备好了吗</h1><p id="061d" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">你现在可以走了。只需提交并合并请求，您就会看到您的发布流。</p><p id="5427" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请记住，<strong class="kf ir">语义发布</strong>默认使用<a class="ae kc" href="https://github.com/semantic-release/semantic-release#commit-message-format" rel="noopener ugc nofollow" target="_blank">角度提交消息约定</a>来解析提交消息，并以<a class="ae kc" href="https://github.com/conventional-changelog/conventional-changelog" rel="noopener ugc nofollow" target="_blank">传统格式</a>生成变更日志，因此当您提交时，只需使用该格式的消息。</p><p id="16e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之，要让<strong class="kf ir">语义发布</strong>自动管理我们的发布，我们要做的就是:</p><ol class=""><li id="985d" class="mq mr iq kf b kg kh kk kl ko ms ks mt kw mu la nx mw mx my bi translated">生成一个个人访问令牌并设置<code class="fe mz na nb nc b">GITLAB_TOKEN</code>变量来保存它的值</li><li id="a4f4" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la nx mw mx my bi translated">在项目根中创建<strong class="kf ir">语义发布</strong>配置文件(<code class="fe mz na nb nc b">.releaserc.yml</code>)来设置插件和工作流(分支)</li><li id="dea4" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la nx mw mx my bi translated">在管道配置(<code class="fe mz na nb nc b">.gitlab-ci.yml</code>)中添加一个作业来运行<strong class="kf ir">语义发布</strong></li></ol><p id="b0c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面你可以找到关于定制案例和内部的进一步讨论。</p><h1 id="621c" class="lz lc iq bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">在幕后</h1><p id="31c7" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">根据上面的设置，如果您想知道当管道被触发时会发生什么，下面是详细信息:</p><ol class=""><li id="db9b" class="mq mr iq kf b kg kh kk kl ko ms ks mt kw mu la nx mw mx my bi translated">当一个新的提交发生时(通过<code class="fe mz na nb nc b">git push</code>或合并), GitLab启动一个新的管道</li><li id="d69e" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la nx mw mx my bi translated">当管道运行启动<strong class="kf ir">语义释放</strong>的作业时，流程按照配置的顺序，为每个插件执行每个<a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/#release-steps" rel="noopener ugc nofollow" target="_blank">释放步骤</a></li><li id="5cfc" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la nx mw mx my bi translated">最新版本是通过检查<a class="ae kc" href="https://git-scm.com/book/en/v2/Git-Basics-Tagging" rel="noopener ugc nofollow" target="_blank">标签</a>和提交消息来确定的</li><li id="95ac" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la nx mw mx my bi translated"><code class="fe mz na nb nc b">analyzeCommits</code>(唯一需要的步骤)决定了是否需要创建一个新的版本，如果需要，是什么类型</li><li id="69d6" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la nx mw mx my bi translated">每个插件执行其核心任务，如生成发行说明、变更日志或创建标签。默认情况下，根据<a class="ae kc" href="https://github.com/semantic-release/semantic-release#commit-message-format" rel="noopener ugc nofollow" target="_blank">角度提交消息约定</a>解释变更日志</li><li id="5fd3" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la nx mw mx my bi translated">然后发布并由插件通知</li></ol><p id="101b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意<strong class="kf ir">语义发布</strong>不在Git存储库中存储状态文件来保存当前版本。相反，它只检查提交历史来确定当前版本和下一个版本。这使得它更干净，侵入性更小，避免你的回购混乱。</p><h2 id="7d10" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">语义发布如何决定何时标记一个版本？</h2><p id="78eb" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><strong class="kf ir">语义发布</strong>做出这个决定的依据是:</p><ul class=""><li id="718e" class="mq mr iq kf b kg kh kk kl ko ms ks mt kw mu la mv mw mx my bi translated">提交的分支(通过合并请求或者<code class="fe mz na nb nc b">push</code>)必须在工作流配置中进行配置(配置文件的<code class="fe mz na nb nc b">branches</code>部分)</li><li id="3273" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la mv mw mx my bi translated">提交消息的格式或合并请求的标题必须匹配为<code class="fe mz na nb nc b"><a class="ae kc" href="https://github.com/semantic-release/commit-analyzer" rel="noopener ugc nofollow" target="_blank">@semantic-release/commit-analyzer</a></code>插件配置的格式之一(通常配置为使用预置)</li></ul><p id="7d9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些条件<strong class="kf ir">必须都为真</strong>，否则<strong class="kf ir">语义释放</strong>将跳过提交的版本控制。</p><p id="01a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当创建<a class="ae kc" href="https://docs.gitlab.com/ee/user/project/merge_requests/" rel="noopener ugc nofollow" target="_blank">合并请求</a>时，您经常<a class="ae kc" href="https://docs.gitlab.com/ee/user/project/merge_requests/squash_and_merge.html" rel="noopener ugc nofollow" target="_blank">挤压</a>属于合并的提交。这是避免混淆提交历史的好方法，但是从<strong class="kf ir">语义发布</strong>的角度来看，它使得单次提交的消息不可见。换句话说，如果你的意思是提交通过它们的提交消息触发一个释放，你会看到<strong class="kf ir">语义释放</strong>没有版本化来自合并请求的提交，因为它不再看到那些消息。这是真的，除非你将合并请求的标题设置为重要消息，在这种情况下<strong class="kf ir">语义释放</strong>能够检测到消息并触发版本。</p><h1 id="f017" class="lz lc iq bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">版本范围</h1><p id="de41" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">如果您配置了同一个<a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/usage/workflow-configuration#branch-types" rel="noopener ugc nofollow" target="_blank">类型</a>的多个分支，您可能会遇到<code class="fe mz na nb nc b">EINVALIDNEXTVERSION</code>错误，看起来是这样的:</p><pre class="nk nl nm nn gt no nc np nq aw nr bi"><span id="a941" class="lb lc iq nc b gy ns nt l nu nv"> [3:54:19 PM] [semantic-release] › ✖  EINVALIDNEXTVERSION The release `x.y.z` on branch `name` cannot be published as it is out of range.<br/> Based on the releases published on other branches, only versions within the range &gt;=x.y.z &lt;x.y.z can be published from branch name.</span></pre><p id="82e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此错误意味着一个分支上的一个提交应该使用与同一类型的另一个分支的现有版本冲突的版本号进行版本控制，这破坏了跨分支的版本号的唯一性。</p><p id="92ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来自<a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/usage/workflow-configuration#release-branches" rel="noopener ugc nofollow" target="_blank">官方文件</a>:</p><blockquote class="ny nz oa"><p id="bea1" class="kd ke ni kf b kg kh ki kj kk kl km kn ob kp kq kr oc kt ku kv od kx ky kz la ij bi translated">一个项目必须定义最少1个发布分支，最多3个。发布分支定义的顺序是很重要的，因为在给定分支上发布的版本必须总是高于在前一个分支上发布的版本。这可以避免出现试图发布相同版本号但不同代码库的版本的情况。当配置了多个发布分支，并且推送了一个会产生版本冲突的提交时，<strong class="kf ir">语义发布</strong>将不会执行发布，并且会抛出一个<code class="fe mz na nb nc b">EINVALIDNEXTVERSION</code>错误，列出有问题的提交以及将它们移动到的有效分支。</p></blockquote><p id="67f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要解决这个问题，您可以避免拥有多个相同类型的分支(即<code class="fe mz na nb nc b">release</code>，或者通过工作流配置中的<code class="fe mz na nb nc b">range</code>属性为分支分配特定的范围(<strong class="kf ir">语义发布</strong>配置文件的<code class="fe mz na nb nc b">branches</code>部分)。更多信息请点击查看<a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/usage/workflow-configuration" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="9e45" class="lz lc iq bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">其他使用案例</h1><h2 id="4a44" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">发布变更日志文件</h2><p id="6a54" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">如果您还想生成<code class="fe mz na nb nc b">CHANGELOG</code>文件，而不仅仅是在GitLab的UI版本中显示它，可以通过以下方式将<code class="fe mz na nb nc b">changelog</code>插件添加到<code class="fe mz na nb nc b">.releaserc.yml</code>文件中:</p><pre class="nk nl nm nn gt no nc np nq aw nr bi"><span id="76ad" class="lb lc iq nc b gy ns nt l nu nv">plugins:<br/>- "<a class="ae kc" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank">@semantic</a>-release/commit-analyzer"<br/>- "<a class="ae kc" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank">@semantic</a>-release/release-notes-generator"<br/><strong class="nc ir">- - "</strong><a class="ae kc" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank"><strong class="nc ir">@semantic</strong></a><strong class="nc ir">-release/changelog"<br/>  - changelogFile: CHANGELOG.md</strong><br/>- "<a class="ae kc" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank">@semantic</a>-release/gitlab"<br/>branches:<br/>- "master"<br/>- "+([0-9])?(.{+([0-9]),x}).x"<br/>- name: "alpha"<br/>  prerelease: "alpha"</span></pre><p id="6915" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样,<code class="fe mz na nb nc b">CHANGELOG.md</code>文件就在项目的根文件夹中生成了。您可以更改文件名或其相对于根目录的路径。</p><p id="3337" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要将插件添加到<code class="fe mz na nb nc b">.gitlab-ci.yml</code>文件中，顺便说一下，为了不在作业结束时丢失生成的文件，我们还(可选地)将它发布到<a class="ae kc" href="https://docs.gitlab.com/ee/ci/yaml/#artifacts" rel="noopener ugc nofollow" target="_blank">管道工件</a>中:</p><pre class="nk nl nm nn gt no nc np nq aw nr bi"><span id="118a" class="lb lc iq nc b gy ns nt l nu nv">release:<br/>  image: node:13<br/>  stage: release<br/>  only:<br/>    refs:<br/>    - master<br/>    - alpha<br/>    # This matches maintenance branches<br/>    - /^(([0-9]+)\.)?([0-9]+)\.x/<br/>    # This matches pre-releases<br/>    - /^([0-9]+)\.([0-9]+)\.([0-9]+)(?:-([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?(?:\+[0-9A-Za-z-]+)?$/ <br/>  script:<br/>    - touch CHANGELOG.md<br/>    - npm install <a class="ae kc" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank">@semantic</a>-release/gitlab <a class="ae kc" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank"><strong class="nc ir">@semantic</strong></a><strong class="nc ir">-release/changelog</strong><br/>    - npx semantic-release<br/>  <strong class="nc ir">artifacts:<br/>    paths:<br/>    - CHANGELOG.md</strong></span></pre><p id="6115" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<strong class="kf ir">语义发布</strong>确定没有要发布的文件时，为了避免由于没有要发布的文件而导致的作业失败，<code class="fe mz na nb nc b">touch CHANGELOG.md</code>是有用的。</p><h2 id="8f74" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">在发布步骤之前知道版本号</h2><p id="5488" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">记住<strong class="kf ir">语义发布</strong>必须在管道的末端运行，因为发布是构建、测试等之后的最后一步。但是，有时您不能等到管道结束时才知道版本号，例如:</p><ul class=""><li id="3c42" class="mq mr iq kf b kg kh kk kl ko ms ks mt kw mu la mv mw mx my bi translated">您需要在某个地方以某种方式构建包含版本号的工件</li><li id="67f3" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la mv mw mx my bi translated">测试需要测试和发布的工件之间的一致性</li><li id="e11b" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la mv mw mx my bi translated">依赖性管理和工件目录需求</li><li id="7129" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la mv mw mx my bi translated">还有更多…</li></ul><p id="f7e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论是哪种情况，当最终仍然运行发布工作时，您需要在构建管道的早期阶段获取版本号。在这里，我们要处理这个问题。请记住:</p><ul class=""><li id="c209" class="mq mr iq kf b kg kh kk kl ko ms ks mt kw mu la mv mw mx my bi translated">这种用法被<strong class="kf ir"> semantic-release </strong>所反对，它遵循一种纯粹主义的方法，认为版本号应该在实际的发布步骤中生成</li><li id="8598" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la mv mw mx my bi translated"><strong class="kf ir">语义发布</strong>将只在它知道的分支(发布分支、预发布和维护)中运行管道时给我们版本号，而在其他分支(即特性分支)中，如果被调用，它将跳过，因此<strong class="kf ir">在这种情况下，您需要生成自己的版本号(与版本号模式无关，以避免冲突)</strong>。我们也会处理这个问题</li></ul><p id="f848" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，为了完成这项工作，我们将扩展<strong class="kf ir">语义发布</strong>配置，以便使用一个额外的插件<code class="fe mz na nb nc b"><a class="ae kc" href="https://github.com/semantic-release/exec" rel="noopener ugc nofollow" target="_blank">@semantic-release/exec</a></code>，它允许我们运行在<strong class="kf ir">语义发布</strong>工作流步骤中编排的任意命令。更详细地说，我们将在<code class="fe mz na nb nc b">verifyRelease</code>步骤中使用该插件(这发生在前面步骤中的其他插件评估提交历史之后)，但在使用<code class="fe mz na nb nc b"><a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/usage/configuration#dryrun" rel="noopener ugc nofollow" target="_blank">--dry-run</a></code>选项时被忽略的其他插件之前。在这个阶段，我们使用预演，因为我们还没有发布任何版本，只是<a class="ae kc" href="https://github.com/semantic-release/semantic-release/blob/master/docs/developer-guide/js-api.md" rel="noopener ugc nofollow" target="_blank">偷偷进入API </a>。</p><p id="1c3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是<code class="fe mz na nb nc b">.releaserc.yml</code>的样子:</p><pre class="nk nl nm nn gt no nc np nq aw nr bi"><span id="5aab" class="lb lc iq nc b gy ns nt l nu nv">plugins:<br/>- "<a class="ae kc" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank">@semantic</a>-release/commit-analyzer"<br/>- "<a class="ae kc" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank">@semantic</a>-release/release-notes-generator"<br/><strong class="nc ir">- - "</strong><a class="ae kc" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank"><strong class="nc ir">@semantic</strong></a><strong class="nc ir">-release/exec"<br/>  - verifyReleaseCmd: "echo ${nextRelease.version} &gt; VERSION.txt"</strong><br/>- "<a class="ae kc" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank">@semantic</a>-release/gitlab"<br/>branches:<br/>- "master"<br/>- "+([0-9])?(.{+([0-9]),x}).x"<br/>- name: "alpha"<br/>  prerelease: "alpha"</span></pre><p id="dde6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你所看到的，新的<code class="fe mz na nb nc b">exec</code>插件只是将下一个版本号保存到一个平面文件<code class="fe mz na nb nc b">VERSION.txt</code>，我们稍后将在管道中看到。</p><p id="e4cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mz na nb nc b">.gitlab-ci.yml</code>管道配置:</p><pre class="nk nl nm nn gt no nc np nq aw nr bi"><span id="fb00" class="lb lc iq nc b gy ns nt l nu nv">stages:<br/>  <strong class="nc ir">- fetch-version</strong><br/>  - build<br/>  - release</span><span id="2ba3" class="lb lc iq nc b gy nw nt l nu nv">fetch-semantic-version:<br/>  # Requires Node &gt;= 10.13 version<br/>  image: node:13<br/>  <strong class="nc ir">stage: fetch-version</strong><br/>  <strong class="nc ir">only:</strong><br/>    refs:<br/>    - master<br/>    - alpha<br/>    - /^(([0-9]+)\.)?([0-9]+)\.x/ # This matches maintenance branches<br/>    - /^([0-9]+)\.([0-9]+)\.([0-9]+)(?:-([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?(?:\+[0-9A-Za-z-]+)?$/ # This matches pre-releases<br/>  script:<br/>    - npm install <a class="ae kc" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank">@semantic</a>-release/gitlab <a class="ae kc" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank">@semantic</a>-release/exec<br/>    - npx semantic-release <strong class="nc ir">--generate-notes false --dry-run</strong><br/>  <strong class="nc ir">artifacts:<br/>    paths:<br/>    - VERSION.txt</strong></span><span id="d5f5" class="lb lc iq nc b gy nw nt l nu nv">generate-non-semantic-version:<br/>  <strong class="nc ir">stage: fetch-version</strong><br/>  <strong class="nc ir">except:</strong><br/>    refs:<br/>    - master<br/>    - alpha<br/>    - /^(([0-9]+)\.)?([0-9]+)\.x/ # This matches maintenance branches<br/>    - /^([0-9]+)\.([0-9]+)\.([0-9]+)(?:-([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?(?:\+[0-9A-Za-z-]+)?$/ # This matches pre-releases<br/>  script:<br/>    <strong class="nc ir">- echo build-$CI_PIPELINE_ID &gt; VERSION.txt<br/>  artifacts:<br/>    paths:<br/>    - VERSION.txt</strong></span><span id="3234" class="lb lc iq nc b gy nw nt l nu nv">build:<br/>  stage: build<br/>  script:<br/>    - echo "Version is <strong class="nc ir">$(cat VERSION.txt)</strong>"</span><span id="9d8b" class="lb lc iq nc b gy nw nt l nu nv">release:<br/>  image: node:13<br/>  stage: release<br/>  only:<br/>    refs:<br/>    - master<br/>    - alpha<br/>    # This matches maintenance branches<br/>    - /^(([0-9]+)\.)?([0-9]+)\.x/<br/>    # This matches pre-releases<br/>    - /^([0-9]+)\.([0-9]+)\.([0-9]+)(?:-([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?(?:\+[0-9A-Za-z-]+)?$/ <br/>  script:<br/>    - npm install <a class="ae kc" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank">@semantic</a>-release/gitlab<br/>    - npx semantic-release</span></pre><p id="fc12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它看起来像很多东西，但你可以找到一些相关的部分用粗体显示。我们在这里做什么:</p><ol class=""><li id="1aef" class="mq mr iq kf b kg kh kk kl ko ms ks mt kw mu la nx mw mx my bi translated">在管道中定义一个名为<code class="fe mz na nb nc b">fetch-version</code>的新阶段。这个阶段在管道的开始运行，以获取或生成版本号并使其可用</li><li id="eb54" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la nx mw mx my bi translated">在<strong class="kf ir">语义发布</strong>管理的分支上，定义一个在<code class="fe mz na nb nc b">fetch-version</code>阶段<code class="fe mz na nb nc b"><strong class="kf ir">only</strong></code> <strong class="kf ir"> </strong>运行的新作业<code class="fe mz na nb nc b">fetch-semantic-version</code>。这一次，我们使用选项<code class="fe mz na nb nc b">--generate-notes false --dry-run</code>来避免应用任何更改。然而，这仍然会生成<code class="fe mz na nb nc b">VERSION.txt</code>文件，因为我们已经有了<strong class="kf ir">语义发布</strong>配置</li><li id="dd9b" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la nx mw mx my bi translated">定义另一个作业<code class="fe mz na nb nc b">generate-non-semantic-version</code>，它也在<code class="fe mz na nb nc b">fetch-version</code>阶段运行，但是只在构建非发布分支(与<code class="fe mz na nb nc b">fetch-semantic-version</code>相反)时运行，并生成一个<code class="fe mz na nb nc b">VERSION.txt</code>文件，该文件具有非语义版本id，与常规版本号不冲突，但是我们仍然可以使用它来构建和测试工件。这里生成的版本id的形式是<code class="fe mz na nb nc b">build-&lt;PIPELINE_ID&gt;</code>，但是您可以选择任何其他形式，比如时间戳、sha或随机数。如果在预发布阶段不需要版本号，可以跳过定义这个作业，但是如果需要，嵌套阶段可以以幂等的方式运行，依赖于版本id的存在</li><li id="c725" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la nx mw mx my bi translated">在两个作业中生成<code class="fe mz na nb nc b">VERSION.txt</code>文件(当然您可以使用任何其他名称),并将其发布为一个<a class="ae kc" href="https://docs.gitlab.com/ee/ci/yaml/#artifacts" rel="noopener ugc nofollow" target="_blank">工件</a>,因为它需要在不同的构建作业中可用</li><li id="b6b2" class="mq mr iq kf b kg nd kk ne ko nf ks ng kw nh la nx mw mx my bi translated">定义另一个示例作业<code class="fe mz na nb nc b">build</code>，该作业仅显示使用<code class="fe mz na nb nc b">VERSION.txt</code>中的值的一个示例，而不管该值是如何以及何时生成的</li></ol></div></div>    
</body>
</html>