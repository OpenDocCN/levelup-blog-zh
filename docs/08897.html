<html>
<head>
<title>Trading Cup and Handles With MarketSmith Pattern Recognition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有MarketSmith模式识别的交易杯和手柄</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/trading-cup-and-handles-with-marketsmith-pattern-recognition-3b869d0cfe2a?source=collection_archive---------4-----------------------#2021-06-16">https://levelup.gitconnected.com/trading-cup-and-handles-with-marketsmith-pattern-recognition-3b869d0cfe2a?source=collection_archive---------4-----------------------#2021-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="73e4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">回溯测试威廉·奥尼尔的经典基本模式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5c79c03941b3965709d79b2f421a4178.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eEY88MUia1LdXC_P"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Julian Hochgesang 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="fecf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由威廉·奥尼尔开发的“有把手的杯子”是一个技术指标，用来识别经过一段时间的盘整后趋势的延续。[1]它包括一个不太成熟的初始上升趋势，一个U形走势(杯子)，接着是另一个剧烈而轻微的震荡(手柄)。价格在反弹后，开始以平滑的斜率盘整，但随后反弹至之前的高点，因为它面临较低价格水平的支撑。</p><p id="2eea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当触及前期高点时，在盘整前买入股票的投资者和其他不太忠诚的投资者卖出股票，最后一次推动股价下跌。最终，价格从第二个支撑位(高于前一个支撑位)开始反转，并突破阻力。交易者使用不同的规则来识别有手柄图案的杯子，并衡量它们的强度，但底部通常持续6-65周，深度从8%到50%不等。当交易有手柄的杯子时，利润目标通常在初始阻力(支点)以上20–25%，止损范围在该线以下5–8%。[2]</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/d21e1b3c472c5186198156a4c4c08106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wO_PHBUgGQnzISvf.png"/></div></div></figure><p id="61fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://marketsmith.investors.com/patternrecognition/" rel="noopener ugc nofollow" target="_blank">模式识别</a>，IBD MarketSmith的高级交易工具包的一部分，在每日和每周的时间周期内识别七种不同的图表模式:带把的杯子和杯子，带把的碟子和碟子，双底，平底，上升底，盘整，IPO底。本文将重点介绍使用模式识别API来识别和交易带手柄模式的杯子。要了解更多关于模式识别的其他属性的信息，请查看其<a class="ae kv" href="https://marketsmith.investors.com/special/MS_PatternRecManual_1-7-5.pdf" rel="noopener ugc nofollow" target="_blank">用户手册</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/5764695dfb2023ee9179e9e7bf344508.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NlI1bwftKWZXTZcajyz0DA.png"/></div></div></figure><h1 id="87a5" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">先决条件</h1><p id="6e4b" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">需要对Python有一个基本的了解，才能从本文中获得最大的收获。我们将使用<code class="fe mr ms mt mu b"><a class="ae kv" href="https://pydantic-docs.helpmanual.io/" rel="noopener ugc nofollow" target="_blank">pydantic</a></code>来验证和序列化数据，<code class="fe mr ms mt mu b"><a class="ae kv" href="https://github.com/stefan-jansen/zipline-reloaded" rel="noopener ugc nofollow" target="_blank">zipline-reloaded</a></code>和<code class="fe mr ms mt mu b"><a class="ae kv" href="https://github.com/quantopian/pyfolio/" rel="noopener ugc nofollow" target="_blank">pyfolio</a></code>来回溯测试策略，<code class="fe mr ms mt mu b"><a class="ae kv" href="https://pandas.pydata.org/docs/" rel="noopener ugc nofollow" target="_blank">pandas</a></code>来加载和访问数据，<code class="fe mr ms mt mu b"><a class="ae kv" href="https://github.com/theskumar/python-dotenv" rel="noopener ugc nofollow" target="_blank">python-dotenv</a></code>来读取环境变量，<code class="fe mr ms mt mu b"><a class="ae kv" href="https://pypi.org/project/yfinance/" rel="noopener ugc nofollow" target="_blank">yfinance</a></code>来获取基准价格数据，<code class="fe mr ms mt mu b"><a class="ae kv" href="https://docs.python-requests.org/" rel="noopener ugc nofollow" target="_blank">requests</a></code>来进行API调用。访问模式识别需要一个<a class="ae kv" href="https://marketsmith.investors.com/ms-platform/#row7" rel="noopener ugc nofollow" target="_blank"> premium MarketSmith帐户</a>。符号数据和道琼斯工业平均指数(DJIA)成分列表将从<a class="ae kv" href="https://financialmodelingprep.com/developer/docs/" rel="noopener ugc nofollow" target="_blank">金融建模准备(FMP) v3 API </a>中获取。为了检索成分的历史价格数据，您需要<a class="ae kv" href="https://zipline.ml4trading.io/bundles.html" rel="noopener ugc nofollow" target="_blank">接收一个zipline数据包</a>。</p><p id="8f67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请确保使用以下版本:</p><ul class=""><li id="4771" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated"><code class="fe mr ms mt mu b">python</code> 3.6.12</li><li id="b3dd" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><code class="fe mr ms mt mu b">pyfolio</code> 0.8.0</li><li id="ab9c" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><code class="fe mr ms mt mu b">pandas</code> 0.22.0</li><li id="a6b5" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><code class="fe mr ms mt mu b">matplotlib</code> 3.0.3</li><li id="31f1" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><code class="fe mr ms mt mu b">numpy</code> 1.19.5</li></ul><p id="d4ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，您需要遵循<a class="ae kv" href="https://github.com/quantopian/pyfolio/issues/661#issuecomment-742053547" rel="noopener ugc nofollow" target="_blank">这个答案</a>并更新<code class="fe mr ms mt mu b">pyfolio</code>源代码中的一行代码，使其与最新的堆栈一起工作。</p><h1 id="4545" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">加载和存储数据</h1><h2 id="374a" class="nj lv iq bd lw nk nl dn ma nm nn dp me lf no np mg lj nq nr mi ln ns nt mk nu bi translated">DJIA成分</h2><p id="3ca6" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">有了一个免费的FMP账户，我们可以从这个端点<a class="ae kv" href="https://financialmodelingprep.com/api/v3/dowjones_constituent" rel="noopener ugc nofollow" target="_blank">访问DJIA的名字列表</a>。首先，创建<code class="fe mr ms mt mu b">src/price/endpoints.py</code>来存储FMP端点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="9a47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">定义<code class="fe mr ms mt mu b">Constituent</code>模型来序列化从FMP API接收的数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="9778" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">定义<code class="fe mr ms mt mu b">load_tickers</code>来获取和存储数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="2194" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们首先加载<code class="fe mr ms mt mu b">FMP_API_KEY</code>环境变量，将其传递给在<code class="fe mr ms mt mu b">constants.py</code>中定义的端点，并通过调用<code class="fe mr ms mt mu b">.json()</code>方法将响应转换为字典。然后，我们使用Pydantic的<code class="fe mr ms mt mu b"><a class="ae kv" href="https://pydantic-docs.helpmanual.io/usage/models/#parsing-data-into-a-specified-type" rel="noopener ugc nofollow" target="_blank">parse_obj_as</a></code>实用程序方法将响应序列化为一系列<code class="fe mr ms mt mu b">Constituent</code>实例。最后，数据被转换回字典列表并存储在<code class="fe mr ms mt mu b">data/tickers.csv</code>中。</p><p id="4075" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">确保将<code class="fe mr ms mt mu b">FMP_API_KEY</code>密钥存储在<code class="fe mr ms mt mu b">.env</code>文件中，并将其设置为您从FMP仪表板收到的密钥。现在我们可以从命令行发送<code class="fe mr ms mt mu b">load_tickers</code>。如果运行正常，我们将得到一个类似下图的CSV文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/63cf9f79a52f9b147f4ac777b38ad435.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*htoWQu7d3Jdow8-k--Mixw.png"/></div></div></figure><h2 id="1bc1" class="nj lv iq bd lw nk nl dn ma nm nn dp me lf no np mg lj nq nr mi ln ns nt mk nu bi translated">带手柄数据的杯子</h2><p id="b5af" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">现在，我们应该为<code class="fe mr ms mt mu b">data/tickers.csv</code>中的所有符号加载带有手柄图案的杯子历史。让我们首先定义我们要调用的MarketSmith端点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="8324" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">AuthSession</code>该类将环境变量传递给IBD API，以生成经过验证的会话。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="224d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们首先将用户凭证发送到<code class="fe mr ms mt mu b">GET_LOGIN</code>端点以接收用户对象，然后该用户对象将被传递(连同一个额外的<code class="fe mr ms mt mu b">action</code>键)到<code class="fe mr ms mt mu b">HANDLE_LOGIN</code>。该响应包括必要的<code class="fe mr ms mt mu b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie" rel="noopener ugc nofollow" target="_blank">Set-Cookie</a></code>报头，以便为将来的请求验证会话。不要忘记在<code class="fe mr ms mt mu b">.env</code>中定义<code class="fe mr ms mt mu b">USERNAME</code>、<code class="fe mr ms mt mu b">PASSWORD</code>和<code class="fe mr ms mt mu b">API_KEY</code>值(根据您的MarketSmith帐户凭证)。</p><p id="a0c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在获取模式之前，我们需要加载<code class="fe mr ms mt mu b">Instrument</code>和<code class="fe mr ms mt mu b">User</code>对象。先说后者。定义<code class="fe mr ms mt mu b">User</code>模型来序列化我们将从MarketSmith后端接收的对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="40d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">get_user</code>方法接收经过身份验证的会话，并返回经过身份验证的用户信息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d341" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b"><a class="ae kv" href="https://pydantic-docs.helpmanual.io/usage/validation_decorator/" rel="noopener ugc nofollow" target="_blank">validate_arguments</a></code> decorator在函数被调用之前解析并验证参数。<code class="fe mr ms mt mu b"><a class="ae kv" href="https://pydantic-docs.helpmanual.io/usage/types/#arbitrary-types-allowed" rel="noopener ugc nofollow" target="_blank">arbitrary_types_allowed</a></code>用不扩展pydantic <code class="fe mr ms mt mu b">BaseModel</code>类的实例(在本例中是一个<code class="fe mr ms mt mu b">AuthSession</code>实例)解析参数。</p><p id="6649" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是时候从MS API加载仪器数据了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="bf03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">MS API使用以下格式传递日期:<code class="fe mr ms mt mu b">/Date(1536303600000–0700)/</code>–第一个数字是从纪元开始的<a class="ae kv" href="https://en.wikipedia.org/wiki/Unix_time" rel="noopener ugc nofollow" target="_blank">毫秒日期，第二个数字是与GMT的时区差异。<code class="fe mr ms mt mu b">convert_msdate_to_date</code>方法将MS API日期字符串转换为内置的<code class="fe mr ms mt mu b">datetime.date</code>对象。</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="0c6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">get_instrument</code>在MarketSmith数据库中搜索符号，然后在搜索结果中查找精确匹配。如果符号的精确匹配数不为1，则引发<code class="fe mr ms mt mu b">AssertionError</code>。最后，它将接收到的字典序列化为一个<code class="fe mr ms mt mu b">Instrument</code>实例。</p><p id="19ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正在讨论问题的实质。让我们加载、解析和存储带有句柄模式的Cup。首先，定义一个模型来序列化数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="dda9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们需要一些方法来处理模式的提取和存储。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="cf95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">get_patterns</code>向模式端点发出请求，并接收某一特定时期内某一乐器的所有图表模式。注意，如果你想得到周线图的模式，设置<code class="fe mr ms mt mu b">frequency</code>为2。</p><p id="8c82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">MarketSmith通过instrument对象传递一个<code class="fe mr ms mt mu b">properties</code>属性，该属性将乐器的自定义属性作为一个列表。因为我们只关心有手柄图案的杯子，并且它们共享相同的属性，所以我们使用<code class="fe mr ms mt mu b">flattern_pattern_properties</code>通过移除<code class="fe mr ms mt mu b">properties</code>键并将其列表值的元素添加到我们的初始乐器对象来展平对象。</p><p id="872c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">filter_cup_with_handles</code>接收模式对象列表，并返回其中包含手柄模式的杯子。这种方法的一个“问题”是MS在<code class="fe mr ms mt mu b">cupWithHandles</code>键下传递没有把手的杯子和有把手的杯子，但是只有那些<code class="fe mr ms mt mu b">patternType</code>为1的杯子是有把手的杯子(参见上面代码片段中的第100–102行)。</p><p id="d4fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，<code class="fe mr ms mt mu b">store_patterns</code>接收一个模式实例列表，并将它们附加到一个本地CSV文件中。</p><p id="3764" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，编写一些控制器函数来编排所有之前定义的方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d034" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">convert_csv_to_records</code>读取CSV文件的行并用pydantic模型序列化它们。我们稍后将使用它来读取和解析<code class="fe mr ms mt mu b">tickers.csv</code>文件中的数据。</p><p id="a7b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">extract_patterns</code>接收一个ticker、一个模式类型的过滤方法、开始和结束日期以及一个认证的会话。然后，它编排其他方法来获取和序列化过滤后的模式。</p><p id="3696" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">extract_n_store_cup_with_handles</code>用一列<code class="fe mr ms mt mu b">Constituent</code>对象接受从epoch开始的以毫秒为单位的开始和结束日期，用句柄模式检索它们的cup，并将这些模式存储在<code class="fe mr ms mt mu b">data/patterns.csv</code>文件中。现在，使用所需的参数调用该方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="2781" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">厉害！我们已经完成了数据收集部分。让我们根据这些模式定义一个交易算法，并评估结果。</p><h1 id="335b" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">战略</h1><p id="75e2" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">创建一个Jupyter笔记本来开发、回溯测试和分析策略。首先，导入需求。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d759" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该算法在每个分笔成交点循环模式，如果满足以下所有条件，则对资产进行排序:</p><ul class=""><li id="8af6" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated">当前日期已超过对象的<code class="fe mr ms mt mu b">handleLowDate</code>属性，但未超过30天；</li><li id="adc0" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">现价已突破支点价格水平(杯子第二高点)1%以上；</li><li id="b93a" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">50天简单移动平均线(SMA)在200天SMA的上方。</li></ul><p id="630c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该算法随后会在以下任何情况下平仓:</p><ul class=""><li id="bfd8" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated">这项交易产生了15%或更多的利润；</li><li id="7bef" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">交易导致亏损5%或以上；</li><li id="04ed" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">自开仓以来已过去21天或更长时间。</li></ul><p id="f692" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们用SPY(标准普尔500信托ETF) <strong class="ky ir"> </strong>的收益作为基准，运行2016年到2018年的算法，用一千万美金的资金。让我们将所有这些参数存储在一个单元格中，以便于调整或优化它们。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="dde8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在定义逻辑之前，我们需要一个实用函数，使DataFrame的日期列能够识别时区，这允许我们将<code class="fe mr ms mt mu b">patterns.csv</code>文件中的日期与<code class="fe mr ms mt mu b">zipline</code>内置日期进行比较。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="90d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">滑索需要两个功能:<code class="fe mr ms mt mu b">initialize</code>和<code class="fe mr ms mt mu b">handle_data</code>。前者通过接收参数并向其添加全局变量来设置回溯测试上下文。后者在每个分笔成交点被调用，并接受两个参数——<code class="fe mr ms mt mu b">context</code>(算法的全局上下文)和<code class="fe mr ms mt mu b">data</code>，后者包括特定于当前分笔成交点的信息——并根据当前市场条件进行交易。通过隐藏未来价格数据，zipline确保了逻辑中没有前瞻性偏见。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="30bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，<code class="fe mr ms mt mu b"><a class="ae kv" href="https://zipline.ml4trading.io/api-reference.html#zipline.api.symbol" rel="noopener ugc nofollow" target="_blank">zipline.api.symbol</a></code>方法接收一个ticker并返回相应的<code class="fe mr ms mt mu b"><a class="ae kv" href="https://zipline.ml4trading.io/api-reference.html#zipline.assets.Equity" rel="noopener ugc nofollow" target="_blank">Equity</a></code>对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="7267" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，<code class="fe mr ms mt mu b">data.history</code>加载过去200个交易日的股票列表的价格数据。然后，该方法遍历模式，找到满足所有需求并且还不在投资组合中的实例。开立新头寸时，使用<code class="fe mr ms mt mu b">zp.api.order_target_percent</code>在所有头寸之间平均重新分配资金。最后，代码将当前日期存储在<code class="fe mr ms mt mu b">context.position_dates</code>字典中，以备将来参考。最后，它遍历未结头寸，如果满足任何卖出要求，就卖出资产。</p><p id="c703" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快好了。定义从<code class="fe mr ms mt mu b">yfinance</code>获取基准价格数据的方法，并将其处理为可接受的<code class="fe mr ms mt mu b">pyfolio</code>格式(带日期索引的熊猫系列)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="a79d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，退货是通过调用价格历史数据帧的<code class="fe mr ms mt mu b">Close</code>列上的<code class="fe mr ms mt mu b">pct_change</code>方法来计算的。现在我们需要处理算法的分析。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="91d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">analyze</code>接收两个参数:<code class="fe mr ms mt mu b">perf</code>，zipline <code class="fe mr ms mt mu b">run_algorithm</code>函数的返回值，以及<code class="fe mr ms mt mu b">bench</code>，从先前定义的方法中检索的基准返回。<code class="fe mr ms mt mu b">pf.utils.extract_rets_pos_txn_from_zipline</code>从业绩数据框架中提取日收益、持仓历史以及算法所做的所有交易清单。我们将基准测试和回溯测试结果传递给<code class="fe mr ms mt mu b">pf.create_full_tear_sheet</code>以生成全面的策略分析。最后还是调用<code class="fe mr ms mt mu b">run_algorithm</code>检查结果吧。确保将开始和结束日期转换为本地化的pandas <code class="fe mr ms mt mu b">Timestamp</code>对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="2c06" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">结果</h1><p id="d3ab" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">是时候接受我们应得的报应了。运行<code class="fe mr ms mt mu b">analyze</code>方法后，pyfolio生成一个<a class="ae kv" href="https://nbviewer.jupyter.org/format/slides/github/quantopian/pyfolio/blob/master/pyfolio/examples/pyfolio_talk_slides.ipynb#/10" rel="noopener ugc nofollow" target="_blank">分析表</a>，其中包含几个表格和图表，用于呈现结果的详细分析。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="ce21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于0.08 alpha和0.1 beta，该策略似乎过于被动，这可以通过增加观察名单股票的数量来改善。但该策略的风险回报指标看起来很可靠——值得注意的是，夏普、索蒂诺和卡尔马尔比率显示了在低风险下可以接受的回报。您可以在下面找到策略结果的完整列表。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/30d18b372a9c066cafe0e38e30db9a7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dGnrtg9M0Inn7mF3JqHUOQ.png"/></div></div></figure><h1 id="02e1" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">丰富</h1><p id="ff91" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">该战略可以在许多方面得到加强；我们来讨论其中的一些。</p><ul class=""><li id="94bf" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated"><strong class="ky ir"> %</strong></li><li id="ac79" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><strong class="ky ir"> %[3]</strong></li><li id="9657" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><strong class="ky ir">突破时的成交量</strong>:另一个解决办法是在突破日成交量高于平均水平时买入该名称。</li><li id="e461" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><strong class="ky ir">杯子的波动性</strong>:杯子不应该是龌龊的V型；使用价格波动的平均真实范围或标准差，我们可以在形成杯子形态的同时衡量价格运动的平稳性。[4]</li><li id="b15e" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">前期上升趋势强度:通过确保形态遵循一个强大的既定上升趋势，利用反弹的高度和长度，我们可以确保一个强大的走势支持基础。</li></ul></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="c3b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[1] D. Saito-Chung，<a class="ae kv" href="https://www.investors.com/how-to-invest/investors-corner/the-basics-how-to-analyze-a-stocks-cup-with-handle/" rel="noopener ugc nofollow" target="_blank">何时买入最佳成长股:如何分析一只股票的带柄杯</a> (2020)，投资者商报</p><p id="3e26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2] <a class="ae kv" href="https://school.stockcharts.com/doku.php?id=chart_analysis:chart_patterns:cup_with_handle_continuation" rel="noopener ugc nofollow" target="_blank">带柄杯子</a>，股票走势图</p><p id="6475" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[3]莱托宁，<a class="ae kv" href="https://www.investors.com/how-to-invest/investors-corner/how-to-invest-stocks-roku-stock-use-skyscrapers-volume-identify-breakout/" rel="noopener ugc nofollow" target="_blank"> Roku，2019年的顶级股票之一，在突破之前建造了积累的“摩天大楼”</a> (2019)，投资者商业日报</p><p id="327b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[4]w . j . O . Neill，<a class="ae kv" href="https://www.oreilly.com/library/view/how-to-make/9780071614146/" rel="noopener ugc nofollow" target="_blank">如何在股票中赚钱:在繁荣时期和萧条时期的成功系统</a> (2009)</p><p id="eb3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="og">你可以在这里</em>  <em class="og">找到源代码</em> <a class="ae kv" href="https://github.com/HumanRupert/marketsmith_pattern_recognition" rel="noopener ugc nofollow" target="_blank"> <em class="og">。</em></a></p></div></div>    
</body>
</html>