<html>
<head>
<title>BLoC Pattern in Flutter without any external library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在没有任何外部库情况下，颤振中的阻塞模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/bloc-pattern-in-flutter-without-any-external-library-3efd330ff224?source=collection_archive---------9-----------------------#2022-03-18">https://levelup.gitconnected.com/bloc-pattern-in-flutter-without-any-external-library-3efd330ff224?source=collection_archive---------9-----------------------#2022-03-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d667" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你们都遇到过使用诸如rxdart、flutter_bloc等库实现bloc的各种方法。在本文中，我们将看到如何使用简单的计数器应用程序在没有任何库的情况下实现BLoC模式。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/96eee68c7723eb5ac5ca0eebe118d268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B78AZ6Ci6fnylm4oL-M7yA.png"/></div></div></figure><p id="40aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">让我们使用块模式</strong>创建一个示例项目</p><ol class=""><li id="1c37" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated"><em class="lg">创建一个新的颤振项目，改变你的main.dart如下。</em></li></ol><pre class="km kn ko kp gt lh li lj lk aw ll bi"><span id="65dd" class="lm ln iq li b gy lo lp l lq lr"><strong class="li ir">import </strong>'package:flutter/material.dart';<br/><strong class="li ir">import </strong>'src/my_app.dart';</span><span id="2d46" class="lm ln iq li b gy ls lp l lq lr">void main(){<br/>  runApp(MyApp());<br/>}</span></pre><p id="e95e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lg"> 2。在lib包中创建一个名为my_app.dart的文件。复制粘贴下面的代码在里面。</em></p><pre class="km kn ko kp gt lh li lj lk aw ll bi"><span id="9b06" class="lm ln iq li b gy lo lp l lq lr">import 'package:flutter/material.dart';<br/><br/>class MyApp extends StatelessWidget {<br/>  const MyApp({Key? key}) : super(key: key);<br/><br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return MaterialApp(<br/>      title: 'Flutter Bloc',<br/>      theme: ThemeData(primarySwatch: Colors.<em class="lg">blue</em>,),<br/>      home: const MyCounter(),<br/>    );<br/>  }<br/>}}<br/>}</span></pre><p id="9cb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.让我们现在创建我们的块部分。创建一个名为counter_bloc.dart的文件，并在其中添加StreamController和Stream。StreamController将向我们的流添加值/数据，流将向我们的小部件(即StreamBuilder)公开数据。还要添加一个变量count来存储计数器的当前值，并将其初始化为零。</p><pre class="km kn ko kp gt lh li lj lk aw ll bi"><span id="ba64" class="lm ln iq li b gy lo lp l lq lr">import 'dart:async';</span><span id="f000" class="lm ln iq li b gy ls lp l lq lr">class CounterBloc{</span><span id="baa7" class="lm ln iq li b gy ls lp l lq lr">int count = 0;</span><span id="3b01" class="lm ln iq li b gy ls lp l lq lr">// Sending value to Stream<br/>final StreamController&lt;int&gt; _counterController = StreamController&lt;int&gt;();<br/><br/>// Expose value to StreamBuilder<br/>Stream&lt;int&gt; get counterStream =&gt; _counterController.stream;</span><span id="3523" class="lm ln iq li b gy ls lp l lq lr">}</span></pre><p id="5835" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们将实现增量逻辑。在这一部分中，我们可以根据需要进行任何复杂的计算或进行网络调用。为了让这个例子简单易懂，我们正在做一个简单的增量运算。</p><pre class="km kn ko kp gt lh li lj lk aw ll bi"><span id="4732" class="lm ln iq li b gy lo lp l lq lr">incrementCounter(){<br/>  _counterController.sink.add(count++);<br/>}</span></pre><p id="a663" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们不得不在溪流不使用时将其关闭。否则就是内存泄漏。让我们在CounterBloc类中添加一个dispose方法。</p><pre class="km kn ko kp gt lh li lj lk aw ll bi"><span id="703a" class="lm ln iq li b gy lo lp l lq lr">void dispose(){<br/>  _counterController.close();<br/>}</span></pre><p id="5170" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">counter_bloc.dart的最终代码如下所示:</p><pre class="km kn ko kp gt lh li lj lk aw ll bi"><span id="384f" class="lm ln iq li b gy lo lp l lq lr">import 'dart:async';<br/><br/>class CounterBloc{<br/><br/>  int count = 0;<br/><br/>  // Sending value to Stream<br/>  final StreamController&lt;int&gt; _counterController = StreamController&lt;int&gt;();<br/><br/>  // Expose value to StreamBuilder<br/>  Stream&lt;int&gt; get counterStream =&gt; _counterController.stream;<br/><br/>  incrementCounter(){<br/>    _counterController.sink.add(count++);<br/>  }<br/><br/>  void dispose(){<br/>    _counterController.close();<br/>  }<br/><br/>}<br/><br/>final counterBloc = CounterBloc();</span></pre><p id="fbf7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.我们已经完成了块零件的创建。现在让我们在应用程序中实现它。打开my_app.dart文件，并在其中创建一个有状态的小部件，如下所示。</p><pre class="km kn ko kp gt lh li lj lk aw ll bi"><span id="f7e2" class="lm ln iq li b gy lo lp l lq lr">class MyCounter extends StatefulWidget {<br/>  const MyCounter({Key? key}) : super(key: key);<br/><br/>  @override<br/>  State&lt;MyCounter&gt; createState() =&gt; _MyCounterState();<br/>}<br/><br/>class _MyCounterState extends State&lt;MyCounter&gt; {<br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return Scaffold();<br/>  }<br/>}</span></pre><p id="425c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在实际的交互开始了，让我们看看如何通过点击按钮从我们的小部件与我们的bloc进行通信。</p><p id="9f89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们不需要在小部件中为我们的块创建一个实例。因为我们在counter_bloc.dart文件中使用final关键字创建实例的单例模式本身为<code class="fe lt lu lv li b">final counterBloc = CounterBloc();</code>，所以我们可以在my_app.dart中导入counter_bloc.dart文件后直接使用counter _ bloc . dart变量调用函数/访问变量</p><pre class="km kn ko kp gt lh li lj lk aw ll bi"><span id="5495" class="lm ln iq li b gy lo lp l lq lr">FloatingActionButton(<br/>  onPressed: (){<br/>    counterBloc.incrementCounter();<br/>  },<br/>  tooltip: 'Increment',<br/>  child: const Icon(Icons.<em class="lg">add</em>),<br/>)</span></pre><p id="ea72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们根据从bloc收到的数据流来更新UI/小部件。我们有StreamBuilder小部件，当一个新数据被添加到它观察的流中时，它会自动改变它持有的小部件的状态。StreamBuilder正在观察我们集团的逆流。</p><pre class="km kn ko kp gt lh li lj lk aw ll bi"><span id="308a" class="lm ln iq li b gy lo lp l lq lr">StreamBuilder(<br/>  initialData: counterBloc.count,<br/>  stream: counterBloc.counterStream,<br/>  builder: (BuildContext context, AsyncSnapshot&lt;int&gt; snapshot){<br/>    return Text(<br/>      '${snapshot.data}',<br/>      style: Theme.<em class="lg">of</em>(context).textTheme.headline4,<br/>    );<br/>})</span></pre><p id="7ad3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你注意到了吗，我们错过了一件事。我们忘记调用我们的块的dispose方法。这是非常重要的，如果我们错过了它，那么它将是一个内存泄漏。我们必须通过覆盖有状态小部件的dispose方法来调用bloc的dispose方法。就看下面怎么做吧。</p><pre class="km kn ko kp gt lh li lj lk aw ll bi"><span id="0fd9" class="lm ln iq li b gy lo lp l lq lr">@override<br/>void dispose() {<br/>  counterBloc.dispose();<br/>  super.dispose();<br/>}</span></pre><p id="9b71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们my_app.dart的最终代码如下。</p><pre class="km kn ko kp gt lh li lj lk aw ll bi"><span id="f94b" class="lm ln iq li b gy lo lp l lq lr">import 'package:flutter/material.dart';<br/>import 'package:flutter_bloc_sample/counter_bloc.dart';<br/><br/>class MyApp extends StatelessWidget {<br/>  const MyApp({Key? key}) : super(key: key);<br/><br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return MaterialApp(<br/>      title: 'Flutter Bloc',<br/>      theme: ThemeData(primarySwatch: Colors.<em class="lg">blue</em>,),<br/>      home: const MyCounter(),<br/>    );<br/>  }<br/>}<br/><br/>class MyCounter extends StatefulWidget {<br/>  const MyCounter({Key? key}) : super(key: key);<br/><br/>  @override<br/>  State&lt;MyCounter&gt; createState() =&gt; _MyCounterState();<br/>}<br/><br/>class _MyCounterState extends State&lt;MyCounter&gt; {<br/><br/>  @override<br/>  void dispose() {<br/>    counterBloc.dispose();<br/>    super.dispose();<br/>  }<br/><br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return Scaffold(<br/>      appBar: AppBar(<br/>        title: const Text("Simple Counter"),<br/>      ),<br/>      body: Center(<br/>        child: Column(<br/>          mainAxisAlignment: MainAxisAlignment.center,<br/>          children: &lt;Widget&gt;[<br/>            const Text(<br/>              'You have pushed the button this many times:',<br/>            ),<br/>            StreamBuilder(<br/>              initialData: counterBloc.count,<br/>              stream: counterBloc.counterStream,<br/>              builder: (BuildContext context, AsyncSnapshot&lt;int&gt; snapshot){<br/>                return Text(<br/>                  '${snapshot.data}',<br/>                  style: Theme.<em class="lg">of</em>(context).textTheme.headline4,<br/>                );<br/>            })<br/>          ],<br/>        ),<br/>      ),<br/>      floatingActionButton: FloatingActionButton(<br/>        onPressed: (){<br/>          counterBloc.incrementCounter();<br/>        },<br/>        tooltip: 'Increment',<br/>        child: const Icon(Icons.<em class="lg">add</em>),<br/>      ),<br/>    );<br/>  }<br/>}</span></pre><p id="db67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经学会了如何在不使用任何库的情况下实现块模式。</p><pre class="km kn ko kp gt lh li lj lk aw ll bi"><span id="b753" class="lm ln iq li b gy lo lp l lq lr">https://www.buymeacoffee.com/jarinrocksU</span></pre><p id="015c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你发现你所读的有用，别忘了👏👏。</p><p id="6d8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">示例代码可以在Github上找到；</p><p id="5800" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lw" href="https://github.com/jarinrocks/flutter_bloc_sample" rel="noopener ugc nofollow" target="_blank">https://github.com/jarinrocks/flutter_bloc_sample</a></p></div></div>    
</body>
</html>