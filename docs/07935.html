<html>
<head>
<title>Moving from Azure App Services to Azure Kubernetes Service (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Azure应用服务转移到Azure Kubernetes服务(第1部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/moving-from-azure-app-services-to-azure-kubernetes-service-part-1-e489857c6440?source=collection_archive---------1-----------------------#2021-03-23">https://levelup.gitconnected.com/moving-from-azure-app-services-to-azure-kubernetes-service-part-1-e489857c6440?source=collection_archive---------1-----------------------#2021-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/a352f3a6178d998c93abf0714154f4bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*HpdTAOUSHIziVATFdxG3hg.png"/></div></figure><div class=""/><p id="4995" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="kv">我建立AKS集群的经验，以及在Kubernetes和App Services上运行应用程序的比较。</em></p><p id="23d6" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="kv">给你一个警告——这篇文章很长！</em></p><p id="e1c9" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="kv">我写这篇文章的主要动机是记录我自己学习Azure Kubernetes的旅程，以及命令的确切列表和它们运行的执行顺序，在可能的情况下，我需要提醒我做了什么来让我的AKS集群工作。</em></p><p id="542a" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你也开始使用AKS，希望你会发现这也很有用！</p></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><p id="5964" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我工作的前三家公司都使用Azure应用服务来托管他们的网络应用。这是一个非常好的平台，原因如下:</p><ul class=""><li id="4070" class="ld le ja jz b ka kb ke kf ki lf km lg kq lh ku li lj lk ll bi translated">这非常容易设置</li><li id="c8bc" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">与Azure DevOps的内置集成</li><li id="3cee" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">与用编写的应用程序完美配合。NET/。网络核心</li><li id="d5f2" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">没有管理开销(即不需要系统管理员活动)</li></ul><p id="ef9c" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，如果您有一个由一个前端和几个API组成的应用程序，这种设置工作得相当好。</p><p id="8cf5" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但是，当环境开始扩展时，管理起来会非常麻烦:</p><ul class=""><li id="2ae3" class="ld le ja jz b ka kb ke kf ki lf km lg kq lh ku li lj lk ll bi translated">越来越多的API开始出现(因为现在微服务风靡一时)。</li><li id="f93b" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">每个API都需要自己的Azure DevOps管道设置、自己的ARM/Terraform模板定制模板、应用程序设置和机密设置。</li></ul><p id="9386" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">将上述数字乘以30或更多，最终会变得相当麻烦。</p><p id="51cb" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">由于Kubernetes现在非常受欢迎(我一直在业余时间摆弄它)，我决定做一个应用程序的基础设施和架构在Kubernetes和应用程序服务上运行时会有什么不同的比较。</p><p id="6d00" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">具体来说，我想比较以下内容:</p><ul class=""><li id="5be9" class="ld le ja jz b ka kb ke kf ki lf km lg kq lh ku li lj lk ll bi translated">基础设施设计</li><li id="6311" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">CICD管道有何不同</li><li id="ef3e" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">进行这种转换所需的代码更改</li><li id="19c8" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">从一个平台转移到另一个平台的影响(好的或坏的)</li></ul><p id="73dd" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">请记住:我不是Kubernetes专家，所以本文中讨论的一些设置可能没有遵循“最佳实践”。T11】</p><p id="cab4" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz jb"> <em class="kv">如果您有任何意见或改进建议，请告诉我！</em>T15】</strong></p></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><h1 id="24de" class="lr ls ja bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">设计差异</h1><p id="2ea8" class="pw-post-body-paragraph jx jy ja jz b ka mp kc kd ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku im bi translated">下图是我对托管在App Services vs AKS中的web应用程序设计的概念视图:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mu"><img src="../Images/017dddee265ff9b248c88f3410f87724.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hmelvMm6lYfl_WjXBue8uA.png"/></div></div></figure><p id="ebb4" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">该图非常简单明了，但需要注意的关键点是:</p><ul class=""><li id="05a3" class="ld le ja jz b ka kb ke kf ki lf km lg kq lh ku li lj lk ll bi translated">对于最初的转变，我选择简单地用AKS替换应用服务。生态系统的其余部分基本保持原样。我会在未来尝试将更多的东西整合到Kubernetes中。</li><li id="27a8" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">在应用服务平台中，每个应用都需要自己的基础架构代码(ARM / Terraform)来提供其应用服务实例。<br/>在Kubernetes中，每个应用都需要自己的部署和服务yaml我选择每个名称空间有一个入口。</li></ul></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><h1 id="1c4a" class="lr ls ja bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">设置AKS</h1><h2 id="8259" class="nd ls ja bd lt ne nf dn lx ng nh dp mb ki ni nj mf km nk nl mj kq nm nn mn no bi translated">先决条件</h2><p id="140a" class="pw-post-body-paragraph jx jy ja jz b ka mp kc kd ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku im bi translated">安装以下工具:</p><ul class=""><li id="3a22" class="ld le ja jz b ka kb ke kf ki lf km lg kq lh ku li lj lk ll bi translated">az cli </li><li id="24ea" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated"><a class="ae np" href="https://kubernetes.io/docs/tasks/tools/#kubectl" rel="noopener ugc nofollow" target="_blank"> kubectl </a></li><li id="42f9" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated"><a class="ae np" href="https://helm.sh/docs/intro/install/" rel="noopener ugc nofollow" target="_blank">舵</a></li></ul><p id="d5f1" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz jb">注意:我将在WSL2 (Ubuntu) </strong>中运行下面的其余命令</p><h2 id="7211" class="nd ls ja bd lt ne nf dn lx ng nh dp mb ki ni nj mf km nk nl mj kq nm nn mn no bi translated">创建AKS集群</h2><pre class="mv mw mx my gt nq nr ns nt aw nu bi"><span id="cad1" class="nd ls ja nr b gy nv nw l nx ny">SUBSCRIPTION="Jordan's VSP Subscription"<br/>RG="jordanaks"<br/>AKSCLUSTER="myAKSCluster"</span><span id="221b" class="nd ls ja nr b gy nz nw l nx ny"># Login<br/>az login<br/>az account set -s $SUBSCRIPTION</span><span id="b869" class="nd ls ja nr b gy nz nw l nx ny"># Create resource group<br/>az group create --name $RG --location australiaEast</span><span id="0561" class="nd ls ja nr b gy nz nw l nx ny"># Create AKS<br/>az aks create --resource-group $RG --name $AKSCLUSTER --node-count 1 --enable-addons monitoring</span><span id="5c7f" class="nd ls ja nr b gy nz nw l nx ny"># Get the resource group of AKS cluster<br/>az aks show --resource-group $RG --name $AKSCLUSTER --query nodeResourceGroup -o tsv</span><span id="bbdb" class="nd ls ja nr b gy nz nw l nx ny"># Create public IP address in AKS cluster resource group<br/>az network public-ip create --resource-group MC_jordanaks_myAKSCluster_australiaeast --name jordanaksPublicIP --sku Standard --allocation-method static --query publicIp.ipAddress -o tsv</span><span id="fcb4" class="nd ls ja nr b gy nz nw l nx ny"># Get the public IP address<br/>az network public-ip show --resource-group MC_jordanaks_myAKSCluster_australiaeast --name jordanaksPublicIP</span><span id="b237" class="nd ls ja nr b gy nz nw l nx ny"># Get access credentials for AKS; This configures kubectl for you!<br/>az aks get-credentials --resource-group $RG --name $AKSCLUSTER</span></pre><h2 id="f486" class="nd ls ja bd lt ne nf dn lx ng nh dp mb ki ni nj mf km nk nl mj kq nm nn mn no bi translated">设置nginx入口控制器</h2><p id="acd6" class="pw-post-body-paragraph jx jy ja jz b ka mp kc kd ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku im bi translated">为了使用入口资源，我们需要安装一个入口控制器。我选择使用nginx，因为这是微软指南的建议。</p><pre class="mv mw mx my gt nq nr ns nt aw nu bi"><span id="c7ca" class="nd ls ja nr b gy nv nw l nx ny"># Create a namespace for ingress resources<br/>kubectl create namespace ingress-basic</span><span id="f6fb" class="nd ls ja nr b gy nz nw l nx ny"># Add the ingress-nginx repository<br/>helm repo add ingress-nginx <a class="ae np" href="https://kubernetes.github.io/ingress-nginx" rel="noopener ugc nofollow" target="_blank">https://kubernetes.github.io/ingress-nginx</a></span><span id="902b" class="nd ls ja nr b gy nz nw l nx ny"># Use Helm to deploy an NGINX ingress controller;<br/># Replace loadBalancerIP with the IP address set up in the previous <br/># step<br/>helm install nginx-ingress ingress-nginx/ingress-nginx \<br/>    --namespace ingress-basic \<br/>    --set controller.replicaCount=2 \<br/>    --set controller.nodeSelector."beta\.kubernetes\.io/os"=linux \<br/>    --set defaultBackend.nodeSelector."beta\.kubernetes\.io/os"=linux \<br/>    --set controller.admissionWebhooks.patch.nodeSelector."beta\.kubernetes\.io/os"=linux \<br/>    --set controller.service.loadBalancerIP="20.193.57.230" \<br/>    --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-dns-label-name"="jordan" \<br/>    --set controller.service.externalTrafficPolicy=Local</span><span id="2219" class="nd ls ja nr b gy nz nw l nx ny"># Verify the external IP has been binded to the ingress controller<br/>kubectl --namespace ingress-basic get services -o wide -w nginx-ingress-ingress-nginx-controller</span></pre><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oa"><img src="../Images/5c28fb3182c97072980002b09af62db1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qWgd1jBf4SBdnrAA1DHO0A.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">入口控制器应将上一步中创建的公共IP绑定到其外部IP</figcaption></figure><p id="3636" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果您发现公共IP没有正确绑定，请查看kubernetes事件日志，了解发生了什么:<br/> <code class="fe of og oh nr b">kubectl get events --all-namespaces</code></p><h2 id="49be" class="nd ls ja bd lt ne nf dn lx ng nh dp mb ki ni nj mf km nk nl mj kq nm nn mn no bi translated">设置DNS记录</h2><p id="824c" class="pw-post-body-paragraph jx jy ja jz b ka mp kc kd ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku im bi translated">为您的域创建一个A记录，指向您刚刚创建的公共IP。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/1735648be209a4b02d6babd98a34d2cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*DPJ8cdE0zs59vxurI-fKCA.png"/></div></figure><p id="4786" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在我的例子中，记录将允许我浏览到我在<a class="ae np" href="https://dev.jordanlee.net" rel="noopener ugc nofollow" target="_blank">https://dev.jordanlee.net</a>的AKS实例。</p><p id="6c56" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这很重要，因为我们需要建立记录，以便为我们的web应用程序生成TLS证书。</p><h2 id="1652" class="nd ls ja bd lt ne nf dn lx ng nh dp mb ki ni nj mf km nk nl mj kq nm nn mn no bi translated">安装证书管理器</h2><p id="5bce" class="pw-post-body-paragraph jx jy ja jz b ka mp kc kd ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku im bi translated"><a class="ae np" href="https://cert-manager.io/" rel="noopener ugc nofollow" target="_blank"> cert-manager </a>是一个本地的Kubernetes证书管理控制器。它可以帮助从各种来源颁发证书，如Let's Encrypt、HashiCorp Vault、Venafi、简单签名密钥对或自签名。</p><pre class="mv mw mx my gt nq nr ns nt aw nu bi"><span id="e47f" class="nd ls ja nr b gy nv nw l nx ny"># Label the cert-manager namespace to disable resource validation<br/>kubectl label namespace ingress-basic cert-manager.io/disable-validation=true</span><span id="9656" class="nd ls ja nr b gy nz nw l nx ny"># Add the Jetstack Helm repository<br/>helm repo add jetstack <a class="ae np" href="https://charts.jetstack.io" rel="noopener ugc nofollow" target="_blank">https://charts.jetstack.io</a></span><span id="5273" class="nd ls ja nr b gy nz nw l nx ny"># Update your local Helm chart repository cache<br/>helm repo update</span><span id="eaf8" class="nd ls ja nr b gy nz nw l nx ny"># Install the cert-manager Helm chart<br/>helm install \<br/>  cert-manager \<br/>  --namespace ingress-basic \<br/>  --set installCRDs=true \<br/>  --set nodeSelector."beta\.kubernetes\.io/os"=linux \<br/>  jetstack/cert-manager</span></pre><p id="e6d6" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在安装了cert-manager，我们需要设置ClusterIssuer资源。这些将与外部CA交互，为我们生成证书。</p><p id="ca64" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我将为LetsEncrypt设置集群发行者。</p><p id="bed9" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">创建以下文件(您需要更新电子邮件值):</p><pre class="mv mw mx my gt nq nr ns nt aw nu bi"><span id="b8f2" class="nd ls ja nr b gy nv nw l nx ny"># clusterissuers.yaml<br/>apiVersion: cert-manager.io/v1alpha2<br/>kind: ClusterIssuer<br/>metadata:<br/>  name: letsencrypt-staging<br/>spec:<br/>  acme:<br/>    server: <a class="ae np" href="https://acme-staging-v02.api.letsencrypt.org/directory" rel="noopener ugc nofollow" target="_blank">https://acme-staging-v02.api.letsencrypt.org/directory</a><br/>    email: <a class="ae np" href="mailto:jordan@jordanlee.net" rel="noopener ugc nofollow" target="_blank">jordan@jordanlee.net</a><br/>    privateKeySecretRef:<br/>      name: letsencrypt-staging<br/>    solvers:<br/>    - http01:<br/>        ingress:<br/>          class: nginx<br/>          podTemplate:<br/>            spec:<br/>              nodeSelector:<br/>                "kubernetes.io/os": linux</span><span id="e2eb" class="nd ls ja nr b gy nz nw l nx ny">---</span><span id="85d2" class="nd ls ja nr b gy nz nw l nx ny">apiVersion: cert-manager.io/v1alpha2<br/>kind: ClusterIssuer<br/>metadata:<br/>  name: letsencrypt-prod<br/>  namespace: cert-manager<br/>spec:<br/>  acme:<br/>    server: <a class="ae np" href="https://acme-v02.api.letsencrypt.org/directory" rel="noopener ugc nofollow" target="_blank">https://acme-v02.api.letsencrypt.org/directory</a><br/>    email: <a class="ae np" href="mailto:jordan@jordanlee.net" rel="noopener ugc nofollow" target="_blank">jordan@jordanlee.net</a><br/>    privateKeySecretRef:<br/>      name: letsencrypt-prod<br/>    solvers:<br/>    - http01:<br/>        ingress:<br/>          class: nginx</span></pre><p id="cfa7" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后用<br/>和<code class="fe of og oh nr b">kubectl create -f clusterissuers.yaml -n ingress-basic</code>创建发卡行</p><p id="df27" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">使用以下命令验证集群发行者是否准备就绪:<br/> <code class="fe of og oh nr b">kubectl get ClusterIssuer -n ingress-basic</code></p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/deab882fc01f55b0ad43071eac70e843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*2JGCgmw_5DOA1R3Y00qa4Q.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">两个发行者都应该处于就绪状态</figcaption></figure><h2 id="20ec" class="nd ls ja bd lt ne nf dn lx ng nh dp mb ki ni nj mf km nk nl mj kq nm nn mn no bi translated">设置Azure容器注册表(ACR)</h2><p id="b845" class="pw-post-body-paragraph jx jy ja jz b ka mp kc kd ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku im bi translated">ACR用于存储私有Docker容器映像(想想Docker Hub的Azure版本)。</p><p id="1472" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这在技术上并不是必需的，但是我工作过的大多数企业都强制要求使用私有注册中心，而且因为ACR是由AKS支持的，所以我在这个例子中使用了它。</p><pre class="mv mw mx my gt nq nr ns nt aw nu bi"><span id="dc74" class="nd ls ja nr b gy nv nw l nx ny"># Create ACR<br/>MYACR=etherlabs<br/>az acr create -n $MYACR -g $RG --sku basic</span><span id="a9f6" class="nd ls ja nr b gy nz nw l nx ny"># Attach ACR to AKS<br/>az aks update -g $RG -n $AKSCLUSTER --attach-acr $MYACR</span></pre></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><h1 id="b002" class="lr ls ja bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">设置开发命名空间</h1><p id="39c8" class="pw-post-body-paragraph jx jy ja jz b ka mp kc kd ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku im bi translated">AKS现已设置为:</p><ul class=""><li id="90ff" class="ld le ja jz b ka kb ke kf ki lf km lg kq lh ku li lj lk ll bi translated">通过nginx入口服务传入的web请求</li><li id="463c" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">从LetsEncrypt获取TLS证书以保护web流量</li></ul><p id="7b39" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，我将为我的开发环境设置一个名称空间，并添加一个“hello world”类型的服务来测试设置。</p><p id="7f18" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">首先，创建一个新的名称空间:<br/> <code class="fe of og oh nr b">kubectl create ns development</code></p><p id="32c2" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们现在可以使用以下yaml为helloworld创建部署和服务:</p><pre class="mv mw mx my gt nq nr ns nt aw nu bi"><span id="87fe" class="nd ls ja nr b gy nv nw l nx ny"># ingress-demo.yaml<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: ingress-demo<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: ingress-demo<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: ingress-demo<br/>    spec:<br/>      containers:<br/>      - name: ingress-demo<br/>        image: mcr.microsoft.com/azuredocs/aks-helloworld:v1<br/>        ports:<br/>        - containerPort: 80<br/>        env:<br/>        - name: TITLE<br/>          value: "Welcome to jordanlee.net"<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: ingress-demo<br/>spec:<br/>  type: ClusterIP<br/>  ports:<br/>  - port: 80<br/>  selector:<br/>    app: ingress-demo</span></pre><p id="e336" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">部署应用:<br/> <code class="fe of og oh nr b">kubectl create -f ingress-demo.yaml -n development</code></p><p id="d977" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，向名称空间添加一个入口资源。这就是允许外部请求访问helloworld应用程序的原因:</p><pre class="mv mw mx my gt nq nr ns nt aw nu bi"><span id="a518" class="nd ls ja nr b gy nv nw l nx ny"># development-ingress.yaml<br/>apiVersion: networking.k8s.io/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: development-ingress<br/>  annotations:<br/>    kubernetes.io/ingress.class: nginx<br/>    cert-manager.io/cluster-issuer: letsencrypt-prod<br/>    nginx.ingress.kubernetes.io/rewrite-target: /$2<br/>    nginx.ingress.kubernetes.io/use-regex: "true"<br/>spec:<br/>  tls:<br/>  - hosts:<br/>    - dev.jordanlee.net<br/>    secretName: tls-secret<br/>  rules:<br/>  - host: dev.jordanlee.net<br/>    http:<br/>      paths:<br/>      - backend:<br/>          serviceName: ingress-demo<br/>          servicePort: 80<br/>        path: /(.*)</span></pre><p id="e8c7" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">使用<br/> <code class="fe of og oh nr b">kubectl create -f development-ingress.yaml -n development</code>创建入口资源</p><p id="d357" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果您在我们刚刚创建的入口上运行kubectl describe，您应该会看到以下内容:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi ok"><img src="../Images/986a6b7d113b92e3be9db9cbc7afb5b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I3frJhfEtJNMwrST0bp_Qg.png"/></div></div></figure><p id="7d6b" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了验证，我可以浏览到<a class="ae np" href="https://dev.jordanlee.net" rel="noopener ugc nofollow" target="_blank">https://dev.jordanlee.net</a>，我应该得到以下内容:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/ce7c740aabc3dc3c0d01bc2d31630502.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*Sx5OrVUzANaUKhSMuSUPeg.png"/></div></figure><p id="ec71" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果我检查证书，我可以看到LetsEncrypt颁发了一个有效的证书:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div class="gh gi om"><img src="../Images/5784b14893b2167d1141cd871d3fb1bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*-vpWVlxc_w1CW8gS_nBv9g.png"/></div></figure><p id="5691" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意损坏的图像——这是由于图像URL指向/static，它没有在我的入口路由中定义。我现在不会为此烦恼，因为这只是为了验证:</p><ul class=""><li id="adae" class="ld le ja jz b ka kb ke kf ki lf km lg kq lh ku li lj lk ll bi translated">外部流量可以通过入口到达helloworld应用程序</li><li id="acfe" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">使用有效证书保护Web流量</li></ul></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><h1 id="0594" class="lr ls ja bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">部署DemoApi</h1><p id="789f" class="pw-post-body-paragraph jx jy ja jz b ka mp kc kd ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku im bi translated">我的下一步是手动测试以下内容:</p><ul class=""><li id="fa14" class="ld le ja jz b ka kb ke kf ki lf km lg kq lh ku li lj lk ll bi translated">使用多阶段构建为此API创建Docker映像</li><li id="f92d" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">标记图像并将其推送到我的ACR实例</li><li id="7eac" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">为我的映像设置部署、服务和进入规则</li><li id="bc0f" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">推送我的映像的新版本时更新部署</li></ul><p id="dce9" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对于这个例子，我写了一个简单的ASP.NET 5 API(恰当地命名为“DemoApi”)。该代码可在GitHub上获得:</p><div class="is it gp gr iu on"><a href="https://github.com/therealjordanlee/DemoApi" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd jb gy z fp os fr fs ot fu fw iz bi translated">therealjordanlee/DemoApi</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">在GitHub上创建一个帐户，为therealjordanlee/DemoApi开发做贡献。</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">github.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb iw on"/></div></div></a></div><h2 id="68a2" class="nd ls ja bd lt ne nf dn lx ng nh dp mb ki ni nj mf km nk nl mj kq nm nn mn no bi translated">将我的代码归档</h2><p id="7ef8" class="pw-post-body-paragraph jx jy ja jz b ka mp kc kd ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku im bi translated">Visual Studio 2019让这变得非常简单。创建新解决方案时，勾选“启用Docker”复选框将自动为您生成Docker文件:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/503dbe54932aca9725ebd11bdf6d5755.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*G-JvvwWX0UhUqESCBXX_TQ.png"/></div></figure><p id="c289" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是生成的结果:</p><pre class="mv mw mx my gt nq nr ns nt aw nu bi"><span id="c936" class="nd ls ja nr b gy nv nw l nx ny">FROM mcr.microsoft.com/dotnet/aspnet:5.0 AS base<br/>WORKDIR /app<br/>EXPOSE 80<br/>EXPOSE 443</span><span id="69f3" class="nd ls ja nr b gy nz nw l nx ny">FROM mcr.microsoft.com/dotnet/sdk:5.0 AS build<br/>WORKDIR /src<br/>COPY ["DemoApi/DemoApi.csproj", "DemoApi/"]<br/>RUN dotnet restore "DemoApi/DemoApi.csproj"<br/>COPY . .<br/>WORKDIR "/src/DemoApi"<br/>RUN dotnet build "DemoApi.csproj" -c Release -o /app/build</span><span id="cb08" class="nd ls ja nr b gy nz nw l nx ny">FROM build AS publish<br/>RUN dotnet publish "DemoApi.csproj" -c Release -o /app/publish</span><span id="0d17" class="nd ls ja nr b gy nz nw l nx ny">FROM base AS final<br/>WORKDIR /app<br/>COPY --from=publish /app/publish .<br/>ENTRYPOINT ["dotnet", "DemoApi.dll"]</span></pre><p id="a1f0" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后我可以使用</p><pre class="mv mw mx my gt nq nr ns nt aw nu bi"><span id="d58b" class="nd ls ja nr b gy nv nw l nx ny"># Login to ACR<br/>az acr login --name $MYACR</span><span id="dd0c" class="nd ls ja nr b gy nz nw l nx ny"># Build<br/>docker build -f Dockerfile .. -t etherlabs.azurecr.io/demoapi:initial</span></pre><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi pd"><img src="../Images/dd08de93a1c10c8863633b70c51496c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r7AiaDW8vpUDoTe86klV0g.png"/></div></div></figure><h2 id="3896" class="nd ls ja bd lt ne nf dn lx ng nh dp mb ki ni nj mf km nk nl mj kq nm nn mn no bi translated">标记并推送至ACR</h2><pre class="mv mw mx my gt nq nr ns nt aw nu bi"><span id="e985" class="nd ls ja nr b gy nv nw l nx ny"># Add additional tag<br/>docker tag etherlabs.azurecr.io/demoapi:initial etherlabs.azurecr.io/demoapi:development</span><span id="a9a3" class="nd ls ja nr b gy nz nw l nx ny"># Push the image to ACR<br/>docker push etherlabs.azurecr.io/demoapi:development<br/>docker push etherlabs.azurecr.io/demoapi:initial</span></pre><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi pe"><img src="../Images/e37477f90ef2d1579a74cd26d405c8f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EDPu12FeDbqoTjNKRdI5iA.png"/></div></div></figure><p id="446a" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">查看Azure Portal中的容器注册表，我可以看到图像已被推送:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/0198ee9a28f71601210fea4fb107984f.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*9FhrfZJxqaHtdcmJN6IQOA.png"/></div></figure><h2 id="e1d5" class="nd ls ja bd lt ne nf dn lx ng nh dp mb ki ni nj mf km nk nl mj kq nm nn mn no bi translated">设置DemoApi配置变量</h2><p id="5b86" class="pw-post-body-paragraph jx jy ja jz b ka mp kc kd ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku im bi translated">在为DemoApi添加部署和服务资源之前，我首先需要设置一些配置。</p><p id="7a7c" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">非常简单API从配置中读入两个字符串:<code class="fe of og oh nr b">HelloMessage</code>和<code class="fe of og oh nr b">SecretMessage</code>:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi pg"><img src="../Images/90a35716ddef35372b2d07b287d4c3d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*nNNhojhAmRAgSg4vhcF5nQ.png"/></div></div></figure><p id="6185" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">它有两个端点:</p><ul class=""><li id="aff8" class="ld le ja jz b ka kb ke kf ki lf km lg kq lh ku li lj lk ll bi translated">/message/normal —返回MessageSettings。HelloMessage</li><li id="064c" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">/message/secret —返回消息设置。秘密信息</li></ul><figure class="mv mw mx my gt iv gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/c3fbf7ccfc59769c01074025d93f162b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*t4oJIAWJXN89TT0D20Nxew.png"/></div></figure><p id="c2a3" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，我需要设置以下内容:</p><ul class=""><li id="6b22" class="ld le ja jz b ka kb ke kf ki lf km lg kq lh ku li lj lk ll bi translated">HelloMessage的配置映射</li><li id="31bc" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">秘密消息的秘密</li></ul><p id="38eb" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这些将作为环境变量添加到部署中。</p><p id="d9c3" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这非常简单:</p><pre class="mv mw mx my gt nq nr ns nt aw nu bi"><span id="764b" class="nd ls ja nr b gy nv nw l nx ny"># Create ConfigMap<br/>kubectl create demoapi-env --from-literal=MessageSettings__HelloMessage="Hello Alinta" -n development</span><span id="b99c" class="nd ls ja nr b gy nz nw l nx ny"># Create Secret<br/>kubectl create secret generic demoapi-secret --from-literal=MessageSettings__SecretMessage='its a secret!' -n development</span></pre><p id="8b14" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意，因为这是Linux，所以嵌套值是使用两个下划线而不是冒号来定义的。</p><h2 id="c4a3" class="nd ls ja bd lt ne nf dn lx ng nh dp mb ki ni nj mf km nk nl mj kq nm nn mn no bi translated">将DemoApi添加到AKS</h2><p id="4412" class="pw-post-body-paragraph jx jy ja jz b ka mp kc kd ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku im bi translated">我现在已经准备好为DemoApi设置部署、服务和入口规则。这是yaml:</p><pre class="mv mw mx my gt nq nr ns nt aw nu bi"><span id="8be8" class="nd ls ja nr b gy nv nw l nx ny"># demoapi.yaml<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: demo-api<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: demo-api<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: demo-api<br/>    spec:<br/>      containers:<br/>      - name: demo-api<br/>        image: etherlabs.azurecr.io/demoapi:development<br/>        imagePullPolicy: Always<br/>        ports:<br/>        - containerPort: 80<br/>        envFrom:<br/>        - configMapRef:<br/>            name: demoapi-env<br/>        - secretRef:<br/>            name: demoapi-secret</span><span id="f058" class="nd ls ja nr b gy nz nw l nx ny">---</span><span id="7d9e" class="nd ls ja nr b gy nz nw l nx ny">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: demo-api<br/>spec:<br/>  type: ClusterIP<br/>  ports:<br/>  - port: 80<br/>  selector:<br/>    app: demo-api</span></pre><p id="4702" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">用<br/>创建资源:<code class="fe of og oh nr b">kubectl create -f demoapi.yaml -n development</code></p><p id="079e" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在部署了DemoApi之后，我可以更新入口规则，使它可以从外部访问。在<code class="fe of og oh nr b">development-ingress.yaml</code>中，我将DemoApi的路径指定为<code class="fe of og oh nr b">/demo(/|$)(.*)</code>:</p><pre class="mv mw mx my gt nq nr ns nt aw nu bi"><span id="7275" class="nd ls ja nr b gy nv nw l nx ny"># development-ingress.yaml<br/>apiVersion: networking.k8s.io/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: development-ingress<br/>  annotations:<br/>    kubernetes.io/ingress.class: nginx<br/>    cert-manager.io/cluster-issuer: letsencrypt-prod<br/>    nginx.ingress.kubernetes.io/rewrite-target: /$2<br/>    nginx.ingress.kubernetes.io/use-regex: "true"<br/>spec:<br/>  tls:<br/>  - hosts:<br/>    - dev.jordanlee.net<br/>    secretName: tls-secret<br/>  rules:<br/>  - host: dev.jordanlee.net<br/>    http:<br/>      paths:<br/>      - backend:<br/>          serviceName: demo-api<br/>          servicePort: 80<br/>        path: /demo(/|$)(.*)<br/>      - backend:<br/>          serviceName: ingress-demo<br/>          servicePort: 80<br/>        path: /(.*)</span></pre><p id="d722" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后我用<br/> <code class="fe of og oh nr b">kubectl replace -f development-ingress.yaml -n development</code>更新入口规则</p><p id="4e7a" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">浏览到swagger端点显示其可访问性:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/0ae5afcb1ec17950cc6651d04dbba35e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*K6h2tLTHQ67EME12zYdw7w.png"/></div></figure></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><h1 id="6ad6" class="lr ls ja bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">使用Azure Devops设置CI/CD</h1><p id="5995" class="pw-post-body-paragraph jx jy ja jz b ka mp kc kd ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku im bi translated">现在我已经知道可以手动构建DemoApi并将其部署到AKS，接下来我想做的是自动化这个过程。我的工作场所使用Azure DevOps，这也是我最熟悉的工具，所以我将在CI/CD管道中使用它。</p><p id="e8c0" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">有许多不同的方法可以建立CI/CD流；下图显示了我的工作场所目前的设置情况:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi pj"><img src="../Images/61cee52859d2c586f59e2ba4099bc123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IcPO6Cmmdsl8HVKfZUz7tg.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">部署到Azure应用服务的CI/CD工作流</figcaption></figure><p id="7342" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我几乎可以肯定有更好、更有效的方法来做到这一点。但是，对于这个概念验证，我选择简单地调整现有的ak流程:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi pk"><img src="../Images/72b16eec0415360a6381e517d124039a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F3rlWaAwM3SiH18z6NKSYg.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">部署到AKS的CI/CD工作流</figcaption></figure><p id="19e0" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是我为这个工作流创建的管道yaml:</p><pre class="mv mw mx my gt nq nr ns nt aw nu bi"><span id="9eb3" class="nd ls ja nr b gy nv nw l nx ny">stages:<br/>  - stage: BuildAndTest<br/>    condition: ne(variables['Build.SourceBranch'], 'refs/heads/main')<br/>    jobs:<br/>      - job: BuildAndTest<br/>        steps:<br/>          - task: DotNetCoreCLI@2<br/>            displayName: 'dotnet build'<br/>            inputs:<br/>              command: build<br/>              projects: '**/*.sln'<br/>              arguments: '--configuration Release'</span><span id="17f2" class="nd ls ja nr b gy nz nw l nx ny">- task: DotNetCoreCLI@2<br/>            inputs:<br/>              command: 'test'<br/>              projects: '**/*.sln'</span><span id="0a0d" class="nd ls ja nr b gy nz nw l nx ny">- stage: Containerize<br/>    condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')<br/>    jobs:<br/>      - job: Containerize<br/>        steps:<br/>          - task: Docker@2<br/>            inputs:<br/>              containerRegistry: 'Etherlabs'<br/>              repository: 'demoapi'<br/>              command: 'buildAndPush'<br/>              Dockerfile: '**/Dockerfile'<br/>              buildContext: 'src'<br/>              tags: |<br/>                $(Build.BuildNumber)<br/>                development</span><span id="4d39" class="nd ls ja nr b gy nz nw l nx ny">- task: Kubernetes@1<br/>            inputs:<br/>              connectionType: 'Kubernetes Service Connection'<br/>              kubernetesServiceEndpoint: 'Jordan AKS'<br/>              namespace: 'development'<br/>              command: 'rollout'<br/>              arguments: 'restart deployment demo-api'<br/>              secretType: 'dockerRegistry'<br/>              containerRegistryType: 'Azure Container Registry'</span></pre><h2 id="64d9" class="nd ls ja bd lt ne nf dn lx ng nh dp mb ki ni nj mf km nk nl mj kq nm nn mn no bi translated">测试管道</h2><p id="42be" class="pw-post-body-paragraph jx jy ja jz b ka mp kc kd ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku im bi translated">我在代码中添加了另一个虚拟端点来测试管道:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/d6ca14c473291c939a7ba571342d351b.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*sohxllJgHPWcJ-slUCuYOQ.png"/></div></figure><p id="3a4a" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">观察Azure DevOps管道，看起来部署已经成功完成:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/43c640418613294e69a239191bf83bd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*sDJPGPXHle69EUSuTOPYfw.png"/></div></figure><p id="1908" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后，为了仔细检查实际部署的更改，我尝试浏览到blah端点:</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/406cb24a661103e4cc7f004da9f81963.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*22ZkTvHomsHqnYqfvnrUsw.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">成功了！</figcaption></figure></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><h1 id="9cec" class="lr ls ja bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">结论</h1><p id="9724" class="pw-post-body-paragraph jx jy ja jz b ka mp kc kd ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku im bi translated">我最初做这个PoC是为了更好地理解Kubernetes环境中的开发与App Services环境中的开发有何不同。这些是我的想法:</p><h2 id="de99" class="nd ls ja bd lt ne nf dn lx ng nh dp mb ki ni nj mf km nk nl mj kq nm nn mn no bi translated">基础设施设计</h2><p id="9a32" class="pw-post-body-paragraph jx jy ja jz b ka mp kc kd ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku im bi translated">在我看来，就基础设施的简单性而言，AKS比App服务有着巨大的优势。</p><p id="b5aa" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">考虑如下应用生态系统:</p><ul class=""><li id="05d3" class="ld le ja jz b ka kb ke kf ki lf km lg kq lh ku li lj lk ll bi translated">20个API</li><li id="7331" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">3个环境:开发、用户验收测试、生产</li></ul><p id="baad" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这需要60个应用服务实例。如果ARM模板部署是CI/CD管道的一部分，那么运行ARM部署会花费大量时间。</p><p id="3357" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">Kubernetes上运行的相同生态系统可以在单个AKS实例中运行，为每个环境设置单独的名称空间。</p><p id="75c1" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这种设置中，不需要将ARM部署作为管道的一部分来运行。</p><p id="a7e6" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz jb">获胜者:AKS </strong></p><h2 id="cd1b" class="nd ls ja bd lt ne nf dn lx ng nh dp mb ki ni nj mf km nk nl mj kq nm nn mn no bi translated">CI/CD管道</h2><p id="57f7" class="pw-post-body-paragraph jx jy ja jz b ka mp kc kd ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku im bi translated">我在这个概念验证中使用的AKS管道与应用服务管道没有太大的不同。然而，我认为AKS相对于应用服务有两大优势:</p><ul class=""><li id="2fa2" class="ld le ja jz b ka kb ke kf ki lf km lg kq lh ku li lj lk ll bi translated">不需要ARM模板部署。</li><li id="dacb" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">AKS的“首次展示”过程比应用服务中的Web部署过程要快得多。<br/>此外，借助滚动部署、就绪性和活性探测等功能，在AKS中实现“零停机”部署要简单得多。</li></ul><p id="cd67" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz jb">获胜者:AKS </strong></p><h2 id="a01c" class="nd ls ja bd lt ne nf dn lx ng nh dp mb ki ni nj mf km nk nl mj kq nm nn mn no bi translated">AKS所需的代码更改</h2><p id="8ccb" class="pw-post-body-paragraph jx jy ja jz b ka mp kc kd ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku im bi translated">不适用。</p><p id="9fc5" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">至少在ASP.NET核心解决方案利用选项和图标配置来获取应用程序设置的情况下，不需要Kubernetes特定的代码更改。</p><h2 id="7e5c" class="nd ls ja bd lt ne nf dn lx ng nh dp mb ki ni nj mf km nk nl mj kq nm nn mn no bi translated">AKS与App服务的利弊</h2><p id="c884" class="pw-post-body-paragraph jx jy ja jz b ka mp kc kd ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku im bi translated"><strong class="jz jb">缺点:</strong></p><ul class=""><li id="5ad8" class="ld le ja jz b ka kb ke kf ki lf km lg kq lh ku li lj lk ll bi translated">对于不熟悉Linux或“sysadmin”类型活动的开发人员来说，这是一条陡峭的学习曲线</li><li id="ad1f" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">需要学习所有Kubernetes特有的术语和概念</li><li id="5d2e" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">实现“最佳实践”的AKS设置需要做更多的工作</li></ul><p id="a2b2" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz jb">优点:</strong></p><ul class=""><li id="e555" class="ld le ja jz b ka kb ke kf ki lf km lg kq lh ku li lj lk ll bi translated">更简单的CI/CD</li><li id="b85a" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">开启了服务网格架构的潜力</li><li id="8327" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">AKS可以提供大多数现成的“实用程序”类型的功能(例如路由聚合和证书)</li></ul></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><h1 id="f764" class="lr ls ja bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">//待办事项</h1><p id="31aa" class="pw-post-body-paragraph jx jy ja jz b ka mp kc kd ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku im bi translated">关于AKS，我还有很多未解决的问题要探索，我会在以后的帖子中尝试解决这些问题。即:</p><ul class=""><li id="b377" class="ld le ja jz b ka kb ke kf ki lf km lg kq lh ku li lj lk ll bi translated">为名称空间实现适当的RBAC</li><li id="d5ca" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">添加Istio(服务网格)</li><li id="c696" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">用Azure应用网关替换nginx入口控制器</li><li id="05d9" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">用于提供对AKS的内部访问的VPN解决方案</li><li id="679b" class="ld le ja jz b ka lm ke ln ki lo km lp kq lq ku li lj lk ll bi translated">AKS上的无服务器(功能即服务)</li></ul></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><p id="21c3" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="kv">如果你已经读到这里，那么恭喜你！你要么非常有耐心，要么真的对Kubernetes感兴趣。</em></p><p id="7805" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">无论如何，感谢您的阅读，我希望这篇文章对您有用！</p></div></div>    
</body>
</html>