<html>
<head>
<title>How to Test NuxtJS Middleware</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何测试NuxtJS中间件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-test-nuxtjs-middleware-793a4fbd039d?source=collection_archive---------4-----------------------#2020-05-19">https://levelup.gitconnected.com/how-to-test-nuxtjs-middleware-793a4fbd039d?source=collection_archive---------4-----------------------#2020-05-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/85ab06869b13937a8d5d7d988f9c799d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U6ybL-9CoyuOwsQCpukkmQ.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">来自<a class="ae jg" href="https://www.pexels.com/photo/female-engineer-controlling-flight-simulator-3862132/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>的<a class="ae jg" href="https://www.pexels.com/@thisisengineering?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">this is工程</a>照片</figcaption></figure><h2 id="f9ba" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph">测试直到你变成绿色</h2><div class=""/><div class=""><h2 id="80f0" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">带有示例的NuxtJS中间件测试设置的分步教程</h2></div><p id="f9c8" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">NuxtJS框架允许快速构建和启动Vue.js应用程序。它的众多便利之一是能够通过中间件<em class="md">传递请求，而不需要额外的服务器。如果您主要只是需要一个客户端Vue.js应用程序，但还需要支持一些服务器端API调用或操作，NuxtJS可以让这一切变得简单。此外，如果您对第三方API的调用被限制在您的服务器端中间件中，这有助于确保您的API秘密不会暴露给浏览器客户端。</em></p><p id="ab74" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">服务器端中间件很棒，但是我们如何确保我们的中间件得到充分的测试？</p><blockquote class="me"><p id="0862" class="mf mg jj bd mh mi mj mk ml mm mn mc dk translated">在这个循序渐进的教程中，我们将介绍测试NuxtJS应用程序中使用的服务器中间件的设置。我们将使用Je <code class="fe mo mp mq mr b">st</code>和S <code class="fe mo mp mq mr b">uperTest</code>，浏览各种中间件示例及其相应的测试。</p></blockquote><p id="c35c" class="pw-post-body-paragraph lh li jj lj b lk ms kt lm ln mt kw lp lq mu ls lt lu mv lw lx ly mw ma mb mc im bi translated">这是我们的教程路线图:</p><ol class=""><li id="d062" class="mx my jj lj b lk ll ln lo lq mz lu na ly nb mc nc nd ne nf bi translated">创建一个新的NuxtJS应用程序。</li><li id="51b8" class="mx my jj lj b lk ng ln nh lq ni lu nj ly nk mc nc nd ne nf bi translated">为我们的第一个服务器端中间件——一个基本GET请求的API端点——编写测试。</li><li id="f72d" class="mx my jj lj b lk ng ln nh lq ni lu nj ly nk mc nc nd ne nf bi translated">创建一个模拟服务器的测试支持文件，并使用在<code class="fe mo mp mq mr b">nuxt.config.js</code>注册的每个中间件。</li><li id="73dc" class="mx my jj lj b lk ng ln nh lq ni lu nj ly nk mc nc nd ne nf bi translated">实现我们的中间件，让我们的测试变得绿色。</li><li id="35cc" class="mx my jj lj b lk ng ln nh lq ni lu nj ly nk mc nc nd ne nf bi translated">有了我们的测试框架，再看几个中间件测试和实现的例子。</li></ol><h1 id="060e" class="nl nm jj bd nn no np nq nr ns nt nu nv ky nw kz nx lb ny lc nz le oa lf ob oc bi translated">1.创建一个NuxtJS应用程序</h1><p id="2ca4" class="pw-post-body-paragraph lh li jj lj b lk od kt lm ln oe kw lp lq of ls lt lu og lw lx ly oh ma mb mc im bi translated">我们将从创建一个新的NuxtJS应用程序开始。在本教程中，我们将使用<code class="fe mo mp mq mr b">yarn</code>，但你也可以使用<code class="fe mo mp mq mr b">npm</code>。在命令行中，我们将运行<code class="fe mo mp mq mr b">yarn create nuxt-app</code>命令，然后回答一些提示。注意，对本教程很重要的是，我们<strong class="lj jt">将</strong>使用<code class="fe mo mp mq mr b">ESLint</code>、<code class="fe mo mp mq mr b">Jest</code>和<code class="fe mo mp mq mr b">Universal (SSR)</code>渲染模式。</p><pre class="oi oj ok ol gt om mr on oo aw op bi"><span id="c342" class="oq nm jj mr b gy or os l ot ou">~$ <strong class="mr jt">yarn create nuxt-app middleware-tests<br/></strong>...<br/>create-nuxt-app v2.15.0<br/>✨  Generating Nuxt.js project in middleware-tests<br/>? Project name <em class="md">middleware-tests</em><br/>? Project description <em class="md">My NuxtJS demonstration of middleware testing</em><br/>? Author name <em class="md">Alvin Lee</em><br/>? Choose programming language <em class="md">JavaScript</em><br/>? Choose the package manager <em class="md">Yarn</em><br/>? Choose UI framework <em class="md">None</em><br/>? Choose custom server framework <em class="md">None (Recommended)</em><br/>? Choose Nuxt.js modules <em class="md">None</em><br/>? Choose linting tools <strong class="mr jt">ESLint</strong><br/>? Choose test framework <strong class="mr jt">Jest</strong><br/>? Choose rendering mode <strong class="mr jt">Universal (SSR)</strong><br/>? Choose development tools <em class="md">None<br/>...<br/></em>Done in 217.53s.</span></pre><p id="fdef" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们有我们的NuxtJS应用程序。让我们继续删除前端相关代码，因为这不是我们在这里关注的重点:</p><pre class="oi oj ok ol gt om mr on oo aw op bi"><span id="2fe6" class="oq nm jj mr b gy or os l ot ou">~$ <strong class="mr jt">cd middleware-tests</strong><br/>~/middleware-tests$ <strong class="mr jt">rm components/*</strong><br/>~/middleware-tests$ <strong class="mr jt">rm pages/*</strong></span><span id="c1d8" class="oq nm jj mr b gy ov os l ot ou">~/middleware-tests$ <strong class="mr jt">yarn test<br/></strong>yarn run v1.22.4<br/>$ jest<br/>No tests found, exiting with code 1</span></pre><p id="25f1" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">好吧，这是个开始。我们还没有任何测试，但我们正在路上。</p><h1 id="4677" class="nl nm jj bd nn no np nq nr ns nt nu nv ky nw kz nx lb ny lc nz le oa lf ob oc bi translated">2.为获取端点中间件编写测试</h1><p id="17f8" class="pw-post-body-paragraph lh li jj lj b lk od kt lm ln oe kw lp lq of ls lt lu og lw lx ly oh ma mb mc im bi translated">让我们为我们的第一个中间件编写一些测试。我们想要的是一个基本的API端点，它可以完成以下任务:</p><ul class=""><li id="208f" class="mx my jj lj b lk ll ln lo lq mz lu na ly nb mc ow nd ne nf bi translated">接受对端点<code class="fe mo mp mq mr b">/hello</code>的GET请求</li><li id="19af" class="mx my jj lj b lk ng ln nh lq ni lu nj ly nk mc ow nd ne nf bi translated">需要一个GET查询参数<code class="fe mo mp mq mr b">name</code></li><li id="08b4" class="mx my jj lj b lk ng ln nh lq ni lu nj ly nk mc ow nd ne nf bi translated">返回一个带有<code class="fe mo mp mq mr b">name</code>和<code class="fe mo mp mq mr b">message</code>的JSON编码对象。例如，如果给定的<code class="fe mo mp mq mr b">name</code>是<code class="fe mo mp mq mr b">John</code>，那么应该返回的是:</li></ul><pre class="oi oj ok ol gt om mr on oo aw op bi"><span id="a184" class="oq nm jj mr b gy or os l ot ou">{<br/>  "name":"John",<br/>  "message":"Hello, John."<br/>}</span></pre><ul class=""><li id="8427" class="mx my jj lj b lk ll ln lo lq mz lu na ly nb mc ow nd ne nf bi translated">如果<code class="fe mo mp mq mr b">name</code>参数未给定或为空，则用状态码<code class="fe mo mp mq mr b">500</code>响应。</li></ul><p id="ef8e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">很简单。请记住，我们不是要一个超级复杂的中间件——我们的目标是掌握中间件测试设置。为了测试，我们将使用<a class="ae jg" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>和<a class="ae jg" href="https://github.com/visionmedia/supertest" rel="noopener ugc nofollow" target="_blank"> SuperTest </a>。Jest已经嵌入到我们的NuxtJS应用程序中，但是我们需要添加SuperTest:</p><pre class="oi oj ok ol gt om mr on oo aw op bi"><span id="7c89" class="oq nm jj mr b gy or os l ot ou">~/middleware-tests$ <strong class="mr jt">yarn add --dev supertest</strong></span></pre><p id="7884" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来，让我们创建一个<code class="fe mo mp mq mr b">middleware</code>子文件夹。</p><pre class="oi oj ok ol gt om mr on oo aw op bi"><span id="2696" class="oq nm jj mr b gy or os l ot ou">~/middleware-tests$ <strong class="mr jt">mkdir middleware</strong></span></pre><p id="6f53" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们在这个新的<code class="fe mo mp mq mr b">middleware</code>文件夹中创建我们的测试文件，将其命名为<code class="fe mo mp mq mr b">hello.test.js</code>:</p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">GET endpoint中间件的测试文件:~/middleware-tests/middleware/hello . test . js</figcaption></figure><p id="129d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，当我们运行测试时，我们会注意到一个缺失的模块:</p><pre class="oi oj ok ol gt om mr on oo aw op bi"><span id="b8c3" class="oq nm jj mr b gy or os l ot ou">~/middleware-tests$ <strong class="mr jt">yarn test</strong><br/>yarn run v1.22.4<br/>$ jest<br/> FAIL  middleware/hello.test.js<br/>  ● Test suite failed to run</span><span id="228c" class="oq nm jj mr b gy ov os l ot ou">Cannot find module '../testSupport/serverSideApp' from 'hello.test.js'</span></pre><p id="153d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">没错——我们还没写<code class="fe mo mp mq mr b">serverSideApp.js</code>。我们需要创建模拟NuxtJS的设置，为我们所有的中间件提供服务。让我们现在做那件事。</p><h1 id="08a2" class="nl nm jj bd nn no np nq nr ns nt nu nv ky nw kz nx lb ny lc nz le oa lf ob oc bi translated">3.创建模拟服务器的测试支持文件</h1><p id="29dd" class="pw-post-body-paragraph lh li jj lj b lk od kt lm ln oe kw lp lq of ls lt lu og lw lx ly oh ma mb mc im bi translated">NuxtJS 的<a class="ae jg" href="https://nuxtjs.org/api/configuration-servermiddleware/" rel="noopener ugc nofollow" target="_blank">文档写道:</a></p><blockquote class="oz pa pb"><p id="b844" class="lh li md lj b lk ll kt lm ln lo kw lp pc lr ls lt pd lv lw lx pe lz ma mb mc im bi translated">Nuxt在内部创建了一个<a class="ae jg" href="https://github.com/senchalabs/connect" rel="noopener ugc nofollow" target="_blank"> connect </a>实例，我们可以向其中添加我们自己的定制中间件。这允许我们注册额外的路由，而不需要外部服务器。</p></blockquote><p id="74e2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此，对于我们的测试支持，我们想要创建一个<a class="ae jg" href="https://github.com/senchalabs/connect" rel="noopener ugc nofollow" target="_blank">连接实例</a>，它使用我们在<code class="fe mo mp mq mr b">nuxt.config.js</code>中注册的所有中间件。我们上面的测试获取了那个实例(名为<code class="fe mo mp mq mr b">app</code>)并将其交给SuperTest，这样我们就可以四处查看并断言一些期望。</p><p id="338f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个<code class="fe mo mp mq mr b">app</code>就是我们需要在<code class="fe mo mp mq mr b">testSupport/serverSideApp.js</code>中创建和导出的内容。让我们创建<code class="fe mo mp mq mr b">testSupport</code>子文件夹:</p><pre class="oi oj ok ol gt om mr on oo aw op bi"><span id="fe1b" class="oq nm jj mr b gy or os l ot ou">~/middleware-tests$ <strong class="mr jt">mkdir testSupport</strong></span></pre><p id="72ff" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这个文件夹中，我们创建了<code class="fe mo mp mq mr b">serverSideApp.js</code>:</p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">~/testSupport/serverSideApp.js</figcaption></figure><p id="26f1" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们看看上面的代码是做什么的。总的来说，我们正在创建一个<a class="ae jg" href="https://github.com/senchalabs/connect" rel="noopener ugc nofollow" target="_blank"> Connect </a>实例，将它告知<code class="fe mo mp mq mr b">nuxt.config.js</code>中定义的<code class="fe mo mp mq mr b">use</code>各种中间件，然后我们导出该实例。</p><p id="ca39" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在<code class="fe mo mp mq mr b">nuxt.config.js</code>的<code class="fe mo mp mq mr b">serverMiddleware</code>数组中注册的中间件可以通过两种方式注册:</p><ul class=""><li id="5ffa" class="mx my jj lj b lk ll ln lo lq mz lu na ly nb mc ow nd ne nf bi translated">作为一个<code class="fe mo mp mq mr b">string</code>，它是导出中间件处理函数的文件的位置——这个中间件没有挂载路径，这意味着它将应用于所有请求，而不管它们的路径。</li><li id="4b29" class="mx my jj lj b lk ng ln nh lq ni lu nj ly nk mc ow nd ne nf bi translated">作为带有<code class="fe mo mp mq mr b">path</code>和<code class="fe mo mp mq mr b">handler</code>的<code class="fe mo mp mq mr b">object</code>。<code class="fe mo mp mq mr b">path</code>是这个中间件将被应用的请求路径挂载点，而<code class="fe mo mp mq mr b">handler</code>是中间件处理函数的位置。</li></ul><p id="1141" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在上面的代码中，我们检查了<code class="fe mo mp mq mr b">serverMiddleware</code>数组中的每一项。如果它是一个<code class="fe mo mp mq mr b">string</code>，我们导入处理函数并告诉我们的<code class="fe mo mp mq mr b">app</code>到<code class="fe mo mp mq mr b">use</code>它没有任何路径挂载点。如果它是一个<code class="fe mo mp mq mr b">object</code>，我们导入在<code class="fe mo mp mq mr b">handler</code>提供的位置找到的处理函数，并在<code class="fe mo mp mq mr b">path</code>中定义的挂载点<code class="fe mo mp mq mr b">use</code>它。</p><p id="28d7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">你可能熟悉与Express 几乎相同的过程。这里没多大区别。我们选择使用Connect，因为这是NuxtJS开箱即用的，我们希望我们的测试设置尽可能地反映生产设置。</p><p id="a65b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">顺便提一下，NuxtJS文档还允许向<code class="fe mo mp mq mr b">serverMiddleware</code>提供一个对象，而不是一个数组。使用这种对象格式是不太常见的方法——如果这是您决定要做的，您可以相应地调整您的<code class="fe mo mp mq mr b">serverSideApp.js</code>代码。</p><p id="654a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，我们回到我们的测试:</p><pre class="oi oj ok ol gt om mr on oo aw op bi"><span id="d043" class="oq nm jj mr b gy or os l ot ou">~/middleware-tests$ <strong class="mr jt">yarn test</strong><br/> FAIL  middleware/hello.test.js<br/>  ● Test suite failed to run</span><span id="4a9c" class="oq nm jj mr b gy ov os l ot ou">TypeError: _nuxt.default.serverMiddleware is not iterable</span></pre><p id="766a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是怎么回事？我们还没有在<code class="fe mo mp mq mr b">nuxt.config.js</code>注册(或编写)我们的<code class="fe mo mp mq mr b">hello.js</code>中间件。编辑<code class="fe mo mp mq mr b">nuxt.config.js</code>，添加<code class="fe mo mp mq mr b">serverMiddleware</code>配置属性如下:</p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">将serverMiddleware属性添加到~/nuxt.config.js中</figcaption></figure><p id="b344" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，当我们运行测试时，我们被告知无法定位<code class="fe mo mp mq mr b">hello.js</code>。我们的服务器中间件已经注册了，NuxtJS正在找；但是我们还没有写出来。</p><p id="a38f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">是时候实现我们的中间件了。</p><h1 id="80ae" class="nl nm jj bd nn no np nq nr ns nt nu nv ky nw kz nx lb ny lc nz le oa lf ob oc bi translated">4.实现中间件以通过测试</h1><p id="2985" class="pw-post-body-paragraph lh li jj lj b lk od kt lm ln oe kw lp lq of ls lt lu og lw lx ly oh ma mb mc im bi translated">在<code class="fe mo mp mq mr b">middleware/</code>文件夹中，我们实现了我们的中间件，编写<code class="fe mo mp mq mr b">hello.js</code>:</p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">中间件实现:~/middleware-tests/middleware/hello . js</figcaption></figure><p id="d0ef" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，我们的中间件实现已经完成，让我们再次运行我们的测试:</p><pre class="oi oj ok ol gt om mr on oo aw op bi"><span id="607e" class="oq nm jj mr b gy or os l ot ou">~/middleware-tests$ <strong class="mr jt">yarn test</strong></span><span id="1989" class="oq nm jj mr b gy ov os l ot ou">PASS  middleware/hello.test.js<br/>  GET /hello<br/>    when query param "name" provided<br/>      when "name" is blank<br/>        ✓ responds with status code 500 (52ms)<br/>      when "name" is not blank<br/>        ✓ responds with status code 200 (9ms)<br/>        response body<br/>          ✓ is a JSON object with correct "name" and "message" (3ms)<br/>    when query param "name" not provided<br/>      ✓ responds with status code 500 (1ms)</span><span id="1fc3" class="oq nm jj mr b gy ov os l ot ou">-----|---------|----------|---------|---------|-------------------|<br/>File | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s |<br/>-----|---------|----------|---------|---------|-------------------|<br/>All  |       0 |        0 |       0 |       0 |                   |<br/>-----|---------|----------|---------|---------|-------------------|</span><span id="d6f7" class="oq nm jj mr b gy ov os l ot ou">Test Suites: 1 passed, 1 total<br/>Tests:       4 passed, 4 total<br/>Snapshots:   0 total<br/>Time:        1.359s<br/>Ran all test suites.<br/>Done in 2.35s.</span></pre><p id="8957" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">太好了。我们所有的测试都通过了。然而，你会注意到，测试<strong class="lj jt">覆盖率</strong>结果显示了一堆0。这是因为当前的<code class="fe mo mp mq mr b">jest</code>配置在计算代码覆盖率时没有考虑到我们的中间件文件。让我们通过给<code class="fe mo mp mq mr b">jest.config.js</code>添加一行来改变这一点:</p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">将中间件文件添加到~/jest.config.js中的代码覆盖率配置中</figcaption></figure><p id="e49a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们添加了最后一行(上面要点中的第20行)来在收集覆盖数据时包含<code class="fe mo mp mq mr b">middleware</code>子文件夹中的<code class="fe mo mp mq mr b">.js</code>文件。现在，当我们运行测试时:</p><pre class="oi oj ok ol gt om mr on oo aw op bi"><span id="2e20" class="oq nm jj mr b gy or os l ot ou">~/middleware-tests$ <strong class="mr jt">yarn test<br/></strong> PASS  middleware/hello.test.js<br/>  GET /hello<br/>    when query param "name" provided<br/>      when "name" is blank<br/>        ✓ responds with status code 500 (53ms)<br/>      when "name" is not blank<br/>        ✓ responds with status code 200 (9ms)<br/>        response body<br/>          ✓ is a JSON object with correct "name" and "message" (2ms)<br/>    when query param "name" not provided<br/>      ✓ responds with status code 500 (1ms)</span><span id="f511" class="oq nm jj mr b gy ov os l ot ou">-------|---------|----------|---------|---------|------------------|<br/>File   | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s|<br/>-------|---------|----------|---------|---------|------------------|<br/>All    |     100 |      100 |     100 |     100 |                  |<br/> hello.js |  100 |      100 |     100 |     100 |                  |<br/>-------|---------|----------|---------|---------|------------------|<br/>Test Suites: 1 passed, 1 total<br/>Tests:       4 passed, 4 total<br/>Snapshots:   0 total<br/>Time:        1.439s<br/>Ran all test suites.<br/>Done in 2.27s.</span></pre><p id="8f96" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">你会注意到，我们的中间件文件包含在代码覆盖检查中，我们显示的是100%。太好了！我们的第一个中间件有一个测试文件和一个让我们的测试通过的实现。但更重要的是，我们已经为中间件的可靠测试准备好了配置和基础设施。</p><p id="bf24" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">简单回顾一下，以下是我们在本教程中编辑或创建的文件:</p><pre class="oi oj ok ol gt om mr on oo aw op bi"><span id="77a8" class="oq nm jj mr b gy or os l ot ou">.<br/>├── jest.config.js     <em class="md">(added middleware files to code coverage)</em><br/>├── nuxt.config.js     <em class="md">(registered middleware in serverMiddleware)</em><br/>├── package.json       <em class="md">(added supertest package)</em><br/>testSupport/<br/>└── serverSideApp.js   <em class="md">(new)</em><br/>middleware/<br/>├── hello.js           <em class="md">(new)</em><br/>└── hello.test.js      <em class="md">(new)</em></span></pre><p id="25de" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们继续看一些其他的中间件及其测试的例子。</p><h1 id="79ad" class="nl nm jj bd nn no np nq nr ns nt nu nv ky nw kz nx lb ny lc nz le oa lf ob oc bi translated">5.中间件和测试的其他示例</h1><p id="1342" class="pw-post-body-paragraph lh li jj lj b lk od kt lm ln oe kw lp lq of ls lt lu og lw lx ly oh ma mb mc im bi translated">在本教程的最后一部分，我们将讨论一些在NuxtJS应用程序中使用的中间件的常见情况。对于每个中间件，我们将编写一个测试文件，然后是一个实现。我们将涵盖以下示例:</p><ul class=""><li id="864a" class="mx my jj lj b lk ll ln lo lq mz lu na ly nb mc ow nd ne nf bi translated">记录器</li><li id="e99b" class="mx my jj lj b lk ng ln nh lq ni lu nj ly nk mc ow nd ne nf bi translated">向请求添加时间戳</li><li id="4684" class="mx my jj lj b lk ng ln nh lq ni lu nj ly nk mc ow nd ne nf bi translated">验证授权标题中的JWT</li></ul><p id="ab13" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">同样，我们并不打算构建具有大量功能的超级复杂的中间件。我们只是想介绍一些基础知识，以便对测试有一个好的感觉。</p><h2 id="f89e" class="oq nm jj bd nn pf pg dn nr ph pi dp nv lq pj pk nx lu pl pm nz ly pn po ob jp bi translated">示例1:记录器中间件</h2><p id="913f" class="pw-post-body-paragraph lh li jj lj b lk od kt lm ln oe kw lp lq of ls lt lu og lw lx ly oh ma mb mc im bi translated">对于这个例子，我们想要一个中间件，它将每个请求的<code class="fe mo mp mq mr b">method</code>和<code class="fe mo mp mq mr b">url</code>记录到控制台。我们希望这个中间件用于所有的路径，而不仅仅是特定的端点。</p><p id="6aec" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面是我们的测试文件可能的样子:</p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">记录器中间件的测试文件:~/middleware-tests/middleware/Logger . test . js</figcaption></figure><p id="4788" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">注意，我们利用Jest的<code class="fe mo mp mq mr b">spyOn</code>功能来监视<code class="fe mo mp mq mr b">console.log</code>。</p><p id="0a6e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">有了我们的测试文件，我们需要做两件事来让这些测试变得绿色:</p><ol class=""><li id="9fb1" class="mx my jj lj b lk ll ln lo lq mz lu na ly nb mc nc nd ne nf bi translated">创建我们的日志中间件实现文件。</li><li id="07bf" class="mx my jj lj b lk ng ln nh lq ni lu nj ly nk mc nc nd ne nf bi translated">在<code class="fe mo mp mq mr b">nuxt.config.js</code>中注册该中间件</li></ol><p id="e281" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们的日志中间件实现非常简单:</p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">记录器中间件实现:~/Middleware-tests/Middleware/logger . js</figcaption></figure><p id="f551" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们需要做的最后一件事是将这个中间件的条目添加到<code class="fe mo mp mq mr b">nuxt.config.js</code>中的<code class="fe mo mp mq mr b">serverMiddleware</code>数组中。因为我们希望我们的日志中间件用于所有的路径，我们简单地将它作为一个字符串添加，而不是作为一个带有T3和T4的对象。另外，<code class="fe mo mp mq mr b">nuxt.config.js</code>将按照注册的顺序使用中间件，所以我们希望在注册我们的<code class="fe mo mp mq mr b">hello</code>中间件之前<em class="md">注册我们的日志中间件。修改<code class="fe mo mp mq mr b">nuxt.config.js</code>如下所示:</em></p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">在~/nuxt.config.js中注册记录器中间件</figcaption></figure><p id="d054" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，当我们运行我们的测试时，我们应该看到所有的测试都通过了，并且100%的代码覆盖率。</p><p id="07ec" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">顺便说一下，由于我们将所有请求记录到<code class="fe mo mp mq mr b">console</code>，您会注意到您的测试套件现在有了更多的<code class="fe mo mp mq mr b">console.log</code>语句。为了消除这些问题，您可以将<code class="fe mo mp mq mr b">--silent</code>标记添加到您的测试运行中:</p><pre class="oi oj ok ol gt om mr on oo aw op bi"><span id="05c5" class="oq nm jj mr b gy or os l ot ou">~/middleware-tests$ <strong class="mr jt">yarn test --silent<br/></strong> PASS  middleware/hello.test.js<br/> PASS  middleware/logger.test.js</span></pre><h2 id="5936" class="oq nm jj bd nn pf pg dn nr ph pi dp nv lq pj pk nx lu pl pm nz ly pn po ob jp bi translated">示例2:请求时间戳</h2><p id="51e3" class="pw-post-body-paragraph lh li jj lj b lk od kt lm ln oe kw lp lq of ls lt lu og lw lx ly oh ma mb mc im bi translated">对于我们的第二个例子，我们想要获取传入的HTTP请求(<code class="fe mo mp mq mr b">req</code>)并向其添加我们自己的<code class="fe mo mp mq mr b">requestTime</code>属性。这个中间件应该在所有路径上使用。</p><p id="7702" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">首先，我们的测试文件:</p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">请求时间戳中间件的测试文件:~/middleware-tests/middleware/Timestamp . test . js</figcaption></figure><p id="0c20" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个测试有点棘手。我们假设这个时间戳中间件将在我们的请求通过的中间件处理程序管道的早期出现。此时，<code class="fe mo mp mq mr b">req</code>被赋予了一个新的<code class="fe mo mp mq mr b">requestTime</code>属性。但到目前为止，我们还没有任何端点使用或输出那个<code class="fe mo mp mq mr b">requestTime</code>。那么，我们如何测试我们的时间戳中间件实际上做了它应该做的事情？</p><p id="39f7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在我们的测试文件中，我们创建了一个返回<code class="fe mo mp mq mr b">req.requestTime</code>的中间件<code class="fe mo mp mq mr b">use</code>，使得这个中间件只适用于特定的路径。然后，我们向该路径发出请求，期望响应包含正确的时间戳。只有正确编写了<code class="fe mo mp mq mr b">req.requestTime</code>,时间戳才会存在。请记住，我们在这里只<code class="fe mo mp mq mr b">use</code>这个中间件<em class="md">——</em>在这个测试文件中——作为一个临时的“窥视”请求的方法。</p><p id="3cd2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是拥有来自<code class="fe mo mp mq mr b">serverSideApp.js</code>的<code class="fe mo mp mq mr b">app</code>的好处之一——当需要时，我们可以<code class="fe mo mp mq mr b">use</code>额外的中间件来帮助我们探查<code class="fe mo mp mq mr b">req</code>和<code class="fe mo mp mq mr b">res</code>的状态，以便断言一些期望。</p><p id="3c93" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个请求时间戳中间件的实现非常简单:</p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">请求时间戳中间件实现:~/middleware-tests/middleware/timestamp . js</figcaption></figure><p id="262b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们记住在<code class="fe mo mp mq mr b">nuxt.config.js</code>的<code class="fe mo mp mq mr b">serverMiddleware</code>栈中注册这个中间件:</p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">在nuxt.config.js中注册timestamp.js中间件</figcaption></figure><p id="ae08" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们运行我们的测试，我们看到一切都通过了。让我们继续我们的最后一个例子。</p><pre class="oi oj ok ol gt om mr on oo aw op bi"><span id="20ee" class="oq nm jj mr b gy or os l ot ou">~/middleware-tests$ <strong class="mr jt">yarn test --silent</strong><br/> PASS  middleware/hello.test.js<br/> PASS  middleware/logger.test.js<br/> PASS  middleware/timestamp.test.js</span></pre><h2 id="97e0" class="oq nm jj bd nn pf pg dn nr ph pi dp nv lq pj pk nx lu pl pm nz ly pn po ob jp bi translated">示例3:验证授权标题中的JWT</h2><p id="bc34" class="pw-post-body-paragraph lh li jj lj b lk od kt lm ln oe kw lp lq of ls lt lu og lw lx ly oh ma mb mc im bi translated">对于我们的最后一个例子，让我们假设有一个受保护的路径(<code class="fe mo mp mq mr b">/protected</code>)，它是一个GET请求端点，但是它需要一个有效的<a class="ae jg" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JSON Web令牌</a> (JWT)。如果JWT有效，响应正文应该包含JWT中编码的<code class="fe mo mp mq mr b">userID</code>，响应将有一个状态代码<code class="fe mo mp mq mr b">200</code>。否则，我们应该得到一个状态代码<code class="fe mo mp mq mr b">401</code>。</p><p id="66e0" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">JWT的也应该用一个秘密签名，这样我们可以验证请求中提供的JWT确实来自一个可信的来源。</p><p id="2767" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于这个中间件，我们需要添加<code class="fe mo mp mq mr b"><a class="ae jg" href="https://github.com/auth0/node-jsonwebtoken" rel="noopener ugc nofollow" target="_blank">jsonwebtoken</a></code>包:</p><pre class="oi oj ok ol gt om mr on oo aw op bi"><span id="94d0" class="oq nm jj mr b gy or os l ot ou">~/middleware-tests$ <strong class="mr jt">yarn add jsonwebtoken</strong></span></pre><p id="e65f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们的测试文件可能是这样的:</p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">JWT授权中间件的测试文件:~/middleware-tests/middleware/protected . test . js</figcaption></figure><p id="4d82" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然后，我们在<code class="fe mo mp mq mr b">protected.js</code>中的中间件的实现文件:</p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">JWT授权中间件的实现:~/middleware-tests/middleware/protected . js</figcaption></figure><p id="db8b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">关于上面两个文件中的<code class="fe mo mp mq mr b">JWT_SECRET</code>,只需简单说明一下。显然，在两个不同的文件中定义<code class="fe mo mp mq mr b">JWT_SECRET</code>是不明智的做法。应该有一个单一的真理来源——一个定义了一次<code class="fe mo mp mq mr b">JWT_SECRET</code>的中心位置，任何其他需要它的代码都会引用它。此外，像<code class="fe mo mp mq mr b">JWT_SECRET</code>这样敏感的信息根本不应该硬编码——它应该驻留在某个环境变量中，永远不要放入您的源代码库中。在上面的例子中，我这样做只是为了使本教程简单，并专注于手头的任务:学习如何测试中间件。</p><p id="d297" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后，不要忘记注册您的中间件:</p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="7d3e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们整个测试套件的最后一次运行:</p><pre class="oi oj ok ol gt om mr on oo aw op bi"><span id="d5a3" class="oq nm jj mr b gy or os l ot ou">~/middleware-tests$ <strong class="mr jt">yarn test --silent --verbose<br/></strong> PASS  middleware/hello.test.js<br/>  GET /hello<br/>    when query param "name" provided<br/>      when "name" is blank<br/>        ✓ responds with status code 500 (34ms)<br/>      when "name" is not blank<br/>        ✓ responds with status code 200 (8ms)<br/>        response body<br/>          ✓ is a JSON object with correct "name" and "message" (8ms)<br/>    when query param "name" not provided<br/>      ✓ responds with status code 500 (8ms)</span><span id="2dd1" class="oq nm jj mr b gy ov os l ot ou">PASS  middleware/protected.test.js<br/>  GET /protected<br/>    when header does not have authorization<br/>      ✓ responds with status code 401 (7ms)<br/>    when header has authorization<br/>      when format not recognized<br/>        ✓ responds with status code 401 (3ms)<br/>      when format is Bearer token<br/>        when JWT is invalid<br/>          ✓ responds with status code 401 (3ms)<br/>        when JWT is valid<br/>          when JWT does not contain a userID<br/>            ✓ responds with status code 401 (2ms)<br/>          when JWT contains a userID<br/>            ✓ responds with status code 200 (1ms)<br/>            ✓ responds with userID as response text (2ms)</span><span id="aeae" class="oq nm jj mr b gy ov os l ot ou">PASS  middleware/logger.test.js<br/>  Logger<br/>    when request made to valid path<br/>      ✓ logs request method and url to console (4ms)<br/>    when request made to invalid path<br/>      ✓ logs request method and url to console (4ms)</span><span id="556d" class="oq nm jj mr b gy ov os l ot ou">PASS  middleware/timestamp.test.js<br/>  Request Timestamp<br/>    ✓ adds timestamp property to the original request (3ms)</span><span id="5801" class="oq nm jj mr b gy ov os l ot ou">--------------|-------|--------|-------|-------|-------------------|<br/>File          |% Stmts|% Branch|% Funcs|% Lines| Uncovered Line #s |<br/>--------------|-------|--------|-------|-------|-------------------|<br/>All files     |   100 |    100 |   100 |   100 |                   |<br/> hello.js     |   100 |    100 |   100 |   100 |                   |<br/> logger.js    |   100 |    100 |   100 |   100 |                   |<br/> protected.js |   100 |    100 |   100 |   100 |                   |<br/> timestamp.js |   100 |    100 |   100 |   100 |                   |<br/>--------------|-------|--------|-------|-------|-------------------|<br/>Test Suites: 4 passed, 4 total<br/>Tests:       13 passed, 13 total<br/>Snapshots:   0 total<br/>Time:        1.899s<br/>Done in 2.72s.</span></pre><h1 id="6daf" class="nl nm jj bd nn no np nq nr ns nt nu nv ky nw kz nx lb ny lc nz le oa lf ob oc bi translated">最终总结</h1><p id="4fbf" class="pw-post-body-paragraph lh li jj lj b lk od kt lm ln oe kw lp lq of ls lt lu og lw lx ly oh ma mb mc im bi translated">我们的教程已经结束了。当我们开始时，我们知道我们想要利用NuxtJS的内置特性在服务器上容纳中间件，但是我们需要一个设置来帮助我们正确地测试我们的中间件。</p><p id="5aca" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们经历了以下步骤:</p><ol class=""><li id="520e" class="mx my jj lj b lk ll ln lo lq mz lu na ly nb mc nc nd ne nf bi translated">创建了一个新的NuxtJS应用程序。</li><li id="ce15" class="mx my jj lj b lk ng ln nh lq ni lu nj ly nk mc nc nd ne nf bi translated">为我们的第一个中间件编写测试——一个基本GET请求的API端点(<code class="fe mo mp mq mr b">hello.test.js</code>)。</li><li id="a9b3" class="mx my jj lj b lk ng ln nh lq ni lu nj ly nk mc nc nd ne nf bi translated">创建了<code class="fe mo mp mq mr b">serverSideApp.js</code>，这是一个测试支持文件，它建立了一个Connect实例，该实例在<code class="fe mo mp mq mr b">nuxt.config.js</code>中注册的所有中间件处理程序上调用<code class="fe mo mp mq mr b">use</code>。</li><li id="1ec2" class="mx my jj lj b lk ng ln nh lq ni lu nj ly nk mc nc nd ne nf bi translated">修改了<code class="fe mo mp mq mr b">jest.config.js</code>，将<code class="fe mo mp mq mr b">middleware</code>子文件夹中的文件添加到我们的配置中，这样<code class="fe mo mp mq mr b">jest</code>将在其代码覆盖检查中包含中间件文件。</li><li id="fbdd" class="mx my jj lj b lk ng ln nh lq ni lu nj ly nk mc nc nd ne nf bi translated">实现了我们的GET endpoint中间件(<code class="fe mo mp mq mr b">hello.js</code>，确保我们在<code class="fe mo mp mq mr b">nuxt.config.js</code>的<code class="fe mo mp mq mr b">serverMiddleware</code>属性中注册了它。</li><li id="38b7" class="mx my jj lj b lk ng ln nh lq ni lu nj ly nk mc nc nd ne nf bi translated">对于另外三个中间件示例，经历了相同的“编写测试、编写实现、注册中间件”过程:</li></ol><ul class=""><li id="df86" class="mx my jj lj b lk ll ln lo lq mz lu na ly nb mc ow nd ne nf bi translated">一个日志记录中间件(<code class="fe mo mp mq mr b">logger.js</code>)，它将请求的<code class="fe mo mp mq mr b">method</code>和<code class="fe mo mp mq mr b">url</code>记录到控制台。这个中间件在所有路径上运行。</li><li id="54d2" class="mx my jj lj b lk ng ln nh lq ni lu nj ly nk mc ow nd ne nf bi translated">一个请求时间戳中间件(<code class="fe mo mp mq mr b">timestamp.js</code>)，它向<code class="fe mo mp mq mr b">req</code>添加了一个<code class="fe mo mp mq mr b">requestTime</code>属性，下游的其他中间件可以使用这个属性。这个中间件在所有路径上运行。</li><li id="8f3d" class="mx my jj lj b lk ng ln nh lq ni lu nj ly nk mc ow nd ne nf bi translated">一个JSON Web令牌验证中间件(<code class="fe mo mp mq mr b">protected.js</code>)，它检查请求是否包含带有有效签名的JWT的<code class="fe mo mp mq mr b">authorization</code>报头。这个中间件运行在一个特定的路径上(<code class="fe mo mp mq mr b">/protected</code>)。</li></ul><p id="fac2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">有了这个中间件测试的基本框架，您就可以为下一个NuxtJS应用程序编写健壮且经过良好测试的中间件代码了。去改变世界吧。</p></div><div class="ab cl pp pq hx pr" role="separator"><span class="ps bw bk pt pu pv"/><span class="ps bw bk pt pu pv"/><span class="ps bw bk pt pu"/></div><div class="im in io ip iq"><p id="3ffe" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="md">阿尔文·李</em>是亚利桑那州凤凰城的一名全栈开发人员和远程工作者。他专门从事web开发、技术咨询以及为初创公司和小型企业构建原型。他可以在Moonlight上找到，在那里你可以<a class="ae jg" href="https://www.moonlightwork.com/app/users/2862/profile" rel="noopener ugc nofollow" target="_blank">查看他的个人资料</a>或者<a class="ae jg" href="https://www.moonlightwork.com/r/2862" rel="noopener ugc nofollow" target="_blank">请求雇佣他提供服务</a>。</p></div></div>    
</body>
</html>