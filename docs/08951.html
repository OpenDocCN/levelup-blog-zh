<html>
<head>
<title>Javascript’s __proto__ vs prototype</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript的__proto__ vs原型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascripts-proto-vs-prototype-a21ec7f25bc1?source=collection_archive---------4-----------------------#2021-06-22">https://levelup.gitconnected.com/javascripts-proto-vs-prototype-a21ec7f25bc1?source=collection_archive---------4-----------------------#2021-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7aff" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Javascript很混乱。在所有神秘的东西中，<code class="fe kf kg kh ki b">__proto__</code>和<code class="fe kf kg kh ki b">prototype</code>的区别是独一无二的。这让大多数试图学习该语言面向对象方面的程序员感到困惑。</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/2f55f14040b50a2df3bc842b49f680c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cCCI0qNGTaLR9NaeGeM7DQ.png"/></div></div></figure><p id="9976" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文面向对面向对象编程有基本了解并探索Javascript实现这一点的开发人员。</p><p id="1ee9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们从以下几点重新开始</p><ol class=""><li id="83b3" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">Javascript中的一切都是对象(除了基本类型)</li><li id="e443" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">每个物体都有原型</li><li id="1432" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">一个对象的默认原型是<code class="fe kf kg kh ki b">Object.prototype</code></li><li id="300a" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">当访问对象的属性时，对象会查看自己的属性。如果没有找到，那么它会查看其原型的属性。并且它继续这样做，除非找到该属性或者它到达了<code class="fe kf kg kh ki b">Object.prototype</code>。如果在<code class="fe kf kg kh ki b">Object.prototype</code>中没有找到该属性，则返回undefined。</li></ol><p id="7fa6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您对这些不清楚，您可以查看<a class="ae mf" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes" rel="noopener ugc nofollow" target="_blank"> MDN文档中的Javascript </a>原型。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><ol class=""><li id="d080" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><strong class="kx ir">什么是</strong> <code class="fe kf kg kh ki b"><strong class="kx ir">__proto__</strong></code> <strong class="kx ir">其目的是什么？</strong></li></ol><p id="9425" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了更好地理解这一点，让我们继续看一些例子。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mn"><img src="../Images/4f198746ecbc2c95f45f75807587b311.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x41v2yfTb6xiAsA6e27NOw.png"/></div></div></figure><p id="464a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe kf kg kh ki b">person</code>是一个简单的对象，它有三个属性<code class="fe kf kg kh ki b">name</code>、<code class="fe kf kg kh ki b">age</code>和<code class="fe kf kg kh ki b">gender</code>。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mo"><img src="../Images/cc3651fe2a21a3781b75f86be4f6777e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s7YzKa7cz_sWtUBOLNsdpQ.png"/></div></div></figure><p id="cf74" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在对那个<code class="fe kf kg kh ki b">person</code>对象使用<code class="fe kf kg kh ki b">console.dir </code>时，我们可以看到它有一个<code class="fe kf kg kh ki b">__proto__</code>属性。</p><p id="ee48" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe kf kg kh ki b">__proto__</code>属性是添加到每个对象的默认属性。这个属性指向对象的<code class="fe kf kg kh ki b">prototype</code>。</p><p id="9c4e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个对象的默认<code class="fe kf kg kh ki b">prototype</code>为<code class="fe kf kg kh ki b">Object.prototype</code>。因此，<code class="fe kf kg kh ki b">person</code>对象的<code class="fe kf kg kh ki b">__proto__</code>属性指向<code class="fe kf kg kh ki b">Object.prototype</code>。</p><p id="cd2d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我说的是真的，那么插图看起来会像这样。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mp"><img src="../Images/30e1544cbbdfd3488adb061b8269bcdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A5dyLBG-d2S3DbBbwgrdsw.png"/></div></div></figure><p id="424c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们验证一下我所说的是不是真的。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mq"><img src="../Images/779c1262c369a3169093603c25a19521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t7rBVXoGwZddbabW2qN6dg.png"/></div></div></figure><p id="5f4f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如你所看到的，<code class="fe kf kg kh ki b">person</code>对象的<code class="fe kf kg kh ki b">__proto__</code>属性确实等于<code class="fe kf kg kh ki b">Object.prototype</code>。</p><p id="a075" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我想创建另一个对象<code class="fe kf kg kh ki b">teacher</code>。该对象将具有与<code class="fe kf kg kh ki b">person</code>对象相同的属性和值。只有一个额外的属性——<code class="fe kf kg kh ki b"> subject</code>——将被添加。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mr"><img src="../Images/0c3763266db1b87ea4b4d61772248910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mgxCFdbKnmdS5XXcWSOJjw.png"/></div></div></figure><p id="1c1b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">默认情况下，<code class="fe kf kg kh ki b">teacher</code>的<code class="fe kf kg kh ki b">__proto__</code>属性会指向<code class="fe kf kg kh ki b">Object.prototype</code>对象。</p><p id="caa1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">插图看起来会像这样。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ms"><img src="../Images/b6546645fab56f57fc60be804470013a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Otz_3dVSupsKS8Nch7LvNA.png"/></div></div></figure><p id="ffef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你能看出这里的问题吗？<code class="fe kf kg kh ki b">teacher</code>和<code class="fe kf kg kh ki b">person</code>有三个相同值的公共属性。如果我们能以某种方式从<code class="fe kf kg kh ki b">person</code>继承<code class="fe kf kg kh ki b">teacher</code>的属性，那就太好了。</p><p id="09d8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，让我们首先放弃当前的<code class="fe kf kg kh ki b">teacher</code>对象。并创建一个只有<code class="fe kf kg kh ki b">subject</code>属性的新对象，因为我们将从<code class="fe kf kg kh ki b">person</code>对象继承其他属性。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mt"><img src="../Images/6f04a21d69c858bd5cf11f6d8ea87579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d5Ma8pCypSGgiN4PqS3T6Q.png"/></div></div></figure><p id="b4c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，这个结构看起来就像这样。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mu"><img src="../Images/dd89575018d24fb7c8f688b2e2c35449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VnxfSAkydqePHn_jSp93KA.png"/></div></div></figure><p id="73ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，新的<code class="fe kf kg kh ki b">teacher</code>的<code class="fe kf kg kh ki b">__proto__</code>属性仍然指向<code class="fe kf kg kh ki b">Object.prototype</code>对象。为了继承，我们必须使<code class="fe kf kg kh ki b">teacher</code>的<code class="fe kf kg kh ki b">__proto__</code>属性指向<code class="fe kf kg kh ki b">person</code>。</p><p id="8e78" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以使用<code class="fe kf kg kh ki b">Object.setPrototypeOf</code>功能。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mv"><img src="../Images/aac4e747842a84958e356e764bfd8335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2zyGtoBxvV01OCm3dgy_eg.png"/></div></div></figure><p id="dffb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，插图看起来像这样。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mw"><img src="../Images/cf7e32dd24a11a50f6be5e6a34bc2b48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ciqJxJ_cCINO_WwI-n72w.png"/></div></div></figure><p id="f4b7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe kf kg kh ki b">teacher</code>的<code class="fe kf kg kh ki b">__proto__</code>属性指向<code class="fe kf kg kh ki b">person</code>对象，<code class="fe kf kg kh ki b">person</code>的<code class="fe kf kg kh ki b">__proto__ </code>属性指向<code class="fe kf kg kh ki b">Object.prototype</code>对象。</p><p id="857c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们验证一下<code class="fe kf kg kh ki b">teacher</code>的<code class="fe kf kg kh ki b">__proto__</code>属性是否确实指向了<code class="fe kf kg kh ki b">person</code>对象。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mx"><img src="../Images/3f6cd013611c82758717b561a69f7663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8HQb1_DBwEAaXP_s2bvTTw.png"/></div></div></figure><p id="2fbe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们已经通过原型链接成功地继承了<code class="fe kf kg kh ki b">person</code>对象的属性。</p><p id="331f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们可以从<code class="fe kf kg kh ki b">teacher</code>对象中访问属性。如果在对象本身中找到该属性，它将返回。否则它会问它的原型等等。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi my"><img src="../Images/a5e7f23de8faad080d873981249a8326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*noqCTklLjSSv-W-1o-7WKQ.png"/></div></div></figure><p id="5b8a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">需要注意的一件重要事情是，<code class="fe kf kg kh ki b">__proto__</code>只是对原型的引用，而不是实例化。因此，如果我们修改原型对象中的任何属性，它也会影响子对象。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mo"><img src="../Images/8aba97b6cd3d94a3b8146a370792f5b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ag0Ir6fxAGLrL-ok5JKPvw.png"/></div></div></figure><p id="dec7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看看修改<code class="fe kf kg kh ki b">person</code>的属性是如何改变<code class="fe kf kg kh ki b">teacher</code>的<code class="fe kf kg kh ki b">__proto__</code>属性的。</p><p id="1fbc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，可以有把握地说，术语<strong class="kx ir">原型继承</strong>并不完全准确。与其说是实际继承，不如说是委托！</p><p id="d6f7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">简而言之，每个对象的<code class="fe kf kg kh ki b">__proto__</code>属性都指向对象的原型。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="7123" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> 2。什么是构造函数中的</strong> <code class="fe kf kg kh ki b"><strong class="kx ir">prototype</strong></code> <strong class="kx ir">属性，它的用途是什么？</strong></p><p id="ff91" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们从例子开始，因为它有助于更好地理解这个主题。</p><p id="e382" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们必须创建一堆属性相同但值不同的<code class="fe kf kg kh ki b">person</code>对象会怎么样？</p><p id="8ef5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以很容易地创建一个构造函数来满足这个目的。</p><p id="a93c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">构造函数是一种特殊类型的函数。它就像一个物体的蓝图。您可以使用构造函数创建具有相同属性但不同值的对象。</p><p id="8e85" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">构造函数看起来会像这样。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mz"><img src="../Images/b9b8a959e14170c82064412bdf785a51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YJkV_P96VBqA5o1YGaKI7w.png"/></div></div></figure><p id="7c74" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为函数也是对象，所以它会有一个指向函数原型的<code class="fe kf kg kh ki b">__proto__</code>属性。</p><p id="baba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">函数是特殊类型的对象。函数的<code class="fe kf kg kh ki b">__proto__</code>属性指向<code class="fe kf kg kh ki b">Function.prototype </code>而不是<code class="fe kf kg kh ki b">Object.prototype</code>。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi na"><img src="../Images/973082ae65e853c399464a96c2e18cae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BVsOEGzuoVmS70F84NtpCw.png"/></div></div></figure><p id="c16b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，除了<code class="fe kf kg kh ki b">__proto__</code>属性，构造函数还有一个<code class="fe kf kg kh ki b">prototype</code>属性。</p><p id="d5fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意嵌套在<code class="fe kf kg kh ki b">Person</code>构造函数的<code class="fe kf kg kh ki b">prototype</code>属性中的<code class="fe kf kg kh ki b">__proto__</code>属性。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nb"><img src="../Images/5babe20954862b43d864f8de55a72064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YyBdTWnBmPL6lRzmAG94VQ.png"/></div></div></figure><p id="ce7e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">原来嵌套的<code class="fe kf kg kh ki b">__proto__ </code>属性其实指向的是<code class="fe kf kg kh ki b">Object.prototype</code>。</p><p id="01b8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">图表看起来就像这样，</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nc"><img src="../Images/341487064adbd048e4ede973ea083356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VuO2C7INLqTvM-MbVaNJeQ.png"/></div></div></figure><p id="56aa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们验证一下图表是否正确。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi na"><img src="../Images/f28d1a86b744778b9da3d894aedb7960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*unTqzpuUdalfYqFtlBVw4Q.png"/></div></div></figure><p id="6d50" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是<code class="fe kf kg kh ki b">Person</code>构造函数中的<code class="fe kf kg kh ki b">prototype</code>属性的用途是什么呢？</p><p id="8e60" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">原来，每当我们用<code class="fe kf kg kh ki b">Person</code>构造函数实例化一个对象时，构造函数都会使新对象的<code class="fe kf kg kh ki b">__proto__</code>属性指向与它的<code class="fe kf kg kh ki b">prototype</code>属性相同的对象。</p><p id="3530" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这可能没什么意义。</p><p id="8906" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们来看一些真实的例子。</p><p id="1793" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们使用<code class="fe kf kg kh ki b">Person</code>构造函数实例化一个名为<code class="fe kf kg kh ki b">mySelf</code>的新对象。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mz"><img src="../Images/8e4b7de0e16e9548e3c617b720796c94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W3EnUbCYu3UxjvL_yRcmXQ.png"/></div></div></figure><p id="4c6d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意构造函数是如何让<code class="fe kf kg kh ki b">mySelf</code>的<code class="fe kf kg kh ki b">__proto__</code>属性指向<code class="fe kf kg kh ki b">Person.prototype</code>的。</p><p id="3ba5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后一幅插图看起来像这样，</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nd"><img src="../Images/abe111c885a85082068c070bb44f3a11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6a1Isvzz_mXKHIgNbHkS4g.png"/></div></div></figure><p id="9db7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，构造函数的<code class="fe kf kg kh ki b">prorotype</code>属性的唯一目的是初始化使用该构造函数实例化的对象的<code class="fe kf kg kh ki b">__proto__</code>属性。</p><p id="ba8f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">结论</strong></p><p id="c54f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">希望我没有让你更加困惑。现在你对<code class="fe kf kg kh ki b">__proto__</code>和<code class="fe kf kg kh ki b">prototype</code>的区别有了更多的了解。</p><p id="3c54" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这无疑是一个糟糕的设计，让很多程序员感到困惑。但是如你所知，Javascript更像是一种旋转的语言，而不是一种设计良好的语言。所以，我们迟早要与它和平共处。</p><p id="0d3c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我很高兴你已经读完了这篇文章。我真的希望你能就你的想法说几句话。✏️</p></div></div>    
</body>
</html>