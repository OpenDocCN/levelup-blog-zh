<html>
<head>
<title>A Beginner’s guide to Slices and Arrays in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋切片和数组初学者指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-beginners-guide-to-slices-and-arrays-in-go-67ed9e54e133?source=collection_archive---------19-----------------------#2020-09-07">https://levelup.gitconnected.com/a-beginners-guide-to-slices-and-arrays-in-go-67ed9e54e133?source=collection_archive---------19-----------------------#2020-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b6e8db5de488c5e3b54c18e16967a67c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CN0IE2RjwiC6kPjDX39suA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">蕾妮·弗伦奇(<a class="ae kf" href="http://reneefrench.blogspot.com/" rel="noopener ugc nofollow" target="_blank">http://reneefrench.blogspot.com</a>)</figcaption></figure><p id="fdc1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我学习Go的基础知识时，我惊讶地发现Go没有丰富的内置库，比如数组、地图等等..一个原因是，我来自Java等传统语言，熟悉数组和映射类型的几种实现。比如有LinkedLists、ArrayLists、HashMap、LinkedHashMap等丰富的集合。在Java里。很快，我意识到，通过Go内置的数组、切片和地图，人们可以轻松完成大部分工作。但是，为了更深入地理解数组、切片和映射的概念，确实需要一个学习过程。在本文中，我将详细介绍数组和切片这两种类型的基本知识和用法。</p><p id="aab5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">数组</strong></p><p id="4759" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">几乎所有的主流语言都有数组。数组是某种<em class="le">类型</em>的索引列表。数组有一个固定的大小，我们在初始化的时候提供。数组中元素的索引从零开始。一个字符串数组在下面两个was之一中初始化—</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="3137" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要访问和分配一个元素，可以这样做— arr[index]。由于索引从0开始，最大可能索引是<code class="fe ll lm ln lo b">length of array-1</code>。如果我们试图访问一个索引大于数组长度的元素呢？类似于— <code class="fe ll lm ln lo b"> array[4]</code>的东西。它将导致如下错误—</p><pre class="lf lg lh li gt lp lo lq lr aw ls bi"><span id="6196" class="lt lu it lo b gy lv lw l lx ly">invalid array index 4 (out of bounds for 3-element array)</span></pre><p id="4285" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着一旦定义了一个数组，就没有办法再添加它了。一个<strong class="ki iu">数组是一个固定的元素列表</strong>。但是在大多数情况下，调整列表大小的特性会派上用场。这就是<em class="le">切片</em>进入画面的地方。</p><p id="acb5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">切片</strong></p><p id="d8b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">切片是数组的一部分。切片保存对基础数组的引用。它们是可调整大小的。人们可以添加元素或删除现有的元素。切片不保存数据，它们只保存指向元素数组的指针。切片创建如下—</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="c387" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上例所示，切片是以这种格式从底层数组创建的— <code class="fe ll lm ln lo b">array[startIndex : endIndex]</code>。这里有一点需要注意的是，<code class="fe ll lm ln lo b">startIndex</code>是包容性的，<code class="fe ll lm ln lo b">endIndex</code>是排他性的。这就是为什么上面代码片段的输出是<code class="fe ll lm ln lo b">[“World”, “!”]</code>。</p><p id="0403" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简单来说，切片可以理解为如下所示的结构类型</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="826b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然名称、类型、指针引用和长度的含义是可推断的，但容量有点棘手。切片的容量是指从切片的起始位置开始，支撑数组中的元素数量。例如，考虑以下场景—</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="3520" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为上面的切片从索引2开始，到索引4结束，所以它的长度是3。由于支持数组的长度是10，切片的起始索引是2，所以切片的容量将是从索引位置2到数组末尾ie的元素数。10–2 = 8.</p><p id="6532" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面代码片段的输出是这样的-</p><pre class="lf lg lh li gt lp lo lq lr aw ls bi"><span id="6fe0" class="lt lu it lo b gy lv lw l lx ly">slice: [3 4 5]  has length:  3 , and capacity: 8</span></pre><p id="e58e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:切片的长度由内置函数<code class="fe ll lm ln lo b">len()</code>和通过<code class="fe ll lm ln lo b">cap()</code>的容量计算得出。</p><p id="87af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也可以在没有底层数组的情况下创建切片，尽管在内部，Go将数据保存在数组中。我们可以使用Go的内置<code class="fe ll lm ln lo b">make() </code>功能—</p><pre class="lf lg lh li gt lp lo lq lr aw ls bi"><span id="9d0c" class="lt lu it lo b gy lv lw l lx ly">make([]int, 5) </span></pre><p id="826f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建一个类型为<code class="fe ll lm ln lo b">int</code>且长度为5的切片。由于<code class="fe ll lm ln lo b">int</code>类型的零值为0，上面的切片打印出来看起来像<code class="fe ll lm ln lo b">[0 0 0 0 0]</code>。</p><p id="56e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> append() </strong></p><p id="0603" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实现切片灵活性的一种方法是通过内置的append函数。考虑这个场景—</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lj lk l"/></div></figure><pre class="lf lg lh li gt lp lo lq lr aw ls bi"><span id="e907" class="lt lu it lo b gy lv lw l lx ly">slice: [3 4 5]  has length:  3 , and capacity:  4<br/>slice: [3 4 5 9]  array: [1 2 3 4 5 9]</span></pre><p id="494e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最初，从startIndex为2、结束于4的数组中切下一个切片。当我们在切片上追加9，就变成了<code class="fe ll lm ln lo b">[3 4 5 9]</code>。这里一个有趣的观察是数组的第五个索引是如何从6更新到9的。这是因为如上所述，切片保存了指向数组的指针。任何添加都会对它支持的数组产生影响。这里有一个奇怪的想法，数组中元素的长度是5，切片中的最后一个元素现在指向数组中的最后一个元素。当我们试图向切片添加一个元素时会发生什么？</p><p id="576a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来找出答案。我将下面的代码片段添加到上面的代码中。</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lj lk l"/></div></figure><pre class="lf lg lh li gt lp lo lq lr aw ls bi"><span id="fd9d" class="lt lu it lo b gy lv lw l lx ly">slice: [3 4 5 9 11]  array: [1 2 3 4 5 9]</span></pre><p id="2dea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不出所料，切片中添加了11。在这一点上没有什么好惊讶的。但有趣的是，数组没有更新。内部发生的情况是，由于数组是一个固定的元素块，并且容量耗尽，Go <strong class="ki iu">将数组的元素复制到一个新数组中，其容量是现有数组的两倍</strong>并且<strong class="ki iu">将切片指向这个新数组</strong>。我们可以通过在切片上调用<strong class="ki iu"> cap() </strong>来验证这一点。</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="0883" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出看起来如下—</p><pre class="lf lg lh li gt lp lo lq lr aw ls bi"><span id="f929" class="lt lu it lo b gy lv lw l lx ly">slice: [3 4 5 9]  array: [1 2 3 4 5 9]<br/>capacity of the slice:  4<br/>slice: [3 4 5 9 11]  array: [1 2 3 4 5 9]<br/>capacity of the slice:  8</span></pre><p id="88b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如预期的那样，容量从4个增加到了8个。现在对切片的任何更新都不会对它以前指向的旧的<code class="fe ll lm ln lo b">array</code>产生影响。</p><p id="c7d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> make() </strong></p><p id="9efc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过<code class="fe ll lm ln lo b">make()</code>函数，我们可以创建一个切片，而不必显式初始化一个数组并从中切割一个切片。<code class="fe ll lm ln lo b">make()</code>所做的是用<code class="fe ll lm ln lo b">length</code>和可选的<code class="fe ll lm ln lo b">capacity</code>参数创建一个内部数组。这个内部数组在后台创建，程序员看不到。让我们举个例子——</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="dfb7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过使用<code class="fe ll lm ln lo b">append()</code>，我们可以增加列表的大小。和以前一样，可以以通常的方式访问特定的元素— <code class="fe ll lm ln lo b">slice[index]</code></p><p id="93d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个参数是切片的长度。此外，我们还可以提供容量。让我们看看，随着切片长度的增加，切片的容量是如何变化的。</p><p id="7f9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">迭代</strong></p><p id="ffff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以通过循环对切片进行迭代来操作和访问切片。让我们在下面的例子中理解如何用<code class="fe ll lm ln lo b">for</code>循环来实现——</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="f19a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">访问大于切片长度的索引会导致如下所示的错误</p><pre class="lf lg lh li gt lp lo lq lr aw ls bi"><span id="d184" class="lt lu it lo b gy lv lw l lx ly">panic: runtime error: index out of range [7] with length 5</span></pre><p id="19cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以使用<code class="fe ll lm ln lo b">range</code>对切片进行迭代</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="f04c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面代码片段的输出如下-</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/a7f01361bc8bf0d3645daefe831e6a63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*efG1TnZtV-UQ-BeKDZkdtQ.png"/></div></figure><p id="d8ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">长度与容量</strong></p><p id="9040" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如前所述，在用make函数初始化切片时，我们可以提供capacity作为可选参数。默认情况下，它与长度参数相同。切片的容量可以看作是Go分配给切片的连续存储量。一旦切片长度达到其容量，Go环境将创建一个容量加倍的新后备数组，并将现有数组中的所有元素复制到新数组中。通过下面的例子，让我们看看容量是如何随着长度的增加而增加的——</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lj lk l"/></div></figure><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ma"><img src="../Images/e2517ba28fd954471f2cd164a5b69ecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q3zHpQqN8KhR0gcQFILQlA.png"/></div></div></figure><p id="a953" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看看当长度达到2的幂时，容量是如何翻倍的。当切片的长度和容量为4时，添加一个数字会触发容量翻倍。</p><p id="4fe8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们提供像— make([]int，6，6)这样的自定义容量，容量将遵循6的倍数，如下所示—</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/cdcd985ce45c536b9ea74900d64f549d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*XX44Qtz92P8kNaWQzx2F5g.png"/></div></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="9842" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就这样，对切片内部的基本理解为使用Go提供了一个良好的开端。试试这个<a class="ae kf" href="https://play.golang.org/" rel="noopener ugc nofollow" target="_blank">https://play.golang.org/</a>来写围棋的小片段。</p><p id="5901" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">参考https://blog.golang.org/slices的官方博客<a class="ae kf" href="https://blog.golang.org/slices" rel="noopener ugc nofollow" target="_blank">可以更好地理解切片的概念和特性。</a></p></div></div>    
</body>
</html>