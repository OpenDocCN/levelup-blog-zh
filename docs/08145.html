<html>
<head>
<title>OOP with D&amp;D: Polymorphism</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象的D&amp;D:多态性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/oop-with-d-d-polymorphism-b1974435063b?source=collection_archive---------6-----------------------#2021-04-05">https://levelup.gitconnected.com/oop-with-d-d-polymorphism-b1974435063b?source=collection_archive---------6-----------------------#2021-04-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="09ea" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用D&amp;D理解OOP的四个支柱，第三部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fec5835f3157584d64334d5d2bb200a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*koUn1NTGIuEaT3sG-0iuaA.jpeg"/></div></div></figure><p id="a6e0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上周，我们讨论了抽象，这是一种开发人员只提供使用各种类及其方法所需的细节，而不将它们暴露给底层代码的能力。这为你的源代码提供了保护，同时也节省了用户的时间，因为当他们想要使用你的方法、类、包等的时候，他们不需要重新发明轮子。这是一个非常简单的概念！</p><p id="aff0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还讨论了抽象类，即至少有一个未定义方法的类。在Python中，首先需要从<code class="fe ln lo lp lq b">abc</code>包中导入<code class="fe ln lo lp lq b">ABC </code>(抽象基类的首字母缩写)和<code class="fe ln lo lp lq b">abstractmethod</code>。我们通过使我们的类成为<code class="fe ln lo lp lq b">ABC</code>类的伪子类来声明我们的类是抽象的。要创建一个抽象方法，首先用<code class="fe ln lo lp lq b">@abstractmethod</code>声明它，并命名你的方法，将<code class="fe ln lo lp lq b">self</code>作为参数传入。我们用<code class="fe ln lo lp lq b">pass</code>将方法留空，以便其他类可以设置自己的实现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/37f020a5a3cede3ebb46552d2a63c048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/0*W1V-L3sbdZ7F8HXN.png"/></div></figure><p id="a4c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">Sentient</code>类现在是一个抽象类。这意味着它不是可实例化的。这是因为抽象类不是用作对象的蓝图，而是用于其他类。此外，抽象类的任何子类也将是抽象的，直到它们为它们继承的所有抽象方法提供实现。因此，<code class="fe ln lo lp lq b">Monster</code> class也是一个抽象类，尽管它没有被声明为“抽象”。它通过继承变得抽象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/7bd606a71e807f2c0ea102d801020887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vKGm89Zy_RFNv8EIIheUkQ.png"/></div></div></figure><p id="788b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦提供了一个实现，这个类就变得具体和可实例化了，正如我们在<code class="fe ln lo lp lq b">DragonTurtle</code>类中看到的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/7f061ba30f40234fe6b299774c17bce9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/0*UlGFzpdrWnDKlNa7.png"/></div></figure><p id="0413" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">子类如何为一个方法(抽象的或不抽象的)提供实现的想法为今天的主题:多态性提供了一个很好的开端。</p><blockquote class="lu lv lw"><p id="be00" class="kr ks lx kt b ku kv jr kw kx ky ju kz ly lb lc ld lz lf lg lh ma lj lk ll lm ij bi translated">2021年4月12日更新:特别感谢<a class="ae mb" href="https://angelohulshout.medium.com/" rel="noopener">Angelo hul shour</a>花时间向我阐明多态性的定义。之前，我说错了，方法可以“共享相同的名称，但用于不同的目的。”这是<strong class="kt ir">很差的做法</strong>。毕竟，你不会想要两个叫做<code class="fe ln lo lp lq b">add()</code>的方法，并让其中一个打印一首歌的歌词！我冒昧地用Angelo提供的更合适的定义更新了这篇文章。</p></blockquote><h1 id="cd1e" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">什么是多态性？</h1><p id="d925" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">多态性真的很奇怪。在编程中，多态性是一种允许方法共享相同名称但具有不同实现的属性。正如这个词的定义(“多种形式”)所暗示的，多态性以不同的方式表现出来:动态和静态多态性。</p><h2 id="d62a" class="mz md iq bd me na nb dn mi nc nd dp mm la ne nf mo le ng nh mq li ni nj ms nk bi translated">动态多态性(Python中)</h2><p id="dd86" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">在Python中，动态多态通常是通过方法重写来实现的。这是指子类为从其父类继承的方法提供自己的实现。你可能记得我们上周用<code class="fe ln lo lp lq b">Animal</code>和<code class="fe ln lo lp lq b">Fox</code>类和<code class="fe ln lo lp lq b">speak()</code>方法做了这个。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/9126d0e39f4ee72c9cfe4a707f613374.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/0*WWSKpINoYR-cD0vl.png"/></div></figure><p id="8dc5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里，即使我们有两个共享方法的独立实现，程序也不会混淆使用哪个版本，因为实现与对象的类相关联。然而，正如我们在下面看到的，这种多态的好处并不仅仅局限于父子关系:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/4f0558e7ea13aae10ab5d0d948fdc9f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*0fRMMS0gUTn6I8XF7e2j7A.png"/></div></figure><blockquote class="lu lv lw"><p id="b9e3" class="kr ks lx kt b ku kv jr kw kx ky ju kz ly lb lc ld lz lf lg lh ma lj lk ll lm ij bi translated">注意:虽然这是动态多态的一个例子，但这是<strong class="kt ir"> <em class="iq">而不是</em> </strong> <em class="iq"> </em>方法覆盖。方法重写只能发生在具有父子层次结构的类之间。</p></blockquote><p id="f809" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里，我们已经剥离了类的层次关系，但是Python仍然不会对使用哪个版本感到困惑，因为方法还是与对象的类联系在一起。</p><h2 id="5268" class="mz md iq bd me na nb dn mi nc nd dp mm la ne nf mo le ng nh mq li ni nj ms nk bi translated">在D&amp;D</h2><p id="5cee" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">为此，让我们通过为<code class="fe ln lo lp lq b">calculate_hit_points</code>提供一个实现来使<code class="fe ln lo lp lq b">Monster</code>类具体化。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/b60f8f67f91ef95ae806c9b2ad42ec01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*xS1CpIBvNkiUNLm6Sq-eYQ.png"/></div></figure><p id="5c83" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的方法基于一个人形警卫，因为这是一个很好的基线。现在，我们将测试它是可实例化的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/85e9b60f9c49a9f1b3ce053c7fa207b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*i19-qhK35Fxl91zaaz95AQ.png"/></div></figure><p id="9a6a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好吧！该类现在是具体的，并且该方法正在按预期工作。现在，让我们再次创建<code class="fe ln lo lp lq b">DragonTurtle</code>类，并提供它自己的实现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/2ff1b022a687be4d04fac0033b300e02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*5hm11DyeQHHxBdL2WKxKHQ.jpeg"/></div></figure><p id="b0e5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，<code class="fe ln lo lp lq b">DragonTurtle</code>类的实现覆盖了<code class="fe ln lo lp lq b">Monster</code>类。这允许更大的灵活性和更具体的实现。</p><h2 id="787b" class="mz md iq bd me na nb dn mi nc nd dp mm la ne nf mo le ng nh mq li ni nj ms nk bi translated">为什么这很重要？</h2><p id="0fe8" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">首先，你不需要为每一个方法取一个唯一的名字。您也不必使用长而复杂的名称来区分这些方法。当你考虑到程序员经常有类似的想法时，这是非常重要的。如果两个程序员做了一个叫<code class="fe ln lo lp lq b">mean()</code>的方法会怎么样。它们唯一不同的地方是，只在数组上运行，而另一个在Pandas系列上运行。你以完全相同的方式调用这些方法。如果没有多态，你会得到一个错误，因为程序员碰巧用相同的名字命名了他们的函数，尽管它们的操作不同。然而，由于多态性，我们不必担心这一点。</p><h2 id="633f" class="mz md iq bd me na nb dn mi nc nd dp mm la ne nf mo le ng nh mq li ni nj ms nk bi translated">动态多态性(其他语言)</h2><p id="722f" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">一般认为，动态多态是指将一个<em class="lx">子</em>对象赋给一个<em class="lx">父</em>类型的引用变量，但表现出子类方法的行为。本质上，对象看起来像父类，但是当你调用它的一个方法时，它的行为就像子类。如果你把一个父对象赋给一个子类型的引用变量，而结果正好相反:它看起来像子类，行为像父类。同样的事情在Python中也可以实现，但是看起来有点不一样。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/40d33de0d0f3a97ec016066775d32ae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*JhcR4y2LePNA2b-NLRF3jg.png"/></div></figure><p id="9618" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这种情况下，对象看起来像一个<code class="fe ln lo lp lq b">Animal</code>，但行为像一个<code class="fe ln lo lp lq b">Fox</code>。我们实现这个的方式基本上是通过覆盖对象的<code class="fe ln lo lp lq b">speak</code>方法，这样它就调用了<code class="fe ln lo lp lq b">fox</code>类的实现。这不同于像Java这样的语言，在Java中，你将引用变量声明为一个<code class="fe ln lo lp lq b">Animal</code>类型，并将它赋给一个<code class="fe ln lo lp lq b">Fox</code>对象。Python之所以不同，是因为所有变量都是动态的；它们不像在Java中那样被赋予“类型”。</p><p id="6c05" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这可能比它需要的更令人困惑。请记住，动态多态性允许您将一个方法的实现更改为另一个类的实现，以便进一步定制。</p><h2 id="cc44" class="mz md iq bd me na nb dn mi nc nd dp mm la ne nf mo le ng nh mq li ni nj ms nk bi translated">静态多态性</h2><p id="c408" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">静态多态允许一个类有多个同名的方法，只要它们采用不同的参数。这被称为方法重载。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/da9a69b5b4a2c3a59d21802feebd3526.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*mRb2B185vzYhnxSqKsSRCw.png"/></div></figure><p id="32c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，我们提供了两个名为<code class="fe ln lo lp lq b">add</code>的方法，它们接受不同的参数。一个显式地接受整数。另一个隐式接受浮点(由<code class="fe ln lo lp lq b">round</code>函数隐含)。尽管有相同的名称，Python并不会混淆使用哪种方法，因为参数接受的数据类型不同。当传递浮点数时，Python知道执行第二个方法。如果参数是整数，那么它执行第一个定义的方法。</p><h2 id="7b3e" class="mz md iq bd me na nb dn mi nc nd dp mm la ne nf mo le ng nh mq li ni nj ms nk bi translated">为什么这很重要？</h2><p id="7a1b" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">这使得用户体验更加流畅。想象一下，如果必须根据所引用的对象或变量的数据类型来不同地调用<code class="fe ln lo lp lq b">print</code>函数，那该有多烦人。必须指定<code class="fe ln lo lp lq b">print_string</code>、<code class="fe ln lo lp lq b">print_int</code>、<code class="fe ln lo lp lq b">print_float</code>、<code class="fe ln lo lp lq b">print_list</code>等。每次都会变得很老，很快！</p><h1 id="dcf3" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">摘要</h1><p id="bd9f" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">多态有很多好处。为了更好的用户体验和跨不同类的标准化接口，可以重用方法名。您还可以控制对更加定制的实现应用什么方法。</p><p id="dce5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下周:封装！</p></div></div>    
</body>
</html>