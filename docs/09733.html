<html>
<head>
<title>Java Algorithms: Reverse Words in a String Revisited (LeetCode)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java算法:重新访问字符串中的反向单词(LeetCode)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/java-algorithms-reverse-words-in-a-string-revisited-leetcode-7659dd83635b?source=collection_archive---------24-----------------------#2021-09-07">https://levelup.gitconnected.com/java-algorithms-reverse-words-in-a-string-revisited-leetcode-7659dd83635b?source=collection_archive---------24-----------------------#2021-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1371" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我对这个LeetCode问题的看法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/395e50ff81b0510dcd4c09a535b77906.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G7rFQfzQ5OND5N-z"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Riccardo Annandale 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="c156" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最近偶然发现了一篇由<a class="ls lt ep" href="https://medium.com/u/2e81cf0e57a1?source=post_page-----7659dd83635b--------------------------------" rel="noopener" target="_blank"> Ruslan Rakhmedov </a>撰写的<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/java-algorithms-reverse-words-in-string-leetcode-b6d180252e28"> Medium文章，讲述了如何用Java解决</a><a class="ae kv" href="https://leetcode.com/problems/reverse-words-in-a-string" rel="noopener ugc nofollow" target="_blank"> LeetCode问题151 </a>:给定一个由一个或多个空格分隔的单词串，返回一个由单个空格分隔的逆序新单词串。原始字符串可能有也可能没有前导空格和尾随空格，但它保证至少包含一个单词。</p><p id="06ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">鲁斯兰的解决方案非常好:它完成了工作，足够快，而且容易理解。老实说，我更愿意看到他的代码投入生产，而不是我的…除非我们的目标是最高的性能，这正是LeetCode竞赛的情况！</p><h1 id="6cfd" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">溶液分析</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Ruslan Rakhmedov的原创解决方案</figcaption></figure><p id="3b0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Ruslan的解决方案依赖于<code class="fe mo mp mq mr b">String.split()</code>方法将原始字符串分解成单词。该方法接受匹配分隔符的正则表达式，但是它有一个优化的快速路径实现，因为正则表达式实际上是一个字符，所以在这种情况下不进行模式匹配。</p><p id="44f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mo mp mq mr b">String.split()</code>内部分配一个<code class="fe mo mp mq mr b">ArrayList</code>来存储中间结果。<code class="fe mo mp mq mr b">ArrayList</code>的默认容量是十个元素，当我们的字符串包含十个以上的单词时，这将导致额外的分配和复制。该方法返回一个字符串数组，因此<code class="fe mo mp mq mr b">ArrayList.toArray()</code>被调用，这又需要一次分配和复制。当然，结果数组的每个元素都是一个<code class="fe mo mp mq mr b">String</code>，它必须被分配并填充来自原始字符串的数据(即另一个副本)。</p><p id="e6e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于Java字符串是不可变的，Ruslan使用<code class="fe mo mp mq mr b">StringBuilder</code>来构建结果字符串。它分配一个默认大小为16个字符的数组，这意味着对更长的字符串进行额外的分配和复制操作。最后，<code class="fe mo mp mq mr b">StringBuilder.toString</code>必须再分配和填充一个<code class="fe mo mp mq mr b">String</code>对象。</p><p id="0557" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管Java非常快，但这段代码还是给我们留下了一些改进的空间。那么，我们能做得更好吗？</p><h1 id="28c9" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">改进的解决方案</h1><p id="e5de" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">事实上，我们可以。避免<code class="fe mo mp mq mr b">String.split()</code>和<code class="fe mo mp mq mr b">StringBuilder</code>并由我们自己实现所有需要的代码允许我们大幅减少分配和数据复制操作的数量。想法很简单:以逆序遍历原始字符串，找到单词边界，跳过空白序列。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">作者优化的实现</figcaption></figure><p id="4fcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们用原始字符串的大小分配一个<code class="fe mo mp mq mr b">destination</code>字符数组。这可能比我们实际需要的内存更多，但是在最坏的情况下，当原始字符串是由一个空格分隔的单词序列，没有前导或尾随空格时，它仅够存储结果。<code class="fe mo mp mq mr b">destinationIndex</code>保存<code class="fe mo mp mq mr b">destination</code>数组中的下一个写位置。</p><p id="3c09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原始字符串<code class="fe mo mp mq mr b">s</code>被视为一系列字符。变量<code class="fe mo mp mq mr b">beforeWordStartIndex</code>和<code class="fe mo mp mq mr b">wordEndIndex</code>跟踪字边界，辅助函数<code class="fe mo mp mq mr b">consumeWhitespace</code>和<code class="fe mo mp mq mr b">consumeWord</code>用于以逆序遍历字符串并更新变量。对于在原始字符串中找到的每个单词，使用<code class="fe mo mp mq mr b">copyChars</code>方法将相应的字符复制到<code class="fe mo mp mq mr b">destination</code>数组中。另外，<code class="fe mo mp mq mr b">writeWhitespace</code>方法用于向结果字符串发出一个空格分隔符。</p><p id="7185" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们利用专门的<code class="fe mo mp mq mr b">String(char value[], int offset, int count)</code>构造函数从char数组创建一个字符串，这需要一次分配和一次复制操作。</p><h1 id="f6dc" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">复杂性和LeetCode结果</h1><p id="1567" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">这种解决方案在时间和空间需求上都是线性的。</p><p id="a7d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假定<code class="fe mo mp mq mr b">n</code>是原始字符串的长度，我们分配<code class="fe mo mp mq mr b">n</code> chars数组作为我们的工作缓冲区。结果字符串的长度也不超过<code class="fe mo mp mq mr b">n</code>个字符。这样分配的总内存大小不超过<code class="fe mo mp mq mr b">2n</code>个字符，也就是O(n)。</p><p id="b6ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们遍历字符串两次:查找字边界和将数据复制到工作缓冲区。在<code class="fe mo mp mq mr b">String</code>构造函数中还隐藏了另一个复制操作。所以我们的解决方案只需要<code class="fe mo mp mq mr b">3n</code>个操作，也就是O(n)。</p><p id="6ecf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将解决方案提交给LeetCode给出的最高运行时间为1 ms，我相信这是LeetCode时间分辨率的极限。内存消耗主要由JVM的使用决定，似乎与代码无关。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/f6167fcecc62e4b6b6afbfd84fd50119.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d2JbtnbAKpBcxz1C7mfAmA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">LeetCode提交结果</figcaption></figure></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="abb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管Ruslan Rakhmedov的原始解决方案看起来做了大量的分配和数据篡改，但Java可以非常快，并且分配非常便宜。在现实世界中，您可能不会注意到任何性能差异。Ruslan的代码易于阅读和遵循，这通常比达到顶级性能重要得多。</p><p id="fc7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">过早的优化是不好的。这不仅浪费时间，还会导致代码更加繁琐，更难维护。优化代码的唯一真正原因是遇到一个经过验证的性能瓶颈。或者在这种情况下，参加LeetCode比赛。</p><p id="05ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以增加代码复杂性为代价，我们能够将内存需求减少到<code class="fe mo mp mq mr b">2n</code>个字符，将时间需求减少到<code class="fe mo mp mq mr b">3n</code>个操作，这是LeetCode上最快的解决方案，给出了毫秒级的时间分辨率。</p></div></div>    
</body>
</html>