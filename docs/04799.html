<html>
<head>
<title>Trigger a pipeline using a webhook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用webhook触发管道</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/trigger-a-pipeline-using-webhook-586a664addd7?source=collection_archive---------3-----------------------#2020-07-16">https://levelup.gitconnected.com/trigger-a-pipeline-using-webhook-586a664addd7?source=collection_archive---------3-----------------------#2020-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="828e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您已经静态地呈现了您的web应用程序，并且想要在内容管理系统(CMS)中使用webhook进行任何发布/取消发布操作时触发您的构建管道。这不仅仅是使用webhook触发一个管道。在我们继续创建自动化工作流之前，我们将需要以下内容。</p><ul class=""><li id="e403" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">CMS(我们将使用Contentful)</li><li id="f008" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">无服务器功能(Azure Function Apps/Google Cloud Functions/AWS lambda)</li><li id="0db5" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">DevOps管道将被触发。</li><li id="05fb" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">CI tool REST API令牌安全地触发构建管道(我们将使用Azure DevOps的个人访问令牌)</li><li id="2633" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">代码库</li><li id="3369" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">队列存储(我们将使用Azure队列存储)</li><li id="6cca" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">目标服务器(应用服务/EC2等。查看发布的内容)</li></ul><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/09003754fda48aa82ed28b30b600ddeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BFuT1paGmwWJ-RkX2QMzdQ.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">0.1工作流程图</figcaption></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="65e2" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">1.创建功能应用程序</h1><ul class=""><li id="7539" class="kl km iq jp b jq mu ju mv jy mw kc mx kg my kk kq kr ks kt bi translated">转到Azure门户→自定义部署→加载GitHub快速启动模板或加载您自己的自定义模板和参数文件</li></ul><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi mz"><img src="../Images/9faa74db572582d4ad19e1b761e01630.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eYUYU7z3JILQJfMQDMMXBw.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">1.1功能App定制模板部署</figcaption></figure><ul class=""><li id="fd96" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">或者，我们可以从门户创建一个功能应用程序和一个存储帐户。</li><li id="27de" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">进入Azure门户→创建函数App→填写实例详情→根据需要选择运行时。我们将使用Node。Js作为运行时堆栈→下一步:托管</li></ul><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi na"><img src="../Images/f75914d631340b3499092f5a33178bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VKEMW4T15yOXmZ7NUsRrOA.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">1.2从门户创建功能应用</figcaption></figure><ul class=""><li id="e216" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">创建新的存储帐户/使用现有帐户→根据环境/使用情况选择消费/高级计划类型。此存储帐户将用于存储功能应用程序文件。这是因为Functions依赖Azure存储进行操作，比如管理触发器和记录函数执行。存储帐户需要有队列和文件存储服务。只有Blob存储帐户不能与Azure函数一起使用。</li></ul><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nb"><img src="../Images/2969e8d38c3110044370a98b2a0e3d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y5aJeUghTIk-EtoJ8GoBHA.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">1.3托管</figcaption></figure><ul class=""><li id="493b" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">转到监控→根据需要启用应用洞察→添加资源创建日期、TA、所有者等标签。→查看+创建</li></ul><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nc"><img src="../Images/d2c6400b1e60a190181610d3910b04d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KS31gz3D4QVXNa1foS_dkA.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">1.4监控</figcaption></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="1426" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">2.在函数应用程序中添加函数</h1><p id="4aff" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ij bi translated">我们将在Azure Repos Git中存储我们的函数应用程序代码，并使用Azure管道将我们的代码部署到创建的函数应用程序中。你可以直接在函数App编辑器里写你的代码(不推荐)。Azure Repos Git分支中的文件夹结构如下所示。对于不同的运行时堆栈，文件夹结构会有所不同。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ng"><img src="../Images/b055dcbf9a8755a7ab6eb8cd677fa62d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZurxAeoI0HkaNRiLfDkgyA.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">2.1 git分支中函数App的文件夹结构</figcaption></figure><ul class=""><li id="c278" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><strong class="jp ir"> package.json </strong>将包含依赖项和开发依赖项，如Axios模块或azure-storage-module。该文件还包含与项目相关的各种元数据，如版本、描述等。</li><li id="b069" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><strong class="jp ir"> index.js </strong>将包含我们的代码。</li><li id="c88e" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><strong class="jp ir"> host.json </strong>元数据文件包含影响一个函数app所有函数的全局配置选项。host.json中与绑定相关的配置同样适用于函数app中的每个函数。</li><li id="6b60" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">在<strong class="jp ir"> function.json </strong>中，您可以使用解析各种来源的值的表达式。大多数表达式都用花括号括起来。例如，在队列触发器函数中，{queueTrigger}解析为队列消息文本。如果blob输出绑定的path属性是container/{queueTrigger}，并且该函数由队列消息HelloWorld触发，则创建一个名为HelloWorld的blob。</li><li id="15af" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">找到下面的样本文件。</li></ul><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nh ni l"/></div></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nj"><img src="../Images/5ba6449d9d4f6a5a5524461b92ea17e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ohx-kVux_Gvl1WvRGnKwaQ.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">2.2功能逻辑</figcaption></figure><h1 id="57d5" class="lw lx iq bd ly lz nk mb mc md nl mf mg mh nm mj mk ml nn mn mo mp no mr ms mt bi translated">3.使用Azure DevOps管道部署功能应用程序代码</h1><p id="cc54" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ij bi translated">一旦您准备好了函数代码，就可以使用Azure DevOps CI/CD管道将它部署到Azure函数中。查看<a class="ae np" rel="noopener ugc nofollow" target="_blank" href="/configure-ci-cd-pipelines-for-nodejs-applications-with-azure-devops-44e7425f5a99">这篇关于如何部署节点的</a>文章。使用Azure DevOps管道的Js应用程序。除了<strong class="jp ir"> 2.6 </strong>我们必须选择<strong class="jp ir">功能App </strong>作为<strong class="jp ir"> App服务类型外，所有步骤都是相似的。</strong>将存储账户密钥和个人访问令牌等所有机密保存在Keyvault中，以便安全访问。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="9542" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">4.CMS webhook设置</h1><p id="88ac" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ij bi translated">当我们准备好函数应用程序时，让我们在contentful webhook设置页面中添加函数应用程序端点URL。</p><ul class=""><li id="7841" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">获取函数端点URL</li></ul><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nq"><img src="../Images/8881f5ed5ab0e199ef7a8c612adb53b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*goYK42C3MCI4MT1mELo3Mg.jpeg"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">4.1进入功能应用程序→功能</figcaption></figure><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nr"><img src="../Images/45d72b4d2764ed5edd17cf987d780ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uWYEO3khCyDL8U6sTsBRTg.jpeg"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">4.2概述→获取函数URL →复制URL</figcaption></figure><ul class=""><li id="8bbd" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">在Contentful中设置webhook设置。</li></ul><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ns"><img src="../Images/278b997469354daa28cc71a84d1876a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k6aak9hTc-5G1G1h81kZaw.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">4.3转到设置→Webhooks</figcaption></figure><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nt"><img src="../Images/12dfebcffb4f1bf771c177e4411de453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z4Lo1uyffVl4STpne2XK3Q.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">4.4添加Webhook</figcaption></figure><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nu"><img src="../Images/9a8f8fc5a8575aaafe7a6cb26f857833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JnFKgqLYbT9vbBaQ1DtrnQ.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">4.5插入复制的端点URL，并根据您的要求设置触发器</figcaption></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="212c" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">为什么我们需要队列存储？</h1><p id="479d" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ij bi translated"><strong class="jp ir">目标→ </strong>使用无服务器函数触发Azure DevOps管道(无服务器…但是<a class="ae np" href="https://www.linkedin.com/in/aniketprashar/" rel="noopener ugc nofollow" target="_blank">为什么</a>？🤔)<br/> <strong class="jp ir">解决方案</strong> →调用Azure DevOps REST API触发管道。每当CMS上有任何发布或取消发布操作时，webhook将启动一个函数应用实例，函数应用实例将触发DevOps管道。简单…不是吗？</p><p id="ce02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上述解决方案适用于POC，但它适用于真实项目吗？让我们试着找出它。</p><ol class=""><li id="f749" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk nv kr ks kt bi translated">开发团队想要在<em class="nw"> Contentful </em>上发布新内容。该任务涉及多个成员。开发者A在30分钟内发布了~150个内容，开发者B在20分钟内发布了100个内容(与A的时间重叠)。</li><li id="4191" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk nv kr ks kt bi translated">那么，在30分钟内我们能期待多少个webhook触发器呢？可能250！？<br/>别忘了在CMS webhook设置中取消勾选<strong class="jp ir">自动保存</strong>触发选项，除非只是一个‘POC’(<a class="ae np" href="https://www.linkedin.com/in/aniketprashar/" rel="noopener ugc nofollow" target="_blank">为什么</a>？🤔)</li></ol><blockquote class="nx ny nz"><p id="50b1" class="jn jo nw jp b jq jr js jt ju jv jw jx oa jz ka kb ob kd ke kf oc kh ki kj kk ij bi translated">测试:一个功能应用可以扩展到多少个实例。</p></blockquote><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi od"><img src="../Images/ba58654ce19dccf40ab854ddb00fa997.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5tapuEUSGdrkt6-ISHU4pw.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">2.3 Webhook触发器设置</figcaption></figure><p id="c0ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.因此，30分钟内将有250个webhook触发器，它将触发您的管道250次。如果这个数字增长到1000或者10000呢？这对您的Azure DevOps组织有好处吗？</p><blockquote class="nx ny nz"><p id="df4c" class="jn jo nw jp b jq jr js jt ju jv jw jx oa jz ka kb ob kd ke kf oc kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">小测验:</em> </strong> <em class="iq">您的Azure DevOps组织中有多少个代理池？</em></p></blockquote><p id="6296" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.即使您对这么多管道触发器感到满意，并且您的代理池足以处理您组织中的所有管道任务，这是最佳解决方案吗？难道不能用几个管道触发器来完成吗？</p><p id="6bed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.<strong class="jp ir">场景</strong>:有2辆公交车，N个学生。学生想从上车点P到下车点d。公共汽车司机不知道学生人数和他们的到达时间。司机A决定只要有学生到达，就开始公共汽车服务，因为他们不确定下一个学生是否会来。因此，在某一天，100名学生以1分钟的间隔来到接送点p。因此，公共汽车服务运行的次数是100次(不贵🤑司机B决定在任何学生出现后等待15分钟。因此，在某一天，100名学生以1分钟的间隔到达接送点p。</p><blockquote class="nx ny nz"><p id="5e09" class="jn jo nw jp b jq jr js jt ju jv jw jx oa jz ka kb ob kd ke kf oc kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">小测验:</em> </strong> <em class="iq">公交服务跑了几次？</em></p></blockquote><p id="ca35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你想怎么操作完全取决于你自己。我们还是选后者吧，这样文章可以长一点。</p><p id="eb08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi oe translated">假设，两个开发者正在发布内容。Dev A在12:00发布内容。它将触发函数app，并创建一个新的函数app实例。它将检查队列中是否已经有消息。它现在是空的，所以它会在队列中放一些消息，并等到12:15(可定制)才调用Azure DevOps REST API并清除队列。<br/>当该实例仍在运行时，Dev B在12:05发布了一个新内容，这将启动一个新的函数应用程序实例，该实例也将检查队列中是否有任何消息。很幸运，它找到了一条消息，因此，它不会等待15分钟，函数实例终止。在12:15，已经运行的实例将清除队列中的消息并触发管道。然后，管道将构建解决方案，变更A和B都将在新的构建中更新。所以，不用两个触发器，我们只用一个就能逃脱。即使15分钟内有200个webhook调用，仅一个管道触发器就足以发布所有最新的200个更改。唯一的代价是15分钟的短暂时间间隔，可以根据使用情况进行定制。</p><blockquote class="nx ny nz"><p id="b715" class="jn jo nw jp b jq jr js jt ju jv jw jx oa jz ka kb ob kd ke kf oc kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">小测验:</em> </strong> <em class="iq">一个函数实例能运行多久？</em></p></blockquote><p id="1041" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如果您需要任何帮助或有任何建议，请通过</strong> <a class="ae np" href="https://www.linkedin.com/in/aniketprashar" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> LinkedIn </strong> </a>联系我</p></div></div>    
</body>
</html>