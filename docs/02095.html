<html>
<head>
<title>Three Methods to Share Rails Assets With Nginx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与Nginx共享Rails资产的三种方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/three-methods-to-share-rails-assets-with-nginx-f39c90bb7d68?source=collection_archive---------6-----------------------#2020-02-18">https://levelup.gitconnected.com/three-methods-to-share-rails-assets-with-nginx-f39c90bb7d68?source=collection_archive---------6-----------------------#2020-02-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4087" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过使用反向代理(如Nginx)来服务资产，提高Rails应用程序的性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/911b9d624992d9996f88fc4e4d93caf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qlzCcdg3KjlMMVsa"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">伊莱恩·卡萨普在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1009" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">性能是每个web应用程序的关键问题。虽然应用程序的性能可以通过优化web应用程序本身的算法和过程来大幅提高，但也可以通过优化托管堆栈中的其他层来提高，如后期持久性或前端层。</p><p id="dcdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">影响web应用程序速度和性能的一个方面是实现的内容交付策略。举例来说，web应用程序内容可以分为两类:</p><ul class=""><li id="0a91" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">静态内容:该内容按原样提供，不需要应用程序进行任何处理。这种内容的例子有样式表、图像和javascript脚本。</li><li id="ccc0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">动态内容:在将响应发送给客户机之前，需要计算或处理这些内容。涉及查询数据库以收集数据并将其显示给最终用户的这种内容请求的例子。</li></ul><p id="e5b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于静态内容不需要由应用程序处理，所以它也可以由其他应用程序提供，例如反向代理应用程序。将静态内容服务从应用程序本身转移到反向代理的主要优点是</p><ul class=""><li id="f575" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">如果使用反向代理，提供静态内容会更快。首先，不需要向应用程序发送另一个请求，其次，反向代理在提供静态内容方面要快得多，并且提供了更多的技术来增强提供内容的性能，例如压缩内容。</li><li id="856e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">由于不是每个请求都会被转发到web应用程序，应用程序的负载将会减少，因此应用程序将能够处理更多的并发请求而不会崩溃。</li></ul><p id="cbb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将介绍三种方法，通过Nginx反向代理共享Docker容器中托管的Rails应用程序的静态内容。</p><h2 id="b910" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">第一种方法:在本地预编译资产</strong></h2><p id="9b58" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">这种方法背后的思想是在本地(在执行部署命令的主机上)预编译Rails应用程序的资产，然后将资产复制到Nginx和Rails应用程序的Docker映像中。使用这种方法部署应用程序将包括以下步骤</p><ul class=""><li id="48aa" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">查看该项目的源代码</li><li id="9379" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">预编译Rails应用程序。这一步将在<strong class="lb iu"> <em class="nh">公共</em> </strong>文件夹中生成资产文件。</li><li id="4a81" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">为Nginx和应用程序构建docker映像。</li><li id="4f5d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">执行应用程序的部署。</li></ul><p id="811b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码片段展示了docker-compose如何实现上述步骤。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="468e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以简单地通过克隆GitHub  repo后面的<a class="ae ky" href="https://github.com/wshihadeh/three_methods_to_share_assets" rel="noopener ugc nofollow" target="_blank">并执行下面的命令来测试上述方法。</a></p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="5b1a" class="mj mk it nl b gy np nq l nr ns">$&gt; git clone <a class="ae ky" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:wshihadeh/three_methods_to_share_assets.git<br/>$&gt; cd precompile_on_the_host<br/>$&gt; make config # to do the local Precompile<br/>$&gt; make deploy # to depoy the services<br/>$&gt; make stop # to stop the services</span></pre><p id="887f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还需要将下面一行添加到您的<code class="fe nt nu nv nl b">/etc/hosts</code>文件中，以便能够在<code class="fe nt nu nv nl b">http://blog.local.me</code>访问站点。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="21bb" class="mj mk it nl b gy np nq l nr ns">127.0.0.1 blog.local.me</span></pre><h2 id="5570" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">第二种方法:在运行时预编译资产</strong></h2><p id="b668" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">这种方法会将Rails应用程序的资产预编译延迟到应用程序的运行时。以下几点总结了实施该方法所需的步骤</p><ul class=""><li id="1369" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">更新Rails应用程序的docket入口点，以便在启动Rails服务器之前预编译资产。</li><li id="1d89" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">构建Docker图像。</li><li id="a42c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将Rails应用程序和Nginx配置为对静态资产使用相同的卷。</li><li id="35ee" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">部署服务。</li></ul><p id="0af4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码片段展示了如何使用docker-compose实现上述步骤。一旦应用程序容器启动，它将生成资产并将它们存储在资产卷中，由于Rails应用程序和Nginx都可以访问同一个卷，因此Nginx将可以访问资产并为它们提供服务。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e5c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以简单地通过克隆GitHub  repo后面的<a class="ae ky" href="https://github.com/wshihadeh/three_methods_to_share_assets" rel="noopener ugc nofollow" target="_blank">并执行下面的命令来测试上述方法。</a></p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="7104" class="mj mk it nl b gy np nq l nr ns">$&gt; git clone <a class="ae ky" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:wshihadeh/three_methods_to_share_assets.git<br/>$&gt; cd precompile_at_runtime<br/>$&gt; make deploy # to depoy the services<br/>$&gt; make stop # to stop the services</span></pre><p id="270d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还需要将下面一行添加到您的<code class="fe nt nu nv nl b">/etc/hosts</code>文件中，以便能够在<code class="fe nt nu nv nl b"><a class="ae ky" href="http://blog.local.me." rel="noopener ugc nofollow" target="_blank">http://blog.local.me</a></code> <a class="ae ky" href="http://blog.local.me." rel="noopener ugc nofollow" target="_blank">上访问站点。</a></p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="a898" class="mj mk it nl b gy np nq l nr ns">127.0.0.1 blog.local.me</span></pre><h2 id="9d54" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">第三种方法:在构建映像时预编译资产</strong></h2><p id="a930" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">该方法将在docker构建阶段执行预编译过程，作为在docker文件中为Rails应用程序定义的步骤之一，而不是在主机上或在运行时在docker容器内预编译资产。下面是实现该方法所需的步骤</p><ul class=""><li id="c15e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">安装ruby gems后，更新Rails应用程序Dockerfile以预编译资产。</li><li id="9062" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将Nginx Docker文件更新为多级Docker文件，从Rails应用程序Docker映像复制资产文件。</li><li id="17f7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">部署服务。</li></ul><p id="c6fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码片段展示了Nginx和Rails应用程序docker图像的一个例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="43d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以简单地通过克隆GitHub  repo后面的<a class="ae ky" href="https://github.com/wshihadeh/three_methods_to_share_assets" rel="noopener ugc nofollow" target="_blank">并执行下面的命令来测试上述方法。</a></p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="fa6c" class="mj mk it nl b gy np nq l nr ns">$&gt; git clone <a class="ae ky" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:wshihadeh/three_methods_to_share_assets.git<br/>$&gt; cd precompile_during_docker_build<br/>$&gt; make deploy # to depoy the services<br/>$&gt; make stop # to stop the services</span></pre><p id="7232" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还需要在<code class="fe nt nu nv nl b">/etc/hosts</code>文件中添加以下一行，以便能够访问<code class="fe nt nu nv nl b"><a class="ae ky" href="http://blog.local.me." rel="noopener ugc nofollow" target="_blank">http://blog.local.me</a></code> <a class="ae ky" href="http://blog.local.me." rel="noopener ugc nofollow" target="_blank">上的网站。</a></p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="63c1" class="mj mk it nl b gy np nq l nr ns">127.0.0.1 blog.local.me</span></pre><p id="8182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">最终想法&amp;其他方案</strong></p><p id="5f25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上三种方法描述了如何与逆向共享Rails应用程序资产，以及如何配置Nginx来服务这些资产。然而，这并不是唯一一个可以提高资产服务绩效的想法。您可以考虑的其他方案简述如下</p><ul class=""><li id="3b14" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用rails应用程序服务资产，并配置Nginx缓存来自Rails应用程序的资产。</li></ul><div class="nw nx gp gr ny nz"><a href="https://medium.com/@wshihadeh/cache-and-serve-rails-static-assets-with-nginx-reverse-proxy-dfcd49319547" rel="noopener follow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">使用Nginx反向代理缓存和服务Rails静态资产</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">通过服务和缓存web请求静态内容，提高Rails web应用程序的性能和速度</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">medium.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ks nz"/></div></div></a></div><ul class=""><li id="05a3" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Content_delivery_network" rel="noopener ugc nofollow" target="_blank">内容交付网络</a>来服务Rails应用程序的资产。关于CDN的更多信息可以在<a class="ae ky" href="https://guides.rubyonrails.org/asset_pipeline.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</li></ul><h2 id="9632" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">结论</strong></h2><p id="d0b8" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">使用反向代理服务资产或静态内容可以提高web应用程序的性能，因为这将减少后端应用程序的负载，并且可以更快地服务静态内容。另一方面，还有其他有助于提高静态资产服务性能的方案，如使用cdn。</p></div></div>    
</body>
</html>