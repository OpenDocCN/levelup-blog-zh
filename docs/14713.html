<html>
<head>
<title>How To Write Tests For Node Express Routes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为节点快速路由编写测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-write-tests-for-node-express-routes-with-auth-example-dd0b7e817b76?source=collection_archive---------17-----------------------#2022-12-19">https://levelup.gitconnected.com/how-to-write-tests-for-node-express-routes-with-auth-example-dd0b7e817b76?source=collection_archive---------17-----------------------#2022-12-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8369" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Jest plus Typescript编写综合单元测试的指南，并附有验证示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1edd06e9b38a9c64a0bf98ae2ed77ff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*h6GBJeXVJ7yiochv.jpg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://www.headspin.io/blog/the-testing-pyramid-simplified-for-one-and-all" rel="noopener ugc nofollow" target="_blank">大头针</a>的图像</figcaption></figure><p id="fd8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单元测试是测试期的底部是有充分理由的。这是保证应用程序大部分功能的基本测试形式。其背后的概念是，如果我们能够确保每个功能/路线/组件都按照预期运行，那么系统作为一个整体应该能够正常工作。</p><p id="2d81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，这不是故事的全部，这就是为什么我们有集成和端到端测试。然而，为每个功能的每个流程创建端到端的测试场景是不现实的。</p><p id="ad31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将讨论单元测试的重要性，并提供为快速路由处理程序编写单元测试的最佳实践。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="438c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">单元测试的原因</h1><ul class=""><li id="65cf" class="mu mv it lb b lc mw lf mx li my lm mz lq na lu nb nc nd ne bi translated"><strong class="lb iu">开发速度</strong>:单元测试非常容易编写，因此开发人员可以在添加测试的同时快速开发新的功能。</li><li id="7451" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu">测试速度</strong>:单元测试运行起来比端到端测试快得多，因此编写大量的单元测试是可行的，因为它们可以在每一次拉请求变更时运行，而不会显著增加迭代时间。</li><li id="eea8" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu">容易保证高覆盖率</strong>:单元测试是单独测试每个功能，因此可以测试每个功能的每个可能的流程。通过将每个功能作为一个独立的单元来完成，获得高覆盖率就变成了一个简单的过程。</li><li id="0826" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu">提高代码的可重用性:</strong>单元测试的功能是可信的，因此可以很容易地重用，而不用担心引入错误。</li><li id="b881" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu">可以作为文档</strong>:单元测试在很多方面作为文档:它们显示输入和输出的例子，并为不同的流程设置期望。在阅读了一个函数的单元测试之后，你应该能够更好地理解它。</li></ul><h1 id="a3cf" class="mc md it bd me mf nk mh mi mj nl ml mm jz nm ka mo kc nn kd mq kf no kg ms mt bi translated">安装依赖项</h1><p id="6033" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">首先，您需要安装以下开发依赖项:</p><ul class=""><li id="81ff" class="mu mv it lb b lc ld lf lg li ns lm nt lq nu lu nb nc nd ne bi translated">超级测试</li><li id="d192" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">玩笑</li><li id="4ddd" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">ts-jest</li><li id="49a6" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">@types/supertest(如果使用typescript)</li><li id="a1af" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">@types/jest(如果您使用的是typescript)</li></ul><p id="1866" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的命令是:</p><p id="3b47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nv"> npm安装—保存-开发super test jest ts-jest @ types/jest @ types/super test</em></p><h1 id="cd27" class="mc md it bd me mf nk mh mi mj nl ml mm jz nm ka mo kc nn kd mq kf no kg ms mt bi translated">设置Package.json</h1><p id="5056" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在安装了前面提到的依赖项之后，是时候配置jest并编写脚本来运行测试了。您的package.json应该如下所示:</p><pre class="kj kk kl km gt nw nx ny bn nz oa bi"><span id="9b10" class="ob md it nx b be oc od l oe of">{<br/>...<br/>  "scripts": {<br/>    "start": "ts-node-dev src/index.ts",<br/>    "test": "jest --watchAll --no-cache"<br/>  },<br/>  "jest": {<br/>    "preset": "ts-jest",<br/>    "testEnvironment": "node",<br/>    "setupFilesAfterEnv": [<br/>      "./src/test/setup.ts"<br/>    ]<br/>  },<br/>...<br/>  },<br/>  "devDependencies": {<br/>    "@types/jest": "^29.2.3",<br/>    "@types/supertest": "^2.0.12",<br/>    "jest": "^29.3.1",<br/>    "supertest": "^6.3.1",<br/>    "ts-jest": "^29.0.3"<br/>  }<br/>}</span></pre><p id="36ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们打开这个。测试脚本实际上运行jest，并带有监视文件更改的选项，以便在更改后重新运行测试(这就是— watchAll标志的作用)。我们还标记了no-cache选项，以确保jest不使用缓存，缓存是错误测试的常见来源。</p><p id="7602" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">jest配置实质上是将jest配置为使用ts-jest，将测试环境指定为节点环境，最后指定安装测试文件的位置。</p><p id="ed85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们随相应版本一起安装的开发依赖项。完全有可能你有和我不同的依赖版本，但是除非在即将到来的版本中有重大改变，否则本教程仍然适用。</p><h1 id="e070" class="mc md it bd me mf nk mh mi mj nl ml mm jz nm ka mo kc nn kd mq kf no kg ms mt bi translated">测试设置文件</h1><p id="68cb" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">您应该在package.json中为setupFilesAfterEnv指定的路径下创建一个名为setup.ts的文件。这个文件将包含我们想要在所有测试文件中运行的任何逻辑。</p><h2 id="d7c5" class="og md it bd me oh oi dn mi oj ok dp mm li ol om mo lm on oo mq lq op oq ms or bi translated"><strong class="ak">使用数据库进行测试</strong></h2><p id="00e4" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">例如，在我正在做的一个项目中，我们使用MongoDB作为我们的数据库，我们需要使用一个内存中的MongoDB来进行使用mongo-memory-server的测试。在开始任何测试之前，需要建立到mongo内存服务器的连接，因此我们将该逻辑合并到一个<em class="nv"> beforeAll </em>块中:</p><pre class="kj kk kl km gt nw nx ny bn nz oa bi"><span id="f9e9" class="ob md it nx b be oc od l oe of">let mongo: any;<br/>beforeAll(async () =&gt; {<br/>  mongo = await MongoMemoryServer.create();<br/>  const mongoUri = mongo.getUri();<br/>  await mongoose.connect(mongoUri, {});<br/>});</span></pre><p id="87fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在每次测试之后，我们希望清除mongo内存服务器中任何可能由测试存储的内容。我们在每个模块之前的<em class="nv">中执行此操作:</em></p><pre class="kj kk kl km gt nw nx ny bn nz oa bi"><span id="0a60" class="ob md it nx b be oc od l oe of">beforeEach(async () =&gt; {<br/>  const collections = await mongoose.connection.db.collections();<br/>  for (let collection of collections) {<br/>    await collection.deleteMany({});<br/>  }<br/>});</span></pre><p id="741e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们在一个<em class="nv"> afterAll </em>块中完成所有测试后，停止与mongo内存服务器的连接:</p><pre class="kj kk kl km gt nw nx ny bn nz oa bi"><span id="ed6e" class="ob md it nx b be oc od l oe of">afterAll(async () =&gt; {<br/>  if (mongo) {<br/>    await mongo.stop();<br/>  }<br/>  await mongoose.connection.close();<br/>});</span></pre><h2 id="e848" class="og md it bd me oh oi dn mi oj ok dp mm li ol om mo lm on oo mq lq op oq ms or bi translated"><strong class="ak">为测试定义环境变量</strong></h2><p id="cde5" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">安装文件是存放测试期间可能需要访问的任何环境变量的好地方。例如，如果您使用JWT测试授权，您可能需要在安装文件的<em class="nv"> beforeAll </em>块中模仿JWT密钥:</p><pre class="kj kk kl km gt nw nx ny bn nz oa bi"><span id="e3df" class="ob md it nx b be oc od l oe of">beforeAll(async () =&gt; {<br/>  process.env.jwt = "mock-jwt-key";<br/>});</span></pre><h2 id="947a" class="og md it bd me oh oi dn mi oj ok dp mm li ol om mo lm on oo mq lq op oq ms or bi translated"><strong class="ak">创建全局测试功能</strong></h2><p id="f2a8" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">如果您知道在大多数测试中会用到某些函数，那么您有几个选择。您可以定义一个全局函数，这样您就可以在测试中使用它，而不需要导入它，这非常方便。或者您可以将其导出，然后导入到您需要使用的文件中。出于本教程的目的，我将向您展示如何声明一个全局函数:</p><pre class="kj kk kl km gt nw nx ny bn nz oa bi"><span id="8e0f" class="ob md it nx b be oc od l oe of">declare global {<br/>  var functionIUseAlot: () =&gt; string;<br/>}<br/><br/>global.functionIUseAlot = () =&gt; {<br/>  // whatever reusable logic you need to apply<br/>  return "done";<br/>};</span></pre><h1 id="6f42" class="mc md it bd me mf nk mh mi mj nl ml mm jz nm ka mo kc nn kd mq kf no kg ms mt bi translated">测试路线</h1><p id="2f30" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">所有的设置完成后，我们可以开始测试我们的路线。为此，我建议您在routes文件夹下创建一个名为__tests__的文件夹，它将存放您的路由的所有单元测试。文件夹名__tests__是jest用来标识测试位置的关键字。在该文件夹中，您将为想要测试的每条路由创建一个文件，格式为routeName.test.ts。</p><p id="2dc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有测试中的一个共同点是，除了supertest的请求函数之外，我们还将导入express应用程序，该函数将位于每个测试文件的顶部，如下所示:</p><pre class="kj kk kl km gt nw nx ny bn nz oa bi"><span id="b242" class="ob md it nx b be oc od l oe of">import request from "supertest";<br/>import { app } from "../../app";</span></pre><h2 id="8d1e" class="og md it bd me oh oi dn mi oj ok dp mm li ol om mo lm on oo mq lq op oq ms or bi translated">发送测试请求</h2><p id="df56" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们向应用程序发送测试请求的方式是使用从supertest导入的请求函数。它看起来会像这样:</p><pre class="kj kk kl km gt nw nx ny bn nz oa bi"><span id="850e" class="ob md it nx b be oc od l oe of">it("test that just sends a post request", async () =&gt; {<br/>  await request(app)<br/>    .post("/route/we/want/to/test")<br/>    .send({item: "some content"});<br/>});<br/><br/>it("test that just sends a get request", async () =&gt; {<br/>  await request(app)<br/>    .get("/route/we/want/to/test")<br/>    .send();<br/>});</span></pre><p id="9b3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码块显示了如何发送post和get请求。它们不是功能测试，因为它们不期待任何东西。</p><h2 id="398c" class="og md it bd me oh oi dn mi oj ok dp mm li ol om mo lm on oo mq lq op oq ms or bi translated">期望状态代码</h2><p id="3c9d" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们可以测试路由的最基本的东西是它返回的状态代码。在上一节的基础上，让我们实现一些期望:</p><pre class="kj kk kl km gt nw nx ny bn nz oa bi"><span id="7ca3" class="ob md it nx b be oc od l oe of">it("fails when not providing user age", async () =&gt; {<br/>  await request(app)<br/>    .post("/auth/signup")<br/>    .send({name: "Ben Campbell", <br/>           email: "bencampbell@hotmail.com",<br/>           password: "super-secure-password"})<br/>    .expect(400); // bad request<br/>});<br/><br/>it("succeeds when provided valid information", async () =&gt; {<br/>  await request(app)<br/>    .post("/auth/signup")<br/>    .send({name: "Ben Campbell", <br/>           email: "bencampbell@hotmail.com",<br/>           password: "super-secure-password",<br/>           age: 42})<br/>    .expect(201); // success - user created<br/>});</span></pre><p id="8110" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们测试了两种情况:用户尝试注册失败和成功。这是一个非常简单的例子，但是想象一下，在同样的场景中，我们也希望在用户注册后设置一个cookie。这是我们需要测试的一个非常常见的场景。</p><h2 id="3159" class="og md it bd me oh oi dn mi oj ok dp mm li ol om mo lm on oo mq lq op oq ms or bi translated">测试Cookies</h2><p id="4097" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">解决方案实际上非常简单，我们需要做的就是确保定义了响应集Cookie头。我们实际上并不关心它里面有什么，对于auth的大部分，我们将使用JWT和cookie管理器，所以这不是我们要测试的功能。</p><pre class="kj kk kl km gt nw nx ny bn nz oa bi"><span id="0229" class="ob md it nx b be oc od l oe of">it("successful signup leads to cookie being set in response", async () =&gt; {<br/>  const response = await request(app)<br/>    .post("/auth/signup")<br/>    .send({name: "Ben Campbell", <br/>           email: "bencampbell@hotmail.com",<br/>           password: "super-secure-password",<br/>           age: 42})<br/>    .expect(201); // success - user created<br/><br/>  expect(response.get("Set-Cookie")).toBeDefined();<br/>});</span></pre><p id="52be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们将post请求的结果分配给response。然后我们检查Set-Cookie头是否在响应中定义，这意味着我们的代码运行正确，并且将向用户返回一个Cookie。</p><p id="116a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们需要一个cookie来传递请求的情况呢？例如，在检查用户信息时，我们需要一个带有JWT令牌的cookie。下面的代码块处理这种情况:</p><pre class="kj kk kl km gt nw nx ny bn nz oa bi"><span id="579b" class="ob md it nx b be oc od l oe of">it("returns the current users age", async () =&gt; {<br/>  const signUpResponse = await request(app)<br/>    .post("/auth/signup")<br/>    .send({name: "Ben Campbell", <br/>           email: "bencampbell@hotmail.com",<br/>           password: "super-secure-password",<br/>           age: 42})<br/>    .expect(201);<br/>  <br/>  const cookie = signUpResponse.get('Set-Cookie');<br/><br/>  const response = await request(app)<br/>    .get("/auth/userage")<br/>    .set("Cookie", cookie)<br/>    .send()<br/>    .expect(200);<br/><br/>  expect(response.body.user.age).toEqual(42);<br/>});</span></pre><p id="42bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码块中，我们再次注册用户，以便检索我们需要提供给后续请求的cookie，从而测试获取用户年龄的功能。然后，我们检查响应的正文，看它是否包含正确的年龄。</p><p id="6803" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我为你提供了一些用jest对你的路线进行单元测试的基本测试策略。我希望您发现这很有用，如果您考虑跟随我！我经常写这样的技术内容。</p></div></div>    
</body>
</html>